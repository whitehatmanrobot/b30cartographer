
0x3cd5248e, 0x14f9, 0x11d1, 0xae, 0x9c, 0x0, 0xc0, 0x4f, 0xb6, 0x88, 0x20);

#define EVENTCLASS  L"MyEvent"


class CMyEventProvider : public IWbemEventProvider, public IWbemProviderInit
{
    ULONG               m_cRef;
    IWbemServices       *m_pNs;
    IWbemObjectSink     *m_pSink;
    IWbemClassObject    *m_pEventClassDef;
    int                 m_eStatus;
    HANDLE              m_hThread;
            
    static DWORD WINAPI EventThread(LPVOID pArg);
    void InstanceThread();

public:
    enum { Pending, Running, PendingStop, Stopped };

    CMyEventProvider();
   ~CMyEventProvider();

    //
    // IUnknown members
    //
    STDMETHODIMP         QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // Inherited from IWbemEventProvider
    // =================================

    HRESULT STDMETHODCALLTYPE ProvideEvents( 
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink,
            /* [in] */ long lFlags
            );

    // Inherited from IWbemProviderInit
    // ================================

    HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ LPWSTR pszUser,
            /* [in] */ LONG lFlags,
            /* [in] */ LPWSTR pszNamespace,
            /* [in] */ LPWSTR pszLocale,
            /* [in] */ IWbemServices __RPC_FAR *pNamespace,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemProviderInitSink __RPC_FAR *pInitSink
            );
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\eventprovider\evprov.cpp ===
// **************************************************************************

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// File:  EVPROV.cpp
//
// Description:
//    Sample event provider.
//
// History:
//
// **************************************************************************

#include <windows.h>
#include <stdio.h>

#include <wbemidl.h>

#include "oahelp.inl"
#include "evprov.h"


//***************************************************************************
//
//***************************************************************************
// ok

CMyEventProvider::CMyEventProvider()
{
    m_pNs = 0;
    m_pSink = 0;
    m_cRef = 0;
    m_pEventClassDef = 0;
    m_eStatus = Pending;
    m_hThread = 0;
}


//***************************************************************************
//
//***************************************************************************
// ok

CMyEventProvider::~CMyEventProvider()
{
    if (m_hThread)
        CloseHandle(m_hThread);

    if (m_pNs)
        m_pNs->Release();

    if (m_pSink)
        m_pSink->Release();

    if (m_pEventClassDef)
        m_pEventClassDef->Release();        
}


//***************************************************************************
//
//***************************************************************************
// ok

STDMETHODIMP CMyEventProvider::QueryInterface(REFIID riid, LPVOID * ppv)
{
    *ppv = 0;

    if (IID_IUnknown==riid || IID_IWbemEventProvider==riid)
    {
        *ppv = (IWbemEventProvider *) this;
        AddRef();
        return NOERROR;
    }

    if (IID_IWbemProviderInit==riid)
    {
        *ppv = (IWbemProviderInit *) this;
        AddRef();
        return NOERROR;
    }

    return E_NOINTERFACE;
}



//***************************************************************************
//
//***************************************************************************
// ok

ULONG CMyEventProvider::AddRef()
{
    return ++m_cRef;
}



//***************************************************************************
//
//***************************************************************************
// ok

ULONG CMyEventProvider::Release()
{
    if (0 != --m_cRef)
        return m_cRef;

    // If here, we are shutting down.
    // ==============================

    m_eStatus = PendingStop;

    return 0;
}


//***************************************************************************
//
//***************************************************************************
// ok

HRESULT CMyEventProvider::ProvideEvents( 
    /* [in] */ IWbemObjectSink __RPC_FAR *pSink,
    /* [in] */ long lFlags
    )
{
    // Copy the sink.
    // ==============
    
    m_pSink = pSink;
    m_pSink->AddRef();

    // Create the event thread.
    // ========================
    
    DWORD dwTID;
    
    m_hThread = CreateThread(
        0,
        0,
        CMyEventProvider::EventThread,
        this,
        0,
        &dwTID
        );


    // Wait for provider to be 'ready'.
    // ================================
    
    while (m_eStatus != Running)
        Sleep(100);

    return WBEM_NO_ERROR;
}


//***************************************************************************
//
//  This particular provider, being in a DLL operates via its own thread.  
//
//  In practice, such a provider would probably be implemented within a 
//  separate EXE.
//
//***************************************************************************
// ok

DWORD WINAPI CMyEventProvider::EventThread(LPVOID pArg)
{
    // Make transition to the per-instance method.
    // ===========================================
    
    ((CMyEventProvider *)pArg)->InstanceThread();
    return 0;
}

//***************************************************************************
//
//  Events are generated from here
//
//***************************************************************************
// ok

void CMyEventProvider::InstanceThread()
{
    int nIteration = 0;

    CoInitializeEx(NULL, COINIT_MULTITHREADED);

    m_eStatus = Running;
        
    while (m_eStatus == Running)
    {
        Sleep(2000);    // Provide an event every two seconds
        
        
        // Generate a new event object.
        // ============================
        
        IWbemClassObject *pEvt = 0;

        HRESULT hRes = m_pEventClassDef->SpawnInstance(0, &pEvt);
        if (hRes != 0)
            continue;   // Failed
            

        // Generate some values to put in the event.
        // =========================================
                
        wchar_t Buf[128];
        swprintf(Buf, L"Test Event <%d>", nIteration);
 
        CVARIANT vName(Buf);
        pEvt->Put(CBSTR(L"Name"), 0, vName, 0);        

        CVARIANT vCount((LONG) nIteration);
        pEvt->Put(CBSTR(L"Value"), 0, vCount, 0);        

        // Deliver the event to CIMOM.
        // ============================
        
        hRes = m_pSink->Indicate(1, &pEvt);
        
        if (hRes)
        {
            // If here, delivery failed.  Do something to report it.
        }

        pEvt->Release();                    
        nIteration++;
    }

    // When we get to here, we are no longer interested in the
    // provider and Release() has long since returned.
    
    m_eStatus = Stopped;
    delete this;
}





//***************************************************************************
//
//***************************************************************************

    // Inherited from IWbemProviderInit
    // ================================

HRESULT CMyEventProvider::Initialize( 
            /* [in] */ LPWSTR pszUser,
            /* [in] */ LONG lFlags,
            /* [in] */ LPWSTR pszNamespace,
            /* [in] */ LPWSTR pszLocale,
            /* [in] */ IWbemServices __RPC_FAR *pNamespace,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemProviderInitSink __RPC_FAR *pInitSink
            )
{
    // We don't care about most of the incoming parameters in this
    // simple sample.  However, we will save the namespace pointer
    // and get our event class definition.
    // ===========================================================

    m_pNs = pNamespace;
    m_pNs->AddRef();    

    // Grab the class definition for the event.
    // ======================================
    
    IWbemClassObject *pObj = 0;

    HRESULT hRes = m_pNs->GetObject(
        CBSTR(EVENTCLASS),          
        0,                          
        pCtx,  
        &pObj,
        0
        );

    if (hRes != 0)
        return WBEM_E_FAILED;

    m_pEventClassDef = pObj;

    // Tell CIMOM that we're up and running.
    // =====================================

    pInitSink->SetStatus(WBEM_S_INITIALIZED,0);
    
    return WBEM_NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\frameworkabr\binding.h ===
//=================================================================

//

// binding.h -- Generic association class

//

// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#pragma once

#include "assoc.h"

#define MAX_ORS 3

class CBinding : public CAssociation
{
    public:

        CBinding(
            LPCWSTR pwszClassName,
            LPCWSTR pwszNamespaceName,

            LPCWSTR pwszLeftClassName,
            LPCWSTR pwszRightClassName,

            LPCWSTR pwszLeftPropertyName,
            LPCWSTR pwszRightPropertyName,

            LPCWSTR pwszLeftBindingPropertyName,
            LPCWSTR pwszRightBindingPropertyName
        );

        virtual ~CBinding();

    protected:

        virtual bool AreRelated(

            const CInstance *pLeft, 
            const CInstance *pRight
        );

        virtual void MakeWhere(

            CHStringArray &sRightPaths,
            CHStringArray &sRightWheres
        );

        virtual HRESULT FindWhere(

            TRefPointerCollection<CInstance> &lefts,
            CHStringArray &sLeftWheres
        );

        virtual HRESULT GetLeftInstances(

            MethodContext *pMethodContext, 
            TRefPointerCollection<CInstance> &lefts,
            const CHStringArray &sRightValues
        );

        virtual HRESULT GetRightInstances(

            MethodContext *pMethodContext, 
            TRefPointerCollection<CInstance> *lefts,
            const CHStringArray &sLeftWheres
        );

        virtual HRESULT RetrieveLeftInstance(

            LPCWSTR lpwszObjPath,
            CInstance **ppInstance,
            MethodContext *pMethodContext
        );

        virtual HRESULT RetrieveRightInstance(

            LPCWSTR lpwszObjPath,
            CInstance **ppInstance,
            MethodContext *pMethodContext
        );

        bool CompareVariantsNoCase(const VARIANT *v1, const VARIANT *v2);

        HRESULT MakeString(VARIANT *pvValue, CHString &sTemp);

        DWORD IsInList(
                                
            const CHStringArray &csaArray, 
            LPCWSTR pwszValue
        );

        void EscapeCharacters(LPCWSTR wszIn,
                          CHString& chstrOut);

//-----------

        CHString m_sLeftBindingPropertyName;
        CHString m_sRightBindingPropertyName;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\eventprovider\oahelp.inl ===
// **************************************************************************
//
// Copyright (c) 1997-1999 Microsoft Corporation.
//
// File:  OAHELP.INL
//
// Description:
//        OLE Automation Helpers for client code
//
// History:
//
// **************************************************************************

#ifndef _OAHELP_INL_
#define _OAHELP_INL_

class CBSTR
{
    BSTR m_pStr;
public:
    CBSTR() { m_pStr = 0; }
    CBSTR(LPWSTR pSrc) { m_pStr = SysAllocString(pSrc); }
   ~CBSTR() { if (m_pStr) SysFreeString(m_pStr); }
    operator BSTR() { return m_pStr; }

    void Unbind() { m_pStr = 0; }
};

class CVARIANT
{
    VARIANT v;
public:
    CVARIANT() { VariantInit(&v); }
   ~CVARIANT() { VariantClear(&v); }
    void Clear()  { VariantClear(&v); }

    operator VARIANT *() { return &v; }
    VARIANT *operator &() { return &v; }

    CVARIANT(LPWSTR pSrc)   { VariantInit(&v); SetStr(pSrc); }
    CVARIANT(LONG lSrc)     { VariantInit(&v); SetLONG(lSrc); }
    CVARIANT(BOOL b)        { VariantInit(&v); SetBool(b); }
    CVARIANT(short i)       { VariantInit(&v); SetShort(i); }
    CVARIANT(double d)      { VariantInit(&v); SetDouble(d); }
    CVARIANT(BYTE b)        { VariantInit(&v); SetByte(b); }
    CVARIANT(IDispatch * pDisp) { VariantInit(&v); pDisp->AddRef(); SetDispatch(pDisp); }

    void   SetStr(LPWSTR pSrc)
    { Clear(); V_VT(&v) = pSrc ? VT_BSTR : VT_NULL; 
      V_BSTR(&v) = pSrc ? SysAllocString(pSrc) : 0; 
    }

    LPWSTR GetStr() { return V_VT(&v) == VT_BSTR ? V_BSTR(&v) : 0; }
    operator LPWSTR() { return V_VT(&v) == VT_BSTR ? V_BSTR(&v) : 0; }

    void SetLONG(LONG lSrc) { Clear(); V_VT(&v) = VT_I4; V_I4(&v) = lSrc; }
    LONG GetLONG() { return V_I4(&v); }
    operator LONG() { return V_I4(&v);  }

    void SetDouble(double dSrc) { Clear(); V_VT(&v) = VT_R8; V_R8(&v) = dSrc; }
    double GetDouble() { return V_R8(&v); }
    operator double() { return V_R8(&v);  }

    void SetByte(BYTE bySrc) { Clear(); V_VT(&v) = VT_UI1; V_UI1(&v) = bySrc; }
    BYTE GetByte() { return V_UI1(&v); }
    operator BYTE() { return V_UI1(&v);  }

    void SetBool(BOOL b) { V_VT(&v) = VT_BOOL; V_BOOL(&v) = b ? VARIANT_TRUE : VARIANT_FALSE; }
    BOOL GetBool() { return V_BOOL(&v) == VARIANT_TRUE; }
    operator BOOL() { return V_BOOL(&v); }

    void SetDispatch(IDispatch* pDisp) { V_VT(&v) = VT_DISPATCH; V_DISPATCH(&v) = pDisp; }
    IDispatch * GetDispatch() { return V_DISPATCH(&v); }

    void SetUnknown(IUnknown* pUnk) { V_VT(&v) = VT_UNKNOWN; V_UNKNOWN(&v) = pUnk; }
    IUnknown * GetUnknown() { return V_UNKNOWN(&v); }

    void SetShort(short i) { V_VT(&v) = VT_I2; V_I2(&v) = i; }
    short GetShort() { return V_I2(&v); }
    operator short() { return V_I2(&v); }

    VARTYPE GetType() { return V_VT(&v); }

    void SetArray(SAFEARRAY *p, VARTYPE vt) { Clear(); V_VT(&v) = vt; V_ARRAY(&v) = p; }
        // This function acquires the SAFEARRAY pointer and it is no longer owned
        // by the caller.

    operator SAFEARRAY *() { return (V_VT(&v) & VT_ARRAY ? V_ARRAY(&v) : 0); }

    void Unbind() { VariantInit(&v); }
};

class CSAFEARRAY
{
    SAFEARRAY *p;
public:
    CSAFEARRAY(VARTYPE v, int nSize) 
    {
        SAFEARRAYBOUND rgsabound[1];
    	rgsabound[0].lLbound = 0;
    	rgsabound[0].cElements = nSize;
        p = SafeArrayCreate(v, 1, rgsabound);
    }
    
    ~CSAFEARRAY() { if (p) SafeArrayDestroy(p); }
    CSAFEARRAY(SAFEARRAY *pSrc) { p = pSrc; }

    HRESULT Put(long nLocation, LPVOID pData) {
        return SafeArrayPutElement(p, &nLocation, pData);                
    }

    HRESULT Get(long nLocation, LPVOID pData) { 
        return SafeArrayGetElement(p, &nLocation, pData);                
    }

    HRESULT Access(void **pData) { return SafeArrayAccessData(p, pData); }
    HRESULT Unaccess() { return SafeArrayUnaccessData(p); }

    operator SAFEARRAY *() { return p; }
    long GetNumElements() { long upper; SafeArrayGetUBound(p, 1, &upper); return upper + 1; }

    void Unbind() { p = 0; }
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\eventprovider\olesrvr.cpp ===
// **************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// File:  OLESRVR.CPP
//
// Description:
//		  Event provider sample - COM server implementations
//
// History:
//
// **************************************************************************

#include <windows.h>
#include <stdio.h>
#include <time.h>
#include <locale.h>

#include <wbemidl.h>
#include <initguid.h>

#include "evprov.h"

static HINSTANCE g_hInstance;

//***************************************************************************
//
//  DllMain
//
//***************************************************************************

BOOL WINAPI DllMain(
    HINSTANCE hinstDLL,
    DWORD dwReason,
    LPVOID lpReserved
    )
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        g_hInstance = hinstDLL;
        setlocale(LC_ALL, "");    
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
    }

    return TRUE;
}



//***************************************************************************
//
//  class CFactory
//
//***************************************************************************

class CFactory : public IClassFactory
{
    ULONG           m_cRef;
    CLSID           m_ClsId;

public:
    CFactory(const CLSID & ClsId);
    ~CFactory();

    //
    // IUnknown members
    //
    STDMETHODIMP         QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // IClassFactory members
    //
    STDMETHODIMP     CreateInstance(LPUNKNOWN, REFIID, LPVOID *);
    STDMETHODIMP     LockServer(BOOL);
};




//***************************************************************************
//
// Count number of objects and number of locks on this DLL.
//
//***************************************************************************

static ULONG g_cObj = 0;
static ULONG g_cLock = 0;



//***************************************************************************
//
//  DllGetClassObject
//
//***************************************************************************

extern "C"
HRESULT APIENTRY DllGetClassObject(
    REFCLSID rclsid,
    REFIID riid,
    LPVOID * ppv
    )
{
    HRESULT         hr;


    CFactory *pFactory;

    //
    //  Verify the caller is asking for our type of object.
    //
    if (CLSID_MyEventProvider != rclsid) 
            return E_FAIL;

    //
    // Check that we can provide the interface.
    //
    if (IID_IUnknown != riid && IID_IClassFactory != riid)
        return E_NOINTERFACE;

    //
    // Get a new class factory.
    //
    pFactory = new CFactory(rclsid);

    if (!pFactory)
        return E_OUTOFMEMORY;

    //
    // Verify we can get an instance.
    //
    hr = pFactory->QueryInterface(riid, ppv);

    if (FAILED(hr))
        delete pFactory;

    return hr;
}

//***************************************************************************
//
//  DllCanUnloadNow
//
//***************************************************************************
extern "C"
HRESULT APIENTRY DllCanUnloadNow(void)
{
    SCODE sc = TRUE;

    if (g_cObj || g_cLock)
        sc = S_FALSE;

    return sc;
}

//***************************************************************************
//
//***************************************************************************

void ObjectCreated(DWORD dwType)
{
    InterlockedIncrement((LONG *) &g_cObj);
}

void ObjectDestroyed(DWORD dwType)
{
    InterlockedDecrement((LONG *) &g_cObj);
}


//***************************************************************************
//
//  CFactory::CFactory
//
//***************************************************************************

CFactory::CFactory(const CLSID & ClsId)
{
    m_cRef = 0;
    m_ClsId = ClsId;
    ObjectCreated(0);
}

//***************************************************************************
//
//  CFactory::~CFactory
//
//***************************************************************************

CFactory::~CFactory()
{
    // nothing
    ObjectDestroyed(0);
}

//***************************************************************************
//
//  CFactory::QueryInterface, AddRef and Release
//
//***************************************************************************

STDMETHODIMP CFactory::QueryInterface(REFIID riid, LPVOID * ppv)
{
    *ppv = 0;

    if (IID_IUnknown==riid || IID_IClassFactory==riid)
    {
        *ppv = this;
        AddRef();
        return NOERROR;
    }

    return E_NOINTERFACE;
}


ULONG CFactory::AddRef()
{
    return ++m_cRef;
}


ULONG CFactory::Release()
{
    if (0 != --m_cRef)
        return m_cRef;
    delete this;
    return 0;
}

//***************************************************************************
//
//  CFactory::CreateInstance
//
//***************************************************************************

STDMETHODIMP CFactory::CreateInstance(
    LPUNKNOWN pUnkOuter,
    REFIID riid,
    LPVOID * ppvObj)
{
    IUnknown* pObj;
    HRESULT  hr;

    //
    //  Defaults
    //
    *ppvObj=NULL;
    hr = E_OUTOFMEMORY;

    //
    // We aren't supporting aggregation.
    //
    if (pUnkOuter)
        return CLASS_E_NOAGGREGATION;

    if (m_ClsId == CLSID_MyEventProvider)
    {
        pObj = (IWbemProviderInit *) new CMyEventProvider;
    }

    if (!pObj)
        return hr;

    //
    //  Initialize the object and verify that it can return the
    //  interface in question.
    //                                         
    hr = pObj->QueryInterface(riid, ppvObj);

    //
    // Kill the object if initial creation or Init failed.
    //
    if (FAILED(hr))
        delete pObj;

    return hr;
}

//***************************************************************************
//
//***************************************************************************

STDMETHODIMP CFactory::LockServer(BOOL fLock)
{
    if (fLock)
        InterlockedIncrement((LONG *) &g_cLock);
    else
        InterlockedDecrement((LONG *) &g_cLock);

    return NOERROR;
}




//***************************************************************************
//
//  DllRegisterServer
//
//  Standard OLE entry point for registering the server.
//
//  RETURN VALUES:
//
//      S_OK        Registration was successful
//      E_FAIL      Registration failed.
//
//***************************************************************************

extern "C"
HRESULT APIENTRY DllRegisterServer(void)
{
    wchar_t Path[1024];
    wchar_t *pGuidStr = 0;
    wchar_t KeyPath[1024];

    // Where are we?
    // =============
    GetModuleFileNameW(g_hInstance, Path, 1024);

    // Convert CLSID to string.
    // ========================

    StringFromCLSID(CLSID_MyEventProvider, &pGuidStr);
    swprintf(KeyPath, L"CLSID\\\\%s", pGuidStr);

    HKEY hKey;
    LONG lRes = RegCreateKeyW(HKEY_CLASSES_ROOT, KeyPath, &hKey);
    if (lRes)
        return E_FAIL;

    wchar_t *pName = L"WMI Sample Event Provider";
    RegSetValueExW(hKey, 0, 0, REG_SZ, (const BYTE *) pName, (DWORD)(wcslen(pName) * 2 + 2));

    HKEY hSubkey;
    lRes = RegCreateKey(hKey, "InprocServer32", &hSubkey);

    RegSetValueExW(hSubkey, 0, 0, REG_SZ, (const BYTE *) Path, (DWORD)(wcslen(Path) * 2 + 2));
    RegSetValueExW(hSubkey, L"ThreadingModel", 0, REG_SZ, (const BYTE *) L"Both", (DWORD)(wcslen(L"Both") * 2 + 2));

    RegCloseKey(hSubkey);
    RegCloseKey(hKey);

    CoTaskMemFree(pGuidStr);

    return S_OK;
}

//***************************************************************************
//
//  DllUnregisterServer
//
//  Standard OLE entry point for unregistering the server.
//
//  RETURN VALUES:
//
//      S_OK        Unregistration was successful
//      E_FAIL      Unregistration failed.
//
//***************************************************************************

extern "C"
HRESULT APIENTRY DllUnregisterServer(void)
{
    wchar_t *pGuidStr = 0;
    HKEY hKey;
    wchar_t KeyPath[256];

    StringFromCLSID(CLSID_MyEventProvider, &pGuidStr);
    swprintf(KeyPath, L"CLSID\\%s", pGuidStr);

    // Delete InProcServer32 subkey.
    // =============================
    LONG lRes = RegOpenKeyW(HKEY_CLASSES_ROOT, KeyPath, &hKey);
    if (lRes)
        return E_FAIL;

    RegDeleteKeyW(hKey, L"InprocServer32");
    RegCloseKey(hKey);

    // Delete CLSID GUID key.
    // ======================

    lRes = RegOpenKeyW(HKEY_CLASSES_ROOT, L"CLSID", &hKey);
    if (lRes)
        return E_FAIL;

    RegDeleteKeyW(hKey, pGuidStr);
    RegCloseKey(hKey);

    CoTaskMemFree(pGuidStr);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\frameworkabr\binding.cpp ===
//=================================================================

//

// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
//
// binding.cpp -- Rule-based association class
//
// This class allows for the creation of a specific type of rule-based associations.  Consider 
// this example:
// 
// CBinding MyPhysicalDiskToLogicalDisk(
//     L"PhysicalDiskToLogicalDisk",
//     L"Root\\default",
//     L"PhysicalFixedDisk",
//     L"LogicalDisk",
//     L"Antecendent",
//     L"Dependent",
//     L"MappedDriveLetter",
//     L"DriveLetter"
// );
// 
// This declaration is saying that there is a class named "PhysicalDiskToLogicalDisk" which 
// resides in the "root\default" namespace.  It is an association between the "PhysicalFixedDisk" 
// class, and the "LogicalDisk" class.  The "PhysicalFixedDisk" value goes into the 
// "Antecendent" property of the "PhysicalDiskToLogicalDisk" class, and the 
// "LogicalDisk" value goes in the "Dependent" property of the "PhysicalDiskToLogicalDisk" class.
// Only return instances where PhysicalFixedDisk.MappedDriveLetter = LogicalDisk.DriveLetter.
// 
// Some notes:
// - When choosing which of the two classes should be the left class, choose the class that is
// likely to have fewer instances.  This will result in less memory being used, and instances
// being sent back to the client sooner.
// 
// - CBinding supports ExecQuery, GetObject, and EnumerateInstances.
// 
// - CBinding is designed to be derived from.  For example, if your association needs to 
// support DeleteInstance, ExecMethod, or PutInstance, create a class that derives from 
// CBinding, and add the appropriate methods.  Also, various methods such as 
// LoadPropertyValues and AreRelated may be useful for further customization.
// 
// - The two endpoint classes can be dynamic, static, or abstract.  CBinding will do a deep 
// enumeration (actually a query, which is always deep) to retrieve the instances.
// 
// - When calling the endpoint classes, CBinding will use per property gets, and queries
// with Select clauses and/or Where statements.  If the endpoint classes support per-property
// gets or queries, this will result in better performance for the associaton class.
// 
// - The association class and both endpoints must all be in the same namespace.
// 
// See also: CAssociation (assoc.cpp) for a different type of rule-based association.
// 
//=================================================================

#include <fwcommon.h>

#include "Binding.h"

/////////////////////////////////////////////////////////////////////
//
// Function:   CBinding::CBinding
//
// Constructor.
//
/////////////////////////////////////////////////////////////////////

CBinding::CBinding(

    LPCWSTR pwszClassName,
    LPCWSTR pwszNamespaceName,

    LPCWSTR pwszLeftClassName,
    LPCWSTR pwszRightClassName,

    LPCWSTR pwszLeftPropertyName,
    LPCWSTR pwszRightPropertyName,

    LPCWSTR pwszLeftBindingPropertyName,
    LPCWSTR pwszRightBindingPropertyName

) : CAssociation (

    pwszClassName,
    pwszNamespaceName,
    pwszLeftClassName,
    pwszRightClassName,
    pwszLeftPropertyName,
    pwszRightPropertyName
)
{
    // Save off the binding property names
    m_sLeftBindingPropertyName = pwszLeftBindingPropertyName;
    m_sRightBindingPropertyName = pwszRightBindingPropertyName;
}

/////////////////////////////////////////////////////////////////////
//
// Function:   CBinding::~CBinding
//
// Destructor.
//
/////////////////////////////////////////////////////////////////////

CBinding::~CBinding()
{
}

/////////////////////////////////////////////////////////////////////
//
// Function:   CBinding::AreRelated
//
// Determine whether the two instances are related.  For
// CBinding, this is done by comparing their BindingProperty values.
//
// Note that NULL properties values are not considered to be related
// to anything, even another NULL.
//
/////////////////////////////////////////////////////////////////////

bool CBinding::AreRelated(

    const CInstance *pLeft,
    const CInstance *pRight
)
{
    bool bRet = false;

    variant_t   LeftBindingPropertyValue,
                RightBindingPropertyValue;

    if (pLeft->GetVariant(m_sLeftBindingPropertyName, LeftBindingPropertyValue) &&
        pRight->GetVariant(m_sRightBindingPropertyName,  RightBindingPropertyValue) )
    {
        bRet = CompareVariantsNoCase(&LeftBindingPropertyValue, &RightBindingPropertyValue);
    }

    return bRet;
}

/////////////////////////////////////////////////////////////////////
//
// Function:   CBinding::GetRightInstances
//
// Make an async call (well, sort of async) to retrieve all of the
// instances of the righthand class.  If possible use the sLeftWheres
// to create a query to minimize the number of returned instances.
//
/////////////////////////////////////////////////////////////////////

HRESULT CBinding::GetRightInstances(

    MethodContext *pMethodContext,
    TRefPointerCollection<CInstance> *lefts,
    const CHStringArray &sLeftWheres
)
{
    CHString sQuery;

    // Did we get any where clauses?
    if (sLeftWheres.GetSize() == 0)
    {
        // Nope, retrieve them all.
        sQuery.Format(L"SELECT __RELPATH, %s FROM %s WHERE %s<>NULL", 

                        (LPCWSTR)m_sRightBindingPropertyName, 
                        (LPCWSTR)m_sRightClassName,
                        (LPCWSTR)m_sRightBindingPropertyName);
    }
    else
    {
        // Yup, build a query to only retrieve those instances.
        CHString sQuery2;

        sQuery.Format(L"SELECT __RELPATH, %s FROM %s WHERE (%s<>NULL) AND (%s=%s ", 

            (LPCWSTR)m_sRightBindingPropertyName, 
            (LPCWSTR)m_sRightClassName, 
            (LPCWSTR)m_sRightBindingPropertyName, 
            (LPCWSTR)m_sRightBindingPropertyName, 
            (LPCWSTR)sLeftWheres[0]);

        // Usually, we should only have one (that's what ASSOCIATORS and REFERENCES will
        // generate).  However, if we have more than one, tack the rest on.
        for (DWORD x=1; x < sLeftWheres.GetSize(); x++)
        {
            sQuery2.Format(L"OR %s=%s ", (LPCWSTR)m_sRightBindingPropertyName, (LPCWSTR)sLeftWheres[x]);
            sQuery += sQuery2;
        }

        // put the final close parenthesis.
        sQuery.SetAt(sQuery.GetLength() - 1, L')');
    }

    // 'StaticEnumerationCallback' will get called once for each instance
    // returned from the query
    HRESULT hr = CWbemProviderGlue::GetInstancesByQueryAsynch(
        sQuery,
        this,
        StaticEnumerationCallback,
        GetNamespace(),
        pMethodContext,
        lefts);

    return hr;
}

/////////////////////////////////////////////////////////////////////
//
// Function:   CBinding::GetLeftInstances
//
// Retrieve the lefthand instances, storing them in lefts
//
/////////////////////////////////////////////////////////////////////

HRESULT CBinding::GetLeftInstances(

    MethodContext *pMethodContext,
    TRefPointerCollection<CInstance> &lefts,
    const CHStringArray &sRightWheres
)
{
    CHString sQuery;

    // Did we get any where clauses?
    if (sRightWheres.GetSize() == 0)
    {
        // Nope, retrieve them all.
        sQuery.Format(L"SELECT __RELPATH, %s FROM %s WHERE %s <> NULL", 
                            (LPCWSTR)m_sLeftBindingPropertyName, 
                            (LPCWSTR)m_sLeftClassName,
                            (LPCWSTR)m_sLeftBindingPropertyName
                            );
    }
    else
    {
        // Yup, build a query to only retrieve those instances.
        CHString sQuery2;

        sQuery.Format(L"SELECT __RELPATH, %s FROM %s WHERE (%s<>NULL) AND (%s=%s ", 
            (LPCWSTR)m_sLeftBindingPropertyName, 
            (LPCWSTR)m_sLeftClassName, 
            (LPCWSTR)m_sLeftBindingPropertyName, 
            (LPCWSTR)m_sLeftBindingPropertyName, 
            (LPCWSTR)sRightWheres[0]);

        // Usually, we should only have one (that's what ASSOCIATORS and REFERENCES will
        // generate).  However, if we have more than one, tack the rest on.
        for (DWORD x=1; x < sRightWheres.GetSize(); x++)
        {
            sQuery2.Format(L"OR %s=%s ", (LPCWSTR)m_sLeftBindingPropertyName, (LPCWSTR)sRightWheres[x]);
            sQuery += sQuery2;
        }

        // put the final close parenthesis.
        sQuery.SetAt(sQuery.GetLength() - 1, L')');
    }

    return CWbemProviderGlue::GetInstancesByQuery(sQuery, &lefts, pMethodContext, GetNamespace());
}

/////////////////////////////////////////////////////////////////////
//
// Function:   CBinding::RetrieveLeftInstance
//
// Retrieve a specific lefthand instance.  Use per-property gets
// to only request the required properties for best performance.
//
/////////////////////////////////////////////////////////////////////

HRESULT CBinding::RetrieveLeftInstance(

    LPCWSTR lpwszObjPath,
    CInstance **ppInstance,
    MethodContext *pMethodContext
)
{
    CHStringArray csaProperties;
    csaProperties.Add(L"__Relpath");
    csaProperties.Add(m_sLeftBindingPropertyName);

    return CWbemProviderGlue::GetInstancePropertiesByPath(lpwszObjPath, ppInstance, pMethodContext, csaProperties);
}

/////////////////////////////////////////////////////////////////////
//
// Function:   CBinding::RetrieveRightInstance
//
// Retrieve a specific lefthand instance.  Use per-property gets
// to only request the required properties for best performance.
//
/////////////////////////////////////////////////////////////////////

HRESULT CBinding::RetrieveRightInstance(

    LPCWSTR lpwszObjPath,
    CInstance **ppInstance,
    MethodContext *pMethodContext
)
{
    CHStringArray csaProperties;
    csaProperties.Add(L"__Relpath");
    csaProperties.Add(m_sRightBindingPropertyName);

    return CWbemProviderGlue::GetInstancePropertiesByPath(lpwszObjPath, ppInstance, pMethodContext, csaProperties);
}

/////////////////////////////////////////////////////////////////////
//
// Function:   CBinding::MakeWhere
//
// If the key property of the righthand class also happens to be
// the binding property AND if we have a path for specific righthand
// instances we need to return, then we can use the path for the 
// righthand instances to build a where clause for the lefthand 
// instances.
//
// Note that if we find invalid paths in sRightPaths, we remove
// them from sRightPaths.
//
/////////////////////////////////////////////////////////////////////

void CBinding::MakeWhere(

    CHStringArray &sRightPaths,
    CHStringArray &sRightWheres
)
{
    // See if we have any righthand instances
    if (sRightPaths.GetSize() > 0)
    {
        ParsedObjectPath    *pParsedPath = NULL;
        CObjectPathParser    objpathParser;
        CHString sTemp;

        for (DWORD x=0; x < sRightPaths.GetSize();) // Note that x++ is done inside the loop
        {
            // Parse the instance
            int nStatus = objpathParser.Parse( sRightPaths[x],  &pParsedPath );

            if ( 0 == nStatus )
            {
                try
                {
                    // See if the property name in the key is the property name we are binding on
                    if ( (pParsedPath->m_dwNumKeys == 1) && (pParsedPath->m_paKeys[0]->m_pName != NULL) )
                    {
                        if (_wcsicmp(pParsedPath->m_paKeys[0]->m_pName, m_sRightBindingPropertyName) == 0)
                        {
                            // Yes, it is.  Make a where clause statement.
                            HRESULT hr = MakeString(&pParsedPath->m_paKeys[0]->m_vValue, sTemp);

                            // See if we already have that where clause
                            if ( SUCCEEDED(hr) && IsInList(sRightWheres, sTemp) == -1)
                            {
                                // A query with 1000 where clauses isn't going
                                // to be very efficient either.  Pick a reasonable limit
                                if (sRightWheres.GetSize() < MAX_ORS)
                                {
                                    sRightWheres.Add(sTemp);
                                }
                                else
                                {
                                    // Too many.  Fall back on a complete enum
                                    sRightWheres.RemoveAll();
                                    break;
                                }
                            }
                        }
                        else
                        {
                            // Fall back on a complete enum
                            sRightWheres.RemoveAll();
                            break;
                        }
                    }
                    else
                    {
                        // Fall back on a complete enum
                        sRightWheres.RemoveAll();
                        break;
                    }

                    // This was a valid path
                    x++;
                }
                catch ( ... )
                {
                    objpathParser.Free( pParsedPath );
                    throw;
                }

                objpathParser.Free( pParsedPath );
            }
            else
            {
                // This was an invalid path.  Remove it
                sRightPaths.RemoveAt(x);
            }
        }
    }
}

/////////////////////////////////////////////////////////////////////
//
// Function:   CBinding::FindWhere
//
// At this point, we have loaded all the lefthand instances.  We
// can use the binding property from these instances to build
// a where clause to be used when retrieve the righthand instances.
//
/////////////////////////////////////////////////////////////////////

HRESULT CBinding::FindWhere(

    TRefPointerCollection<CInstance> &lefts,
    CHStringArray &sLeftWheres
)
{
    REFPTRCOLLECTION_POSITION posLeft;
    CInstancePtr pLeft;
    HRESULT hr = WBEM_S_NO_ERROR;

    if (lefts.BeginEnum(posLeft))
    {
        variant_t   vLeftBindingPropertyValue;
        CHString sTemp;

        // Walk the left instances
        for (pLeft.Attach(lefts.GetNext(posLeft)) ;
            (pLeft != NULL) ;
            pLeft.Attach(lefts.GetNext(posLeft)) )
        {
            // Get the binding property from the left
            if (pLeft->GetVariant(m_sLeftBindingPropertyName, vLeftBindingPropertyValue))
            {
                // Turn it into a where clause
                hr = MakeString(&vLeftBindingPropertyValue, sTemp);

                // See if we alread have this where clause
                if (SUCCEEDED(hr) && IsInList(sLeftWheres, sTemp) == -1)
                {
                    // A query with 1000 where clauses isn't going
                    // to be very efficient either.  Pick a reasonable limit
                    if (sLeftWheres.GetSize() < MAX_ORS)
                    {
                        sLeftWheres.Add(sTemp);
                    }
                    else
                    {
                        // Too many.  Fall back to enum
                        sLeftWheres.RemoveAll();
                        break;
                    }
                }

                vLeftBindingPropertyValue.Clear();
            }
            else
            {
                hr = WBEM_E_FAILED;
                break;
            }
        }

        lefts.EndEnum();
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////
//
// Function:   CBinding::MakeString
//
// Turn the bindingproperty value into a string suitable for using
// in a wql where clause.
//
/////////////////////////////////////////////////////////////////////

HRESULT CBinding::MakeString(VARIANT *pvValue, CHString &sTemp)
{
    bool bIsString = V_VT(pvValue) == VT_BSTR;
    HRESULT hr = VariantChangeType(
        
            pvValue, 
            pvValue, 
            VARIANT_NOVALUEPROP, 
            VT_BSTR
    );

    if (SUCCEEDED(hr))
    {
        // If the original type was string, we need to escape quotes
        // and backslashes, and put double quotes around it.
        if (bIsString)
        {
            CHString sTemp2;
            EscapeCharacters(V_BSTR(pvValue), sTemp2);

            sTemp.Format(L"\"%s\"", (LPCWSTR)sTemp2);
        }
        else
        {
            sTemp = V_BSTR(pvValue);
        }
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////
//
// Function:   CBinding::IsInList
//
// See whether a given string already exists in a chstring array.
//
/////////////////////////////////////////////////////////////////////

DWORD CBinding::IsInList(
                                
    const CHStringArray &csaArray, 
    LPCWSTR pwszValue
)
{
    DWORD dwSize = csaArray.GetSize();

    for (DWORD x=0; x < dwSize; x++)
    {
        // Note this is a CASE INSENSITIVE compare
        if (_wcsicmp(csaArray[x], pwszValue) == 0)
        {
            return x;
        }
    }

    return -1;
}

/////////////////////////////////////////////////////////////////////
//
// Function:   CBinding::CompareVariantsNoCase
//
// Compare two variants to see if they are the same.
//
/////////////////////////////////////////////////////////////////////

bool CBinding::CompareVariantsNoCase(const VARIANT *v1, const VARIANT *v2)
{
   if (v1->vt == v2->vt)
   {
      switch (v1->vt)
      {
          case VT_NULL: return false;
          case VT_BOOL: return (v1->boolVal == v2->boolVal);
          case VT_UI1:  return (v1->bVal == v2->bVal);
          case VT_I2:   return (v1->iVal == v2->iVal);
          case VT_I4:   return (v1->lVal == v2->lVal);
          case VT_R4:   return (v1->fltVal == v2->fltVal);
          case VT_R8:   return (v1->dblVal == v2->dblVal);
          case VT_BSTR:
          {
              if ( (v1->bstrVal == v2->bstrVal) || // deal with both being NULL
                   (0 == _wcsicmp(v1->bstrVal, v2->bstrVal)) )
              {                   
                  return true;
              }
              else
              {
                  return false;
              }
          }
          default:
          {
              // Should never get here
          }
      }
   }

   return false;
}

/////////////////////////////////////////////////////////////////////
//
// Function:   CBinding::EscapeBackslashes
//
// Prefix " and \ characters with an additional \
//
/////////////////////////////////////////////////////////////////////

VOID CBinding::EscapeCharacters(LPCWSTR wszIn,
                     CHString& chstrOut)
{
    CHString chstrCpyNormPathname(wszIn);
    LONG lNext = -1L;
    chstrOut.Empty();

    // Find the next character to escape
    while( (lNext = chstrCpyNormPathname.FindOneOf(L"\"\\") ) != -1)
    {
        // Add on to the new string we are building:
        chstrOut += chstrCpyNormPathname.Left(lNext + 1);
        // Add on the second backslash:
        chstrOut += _T('\\');
        // Hack off from the input string the portion we just copied
        chstrCpyNormPathname = chstrCpyNormPathname.Right(chstrCpyNormPathname.GetLength() - lNext - 1);
    }

    // If the last character wasn't a '\', there may still be leftovers, so
    // copy them here.
    if(chstrCpyNormPathname.GetLength() != 0)
    {
        chstrOut += chstrCpyNormPathname;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\frameworkabr\assoc.cpp ===
//=================================================================================================

//

// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
//
// assoc.cpp -- Rule-based association class
//
// This class allows for the creation of a specific type of rule-based associations.  Consider 
// this example:
// 
//     CAssociation MyThisComputerPhysicalFixedDisk(
//         L"ThisComputerPhysicalFixedDisk",
//         L"Root\\default",
//         L"ThisComputer",
//         L"PhysicalFixedDisk",
//         L"GroupComponent",
//         L"PartComponent"
//     ) ;
// 
// This declaration is saying that there is a class named "ThisComputerPhysicalFixedDisk" which 
// resides in the "root\default" namespace.  It is an association between the "ThisComputer" 
// class, and the "PhysicalFixedDisk" class.  The "ThisComputer" value goes into the 
// "GroupComponent" property of the "ThisComputerPhysicalFixedDisk" class, and the 
// "PhysicalFixedDisk" value goes in the "PartComponent" property of the 
// "ThisComputerPhysicalFixedDisk" class.
// 
// Some notes:
// - This class will take all the instances of the left class ("ThisComputer" in the example
// above) and relate them to ALL instances of the right class ("PhysicalFixedDisk" in the example
// above).  So, if there are 3 instances of the left class, and 4 instances of the right class,
// this association class will return 12 instances.
// 
// - When choosing which of the two classes should be the left class, choose the class that is
// likely to have fewer instances.  This will result in less memory being used, and instances
// being sent back to the client sooner.
// 
// - CAssociation supports ExecQuery, GetObject, and EnumerateInstances.
// 
// - CAssociation is designed to be derived from.  For example, if your association needs to 
// support DeleteInstance, ExecMethod, or PutInstance, create a class that derives from 
// CAssociation, and add the appropriate methods.  Also, various methods such as 
// LoadPropertyValues and AreRelated may be useful for further customization.
// 
// - The two endpoint classes can be dynamic, static, or abstract.  CAssociation will do a deep 
// enumeration (actually a query, which is always deep) to retrieve the instances.
//
// - When calling the endpoint classes, CAssociation will use per property gets, and queries
// with Select clauses and/or Where statements.  If the endpoint classes support per-property
// gets or queries, this will result in better performance for the associaton class.
//
// - The association class and both endpoints must all be in the same namespace.
// 
// See also: CBinding (binding.cpp) for a different type of rule-based association.
//
//=================================================================================================

#include <fwcommon.h>
#include <comdef.h>

#include "Assoc.h"

/////////////////////////////////////////////////////////////////////
//
// Function:   CAssociation::CAssociation
//
// Constructor.
//
/////////////////////////////////////////////////////////////////////

CAssociation::CAssociation(

    LPCWSTR pwszClassName,
    LPCWSTR pwszNamespaceName,

    LPCWSTR pwszLeftClassName,
    LPCWSTR pwszRightClassName,

    LPCWSTR pwszLeftPropertyName,
    LPCWSTR pwszRightPropertyName

) : Provider(pwszClassName, pwszNamespaceName)
{
    // Save off the class and property names
    m_sLeftClassName = pwszLeftClassName;
    m_sRightClassName = pwszRightClassName;

    m_sLeftPropertyName = pwszLeftPropertyName;
    m_sRightPropertyName = pwszRightPropertyName;
}

/////////////////////////////////////////////////////////////////////
//
// Function:   CAssociation::~CAssociation
//
// Destructor
//
/////////////////////////////////////////////////////////////////////

CAssociation::~CAssociation()
{
}

/////////////////////////////////////////////////////////////////////
//
// Function:   CAssociation::ExecQuery
//
// This routine will optimize on queries of the form:
// WHERE prop1 = value1 [ or prop1 = value2 ...]
// 
// This type of query is commonly seen when doing an ASSOCIATORS or 
// REFERENCES query against one of the endpoint classes.
// 
// This routine will also optimize on queries of the form:
// WHERE prop1 = value1 [ or prop1 = value2 ...] AND 
//       prop2 = value3 [ or prop2 = value4 ...]
// 
// It will NOT optmize on queries of the form:
// WHERE prop1 <> value1
// WHERE prop1 > value1
// WHERE prop1 = value1 OR prop2 = value2
// 
/////////////////////////////////////////////////////////////////////

HRESULT CAssociation::ExecQuery(

    MethodContext* pMethodContext,
    CFrameworkQuery &pQuery,
    long lFlags
)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    TRefPointerCollection<CInstance> lefts;

    CHStringArray sLeftPaths, sRightPaths;

    // Look for WHERE m_sLeftPropertyName=value1
    pQuery.GetValuesForProp ( m_sLeftPropertyName, sLeftPaths ) ;

    // Look for WHERE m_sRightPropertyName=value1
    pQuery.GetValuesForProp ( m_sRightPropertyName, sRightPaths ) ;

    if (sLeftPaths.GetSize() == 0)
    {
        // They didn't ask for a specific set of left instances.  However,
        // it may be that we can figure out what left instances we need
        // by looking at what right instances they requested.  CAssociation 
        // doesn't do this, but CBinding does.
        CHStringArray sRightWheres;
        bool bHadRights = sRightPaths.GetSize() > 0;

        MakeWhere(sRightPaths, sRightWheres);

        // If we used to have a list of RightWheres, and MakeWhere discarded
        // them all as unusable, then there aren't going to be any
        // instances that match the query.
        if (!bHadRights || sRightPaths.GetSize() > 0)
        {
            // GetLeftInstances populates lefts using a sRightWheres
            // to construct a query.
            hr = GetLeftInstances(pMethodContext, lefts, sRightWheres);
        }
    }
    else
    {
        // For each sLeftPaths that is valid, create an entry in lefts by
        // doing a GetObject on the sLeftPaths entry.
        hr = ValidateLeftObjectPaths(pMethodContext, sLeftPaths, lefts);
    }

    // If we failed, or if there are no instances on the left, there's
    // no point in continuing.
    if (SUCCEEDED(hr) && lefts.GetSize() > 0)
    {
        // If the where clause didn't specify any value for the right property
        if (sRightPaths.GetSize() == 0)
        {
            // We may be able to use the information from the already retrieved 
            // left instances to limit which instances we retrieve from the right.
            // CAssociation doesn't do this, but CBinding does.
            CHStringArray sLeftWheres;
            hr = FindWhere(lefts, sLeftWheres);

            if (SUCCEEDED(hr))
            {
                // GetRightInstances takes the 'lefts' and rubs all the
                // rights against them creating instances where appropriate
                hr = GetRightInstances(pMethodContext, &lefts, sLeftWheres);
            }
        }
        else
        {
            // They gave us a list of object paths for the righthand property
            TRefPointerCollection<CInstance> rights;

            // For each sRightPaths that is valid, create an instance
            hr = ValidateRightObjectPaths(pMethodContext, sRightPaths, lefts);
        }
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////
//
// Function:   CAssociation::GetObject
//
// Verify the exist of the specified association class instance.
//
/////////////////////////////////////////////////////////////////////

HRESULT CAssociation::GetObject(

    CInstance* pInstance,
    long lFlags,
    CFrameworkQuery &pQuery
)
{
    HRESULT hr = WBEM_E_NOT_FOUND;

    CHString sLeftPath, sRightPath;

    // Get the two endpoints to verify
    if (pInstance->GetCHString(m_sLeftPropertyName, sLeftPath ) &&
        pInstance->GetCHString(m_sRightPropertyName, sRightPath ) )
    {
        CInstancePtr pLeft, pRight;

        // Try to get the objects
        if (
                SUCCEEDED(hr = RetrieveLeftInstance(

                                    sLeftPath, 
                                    &pLeft, 
                                    pInstance->GetMethodContext())
                       ) &&
                SUCCEEDED(hr = RetrieveRightInstance(

                                    sRightPath, 
                                    &pRight, 
                                    pInstance->GetMethodContext())
                         ) 
           )
        {

            hr = WBEM_E_NOT_FOUND;

            // So, the end points exist.  Are they derived from or equal 
            // to the classes we are working with?
            CHString sLeftClass, sRightClass;

            pLeft->GetCHString(L"__Class", sLeftClass);
            pRight->GetCHString(L"__Class", sRightClass);

            bool bDerived = IsDerivedFrom(

                                m_sLeftClassName, 
                                sLeftClass, 
                                pInstance->GetMethodContext()
                            );

            if (bDerived)
            {
                bDerived = IsDerivedFrom(

                                m_sRightClassName, 
                                sRightClass, 
                                pInstance->GetMethodContext()
                            );
            }

            if (bDerived)
            {
                // Just because two instances are valid and derive from the right class, 
                // doesn't mean they are related.  Do any other checks.
                if (AreRelated(pLeft, pRight))
                {
                    // CBinding and CAssoc don't populate any additional properties, but
                    // an overload of one of these classes might.
                    hr = LoadPropertyValues(pInstance, pLeft, pRight);
                }
            }
        }
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////
//
// Function:   CAssociation::EnumerateInstances
//
// Return all instances of the association class
//
/////////////////////////////////////////////////////////////////////

HRESULT CAssociation::EnumerateInstances(

    MethodContext *pMethodContext,
    long lFlags /*= 0L*/
)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    TRefPointerCollection<CInstance> lefts;
    CHStringArray sWheres;

    // GetLeftInstances populates lefts
    if (SUCCEEDED(hr = GetLeftInstances(pMethodContext, lefts, sWheres)))
    {
        // We may be able to use the information from the already retrieved 
        // left instances to limit which instances we retrieve from the right.
        // CAssociation doesn't do this, but CBinding does.
        FindWhere(lefts, sWheres);

        // GetRightInstances takes the 'lefts' and rubs all the
        // rights against them
        hr = GetRightInstances(pMethodContext, &lefts, sWheres);
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////
//
// Function:   CAssociation::GetRightInstances
//
// For each instance of the righthand class retrieved, call
// CAssociation::StaticEnumerationCallback.
//
/////////////////////////////////////////////////////////////////////

HRESULT CAssociation::GetRightInstances(

    MethodContext *pMethodContext,
    TRefPointerCollection<CInstance> *lefts,
    const CHStringArray &sLeftWheres
)
{
    CHString sQuery;
    sQuery.Format(L"SELECT __RELPATH FROM %s", m_sRightClassName);

    // 'StaticEnumerationCallback' will get called once for each instance
    // returned from the query
    HRESULT hr = CWbemProviderGlue::GetInstancesByQueryAsynch(
        sQuery,
        this,
        StaticEnumerationCallback,
        GetNamespace(),
        pMethodContext,
        lefts);

    return hr;
}

/////////////////////////////////////////////////////////////////////
//
// Function:   CAssociation::StaticEnumerationCallback
//
// Put the 'this' pointer back, and call CAssociation::EnumerationCallback
//
/////////////////////////////////////////////////////////////////////

HRESULT WINAPI CAssociation::StaticEnumerationCallback(

    Provider* pThat,
    CInstance* pInstance,
    MethodContext* pContext,
    void* pUserData
)
{
    HRESULT hr;

    CAssociation *pThis = (CAssociation *) pThat;

    if (pThis)
    {
        hr = pThis->EnumerationCallback(pInstance, pContext, pUserData);
    }
    else
    {
        hr = WBEM_S_NO_ERROR;
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////
//
// Function:   CAssociation::EnumerationCallback
//
// Take the righthand instance that was passed in and pair it
// with each of the left hand instances.
//
/////////////////////////////////////////////////////////////////////

HRESULT CAssociation::EnumerationCallback(

    CInstance *pRight,
    MethodContext *pMethodContext,
    void *pUserData
)
{
    HRESULT hr = WBEM_E_FAILED;

    CInstancePtr pLeft;
    REFPTRCOLLECTION_POSITION posLeft;
    CHString sLeftPath, sRightPath;

    // Cast for userdata back to what it is
    TRefPointerCollection<CInstance> *pLefts = (TRefPointerCollection<CInstance> *)pUserData;

    if (pLefts->BeginEnum(posLeft))
    {
        hr = WBEM_S_NO_ERROR;

        // Walk all the pLefts
        for (pLeft.Attach(pLefts->GetNext(posLeft)) ;
            (SUCCEEDED(hr)) && (pLeft != NULL) ;
            pLeft.Attach(pLefts->GetNext(posLeft)) )
        {
            // Compare it to the current pRight
            if(AreRelated(pLeft, pRight))
            {
                // We have a winner.  Populate the properties and send it back.
                if (GetLocalInstancePath(pLeft,  sLeftPath) &&
                    GetLocalInstancePath(pRight, sRightPath))
                {
                    CInstancePtr pNewAssoc(CreateNewInstance(pMethodContext), false);

                    if (pNewAssoc->SetCHString(m_sLeftPropertyName, sLeftPath) &&
                        pNewAssoc->SetCHString(m_sRightPropertyName, sRightPath) )
                    {
                        if (SUCCEEDED(hr = LoadPropertyValues(pNewAssoc, pLeft, pRight)))
                        {
                            hr = pNewAssoc->Commit();
                        }
                    }
                }
            }
        }

        pLefts->EndEnum();
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////
//
// Function:   CAssociation::ValidateLeftObjectPaths
//
// Populate the lefts array by doing GetObjects on the object paths
// passed in sPaths.
//
/////////////////////////////////////////////////////////////////////

HRESULT CAssociation::ValidateLeftObjectPaths(

    MethodContext *pMethodContext,
    const CHStringArray &sPaths,
    TRefPointerCollection<CInstance> &lefts
)
{
    CInstancePtr pInstance;

    // Walk the object paths
    for (DWORD x=0; x < sPaths.GetSize(); x++)
    {
        ParsedObjectPath    *pParsedPath = NULL;
        CObjectPathParser    objpathParser;
        CHString sPath(sPaths[x]);

        // Parse the object path
        int nStatus = objpathParser.Parse( sPath,  &pParsedPath );

        if ( 0 == nStatus )
        {
            // Is this class derived from or equal to the lefthand class?
            bool bDerived = false;

            try
            {
                bDerived = IsDerivedFrom(

                                m_sLeftClassName, 
                                pParsedPath->m_pClass, 
                                pMethodContext
                            );

                // Make sure this is an absolute path
                if (pParsedPath->m_dwNumNamespaces == 0)
                {
                    sPath = L"\\\\.\\" + GetNamespace() + L':' + sPath;
                }

            }
            catch ( ... )
            {
                objpathParser.Free( pParsedPath );
                throw;
            }

            objpathParser.Free( pParsedPath );

            if (bDerived)
            {
                // See if it is valid.  Note that we DON'T send back an error just because
                // we can't find one of the object paths.
                if (SUCCEEDED(RetrieveLeftInstance(sPath, &pInstance, pMethodContext)))
                {
                    // Yup, add it to the list
                    lefts.Add(pInstance);
                }
            }
        }
    }

    return WBEM_S_NO_ERROR;
}

/////////////////////////////////////////////////////////////////////
//
// Function:   CAssociation::ValidateRightObjectPaths
//
// Retrieve the righthand instances by doing GetObjects on the object 
// paths passed in sPaths.  Pass them to EnumerationCallback.
//
/////////////////////////////////////////////////////////////////////

HRESULT CAssociation::ValidateRightObjectPaths(

    MethodContext *pMethodContext,
    const CHStringArray &sPaths,
    TRefPointerCollection<CInstance> &lefts
)
{
    HRESULT hr = WBEM_S_NO_ERROR;;
    CInstancePtr pInstance;
    
    // Walk the object paths
    for (DWORD x=0;
    (x < sPaths.GetSize()) && SUCCEEDED(hr);
    x++)
    {
        ParsedObjectPath    *pParsedPath = NULL;
        CObjectPathParser    objpathParser;
        CHString sPath(sPaths[x]);
        
        int nStatus = objpathParser.Parse( sPath,  &pParsedPath );
        
        if ( 0 == nStatus )
        {
            bool bDerived = false;
            try
            {
                // Make sure this object path is at least related to us
                bDerived = IsDerivedFrom(
                    
                    m_sRightClassName, 
                    pParsedPath->m_pClass, 
                    pMethodContext
                    );
                
                // Make sure this is an absolute path
                if (pParsedPath->m_dwNumNamespaces == 0)
                {
                    sPath = L"\\\\.\\" + GetNamespace() + L':' + sPath;
                }
            }
            catch ( ... )
            {
                objpathParser.Free( pParsedPath );
                throw;
            }
            
            objpathParser.Free( pParsedPath );
            
            if (bDerived)
            {
                // See if it is valid.  Note that we DON'T send back an error just because
                // we can't find one of the object paths.
                if (SUCCEEDED(RetrieveRightInstance(sPath, &pInstance, pMethodContext)))
                {
                    hr = EnumerationCallback(pInstance, pMethodContext, &lefts);
                }
            }
        }
    }
    
    return hr;
}

/////////////////////////////////////////////////////////////////////
//
// Function:   CAssociation::GetLeftInstances
//
// Retrieve all the lefthand instances and store them in lefts
//
/////////////////////////////////////////////////////////////////////

HRESULT CAssociation::GetLeftInstances(

    MethodContext *pMethodContext,
    TRefPointerCollection<CInstance> &lefts,
    const CHStringArray &sRightWheres
)
{
    CHString sQuery;
    sQuery.Format(L"SELECT __RELPATH FROM %s", m_sLeftClassName);

    return CWbemProviderGlue::GetInstancesByQuery(sQuery, &lefts, pMethodContext, GetNamespace());
}

/////////////////////////////////////////////////////////////////////
//
// Function:   CAssociation::RetrieveLeftInstance
//
// Retrieve a specific lefthand instance.  Use per-property gets
// to only request the keys for maximum performance.
//
/////////////////////////////////////////////////////////////////////

HRESULT CAssociation::RetrieveLeftInstance(

    LPCWSTR lpwszObjPath,
    CInstance **ppInstance,
    MethodContext *pMethodContext
)
{
    return CWbemProviderGlue::GetInstanceKeysByPath(lpwszObjPath, ppInstance, pMethodContext);
}

/////////////////////////////////////////////////////////////////////
//
// Function:   CAssociation::RetrieveRightInstance
//
// Retrieve a specific righthand instance.  Use per-property gets
// to only request the keys for maximum performance.
//
/////////////////////////////////////////////////////////////////////

HRESULT CAssociation::RetrieveRightInstance(

    LPCWSTR lpwszObjPath,
    CInstance **ppInstance,
    MethodContext *pMethodContext
)
{
    return CWbemProviderGlue::GetInstanceKeysByPath(lpwszObjPath, ppInstance, pMethodContext);
}

/////////////////////////////////////////////////////////////////////
//
// Function:   CAssociation::IsInstance
//
// See whether the specified CInstance is an Instance object, or a
// Class object.
//
/////////////////////////////////////////////////////////////////////

bool CAssociation::IsInstance(const CInstance *pInstance)
{
    DWORD dwGenus = 0;

    pInstance->GetDWORD(L"__Genus", dwGenus);

    return dwGenus == WBEM_GENUS_INSTANCE;
}

/////////////////////////////////////////////////////////////////////
//
// Function:   CAssociation::IsDerivedFrom
//
// See whether the specified class is derived from or equal 
// to the class we are working with.  Specifically, does 
// pszDerivedClassName derive from pszBaseClassName?
//
/////////////////////////////////////////////////////////////////////

bool CAssociation::IsDerivedFrom(
                              
    LPCWSTR pszBaseClassName, 
    LPCWSTR pszDerivedClassName, 
    MethodContext *pMethodContext
)
{
    // First let's see if they are equal.  CWbemProviderGlue::IsDerivedFrom 
    // doesn't check for this case
    bool bDerived = _wcsicmp(pszBaseClassName, pszDerivedClassName) == 0;
    if (!bDerived)
    {
        bDerived = CWbemProviderGlue::IsDerivedFrom(
            
                                            pszBaseClassName, 
                                            pszDerivedClassName, 
                                            pMethodContext
                                        );
    }

    return bDerived;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\frameworkprov\makefile.inc ===
$(O)\makefile : frameworkprov.mak
	copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\frameworkabr\maindll.cpp ===
//***************************************************************************

//

//  MAINDLL.CPP

//

//  Module: WBEM Framework Instance provider

//

//  Purpose: Contains DLL entry points.  Also has code that controls

//           when the DLL can be unloaded by tracking the number of

//           objects and locks as well as routines that support

//           self registration.

//

// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#define INITGUID

#include <fwcommon.h>
#include "binding.h"

#ifdef _DEBUG
#include <locale.h>
#endif

#define PROVIDER_NAME L"Sample Association"

#ifdef UNICODE
#define TOBSTRT(x)        x
#else
#define TOBSTRT(x)        _bstr_t(x)
#endif

HRESULT RegisterServer(LPCTSTR a_pName, REFGUID a_rguid ) ;
HRESULT UnregisterServer( REFGUID a_rguid );

HMODULE ghModule = NULL;

//Count number of locks.
long       g_cLock=0;

// {5D11C6F1-4B06-4bf8-954C-7C4E78E2F167}
DEFINE_GUID(CLSID_AssocSample, 
0x5d11c6f1, 0x4b06, 0x4bf8, 0x95, 0x4c, 0x7c, 0x4e, 0x78, 0xe2, 0xf1, 0x67);

//***************************************************************************
//
//  DllGetClassObject
//
//  Purpose: Called by Ole when some client wants a class factory.  Return
//           one only if it is the sort of class this DLL supports.
//
//***************************************************************************

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, PPVOID ppv)
{
    HRESULT hr = E_FAIL;
    CWbemGlueFactory *pObj = NULL;
    *ppv = NULL;

    try
    {
        if (CLSID_AssocSample == rclsid )
        {
            pObj = new CWbemGlueFactory();

            if (NULL!=pObj)
            {
                hr = pObj->QueryInterface(riid, ppv);

                if (FAILED(hr))
                {
                    delete pObj;
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }

        }
        else
        {
            hr = E_FAIL;
        }
    }
    catch ( ... )
    {
        if (NULL != pObj)
        {
            delete pObj;
        }
    }

    return hr;
}

//***************************************************************************
//
// DllCanUnloadNow
//
// Purpose: Called periodically by Ole in order to determine if the
//          DLL can be freed.
//
// Return:  S_OK if there are no objects in use and the class factory
//          isn't locked.
//
//***************************************************************************

STDAPI DllCanUnloadNow(void)
{
    HRESULT   hr = S_FALSE;

    // It is OK to unload if there are no locks on the
    // class factory and the framework allows us to go.
    if ( ( 0L == g_cLock ) &&
         CWbemProviderGlue::FrameworkLogoffDLL( PROVIDER_NAME ) )
    {
        hr = S_OK;
    }
    else
    {
        hr = S_FALSE;
    }

    return hr;
}

//***************************************************************************
//
// DllRegisterServer
//
// Purpose: Called during setup or by regsvr32.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllRegisterServer(void)
{
    HRESULT hr;

    hr = RegisterServer( _T("Microsoft Rule Based Association Sample"), CLSID_AssocSample ) ;

    return hr;
}

/***************************************************************************
 * SetKeyAndValue
 *
 * Purpose:
 *  Private helper function for DllRegisterServer that creates
 *  a key, sets a value, and closes that key.
 *
 * Parameters:
 *  pszKey          LPTSTR to the name of the key
 *  pszSubkey       LPTSTR to the name of a subkey
 *  pszValue        LPTSTR to the value to store
 *
 * Return Value:
 *  BOOL            TRUE if successful, FALSE otherwise.
 ***************************************************************************/

BOOL SetKeyAndValue(LPCWSTR pszKey, LPCWSTR pszSubkey, LPCWSTR pszValueName, LPCWSTR pszValue)
{
    HKEY        hKey;
    TCHAR       szKey[256];
    BOOL        bRet = FALSE;

    _tcscpy(TOBSTRT(szKey), TOBSTRT(pszKey));

    if (NULL!=pszSubkey)
    {
        _tcscat(TOBSTRT(szKey), TOBSTRT(_T("\\")));
        _tcscat(TOBSTRT(szKey), TOBSTRT(pszSubkey));
    }

    if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_LOCAL_MACHINE, 
                                        szKey, 
                                        0, 
                                        NULL, 
                                        REG_OPTION_NON_VOLATILE, 
                                        KEY_ALL_ACCESS, 
                                        NULL, 
                                        &hKey, 
                                        NULL))
    {
        if (NULL!=pszValue)
        {
            if (ERROR_SUCCESS == RegSetValueEx(hKey, 
                                    (LPCTSTR)TOBSTRT(pszValueName), 
                                    0, 
                                    REG_SZ, 
                                    (BYTE *)(LPCTSTR)TOBSTRT(pszValue), 
                                    (_tcslen(TOBSTRT(pszValue))+1)*sizeof(TCHAR)))
            {
                bRet = TRUE;
            }                
        }
        RegCloseKey(hKey);
    }

    return bRet;
}

/***************************************************************************
 * RegisterServer
 *
 * Purpose:
 *  Private helper function for DllRegisterServer that registers
 *  this dll as a com object.
 *
 * Parameters:
 *  a_pName         LPCWSTR that describes this com object
 *  a_rguid         Guid of this com object
 *
 * Return Value:
 *  HRESULT
 ***************************************************************************/

HRESULT RegisterServer(LPCTSTR a_pName, REFGUID a_rguid )
{
    HRESULT hr = E_FAIL;
    WCHAR      wcID[128];
    TCHAR      szCLSID[128];
    TCHAR      szModule[MAX_PATH] = {0};
    TCHAR *pModel = _T("Both") ;
   
    GetModuleFileName(ghModule, szModule,  MAX_PATH);

    // Create the path.
    StringFromGUID2(a_rguid, wcID, 128);
    _tcscpy(szCLSID, TEXT("SOFTWARE\\CLASSES\\CLSID\\"));

#ifndef _UNICODE

    TCHAR      szID[128];
    wcstombs(szID, wcID, 128);
    lstrcat(szCLSID, szID);

#else

    _tcscat(szCLSID, wcID);

#endif

    // Create entries under CLSID

    HKEY hKey1;
    if (RegCreateKey(HKEY_LOCAL_MACHINE, szCLSID, &hKey1) == ERROR_SUCCESS)
    {
        if (RegSetValueEx(hKey1, 
                        NULL, 
                        0, 
                        REG_SZ, 
                        (BYTE *)a_pName, 
                        (lstrlen(a_pName)+1) * sizeof(TCHAR)) == ERROR_SUCCESS)
        {
            HKEY hKey2 ;
            if (RegCreateKey(hKey1, _T("InprocServer32"), &hKey2) == ERROR_SUCCESS)
            {
                if (RegSetValueEx(hKey2, 
                                    NULL, 
                                    0, 
                                    REG_SZ, 
                                    (BYTE *)szModule,
                                    (lstrlen(szModule)+1) * sizeof(TCHAR)) == ERROR_SUCCESS)
                {
                    if (RegSetValueEx(hKey2, 
                                        _T("ThreadingModel"), 
                                        0, 
                                        REG_SZ,
                                        (BYTE *)pModel, 
                                        (lstrlen(pModel)+1) * sizeof(TCHAR)) == ERROR_SUCCESS)
                    {
                        hr = S_OK;
                    }
                }

                CloseHandle(hKey2);
            }
        }

        CloseHandle(hKey1);
    }

    return hr;
}

//***************************************************************************
//
// DllUnregisterServer
//
// Purpose: Called from REGSVR32.EXE /U to remove the com registry entries.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllUnregisterServer(void)
{
    HRESULT hr;

    hr = UnregisterServer( CLSID_AssocSample ) ;

    return hr;
}

/***************************************************************************
 * UnregisterServer
 *
 * Purpose:
 *  Private helper function for DllUnregisterServer that unregisters
 *  this dll as a com object.
 *
 * Parameters:
 *  a_rguid         Guid of this com object
 *
 * Return Value:
 *  HRESULT
 ***************************************************************************/

HRESULT UnregisterServer( REFGUID a_rguid )
{
    WCHAR wcID[128];
    TCHAR szCLSID[128];
    TCHAR szProviderCLSIDAppID[128];
    HKEY  hKey;

    // Create the path using the CLSID

    StringFromGUID2( a_rguid, wcID, 128);
    lstrcpy(szCLSID, TEXT("SOFTWARE\\CLASSES\\CLSID\\"));
    _tcscpy(szProviderCLSIDAppID, TEXT("SOFTWARE\\CLASSES\\APPID\\"));

#ifndef _UNICODE

    char szID[128];
    wcstombs(szID, wcID, 128);
    lstrcat(szCLSID, szID);
    _tcscat(szProviderCLSIDAppID, szID);

#else

    lstrcat(szCLSID, wcID);
    _tcscat(szProviderCLSIDAppID, wcID);

#endif

    DWORD dwRet ;

    // Delete entries under APPID.  Note that we don't really use
    // dwRet, since the absence of these keys may simply mean that
    // we were never registered, or have already be unregistered.

    dwRet = RegDeleteKey(HKEY_LOCAL_MACHINE, szProviderCLSIDAppID);

    dwRet = RegOpenKey(HKEY_LOCAL_MACHINE, szCLSID, &hKey);
    if(dwRet == NO_ERROR)
    {
        dwRet = RegDeleteKey(hKey, _T("InProcServer32") );
        dwRet = RegDeleteKey(hKey, _T("LocalServer32"));
        CloseHandle(hKey);
    }

    dwRet = RegDeleteKey(HKEY_LOCAL_MACHINE, szCLSID);

    return NOERROR;
}

/***************************************************************************
 * DllMain
 *
 * Purpose:
 *  This entry point is called by the os once at dll load, and once 
 *  at dll unload
 *
 * Return Value:
 *  BOOL
 ***************************************************************************/

BOOL APIENTRY DllMain( HINSTANCE hinstDLL,  // handle to DLL module
                       DWORD fdwReason,     // reason for calling function
                       LPVOID lpReserved )  // reserved
{
    BOOL bRet = TRUE;

    // Perform actions based on the reason for calling.
    switch( fdwReason )
    {
        case DLL_PROCESS_ATTACH:
        {
                ghModule = hinstDLL ;


             // Initialize once for each new process.
             // Return FALSE to fail DLL load.

#ifdef _DEBUG
                // Do this so our locale is set even when we're debug
                // and winmgmt.exe is release.
                setlocale(LC_ALL, "");
#endif

                bRet = CWbemProviderGlue::FrameworkLoginDLL(PROVIDER_NAME);

                DisableThreadLibraryCalls(hinstDLL);
            }
            break;

        case DLL_THREAD_ATTACH:
        {
            // Do thread-specific initialization.
            // Because of DisableThreadLibraryCalls, we should never get here
        }
        break;

        case DLL_THREAD_DETACH:
        {
            // Do thread-specific cleanup.
            // Because of DisableThreadLibraryCalls, we should never get here
        }
        break;

        case DLL_PROCESS_DETACH:
        {
            // Perform any necessary cleanup.
        }
        break;
    }

    return bRet;  // status of DLL_PROCESS_ATTACH.
}

//=============================
// This declares two assocation-by-rule classes (see binding.cpp and assoc.cpp for descriptions
// of how association by rule works).  You can declare any number of framework classes here, as 
// long as the "Provider" qualifier on the class maps to an instance of __Win32Provider that has 
// the ClsID at the top of this file.

CAssociation MyThisComputerPhysicalFixedDisk(
    L"ThisComputerPhysicalDisk",
    L"Root\\default",
    L"ThisComputer",
    L"PhysicalFixedDisk",
    L"GroupComponent",
    L"PartComponent"
) ;

CBinding MyPhysicalDiskToLogicalDisk(
    L"PhysicalDiskToLogicalDisk",
    L"Root\\default",
    L"PhysicalFixedDisk",
    L"LogicalDisk",
    L"Antecendent",
    L"Dependent",
    L"MappedDriveLetter",
    L"DriveLetter"
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\frameworkprov\frameworkprov.cpp ===
/******************************************************************

 Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved 
   FrameworkProv.CPP -- WMI provider class implementation

   Generated by Microsoft WMI Code Generation Engine
  
   TO DO: - See individual function headers
          - When linking, make sure you link to framedyd.lib & 
            msvcrtd.lib (debug) or framedyn.lib & msvcrt.lib (retail).
  
   Description: 
   Sample provider using the Provider Framework
  
******************************************************************/

#include <fwcommon.h>  // This must be the first include.

#include "FrameworkProv.h"

// See ExecQuery for details of the usage of these #defines
#define BIT_REDNOSE 0x00000001
#define BIT_WEIGHT  0x00000002
#define BIT_ALL_PROPERTIES 0xffffffff

// TO DO: Replace "NameSpace" with the appropriate namespace for your
//        provider instance.   For instance:  "root\\default or "root\\cimv2".
//===================================================================
CReindeer MyReindeerProvSet (PROVIDER_NAME_REINDEERPROV, L"root\\default") ;

// Property names
//===============
const static WCHAR* pName = L"Name" ;
const static WCHAR* pRedNose = L"RedNose" ;
const static WCHAR* pWeight = L"Weight" ;

// This WCHAR * is used to illustrate returning status
// objects.  See DeleteInstance.
//====================================================
const static WCHAR* pErrorClass = L"\\\\.\\root\\default:ReindeerError";

// Sample data
// ===========
Deers ohDeers[Deers::NDeers] =
{
    // Name     Weight  Red Nose    Deleted flag
    {L"Dasher",  200,    false,      false},
    {L"Dancer",  150,    false,      false},
    {L"Prancer", 162,    false,      false},
    {L"Vixen",   125,    false,      false},
    {L"Comet",   212,    false,      false},
    {L"Cupid",   196,    false,      false},
    {L"Donder",  255,    false,      false},
    {L"Blitzen", 145,    false,      false},
    {L"Rudolf",  123,    true,       false}
};

/*****************************************************************************
 *
 *  FUNCTION    :   CReindeer::CReindeer
 *
 *  DESCRIPTION :   Constructor
 *
 *  INPUTS      :   none
 *
 *  RETURNS     :   nothing
 *
 *  COMMENTS    :   Calls the Provider constructor.
 *
 *****************************************************************************/
CReindeer::CReindeer (LPCWSTR lpwszName, LPCWSTR lpwszNameSpace ) :
    Provider(lpwszName, lpwszNameSpace)
{
}

/*****************************************************************************
 *
 *  FUNCTION    :   CReindeer::~CReindeer
 *
 *  DESCRIPTION :   Destructor
 *
 *  INPUTS      :   none
 *
 *  RETURNS     :   nothing
 *
 *  COMMENTS    : 
 *
 *****************************************************************************/
CReindeer::~CReindeer ()
{
}

/*****************************************************************************
*
*  FUNCTION    :    CReindeer::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*  INPUTS      :    A pointer to the MethodContext for communication with WinMgmt.
*                   A long that contains the flags described in 
*                   IWbemServices::CreateInstanceEnumAsync.  Note that the following
*                   flags are handled by (and filtered out by) WinMgmt:
*                       WBEM_FLAG_DEEP
*                       WBEM_FLAG_SHALLOW
*                       WBEM_FLAG_RETURN_IMMEDIATELY
*                       WBEM_FLAG_FORWARD_ONLY
*                       WBEM_FLAG_BIDIRECTIONAL
*
*  RETURNS     :    WBEM_S_NO_ERROR if successful
*
*  COMMENTS    : TO DO: All instances on the machine should be returned here and
*                       all properties that this class knows how to populate must 
*                       be filled in.  If there are no instances, return 
*                       WBEM_S_NO_ERROR.  It is not an error to have no instances.
*                       If you are implementing a 'method only' provider, you
*                       should remove this method.
*
*****************************************************************************/
HRESULT CReindeer::EnumerateInstances ( MethodContext* pMethodContext, long lFlags )
{
    HRESULT hRes = WBEM_S_NO_ERROR;

    // create an instance for each reindeer
    for (int i = 0; (i < Deers::NDeers) && (SUCCEEDED(hRes)); i++)
    {
        // we don't want to return deleted deer
        if (!ohDeers[i].m_deleted)
        {
            // Note that CreateNewInstance may throw, but will never return NULL.
            CInstance *pInstance = CreateNewInstance(pMethodContext);

            pInstance->SetCHString(pName, CHString(ohDeers[i].m_name));
            if (SUCCEEDED(LoadPropertyValues(pInstance, i, BIT_ALL_PROPERTIES)))
            {
                hRes = pInstance->Commit();
            }

            pInstance->Release();
        }
    }

    return hRes ;
}

/*****************************************************************************
*
*  FUNCTION    :    CReindeer::GetObject
*
*  DESCRIPTION :    Find a single instance based on the key properties for the
*                   class. 
*
*  INPUTS      :    A pointer to a CInstance object containing the key properties. 
*                   A long that contains the flags described in 
*                   IWbemServices::GetObjectAsync.  
*
*  RETURNS     :    WBEM_S_NO_ERROR if the instance can be found
*                   WBEM_E_NOT_FOUND if the instance described by the key properties 
*                   could not be found
*                   WBEM_E_FAILED if the instance could be found but another error 
*                   occurred. 
*
*  COMMENTS    :    If you are implementing a 'method only' provider, you should
*                   remove this method.
*
*****************************************************************************/
HRESULT CReindeer::GetObject ( CInstance* pInstance, long lFlags )
{
    // TO DO: The GetObject function is used to search for an instance of this
    //        class on the machine based on the key properties.   Unlike
    //        EnumerateInstances which finds all instances on the machine, GetObject
    //        uses the key properties to find the matching single instance and 
    //        returns that instance.
    //
    //        Use the CInstance Get functions (for example, call 
    //        GetCHString(L"Name", sTemp)) against pInstance to see the key values 
    //        the client requested.
    HRESULT hr = WBEM_E_NOT_FOUND;

    // name is the key, we retrieve the name
    CHString name;
    pInstance->GetCHString(pName, name);

    // search the array for a Reindeer with the name we're given
    // (make sure he hasn't been deleted!)
    for (int i = 0; i < Deers::NDeers; i++) 
    {
        if (0 == name.CompareNoCase(CHString(ohDeers[i].m_name)) && !ohDeers[i].m_deleted)
        {
            // we found the one they're look for - fill in the data
            
            hr = LoadPropertyValues(pInstance, i, BIT_ALL_PROPERTIES);
            break;
        }
    }

    return hr ;
}

/*****************************************************************************
*
*  FUNCTION    :    CReindeer::ExecQuery
*
*  DESCRIPTION :    You are passed a method context to use in the creation of 
*                   instances that satisfy the query, and a CFrameworkQuery 
*                   which describes the query.  Create and populate all 
*                   instances which satisfy the query.  You may return more 
*                   instances or more properties than are requested and WinMgmt 
*                   will post filter out any that do not apply.
*
*  INPUTS      :    A pointer to the MethodContext for communication with WinMgmt.
*                   A query object describing the query to satisfy.
*                   A long that contains the flags described in 
*                   IWbemServices::CreateInstanceEnumAsync.  Note that the following
*                   flags are handled by (and filtered out by) WinMgmt:
*                       WBEM_FLAG_FORWARD_ONLY
*                       WBEM_FLAG_BIDIRECTIONAL
*                       WBEM_FLAG_ENSURE_LOCATABLE
*
*  RETURNS     :    WBEM_E_PROVIDER_NOT_CAPABLE if queries not supported for 
*                       this class or if the query is too complex for this class
*                       to interpret.  The framework will call the EnumerateInstances
*                       function instead and let Winmgmt post filter.
*                   WBEM_E_FAILED if the query failed
*                   WBEM_S_NO_ERROR if query was successful 
*
*  COMMENTS    : TO DO: Most providers will not need to implement this method.  If you don't, WinMgmt 
*                       will call your enumerate function to get all the instances and perform the 
*                       filtering for you.  Unless you expect SIGNIFICANT savings from implementing 
*                       queries, you should remove this method.  You should also remove this method
*                       if you are implementing a 'method only' provider.
*
*****************************************************************************/
HRESULT CReindeer::ExecQuery (MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags)
{

// While this class is too small to really benefit from query processing, this method is
// being instrumented to show how it could be done.  There are two different ways query processing
// can be used to improve performance.  
// 
// Method 1 - Look at the fields that are being requested, and only return data for those fields.  This
//            can be a very big win for some classes if some properties are very expensive to retrieve.  
//            In our own LogicalDisk class, populating just the DeviceID field is very cheap.  However, 
//            populating the FreeSpace property requires that we spin up the disk.  For floppy, cd, and 
//            network drives, that is very expensive.
//
// Method 2 - Look at the where clause and only return the requested records.  Obviously, this also has 
//            the potential to be a big win.  For example, if the query is of the form 'Select Name, 
//            Size from CIM_Datafile where where drive="a:"', clearly this can be resolved much faster 
//            then doing the default behavior when no ExecQuery routine is specified (enumerating all 
//            directories on all drives and let Winmgmt pick out the matching entries).

//            On the other hand, just because a WHERE clause in included doesn't mean that the query can 
//            be processed any faster.  Consider a query of the form "Select * from CIM_Datafile where 
//            ReadOnly = TRUE".  By the time we have called FindFirstFile and examined the structure, the 
//            most expensive parts of the processing is already done.  How about a query of the form 
//            'Select * from CIM_Datafile where Drive="a:" or ReadOnly = TRUE'?  Again, to satisfy this 
//            query, we're going to have to walk all the instances on all the drives anyway since there 
//            is no way to specify to the Win32 API's that you only want ReadOnly files.  Since Winmgmt 
//            already has a bunch of code to process instances against queries, there's no reason to add 
//            that complexity to our provider UNLESS we are getting a big performance win.  If we send 
//            back a few too many instances, winmgmt will trim them out.

//            For most classes, there are a few (sometimes only 1) properties that it makes sense to 
//            try to optimize on (CIM_Datafile actually does a bunch, but many other classes that process 
//            queries only do 1-2).

//            So, there is a method that can be run against the CFrameworkQuery object where you pass it 
//            the name of a property, and it will tell you all the values they requested.  For example, 
//            if the query is of the form 'Select * from Reindeer where name = "Dasher" or 
//            name = "Dancer" or name = "pickle"', GetValuesForProp(L"Name") would send back an array 
//            that contains {"Dasher", "Dancer", "pickle"}.  Or if the query was of the form 'Select * 
//            from CIM_Datafile where Drive = "a:" AND ReadOnly = TRUE' (note that this query, unlike 
//            the one in the paragraph above, uses AND), then GetValuesForProp(L"Drive") would 
//            return {"a:"}.  Given this array, you can quickly return just the few instances they 
//            requested.  If there are additional clauses on the query that you didn't process, (like 
//            the Drive AND ReadOnly example above), don't worry.  Winmgmt will discard the instances 
//            that don't match.

// In your provider, you can use either, neither, or both of these methods.  In the code below, 
// both methods are illustrated.

   DWORD dwRequiredProperties = 0;
   CHStringArray asNames;
   HRESULT hRes = WBEM_S_NO_ERROR;

   // Part of Method 2
   Query.GetValuesForProp(pName, asNames);

   BOOL bGetAllInstances = asNames.GetSize() == 0;

   // Used by Method 1
   if (Query.IsPropertyRequired(pWeight))
       dwRequiredProperties |= BIT_WEIGHT;

   if (Query.IsPropertyRequired(pRedNose))
       dwRequiredProperties |= BIT_REDNOSE;

    // walk through all the reindeer
   for (int i = 0; (i < Deers::NDeers) && (SUCCEEDED(hRes)); i++)
   {
       // we don't want to return deleted deer
       if (!ohDeers[i].m_deleted)
       {
           // Method 2 - Check to see if the query CAN be processed by 'name', if so,
           // only return those names.
           if (bGetAllInstances || IsInList(asNames, ohDeers[i].m_name))
           {
               // Note that CreateNewInstance may throw, but will never return NULL.
               CInstance *pInstance = CreateNewInstance(pMethodContext);

               // Always set the key property
               pInstance->SetCHString(pName, CHString(ohDeers[i].m_name));

               if (SUCCEEDED(LoadPropertyValues(pInstance, i, dwRequiredProperties)))
               {
                   hRes = pInstance->Commit();
               }

               pInstance->Release();
           }
       }
   }

   return hRes;
}

/*****************************************************************************
*
*  FUNCTION    : CReindeer::LoadPropertyValues
*
*  DESCRIPTION :    This routine was NOT created by the code generator.  It
*                   was hand edited into this file.  Creating this routines 
*                   saves us from having to have these pInstance->Set lines 
*                   in three different routines (EnumerateInstances, 
*                   GetObject, ExecQuery).
*
*  INPUTS      :    - A pointer to a CInstance object to populate
*                   - A DWORD that is the index into ohDeers of the entry to 
*                   populate.  For a more useful class, this might be a pointer
*                   to a structure from which we extract the information.
*                   - A DWORD that is a bitmask indicating which properties 
*                   to populate.
*
*  RETURNS     :    WBEM_S_NO_ERROR if instance is properly populated
*
*  COMMENTS    : 
*
*****************************************************************************/
HRESULT CReindeer::LoadPropertyValues( CInstance *pInstance, DWORD dwIndex, DWORD dwRequiredProperties)
{
   if (dwRequiredProperties & BIT_WEIGHT)
       pInstance->SetDWORD(pWeight,  ohDeers[dwIndex].m_weight);
   
   if (dwRequiredProperties & BIT_REDNOSE)
       pInstance->Setbool(pRedNose,  ohDeers[dwIndex].m_redNose);

   return WBEM_S_NO_ERROR;
}
                   
/*****************************************************************************
*
*  FUNCTION    : CReindeer::PutInstance
*
*  DESCRIPTION :    PutInstance should be used in provider classes that can 
*                   write instance information back to the hardware or 
*                   software.  For example: Win32_Environment will allow a 
*                   PutInstance to create or update an environment variable.  
*                   However, a class like MotherboardDevice will not allow 
*                   editing of the number of slots, since it is difficult for 
*                   a provider to affect that number.
*
*  INPUTS      :    A pointer to a CInstance object containing the key properties. 
*                   A long that contains the flags described in 
*                   IWbemServices::PutInstanceAsync.  
*
*  RETURNS     :    WBEM_E_PROVIDER_NOT_CAPABLE if PutInstance is not available
*                   WBEM_E_FAILED if there is an error delivering the instance
*                   WBEM_E_INVALID_PARAMETER if any of the instance properties 
*                   are incorrect.
*                   WBEM_S_NO_ERROR if instance is properly delivered
*
*  COMMENTS    : TO DO: If you don't intend to support writing to your provider, 
*                       or are creating a 'method only' provider, remove this 
*                       method.
*
*****************************************************************************/
HRESULT CReindeer::PutInstance ( const CInstance &Instance, long lFlags)
{
    HRESULT hresult = WBEM_E_INVALID_PARAMETER;

    // we do not create reindeer here.
    if (lFlags & WBEM_FLAG_CREATE_ONLY) 
        hresult = WBEM_E_UNSUPPORTED_PARAMETER;
    else
    {
        // get the key value so we can tell which reindeer we're operating on
        CHString name;
        Instance.GetCHString(pName, name);
        for (int i = 0; i < Deers::NDeers; i++) 
        {
            if (0 == name.CompareNoCase(CHString(ohDeers[i].m_name)) && !ohDeers[i].m_deleted)
            {
                // we found one, we can change the red nose and/or the weight properties
                DWORD weight;
                bool  redNoze;

                if (Instance.GetDWORD(pWeight,  weight))
                    ohDeers[i].m_weight = weight;

                if (Instance.Getbool(pRedNose, redNoze))
                    ohDeers[i].m_redNose = redNoze;

                hresult = WBEM_S_NO_ERROR;
                break;
            }
        }

        if (FAILED(hresult))
        {
            // If they said they wanted to update, but it wasn't there
            if (lFlags & WBEM_FLAG_UPDATE_ONLY)
            {
                hresult = WBEM_E_NOT_FOUND;
            }
        }
    }

    return hresult; 
}

/*****************************************************************************
*
*  FUNCTION    :    CReindeer::DeleteInstance
*
*  DESCRIPTION :    DeleteInstance, like PutInstance, actually writes information
*                   to the software or hardware.   For most hardware devices, 
*                   DeleteInstance should not be implemented, but for software
*                   configuration, DeleteInstance implementation is plausible.
*
*  INPUTS      :    A pointer to a CInstance object containing the key properties. 
*                   A long that contains the flags described in 
*                   IWbemServices::DeleteInstanceAsync.  
*
*  RETURNS     :    WBEM_E_PROVIDER_NOT_CAPABLE if DeleteInstance is not available.
*                   WBEM_E_FAILED if there is an error deleting the instance.
*                   WBEM_E_INVALID_PARAMETER if any of the instance properties 
*                   are incorrect.
*                   WBEM_S_NO_ERROR if instance is properly deleted.
*
*  COMMENTS    : TO DO: If you don't intend to support deleting instances or are
*                       creating a 'method only' provider, remove this method.
*
*****************************************************************************/
HRESULT CReindeer::DeleteInstance ( const CInstance &Instance, long lFlags )
{
    HRESULT hresult = WBEM_E_NOT_FOUND;

    // get the key value so we can tell which reindeer we're operating on
    CHString name;
    Instance.GetCHString(pName, name);

    // see if we can find the deer we want,
    // note that we won't delete one that's already been deleted
    for (int i = 0; i < Deers::NDeers; i++) 
    {
        if (0 == name.CompareNoCase(ohDeers[i].m_name)) 
        {
            if (!ohDeers[i].m_deleted)
            {
                // we found it - mark as deleted 
                ohDeers[i].m_deleted = true;
                hresult = WBEM_S_NO_ERROR;
                break;
            }
            else
            {
                // Ok, this is a bit of a stretch, but I want to be able
                // to show how to report errors using an error object.

                // This code is entered if the same reindeer is deleted
                // twice in a row.  If this deletion is done in wbemtest, 
                // a dialog with a 'More Info' button will be displayed.  
                // Clicking this button will show the object we are 
                // populating here.
                CHString sRelPath;

                Instance.GetCHString(L"__RelPath", sRelPath);
                CInstance *pErrorInstance = NULL;

                // First, get a status object
                CWbemProviderGlue::GetInstanceByPath(pErrorClass, &pErrorInstance);

                // Now, populate it
                pErrorInstance->SetWCHARSplat(L"Operation", L"DeleteInstance");
                pErrorInstance->SetCHString(L"ParameterInfo", sRelPath);
                pErrorInstance->SetWCHARSplat(L"ProviderName", PROVIDER_NAME_REINDEERPROV);
                pErrorInstance->SetDWORD(L"StatusCode", WBEM_E_NOT_FOUND);
                pErrorInstance->SetCHString(L"ReindeerName", name);

                pErrorInstance->SetWCHARSplat(L"Description", 
                    L"Attempt to delete reindeer that has already been deleted");

                // Get the actual IWbemClassObject pointer
                IWbemClassObject *pObj = pErrorInstance->GetClassObjectInterface();

                // Note that no Release() is required for this
                MethodContext *pMethodContext = Instance.GetMethodContext();  

                // Set the status object
                pMethodContext->SetStatusObject(pObj);

                // Cleanup
                pObj->Release();
                pErrorInstance->Release();

                break;
            }
        }
    }

    return hresult;
}

/*****************************************************************************
*
*  FUNCTION    :    CReindeer::ExecMethod
*
*  DESCRIPTION :    Override this function to provide support for methods.  
*                   A method is an entry point for the user of your provider 
*                   to request your class perform some function above and 
*                   beyond a change of state.  (A change of state should be 
*                   handled by PutInstance() )
*
*  INPUTS      :    A pointer to a CInstance containing the instance the method was executed against.
*                   A string containing the method name
*                   A pointer to the CInstance which contains the IN parameters.
*                   A pointer to the CInstance to contain the OUT parameters.
*                   A set of specialized method flags
*
*  RETURNS     :    WBEM_E_PROVIDER_NOT_CAPABLE if not implemented for this class
*                   WBEM_S_NO_ERROR if method executes successfully
*                   WBEM_E_FAILED if error occurs executing method 
*
*  COMMENTS    : TO DO: If you don't intend to support Methods, remove this method.
*
*****************************************************************************/
HRESULT CReindeer::ExecMethod ( const CInstance& Instance,
                        const BSTR bstrMethodName,
                        CInstance *pInParams,
                        CInstance *pOutParams,
                        long lFlags
)
{
    // Note that there are two status codes involved here.  The hresult,
    // which is the return code for the function, indicates whether the method
    // was successfully invoked.  Then there is the hStatusCode which is used
    // to indicate whether the function did what it was asked to do.  
    
    // hStatusCode will end up being the uint32 return code, and can be seen in the
    // 'Edit Out Parameters' box in wbemtest after executing this method.

    HRESULT hresult = WBEM_E_PROVIDER_NOT_CAPABLE;
    HRESULT hStatusCode = WBEM_E_NOT_FOUND;

    // Make sure we recognize the method they are requesting
    if (_wcsicmp(bstrMethodName, L"Undelete") == 0)
    {
        // The method we implement here is declared as:

	    //	[Implemented, static, Description(
	    //	"The Undelete method will set the Deleted flag for the specified"
        //    "reindeer back to false.  Returns WBEM_S_NO_ERROR if succeeded, 
        //    WBEM_E_NOT_FOUND if the Reindeer is not in the list, or WBEM_S_FALSE
        //    if the reindeer was not already marked as deleted.")]
        // uint32 Undelete([In] string ReindeerName) ;

        hresult = WBEM_S_NO_ERROR;

        // get the key value so we can tell which reindeer we're operating on
        CHString name;
        pInParams->GetCHString(L"ReindeerName", name);

        // see if we can find the deer we want,
        for (int i = 0; i < Deers::NDeers; i++) 
        {
            if (0 == name.CompareNoCase(ohDeers[i].m_name)) 
            {
                if (!ohDeers[i].m_deleted)
                {
                    // It wasn't deleted.  Set the appropriate code
                    hStatusCode = WBEM_S_FALSE;
                    break;
                }
                else
                {
                    // It was deleted, so undelete it, and set the
                    // error code.
                    ohDeers[i].m_deleted = false;
                    hStatusCode = WBEM_S_NO_ERROR;
                }
            }
        }

        // put the result code back in the structure.
        pOutParams->SetDWORD(L"ReturnValue", hStatusCode);
    } 
    else if (_wcsicmp(bstrMethodName, L"Rename") == 0)
    {
        // The method we implement here is declared as:

        //        [Implemented, Description(
        //        "The Rename method will change the name of the reindeer it is run"
        //        "against.")]
        //    uint32 Rename([In] string NewReindeerName) ;

        hresult = WBEM_S_NO_ERROR;

        // get the key value so we can tell which reindeer we're operating on
        CHString sNewName, sCurName;
        Instance.GetCHString(L"name", sCurName);  // Old name

        if (!pInParams->IsNull(L"NewReindeerName"))
        {
            pInParams->GetCHString(L"NewReindeerName", sNewName); // New name
        }

        // No name was specified or a blank name was specified.
        if (!sNewName.IsEmpty())
        {
            // see if we can find the deer we want,
            for (int i = 0; i < Deers::NDeers; i++) 
            {
                if (0 == sCurName.CompareNoCase(ohDeers[i].m_name)) 
                {
                    if (!ohDeers[i].m_deleted)
                    {
                        ohDeers[i].m_name = sNewName.AllocSysString();
                        hStatusCode = WBEM_S_NO_ERROR;
                        break;
                    }
                }
            }
        }
        else
        {
            hStatusCode = WBEM_E_INVALID_PARAMETER;
        }

        // put the result code back in the structure.
        pOutParams->SetDWORD(L"ReturnValue", hStatusCode);
    }

    // Shows how to use the GetInstancesByQuery method.  The error reporting is a little light,
    // but I didn't want obscure the GetInstancesByQuery function with a whole bunch of other
    // stuff.
    else if (_wcsicmp(bstrMethodName, L"CalcWeight") == 0)
    {
        // The method we implement here is declared as:

        //        [Implemented, static, Description(
        //        "The CalcWeight method will compute the total weight of all "
        //        "the reindeer.  It will return the total weight, or 0xffffffff "
        //        "on error.")]
        //    uint32 CalcWeight() ;

        TRefPointerCollection<CInstance>    ReindeerList;

        // Get a method context pointer off the CInstance
        MethodContext *pMethodContext = Instance.GetMethodContext();

        // Run the query.  While I'm not using a WHERE clause here, I certainly could.  Note 
        // that the ReindeerList is a collection of CInstances.  As such, it can get VERY large
        // depending on the number of instances, and the size of the instances.  If you are
        // going to be hitting a big class, consider the GetInstancesByQueryAsynch function
        // instead.
        if (SUCCEEDED(hresult = CWbemProviderGlue::GetInstancesByQuery(L"SELECT Weight FROM Reindeer",
                                            &ReindeerList,
                                            pMethodContext,
                                            L"root\\default")))
        {
            REFPTRCOLLECTION_POSITION   pos;

            // Initialize the enum
            if ( ReindeerList.BeginEnum( pos ) )
            {

                // Set some vars
                CInstance *pReindeer;
                DWORD dwWeight, dwTotWeight = 0;

                // Walk the enum.  Note the pReindeer must be released when
                // we are done with it.
                while (pReindeer = ReindeerList.GetNext(pos))
                {
                    if (pReindeer->GetDWORD(pWeight, dwWeight))
                    {
                        dwTotWeight += dwWeight;
                    }

                    pReindeer->Release();
                }

                ReindeerList.EndEnum();

                // Set the out parameter, and we're done
                pOutParams->SetDWORD(L"ReturnValue", dwTotWeight);
            }
            else
            {
                pOutParams->SetDWORD(L"ReturnValue", 0xffffffff);
            }
        }
        else
        {
            pOutParams->SetDWORD(L"ReturnValue", 0xffffffff);
        }
    }
    else if (_wcsicmp(bstrMethodName, L"CalcWeightNonRed") == 0)
    {
        //        [Implemented, static, Description(
        //        "The CalcWeightNonRed method will compute the total weight of all "
        //        "the reindeer that don't have a red nose.  It will return the total "
        //        "weight, or 0xffffffff on error.")]
        //    uint32 CalcWeightNonRed() ;

        // This time we're going to use the Asynch version of GetInstancesByQuery.
        // See EnumerationCallback for discussion.

        // Get a method context pointer off the CInstance
        MethodContext *pMethodContext = Instance.GetMethodContext();

        DWORD dwTotWeight = 0;

   	    hresult = CWbemProviderGlue::GetInstancesByQueryAsynch(
                                        L"Select Weight FROM Reindeer WHERE RedNose = FALSE", 
                                        this, 
                                        StaticEnumerationCallback, 
                                        L"Root\\Default", 
                                        pMethodContext, 
                                        &dwTotWeight);

        if (SUCCEEDED(hresult))
        {
            pOutParams->SetDWORD(L"ReturnValue", dwTotWeight);
        }
        else
        {
            pOutParams->SetDWORD(L"ReturnValue", 0xffffffff);
        }
    }

    return hresult;
}

BOOL CReindeer::IsInList(const CHStringArray &asArray, LPCWSTR pszString)
{
    DWORD dwSize = asArray.GetSize();

    for (DWORD x=0; x < dwSize; x++)
    {
        if (asArray[x].CompareNoCase(pszString) == 0)
        {
            return TRUE;
        }
    }

    return FALSE;
}

/*****************************************************************************
 *
 *  FUNCTION    : CReindeer::StaticEnumerationCallback
 *
 *  DESCRIPTION : Called from GetAllInstancesAsynch as a wrapper to EnumerationCallback
 *
 *  INPUTS      : 
 *
 *  OUTPUTS     : 
 *
 *  RETURNS     : 
 *
 *  COMMENTS    : 
 *
 *****************************************************************************/
HRESULT WINAPI CReindeer::StaticEnumerationCallback(
                                                    
    Provider* pThat, 
    CInstance* pInstance, 
    MethodContext* pContext, 
    void* pUserData) 
{
    CReindeer* pThis;
    HRESULT hr;

	pThis = static_cast<CReindeer *>(pThat);

	if (pThis)
		hr = pThis->EnumerationCallback(pInstance, pContext, pUserData);
    else
        hr = WBEM_E_FAILED;

    return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : CReindeer::EnumerationCallback
 *
 *  DESCRIPTION : Called from GetAllInstancesAsynch via StaticEnumerationCallback
 *
 *  INPUTS      : (see CWbemProviderGlue::GetAllInstancesAsynch)
 *
 *  OUTPUTS     : 
 *
 *  RETURNS     : 
 *
 *  COMMENTS    : If we wanted to, this routine could create/commit instances.  We
 *                have a pMethodContext, all we'd need to do is 
 *                pInstance = CreateNewInstance(pMethodContext)
 *
 *                However, since in Reindeer this routine is being called from ExecMethod, 
 *                that really doesn't make any sense.  But if we were writing
 *                an association class between User and Group, we could do a query
 *                like "SELECT Domain, Name, SidType from Win32_Group", and 'asynchronously'
 *                call a routine just like this that took the group name, called the Win32 
 *                api's to find out what users were in that group, and create/commit
 *                instances.  If we did do that, then the return value from this function
 *                should be set to the return value of the Commit() call.  That way, if
 *                the client cancels the enumeration, everything will cancel correctly.
 *
 *                The benefit to using these 'Asynch' functions is that instances
 *                would start appearing at the client sooner.  After all, if we called
 *                the GetInstancesByQuery, that function wouldn't return until it had
 *                ALL the groups stored in the TRefPointerCollection.  This could take
 *                a while if many groups are defined.  Further, the TRefPointerCollection
 *                could consume a great deal of memory.
 *
 *****************************************************************************/
HRESULT CReindeer::EnumerationCallback(
                                       
    CInstance *pReindeer, 
    MethodContext *pMethodContext, 
    VOID *pTotWeight
)
{
    DWORD dwWeight;
    LPDWORD pdwTotWeight = (LPDWORD)pTotWeight;

    if (pReindeer->GetDWORD(pWeight, dwWeight))
    {
        *pdwTotWeight += dwWeight;
    }

    return WBEM_S_NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\frameworkprov\maindll.cpp ===
//***************************************************************************

//

//  MAINDLL.CPP

// 

//  Module: WMI Framework Instance provider 

//

//  Purpose: Contains DLL entry points.  Also has code that controls

//           when the DLL can be unloaded by tracking the number of

//           objects and locks as well as routines that support

//           self registration.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <FWcommon.h>
#include <objbase.h>
#include <initguid.h>

HMODULE ghModule;
//============

WCHAR *GUIDSTRING = L"{9a5dd473-d410-11d1-b829-00c04f94c7c3}";
CLSID CLSID_CIM_REINDEER;

//Count number of objects and number of locks.
long g_cLock=0;

//***************************************************************************
//
//  DllGetClassObject
//
//  Purpose: Called by Ole when some client wants a class factory.  Return 
//           one only if it is the sort of class this DLL supports.
//
//***************************************************************************

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, PPVOID ppv)
{
    HRESULT hr;
    CWbemGlueFactory *pObj;

    CLSIDFromString(GUIDSTRING, &CLSID_CIM_REINDEER);
    if (CLSID_CIM_REINDEER!=rclsid)
        return E_FAIL;

    pObj=new CWbemGlueFactory();

    if (NULL==pObj)
        return E_OUTOFMEMORY;

    hr=pObj->QueryInterface(riid, ppv);

    if (FAILED(hr))
        delete pObj;

    return hr;
}

//***************************************************************************
//
// DllCanUnloadNow
//
// Purpose: Called periodically by Ole in order to determine if the
//          DLL can be freed.
//
// Return:  S_OK if there are no objects in use and the class factory 
//          isn't locked.
//
//***************************************************************************

STDAPI DllCanUnloadNow(void)
{
    SCODE   sc;

    // It is OK to unload if there are no objects or locks on the 
    // class factory and the framework is done with you.
    
    if ((0L==g_cLock) && CWbemProviderGlue::FrameworkLogoffDLL(L"ReindeerProv"))
    {
        sc = S_OK;
    }
    else
    {
        sc = S_FALSE;
    }
    return sc;
}

//***************************************************************************
//
//  Is4OrMore
//
//  Returns true if win95 or any version of NT > 3.51
//
//***************************************************************************

BOOL Is4OrMore(void)
{
    OSVERSIONINFO os;

    os.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if(!GetVersionEx(&os))
        return FALSE;           // should never happen

    return os.dwMajorVersion >= 4;
}

//***************************************************************************
//
// DllRegisterServer
//
// Purpose: Called during setup or by regsvr32.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllRegisterServer(void)
{   
    char       szID[128];
    WCHAR      wcID[128];
    char       szCLSID[128];
    char       szModule[MAX_PATH];
    char * pName = "Sample provider using the Provider Framework";
    char * pModel;
    HKEY hKey1, hKey2;

    // TO DO: Using 'Both' is preferable.  The framework is designed and written to support
    // free threaded code.  If you will be writing free-threaded code, uncomment these 
    // three lines.

    // Since Reindeer is free threaded, these lines have been uncommented

    if(Is4OrMore())
        pModel = "Both";
    else
        pModel = "Apartment";

    // Create the path.

    CLSIDFromString(GUIDSTRING, &CLSID_CIM_REINDEER);
    StringFromGUID2(CLSID_CIM_REINDEER, wcID, 128);
    wcstombs(szID, wcID, 128);
    lstrcpy(szCLSID, TEXT("SOFTWARE\\CLASSES\\CLSID\\"));
    lstrcat(szCLSID, szID);

    // Create entries under CLSID

    RegCreateKey(HKEY_LOCAL_MACHINE, szCLSID, &hKey1);
    RegSetValueEx(hKey1, NULL, 0, REG_SZ, (BYTE *)pName, lstrlen(pName)+1);
    RegCreateKey(hKey1,"InprocServer32",&hKey2);

    GetModuleFileName(ghModule, szModule,  MAX_PATH);
    RegSetValueEx(hKey2, NULL, 0, REG_SZ, (BYTE *)szModule, 
                                        lstrlen(szModule)+1);
    RegSetValueEx(hKey2, "ThreadingModel", 0, REG_SZ, 
                                        (BYTE *)pModel, lstrlen(pModel)+1);
    CloseHandle(hKey1);
    CloseHandle(hKey2);

    return NOERROR;
}

//***************************************************************************
//
// DllUnregisterServer
//
// Purpose: Called when it is time to remove the registry entries.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllUnregisterServer(void)
{
    char       szID[128];
    WCHAR      wcID[128];
    char  szCLSID[128];
    HKEY hKey;

    // Create the path using the CLSID

    CLSIDFromString(GUIDSTRING, &CLSID_CIM_REINDEER);
    StringFromGUID2(CLSID_CIM_REINDEER, wcID, 128);
    wcstombs(szID, wcID, 128);
    lstrcpy(szCLSID, TEXT("SOFTWARE\\CLASSES\\CLSID\\"));
    lstrcat(szCLSID, szID);

    // First delete the InProcServer subkey.

    DWORD dwRet = RegOpenKey(HKEY_LOCAL_MACHINE, szCLSID, &hKey);
    if(dwRet == NO_ERROR)
    {
        RegDeleteKey(hKey, "InProcServer32");
        CloseHandle(hKey);
    }

    dwRet = RegOpenKey(HKEY_LOCAL_MACHINE, TEXT("SOFTWARE\\CLASSES\\CLSID\\"), &hKey);
    if(dwRet == NO_ERROR)
    {
        RegDeleteKey(hKey,szID);
        CloseHandle(hKey);
    }

    return NOERROR;
}

//***************************************************************************
//
// DllMain
//
// Purpose: Called by the operating system when processes and threads are 
//          initialized and terminated, or upon calls to the LoadLibrary 
//          and FreeLibrary functions
//
// Return:  TRUE if load was successful, else FALSE
//***************************************************************************

BOOL APIENTRY DllMain ( HINSTANCE hInstDLL, // handle to dll module
                        DWORD fdwReason,    // reason for calling function
                        LPVOID lpReserved   )   // reserved
{
    BOOL bRet = TRUE;
    
    // Perform actions based on the reason for calling.
    switch( fdwReason ) 
    { 
        case DLL_PROCESS_ATTACH:
    // TO DO: Consider adding DisableThreadLibraryCalls().
            DisableThreadLibraryCalls(hInstDLL);

         // Initialize once for each new process.
         // Return FALSE to fail DLL load.
            ghModule = hInstDLL;
            bRet = CWbemProviderGlue::FrameworkLoginDLL(L"ReindeerProv");
            break;

        case DLL_THREAD_ATTACH:
         // Do thread-specific initialization.
            break;

        case DLL_THREAD_DETACH:
         // Do thread-specific cleanup.
            break;

        case DLL_PROCESS_DETACH:
         // Perform any necessary cleanup.
            break;
    }

    return bRet;  // Sstatus of DLL_PROCESS_ATTACH.
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\frameworkprov\frameworkprov.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
/******************************************************************

   FrameworkProv.H -- WMI provider class definition

   Generated by Microsoft WMI Code Generation Engine
 
   Description: 
   Sample provider using the Provider Framework

*******************************************************************/

// Property set identification
//============================

#define PROVIDER_NAME_REINDEERPROV L"Reindeer"

// Property name externs -- defined in FrameworkProv.cpp
//=================================================

extern const WCHAR* pName ;
extern const WCHAR* pRedNose ;
extern const WCHAR* pWeight ;

class CReindeer : public Provider 
{
	public:
		// Constructor/destructor
		//=======================

		CReindeer(LPCWSTR chsClassName, LPCWSTR lpszNameSpace);
		virtual ~CReindeer();

	protected:
		// Reading Functions
		//============================
		virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
		virtual HRESULT GetObject(CInstance* pInstance, long lFlags = 0L);
		virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags = 0L);

		// Writing Functions
		//============================
		virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L);
		virtual HRESULT DeleteInstance(const CInstance& Instance, long lFlags = 0L);

		// Other Functions
		virtual HRESULT ExecMethod( const CInstance& Instance,
						const BSTR bstrMethodName,
						CInstance *pInParams,
						CInstance *pOutParams,
						long lFlags = 0L );

		// TO DO: Declare any additional functions and accessor
		// functions for private data used by this class
		//===========================================================
        HRESULT LoadPropertyValues( CInstance *pInstance, DWORD dwIndex, DWORD dwRequiredProperties);

	private:
		// All data members for CReindeer should be included here.   
        BOOL IsInList(const CHStringArray &asArray, LPCWSTR pszString);
        static HRESULT WINAPI StaticEnumerationCallback(Provider* pThat, CInstance* pInstance, MethodContext* pContext, void* pUserData);
        HRESULT EnumerationCallback(CInstance *pReindeer, MethodContext *pMethodContext, VOID *pTotWeight);

} ;

// struct to hold instance information
struct Deers
{
	WCHAR*    m_name;	// name of Reindeer
	DWORD    m_weight;  // weight of reindeer
	bool     m_redNose; // does he have a red nose?
	bool     m_deleted; // has he been deleted?

	enum {NDeers = 9};
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\instprov\makefile.inc ===
$(O)\makefile : makefile.nm
	copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\instprov\classfac.cpp ===
//***************************************************************************

//

//  CLASSFAC.CPP

//

//  Module: WMI Instance provider sample code

//

//  Purpose: Contains the class factory.  This creates objects when

//           connections are requested.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <objbase.h>
#include "sample.h"

//***************************************************************************
//
// CProvFactory::CProvFactory
// CProvFactory::~CProvFactory
//
// Constructor Parameters:
//  None
//***************************************************************************

CProvFactory::CProvFactory()
{
    m_cRef=0L;
    return;
}

CProvFactory::~CProvFactory(void)
{
    return;
}

//***************************************************************************
//
// CProvFactory::QueryInterface
// CProvFactory::AddRef
// CProvFactory::Release
//
// Purpose: Standard Ole routines needed for all interfaces
//
//***************************************************************************


STDMETHODIMP CProvFactory::QueryInterface(REFIID riid
    , PPVOID ppv)
{
    *ppv=NULL;

    if (IID_IUnknown==riid || IID_IClassFactory==riid)
        *ppv=this;

    if (NULL!=*ppv)
        {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
        }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CProvFactory::AddRef(void)
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CProvFactory::Release(void)
{
    ULONG nNewCount = InterlockedDecrement((long *)&m_cRef);
    if (0L == nNewCount)
        delete this;
    
    return nNewCount;
}

//***************************************************************************
//
// CProvFactory::CreateInstance
//
// Purpose: Instantiates a Locator object returning an interface pointer.
//
// Parameters:
//  pUnkOuter       LPUNKNOWN to the controlling IUnknown if we are
//                  being used in an aggregation.
//  riid            REFIID identifying the interface the caller
//                  desires to have for the new object.
//  ppvObj          PPVOID in which to store the desired
//                  interface pointer for the new object.
//
// Return Value:
//  HRESULT         NOERROR if successful, otherwise E_NOINTERFACE
//                  if we cannot support the requested interface.
//***************************************************************************

STDMETHODIMP CProvFactory::CreateInstance(LPUNKNOWN pUnkOuter
    , REFIID riid, PPVOID ppvObj)
{
    CInstPro *   pObj;
    HRESULT hr;

    *ppvObj=NULL;

    // This object doesnt support aggregation.

    if (NULL!=pUnkOuter)
        return CLASS_E_NOAGGREGATION;

    // Create the locator object.
    
    pObj=new CInstPro();
    if (NULL==pObj)
        return E_OUTOFMEMORY;

    hr=pObj->QueryInterface(riid, ppvObj);

    //Kill the object if initial creation or Init failed.

    if (FAILED(hr))
        delete pObj;
    return hr;
}

//***************************************************************************
//
// CProvFactory::LockServer
//
// Purpose:
//  Increments or decrements the lock count of the DLL.  If the
//  lock count goes to zero and there are no objects, the DLL
//  is allowed to unload.  See DllCanUnloadNow.
//
// Parameters:
//  fLock           BOOL specifying whether to increment or
//                  decrement the lock count.
//
// Return Value:
//  HRESULT         NOERROR always.
//***************************************************************************


STDMETHODIMP CProvFactory::LockServer(BOOL fLock)
{
    if (fLock)
        InterlockedIncrement(&g_cLock);
    else
        InterlockedDecrement(&g_cLock);
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\methcli\makefile.inc ===
$(O)\makefile : makefile.nm
	copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\instprov\instprov.cpp ===
//***************************************************************************

//

//  INSTPRO.CPP

//

//  Module: WMI Instance provider sample code

//

//  Purpose: Defines the CInstPro class.  An object of this class is

//           created by the class factory for each connection.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <objbase.h>
#include "sample.h"
#include <process.h>

InstDef MyDefs[] = {{L"a", 1}, {L"b", 2}, {L"c", 3}};

long glNumInst = sizeof(MyDefs)/sizeof(InstDef);

//***************************************************************************
//
// CInstPro::CInstPro
// CInstPro::~CInstPro
//
//***************************************************************************

CInstPro::CInstPro(BSTR ObjectPath, BSTR User, BSTR Password, IWbemContext * pCtx)
{
    m_pNamespace = NULL;
    m_cRef=0;
    InterlockedIncrement(&g_cObj);
    return;
}

CInstPro::~CInstPro(void)
{
    if(m_pNamespace)
        m_pNamespace->Release();
    InterlockedDecrement(&g_cObj);
    return;
}

//***************************************************************************
//
// CInstPro::QueryInterface
// CInstPro::AddRef
// CInstPro::Release
//
// Purpose: IUnknown members for CInstPro object.
//***************************************************************************


STDMETHODIMP CInstPro::QueryInterface(REFIID riid, PPVOID ppv)
{
    *ppv=NULL;

    // Since we have dual inheritance, it is necessary to cast the return type

    if(riid== IID_IWbemServices)
       *ppv=(IWbemServices*)this;

    if(IID_IUnknown==riid || riid== IID_IWbemProviderInit)
       *ppv=(IWbemProviderInit*)this;
    

    if (NULL!=*ppv) {
        AddRef();
        return NOERROR;
        }
    else
        return E_NOINTERFACE;
  
}


STDMETHODIMP_(ULONG) CInstPro::AddRef(void)
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CInstPro::Release(void)
{
    ULONG nNewCount = InterlockedDecrement((long *)&m_cRef);
    if (0L == nNewCount)
        delete this;
    
    return nNewCount;
}

/***********************************************************************
*                                                                      *
*   CInstPro::Initialize                                                *
*                                                                      *
*   Purpose: This is the implementation of IWbemProviderInit. The method  *
*   is need to initialize with CIMOM.                                    *
*                                                                      *
***********************************************************************/

STDMETHODIMP CInstPro::Initialize(LPWSTR pszUser, LONG lFlags,
                                    LPWSTR pszNamespace, LPWSTR pszLocale,
                                    IWbemServices *pNamespace, 
                                    IWbemContext *pCtx,
                                    IWbemProviderInitSink *pInitSink)
{
    if(pNamespace)
        pNamespace->AddRef();
    m_pNamespace = pNamespace;

    //Let CIMOM know you are initialized
    //==================================
    
    pInitSink->SetStatus(WBEM_S_INITIALIZED,0);
    return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
// CInstPro::CreateInstanceEnumAsync
//
// Purpose: Asynchronously enumerates the instances.  
//
//***************************************************************************

SCODE CInstPro::CreateInstanceEnumAsync( const BSTR RefStr, long lFlags, IWbemContext *pCtx,
       IWbemObjectSink FAR* pHandler)
{
    SCODE sc;
    int iCnt;
    IWbemClassObject FAR* pNewInst;
  
    // Do a check of arguments and make sure we have pointer to Namespace

    if(pHandler == NULL || m_pNamespace == NULL)
        return WBEM_E_INVALID_PARAMETER;

    for(iCnt=0; iCnt < glNumInst; iCnt++)
    {
        sc = CreateInst(m_pNamespace,MyDefs[iCnt].pwcKey,
                    MyDefs[iCnt].lValue, &pNewInst, RefStr, pCtx);
 
        if(sc != S_OK)
            break;

        // Send the object to the caller

        pHandler->Indicate(1,&pNewInst);
        pNewInst->Release();
    }

    // Set status

    pHandler->SetStatus(0,sc,NULL, NULL);

    return sc;
}


//***************************************************************************
//
// CInstPro::GetObjectByPath
// CInstPro::GetObjectByPathAsync
//
// Purpose: Creates an instance given a particular path value.
//
//***************************************************************************



SCODE CInstPro::GetObjectAsync(const BSTR ObjectPath, long lFlags,IWbemContext  *pCtx,
                    IWbemObjectSink FAR* pHandler)
{

    SCODE sc;
    IWbemClassObject FAR* pObj;
    BOOL bOK = FALSE;

    // Do a check of arguments and make sure we have pointer to Namespace

    if(ObjectPath == NULL || pHandler == NULL || m_pNamespace == NULL)
        return WBEM_E_INVALID_PARAMETER;

    // do the get, pass the object on to the notify
    
    sc = GetByPath(ObjectPath,&pObj, pCtx);
    if(sc == S_OK) 
    {
        pHandler->Indicate(1,&pObj);
        pObj->Release();
        bOK = TRUE;
    }

    sc = (bOK) ? S_OK : WBEM_E_NOT_FOUND;

    // Set Status

    pHandler->SetStatus(0,sc, NULL, NULL);

    return sc;
}
 
//***************************************************************************
//
// CInstPro::GetByPath
//
// Purpose: Creates an instance given a particular Path value.
//
//***************************************************************************

SCODE CInstPro::GetByPath(BSTR ObjectPath, IWbemClassObject FAR* FAR* ppObj, IWbemContext  *pCtx)
{
    SCODE sc = S_OK;
    
    int iCnt;

    // do a simple path parse.  The path will look something like
    // InstProvSamp.MyKey="a"
    // Create a test string with just the part between quotes.

    WCHAR wcTest[MAX_PATH+1];
    wcscpy(wcTest,ObjectPath);
    WCHAR * pwcTest, * pwcCompare = NULL;
    int iNumQuotes = 0;
    for(pwcTest = wcTest; *pwcTest; pwcTest++)
        if(*pwcTest == L'\"')
        {
            iNumQuotes++;
            if(iNumQuotes == 1)
            {
                pwcCompare = pwcTest+1;
            }
            else if(iNumQuotes == 2)
            {
                *pwcTest = NULL;
                break;
            }
        }
        else if(*pwcTest == L'.')
            *pwcTest = NULL;    // issolate the class name.
    if(iNumQuotes != 2)
        return WBEM_E_FAILED;

    // check the instance list for a match.

    for(iCnt = 0; iCnt < glNumInst; iCnt++)
    {
        if(!_wcsicmp(MyDefs[iCnt].pwcKey, pwcCompare))
        {
            sc = CreateInst(m_pNamespace,MyDefs[iCnt].pwcKey,
                    MyDefs[iCnt].lValue, ppObj, wcTest, pCtx);
            return sc;
        }
    }

    return WBEM_E_NOT_FOUND;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\instprov\utils.cpp ===
//***************************************************************************

//

//  UTILS.CPP

//

//  Module: WMI Instance provider sample code

//

//  Purpose: General purpose utilities.  

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <objbase.h>
#include "sample.h"


//***************************************************************************
//
// CreateInst
//
// Purpose: Creates a new instance and sets
//          the inital values of the properties.
//
// Return:   S_OK if all is well, otherwise an error code is returned
//
//***************************************************************************

SCODE CreateInst(IWbemServices * pNamespace, LPWSTR pKey, long lVal, 
                                        IWbemClassObject ** pNewInst,
                                        WCHAR * pwcClassName,
										IWbemContext  *pCtx)
{   
    SCODE sc;
    IWbemClassObject * pClass = NULL;
    sc = pNamespace->GetObject(pwcClassName, 0, pCtx, &pClass, NULL);
    if(sc != S_OK)
        return WBEM_E_FAILED;
    sc = pClass->SpawnInstance(0, pNewInst);
    pClass->Release();
    if(FAILED(sc))
        return sc;
    VARIANT v;

    // Set the key property value.

    v.vt = VT_BSTR;
    v.bstrVal = SysAllocString(pKey);
    sc = (*pNewInst)->Put(L"MyKey", 0, &v, 0);
    VariantClear(&v);

    // Set the number property value.

    v.vt = VT_I4;
    v.lVal = lVal;
    sc = (*pNewInst)->Put(L"MyValue", 0, &v, 0);
    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\instprov\maindll.cpp ===
//***************************************************************************

//

//  MAINDLL.CPP

// 

//  Module: WMI Instance provider sample code

//

//  Purpose: Contains DLL entry points.  Also has code that controls

//           when the DLL can be unloaded by tracking the number of

//           objects and locks as well as routines that support

//           self registration.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <objbase.h>
#include <initguid.h>
#include "sample.h"

HMODULE ghModule;

// TODO, GuidGen should be used to generate a unique number for any 
// providers that are going to be used for anything more extensive 
// than just testing.

DEFINE_GUID(CLSID_instprovider,0x22cb8761, 0x914a, 0x11cf, 0xb7, 0x5, 0x0, 0xaa, 0x0, 0x62, 0xcb, 0xb7);
// {22CB8761-914A-11cf-B705-00AA0062CBB7}

//Count number of objects and number of locks.

long       g_cObj=0;
long       g_cLock=0;

//***************************************************************************
//
// LibMain32
//
// Purpose: Entry point for DLL.
//
// Return: TRUE if OK.
//
//***************************************************************************


BOOL WINAPI LibMain32(HINSTANCE hInstance, ULONG ulReason
    , LPVOID pvReserved)
{
    if (DLL_PROCESS_ATTACH==ulReason)
        ghModule = hInstance;
    return TRUE;
}

//***************************************************************************
//
//  DllGetClassObject
//
//  Purpose: Called by Ole when some client wants a class factory.  Return 
//           one only if it is the sort of class this DLL supports.
//
//***************************************************************************


STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, PPVOID ppv)
{
    HRESULT hr;
    CProvFactory *pObj;

    if (CLSID_instprovider!=rclsid)
        return E_FAIL;

    pObj=new CProvFactory();

    if (NULL==pObj)
        return E_OUTOFMEMORY;

    hr=pObj->QueryInterface(riid, ppv);

    if (FAILED(hr))
        delete pObj;

    return hr;
}

//***************************************************************************
//
// DllCanUnloadNow
//
// Purpose: Called periodically by Ole in order to determine if the
//          DLL can be freed.
//
// Return:  S_OK if there are no objects in use and the class factory 
//          isn't locked.
//
//***************************************************************************

STDAPI DllCanUnloadNow(void)
{
    SCODE   sc;

    //It is OK to unload if there are no objects or locks on the 
    // class factory.
    
    sc=(0L==g_cObj && 0L==g_cLock) ? S_OK : S_FALSE;
    return sc;
}

//***************************************************************************
//
// DllRegisterServer
//
// Purpose: Called during setup or by regsvr32.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllRegisterServer(void)
{   
    char       szID[128];
    WCHAR      wcID[128];
    char       szCLSID[128];
    char       szModule[MAX_PATH];
    char * pName = "WMI Sample Instance Provider";
    char * pModel = "Both";
    HKEY hKey1, hKey2;

    // Create the path.

    StringFromGUID2(CLSID_instprovider, wcID, 128);
    wcstombs(szID, wcID, 128);
    lstrcpy(szCLSID, TEXT("Software\\classes\\CLSID\\"));
    lstrcat(szCLSID, szID);

    // Create entries under CLSID

    RegCreateKey(HKEY_LOCAL_MACHINE, szCLSID, &hKey1);
    RegSetValueEx(hKey1, NULL, 0, REG_SZ, (BYTE *)pName, lstrlen(pName)+1);
    RegCreateKey(hKey1,"InprocServer32",&hKey2);

    GetModuleFileName(ghModule, szModule,  MAX_PATH);
    RegSetValueEx(hKey2, NULL, 0, REG_SZ, (BYTE *)szModule, 
                                        lstrlen(szModule)+1);
    RegSetValueEx(hKey2, "ThreadingModel", 0, REG_SZ, 
                                        (BYTE *)pModel, lstrlen(pModel)+1);
    RegCloseKey(hKey1);
    RegCloseKey(hKey2);
    return NOERROR;
}

//***************************************************************************
//
// DllUnregisterServer
//
// Purpose: Called when it is time to remove the registry entries.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllUnregisterServer(void)
{
    char       szID[128];
    WCHAR      wcID[128];
    char  szCLSID[128];
    HKEY hKey;

    // Create the path using the CLSID

    StringFromGUID2(CLSID_instprovider, wcID, 128);
    wcstombs(szID, wcID, 128);
    lstrcpy(szCLSID, TEXT("Software\\classes\\CLSID\\"));
    lstrcat(szCLSID, szID);

    // First delete the InProcServer subkey.

    DWORD dwRet = RegOpenKey(HKEY_LOCAL_MACHINE, szCLSID, &hKey);
    if(dwRet == NO_ERROR)
    {
        RegDeleteKey(hKey, "InProcServer32");
        RegCloseKey(hKey);
    }

    dwRet = RegOpenKey(HKEY_LOCAL_MACHINE, "Software\\classes\\CLSID", &hKey);
    if(dwRet == NO_ERROR)
    {
        RegDeleteKey(hKey,szID);
        RegCloseKey(hKey);
    }

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\methprov\makefile.inc ===
$(O)\makefile : makefile.nm
	copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\instprov\sample.h ===
//***************************************************************************

//

//  sample.h

//

//  Module: WMI Instance provider sample code

//

//  Purpose: Genral purpose include file.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef _sample_H_
#define _sample_H_

#include <wbemprov.h>

typedef LPVOID * PPVOID;

// Provider interfaces are provided by objects of this class
 
class CInstPro : public IWbemServices, public IWbemProviderInit
    {
    protected:
        ULONG              m_cRef;         //Object reference count
        IWbemServices *  m_pNamespace;
     public:
        CInstPro(BSTR ObjectPath = NULL, BSTR User = NULL, BSTR Password = NULL, IWbemContext * pCtx=NULL);
        ~CInstPro(void);

        //Non-delegating object IUnknown

        STDMETHODIMP         QueryInterface(REFIID, PPVOID);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

                //IWbemProviderInit

        HRESULT STDMETHODCALLTYPE Initialize(
             /* [in] */ LPWSTR pszUser,
             /* [in] */ LONG lFlags,
             /* [in] */ LPWSTR pszNamespace,
             /* [in] */ LPWSTR pszLocale,
             /* [in] */ IWbemServices *pNamespace,
             /* [in] */ IWbemContext *pCtx,
             /* [in] */ IWbemProviderInitSink *pInitSink
                        );

        SCODE GetByPath( BSTR Path, IWbemClassObject FAR* FAR* pObj, IWbemContext  *pCtx);

        //IWbemServices  

		  HRESULT STDMETHODCALLTYPE OpenNamespace( 
            /* [in] */ const BSTR Namespace,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CancelAsyncCall( 
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE QueryObjectSink( 
            /* [in] */ long lFlags,
            /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE GetObject( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE GetObjectAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        HRESULT STDMETHODCALLTYPE PutClass( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE PutClassAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE DeleteClass( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE DeleteClassAsync( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CreateClassEnum( 
            /* [in] */ const BSTR Superclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CreateClassEnumAsync( 
            /* [in] */ const BSTR Superclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE PutInstance( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE PutInstanceAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE DeleteInstance( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE DeleteInstanceAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CreateInstanceEnum( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        HRESULT STDMETHODCALLTYPE ExecQuery( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE ExecQueryAsync( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE ExecNotificationQuery( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE ExecMethod( const BSTR, const BSTR, long, IWbemContext*,
            IWbemClassObject*, IWbemClassObject**, IWbemCallResult**) {return WBEM_E_NOT_SUPPORTED;}

        HRESULT STDMETHODCALLTYPE ExecMethodAsync( const BSTR, const BSTR, long, 
            IWbemContext*, IWbemClassObject*, IWbemObjectSink*) {return WBEM_E_NOT_SUPPORTED;}

};

typedef CInstPro *PCInstPro;

// This class is the class factory for CInstPro objects.

class CProvFactory : public IClassFactory
    {
    protected:
        ULONG           m_cRef;

    public:
        CProvFactory(void);
        ~CProvFactory(void);

        //IUnknown members
        STDMETHODIMP         QueryInterface(REFIID, PPVOID);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        //IClassFactory members
        STDMETHODIMP         CreateInstance(LPUNKNOWN, REFIID
                                 , PPVOID);
        STDMETHODIMP         LockServer(BOOL);
    };

typedef CProvFactory *PCProvFactory;



// These variables keep track of when the module can be unloaded

extern long       g_cObj;
extern long       g_cLock;

// General purpose utilities.  

             
SCODE CreateInst( IWbemServices * pNamespace, LPWSTR pKey, long lVal, 
                                             IWbemClassObject ** pNewInst,
                                             WCHAR * pwcClassName,
											 IWbemContext  *pCtx); 

typedef struct {
   WCHAR * pwcKey;
   long lValue;
   } InstDef;

extern InstDef MyDefs[];
extern long glNumInst;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\methcli\methcli.cpp ===
// **************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// File:  methcli.cpp 
//
// Description:
//        WMI Method Client Sample.
//		  This sample shows how to call a method on an object in WMI
//
// History:
//
// **************************************************************************

#include <objbase.h>
#include <windows.h>                                     
#include <stdio.h>
#include <wbemidl.h> 

//***************************************************************************
//
// main
//
// Purpose: Initialized Ole, call the method, and cleanup.
//
//***************************************************************************

BOOL g_bInProc = FALSE;
 
int main(int iArgCnt, char ** argv)
{
    IWbemLocator *pLocator = NULL;
    IWbemServices *pNamespace = 0;
    IWbemClassObject * pClass = NULL;
    IWbemClassObject * pOutInst = NULL;
    IWbemClassObject * pInClass = NULL;
    IWbemClassObject * pInInst = NULL;
  
    BSTR path = SysAllocString(L"root\\default");
    BSTR ClassPath = SysAllocString(L"MethProvSamp");
    BSTR MethodName = SysAllocString(L"Echo");
    BSTR ArgName = SysAllocString(L"sInArg");
    BSTR Text;

    // Initialize COM and connect up to CIMOM

    HRESULT hr = CoInitialize(0);

    HRESULT hres = CoInitializeSecurity	( NULL, -1, NULL, NULL, 									RPC_C_AUTHN_LEVEL_DEFAULT, 
					RPC_C_IMP_LEVEL_IMPERSONATE, 
					NULL, 
					EOAC_NONE, 
					NULL );

    hr = CoCreateInstance(CLSID_WbemLocator, 0, CLSCTX_INPROC_SERVER,
            IID_IWbemLocator, (LPVOID *) &pLocator);
    hr = pLocator->ConnectServer(path, NULL, NULL, NULL, 0, NULL, NULL, &pNamespace);
    printf("\n\nConnectServer returned 0x%x:", hr);
    if(hr != WBEM_S_NO_ERROR)
        return 1;

    // Get the class object

    hr = pNamespace->GetObject(ClassPath, 0, NULL, &pClass, NULL);
    printf("\nGetObject returned 0x%x:", hr);
    if(hr != WBEM_S_NO_ERROR)
        return 1;


    // Get the input argument and set the property

    hr = pClass->GetMethod(MethodName, 0, &pInClass, NULL); 
    printf("\nGetMethod returned 0x%x:", hr);
    if(hr != WBEM_S_NO_ERROR)
        return 1;

    hr = pInClass->SpawnInstance(0, &pInInst);
    printf("\nSpawnInstance returned 0x%x:", hr);
    if(hr != WBEM_S_NO_ERROR)
        return 1;


    VARIANT var;
    var.vt = VT_BSTR;
    var.bstrVal= SysAllocString(L"hello");
    hr = pInInst->Put(ArgName, 0, &var, 0);
    VariantClear(&var);

    // Call the method

    hr = pNamespace->ExecMethod(ClassPath, MethodName, 0, NULL, pInInst, &pOutInst, NULL);
    printf("\nExecMethod returned 0x%x:", hr);
    if(hr != WBEM_S_NO_ERROR)
        return 1;

    
    // Display the results.

    hr = pOutInst->GetObjectText(0, &Text);
    printf("\n\nThe object text of the output object is:\n%S", Text);

    // Free up resources

    SysFreeString(path);
    SysFreeString(ClassPath);
    SysFreeString(MethodName);
    SysFreeString(ArgName);
    SysFreeString(Text);
    pClass->Release();
    pInInst->Release();
    pInClass->Release();
    pOutInst->Release();
    pLocator->Release();
    pNamespace->Release();
    CoUninitialize();
    printf("Terminating normally\n");
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\methprov\classfac.cpp ===
//***************************************************************************

//

//  CLASSFAC.CPP

//

//  Module: WMI method provider sample code

//

//  Purpose: Contains the class factory.  This creates objects when

//           connections are requested.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <objbase.h>
#include "methprov.h"

//***************************************************************************
//
// CProvFactory::CProvFactory
// CProvFactory::~CProvFactory
//
// Constructor Parameters:
//  None
//***************************************************************************

CProvFactory::CProvFactory()
{
    m_cRef=0L;
    return;
}

CProvFactory::~CProvFactory(void)
{
    return;
}

//***************************************************************************
//
// CProvFactory::QueryInterface
// CProvFactory::AddRef
// CProvFactory::Release
//
// Purpose: Standard Ole routines needed for all interfaces
//
//***************************************************************************


STDMETHODIMP CProvFactory::QueryInterface(REFIID riid
    , PPVOID ppv)
{
    *ppv=NULL;

    if (IID_IUnknown==riid || IID_IClassFactory==riid)
        *ppv=this;

    if (NULL!=*ppv)
        {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
        }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CProvFactory::AddRef(void)
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CProvFactory::Release(void)
{
    ULONG nNewCount = InterlockedDecrement((long *)&m_cRef);
    if (0L == nNewCount)
        delete this;
    
    return nNewCount;
}

//***************************************************************************
//
// CProvFactory::CreateInstance
//
// Purpose: Instantiates a Locator object returning an interface pointer.
//
// Parameters:
//  pUnkOuter       LPUNKNOWN to the controlling IUnknown if we are
//                  being used in an aggregation.
//  riid            REFIID identifying the interface the caller
//                  desires to have for the new object.
//  ppvObj          PPVOID in which to store the desired
//                  interface pointer for the new object.
//
// Return Value:
//  HRESULT         NOERROR if successful, otherwise E_NOINTERFACE
//                  if we cannot support the requested interface.
//***************************************************************************

STDMETHODIMP CProvFactory::CreateInstance(LPUNKNOWN pUnkOuter
    , REFIID riid, PPVOID ppvObj)
{
    IWbemProviderInit *   pInit;
    HRESULT hr;

    *ppvObj=NULL;
    hr = E_OUTOFMEMORY;

    // This object doesnt support aggregation.

    if (NULL!=pUnkOuter)
        return CLASS_E_NOAGGREGATION;

    // Create the Initialize object.
    
    pInit=new CMethodPro();

    if (NULL==pInit)
        return E_OUTOFMEMORY;

    hr=pInit->QueryInterface(riid, ppvObj);

    //Kill the object if initial creation or Init failed.

    if (FAILED(hr))
        delete pInit;
    return hr;
}

//***************************************************************************
//
// CProvFactory::LockServer
//
// Purpose:
//  Increments or decrements the lock count of the DLL.  If the
//  lock count goes to zero and there are no objects, the DLL
//  is allowed to unload.  See DllCanUnloadNow.
//
// Parameters:
//  fLock           BOOL specifying whether to increment or
//                  decrement the lock count.
//
// Return Value:
//  HRESULT         NOERROR always.
//***************************************************************************


STDMETHODIMP CProvFactory::LockServer(BOOL fLock)
{
    if (fLock)
        InterlockedIncrement(&g_cLock);
    else
        InterlockedDecrement(&g_cLock);
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\methprov\maindll.cpp ===
//***************************************************************************

//

//  MAINDLL.CPP

// 

//  Module: WMI Method provider sample code

//

//  Purpose: Contains DLL entry points.  Also has code that controls

//           when the DLL can be unloaded by tracking the number of

//           objects and locks as well as routines that support

//           self registration.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <objbase.h>
#include <initguid.h>
#include "methprov.h"

HMODULE ghModule;

// TODO, GuidGen should be used to generate a unique number for any 
// providers that are going to be used for anything more extensive 
// than just testing.
                                 
DEFINE_GUID(CLSID_methodprovider,0xe30ec6a0, 0x23cf, 0x11d1, 0x8f, 0xde, 0x0, 0x0, 0xf8, 0x4, 0xaa, 0x5c);
//{E30EC6A0-23CF-11d1-8FDE-0000F804AA5C}

//Count number of objects and number of locks.

long       g_cObj=0;
long       g_cLock=0;

//***************************************************************************
//
// LibMain32
//
// Purpose: Entry point for DLL.
//
// Return: TRUE if OK.
//
//***************************************************************************


BOOL WINAPI LibMain32(HINSTANCE hInstance, ULONG ulReason
    , LPVOID pvReserved)
{
    if (DLL_PROCESS_DETACH==ulReason)
    {
        return TRUE;
    }
    else
    {
        if (DLL_PROCESS_ATTACH!=ulReason)
            return TRUE;
    }

    ghModule = hInstance;
    return TRUE;
}

//***************************************************************************
//
//  DllGetClassObject
//
//  Purpose: Called by Ole when some client wants a class factory.  Return 
//           one only if it is the sort of class this DLL supports.
//
//***************************************************************************


STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, PPVOID ppv)
{
    HRESULT hr;
    CProvFactory *pObj;

    if (CLSID_methodprovider!=rclsid)
        return E_FAIL;

    pObj=new CProvFactory();

    if (NULL==pObj)
        return E_OUTOFMEMORY;

    hr=pObj->QueryInterface(riid, ppv);

    if (FAILED(hr))
        delete pObj;

    return hr;
}

//***************************************************************************
//
// DllCanUnloadNow
//
// Purpose: Called periodically by Ole in order to determine if the
//          DLL can be freed.
//
// Return:  S_OK if there are no objects in use and the class factory 
//          isn't locked.
//
//***************************************************************************

STDAPI DllCanUnloadNow(void)
{
    SCODE   sc;

    //It is OK to unload if there are no objects or locks on the 
    // class factory.
    
    sc=(0L==g_cObj && 0L==g_cLock) ? S_OK : S_FALSE;
    return sc;
}

//***************************************************************************
//
//  Is4OrMore
//
//  Returns true if win95 or any version of NT > 3.51
//
//***************************************************************************

BOOL Is4OrMore(void)
{
    OSVERSIONINFO os;
    os.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if(!GetVersionEx(&os))
        return FALSE;           // should never happen
    return os.dwMajorVersion >= 4;
}

//***************************************************************************
//
// DllRegisterServer
//
// Purpose: Called during setup or by regsvr32.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllRegisterServer(void)
{   
    char       szID[128];
    WCHAR      wcID[128];
    char       szCLSID[128];
    char       szModule[MAX_PATH];
    char * pName = "WMI Method Provider Test";
    char * pModel;
    HKEY hKey1, hKey2;

    // Normally we want to use "Both" as the threading model since
    // the DLL is free threaded, but NT 3.51 Ole doesnt work unless
    // the model is "Aparment"

    if(Is4OrMore())
        pModel = "Both";
    else
        pModel = "Apartment";

    // Create the path.

    StringFromGUID2(CLSID_methodprovider, wcID, 128);
    wcstombs(szID, wcID, 128);
    lstrcpy(szCLSID, TEXT("CLSID\\"));
    lstrcat(szCLSID, szID);

    // Create entries under CLSID

    RegCreateKey(HKEY_CLASSES_ROOT, szCLSID, &hKey1);
    RegSetValueEx(hKey1, NULL, 0, REG_SZ, (BYTE *)pName, lstrlen(pName)+1);
    RegCreateKey(hKey1,"InprocServer32",&hKey2);

    GetModuleFileName(ghModule, szModule,  MAX_PATH);
    RegSetValueEx(hKey2, NULL, 0, REG_SZ, (BYTE *)szModule, 
                                        lstrlen(szModule)+1);
    RegSetValueEx(hKey2, "ThreadingModel", 0, REG_SZ, 
                                        (BYTE *)pModel, lstrlen(pModel)+1);
    RegCloseKey(hKey1);
    RegCloseKey(hKey2);
    return NOERROR;
}

//***************************************************************************
//
// DllUnregisterServer
//
// Purpose: Called when it is time to remove the registry entries.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllUnregisterServer(void)
{
    char       szID[128];
    WCHAR      wcID[128];
    char  szCLSID[128];
    HKEY hKey;

    // Create the path using the CLSID

    StringFromGUID2(CLSID_methodprovider, wcID, 128);
    wcstombs(szID, wcID, 128);
    lstrcpy(szCLSID, TEXT("CLSID\\"));
    lstrcat(szCLSID, szID);

    // First delete the InProcServer subkey.

    DWORD dwRet = RegOpenKey(HKEY_CLASSES_ROOT, szCLSID, &hKey);
    if(dwRet == NO_ERROR)
    {
        RegDeleteKey(hKey, "InProcServer32");
        RegCloseKey(hKey);
    }

    dwRet = RegOpenKey(HKEY_CLASSES_ROOT, "CLSID", &hKey);
    if(dwRet == NO_ERROR)
    {
        RegDeleteKey(hKey,szID);
        RegCloseKey(hKey);
    }

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\methprov\methprov.cpp ===
//***************************************************************************

//

//  METHPROV.CPP

//

//  Module: WMI Method provider sample code

//

//  Purpose: Defines the CMethodPro class.  An object of this class is

//           created by the class factory for each connection.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <objbase.h>
#include "methprov.h"
#include <process.h>
#include <wbemidl.h>
#include <stdio.h>


//***************************************************************************
//
// CMethodPro::CMethodPro
// CMethodPro::~CMethodPro
//
//***************************************************************************

CMethodPro::CMethodPro()
{
    InterlockedIncrement(&g_cObj);
    return;
   
}

CMethodPro::~CMethodPro(void)
{
    InterlockedDecrement(&g_cObj);
    return;
}

//***************************************************************************
//
// CMethodPro::QueryInterface
// CMethodPro::AddRef
// CMethodPro::Release
//
// Purpose: IUnknown members for CMethodPro object.
//***************************************************************************


STDMETHODIMP CMethodPro::QueryInterface(REFIID riid, PPVOID ppv)
{
    *ppv=NULL;

    if (IID_IUnknown==riid || IID_IWbemServices == riid || IID_IWbemProviderInit==riid)
       if(riid== IID_IWbemServices){
          *ppv=(IWbemServices*)this;
       }

       if(IID_IUnknown==riid || riid== IID_IWbemProviderInit){
          *ppv=(IWbemProviderInit*)this;
       }
    

    if (NULL!=*ppv) {
        AddRef();
        return NOERROR;
        }
    else
        return E_NOINTERFACE;
}


STDMETHODIMP_(ULONG) CMethodPro::AddRef(void)
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CMethodPro::Release(void)
{
    ULONG nNewCount = InterlockedDecrement((long *)&m_cRef);
    if (0L == nNewCount)
        delete this;
    
    return nNewCount;
}

/***********************************************************************
*                                                                      *
*CMethodPro::Initialize                                                *
*                                                                      *
*Purpose: This is the implementation of IWbemProviderInit. The method  *
* is need to initialize with CIMOM.                                    *
*                                                                      *
***********************************************************************/
STDMETHODIMP CMethodPro::Initialize(LPWSTR pszUser, LONG lFlags,
                                    LPWSTR pszNamespace, LPWSTR pszLocale,
                                    IWbemServices *pNamespace, 
                                    IWbemContext *pCtx,
                                    IWbemProviderInitSink *pInitSink)
{

   
   m_pWbemSvcs=pNamespace;
   m_pWbemSvcs->AddRef();
   
    //Let CIMOM know your initialized
    //===============================
    pInitSink->SetStatus(WBEM_S_INITIALIZED,0);
    return WBEM_S_NO_ERROR;
}



/************************************************************************
*                                                                       *      
*CMethodPro::ExecMethodAsync                                            *
*                                                                       *
*Purpose: This is the Async function implementation.                    *
*         The only method supported in this sample is named Echo.  It   * 
*         takes an input string, copies it to the output and returns the* 
*         length.  The mof definition is                                *
*                                                                       *
*    [dynamic: ToInstance, provider("MethProv")]class MethProvSamp      *
*    {                                                                  *
*         [implemented, static]                                         *
*            uint32 Echo([IN]string sInArg="default",                   *
*                [out] string sOutArg);                                 *
*    };                                                                 *
*                                                                       *
************************************************************************/

STDMETHODIMP CMethodPro::ExecMethodAsync(const BSTR ObjectPath, const BSTR MethodName, 
            long lFlags, IWbemContext* pCtx, IWbemClassObject* pInParams, 
            IWbemObjectSink* pResultSink)
{
    HRESULT hr;    
    IWbemClassObject * pClass = NULL;
    IWbemClassObject * pOutClass = NULL;    
    IWbemClassObject* pOutParams = NULL;
 
    // Do some minimal error checking.  This code only support the
    // method "Echo" as defined in the mof.  A routine could support
    // more than on method

    if(_wcsicmp(MethodName, L"Echo"))
        return WBEM_E_INVALID_PARAMETER;

    // Allocate some BSTRs
    
    BSTR ClassName = SysAllocString(L"MethProvSamp");    
    BSTR InputArgName = SysAllocString(L"sInArg");
    BSTR OutputArgName = SysAllocString(L"sOutArg");
    BSTR retValName = SysAllocString(L"ReturnValue");

    // Get the class object, this is hard coded and matches the class
    // in the MOF.  A more sophisticated example would parse the 
    // ObjectPath to determine the class and possibly the instance.

    hr = m_pWbemSvcs->GetObject(ClassName, 0, pCtx, &pClass, NULL);
	if(hr != S_OK)
	{
		 pResultSink->SetStatus(0,hr, NULL, NULL);
		 return WBEM_S_NO_ERROR;
	}
 

    // This method returns values, and so create an instance of the
    // output argument class.

    hr = pClass->GetMethod(MethodName, 0, NULL, &pOutClass);
    pOutClass->SpawnInstance(0, &pOutParams);

    // Copy the input argument into the output object    
    
    VARIANT var;
    VariantInit(&var);    // Get the input argument
    pInParams->Get(InputArgName, 0, &var, NULL, NULL);   

    // put it into the output object

    pOutParams->Put(OutputArgName , 0, &var, 0);      
    long lLen = (long)wcslen(var.bstrVal);    VariantClear(&var);    var.vt = VT_I4;
    var.lVal = lLen;    // special name for return value.
    pOutParams->Put(retValName , 0, &var, 0); 

    // Send the output object back to the client via the sink. Then 
    // release the pointers and free the strings.

    hr = pResultSink->Indicate(1, &pOutParams);    
    pOutParams->Release();
    pOutClass->Release();    
    pClass->Release();    
    SysFreeString(ClassName);
    SysFreeString(InputArgName);    
    SysFreeString(OutputArgName);
    SysFreeString(retValName);     
    
    // all done now, set the status
    hr = pResultSink->SetStatus(0,WBEM_S_NO_ERROR,NULL,NULL);
    return WBEM_S_NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\methprov\oahelp.inl ===
// **************************************************************************
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:  OAHELP.INL
//
// Description:  OLE Automation Helpers for client code
//
// History:
//
// **************************************************************************

#ifndef _OAHELP_INL_
#define _OAHELP_INL_

class CBSTR
{
    BSTR m_pStr;
public:
    CBSTR() { m_pStr = 0; }
    CBSTR(LPWSTR pSrc) { m_pStr = SysAllocString(pSrc); }
   ~CBSTR() { if (m_pStr) SysFreeString(m_pStr); }
    operator BSTR() { return m_pStr; }

    void Unbind() { m_pStr = 0; }
};

class CVARIANT
{
    VARIANT v;
public:
    CVARIANT() { VariantInit(&v); }
   ~CVARIANT() { VariantClear(&v); }
    void Clear()  { VariantClear(&v); }

    operator VARIANT *() { return &v; }
    VARIANT *operator &() { return &v; }

    CVARIANT(LPWSTR pSrc)   { VariantInit(&v); SetStr(pSrc); }
    CVARIANT(LONG lSrc)     { VariantInit(&v); SetLONG(lSrc); }
    CVARIANT(BOOL b)        { VariantInit(&v); SetBool(b); }
    CVARIANT(short i)       { VariantInit(&v); SetShort(i); }
    CVARIANT(double d)      { VariantInit(&v); SetDouble(d); }
    CVARIANT(BYTE b)        { VariantInit(&v); SetByte(b); }
    CVARIANT(IDispatch * pDisp) { VariantInit(&v); pDisp->AddRef(); SetDispatch(pDisp); }

    void   SetStr(LPWSTR pSrc)
    { Clear(); V_VT(&v) = pSrc ? VT_BSTR : VT_NULL; 
      V_BSTR(&v) = pSrc ? SysAllocString(pSrc) : 0; 
    }

    LPWSTR GetStr() { return V_VT(&v) == VT_BSTR ? V_BSTR(&v) : 0; }
    operator LPWSTR() { return V_VT(&v) == VT_BSTR ? V_BSTR(&v) : 0; }

    void SetLONG(LONG lSrc) { Clear(); V_VT(&v) = VT_I4; V_I4(&v) = lSrc; }
    LONG GetLONG() { return V_I4(&v); }
    operator LONG() { return V_I4(&v);  }

    void SetDouble(double dSrc) { Clear(); V_VT(&v) = VT_R8; V_R8(&v) = dSrc; }
    double GetDouble() { return V_R8(&v); }
    operator double() { return V_R8(&v);  }

    void SetByte(BYTE bySrc) { Clear(); V_VT(&v) = VT_UI1; V_UI1(&v) = bySrc; }
    BYTE GetByte() { return V_UI1(&v); }
    operator BYTE() { return V_UI1(&v);  }

    void SetBool(BOOL b) { V_VT(&v) = VT_BOOL; V_BOOL(&v) = b ? VARIANT_TRUE : VARIANT_FALSE; }
    BOOL GetBool() { return V_BOOL(&v) == VARIANT_TRUE; }
    operator BOOL() { return V_BOOL(&v); }

    void SetDispatch(IDispatch* pDisp) { V_VT(&v) = VT_DISPATCH; V_DISPATCH(&v) = pDisp; }
    IDispatch * GetDispatch() { return V_DISPATCH(&v); }

    void SetUnknown(IUnknown* pUnk) { V_VT(&v) = VT_UNKNOWN; V_UNKNOWN(&v) = pUnk; }
    IUnknown * GetUnknown() { return V_UNKNOWN(&v); }

    void SetShort(short i) { V_VT(&v) = VT_I2; V_I2(&v) = i; }
    short GetShort() { return V_I2(&v); }
    operator short() { return V_I2(&v); }

    VARTYPE GetType() { return V_VT(&v); }

    void SetArray(SAFEARRAY *p, VARTYPE vt) { Clear(); V_VT(&v) = vt; V_ARRAY(&v) = p; }
        // This function acquires the SAFEARRAY pointer and it is no longer owned
        // by the caller.

    operator SAFEARRAY *() { return (V_VT(&v) & VT_ARRAY ? V_ARRAY(&v) : 0); }

    void Unbind() { VariantInit(&v); }
};

class CSAFEARRAY
{
    SAFEARRAY *p;
public:
    CSAFEARRAY(VARTYPE v, int nSize) 
    {
        SAFEARRAYBOUND rgsabound[1];
    	rgsabound[0].lLbound = 0;
    	rgsabound[0].cElements = nSize;
        p = SafeArrayCreate(v, 1, rgsabound);
    }
    
    ~CSAFEARRAY() { if (p) SafeArrayDestroy(p); }
    CSAFEARRAY(SAFEARRAY *pSrc) { p = pSrc; }

    HRESULT Put(long nLocation, LPVOID pData) {
        return SafeArrayPutElement(p, &nLocation, pData);                
    }

    HRESULT Get(long nLocation, LPVOID pData) { 
        return SafeArrayGetElement(p, &nLocation, pData);                
    }

    HRESULT Access(void **pData) { return SafeArrayAccessData(p, pData); }
    HRESULT Unaccess() { return SafeArrayUnaccessData(p); }

    operator SAFEARRAY *() { return p; }
    long GetNumElements() { long upper; SafeArrayGetUBound(p, 1, &upper); return upper + 1; }

    void Unbind() { p = 0; }
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\objpathparser\makefile.inc ===
$(O)\makefile : makefile.nm
	copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\methprov\methprov.h ===
//***************************************************************************

//

//  methprov.h

//

//  Module: WMI Method Test Provider code

//

//  Purpose: Method Provider Test Header File.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef _methprov_H_
#define _methprov_H_

#include "wbemidl.h"

typedef LPVOID * PPVOID;

// Provider interfaces are provided by objects of this class
 
class CMethodPro : public IWbemServices, public IWbemProviderInit
    {
    protected:
        ULONG              m_cRef;         //Object reference count
        IWbemServices *  m_pWbemSvcs;
        IWbemClassObject* m_pOutClass;
     public:
        CMethodPro();
        ~CMethodPro(void);

        //Non-delegating object IUnknown

        STDMETHODIMP         QueryInterface(REFIID, PPVOID);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo){return WBEM_E_NOT_SUPPORTED;};

        STDMETHOD(GetTypeInfo)(
           THIS_
           UINT itinfo,
           LCID lcid,
           ITypeInfo FAR* FAR* pptinfo){return WBEM_E_NOT_SUPPORTED;};

        STDMETHOD(GetIDsOfNames)(
          THIS_
          REFIID riid,
          OLECHAR FAR* FAR* rgszNames,
          UINT cNames,
          LCID lcid,
          DISPID FAR* rgdispid){return WBEM_E_NOT_SUPPORTED;};

        STDMETHOD(Invoke)(
          THIS_
          DISPID dispidMember,
          REFIID riid,
          LCID lcid,
          WORD wFlags,
          DISPPARAMS FAR* pdispparams,
          VARIANT FAR* pvarResult,
          EXCEPINFO FAR* pexcepinfo,
          UINT FAR* puArgErr){return WBEM_E_NOT_SUPPORTED;};


        //IWbemProviderInit

        HRESULT STDMETHODCALLTYPE Initialize(
             /* [in] */ LPWSTR pszUser,
             /* [in] */ LONG lFlags,
             /* [in] */ LPWSTR pszNamespace,
             /* [in] */ LPWSTR pszLocale,
             /* [in] */ IWbemServices *pNamespace,
             /* [in] */ IWbemContext *pCtx,
             /* [in] */ IWbemProviderInitSink *pInitSink
                        );

        //IWbemServices  

		HRESULT STDMETHODCALLTYPE OpenNamespace( 
            /* [in] */ const BSTR Namespace,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CancelAsyncCall( 
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE QueryObjectSink( 
            /* [in] */ long lFlags,
            /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE GetObject( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE GetObjectAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler){return WBEM_E_NOT_SUPPORTED;}
        
        HRESULT STDMETHODCALLTYPE PutClass( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE PutClassAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE DeleteClass( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE DeleteClassAsync( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CreateClassEnum( 
            /* [in] */ const BSTR Superclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CreateClassEnumAsync( 
            /* [in] */ const BSTR Superclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE PutInstance( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE PutInstanceAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE DeleteInstance( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE DeleteInstanceAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CreateInstanceEnum( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler){return WBEM_E_NOT_SUPPORTED;}
        
        HRESULT STDMETHODCALLTYPE ExecQuery( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE ExecQueryAsync( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE ExecNotificationQuery( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        // Supported !!!!

        HRESULT STDMETHODCALLTYPE ExecMethod( const BSTR, const BSTR, long, IWbemContext*,
            IWbemClassObject*, IWbemClassObject**, IWbemCallResult**){return WBEM_E_NOT_SUPPORTED;}

        HRESULT STDMETHODCALLTYPE ExecMethodAsync( const BSTR, const BSTR, long, 
            IWbemContext*, IWbemClassObject*, IWbemObjectSink*);

       
};

typedef CMethodPro *PCMethodPro;

// This class is the class factory for CMethodPro objects.

class CProvFactory : public IClassFactory
    {
    protected:
        ULONG           m_cRef;

    public:
        CProvFactory(void);
        ~CProvFactory(void);

        //IUnknown members
        STDMETHODIMP         QueryInterface(REFIID, PPVOID);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        //IClassFactory members
        STDMETHODIMP         CreateInstance(LPUNKNOWN, REFIID
                                 , PPVOID);
        STDMETHODIMP         LockServer(BOOL);
    };

typedef CProvFactory *PCProvFactory;



// These variables keep track of when the module can be unloaded

extern long       g_cObj;
extern long       g_cLock;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\objpathparser\genlex.cpp ===
// **************************************************************************

// Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// File:  GENLEX.CPP
//
// Description:  
//    Generic lexer framework classes.
//
// History:
//
// **************************************************************************

#include <windows.h>
#include <stdio.h>

#include <genlex.h>

//***************************************************************************
//
//***************************************************************************

CGenLexer::CGenLexer(LexEl *pTbl, CGenLexSource *pSrc)
{
    m_nCurBufSize = 256;
    m_pTokenBuf = (wchar_t *) HeapAlloc(GetProcessHeap(), 0,
        m_nCurBufSize * 2);
    m_nCurrentLine = 1;
    m_pTable = pTbl;
    m_pSrc = pSrc;
}

//***************************************************************************
//
//***************************************************************************
void CGenLexer::Reset()
{
    m_pSrc->Reset();
    m_nCurrentLine = 1;
}


//***************************************************************************
//
//***************************************************************************

CGenLexer::~CGenLexer()
{
    HeapFree(GetProcessHeap(), 0, m_pTokenBuf);
}

//***************************************************************************
//
//***************************************************************************

int CGenLexer::NextToken()
{
    int nState = 0;
    int nCurBufEnd = 0;
    BOOL bRead = TRUE;
    wchar_t cCurrent = 0;
    *m_pTokenBuf = 0;
    BOOL bEOF = FALSE;


    // Generic DFA driver based on the table specified
    // in the constructor.
    // ===============================================

    while (1)
    {
        BOOL bMatch = FALSE;
        WORD wInstructions = m_pTable[nState].wInstructions;

        if (bRead)
        {
            if(bEOF)
            {
                // The lexer table allowed us to go past end of string!!!
                return 1;
            }
            cCurrent = m_pSrc->NextChar();
            if(cCurrent == 0)
                bEOF = TRUE;
        }

        bRead = FALSE;

        // Check here if only the first character is present.
        // ==================================================

        if (m_pTable[nState].cFirst == GLEX_ANY)
            bMatch = TRUE;
        else if (m_pTable[nState].cLast == GLEX_EMPTY)
        {
            if (cCurrent == m_pTable[nState].cFirst)
                bMatch = TRUE;
            else if ((wInstructions & GLEX_NOT) &&
                !(cCurrent == m_pTable[nState].cFirst))
                bMatch = TRUE;
        }

        // If here, both first/last are present and we
        // are testing to see if the input is in between.
        // ==============================================
        else if (m_pTable[nState].cFirst != GLEX_ANY)
        {
            if ((wInstructions & GLEX_NOT) &&
                !(cCurrent >= m_pTable[nState].cFirst &&
                cCurrent <= m_pTable[nState].cLast))
                    bMatch = TRUE;
            else if (cCurrent >= m_pTable[nState].cFirst &&
                cCurrent <= m_pTable[nState].cLast)
                    bMatch = TRUE;
        }

        // Interpret the instruction field to determine
        // whether the character is actually to be included
        // in the token text.
        // ================================================

        if (bMatch)
        {
            if (wInstructions & GLEX_ACCEPT)
            {
                // Expand the current buffer, if required.
                // =======================================

                if (nCurBufEnd == m_nCurBufSize - 1)
                {
                    m_nCurBufSize += 256;
                    m_pTokenBuf = (wchar_t *) HeapReAlloc(GetProcessHeap(), 0, m_pTokenBuf,
                        m_nCurBufSize * 2);
                }

                m_pTokenBuf[nCurBufEnd] = cCurrent;
                m_pTokenBuf[++nCurBufEnd]= 0;
                bRead = TRUE;
            }
            if (wInstructions & GLEX_CONSUME)
               bRead = TRUE;

            // else GLEX_CONSUME, which means 'skip'

            // If the PUSHBACK instruction is present,
            // push the char back.
            // ======================================
            if (wInstructions & GLEX_PUSHBACK)
            {
                bRead = TRUE;
                m_pSrc->Pushback(cCurrent);
            }

            // If a linefeed instruction.
            // ==========================
            if (wInstructions & GLEX_LINEFEED)
                m_nCurrentLine++;

            // If the return field is present and there was
            // a match, then return the specified token.  Alternately,
            // the GLEX_RETURN instruction will force a return
            // match, or no match.
            // =======================================================
            if (m_pTable[nState].wReturnTok ||
                (wInstructions & GLEX_RETURN))
                return int(m_pTable[nState].wReturnTok);

            nState = int(m_pTable[nState].wGotoState);
        }

        // If here, there was no match.
        // ===================================
        else
            nState++;
    }

    return 0;   // No path to here
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\objpathparser\genlex.h ===
// **************************************************************************

// Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// File:  GENLEX.H
//
// Description:  
//    Generic lexer framework classes.
//
// History:
//
// **************************************************************************

#ifndef _GENLEX_H_
#define _GENLEX_H_


class CGenLexSource
{
public:
    virtual wchar_t NextChar() = 0;
        // Return 0 on end-of-input
    virtual void Pushback(wchar_t) = 0;
    virtual void Reset() = 0;
};

class CTextLexSource : public CGenLexSource
{
    wchar_t *m_pSrcBuf;
    wchar_t *m_pStart;

public:
    CTextLexSource(wchar_t *pSrc) { m_pSrcBuf = m_pStart = pSrc; }
        // Binds directly to <pSrc> buffer, but doesn't delete it.

    wchar_t NextChar() { return *m_pSrcBuf++ ? m_pSrcBuf[-1] : 0; }
    void Pushback(wchar_t) { --m_pSrcBuf; }
    void Reset() { m_pSrcBuf = m_pStart; }
};


#pragma pack(2)
struct LexEl
{
    wchar_t cFirst, cLast;
    WORD wGotoState;
    WORD wReturnTok;
    WORD wInstructions;
};
#pragma pack()


// Lexer driver instructions

#define GLEX_ACCEPT      0x1            // Add the char to the token
#define GLEX_CONSUME     0x2            // Consume the char without adding to token
#define GLEX_PUSHBACK    0x4            // Place the char back in the source buffer for next token
#define GLEX_NOT         0x8            // A match occurs if the char is NOT the one specified
#define GLEX_LINEFEED    0x10               // Increase the source linecount
#define GLEX_RETURN      0x20               // Return the indicated token to caller
#define GLEX_ANY         wchar_t(0xFFFF)    // Any character
#define GLEX_EMPTY       wchar_t(0xFFFE)    // When subrange is not specified

class CGenLexer
{
    wchar_t    *m_pTokenBuf;
    int         m_nCurrentLine;
    int         m_nCurBufSize;
    CGenLexSource   *m_pSrc;
    LexEl           *m_pTable;
    
public:
    CGenLexer(LexEl *pTbl, CGenLexSource *pSrc);
    
   ~CGenLexer(); 
    int NextToken();
        // Returns 0 on end of input.

    wchar_t* GetTokenText() { return m_pTokenBuf; }
    int GetLineNum() { return m_nCurrentLine; }
    void Reset();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\objpathparser\objpath.cpp ===
// **************************************************************************

// Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// File:  OBJPATH.CPP
//
// Description:  
//    Object path parser.
//
// History:
//
// **************************************************************************

#include <windows.h>
#include <stdio.h>
#include <genlex.h>
#include <opathlex.h>
#include <objpath.h>

#define Macro_CloneLPWSTR(x) \
    (x ? wcscpy(new wchar_t[wcslen(x) + 1], x) : 0)


ParsedObjectPath::ParsedObjectPath()
{
    m_pServer = 0;                  // NULL if no server
    m_dwNumNamespaces = 0;          // 0 if no namespaces

    m_dwAllocNamespaces = 2;
    m_paNamespaces = new LPWSTR[m_dwAllocNamespaces];

    m_pClass = 0;                   // Class name
    m_dwNumKeys = 0;                // 0 if no keys (just a class name)
    m_bSingletonObj = FALSE;
    m_dwAllocKeys = 2;
    m_paKeys = new KeyRef *[m_dwAllocKeys];
}

ParsedObjectPath::~ParsedObjectPath()
{
    delete m_pServer;
    for (DWORD dwIx = 0; dwIx < m_dwNumNamespaces; dwIx++)
        delete m_paNamespaces[dwIx];
    delete m_paNamespaces;
    delete m_pClass;

    for (dwIx = 0; dwIx < m_dwNumKeys; dwIx++)
        delete m_paKeys[dwIx];
    delete m_paKeys;
}

BOOL ParsedObjectPath::SetClassName(LPCWSTR wszClassName)
{
    delete [] m_pClass;
    if(wszClassName == NULL)
    {
        m_pClass = NULL;
    }
    else
    {
        m_pClass = Macro_CloneLPWSTR(wszClassName);
    }

    return TRUE;
}

BOOL ParsedObjectPath::IsClass()
{
    if(!IsObject())
        return FALSE;

    return (m_dwNumKeys == 0 && !m_bSingletonObj);
}

BOOL ParsedObjectPath::IsInstance()
{
    return IsObject() && !IsClass();
}

BOOL ParsedObjectPath::IsObject()
{
    if(m_pClass == NULL)
        return FALSE;

    if(m_pServer)
    {
        return (m_dwNumNamespaces > 0);
    }
    else
    {
        return (m_dwNumNamespaces == 0);
    }
}

BOOL ParsedObjectPath::AddNamespace(LPCWSTR wszNamespace)
{
    if(m_dwNumNamespaces == m_dwAllocNamespaces)
    {
        DWORD dwNewAllocNamespaces = m_dwAllocNamespaces * 2;
        LPWSTR* paNewNamespaces = new LPWSTR[dwNewAllocNamespaces];
        memcpy(paNewNamespaces, m_paNamespaces, 
            sizeof(LPWSTR) * m_dwAllocNamespaces);
        delete [] m_paNamespaces;
        m_paNamespaces = paNewNamespaces;
        m_dwAllocNamespaces = dwNewAllocNamespaces;
    }
    m_paNamespaces[m_dwNumNamespaces++] = Macro_CloneLPWSTR(wszNamespace);

    return TRUE;
}

BOOL ParsedObjectPath::AddKeyRefEx(LPCWSTR wszKeyName, const VARIANT* pvValue )
{
    BOOL bStatus = TRUE ;
    BOOL bFound = FALSE ;
    BOOL bUnNamed = FALSE ;

    for ( ULONG dwIndex = 0 ; dwIndex < m_dwNumKeys ; dwIndex ++ )
    {
        if ( ( (*m_paKeys) [ dwIndex ].m_pName ) && wszKeyName )
        {
            if ( _wcsicmp ( ( (*m_paKeys) [ dwIndex ].m_pName ) , wszKeyName ) 
                                                                        == 0 )
            {
                bFound = TRUE ;
                break ;
            }
        }
        else
        {
            if ( ( ( (*m_paKeys) [ dwIndex ].m_pName ) == 0 ) )
            {
                bUnNamed = TRUE ;
                if ( ( wszKeyName == 0 ) )
                {
                    bFound = TRUE ;
                    break ;
                }
            }
        }
    }

    if ( ! wszKeyName )
    {
        /* Remove all existing keys */

        for ( ULONG dwDeleteIndex = 0 ; dwDeleteIndex < m_dwNumKeys ; 
                                                            dwDeleteIndex ++ )
        {
            delete ( (*m_paKeys) [ dwDeleteIndex ].m_pName ) ;
            (*m_paKeys) [ dwDeleteIndex ].m_pName = NULL ;
            VariantClear ( & ( * m_paKeys ) [ dwDeleteIndex ].m_vValue ) ;
        }

        VariantCopy ( & ( * m_paKeys ) [ 0 ].m_vValue , ( VARIANT * ) pvValue );

        m_dwNumKeys = 1 ;
    }
    else
    {
        if ( bFound )
        {
            /*
             *    If key already exists then just replace the value
             */

            if ( wszKeyName )
            {
                (*m_paKeys) [ dwIndex ].m_pName = 
                    new wchar_t [ wcslen ( wszKeyName ) + 1 ] ;
                wcscpy ( (*m_paKeys) [ dwIndex ].m_pName , wszKeyName ) ;
            }

            VariantClear ( & ( * m_paKeys ) [ dwIndex ].m_vValue ) ;
            VariantCopy ( & ( * m_paKeys ) [ dwIndex ].m_vValue , 
                    ( VARIANT * ) pvValue ) ;
        }
        else
        {
            if ( bUnNamed )
            {
                /* Add an un named key */

                for ( ULONG dwDeleteIndex = 0 ; dwDeleteIndex < m_dwNumKeys ; 
                        dwDeleteIndex ++ )
                {
                    delete ( (*m_paKeys) [ dwDeleteIndex ].m_pName ) ;
                    (*m_paKeys) [ dwDeleteIndex ].m_pName = NULL ;
                    VariantClear (& ( * m_paKeys ) [ dwDeleteIndex ].m_vValue );
                }

                (*m_paKeys) [ 0 ].m_pName = 
                    new wchar_t [ wcslen ( wszKeyName ) + 1 ] ;
                wcscpy ( (*m_paKeys) [ 0 ].m_pName , wszKeyName ) ;

                VariantCopy ( & ( * m_paKeys ) [ 0 ].m_vValue , 
                    ( VARIANT * ) pvValue ) ;

                m_dwNumKeys = 1 ;
            }
            else
            {
                /* Add a Named Key */

                AddKeyRef(wszKeyName, pvValue);
            }
        }
    }

    return bStatus;
}

void ParsedObjectPath::ClearKeys ()
{
    for ( ULONG dwDeleteIndex = 0 ; dwDeleteIndex < m_dwNumKeys ; 
            dwDeleteIndex ++ )
    {
        delete ( (*m_paKeys) [ dwDeleteIndex ].m_pName ) ;
        (*m_paKeys) [ dwDeleteIndex ].m_pName = NULL ;
        VariantClear ( & ( * m_paKeys ) [ dwDeleteIndex ].m_vValue ) ;
		delete m_paKeys ;
		m_paKeys = NULL ;
    }

    m_dwNumKeys = 0 ;
}

BOOL ParsedObjectPath::AddKeyRef(LPCWSTR wszKeyName, const VARIANT* pvValue)
{
    if(m_dwNumKeys == m_dwAllocKeys)
    {
        DWORD dwNewAllocKeys = m_dwAllocKeys * 2;
        KeyRef** paNewKeys = new KeyRef*[dwNewAllocKeys];
        memcpy(paNewKeys, m_paKeys, sizeof(KeyRef*) * m_dwAllocKeys);
        delete [] m_paKeys;
        m_paKeys = paNewKeys;
        m_dwAllocKeys = dwNewAllocKeys;
    }

    m_paKeys[m_dwNumKeys] = new KeyRef(wszKeyName, pvValue);
    m_dwNumKeys++;
    return TRUE;
}

BOOL ParsedObjectPath::AddKeyRef(KeyRef* pAcquireRef)
{
    if(m_dwNumKeys == m_dwAllocKeys)
    {
        DWORD dwNewAllocKeys = m_dwAllocKeys * 2;
        KeyRef** paNewKeys = new KeyRef*[dwNewAllocKeys];
        memcpy(paNewKeys, m_paKeys, sizeof(KeyRef*) * m_dwAllocKeys);
        delete [] m_paKeys;
        m_paKeys = paNewKeys;
        m_dwAllocKeys = dwNewAllocKeys;
    }

    m_paKeys[m_dwNumKeys] = pAcquireRef;
    m_dwNumKeys++;
    return TRUE;
}

KeyRef::KeyRef()
{
    m_pName = 0;
    VariantInit(&m_vValue);
}

KeyRef::KeyRef(LPCWSTR wszKeyName, const VARIANT* pvValue)
{
    m_pName = Macro_CloneLPWSTR(wszKeyName);
    VariantInit(&m_vValue);
    VariantCopy(&m_vValue, (VARIANT*)pvValue);
}

KeyRef::~KeyRef()
{
    delete m_pName;
    VariantClear(&m_vValue);
}




int CObjectPathParser::Unparse(
        ParsedObjectPath* pInput,
        DELETE_ME LPWSTR* pwszPath)
{
    if(pInput->m_pClass == NULL)
    {
        return CObjectPathParser::InvalidParameter;
    }

    // Allocate enough space
    // =====================

    int nSpace = wcslen(pInput->m_pClass);
    nSpace += 10;
    DWORD dwIx;
    for (dwIx = 0; dwIx < pInput->m_dwNumKeys; dwIx++)
    {
        KeyRef* pKey = pInput->m_paKeys[dwIx];
        if(pKey->m_pName)
            nSpace += wcslen(pKey->m_pName);
        if(V_VT(&pKey->m_vValue) == VT_BSTR)
        {
            nSpace += wcslen(V_BSTR(&pKey->m_vValue))*2 + 10;
        }
        else if(V_VT(&pKey->m_vValue) == VT_I4)
        {
            nSpace += 30;
        }
    }
    if(pInput->m_bSingletonObj)
        nSpace +=2;

    WCHAR wszTemp[30];
    LPWSTR wszPath = new WCHAR[nSpace];
    wcscpy(wszPath, pInput->m_pClass);


    for (dwIx = 0; dwIx < pInput->m_dwNumKeys; dwIx++)
    {
        KeyRef* pKey = pInput->m_paKeys[dwIx];

        // We dont want to put a '.' if there isnt a key name,
        // for example, Myclass="value"
        if(dwIx == 0)
        {
            if(pKey->m_pName || pInput->m_dwNumKeys > 1)
                wcscat(wszPath, L".");
        }
        else
        {
            wcscat(wszPath, L",");
        }
        if(pKey->m_pName)
            wcscat(wszPath, pKey->m_pName);
        wcscat(wszPath, L"=");

        if(V_VT(&pKey->m_vValue) == VT_BSTR)
        {
            wcscat(wszPath, L"\"");
            WCHAR* pwc = V_BSTR(&pKey->m_vValue);
            WCHAR str[2];
            str[1] = 0;
            while(*pwc)
            {
                if(*pwc == '\\' || *pwc == '"')
                {
                    wcscat(wszPath, L"\\");
                }
                else if (*pwc == '/')
                    wcscat(wszPath,L"/");
                str[0] = *pwc;
                wcscat(wszPath, str);
                pwc++;
            }

            wcscat(wszPath, L"\"");
        }
        else if(V_VT(&pKey->m_vValue) == VT_I4)
        {
            swprintf(wszTemp, L"%d", V_I4(&pKey->m_vValue));
            wcscat(wszPath, wszTemp);
        }
    }

    // Take care of the singleton case.  This is a path of the form
    // MyClass=@  and represents a single instance of a class with no
    // keys.

    if(pInput->m_bSingletonObj && pInput->m_dwNumKeys == 0)
        wcscat(wszPath, L"=@");


    *pwszPath = wszPath;

    return NoError;
}


LPWSTR CObjectPathParser::GetRelativePath(LPWSTR wszFullPath)
{
    LPWSTR wsz = wcschr(wszFullPath, L':');
    if(wsz)
        return wsz + 1;
    else
        return NULL;
}





void CObjectPathParser::Zero()
{
    m_nCurrentToken = 0;
    m_pLexer = 0;
    m_pInitialIdent = 0;
    m_pOutput = 0;
    m_pTmpKeyRef = 0;
}

CObjectPathParser::CObjectPathParser(ObjectParserFlags eFlags)
    : m_eFlags(eFlags)
{
    Zero();
}

void CObjectPathParser::Empty()
{
    delete m_pLexer;
    delete m_pInitialIdent;
    delete m_pTmpKeyRef;
    // m_pOutput is intentionally left alone,
    // since all code paths delete this already on error, or
    // else the user acquired the pointer.
}

CObjectPathParser::~CObjectPathParser()
{
    Empty();
}

int CObjectPathParser::Parse(
    LPWSTR pRawPath,
    ParsedObjectPath **pOutput
    )
{
    if (pOutput == 0 || pRawPath == 0 || wcslen(pRawPath) == 0)
        return CObjectPathParser::InvalidParameter;

    // Check for leading / trailing ws.
    // ================================
    
    if (iswspace(pRawPath[wcslen(pRawPath)-1]) || iswspace(pRawPath[0])) 
        return InvalidParameter;
    
     // These are required for multiple calls to Parse().
    // ==================================================
    Empty();
    Zero();

    // Set default return to NULL initially until we have some output.
    // ===============================================================
    *pOutput = 0;

    m_pOutput = new ParsedObjectPath;

    // Parse the server name (if there is one) manually
    // ================================================

    if ( (pRawPath[0] == '\\' && pRawPath[1] == '\\') ||
         (pRawPath[0] == '/' && pRawPath[1] == '/'))
    {
        WCHAR* pwcStart = pRawPath + 2;

        // Find the next backslash --- it's the end of the server name
        // ===========================================================

        WCHAR* pwcEnd = wcschr(pwcStart, L'\\');
        if (pwcEnd == NULL)
        {
            pwcEnd = wcschr(pwcStart, L'/');
            if (pwcEnd == NULL)
            {
                delete m_pOutput;
                return SyntaxError;
            }
        }

        if(pwcEnd == pwcStart)
        {
            delete m_pOutput;
            return SyntaxError;
        }
        m_pOutput->m_pServer = new WCHAR[pwcEnd-pwcStart+1];
        wcsncpy(m_pOutput->m_pServer, pwcStart, pwcEnd-pwcStart);
        m_pOutput->m_pServer[pwcEnd-pwcStart] = 0;

        pRawPath = pwcEnd;
    }

    // Point the lexer at the source.
    // ==============================

    CTextLexSource src(pRawPath);
    m_pLexer = new CGenLexer(OPath_LexTable, &src);

    // Go.
    // ===

    int nRes = begin_parse();
    if (nRes)
    {
        delete m_pOutput;
        return nRes;
    }

    if (m_nCurrentToken != OPATH_TOK_EOF)
    {
        delete m_pOutput;
        return SyntaxError;
    }

    if(m_pOutput->m_dwNumNamespaces > 0 && m_pOutput->m_pServer == NULL)
    {
        if(m_eFlags != e_ParserAcceptRelativeNamespace)
        {
            delete m_pOutput;
            return SyntaxError;
        }
        else
        {
            // Local namespace --- set server to "."
            // =====================================
            m_pOutput->m_pServer = new WCHAR[2];
            wcscpy(m_pOutput->m_pServer, L".");
        }
    }

    // Sort the key refs lexically. If there is only
    // one key, there is nothing to sort anyway.
    // =============================================
    if (m_pOutput->m_dwNumKeys > 1)
    {
        BOOL bChanges = TRUE;
        while (bChanges)
        {
            bChanges = FALSE;
            for (DWORD dwIx = 0; dwIx < m_pOutput->m_dwNumKeys - 1; dwIx++)
            {
                if (_wcsicmp(m_pOutput->m_paKeys[dwIx]->m_pName,
                    m_pOutput->m_paKeys[dwIx+1]->m_pName) > 0)
                {
                    KeyRef *pTmp = m_pOutput->m_paKeys[dwIx];
                    m_pOutput->m_paKeys[dwIx] = m_pOutput->m_paKeys[dwIx + 1];
                    m_pOutput->m_paKeys[dwIx + 1] = pTmp;
                    bChanges = TRUE;
                }
            }
        }
    }


    // Add in key refs.
    // ================
    *pOutput = m_pOutput;
    m_pOutput = 0;
    return NoError;
}

BOOL CObjectPathParser::NextToken()
{
    m_nCurrentToken = m_pLexer->NextToken();
    if (m_nCurrentToken == OPATH_TOK_ERROR)
        return FALSE;
    return TRUE;
}


void CObjectPathParser::Free(ParsedObjectPath *pOutput)
{
    delete pOutput;
}

//
//  <Parse> ::= BACKSLASH <ns_or_server>;
//  <Parse> ::= IDENT <ns_or_class>;
//  <Parse> ::= COLON <objref>;
//
int CObjectPathParser::begin_parse()
{
    if (!NextToken())
        return SyntaxError;

    if (m_nCurrentToken == OPATH_TOK_BACKSLASH)
    {
        if (!NextToken())
            return SyntaxError;
        return ns_or_server();
    }
    else if (m_nCurrentToken == OPATH_TOK_IDENT)
    {
        m_pInitialIdent = Macro_CloneLPWSTR(m_pLexer->GetTokenText());
        if (!NextToken())
            return SyntaxError;

        // Copy the token and put it in a temporary holding place
        // until we figure out whether it is a namespace or a class name.
        // ==============================================================

        return ns_or_class();
    }
    else if (m_nCurrentToken == OPATH_TOK_COLON)
    {
        if (!NextToken())
            return SyntaxError;
        return objref();
    }

    // If here, we had a bad starter token.
    // ====================================

    return SyntaxError;
}

//
//  <ns_or_server> ::= BACKSLASH <dot_or_ident> BACKSLASH <ns_list> <optional_objref>;
//  <ns_or_server> ::= <ns_list> <optional_objref>;
//
//  <dot_or_ident> is embedded.
//
int CObjectPathParser::ns_or_server()
{
    if (m_nCurrentToken == OPATH_TOK_BACKSLASH)
    {
        // Actually, server names have been take care of, so this is a failure
        // ===================================================================

        return SyntaxError;
    }
    else if (m_nCurrentToken == OPATH_TOK_IDENT)
    {
        int nRes = ns_list();
        if (nRes)
            return nRes;
        return optional_objref();
    }

    return SyntaxError;
}

//
//  <optional_objref> ::= COLON <objref>;
//  <optional_objref> ::= <>;
//
int CObjectPathParser::optional_objref()
{
    if (m_nCurrentToken == OPATH_TOK_EOF)
        return NoError;

    if (m_nCurrentToken != OPATH_TOK_COLON)
        return SyntaxError;
    if (!NextToken())
        return SyntaxError;
    return objref();
}


//
//  <ns_or_class> ::= COLON <ident_becomes_ns> <objref>;
//  <ns_or_class> ::= BACKSLASH <ident_becomes_ns> <ns_list> COLON <objref>;
//  <ns_or_class> ::= BACKSLASH <ident_becomes_ns> <ns_list>;
//
int CObjectPathParser::ns_or_class()
{
    if (m_nCurrentToken == OPATH_TOK_COLON)
    {
        ident_becomes_ns();
        if (!NextToken())
            return SyntaxError;
        return objref();
    }
    else if (m_nCurrentToken == OPATH_TOK_BACKSLASH)
    {
        ident_becomes_ns();
        if (!NextToken())
            return SyntaxError;
        int nRes = ns_list();
        if (nRes)
            return nRes;
        if (m_nCurrentToken == OPATH_TOK_EOF)    // ns only
            return NoError;

        if (m_nCurrentToken != OPATH_TOK_COLON)
            return SyntaxError;
        if (!NextToken())
            return SyntaxError;
        return objref();
    }

    // Else
    // ====
    ident_becomes_class();
    return objref_rest();
}

//
//  <objref> ::= IDENT <objref_rest>;  // IDENT is classname
//
int CObjectPathParser::objref()
{
    if (m_nCurrentToken != OPATH_TOK_IDENT)
        return SyntaxError;

    m_pOutput->m_pClass = Macro_CloneLPWSTR(m_pLexer->GetTokenText());

    if (!NextToken())
        return SyntaxError;

    return objref_rest();
}

//
// <ns_list> ::= IDENT <ns_list_rest>;
//
int CObjectPathParser::ns_list()
{
    if (m_nCurrentToken == OPATH_TOK_IDENT)
    {
        m_pOutput->AddNamespace(m_pLexer->GetTokenText());

        if (!NextToken())
            return SyntaxError;
        return ns_list_rest();
    }

    return SyntaxError;
}

//
//  <ident_becomes_ns> ::= <>;      // <initial_ident> becomes a namespace
//
int CObjectPathParser::ident_becomes_ns()
{
    m_pOutput->AddNamespace(m_pInitialIdent);

    delete m_pInitialIdent;
    m_pInitialIdent = 0;
    return NoError;
}

//
//  <ident_becomes_class> ::= <>;   // <initial_ident> becomes the class
//
int CObjectPathParser::ident_becomes_class()
{
    m_pOutput->m_pClass = Macro_CloneLPWSTR(m_pInitialIdent);
    delete m_pInitialIdent;
    m_pInitialIdent = 0;
    return NoError;
}

//
//  <objref_rest> ::= EQUALS <key_const>;
//  <objref_rest> ::= EQUALS *;
//  <objref_rest> ::= DOT <keyref_list>;
//  <objref_rest> ::= <>;
//
int CObjectPathParser::objref_rest()
{
    if (m_nCurrentToken == OPATH_TOK_EQ)
    {
        if (!NextToken())
            return SyntaxError;

        // Take care of the singleton case.  This is a path of the form
        // MyClass=@  and represents a singleton instance of a class with no
        // keys.


        if(m_nCurrentToken == OPATH_TOK_SINGLETON_SYM)
        {
            if(NextToken() && m_nCurrentToken != OPATH_TOK_EOF)
                return SyntaxError;
            m_pOutput->m_bSingletonObj = TRUE;
            return NoError;

        }

        m_pTmpKeyRef = new KeyRef;
        int nRes = key_const();
        if (nRes)
        {
            delete m_pTmpKeyRef;
            m_pTmpKeyRef = 0;
            return nRes;
        }

        m_pOutput->AddKeyRef(m_pTmpKeyRef);
        m_pTmpKeyRef = 0;
    }
    else if (m_nCurrentToken == OPATH_TOK_DOT)
    {
        if (!NextToken())
            return SyntaxError;
        return keyref_list();
    }

    return NoError;
}

//
//  <ns_list_rest> ::= BACKSLASH <ns_list>;
//  <ns_list_rest> ::= <>;
//
int CObjectPathParser::ns_list_rest()
{
    if (m_nCurrentToken == OPATH_TOK_BACKSLASH)
    {
        if (!NextToken())
            return SyntaxError;
        return ns_list();
    }
    return NoError;
}

//
//  <key_const> ::= STRING_CONST;
//  <key_const> ::= INTEGRAL_CONST;
//  <key_const> ::= REAL_CONST;
//  <key_const> ::= IDENT;      // Where IDENT is "OBJECT" for singleton classes
//
int CObjectPathParser::key_const()
{
    // If here, we have a key constant.
    // We may or may not have the property name
    // associated with it.
    // ========================================

    if (m_nCurrentToken == OPATH_TOK_QSTRING)
    {
        V_VT(&m_pTmpKeyRef->m_vValue) = VT_BSTR;
        V_BSTR(&m_pTmpKeyRef->m_vValue) = SysAllocString(m_pLexer->GetTokenText());
    }
    else if (m_nCurrentToken == OPATH_TOK_INT)
    {
        V_VT(&m_pTmpKeyRef->m_vValue) = VT_I4;
        char buf[32];
        sprintf(buf, "%S", m_pLexer->GetTokenText());
        V_I4(&m_pTmpKeyRef->m_vValue) = atol(buf);
    }
    else if (m_nCurrentToken == OPATH_TOK_HEXINT)
    {
        V_VT(&m_pTmpKeyRef->m_vValue) = VT_I4;
        char buf[32];
        sprintf(buf, "%S", m_pLexer->GetTokenText());
        long l;
        sscanf(buf, "%x", &l);
        V_I4(&m_pTmpKeyRef->m_vValue) = l;
    }
    else if (m_nCurrentToken == OPATH_TOK_IDENT)
    {
       if (_wcsicmp(m_pLexer->GetTokenText(), L"TRUE") == 0)
       {
            V_VT(&m_pTmpKeyRef->m_vValue) = VT_I4;
            V_I4(&m_pTmpKeyRef->m_vValue) = 1;
          }
       else if (_wcsicmp(m_pLexer->GetTokenText(), L"FALSE") == 0)
       {
            V_VT(&m_pTmpKeyRef->m_vValue) = VT_I4;
            V_I4(&m_pTmpKeyRef->m_vValue) = 0;
       }
       else
            return SyntaxError;
    }
    else return SyntaxError;

    if (!NextToken())
        return SyntaxError;

    return NoError;
}

//
// <keyref_list> ::= <keyref> <keyref_term>;
//
int CObjectPathParser::keyref_list()
{
    int nRes = keyref();
    if (nRes)
        return nRes;
    return keyref_term();
}

//
// <keyref> ::= <propname> EQUALS <key_const>;
//
int CObjectPathParser::keyref()
{
    m_pTmpKeyRef = new KeyRef;

    int nRes = propname();

    if (nRes)
    {
        delete m_pTmpKeyRef;
        m_pTmpKeyRef = 0;
        return nRes;
    }

    if (m_nCurrentToken != OPATH_TOK_EQ)
    {
        delete m_pTmpKeyRef;
        m_pTmpKeyRef = 0;
        return SyntaxError;
    }

    if (!NextToken())
    {
        delete m_pTmpKeyRef;
        m_pTmpKeyRef = 0;
        return SyntaxError;
    }

    nRes = key_const();
    if (nRes)
    {
        delete m_pTmpKeyRef;
        m_pTmpKeyRef = 0;
        return nRes;
    }

    m_pOutput->AddKeyRef(m_pTmpKeyRef);
    m_pTmpKeyRef = 0;

    return NoError;
}

//
//  <keyref_term> ::= COMMA <keyref_list>;      // Used for compound keys
//  <keyref_term> ::= <>;
//
int CObjectPathParser::keyref_term()
{
    if (m_nCurrentToken == OPATH_TOK_COMMA)
    {
        if (!NextToken())
            return SyntaxError;
        return keyref_list();
    }

    return NoError;
}

//
// <propname>  ::= IDENT;
//
int CObjectPathParser::propname()
{
    if (m_nCurrentToken != OPATH_TOK_IDENT)
        return SyntaxError;

    m_pTmpKeyRef->m_pName = Macro_CloneLPWSTR(m_pLexer->GetTokenText());

    if (!NextToken())
    {
        delete m_pTmpKeyRef;
        m_pTmpKeyRef = 0;
        return SyntaxError;
    }

    return NoError;
}

//***************************************************************************
//
//  ParsedObjectPath::GetKeyString
//
//  Returns the db-engine compatible key string for the object.
//  The format will likely change after the Alpha PDK Release.
//
//  Return value:
//  NULL on error or for pure classes.  Otherwise returns a pointer to
//  a newly allocated string which must be deallocated with operator
//  delete.
//
//***************************************************************************
LPWSTR ParsedObjectPath::GetKeyString()
{
    if (m_dwNumKeys == 0 && !m_bSingletonObj)
    {
        if (m_pClass == 0 || wcslen(m_pClass) == 0)
            return 0;

        LPWSTR pTmp = new wchar_t[wcslen(m_pClass) + 1];
        wcscpy(pTmp, m_pClass);

        return pTmp;
    }

    // Allocate enough space
    // =====================

    int nSpace = 10;
    DWORD dwIx;
    for (dwIx = 0; dwIx < m_dwNumKeys; dwIx++)
    {
        KeyRef* pKey = m_paKeys[dwIx];
        nSpace += 2; // for the |
        if(V_VT(&pKey->m_vValue) == VT_BSTR)
        {
            nSpace += wcslen(V_BSTR(&pKey->m_vValue))*2 + 10;
        }
        else if(V_VT(&pKey->m_vValue) == VT_I4)
        {
            nSpace += 30;
        }
    }
    if(m_bSingletonObj)
        nSpace +=20;


    LPWSTR pRetVal = new wchar_t[nSpace];
    wchar_t Tmp[32];
    long nVal;

    *pRetVal = 0;
    BOOL bFirst = TRUE;

    // The key are already sorted lexically.
    // =====================================

    WCHAR wszSeparator[2];
    wszSeparator[0] = 0xFFFF;
    wszSeparator[1] = 0;

    for (DWORD i = 0; i < m_dwNumKeys; i++)
    {
        if (!bFirst)
            wcscat(pRetVal, wszSeparator);
        bFirst = FALSE;

        KeyRef *pKeyRef = m_paKeys[i];
        VARIANT *pv = &pKeyRef->m_vValue;

        int nType = V_VT(pv);
        switch (nType)
        {
            case VT_LPWSTR:
            case VT_BSTR:
                wcscat(pRetVal, V_BSTR(pv));
                break;

            case VT_I4:
                nVal = V_I4(pv);
                swprintf(Tmp, L"%d", nVal);
                wcscat(pRetVal, Tmp);
                break;

            case VT_I2:
                nVal = V_I2(pv);
                swprintf(Tmp, L"%d", nVal);
                wcscat(pRetVal, Tmp);
                break;

            case VT_UI1:
                nVal = V_UI1(pv);
                swprintf(Tmp, L"%d", nVal);
                wcscat(pRetVal, Tmp);
                break;

            case VT_BOOL:
                nVal = V_BOOL(pv);
                swprintf(Tmp, L"%d", (nVal?1:0));
                wcscat(pRetVal, Tmp);
                break;

            default:
                wcscat(pRetVal, L"NULL");
        }
    }

    if (wcslen(pRetVal) == 0)
    {
        if(m_bSingletonObj)
        {
            wcscpy(pRetVal, L"@");
        }
    }
    return pRetVal;     // This may not be NULL
}

LPWSTR ParsedObjectPath::GetNamespacePart()
{
    if(m_pServer == NULL && m_dwNumNamespaces == 0)
        return NULL;

    // Compute necessary space
    // =======================

    int nSpace = 0;
    for(DWORD i = 0; i < m_dwNumNamespaces; i++)
        nSpace += 1 + wcslen(m_paNamespaces[i]);
    nSpace--;

    // Allocate buffer
    // ===============

    LPWSTR wszOut = new wchar_t[nSpace + 1];
    *wszOut = 0;

    // Output
    // ======

    for(i = 0; i < m_dwNumNamespaces; i++)
    {
        if(i != 0) wcscat(wszOut, L"\\");
        wcscat(wszOut, m_paNamespaces[i]);
    }

    return wszOut;
}

LPWSTR ParsedObjectPath::GetParentNamespacePart()
{
    if(m_pServer == NULL && m_dwNumNamespaces < 1) 
        return NULL;

    // Compute necessary space
    // =======================

    int nSpace = 0;
    for(DWORD i = 0; i < m_dwNumNamespaces - 1; i++)
        nSpace += 1 + wcslen(m_paNamespaces[i]);
    nSpace--;

    // Allocate buffer
    // ===============

    LPWSTR wszOut = new wchar_t[nSpace + 1];
    *wszOut = 0;

    // Output
    // ======

    for(i = 0; i < m_dwNumNamespaces - 1; i++)
    {
        if(i != 0) wcscat(wszOut, L"\\");
        wcscat(wszOut, m_paNamespaces[i]);
    }

    return wszOut;
}

BOOL ParsedObjectPath::IsRelative(LPWSTR wszMachine, LPWSTR wszNamespace)
{
    if(!IsLocal(wszMachine))
        return FALSE;

    if(m_dwNumNamespaces == 0)
        return TRUE;

    LPWSTR wszCopy = new wchar_t[wcslen(wszNamespace) + 1];
    wcscpy(wszCopy, wszNamespace);
    LPWSTR wszLeft = wszCopy;
    BOOL bFailed = FALSE;

    for(DWORD i = 0; i < m_dwNumNamespaces; i++)
    {
        unsigned int nLen = wcslen(m_paNamespaces[i]);
        if(nLen > wcslen(wszLeft))
        {
            bFailed = TRUE;
            break;
        }
        if(i == m_dwNumNamespaces - 1 && wszLeft[nLen] != 0)
        {
            bFailed = TRUE;
            break;
        }
        if(i != m_dwNumNamespaces - 1 && wszLeft[nLen] != L'\\')
        {
            bFailed = TRUE;
            break;
        }

        wszLeft[nLen] = 0;
        if(_wcsicmp(wszLeft, m_paNamespaces[i]))
        {
            bFailed = TRUE;
            break;
        }
        wszLeft += nLen+1;
    }
    delete [] wszCopy;
    return !bFailed;
}

BOOL ParsedObjectPath::IsLocal(LPWSTR wszMachine)
{
    return (m_pServer == NULL || !_wcsicmp(m_pServer, L".") ||
        !_wcsicmp(m_pServer, wszMachine));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\objpathparser\objpath.h ===
// **************************************************************************

// Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// File:  OBJPATH.H
//
// Description:  
//    Object path parser.
//
// History:
//
// **************************************************************************

#ifndef _OBJPATH_H_
#define _OBJPATH_H_

#include <opathlex.h>

#define DELETE_ME

struct  KeyRef
{
    LPWSTR  m_pName;
    VARIANT m_vValue;

    KeyRef();
    KeyRef(LPCWSTR wszKeyName, const VARIANT* pvValue);
   ~KeyRef();
};

struct  ParsedObjectPath
{
    LPWSTR      m_pServer;              // NULL if no server
    DWORD       m_dwNumNamespaces;      // 0 if no namespaces
    DWORD       m_dwAllocNamespaces;    // size of m_paNamespaces
    LPWSTR     *m_paNamespaces;         // NULL if no namespaces
    LPWSTR      m_pClass;               // Class name
    DWORD       m_dwNumKeys;            // 0 if no keys (just a class name)
    DWORD       m_dwAllocKeys;          // size of m_paKeys
    KeyRef    **m_paKeys;               // NULL if no keys specified
    BOOL        m_bSingletonObj;        // true if object of class with no keys
    ParsedObjectPath();
   ~ParsedObjectPath();

public:
    BOOL SetClassName(LPCWSTR wszClassName);
    BOOL AddKeyRef(LPCWSTR wszKeyName, const VARIANT* pvValue);
    BOOL AddKeyRef(KeyRef* pAcquireRef);
	BOOL AddKeyRefEx(LPCWSTR wszKeyName, const VARIANT* pvValue);
    BOOL AddNamespace(LPCWSTR wszNamespace);
    LPWSTR GetKeyString();
    LPWSTR GetNamespacePart();
	LPWSTR GetParentNamespacePart();
	void ClearKeys () ;
    BOOL IsRelative(LPWSTR wszMachine, LPWSTR wszNamespace);
    BOOL IsLocal(LPWSTR wszMachine);
    BOOL IsClass();
    BOOL IsInstance();
    BOOL IsObject();
};

// NOTE:
// The m_vValue in the KeyRef may not be of the expected type, i.e., the parser
// cannot distinguish 16 bit integers from 32 bit integers if they fall within the
// legal subrange of a 16 bit value.  Therefore, the parser only uses the following
// types for keys:
//      VT_I4, VT_R8, VT_BSTR
// If the underlying type is different, the user of this parser must do appropriate
// type conversion.
//  
typedef enum
{
    e_ParserAcceptRelativeNamespace,
    e_ParserAbsoluteNamespaceOnly
} ObjectParserFlags;

class  CObjectPathParser
{
    LPWSTR m_pInitialIdent;
    int m_nCurrentToken;
    CGenLexer *m_pLexer;
    ParsedObjectPath *m_pOutput;
    KeyRef *m_pTmpKeyRef;
    
    ObjectParserFlags m_eFlags;

private:
    void Zero();
    void Empty();

    int begin_parse();

    int ns_or_server();
    int ns_or_class();
    int objref();
    int ns_list();
    int ident_becomes_ns();
    int ident_becomes_class();
    int objref_rest();
    int ns_list_rest();
    int key_const();
    int keyref_list();
    int keyref();
    int keyref_term();
    int propname();    
    int optional_objref();

    int NextToken();

public:
    enum { NoError, SyntaxError, InvalidParameter };

    CObjectPathParser(ObjectParserFlags eFlags = e_ParserAbsoluteNamespaceOnly);
   ~CObjectPathParser();

    int Parse(
        LPWSTR RawPath,
        ParsedObjectPath **pOutput
        );
    static int Unparse(
        ParsedObjectPath* pInput,
        DELETE_ME LPWSTR* pwszPath);

    static LPWSTR GetRelativePath(LPWSTR wszFullPath);

    void Free(ParsedObjectPath *pOutput);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\objpathparser\opathlex.h ===
// **************************************************************************

// Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// File:  OPATHLEX.H
//
// Description:  
//    Object Path DFA Tokens
//
// History:
//  24-Jun-95       Created.
//  14-Apr-98       Radical update for singly quoted strings, remove
//                  unused tokens, add hex constants, etc.
//
// **************************************************************************

#ifndef _OPATHLEX_H_

#define OPATH_TOK_EOF       0
#define OPATH_TOK_ERROR     1

#define OPATH_TOK_IDENT         100
#define OPATH_TOK_QSTRING       101
#define OPATH_TOK_INT           102
#define OPATH_TOK_HEXINT        103
#define OPATH_TOK_EQ            104

#define OPATH_TOK_DOT           105
#define OPATH_TOK_OPEN_PAREN    106
#define OPATH_TOK_CLOSE_PAREN   107
#define OPATH_TOK_SINGLETON_SYM 108
#define OPATH_TOK_COMMA         109

#define OPATH_TOK_BACKSLASH     110
#define OPATH_TOK_COLON         111

#define OPATH_SINGLETON_STRING  L"@"

extern LexEl OPath_LexTable[];


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\objpathparser\opathlex.cpp ===
// **************************************************************************

// Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// File:  OPATHLEX.CPP
//
// Description:  
//    Object Path Lexer Map (for use with GENLEX.CPP).
//
// History:
//  24-Jun-95       Created.
//  14-Apr-98       Radical update for singly quoted strings, remove
//                  unused tokens, add hex constants, etc.
//
// **************************************************************************

#include <windows.h>
#include <stdio.h>

#include <genlex.h>
#include <opathlex.h>             


#define ST_IDENT            22
#define ST_NUMERIC          28
#define ST_DECIMAL          30
#define ST_HEX              32
#define ST_SQ_STRING        36
#define ST_DQ_STRING        40
#define ST_DQ_STRING_ESC    43



// DFA State Table for Object Path tokens.
// =======================================

LexEl OPath_LexTable[] =
{

// State    First   Last        New state,  Return tok,      Instructions
// =======================================================================

    // -------------------------------------------------------------
    // Identifiers
    
/* 0 */  L'A',   L'Z',       ST_IDENT,   0,               GLEX_ACCEPT,
/* 1 */  L'a',   L'z',       ST_IDENT,   0,               GLEX_ACCEPT,
/* 2 */  0x80,   0xfffd,     ST_IDENT,   0,               GLEX_ACCEPT,
/* 3 */  L'_',   GLEX_EMPTY, ST_IDENT,   0,               GLEX_ACCEPT,

    // -------------------------------------------------------------
    // Single symbols
    
/* 4 */  L'.',   GLEX_EMPTY, 0,  OPATH_TOK_DOT,              GLEX_ACCEPT,
/* 5 */  '@',    GLEX_EMPTY, 0,  OPATH_TOK_SINGLETON_SYM,    GLEX_ACCEPT,
/* 6 */  L'=',   GLEX_EMPTY, 0,  OPATH_TOK_EQ,               GLEX_ACCEPT,
/* 7 */  L':',   GLEX_EMPTY, 0,  OPATH_TOK_COLON,            GLEX_ACCEPT,

    // -------------------------------------------------------------
    // Backslashes & forward slashes are interchangeable and reported
    // as OPATH_TOK_BACKSLASH to the parser.
    
/* 8 */ L'\\',  GLEX_EMPTY, 0, OPATH_TOK_BACKSLASH,      GLEX_ACCEPT,
/* 9 */ L'/',   GLEX_EMPTY, 0, OPATH_TOK_BACKSLASH,      GLEX_ACCEPT,

    // -------------------------------------------------------------
    // Simple numeric transition.  The '-' must be followed
    // by decimal digit sequence.  The '0' may be the beginning of a hex
    // or a decimal sequence.
    
/* 10 */ L'1',   L'9',       ST_DECIMAL, 0,               GLEX_ACCEPT,
/* 11 */ L'-',   GLEX_EMPTY, ST_DECIMAL, 0,               GLEX_ACCEPT,
/* 12 */ L'0',   GLEX_EMPTY, ST_NUMERIC, 0,               GLEX_ACCEPT,


    // -------------------------------------------------------------
    // Simple string transition
    //
    // If a single quote begins the string, it must end the string.
    // Escapes are not supported:   'ab', 'a"b'  <not: 'a\'b'>
    //
    // If a double quote begins the string, it must end the string,
    // except that escape+quote is an embedded double quote:
    //
    //     "ab", "a'b", "a\"b"
    // 
        
/* 13 */ L'"',   GLEX_EMPTY, ST_DQ_STRING, 0,               GLEX_CONSUME,
/* 14 */ L'\'',  GLEX_EMPTY, ST_SQ_STRING, 0,               GLEX_CONSUME,


    // -------------------------------------------------------------
    // Whitespace, newlines, etc.  Whitespace is an error.
    
/* 15 */ L' ',   GLEX_EMPTY, 0,  OPATH_TOK_ERROR,  GLEX_ACCEPT|GLEX_RETURN,
/* 16 */ L'\t',  GLEX_EMPTY, 0,  OPATH_TOK_ERROR,  GLEX_ACCEPT|GLEX_RETURN,
/* 17 */ L'\n',  GLEX_EMPTY, 0,  OPATH_TOK_ERROR,  GLEX_ACCEPT|GLEX_RETURN,
/* 18 */ L'\r',  GLEX_EMPTY, 0,  OPATH_TOK_ERROR,  GLEX_ACCEPT|GLEX_RETURN,
/* 19 */ 0,      GLEX_EMPTY, 0,  OPATH_TOK_EOF,   GLEX_CONSUME|GLEX_RETURN, // Note forced return
/* 20 */ L',',   GLEX_EMPTY, 0,  OPATH_TOK_COMMA, GLEX_ACCEPT,

    // All remaining unknown characters

/* 21 */ GLEX_ANY, GLEX_EMPTY, 0,        OPATH_TOK_ERROR, GLEX_ACCEPT|GLEX_RETURN,


    // -------------------------------------------------------------
    // ST_IDENT
    // Accepts C/C++ identifiers, plus any char >= U+0080.

/* 22 */  L'a',   L'z',       ST_IDENT,   0,          GLEX_ACCEPT,
/* 23 */  L'A',   L'Z',       ST_IDENT,   0,          GLEX_ACCEPT,
/* 24 */  L'_',   GLEX_EMPTY, ST_IDENT,   0,          GLEX_ACCEPT,
/* 25 */  L'0',   L'9',       ST_IDENT,   0,          GLEX_ACCEPT,
/* 26 */  0x80,  0xfffd,     ST_IDENT,   0,           GLEX_ACCEPT,
/* 27 */  GLEX_ANY, GLEX_EMPTY,  0,       OPATH_TOK_IDENT,  GLEX_PUSHBACK|GLEX_RETURN,

    // -------------------------------------------------------------
    // ST_NUMERIC
    // 
    // A zero has been recognized.
    // If the next char is 'x' or 'X', we have a valid hex sequence.
    // Otherwise, if '1' to '9' we have a decimal sequence.
    // 

/* 28 */  L'x',  GLEX_EMPTY,  ST_HEX,  0,    GLEX_ACCEPT,
/* 29 */  L'X',  GLEX_EMPTY,  ST_HEX,  0,    GLEX_ACCEPT,


    // -------------------------------------------------------------
    // ST_DECIMAL
    // 

/* 30 */  L'0',     L'9',       ST_DECIMAL, 0,              GLEX_ACCEPT,
/* 31 */  GLEX_ANY, GLEX_EMPTY, 0,          OPATH_TOK_INT,  GLEX_PUSHBACK|GLEX_RETURN,

    // -------------------------------------------------------------
    // ST_HEX
    //
    // Recognizes a valid hex sequence.

/* 32 */  L'a',     L'f',       ST_HEX,     0,                 GLEX_ACCEPT,
/* 33 */  L'A',     L'F',       ST_HEX,     0,                 GLEX_ACCEPT,
/* 34 */  L'0',     L'9',       ST_HEX,     0,                 GLEX_ACCEPT,
/* 35 */  GLEX_ANY, GLEX_EMPTY, 0,          OPATH_TOK_HEXINT,  GLEX_PUSHBACK|GLEX_RETURN,
    
    // -------------------------------------------------------------
    // ST_SQ_STRING : Single quoted strings
    //
    // If a single quote begins the string, it must end the string.
    // Escapes are not supported:   'ab', 'a"b'  <not: 'a\'b'>

/* 36 */   L'\n', GLEX_EMPTY, 0,  OPATH_TOK_ERROR,      GLEX_ACCEPT|GLEX_LINEFEED,
/* 37 */   L'\r', GLEX_EMPTY, 0,  OPATH_TOK_ERROR,      GLEX_ACCEPT|GLEX_LINEFEED,
/* 38 */   L'\'',  GLEX_EMPTY, 0,  OPATH_TOK_QSTRING,   GLEX_CONSUME,
/* 39 */   GLEX_ANY, GLEX_EMPTY, ST_SQ_STRING,  0,      GLEX_ACCEPT,

    // -------------------------------------------------------------
    // ST_DQ_STRING
    //
    // If a double quote begins the string, it must end the string,
    // except that escape+quote is an embedded double quote:
    //
    //     "ab", "a'b", "a\"b"
    // 

/* 40 */   L'\\', GLEX_EMPTY, ST_DQ_STRING_ESC, 0,                  GLEX_CONSUME,    // Escape
/* 41 */   L'"',  GLEX_EMPTY, 0,                OPATH_TOK_QSTRING,  GLEX_CONSUME,
/* 42 */   L'"',  GLEX_EMPTY, ST_DQ_STRING,     0,                  GLEX_ACCEPT|GLEX_NOT, 
                    // Accept anything but a quote

    //-------------------------------------------------------------
    // ST_DQ_STRING_ESC
    //
    // An escape occurred while in a string.
    // Either an embedded slash or embedded quote must have occurred.
    // Otherwise, an unsupported escape has occurred and we fail.

/* 43  */    L'\\', GLEX_EMPTY, ST_DQ_STRING, 0,  GLEX_ACCEPT,
/* 44  */    L'"',  GLEX_EMPTY, ST_DQ_STRING, 0,  GLEX_ACCEPT,
/* 45  */ GLEX_ANY, GLEX_EMPTY, 0,        OPATH_TOK_ERROR, GLEX_ACCEPT|GLEX_RETURN,

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\pingwbem\makefile.inc ===
$(O)\makefile : makefile.nm
	copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\objpathparser\pathtest.cpp ===
// **************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// File:  pathtest.cpp
//
// Description:  
//		  Test app to test the object path parser
//
// History:
//
// **************************************************************************

#include <windows.h>
#include <stdio.h>

#include "genlex.h"
#include "objpath.h"



void main(int argc, char **argv)
{
    ParsedObjectPath* pOutput = 0;

    wchar_t *pPath = L"\\\\.\\root\\default:MyClass=\"keyval\"";

    CObjectPathParser p;
    int nStatus = p.Parse(pPath,  &pOutput);

    printf("Return code is %d\n", nStatus);

    if (nStatus != 0)
        return;

    printf("----Output----\n");

    LPWSTR pKey = pOutput->GetKeyString();
    printf("Key String = <%S>\n", pKey);
    delete pKey;

    printf("Server = %S\n", pOutput->m_pServer);

    for (DWORD dwIx = 0; dwIx < pOutput->m_dwNumNamespaces; dwIx++)
    {
        printf("Namespace = <%S>\n", pOutput->m_paNamespaces[dwIx]);
    }

    printf("Class = <%S>\n", pOutput->m_pClass);

    // If here, the key ref is complete.
    // =================================

    for (dwIx = 0; dwIx < pOutput->m_dwNumKeys; dwIx++)
    {
        KeyRef *pTmp = pOutput->m_paKeys[dwIx];
        printf("*** KeyRef contents:\n");
        printf("    Name = %S   Value=", pTmp->m_pName);
        switch (V_VT(&pTmp->m_vValue))
        {
            case VT_I4: printf("%d", V_I4(&pTmp->m_vValue)); break;
            case VT_R8: printf("%f", V_R8(&pTmp->m_vValue)); break;
            case VT_BSTR: printf("<%S>", V_BSTR(&pTmp->m_vValue)); break;
            default:
                printf("BAD KEY REF\n");
        }
        printf("\n");
    }


    p.Free(pOutput);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\propprov\makefile.inc ===
$(O)\makefile : makefile.nm
	copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\pathparser\pathparser.cpp ===
// **************************************************************************
//
// Copyright (c) 2001 Microsoft Corporation, All Rights Reserved
//
// File:  PathParser.cpp 
//
// Description:
//      WMI Path Parser Sample.
//      This sample shows how to use the Path Parser.  It takes a path as a command
//      line argument and passes it off to the parser to be parsed and then uses various
//      functions to get pieces of the path.
//
// History:
//
// **************************************************************************

#include <objbase.h>
#include <windows.h>                                     
#include <stdio.h>
#include <wbemidl.h> 
#include <wmiutils.h>

//***************************************************************************
//
// DumpServerName
//
// Purpose: Dumps the server name
//
//***************************************************************************

void DumpServerName(IWbemPath * pParser)
{
    HRESULT hr;

    // One could safely assume a maximum server name, but for the sake of example,
    // the code will call GetServer in order to determine how long of name is needed, then
    // do the allocation, then get the name and finally dump it.
    
    DWORD dwSize = 0;
    hr = pParser->GetServer(&dwSize, NULL);
    if(FAILED(hr) || dwSize == 0)
        return;                                 // nothing here, just return

    WCHAR * pServer = new WCHAR[dwSize];
    if(pServer)
    {
        hr = pParser->GetServer(&dwSize,  pServer);
        if(FAILED(hr))
            printf("\nUnexpected failure, hr = 0x%x", hr);
        else
            printf("\nThe server name is <%S>", pServer);
        delete [] pServer;
    }
}

//***************************************************************************
//
// DumpNamespaces
//
// Purpose: Dumps the name spaces
//
//***************************************************************************

void DumpNamespaces(IWbemPath * pParser)
{
    HRESULT hr;

    // first get the number of namespaces

    ULONG lCnt;
    hr  = pParser->GetNamespaceCount(&lCnt);
    if(FAILED(hr))
    {
        printf("\nGetNamespaceCount failed, hr = 0x%x", hr);
        return;
    }
    
    for(ULONG dwCnt = 0; dwCnt < lCnt; dwCnt++)
    {
        if(dwCnt == 0)
            printf("\nNamespaces=");
        else
            printf(",");

        // first determine the necessary buffer size
        
        DWORD dwSize = 0;
        hr = pParser->GetNamespaceAt(dwCnt, &dwSize, NULL);
        if(FAILED(hr) || dwSize == 0)
        {
            printf("\nGetNamespaceAt failed, hr = 0x%x", hr);
            return;
        }

        WCHAR * pNamespace = new WCHAR[dwSize];
        if(pNamespace)
        {
            hr = pParser->GetNamespaceAt(dwCnt, &dwSize,  pNamespace);
            if(FAILED(hr))
                printf("\nGetNamespaceAt failed for index %d, sc = 0x%x", dwCnt, hr);
            else
                printf("%S", pNamespace);
            delete [] pNamespace;
        }
    }
}

//***************************************************************************
//
// DumpClassName
//
// Purpose: Dumps the class name
//
//***************************************************************************

void DumpClassName(IWbemPath * pParser)
{
    HRESULT hr;

    // One could safely assume a maximum class name, but for the sake of example,
    // the code will call GetClassName in order to determine how long of name is needed, then
    // do the allocation, then get the name and finally dump it.
    
    DWORD dwSize = 0;
    hr = pParser->GetClassName(&dwSize, NULL);
    if(FAILED(hr) || dwSize == 0)
        return;                                 // nothing here, just return

    WCHAR * pClassName = new WCHAR[dwSize];
    if(pClassName)
    {
        hr = pParser->GetClassName(&dwSize,  pClassName);
        if(FAILED(hr))
            printf("\nUnexpected failure, hr = 0x%x", hr);
        else
            printf("\nThe class name is <%S>", pClassName);
        delete [] pClassName;
    }
}

//***************************************************************************
//
// DumpKeyList
//
// Purpose: Dumps out the keys
//
//***************************************************************************

void DumpKeyList(IWbemPath * pParser)
{

    HRESULT hr;
    IWbemPathKeyList * pKeyList = NULL;
    hr = pParser->GetKeyList(&pKeyList);
    if(FAILED(hr) || pKeyList == NULL)
    {
        printf("\nNULL KEY LIST *****************");
        return;
    }

    unsigned long uNumKey;
    hr = pKeyList->GetCount(&uNumKey);
    if(FAILED(hr))
    {
        printf("\nGetCount failed, hr = 0x%x", hr);
        return;
    }
    printf("\nThe key count is %d", uNumKey);

    // check for the special case of a singleton.  In this case, the path does not have a named key and the
    // value is "@"

    if(uNumKey == 0)
    {
        ULONGLONG uResponse;
        hr = pKeyList->GetInfo(0, &uResponse);
        if(SUCCEEDED(hr) && (uResponse & WBEMPATH_INFO_CONTAINS_SINGLETON))
        {
            printf("\nPath is a singleton");
            return;
        }
    }

    // for the sake of clarity, this example assumes a maximum name size of 256.  Normally, an application would
    // take one of two approaches;  First, it could just allocate a buffer the size of the text used in the SetText 
    // call and assume that is sufficient for the largest piece.  Second, it can call GetKey2 will a NULL pointer
    // to the name buffer and find out how large it needs to be, as is done in the DumpClassName and 
    // DumpServer routines.
    
     WCHAR wName[256];
     for(DWORD uKeyIx = 0; uKeyIx < uNumKey ; uKeyIx++)
     {
        ULONG uKeyType; 
        DWORD dwSize = 256;

        VARIANT var, var2;
        VariantInit(&var);
        VariantInit(&var2);
        hr = pKeyList->GetKey2(uKeyIx, 0, &dwSize, wName, &var, &uKeyType);
        if(FAILED(hr))
        {
            printf("\nGetKey2 failed, index = %d, hr = 0x%x", uKeyIx, hr);
        }
        else
        {
            // here we use Variant change type as a convenient string conversion routine.
            
            hr = VariantChangeType(&var2, &var, 0, VT_BSTR);
            if(SUCCEEDED(hr))
            {
                printf("\nKey %d, has name <%S>, type %d, value <%S>", uKeyIx, wName, uKeyType, var2.bstrVal);
                VariantClear(&var2);
            }
            else
                printf("\nVariantChangeType failed, hr = 0x%x", hr);
        VariantClear(&var);
        }
     }
}

//***************************************************************************
//
// ParseAndDump
//
// Purpose: Does the actual parse, and dumps information
//
//***************************************************************************

void ParseAndDump(IWbemPath * pParser, WCHAR * pwcPath)
{
    HRESULT hr;
    printf("\nAttempting to parse string <%S>", pwcPath);
    hr = pParser->SetText(WBEMPATH_CREATE_ACCEPT_ALL, pwcPath);
    if(FAILED(hr))
    {
        printf("\nParse failed, return code is 0x%x", hr);
        return;
    }
    DumpServerName(pParser);
    DumpNamespaces(pParser);
    DumpClassName(pParser);
    DumpKeyList(pParser);
}

//***************************************************************************
//
// main
//
// Purpose: Program entry point.  It checks the argument, converts it to unicode,
//               initializes Com, and creates the parser.
//
//***************************************************************************

int main(int iArgCnt, char ** argv)
{

    // First argument is the is the path.  If not present, dump out a usage message.

    if(iArgCnt < 2)
    {
        printf("\nUsage:  PathParser <PathToBeParsed>"
                 "\nExample:  PathParser \\\\MyServer\\root\\default:stdregprov=@"
                 "\nor        PathParser \\\\MyServer\\root\\default:stdregprov.key=\\\"hello\\\""
                 "\nor        PathParser \\\\MyServer\\root\\default:stdregprov.key=23"
                 );
        return 1;
    }

    // Convert to unicode

    int iLen = strlen(argv[1]);
    WCHAR * pwcPath = new WCHAR[iLen+1];
    if(pwcPath == NULL)
    {
        printf("\nFailed due to lack of memory");
        return 1;
    }
    mbstowcs(pwcPath, argv[1], iLen + 1);
 
    // Initialize COM and create the path parser object

    HRESULT hr = CoInitializeEx(0, COINIT_MULTITHREADED);
    if(SUCCEEDED(hr))
    {
        IWbemPath *pParser = NULL;
        hr = CoCreateInstance(CLSID_WbemDefPath, 0, CLSCTX_INPROC_SERVER,
                                                                     IID_IWbemPath, (LPVOID *) &pParser);
        if(SUCCEEDED(hr))
        {
            ParseAndDump(pParser, pwcPath);
            pParser->Release();
        }
        else
            printf("\nCoCreateInstance of CLSID_WbemDefPath, return is 0x%x", hr);
        CoUninitialize();
    }
    delete [] pwcPath;
    printf("\nTerminating normally");
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\pingwbem\main.cpp ===
// **************************************************************************

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// File:  main.cpp
//
// Description:
//      This file implements the pingWBEM tutorial.
//		It shows how to make a WMI connection to a target machine.
// 
// History:
//
// **************************************************************************

#pragma warning(disable:4514 4201)

#include <windows.h>
#include <stdio.h>                  // fprintf
#include <wbemcli.h>  // wmi interface declarations
#include <tchar.h>                  // char macros

#define CVTFAILED _T("WideCharToMultiByte failed")
#define PAGESIZE 4096

// prototypes.
WCHAR *cvt(char *x, WCHAR **y);
int myFWPrintf(FILE *f, TCHAR *fmt, ...);
DWORD ProcessCommandLine(int argc, TCHAR *argv[]);
TCHAR *ErrorString(HRESULT hRes);

// globals
BOOL bFile;
FILE *g_fOut;
TCHAR *pwcsGNamespace = _T("root\\cimv2"); // NameSpace to start from

//***************************************************************************
//
// main - used main since the command line parameters come in as char.
//
//***************************************************************************
extern "C" int main(int argc, char *argv[])
{
	IWbemServices *pIWbemServices = NULL;
	HRESULT hRes;
	IWbemLocator *pIWbemLocator = NULL;
	BSTR Namespace = NULL;
	WCHAR *temp;

	// process the command line
	if (ProcessCommandLine(argc, argv) == S_OK) 
	{
		// Initialize COM.
		if ((hRes = CoInitialize(NULL)) == S_OK) 
		{
			// Create an instance of the WbemLocator interface
			if ((hRes = CoCreateInstance(CLSID_WbemLocator,
											NULL,
											CLSCTX_INPROC_SERVER,
											IID_IWbemLocator,
											(LPVOID *) &pIWbemLocator)) == S_OK)
			{
				// Use the pointer returned in step two to connect to
				//     the server using the passed in namespace.
				Namespace = SysAllocString(cvt(pwcsGNamespace, &temp));

				if ((hRes = pIWbemLocator->ConnectServer(Namespace,
														NULL, 
														NULL, 
														NULL, 0L,       // locale, flags
														NULL,           //authority
														NULL,                           // Context
														&pIWbemServices)) == S_OK)
				{
				myFWPrintf(g_fOut, _T("%s was found: %s\n"), pwcsGNamespace, ErrorString(hRes));

					// release the service.
					if (pIWbemServices)
					{ 
						pIWbemServices->Release(); 
						pIWbemServices = NULL;
					}
				}
				else
				{
				myFWPrintf(g_fOut, _T("%s not found: %s\n"), pwcsGNamespace, ErrorString(hRes));
				} //endif ConnectServer()

				// cleanup the BSTRs
				SysFreeString(Namespace);

				// release th locator.
				if (pIWbemLocator) 
				{ 
					pIWbemLocator->Release(); 
					pIWbemLocator = NULL;
				}
			}
			else
			{
			  myFWPrintf(g_fOut, _T("Failed to create IWbemLocator object: %s\n"), ErrorString(hRes));
			} //endif CoCreateInstance()

			// done with COM.
		   CoUninitialize();
		}
		else
		{
		  myFWPrintf(g_fOut, _T("OleInitialize Failed: %s\n"), ErrorString(hRes));
		} //endif OleInitialize()
   }

   // Wrapup and exit
   if (bFile) 
   {
      fclose(g_fOut);
   }

   return 0;
}

//*****************************************************************************
// Function:   ProcessCommandLine
// Purpose:    This function processes the command line for the program, 
//             filling in the global variables determining what the program 
//             will do.
//*****************************************************************************
DWORD ProcessCommandLine(int argc, TCHAR *argv[])
{
   int iLoop;
   char *szHelp = "PingWBEM - Pings a machine for a WMI Service.\n\n"
		  "\n"
		  "Syntax: PingWBEM [Namespace]\n"
		  "Where:  'Namespace' is the namespace to ping (defaults to root\\cimv2)\n"
		  "\n"
		  "EXAMPLES:\n"
		  "\n"
		  "  PingWBEM                         - Pings the local machine\n"
		  "  PingWBEM \\\\foo\\root\\cimv2      - Pings the foo machine\n"
		  "\n";

   // Process all the arguments.
   // ==========================

   // Set global flags depending on command line arguments
   for (iLoop = 1; iLoop < argc; ++iLoop) 
   {
      if (stricmp(argv[iLoop], _T("/HELP")) == 0 || 
		  stricmp(argv[iLoop],_T("-HELP")) == 0 || 
	 (strcmp(argv[iLoop], _T("/?")) == 0) || 
		 (strcmp(argv[iLoop], _T("-?")) == 0)) 
	  {
	 fputs(szHelp, stdout);
	 return(S_FALSE);
      } 
	  else // must be the namespace.
	  {
		 pwcsGNamespace = argv[iLoop];
      } //endif argv

   } //endfor

   if (!bFile) 
   {
      g_fOut = stdout;
   }

   // Finished.
   // =========

   return(S_OK);
}

//*****************************************************************************
// Function:   WbemErrorString
// Purpose:    Turns sc into a text string
//*****************************************************************************
TCHAR *ErrorString(HRESULT hRes)
{
	TCHAR szBuffer2[19];
	static TCHAR szBuffer[sizeof(szBuffer2) + 4];
	TCHAR *psz;

   switch(hRes) 
   {
   case WBEM_NO_ERROR:
		psz = _T("WBEM_NO_ERROR");
		break;
   case WBEM_S_FALSE:
		psz = _T("WBEM_S_FALSE");
		break;
   case WBEM_S_NO_MORE_DATA:
		psz = _T("WBEM_S_NO_MORE_DATA");
		break;
	case WBEM_E_FAILED:
		psz = _T("WBEM_E_FAILED");
		break;
	case WBEM_E_NOT_FOUND:
		psz = _T("WBEM_E_NOT_FOUND");
		break;
	case WBEM_E_ACCESS_DENIED:
		psz = _T("WBEM_E_ACCESS_DENIED");
		break;
	case WBEM_E_PROVIDER_FAILURE:
		psz = _T("WBEM_E_PROVIDER_FAILURE");
		break;
	case WBEM_E_TYPE_MISMATCH:
		psz = _T("WBEM_E_TYPE_MISMATCH");
		break;
	case WBEM_E_OUT_OF_MEMORY:
		psz = _T("WBEM_E_OUT_OF_MEMORY");
		break;
	case WBEM_E_INVALID_CONTEXT:
		psz = _T("WBEM_E_INVALID_CONTEXT");
		break;
	case WBEM_E_INVALID_PARAMETER:
		psz = _T("WBEM_E_INVALID_PARAMETER");
		break;
	case WBEM_E_NOT_AVAILABLE:
		psz = _T("WBEM_E_NOT_AVAILABLE");
		break;
	case WBEM_E_CRITICAL_ERROR:
		psz = _T("WBEM_E_CRITICAL_ERROR");
		break;
	case WBEM_E_INVALID_STREAM:
		psz = _T("WBEM_E_INVALID_STREAM");
		break;
	case WBEM_E_NOT_SUPPORTED:
		psz = _T("WBEM_E_NOT_SUPPORTED");
		break;
	case WBEM_E_INVALID_SUPERCLASS:
		psz = _T("WBEM_E_INVALID_SUPERCLASS");
		break;
	case WBEM_E_INVALID_NAMESPACE:
		psz = _T("WBEM_E_INVALID_NAMESPACE");
		break;
	case WBEM_E_INVALID_OBJECT:
		psz = _T("WBEM_E_INVALID_OBJECT");
		break;
	case WBEM_E_INVALID_CLASS:
		psz = _T("WBEM_E_INVALID_CLASS");
		break;
	case WBEM_E_PROVIDER_NOT_FOUND:
		psz = _T("WBEM_E_PROVIDER_NOT_FOUND");
		break;
	case WBEM_E_INVALID_PROVIDER_REGISTRATION:
		psz = _T("WBEM_E_INVALID_PROVIDER_REGISTRATION");
		break;
	case WBEM_E_PROVIDER_LOAD_FAILURE:
		psz = _T("WBEM_E_PROVIDER_LOAD_FAILURE");
		break;
	case WBEM_E_INITIALIZATION_FAILURE:
		psz = _T("WBEM_E_INITIALIZATION_FAILURE");
		break;
	case WBEM_E_TRANSPORT_FAILURE:
		psz = _T("WBEM_E_TRANSPORT_FAILURE");
		break;
	case WBEM_E_INVALID_OPERATION:
		psz = _T("WBEM_E_INVALID_OPERATION");
		break;
	case WBEM_E_INVALID_QUERY:
		psz = _T("WBEM_E_INVALID_QUERY");
		break;
	case WBEM_E_INVALID_QUERY_TYPE:
		psz = _T("WBEM_E_INVALID_QUERY_TYPE");
		break;
	case WBEM_E_ALREADY_EXISTS:
		psz = _T("WBEM_E_ALREADY_EXISTS");
		break;
   case WBEM_S_ALREADY_EXISTS:
      psz = _T("WBEM_S_ALREADY_EXISTS");
      break;
   case WBEM_S_RESET_TO_DEFAULT:
      psz = _T("WBEM_S_RESET_TO_DEFAULT");
      break;
   case WBEM_S_DIFFERENT:
      psz = _T("WBEM_S_DIFFERENT");
      break;
   case WBEM_E_OVERRIDE_NOT_ALLOWED:
      psz = _T("WBEM_E_OVERRIDE_NOT_ALLOWED");
      break;
   case WBEM_E_PROPAGATED_QUALIFIER:
      psz = _T("WBEM_E_PROPAGATED_QUALIFIER");
      break;
   case WBEM_E_PROPAGATED_PROPERTY:
      psz = _T("WBEM_E_PROPAGATED_PROPERTY");
      break;
   case WBEM_E_UNEXPECTED:
      psz = _T("WBEM_E_UNEXPECTED");
      break;
   case WBEM_E_ILLEGAL_OPERATION:
      psz = _T("WBEM_E_ILLEGAL_OPERATION");
      break;
   case WBEM_E_CANNOT_BE_KEY:
      psz = _T("WBEM_E_CANNOT_BE_KEY");
      break;
   case WBEM_E_INCOMPLETE_CLASS:
      psz = _T("WBEM_E_INCOMPLETE_CLASS");
      break;
   case WBEM_E_INVALID_SYNTAX:
      psz = _T("WBEM_E_INVALID_SYNTAX");
      break;
   case WBEM_E_NONDECORATED_OBJECT:
      psz = _T("WBEM_E_NONDECORATED_OBJECT");
      break;
   case WBEM_E_READ_ONLY:
      psz = _T("WBEM_E_READ_ONLY");
      break;
   case WBEM_E_PROVIDER_NOT_CAPABLE:
      psz = _T("WBEM_E_PROVIDER_NOT_CAPABLE");
      break;
   case WBEM_E_CLASS_HAS_CHILDREN:
      psz = _T("WBEM_E_CLASS_HAS_CHILDREN");
      break;
   case WBEM_E_CLASS_HAS_INSTANCES:
      psz = _T("WBEM_E_CLASS_HAS_INSTANCES");
      break;
   case WBEM_E_QUERY_NOT_IMPLEMENTED:
      psz = _T("WBEM_E_QUERY_NOT_IMPLEMENTED");
      break;
   case WBEM_E_ILLEGAL_NULL:
      psz = _T("WBEM_E_ILLEGAL_NULL");
      break;
   case WBEM_E_INVALID_QUALIFIER_TYPE:
      psz = _T("WBEM_E_INVALID_QUALIFIER_TYPE");
      break;
   case WBEM_E_INVALID_PROPERTY_TYPE:
      psz = _T("WBEM_E_INVALID_PROPERTY_TYPE");
      break;
   case WBEM_E_VALUE_OUT_OF_RANGE:
      psz = _T("WBEM_E_VALUE_OUT_OF_RANGE");
      break;
   case WBEM_E_CANNOT_BE_SINGLETON:
      psz = _T("WBEM_E_CANNOT_BE_SINGLETON");
      break;
	default:
      _ltoa(hRes, szBuffer2, 16);
      strcpy(szBuffer, _T("0x"));
      strcat(szBuffer, szBuffer2);
	  psz = szBuffer;
	  break;
	}
	return psz;
}

//*****************************************************************************
// Function:   cvt
// Purpose:    Converts unicode to oem for console output
// Note:       y must be freed by caller
//*****************************************************************************
WCHAR *cvt(char *x, WCHAR **y)
{
	int dwRet, i;
   
	i = MultiByteToWideChar(CP_OEMCP, 0, x, -1, NULL, NULL);

	// bug#2696 - the number returned by MultiByteToWideChar is the number
	// of WCHARs not the number of BYTEs needed
	*y = (WCHAR *)calloc(i, sizeof(WCHAR));
	dwRet = MultiByteToWideChar(CP_OEMCP, 0, x, -1, *y, i);
	if (dwRet == 0) 
	{
		free(*y);
		*y = (WCHAR *)malloc(sizeof(CVTFAILED));
		memcpy(*y, CVTFAILED, sizeof(CVTFAILED));
	}

	return *y;
};

//*****************************************************************************
// Function:   myWFPrintf
// Purpose:    Checks to see if outputing to console and converts strings
//             to oem if necessary.
// Note:       Returns number of characters written (ie if we write 3 oem
//             chars, it returns 3.  If it writes 4 wchars, it returns 4).
//*****************************************************************************
int myFWPrintf(FILE *f, TCHAR *fmt, ...)

{
   va_list    argptr;
   int i;

   int iSize = PAGESIZE;
   TCHAR *wszBuff = (TCHAR *)malloc(iSize);

   va_start(argptr, fmt);  // Init variable arguments

   // Format the string into a buffer.  Make sure the buffer is big enough
   while (_vsnprintf(wszBuff, (iSize/sizeof(TCHAR))-1, fmt, argptr) == -1) 
   {
      iSize += PAGESIZE;
      wszBuff = (TCHAR *)realloc(wszBuff, iSize);
   }

   if (f == stdout) 
   {
      fputs(wszBuff, f);
      i = (int) strlen(wszBuff);
   } 
   else 
   {
      i = (int) strlen(wszBuff);
      fwrite(wszBuff, i * sizeof(TCHAR), 1, f);
   }

   free(wszBuff);
   va_end(argptr);

   return i;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\propprov\classfac.cpp ===
//***************************************************************************

//

//  CLASSFAC.CPP

//

//  Module: WMI Sample Property Provider

//

//  Purpose: Contains the class factory.  This creates objects when

//           connections are requested.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <objbase.h>
#include "sample.h"

//***************************************************************************
//
// CProvFactory::CProvFactory
// CProvFactory::~CProvFactory
//
// Constructor Parameters:
//  None
//***************************************************************************

CProvFactory::CProvFactory()
{
    m_cRef=0L;
    return;
}

CProvFactory::~CProvFactory(void)
{
    return;
}

//***************************************************************************
//
// CProvFactory::QueryInterface
// CProvFactory::AddRef
// CProvFactory::Release
//
// Purpose: Standard Ole routines needed for all interfaces
//
//***************************************************************************


STDMETHODIMP CProvFactory::QueryInterface(REFIID riid
    , PPVOID ppv)
{
    *ppv=NULL;

    if (IID_IUnknown==riid || IID_IClassFactory==riid)
        *ppv=this;

    if (NULL!=*ppv)
        {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
        }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CProvFactory::AddRef(void)
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CProvFactory::Release(void)
{
    ULONG nNewCount = InterlockedDecrement((long *)&m_cRef);
    if (0L == nNewCount)
        delete this;
    
    return nNewCount;
}

//***************************************************************************
//
// CProvFactory::CreateInstance
//
// Purpose: Instantiates a Locator object returning an interface pointer.
//
// Parameters:
//  pUnkOuter       LPUNKNOWN to the controlling IUnknown if we are
//                  being used in an aggregation.
//  riid            REFIID identifying the interface the caller
//                  desires to have for the new object.
//  ppvObj          PPVOID in which to store the desired
//                  interface pointer for the new object.
//
// Return Value:
//  HRESULT         NOERROR if successful, otherwise E_NOINTERFACE
//                  if we cannot support the requested interface.
//***************************************************************************

STDMETHODIMP CProvFactory::CreateInstance(LPUNKNOWN pUnkOuter
    , REFIID riid, PPVOID ppvObj)
{
    IUnknown *   pObj;
    HRESULT      hr;

    *ppvObj=NULL;

    // This object doesnt support aggregation.

    if (NULL!=pUnkOuter)
        return CLASS_E_NOAGGREGATION;

    //Create the object.
    
    pObj= new CPropPro();

    if (NULL==pObj)
        return E_OUTOFMEMORY;

    hr=pObj->QueryInterface(riid, ppvObj);

    //Kill the object if initial creation or Init failed.
    if (FAILED(hr))
        delete pObj;
    return hr;
}

//***************************************************************************
//
// CProvFactory::LockServer
//
// Purpose:
//  Increments or decrements the lock count of the DLL.  If the
//  lock count goes to zero and there are no objects, the DLL
//  is allowed to unload.  See DllCanUnloadNow.
//
// Parameters:
//  fLock           BOOL specifying whether to increment or
//                  decrement the lock count.
//
// Return Value:
//  HRESULT         NOERROR always.
//***************************************************************************


STDMETHODIMP CProvFactory::LockServer(BOOL fLock)
{
    if (fLock)
        InterlockedIncrement(&g_cLock);
    else
        InterlockedDecrement(&g_cLock);
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\propprov\maindll.cpp ===
//***************************************************************************

//

//  MAINDLL.CPP

// 

//  Module: WMI Sample Property Provider

//

//  Purpose: Contains DLL entry points.  Also has code that controls

//           when the DLL can be unloaded by tracking the number of

//           objects and locks as well as routines that support

//           self registration.  

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <objbase.h>
#include <initguid.h>
#include "sample.h"

HMODULE ghModule;

// TODO, GuidGen should be used to generate a unique number for any 
// providers that are going to be used for anything more extensive 
// than just testing.

DEFINE_GUID(CLSID_PropProvider,0xCEDEB622L,0x8C78,0x11CF,0xA5,0xB6,0x00,0xAA,0x00,0x68,0x0C,0x3F);

//Count number of objects and number of locks.

long       g_cObj=0;
long       g_cLock=0;

//***************************************************************************
//
// LibMain32
//
// Purpose: Entry point for DLL.
//
// Return: TRUE if OK.
//
//***************************************************************************


BOOL WINAPI LibMain32(HINSTANCE hInstance, ULONG ulReason
    , LPVOID pvReserved)
{

    if (DLL_PROCESS_ATTACH==ulReason)
        ghModule = hInstance;
    return TRUE;
}

//***************************************************************************
//
//  DllGetClassObject
//
//  Purpose: Called by Ole when some client wants a class factory.  Return 
//           one only if it is the sort of class this DLL supports.
//
//***************************************************************************


STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, PPVOID ppv)
{
    HRESULT hr;
    CProvFactory *pObj;

    if (CLSID_PropProvider!=rclsid)
        return E_FAIL;

    pObj=new CProvFactory();

    if (NULL==pObj)
        return E_OUTOFMEMORY;


    hr=pObj->QueryInterface(riid, ppv);

    if (FAILED(hr))
        delete pObj;

    return hr;
}

//***************************************************************************
//
// DllCanUnloadNow
//
// Purpose: Called periodically by Ole in order to determine if the
//          DLL can be freed.
//
// Return:  S_OK if there are no objects in use and the class factory 
//          isn't locked.
//
//***************************************************************************

STDAPI DllCanUnloadNow(void)
{
    SCODE   sc;

    //It is OK to unload if there are no objects or locks on the 
    // class factory.
    
    sc=( g_cObj < 1 && g_cLock < 1) ? S_OK : S_FALSE;
    return sc;
}

//***************************************************************************
//
// DllRegisterServer
//
// Purpose: Called when it is time to setup the registry settings.  This could
//          be done by a setup program, or by using a system utility such
//          as REGSVR32.EXE.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllRegisterServer(void)
{   
    char       szID[128];
    WCHAR      wcID[128];
    char       szCLSID[128];
    char       szModule[MAX_PATH];
    char * pName = "WMI Sample Prop Provider";
    char * pModel = "Both";
    HKEY hKey1, hKey2;

    // Create the path.

    StringFromGUID2(CLSID_PropProvider, wcID, 128);
    wcstombs(szID, wcID, 128);
    lstrcpy(szCLSID, TEXT("Software\\classes\\CLSID\\"));
    lstrcat(szCLSID, szID);


    // Create entries under CLSID

    RegCreateKey(HKEY_LOCAL_MACHINE, szCLSID, &hKey1);
    RegSetValueEx(hKey1, NULL, 0, REG_SZ, (BYTE *)pName, lstrlen(pName)+1);
    RegCreateKey(hKey1,"InprocServer32",&hKey2);

    GetModuleFileName(ghModule, szModule,  MAX_PATH);
    RegSetValueEx(hKey2, NULL, 0, REG_SZ, (BYTE *)szModule, 
                                        lstrlen(szModule)+1);
    RegSetValueEx(hKey2, "ThreadingModel", 0, REG_SZ, 
                                        (BYTE *)pModel, lstrlen(pModel)+1);
    RegCloseKey(hKey1);
    RegCloseKey(hKey2);
    return NOERROR;
}


//***************************************************************************
//
// DllUnregisterServer
//
// Purpose: Called when it is time to remove the registry entries.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllUnregisterServer(void)
{
    char       szID[128];
    WCHAR      wcID[128];
    char  szCLSID[128];
    HKEY hKey;

    // Create the path using the CLSID

    StringFromGUID2(CLSID_PropProvider, wcID, 128);
    wcstombs(szID, wcID, 128);
    lstrcpy(szCLSID, TEXT("Software\\classes\\CLSID\\"));
    lstrcat(szCLSID, szID);

    // First delete the InProcServer subkey.

    DWORD dwRet = RegOpenKey(HKEY_LOCAL_MACHINE, szCLSID, &hKey);
    if(dwRet == NO_ERROR)
    {
        RegDeleteKey(hKey, "InProcServer32");
        RegCloseKey(hKey);
    }

    dwRet = RegOpenKey(HKEY_LOCAL_MACHINE, "Software\\classes\\CLSID", &hKey);
    if(dwRet == NO_ERROR)
    {
        RegDeleteKey(hKey,szID);
        RegCloseKey(hKey);
    }

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\propprov\propprov.cpp ===
//***************************************************************************

//

//  propprov.cpp

//

//  Module: WMI Sample Property Provider

//

//  Purpose: Provider class code.  An object of this class is

//           created by the class factory for each connection.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <objbase.h>
#include "sample.h"


//***************************************************************************
//
// CPropPro::CPropPro
// CPropPro::~CPropPro
//
//***************************************************************************

CPropPro::CPropPro()
{
    m_cRef=0;
    InterlockedIncrement(&g_cObj);
    return;
}

CPropPro::~CPropPro(void)
{
    InterlockedDecrement(&g_cObj);
    return;
}

//***************************************************************************
//
//  CPropPro::QueryInterface
//
//  Returns a pointer to supported interfaces.
//
//***************************************************************************

STDMETHODIMP CPropPro::QueryInterface(REFIID riid, PPVOID ppv)
{
    *ppv=NULL;
    
    // This provider only support IUnknown and IWbemPropertyProvider.

    if (IID_IUnknown==riid || IID_IWbemPropertyProvider == riid)
        *ppv=this;

    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return E_NOINTERFACE;
 }

//***************************************************************************
//
//  CPropPro::AddRef
//
//  Interface has another user, up the usage count.
//
//***************************************************************************

STDMETHODIMP_(ULONG) CPropPro::AddRef(void)
{
    return ++m_cRef;
}

//***************************************************************************
//
//  CPropPro::Release
//
//  Interface has been released.  Object will be deleted if the
//  usage count is zero.
//
//***************************************************************************

STDMETHODIMP_(ULONG) CPropPro::Release(void)
{
    ULONG nNewCount = InterlockedDecrement((long *)&m_cRef);
    if (0L == nNewCount)
        delete this;
    
    return nNewCount;
}


//***************************************************************************
//
// CPropPro::PutProperty
// CPropPro::GetProperty
//
// Purpose: PutProperty writes out data and GetProperty returns data.
//
//***************************************************************************

STDMETHODIMP CPropPro::PutProperty(
		    long lFlags,
            const BSTR Locale,						   
            const BSTR ClassMapping,
            const BSTR InstMapping,
            const BSTR PropMapping,
            const VARIANT *pvValue)
{
    
    return WBEM_E_PROVIDER_NOT_CAPABLE;

}

STDMETHODIMP CPropPro::GetProperty(
		    long lFlags,
            const BSTR Locale,						   
			const BSTR ClassMapping,
            const BSTR InstMapping,
            const BSTR PropMapping,
            VARIANT *pvValue)
{
    SCODE sc = WBEM_S_NO_ERROR;

    // Depending on the InstMapping, return either a hard coded integer or
    // a string.  These mapping strings could be used in a more sophisticated
    // manner!  

    if(!_wcsicmp(PropMapping, L"GiveMeANumber!"))
    {
        pvValue->vt = VT_I4;
        pvValue->lVal = 27;
    }
    else
    {
        pvValue->vt = VT_BSTR;
        pvValue->bstrVal = SysAllocString(L"Hello World");
        if(pvValue->bstrVal == NULL)
            sc = WBEM_E_OUT_OF_MEMORY;
    }
    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\propprov\sample.h ===
//***************************************************************************

//

//  SAMPLE.h

//

//  Module: WMI Sample Property Provider

//

//  Purpose: Genral purpose include file.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef _SAMPLE_H_
#define _SAMPLE_H_

#include <wbemcli.h>
#include <wbemprov.h>

typedef LPVOID * PPVOID;

// Provider interfaces are provided by objects of this class
 
class CPropPro : public IWbemPropertyProvider
    {
    protected:
        ULONG           m_cRef;         //Object reference count
   
    public:
        CPropPro();
        ~CPropPro(void);

    //Non-delegating object IUnknown
        STDMETHODIMP         QueryInterface(REFIID, PPVOID);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

    
    /* IWbemPropertyProvider methods */

       virtual HRESULT STDMETHODCALLTYPE GetProperty( 
           	/* [in] */ long lFlags,
            /* [in] */ const BSTR Locale,						   
            /* [in] */ const BSTR ClassMapping,
            /* [in] */ const BSTR InstMapping,
            /* [in] */ const BSTR PropMapping,
            /* [out] */ VARIANT *pvValue);
        
        virtual HRESULT STDMETHODCALLTYPE PutProperty( 
            /* [in] */ long lFlags,
            /* [in] */ const BSTR Locale,						   
            /* [in] */ const BSTR ClassMapping,
            /* [in] */ const BSTR InstMapping,
            /* [in] */ const BSTR PropMapping,
            /* [in] */ const VARIANT __RPC_FAR *pvValue);

    };

// This class is the class factory for CPropPro objects.

class CProvFactory : public IClassFactory
    {
    protected:
        ULONG           m_cRef;

    public:
        CProvFactory(void);
        ~CProvFactory(void);

        //IUnknown members
        STDMETHODIMP         QueryInterface(REFIID, PPVOID);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        //IClassFactory members
        STDMETHODIMP         CreateInstance(LPUNKNOWN, REFIID
                                 , PPVOID);
        STDMETHODIMP         LockServer(BOOL);
    };

typedef CProvFactory *PCProvFactory;

// These variables keep track of when the module can be unloaded

extern long       g_cObj;
extern long       g_cLock;

// General purpose utilities.  

#endif //_SAMPLE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\simpleclient\src\makefile.inc ===
$(O)\makefile : makefile.nm
	copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\queryparser\queryparser.cpp ===
// **************************************************************************
//
// Copyright (c) 2001 Microsoft Corporation, All Rights Reserved
//
// File:  QueryParser.cpp 
//
// Description:
//      WMI Query Parser Sample.
//      This sample shows how to use the Query Parser.  It takes a query as a command
//      line argument and passes it off to the parser to be parsed and then uses various
//      functions to get pieces of the path.
//
// **************************************************************************


#define _WIN32_WINNT    0x0400

#include <windows.h>
#include <stdio.h>
#include <wmiutils.h>

LPWSTR g_pQuery = 0;

//***************************************************************************
//
// DumpFeatureMasks
//
// Purpose: Outputs the mask in readable format
//
//***************************************************************************

void DumpFeatureMasks(ULONG mask1, ULONG mask2)
{
    printf("Query Features:\n");

    if (mask1 & WMIQ_RPNF_WHERE_CLAUSE_PRESENT)
        printf("WMIQ_RPNF_WHERE_CLAUSE_PRESENT\n");

    if (mask1 & WMIQ_RPNF_QUERY_IS_CONJUNCTIVE)
        printf("WMIQ_RPNF_QUERY_IS_CONJUNCTIVE\n");

    if (mask1 & WMIQ_RPNF_QUERY_IS_DISJUNCTIVE)
        printf("WMIQ_RPNF_QUERY_IS_DISJUNCTIVE\n");

    if (mask1 & WMIQ_RPNF_PROJECTION)
        printf("WMIQ_RPNF_PROJECTION\n");

    if (mask1 & WMIQ_RPNF_FEATURE_SELECT_STAR)
        printf("WMIQ_RPNF_FEATURE_SELECT_STAR\n");

    if (mask1 & WMIQ_RPNF_EQUALITY_TESTS_ONLY)
        printf("WMIQ_RPNF_EQUALITY_TESTS_ONLY\n");

    if (mask1 & WMIQ_RPNF_COUNT_STAR)
        printf("WMIQ_RPNF_COUNT_STAR\n");

    if (mask1 & WMIQ_RPNF_QUALIFIED_NAMES_IN_SELECT)
        printf("WMIQ_RPNF_QUALIFIED_NAMES_IN_SELECT\n");

    if (mask1 & WMIQ_RPNF_QUALIFIED_NAMES_IN_WHERE)
        printf("WMIQ_RPNF_QUALIFIED_NAMES_IN_WHERE\n");

    if (mask1 & WMIQ_RPNF_PROP_TO_PROP_TESTS)
        printf("WMIQ_RPNF_PROP_TO_PROP_TESTS\n");

    if (mask1 & WMIQ_RPNF_ORDER_BY)
        printf("WMIQ_RPNF_ORDER_BY\n");

    if (mask1 & WMIQ_RPNF_ISA_USED)
        printf("WMIQ_RPNF_ISA_USED\n");

    if (mask1 & WMIQ_RPNF_ISNOTA_USED)
        printf("WMIQ_RPNF_ISNOTA_USED\n");

    if (mask1 & WMIQ_RPNF_GROUP_BY_HAVING)
        printf("WMIQ_RPNF_GROUP_BY_HAVING\n");

    if (mask1 & WMIQ_RPNF_WITHIN_INTERVAL)
        printf("WMIQ_RPNF_WITHIN_INTERVAL\n");

    if (mask1 & WMIQ_RPNF_WITHIN_AGGREGATE)
        printf("WMIQ_RPNF_WITHIN_AGGREGATE\n");

    if (mask1 & WMIQ_RPNF_SYSPROP_CLASS)
        printf("WMIQ_RPNF_SYSPROP_CLASS\n");

    if (mask1 & WMIQ_RPNF_REFERENCE_TESTS)
        printf("WMIQ_RPNF_REFERENCE_TESTS\n");

    if (mask1 & WMIQ_RPNF_DATETIME_TESTS)
        printf("WMIQ_RPNF_DATETIME_TESTS\n");

    if (mask1 & WMIQ_RPNF_ARRAY_ACCESS)
        printf("WMIQ_RPNF_ARRAY_ACCESS\n");

    if (mask1 & WMIQ_RPNF_QUALIFIER_FILTER)
        printf("WMIQ_RPNF_QUALIFIER_FILTER\n");

    if (mask1 & WMIQ_RPNF_SELECTED_FROM_PATH)
        printf("WMIQ_RPNF_SELECTED_FROM_PATH\n");
}

//***************************************************************************
//
// DumpSelectList
//
// Purpose: Lists the selected columns
//
//***************************************************************************

void DumpSelectList(ULONG uCount, SWbemQueryQualifiedName **pNames)
{
    unsigned u;

    printf("----BEGIN SELECT CLAUSE---\n");
    printf("Selected target columns/props = ");

    for (u = 0; u < uCount; u++)
    {
        SWbemQueryQualifiedName *p = pNames[u];

        // Print out current name.
        // Note that we support qualified names,
        // like p1.a,  p2.b, etc.
        // For simple cases, the m_uNameListSize is 1.
        // ===========================================

        for (unsigned u2 = 0; u2 < p->m_uNameListSize; u2++)
        {
            if (u2 > 0)
                printf(".");
            printf("%S", p->m_ppszNameList[u2]);
        }

        printf(", ");
    }

    printf("\n");
    printf("---END SELECT CLAUSE-----\n");
}

//***************************************************************************
//
// DumpSubexpression
//
// Purpose: dumps out one of the subexpressions that make up the where clause
//
//***************************************************************************

void DumpSubexpression(SWbemRpnQueryToken *pTemp)
{
    printf("---SUBEXPRESSION TOKEN---\n");

    if (pTemp->m_uSubexpressionShape & WMIQ_RPN_LEFT_PROPERTY_NAME)
    {
        printf("    WMIQ_RPN_LEFT_PROPERTY_NAME\n");
    }
    if (pTemp->m_uSubexpressionShape & WMIQ_RPN_RIGHT_PROPERTY_NAME)
    {
        printf("    WMIQ_RPN_RIGHT_PROPERTY_NAME\n");
    }
    if (pTemp->m_uSubexpressionShape & WMIQ_RPN_CONST2)
    {
        printf("    WMIQ_RPN_CONST2\n");
    }
    if (pTemp->m_uSubexpressionShape & WMIQ_RPN_CONST)
    {
        printf("    WMIQ_RPN_CONST\n");
    }
    if (pTemp->m_uSubexpressionShape & WMIQ_RPN_RELOP)
    {
        printf("    WMIQ_RPN_RELOP\n");
    }
    if (pTemp->m_uSubexpressionShape & WMIQ_RPN_LEFT_FUNCTION)
    {
        printf("    WMIQ_RPN_LEFT_FUNCTION\n");
    }
    if (pTemp->m_uSubexpressionShape & WMIQ_RPN_RIGHT_FUNCTION)
    {
        printf("    WMIQ_RPN_RIGHT_FUNCTION\n");
    }

    switch (pTemp->m_uOperator)
    {
        case WMIQ_RPN_OP_UNDEFINED: printf("  Operator (Invalid) WMIQ_RPN_OP_UNDEFINED\n"); break;
        case WMIQ_RPN_OP_EQ : printf("  Operator =  (WMIQ_RPN_OP_EQ)\n"); break;
        case WMIQ_RPN_OP_NE : printf("  Operator != (WMIQ_RPN_OP_NE)\n"); break;
        case WMIQ_RPN_OP_GE : printf("  Operator >= (WMIQ_RPN_OP_GE)\n"); break;
        case WMIQ_RPN_OP_LE : printf("  Operator <= (WMIQ_RPN_OP_LE)\n"); break;
        case WMIQ_RPN_OP_LT : printf("  Operator <  (WMIQ_RPN_OP_LT)\n"); break;
        case WMIQ_RPN_OP_GT : printf("  Operator >  (WMIQ_RPN_OP_GT)\n"); break;
        case WMIQ_RPN_OP_LIKE : printf("  Operator LIKE (WMIQ_RPN_OP_LIKE)\n"); break;
        case WMIQ_RPN_OP_ISA  : printf("  Operator ISA  (WMIQ_RPN_OP_ISA)\n"); break;
        case WMIQ_RPN_OP_ISNOTA  : printf("  Operator ISNOTA (WMIQ_RPN_OP_ISNOTA)\n"); break;

        default:
            printf("  Operator <INVALID -- Internal Error>\n");
            break;
    }

    // Dump identifiers (propety names)


    if (pTemp->m_pRightIdent)
    {
        printf("  Right side identifier = ");
        SWbemQueryQualifiedName *p = pTemp->m_pRightIdent;
        for (unsigned u = 0; u < p->m_uNameListSize; u++)
        {
            if (u > 0)
                printf(".");
            printf("%S", p->m_ppszNameList[u]);
        }
        printf("\n");
    }

    if (pTemp->m_pLeftIdent)
    {
        printf("  Left side identifier = ");
        SWbemQueryQualifiedName *p = pTemp->m_pLeftIdent;
        for (unsigned u = 0; u < p->m_uNameListSize; u++)
        {
            if (u > 0)
                printf(".");
            printf("%S", p->m_ppszNameList[u]);
        }
        printf("\n");
    }

    printf("  Apparent Type of Query Constant is ");

    switch(pTemp->m_uConstApparentType)
    {
        case VT_NULL:
            printf("VT_NULL");
            break;
        case VT_I4:
            printf("VT_I4,  Value = %d\n", pTemp->m_Const.m_lLongVal);
            break;
        case VT_UI4:
            printf("VT_UI4, Value = %u\n", pTemp->m_Const.m_uLongVal);
            break;
        case VT_BOOL:
            printf("VT_BOOL, Value = %d\n", pTemp->m_Const.m_bBoolVal);
            break;
        case VT_R8:
            printf("VT_R8, Value = %f\n", pTemp->m_Const.m_dblVal);
            break;
        case VT_LPWSTR:
            printf("VT_LPWSTR, Value = %S\n", pTemp->m_Const.m_pszStrVal);
            break;
    }

    printf("  Function name applied to Left Side = %S\n", pTemp->m_pszLeftFunc);
    printf("  Function name applied to Right Side = %S\n", pTemp->m_pszRightFunc);

    printf("----END SUBEXPRESSION TOKEN---\n");
}

//***************************************************************************
//
// DumpWhereClause
//
// Purpose: Dumps out the where clause
//
//***************************************************************************

void DumpWhereClause(ULONG uCount, SWbemRpnQueryToken **pWhere)
{
    printf("---BEGIN WHERE CLAUSE---\n");

    unsigned u;

    for (u = 0; u < uCount; u++)
    {
        SWbemRpnQueryToken *pTemp = pWhere[u];

        switch(pTemp->m_uTokenType)
        {
            case WMIQ_RPN_TOKEN_EXPRESSION:
                DumpSubexpression(pTemp);
                break;

            case WMIQ_RPN_TOKEN_AND:
                printf(" Operator: AND\n");
                break;

            case WMIQ_RPN_TOKEN_OR:
                printf(" Operator: OR\n");
                break;

            case WMIQ_RPN_TOKEN_NOT:
                printf(" Operator: NOT\n");

            default:
                printf(" Operator: INVALID\n");
        }
    }

    printf("---END WHERE CLAUSE---\n");
}

//***************************************************************************
//
// DumpFromClause
//
// Purpose: Dumps out the from clause
//
//***************************************************************************

void DumpFromClause(SWbemRpnEncodedQuery *pQuery)
{
    printf("---FROM clause---\n");

    if (pQuery->m_uFromTargetType & WMIQ_RPN_FROM_PATH)
    {
        printf("  Selected from container/scope [%S]\n", pQuery->m_pszOptionalFromPath);
    }

    if (pQuery->m_uFromTargetType & WMIQ_RPN_FROM_UNARY)
    {
        printf("  Single class select = %S\n", pQuery->m_ppszFromList[0]);
    }
    else if (pQuery->m_uFromTargetType & WMIQ_RPN_FROM_CLASS_LIST)
    {
        for (unsigned u = 0; u < pQuery->m_uFromListSize; u++)
        {
            printf("  Selected class = %S\n", pQuery->m_ppszFromList[u]);
        }
    }
    else
    {
        printf("  No target classes selected; select ALL\n");
    }

    printf("---END FROM clause\n");
}

//***************************************************************************
//
// DumpRpn
//
// Purpose: Mainly calls the other routines which dump out the specific parts
//
//***************************************************************************

void DumpRpn(SWbemRpnEncodedQuery *pRpn)
{
    printf("------------RPN Encoded Query-----------------\n");
    printf("RPN Version = %d\n", pRpn->m_uVersion);
    printf("RPN Token Type = %d\n", pRpn->m_uTokenType);

    printf("Total detected features = %d  Feature Set = { ", pRpn->m_uDetectedArraySize);
    for (unsigned i = 0; i < pRpn->m_uDetectedArraySize; i++)
        printf("%d ", pRpn->m_puDetectedFeatures[i]);
    printf("}\n\n");

    DumpFeatureMasks(pRpn->m_uParsedFeatureMask1, pRpn->m_uParsedFeatureMask2);
    DumpSelectList(pRpn->m_uSelectListSize, pRpn->m_ppSelectList);
    DumpFromClause(pRpn);
    DumpWhereClause(pRpn->m_uWhereClauseSize, pRpn->m_ppRpnWhereClause);
}

//***************************************************************************
//
// TestQuery
//
// Purpose: Calls the parser to parse the query, and if all is well, calls
// the other routines to dump out the results.
//
//***************************************************************************

void TestQuery(IWbemQuery *pQuery)
{
    HRESULT hRes;
    ULONG uFeatures[] =
    {
        WMIQ_LF1_BASIC_SELECT,
        WMIQ_LF2_CLASS_NAME_IN_QUERY
    };

    hRes = pQuery->SetLanguageFeatures(0, sizeof(uFeatures)/sizeof(ULONG), uFeatures);

    hRes = pQuery->Parse(L"SQL", g_pQuery, 0);

    if (FAILED(hRes))
    {
        printf("Parse failed with error 0x%X\n", hRes);
        return;
    }


    SWbemRpnEncodedQuery *pRpn = 0;
    hRes = pQuery->GetAnalysis(
        WMIQ_ANALYSIS_RPN_SEQUENCE,
        0,
        (LPVOID *) &pRpn
        );

    if (SUCCEEDED(hRes))
    {
        printf("\n\nGot RPN Output\n");
        DumpRpn(pRpn);
        pQuery->FreeMemory(pRpn);
    }
}

//***************************************************************************
//
// main
//
// Purpose: Entry point for the application.
//
//***************************************************************************

void main(int argc, char *argv[])
{
    if (argc < 2)
    {
        printf("\nusage:  QueryParser \"query\"");
		printf("\nexample;  c:>QueryParser \"select RowA, RowB from tableName where propz=3\"");
        return;
    }

    printf("Query = %s\n", argv[1]);

    wchar_t buf[512];
    swprintf(buf, L"%S", argv[1]);
    g_pQuery = buf;

    // Standard COM initialization stuff.
    // ===================================

    CoInitializeEx(0, COINIT_MULTITHREADED);

    // Get the QueryParser object call the test code
    // =============================================

    IWbemQuery *pQuery = 0;

    DWORD dwRes = CoCreateInstance(CLSID_WbemQuery, 0, CLSCTX_INPROC_SERVER,
            IID_IWbemQuery, (LPVOID *) &pQuery);

    if (dwRes != S_OK)
        printf("Failed to create Query object.\n");
    else
    {
        printf("Got a query parser object\n");
        TestQuery(pQuery);
        pQuery->Release();
    }

    CoUninitialize();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\simpleclient\src\resource.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by WbemClient.rc
//
#define IDC_ENUMDISKS                   3
#define IDC_MAKEOFFICE                  4
#define IDC_DISKINFO                    5
#define IDM_ABOUTBOX                    0x0010
#define IDD_ABOUTBOX                    100
#define IDS_ABOUTBOX                    101
#define IDD_WBEMCLIENT_DIALOG           102
#define IDR_MAINFRAME                   128
#define IDC_CONNECT                     1000
#define IDC_OUTPUTLIST                  1001
#define IDC_NAMESPACE                   1002

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        129
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1003
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\simpleclient\src\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes

//	WbemClient.pch will be the pre-compiled header

//	stdafx.obj will contain the pre-compiled type information

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\simpleclient\src\stdafx.h ===
// stdafx.h : include file for standard system include files,

//  or project specific include files that are used frequently, but

//      are changed infrequently

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved

#if !defined(AFX_STDAFX_H__4C1DEDFE_F003_11D1_BDD8_00C04F8F8B8D__INCLUDED_)
#define AFX_STDAFX_H__4C1DEDFE_F003_11D1_BDD8_00C04F8F8B8D__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdisp.h>        // MFC OLE automation classes
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__4C1DEDFE_F003_11D1_BDD8_00C04F8F8B8D__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\security\security.cpp ===
// **************************************************************************
//
// Copyright (c) 2001 Microsoft Corporation, All Rights Reserved
//
// File:  Security.cpp 
//
// Description:
//        WMI Client Security Sample.  This sample shows how various how to 
// handle various DCOM security issues.  In particular, it shows how to call
// CoSetProxyBlanket in order to deal with common situations.  The sample also
// shows how to access the security descriptors that wmi uses to control
// namespace access.
//
// **************************************************************************

#include <objbase.h>
#include <windows.h>                                     
#include <stdio.h>
#include <wbemidl.h> 
#include <comdef.h>

WCHAR wPath[MAX_PATH];
WCHAR wFullUserName[MAX_PATH];
WCHAR wPassWord[MAX_PATH];

bool bPassWordSet = false;
bool bUserNameSet = false;

void __stdcall _com_issue_error(HRESULT){}

//***************************************************************************
//
// DisplayOptions
//
// Purpose: Displays the command line options.
//
//***************************************************************************

void DisplayOptions()
{
    printf("\nThis application demonstrates various DCOM security issues.  It \n"
            "will connect up to the namespace and enumerate the top level classes\n"
            "and will also dump the security descriptor used to control access to the namespace.\n\n"
            "usage: Security [-P:<Password>] [-U:<UserName>] [-L] [-A:<name>] <ServerNamespace>\n"
            "              -U:<UserName>             Optional User Name\n"
            "              -P:<Password>             Optional Login password\n"
            "Example; c:>Security -U:domain\\username -P:xyz -L \\\\server\\root\\default\n"
            );
    return;
}

//***************************************************************************
//
// ProcessArguments
//
// Purpose: Processes command line arguments.  Returns FALSE if there is a
// problem, or if user just wants help.
//
//***************************************************************************

BOOL ProcessArguments(int iArgCnt, WCHAR ** argv)
{
    wPath[0] = 0;
    wFullUserName[0] = 0;
    wPassWord[0] = 0;

    if(iArgCnt < 2)
        return FALSE;
    for(int iCnt = 1; iCnt < iArgCnt-1 ; iCnt++)
    {
        WCHAR * pArg = argv[iCnt];
        if(pArg[0] != '-')
            return FALSE;
        switch (pArg[1])
        {
            case L'u':
            case L'U':
                wcscpy(wFullUserName, pArg+3);
                bUserNameSet = true;
                break;
            case L'p':
            case L'P':
                wcscpy(wPassWord, pArg+3);
                bPassWordSet = true;
                break;
            default:
                return FALSE;
        }
    }

    // Get the path, it is the last argument

    if(argv[iArgCnt-1][0] == L'-')      // probably -help or -?.  Not valid path!
        return FALSE;
    wcscpy(wPath, argv[iArgCnt-1]);
    return TRUE;
}

//***************************************************************************
//
// SetProxySecurity
//
// Purpose: Calls CoSetProxyBlanket in order to control the security on a 
// particular interface proxy.
//
//***************************************************************************

HRESULT SetProxySecurity(IUnknown * pProxy)
{
    HRESULT hr;
    DWORD dwAuthnLevel;
    RPC_AUTH_IDENTITY_HANDLE * pAuthInfo = NULL;

    //  There are various reasons to set security.  An application that can 
    //  call CoInitializeSecurity and doesnt use an alternative user\password,
    //  need not bother with call CoSetProxyBlanket.  There are at least
    //  three cases that do need it though.
    //
    //  1) Dlls cannot call CoInitializeSecurity and will need to call it just
    //     to raise the impersonation level.  This does NOT require that the 
    //     RPC_AUTH_IDENTITY_HANDLE to be set nor does this require setting
    //     it on the IUnknown pointer.
    //  2) Any time that an alternative user\password are set as is the case
    //     in this simple sample.  Note that it is necessary in that case to 
    //     also set the information on the IUnknown.
    //  3) If the caller has a thread token from a remote call to itself and
    //     it wants to use that identity.  That would be the case of an RPC/COM
    //     server which is handling a call from one of its clients and it wants
    //     to use the client's identity in calls to WMI.  In this case, then 
    //     the RPC_AUTH_IDENTITY_HANDLE does not need to be set, but the 
    //     dwCapabilities arguement should be set for cloaking.  This is also
    //     required for the IUnknown pointer.
    

    if(bPassWordSet == false && bUserNameSet == false)
    {
        // In this case, nothing needs to be done.  But for the sake of 
        // example the code will set the impersonation level.  

        // For backwards compatibility, retrieve the previous authentication level, so
        // we can echo-back the value when we set the blanket

        hr = CoQueryProxyBlanket(
            pProxy,           //Location for the proxy to query
            NULL,             //Location for the current authentication service
            NULL,             //Location for the current authorization service
            NULL,             //Location for the current principal name
            &dwAuthnLevel,    //Location for the current authentication level
            NULL,             //Location for the current impersonation level
            NULL,             //Location for the value passed to IClientSecurity::SetBlanket
            NULL              //Location for flags indicating further capabilities of the proxy
                );
        if(FAILED(hr))
            return hr;
        hr = CoSetProxyBlanket(pProxy, RPC_C_AUTHN_DEFAULT, RPC_C_AUTHZ_DEFAULT, COLE_DEFAULT_PRINCIPAL, dwAuthnLevel,
            RPC_C_IMP_LEVEL_IMPERSONATE, COLE_DEFAULT_AUTHINFO, EOAC_DEFAULT);
        return hr;
    }
    else
    {
        // The user\password was set, it is necessary to call CoSetProxyBlanket

        COAUTHIDENTITY authident;
        pAuthInfo = NULL;

        // For backwards compatibility, retrieve the previous authentication level, so
        // we can echo-back the value when we set the blanket

        hr = CoQueryProxyBlanket(
            pProxy,           //Location for the proxy to query
            NULL,             //Location for the current authentication service
            NULL,             //Location for the current authorization service
            NULL,             //Location for the current principal name
            &dwAuthnLevel,    //Location for the current authentication level
            NULL,             //Location for the current impersonation level
            NULL,             //Location for the value passed to IClientSecurity::SetBlanket
            NULL              //Location for flags indicating further capabilities of the proxy
                );

        memset((void *)&authident,0,sizeof(COAUTHIDENTITY));

        // note that this assumes NT.  Win9X would fill in the field with 
        // ascii and then use SEC_WINNT_AUTH_IDENTITY_ANSI flag instead

        WCHAR wUserName[MAX_PATH];
        WCHAR wDomainName[MAX_PATH];
        wUserName[0] = 0;
        wDomainName[0] = 0;
        bool bDomainNameSet = false;

        if(bUserNameSet)
        {
            // Note that the user name may be in the form domain\user.  If so, split it up

            for(WCHAR * pTemp = wFullUserName; *pTemp; pTemp++)
            {
                if(*pTemp == L'\\')
                {
                    *pTemp = 0;
                    wcscpy(wDomainName, wFullUserName);
                    wcscpy(wUserName, pTemp +1);
                    *pTemp = L'\\';             // put it back
                    bDomainNameSet = true;
                    break;
                }
            }
            authident.UserLength = wcslen(wUserName);
            authident.User = (LPWSTR)wUserName;
        }
        if(bDomainNameSet)
        {
            authident.DomainLength = wcslen(wDomainName);
            authident.Domain = (LPWSTR)wDomainName;
        } 
        if(bPassWordSet)
        {
            authident.PasswordLength = wcslen(wPassWord);
            authident.Password = (LPWSTR)wPassWord;
        }
        authident.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;


        hr = CoSetProxyBlanket(pProxy, RPC_C_AUTHN_DEFAULT, RPC_C_AUTHZ_DEFAULT, COLE_DEFAULT_PRINCIPAL, dwAuthnLevel,
            RPC_C_IMP_LEVEL_IMPERSONATE, &authident, EOAC_DEFAULT);
        if(FAILED(hr))
            return hr;

        // There is a remote IUnknown interface that lurks behind IUnknown.
        // If that is not set, then the Release call can return access denied.

        IUnknown * pUnk = NULL;
        hr = pProxy->QueryInterface(IID_IUnknown, (void **)&pUnk);
        if(FAILED(hr))
            return hr;
        hr = CoSetProxyBlanket(pUnk, RPC_C_AUTHN_DEFAULT, RPC_C_AUTHZ_DEFAULT, COLE_DEFAULT_PRINCIPAL, dwAuthnLevel,
            RPC_C_IMP_LEVEL_IMPERSONATE, &authident, EOAC_DEFAULT);
        pUnk->Release();
        return hr;
    }
}

//***************************************************************************
//
// ListClasses
//
// Purpose: Lists the classes.
//
//***************************************************************************

void ListClasses(IWbemServices *pNamespace)
{
    HRESULT hr;
    IEnumWbemClassObject *pEnum = NULL;

    hr = pNamespace->CreateClassEnum(NULL, 0, NULL, &pEnum);
    if(SUCCEEDED(hr))
    {

        // Note that even though security was set on the namespace pointer, it must 
        // also be set on this pointer since COM will revert back to the default
        // settings for any new pointers!

        hr = SetProxySecurity(pEnum);
        if(SUCCEEDED(hr))
        {
            IWbemClassObject* Array[1];
            Array[0] = NULL;
            ULONG uRet = 0;
            while (SUCCEEDED(hr = pEnum->Next(10000, 1, Array, &uRet)) && Array[0])
            {
                // Note that IWbemClassObjects are inproc and thus have no proxy.
                // Therefore, they never need CoSetProxyBlanket.

                BSTR strText;
                IWbemClassObject* pObj = Array[0];
                hr = pObj->GetObjectText(0, &strText);

                if(SUCCEEDED(hr) && strText)
                {
                    printf("\nGot class %S", strText);
                    SysFreeString(strText);
                }
                pObj->Release();
                Array[0] = NULL;
            }
        }
        else
            printf("\nFAILED TO SET SECURITY FOR ENUMERATOR!!!!! hr = 0x%x", hr);
        pEnum->Release();
    }
}

//***************************************************************************
//
// DumpAce
//
// Purpose: Dumps information in an ACE. Note that this is simple cook book
// code.  There are many available wrappers to do this sort of thing.
//
//***************************************************************************

void DumpAce(ACCESS_ALLOWED_ACE * pAce)
{
    printf("\n Ace, type=0x%x, flags=0x%x, mask=0x%x",
        pAce->Header.AceType, pAce->Header.AceFlags, pAce->Mask);

    PSID pSid = 0;
    SID_NAME_USE use;
    WCHAR wcUser[100], wcDomain[100];
    DWORD dwNameSize = 100, dwDomainSize = 100;
    pSid = &pAce->SidStart;
    if(LookupAccountSidW(
            NULL,              // name of local or remote computer
            pSid,              // security identifier
            wcUser,            // account name buffer
            &dwNameSize,       // size of account name buffer
            wcDomain,          // domain name
            &dwDomainSize,     // size of domain name buffer
            &use))
        printf(" User name = %S, Domain name = %S", wcUser, wcDomain);
}   

//***************************************************************************
//
// DumpSD
//
// Purpose: Dumps information in a security descriptor.  Note that this is 
// simple cook book code.  There are many available wrappers to do this sort
// of thing.
//
//***************************************************************************

void DumpSD(PSECURITY_DESCRIPTOR pSD)
{
    DWORD dwSize = GetSecurityDescriptorLength(pSD);
    printf("\nSecurity Descriptor is of size %d", dwSize);

    BOOL DaclPresent, DaclDefaulted;
    PACL pDacl;
    if(GetSecurityDescriptorDacl(pSD, &DaclPresent,
                &pDacl, &DaclDefaulted) && DaclPresent)
    {

        // Dump the aces

        ACL_SIZE_INFORMATION inf;
        DWORD dwNumAces;
        if(GetAclInformation(
            pDacl,
            &inf,
            sizeof(ACL_SIZE_INFORMATION),
            AclSizeInformation
            ))
        {
            dwNumAces = inf.AceCount;
            printf("\nThe DACL has %d ACEs", dwNumAces);
            for(DWORD dwCnt = 0; dwCnt < dwNumAces; dwCnt++)
            {
                ACCESS_ALLOWED_ACE * pAce;
                if(GetAce(pDacl, dwCnt, (LPVOID *)&pAce))
                    DumpAce(pAce);
            }
        }
    }
}

//***************************************************************************
//
// StoreSD
//
// Purpose: Writes back the ACL which controls access to the namespace.
//
//***************************************************************************


bool StoreSD(IWbemServices * pSession, PSECURITY_DESCRIPTOR pSD)
{
    bool bRet = false;
    HRESULT hr;

    // Get the class object

    IWbemClassObject * pClass = NULL;
    _bstr_t InstPath(L"__systemsecurity=@");
    _bstr_t ClassPath(L"__systemsecurity");
    hr = pSession->GetObject(ClassPath, 0, NULL, &pClass, NULL);
    if(FAILED(hr))
        return false;

    // Get the input parameter class

    _bstr_t MethName(L"SetSD");
    IWbemClassObject * pInClassSig = NULL;
    hr = pClass->GetMethod(MethName,0, &pInClassSig, NULL);
    pClass->Release();
    if(FAILED(hr))
        return false;

    // spawn an instance of the input parameter class

    IWbemClassObject * pInArg = NULL;
    pInClassSig->SpawnInstance(0, &pInArg);
    pInClassSig->Release();
    if(FAILED(hr))
        return false;


    // move the SD into a variant.

    SAFEARRAY FAR* psa;
    SAFEARRAYBOUND rgsabound[1];    rgsabound[0].lLbound = 0;
    long lSize = GetSecurityDescriptorLength(pSD);
    rgsabound[0].cElements = lSize;
    psa = SafeArrayCreate( VT_UI1, 1 , rgsabound );
    if(psa == NULL)
    {
        pInArg->Release();
        return false;
    }

    char * pData = NULL;
    hr = SafeArrayAccessData(psa, (void HUGEP* FAR*)&pData);
    if(FAILED(hr))
    {
        pInArg->Release();
        return false;
    }

    memcpy(pData, pSD, lSize);

    SafeArrayUnaccessData(psa);
    _variant_t var;
    var.vt = VT_I4|VT_ARRAY;
    var.parray = psa;

    // put the property

    hr = pInArg->Put(L"SD" , 0, &var, 0);      
    if(FAILED(hr))
    {
        pInArg->Release();
        return false;
    }

    // Execute the method

    IWbemClassObject * pOutParams = NULL;
    hr = pSession->ExecMethod(InstPath,
            MethName,
            0,
            NULL, pInArg,
            NULL, NULL);
    if(FAILED(hr))
        printf("\nPut failed, returned 0x%x",hr);

    return bRet;
}

//***************************************************************************
//
// ReadACL
//
// Purpose: Reads the ACL which controls access to the namespace.
//
//***************************************************************************

bool ReadACL(IWbemServices *pNamespace)
{
    bool bRet = false;
    _bstr_t InstPath(L"__systemsecurity=@");
    _bstr_t MethName(L"GetSD");
    IWbemClassObject * pOutParams = NULL;

    // The security descriptor is returned via the GetSD method
    
    HRESULT hr = pNamespace->ExecMethod(InstPath,
            MethName,
            0,
            NULL, NULL,
            &pOutParams, NULL);
    if(SUCCEEDED(hr))
    {

        // The output parameters has a property which has the descriptor

        _bstr_t prop(L"sd");
        _variant_t var;
        hr = pOutParams->Get(prop, 0, &var, NULL, NULL);
        if(SUCCEEDED(hr))
        {
            if(var.vt != (VT_ARRAY | VT_UI1))
                return false;
            SAFEARRAY * psa = var.parray;
            PSECURITY_DESCRIPTOR pSD;
            hr = SafeArrayAccessData(psa, (void HUGEP* FAR*)&pSD);
            if(hr != 0)
                return false;

            // Dump out some information

            DumpSD(pSD);

            // Given that the security desciptor is now present, the code could use standard
            // nt functions to add or remove ace's.  There are also various libraries available
            // that can make the job a bit easier.  This sample does not change the security 
            // descriptor, but does write it back unchanged as an example.

            StoreSD(pNamespace, pSD);
            SafeArrayUnaccessData(psa);
            bRet = true;
        }
    }
    return bRet;
}

//***************************************************************************
//
// main
//
// Purpose: Main entry point.
//
//***************************************************************************

BOOL g_bInProc = FALSE;
 
int wmain(int iArgCnt, WCHAR ** argv)
{

    if(!ProcessArguments(iArgCnt, argv))
    {
        DisplayOptions();
            return 1;
    }
    
    IWbemLocator *pLocator = NULL;
    IWbemServices *pNamespace = 0;
    IWbemClassObject * pClass = NULL;

    // Initialize COM.

    HRESULT hr = CoInitialize(0);

    // This has two valuable purposes.  First, it sets the default impersonation level
    // to "Impersonate" which is what WMI providers will generally require.  Second,
    // it sets the required authentication level of to None.  That means that WINMGMT 
    // servers running on NT4 will be able to call back.   
    //
    // DLLs cannot call this function.  To bump up the impersonation level, they must 
    // call CoSetProxyBlanket which is illustrated later on.  To get around the NT 4 call
    // back problem, DLLs should avoid asyncronous methods, or they can use 
    // Unsecapp.exe which is discussed in the documentation.
    
    hr = CoInitializeSecurity(NULL, -1, NULL, NULL,
                                RPC_C_AUTHN_LEVEL_NONE,
                                RPC_C_IMP_LEVEL_IMPERSONATE,
                                NULL, EOAC_NONE, 0);
                                
    hr = CoCreateInstance(CLSID_WbemLocator, 0, CLSCTX_INPROC_SERVER,
            IID_IWbemLocator, (LPVOID *) &pLocator);

    
    
    hr = pLocator->ConnectServer(wPath, 
                    (bUserNameSet) ? wFullUserName : NULL, 
                    (bPassWordSet) ? wPassWord : NULL, 
                    NULL, 0, NULL, NULL, &pNamespace);
    printf("\n\nConnectServer returned 0x%x:", hr);
    if(FAILED(hr))
    {
        printf("\nConnectServer failed, hr = 0x%x", hr);
    }
    else
    {
        printf("\nConnection succeeded");
        hr = SetProxySecurity(pNamespace);
        if(SUCCEEDED(hr))
        {
            ListClasses(pNamespace);
            ReadACL(pNamespace);
        }
        pNamespace->Release();
    }
    CoUninitialize();
    printf("Terminating normally\n");
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\simpleclient\src\wbemclient.cpp ===
// WbemClient.cpp : Defines the class behaviors for the application.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved

#include "stdafx.h"
#include "WbemClient.h"
#include "WbemClientDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CWbemClientApp

BEGIN_MESSAGE_MAP(CWbemClientApp, CWinApp)
	//{{AFX_MSG_MAP(CWbemClientApp)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWbemClientApp construction

CWbemClientApp::CWbemClientApp()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CWbemClientApp object

CWbemClientApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CWbemClientApp initialization

BOOL CWbemClientApp::InitInstance()
{
	// Initialize OLE libraries
	if (!AfxOleInit())
	{
		AfxMessageBox(_T("Failed to initialize OLE"));
		return FALSE;
	}
	if (!InitSecurity())
	{
		AfxMessageBox(_T("Failed to fix security"));
		return FALSE;
	}

	// Standard initialization
	// If you are not using these features and wish to reduce the size
	//  of your final executable, you should remove from the following
	//  the specific initialization routines you do not need.

#ifdef _AFXDLL
	Enable3dControls();			// Call this when using MFC in a shared DLL
#else
	Enable3dControlsStatic();	// Call this when linking to MFC statically
#endif

	CWbemClientDlg dlg;
	m_pMainWnd = &dlg;
	INT_PTR nResponse = dlg.DoModal();
	if (nResponse == IDOK)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with OK
	}
	else if (nResponse == IDCANCEL)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with Cancel
	}

	// Since the dialog has been closed, return FALSE so that we exit the
	//  application, rather than start the application's message pump.
	return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// CWbemClientApp security

// Initialize COM security for DCOM services.
// Returns true if successful.
bool CWbemClientApp::InitSecurity(void)
{
	// Adjust the security to allow client impersonation.
	HRESULT hres = CoInitializeSecurity
								( NULL, -1, NULL, NULL, 
											RPC_C_AUTHN_LEVEL_DEFAULT, 
											RPC_C_IMP_LEVEL_IMPERSONATE, 
											NULL, 
											EOAC_NONE, 
											NULL );
	return (SUCCEEDED(hres));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\simpleclient\src\wbemclient.h ===
// WbemClient.h : main header file for the WBEMCLIENT application

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved

#if !defined(AFX_WBEMCLIENT_H__4C1DEDF7_F003_11D1_BDD8_00C04F8F8B8D__INCLUDED_)
#define AFX_WBEMCLIENT_H__4C1DEDF7_F003_11D1_BDD8_00C04F8F8B8D__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols

/////////////////////////////////////////////////////////////////////////////
// CWbemClientApp:
// See WbemClient.cpp for the implementation of this class
//

class CWbemClientApp : public CWinApp
{
public:
	CWbemClientApp();

	bool InitSecurity();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CWbemClientApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(CWbemClientApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_WBEMCLIENT_H__4C1DEDF7_F003_11D1_BDD8_00C04F8F8B8D__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\snapin\about.cpp ===
//==============================================================;
//
//      This source code is only intended as a supplement to existing Microsoft documentation.
//
//      Use of this code is NOT supported.
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//    Microsoft Premier Support for Developers
//
//==============================================================;

#include "About.h"
#include "resource.h"
#include "globals.h"
#include <crtdbg.h>

CSnapinAbout::CSnapinAbout()
: m_cref(0)
{
    OBJECT_CREATED

        m_hSmallImage = (HBITMAP)LoadImage(g_hinst, MAKEINTRESOURCE(IDB_SMBMP), IMAGE_BITMAP, 16, 16, LR_LOADTRANSPARENT);
    m_hLargeImage = (HBITMAP)LoadImage(g_hinst, MAKEINTRESOURCE(IDB_LGBMP), IMAGE_BITMAP, 32, 32, LR_LOADTRANSPARENT);

    m_hSmallImageOpen = (HBITMAP)LoadImage(g_hinst, MAKEINTRESOURCE(IDB_SMOPEN), IMAGE_BITMAP, 16, 16, LR_LOADTRANSPARENT);

    m_hAppIcon = LoadIcon(g_hinst, MAKEINTRESOURCE(IDI_ICON1));
}

CSnapinAbout::~CSnapinAbout()
{
    if (m_hSmallImage != NULL)
        FreeResource(m_hSmallImage);

    if (m_hLargeImage != NULL)
        FreeResource(m_hLargeImage);

    if (m_hSmallImageOpen != NULL)
        FreeResource(m_hSmallImageOpen);

    if (m_hAppIcon != NULL)
        FreeResource(m_hAppIcon);

    m_hSmallImage = NULL;
    m_hLargeImage = NULL;
    m_hSmallImageOpen = NULL;
    m_hAppIcon = NULL;

    OBJECT_DESTROYED
}

///////////////////////
// IUnknown implementation
///////////////////////

STDMETHODIMP CSnapinAbout::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;

    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<ISnapinAbout *>(this);
    else if (IsEqualIID(riid, IID_ISnapinAbout))
        *ppv = static_cast<ISnapinAbout *>(this);

    if (*ppv)
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CSnapinAbout::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CSnapinAbout::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        // we need to decrement our object count in the DLL
        delete this;
        return 0;
    }
    return m_cref;

}

///////////////////////////////
// Interface ISnapinAbout
///////////////////////////////
STDMETHODIMP CSnapinAbout::GetSnapinDescription(
                                                /* [out] */ LPOLESTR *lpDescription)
{
    _TCHAR szDesc[MAX_PATH];

    LoadString(g_hinst, IDS_SNAPINDESC, szDesc, sizeof(szDesc));

    return AllocOleStr(lpDescription, szDesc);
}


STDMETHODIMP CSnapinAbout::GetProvider(
                                       /* [out] */ LPOLESTR *lpName)
{
    return AllocOleStr(lpName, _T("Copyright  1998 Microsoft Corporation"));;
}


STDMETHODIMP CSnapinAbout::GetSnapinVersion(
                                            /* [out] */ LPOLESTR *lpVersion)
{
    return AllocOleStr(lpVersion, _T("1.0"));;
}


STDMETHODIMP CSnapinAbout::GetSnapinImage(
                                          /* [out] */ HICON *hAppIcon)
{
    *hAppIcon = m_hAppIcon;

    if (*hAppIcon == NULL)
        return E_FAIL;
    else
        return S_OK;
}


STDMETHODIMP CSnapinAbout::GetStaticFolderImage(
                                                /* [out] */ HBITMAP *hSmallImage,
                                                /* [out] */ HBITMAP *hSmallImageOpen,
                                                /* [out] */ HBITMAP *hLargeImage,
                                                /* [out] */ COLORREF *cMask)
{
    *hSmallImage = m_hSmallImage;
    *hLargeImage = m_hLargeImage;

    *hSmallImageOpen = m_hSmallImageOpen;

    *cMask = RGB(0, 128, 128);

    if (*hSmallImage == NULL || *hLargeImage == NULL || *hSmallImageOpen == NULL)
        return E_FAIL;
    else
        return S_OK;
}

// this allocates a chunk of memory using CoTaskMemAlloc and copies our chars into it
HRESULT CSnapinAbout::AllocOleStr(LPOLESTR *lpDest, _TCHAR *szBuffer)
{
        MAKE_WIDEPTR_FROMTSTR_ALLOC(wszStr, szBuffer);
        *lpDest = wszStr;


    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\simpleclient\src\wbemclientdlg.h ===
// WbemClientDlg.h : header file

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved

#if !defined(AFX_WBEMCLIENTDLG_H__4C1DEDF9_F003_11D1_BDD8_00C04F8F8B8D__INCLUDED_)
#define AFX_WBEMCLIENTDLG_H__4C1DEDF9_F003_11D1_BDD8_00C04F8F8B8D__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "wbemcli.h"     // WMI interface declarations

class CWbemClientDlgAutoProxy;

/////////////////////////////////////////////////////////////////////////////
// CWbemClientDlg dialog

class CWbemClientDlg : public CDialog
{
// Construction
public:
	CWbemClientDlg(CWnd* pParent = NULL);	// standard constructor

// Dialog Data
	//{{AFX_DATA(CWbemClientDlg)
	enum { IDD = IDD_WBEMCLIENT_DIALOG };
	CButton	m_diskInfo;
	CButton	m_makeOffice;
	CButton	m_enumDisks;
	CListBox	m_outputList;
	CString	m_namespace;
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CWbemClientDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support
	//}}AFX_VIRTUAL

private:
	IWbemServices *m_pIWbemServices;
	IWbemServices *m_pOfficeService;

// Implementation
protected:
	HICON m_hIcon;

	// Generated message map functions
	//{{AFX_MSG(CWbemClientDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
	afx_msg void OnPaint();
	afx_msg HCURSOR OnQueryDragIcon();
	afx_msg void OnConnect();
	afx_msg void OnEnumdisks();
	afx_msg void OnMakeoffice();
	afx_msg void OnDiskinfo();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_WBEMCLIENTDLG_H__4C1DEDF9_F003_11D1_BDD8_00C04F8F8B8D__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\simpleclient\src\wbemclientdlg.cpp ===
// WbemClientDlg.cpp : implementation file

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved

#include "stdafx.h"
#include "WbemClient.h"
#include "WbemClientDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// Return error message.
CString ErrorMsg(LPCTSTR str, HRESULT hRes) {
   	CString s;
	s.Format("%s(0x%08lx)", str, hRes);
	return s;
}

/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
	CAboutDlg();

// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAboutDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	//{{AFX_MSG(CAboutDlg)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
	//{{AFX_DATA_INIT(CAboutDlg)
	//}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
		// No message handlers
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWbemClientDlg dialog

CWbemClientDlg::CWbemClientDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CWbemClientDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CWbemClientDlg)
	m_namespace = _T("\\\\.\\root\\cimv2");
	//}}AFX_DATA_INIT
	// Note that LoadIcon does not require a subsequent DestroyIcon in Win32
	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
	m_pIWbemServices = NULL;
	m_pOfficeService = NULL;
}

void CWbemClientDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CWbemClientDlg)
	DDX_Control(pDX, IDC_DISKINFO, m_diskInfo);
	DDX_Control(pDX, IDC_MAKEOFFICE, m_makeOffice);
	DDX_Control(pDX, IDC_ENUMDISKS, m_enumDisks);
	DDX_Control(pDX, IDC_OUTPUTLIST, m_outputList);
	DDX_Text(pDX, IDC_NAMESPACE, m_namespace);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CWbemClientDlg, CDialog)
	//{{AFX_MSG_MAP(CWbemClientDlg)
	ON_WM_SYSCOMMAND()
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()
	ON_BN_CLICKED(IDC_CONNECT, OnConnect)
	ON_BN_CLICKED(IDC_ENUMDISKS, OnEnumdisks)
	ON_BN_CLICKED(IDC_MAKEOFFICE, OnMakeoffice)
	ON_BN_CLICKED(IDC_DISKINFO, OnDiskinfo)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWbemClientDlg message handlers

BOOL CWbemClientDlg::OnInitDialog()
{
	CDialog::OnInitDialog();

	// Add "About..." menu item to system menu.

	// IDM_ABOUTBOX must be in the system command range.
	ASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);
	ASSERT(IDM_ABOUTBOX < 0xF000);

	CMenu* pSysMenu = GetSystemMenu(FALSE);
	if (pSysMenu != NULL)
	{
		CString strAboutMenu;
		strAboutMenu.LoadString(IDS_ABOUTBOX);
		if (!strAboutMenu.IsEmpty())
		{
			pSysMenu->AppendMenu(MF_SEPARATOR);
			pSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);
		}
	}

	// Set the icon for this dialog.  The framework does this automatically
	//  when the application's main window is not a dialog
	SetIcon(m_hIcon, TRUE);			// Set big icon
	SetIcon(m_hIcon, FALSE);		// Set small icon
	
	// TODO: Add extra initialization here
	
	return TRUE;  // return TRUE  unless you set the focus to a control
}

void CWbemClientDlg::OnSysCommand(UINT nID, LPARAM lParam)
{
	if ((nID & 0xFFF0) == IDM_ABOUTBOX)
	{
		CAboutDlg dlgAbout;
		dlgAbout.DoModal();
	}
	else
	{
		CDialog::OnSysCommand(nID, lParam);
	}
}

// If you add a minimize button to your dialog, you will need the code below
//  to draw the icon.  For MFC applications using the document/view model,
//  this is automatically done for you by the framework.

void CWbemClientDlg::OnPaint() 
{
	if (IsIconic())
	{
		CPaintDC dc(this); // device context for painting

		SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);

		// Center icon in client rectangle
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

		// Draw the icon
		dc.DrawIcon(x, y, m_hIcon);
	}
	else
	{
		CDialog::OnPaint();
	}
}

// The system calls this to obtain the cursor to display while the user drags
//  the minimized window.
HCURSOR CWbemClientDlg::OnQueryDragIcon()
{
	return (HCURSOR) m_hIcon;
}


/////////////////////////////////////////////////////////////////////////////
// CWbemClientDlg connection

void CWbemClientDlg::OnConnect() 
{
	CWaitCursor wait;	// show wait cursor until finished
	
	// Create an instance of the WbemLocator interface.
	IWbemLocator *pIWbemLocator = NULL;

	// wmibug#2639
	UpdateData();

	if(CoCreateInstance(CLSID_WbemLocator,
		NULL,
		CLSCTX_INPROC_SERVER,
		IID_IWbemLocator,
		(LPVOID *) &pIWbemLocator) == S_OK)
	{
		// If already connected, release m_pIWbemServices.
		if (m_pIWbemServices)  m_pIWbemServices->Release();

		// Using the locator, connect to CIMOM in the given namespace.
		BSTR pNamespace = m_namespace.AllocSysString();

		if(pIWbemLocator->ConnectServer(pNamespace,
								NULL,   //using current account for simplicity
								NULL,	//using current password for simplicity
								0L,		// locale
								0L,		// securityFlags
								NULL,	// authority (domain for NTLM)
								NULL,	// context
								&m_pIWbemServices) == S_OK) 
		{	
			// Indicate success.
			m_outputList.ResetContent();
			m_outputList.AddString(_T("Connected to namespace"));

			// It's safe the hit the other buttons now.
			m_enumDisks.EnableWindow(TRUE);
			m_makeOffice.EnableWindow(TRUE);
			
						   
		}
		else AfxMessageBox(_T("Bad namespace"));

		// Done with pNamespace.
		SysFreeString(pNamespace);

		// Done with pIWbemLocator. 
		pIWbemLocator->Release(); 
	}
	else AfxMessageBox(_T("Failed to create IWbemLocator object"));
}

void CWbemClientDlg::OnEnumdisks() 
{
	CWaitCursor wait;	// show wait cursor until finished

	// Get the Win32_LogicalDisk class
	BSTR className = SysAllocString(L"Win32_LogicalDisk");
	IEnumWbemClassObject *pEnumStorageDevs = NULL;
		
	m_outputList.ResetContent();

	// Get the list of logical storage device instances.
	HRESULT hRes = m_pIWbemServices->CreateInstanceEnum(
		className,			// name of class
		0,
		NULL,
		&pEnumStorageDevs);	// pointer to enumerator

	SysFreeString(className);

	// For each logical storage device...
	if (SUCCEEDED(hRes)) 
	{
		ULONG uReturned = 1;
		while(uReturned == 1)
		{
			IWbemClassObject *pStorageDev = NULL;
			//---------------------------
			// enumerate through the resultset.
			hRes = pEnumStorageDevs->Next(
				2000,			// timeout in two seconds
				1,				// return just one storage device
				&pStorageDev,	// pointer to storage device
				&uReturned);	// number obtained: one or zero

			if (SUCCEEDED(hRes) && (uReturned == 1))
			{
				VARIANT pVal;
				VariantClear(&pVal);

				// Get the "__RELPATH" system property.
				BSTR propName = SysAllocString(L"__RELPATH");

				hRes = pStorageDev->Get(
					propName,	// property name 
					0L, 
					&pVal,		// output to this variant 
					NULL, 
					NULL);

				// Done with this object.
				if (pStorageDev)  pStorageDev->Release();

				// Add the path property to the output listbox.
				if (SUCCEEDED(hRes)) 
					m_outputList.AddString(CString(V_BSTR(&pVal)));
			}
        } // end while

		// Done with this enumerator.
		if (pEnumStorageDevs)  pEnumStorageDevs->Release();
		
		// Enable disk info button if disk info is available.
		if (m_outputList.GetCount() > 0)
		{
			m_outputList.SetCurSel(0);
			m_diskInfo.EnableWindow(TRUE);
		}
    } 
	else m_outputList.AddString(
		ErrorMsg(_T("CreateInstanceEnum() failed:"), hRes));
}


/////////////////////////////////////////////////////////////////////////////
// Create a namespace

// Save a pointer to the root\cimv2\office namespace 
// in m_pOfficeService.
// Create the namespace if it doesn't already exist
void CWbemClientDlg::OnMakeoffice() 
{
	CWaitCursor wait;

	// If already connected to the namespace, we are done.
	if (m_pOfficeService)  return;

	// if "Office" namespace doesn't exist...
	BSTR Namespace = SysAllocString(L"SAMPLE_Office");

	HRESULT hRes = m_pIWbemServices->OpenNamespace(
		Namespace, 
		0, NULL, 
		&m_pOfficeService, 
		NULL);
	
	// Don't SysFreeString(Namespace) here; we'll need it later.
	m_outputList.ResetContent();

	if (FAILED(hRes)) 
	{ 
		// Create __namespace class.
		BSTR NamespaceClass = SysAllocString(L"__Namespace");
		IWbemClassObject *pNSClass = NULL;

		hRes = m_pIWbemServices->GetObject(
			NamespaceClass,	// object path
			0L,	NULL,
			&pNSClass,		// pointer to object
			NULL);
		
		SysFreeString(NamespaceClass);

		if (SUCCEEDED(hRes))
		{
			// Spawn a new instance of this class.
			IWbemClassObject *pNSInst = NULL;

			hRes = pNSClass->SpawnInstance(0, &pNSInst);
			if(SUCCEEDED(hRes))
			{
				// Set the new namespace's name.
				VARIANT v;
				VariantInit(&v);
				V_VT(&v) = VT_BSTR;
				V_BSTR(&v) = Namespace;
				
				BSTR Prop = SysAllocString(L"Name");

				hRes = pNSInst->Put(
					Prop, 
					0, 
					&v, 
					0);

				SysFreeString(Prop);
				VariantClear(&v);

				// Create the instance.
				hRes = m_pIWbemServices->PutInstance(
					pNSInst, 
					WBEM_FLAG_CREATE_OR_UPDATE, 
					NULL, NULL);

				pNSInst->Release();
				pNSInst = NULL;

				if (SUCCEEDED(hRes)) {
					m_outputList.AddString(_T("Created office namespace"));

					// open the new namespace.
					hRes = m_pIWbemServices->OpenNamespace(
						Namespace, 0, NULL, &m_pOfficeService, NULL);
				}
			}
			pNSClass->Release();  // Don't need the class any more
			pNSClass = NULL;
		}
	}

	SysFreeString(Namespace);

	if (m_pOfficeService)
	{
		 // wmibug#3024: Note: We should always 'try' to create the namespace.  We
		 // don't use m_pOfficeService for anything else, so it is a good idea to
		 // Release() and NULL it
		 m_pOfficeService->Release();
		 m_pOfficeService = NULL;
		 m_outputList.AddString(_T("Connected to office"));
	}
	else m_outputList.AddString(
		ErrorMsg(_T("Failed to connect to office"), hRes));

	m_diskInfo.EnableWindow(FALSE);
}


// Display the properties of the selected disk.
void CWbemClientDlg::OnDiskinfo() 
{
	CWaitCursor wait;
	
	// OnEnumDisks must precede next OnDiskInfo.
	m_diskInfo.EnableWindow(FALSE);
	
	// Get selected disk from list box as a BSTR
	CString sDevice;
	int index = m_outputList.GetCurSel();
	m_outputList.GetText(index, sDevice);

	BSTR sDisk = sDevice.AllocSysString();

	// Get the selected Win32_LogicalDisk instance.
	IWbemClassObject *pDisk = NULL;

	HRESULT hRes = m_pIWbemServices->GetObject(
		sDisk,		// object path
		0L,	NULL,
		&pDisk,		// pointer to object
		NULL);

	SysFreeString(sDisk);
	
	// Get the property names from this instance.
	SAFEARRAY *psaNames = NULL;

	hRes = pDisk->GetNames(
		NULL, 
		WBEM_FLAG_ALWAYS | WBEM_FLAG_NONSYSTEM_ONLY, 
		NULL, 
		&psaNames);
	
	if (SUCCEEDED(hRes))
	{
		// Get the number of properties.
		long lLower, lUpper; 

		SafeArrayGetLBound(psaNames, 1, &lLower);
		SafeArrayGetUBound(psaNames, 1, &lUpper);
		TRACE("SAFEARRAY from %d to %d\n", lLower, lUpper);

		// For each property...
		BSTR cimType  = SysAllocString(L"CIMTYPE");
		BSTR PropName = NULL;

		m_outputList.ResetContent();

		for (long i = lLower; i <= lUpper; i++) 
		{
			// Get this property.
			hRes = SafeArrayGetElement(
				psaNames, 
				&i, 
				&PropName);
			if (SUCCEEDED(hRes))
			{
				// Format: name (type) ==> value
				CString sProp = CString(PropName) + _T(" (");

				VARIANT pVal;
				VariantClear(&pVal);

				// Get qualifier set for this property.
				// Note that system properties have no qualifier set.
				IWbemQualifierSet *pQualSet = NULL;
				
				hRes = pDisk->GetPropertyQualifierSet(
					PropName,		// name of property
					&pQualSet);		// qualifier set pointer

				if (SUCCEEDED(hRes))
				{
					pQualSet->Get(
						cimType,	// property name 
						0L, 
						&pVal,		// output to this variant 
						NULL);

					if (SUCCEEDED(hRes)) 
					{
					   sProp += V_BSTR(&pVal);
					} 
				}
				sProp += _T(")");
				m_outputList.AddString(sProp);
			}
			SysFreeString(PropName);

		}
		SafeArrayDestroy(psaNames);
	}
	pDisk->Release();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\snapin\about.h ===
//==============================================================;

//

//	This source code is only intended as a supplement to existing Microsoft documentation. 

//

//	Use of this code is NOT supported.  

//

//

//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY

//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE

//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR

//  PURPOSE.

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved 
//
//    Microsoft Premier Support for Developers
//
//==============================================================;

#ifndef _SAMPABOUT_H_
#define _SAMPABOUT_H_

#include <tchar.h>
#include <mmc.h>

class CSnapinAbout : public ISnapinAbout
{
private:
    ULONG				m_cref;
    HBITMAP				m_hSmallImage;
    HBITMAP				m_hLargeImage;
    HBITMAP				m_hSmallImageOpen;
    HICON				m_hAppIcon;
    
public:
    CSnapinAbout();
    ~CSnapinAbout();
    
    ///////////////////////////////
    // Interface IUnknown
    ///////////////////////////////
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    ///////////////////////////////
    // Interface ISnapinAbout
    ///////////////////////////////
    STDMETHODIMP GetSnapinDescription( 
        /* [out] */ LPOLESTR *lpDescription);
        
        STDMETHODIMP GetProvider( 
        /* [out] */ LPOLESTR *lpName);
        
        STDMETHODIMP GetSnapinVersion( 
        /* [out] */ LPOLESTR *lpVersion);
        
        STDMETHODIMP GetSnapinImage( 
        /* [out] */ HICON *hAppIcon);
        
        STDMETHODIMP GetStaticFolderImage( 
        /* [out] */ HBITMAP *hSmallImage,
        /* [out] */ HBITMAP *hSmallImageOpen,
        /* [out] */ HBITMAP *hLargeImage,
        /* [out] */ COLORREF *cMask);
        
        ///////////////////////////////
        // Private Interface 
        ///////////////////////////////
private:
    HRESULT	CSnapinAbout::AllocOleStr(
        LPOLESTR *lpDest, 
        _TCHAR *szBuffer);
};

#endif _SAMPABOUT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\snapin\basesnap.h ===
//==============================================================;

//

//	This source code is only intended as a supplement to existing Microsoft documentation. 

//

//	Use of this code is NOT supported.  

//

//

//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY

//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE

//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR

//  PURPOSE.

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved 
//
//    Microsoft Premier Support for Developers
//
//==============================================================;
#ifndef _BASESNAP_H_
#define _BASESNAP_H_

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppvObj);
STDAPI DllCanUnloadNow(void);

ULONG g_uObjects = 0;
ULONG g_uSrvLock = 0;

class CClassFactory : public IClassFactory
{
private:
    ULONG	m_cref;
    
public:
    enum FACTORY_TYPE {COMPONENT = 0, ABOUT = 1};
    
    CClassFactory(FACTORY_TYPE factoryType);
    ~CClassFactory();
    
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    STDMETHODIMP CreateInstance(LPUNKNOWN, REFIID, LPVOID *);
    STDMETHODIMP LockServer(BOOL);
    
private:
    FACTORY_TYPE m_factoryType;
};

#endif _BASESNAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\snapin\basesnap.cpp ===
//==============================================================;

//

//	This source code is only intended as a supplement to existing Microsoft documentation. 

//

//	Use of this code is NOT supported.  

//

//

//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY

//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE

//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR

//  PURPOSE.

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved 
//
//    Microsoft Premier Support for Developers
//
//==============================================================;

#include <objbase.h>
#include <olectl.h>
#include <initguid.h>
#include "guids.h"
#include "basesnap.h"
#include "Comp.h"
#include "CompData.h"
#include "About.h"
#include "Registry.h"

// our globals
HINSTANCE g_hinst;

BOOL WINAPI DllMain(HINSTANCE hinstDLL, 
                    DWORD fdwReason, 
                    void* lpvReserved)
{
    
    if (fdwReason == DLL_PROCESS_ATTACH) {
        g_hinst = hinstDLL;
    }
    
    return TRUE;
}


STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppvObj)
{
    if ((rclsid != CLSID_CComponentData) && (rclsid != CLSID_CSnapinAbout))
        return CLASS_E_CLASSNOTAVAILABLE;
    
    
    if (!ppvObj)
        return E_FAIL;
    
    *ppvObj = NULL;
    
    // We can only hand out IUnknown and IClassFactory pointers.  Fail
    // if they ask for anything else.
    if (!IsEqualIID(riid, IID_IUnknown) && !IsEqualIID(riid, IID_IClassFactory))
        return E_NOINTERFACE;
    
    CClassFactory *pFactory = NULL;
    
    // make the factory passing in the creation function for the type of object they want
    if (rclsid == CLSID_CComponentData)
        pFactory = new CClassFactory(CClassFactory::COMPONENT);
    else if (rclsid == CLSID_CSnapinAbout)
        pFactory = new CClassFactory(CClassFactory::ABOUT);
    
    if (NULL == pFactory)
        return E_OUTOFMEMORY;
    
    HRESULT hr = pFactory->QueryInterface(riid, ppvObj);
    
    return hr;
}

STDAPI DllCanUnloadNow(void)
{
    if (g_uObjects == 0 && g_uSrvLock == 0)
        return S_OK;
    else
        return S_FALSE;
}


CClassFactory::CClassFactory(FACTORY_TYPE factoryType)
: m_cref(0), m_factoryType(factoryType)
{
    OBJECT_CREATED
}

CClassFactory::~CClassFactory()
{
    OBJECT_DESTROYED
}

STDMETHODIMP CClassFactory::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;
    
    *ppv = NULL;
    
    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IClassFactory *>(this);
    else
        if (IsEqualIID(riid, IID_IClassFactory))
            *ppv = static_cast<IClassFactory *>(this);
        
        if (*ppv)
        {
            reinterpret_cast<IUnknown *>(*ppv)->AddRef();
            return S_OK;
        }
        
        return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CClassFactory::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CClassFactory::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        delete this;
        return 0;
    }
    return m_cref;
}

STDMETHODIMP CClassFactory::CreateInstance(LPUNKNOWN pUnkOuter, REFIID riid, LPVOID * ppvObj)
{
    HRESULT  hr;
    void* pObj;
    
    if (!ppvObj)
        return E_FAIL;
    
    *ppvObj = NULL;
    
    // Our object does does not support aggregation, so we need to
    // fail if they ask us to do aggregation.
    if (pUnkOuter)
        return CLASS_E_NOAGGREGATION;
    
    if (COMPONENT == m_factoryType) {
        pObj = new CComponentData();
    } else {
        pObj = new CSnapinAbout();
    }
    
    if (!pObj)
        return E_OUTOFMEMORY;
    
    // QueryInterface will do the AddRef() for us, so we do not
    // do it in this function
    hr = ((LPUNKNOWN)pObj)->QueryInterface(riid, ppvObj);
    
    if (FAILED(hr))
        delete pObj;
    
    return hr;
}

STDMETHODIMP CClassFactory::LockServer(BOOL fLock)
{
    if (fLock)
        InterlockedIncrement((LONG *)&g_uSrvLock);
    else
        InterlockedDecrement((LONG *)&g_uSrvLock);
    
    return S_OK;
}

//////////////////////////////////////////////////////////
//
// Exported functions
//


//
// Server registration
//
STDAPI DllRegisterServer()
{
    HRESULT hr = SELFREG_E_CLASS;
    _TCHAR szName[256];
    _TCHAR szSnapInName[256];
    
    LoadString(g_hinst, IDS_NAME, szName, sizeof(szName));
    LoadString(g_hinst, IDS_SNAPINNAME, szSnapInName, sizeof(szSnapInName));
    
    _TCHAR szAboutName[256];
    
    LoadString(g_hinst, IDS_ABOUTNAME, szAboutName, sizeof(szAboutName));
    
    // register our CoClasses
    hr = RegisterServer(g_hinst, 
        CLSID_CComponentData, 
        szName);
    
    if SUCCEEDED(hr)
        hr = RegisterServer(g_hinst, 
        CLSID_CSnapinAbout, 
        szAboutName);
    
    // place the registry information for SnapIns
    if SUCCEEDED(hr)
        hr = RegisterSnapin(CLSID_CComponentData, szSnapInName, CLSID_CSnapinAbout, FALSE);
    
    return hr;
}


STDAPI DllUnregisterServer()
{
    if (UnregisterServer(CLSID_CComponentData) == S_OK)
        return UnregisterSnapin(CLSID_CComponentData);
    else
        return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\snapin\comp.cpp ===
//==============================================================;

//

//      This source code is only intended as a supplement to existing Microsoft documentation.

//

//      Use of this code is NOT supported.

//

//

//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY

//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE

//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR

//  PURPOSE.

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved 
//
//    Microsoft Premier Support for Developers
//
//==============================================================;

#include "Comp.h"
#include "DataObj.h"
#include <commctrl.h>        // Needed for button styles...
#include <crtdbg.h>
#include "globals.h"
#include "resource.h"
#include "DeleBase.h"
#include "CompData.h"

CComponent::CComponent(CComponentData *parent)
: m_pComponentData(parent), m_cref(0), m_ipConsole(NULL)
{
    OBJECT_CREATED
}

CComponent::~CComponent()
{
    OBJECT_DESTROYED
}

STDMETHODIMP CComponent::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;

    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IComponent *>(this);
    else if (IsEqualIID(riid, IID_IComponent))
        *ppv = static_cast<IComponent *>(this);

    // first things first, make sure that when MMC
    // asks if we do property sheets, that we actually
    // say "yes"
    else if (IsEqualIID(riid, IID_IExtendPropertySheet))
        *ppv = static_cast<IExtendPropertySheet2 *>(this);
    else if (IsEqualIID(riid, IID_IExtendPropertySheet2))
        *ppv = static_cast<IExtendPropertySheet2 *>(this);

    if (*ppv)
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CComponent::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CComponent::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        delete this;
        return 0;
    }
    return m_cref;

}

///////////////////////////////
// Interface IComponent
///////////////////////////////
STDMETHODIMP CComponent::Initialize(
                                    /* [in] */ LPCONSOLE lpConsole)
{
    HRESULT hr = S_OK;

    // Save away all the interfaces we'll need.
    // Fail if we can't QI the required interfaces.

    m_ipConsole = lpConsole;
    m_ipConsole->AddRef();

    return hr;
}

STDMETHODIMP CComponent::Notify(
                                /* [in] */ LPDATAOBJECT lpDataObject,
                                /* [in] */ MMC_NOTIFY_TYPE event,
                                /* [in] */ LPARAM arg,
                                /* [in] */ LPARAM param)
{
        MMCN_Crack(FALSE, lpDataObject, NULL, this, event, arg, param);

    HRESULT hr = S_FALSE;
    CDelegationBase *base = NULL;

    // we need to watch for property change and delegate it
    // a little differently, we're actually going to send
    // the CDelegationBase object pointer in the property page
    // PSN_APPLY handler via MMCPropPageNotify()
    if (MMCN_PROPERTY_CHANGE != event) {
        if (NULL == lpDataObject)
            return S_FALSE;

        base = GetOurDataObject(lpDataObject)->GetBaseNodeObject();
    } else {
        base = (CDelegationBase *)param;
    }

    switch (event)      {
    case MMCN_SHOW:
        hr = base->OnShow(m_ipConsole, (BOOL)arg, (HSCOPEITEM)param);
        break;

    case MMCN_ADD_IMAGES:
        hr = base->OnAddImages((IImageList *)arg, (HSCOPEITEM)param);
        break;

    case MMCN_SELECT:
        hr = base->OnSelect(m_ipConsole, (BOOL)LOWORD(arg), (BOOL)HIWORD(arg));
        break;

    case MMCN_RENAME:
        hr = base->OnRename((LPOLESTR)param);
        break;

    case MMCN_REFRESH:
        hr = base->OnRefresh(lpDataObject);
        break;

	// handle the property change notification if we need to do anything
    // special with it
    case MMCN_PROPERTY_CHANGE:
        hr = base->OnPropertyChange();
        break;
    }

    return hr;
}

STDMETHODIMP CComponent::Destroy(
                                 /* [in] */ MMC_COOKIE cookie)
{
    if (m_ipConsole) {
        m_ipConsole->Release();
        m_ipConsole = NULL;
    }

    return S_OK;
}


STDMETHODIMP CComponent::QueryDataObject(
                                         /* [in] */ MMC_COOKIE cookie,
                                         /* [in] */ DATA_OBJECT_TYPES type,
                                         /* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject)
{
    CDataObject *pObj = NULL;

    if (cookie == 0)
        pObj = new CDataObject((MMC_COOKIE)m_pComponentData->m_pStaticNode, type);
    else
        pObj = new CDataObject(cookie, type);

    if (!pObj)
        return E_OUTOFMEMORY;

    pObj->QueryInterface(IID_IDataObject, (void **)ppDataObject);

    return S_OK;
}

STDMETHODIMP CComponent::GetResultViewType(
                                           /* [in] */ MMC_COOKIE cookie,
                                           /* [out] */ LPOLESTR __RPC_FAR *ppViewType,
                                           /* [out] */ long __RPC_FAR *pViewOptions)
{
    CDelegationBase *base = (CDelegationBase *)cookie;

    //
    // Ask for default listview.
    //
    if (base == NULL)
    {
        *pViewOptions = MMC_VIEW_OPTIONS_NONE;
        *ppViewType = NULL;
    }
    else
        return base->GetResultViewType(ppViewType, pViewOptions);

    return S_OK;
}

STDMETHODIMP CComponent::GetDisplayInfo(
                                        /* [out][in] */ RESULTDATAITEM __RPC_FAR *pResultDataItem)
{
    HRESULT hr = S_OK;
    CDelegationBase *base = NULL;

    // if they are asking for the RDI_STR we have one of those to give

    if (pResultDataItem->lParam) {
        base = (CDelegationBase *)pResultDataItem->lParam;
        if (pResultDataItem->mask & RDI_STR) {
                        LPCTSTR pszT = base->GetDisplayName(pResultDataItem->nCol);
                        MAKE_WIDEPTR_FROMTSTR_ALLOC(pszW, pszT);
            pResultDataItem->str = pszW;
        }

        if (pResultDataItem->mask & RDI_IMAGE) {
            pResultDataItem->nImage = base->GetBitmapIndex();
        }
    }

    return hr;
}


STDMETHODIMP CComponent::CompareObjects(
                                        /* [in] */ LPDATAOBJECT lpDataObjectA,
                                        /* [in] */ LPDATAOBJECT lpDataObjectB)
{
    CDelegationBase *baseA = GetOurDataObject(lpDataObjectA)->GetBaseNodeObject();
    CDelegationBase *baseB = GetOurDataObject(lpDataObjectB)->GetBaseNodeObject();

    // compare the object pointers
    if (baseA->GetCookie() == baseB->GetCookie())
        return S_OK;

    return S_FALSE;
}

///////////////////////////////////
// Interface IExtendPropertySheet2
///////////////////////////////////
HRESULT CComponent::CreatePropertyPages(
                                        /* [in] */ LPPROPERTYSHEETCALLBACK lpProvider,
                                        /* [in] */ LONG_PTR handle,
                                        /* [in] */ LPDATAOBJECT lpIDataObject)
{
    CDelegationBase *base = GetOurDataObject(lpIDataObject)->GetBaseNodeObject();

    return base->CreatePropertyPages(lpProvider, handle);
}

HRESULT CComponent::QueryPagesFor(
                                  /* [in] */ LPDATAOBJECT lpDataObject)
{
    CDelegationBase *base = GetOurDataObject(lpDataObject)->GetBaseNodeObject();

    return base->HasPropertySheets();
}

HRESULT CComponent::GetWatermarks(
                                  /* [in] */ LPDATAOBJECT lpIDataObject,
                                  /* [out] */ HBITMAP __RPC_FAR *lphWatermark,
                                  /* [out] */ HBITMAP __RPC_FAR *lphHeader,
                                  /* [out] */ HPALETTE __RPC_FAR *lphPalette,
                                  /* [out] */ BOOL __RPC_FAR *bStretch)
{
    CDelegationBase *base = GetOurDataObject(lpIDataObject)->GetBaseNodeObject();

    return base->GetWatermarks(lphWatermark, lphHeader, lphPalette, bStretch);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\snapin\comp.h ===
//==============================================================;

//

//	This source code is only intended as a supplement to existing Microsoft documentation. 

//

//	Use of this code is NOT supported.  

//

//

//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY

//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE

//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR

//  PURPOSE.

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved 
//
//    Microsoft Premier Support for Developers
//
//==============================================================;

#ifndef _SAMPCOMP_H_
#define _SAMPCOMP_H_

#include <mmc.h>

class CComponent : public IComponent,
IExtendPropertySheet2
{
private:
    ULONG				m_cref;
    
    IConsole*		m_ipConsole;
    
    class CComponentData *m_pComponentData;
    
    public:
        CComponent(CComponentData *parent);
        ~CComponent();
        
        ///////////////////////////////
        // Interface IUnknown
        ///////////////////////////////
        STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
        STDMETHODIMP_(ULONG) AddRef();
        STDMETHODIMP_(ULONG) Release();
        
        ///////////////////////////////
        // Interface IComponent
        ///////////////////////////////
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ LPCONSOLE lpConsole);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Notify( 
            /* [in] */ LPDATAOBJECT lpDataObject,
            /* [in] */ MMC_NOTIFY_TYPE event,
            /* [in] */ LPARAM arg,
            /* [in] */ LPARAM param);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Destroy( 
            /* [in] */ MMC_COOKIE cookie);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryDataObject( 
            /* [in] */ MMC_COOKIE cookie,
            /* [in] */ DATA_OBJECT_TYPES type,
            /* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetResultViewType( 
            /* [in] */ MMC_COOKIE cookie,
            /* [out] */ LPOLESTR __RPC_FAR *ppViewType,
            /* [out] */ long __RPC_FAR *pViewOptions);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDisplayInfo( 
            /* [out][in] */ RESULTDATAITEM __RPC_FAR *pResultDataItem);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CompareObjects( 
            /* [in] */ LPDATAOBJECT lpDataObjectA,
            /* [in] */ LPDATAOBJECT lpDataObjectB);
            
            //////////////////////////////////
            // Interface IExtendPropertySheet2
            //////////////////////////////////
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreatePropertyPages( 
            /* [in] */ LPPROPERTYSHEETCALLBACK lpProvider,
            /* [in] */ LONG_PTR handle,
            /* [in] */ LPDATAOBJECT lpIDataObject);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryPagesFor( 
            /* [in] */ LPDATAOBJECT lpDataObject);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetWatermarks( 
            /* [in] */ LPDATAOBJECT lpIDataObject,
            /* [out] */ HBITMAP __RPC_FAR *lphWatermark,
            /* [out] */ HBITMAP __RPC_FAR *lphHeader,
            /* [out] */ HPALETTE __RPC_FAR *lphPalette,
            /* [out] */ BOOL __RPC_FAR *bStretch);
};

#endif _SAMPCOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\snapin\compdata.cpp ===
//==============================================================;

//

//      This source code is only intended as a supplement to existing Microsoft documentation.

//

//      Use of this code is NOT supported.

//

//

//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY

//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE

//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR

//  PURPOSE.

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved 
//
//    Microsoft Premier Support for Developers
//
//==============================================================;

#include "Comp.h"
#include "CompData.h"
#include "DataObj.h"
#include "resource.h"
#include <crtdbg.h>

CComponentData::CComponentData()
: m_cref(0), m_ipConsoleNameSpace(NULL), m_ipConsole(NULL)
{
    OBJECT_CREATED

        m_pStaticNode = new CStaticNode;
}

CComponentData::~CComponentData()
{
    if (m_pStaticNode) {
        delete m_pStaticNode;
    }

    OBJECT_DESTROYED
}

///////////////////////
// IUnknown implementation
///////////////////////

STDMETHODIMP CComponentData::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;

    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IComponentData *>(this);
    else if (IsEqualIID(riid, IID_IComponentData))
        *ppv = static_cast<IComponentData *>(this);

    // first things first, make sure that when MMC
    // asks if we do property sheets, that we actually
    // say "yes"
    else if (IsEqualIID(riid, IID_IExtendPropertySheet) ||
        IsEqualIID(riid, IID_IExtendPropertySheet2))
        *ppv = static_cast<IExtendPropertySheet2 *>(this);

    if (*ppv)
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CComponentData::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CComponentData::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        // we need to decrement our object count in the DLL
        delete this;
        return 0;
    }

    return m_cref;
}

///////////////////////////////
// Interface IComponentData
///////////////////////////////
HRESULT CComponentData::Initialize(
                                   /* [in] */ LPUNKNOWN pUnknown)
{
    HRESULT      hr;

    //
    // Get pointer to name space interface
    //
    hr = pUnknown->QueryInterface(IID_IConsoleNameSpace, (void **)&m_ipConsoleNameSpace);
    _ASSERT( S_OK == hr );

    //
    // Get pointer to console interface
    //
    hr = pUnknown->QueryInterface(IID_IConsole, (void **)&m_ipConsole);
    _ASSERT( S_OK == hr );

    IImageList *pImageList;
    m_ipConsole->QueryScopeImageList(&pImageList);
    _ASSERT( S_OK == hr );

    hr = pImageList->ImageListSetStrip((LONG_PTR *)m_pStaticNode->m_pBMapSm, // pointer to a handle
        (LONG_PTR *)m_pStaticNode->m_pBMapLg, // pointer to a handle
        0, // index of the first image in the strip
        RGB(0, 128, 128)  // color of the icon mask
        );

    pImageList->Release();

    return S_OK;
}

HRESULT CComponentData::CreateComponent(
                                        /* [out] */ LPCOMPONENT __RPC_FAR *ppComponent)
{
    *ppComponent = NULL;

    CComponent *pComponent = new CComponent(this);

    if (NULL == pComponent)
        return E_OUTOFMEMORY;

    return pComponent->QueryInterface(IID_IComponent, (void **)ppComponent);
}

HRESULT CComponentData::Notify(
                               /* [in] */ LPDATAOBJECT lpDataObject,
                               /* [in] */ MMC_NOTIFY_TYPE event,
                               /* [in] */ LPARAM arg,
                               /* [in] */ LPARAM param)
{
	MMCN_Crack(TRUE, lpDataObject, this, NULL, event, arg, param);

    if (NULL == lpDataObject)
        return S_FALSE;

    HRESULT hr = S_FALSE;
    CDelegationBase *base = GetOurDataObject(lpDataObject)->GetBaseNodeObject();

    switch (event)
    {
    case MMCN_EXPAND:
        hr = base->OnExpand(m_ipConsoleNameSpace, m_ipConsole, (HSCOPEITEM)param);
        break;
    }

    return hr;
}

HRESULT CComponentData::Destroy( void)
{
    // Free interfaces
    if (m_ipConsoleNameSpace) {
        m_ipConsoleNameSpace->Release();
        m_ipConsoleNameSpace = NULL;
    }

    if (m_ipConsole) {
        m_ipConsole->Release();
        m_ipConsole = NULL;
    }

    return S_OK;
}

HRESULT CComponentData::QueryDataObject(
                                        /* [in] */ MMC_COOKIE cookie,
                                        /* [in] */ DATA_OBJECT_TYPES type,
                                        /* [out] */ LPDATAOBJECT *ppDataObject)
{
    CDataObject *pObj = NULL;

    if (cookie == 0)
        pObj = new CDataObject((MMC_COOKIE)m_pStaticNode, type);
    else
        pObj = new CDataObject(cookie, type);

    if (!pObj)
        return E_OUTOFMEMORY;

    pObj->QueryInterface(IID_IDataObject, (void **)ppDataObject);

    return S_OK;
}

HRESULT CComponentData::GetDisplayInfo(
                                       /* [out][in] */ SCOPEDATAITEM *pScopeDataItem)
{
    HRESULT hr = S_FALSE;

    // if they are asking for the SDI_STR we have one of those to give
    if (pScopeDataItem->lParam) {
        CDelegationBase *base = (CDelegationBase *)pScopeDataItem->lParam;
        if (pScopeDataItem->mask & SDI_STR) {
                        LPCTSTR pszT = base->GetDisplayName();
                        MAKE_WIDEPTR_FROMTSTR_ALLOC(pszW, pszT);
            pScopeDataItem->displayname = pszW;
        }

        if (pScopeDataItem->mask & SDI_IMAGE) {
            pScopeDataItem->nImage = base->GetBitmapIndex();
        }
    }

    return hr;
}

HRESULT CComponentData::CompareObjects(
                                       /* [in] */ LPDATAOBJECT lpDataObjectA,
                                       /* [in] */ LPDATAOBJECT lpDataObjectB)
{
    CDelegationBase *baseA = GetOurDataObject(lpDataObjectA)->GetBaseNodeObject();
    CDelegationBase *baseB = GetOurDataObject(lpDataObjectB)->GetBaseNodeObject();

    // compare the object pointers
    if (baseA->GetCookie() == baseB->GetCookie())
        return S_OK;

    return S_FALSE;
}

///////////////////////////////////
// Interface IExtendPropertySheet2
///////////////////////////////////
HRESULT CComponentData::CreatePropertyPages(
                                            /* [in] */ LPPROPERTYSHEETCALLBACK lpProvider,
                                            /* [in] */ LONG_PTR handle,
                                            /* [in] */ LPDATAOBJECT lpIDataObject)
{
    CDelegationBase *base = GetOurDataObject(lpIDataObject)->GetBaseNodeObject();

    return base->CreatePropertyPages(lpProvider, handle);
}

HRESULT CComponentData::QueryPagesFor(
                                      /* [in] */ LPDATAOBJECT lpDataObject)
{
    CDelegationBase *base = GetOurDataObject(lpDataObject)->GetBaseNodeObject();

    return base->HasPropertySheets();
}

HRESULT CComponentData::GetWatermarks(
                                      /* [in] */ LPDATAOBJECT lpIDataObject,
                                      /* [out] */ HBITMAP __RPC_FAR *lphWatermark,
                                      /* [out] */ HBITMAP __RPC_FAR *lphHeader,
                                      /* [out] */ HPALETTE __RPC_FAR *lphPalette,
                                      /* [out] */ BOOL __RPC_FAR *bStretch)
{
    CDelegationBase *base = GetOurDataObject(lpIDataObject)->GetBaseNodeObject();

    return base->GetWatermarks(lphWatermark, lphHeader, lphPalette, bStretch);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\snapin\dataobj.h ===
//==============================================================;

//

//	This source code is only intended as a supplement to existing Microsoft documentation. 

//

//	Use of this code is NOT supported.  

//

//

//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY

//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE

//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR

//  PURPOSE.

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved 
//
//    Microsoft Premier Support for Developers
//
//==============================================================;

#ifndef _SAMPDATAOBJECT_H_
#define _SAMPDATAOBJECT_H_

#include <mmc.h>
#include "DeleBase.h"

class CDataObject : public IDataObject
{
private:
    ULONG				m_cref;
    MMC_COOKIE			m_lCookie;
    DATA_OBJECT_TYPES   m_context;
    
public:
    CDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES context);
    ~CDataObject();
    
    ///////////////////////////////
    // Interface IUnknown
    ///////////////////////////////
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    ///////////////////////////////
    // IDataObject methods 
    ///////////////////////////////
    STDMETHODIMP GetDataHere (FORMATETC *pformatetc, STGMEDIUM *pmedium);
    
    // The rest are not implemented
    STDMETHODIMP GetData (LPFORMATETC lpFormatetcIn, LPSTGMEDIUM lpMedium)
    { return E_NOTIMPL; };
    
    STDMETHODIMP EnumFormatEtc (DWORD dwDirection, LPENUMFORMATETC* ppEnumFormatEtc)
    { return E_NOTIMPL; };
    
    STDMETHODIMP QueryGetData (LPFORMATETC lpFormatetc) 
    { return E_NOTIMPL; };
    
    STDMETHODIMP GetCanonicalFormatEtc (LPFORMATETC lpFormatetcIn, LPFORMATETC lpFormatetcOut)
    { return E_NOTIMPL; };
    
    STDMETHODIMP SetData (LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium, BOOL bRelease)
    { return E_NOTIMPL; };
    
    STDMETHODIMP DAdvise (LPFORMATETC lpFormatetc, DWORD advf, LPADVISESINK pAdvSink, LPDWORD pdwConnection)
    { return E_NOTIMPL; };
    
    STDMETHODIMP DUnadvise (DWORD dwConnection)
    { return E_NOTIMPL; };
    
    STDMETHODIMP EnumDAdvise (LPENUMSTATDATA* ppEnumAdvise)
    { return E_NOTIMPL; };
    
    ///////////////////////////////
    // Custom Methods
    ///////////////////////////////
    
    CDelegationBase *GetBaseNodeObject() {
        return (CDelegationBase *)m_lCookie;
    }
    
    DATA_OBJECT_TYPES GetContext() {
        return m_context;
    }
    
public:
    // clipboard formats
    static UINT s_cfSZNodeType;
    static UINT s_cfDisplayName;
    static UINT s_cfNodeType;
    static UINT s_cfSnapinClsid;
    static UINT s_cfInternal;
    
};

HRESULT ExtractFromDataObject(IDataObject *lpDataObject,UINT cf,ULONG cb,HGLOBAL *phGlobal);
CDataObject* GetOurDataObject(IDataObject *lpDataObject);
BOOL IsMMCMultiSelectDataObject(IDataObject *lpDataObject);

#endif _SAMPDATAOBJECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\snapin\compdata.h ===
//==============================================================;

//

//	This source code is only intended as a supplement to existing Microsoft documentation. 

//

//	Use of this code is NOT supported.  

//

//

//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY

//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE

//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR

//  PURPOSE.

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved 
//
//    Microsoft Premier Support for Developers
//
//==============================================================;

#ifndef _SAMPCOMPDATA_H_
#define _SAMPCOMPDATA_H_

#include <mmc.h>
#include "DeleBase.h"
#include "StatNode.h"
#include "Comp.h"

class CComponentData : public IComponentData, IExtendPropertySheet2
{
    friend class CComponent;
    
private:
    ULONG				m_cref;
    LPCONSOLE			m_ipConsole;
    LPCONSOLENAMESPACE	m_ipConsoleNameSpace;
    
    CStaticNode     *m_pStaticNode;
    
public:
    CComponentData();
    ~CComponentData();
    
    ///////////////////////////////
    // Interface IUnknown
    ///////////////////////////////
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    ///////////////////////////////
    // Interface IComponentData
    ///////////////////////////////
    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Initialize( 
        /* [in] */ LPUNKNOWN pUnknown);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateComponent( 
        /* [out] */ LPCOMPONENT __RPC_FAR *ppComponent);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Notify( 
        /* [in] */ LPDATAOBJECT lpDataObject,
        /* [in] */ MMC_NOTIFY_TYPE event,
        /* [in] */ LPARAM arg,
        /* [in] */ LPARAM param);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Destroy( void);
    
    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryDataObject( 
        /* [in] */ MMC_COOKIE cookie,
        /* [in] */ DATA_OBJECT_TYPES type,
        /* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDisplayInfo( 
        /* [out][in] */ SCOPEDATAITEM __RPC_FAR *pScopeDataItem);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CompareObjects( 
        /* [in] */ LPDATAOBJECT lpDataObjectA,
        /* [in] */ LPDATAOBJECT lpDataObjectB);
        
        //////////////////////////////////
        // Interface IExtendPropertySheet2
        //////////////////////////////////
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreatePropertyPages( 
        /* [in] */ LPPROPERTYSHEETCALLBACK lpProvider,
        /* [in] */ LONG_PTR handle,
        /* [in] */ LPDATAOBJECT lpIDataObject);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryPagesFor( 
        /* [in] */ LPDATAOBJECT lpDataObject);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetWatermarks( 
        /* [in] */ LPDATAOBJECT lpIDataObject,
        /* [out] */ HBITMAP __RPC_FAR *lphWatermark,
        /* [out] */ HBITMAP __RPC_FAR *lphHeader,
        /* [out] */ HPALETTE __RPC_FAR *lphPalette,
        /* [out] */ BOOL __RPC_FAR *bStretch);
};

#endif _SAMPCOMPDATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\snapin\dataobj.cpp ===
//==============================================================;

//

//      This source code is only intended as a supplement to existing Microsoft documentation.

//

//      Use of this code is NOT supported.

//

//

//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY

//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE

//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR

//  PURPOSE.

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved 
//
//    Microsoft Premier Support for Developers
//
//==============================================================;

#include "DataObj.h"
#include "guids.h"
#include "DeleBase.h"

//
// This is the minimum set of clipboard formats we must implement.
// MMC uses these to get necessary information from our snapin about
// our nodes.
//

// we need to do this to get around MMC.IDL - it explicitly defines
// the clipboard formats as WCHAR types...
#define _T_CCF_DISPLAY_NAME _T("CCF_DISPLAY_NAME")
#define _T_CCF_NODETYPE _T("CCF_NODETYPE")
#define _T_CCF_SZNODETYPE _T("CCF_SZNODETYPE")
#define _T_CCF_SNAPIN_CLASSID _T("CCF_SNAPIN_CLASSID")

#define _T_CCF_INTERNAL_SNAPIN _T("{2479DB32-5276-11d2-94F5-00C04FB92EC2}")

    // These are the clipboard formats that we must supply at a minimum.
    // mmc.h actually defined these. We can make up our own to use for
    // other reasons. We don't need any others at this time.
UINT CDataObject::s_cfDisplayName = RegisterClipboardFormat(_T_CCF_DISPLAY_NAME);
UINT CDataObject::s_cfNodeType    = RegisterClipboardFormat(_T_CCF_NODETYPE);
UINT CDataObject::s_cfSZNodeType  = RegisterClipboardFormat(_T_CCF_SZNODETYPE);
UINT CDataObject::s_cfSnapinClsid = RegisterClipboardFormat(_T_CCF_SNAPIN_CLASSID);
UINT CDataObject::s_cfInternal    = RegisterClipboardFormat(_T_CCF_INTERNAL_SNAPIN);


CDataObject::CDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES context)
: m_lCookie(cookie), m_context(context), m_cref(0)
{
}

CDataObject::~CDataObject()
{
}

///////////////////////
// IUnknown implementation
///////////////////////

STDMETHODIMP CDataObject::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;

    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IDataObject *>(this);
    else if (IsEqualIID(riid, IID_IDataObject))
        *ppv = static_cast<IDataObject *>(this);

    if (*ppv)
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CDataObject::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CDataObject::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        delete this;
        return 0;
    }
    return m_cref;

}

/////////////////////////////////////////////////////////////////////////////
// IDataObject implementation
//
HRESULT CDataObject::GetDataHere(
                                 FORMATETC *pFormatEtc,     // [in]  Pointer to the FORMATETC structure
                                 STGMEDIUM *pMedium         // [out] Pointer to the STGMEDIUM structure
                                 )
{
    const   CLIPFORMAT cf = pFormatEtc->cfFormat;
    IStream *pStream = NULL;

    CDelegationBase *base = GetBaseNodeObject();

    HRESULT hr = CreateStreamOnHGlobal( pMedium->hGlobal, FALSE, &pStream );
    if ( FAILED(hr) )
        return hr;                       // Minimal error checking

    hr = DV_E_FORMATETC;                 // Unknown format

    if (cf == s_cfDisplayName) {
        const _TCHAR *pszName = base->GetDisplayName();

                MAKE_WIDEPTR_FROMTSTR(wszName, pszName);

                // get length of original string and convert it accordingly
        ULONG ulSizeofName = lstrlen(pszName);
        ulSizeofName++;                      // Count null character
        ulSizeofName *= sizeof(WCHAR);

        hr = pStream->Write(wszName, ulSizeofName, NULL);
    } else if (cf == s_cfNodeType) {
        const GUID *pGUID = (const GUID *)&base->getNodeType();

        hr = pStream->Write(pGUID, (ULONG)(sizeof(GUID)), NULL);
    } else if (cf == s_cfSZNodeType) {
        LPOLESTR szGuid;
        hr = StringFromCLSID(base->getNodeType(), &szGuid);

        if (SUCCEEDED(hr)) {
            hr = pStream->Write(szGuid, (ULONG)wcslen(szGuid), NULL);
            CoTaskMemFree(szGuid);
        }
    } else if (cf == s_cfSnapinClsid) {
        const GUID *pGUID = NULL;
        pGUID = &CLSID_CComponentData;

        hr = pStream->Write(pGUID, sizeof(GUID), NULL);
    } else if (cf == s_cfInternal) {
        // we are being asked to get our this pointer from the IDataObject interface
        // only our own snap-in objects will know how to do this.
        CDataObject *pThis = this;
        hr = pStream->Write( &pThis, sizeof(CDataObject*), NULL );
    }

    pStream->Release();

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// Global helper functions to help work with dataobjects and
// clipboard formats


//---------------------------------------------------------------------------
//  Returns the current object based on the s_cfInternal clipboard format
//
CDataObject* GetOurDataObject (
                               LPDATAOBJECT lpDataObject      // [in] IComponent pointer
                               )
{
    HRESULT                      hr      = S_OK;
    CDataObject *pSDO     = NULL;

    // quick exit if we didn't get a DataObject
    if (lpDataObject == NULL)
        return NULL;

    STGMEDIUM stgmedium = { TYMED_HGLOBAL,  NULL  };
    FORMATETC formatetc = { CDataObject::s_cfInternal, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };

    // Allocate memory for the stream
    stgmedium.hGlobal = GlobalAlloc( GMEM_SHARE, sizeof(CDataObject *));

    if (!stgmedium.hGlobal)     {
        hr = E_OUTOFMEMORY;
    }

    if SUCCEEDED(hr)
        // Attempt to get data from the object
        hr = lpDataObject->GetDataHere( &formatetc, &stgmedium );

    // stgmedium now has the data we need
    if (SUCCEEDED(hr))  {
        pSDO = *(CDataObject **)(stgmedium.hGlobal);
    }

    // if we have memory free it
    if (stgmedium.hGlobal)
        GlobalFree(stgmedium.hGlobal);

    return pSDO;

} // end GetOurDataObject()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\snapin\makefile.inc ===
$(O)\makefile : makefile.nm
	copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\snapin\delebase.cpp ===
//==============================================================;

//

//	This source code is only intended as a supplement to 

//  existing Microsoft documentation. 

//

//	Use of this code is NOT supported.  

//

//

//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY

//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE

//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR

//  PURPOSE.

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved 
//
//    Microsoft Premier Support for Developers
//
//==============================================================;

#include "DeleBase.h"

const GUID CDelegationBase::thisGuid = { 0x2974380c, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };

HBITMAP CDelegationBase::m_pBMapSm = NULL;
HBITMAP CDelegationBase::m_pBMapLg = NULL;


//==============================================================
//
// CDelegationBase implementation
//
//
CDelegationBase::CDelegationBase() 
: bExpanded(FALSE) 
{ 
    if (NULL == m_pBMapSm || NULL == m_pBMapLg)
        LoadBitmaps(); 
}

CDelegationBase::~CDelegationBase() 
{ 
}

// CDelegationBase::AddImages sets up the collection of images to be displayed
// by the IComponent in the result pane as a result of its MMCN_SHOW handler
HRESULT CDelegationBase::OnAddImages(IImageList *pImageList, HSCOPEITEM hsi) 
{
    return pImageList->ImageListSetStrip((LONG_PTR *)m_pBMapSm, // pointer to a handle
        (LONG_PTR *)m_pBMapLg, // pointer to a handle
        0, // index of the first image in the strip
        RGB(0, 128, 128)  // color of the icon mask
        );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\snapin\delebase.h ===
//==============================================================;

//

//	This source code is only intended as a supplement to 

//  existing Microsoft documentation. 

//

//	Use of this code is NOT supported.  

//

//

//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY

//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE

//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR

//  PURPOSE.

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved 
//
//    Microsoft Premier Support for Developers
//
//==============================================================;

#ifndef _BRANCHES_H
#define _BRANCHES_H

#include <mmc.h>
#include <crtdbg.h>
#include "globals.h"
#include "resource.h"
#include "LocalRes.h"

class CDelegationBase {
public:
    CDelegationBase();
    virtual ~CDelegationBase();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) = 0;
    virtual const GUID & getNodeType() { _ASSERT(FALSE); return IID_NULL; }
    
    virtual const LPARAM GetCookie() { return reinterpret_cast<LPARAM>(this); }
    virtual const int GetBitmapIndex() = 0;
    
    virtual HRESULT GetResultViewType(LPOLESTR *ppViewType, long *pViewOptions) { return S_FALSE; }
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnExpand(IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsole, HSCOPEITEM parent) { return S_FALSE; }
    virtual HRESULT OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem) { return S_FALSE; }
    virtual HRESULT OnAddImages(IImageList *pImageList, HSCOPEITEM hsi);
    virtual HRESULT OnRename(LPOLESTR pszNewName) { return S_FALSE; }
    virtual HRESULT OnSelect(IConsole *pConsole, BOOL bScope, BOOL bSelect) { return S_FALSE; }
	virtual HRESULT OnRefresh(LPDATAOBJECT lpDataObject) { return S_FALSE; }
    
    virtual HRESULT CreatePropertyPages(IPropertySheetCallback *lpProvider,
        LONG_PTR handle) { return S_FALSE; }
    virtual HRESULT HasPropertySheets() { return S_FALSE; }
    virtual HRESULT GetWatermarks(HBITMAP *lphWatermark,
        HBITMAP *lphHeader,
        HPALETTE *lphPalette,
        BOOL *bStretch) { return S_FALSE; }
    
    virtual HRESULT OnPropertyChange() { return S_OK; }
    
public:
    static HBITMAP m_pBMapSm;
    static HBITMAP m_pBMapLg;
    
protected:
    static void LoadBitmaps() {
        m_pBMapSm = LoadBitmap(g_hinst, MAKEINTRESOURCE(IDR_SMICONS));
        m_pBMapLg = LoadBitmap(g_hinst, MAKEINTRESOURCE(IDR_LGICONS));
    }
    
    BOOL bExpanded;
    
private:
    // {2974380C-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
};

#endif // _BRANCHES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\snapin\localres.h ===
//==============================================================;

//

//	This source code is only intended as a supplement to existing Microsoft documentation. 

//

//	Use of this code is NOT supported.  

//

//

//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY

//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE

//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR

//  PURPOSE.

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved 
//
//    Microsoft Premier Support for Developers
//
//==============================================================;

#ifndef __LocalResource_H__
#define __LocalResource_H__

#define INDEX_NONE          -1
#define INDEX_SPACEICON     0
#define INDEX_LANDICON      1
#define INDEX_SKYICON       2
#define INDEX_PEOPLEICON    3
#define INDEX_CLOSEDFOLDER  4
#define INDEX_OPENFOLDER    5

#endif // __LocalResource_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\snapin\equipment.h ===
//==============================================================;

//

//	This source code is only intended as a supplement to 

//  existing Microsoft documentation. 

//

//	Use of this code is NOT supported.  

//

//

//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY

//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE

//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR

//  PURPOSE.

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved 
//
//    Microsoft Premier Support for Developers
//
//==============================================================;

#ifndef _EQUIPMENT_H
#define _EQUIPMENT_H

#include "DeleBase.h"
#include <wbemcli.h>
#include "SimpleArray.h"

class CEquipment;

class CEquipmentFolder : public CDelegationBase {
public:
    CEquipmentFolder();
    virtual ~CEquipmentFolder();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("Equipment"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_CLOSEDFOLDER; }
    
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnSelect(IConsole *pConsole, BOOL bScope, BOOL bSelect);
	HRESULT OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem);
	HRESULT GetPtr(IWbemServices **ptr);
	virtual HRESULT OnRefresh(LPDATAOBJECT lpDataObject);
    
private:
    // {2974380e-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
	CSimpleArray<CEquipment *> m_children;

	bool EnumChildren(IWbemServices *service);
	void EmptyChildren(void);
	HRESULT DisplayChildren(void);

	// for the connection thread.
    void StopThread();
    static LRESULT CALLBACK WindowProc(
							  HWND hwnd,      // handle to window
							  UINT uMsg,      // message identifier
							  WPARAM wParam,  // first message parameter
							  LPARAM lParam);   // second message parameter

    static DWORD WINAPI ThreadProc(LPVOID lpParameter);
	bool ErrorString(HRESULT hr, TCHAR *errMsg, UINT errSize);
	void RegisterEventSink(IWbemServices *service);
	IWbemObjectSink *m_pStubSink;
	IUnsecuredApartment *m_pUnsecApp;

    HWND m_connectHwnd;
    DWORD m_threadId;
    HANDLE m_thread;

	HANDLE m_doWork;		// telling the thread to do something.
	int m_threadCmd;		// what command the thread should do.
	#define CT_CONNECT 0
	#define CT_GET_PTR 1
	#define CT_EXIT 2

    CRITICAL_SECTION m_critSect;
    bool m_running;			// thread is processing a command now.

	HANDLE m_ptrReady;		// the thread has done the work.
	BOOL m_bSelected;
    IResultData *m_pResultData;
	IStream *m_pStream;
	IWbemServices *m_realWMI;// lives in the background thread. Use marshalling.
};

class CEquipment : public CDelegationBase {
public:
    CEquipment(CEquipmentFolder *parent, IWbemClassObject *inst);
    virtual ~CEquipment() 
	{
		if(m_inst)
			m_inst->Release();

		m_inst = 0;
	}
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0);
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }

public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnSelect(IConsole *pConsole, BOOL bScope, BOOL bSelect);
    
    virtual HRESULT CreatePropertyPages(IPropertySheetCallback *lpProvider, LONG_PTR handle);
    virtual HRESULT HasPropertySheets();
    virtual HRESULT GetWatermarks(HBITMAP *lphWatermark,
									HBITMAP *lphHeader,
									HPALETTE *lphPalette,
									BOOL *bStretch);
    
    virtual HRESULT OnPropertyChange();
    
private:
	CEquipmentFolder *m_parent;
    IWbemClassObject *m_inst;

    LONG_PTR m_ppHandle;
    
    static INT_PTR CALLBACK DialogProc(
						HWND hwndDlg,  // handle to dialog box
						UINT uMsg,     // message
						WPARAM wParam, // first message parameter
						LPARAM lParam);// second message parameter

    // {2974380e-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
	bool GetGirls(void);
	const TCHAR *ConvertSurfaceValue(BYTE val);
	HRESULT PutProperty(LPWSTR propName, LPTSTR str);
	HRESULT PutProperty(LPWSTR propName, BYTE val);
	HRESULT PutProperty(LPWSTR propName, bool val);
	void LoadSurfaces(HWND hwndDlg, BYTE iSurface);
	BYTE m_iSurface;
};


#endif // _EQUIPMENT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\snapin\globals.h ===
//==============================================================;

//

//      This source code is only intended as a supplement to existing Microsoft documentation.

//

//      Use of this code is NOT supported.

//

//

//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY

//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE

//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR

//  PURPOSE.

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved 
//
//    Microsoft Premier Support for Developers
//
//==============================================================;

#ifndef _MMC_GLOBALS_H
#define _MMC_GLOBALS_H

#include <tchar.h>

#ifndef STRINGS_ONLY
        #define IDM_BUTTON1    0x100
        #define IDM_BUTTON2    0x101

        extern HINSTANCE g_hinst;
        extern ULONG g_uObjects;

        #define OBJECT_CREATED InterlockedIncrement((long *)&g_uObjects);
        #define OBJECT_DESTROYED InterlockedDecrement((long *)&g_uObjects);

        // uncomment the following #define to enable message cracking
        // #define MMC_CRACK_MESSAGES
        void MMCN_Crack(BOOL bComponentData,
                                        IDataObject *pDataObject,
                                        IComponentData *pCompData,
                                        IComponent *pComp,
                                        MMC_NOTIFY_TYPE event,
                                        LPARAM arg,
                                        LPARAM param);
#endif

//=--------------------------------------------------------------------------=
// allocates a temporary buffer that will disappear when it goes out of scope
// NOTE: be careful of that -- make sure you use the string in the same or
// nested scope in which you created this buffer. people should not use this
// class directly.  use the macro(s) below.
//
class TempBuffer {
  public:
    TempBuffer(ULONG cBytes) {
        m_pBuf = (cBytes <= 120) ? &m_szTmpBuf : HeapAlloc(GetProcessHeap(), 0, cBytes);
        m_fHeapAlloc = (cBytes > 120);
    }
    ~TempBuffer() {
        if (m_pBuf && m_fHeapAlloc) HeapFree(GetProcessHeap(), 0, m_pBuf);
    }
    void *GetBuffer() {
        return m_pBuf;
    }

  private:
    void *m_pBuf;
    // we'll use this temp buffer for small cases.
    //
    char  m_szTmpBuf[120];
    unsigned m_fHeapAlloc:1;
};

//=--------------------------------------------------------------------------=
// string helpers.
//
// given a _TCHAR, copy it into a wide buffer.
// be careful about scoping when using this macro!
//
// how to use the below two macros:
//
//  ...
//  LPTSTR pszT;
//  pszT = MyGetTStringRoutine();
//  MAKE_WIDEPTR_FROMSTR(pwsz, pszT);
//  MyUseWideStringRoutine(pwsz);
//  ...
#ifdef UNICODE
#define MAKE_WIDEPTR_FROMTSTR(ptrname, tstr) \
    long __l##ptrname = (lstrlenW(tstr) + 1) * sizeof(WCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    lstrcpyW((LPWSTR)__TempBuffer##ptrname.GetBuffer(), tstr); \
    LPWSTR ptrname = (LPWSTR)__TempBuffer##ptrname.GetBuffer()
#else // ANSI
#define MAKE_WIDEPTR_FROMTSTR(ptrname, tstr) \
    long __l##ptrname = (lstrlenA(tstr) + 1) * sizeof(WCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    MultiByteToWideChar(CP_ACP, 0, tstr, -1, (LPWSTR)__TempBuffer##ptrname.GetBuffer(), __l##ptrname); \
    LPWSTR ptrname = (LPWSTR)__TempBuffer##ptrname.GetBuffer()
#endif

#ifdef UNICODE
#define MAKE_WIDEPTR_FROMTSTR_ALLOC(ptrname, tstr) \
    long __l##ptrname = (lstrlenW(tstr) + 1) * sizeof(WCHAR); \
    LPWSTR ptrname = (LPWSTR)CoTaskMemAlloc(__l##ptrname); \
    lstrcpyW((LPWSTR)ptrname, tstr)
#else // ANSI
#define MAKE_WIDEPTR_FROMTSTR_ALLOC(ptrname, tstr) \
    long __l##ptrname = (lstrlenA(tstr) + 1) * sizeof(WCHAR); \
    LPWSTR ptrname = (LPWSTR)CoTaskMemAlloc(__l##ptrname); \
    MultiByteToWideChar(CP_ACP, 0, tstr, -1, ptrname, __l##ptrname)
#endif

//
// similarily for MAKE_TSTRPTR_FROMWIDE.  note that the first param does not
// have to be declared, and no clean up must be done.
//
// * 2 for DBCS handling in below length computation
//
#ifdef UNICODE
#define MAKE_TSTRPTR_FROMWIDE(ptrname, widestr) \
    long __l##ptrname = (long)((wcslen(widestr) + 1) * 2 * sizeof(TCHAR)); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    lstrcpyW((LPTSTR)__TempBuffer##ptrname.GetBuffer(), widestr); \
    LPTSTR ptrname = (LPTSTR)__TempBuffer##ptrname.GetBuffer()
#else // ANSI
#define MAKE_TSTRPTR_FROMWIDE(ptrname, widestr) \
    long __l##ptrname = (long)((wcslen(widestr) + 1) * 2 * sizeof(TCHAR)); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    WideCharToMultiByte(CP_ACP, 0, widestr, -1, (LPSTR)__TempBuffer##ptrname.GetBuffer(), __l##ptrname, NULL, NULL); \
    LPTSTR ptrname = (LPTSTR)__TempBuffer##ptrname.GetBuffer()
#endif

#endif // _MMC_GLOBALS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\snapin\equipment.cpp ===
//==============================================================;

//

//      This source code is only intended as a supplement to

//  existing Microsoft documentation.

//

//      Use of this code is NOT supported.

//

//

//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY

//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE

//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR

//  PURPOSE.

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved 
//
//    Microsoft Premier Support for Developers
//
//==============================================================
#ifndef _WIN32_DCOM
#define _WIN32_DCOM
#endif

#include <objbase.h>
#include <objidl.h>

#include <stdio.h>
#include "equipment.h"
#include <commctrl.h>
#include <comdef.h>
#include <windowsx.h>


const GUID CEquipmentFolder::thisGuid = { 0xef163733, 0x9353, 0x11d2, { 0x99, 0x67, 0x0, 0x80, 0xc7, 0xdc, 0xb3, 0xdc } };

const GUID CEquipment::thisGuid = { 0xef163735, 0x9353, 0x11d2, { 0x99, 0x67, 0x0, 0x80, 0xc7, 0xdc, 0xb3, 0xdc } };

#define WM_WMI_CONNECTED WM_APP    // only sent to CEquipmentFolder::m_connectHwnd
#define WM_REFRESH_EVENT WM_APP+1   // only sent to CEquipmentFolder::m_connectHwnd

//==============================================================
//
// CEventSink implementation
//
class CEventSink : public IWbemObjectSink
{
public:
    CEventSink(HWND hwnd) : m_hwnd(hwnd){}
    ~CEventSink(){};

    STDMETHOD_(SCODE, Indicate)(long lObjectCount,
								IWbemClassObject **pObjArray)
	{
		// Not actually using the pObjArray. Just need a trigger for the 
		// refresh.
		::SendMessage(m_hwnd, WM_REFRESH_EVENT, 0, 0);
		return S_OK;
	}

    STDMETHOD_(SCODE, SetStatus)(long lFlags,
									HRESULT hResult,
									BSTR strParam,
									IWbemClassObject *pObjParam)
	{
		// SetStatus() may be called to indicate that your query becomes
		// invalid or valid again  ussually caused by multithreading 'situations'.
		return S_OK;
	}

    // IUnknown members
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID* ppv)
	{
		if(riid == IID_IUnknown || riid == IID_IWbemObjectSink)
		{
			*ppv = this;

			// you're handing out a copy of yourself so account for it.
			AddRef();
			return S_OK;
		}
		else 
		{
			return E_NOINTERFACE;
		}
	}
    STDMETHODIMP_(ULONG) AddRef(void)
	{
	    return InterlockedIncrement(&m_lRef);
	}
    STDMETHODIMP_(ULONG) Release(void)
	{
		// InterlockedDecrement() helps with thread safety.
		int lNewRef = InterlockedDecrement(&m_lRef);
		// when all the copies are released...
		if(lNewRef == 0)
		{
			// kill thyself.
			delete this;
		}

		return lNewRef;
	}

private:
    long m_lRef;
	HWND m_hwnd;
};

//==============================================================
CEquipmentFolder::CEquipmentFolder() :
					m_connectHwnd(0),
					m_threadId(0), m_thread(0), 
					m_doWork(0), m_threadCmd(CT_CONNECT),
					m_running(false), m_ptrReady(0), 
					m_pStream(0), m_realWMI(0),
					m_pResultData(0), m_pStubSink(0),
					m_pUnsecApp(0), m_bSelected(FALSE)
{
    WNDCLASS wndClass;

    ZeroMemory(&wndClass, sizeof(WNDCLASS));

    wndClass.lpfnWndProc = WindowProc; 
    wndClass.lpszClassName = _T("connectthreadwindow"); 
    wndClass.hInstance = g_hinst;

    ATOM atom = RegisterClass(&wndClass);
    m_connectHwnd = CreateWindow(
						_T("connectthreadwindow"),  // pointer to registered class name
						NULL,		 // pointer to window name
						0,			 // window style
						0,           // horizontal position of window
						0,           // vertical position of window
						0,           // window width
						0,           // window height
						NULL,		 // handle to parent or owner window
						NULL,        // handle to menu or child-window identifier
						g_hinst,     // handle to application instance
						(void *)this); // pointer to window-creation data
					
    if (m_connectHwnd)
        SetWindowLongPtr(m_connectHwnd, GWLP_USERDATA, (LONG_PTR)this);

    InitializeCriticalSection(&m_critSect);
	m_doWork = CreateEvent(NULL, FALSE, FALSE, NULL);
	m_ptrReady = CreateEvent(NULL, FALSE, FALSE, NULL);

    EnterCriticalSection(&m_critSect);
	
	// NOTE: I'm connecting real early. You may want to connect from some other place.
	m_threadCmd = CT_CONNECT;
	SetEvent(m_doWork);
    m_thread = CreateThread(NULL, 0, ThreadProc, (void *)this, 0, &m_threadId);

    LeaveCriticalSection(&m_critSect);
}

CEquipmentFolder::~CEquipmentFolder()
{
	EmptyChildren();
	if(m_pResultData)
	{
		m_pResultData->Release();
		m_pResultData = 0;
	}

	if(m_pStubSink)
	{
		IWbemServices *service = 0;
		HRESULT hr = GetPtr(&service);
		if(SUCCEEDED(hr))
		{
			service->CancelAsyncCall(m_pStubSink);
			service->Release();
			service = 0;
		}
		m_pStubSink->Release();
		m_pStubSink = NULL;
	}

	if(m_pUnsecApp)
	{
		m_pUnsecApp->Release();
		m_pUnsecApp = 0;
	}

    StopThread();

    if(m_connectHwnd != NULL)
        DestroyWindow(m_connectHwnd);

    UnregisterClass(_T("connectthreadwindow"), NULL);
    DeleteCriticalSection(&m_critSect);
}

void CEquipmentFolder::StopThread()
{
    EnterCriticalSection(&m_critSect);
    m_running = false;

    if (m_thread != NULL) 
	{
		m_threadCmd = CT_EXIT;
		SetEvent(m_doWork);
		WaitForSingleObject(m_ptrReady, 10000);

        CloseHandle(m_thread);

        m_thread = NULL;
    }
    LeaveCriticalSection(&m_critSect);
}

LRESULT CALLBACK CEquipmentFolder::WindowProc(
								  HWND hwnd,      // handle to window
								  UINT uMsg,      // message identifier
								  WPARAM wParam,  // first message parameter
								  LPARAM lParam)  // second message parameter
{
    CEquipmentFolder *pThis = (CEquipmentFolder *)GetWindowLongPtr(hwnd, GWLP_USERDATA);

    switch (uMsg) 
	{
    case WM_WMI_CONNECTED:
        if(pThis != NULL && SUCCEEDED(wParam))
		{
			IWbemServices *service = 0;
			HRESULT hr = pThis->GetPtr(&service);
			if(SUCCEEDED(hr))
			{
				pThis->RegisterEventSink(service);
				pThis->EnumChildren(service);

				// m_pResultData gets set when an onShow has happened. If set, the user already wants
				// to see equipment but the connection was slower than the UI. Catchup now.
				if(pThis->m_pResultData)
					pThis->DisplayChildren();

				// done with the marshalled service ptr.
				service->Release();
				service = 0;
			}
		}
		else
		{
			TCHAR errMsg[255] = {0};
			pThis->ErrorString((HRESULT)wParam, errMsg, 255);

			MessageBox(hwnd, errMsg, _T("WMI Snapin Sample"), MB_OK|MB_ICONSTOP);
		}
        break;

    case WM_REFRESH_EVENT:
        if(pThis != NULL)
		{
			IWbemServices *service = 0;
			HRESULT hr = pThis->GetPtr(&service);
			if(SUCCEEDED(hr))
			{
				pThis->EmptyChildren();
				pThis->EnumChildren(service);

				if(pThis->m_bSelected)
					pThis->DisplayChildren();

				// done with the marshalled service ptr.
				service->Release();
				service = 0;
			}
		}
        break;
	} //endswitch

    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}

void CEquipmentFolder::RegisterEventSink(IWbemServices *service)
{
	//NOTE: this logic is from the Wmi documentation,
	// "Security Considerations with Asynchronous Calls" so you can
	// follow along.

	// allocate the sink if its not already allocated.
	if(m_pStubSink == 0)
	{
		CEventSink *pEventSink = 0;
		IUnknown* pStubUnk = 0;

		// create the 'real' sink.
		pEventSink = new CEventSink(m_connectHwnd);
		pEventSink->AddRef();

		// create an unsecapp object.
		CoCreateInstance(CLSID_UnsecuredApartment, NULL, 
						  CLSCTX_LOCAL_SERVER, IID_IUnsecuredApartment, 
						  (void**)&m_pUnsecApp);

		// give the 'real' sink to the unsecapp to manage. Get a 'pStubUnk' in return.
		m_pUnsecApp->CreateObjectStub(pEventSink, &pStubUnk);

		// from that pUnk, get a wrapper to your original sink.
		pStubUnk->QueryInterface(IID_IWbemObjectSink, (void **)&m_pStubSink);
		pStubUnk->Release();

		// release the 'real' sink cuz m_pStubSink "owns" it now.
		long ref = pEventSink->Release();
	}

	HRESULT hRes = S_OK;
	BSTR qLang = SysAllocString(L"WQL");
	BSTR query = SysAllocString(L"select * from __InstanceCreationEvent where TargetInstance isa \"SAMPLE_OfficeEquipment\"");

	// execute the query. For *Async, the last parm is a sink object
	// that will be sent the resultset instead of returning the normal
	// enumerator object.
	if(SUCCEEDED(hRes = service->ExecNotificationQueryAsync(qLang, query,
															0L, NULL,              
															m_pStubSink)))
	{
		OutputDebugString(_T("Executed filter query\n"));
	}
	else
	{
		OutputDebugString(_T("ExecQuery() failed\n"));

	} //endif ExecQuery()

	SysFreeString(qLang);
	SysFreeString(query);
}

void CEquipmentFolder::EmptyChildren(void)
{
	if(m_pResultData)
		HRESULT hr = m_pResultData->DeleteAllRsltItems();

	int last = m_children.GetSize();
    for (int n = 0; n < last; n++)
	{
        if (m_children[n] != NULL)
            delete m_children[n];
	}
	m_children.RemoveAll();
}


bool CEquipmentFolder::EnumChildren(IWbemServices *service)
{
	IEnumWbemClassObject *pEnumEquip = NULL;
	HRESULT hr = S_OK;
	// get the list of equipment...
	if (SUCCEEDED(hr = service->CreateInstanceEnum((bstr_t)L"SAMPLE_OfficeEquipment",
											WBEM_FLAG_SHALLOW, 
											NULL, &pEnumEquip))) 
	{
		// NOTE: pEquip MUST be set to NULL for Next().
		IWbemClassObject *pEquip = NULL;
		CEquipment *pEquipInst = 0;

		ULONG uReturned = 1;
		VARIANT pVal;

		VariantInit(&pVal);

		while((SUCCEEDED(hr = pEnumEquip->Next(-1, 1, &pEquip, &uReturned))) && 
				(uReturned != 0))
		{
			pEquipInst = new CEquipment(this, pEquip);

			m_children.Add(pEquipInst);

			// Done with this object.
			if(pEquip)
			{ 
				pEquip->Release();

				// NOTE: pEquip MUST be reset to NULL for Next().
				pEquip = NULL;
			} 

		} // endwhile

		// Done with this enumerator.
		if (pEnumEquip)
		{ 
			pEnumEquip->Release(); 
			pEnumEquip = NULL;
		}
	} // endif CreateInstanceEnum()
	return SUCCEEDED(hr);
}

HRESULT CEquipmentFolder::GetPtr(IWbemServices **ptr)
{
	HRESULT hr = E_FAIL;
	m_threadCmd = CT_GET_PTR;
	SetEvent(m_doWork);
	WaitForSingleObject(m_ptrReady, 10000);
	
	if(ptr && m_pStream)
	{
		*ptr = 0;
		hr = CoGetInterfaceAndReleaseStream(m_pStream,
											IID_IWbemServices,
											(void**)ptr);
	}
	return hr;
}

DWORD WINAPI CEquipmentFolder::ThreadProc(LPVOID lpParameter)
{
    CEquipmentFolder *pThis = (CEquipmentFolder *)lpParameter;

	HRESULT hr = S_OK;

	CoInitialize(NULL);

	while(true)
	{
		WaitForSingleObject(pThis->m_doWork, -1);

		switch(pThis->m_threadCmd)
		{
		case CT_CONNECT:
			{
				IWbemLocator *pLocator = 0;
				HRESULT hr;

				// Create an instance of the WbemLocator interface.
				hr = CoCreateInstance(CLSID_WbemLocator,
									  NULL, CLSCTX_INPROC_SERVER,
									  IID_IWbemLocator, (LPVOID *)&pLocator);

				if(SUCCEEDED(hr))
				{    
					hr = pLocator->ConnectServer((bstr_t)L"root\\cimv2\\SAMPLE_Office",
													NULL,         // User
													NULL,         // Password
													NULL,         // Locale
													0,            // Security Flags
													NULL,         // Authority
													NULL,         // Context
													&pThis->m_realWMI);  // Namespace

					if (SUCCEEDED(hr) && pThis->m_connectHwnd != NULL)
					{
						hr = CoSetProxyBlanket(pThis->m_realWMI,
										RPC_C_AUTHN_DEFAULT, 
										RPC_C_AUTHZ_DEFAULT, 
										COLE_DEFAULT_PRINCIPAL, 
										RPC_C_AUTHN_LEVEL_DEFAULT, 
										RPC_C_IMP_LEVEL_IMPERSONATE, 
										COLE_DEFAULT_AUTHINFO, 
										EOAC_NONE );

						if (SUCCEEDED(hr))
						{
							// tell the callback the result of the connection.
							PostMessage(pThis->m_connectHwnd, WM_WMI_CONNECTED, hr, 0);
						}
					}
				}
			}
			break;

		case CT_GET_PTR:
			if(pThis->m_realWMI != NULL)
			{
				hr = CoMarshalInterThreadInterfaceInStream(IID_IWbemServices,
															pThis->m_realWMI, 
															&(pThis->m_pStream));
			}

			SetEvent(pThis->m_ptrReady);
			break;

		case CT_EXIT:
			if(pThis->m_realWMI != NULL)
			{
				pThis->m_realWMI->Release();
				pThis->m_realWMI = 0;
			}
			SetEvent(pThis->m_ptrReady);
			return 0;
			break;

		} //endswitch

	} //endwhile(true)

    return 0;
}

HRESULT CEquipmentFolder::DisplayChildren(void)
{
    // insert items here
    RESULTDATAITEM rdi;
	HRESULT hr = S_OK;
	int last = m_children.GetSize();
	CEquipment *pEquip = 0;

	if(m_pResultData)
		HRESULT hr = m_pResultData->DeleteAllRsltItems();

    // create the child nodes, then expand them
    for (int n = 0; n < last; n++) 
	{
		pEquip = (CEquipment *)m_children[n];

        ZeroMemory(&rdi, sizeof(RESULTDATAITEM) );
        rdi.mask       =	RDI_STR       |   // Displayname is valid
							RDI_IMAGE     |	  // nImage is valid
							RDI_PARAM;        

        rdi.nImage      = pEquip->GetBitmapIndex();
        rdi.str         = MMC_CALLBACK;
        rdi.nCol        = 0;
        rdi.lParam      = (LPARAM)pEquip;

        hr = m_pResultData->InsertItem( &rdi );

        _ASSERT( SUCCEEDED(hr) );
    }
	return hr;
}

HRESULT CEquipmentFolder::OnSelect(IConsole *pConsole, BOOL bScope, BOOL bSelect)
{
	m_bSelected = bSelect;
	IConsoleVerb *menu = NULL;
	if(SUCCEEDED(pConsole->QueryConsoleVerb(&menu)))
	{
		menu->SetVerbState(MMC_VERB_REFRESH, ENABLED, TRUE);
		menu->SetVerbState(MMC_VERB_REFRESH, HIDDEN, FALSE);
		menu->Release();
	}
	return S_OK;
}

HRESULT CEquipmentFolder::OnRefresh(LPDATAOBJECT lpDataObject)
{
	IWbemServices *service = 0;
	HRESULT hr = GetPtr(&service);
	if(SUCCEEDED(hr))
	{
		EmptyChildren();
		EnumChildren(service);
		DisplayChildren();
		// done with the marshalled service ptr.
		service->Release();
		service = 0;
	}

	return S_OK;
}

HRESULT CEquipmentFolder::OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem)
{
    HRESULT      hr = S_OK;

    IHeaderCtrl *pHeaderCtrl = NULL;

    if (bShow) 
	{
        hr = pConsole->QueryInterface(IID_IHeaderCtrl, (void **)&pHeaderCtrl);
        _ASSERT( SUCCEEDED(hr) );

        hr = pConsole->QueryInterface(IID_IResultData, (void **)&m_pResultData);
        _ASSERT( SUCCEEDED(hr) );

        // Set the column headers in the results pane
        hr = pHeaderCtrl->InsertColumn(0, L"SKU", LVCFMT_LEFT, 150);
        _ASSERT( S_OK == hr );

        hr = pHeaderCtrl->InsertColumn(1, L"Item", LVCFMT_LEFT, 200);
        _ASSERT( S_OK == hr );

        hr = m_pResultData->DeleteAllRsltItems();
        _ASSERT( SUCCEEDED(hr) );

        if(!bExpanded) 
		{
			hr = DisplayChildren();
        }

        pHeaderCtrl->Release();
    }

    return hr;
}

//----------------------------------------------------------
#define TEMP_BUF 255

bool CEquipmentFolder::ErrorString(HRESULT hr, 
								   TCHAR *errMsg, UINT errSize)
{
    TCHAR szError[TEMP_BUF] = {0};
	TCHAR szFacility[TEMP_BUF] = {0};
	IWbemStatusCodeText * pStatus = NULL;

    // initialize buffers.
	memset(errMsg, 0, errSize * sizeof(TCHAR));

	HRESULT hr1 = CoInitialize(NULL);
	SCODE sc1 = CoCreateInstance(CLSID_WbemStatusCodeText, 
								0, CLSCTX_INPROC_SERVER,
								IID_IWbemStatusCodeText, 
								(LPVOID *) &pStatus);

	// loaded OK?
	if(sc1 == S_OK)
	{
		BSTR bstr;
		sc1 = pStatus->GetErrorCodeText(hr, 0, 0, &bstr);
		if(sc1 == S_OK)
		{
			wcstombs(szError, bstr, TEMP_BUF-1);
			SysFreeString(bstr);
			bstr = 0;
		}

		sc1 = pStatus->GetFacilityCodeText(hr, 0, 0, &bstr);
		if(sc1 == S_OK)
		{
			wcstombs(szFacility, bstr, TEMP_BUF-1);
			SysFreeString(bstr);
			bstr = 0;
		}

		// RELEASE
		pStatus->Release();
		pStatus = NULL;
	}
	else
	{
		::MessageBox(NULL, _T("WBEM error features not available. Upgrade WMI to a newer build."),
					 _T("Internal Error"), MB_ICONSTOP|MB_OK);
	}

	// if not msgs returned....
	if(_tcslen(szFacility) == 0 || _tcslen(szError) == 0)
	{
		// format the error nbr as a reasonable default.
		_stprintf(errMsg, _T("Error code: 0x%08X"), hr);
	}
	else
	{
		// format a readable msg.
		_stprintf(errMsg, _T("%s: %s"), szFacility, szError);
	}

	if(hr1 == S_OK)
		CoUninitialize();

	return (SUCCEEDED(sc1) && SUCCEEDED(hr1));
}


//========================================
CEquipment::CEquipment(CEquipmentFolder *parent, IWbemClassObject *inst) :
						m_parent(parent),
						m_inst(inst)
{
	if(m_inst)
		m_inst->AddRef();
}

// helper values for calling GetDisplayName().
#define SKU_COL 0
#define ITEM_COL 1

const _TCHAR *CEquipment::GetDisplayName(int nCol)
{
    static _TCHAR buf[128];

	// Get the corresponding property for nCol. This is in-proc local copy 
	//	  so its pretty fast even if IWbemServices is a remote connection.
	if(m_inst)
	{
		VARIANT pVal;
		WCHAR propName[10] = {0};

		VariantInit(&pVal);

		switch(nCol) 
		{
		case 0:
			wcscpy(propName, L"SKU");
			break;

		case 1:
			wcscpy(propName, L"Item");
			break;

		} //endswitch

		if(m_inst->Get(propName, 0L, &pVal, NULL, NULL) == S_OK) 
		{
			bstr_t temp(pVal);
			_tcscpy(buf, (LPTSTR)temp);
		} 

		VariantClear(&pVal);
	} //endif (m_inst)

    return buf;
}


HRESULT CEquipment::PutProperty(LPWSTR propName, LPTSTR str)
{
	HRESULT hr = E_FAIL;
	if(m_inst)
	{
		VARIANT pVal;
		bstr_t temp(str);

		VariantInit(&pVal);
		V_BSTR(&pVal) = temp;
		V_VT(&pVal) = VT_BSTR;

		hr = m_inst->Put(propName, 0L, &pVal, 0); 

		VariantClear(&pVal);
	} //endif (m_inst)

    return hr;
}


// handle anything special when the user clicks Apply or Ok
// on the property sheet.  This sample directly accesses the
// operated-on object, so there's nothing special do to...
HRESULT CEquipment::OnPropertyChange()
{
    return S_OK;
}

HRESULT CEquipment::OnSelect(IConsole *pConsole, BOOL bScope, BOOL bSelect)
{
    IConsoleVerb *pConsoleVerb;

    HRESULT hr = pConsole->QueryConsoleVerb(&pConsoleVerb);
    _ASSERT(SUCCEEDED(hr));

    // can't get to properties (via the standard methods) unless
    // we tell MMC to display the Properties menu item and
    // toolbar button, this wil give the user a visual cue that
    // there's "something" to do
    hr = pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, TRUE);

    pConsoleVerb->Release();

    return S_OK;
}

// Implement the dialog proc
INT_PTR CALLBACK CEquipment::DialogProc(
                                  HWND hwndDlg,  // handle to dialog box
                                  UINT uMsg,     // message
                                  WPARAM wParam, // first message parameter
                                  LPARAM lParam  // second message parameter
                                  )
{
    static CEquipment *pEquip = NULL;

    switch (uMsg) 
	{
    case WM_INITDIALOG:
		{
			// catch the "this" pointer so we can actually operate on the object
			pEquip = reinterpret_cast<CEquipment *>(reinterpret_cast<PROPSHEETPAGE *>(lParam)->lParam);

			SetDlgItemText(hwndDlg, IDC_PEOPLE_NAME, pEquip->GetDisplayName(SKU_COL));
			SetDlgItemText(hwndDlg, IDC_PEOPLE_COLOR, pEquip->GetDisplayName(ITEM_COL));
		}
        break;

    case WM_COMMAND:
        // turn the Apply button on
        if (HIWORD(wParam) == EN_CHANGE ||
            HIWORD(wParam) == CBN_SELCHANGE)
            SendMessage(GetParent(hwndDlg), PSM_CHANGED, (WPARAM)hwndDlg, 0);
        break;

    case WM_DESTROY:
        // tell MMC that we're done with the property sheet (we got this
        // handle in CreatePropertyPages
        MMCFreeNotifyHandle(pEquip->m_ppHandle);
        break;

    case WM_NOTIFY:
        
		switch(((NMHDR *)lParam)->code) 
		{
        case PSN_APPLY:
			{
				bool changed = false;
				TCHAR temp[50] = {0};
				HRESULT hr = S_OK;

				HWND hWnd = GetDlgItem(hwndDlg, IDC_PEOPLE_NAME);
				if(hWnd && Edit_GetModify(hWnd))
				{
					GetWindowText(hWnd, temp, 50);
					changed |= SUCCEEDED(pEquip->PutProperty(L"SKU", temp));
				}

				hWnd = GetDlgItem(hwndDlg, IDC_PEOPLE_COLOR);
				if(hWnd && Edit_GetModify(hWnd))
				{
					GetWindowText(hWnd, temp, 50);
					changed |= SUCCEEDED(pEquip->PutProperty(L"Item", temp));
				}

				// if any property changed, write it back to WMI.
				if(changed)
				{
					IWbemServices *service = 0;
					// dialogs run in their own thread so use the marshalling helper
					// get a useable IWbemServices ptr.
					// NOTE: IWbemClassObjects are in-proc so they DONT need to be
					// marshalled.
					if(SUCCEEDED(pEquip->m_parent->GetPtr(&service)))
					{
						service->PutInstance(pEquip->m_inst, WBEM_FLAG_CREATE_OR_UPDATE, 0, 0);
						service->Release();
			            HRESULT hr = MMCPropertyChangeNotify(pEquip->m_ppHandle, (long)pEquip);
					}
				}
			}
			break;
        } // endswitch (((NMHDR *)lParam)->code) 

        break;

    } // endswitch (uMsg) 

    return DefWindowProc(hwndDlg, uMsg, wParam, lParam);
}


HRESULT CEquipment::HasPropertySheets()
{
    // say "yes" when MMC asks if we have pages
    return S_OK;
}

HRESULT CEquipment::CreatePropertyPages(IPropertySheetCallback *lpProvider, LONG_PTR handle)
{
    PROPSHEETPAGE psp;
    HPROPSHEETPAGE hPage = NULL;

    // cache this handle so we can call MMCPropertyChangeNotify
    m_ppHandle = handle;

    // create the property page for this node.
    // NOTE: if your node has multiple pages, put the following
    // in a loop and create multiple pages calling
    // lpProvider->AddPage() for each page.
    psp.dwSize = sizeof(PROPSHEETPAGE);
    psp.dwFlags = PSP_DEFAULT | PSP_USETITLE | PSP_HASHELP;
    psp.hInstance = g_hinst;
    psp.pszTemplate = MAKEINTRESOURCE(IDD_EQUIPMENT);
    psp.pfnDlgProc = DialogProc;
    psp.lParam = reinterpret_cast<LPARAM>(this);
    psp.pszTitle = MAKEINTRESOURCE(IDS_EQUIPMENT_TITLE);


    hPage = CreatePropertySheetPage(&psp);
    _ASSERT(hPage);

    return lpProvider->AddPage(hPage);
}

HRESULT CEquipment::GetWatermarks(HBITMAP *lphWatermark,
								   HBITMAP *lphHeader,
								   HPALETTE *lphPalette,
								   BOOL *bStretch)
{
    return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\snapin\guids.h ===
//==============================================================;

//

//	This source code is only intended as a supplement to existing Microsoft documentation. 

//

//	Use of this code is NOT supported.  

//

//

//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY

//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE

//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR

//  PURPOSE.

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved 
//
//    Microsoft Premier Support for Developers
//
//==============================================================;

// {6BB32803-92E6-11d2-9967-0080C7DCB3DC}
DEFINE_GUID(CLSID_CComponentData, 
            0x6bb32803, 0x92e6, 0x11d2, 0x99, 0x67, 0x0, 0x80, 0xc7, 0xdc, 0xb3, 0xdc);

// {73A37F61-92E6-11d2-9967-0080C7DCB3DC}
DEFINE_GUID(CLSID_CSnapinAbout, 
            0x73a37f61, 0x92e6, 0x11d2, 0x99, 0x67, 0x0, 0x80, 0xc7, 0xdc, 0xb3, 0xdc);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\snapin\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Resource.rc
//
#define IDS_HELPFILE                    1
#define IDS_SNAPINDESC                  2
#define IDS_NAME                        3
#define IDS_SNAPINNAME                  6
#define IDS_ABOUTNAME                   9
#define IDS_EQUIPMENT_TITLE             12
#define IDI_ICON1                       108
#define IDD_EQUIPMENT                   108
#define IDB_SMOPEN                      111
#define IDB_SMBMP                       112
#define IDB_LGBMP                       113
#define IDR_SMICONS                     120
#define IDR_LGICONS                     121
#define IDC_PEOPLE_NAME                 1008
#define IDC_PEOPLE_COLOR                1009
#define IDC_PEOPLE_MATERIAL             1010
#define IDC_PEOPLE_OWNER                1011
#define IDC_PEOPLE_SURFACE              1012
#define IDC_GIRLS                       1013
#define IDC_PEOPLE_GIRLS                1013

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        116
#define _APS_NEXT_COMMAND_VALUE         40016
#define _APS_NEXT_CONTROL_VALUE         1014
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\snapin\registry.cpp ===
//==============================================================;

//

//      This source code is only intended as a supplement to existing Microsoft documentation.

//

//      Use of this code is NOT supported.

//

//

//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY

//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE

//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR

//  PURPOSE.

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved 
//
//    Microsoft Premier Support for Developers
//
//==============================================================;

#include <objbase.h>
#include <assert.h>

#include "Registry.h"

#define STRINGS_ONLY
#include "globals.h"

////////////////////////////////////////////////////////
//
// Internal helper functions prototypes
//

// Set the given key and its value.
BOOL setKeyAndValue(const _TCHAR* pszPath,
                    const _TCHAR* szSubkey,
                    const _TCHAR* szValue) ;

// Set the given key and its value in the MMC Snapin location
BOOL setSnapInKeyAndValue(const _TCHAR* szKey,
                          const _TCHAR* szSubkey,
                          const _TCHAR* szName,
                          const _TCHAR* szValue);

// Set the given valuename under the key to value
BOOL setValue(const _TCHAR* szKey,
              const _TCHAR* szValueName,
              const _TCHAR* szValue);

// Delete szKeyChild and all of its descendents.
LONG recursiveDeleteKey(HKEY hKeyParent, const _TCHAR* szKeyChild) ;

////////////////////////////////////////////////////////
//
// Constants
//

// Size of a CLSID as a string
//const int CLSID_STRING_SIZE = 39 ;

/////////////////////////////////////////////////////////
//
// Public function implementation
//

//
// Register the component in the registry.
//
HRESULT RegisterServer(HMODULE hModule,            // DLL module handle
                       const CLSID& clsid,         // Class ID
                       const _TCHAR* szFriendlyName)       //   IDs
{
    // Get server location.
    _TCHAR szModule[512] ;
    DWORD dwResult =
        ::GetModuleFileName(hModule,
        szModule,
        sizeof(szModule)/sizeof(_TCHAR)) ;

    assert(dwResult != 0) ;

    // Get CLSID
    LPOLESTR wszCLSID = NULL ;
    HRESULT hr = StringFromCLSID(clsid, &wszCLSID) ;

    assert(SUCCEEDED(hr)) ;

        MAKE_TSTRPTR_FROMWIDE(pszCLSID, wszCLSID);

    // Build the key CLSID\\{...}
    _TCHAR szKey[64] ;
    _tcscpy(szKey, _T("CLSID\\")) ;
        _tcscat(szKey, pszCLSID) ;

    // Add the CLSID to the registry.
    setKeyAndValue(szKey, NULL, szFriendlyName) ;

    // Add the server filename subkey under the CLSID key.
    setKeyAndValue(szKey, _T("InprocServer32"), szModule) ;

    // set the threading model
    _tcscat(szKey, _T("\\InprocServer32"));
    setValue(szKey, _T("ThreadingModel"), _T("Apartment"));

    // Free memory.
    CoTaskMemFree(wszCLSID) ;

    return S_OK ;
}

//
// Remove the component from the registry.
//
LONG UnregisterServer(const CLSID& clsid)       //   IDs
{
    // Get CLSID
    LPOLESTR wszCLSID = NULL ;
    HRESULT hr = StringFromCLSID(clsid, &wszCLSID) ;


    // Build the key CLSID\\{...}
    _TCHAR szKey[64] ;
    _tcscpy(szKey, _T("CLSID\\")) ;

        MAKE_TSTRPTR_FROMWIDE(pszT, wszCLSID);
        _tcscat(szKey, pszT) ;

    // Delete the CLSID Key - CLSID\{...}
    LONG lResult = recursiveDeleteKey(HKEY_CLASSES_ROOT, szKey) ;
    assert((lResult == ERROR_SUCCESS) ||
               (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.

    // Free memory.
    CoTaskMemFree(wszCLSID) ;

    return S_OK ;
}

//
// Register the snap-in in the registry.
//
HRESULT RegisterSnapin(const CLSID& clsid,         // Class ID
                       const _TCHAR* szNameString,   // NameString
                       const CLSID& clsidAbout,         // Class Id for About Class
                       const BOOL fSupportExtensions)
{
    // Get CLSID
    LPOLESTR wszCLSID = NULL ;
    LPOLESTR wszAboutCLSID = NULL;
    HRESULT hr = StringFromCLSID(clsid, &wszCLSID) ;

    if (IID_NULL != clsidAbout)
        hr = StringFromCLSID(clsidAbout, &wszAboutCLSID);

        MAKE_TSTRPTR_FROMWIDE(pszCLSID, wszCLSID);
        MAKE_TSTRPTR_FROMWIDE(pszAboutCLSID, wszAboutCLSID);


    // Add the CLSID to the registry.
    setSnapInKeyAndValue(pszCLSID, NULL, _T("NameString"), szNameString) ;
    setSnapInKeyAndValue(pszCLSID, _T("StandAlone"), NULL, NULL);
    if (IID_NULL != clsidAbout)
        setSnapInKeyAndValue(pszCLSID, NULL, _T("About"), pszAboutCLSID);

    if (fSupportExtensions) {
        // Build the key NodeType
        setSnapInKeyAndValue(pszCLSID, _T("NodeTypes"), NULL, NULL);

        _TCHAR szKey[64] ;
        _tcscpy(szKey, pszCLSID) ;
        _tcscat(szKey, _T("\\NodeTypes")) ;
        setSnapInKeyAndValue(szKey, pszCLSID, NULL, NULL);
    }

    // Free memory.
    CoTaskMemFree(wszCLSID) ;
    if (IID_NULL != clsidAbout)
        CoTaskMemFree(wszAboutCLSID);

    return S_OK ;
}

//
// Unregister the snap-in in the registry.
//
HRESULT UnregisterSnapin(const CLSID& clsid)         // Class ID
{
    _TCHAR szKeyBuf[1024];
    LPOLESTR wszCLSID = NULL;

    // Get CLSID
    HRESULT hr = StringFromCLSID(clsid, &wszCLSID);
        MAKE_TSTRPTR_FROMWIDE(pszCLSID, wszCLSID);

    // Load the buffer with the Snap-In Location
    _tcscpy(szKeyBuf, _T("SOFTWARE\\Microsoft\\MMC\\SnapIns"));

    // Copy keyname into buffer.
    _tcscat(szKeyBuf, _T("\\"));
    _tcscat(szKeyBuf, pszCLSID);

    // Delete the CLSID Key - CLSID\{...}
    LONG lResult = recursiveDeleteKey(HKEY_LOCAL_MACHINE, szKeyBuf);
    assert((lResult == ERROR_SUCCESS) ||
               (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.

    // free the memory
    CoTaskMemFree(wszCLSID);

    return S_OK;
}

//
// Delete a key and all of its descendents.
//
LONG recursiveDeleteKey(HKEY hKeyParent,           // Parent of key to delete
                        const _TCHAR* lpszKeyChild)  // Key to delete
{
    // Open the child.
    HKEY hKeyChild ;
    LONG lRes = RegOpenKeyEx(hKeyParent, lpszKeyChild, 0,
        KEY_ALL_ACCESS, &hKeyChild) ;
    if (lRes != ERROR_SUCCESS)
    {
        return lRes ;
    }

    // Enumerate all of the decendents of this child.
    FILETIME time ;
    _TCHAR szBuffer[256] ;
    DWORD dwSize = 256 ;
    while (RegEnumKeyEx(hKeyChild, 0, szBuffer, &dwSize, NULL,
        NULL, NULL, &time) == S_OK)
    {
        // Delete the decendents of this child.
        lRes = recursiveDeleteKey(hKeyChild, szBuffer) ;
        if (lRes != ERROR_SUCCESS)
        {
            // Cleanup before exiting.
            RegCloseKey(hKeyChild) ;
            return lRes;
        }
        dwSize = 256 ;
    }

    // Close the child.
    RegCloseKey(hKeyChild) ;

    // Delete this child.
    return RegDeleteKey(hKeyParent, lpszKeyChild) ;
}

//
// Create a key and set its value.
//   - This helper function was borrowed and modifed from
//     Kraig Brockschmidt's book Inside OLE.
//
BOOL setKeyAndValue(const _TCHAR* szKey,
                    const _TCHAR* szSubkey,
                    const _TCHAR* szValue)
{
    HKEY hKey;
    _TCHAR szKeyBuf[1024] ;

    // Copy keyname into buffer.
    _tcscpy(szKeyBuf, szKey) ;

    // Add subkey name to buffer.
    if (szSubkey != NULL)
    {
        _tcscat(szKeyBuf, _T("\\")) ;
        _tcscat(szKeyBuf, szSubkey ) ;
    }

    // Create and open key and subkey.
    long lResult = RegCreateKeyEx(HKEY_CLASSES_ROOT ,
        szKeyBuf,
        0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, NULL,
        &hKey, NULL) ;
    if (lResult != ERROR_SUCCESS)
    {
        return FALSE ;
    }

    // Set the Value.
    if (szValue != NULL)
    {
        RegSetValueEx(hKey, NULL, 0, REG_SZ,
            (BYTE *)szValue,
            (DWORD)(_tcslen(szValue)+1)*sizeof(_TCHAR)) ;
    }

    RegCloseKey(hKey) ;
    return TRUE ;
}

//
// Open a key value and set it
//
BOOL setValue(const _TCHAR* szKey,
              const _TCHAR* szValueName,
              const _TCHAR* szValue)
{
    HKEY hKey;
    _TCHAR szKeyBuf[1024] ;

    // Copy keyname into buffer.
    _tcscpy(szKeyBuf, szKey) ;

    // Create and open key and subkey.
    long lResult = RegCreateKeyEx(HKEY_CLASSES_ROOT ,
        szKeyBuf,
        0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, NULL,
        &hKey, NULL) ;
    if (lResult != ERROR_SUCCESS)
    {
        return FALSE ;
    }

    // Set the Value.
    if (szValue != NULL)
    {
        RegSetValueEx(hKey, szValueName, 0, REG_SZ,
            (BYTE *)szValue,
            (DWORD)(_tcslen(szValue)+1)*sizeof(_TCHAR)) ;
    }

    RegCloseKey(hKey) ;
    return TRUE ;
}

//
// Create a key and set its value.
//   - This helper function was borrowed and modifed from
//     Kraig Brockschmidt's book Inside OLE.
//
BOOL setSnapInKeyAndValue(const _TCHAR* szKey,
                          const _TCHAR* szSubkey,
                          const _TCHAR* szName,
                          const _TCHAR* szValue)
{
    HKEY hKey;
    _TCHAR szKeyBuf[1024] ;

    // Load the buffer with the Snap-In Location
    _tcscpy(szKeyBuf, _T("SOFTWARE\\Microsoft\\MMC\\SnapIns"));

    // Copy keyname into buffer.
    _tcscat(szKeyBuf, _T("\\")) ;
    _tcscat(szKeyBuf, szKey) ;

    // Add subkey name to buffer.
    if (szSubkey != NULL)
    {
        _tcscat(szKeyBuf, _T("\\")) ;
        _tcscat(szKeyBuf, szSubkey ) ;
    }

    // Create and open key and subkey.
    long lResult = RegCreateKeyEx(HKEY_LOCAL_MACHINE ,
        szKeyBuf,
        0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, NULL,
        &hKey, NULL) ;
    if (lResult != ERROR_SUCCESS)
    {
        return FALSE ;
    }

    // Set the Value.
    if (szValue != NULL)
    {
        RegSetValueEx(hKey, szName, 0, REG_SZ,
            (BYTE *)szValue,
            (DWORD)(_tcslen(szValue)+1)*sizeof(_TCHAR)) ;
    }

    RegCloseKey(hKey) ;
    return TRUE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\snapin\mmccrack.cpp ===
//==============================================================;

//

//      This source code is only intended as a supplement to existing Microsoft documentation.

//

//      Use of this code is NOT supported.

//

//

//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY

//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE

//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR

//  PURPOSE.

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved 
//
//    Microsoft Premier Support for Developers
//
//==============================================================;

#include <mmc.h>
#include <winuser.h>
#include <tchar.h>

#include "globals.h"

static TCHAR *MMCN_CrackVerb(MMC_CONSOLE_VERB verb)
{
        static TCHAR error[64];

        switch (verb) {
    case MMC_VERB_NONE:
                return _T("NONE");
    case MMC_VERB_OPEN:
                return _T("OPEN");
    case MMC_VERB_COPY:
                return _T("COPY");
    case MMC_VERB_PASTE:
                return _T("PASTE");
    case MMC_VERB_DELETE:
                return _T("DELETE");
    case MMC_VERB_PROPERTIES:
                return _T("PROPERTIES");
    case MMC_VERB_RENAME:
                return _T("RENAME");
    case MMC_VERB_REFRESH:
                return _T("REFRESH");
    case MMC_VERB_PRINT:
                return _T("PRINT");
    case MMC_VERB_CUT:
                return _T("CUT");
        default:
                wsprintf(error, _T("Unknown verb id %d"), verb);
                return error;
        }
}

void MMCN_Crack(BOOL bComponentData,
                IDataObject *pDataObject,
                                IComponentData *pCompData,
                                IComponent *pComp,
                MMC_NOTIFY_TYPE event,
                                LPARAM arg,
                                LPARAM param)
{
#ifdef MMC_CRACK_MESSAGES
        TCHAR message[256] = {0};

        if (bComponentData == TRUE)
                OutputDebugString(_T("IComponentData::Notify( "));
        else
                OutputDebugString(_T("IComponent::Notify( "));

        wsprintf(message, _T("DataObject: %08x, CompData: %08x, Comp: %08x ) - "), pDataObject, pCompData, pComp);
        OutputDebugString(message);

    switch (event)      {
                case MMCN_ACTIVATE:
                        wsprintf(message, _T("MMCN_ACTIVATE\n\tActivate: %d\n"), arg);
                        break;

                case MMCN_ADD_IMAGES:
                        wsprintf(message, _T("MMCN_ADD_IMAGES\n\tImage List: %08x\n\tScope Item: %08x\n"), arg, param);
                        break;

                case MMCN_BTN_CLICK:
                        wsprintf(message, _T("MMCN_BTN_CLICK\n\tVerb: %ws\n"), MMCN_CrackVerb((MMC_CONSOLE_VERB)param));
                        break;

                case MMCN_COLUMN_CLICK:
                        wsprintf(message, _T("MMCN_COLUMN_CLICK\n\tColumn: %d\n\tSort Option: %d\n"), arg,       param);
                        break;

                case MMCN_COLUMNS_CHANGED:
                        wsprintf(message, _T("MMCN_COLUMNS_CHANGED\n"));
                        break;

                case MMCN_CONTEXTHELP:
                        wsprintf(message, _T("MMCN_CONTEXTHELP\n"));
                        break;

                case MMCN_CONTEXTMENU:
                        wsprintf(message, _T("MMCN_CONTEXTMENU\n"));
                        break;

                case MMCN_CUTORMOVE:
                        wsprintf(message, _T("MMCN_CUTORMOVE\n"));
                        break;

                case MMCN_DBLCLICK:
                        wsprintf(message, _T("MMCN_DBLCLICK\n"));
                        break;

                case MMCN_DELETE:
                        wsprintf(message, _T("MMCN_DELETE\n"));
                        break;

                case MMCN_DESELECT_ALL:
                        wsprintf(message, _T("MMCN_DESELECT_ALL\n"));
                        break;

                case MMCN_EXPAND:
                        wsprintf(message, _T("MMCN_EXPAND\n\tExpand: %d\n\tScope Item: %08x\n"), arg, param);
                        break;

                case MMCN_EXPANDSYNC:
                        wsprintf(message, _T("MMCN_EXPANDSYNC\n"));
                        break;

                case MMCN_FILTERBTN_CLICK:
                        wsprintf(message, _T("MMCN_FILTERBTN_CLICK\n\tColumn: %d\n"), arg);
                        break;

                case MMCN_FILTER_CHANGE:
                        wsprintf(message, _T("MMCN_FILTER_CHANGE\n\tColumn: %d\n"), param);
                        break;

                case MMCN_HELP:
                        wsprintf(message, _T("MMCN_HELP\n"));
                        break;

                case MMCN_INITOCX:
                        wsprintf(message, _T("MMCN_INITOCX\n\tIUnknown: %08x\n"), param);
                        break;

                case MMCN_LISTPAD:
                        wsprintf(message, _T("MMCN_LISTPAD\n\tConnect: %d\n"), arg);
                        break;

                case MMCN_MENU_BTNCLICK:
                        wsprintf(message, _T("MMCN_MENU_BTNCLICK\n"));
                        break;

                case MMCN_MINIMIZED:
                        wsprintf(message, _T("MMCN_MINIMIZED\n\tMinimized: %d\n"), arg);
                        break;

                case MMCN_PASTE:
                        wsprintf(message, _T("MMCN_PASTE\n\tCopy: %d\n"), param == NULL);
                        break;

                case MMCN_PRELOAD:
                        wsprintf(message, _T("MMCN_PRELOAD\n\tScope Item: %08x\n"), arg);
                        break;

                case MMCN_PRINT:
                        wsprintf(message, _T("MMCN_PRINT\n"));
                        break;

                case MMCN_PROPERTY_CHANGE:
                        wsprintf(message, _T("MMCN_PROPERTY_CHANGE\n\tScope: %d\n\tArg: %08x\n"), arg, param);
                        break;

                case MMCN_QUERY_PASTE:
                        wsprintf(message, _T("MMCN_QUERY_PASTE\n"));
                        break;

                case MMCN_REFRESH:
                        wsprintf(message, _T("MMCN_REFRESH\n"));
                        break;

                case MMCN_REMOVE_CHILDREN:
                        wsprintf(message, _T("MMCN_REMOVE_CHILDREN\n\tScope Item: %08x\n"), arg);
                        break;

                case MMCN_RENAME:
                        wsprintf(message, _T("MMCN_RENAME\n\tNew Name: '%ws'\n"), (LPOLESTR)param);
                        break;

                case MMCN_RESTORE_VIEW:
                        wsprintf(message, _T("MMCN_RESTORE_VIEW\n"));
                        break;

                case MMCN_SELECT:
                        wsprintf(message, _T("MMCN_SELECT\n\tScope: %d\n\tSelect: %08x\n"), LOWORD(arg), HIWORD(arg));
                        break;

                case MMCN_SHOW:
                        wsprintf(message, _T("MMCN_SHOW\n\tShow: %d\n\tScope Item: %08x\n"), arg, param);
                        break;

                case MMCN_SNAPINHELP:
                        wsprintf(message, _T("MMCN_SNAPINHELP\n"));
                        break;

                case MMCN_VIEW_CHANGE:
                        wsprintf(message, _T("MMCN_VIEW_CHANGE\n\tData: %08x\n\tHint: %08x\n"), arg, param);
                        break;
        }

        if (message[0] != 0)
                OutputDebugString(message);
        else
                OutputDebugString(_T("unknown event\n"));

#endif
        return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\tempconsumer\makefile.inc ===
$(O)\makefile : makefile.nm
	copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\snapin\simplearray.h ===
//==============================================================;

//

//      This source code is only intended as a supplement to existing Microsoft documentation.

//

//      Use of this code is NOT supported.

//

//

//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY

//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE

//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR

//  PURPOSE.

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved 
//
//    Microsoft Premier Support for Developers
//
//==============================================================;

#if (_ATL_VER < 0x0300)
/////////////////////////////////////////////////////////////////////////////
// Collection helpers - CSimpleArray & CSimpleMap

template <class T>
class CSimpleArray
{
public:
	T* m_aT;
	int m_nSize;
	int m_nAllocSize;

// Construction/destruction
	CSimpleArray() : m_aT(NULL), m_nSize(0), m_nAllocSize(0)
	{ }

	~CSimpleArray()
	{
		RemoveAll();
	}

// Operations
	int GetSize() const
	{
		return m_nSize;
	}
	BOOL Add(T& t)
	{
		if(m_nSize == m_nAllocSize)
		{
			T* aT;
			int nNewAllocSize = (m_nAllocSize == 0) ? 1 : (m_nSize * 2);
			aT = (T*)realloc(m_aT, nNewAllocSize * sizeof(T));
			if(aT == NULL)
				return FALSE;
			m_nAllocSize = nNewAllocSize;
			m_aT = aT;
		}
		m_nSize++;
		SetAtIndex(m_nSize - 1, t);
		return TRUE;
	}
	BOOL Remove(T& t)
	{
		int nIndex = Find(t);
		if(nIndex == -1)
			return FALSE;
		return RemoveAt(nIndex);
	}
	BOOL RemoveAt(int nIndex)
	{
		if(nIndex != (m_nSize - 1))
			memmove((void*)&m_aT[nIndex], (void*)&m_aT[nIndex + 1], (m_nSize - (nIndex + 1)) * sizeof(T));
		m_nSize--;
		return TRUE;
	}
	void RemoveAll()
	{
		if(m_aT != NULL)
		{
			free(m_aT);
			m_aT = NULL;
		}
		m_nSize = 0;
		m_nAllocSize = 0;
	}
	T& operator[] (int nIndex) const
	{
		_ASSERT(nIndex >= 0 && nIndex < m_nSize);
		return m_aT[nIndex];
	}
	T* GetData() const
	{
		return m_aT;
	}

// Implementation
	void SetAtIndex(int nIndex, T& t)
	{
		_ASSERT(nIndex >= 0 && nIndex < m_nSize);
		m_aT[nIndex] = t;
	}
	int Find(T& t) const
	{
		for(int i = 0; i < m_nSize; i++)
		{
			if(m_aT[i] == t)
				return i;
		}
		return -1;	// not found
	}
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\tempconsumer\oahelp.inl ===
// **************************************************************************
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:  OAHELP.INL
//
// Description:  OLE Automation Helpers for client code
//
// History:
//
// **************************************************************************

#ifndef _OAHELP_INL_
#define _OAHELP_INL_

class CBSTR
{
    BSTR m_pStr;
public:
    CBSTR() { m_pStr = 0; }
    CBSTR(LPWSTR pSrc) { m_pStr = SysAllocString(pSrc); }
   ~CBSTR() { if (m_pStr) SysFreeString(m_pStr); }
    operator BSTR() { return m_pStr; }

    void Unbind() { m_pStr = 0; }
};

class CVARIANT
{
    VARIANT v;
public:
    CVARIANT() { VariantInit(&v); }
   ~CVARIANT() { VariantClear(&v); }
    void Clear()  { VariantClear(&v); }

    operator VARIANT *() { return &v; }
    VARIANT *operator &() { return &v; }

    CVARIANT(LPWSTR pSrc)   { VariantInit(&v); SetStr(pSrc); }
    CVARIANT(LONG lSrc)     { VariantInit(&v); SetLONG(lSrc); }
    CVARIANT(BOOL b)        { VariantInit(&v); SetBool(b); }
    CVARIANT(short i)       { VariantInit(&v); SetShort(i); }
    CVARIANT(double d)      { VariantInit(&v); SetDouble(d); }
    CVARIANT(BYTE b)        { VariantInit(&v); SetByte(b); }
    CVARIANT(IDispatch * pDisp) { VariantInit(&v); pDisp->AddRef(); SetDispatch(pDisp); }

    void   SetStr(LPWSTR pSrc)
    { Clear(); V_VT(&v) = pSrc ? VT_BSTR : VT_NULL; 
      V_BSTR(&v) = pSrc ? SysAllocString(pSrc) : 0; 
    }

    LPWSTR GetStr() { return V_VT(&v) == VT_BSTR ? V_BSTR(&v) : 0; }
    operator LPWSTR() { return V_VT(&v) == VT_BSTR ? V_BSTR(&v) : 0; }

    void SetLONG(LONG lSrc) { Clear(); V_VT(&v) = VT_I4; V_I4(&v) = lSrc; }
    LONG GetLONG() { return V_I4(&v); }
    operator LONG() { return V_I4(&v);  }

    void SetDouble(double dSrc) { Clear(); V_VT(&v) = VT_R8; V_R8(&v) = dSrc; }
    double GetDouble() { return V_R8(&v); }
    operator double() { return V_R8(&v);  }

    void SetByte(BYTE bySrc) { Clear(); V_VT(&v) = VT_UI1; V_UI1(&v) = bySrc; }
    BYTE GetByte() { return V_UI1(&v); }
    operator BYTE() { return V_UI1(&v);  }

    void SetBool(BOOL b) { V_VT(&v) = VT_BOOL; V_BOOL(&v) = b ? VARIANT_TRUE : VARIANT_FALSE; }
    BOOL GetBool() { return V_BOOL(&v) == VARIANT_TRUE; }
    operator BOOL() { return V_BOOL(&v); }

    void SetDispatch(IDispatch* pDisp) { V_VT(&v) = VT_DISPATCH; V_DISPATCH(&v) = pDisp; }
    IDispatch * GetDispatch() { return V_DISPATCH(&v); }

    void SetUnknown(IUnknown* pUnk) { V_VT(&v) = VT_UNKNOWN; V_UNKNOWN(&v) = pUnk; }
    IUnknown * GetUnknown() { return V_UNKNOWN(&v); }

    void SetShort(short i) { V_VT(&v) = VT_I2; V_I2(&v) = i; }
    short GetShort() { return V_I2(&v); }
    operator short() { return V_I2(&v); }

    VARTYPE GetType() { return V_VT(&v); }

    void SetArray(SAFEARRAY *p, VARTYPE vt) { Clear(); V_VT(&v) = vt; V_ARRAY(&v) = p; }
        // This function acquires the SAFEARRAY pointer and it is no longer owned
        // by the caller.

    operator SAFEARRAY *() { return (V_VT(&v) & VT_ARRAY ? V_ARRAY(&v) : 0); }

    void Unbind() { VariantInit(&v); }
};

class CSAFEARRAY
{
    SAFEARRAY *p;
public:
    CSAFEARRAY(VARTYPE v, int nSize) 
    {
        SAFEARRAYBOUND rgsabound[1];
    	rgsabound[0].lLbound = 0;
    	rgsabound[0].cElements = nSize;
        p = SafeArrayCreate(v, 1, rgsabound);
    }
    
    ~CSAFEARRAY() { if (p) SafeArrayDestroy(p); }
    CSAFEARRAY(SAFEARRAY *pSrc) { p = pSrc; }

    HRESULT Put(long nLocation, LPVOID pData) {
        return SafeArrayPutElement(p, &nLocation, pData);                
    }

    HRESULT Get(long nLocation, LPVOID pData) { 
        return SafeArrayGetElement(p, &nLocation, pData);                
    }

    HRESULT Access(void **pData) { return SafeArrayAccessData(p, pData); }
    HRESULT Unaccess() { return SafeArrayUnaccessData(p); }

    operator SAFEARRAY *() { return p; }
    long GetNumElements() { long upper; SafeArrayGetUBound(p, 1, &upper); return upper + 1; }

    void Unbind() { p = 0; }
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\snapin\statnode.cpp ===
//==============================================================;

//

//	This source code is only intended as a supplement to 

//  existing Microsoft documentation. 

//

//	Use of this code is NOT supported.  

//

//

//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY

//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE

//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR

//  PURPOSE.

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved 
//
//    Microsoft Premier Support for Developers
//
//==============================================================;

#include "StatNode.h"

#include "Equipment.h"

const GUID CStaticNode::thisGuid = { 0x2974380d, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };

//==============================================================
//
// CStaticNode implementation
//
//
CStaticNode::CStaticNode()
{
    children[0] = new CEquipmentFolder;
}

CStaticNode::~CStaticNode()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++)
        if (children[n]) {
            delete children[n];
        }
}

HRESULT CStaticNode::OnExpand(IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsole, HSCOPEITEM parent)
{
    SCOPEDATAITEM sdi;
    
    if (!bExpanded) {
        // create the child nodes, then expand them
        for (int n = 0; n < NUMBER_OF_CHILDREN; n++) 
		{
            ZeroMemory(&sdi, sizeof(SCOPEDATAITEM) );
            sdi.mask = SDI_STR       |   // Displayname is valid
                SDI_PARAM     |   // lParam is valid
                SDI_IMAGE     |   // nImage is valid
                SDI_OPENIMAGE |   // nOpenImage is valid
                SDI_PARENT;
            
            sdi.relativeID  = (HSCOPEITEM)parent;
            sdi.nImage      = children[n]->GetBitmapIndex();
            sdi.nOpenImage  = INDEX_OPENFOLDER;
            sdi.displayname = MMC_CALLBACK;
            sdi.lParam      = (LPARAM)children[n];       // The cookie
            
            HRESULT hr = pConsoleNameSpace->InsertItem( &sdi );
            
            _ASSERT( SUCCEEDED(hr) );
        }
    }
    
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\utillib\wbemsec.h ===
//***************************************************************************

//

//  WBEMSEC.H

//

//  Purpose: Provides prototypes for some security helper functions.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef _WBEMSEC_H_
#define _WBEMSEC_H_

HRESULT InitializeSecurity(DWORD dwAuthLevel, DWORD dwImpLevel);
SCODE GetAuthImp(IUnknown * pFrom, DWORD * pdwAuthLevel, DWORD * pdwImpLevel);
HRESULT SetInterfaceSecurity(IUnknown * pInterface, LPWSTR pDomain, LPWSTR pUser, LPWSTR pPassword, DWORD dwAuthLevel, DWORD dwImpLevel);

#endif // _WBEMSEC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\wmidiskperf\makefile.inc ===
$(O)\makefile : makefile.nm
	copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\snapin\registry.h ===
//==============================================================;

//

//	This source code is only intended as a supplement to existing Microsoft documentation. 

//

//	Use of this code is NOT supported.  

//

//

//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY

//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE

//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR

//  PURPOSE.

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved 
//
//    Microsoft Premier Support for Developers
//
//==============================================================;

#ifndef __Registry_H__
#define __Registry_H__

#include <tchar.h>

// This function will register a component in the Registry.
// The component calls this function from its DllRegisterServer function.
HRESULT RegisterServer(HMODULE hModule, 
                       const CLSID& clsid, 
                       const _TCHAR* szFriendlyName) ;

// This function will unregister a component.  Components
// call this function from their DllUnregisterServer function.
HRESULT UnregisterServer(const CLSID& clsid) ;


// This function will register a Snap-In component.  Components
// call this function from their DllRegisterServer function.
HRESULT RegisterSnapin(const CLSID& clsid,         // Class ID
                       const _TCHAR* szNameString,   // NameString
                       const CLSID& clsidAbout,		// Class Id for About Class
                       const BOOL fSupportExtensions = FALSE);

HRESULT UnregisterSnapin(const CLSID& clsid);         // Class ID

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\snapin\statnode.h ===
//==============================================================;

//

//	This source code is only intended as a supplement to 

//  existing Microsoft documentation. 

//

//	Use of this code is NOT supported.  

//

//

//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY

//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE

//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR

//  PURPOSE.

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved 
//
//    Microsoft Premier Support for Developers
//
//==============================================================;

#ifndef _SNAPINBASE_H
#define _SNAPINBASE_H

#include "DeleBase.h"

class CStaticNode : public CDelegationBase {
public:
    CStaticNode();
    
    virtual ~CStaticNode();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { 
        static _TCHAR szDisplayName[256];
        LoadString(g_hinst, IDS_SNAPINNAME, szDisplayName, sizeof(szDisplayName));
        return szDisplayName; 
    }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_NONE; }
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnExpand(IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsole, HSCOPEITEM parent);
    
private:
    enum { NUMBER_OF_CHILDREN = 1 };
    CDelegationBase *children[NUMBER_OF_CHILDREN];
    
    // {2974380d-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
};



#endif // _SNAPINBASE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\tempconsumer\consumer.cpp ===
// **************************************************************************

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// File:  CONSUMER.CPP
//
// Description:
//     Temporary Async Event Consumer which consumes the events
//     produced by the provider in the "EventProvider" project.
//
//     The events that this consumer asks for are of class "MyEvent".
//
// History:
//
// **************************************************************************

#define _WIN32_WINNT    0x0400

#include <windows.h>
#include <stdio.h>
#include <wbemidl.h>

#include "oahelp.inl"


//***************************************************************************
//
//***************************************************************************

class CMySink : public IWbemObjectSink
{
    UINT m_cRef;

public:
    CMySink() { m_cRef = 1; }
   ~CMySink() { }

    //
    // IUnknown members
    //
    STDMETHODIMP         QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    virtual /* [id] */ HRESULT STDMETHODCALLTYPE Indicate(
            /* [in] */ long lObjectCount,
            /* [size_is][in] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObjArray
            );

    virtual /* [id] */ HRESULT STDMETHODCALLTYPE SetStatus(
            /* [in] */ long lFlags,
            /* [in] */ HRESULT hResult,
            /* [in] */ BSTR strParam,
            /* [in] */ IWbemClassObject __RPC_FAR *pObjParam
            );
};


//***************************************************************************
//
//***************************************************************************

STDMETHODIMP CMySink::QueryInterface(REFIID riid, LPVOID * ppv)
{
    *ppv = 0;

    if (IID_IUnknown==riid || IID_IWbemObjectSink == riid)
    {
        *ppv = (IWbemObjectSink *) this;
        AddRef();
        return NOERROR;
    }

    return E_NOINTERFACE;
}


//***************************************************************************
//
//***************************************************************************

ULONG CMySink::AddRef()
{
    return ++m_cRef;
}

//***************************************************************************
//
//***************************************************************************

ULONG CMySink::Release()
{
    if (0 != --m_cRef)
        return m_cRef;

    delete this;
    return 0;
}

//***************************************************************************
//
//***************************************************************************

HRESULT CMySink::Indicate(
    long lObjectCount,
    IWbemClassObject __RPC_FAR *__RPC_FAR *ppObjArray
    )
{
    printf("Indicate called with %d object(s)\n", lObjectCount);

    // Get the info from the object.
    // =============================
    
    for (long i = 0; i < lObjectCount; i++)
    {
        IWbemClassObject *pObj = ppObjArray[i];
        
        // If here, we know the object is one of the kind we asked for.
        // ============================================================

        CVARIANT vName;
        pObj->Get(CBSTR(L"Name"), 0, &vName, 0, 0);
        CVARIANT vValue;
        pObj->Get(CBSTR(L"Value"), 0, &vValue, 0, 0);
        
        printf("Event info %S %u\n", vName.GetStr(), vValue.GetLONG());
    }

    return WBEM_NO_ERROR;
}


//***************************************************************************
//
//***************************************************************************

HRESULT CMySink::SetStatus(
    /* [in] */ long lFlags,
    /* [in] */ HRESULT hResult,
    /* [in] */ BSTR strParam,
    /* [in] */ IWbemClassObject __RPC_FAR *pObjParam
    )
{
    // Not called during event delivery.
        
    return WBEM_NO_ERROR;
}

//***************************************************************************
//
//***************************************************************************

BOOL ExecuteQuery(
    IWbemObjectSink *pDestSink,
    IWbemServices *pSvc
    )
{
    CBSTR Language(L"WQL");
    CBSTR Query(L"select * from MyEvent");

    HRESULT hRes = pSvc->ExecNotificationQueryAsync(
        Language,
        Query,
        0,                  // Flags
        0,                  // Context
        pDestSink
        );

    if (hRes != 0)
        return FALSE;

    return TRUE;
}



//***************************************************************************
//
//***************************************************************************

void main(int argc, char **argv)
{
    CoInitializeEx(0, COINIT_MULTITHREADED);
    CoInitializeSecurity( NULL, -1, NULL, NULL, 
											RPC_C_AUTHN_LEVEL_DEFAULT, 
											RPC_C_IMP_LEVEL_IMPERSONATE, 
											NULL, 
											EOAC_NONE, 
											NULL );
    IWbemLocator *pLoc = 0;

    DWORD dwRes = CoCreateInstance(CLSID_WbemLocator, 0, CLSCTX_INPROC_SERVER,
            IID_IWbemLocator, (LPVOID *) &pLoc);

    if (dwRes != S_OK)
    {
        printf("Failed to create IWbemLocator object.\n");
        CoUninitialize();
        return;
    }


    // Connect to CIMOM.
    // =================

    IWbemServices *pSvc = 0;

    HRESULT hRes = pLoc->ConnectServer(
            CBSTR(L"\\\\.\\ROOT\\DEFAULT"),
            NULL,
            NULL,
            0,
            0,
            0,
            0,
            &pSvc
            );

    if (hRes)
    {
        printf("Could not connect. Error code = 0x%X\n", hRes);
        CoUninitialize();
        return;
    }

    // If here, we succeeded.
    // ======================


    printf("Connected to CIMOM.\n");


    // Create a new sink.
    // ===================

    CMySink *pSink = new CMySink;

    BOOL bRes = ExecuteQuery(pSink, pSvc);

    // Now, we wait until the user hits ENTER to stop.
    // ===============================================

    if (bRes == TRUE)
    {
        char buf[8];
        gets(buf);

        pSvc->CancelAsyncCall(pSink);
    }
    else
    {
        printf("Unable to execute the event query\n");
    }

    // Cleanup.
    // ========

    printf("Shutting down\n");

    pSink->Release();
    pSvc->Release();
    pLoc->Release();

    CoUninitialize();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\utillib\wbemsec.cpp ===
//***************************************************************************

//

//  WBEMSEC.CPP

//

//  Purpose: Provides some security helper functions.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#define _WIN32_WINNT 0x0400
#include <windows.h>
#include <wbemidl.h>
#include "wbemsec.h"

//***************************************************************************
//
//  InitializeSecurity(DWORD dwAuthLevel, DWORD dwImpLevel)
//
//  DESCRIPTION:
//
//  Initialize DCOM security.  The authentication level is typically 
//  RPC_C_AUTHN_LEVEL_CONNECT,  and the impersonation level is typically 
// RPC_C_IMP_LEVEL_IMPERSONATE.  When using asynchronous call backs, an 
// authentication level of RPC_C_AUTHN_LEVEL_NONE is useful
//
//  RETURN VALUE:
//
//  see description.
//
//***************************************************************************

HRESULT InitializeSecurity(DWORD dwAuthLevel, DWORD dwImpLevel)
{
    // Initialize security
    // ===================

    return CoInitializeSecurity( NULL, -1, NULL, NULL, 
											dwAuthLevel, 
											dwImpLevel, 
											NULL, 
											EOAC_NONE, 
											NULL );
}

//***************************************************************************
//
//  bool bIsNT
//
//  DESCRIPTION:
//
//  Returns true if running windows NT.
//
//  RETURN VALUE:
//
//  see description.
//
//***************************************************************************

bool bIsNT(void)
{
    OSVERSIONINFO os;
    os.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if(!GetVersionEx(&os))
        return FALSE;           // should never happen
    return os.dwPlatformId == VER_PLATFORM_WIN32_NT;
}


//***************************************************************************
//
//  SCODE ParseAuthorityUserArgs
//
//  DESCRIPTION:
//
//  Examines the Authority and User argument and determines the authentication
//  type and possibly extracts the domain name from the user arugment in the 
//  NTLM case.  For NTLM, the domain can be at the end of the authentication
//  string, or in the front of the user name, ex;  "redmond\a-davj"
//
//  PARAMETERS:
//
//  ConnType            Returned with the connection type, ie wbem, ntlm
//  AuthArg             Output, contains the domain name
//  UserArg             Output, user name
//  Authority           Input
//  User                Input
//
//  RETURN VALUE:
//
//  S_OK                all is well
//  else error listed in WBEMSVC.H
//
//***************************************************************************

SCODE ParseAuthorityUserArgs(BSTR & AuthArg, BSTR & UserArg,BSTR & Authority,BSTR & User)
{

    // Determine the connection type by examining the Authority string

    if(!(Authority == NULL || wcslen(Authority) == 0 || !_wcsnicmp(Authority, L"NTLMDOMAIN:",11)))
        return E_INVALIDARG;

    // The ntlm case is more complex.  There are four cases
    // 1)  Authority = NTLMDOMAIN:name" and User = "User"
    // 2)  Authority = NULL and User = "User"
    // 3)  Authority = "NTLMDOMAIN:" User = "domain\user"
    // 4)  Authority = NULL and User = "domain\user"

    // first step is to determine if there is a backslash in the user name somewhere between the
    // second and second to last character

    WCHAR * pSlashInUser = NULL;
    if(User)
    {
        WCHAR * pEnd = User + wcslen(User) - 1;
        for(pSlashInUser = User; pSlashInUser <= pEnd; pSlashInUser++)
            if(*pSlashInUser == L'\\')      // dont think forward slash is allowed!
                break;
        if(pSlashInUser > pEnd)
            pSlashInUser = NULL;
    }

    if(Authority && wcslen(Authority) > 11) 
    {
        if(pSlashInUser)
            return E_INVALIDARG;

        AuthArg = SysAllocString(Authority + 11);
        if(User) UserArg = SysAllocString(User);
        return S_OK;
    }
    else if(pSlashInUser)
    {
        int iDomLen = pSlashInUser-User;
        WCHAR cTemp[MAX_PATH];
        wcsncpy(cTemp, User, iDomLen);
        cTemp[iDomLen] = 0;
        AuthArg = SysAllocString(cTemp);
        if(wcslen(pSlashInUser+1))
            UserArg = SysAllocString(pSlashInUser+1);
    }
    else
        if(User) UserArg = SysAllocString(User);

    return S_OK;
}


//***************************************************************************
//
//  SCODE GetAuthImp
//
//  DESCRIPTION:
//
//  Gets the authentication and impersonation levels for a current interface.
//
//  PARAMETERS:
//
//  pFrom               the interface to be tested.
//  pdwAuthLevel    Set to the authentication level
//  pdwImpLevel    Set to the impersonation level
//  RETURN VALUE:
//
//  S_OK                all is well
//  else error listed in WBEMSVC.H
//
//***************************************************************************

SCODE GetAuthImp(IUnknown * pFrom, DWORD * pdwAuthLevel, DWORD * pdwImpLevel)
{

    if(pFrom == NULL || pdwAuthLevel == NULL || pdwImpLevel == NULL)
        return WBEM_E_INVALID_PARAMETER;

    IClientSecurity * pFromSec = NULL;
    SCODE sc = pFrom->QueryInterface(IID_IClientSecurity, (void **) &pFromSec);
    if(sc == S_OK)
    {
        DWORD dwAuthnSvc, dwAuthzSvc, dwCapabilities;
        sc = pFromSec->QueryBlanket(pFrom, &dwAuthnSvc, &dwAuthzSvc, 
                                            NULL,
                                            pdwAuthLevel, pdwImpLevel,
                                            NULL, &dwCapabilities);

        // Special case of going to a win9x share level box

        if (sc == 0x800706d2)
        {
            *pdwAuthLevel = RPC_C_AUTHN_LEVEL_NONE;
            *pdwImpLevel = RPC_C_IMP_LEVEL_IDENTIFY;
            sc = S_OK;
        }
        pFromSec->Release();
    }
    return sc;
}
//***************************************************************************
//
//  SCODE SetInterfaceSecurity
//
//  DESCRIPTION:
//
//  This routine is used by clients in order to set the identity to be used by a connection.
//  NOTE that setting the security blanket on the interface is not recommended.
//  The clients should typically just call CoInitializeSecurity( NULL, -1, NULL, NULL, 
//											RPC_C_AUTHN_LEVEL_DEFAULT, 
//											RPC_C_IMP_LEVEL_IMPERSONATE, 
//											NULL, 
//											EOAC_NONE, 
//											NULL );
//  before calling out to WMI.
//
//
//  PARAMETERS:
//
//  pInterface         Interface to be set
//  pDomain           Input, domain
//  pUser                Input, user name
//  pPassword        Input, password.
//  pFrom               Input, if not NULL, then the authentication level of this interface
//                           is used
//  bAuthArg          If pFrom is NULL, then this is the authentication level
//  RETURN VALUE:
//
//  S_OK                all is well
//  else error listed in WBEMSVC.H
//
//***************************************************************************

HRESULT SetInterfaceSecurity(IUnknown * pInterface, LPWSTR pAuthority, LPWSTR pUser, 
                             LPWSTR pPassword, DWORD dwAuthLevel, DWORD dwImpLevel)
{
    
    SCODE sc;
    if(pInterface == NULL)
        return E_INVALIDARG;

    // If we are lowering the security, no need to deal with the identification info
    
    if(dwAuthLevel == RPC_C_AUTHN_LEVEL_NONE)
        return CoSetProxyBlanket(pInterface, RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE, NULL,
                       RPC_C_AUTHN_LEVEL_NONE, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_NONE);

    // If we are doing trivial case, just pass in a null authentication structure which is used
    // if the current logged in user's credentials are OK.

    if((pAuthority == NULL || wcslen(pAuthority) < 1) && 
        (pUser == NULL || wcslen(pUser) < 1) && 
        (pPassword == NULL || wcslen(pPassword) < 1))
            return CoSetProxyBlanket(pInterface, RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE, NULL,
                       dwAuthLevel, dwImpLevel, NULL, EOAC_NONE);

    // If user, or Authority was passed in, the we need to create an authority argument for the login
    
    COAUTHIDENTITY  authident;
    BSTR AuthArg = NULL, UserArg = NULL;
    sc = ParseAuthorityUserArgs(AuthArg, UserArg, pAuthority, pUser);
    if(sc != S_OK)
        return sc;

    memset((void *)&authident,0,sizeof(COAUTHIDENTITY));
    if(bIsNT())
    {
        if(UserArg)
        {
            authident.UserLength = wcslen(UserArg);
            authident.User = (LPWSTR)UserArg;
        }
        if(AuthArg)
        {
            authident.DomainLength = wcslen(AuthArg);
            authident.Domain = (LPWSTR)AuthArg;
        }
        if(pPassword)
        {
            authident.PasswordLength = wcslen(pPassword);
            authident.Password = (LPWSTR)pPassword;
        }
        authident.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;
    }
    else
    {
        char szUser[MAX_PATH], szAuthority[MAX_PATH], szPassword[MAX_PATH];

        // Fill in the indentity structure

        if(UserArg)
        {
            wcstombs(szUser, UserArg, MAX_PATH);
            authident.UserLength = strlen(szUser);
            authident.User = (LPWSTR)szUser;
        }
        if(AuthArg)
        {
            wcstombs(szAuthority, AuthArg, MAX_PATH);
            authident.DomainLength = strlen(szAuthority);
            authident.Domain = (LPWSTR)szAuthority;
        }
        if(pPassword)
        {
            wcstombs(szPassword, pPassword, MAX_PATH);
            authident.PasswordLength = strlen(szPassword);
            authident.Password = (LPWSTR)szPassword;
        }
        authident.Flags = SEC_WINNT_AUTH_IDENTITY_ANSI;
    }
    sc = CoSetProxyBlanket(pInterface, RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE, NULL,
                       dwAuthLevel, dwImpLevel, &authident, EOAC_NONE);

    if(UserArg)
        SysFreeString(UserArg);
    if(AuthArg)
        SysFreeString(AuthArg);
    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\wmidiskperf\dpdetail.cpp ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//	File:  dpdetail.cpp
//
//	Description:
//		This file implements the DiskPerfDetails() routine which 
//		demonstrates how to enumerate properties for the DiskPerf
//		class and instances.
//
//	Part of :	WMIDiskPerf
//
//  History:	
//
//***************************************************************************

#include <wbemidl.h>
#include <stdio.h>

void ShowPropInfo( IWbemClassObject *pInst );

char PropListHeader[] =
	"DiskPerf Property Descriptions:\n\n"
	"WMI Data ID\tProperty\tDescription\n"
	"======================================="
	"=======================================\n"
	"";


//==============================================================================
//
//	DiskPerfDetails( IWbemServices * pIWbemServices ) 
//
//==============================================================================
void DiskPerfDetails( IWbemServices * pIWbemServices ) 
{
	HRESULT		hr;
	long		lLower, lUpper, lCount; 
	SAFEARRAY	*psaNames = NULL;
	BSTR		PropName  = NULL;
	VARIANT		vVal;
	ULONG		uReturned;

	IEnumWbemClassObject	*pEnum      = NULL;
	IWbemClassObject		*pPerfData  = NULL;
	IWbemClassObject		*pPerfInst  = NULL;
	IWbemQualifierSet		*pQualSet   = NULL;

	VariantInit( &vVal );

	// Alloc class name string for DiskPerf
	BSTR PerfClass = SysAllocString( L"MSDiskDriver_PerformanceData" );

	// Get the Descriptions for the WMIDataId properties in the Embedded class.
	// Here the object info for the Class - MSDiskDriver_PerformanceData is
	// retrieved and displayed.

	// Collect object information for PerfClass
    hr = pIWbemServices->GetObject( PerfClass,
	                                  0L,
	                                  NULL,
	                                  &pPerfData,
                                      NULL );
	SysFreeString( PerfClass );

	if ( hr == WBEM_NO_ERROR )
	{
		// show the property description list header
		printf( PropListHeader );

		// Load up a safearray of property names
		if ( ( pPerfData->GetNames( NULL,
		                            WBEM_FLAG_ALWAYS | WBEM_FLAG_NONSYSTEM_ONLY,
		                            NULL, 
		                            &psaNames ) ) == WBEM_NO_ERROR )
		{
			// Get the upper and lower bounds of the Names array
			if ( ( hr = SafeArrayGetLBound( psaNames, 1, &lLower ) ) == S_OK ) 
			{
				hr = SafeArrayGetUBound( psaNames, 1, &lUpper );
			}

			if ( hr != S_OK ) 
			{
				printf( "Problem with property name array.\n" );
			}
			else
			{
				BSTR WmiQual  = SysAllocString( L"WmiDataId" );
				BSTR DescQual = SysAllocString( L"Description" );
				UINT uWmiId;

				for ( lCount = lLower; lCount <= lUpper; lCount++ ) 
				{
					// get the property name for this element
					if ( ( SafeArrayGetElement( psaNames, 
					                            &lCount, 
					                            &PropName)) == S_OK )
					{
						if ( ( pPerfData->GetPropertyQualifierSet( PropName, &pQualSet ) ) == WBEM_NO_ERROR ) 
						{
							// check to see if the property is a WMI data Item and save its description
							// these are the DiskPerf counters
							if ( ( pQualSet->Get( WmiQual, 0L, &vVal, NULL ) ) == WBEM_NO_ERROR )
							{
								uWmiId = vVal.lVal;

								VariantClear( &vVal );
								if ( ( pQualSet->Get( DescQual, 0L, &vVal, NULL ) ) == WBEM_NO_ERROR )
								{
									wprintf( L"( %d )\t\t%s\t%s\n", uWmiId, PropName, vVal.bstrVal );
									VariantClear( &vVal );
								}
								else // No Description qualifier available
									wprintf( L"( %d )\t\t%s\n", uWmiId, PropName);

							}

							pQualSet->Release( ); 
							pQualSet = NULL;
						}
						SysFreeString( PropName );
					}
				}
				SysFreeString( WmiQual );
				SysFreeString( DescQual );
			}
			SafeArrayDestroy( psaNames );
		}
		pPerfData->Release( );
	}


	// Now that the data class info is displayed, go get the values for all the
	// disk instances

	PerfClass = SysAllocString( L"MSDiskDriver_Performance" );

	// Create enumerator for all disk instances
    hr = pIWbemServices->CreateInstanceEnum( PerfClass,
	                                         WBEM_FLAG_SHALLOW,
	                                         NULL,
	                                         &pEnum );
	SysFreeString( PerfClass );

	if ( hr == WBEM_NO_ERROR )
	{
        while ( pEnum->Next( INFINITE,
		                     1,
                             &pPerfInst,
                             &uReturned ) == WBEM_NO_ERROR )
		{
			// Explicitly get the properties of InstanceName and Active state

			// Get the Instance Name string
			PropName = SysAllocString( L"InstanceName" );
			if ( ( pPerfInst->Get( PropName, 
			                       0L, 
			                       &vVal, 
			                       NULL, NULL ) ) == WBEM_NO_ERROR ) 
			{
				wprintf( L"\n%s\n", vVal.bstrVal );
				VariantClear( &vVal );
			}

			// Get Active status boolean

			PropName = wcscpy( PropName, L"Active" );
			if ( ( pPerfInst->Get( PropName, 
			                       0L, 
			                       &vVal, 
			                       NULL, NULL ) ) == WBEM_NO_ERROR ) 
			{
				wprintf( L"\t%s\t\t= %s\n", PropName, vVal.boolVal ? L"TRUE" : L"FALSE" );
				VariantClear( &vVal );
			}

			// Get the performance data embedded object
			PropName = wcscpy( PropName, L"PerfData" );
			if ( ( pPerfInst->Get( PropName, 
			                       0L, 
			                       &vVal, 
			                       NULL, NULL ) ) == WBEM_NO_ERROR ) 
			{
				if ( vVal.punkVal->QueryInterface( IID_IWbemClassObject,
				                                  (PVOID *) &pPerfData ) == S_OK )
				{
					// display the WMI data item from this instance
					ShowPropInfo( pPerfData );
					pPerfData->Release( );
				}
				VariantClear( &vVal );
			}

			SysFreeString( PropName );

			pPerfInst->Release( );
		}
		pEnum->Release( );
	}
	else
	{
		printf( "Can't enumerate DiskPerf instances!\n" );
	}
}


// Display property names and values for an instance.
void ShowPropInfo( IWbemClassObject *pInst )
{
	HRESULT hr;
	VARIANT vVal;
	BSTR PropName;

	if ( pInst )
	{
		hr = pInst->BeginEnumeration( WBEM_FLAG_LOCAL_ONLY );
		while ( hr == WBEM_NO_ERROR )
		{
			if ( ( hr = pInst->Next( 0, &PropName,
				                       &vVal, 
				                       NULL, NULL ) ) == WBEM_NO_ERROR ) 
			{
				switch( vVal.vt )
				{
					case VT_I4:
					{
						wprintf( L"\t%s\t= %d\n", PropName, vVal.lVal );
					}
					break;

					case VT_BSTR:
					{
						wprintf( L"\t%s\t= %s\n", PropName, vVal.bstrVal );
					}
					break;

					default:
					{
						wprintf( L"\t%s\t= NULL\n", PropName );
					}
					break;
				}
				VariantClear( &vVal );
				SysFreeString( PropName );
			}
		}
		pInst->EndEnumeration(  );
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vc7\wmiscriptutils\commonfuncs.h ===
#pragma once

HRESULT IsCreateObjectAllowed(IUnknown *pUnk, BSTR strProgId, BSTR *pstrValueName);
HRESULT RegisterCurrentDoc(IUnknown *pUnk, BSTR strProgId);
HRESULT UnRegisterCurrentDoc(IUnknown *pUnk, BSTR strProgId);
HRESULT SafeCreateObject(IUnknown *pUnkControl, BOOL fSafetyEnabled, CLSID clsid, IUnknown **ppUnk);
BOOL IsInternetHostSecurityManagerAvailable(IUnknown *pUnkControl);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\samples\vc\wmidiskperf\wmidiskperf.cpp ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//	File:  WMIDiskPerf.cpp
//
//	Description:
//		Connects to the WMI server and calls DiskPerfDetails( ) to
//		retrieve partition properties.
//
//	Part of :	WMIDiskPerf
//
//  History:	
//
//***************************************************************************


#include <wbemidl.h>
#include <lmcons.h>
#include <stdio.h>


void			DiskPerfDetails( IWbemServices * pIWbemServices );
BOOL			InitSecurity( void );
DWORD WINAPI	WaitThread( HANDLE hWait );


//==============================================================================
//	main( )
//==============================================================================
int main( int argc, char **argv )
{
	HRESULT	hr;
	DWORD	ThreadId, dwLen = UNCLEN;
	HANDLE	hWait, hThread;
	BSTR	pNamespace;
	TCHAR	szSysName[UNCLEN + 3];

	IWbemLocator	*pIWbemLocator  = NULL;
	IWbemServices	*pIWbemServices = NULL;

	if ( !SUCCEEDED( CoInitialize( NULL ) ) || !InitSecurity( ) ) 
	{
		printf( "COM stuff is hosed!\r\n" );

		return 0;
	}

	// Create an instance of the WbemLocator interface.
	if ( CoCreateInstance( CLSID_WbemLocator,
	                       NULL,
	                       CLSCTX_INPROC_SERVER,
	                       IID_IWbemLocator,
	                       (LPVOID *) &pIWbemLocator ) == S_OK )
	{

		lstrcpy( szSysName, "\\\\" );
		GetComputerName( szSysName + 2, &dwLen );
		pNamespace = SysAllocString( L"root\\WMI" );
		// Display connect message and start wait feedback thread
		printf( "Connecting to %s WMI server at ", szSysName );
		wprintf( L"%s...", pNamespace );

		// make a wait event and kick off wait thread
		hWait = CreateEvent( NULL, TRUE, FALSE, NULL );
		hThread = CreateThread( NULL, 0, (LPTHREAD_START_ROUTINE) WaitThread, hWait, 0, &ThreadId );

		// connect and get the IWbemServices pointer
		hr = pIWbemLocator->ConnectServer( pNamespace,
		                                   NULL,
		                                   NULL,
		                                   0L,
		                                   0L,
		                                   NULL,
		                                   NULL,
		                                   &pIWbemServices );

		// kill wait feedback thread
		SetEvent( hWait );
		// make sure thread is gone
		WaitForSingleObject( hThread, INFINITE );
		CloseHandle( hWait );
		SysFreeString( pNamespace );

		// See what WBEM/WMI says about DiskPerf
		if ( hr == WBEM_NO_ERROR )
		{	
			printf( "\nConnected with %s\n", szSysName );

			// done with locator object
			pIWbemLocator->Release( ); 

			
			// go enumerate diskperf instances...
			DiskPerfDetails( pIWbemServices );
			pIWbemServices->Release( );
		}
		else
		{	
			printf( "\nFailed to connect with %s, Error: 0x%8lX\n", szSysName, hr );
		}
	}
	else
	{	
		printf( "WMI services not present or unavailable!\n" );
	}

	CoUninitialize( );

	return 0;
}


//==============================================================================
//	WaitThread( HANDLE hWait )
//==============================================================================
DWORD WINAPI WaitThread( HANDLE hWait )
{
	while ( WaitForSingleObject( hWait, 300 ) == WAIT_TIMEOUT )
	{
		printf(".");
	}
	printf("\n");

	return 0;
}


//==============================================================================
//	InitSecurity( void )
//	Initialize COM security for DCOM services.
//==============================================================================
BOOL InitSecurity( void )
{
	// Adjust the security to allow client impersonation.
	HRESULT hres = CoInitializeSecurity
								( NULL, -1, NULL, NULL, 
								RPC_C_AUTHN_LEVEL_DEFAULT, 
								RPC_C_IMP_LEVEL_IMPERSONATE, 
								NULL, 
								EOAC_NONE, 
								NULL );

	return SUCCEEDED( hres );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vc7\wmiscriptutils\filehash.h ===
#pragma once

class MD5Hash
{
public:
	MD5Hash() {ZeroMemory(dwHash, sizeof(dwHash));}
	BSTR GetHashBSTR()
	{
		TCHAR szHash[33];
		for(int i=0;i<4;i++)
			wsprintf(&szHash[i*8], _T("%08X"), dwHash[i]);
		CComBSTR bstr(szHash);
		return bstr.Detach();
	}
	HRESULT HashData(LPBYTE pData, DWORD dwSize)
	{
		HRESULT hr = E_FAIL;
		HCRYPTPROV hProv = NULL;
		HCRYPTHASH hHash = NULL;
		__try
		{
			if(!CryptAcquireContext(&hProv, NULL, NULL, PROV_RSA_FULL, 0))
				__leave;

			if(!CryptCreateHash(hProv, CALG_MD5, 0, 0, &hHash))
				__leave;

			if(!CryptHashData(hHash, pData, dwSize, 0))
				__leave;

			DWORD dwSizeHash = 0;
			DWORD dwSizeDWORD = sizeof(dwSizeHash);
			if(!CryptGetHashParam(hHash, HP_HASHSIZE, (BYTE*)&dwSizeHash, &dwSizeDWORD, 0))
				__leave;

			if(dwSizeDWORD != sizeof(dwSizeHash) || dwSizeHash != sizeof(dwHash))
				__leave;

			if(!CryptGetHashParam(hHash, HP_HASHVAL, (BYTE*)dwHash, &dwSizeHash, 0))
				__leave;

			hr = S_OK;
		}
		__finally
		{
			if(hHash)
				CryptDestroyHash(hHash);
			if(hProv)
				CryptReleaseContext(hProv, 0);
		}
		return hr;
	}
protected:
	DWORD dwHash[4];

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vc7\wmiscriptutils\commonfuncs.cpp ===
#include "stdafx.h"

#include "CommonFuncs.h"
#include "FileHash.h"

#define SAFE_LOCAL_SCRIPTS_KEY TEXT("Software\\Microsoft\\WBEM\\SafeLocalScripts")


// QUESTIONS:
// - What is passed to SetSite when we are create in script?
// - If we are passed an IOleClientSite, is it a good idea to QueryService for
//   an IWebBrowserApp?
// - Is there a better way to get the IHTMLDocument2 when we are created through
//   script?

// Here are some general notes about what I've observed when creating objects
// in HTML with IE 5.x.

// Observed IE 5.x Behavior
// If an object implements IOleObject AND IObjectWithSite
// - For objects created in an HTML page with an <OBJECT...> tag, IE calls
//   IOleObject::SetClientSite and passes an IOleClientSite object
// - For object created in script of HTML page using JScript
//   'new ActiveXObject' or VBScript 'CreateObject' function, IE calls
//   IObjectWithSite::SetSite with a ??? object

// If an object implements IObjectWithSite (and NOT IOleObject)
// - For object created in HTML page with <OBJECT...> tag, IE calls
//   IObjectWithSite::SetSite and passes an IOleClientSite object
// - For object created in script of HTML page using JScript
//   'new ActiveXObject' or VBScript 'CreateObject' function, IE calls
//   IObjectWithSite::SetSite with a ??? object


//		BYTE *pbData = NULL;
//		DWORD dwSize;
//		GetSourceFromDoc(pDoc, &pbData, &dwSize);
// Get the original source to the document specified by pDoc
HRESULT GetSourceFromDoc(IHTMLDocument2 *pDoc, BYTE **ppbData, DWORD *pdwSize)
{
	HRESULT hr = E_FAIL;
	IPersistStreamInit *pPersistStreamInit = NULL;
	IStream *pStream = NULL;

	*ppbData = NULL;

	__try
	{
		if(FAILED(hr = pDoc->QueryInterface(IID_IPersistStreamInit, (void**) &pPersistStreamInit)))
			__leave;

		if (FAILED(hr = CreateStreamOnHGlobal(NULL, TRUE, &pStream)))
			__leave;

		if(FAILED(hr = pPersistStreamInit->Save(pStream, TRUE)))
			__leave;

		// We are not responsible for freeing this HGLOBAL
		HGLOBAL hGlobal = NULL;
		if(FAILED(hr = GetHGlobalFromStream(pStream, &hGlobal)))
			__leave;

		STATSTG ss;
		if(FAILED(hr = pStream->Stat(&ss, STATFLAG_NONAME)))
			__leave;

		// This should never happen
		if(ss.cbSize.HighPart != 0)
			__leave;

		if(NULL == ((*ppbData) = new BYTE[ss.cbSize.LowPart]))
			__leave;
		
		LPVOID pHTMLText = NULL;
		if(NULL == (pHTMLText = GlobalLock(hGlobal)))
			__leave;

		*pdwSize = ss.cbSize.LowPart;
		memcpy(*ppbData, pHTMLText, ss.cbSize.LowPart);
		GlobalUnlock(hGlobal);
		hr = S_OK;

	}
	__finally
	{
		// If we did not finish, but we allocated memory, we free it.
		if(FAILED(hr) && (*ppbData)!=NULL)
			delete [] (*ppbData);

		if(pPersistStreamInit)
			pPersistStreamInit->Release();
		if(pStream)
			pStream->Release();
	}
	return hr;
}


// For a control specified by pUnk, get the IServiceProvider of the host
HRESULT GetSiteServices(IUnknown *pUnk, IServiceProvider **ppServProv)
{
	HRESULT hr = E_FAIL;
	IOleObject *pOleObj = NULL;
	IObjectWithSite *pObjWithSite = NULL;
	IOleClientSite *pSite = NULL;
	__try
	{
		// Check if the ActiveX control supports IOleObject.
		if(SUCCEEDED(pUnk->QueryInterface(IID_IOleObject, (void**)&pOleObj)))
		{
			// If the control was created through an <OBJECT...> tag, IE will
			// have passed us an IOleClientSite.  If we have not been passed
			// an IOleClientSite, GetClientSite will still SUCCEED, but pSite
			// will be NULL.  In this case, we just go to the next section.
			if(SUCCEEDED(pOleObj->GetClientSite(&pSite)) && pSite)
			{
				hr = pSite->QueryInterface(IID_IServiceProvider, (void**)ppServProv);

				// At this point, we are done and do not want to process the
				// code in the next seciont
				__leave;
			}
		}

		// At this point, one of two things has happened:
		// 1) We didn't support IOleObject
		// 2) We supported IOleObject, but we were never passed an IOleClientSite

		// In either case, we now need to look at IObjectWithSite to try to get
		// to our site
		if(FAILED(hr = pUnk->QueryInterface(IID_IObjectWithSite, (void**)&pObjWithSite)))
			__leave;

		hr = pObjWithSite->GetSite(IID_IServiceProvider, (void**)ppServProv);
	}
	__finally
	{
		// Release any interfaces we used along the way
		if(pOleObj)
			pOleObj->Release();
		if(pObjWithSite)
			pObjWithSite->Release();
		if(pSite)
			pSite->Release();
	}
	return hr;
}

// This function shows how to get to the IHTMLDocument2 that created an
// arbitrary control represented by pUnk
HRESULT GetDocument(IUnknown *pUnk, IHTMLDocument2 **ppDoc)
{
	HRESULT hr = E_FAIL;
	IServiceProvider* pServProv = NULL;
	IDispatch *pDisp = NULL;
	__try
	{
		if(FAILED(hr = GetSiteServices(pUnk, &pServProv)))
			__leave;

		if(FAILED(hr = pServProv->QueryService(SID_SContainerDispatch, IID_IDispatch, (void**)&pDisp)))
			__leave;

		hr = pDisp->QueryInterface(IID_IHTMLDocument2, (void**)ppDoc);
	}
	__finally
	{
		if(pServProv)
			pServProv->Release();
		if(pDisp)
			pDisp->Release();
	}
	return hr;
}





// This function will Release() the current document and return a pointer to
// the parent document.  If no parent document is available, this function
// will return NULL (but will still release the current document)
IHTMLDocument2 *GetParentDocument(IHTMLDocument2 *pDoc)
{
	BSTR bstrURL = NULL;
	BSTR bstrURLParent = NULL;
	IHTMLWindow2 *pWndParent = NULL;
	IHTMLWindow2 *pWndParentParent = NULL;
	IHTMLDocument2 *pDocParent = NULL;
	__try
	{
		if(FAILED(pDoc->get_URL(&bstrURL)))
			__leave;
		if(FAILED(pDoc->get_parentWindow(&pWndParent)))
			__leave;
		if(FAILED(pWndParent->get_parent(&pWndParentParent)))
			__leave;
		if(FAILED(pWndParentParent->get_document(&pDocParent)))
			__leave;
		if(FAILED(pDocParent->get_URL(&bstrURLParent)))
			__leave;
		// TODO: Make this more robust
		if(0 == lstrcmpW(bstrURL, bstrURLParent))
		{
			// We are at the top document.  Release the new document pointer we
			// just received.
			pDocParent->Release();
			pDocParent = NULL;
		}
	}
	__finally
	{
		if(bstrURL)
			SysFreeString(bstrURL);
		if(bstrURLParent)
			SysFreeString(bstrURLParent);
		if(pWndParent)
			pWndParent->Release();
		if(pWndParentParent)
			pWndParentParent->Release();
		if(pDoc)
			pDoc->Release();
	}
	return pDocParent;
}


// Try to append bstr2 to pbstr1.  If this function fails, pbstr1 will still
// point to the original valid allocated bstr.
HRESULT AppendBSTR(BSTR *pbstr1, BSTR bstr2)
{
	HRESULT hr = S_OK;
	CComBSTR bstr;
	if(FAILED(bstr.AppendBSTR(*pbstr1)))
		hr = E_FAIL;
	if(FAILED(bstr.AppendBSTR(bstr2)))
		hr = E_FAIL;
	if(SUCCEEDED(hr))
	{
		SysFreeString(*pbstr1);
		*pbstr1 = bstr.Detach();
	}
	return hr;
}

BSTR AllocBSTR(LPCTSTR lpsz)
{
	CComBSTR bstr(lpsz);
	return bstr.Detach();
}

BOOL IsURLLocal(LPWSTR szURL)
{
	CComBSTR bstrURL(szURL);
	if(FAILED(bstrURL.ToLower()))
		return FALSE;
	// Make sure the URL starts with 'file://'
	if(0 != wcsncmp(bstrURL, L"file://", 7))
		return FALSE;
	
	// Make sure the next part is a drive letter, such as 'C:\'
	if(0 != wcsncmp(&(bstrURL[8]), L":\\", 2))
		return FALSE;

	WCHAR drive = bstrURL[7];
	// Make sure the URL points to drive 'a' to 'z'
	if(drive < 'a' || drive > 'z')
		return FALSE;

	TCHAR szDrive[4];
	lstrcpy(szDrive, TEXT("c:\\"));
	szDrive[0] = (TCHAR)drive;

	UINT uDriveType = GetDriveType(szDrive);
	return (DRIVE_FIXED == uDriveType);
}

// Try to convert the BSTR to lower case.  If this function fails, pbstr will
// still point to the original valid allocated bstr.
HRESULT ToLowerBSTR(BSTR *pbstr)
{
	CComBSTR bstr;
	if(FAILED(bstr.AppendBSTR(*pbstr)))
		return E_FAIL;
	if(FAILED(bstr.ToLower()))
		return E_FAIL;
	SysFreeString(*pbstr);
	*pbstr = bstr.Detach();
	return S_OK;
}

// For a given instance of an ActiveX control (represented by pUnk), and a
// specified strProgId, this function creates a 'full path' that can be checked
// in the registry to see if object creation should be allowed.  The full
// location is created from the following information
// 1) The name of the current EXE
// 2) The ProgId requested
// 3) The HREF of the current document
// 4) The HREF of every parent document up the available hierarchy
// All of the documents in the hierarchy must be on a local hard drive or the
// function will fail.  In addition, if any piece of informaiton along the way
// is not available, the function will fail.  This increases the security of
// our process.
// This function will also create a BSTR in *pbstrHash that contains the
// cumulative MD5 hash of the document and its parents.  This BSTR will be
// allocated by the function and should be freed by the caller.  If the
// function returns NULL for the full location, it will also return NULL for
// *pbstrHash
BSTR GetFullLocation(IUnknown *pUnk, BSTR strProgId, BSTR *pbstrHash)
{
	HRESULT hr = E_FAIL;
	IHTMLDocument2 *pDoc = NULL;
	BSTR bstrURL = NULL;
	BSTR bstrFullLocation = NULL;
	*pbstrHash = NULL;
	BYTE *pbData = NULL;
	BSTR bstrHash = NULL;

	__try
	{
		if(FAILED(GetDocument(pUnk, &pDoc)))
			__leave;

		TCHAR szFilename[_MAX_PATH];
		TCHAR szFilenameLong[_MAX_PATH];
		GetModuleFileName(NULL, szFilenameLong, _MAX_PATH);
		GetShortPathName(szFilenameLong, szFilename, _MAX_PATH);
		
		if(NULL == (bstrFullLocation = AllocBSTR(szFilename)))
			__leave;

		if(FAILED(AppendBSTR(&bstrFullLocation, strProgId)))
			__leave;

		if(NULL == (*pbstrHash = AllocBSTR(_T(""))))
			__leave;

		int nDepth = 0;
		do
		{
			// Make sure we don't get stuck in some infinite loop of parent
			// documents.  If we do get more than 100 levels of parent
			// documents, we assume failure
			if(++nDepth >= 100)
				__leave;

			if(FAILED(pDoc->get_URL(&bstrURL)))
				__leave;

			DWORD dwDataSize = 0;
			if(FAILED(GetSourceFromDoc(pDoc, &pbData, &dwDataSize)))
				__leave;

			MD5Hash hash;
			if(FAILED(hash.HashData(pbData, dwDataSize)))
				__leave;

			if(NULL == (bstrHash = hash.GetHashBSTR()))
				__leave;

			if(FAILED(AppendBSTR(pbstrHash, bstrHash)))
				__leave;

			SysFreeString(bstrHash);
			bstrHash = NULL;
			delete [] pbData;
			pbData = NULL;


			// Make sure every document is on the local hard drive
			if(!IsURLLocal(bstrURL))
				__leave;

			if(FAILED(AppendBSTR(&bstrFullLocation, bstrURL)))
				__leave;

			SysFreeString(bstrURL);
			bstrURL = NULL;
		} while (NULL != (pDoc = GetParentDocument(pDoc)));

		// Make sure we do not have any embeded NULLs.  If we do, we just
		// FAIL the call
		if(SysStringLen(bstrFullLocation) != wcslen(bstrFullLocation))
			__leave;

		// Make the location lower case
		if(FAILED(ToLowerBSTR(&bstrFullLocation)))
			__leave;

		// We've now created the normalized full location
		hr = S_OK;
	}
	__finally
	{
		// pDoc should be NULL if we got to the top of the hierarchy.  If not,
		// we should release it
		if(pDoc)
			pDoc->Release();

		// pbData should be NULL unless there was an error calculating the hash
		if(pbData)
			delete [] pbData;

		// bstrHash should be NULL unless there was a problem
		if(bstrHash)
			SysFreeString(bstrHash);

		// bstrURL should be NULL unless there was a problem
		if(bstrURL)
			SysFreeString(bstrURL);

		// If we didn't make it all the way to the end, we free the full location
		if(FAILED(hr) && bstrFullLocation)
		{
			SysFreeString(bstrFullLocation);
			bstrFullLocation = NULL;
		}

		// If we didn't make it all the way to the end, we free the checksum
		if(FAILED(hr) && *pbstrHash)
		{
			SysFreeString(*pbstrHash);
			*pbstrHash = NULL;
		}
	}

	return bstrFullLocation;
}

// For a given instance of an ActiveXControl (specified by pUnk), see if it is
// permitted to create the object specified by bstrProgId.  This is done by
// verifying that the control was created in an allowed HTML document.
HRESULT IsCreateObjectAllowed(IUnknown *pUnk, BSTR strProgId, BSTR *pstrValueName)
{
	BSTR bstrFullLocation = NULL;
	HRESULT hr = E_FAIL;
	HKEY hKey = NULL;
	LPTSTR pszValueName = NULL;
	LPTSTR pszValue = NULL;
	__try
	{
		BSTR bstrHash = NULL;
		// Get the full location
		if(NULL == (bstrFullLocation = GetFullLocation(pUnk, strProgId, &bstrHash)))
			__leave;

		SysFreeString(bstrHash);

		// Make sure we don't have a zero length string
		if(0 == SysStringLen(bstrFullLocation))
			__leave;

		// Open the registry key to see if this full location is registered
		if(ERROR_SUCCESS != RegOpenKey(HKEY_LOCAL_MACHINE, SAFE_LOCAL_SCRIPTS_KEY, &hKey))
			__leave;

		// Get info on the max lenghts of values in this key
		DWORD cValues, cMaxValueNameLen, cMaxValueLen;
		if(ERROR_SUCCESS != RegQueryInfoKey(hKey, NULL, NULL, NULL, NULL, NULL, NULL, &cValues, &cMaxValueNameLen, &cMaxValueLen, NULL, NULL))
			__leave;

		// Allocate space for the value name
		if(NULL == (pszValueName = new TCHAR[cMaxValueNameLen + 1]))
			__leave;

		// Allocate space for the value (this may be twice as big as necessary in UNICODE)
		if(NULL == (pszValue = new TCHAR[cMaxValueLen + 1]))
			__leave;
		for(DWORD dw = 0;dw<cValues;dw++)
		{
			DWORD cValueNameLen = cMaxValueNameLen+1;
			DWORD cbData = (cMaxValueLen+1)*sizeof(TCHAR);
			DWORD dwType;
			if(ERROR_SUCCESS != RegEnumValue(hKey, dw, pszValueName, &cValueNameLen, NULL, &dwType, (LPBYTE)pszValue, &cbData))
				continue;
			if(dwType != REG_SZ)
				continue;

			BSTR bstrValue = T2BSTR(pszValue);
			if(!bstrValue)
				continue;

			// SEE IF WE HAVE A MATCH
			if(0 == wcscmp(bstrFullLocation, bstrValue))
			{
				// Return the ValueName if requested
				if(pstrValueName)
					*pstrValueName = AllocBSTR(pszValueName);

				hr = S_OK;
			}

			SysFreeString(bstrValue);

			if(SUCCEEDED(hr))
				__leave; // WE FOUND A MATCH
		}
	}
	__finally
	{
		if(bstrFullLocation)
			SysFreeString(bstrFullLocation);
		if(hKey)
			RegCloseKey(hKey);
		if(pszValueName)
			delete [] pszValueName;
		if(pszValue)
			delete [] pszValue;
	}
	return hr;
}

// This function will register the location of the current ActiveX control
// (specified by pUnk) to be allowed to create objects of type strProgId
HRESULT RegisterCurrentDoc(IUnknown *pUnk, BSTR strProgId)
{
	USES_CONVERSION;

	HRESULT hr = E_FAIL;
	BSTR bstrFullLocation = NULL;
	LPTSTR pszFullLocation = NULL;
	HKEY hKey = NULL;

	__try
	{
		// See if we are already registered
		if(SUCCEEDED(IsCreateObjectAllowed(pUnk, strProgId, NULL)))
		{
			hr = S_OK;
			__leave;
		}

		// TODO: Maybe reuse some of the code from IsCreateObjectAllowed

		BSTR bstrHash = NULL;
		// Get the full location
		if(NULL == (bstrFullLocation = GetFullLocation(pUnk, strProgId, &bstrHash)))
			__leave;

		SysFreeString(bstrHash);

		// Make sure we don't have a zero length string
		if(0 == SysStringLen(bstrFullLocation))
			__leave;

		// Convert BSTR to normal string
		if(NULL == (pszFullLocation = W2T(bstrFullLocation)))
			__leave;

		// Create or open the registry key to store the registration
		if(ERROR_SUCCESS != RegCreateKey(HKEY_LOCAL_MACHINE, SAFE_LOCAL_SCRIPTS_KEY, &hKey))
			__leave;

		// Find an empty slot (no more than 1000 registrations
		TCHAR sz[10];
		for(int i=1;i<1000;i++)
		{
			wsprintf(sz, TEXT("%i"), i);
			DWORD cbValue;
			if(ERROR_SUCCESS != RegQueryValueEx(hKey, sz, NULL, NULL, NULL, &cbValue))
				break; // There is nothing in this slot
		}

		// See if we found a slot
		if(i>=1000)
			__leave;

		// Register the location
		if(ERROR_SUCCESS != RegSetValueEx(hKey, sz, 0, REG_SZ, (CONST BYTE *)pszFullLocation, lstrlen(pszFullLocation)*sizeof(TCHAR)))
			__leave;

		// Registered!
		hr = S_OK;
	}
	__finally
	{
		if(bstrFullLocation)
			SysFreeString(bstrFullLocation);
		if(hKey)
			RegCloseKey(hKey);
	}
	return hr;
}


// This function will remove any registration for the current document and
// strProgId
HRESULT UnRegisterCurrentDoc(IUnknown *pUnk, BSTR strProgId)
{
	USES_CONVERSION;

	BSTR bstrValueName = NULL;

	HKEY hKey = NULL;
	if(ERROR_SUCCESS != RegOpenKey(HKEY_LOCAL_MACHINE, SAFE_LOCAL_SCRIPTS_KEY, &hKey))
		return E_FAIL;

	// Make sure to remove ALL instances of this doc/strProgId in the registry
	// NOTE: Each iteration of this loop allocates some space off of the stack
	// for the conversion to ANSI (if not UNICODE build).  This should not be a
	// problem since there should not be too many keys ever registered with the
	// same location.
	while(SUCCEEDED(IsCreateObjectAllowed(pUnk, strProgId, &bstrValueName)) && bstrValueName)
	{
		LPTSTR szValueName = W2T(bstrValueName);
		SysFreeString(bstrValueName);
		bstrValueName = NULL;
		RegDeleteValue(hKey, szValueName);
	}
	RegCloseKey(hKey);
	return S_OK;
}


///////////////////////////////////////////////////////////////////////////////
// VC 6.0 did not ship with header files that included the CONFIRMSAFETY
// definition.
#ifndef CONFIRMSAFETYACTION_LOADOBJECT

EXTERN_C const GUID GUID_CUSTOM_CONFIRMOBJECTSAFETY;
#define CONFIRMSAFETYACTION_LOADOBJECT  0x00000001
struct CONFIRMSAFETY
{
    CLSID       clsid;
    IUnknown *  pUnk;
    DWORD       dwFlags;
};
#endif

const GUID GUID_CUSTOM_CONFIRMOBJECTSAFETY = 
	{ 0x10200490, 0xfa38, 0x11d0, { 0xac, 0xe, 0x0, 0xa0, 0xc9, 0xf, 0xff, 0xc0 }};

///////////////////////////////////////////////////////////////////////////////

HRESULT SafeCreateObject(IUnknown *pUnkControl, BOOL fSafetyEnabled, CLSID clsid, IUnknown **ppUnk)
{
	HRESULT hr = E_FAIL;
	IInternetHostSecurityManager *pSecMan = NULL;
	IServiceProvider *pServProv = NULL;
	__try
	{
		if (fSafetyEnabled)
		{
			if(FAILED(hr = GetSiteServices(pUnkControl, &pServProv)))
				__leave;

			if(FAILED(hr = pServProv->QueryService(SID_SInternetHostSecurityManager, IID_IInternetHostSecurityManager, (void**)&pSecMan)))
				__leave;
			
			// Ask security manager if we can create objects.
			DWORD dwPolicy = 0x12345678;
			if(FAILED(hr = pSecMan->ProcessUrlAction(URLACTION_ACTIVEX_RUN, (BYTE *)&dwPolicy, sizeof(dwPolicy), (BYTE *)&clsid, sizeof(clsid), 0, 0)))
				__leave;

			// TODO: BUG: If we are loaded in an HTA, hr returns S_OK, but 
			// dwPolicy only has the first byte set to zero.  See documentation
			// for ProcessUrlAction.
			// NOTE: This bug is caused by CClient::ProcessUrlAction in
			// nt\private\inet\mshtml\src\other\htmlapp\site.cxx.  This line
			// uses *pPolicy = dwPolicy, but pPolicy is a BYTE * so only the
			// first byte of the policy is copied to the output parameter.
			// To fix this, we check for hr==S_OK (as opposed to S_FALSE), and
			// see if dwPolicy is 0x12345600 (in other words, only the lower
			// byte of dwPolicy was changed).  As per the documentation, S_OK
			// alone should be enough to assume the dwPolicy was
			// URL_POLICY_ALLOW
			if(S_OK == hr && 0x12345600 == dwPolicy)
				dwPolicy = URLPOLICY_ALLOW;
			
			if(URLPOLICY_ALLOW != dwPolicy)
			{
				hr = E_FAIL;
				__leave;;
			}
		}

		// Create the requested object
		if (FAILED(hr = CoCreateInstance(clsid, NULL, CLSCTX_INPROC_SERVER, IID_IUnknown, (void**)ppUnk)))
			__leave;
		
		if (fSafetyEnabled)
		{
			// Query the security manager to see if this object is safe to use.
			DWORD dwPolicy, *pdwPolicy;
			DWORD cbPolicy;
			CONFIRMSAFETY csafe;
			csafe.pUnk = *ppUnk;
			csafe.clsid = clsid;
			csafe.dwFlags = 0;
//			csafe.dwFlags = (fWillLoad ? CONFIRMSAFETYACTION_LOADOBJECT : 0);
			
			if(FAILED(hr = pSecMan->QueryCustomPolicy(GUID_CUSTOM_CONFIRMOBJECTSAFETY, (BYTE **)&pdwPolicy, &cbPolicy, (BYTE *)&csafe, sizeof(csafe), 0)))
				__leave;
			
			dwPolicy = URLPOLICY_DISALLOW;
			if (NULL != pdwPolicy)
			{
				if (sizeof(DWORD) <= cbPolicy)
					dwPolicy = *pdwPolicy;
				CoTaskMemFree(pdwPolicy);
			}
			
			if(URLPOLICY_ALLOW != dwPolicy)
			{
				hr = E_FAIL;
				__leave;
			}
		}
		hr = S_OK;
	}
	__finally
	{
		// If we did not succeeded, we need to release the object we created (if any)
		if(FAILED(hr) && (*ppUnk))
		{
			(*ppUnk)->Release();
			*ppUnk = NULL;
		}

		if(pServProv)
			pServProv->Release();
		if(pSecMan)
			pSecMan->Release();
	}
	return hr;
}

BOOL IsInternetHostSecurityManagerAvailable(IUnknown *pUnkControl)
{
	HRESULT hr = E_FAIL;
	IInternetHostSecurityManager *pSecMan = NULL;
	IServiceProvider *pServProv = NULL;
	__try
	{
		if(FAILED(hr = GetSiteServices(pUnkControl, &pServProv)))
			__leave;

		if(FAILED(hr = pServProv->QueryService(SID_SInternetHostSecurityManager, IID_IInternetHostSecurityManager, (void**)&pSecMan)))
			__leave;
	}
	__finally
	{
		if(pServProv)
			pServProv->Release();
		if(pSecMan)
			pSecMan->Release();
	}
	return SUCCEEDED(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vc7\wmiscriptutils\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by WMIScriptUtils.rc
//
#define IDS_PROJNAME                    100
#define IDB_WMIOBJECTBROKER             101
#define IDR_WMIOBJECTBROKER             102
#define IDR_WMIOBJECTBROKERREGISTRATION 103

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           104
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vc7\wmiscriptutils\filehash.cpp ===
#include "stdafx.h"
#include "FileHash.h"



static DWORD crc_table[256];
static BOOL g_bCRC32Init = FALSE;

void InitCRC32Table()
{
	DWORD crc, poly;
	int i, j;

	poly = 0xEDB88320;
	for (i = 0; i < 256; i++)
	{
		crc = i;
		for (j = 8; j > 0; j--)
		{
			if (crc & 1)
				crc = (crc >> 1) ^ poly;
			else
				crc >>= 1;
		}
		crc_table[i] = crc;
	}
}

DWORD GetCRC32(BYTE *pData, DWORD dwSize)
{
	if(!g_bCRC32Init)
		InitCRC32Table();
	register unsigned long crc;
	BYTE *pEnd = pData + dwSize;
	crc = 0xFFFFFFFF;
	while (pData<pEnd)
		crc = ((crc>>8) & 0x00FFFFFF) ^ crc_table[ (crc^(*(pData++))) & 0xFF ];
	return ( crc^0xFFFFFFFF );
}

HRESULT GetCRC32(HANDLE hFile, DWORD dwSize, DWORD *pdwCRC32)
{
	HRESULT hr = E_FAIL;

	if(0 == dwSize)
	{
		*pdwCRC32 = 0;
		return S_OK;
	}

	HANDLE hMapping = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, dwSize, NULL);
	if(!hMapping)
		return hr;

	BYTE *pData = (BYTE*)MapViewOfFile(hMapping, FILE_MAP_READ, 0, 0, dwSize);

	if(pData)
	{
		*pdwCRC32 = GetCRC32(pData, dwSize);
		hr = S_OK;
		UnmapViewOfFile(pData);
	}
	CloseHandle(hMapping);
	return hr;
}

HRESULT GetCRC32(TCHAR *szFile, DWORD *pdwSize, DWORD *pdwCRC32)
{
	HRESULT hr = E_FAIL;
	HANDLE hFile = CreateFile(szFile, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	if(INVALID_HANDLE_VALUE == hFile)
		return hr;

	DWORD dwHigh = 0;
	*pdwSize = GetFileSize(hFile, &dwHigh);

	// We don't support files larger than 4 gig
	if(0 == dwHigh)
		hr = GetCRC32(hFile, *pdwSize, pdwCRC32);

	CloseHandle(hFile);
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vc7\wmiscriptutils\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vc7\wmiscriptutils\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__ABA61DCB_4742_4DAE_987B_18620A19CDB1__INCLUDED_)
#define AFX_STDAFX_H__ABA61DCB_4742_4DAE_987B_18620A19CDB1__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlctl.h>

#include <comdef.h>
#include <exdisp.h>
#include <shlobj.h>
#include <mshtml.h>


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__ABA61DCB_4742_4DAE_987B_18620A19CDB1__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vc7\wmiscriptutils\commonfuncsunused.cpp ===
//This was alternative way to get to the internet host security manager (instead of using SID_SInternetHostSecurityManager)
#if 0
			if(FAILED(hr = GetDocument(pUnkControl, &pDoc)))
				__leave;

			if(FAILED(hr = pDoc->QueryInterface(IID_IInternetHostSecurityManager, (void**)&pSecMan)))
				__leave;
#endif









// This function shows how to get to the IHTMLDocument2 that created an
// arbitrary control represented by pUnk
HRESULT GetDocument(IUnknown *pUnk, IHTMLDocument2 **ppDoc)
{
	// If an ActiveX control is created in HTML, this function will return 
	// a pointer to the IHTMLDocument2.  To get to the IHTMLDocument2, controls
	// must implement IObjectWithSite.  If controls also implement IOleObject,
	// the method used to get to the IHTMLDocument2 is slightly different.
	// This function abstracts the difference between controls that implement
	// just IObjectWithSite and controls that implement BOTH IOleObject AND
	// IObjectWithSite.  This function also abstracts the different techniques
	// that need to be used depending on if the control was created through an
	// <OBJECT...> tag or if the control was created through JScript using
	// 'new ActiveXObject' or VBScript using 'CreateObject'
	HRESULT hr = E_FAIL;
	IOleObject *pOleObj = NULL;
	IObjectWithSite *pObjWithSite = NULL;
	IOleClientSite *pSite = NULL;
	IOleContainer *pContainer = NULL;
	IServiceProvider *pServProv = NULL;
	IWebBrowserApp *pWebApp = NULL;
	IDispatch *pDisp = NULL;

	__try
	{
		// Check if the ActiveX control supports IOleObject.
		if(SUCCEEDED(pUnk->QueryInterface(IID_IOleObject, (void**)&pOleObj)))
		{
			// If the control was created through an <OBJECT...> tag, IE will
			// have passed us an IOleClientSite.  If we have not been passed
			// an IOleClientSite, GetClientSite will still SUCCEED, but pSite
			// will be NULL.  In this case, we just go to the next section.
			if(SUCCEEDED(pOleObj->GetClientSite(&pSite)) && pSite)
			{
				// We were passed an IOleClientSite!!! We can call GetContainer
				// and QI for the IHTMLDocument2 that we need
				if(FAILED(hr = pSite->GetContainer(&pContainer)))
					__leave;
				hr = pContainer->QueryInterface(IID_IHTMLDocument2, (void**)ppDoc);

				// At this point, we are done and do not want to process the
				// code in the next seciont
				__leave;
			}
		}

		// At this point, one of two things has happened:
		// 1) We didn't support IOleObject
		// 2) We supported IOleObject, but we were never passed an IOleClientSite

		// In either case, we now need to look at IObjectWithSite to try to get
		// to our site
		if(FAILED(hr = pUnk->QueryInterface(IID_IObjectWithSite, (void**)&pObjWithSite)))
			__leave;

		// In case #1 above, we may have been passed an IOleClientSite to
		// IObjectWithSite::SetSite.  This happens if we were created with
		// an <OBJECT...> tag
		if(SUCCEEDED(pObjWithSite->GetSite(IID_IOleClientSite, (void**)&pSite)))
		{
			// We can now call GetContainer and QI for the IHTMLDocument2
			if(FAILED(hr = pSite->GetContainer(&pContainer)))
				__leave;
			hr = pContainer->QueryInterface(IID_IHTMLDocument2, (void**)ppDoc);
		}
		else
		{
			// If we were not passed an IOleClientSite, it is possible that
			// we were created dynamically (with 'new ActiveXObject' in JScript,
			// or 'CreateObject' in VBScript).  We can use the following steps
			// to get to the IHTMLDocument2 that created the control:
			// 1) QI for IServiceProvider
			// 2) Call QueryService to get an IWebBrowserApp
			// 3) Call get_Document to get the IDispatch of the document
			// 4) QI for the IHTMLDocument2 interface.
			if(FAILED(hr = pObjWithSite->GetSite(IID_IServiceProvider, (void**)&pServProv)))
				__leave;
#if 0
			if(FAILED(hr = pServProv->QueryService(SID_SWebBrowserApp, IID_IWebBrowserApp, (void**)&pWebApp)))
				__leave;
			if(FAILED(hr = pWebApp->get_Document(&pDisp)))
				__leave;
			hr = pDisp->QueryInterface(IID_IHTMLDocument2, (void**)ppDoc);
#endif
//			hr = pServProv->QueryService(SID_SContainerDispatch, IID_IHTMLDocument2, (void**)ppDoc);
			if(FAILED(hr = pServProv->QueryService(SID_SContainerDispatch, IID_IDispatch, (void**)&pDisp)))
				__leave;
			hr = pDisp->QueryInterface(IID_IHTMLDocument2, (void**)ppDoc);
		}
	}
	__finally
	{
		// Release any interfaces we used along the way
		if(pOleObj)
			pOleObj->Release();
		if(pObjWithSite)
			pObjWithSite->Release();
		if(pSite)
			pSite->Release();
		if(pContainer)
			pContainer->Release();
		if(pServProv)
			pServProv->Release();
		if(pWebApp)
			pWebApp->Release();
		if(pDisp)
			pDisp->Release();
	}
	return hr;
}




#if 0
// This function shows how to get to the IHTMLDocument2 that created a control
// in either situation (an <OBJECT...> tag or dynamically created controls in
// script).  It assumes that the control has just implement IObjectWithSite
// and NOT IOleObject.  If IOleObject is implemented, IE will NOT call
// IObjectWithSite::SetSite.
HRESULT GetDocumentFromObjectWithSite(IObjectWithSite *pObject, IHTMLDocument2 **ppDoc)
{
	// If an ActiveX control implements IObjectWithSite, this function will
	// return a pointer to the IHTMLDocument2 that is hosting the control 
	// (assuming that the control was created in an HTML page).
	// NOTE: If the ActiveX control has also implemented IOleObject, this
	// function cannot be used.  In that case, IE calls
	// IOleObject::SetClientSite instead of IObjectWithSite::SetSite to pass
	// the control an IOleClientSite object when the control is created in an
	// <OBJECT...> tag.  If the control is created dynamically in JScript with
	// 'new ActiveXObject' or VBScript with 'CreateObject', then
	// IObjectWithSite::SetSite is called.  If the ActiveXControl does not
	// implement IOleObject (but implements IObjectWithSite), IE will always
	// call IObjectWithSite::SetSite.  However, the object passed to SetSite
	// will still vary depending on if the control was created dynamically or
	// statically in an <OBJECT...> tag.  This function abstracts the
	// difference between the two situations.
	HRESULT hr = S_OK;
	IOleClientSite *pSite = NULL;
	IOleContainer *pContainer = NULL;
	IServiceProvider *pServProv = NULL;
	IWebBrowserApp *pWebApp = NULL;
	IDispatch *pDisp = NULL;

	__try
	{
		if(SUCCEEDED(pObject->GetSite(IID_IOleClientSite, (void**)&pSite)))
		{
			// If the ActiveX control that implemented IObjectWithSite was
			// created on an HTML page using the <OBJECT...> tag, IE will call
			// SetSite with an IID_IOleClientSite.  We can call GetContainer
			// and the QI for the IHTMLDocument2.
			if(FAILED(hr = pSite->GetContainer(&pContainer)))
				__leave;
			hr = pContainer->QueryInterface(IID_IHTMLDocument2, (void**)ppDoc);
		}
		else
		{
			// If the ActiveX control that implement IObjectWithSite was
			// created dynamically (with 'new ActiveXObject' in JScript, or
			// CreateObject in VBScript), we are passed a ??? object.  We can
			// QI for IServiceProvider, and get to an IWebBrowserApp through
			// QueryService.  Then, we can get IDispatch pointer of the 
			// document through get_Document, and finally QI for the
			// IHTMLDocument2 interface.
			if(FAILED(hr = pObject->GetSite(IID_IServiceProvider, (void**)&psp)))
				__leave;
			if(FAILED(hr = psp->QueryService(SID_SWebBrowserApp, IID_IWebBrowserApp, (void**)&pApp)))
				__leave;
			if(FAILED(hr = pApp->get_Document(&pDisp)))
				__leave;
			hr = pDisp->QueryInterface(IID_IHTMLDocument2, (void**)ppDoc);
		}
	}
	__finally
	{
		if(pSite)
			pSite->Release();
		if(pContainer)
			pContainer->Release();
		if(pServProv)
			pServProv->Release();
		if(pWebApp)
			pWebApp->Release();
		if(pDisp)
			pDisp->Release();
	}
	return hr;
}
#endif
#if 0
HRESULT CWMIObjectBroker::GetDocument(IHTMLDocument2 **ppDoc)
{
	HRESULT hr = S_OK;
	IOleClientSite *pSite = NULL;
//	if(SUCCEEDED(GetClientSite(&pSite)) && pSite)
	if(FALSE)
	{
		IOleContainer *pContainer;
		if(SUCCEEDED(hr = pSite->GetContainer(&pContainer)))
		{
			hr = pContainer->QueryInterface(IID_IHTMLDocument2, (void**)ppDoc);
			pContainer->Release();
		}
		pSite->Release();
	}
	else
	{
		IServiceProvider *psp = NULL;
		if(SUCCEEDED(hr = GetSite(IID_IServiceProvider, (void**)&psp)))
		{
			IWebBrowserApp *pApp = NULL;
			if(SUCCEEDED(hr = psp->QueryService(SID_SWebBrowserApp, IID_IWebBrowserApp, (void**)&pApp)))
			{
				IDispatch *pDisp;
				if(SUCCEEDED(hr = pApp->get_Document(&pDisp)))
				{
					hr = pDisp->QueryInterface(IID_IHTMLDocument2, (void**)ppDoc);
					pDisp->Release();
				}
				pApp->Release();
			}
			psp->Release();
		}
	}
	return hr;
}
#endif

#if 0
	IHTMLDocument2 *pDoc2 = NULL;
	GetDocument(&pDoc2);

	IOleClientSite *pSite = NULL;
//	GetClientSite(&pSite);
	if(!pSite)
	{
		HRESULT hr = S_OK;
		hr = GetSite(IID_IOleClientSite, (void**)&pSite);
		hr = GetSite(IID_IServiceProvider, (void**)&pSite);
//		hr = GetSite(IID_IActiveScript, (void**)&pSite);
		hr = GetSite(IID_IOleContainer, (void**)&pSite);
		IServiceProvider *psp = NULL;
		hr = GetSite(IID_IServiceProvider, (void**)&psp);
		IWebBrowserApp *pApp = NULL;
		hr = psp->QueryService(SID_SWebBrowserApp, IID_IWebBrowserApp, (void**)&pApp);
		BSTR bstr;
//		pApp->get_LocationURL(&bstr);
		IHTMLDocument2 *pDoc;
		IDispatch *pDisp;
		pApp->get_Document(&pDisp);
		pDisp->QueryInterface(IID_IHTMLDocument2, (void**)&pDoc);
		pDoc->get_URL(&bstr);
		bstr = NULL;
	}
	IOleContainer *pContainer;
	pSite->GetContainer(&pContainer);
	pSite->Release();
	IHTMLDocument2 *pDoc;
	pContainer->QueryInterface(IID_IHTMLDocument2, (void**)&pDoc);
	BSTR bstrURL = NULL;
	pDoc->get_URL(&bstrURL);
	SysFreeString(bstrURL);
	IHTMLDocument2 *pDocParent = NULL;
	IHTMLWindow2 *pWndParent = NULL;
	pDoc->get_parentWindow(&pWndParent);
	pWndParent->get_document(&pDocParent);
	pDocParent->get_URL(&bstrURL);
	SysFreeString(bstrURL);

	pDocParent->Release();
	IHTMLWindow2 *pWnd2 = NULL;
	pWndParent->get_top(&pWnd2);
	pWnd2->get_document(&pDocParent);
	pDocParent->get_URL(&bstrURL);
	SysFreeString(bstrURL);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vc7\wmiscriptutils\wmiobjectbroker.h ===
// WMIObjectBroker.h : Declaration of the CWMIObjectBroker

#ifndef __WMIOBJECTBROKER_H_
#define __WMIOBJECTBROKER_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CWMIObjectBroker
class ATL_NO_VTABLE CWMIObjectBroker : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CWMIObjectBroker, &CLSID_WMIObjectBroker>,
	public IDispatchImpl<IWMIObjectBroker, &IID_IWMIObjectBroker, &LIBID_WMISCRIPTUTILSLib>,
	public IObjectSafetyImpl<CWMIObjectBroker, INTERFACESAFE_FOR_UNTRUSTED_CALLER|INTERFACESAFE_FOR_UNTRUSTED_DATA|INTERFACE_USES_SECURITY_MANAGER>,
	public IObjectWithSiteImpl<CWMIObjectBroker>
{
public:
	CWMIObjectBroker()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_WMIOBJECTBROKER)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CWMIObjectBroker)
	COM_INTERFACE_ENTRY(IWMIObjectBroker)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IObjectSafety)
	COM_INTERFACE_ENTRY(IObjectWithSite)
END_COM_MAP()

// IWMIObjectBroker
public:
	STDMETHOD(CanCreateObject)(/*[in]*/ BSTR strProgId, /*[out, retval]*/ VARIANT_BOOL *bResult);
	STDMETHOD(CreateObject)(BSTR strProgId, IDispatch **obj);
};

#endif //__WMIOBJECTBROKER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vc7\wmiscriptutils\wmiobjectbroker.cpp ===
// WMIObjectBroker.cpp : Implementation of CWMIObjectBroker

#include "stdafx.h"
#include "WMIScriptUtils.h"
#include "WMIObjectBroker.h"
#include "CommonFuncs.h"

/////////////////////////////////////////////////////////////////////////////
// CWMIObjectBroker



STDMETHODIMP CWMIObjectBroker::CreateObject(BSTR strProgId, IDispatch **obj)
{
	HRESULT hr = E_FAIL;
	CLSID clsid;
	IUnknown *pUnk = NULL;
	__try
	{
		BOOL fSafetyEnabled = TRUE;

		// TODO: Do we want this check to enable us to work from WSH?

		// BUG in IE/JScript/VBScript: We should be checking to see if 
		// m_dwCurrentSafety != INTERFACE_USES_SECURITY_MANAGER, but current
		// IE/JScript/VBScript versions do not call SetInterfaceSafetyOptions
		// with anything but INTERFACESAFE_FOR_UNTRUSTED_CALLER

		// If we are run though CScript.exe or WScript.exe, we will never be
		// asked to set safety options through SetInterfaceSafetyOptions.  In
		// addition, there will not be an InternetHostSecurityManager available
		// through our 'site'.  In this case, we allow any object to be created.
		if(m_dwCurrentSafety == 0 && !IsInternetHostSecurityManagerAvailable(GetUnknown()))
			fSafetyEnabled = FALSE;

		// We can override the safety check if this insance of the 'broker'
		// control is allowed to create the object specified by strProbId
		if(fSafetyEnabled && SUCCEEDED(IsCreateObjectAllowed(GetUnknown(), strProgId, NULL)))
			fSafetyEnabled = FALSE;

		// Convert the ProgId to a CLSID
		if(FAILED(hr = CLSIDFromProgID(strProgId, &clsid)))
			__leave;

		// Create the requested object
#if 0
		if(FAILED(hr = CoCreateInstance(clsid, NULL, CLSCTX_INPROC_SERVER, IID_IUnknown, (void**)&pUnk)))
			__leave;
#endif
		if(FAILED(hr = SafeCreateObject(GetUnknown(),fSafetyEnabled, clsid, &pUnk)))
			__leave;

		// Get the IDispatch for the caller
		hr = pUnk->QueryInterface(IID_IDispatch, (void**)obj);
	}
	__finally
	{
		if(pUnk)
			pUnk->Release();
	}
	return hr;
}

STDMETHODIMP CWMIObjectBroker::CanCreateObject(BSTR strProgId, VARIANT_BOOL *bResult)
{
	*bResult = VARIANT_FALSE;
	if(SUCCEEDED(IsCreateObjectAllowed(GetUnknown(), strProgId, NULL)))
		*bResult = VARIANT_TRUE;
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vc7\wmiscriptutils\wmiobjectbrokerregistration.cpp ===
// WMIObjectBrokerRegistration.cpp : Implementation of CWMIObjectBrokerRegistration
#include "stdafx.h"
#include "WMIScriptUtils.h"
#include "WMIObjectBrokerRegistration.h"
#include "CommonFuncs.h"

/////////////////////////////////////////////////////////////////////////////
// CWMIObjectBrokerRegistration


STDMETHODIMP CWMIObjectBrokerRegistration::Register(BSTR strProgId, VARIANT_BOOL *bResult)
{
	*bResult = VARIANT_FALSE;
	if(SUCCEEDED(RegisterCurrentDoc(GetUnknown(), strProgId)))
		*bResult = VARIANT_TRUE;
	return S_OK;
}

STDMETHODIMP CWMIObjectBrokerRegistration::UnRegister(BSTR strProgId, VARIANT_BOOL *bResult)
{
	*bResult = VARIANT_FALSE;
	if(SUCCEEDED(UnRegisterCurrentDoc(GetUnknown(), strProgId)))
		*bResult = VARIANT_TRUE;
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vc7\beta1\system\wbem\wmiscriptutils\commonfuncs.h ===
#pragma once

HRESULT IsCreateObjectAllowed(IUnknown *pUnk, BSTR strProgId, BSTR *pstrValueName);
HRESULT RegisterCurrentDoc(IUnknown *pUnk, BSTR strProgId);
HRESULT UnRegisterCurrentDoc(IUnknown *pUnk, BSTR strProgId);
HRESULT SafeCreateObject(IUnknown *pUnkControl, BOOL fSafetyEnabled, CLSID clsid, IUnknown **ppUnk);
BOOL IsInternetHostSecurityManagerAvailable(IUnknown *pUnkControl);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vc7\wmiscriptutils\wmiscriptutils.cpp ===
// WMIScriptUtils.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f WMIScriptUtilsps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "WMIScriptUtils.h"

#include "WMIScriptUtils_i.c"
#include "WMIObjectBroker.h"
#include "WMIObjectBrokerRegistration.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_WMIObjectBroker, CWMIObjectBroker)
OBJECT_ENTRY(CLSID_WMIObjectBrokerRegistration, CWMIObjectBrokerRegistration)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_WMISCRIPTUTILSLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vc7\beta1\system\wbem\wmiscriptutils\filehash.cpp ===
#include "stdafx.h"
#include "FileHash.h"



static DWORD crc_table[256];
static BOOL g_bCRC32Init = FALSE;

void InitCRC32Table()
{
	DWORD crc, poly;
	int i, j;

	poly = 0xEDB88320;
	for (i = 0; i < 256; i++)
	{
		crc = i;
		for (j = 8; j > 0; j--)
		{
			if (crc & 1)
				crc = (crc >> 1) ^ poly;
			else
				crc >>= 1;
		}
		crc_table[i] = crc;
	}
}

DWORD GetCRC32(BYTE *pData, DWORD dwSize)
{
	if(!g_bCRC32Init)
		InitCRC32Table();
	register unsigned long crc;
	BYTE *pEnd = pData + dwSize;
	crc = 0xFFFFFFFF;
	while (pData<pEnd)
		crc = ((crc>>8) & 0x00FFFFFF) ^ crc_table[ (crc^(*(pData++))) & 0xFF ];
	return ( crc^0xFFFFFFFF );
}

HRESULT GetCRC32(HANDLE hFile, DWORD dwSize, DWORD *pdwCRC32)
{
	HRESULT hr = E_FAIL;

	if(0 == dwSize)
	{
		*pdwCRC32 = 0;
		return S_OK;
	}

	HANDLE hMapping = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, dwSize, NULL);
	if(!hMapping)
		return hr;

	BYTE *pData = (BYTE*)MapViewOfFile(hMapping, FILE_MAP_READ, 0, 0, dwSize);

	if(pData)
	{
		*pdwCRC32 = GetCRC32(pData, dwSize);
		hr = S_OK;
		UnmapViewOfFile(pData);
	}
	CloseHandle(hMapping);
	return hr;
}

HRESULT GetCRC32(TCHAR *szFile, DWORD *pdwSize, DWORD *pdwCRC32)
{
	HRESULT hr = E_FAIL;
	HANDLE hFile = CreateFile(szFile, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	if(INVALID_HANDLE_VALUE == hFile)
		return hr;

	DWORD dwHigh = 0;
	*pdwSize = GetFileSize(hFile, &dwHigh);

	// We don't support files larger than 4 gig
	if(0 == dwHigh)
		hr = GetCRC32(hFile, *pdwSize, pdwCRC32);

	CloseHandle(hFile);
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vc7\beta1\system\wbem\wmiscriptutils\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by WMIScriptUtils.rc
//
#define IDS_PROJNAME                    100
#define IDB_WMIOBJECTBROKER             101
#define IDR_WMIOBJECTBROKER             102
#define IDR_WMIOBJECTBROKERREGISTRATION 103

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           104
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vc7\beta1\system\wbem\wmiscriptutils\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vc7\wmiscriptutils\wmiobjectbrokerregistration.h ===
// WMIObjectBrokerRegistration.h : Declaration of the CWMIObjectBrokerRegistration

#ifndef __WMIOBJECTBROKERREGISTRATION_H_
#define __WMIOBJECTBROKERREGISTRATION_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CWMIObjectBrokerRegistration
class ATL_NO_VTABLE CWMIObjectBrokerRegistration : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CWMIObjectBrokerRegistration, &CLSID_WMIObjectBrokerRegistration>,
	public IDispatchImpl<IWMIObjectBrokerRegistration, &IID_IWMIObjectBrokerRegistration, &LIBID_WMISCRIPTUTILSLib>,
	public IObjectWithSiteImpl<CWMIObjectBrokerRegistration>
{
public:
	CWMIObjectBrokerRegistration()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_WMIOBJECTBROKERREGISTRATION)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CWMIObjectBrokerRegistration)
	COM_INTERFACE_ENTRY(IWMIObjectBrokerRegistration)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IObjectWithSite)
END_COM_MAP()

// IWMIObjectBrokerRegistration
public:
	STDMETHOD(UnRegister)(/*[in]*/ BSTR strProgId, /*[out, retval]*/ VARIANT_BOOL *bResult);
	STDMETHOD(Register)(/*[in]*/ BSTR strProgId, /*[out, retval]*/ VARIANT_BOOL *bResult);
};

#endif //__WMIOBJECTBROKERREGISTRATION_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vc7\beta1\system\wbem\wmiscriptutils\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__ABA61DCB_4742_4DAE_987B_18620A19CDB1__INCLUDED_)
#define AFX_STDAFX_H__ABA61DCB_4742_4DAE_987B_18620A19CDB1__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlctl.h>

#include <comdef.h>
#include <exdisp.h>
#include <shlobj.h>
#include <mshtml.h>


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__ABA61DCB_4742_4DAE_987B_18620A19CDB1__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vc7\beta1\system\wbem\wmiscriptutils\wmiobjectbroker.cpp ===
// WMIObjectBroker.cpp : Implementation of CWMIObjectBroker

#include "stdafx.h"
#include "WMIScriptUtils.h"
#include "WMIObjectBroker.h"
#include "CommonFuncs.h"

/////////////////////////////////////////////////////////////////////////////
// CWMIObjectBroker



STDMETHODIMP CWMIObjectBroker::CreateObject(BSTR strProgId, IDispatch **obj)
{
	HRESULT hr = E_FAIL;
	CLSID clsid;
	IUnknown *pUnk = NULL;
	__try
	{
		BOOL fSafetyEnabled = TRUE;

		// TODO: Do we want this check to enable us to work from WSH?

		// BUG in IE/JScript/VBScript: We should be checking to see if 
		// m_dwCurrentSafety != INTERFACE_USES_SECURITY_MANAGER, but current
		// IE/JScript/VBScript versions do not call SetInterfaceSafetyOptions
		// with anything but INTERFACESAFE_FOR_UNTRUSTED_CALLER

		// If we are run though CScript.exe or WScript.exe, we will never be
		// asked to set safety options through SetInterfaceSafetyOptions.  In
		// addition, there will not be an InternetHostSecurityManager available
		// through our 'site'.  In this case, we allow any object to be created.
		if(m_dwCurrentSafety == 0 && !IsInternetHostSecurityManagerAvailable(GetUnknown()))
			fSafetyEnabled = FALSE;

		// We can override the safety check if this insance of the 'broker'
		// control is allowed to create the object specified by strProbId
		if(fSafetyEnabled && SUCCEEDED(IsCreateObjectAllowed(GetUnknown(), strProgId, NULL)))
			fSafetyEnabled = FALSE;

		// Convert the ProgId to a CLSID
		if(FAILED(hr = CLSIDFromProgID(strProgId, &clsid)))
			__leave;

		// Create the requested object
#if 0
		if(FAILED(hr = CoCreateInstance(clsid, NULL, CLSCTX_INPROC_SERVER, IID_IUnknown, (void**)&pUnk)))
			__leave;
#endif
		if(FAILED(hr = SafeCreateObject(GetUnknown(),fSafetyEnabled, clsid, &pUnk)))
			__leave;

		// Get the IDispatch for the caller
		hr = pUnk->QueryInterface(IID_IDispatch, (void**)obj);
	}
	__finally
	{
		if(pUnk)
			pUnk->Release();
	}
	return hr;
}

STDMETHODIMP CWMIObjectBroker::CanCreateObject(BSTR strProgId, VARIANT_BOOL *bResult)
{
	*bResult = VARIANT_FALSE;
	if(SUCCEEDED(IsCreateObjectAllowed(GetUnknown(), strProgId, NULL)))
		*bResult = VARIANT_TRUE;
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vc7\beta1\system\wbem\wmiscriptutils\wmiobjectbroker.h ===
// WMIObjectBroker.h : Declaration of the CWMIObjectBroker

#ifndef __WMIOBJECTBROKER_H_
#define __WMIOBJECTBROKER_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CWMIObjectBroker
class ATL_NO_VTABLE CWMIObjectBroker : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CWMIObjectBroker, &CLSID_WMIObjectBroker>,
	public IDispatchImpl<IWMIObjectBroker, &IID_IWMIObjectBroker, &LIBID_WMISCRIPTUTILSLib>,
	public IObjectSafetyImpl<CWMIObjectBroker, INTERFACESAFE_FOR_UNTRUSTED_CALLER|INTERFACESAFE_FOR_UNTRUSTED_DATA|INTERFACE_USES_SECURITY_MANAGER>,
	public IObjectWithSiteImpl<CWMIObjectBroker>
{
public:
	CWMIObjectBroker()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_WMIOBJECTBROKER)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CWMIObjectBroker)
	COM_INTERFACE_ENTRY(IWMIObjectBroker)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IObjectSafety)
	COM_INTERFACE_ENTRY(IObjectWithSite)
END_COM_MAP()

// IWMIObjectBroker
public:
	STDMETHOD(CanCreateObject)(/*[in]*/ BSTR strProgId, /*[out, retval]*/ VARIANT_BOOL *bResult);
	STDMETHOD(CreateObject)(BSTR strProgId, IDispatch **obj);
};

#endif //__WMIOBJECTBROKER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vc7\beta1\atlmfc\include\atlwmiprov.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-2000 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLWMIPROV_H__
#define __ATLWMIPROV_H__

#pragma once

#ifndef __cplusplus
	#error requires C++ compilation (use a .cpp suffix)
#endif

#ifndef __wbemprov_h__
	#include <wbemprov.h>
#endif

#ifndef __wmiutils_h__
	#include <wmiutils.h>
#endif

namespace ATL
{

class ATL_NO_VTABLE IWbemInstProviderImpl : public IWbemServices,
											public IWbemProviderInit
	
{
public:

        //IWbemServices  

	    HRESULT STDMETHODCALLTYPE OpenNamespace( 
            /* [in] */ const BSTR Namespace,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult) {return WBEM_E_NOT_SUPPORTED;};
        
/*?*/   HRESULT STDMETHODCALLTYPE CancelAsyncCall( 
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink) {return WBEM_E_NOT_SUPPORTED;};
        
/*?*/   HRESULT STDMETHODCALLTYPE QueryObjectSink( 
            /* [in] */ long lFlags,
            /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE GetObject( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
        
        
        HRESULT STDMETHODCALLTYPE PutClass( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE PutClassAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE DeleteClass( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE DeleteClassAsync( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CreateClassEnum( 
            /* [in] */ const BSTR Superclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CreateClassEnumAsync( 
            /* [in] */ const BSTR Superclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE PutInstance( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
        
        
        HRESULT STDMETHODCALLTYPE DeleteInstance( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
        
        
        HRESULT STDMETHODCALLTYPE CreateInstanceEnum( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
        
        
        HRESULT STDMETHODCALLTYPE ExecQuery( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE ExecNotificationQuery( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE ExecMethod( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ const BSTR strMethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppOutParams,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE ExecMethodAsync( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ const BSTR strMethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};

};


class CProviderHelper
{	
private:
		CComPtr<IWbemClassObject> m_pErrorObject;

public:
		//Construction:
		CProviderHelper(IWbemServices * pNamespace,
							IWbemContext *pCtx)
		{
			if (NULL == pNamespace || NULL == pCtx)
			{
				ATLASSERT (0);
				return;
			}
			
			HRESULT hr = pNamespace->GetObject(CComBSTR(L"__ExtendedStatus"), 
								 0, 
								 pCtx, 
								 &m_pErrorObject, 
								 NULL);
		}

		virtual ~CProviderHelper()
		{
		}	

		HRESULT STDMETHODCALLTYPE ConstructErrorObject (
										/*in*/const ULONG ulStatusCode,
										/*in*/const BSTR bstrDescription,
										/*in*/const BSTR bstrOperation,
										/*in*/const BSTR bstrParameter,
										/*in*/const BSTR bstrProviderName,
										/*out*/IWbemClassObject ** ppErrorObject)
		{
			if (IsBadWritePtr(ppErrorObject, sizeof(IWbemClassObject *)))
			{
				ATLASSERT (0);
				return WBEM_E_INVALID_PARAMETER;
			}
			
			if (m_pErrorObject == NULL)
			{
				return WBEM_E_FAILED;
			}

			HRESULT hr = m_pErrorObject->SpawnInstance(0, ppErrorObject);
			if(FAILED(hr))
			{
			    return hr;
			}

			CComVariant var;

			var.ChangeType(VT_I4);
			var.lVal = ulStatusCode;
			(*ppErrorObject)->Put(CComBSTR(L"StatusCode"), 0, &var, 0);

			var.ChangeType(VT_BSTR);
			var.bstrVal = bstrDescription;
			(*ppErrorObject)->Put(CComBSTR(L"Description"), 0, &var, 0);

			var.bstrVal = bstrOperation;
			(*ppErrorObject)->Put(CComBSTR(L"Operation"), 0, &var, 0);

			var.bstrVal = bstrParameter;
			(*ppErrorObject)->Put(CComBSTR(L"ParameterInfo"), 0, &var, 0);

			var.bstrVal = bstrProviderName;
			(*ppErrorObject)->Put(CComBSTR(L"ProviderName"), 0, &var, 0);
			
			return WBEM_S_NO_ERROR;
		}
};

class CIntrinsicEventProviderHelper : public CProviderHelper
{
private:
	CComPtr<IWbemClassObject> m_pCreationEventClass;
	CComPtr<IWbemClassObject> m_pDeletionEventClass;
	CComPtr<IWbemClassObject> m_pModificationEventClass;

public:

	//Construction
	CIntrinsicEventProviderHelper( IWbemServices * pNamespace, IWbemContext * pCtx)
				: CProviderHelper ( pNamespace, pCtx)
	{

		if (NULL == pNamespace || NULL == pCtx)
		{
			ATLASSERT (0);
			return;
		}		
		
		HRESULT hr = pNamespace->GetObject(CComBSTR(L"__InstanceCreationEvent"), 
								 0, 
								 pCtx, 
								 &m_pCreationEventClass, 
								 NULL);
		if (FAILED(hr)) 
		{
			m_pCreationEventClass = NULL;
			return;
		}
		
		hr = pNamespace->GetObject(CComBSTR(L"__InstanceModificationEvent"), 
									 0, 
									 pCtx, //passing IWbemContext pointer to prevent deadlocks
									 &m_pModificationEventClass, 
									 NULL);
		if (FAILED(hr)) 
		{
			m_pModificationEventClass = NULL;
			return;
		}
		
		hr = pNamespace->GetObject(CComBSTR(L"__InstanceDeletionEvent"), 
										 0, 
										 pCtx, //passing IWbemContext pointer to prevent deadlocks
										 &m_pDeletionEventClass, 
										 NULL);
			
		if (FAILED(hr)) 
		{
			m_pDeletionEventClass = NULL;
			return;
		}

	}


	virtual ~CIntrinsicEventProviderHelper()
	{
	}

	HRESULT STDMETHODCALLTYPE FireCreationEvent(
											/*in*/IWbemClassObject * pNewInstance,
											/*in*/IWbemObjectSink * pSink )
	{
		if (pNewInstance == NULL || pSink == NULL)
		{
			ATLASSERT (0);		
			return WBEM_E_INVALID_PARAMETER;
		}

		if (m_pCreationEventClass == NULL)
		{
			return WBEM_E_FAILED;
		}
		
		CComPtr<IWbemClassObject> pEvtInstance;
	    HRESULT hr = m_pCreationEventClass->SpawnInstance(0, &pEvtInstance);
	    if(FAILED(hr))
		{
	        return hr;
		}
		
		CComVariant var;
		var.ChangeType(VT_UNKNOWN);	
		CComQIPtr<IUnknown, &IID_IUnknown>pTemp(pNewInstance);
		var = pTemp;
		hr = pEvtInstance->Put(CComBSTR(L"TargetInstance"), 0, &var, 0);
		if(FAILED(hr))
		{
	        return hr;
		}

		hr = pSink->Indicate(1, &pEvtInstance );

		return hr;
	}


	HRESULT STDMETHODCALLTYPE FireDeletionEvent(
									/*in*/IWbemClassObject * pInstanceToDelete,
									/*in*/IWbemObjectSink * pSink )
	{
		if (pInstanceToDelete == NULL || pSink == NULL)
		{
			ATLASSERT (0);		
			return WBEM_E_INVALID_PARAMETER;
		}

		if (m_pDeletionEventClass == NULL)
		{
			return WBEM_E_FAILED;
		}

		CComPtr<IWbemClassObject> pEvtInstance;
	    HRESULT hr = m_pDeletionEventClass->SpawnInstance(0, &pEvtInstance);
	    if(FAILED(hr))
		{
	        return hr;
		}
		CComVariant var;
		var.ChangeType(VT_UNKNOWN);	
		CComQIPtr<IUnknown, &IID_IUnknown>pTemp(pInstanceToDelete);
		var = pTemp;

		hr = pEvtInstance->Put(CComBSTR(L"TargetInstance"), 0, &var, 0);
		if(FAILED(hr))
		{
	        return hr;
		}

		hr = pSink->Indicate(1, &pEvtInstance);
		
		return hr;
	}


	HRESULT STDMETHODCALLTYPE FireModificationEvent(
													/*in*/IWbemClassObject * pOldInstance,
													/*in*/IWbemClassObject * pNewInstance,
													/*in*/IWbemObjectSink * pSink )
	{
		if (pOldInstance == NULL || pNewInstance == NULL || pSink == NULL)
		{
			ATLASSERT (0);		
			return WBEM_E_INVALID_PARAMETER;
		}
		
		if (m_pModificationEventClass == NULL)
		{
			return WBEM_E_FAILED;
		}
				
		CComPtr<IWbemClassObject> pEvtInstance;
	    HRESULT hr = m_pModificationEventClass->SpawnInstance(0, &pEvtInstance);
	    if(FAILED(hr))
		{
	        return hr;
		}
		CComVariant var;
		var.ChangeType(VT_UNKNOWN);

		CComQIPtr<IUnknown, &IID_IUnknown>pTempNew(pNewInstance);
		var = pTempNew;
		hr = pEvtInstance->Put(CComBSTR(L"TargetInstance"), 0, &var, 0);
		var.Clear();

		if (FAILED(hr)) 
		{		
			return hr;
		}
		
		CComQIPtr<IUnknown, &IID_IUnknown>pTempOld(pOldInstance);
		var = pTempOld;
		hr = pEvtInstance->Put(CComBSTR(L"PreviousInstance"), 0, &var, 0);
		if (FAILED(hr)) 
		{		
			return hr;
		}
		
		hr = pSink->Indicate(1, &pEvtInstance );

		return hr;
	}

};

class CInstanceProviderHelper : public CProviderHelper
{

public:

	CInstanceProviderHelper (IWbemServices * pNamespace, IWbemContext *pCtx)
				: CProviderHelper ( pNamespace, pCtx)
	{
	}

	virtual ~CInstanceProviderHelper()
	{
	}
	
	HRESULT STDMETHODCALLTYPE CheckInstancePath (
								/*[in]*/ IClassFactory * pParserFactory,	//pointer to path parser class factory
								/*[in]*/ const BSTR ObjectPath,	//object path string
								/*[in]*/ const BSTR ClassName,	//name of WMI class whose instances are provided
								/*[in]*/ ULONG ulTest)			//flags from WMI_PATH_STATUS_FLAG (defined in wmiutils.h)
	{	

		if (pParserFactory == NULL)
		{
			ATLASSERT (0);		
			return WBEM_E_INVALID_PARAMETER;
		}
		
		//Create path parser object
		CComPtr<IWbemPath>pPath;
		HRESULT hr = pParserFactory->CreateInstance(NULL,
											IID_IWbemPath,
											(void **) &pPath);
		if (FAILED(hr))
		{
			return WBEM_E_INVALID_PARAMETER;
		}

		hr = pPath->SetText(WBEMPATH_CREATE_ACCEPT_ALL,
									ObjectPath);
	 	//check that the class requested is the class provided
		long nPathLen = CComBSTR(ObjectPath).Length();
		
		unsigned long ulBufLen = nPathLen + 1;
		WCHAR * wClass = new WCHAR[nPathLen];
		if (NULL == wClass)
		{
			delete[] wClass;
			return WBEM_E_OUT_OF_MEMORY;
		}
		pPath->GetClassName(&ulBufLen, wClass);

		if ( _wcsicmp(ClassName, wClass))
		{
			delete[] wClass;
			return WBEM_E_FAILED;
		}
		
		delete[] wClass;
	  	
		//check that the path reflects the object type
		unsigned __int64 ulPathInfo;
		pPath->GetInfo(0L, &ulPathInfo);
		if (!(ulPathInfo & ulTest))
		{
			return WBEM_E_FAILED;
		}	
		
		return WBEM_S_NO_ERROR;		
	}

};


//IWbemPullClassProviderImpl class 

template <class T>
class ATL_NO_VTABLE IWbemPullClassProviderImpl : public IWbemServices,
												 public IWbemProviderInit
{
	public:


        //IWbemServices  

        virtual HRESULT STDMETHODCALLTYPE OpenNamespace( 
            /* [in] */ const BSTR strNamespace,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult){return WBEM_E_NOT_SUPPORTED;};
        
        virtual HRESULT STDMETHODCALLTYPE CancelAsyncCall( 
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink){return WBEM_E_NOT_SUPPORTED;};
        
        virtual HRESULT STDMETHODCALLTYPE QueryObjectSink( 
            /* [in] */ long lFlags,
            /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        virtual HRESULT STDMETHODCALLTYPE GetObject( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
        
        
        virtual HRESULT STDMETHODCALLTYPE PutClass( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult){return WBEM_E_NOT_SUPPORTED;};
        
        
        virtual HRESULT STDMETHODCALLTYPE DeleteClass( 
            /* [in] */ const BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult){return WBEM_E_NOT_SUPPORTED;};
        
        
        virtual HRESULT STDMETHODCALLTYPE CreateClassEnum( 
            /* [in] */ const BSTR strSuperclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
        
        
        virtual HRESULT STDMETHODCALLTYPE PutInstance( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult){return WBEM_E_NOT_SUPPORTED;};
        
        virtual HRESULT STDMETHODCALLTYPE PutInstanceAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        virtual HRESULT STDMETHODCALLTYPE DeleteInstance( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult){return WBEM_E_NOT_SUPPORTED;};
        
        virtual HRESULT STDMETHODCALLTYPE DeleteInstanceAsync( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler){return WBEM_E_NOT_SUPPORTED;};
        
        virtual HRESULT STDMETHODCALLTYPE CreateInstanceEnum( 
            /* [in] */ const BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
        
        virtual HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync( 
            /* [in] */ const BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        virtual HRESULT STDMETHODCALLTYPE ExecQuery( 
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
        
        
        virtual HRESULT STDMETHODCALLTYPE ExecNotificationQuery( 
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
        
        virtual HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync( 
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        virtual HRESULT STDMETHODCALLTYPE ExecMethod( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ const BSTR strMethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppOutParams,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
        
        virtual HRESULT STDMETHODCALLTYPE ExecMethodAsync( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ const BSTR strMethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        

};


}		//namespace ATL

#endif 	//__ATLWMIPROV_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vc7\beta1\system\wbem\wmiscriptutils\wmiobjectbrokerregistration.cpp ===
// WMIObjectBrokerRegistration.cpp : Implementation of CWMIObjectBrokerRegistration
#include "stdafx.h"
#include "WMIScriptUtils.h"
#include "WMIObjectBrokerRegistration.h"
#include "CommonFuncs.h"

/////////////////////////////////////////////////////////////////////////////
// CWMIObjectBrokerRegistration


STDMETHODIMP CWMIObjectBrokerRegistration::Register(BSTR strProgId, VARIANT_BOOL *bResult)
{
	*bResult = VARIANT_FALSE;
	if(SUCCEEDED(RegisterCurrentDoc(GetUnknown(), strProgId)))
		*bResult = VARIANT_TRUE;
	return S_OK;
}

STDMETHODIMP CWMIObjectBrokerRegistration::UnRegister(BSTR strProgId, VARIANT_BOOL *bResult)
{
	*bResult = VARIANT_FALSE;
	if(SUCCEEDED(UnRegisterCurrentDoc(GetUnknown(), strProgId)))
		*bResult = VARIANT_TRUE;
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vc7\beta1\system\wbem\wmiscriptutils\wmiobjectbrokerregistration.h ===
// WMIObjectBrokerRegistration.h : Declaration of the CWMIObjectBrokerRegistration

#ifndef __WMIOBJECTBROKERREGISTRATION_H_
#define __WMIOBJECTBROKERREGISTRATION_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CWMIObjectBrokerRegistration
class ATL_NO_VTABLE CWMIObjectBrokerRegistration : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CWMIObjectBrokerRegistration, &CLSID_WMIObjectBrokerRegistration>,
	public IDispatchImpl<IWMIObjectBrokerRegistration, &IID_IWMIObjectBrokerRegistration, &LIBID_WMISCRIPTUTILSLib>,
	public IObjectWithSiteImpl<CWMIObjectBrokerRegistration>
{
public:
	CWMIObjectBrokerRegistration()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_WMIOBJECTBROKERREGISTRATION)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CWMIObjectBrokerRegistration)
	COM_INTERFACE_ENTRY(IWMIObjectBrokerRegistration)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IObjectWithSite)
END_COM_MAP()

// IWMIObjectBrokerRegistration
public:
	STDMETHOD(UnRegister)(/*[in]*/ BSTR strProgId, /*[out, retval]*/ VARIANT_BOOL *bResult);
	STDMETHOD(Register)(/*[in]*/ BSTR strProgId, /*[out, retval]*/ VARIANT_BOOL *bResult);
};

#endif //__WMIOBJECTBROKERREGISTRATION_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vc7\beta1\system\wbem\wmiscriptutils\wmiscriptutils.cpp ===
// WMIScriptUtils.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f WMIScriptUtilsps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "WMIScriptUtils.h"

#include "WMIScriptUtils_i.c"
#include "WMIObjectBroker.h"
#include "WMIObjectBrokerRegistration.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_WMIObjectBroker, CWMIObjectBroker)
OBJECT_ENTRY(CLSID_WMIObjectBrokerRegistration, CWMIObjectBrokerRegistration)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_WMISCRIPTUTILSLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vc7\beta1\vcwiz\classwiz\atl\event\templates\1033\wmiprov.cpp ===
// [!output IMPL_FILE] : Implementation of [!output CLASS_NAME]
#include "stdafx.h"
#include "[!output PROJECT_NAME].h"
#include "[!output HEADER_FILE]"


/////////////////////////////////////////////////////////////////////////////
// [!output CLASS_NAME]

// IMPORTANT: the strings defined below are not localizable

// Class name
[!if CLASS_SPECIFIED]
const static WCHAR * s_pMyClassName = L"[!output WMICLASSNAME]"; 
[!if EXTRINSIC]
//properties of the event class [!output WMICLASSNAME]:
[!output EXTR_PROPERTY_DEFINITIONS]
[!endif]
[!else]
//TODO: define provided class name, e.g.:
const static WCHAR * s_pMyClassName = L"MyClassName"; 
[!endif]


//////////////////////////////////////////////////////////////////////////////
// [!output CLASS_NAME]::Initialize()
// Refer to MSDN documentation for IWbemProviderInit::Initialize()
// for details about implementing this method

STDMETHODIMP [!output CLASS_NAME]::Initialize(LPWSTR pszUser,	
									  LONG lFlags,
									  LPWSTR pszNamespace,
									  LPWSTR pszLocale,
									  IWbemServices *pNamespace,
									  IWbemContext *pCtx,
																																							IWbemProviderInitSink *pInitSink) 
{
	
	HRESULT hr = WBEM_E_FAILED;
	if ( NULL == pNamespace || NULL == pInitSink) 
	{
        return WBEM_E_INVALID_PARAMETER;
	}

	//cache IWbemServices pointer 
	//Note: m_pNamespace is a smart pointer, so it AddRef()'s automatically
	m_pNamespace = pNamespace;
					
	[!if INTRINSIC]	
	//get helper object
	m_pHelper = new CIntrinsicEventProviderHelper(pNamespace, pCtx);

	[!endif]
	
	[!if EXTRINSIC]	
	//store event class definition				
	//NOTE: the code below assumes that your event class definition doesn't change while
	//your provider is running.  If this is not true, you should implement a consumer
	//for class modification ans class deletion events. Refer to WMI documentation
	//for event consumers on MSDN.
	hr = m_pNamespace->GetObject(CComBSTR(s_pMyClassName), 
								0, 
								pCtx, //passing IWbemContext pointer to prevent deadlocks
								&m_pEventClass, 
								NULL);

    if(FAILED(hr))
	{
        return hr;
	}

	//get helper object
	m_pHelper = new CProviderHelper(pNamespace, pCtx);

    [!endif]
	[!if INTRINSIC]
	//store target class definition
	hr = m_pNamespace->GetObject(CComBSTR(s_pMyClassName), 
								 0, 
								 pCtx, //passing IWbemContext pointer to prevent deadlocks
								 &m_pDataClass, 
								 NULL);
    if(FAILED(hr))
	{
        return hr;
	}
	[!endif]
	    
    pInitSink->SetStatus(WBEM_S_INITIALIZED,0);
    return WBEM_S_NO_ERROR;
}


//////////////////////////////////////////////////////////////////////////////
// [!output CLASS_NAME]::ProvideEvents()
// Refer to MSDN documentation for  IWbemEventProvider::ProvideEvents()
// for details about implementing this method
	
STDMETHODIMP [!output CLASS_NAME]::ProvideEvents(
							IWbemObjectSink *pSink,
							long lFlags)
{
	//	WMI calls this method to activate the event provider. 
	//  TODO: after you return from this call, start delivering the events as 
	//  they occur to the provided sink interface.You may want to create an independent thread
	//	to handle the event delivery.
	[!if INTRINSIC]
	//  To deliver intrinsic events, invoke FireCreationEvent(), FireDeletionEvent() and
	//  FireModificationEvent() methods on m_pHelper.  
	[!endif]
	//  To report a detailed error or status to WMI, you can call ConstructErrorObject() on m_pHelper. 
	
	//  IMPORTANT: do not block this call for more than a few seconds.

	if ( NULL == pSink )
	{
		return WBEM_E_INVALID_PARAMETER;
	}

	//cache sink pointer
	//Note: m_pSink is a smart pointer, so it AddRef()'s automatically
	m_pSink = pSink;
	
	pSink->SetStatus(0, WBEM_S_NO_ERROR, NULL, NULL);	
	return WBEM_S_NO_ERROR;
}

[!if EVENT_SECURITY ]

//////////////////////////////////////////////////////////////////////////////
// [!output CLASS_NAME]::AccessCheck()
// Refer to MSDN documentation for  IWbemEventProviderSecurity::AccessCheck()
// for details about implementing this method

STDMETHODIMP [!output CLASS_NAME]::AccessCheck(
						WBEM_CWSTR wszQueryLanguage,
						WBEM_CWSTR wszQuery,
						long lSidLength,
						const BYTE* pSid)
{
	return WBEM_S_NO_ERROR;
}
[!endif]

[!if QUERY_SINK ]

//////////////////////////////////////////////////////////////////////////////
// [!output CLASS_NAME]::CancelQuery()
// Refer to MSDN documentation for  IWbemEventProviderQuerySink::CancelQuery()
// for details about implementing this method

STDMETHODIMP [!output CLASS_NAME]::CancelQuery(
						unsigned long dwId)
{
	return WBEM_S_NO_ERROR;
}


//////////////////////////////////////////////////////////////////////////////
// [!output CLASS_NAME]::NewQuery()
// Refer to MSDN documentation for  IWbemEventProviderQuerySink::NewQuery()
// for details about implementing this method

STDMETHODIMP [!output CLASS_NAME]::NewQuery(
						unsigned long dwId,
						WBEM_WSTR wszQueryLanguage,
						WBEM_WSTR wszQuery)
{
	return WBEM_S_NO_ERROR;
}
[!endif]

[!if EXTRINSIC]	
//////////////////////////////////////////////////////////////////////////////
// [!output CLASS_NAME]::FireEvent()

STDMETHODIMP [!output CLASS_NAME]::FireEvent()
{
	//OPTIMIZATION NOTE: the implementation generated by the wizard is straightforward, 
	//but if you are delivering more than 1000 events per second, you would want to use 
	//IWbemObjectAccess interface to fill the event properties. You also want to 
	//consider caching an instance of the event class and re-using it.

	ATLASSERT(m_pEventClass);

	CComPtr<IWbemClassObject> pEvtInstance;
    HRESULT hr = m_pEventClass->SpawnInstance(0, &pEvtInstance);
    if(FAILED(hr))
	{
		return hr;
	}

	//Fill property values of the event object:
	[!if CLASS_SPECIFIED]
    [!output EXTRINSIC_PUT_BLOCK]
	[!else]
	//TODO: modify commented code below to fill the event property values
	//CComVariant var;
	//var.ChangeType(<type>);	//put appropriate vatiant type here
	//var = <value>;			//put appropriate value here
	//hr = pEvtInstance->Put(CComBSTR(L"EventProperty1"), 0, &var, 0);
	//var.Clear();
	[!endif]

	hr = m_pSink->Indicate(1, &pEvtInstance );

	return hr;
}
[!endif]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vc7\beta1\vcwiz\classwiz\atl\event\templates\1033\wmiprov.h ===
[!if !EVENT]
//error: event provider header template invoked for wrong type of provider
[!else]
// [!output HEADER_FILE] : Declaration of the [!output CLASS_NAME]

#pragma once
#include "resource.h"       // main symbols
#include <wbemidl.h>
#include <atlwmiprov.h>


extern const WCHAR * s_pMyClassName;	//class name

[!if EXTRINSIC]
[!output EXTR_PROPERTY_DECLARATIONS]
[!endif]

/////////////////////////////////////////////////////////////////////////////
// [!output CLASS_NAME]

[!if ATTRIBUTED]
[
	coclass,
[!if THREADING_BOTH]
	threading("both"),
[!endif]
[!if THREADING_FREE]
	threading("free"),
[!endif]
	aggregatable("never"),
	vi_progid("[!output VERSION_INDEPENDENT_PROGID]"),
	progid("[!output PROGID]"),
	version(1.0),
	uuid("[!output CLSID_REGISTRY_FORMAT]"),
	helpstring("[!output TYPE_NAME]")
]
[!endif]

class ATL_NO_VTABLE [!output CLASS_NAME] : 
						[!if !ATTRIBUTED]
						[!if THREADING_BOTH]
							public CComObjectRootEx<CComMultiThreadModel>,
						[!endif]
						[!if THREADING_FREE]
							public CComObjectRootEx<CComMultiThreadModel>,
						[!endif]
						public CComCoClass<[!output CLASS_NAME], &CLSID_[!output COCLASS]>,
						[!endif]
						[!if EVENT_SECURITY]
							public IWbemEventProviderSecurity,
						[!endif]
						[!if QUERY_SINK]
							public IWbemEventProviderQuerySink,
						[!endif]
							public IWbemProviderInit,
							public IWbemEventProvider
{
	CComPtr<IWbemServices>  m_pNamespace;	//cached IWbemServices pointer
	CComPtr<IWbemObjectSink> m_pSink;			//cached event sink pointer

	[!if INTRINSIC]	
	CComPtr<IWbemClassObject> m_pDataClass;		//cached definition of the class for which events are fired

	CIntrinsicEventProviderHelper * m_pHelper;	//pointer to helper class object
	[!else]
    CComPtr<IWbemClassObject> m_pEventClass;	//cached event class definition pointer
	
	CProviderHelper * m_pHelper;
  
	STDMETHODIMP FireEvent();
	[!endif]	

public:
    [!output CLASS_NAME]()
	{
		m_pHelper = NULL;		
	}
	
	~[!output CLASS_NAME]()
	{
	    if (NULL != m_pHelper)
		{
			delete m_pHelper;
		}
		//NOTE: interface pointer data members are smart and get released automatically
	}

	[!if !ATTRIBUTED]
	DECLARE_REGISTRY_RESOURCEID(IDR_[!output UPPER_SHORT_NAME])

	DECLARE_NOT_AGGREGATABLE([!output CLASS_NAME])

	BEGIN_COM_MAP([!output CLASS_NAME])
		COM_INTERFACE_ENTRY(IWbemEventProvider)
		[!if EVENT_SECURITY ]
		COM_INTERFACE_ENTRY(IWbemEventProviderSecurity)
		[!endif]
		[!if QUERY_SINK ]
		COM_INTERFACE_ENTRY(IWbemEventProviderQuerySink)
		[!endif]	
		COM_INTERFACE_ENTRY(IWbemProviderInit)
	END_COM_MAP()
	[!endif]


	//IWbemProviderInit
	HRESULT STDMETHODCALLTYPE Initialize( LPWSTR pszUser,
						  LONG lFlags,
						  LPWSTR pszNamespace,
						  LPWSTR pszLocale,
						  IWbemServices *pNamespace,
						  IWbemContext *pCtx,
						  IWbemProviderInitSink *pInitSink);

	//IWbemEventProvider
	HRESULT STDMETHODCALLTYPE ProvideEvents(
							IWbemObjectSink *pSink,
							long lFlags);


	[!if EVENT_SECURITY ]
	//IWbemEventProviderSecurity
	HRESULT STDMETHODCALLTYPE AccessCheck(
							WBEM_CWSTR wszQueryLanguage,
							WBEM_CWSTR wszQuery,
							long lSidLength,
							const BYTE* pSid
	);
	[!endif]

	[!if QUERY_SINK ]
	//IWbemEventProviderQuerySink
	HRESULT STDMETHODCALLTYPE CancelQuery(
	  unsigned long dwId
	);

	HRESULT STDMETHODCALLTYPE NewQuery(
	  unsigned long dwId,
	  WBEM_WSTR wszQueryLanguage,
	  WBEM_WSTR wszQuery
	);
	[!endif]

};

[!if !ATTRIBUTED]
OBJECT_ENTRY_AUTO(__uuidof([!output COCLASS]), [!output CLASS_NAME])
[!endif]

[!endif]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vc7\atlmfc\include\wmiatlprov.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-2000 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLWMIPROV_H__
#define __ATLWMIPROV_H__

#pragma once

#ifndef __cplusplus
	#error requires C++ compilation (use a .cpp suffix)
#endif

#ifndef __wbemprov_h__
	#include <wbemprov.h>
#endif

#ifndef __wmiutils_h__
	#include <wmiutils.h>
#endif

namespace ATL
{

class ATL_NO_VTABLE IWbemInstProviderImpl : public IWbemServices,
											public IWbemProviderInit
	
{
public:

        //IWbemServices  

	    HRESULT STDMETHODCALLTYPE OpenNamespace( 
            /* [in] */ const BSTR Namespace,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult) {return WBEM_E_NOT_SUPPORTED;};
        
/*?*/   HRESULT STDMETHODCALLTYPE CancelAsyncCall( 
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink) {return WBEM_E_NOT_SUPPORTED;};
        
/*?*/   HRESULT STDMETHODCALLTYPE QueryObjectSink( 
            /* [in] */ long lFlags,
            /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE GetObject( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
        
        
        HRESULT STDMETHODCALLTYPE PutClass( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE PutClassAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE DeleteClass( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE DeleteClassAsync( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CreateClassEnum( 
            /* [in] */ const BSTR Superclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CreateClassEnumAsync( 
            /* [in] */ const BSTR Superclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE PutInstance( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
        
        
        HRESULT STDMETHODCALLTYPE DeleteInstance( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
        
        
        HRESULT STDMETHODCALLTYPE CreateInstanceEnum( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
        
        
        HRESULT STDMETHODCALLTYPE ExecQuery( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE ExecNotificationQuery( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE ExecMethod( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ const BSTR strMethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppOutParams,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE ExecMethodAsync( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ const BSTR strMethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};

};


class CProviderHelper
{	
private:
		CComPtr<IWbemClassObject> m_pErrorObject;

public:
		//Construction:
		CProviderHelper(IWbemServices * pNamespace, IWbemContext *pCtx)
		{
			if (NULL == pNamespace)
			{
				ATLASSERT (0);
				return;
			}
			
			HRESULT hr = pNamespace->GetObject(CComBSTR(L"__ExtendedStatus"), 
								 0, 
								 pCtx, 
								 &m_pErrorObject, 
								 NULL);
		}

		virtual ~CProviderHelper()
		{
		}	

		HRESULT STDMETHODCALLTYPE ConstructErrorObject (
										/*in*/const ULONG ulStatusCode,
										/*in*/const BSTR bstrDescription,
										/*in*/const BSTR bstrOperation,
										/*in*/const BSTR bstrParameter,
										/*in*/const BSTR bstrProviderName,
										/*out*/IWbemClassObject ** ppErrorObject)
		{
			if (IsBadWritePtr(ppErrorObject, sizeof(IWbemClassObject *)))
			{
				ATLASSERT (0);
				return WBEM_E_INVALID_PARAMETER;
			}
			
			if (m_pErrorObject == NULL)
			{
				return WBEM_E_FAILED;
			}

			HRESULT hr = m_pErrorObject->SpawnInstance(0, ppErrorObject);
			if(FAILED(hr))
			{
			    return hr;
			}

			CComVariant var;

			var.ChangeType(VT_I4);
			var.lVal = ulStatusCode;
			(*ppErrorObject)->Put(CComBSTR(L"StatusCode"), 0, &var, 0);

			var.ChangeType(VT_BSTR);
			var.bstrVal = bstrDescription;
			(*ppErrorObject)->Put(CComBSTR(L"Description"), 0, &var, 0);

			var.bstrVal = bstrOperation;
			(*ppErrorObject)->Put(CComBSTR(L"Operation"), 0, &var, 0);

			var.bstrVal = bstrParameter;
			(*ppErrorObject)->Put(CComBSTR(L"ParameterInfo"), 0, &var, 0);

			var.bstrVal = bstrProviderName;
			(*ppErrorObject)->Put(CComBSTR(L"ProviderName"), 0, &var, 0);
			
			return WBEM_S_NO_ERROR;
		}
};

class CIntrinsicEventProviderHelper : public CProviderHelper
{
private:
	CComPtr<IWbemClassObject> m_pCreationEventClass;
	CComPtr<IWbemClassObject> m_pDeletionEventClass;
	CComPtr<IWbemClassObject> m_pModificationEventClass;

public:

	//Construction
	CIntrinsicEventProviderHelper( IWbemServices * pNamespace, IWbemContext * pCtx)
				: CProviderHelper ( pNamespace, pCtx)
	{

		if (NULL == pNamespace || NULL == pCtx)
		{
			ATLASSERT (0);
			return;
		}		
		
		HRESULT hr = pNamespace->GetObject(CComBSTR(L"__InstanceCreationEvent"), 
								 0, 
								 pCtx, 
								 &m_pCreationEventClass, 
								 NULL);
		if (FAILED(hr)) 
		{
			m_pCreationEventClass = NULL;
			return;
		}
		
		hr = pNamespace->GetObject(CComBSTR(L"__InstanceModificationEvent"), 
									 0, 
									 pCtx, //passing IWbemContext pointer to prevent deadlocks
									 &m_pModificationEventClass, 
									 NULL);
		if (FAILED(hr)) 
		{
			m_pModificationEventClass = NULL;
			return;
		}
		
		hr = pNamespace->GetObject(CComBSTR(L"__InstanceDeletionEvent"), 
										 0, 
										 pCtx, //passing IWbemContext pointer to prevent deadlocks
										 &m_pDeletionEventClass, 
										 NULL);
			
		if (FAILED(hr)) 
		{
			m_pDeletionEventClass = NULL;
			return;
		}

	}


	virtual ~CIntrinsicEventProviderHelper()
	{
	}

	HRESULT STDMETHODCALLTYPE FireCreationEvent(
											/*in*/IWbemClassObject * pNewInstance,
											/*in*/IWbemObjectSink * pSink )
	{
		if (pNewInstance == NULL || pSink == NULL)
		{
			ATLASSERT (0);		
			return WBEM_E_INVALID_PARAMETER;
		}

		if (m_pCreationEventClass == NULL)
		{
			return WBEM_E_FAILED;
		}
		
		CComPtr<IWbemClassObject> pEvtInstance;
	    HRESULT hr = m_pCreationEventClass->SpawnInstance(0, &pEvtInstance);
	    if(FAILED(hr))
		{
	        return hr;
		}
		
		CComVariant var;
		var.ChangeType(VT_UNKNOWN);	
		CComQIPtr<IUnknown, &IID_IUnknown>pTemp(pNewInstance);
		var = pTemp;
		hr = pEvtInstance->Put(CComBSTR(L"TargetInstance"), 0, &var, 0);
		if(FAILED(hr))
		{
	        return hr;
		}

		hr = pSink->Indicate(1, &pEvtInstance );

		return hr;
	}


	HRESULT STDMETHODCALLTYPE FireDeletionEvent(
									/*in*/IWbemClassObject * pInstanceToDelete,
									/*in*/IWbemObjectSink * pSink )
	{
		if (pInstanceToDelete == NULL || pSink == NULL)
		{
			ATLASSERT (0);		
			return WBEM_E_INVALID_PARAMETER;
		}

		if (m_pDeletionEventClass == NULL)
		{
			return WBEM_E_FAILED;
		}

		CComPtr<IWbemClassObject> pEvtInstance;
	    HRESULT hr = m_pDeletionEventClass->SpawnInstance(0, &pEvtInstance);
	    if(FAILED(hr))
		{
	        return hr;
		}
		CComVariant var;
		var.ChangeType(VT_UNKNOWN);	
		CComQIPtr<IUnknown, &IID_IUnknown>pTemp(pInstanceToDelete);
		var = pTemp;

		hr = pEvtInstance->Put(CComBSTR(L"TargetInstance"), 0, &var, 0);
		if(FAILED(hr))
		{
	        return hr;
		}

		hr = pSink->Indicate(1, &pEvtInstance);
		
		return hr;
	}


	HRESULT STDMETHODCALLTYPE FireModificationEvent(
													/*in*/IWbemClassObject * pOldInstance,
													/*in*/IWbemClassObject * pNewInstance,
													/*in*/IWbemObjectSink * pSink )
	{
		if (pOldInstance == NULL || pNewInstance == NULL || pSink == NULL)
		{
			ATLASSERT (0);		
			return WBEM_E_INVALID_PARAMETER;
		}
		
		if (m_pModificationEventClass == NULL)
		{
			return WBEM_E_FAILED;
		}
				
		CComPtr<IWbemClassObject> pEvtInstance;
	    HRESULT hr = m_pModificationEventClass->SpawnInstance(0, &pEvtInstance);
	    if(FAILED(hr))
		{
	        return hr;
		}
		CComVariant var;
		var.ChangeType(VT_UNKNOWN);

		CComQIPtr<IUnknown, &IID_IUnknown>pTempNew(pNewInstance);
		var = pTempNew;
		hr = pEvtInstance->Put(CComBSTR(L"TargetInstance"), 0, &var, 0);
		var.Clear();

		if (FAILED(hr)) 
		{		
			return hr;
		}
		
		CComQIPtr<IUnknown, &IID_IUnknown>pTempOld(pOldInstance);
		var = pTempOld;
		hr = pEvtInstance->Put(CComBSTR(L"PreviousInstance"), 0, &var, 0);
		if (FAILED(hr)) 
		{		
			return hr;
		}
		
		hr = pSink->Indicate(1, &pEvtInstance );

		return hr;
	}

};

class CInstanceProviderHelper : public CProviderHelper
{

public:

	CInstanceProviderHelper (IWbemServices * pNamespace, IWbemContext *pCtx)
				: CProviderHelper ( pNamespace, pCtx)
	{
	}

	virtual ~CInstanceProviderHelper()
	{
	}
	
	HRESULT STDMETHODCALLTYPE CheckInstancePath (
								/*[in]*/ IClassFactory * pParserFactory,	//pointer to path parser class factory
								/*[in]*/ const BSTR ObjectPath,	//object path string
								/*[in]*/ const BSTR ClassName,	//name of WMI class whose instances are provided
								/*[in]*/ ULONG ulTest)			//flags from WMI_PATH_STATUS_FLAG (defined in wmiutils.h)
	{	

		if (pParserFactory == NULL)
		{
			ATLASSERT (0);		
			return WBEM_E_INVALID_PARAMETER;
		}
		
		//Create path parser object
		CComPtr<IWbemPath>pPath;
		HRESULT hr = pParserFactory->CreateInstance(NULL,
											IID_IWbemPath,
											(void **) &pPath);
		if (FAILED(hr))
		{
			return WBEM_E_INVALID_PARAMETER;
		}

		hr = pPath->SetText(WBEMPATH_CREATE_ACCEPT_ALL,
									ObjectPath);
	 	//check that the class requested is the class provided
		long nPathLen = CComBSTR(ObjectPath).Length();
		
		unsigned long ulBufLen = nPathLen + 1;
		WCHAR * wClass = new WCHAR[nPathLen];
		if (NULL == wClass)
		{
			delete[] wClass;
			return WBEM_E_OUT_OF_MEMORY;
		}
		pPath->GetClassName(&ulBufLen, wClass);

		if ( _wcsicmp(ClassName, wClass))
		{
			delete[] wClass;
			return WBEM_E_FAILED;
		}
		
		delete[] wClass;
	  	
		//check that the path reflects the object type
		unsigned __int64 ulPathInfo;
		pPath->GetInfo(0L, &ulPathInfo);
		if (!(ulPathInfo & ulTest))
		{
			return WBEM_E_FAILED;
		}	
		
		return WBEM_S_NO_ERROR;		
	}

};


//IWbemPullClassProviderImpl class 

template <class T>
class ATL_NO_VTABLE IWbemPullClassProviderImpl : public IWbemServices,
												 public IWbemProviderInit
{
	public:


        //IWbemServices  

        virtual HRESULT STDMETHODCALLTYPE OpenNamespace( 
            /* [in] */ const BSTR strNamespace,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult){return WBEM_E_NOT_SUPPORTED;};
        
        virtual HRESULT STDMETHODCALLTYPE CancelAsyncCall( 
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink){return WBEM_E_NOT_SUPPORTED;};
        
        virtual HRESULT STDMETHODCALLTYPE QueryObjectSink( 
            /* [in] */ long lFlags,
            /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        virtual HRESULT STDMETHODCALLTYPE GetObject( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
        
        
        virtual HRESULT STDMETHODCALLTYPE PutClass( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult){return WBEM_E_NOT_SUPPORTED;};
        
        
        virtual HRESULT STDMETHODCALLTYPE DeleteClass( 
            /* [in] */ const BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult){return WBEM_E_NOT_SUPPORTED;};
        
        
        virtual HRESULT STDMETHODCALLTYPE CreateClassEnum( 
            /* [in] */ const BSTR strSuperclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
        
        
        virtual HRESULT STDMETHODCALLTYPE PutInstance( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult){return WBEM_E_NOT_SUPPORTED;};
        
        virtual HRESULT STDMETHODCALLTYPE PutInstanceAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        virtual HRESULT STDMETHODCALLTYPE DeleteInstance( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult){return WBEM_E_NOT_SUPPORTED;};
        
        virtual HRESULT STDMETHODCALLTYPE DeleteInstanceAsync( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler){return WBEM_E_NOT_SUPPORTED;};
        
        virtual HRESULT STDMETHODCALLTYPE CreateInstanceEnum( 
            /* [in] */ const BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
        
        virtual HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync( 
            /* [in] */ const BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        virtual HRESULT STDMETHODCALLTYPE ExecQuery( 
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
        
        
        virtual HRESULT STDMETHODCALLTYPE ExecNotificationQuery( 
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
        
        virtual HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync( 
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        virtual HRESULT STDMETHODCALLTYPE ExecMethod( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ const BSTR strMethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppOutParams,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
        
        virtual HRESULT STDMETHODCALLTYPE ExecMethodAsync( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ const BSTR strMethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        

};


}		//namespace ATL

#endif 	//__ATLWMIPROV_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vc7\beta1\system\wbem\wmiscriptutils\filehash.h ===
#pragma once

class MD5Hash
{
public:
	MD5Hash() {ZeroMemory(dwHash, sizeof(dwHash));}
	BSTR GetHashBSTR()
	{
		TCHAR szHash[33];
		for(int i=0;i<4;i++)
			wsprintf(&szHash[i*8], _T("%08X"), dwHash[i]);
		CComBSTR bstr(szHash);
		return bstr.Detach();
	}
	HRESULT HashData(LPBYTE pData, DWORD dwSize)
	{
		HRESULT hr = E_FAIL;
		HCRYPTPROV hProv = NULL;
		HCRYPTHASH hHash = NULL;
		__try
		{
			if(!CryptAcquireContext(&hProv, NULL, NULL, PROV_RSA_FULL, 0))
			{
				if(NTE_BAD_KEYSET == GetLastError())
				{
					if(!CryptAcquireContext(&hProv, NULL, NULL, PROV_RSA_FULL, CRYPT_NEWKEYSET))
						__leave;
				}
			}

			if(!CryptCreateHash(hProv, CALG_MD5, 0, 0, &hHash))
				__leave;

			if(!CryptHashData(hHash, pData, dwSize, 0))
				__leave;

			DWORD dwSizeHash = 0;
			DWORD dwSizeDWORD = sizeof(dwSizeHash);
			if(!CryptGetHashParam(hHash, HP_HASHSIZE, (BYTE*)&dwSizeHash, &dwSizeDWORD, 0))
				__leave;

			if(dwSizeDWORD != sizeof(dwSizeHash) || dwSizeHash != sizeof(dwHash))
				__leave;

			if(!CryptGetHashParam(hHash, HP_HASHVAL, (BYTE*)dwHash, &dwSizeHash, 0))
				__leave;

			hr = S_OK;
		}
		__finally
		{
			if(hHash)
				CryptDestroyHash(hHash);
			if(hProv)
				CryptReleaseContext(hProv, 0);
		}
		return hr;
	}
protected:
	DWORD dwHash[4];

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vc7\beta1\system\wbem\wmiscriptutils\commonfuncs.cpp ===
#include "stdafx.h"

#include "CommonFuncs.h"
#include "FileHash.h"

#define SAFE_LOCAL_SCRIPTS_KEY TEXT("Software\\Microsoft\\WBEM\\SafeLocalScripts")


// QUESTIONS:
// - What is passed to SetSite when we are create in script?
// - If we are passed an IOleClientSite, is it a good idea to QueryService for
//   an IWebBrowserApp?
// - Is there a better way to get the IHTMLDocument2 when we are created through
//   script?

// Here are some general notes about what I've observed when creating objects
// in HTML with IE 5.x.

// Observed IE 5.x Behavior
// If an object implements IOleObject AND IObjectWithSite
// - For objects created in an HTML page with an <OBJECT...> tag, IE calls
//   IOleObject::SetClientSite and passes an IOleClientSite object
// - For object created in script of HTML page using JScript
//   'new ActiveXObject' or VBScript 'CreateObject' function, IE calls
//   IObjectWithSite::SetSite with a ??? object

// If an object implements IObjectWithSite (and NOT IOleObject)
// - For object created in HTML page with <OBJECT...> tag, IE calls
//   IObjectWithSite::SetSite and passes an IOleClientSite object
// - For object created in script of HTML page using JScript
//   'new ActiveXObject' or VBScript 'CreateObject' function, IE calls
//   IObjectWithSite::SetSite with a ??? object


//		BYTE *pbData = NULL;
//		DWORD dwSize;
//		GetSourceFromDoc(pDoc, &pbData, &dwSize);
// Get the original source to the document specified by pDoc
HRESULT GetSourceFromDoc(IHTMLDocument2 *pDoc, BYTE **ppbData, DWORD *pdwSize)
{
	HRESULT hr = E_FAIL;
	IPersistStreamInit *pPersistStreamInit = NULL;
	IStream *pStream = NULL;

	*ppbData = NULL;

	__try
	{
		if(FAILED(hr = pDoc->QueryInterface(IID_IPersistStreamInit, (void**) &pPersistStreamInit)))
			__leave;

		if (FAILED(hr = CreateStreamOnHGlobal(NULL, TRUE, &pStream)))
			__leave;

		if(FAILED(hr = pPersistStreamInit->Save(pStream, TRUE)))
			__leave;

		// We are not responsible for freeing this HGLOBAL
		HGLOBAL hGlobal = NULL;
		if(FAILED(hr = GetHGlobalFromStream(pStream, &hGlobal)))
			__leave;

		STATSTG ss;
		if(FAILED(hr = pStream->Stat(&ss, STATFLAG_NONAME)))
			__leave;

		// This should never happen
		if(ss.cbSize.HighPart != 0)
			__leave;

		if(NULL == ((*ppbData) = new BYTE[ss.cbSize.LowPart]))
			__leave;
		
		LPVOID pHTMLText = NULL;
		if(NULL == (pHTMLText = GlobalLock(hGlobal)))
			__leave;

		*pdwSize = ss.cbSize.LowPart;
		memcpy(*ppbData, pHTMLText, ss.cbSize.LowPart);
		GlobalUnlock(hGlobal);
		hr = S_OK;

	}
	__finally
	{
		// If we did not finish, but we allocated memory, we free it.
		if(FAILED(hr) && (*ppbData)!=NULL)
			delete [] (*ppbData);

		if(pPersistStreamInit)
			pPersistStreamInit->Release();
		if(pStream)
			pStream->Release();
	}
	return hr;
}


// For a control specified by pUnk, get the IServiceProvider of the host
HRESULT GetSiteServices(IUnknown *pUnk, IServiceProvider **ppServProv)
{
	HRESULT hr = E_FAIL;
	IOleObject *pOleObj = NULL;
	IObjectWithSite *pObjWithSite = NULL;
	IOleClientSite *pSite = NULL;
	__try
	{
		// Check if the ActiveX control supports IOleObject.
		if(SUCCEEDED(pUnk->QueryInterface(IID_IOleObject, (void**)&pOleObj)))
		{
			// If the control was created through an <OBJECT...> tag, IE will
			// have passed us an IOleClientSite.  If we have not been passed
			// an IOleClientSite, GetClientSite will still SUCCEED, but pSite
			// will be NULL.  In this case, we just go to the next section.
			if(SUCCEEDED(pOleObj->GetClientSite(&pSite)) && pSite)
			{
				hr = pSite->QueryInterface(IID_IServiceProvider, (void**)ppServProv);

				// At this point, we are done and do not want to process the
				// code in the next seciont
				__leave;
			}
		}

		// At this point, one of two things has happened:
		// 1) We didn't support IOleObject
		// 2) We supported IOleObject, but we were never passed an IOleClientSite

		// In either case, we now need to look at IObjectWithSite to try to get
		// to our site
		if(FAILED(hr = pUnk->QueryInterface(IID_IObjectWithSite, (void**)&pObjWithSite)))
			__leave;

		hr = pObjWithSite->GetSite(IID_IServiceProvider, (void**)ppServProv);
	}
	__finally
	{
		// Release any interfaces we used along the way
		if(pOleObj)
			pOleObj->Release();
		if(pObjWithSite)
			pObjWithSite->Release();
		if(pSite)
			pSite->Release();
	}
	return hr;
}

// This function shows how to get to the IHTMLDocument2 that created an
// arbitrary control represented by pUnk
HRESULT GetDocument(IUnknown *pUnk, IHTMLDocument2 **ppDoc)
{
	HRESULT hr = E_FAIL;
	IServiceProvider* pServProv = NULL;
	IDispatch *pDisp = NULL;
	__try
	{
		if(FAILED(hr = GetSiteServices(pUnk, &pServProv)))
			__leave;

		// HACK HACK BUGBUG BUG
		// In IE 5.5, if we use SID_SContainerDispatch, we get to an IHTMLDocument2 that
		// does NOT know about IPersistStreamInit.  It seems that SID_SContainerDispatch
		// gives us a CDocument, and CLSID_HTMLDocument will give us a CDoc.  In IE 5.0,
		// we always got a CDoc that knew how to give us the IPersistStreamInit.
		if(FAILED(hr = pServProv->QueryService(CLSID_HTMLDocument/*SID_SContainerDispatch*/, IID_IDispatch, (void**)&pDisp)))
			__leave;

		hr = pDisp->QueryInterface(IID_IHTMLDocument2, (void**)ppDoc);
	}
	__finally
	{
		if(pServProv)
			pServProv->Release();
		if(pDisp)
			pDisp->Release();
	}
	return hr;
}





// This function will Release() the current document and return a pointer to
// the parent document.  If no parent document is available, this function
// will return NULL (but will still release the current document)
IHTMLDocument2 *GetParentDocument(IHTMLDocument2 *pDoc)
{
	BSTR bstrURL = NULL;
	BSTR bstrURLParent = NULL;
	IHTMLWindow2 *pWndParent = NULL;
	IHTMLWindow2 *pWndParentParent = NULL;
	IHTMLDocument2 *pDocParent = NULL;
	__try
	{
		if(FAILED(pDoc->get_URL(&bstrURL)))
			__leave;
		if(FAILED(pDoc->get_parentWindow(&pWndParent)))
			__leave;
		if(FAILED(pWndParent->get_parent(&pWndParentParent)))
			__leave;
		if(FAILED(pWndParentParent->get_document(&pDocParent)))
			__leave;
		if(FAILED(pDocParent->get_URL(&bstrURLParent)))
			__leave;
		// TODO: Make this more robust
		if(0 == lstrcmpW(bstrURL, bstrURLParent))
		{
			// We are at the top document.  Release the new document pointer we
			// just received.
			pDocParent->Release();
			pDocParent = NULL;
		}
	}
	__finally
	{
		if(bstrURL)
			SysFreeString(bstrURL);
		if(bstrURLParent)
			SysFreeString(bstrURLParent);
		if(pWndParent)
			pWndParent->Release();
		if(pWndParentParent)
			pWndParentParent->Release();
		if(pDoc)
			pDoc->Release();
	}
	return pDocParent;
}


// Try to append bstr2 to pbstr1.  If this function fails, pbstr1 will still
// point to the original valid allocated bstr.
HRESULT AppendBSTR(BSTR *pbstr1, BSTR bstr2)
{
	HRESULT hr = S_OK;
	CComBSTR bstr;
	if(FAILED(bstr.AppendBSTR(*pbstr1)))
		hr = E_FAIL;
	if(FAILED(bstr.AppendBSTR(bstr2)))
		hr = E_FAIL;
	if(SUCCEEDED(hr))
	{
		SysFreeString(*pbstr1);
		*pbstr1 = bstr.Detach();
	}
	return hr;
}

BSTR AllocBSTR(LPCTSTR lpsz)
{
	CComBSTR bstr(lpsz);
	return bstr.Detach();
}

BOOL IsURLLocal(LPWSTR szURL)
{
	CComBSTR bstrURL(szURL);
	if(FAILED(bstrURL.ToLower()))
		return FALSE;
	// Make sure the URL starts with 'file://'
	if(0 != wcsncmp(bstrURL, L"file://", 7))
		return FALSE;
	
	// Make sure the next part is a drive letter, such as 'C:\'
	if(0 != wcsncmp(&(bstrURL[8]), L":\\", 2))
		return FALSE;

	WCHAR drive = bstrURL[7];
	// Make sure the URL points to drive 'a' to 'z'
	if(drive < 'a' || drive > 'z')
		return FALSE;

	TCHAR szDrive[4];
	lstrcpy(szDrive, TEXT("c:\\"));
	szDrive[0] = (TCHAR)drive;

	UINT uDriveType = GetDriveType(szDrive);
	return (DRIVE_FIXED == uDriveType);
}

// Try to convert the BSTR to lower case.  If this function fails, pbstr will
// still point to the original valid allocated bstr.
HRESULT ToLowerBSTR(BSTR *pbstr)
{
	CComBSTR bstr;
	if(FAILED(bstr.AppendBSTR(*pbstr)))
		return E_FAIL;
	if(FAILED(bstr.ToLower()))
		return E_FAIL;
	SysFreeString(*pbstr);
	*pbstr = bstr.Detach();
	return S_OK;
}

// For a given instance of an ActiveX control (represented by pUnk), and a
// specified strProgId, this function creates a 'full path' that can be checked
// in the registry to see if object creation should be allowed.  The full
// location is created from the following information
// 1) The name of the current EXE
// 2) The ProgId requested
// 3) The HREF of the current document
// 4) The HREF of every parent document up the available hierarchy
// All of the documents in the hierarchy must be on a local hard drive or the
// function will fail.  In addition, if any piece of informaiton along the way
// is not available, the function will fail.  This increases the security of
// our process.
// This function will also create a BSTR in *pbstrHash that contains the
// cumulative MD5 hash of the document and its parents.  This BSTR will be
// allocated by the function and should be freed by the caller.  If the
// function returns NULL for the full location, it will also return NULL for
// *pbstrHash
BSTR GetFullLocation(IUnknown *pUnk, BSTR strProgId, BSTR *pbstrHash)
{
	HRESULT hr = E_FAIL;
	IHTMLDocument2 *pDoc = NULL;
	BSTR bstrURL = NULL;
	BSTR bstrFullLocation = NULL;
	*pbstrHash = NULL;
	BYTE *pbData = NULL;
	BSTR bstrHash = NULL;

	__try
	{
		if(FAILED(GetDocument(pUnk, &pDoc)))
			__leave;

		TCHAR szFilename[_MAX_PATH];
		TCHAR szFilenameLong[_MAX_PATH];
		GetModuleFileName(NULL, szFilenameLong, _MAX_PATH);
		GetShortPathName(szFilenameLong, szFilename, _MAX_PATH);
		
		if(NULL == (bstrFullLocation = AllocBSTR(szFilename)))
			__leave;

		if(FAILED(AppendBSTR(&bstrFullLocation, strProgId)))
			__leave;

		if(NULL == (*pbstrHash = AllocBSTR(_T(""))))
			__leave;

		int nDepth = 0;
		do
		{
			// Make sure we don't get stuck in some infinite loop of parent
			// documents.  If we do get more than 100 levels of parent
			// documents, we assume failure
			if(++nDepth >= 100)
				__leave;

			if(FAILED(pDoc->get_URL(&bstrURL)))
				__leave;

			DWORD dwDataSize = 0;
			if(FAILED(GetSourceFromDoc(pDoc, &pbData, &dwDataSize)))
				__leave;

			MD5Hash hash;
			if(FAILED(hash.HashData(pbData, dwDataSize)))
				__leave;

			if(NULL == (bstrHash = hash.GetHashBSTR()))
				__leave;

			if(FAILED(AppendBSTR(pbstrHash, bstrHash)))
				__leave;

			SysFreeString(bstrHash);
			bstrHash = NULL;
			delete [] pbData;
			pbData = NULL;


			// Make sure every document is on the local hard drive
			if(!IsURLLocal(bstrURL))
				__leave;

			if(FAILED(AppendBSTR(&bstrFullLocation, bstrURL)))
				__leave;

			SysFreeString(bstrURL);
			bstrURL = NULL;
		} while (NULL != (pDoc = GetParentDocument(pDoc)));

		// Make sure we do not have any embeded NULLs.  If we do, we just
		// FAIL the call
		if(SysStringLen(bstrFullLocation) != wcslen(bstrFullLocation))
			__leave;

		// Make the location lower case
		if(FAILED(ToLowerBSTR(&bstrFullLocation)))
			__leave;

		// We've now created the normalized full location
		hr = S_OK;
	}
	__finally
	{
		// pDoc should be NULL if we got to the top of the hierarchy.  If not,
		// we should release it
		if(pDoc)
			pDoc->Release();

		// pbData should be NULL unless there was an error calculating the hash
		if(pbData)
			delete [] pbData;

		// bstrHash should be NULL unless there was a problem
		if(bstrHash)
			SysFreeString(bstrHash);

		// bstrURL should be NULL unless there was a problem
		if(bstrURL)
			SysFreeString(bstrURL);

		// If we didn't make it all the way to the end, we free the full location
		if(FAILED(hr) && bstrFullLocation)
		{
			SysFreeString(bstrFullLocation);
			bstrFullLocation = NULL;
		}

		// If we didn't make it all the way to the end, we free the checksum
		if(FAILED(hr) && *pbstrHash)
		{
			SysFreeString(*pbstrHash);
			*pbstrHash = NULL;
		}
	}

	return bstrFullLocation;
}

// For a given instance of an ActiveXControl (specified by pUnk), see if it is
// permitted to create the object specified by bstrProgId.  This is done by
// verifying that the control was created in an allowed HTML document.
HRESULT IsCreateObjectAllowed(IUnknown *pUnk, BSTR strProgId, BSTR *pstrValueName)
{
	BSTR bstrFullLocation = NULL;
	HRESULT hr = E_FAIL;
	HKEY hKey = NULL;
	LPTSTR pszValueName = NULL;
	LPTSTR pszValue = NULL;
	__try
	{
		BSTR bstrHash = NULL;
		// Get the full location
		if(NULL == (bstrFullLocation = GetFullLocation(pUnk, strProgId, &bstrHash)))
			__leave;

		SysFreeString(bstrHash);

		// Make sure we don't have a zero length string
		if(0 == SysStringLen(bstrFullLocation))
			__leave;

		// Open the registry key to see if this full location is registered
		if(ERROR_SUCCESS != RegOpenKey(HKEY_LOCAL_MACHINE, SAFE_LOCAL_SCRIPTS_KEY, &hKey))
			__leave;

		// Get info on the max lenghts of values in this key
		DWORD cValues, cMaxValueNameLen, cMaxValueLen;
		if(ERROR_SUCCESS != RegQueryInfoKey(hKey, NULL, NULL, NULL, NULL, NULL, NULL, &cValues, &cMaxValueNameLen, &cMaxValueLen, NULL, NULL))
			__leave;

		// Allocate space for the value name
		if(NULL == (pszValueName = new TCHAR[cMaxValueNameLen + 1]))
			__leave;

		// Allocate space for the value (this may be twice as big as necessary in UNICODE)
		if(NULL == (pszValue = new TCHAR[cMaxValueLen + 1]))
			__leave;
		for(DWORD dw = 0;dw<cValues;dw++)
		{
			DWORD cValueNameLen = cMaxValueNameLen+1;
			DWORD cbData = (cMaxValueLen+1)*sizeof(TCHAR);
			DWORD dwType;
			if(ERROR_SUCCESS != RegEnumValue(hKey, dw, pszValueName, &cValueNameLen, NULL, &dwType, (LPBYTE)pszValue, &cbData))
				continue;
			if(dwType != REG_SZ)
				continue;

			BSTR bstrValue = T2BSTR(pszValue);
			if(!bstrValue)
				continue;

			// SEE IF WE HAVE A MATCH
			if(0 == wcscmp(bstrFullLocation, bstrValue))
			{
				// Return the ValueName if requested
				if(pstrValueName)
					*pstrValueName = AllocBSTR(pszValueName);

				hr = S_OK;
			}

			SysFreeString(bstrValue);

			if(SUCCEEDED(hr))
				__leave; // WE FOUND A MATCH
		}
	}
	__finally
	{
		if(bstrFullLocation)
			SysFreeString(bstrFullLocation);
		if(hKey)
			RegCloseKey(hKey);
		if(pszValueName)
			delete [] pszValueName;
		if(pszValue)
			delete [] pszValue;
	}
	return hr;
}

// This function will register the location of the current ActiveX control
// (specified by pUnk) to be allowed to create objects of type strProgId
HRESULT RegisterCurrentDoc(IUnknown *pUnk, BSTR strProgId)
{
	USES_CONVERSION;

	HRESULT hr = E_FAIL;
	BSTR bstrFullLocation = NULL;
	LPTSTR pszFullLocation = NULL;
	HKEY hKey = NULL;

	__try
	{
		// See if we are already registered
		if(SUCCEEDED(IsCreateObjectAllowed(pUnk, strProgId, NULL)))
		{
			hr = S_OK;
			__leave;
		}

		// TODO: Maybe reuse some of the code from IsCreateObjectAllowed

		BSTR bstrHash = NULL;
		// Get the full location
		if(NULL == (bstrFullLocation = GetFullLocation(pUnk, strProgId, &bstrHash)))
			__leave;

		SysFreeString(bstrHash);

		// Make sure we don't have a zero length string
		if(0 == SysStringLen(bstrFullLocation))
			__leave;

		// Convert BSTR to normal string
		if(NULL == (pszFullLocation = W2T(bstrFullLocation)))
			__leave;

		// Create or open the registry key to store the registration
		if(ERROR_SUCCESS != RegCreateKey(HKEY_LOCAL_MACHINE, SAFE_LOCAL_SCRIPTS_KEY, &hKey))
			__leave;

		// Find an empty slot (no more than 1000 registrations
		TCHAR sz[10];
		for(int i=1;i<1000;i++)
		{
			wsprintf(sz, TEXT("%i"), i);
			DWORD cbValue;
			if(ERROR_SUCCESS != RegQueryValueEx(hKey, sz, NULL, NULL, NULL, &cbValue))
				break; // There is nothing in this slot
		}

		// See if we found a slot
		if(i>=1000)
			__leave;

		// Register the location
		if(ERROR_SUCCESS != RegSetValueEx(hKey, sz, 0, REG_SZ, (CONST BYTE *)pszFullLocation, lstrlen(pszFullLocation)*sizeof(TCHAR)))
			__leave;

		// Registered!
		hr = S_OK;
	}
	__finally
	{
		if(bstrFullLocation)
			SysFreeString(bstrFullLocation);
		if(hKey)
			RegCloseKey(hKey);
	}
	return hr;
}


// This function will remove any registration for the current document and
// strProgId
HRESULT UnRegisterCurrentDoc(IUnknown *pUnk, BSTR strProgId)
{
	USES_CONVERSION;

	BSTR bstrValueName = NULL;

	HKEY hKey = NULL;
	if(ERROR_SUCCESS != RegOpenKey(HKEY_LOCAL_MACHINE, SAFE_LOCAL_SCRIPTS_KEY, &hKey))
		return E_FAIL;

	// Make sure to remove ALL instances of this doc/strProgId in the registry
	// NOTE: Each iteration of this loop allocates some space off of the stack
	// for the conversion to ANSI (if not UNICODE build).  This should not be a
	// problem since there should not be too many keys ever registered with the
	// same location.
	while(SUCCEEDED(IsCreateObjectAllowed(pUnk, strProgId, &bstrValueName)) && bstrValueName)
	{
		LPTSTR szValueName = W2T(bstrValueName);
		SysFreeString(bstrValueName);
		bstrValueName = NULL;
		RegDeleteValue(hKey, szValueName);
	}
	RegCloseKey(hKey);
	return S_OK;
}


///////////////////////////////////////////////////////////////////////////////
// VC 6.0 did not ship with header files that included the CONFIRMSAFETY
// definition.
#ifndef CONFIRMSAFETYACTION_LOADOBJECT

EXTERN_C const GUID GUID_CUSTOM_CONFIRMOBJECTSAFETY;
#define CONFIRMSAFETYACTION_LOADOBJECT  0x00000001
struct CONFIRMSAFETY
{
    CLSID       clsid;
    IUnknown *  pUnk;
    DWORD       dwFlags;
};
#endif

const GUID GUID_CUSTOM_CONFIRMOBJECTSAFETY = 
	{ 0x10200490, 0xfa38, 0x11d0, { 0xac, 0xe, 0x0, 0xa0, 0xc9, 0xf, 0xff, 0xc0 }};

///////////////////////////////////////////////////////////////////////////////

HRESULT SafeCreateObject(IUnknown *pUnkControl, BOOL fSafetyEnabled, CLSID clsid, IUnknown **ppUnk)
{
	HRESULT hr = E_FAIL;
	IInternetHostSecurityManager *pSecMan = NULL;
	IServiceProvider *pServProv = NULL;
	__try
	{
		if (fSafetyEnabled)
		{
			if(FAILED(hr = GetSiteServices(pUnkControl, &pServProv)))
				__leave;

			if(FAILED(hr = pServProv->QueryService(SID_SInternetHostSecurityManager, IID_IInternetHostSecurityManager, (void**)&pSecMan)))
				__leave;
			
			// Ask security manager if we can create objects.
			DWORD dwPolicy = 0x12345678;
			if(FAILED(hr = pSecMan->ProcessUrlAction(URLACTION_ACTIVEX_RUN, (BYTE *)&dwPolicy, sizeof(dwPolicy), (BYTE *)&clsid, sizeof(clsid), 0, 0)))
				__leave;

			// TODO: BUG: If we are loaded in an HTA, hr returns S_OK, but 
			// dwPolicy only has the first byte set to zero.  See documentation
			// for ProcessUrlAction.
			// NOTE: This bug is caused by CClient::ProcessUrlAction in
			// nt\private\inet\mshtml\src\other\htmlapp\site.cxx.  This line
			// uses *pPolicy = dwPolicy, but pPolicy is a BYTE * so only the
			// first byte of the policy is copied to the output parameter.
			// To fix this, we check for hr==S_OK (as opposed to S_FALSE), and
			// see if dwPolicy is 0x12345600 (in other words, only the lower
			// byte of dwPolicy was changed).  As per the documentation, S_OK
			// alone should be enough to assume the dwPolicy was
			// URL_POLICY_ALLOW
			if(S_OK == hr && 0x12345600 == dwPolicy)
				dwPolicy = URLPOLICY_ALLOW;
			
			if(URLPOLICY_ALLOW != dwPolicy)
			{
				hr = E_FAIL;
				__leave;;
			}
		}

		// Create the requested object
		if (FAILED(hr = CoCreateInstance(clsid, NULL, CLSCTX_INPROC_SERVER, IID_IUnknown, (void**)ppUnk)))
			__leave;
		
		if (fSafetyEnabled)
		{
			// Query the security manager to see if this object is safe to use.
			DWORD dwPolicy, *pdwPolicy;
			DWORD cbPolicy;
			CONFIRMSAFETY csafe;
			csafe.pUnk = *ppUnk;
			csafe.clsid = clsid;
			csafe.dwFlags = 0;
//			csafe.dwFlags = (fWillLoad ? CONFIRMSAFETYACTION_LOADOBJECT : 0);
			
			if(FAILED(hr = pSecMan->QueryCustomPolicy(GUID_CUSTOM_CONFIRMOBJECTSAFETY, (BYTE **)&pdwPolicy, &cbPolicy, (BYTE *)&csafe, sizeof(csafe), 0)))
				__leave;
			
			dwPolicy = URLPOLICY_DISALLOW;
			if (NULL != pdwPolicy)
			{
				if (sizeof(DWORD) <= cbPolicy)
					dwPolicy = *pdwPolicy;
				CoTaskMemFree(pdwPolicy);
			}
			
			if(URLPOLICY_ALLOW != dwPolicy)
			{
				hr = E_FAIL;
				__leave;
			}
		}
		hr = S_OK;
	}
	__finally
	{
		// If we did not succeeded, we need to release the object we created (if any)
		if(FAILED(hr) && (*ppUnk))
		{
			(*ppUnk)->Release();
			*ppUnk = NULL;
		}

		if(pServProv)
			pServProv->Release();
		if(pSecMan)
			pSecMan->Release();
	}
	return hr;
}

BOOL IsInternetHostSecurityManagerAvailable(IUnknown *pUnkControl)
{
	HRESULT hr = E_FAIL;
	IInternetHostSecurityManager *pSecMan = NULL;
	IServiceProvider *pServProv = NULL;
	__try
	{
		if(FAILED(hr = GetSiteServices(pUnkControl, &pServProv)))
			__leave;

		if(FAILED(hr = pServProv->QueryService(SID_SInternetHostSecurityManager, IID_IInternetHostSecurityManager, (void**)&pSecMan)))
			__leave;
	}
	__finally
	{
		if(pServProv)
			pServProv->Release();
		if(pSecMan)
			pSecMan->Release();
	}
	return SUCCEEDED(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vc7\beta1\vcwiz\classwiz\atl\event\templates\1031\wmiprov.h ===
[!if !EVENT]
//Fehler: Ereignisanbieter-Headervorlage wurde fr den falschen Anbietertyp aufgerufen.
[!else]
// [!output HEADER_FILE] : Deklaration von [!output CLASS_NAME]

#pragma once
#include "resource.h"       // Hauptsymbole
#include <wbemidl.h>
#include <atlwmiprov.h>


extern const WCHAR * s_pMyClassName;	//Klassenname

[!if EXTRINSIC]
[!output EXTR_PROPERTY_DECLARATIONS]
[!endif]

/////////////////////////////////////////////////////////////////////////////
// [!output CLASS_NAME]

[!if ATTRIBUTED]
[
	coclass,
[!if THREADING_BOTH]
	threading("both"),
[!endif]
[!if THREADING_FREE]
	threading("free"),
[!endif]
	aggregatable("never"),
	vi_progid("[!output VERSION_INDEPENDENT_PROGID]"),
	progid("[!output PROGID]"),
	version(1.0),
	uuid("[!output CLSID_REGISTRY_FORMAT]"),
	helpstring("[!output TYPE_NAME]")
]
[!endif]

class ATL_NO_VTABLE [!output CLASS_NAME] : 
						[!if !ATTRIBUTED]
						[!if THREADING_BOTH]
							public CComObjectRootEx<CComMultiThreadModel>,
						[!endif]
						[!if THREADING_FREE]
							public CComObjectRootEx<CComMultiThreadModel>,
						[!endif]
						public CComCoClass<[!output CLASS_NAME], &CLSID_[!output COCLASS]>,
						[!endif]
						[!if EVENT_SECURITY]
							public IWbemEventProviderSecurity,
						[!endif]
						[!if QUERY_SINK]
							public IWbemEventProviderQuerySink,
						[!endif]
							public IWbemProviderInit,
							public IWbemEventProvider
{
	CComPtr<IWbemServices>  m_pNamespace;	//Zwischengespeicherter IWbemServices-Zeiger
	CComPtr<IWbemObjectSink> m_pSink;	//ZwischengespeicherterDatensenkenereigniszeiger

	[!if INTRINSIC]	
	CComPtr<IWbemClassObject> m_pDataClass;	//Zwischengespeicherte Definition der Klasse, fr die die Ereignisse ausgelst werden

	CIntrinsicEventProviderHelper * m_pHelper;	//Zeiger fr Hilfsklassenobjekt
	[!else]
    CComPtr<IWbemClassObject> m_pEventClass;	//Zwischengespeicherter Zeiger der Ereignisklassendefinition
	
	CProviderHelper * m_pHelper;
  
	STDMETHODIMP FireEvent();
	[!endif]	

public:
    [!output CLASS_NAME]()
	{
		m_pHelper = NULL;		
	}
	
	~[!output CLASS_NAME]()
	{
	    if (NULL != m_pHelper)
		{
			delete m_pHelper;
		}
		//Hinweis: Schnittstellenzeiger-Datenmitglieder sind dynamisch und werden automatisch freigegeben
	}

	[!if !ATTRIBUTED]
	DECLARE_REGISTRY_RESOURCEID(IDR_[!output UPPER_SHORT_NAME])

	DECLARE_NOT_AGGREGATABLE([!output CLASS_NAME])

	BEGIN_COM_MAP([!output CLASS_NAME])
		COM_INTERFACE_ENTRY(IWbemEventProvider)
		[!if EVENT_SECURITY ]
		COM_INTERFACE_ENTRY(IWbemEventProviderSecurity)
		[!endif]
		[!if QUERY_SINK ]
		COM_INTERFACE_ENTRY(IWbemEventProviderQuerySink)
		[!endif]	
		COM_INTERFACE_ENTRY(IWbemProviderInit)
	END_COM_MAP()
	[!endif]


	//IWbemProviderInit
	HRESULT STDMETHODCALLTYPE Initialize( LPWSTR pszUser,
						  LONG lFlags,
						  LPWSTR pszNamespace,
						  LPWSTR pszLocale,
						  IWbemServices *pNamespace,
						  IWbemContext *pCtx,
						  IWbemProviderInitSink *pInitSink);

	//IWbemEventProvider
	HRESULT STDMETHODCALLTYPE ProvideEvents(
							IWbemObjectSink *pSink,
							long lFlags);


	[!if EVENT_SECURITY ]
	//IWbemEventProviderSecurity
	HRESULT STDMETHODCALLTYPE AccessCheck(
							WBEM_CWSTR wszQueryLanguage,
							WBEM_CWSTR wszQuery,
							long lSidLength,
							const BYTE* pSid
	);
	[!endif]

	[!if QUERY_SINK ]
	//IWbemEventProviderQuerySink
	HRESULT STDMETHODCALLTYPE CancelQuery(
	  unsigned long dwId
	);

	HRESULT STDMETHODCALLTYPE NewQuery(
	  unsigned long dwId,
	  WBEM_WSTR wszQueryLanguage,
	  WBEM_WSTR wszQuery
	);
	[!endif]

};

[!if !ATTRIBUTED]
OBJECT_ENTRY_AUTO(__uuidof([!output COCLASS]), [!output CLASS_NAME])
[!endif]

[!endif]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vc7\beta1\vcwiz\classwiz\atl\event\templates\1041\wmiprov.h ===
[!if !EVENT]
//G[: Cxg voC_ wb_[ ev[g͊Ԉނ̃voC_Ăяo܂B
[!else]
// [!output HEADER_FILE] :  [!output CLASS_NAME] ̐錾B

#pragma once
#include "resource.h"       // C V|łB
#include <wbemidl.h>
#include <atlwmiprov.h>


extern const WCHAR * s_pMyClassName;	//NXłB

[!if EXTRINSIC]
[!output EXTR_PROPERTY_DECLARATIONS]
[!endif]

/////////////////////////////////////////////////////////////////////////////
// [!output CLASS_NAME]

[!if ATTRIBUTED]
[
	coclass,
[!if THREADING_BOTH]
	threading("both"),
[!endif]
[!if THREADING_FREE]
	threading("free"),
[!endif]
	aggregatable("never"),
	vi_progid("[!output VERSION_INDEPENDENT_PROGID]"),
	progid("[!output PROGID]"),
	version(1.0),
	uuid("[!output CLSID_REGISTRY_FORMAT]"),
	helpstring("[!output TYPE_NAME]")
]
[!endif]

class ATL_NO_VTABLE [!output CLASS_NAME] : 
						[!if !ATTRIBUTED]
						[!if THREADING_BOTH]
							public CComObjectRootEx<CComMultiThreadModel>,
						[!endif]
						[!if THREADING_FREE]
							public CComObjectRootEx<CComMultiThreadModel>,
						[!endif]
						public CComCoClass<[!output CLASS_NAME], &CLSID_[!output COCLASS]>,
						[!endif]
						[!if EVENT_SECURITY]
							public IWbemEventProviderSecurity,
						[!endif]
						[!if QUERY_SINK]
							public IWbemEventProviderQuerySink,
						[!endif]
							public IWbemProviderInit,
							public IWbemEventProvider
{
	CComPtr<IWbemServices>  m_pNamespace;	//LbVꂽ IWbemServices |C^łB
	CComPtr<IWbemObjectSink> m_pSink;			//LbVꂽCxg VN |C^łB

	[!if INTRINSIC]	
	CComPtr<IWbemClassObject> m_pDataClass;		//CxgJn邽߂̃LbVꂽNX̒`łB

	CIntrinsicEventProviderHelper * m_pHelper;	//helper NX IuWFNgւ̃|C^łB
	[!else]
    CComPtr<IWbemClassObject> m_pEventClass;	//LbVꂽCxg NX`|C^łB
	
	CProviderHelper * m_pHelper;
  
	STDMETHODIMP FireEvent();
	[!endif]	

public:
    [!output CLASS_NAME]()
	{
		m_pHelper = NULL;		
	}
	
	~[!output CLASS_NAME]()
	{
	    if (NULL != m_pHelper)
		{
			delete m_pHelper;
		}
		//: C^[tFCX |C^ f[^ o̓X}[gŎIɉ܂B
	}

	[!if !ATTRIBUTED]
	DECLARE_REGISTRY_RESOURCEID(IDR_[!output UPPER_SHORT_NAME])

	DECLARE_NOT_AGGREGATABLE([!output CLASS_NAME])

	BEGIN_COM_MAP([!output CLASS_NAME])
		COM_INTERFACE_ENTRY(IWbemEventProvider)
		[!if EVENT_SECURITY ]
		COM_INTERFACE_ENTRY(IWbemEventProviderSecurity)
		[!endif]
		[!if QUERY_SINK ]
		COM_INTERFACE_ENTRY(IWbemEventProviderQuerySink)
		[!endif]	
		COM_INTERFACE_ENTRY(IWbemProviderInit)
	END_COM_MAP()
	[!endif]


	//IWbemProviderInit
	HRESULT STDMETHODCALLTYPE Initialize( LPWSTR pszUser,
						  LONG lFlags,
						  LPWSTR pszNamespace,
						  LPWSTR pszLocale,
						  IWbemServices *pNamespace,
						  IWbemContext *pCtx,
						  IWbemProviderInitSink *pInitSink);

	//IWbemEventProvider
	HRESULT STDMETHODCALLTYPE ProvideEvents(
							IWbemObjectSink *pSink,
							long lFlags);


	[!if EVENT_SECURITY ]
	//IWbemEventProviderSecurity
	HRESULT STDMETHODCALLTYPE AccessCheck(
							WBEM_CWSTR wszQueryLanguage,
							WBEM_CWSTR wszQuery,
							long lSidLength,
							const BYTE* pSid
	);
	[!endif]

	[!if QUERY_SINK ]
	//IWbemEventProviderQuerySink
	HRESULT STDMETHODCALLTYPE CancelQuery(
	  unsigned long dwId
	);

	HRESULT STDMETHODCALLTYPE NewQuery(
	  unsigned long dwId,
	  WBEM_WSTR wszQueryLanguage,
	  WBEM_WSTR wszQuery
	);
	[!endif]

};

[!if !ATTRIBUTED]
OBJECT_ENTRY_AUTO(__uuidof([!output COCLASS]), [!output CLASS_NAME])
[!endif]

[!endif]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vc7\beta1\vcwiz\classwiz\atl\event\templates\1031\wmiprov.cpp ===
// [!output IMPL_FILE] : Implementierung von [!output CLASS_NAME]
#include "stdafx.h"
#include "[!output PROJECT_NAME].h"
#include "[!output HEADER_FILE]"


/////////////////////////////////////////////////////////////////////////////
// [!output CLASS_NAME]

// Wichtig: Die folgenden Strings sollten nicht lokalisiert werden.

// Klassenname
[!if CLASS_SPECIFIED]
const static WCHAR * s_pMyClassName = L"[!output WMICLASSNAME]"; 
[!if EXTRINSIC]
//Eigenschaften der Ereignisklasse [!output WMICLASSNAME]:
[!output EXTR_PROPERTY_DEFINITIONS]
[!endif]
[!else]
//Aktion: Definieren Sie den angegebenen Klassenname, z.B.:
const static WCHAR * s_pMyClassName = L"MyClassName"; 
[!endif]


//////////////////////////////////////////////////////////////////////////////
// [!output CLASS_NAME]::Initialize()
// In der MSDN-Dokumentation fr IWbemProviderInit::Initialize()
// finden Sie weitere Einzelheiten ber die Implementierung dieser Methode.

STDMETHODIMP [!output CLASS_NAME]::Initialize(LPWSTR pszUser,	
									  LONG lFlags,
									  LPWSTR pszNamespace,
									  LPWSTR pszLocale,
									  IWbemServices *pNamespace,
									  IWbemContext *pCtx,
																																							IWbemProviderInitSink *pInitSink) 
{
	
	HRESULT hr = WBEM_E_FAILED;
	if ( NULL == pNamespace || NULL == pInitSink) 
	{
        return WBEM_E_INVALID_PARAMETER;
	}

	//IWbemServices-Zeiger zwischenspeichern 
	//Hinweis: m_pNamespace ist ein dynamischer Zeiger: AddRef() funktioniert automatisch
	m_pNamespace = pNamespace;
					
	[!if INTRINSIC]	
	//Hilfsobjekt abrufen
	m_pHelper = new CIntrinsicEventProviderHelper(pNamespace, pCtx);

	[!endif]
	
	[!if EXTRINSIC]	
	//Ereignisklassendefinition speichern				 
	//Hinweis: Der folgende Code geht davon aus, dass die Ereignisklassendefinition 
	//whrend der Anbieterausfhrung unverndert bleibt. Andernfalls mssen Sie einen 
	//Benutzer fr Klassennderungen und Klassenlschereignisse implementieren. Weitere
	//Informationen ber Ereignisbenutzer finden Sie auf MSDN in der WMI-Dokumentenation.
	hr = m_pNamespace->GetObject(CComBSTR(s_pMyClassName), 
								0, 
								pCtx, //IWbemContext-Zeiger umgehen, um Sperrungen zu verhindern
								&m_pEventClass, 
								NULL);

    if(FAILED(hr))
	{
        return hr;
	}

	//Hilfsobjekt abrufen
	m_pHelper = new CProviderHelper(pNamespace, pCtx);

    [!endif]
	[!if INTRINSIC]
	//Zielklassendefinition speichern
	hr = m_pNamespace->GetObject(CComBSTR(s_pMyClassName), 
								 0, 
								 pCtx, //IWbemContext-Zeiger umgehen, um Sperrungen zu verhindern
								 &m_pDataClass, 
								 NULL);
    if(FAILED(hr))
	{
        return hr;
	}
	[!endif]
	    
    pInitSink->SetStatus(WBEM_S_INITIALIZED,0);
    return WBEM_S_NO_ERROR;
}


//////////////////////////////////////////////////////////////////////////////
// [!output CLASS_NAME]::ProvideEvents()
// In der MSDN-Dokumentation fr IWbemEventProvider::ProvideEvents()
// finden Sie weitere Einzelheiten ber die Implementierung dieser Methode.
	
STDMETHODIMP [!output CLASS_NAME]::ProvideEvents(
							IWbemObjectSink *pSink,
							long lFlags)
{
	//	WMI ruft diese Mehode auf, um den Ereigniszeiger zu aktivieren. 
	//  Aktion: Nach der Aufrufzurckgabe, geben Sie die Ereignisse, wenn Sie in 
	//          der Datensenkenschnittstelle erscheinen, an. Sie knnen einen  
	//	    unabhngigen Thread fr die Ereigniszustellungverarbeitung erstellen.
	[!if INTRINSIC]
	//  Rufen Sie FireCreationEvent()-, FireDeletionEvent()- und FireModificationEvent()-
	//  Methoden auf m_pHelper auf, um innere Ereignisse zu bermitteln.  
	[!endif]
	//  Rufen Sie ConstructErrorObject() auf m_pHelper auf, um einen Fehler oder Status an WMI zu melden. 
	
	//  Wichtig: Diesen Aufruf nicht lnger als ein paar Sekunden blockieren.

	if ( NULL == pSink )
	{
		return WBEM_E_INVALID_PARAMETER;
	}

	//Datensenkezeiger zwischenspeichern
	//Hinweis: m_pSink ist ein dynamischer Zeiger: AddRef() funktioniert automatisch
	m_pSink = pSink;
	
	pSink->SetStatus(0, WBEM_S_NO_ERROR, NULL, NULL);	
	return WBEM_S_NO_ERROR;
}

[!if EVENT_SECURITY ]

//////////////////////////////////////////////////////////////////////////////
// [!output CLASS_NAME]::AccessCheck()
// In der MSDN-Dokumentation fr IWbemEventProviderSecurity::AccessCheck()
// finden Sie weitere Einzelheiten ber die Implementierung dieser Methode.

STDMETHODIMP [!output CLASS_NAME]::AccessCheck(
						WBEM_CWSTR wszQueryLanguage,
						WBEM_CWSTR wszQuery,
						long lSidLength,
						const BYTE* pSid)
{
	return WBEM_S_NO_ERROR;
}
[!endif]

[!if QUERY_SINK ]

//////////////////////////////////////////////////////////////////////////////
// [!output CLASS_NAME]::CancelQuery()
// In der MSDN-Dokumentation fr IWbemEventProviderQuerySink::CancelQuery()
// finden Sie weitere Einzelheiten ber die Implementierung dieser Methode.

STDMETHODIMP [!output CLASS_NAME]::CancelQuery(
						unsigned long dwId)
{
	return WBEM_S_NO_ERROR;
}


//////////////////////////////////////////////////////////////////////////////
// [!output CLASS_NAME]::NewQuery()
// In der MSDN-Dokumentation fr IWbemEventProviderQuerySink::NewQuery()
// finden Sie weitere Einzelheiten ber die Implementierung dieser Methode.

STDMETHODIMP [!output CLASS_NAME]::NewQuery(
						unsigned long dwId,
						WBEM_WSTR wszQueryLanguage,
						WBEM_WSTR wszQuery)
{
	return WBEM_S_NO_ERROR;
}
[!endif]

[!if EXTRINSIC]	
//////////////////////////////////////////////////////////////////////////////
// [!output CLASS_NAME]::FireEvent()

STDMETHODIMP [!output CLASS_NAME]::FireEvent()
{
	//OPTIMIERUNGSHINWEIS: Die vom Assistenten erstellte Implementierung ist sehr simpel, 
	//aber falls Sie mehr als 1000 Ereignisse pro Sekunde zustellen, sollten Sie die
	//IWbemObjectAccess-Schnittstelle verwenden, um die Ereigniseigenschaften aufzufllen.
	//Auerdem sollten Sie eine Instanz der Ereignisklasse zwischenspeichern und mehrmals verwenden.

	ATLASSERT(m_pEventClass);

	CComPtr<IWbemClassObject> pEvtInstance;
    HRESULT hr = m_pEventClass->SpawnInstance(0, &pEvtInstance);
    if(FAILED(hr))
	{
		return hr;
	}

	//Eigenschaftenwerte des Ereignisobjekts auffllen:
	[!if CLASS_SPECIFIED]
    [!output EXTRINSIC_PUT_BLOCK]
	[!else]
	//AKTION: ndern Sie den folgenden kommentierten Code, um die Eigenschaftenwerte des Ereignisobjekts aufzufllen.
	//CComVariant var;
	//var.ChangeType(<type>);	//Passenden Variantentyp hier setzen
	//var = <value>;			//Passenden Wert hier setzen
	//hr = pEvtInstance->Put(CComBSTR(L"EventProperty1"), 0, &var, 0);
	//var.Clear();
	[!endif]

	hr = m_pSink->Indicate(1, &pEvtInstance );

	return hr;
}
[!endif]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vc7\beta1\vcwiz\classwiz\atl\instance\templates\1033\wmiprov.h ===
[!if  !INSTANCE]
//error: instance provider header template invoked for wrong provider type
[!else]
// [!output HEADER_FILE] : Declaration of the [!output CLASS_NAME]

#pragma once
#include "resource.h"       // main symbols

#include <wbemidl.h>
#include <atlwmiprov.h>
#include <wmiutils.h>	//path parser

//////////////////////////////////////////////////////////////////////////////
// Class, property  and method names: defined in [!output IMPL_FILE]

extern const WCHAR * s_pMyClassName;	//class name

[!if CLASS_SPECIFIED]
//properties:
[!output PROPERTY_DECLARATIONS]

//methods:
[!output METHOD_DECLARATIONS]
[!else]
//TODO: declare property names of the provided class, e.g.:
//extern const WCHAR * pMyProperty;

//TODO: declare method names of the provided class, e.g.:
//extern const WCHAR * pMyMethod;
[!endif]

[!if ATTRIBUTED]
[
	coclass,
[!if THREADING_APARTMENT]
	threading("apartment"),
[!endif]
[!if THREADING_BOTH]
	threading("both"),
[!endif]
[!if THREADING_FREE]
	threading("free"),
[!endif]
	aggregatable("never"),
	vi_progid("[!output VERSION_INDEPENDENT_PROGID]"),
	progid("[!output PROGID]"),
	version(1.0),
	uuid("[!output CLSID_REGISTRY_FORMAT]"),
	helpstring("[!output TYPE_NAME]")
]
[!endif]
/////////////////////////////////////////////////////////////////////////////
// [!output CLASS_NAME]

class ATL_NO_VTABLE [!output CLASS_NAME] : 
					[!if !ATTRIBUTED]
					[!if THREADING_APARTMENT]
						public CComObjectRootEx<CComSingleThreadModel>,
					[!endif]
					[!if THREADING_BOTH]
						public CComObjectRootEx<CComMultiThreadModel>,
					[!endif]
					[!if THREADING_FREE]
						public CComObjectRootEx<CComMultiThreadModel>,
					[!endif]
						public CComCoClass<[!output CLASS_NAME], &CLSID_[!output COCLASS]>,
					[!endif]
						public IWbemInstProviderImpl
{
	
	CComPtr<IWbemServices>  m_pNamespace; 	//cached IWbemServices pointer
	CComPtr<IWbemClassObject> m_pClass;		//cached provided class definition	   	
	CComPtr<IWbemClassObject> m_pErrorObject;//cached error object class definition pointer
	CComPtr<IClassFactory> m_pPathFactory;	 //cached pointer to path parser's class factory

	CInstanceProviderHelper * m_pHelper;
	
	STDMETHODIMP GetInstanceByPath (CComBSTR bstrPath,
									IWbemClassObject ** ppInstance );

  public:
	[!output CLASS_NAME]()
	{
		m_pHelper = NULL;					
	}

	~[!output CLASS_NAME]()
	{
	    if (NULL != m_pHelper)
		{
			delete m_pHelper;
		}
		//interface pointer data members are smart and get released automatically
	}
	
	[!if !ATTRIBUTED]
	DECLARE_REGISTRY_RESOURCEID(IDR_[!output UPPER_SHORT_NAME])

	DECLARE_NOT_AGGREGATABLE([!output CLASS_NAME])

	BEGIN_COM_MAP([!output CLASS_NAME])
		COM_INTERFACE_ENTRY(IWbemServices)
		COM_INTERFACE_ENTRY(IWbemProviderInit)
	END_COM_MAP()
	[!endif]

	//IWbemProviderInit
	HRESULT STDMETHODCALLTYPE Initialize( 
										LPWSTR pszUser,
										LONG lFlags,
										LPWSTR pszNamespace,
										LPWSTR pszLocale,
										IWbemServices *pNamespace,
										IWbemContext *pCtx,
										IWbemProviderInitSink *pInitSink);

	//IWbemServices
	HRESULT STDMETHODCALLTYPE GetObjectAsync(
										const BSTR ObjectPath,
										long lFlags,
										IWbemContext __RPC_FAR *pCtx,
										IWbemObjectSink __RPC_FAR *pResponseHandler);


	HRESULT STDMETHODCALLTYPE DeleteInstanceAsync(
										const BSTR ObjectPath,
										long lFlags,
										IWbemContext __RPC_FAR *pCtx,
										IWbemObjectSink __RPC_FAR *pResponseHandler);


	HRESULT STDMETHODCALLTYPE PutInstanceAsync(
										IWbemClassObject __RPC_FAR *pInst,
										long lFlags,
										IWbemContext __RPC_FAR *pCtx,
										IWbemObjectSink __RPC_FAR *pResponseHandler);


	HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync( 
										const BSTR Class,
										long lFlags,
										IWbemContext __RPC_FAR *pCtx,
										IWbemObjectSink __RPC_FAR *pResponseHandler);

	HRESULT STDMETHODCALLTYPE ExecQueryAsync( 
										const BSTR QueryLanguage,
										const BSTR Query,
										long lFlags,
										IWbemContext __RPC_FAR *pCtx,
										IWbemObjectSink __RPC_FAR *pResponseHandler);

	[!if PROVIDE_METHODS]
	HRESULT STDMETHODCALLTYPE ExecMethodAsync( 
										const BSTR strObjectPath,
										const BSTR strMethodName,
										long lFlags,
										IWbemContext __RPC_FAR *pCtx,
										IWbemClassObject __RPC_FAR *pInParams,
										IWbemObjectSink __RPC_FAR *pResponseHandler);
	[!else]
	HRESULT STDMETHODCALLTYPE ExecMethodAsync( 
										const BSTR strObjectPath,
										const BSTR strMethodName,
										long lFlags,
										IWbemContext __RPC_FAR *pCtx,
										IWbemClassObject __RPC_FAR *pInParams,
										IWbemObjectSink __RPC_FAR *pResponseHandler) 
	{	
		//NOTE:	if you decide to provide methods, you should 
		//create your implementation of ExecMethodAsync()
		return WBEM_E_NOT_SUPPORTED;
	}
	[!endif]

};

[!if !ATTRIBUTED]
OBJECT_ENTRY_AUTO(__uuidof([!output COCLASS]), [!output CLASS_NAME])
[!endif]

[!endif]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vc7\beta1\system\wbem\wmiscriptutils\commonfuncsunused.cpp ===
//This was alternative way to get to the internet host security manager (instead of using SID_SInternetHostSecurityManager)
#if 0
			if(FAILED(hr = GetDocument(pUnkControl, &pDoc)))
				__leave;

			if(FAILED(hr = pDoc->QueryInterface(IID_IInternetHostSecurityManager, (void**)&pSecMan)))
				__leave;
#endif









// This function shows how to get to the IHTMLDocument2 that created an
// arbitrary control represented by pUnk
HRESULT GetDocument(IUnknown *pUnk, IHTMLDocument2 **ppDoc)
{
	// If an ActiveX control is created in HTML, this function will return 
	// a pointer to the IHTMLDocument2.  To get to the IHTMLDocument2, controls
	// must implement IObjectWithSite.  If controls also implement IOleObject,
	// the method used to get to the IHTMLDocument2 is slightly different.
	// This function abstracts the difference between controls that implement
	// just IObjectWithSite and controls that implement BOTH IOleObject AND
	// IObjectWithSite.  This function also abstracts the different techniques
	// that need to be used depending on if the control was created through an
	// <OBJECT...> tag or if the control was created through JScript using
	// 'new ActiveXObject' or VBScript using 'CreateObject'
	HRESULT hr = E_FAIL;
	IOleObject *pOleObj = NULL;
	IObjectWithSite *pObjWithSite = NULL;
	IOleClientSite *pSite = NULL;
	IOleContainer *pContainer = NULL;
	IServiceProvider *pServProv = NULL;
	IWebBrowserApp *pWebApp = NULL;
	IDispatch *pDisp = NULL;

	__try
	{
		// Check if the ActiveX control supports IOleObject.
		if(SUCCEEDED(pUnk->QueryInterface(IID_IOleObject, (void**)&pOleObj)))
		{
			// If the control was created through an <OBJECT...> tag, IE will
			// have passed us an IOleClientSite.  If we have not been passed
			// an IOleClientSite, GetClientSite will still SUCCEED, but pSite
			// will be NULL.  In this case, we just go to the next section.
			if(SUCCEEDED(pOleObj->GetClientSite(&pSite)) && pSite)
			{
				// We were passed an IOleClientSite!!! We can call GetContainer
				// and QI for the IHTMLDocument2 that we need
				if(FAILED(hr = pSite->GetContainer(&pContainer)))
					__leave;
				hr = pContainer->QueryInterface(IID_IHTMLDocument2, (void**)ppDoc);

				// At this point, we are done and do not want to process the
				// code in the next seciont
				__leave;
			}
		}

		// At this point, one of two things has happened:
		// 1) We didn't support IOleObject
		// 2) We supported IOleObject, but we were never passed an IOleClientSite

		// In either case, we now need to look at IObjectWithSite to try to get
		// to our site
		if(FAILED(hr = pUnk->QueryInterface(IID_IObjectWithSite, (void**)&pObjWithSite)))
			__leave;

		// In case #1 above, we may have been passed an IOleClientSite to
		// IObjectWithSite::SetSite.  This happens if we were created with
		// an <OBJECT...> tag
		if(SUCCEEDED(pObjWithSite->GetSite(IID_IOleClientSite, (void**)&pSite)))
		{
			// We can now call GetContainer and QI for the IHTMLDocument2
			if(FAILED(hr = pSite->GetContainer(&pContainer)))
				__leave;
			hr = pContainer->QueryInterface(IID_IHTMLDocument2, (void**)ppDoc);
		}
		else
		{
			// If we were not passed an IOleClientSite, it is possible that
			// we were created dynamically (with 'new ActiveXObject' in JScript,
			// or 'CreateObject' in VBScript).  We can use the following steps
			// to get to the IHTMLDocument2 that created the control:
			// 1) QI for IServiceProvider
			// 2) Call QueryService to get an IWebBrowserApp
			// 3) Call get_Document to get the IDispatch of the document
			// 4) QI for the IHTMLDocument2 interface.
			if(FAILED(hr = pObjWithSite->GetSite(IID_IServiceProvider, (void**)&pServProv)))
				__leave;
#if 0
			if(FAILED(hr = pServProv->QueryService(SID_SWebBrowserApp, IID_IWebBrowserApp, (void**)&pWebApp)))
				__leave;
			if(FAILED(hr = pWebApp->get_Document(&pDisp)))
				__leave;
			hr = pDisp->QueryInterface(IID_IHTMLDocument2, (void**)ppDoc);
#endif
//			hr = pServProv->QueryService(SID_SContainerDispatch, IID_IHTMLDocument2, (void**)ppDoc);
			if(FAILED(hr = pServProv->QueryService(SID_SContainerDispatch, IID_IDispatch, (void**)&pDisp)))
				__leave;
			hr = pDisp->QueryInterface(IID_IHTMLDocument2, (void**)ppDoc);
		}
	}
	__finally
	{
		// Release any interfaces we used along the way
		if(pOleObj)
			pOleObj->Release();
		if(pObjWithSite)
			pObjWithSite->Release();
		if(pSite)
			pSite->Release();
		if(pContainer)
			pContainer->Release();
		if(pServProv)
			pServProv->Release();
		if(pWebApp)
			pWebApp->Release();
		if(pDisp)
			pDisp->Release();
	}
	return hr;
}




#if 0
// This function shows how to get to the IHTMLDocument2 that created a control
// in either situation (an <OBJECT...> tag or dynamically created controls in
// script).  It assumes that the control has just implement IObjectWithSite
// and NOT IOleObject.  If IOleObject is implemented, IE will NOT call
// IObjectWithSite::SetSite.
HRESULT GetDocumentFromObjectWithSite(IObjectWithSite *pObject, IHTMLDocument2 **ppDoc)
{
	// If an ActiveX control implements IObjectWithSite, this function will
	// return a pointer to the IHTMLDocument2 that is hosting the control 
	// (assuming that the control was created in an HTML page).
	// NOTE: If the ActiveX control has also implemented IOleObject, this
	// function cannot be used.  In that case, IE calls
	// IOleObject::SetClientSite instead of IObjectWithSite::SetSite to pass
	// the control an IOleClientSite object when the control is created in an
	// <OBJECT...> tag.  If the control is created dynamically in JScript with
	// 'new ActiveXObject' or VBScript with 'CreateObject', then
	// IObjectWithSite::SetSite is called.  If the ActiveXControl does not
	// implement IOleObject (but implements IObjectWithSite), IE will always
	// call IObjectWithSite::SetSite.  However, the object passed to SetSite
	// will still vary depending on if the control was created dynamically or
	// statically in an <OBJECT...> tag.  This function abstracts the
	// difference between the two situations.
	HRESULT hr = S_OK;
	IOleClientSite *pSite = NULL;
	IOleContainer *pContainer = NULL;
	IServiceProvider *pServProv = NULL;
	IWebBrowserApp *pWebApp = NULL;
	IDispatch *pDisp = NULL;

	__try
	{
		if(SUCCEEDED(pObject->GetSite(IID_IOleClientSite, (void**)&pSite)))
		{
			// If the ActiveX control that implemented IObjectWithSite was
			// created on an HTML page using the <OBJECT...> tag, IE will call
			// SetSite with an IID_IOleClientSite.  We can call GetContainer
			// and the QI for the IHTMLDocument2.
			if(FAILED(hr = pSite->GetContainer(&pContainer)))
				__leave;
			hr = pContainer->QueryInterface(IID_IHTMLDocument2, (void**)ppDoc);
		}
		else
		{
			// If the ActiveX control that implement IObjectWithSite was
			// created dynamically (with 'new ActiveXObject' in JScript, or
			// CreateObject in VBScript), we are passed a ??? object.  We can
			// QI for IServiceProvider, and get to an IWebBrowserApp through
			// QueryService.  Then, we can get IDispatch pointer of the 
			// document through get_Document, and finally QI for the
			// IHTMLDocument2 interface.
			if(FAILED(hr = pObject->GetSite(IID_IServiceProvider, (void**)&psp)))
				__leave;
			if(FAILED(hr = psp->QueryService(SID_SWebBrowserApp, IID_IWebBrowserApp, (void**)&pApp)))
				__leave;
			if(FAILED(hr = pApp->get_Document(&pDisp)))
				__leave;
			hr = pDisp->QueryInterface(IID_IHTMLDocument2, (void**)ppDoc);
		}
	}
	__finally
	{
		if(pSite)
			pSite->Release();
		if(pContainer)
			pContainer->Release();
		if(pServProv)
			pServProv->Release();
		if(pWebApp)
			pWebApp->Release();
		if(pDisp)
			pDisp->Release();
	}
	return hr;
}
#endif
#if 0
HRESULT CWMIObjectBroker::GetDocument(IHTMLDocument2 **ppDoc)
{
	HRESULT hr = S_OK;
	IOleClientSite *pSite = NULL;
//	if(SUCCEEDED(GetClientSite(&pSite)) && pSite)
	if(FALSE)
	{
		IOleContainer *pContainer;
		if(SUCCEEDED(hr = pSite->GetContainer(&pContainer)))
		{
			hr = pContainer->QueryInterface(IID_IHTMLDocument2, (void**)ppDoc);
			pContainer->Release();
		}
		pSite->Release();
	}
	else
	{
		IServiceProvider *psp = NULL;
		if(SUCCEEDED(hr = GetSite(IID_IServiceProvider, (void**)&psp)))
		{
			IWebBrowserApp *pApp = NULL;
			if(SUCCEEDED(hr = psp->QueryService(SID_SWebBrowserApp, IID_IWebBrowserApp, (void**)&pApp)))
			{
				IDispatch *pDisp;
				if(SUCCEEDED(hr = pApp->get_Document(&pDisp)))
				{
					hr = pDisp->QueryInterface(IID_IHTMLDocument2, (void**)ppDoc);
					pDisp->Release();
				}
				pApp->Release();
			}
			psp->Release();
		}
	}
	return hr;
}
#endif

#if 0
	IHTMLDocument2 *pDoc2 = NULL;
	GetDocument(&pDoc2);

	IOleClientSite *pSite = NULL;
//	GetClientSite(&pSite);
	if(!pSite)
	{
		HRESULT hr = S_OK;
		hr = GetSite(IID_IOleClientSite, (void**)&pSite);
		hr = GetSite(IID_IServiceProvider, (void**)&pSite);
//		hr = GetSite(IID_IActiveScript, (void**)&pSite);
		hr = GetSite(IID_IOleContainer, (void**)&pSite);
		IServiceProvider *psp = NULL;
		hr = GetSite(IID_IServiceProvider, (void**)&psp);
		IWebBrowserApp *pApp = NULL;
		hr = psp->QueryService(SID_SWebBrowserApp, IID_IWebBrowserApp, (void**)&pApp);
		BSTR bstr;
//		pApp->get_LocationURL(&bstr);
		IHTMLDocument2 *pDoc;
		IDispatch *pDisp;
		pApp->get_Document(&pDisp);
		pDisp->QueryInterface(IID_IHTMLDocument2, (void**)&pDoc);
		pDoc->get_URL(&bstr);
		bstr = NULL;
	}
	IOleContainer *pContainer;
	pSite->GetContainer(&pContainer);
	pSite->Release();
	IHTMLDocument2 *pDoc;
	pContainer->QueryInterface(IID_IHTMLDocument2, (void**)&pDoc);
	BSTR bstrURL = NULL;
	pDoc->get_URL(&bstrURL);
	SysFreeString(bstrURL);
	IHTMLDocument2 *pDocParent = NULL;
	IHTMLWindow2 *pWndParent = NULL;
	pDoc->get_parentWindow(&pWndParent);
	pWndParent->get_document(&pDocParent);
	pDocParent->get_URL(&bstrURL);
	SysFreeString(bstrURL);

	pDocParent->Release();
	IHTMLWindow2 *pWnd2 = NULL;
	pWndParent->get_top(&pWnd2);
	pWnd2->get_document(&pDocParent);
	pDocParent->get_URL(&bstrURL);
	SysFreeString(bstrURL);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vc7\beta1\vcwiz\classwiz\atl\instance\templates\1031\wmiprov.h ===
[!if  !INSTANCE]
//Fehler: Ereignisanbieter-Headervorlage wurde fr den falschen Anbietertyp aufgerufen.
[!else]
// [!output HEADER_FILE] : Deklaration von [!output CLASS_NAME]

#pragma once
#include "resource.h"       // Hauptsymbole

#include <wbemidl.h>
#include <atlwmiprov.h>
#include <wmiutils.h>	//Pfadparser

//////////////////////////////////////////////////////////////////////////////
// Klassen-, Eigenschaften- und Methodennamen: definiert in [!output IMPL_FILE]

extern const WCHAR * s_pMyClassName;	//Klassenname

[!if CLASS_SPECIFIED]
//Eigenschaften:
[!output PROPERTY_DECLARATIONS]

//Methoden:
[!output METHOD_DECLARATIONS]
[!else]
//Aktion: Deklarieren Sie die Eigenschaftennamen der angegebenen Klasse, z.B.:
//extern const WCHAR * pMyProperty;

//Aktion: Deklarieren Sie die Methodennamen der angegebenen Klasse, z.B.:
//extern const WCHAR * pMyMethod;
[!endif]

[!if ATTRIBUTED]
[
	coclass,
[!if THREADING_APARTMENT]
	threading("apartment"),
[!endif]
[!if THREADING_BOTH]
	threading("both"),
[!endif]
[!if THREADING_FREE]
	threading("free"),
[!endif]
	aggregatable("never"),
	vi_progid("[!output VERSION_INDEPENDENT_PROGID]"),
	progid("[!output PROGID]"),
	version(1.0),
	uuid("[!output CLSID_REGISTRY_FORMAT]"),
	helpstring("[!output TYPE_NAME]")
]
[!endif]
/////////////////////////////////////////////////////////////////////////////
// [!output CLASS_NAME]

class ATL_NO_VTABLE [!output CLASS_NAME] : 
					[!if !ATTRIBUTED]
					[!if THREADING_APARTMENT]
						public CComObjectRootEx<CComSingleThreadModel>,
					[!endif]
					[!if THREADING_BOTH]
						public CComObjectRootEx<CComMultiThreadModel>,
					[!endif]
					[!if THREADING_FREE]
						public CComObjectRootEx<CComMultiThreadModel>,
					[!endif]
						public CComCoClass<[!output CLASS_NAME], &CLSID_[!output COCLASS]>,
					[!endif]
						public IWbemInstProviderImpl
{
	
	CComPtr<IWbemServices>  m_pNamespace; 	//Zwischengespeicherter IWbemServices-Zeiger
	CComPtr<IWbemClassObject> m_pClass;	//Zwischengespeicherte angegebene Klassendefinition	   	
	CComPtr<IWbemClassObject> m_pErrorObject;//Zwischengespeicherter Klassendefinitionszeiger des Fehlerobjekts
	CComPtr<IClassFactory> m_pPathFactory;	 //Zwischengespeicherter Zeiger zur Klassenherstellung des Pfadparsers

	CInstanceProviderHelper * m_pHelper;
	
	STDMETHODIMP GetInstanceByPath (CComBSTR bstrPath,
									IWbemClassObject ** ppInstance );

  public:
	[!output CLASS_NAME]()
	{
		m_pHelper = NULL;					
	}

	~[!output CLASS_NAME]()
	{
	    if (NULL != m_pHelper)
		{
			delete m_pHelper;
		}
		//Schnittstellenzeiger-Datenmitglieder sind dynamisch und werden automatisch freigegeben
	}
	
	[!if !ATTRIBUTED]
	DECLARE_REGISTRY_RESOURCEID(IDR_[!output UPPER_SHORT_NAME])

	DECLARE_NOT_AGGREGATABLE([!output CLASS_NAME])

	BEGIN_COM_MAP([!output CLASS_NAME])
		COM_INTERFACE_ENTRY(IWbemServices)
		COM_INTERFACE_ENTRY(IWbemProviderInit)
	END_COM_MAP()
	[!endif]

	//IWbemProviderInit
	HRESULT STDMETHODCALLTYPE Initialize( 
										LPWSTR pszUser,
										LONG lFlags,
										LPWSTR pszNamespace,
										LPWSTR pszLocale,
										IWbemServices *pNamespace,
										IWbemContext *pCtx,
										IWbemProviderInitSink *pInitSink);

	//IWbemServices
	HRESULT STDMETHODCALLTYPE GetObjectAsync(
										const BSTR ObjectPath,
										long lFlags,
										IWbemContext __RPC_FAR *pCtx,
										IWbemObjectSink __RPC_FAR *pResponseHandler);


	HRESULT STDMETHODCALLTYPE DeleteInstanceAsync(
										const BSTR ObjectPath,
										long lFlags,
										IWbemContext __RPC_FAR *pCtx,
										IWbemObjectSink __RPC_FAR *pResponseHandler);


	HRESULT STDMETHODCALLTYPE PutInstanceAsync(
										IWbemClassObject __RPC_FAR *pInst,
										long lFlags,
										IWbemContext __RPC_FAR *pCtx,
										IWbemObjectSink __RPC_FAR *pResponseHandler);


	HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync( 
										const BSTR Class,
										long lFlags,
										IWbemContext __RPC_FAR *pCtx,
										IWbemObjectSink __RPC_FAR *pResponseHandler);

	HRESULT STDMETHODCALLTYPE ExecQueryAsync( 
										const BSTR QueryLanguage,
										const BSTR Query,
										long lFlags,
										IWbemContext __RPC_FAR *pCtx,
										IWbemObjectSink __RPC_FAR *pResponseHandler);

	[!if PROVIDE_METHODS]
	HRESULT STDMETHODCALLTYPE ExecMethodAsync( 
										const BSTR strObjectPath,
										const BSTR strMethodName,
										long lFlags,
										IWbemContext __RPC_FAR *pCtx,
										IWbemClassObject __RPC_FAR *pInParams,
										IWbemObjectSink __RPC_FAR *pResponseHandler);
	[!else]
	HRESULT STDMETHODCALLTYPE ExecMethodAsync( 
										const BSTR strObjectPath,
										const BSTR strMethodName,
										long lFlags,
										IWbemContext __RPC_FAR *pCtx,
										IWbemClassObject __RPC_FAR *pInParams,
										IWbemObjectSink __RPC_FAR *pResponseHandler) 
	{	
		//Hinweis: Wenn Sie Methoden anbieten, sollten Sie
		//eine Implementierung von ExecMethodAsync() erstellen
		return WBEM_E_NOT_SUPPORTED;
	}
	[!endif]

};

[!if !ATTRIBUTED]
OBJECT_ENTRY_AUTO(__uuidof([!output COCLASS]), [!output CLASS_NAME])
[!endif]

[!endif]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vc7\beta1\vcwiz\classwiz\atl\event\templates\1041\wmiprov.cpp ===
// [!output IMPL_FILE] : [!output CLASS_NAME] ̎
#include "stdafx.h"
#include "[!output PROJECT_NAME].h"
#include "[!output HEADER_FILE]"


/////////////////////////////////////////////////////////////////////////////
// [!output CLASS_NAME]

// dv: ȉɒ`Ă镶̓[JCYł܂B

// NX
[!if CLASS_SPECIFIED]
const static WCHAR * s_pMyClassName = L"[!output WMICLASSNAME]"; 
[!if EXTRINSIC]
//Cxg NX [!output WMICLASSNAME] ̃vpeB:
[!output EXTR_PROPERTY_DEFINITIONS]
[!endif]
[!else]
//TODO: 񋟂ꂽNX`ĂB:
const static WCHAR * s_pMyClassName = L"MyClassName"; 
[!endif]


//////////////////////////////////////////////////////////////////////////////
// [!output CLASS_NAME]::Initialize()
// ̃\bh̎ɂĂ̏ڍׂ́AIWbemProviderInit::Initialize()
//  MSDN hLgQƂĂB

STDMETHODIMP [!output CLASS_NAME]::Initialize(LPWSTR pszUser,	
									  LONG lFlags,
									  LPWSTR pszNamespace,
									  LPWSTR pszLocale,
									  IWbemServices *pNamespace,
									  IWbemContext *pCtx,
																																							IWbemProviderInitSink *pInitSink) 
{
	
	HRESULT hr = WBEM_E_FAILED;
	if ( NULL == pNamespace || NULL == pInitSink) 
	{
        return WBEM_E_INVALID_PARAMETER;
	}

	//IWbemServices |C^LbV܂B
	//: m_pNamespace ́AX}[g |C^łBI AddRef() ܂B
	m_pNamespace = pNamespace;
					
	[!if INTRINSIC]	
	//helper IuWFNg擾܂B
	m_pHelper = new CIntrinsicEventProviderHelper(pNamespace, pCtx);

	[!endif]
	
	[!if EXTRINSIC]	
	//Cxg NX̒`ۑ܂B				
	//: ȉ̃R[h́AvoC_̎s̓Cxg NX̒`A
	//ύXȂƉ肵Ă܂BύXꍇ́ANX̏CCxgƍ폜Cxgp
	//RV[}Kv܂BCxg RV[}ɂẮA
	//MSDN  WMI hLgQƂĂB
	hr = m_pNamespace->GetObject(CComBSTR(s_pMyClassName), 
								0, 
								pCtx, //fbhbNȂ悤 IWbemContext |C^n܂B
								&m_pEventClass, 
								NULL);

    if(FAILED(hr))
	{
        return hr;
	}

	//helper IuWFNg擾܂B
	m_pHelper = new CProviderHelper(pNamespace, pCtx);

    [!endif]
	[!if INTRINSIC]
	//^[Qbg̃NX̒`ۑ܂B
	hr = m_pNamespace->GetObject(CComBSTR(s_pMyClassName), 
								 0, 
								 pCtx, //fbhbNȂ悤 IWbemContext |C^n܂B
								 &m_pDataClass, 
								 NULL);
    if(FAILED(hr))
	{
        return hr;
	}
	[!endif]
	    
    pInitSink->SetStatus(WBEM_S_INITIALIZED,0);
    return WBEM_S_NO_ERROR;
}


//////////////////////////////////////////////////////////////////////////////
// [!output CLASS_NAME]::ProvideEvents()
// ̃\bh̎ɂĂ̏ڍׂ́AIWbemEventProvider::ProvideEvents()
//  MSDN hLgQƂĂB
	
STDMETHODIMP [!output CLASS_NAME]::ProvideEvents(
							IWbemObjectSink *pSink,
							long lFlags)
{
	//  WMI ̓Cxg voC_ANeBuɂ邽߂ɂ̃\bhĂяo܂B
	//  TODO: ̌ĂяoԂA^ꂽVN C^[tFCX̂
	//  Cxg̔zMJnĂBCxg̔zz邽߂ɁA
	//  ƗXbh쐬邱Ƃł܂B
	[!if INTRINSIC]
	//  gݍ݃Cxgzz邽߂ɁAm_pHelper  FireCreationEvent()AFireDeletionEvent()A
	//  FireModificationEvent() \bhĂяo܂B 
	[!endif]
	//  WMI ɏڂG[܂͏Ԃ񍐂邽߂ɁAm_pHelper  ConstructErrorObject() ĂяoƂł܂B
	
	//  dv: ̌Ăяo𐔕bȏubNȂłB

	if ( NULL == pSink )
	{
		return WBEM_E_INVALID_PARAMETER;
	}

	//LbV VN |C^
	//: m_pSink ̓X}[g|C^ŁAI AddRef() ܂B
	m_pSink = pSink;
	
	pSink->SetStatus(0, WBEM_S_NO_ERROR, NULL, NULL);	
	return WBEM_S_NO_ERROR;
}

[!if EVENT_SECURITY ]

//////////////////////////////////////////////////////////////////////////////
// [!output CLASS_NAME]::AccessCheck()
// ̃\bh̎ɂĂ̏ڍׂ́AIWbemEventProviderSecurity::AccessCheck()
//  MSDN hLgQƂĂB 

STDMETHODIMP [!output CLASS_NAME]::AccessCheck(
						WBEM_CWSTR wszQueryLanguage,
						WBEM_CWSTR wszQuery,
						long lSidLength,
						const BYTE* pSid)
{
	return WBEM_S_NO_ERROR;
}
[!endif]

[!if QUERY_SINK ]

//////////////////////////////////////////////////////////////////////////////
// [!output CLASS_NAME]::CancelQuery()
// ̃\bh̎ɂĂ̏ڍׂ́AIWbemEventProviderQuerySink::CancelQuery()
//  MSDN hLgQƂĂB

STDMETHODIMP [!output CLASS_NAME]::CancelQuery(
						unsigned long dwId)
{
	return WBEM_S_NO_ERROR;
}


//////////////////////////////////////////////////////////////////////////////
// [!output CLASS_NAME]::NewQuery()
// ̃\bh̎ɂĂ̏ڍׂ́AIWbemEventProviderQuerySink::NewQuery() 
//  MSDN hLgQƂĂB

STDMETHODIMP [!output CLASS_NAME]::NewQuery(
						unsigned long dwId,
						WBEM_WSTR wszQueryLanguage,
						WBEM_WSTR wszQuery)
{
	return WBEM_S_NO_ERROR;
}
[!endif]

[!if EXTRINSIC]	
//////////////////////////////////////////////////////////////////////////////
// [!output CLASS_NAME]::FireEvent()

STDMETHODIMP [!output CLASS_NAME]::FireEvent()
{
	//œK̒: ECU[hɂĐCvg͊ȒPłA
	//b 1000 ȏ̃CxgzMꍇ́ACxg voeB
	//͂邽߂ IWbemObjectAccess C^[tFCXgƂł܂B 
	//܂ACxg NX̃CX^XLbVčėp邱Ƃł܂B

	ATLASSERT(m_pEventClass);

	CComPtr<IWbemClassObject> pEvtInstance;
    HRESULT hr = m_pEventClass->SpawnInstance(0, &pEvtInstance);
    if(FAILED(hr))
	{
		return hr;
	}

	//Cxg IuWFNg̃vpeB̒l𐳂͂ĂB:
	[!if CLASS_SPECIFIED]
    [!output EXTRINSIC_PUT_BLOCK]
	[!else]
	//TODO: Cxg̃IuWFNg̃vpeB̒l͂邽߂Ɏ̃R}h R[hCĂB
	//CComVariant var;
	//var.ChangeType(<type>);	//ɓK؂ȃoAg ^Cv͂ĂB
	//var = <value>;			//ɓK؂Ȓl͂ĂB
	//hr = pEvtInstance->Put(CComBSTR(L"EventProperty1"), 0, &var, 0);
	//var.Clear();
	[!endif]

	hr = m_pSink->Indicate(1, &pEvtInstance );

	return hr;
}
[!endif]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vc7\system\wbem\wmiscriptutils\commonfuncs.h ===
#pragma once

HRESULT IsCreateObjectAllowed(IUnknown *pUnk, BSTR strProgId, BSTR *pstrValueName);
HRESULT RegisterCurrentDoc(IUnknown *pUnk, BSTR strProgId);
HRESULT UnRegisterCurrentDoc(IUnknown *pUnk, BSTR strProgId);
HRESULT SafeCreateObject(IUnknown *pUnkControl, BOOL fSafetyEnabled, CLSID clsid, IUnknown **ppUnk);
BOOL IsInternetHostSecurityManagerAvailable(IUnknown *pUnkControl);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vc7\beta1\vcwiz\classwiz\atl\instance\templates\1033\wmiprov.cpp ===
// [!output IMPL_FILE] : Implementation of [!output CLASS_NAME]
#include "stdafx.h"
#include "[!output PROJECT_NAME].h"
#include "[!output HEADER_FILE]"


/////////////////////////////////////////////////////////////////////////////
// [!output CLASS_NAME]

//////////////////////////////////////////////////////////////////////////////
// Class, property and method names

// IMPORTANT: the strings defined below are not localizable

[!if CLASS_SPECIFIED]
const static WCHAR * s_pMyClassName = L"[!output WMICLASSNAME]"; //class name

//properies:
[!output PROPERTY_DEFINITIONS]

//methods:
[!output METHOD_DEFINITIONS]

[!else]
//TODO: define provided class name, e.g.:
const static WCHAR * s_pMyClassName = L"MyClassName"; 

//TODO: define property names of the provided class, e.g.:
//const static WCHAR * pMyProperty = L"MyProperty";

//TODO: define method names of the provided class, e.g.:
//const static WCHAR * pMyMethod = L"MyMethod";
[!endif]

//////////////////////////////////////////////////////////////////////////////
// [!output CLASS_NAME]::Initialize
//Refer to MSDN documentation for IWbemProviderInit::Initialize()
//for details about implementing this method

STDMETHODIMP [!output CLASS_NAME]::Initialize(LPWSTR pszUser,	
									  LONG lFlags,
									  LPWSTR pszNamespace,
									  LPWSTR pszLocale,
									  IWbemServices *pNamespace,
							 		  IWbemContext *pCtx,
									  IWbemProviderInitSink *pInitSink) 
{

	if ( NULL == pNamespace || NULL == pInitSink) 
	{
        return WBEM_E_INVALID_PARAMETER;
	}

  	//cache IWbemServices pointer 
	//Note: m_pNamespace is a smart pointer, so it AddRef()'s automatically
	m_pNamespace = pNamespace;
				
	//cache provided class definition
	//NOTE: the code below assumes that your class definition doesn't change while
	//your provider is running.  If this is not true, you should implement a consumer
	//for class modification ans class deletion events. Refer to WMI documentation
	//for event consumers on MSDN.
	
    HRESULT hr = m_pNamespace->GetObject(CComBSTR(s_pMyClassName), 
											0, 
											pCtx, 	//passing IWbemContext pointer to prevent deadlocks
											&m_pClass, 
											NULL);
    if(FAILED(hr))
	{
        return WBEM_E_FAILED;
	}    
	
	//cache path parser class factory
	hr = CoGetClassObject(CLSID_WbemDefPath, 
							CLSCTX_INPROC_SERVER, 
							NULL,
							IID_IClassFactory,
							(void **) &m_pPathFactory);
	if (FAILED(hr))
	{
		return WBEM_E_FAILED;
	}

	//create helper object
	m_pHelper = new CInstanceProviderHelper(pNamespace, pCtx);

	//NOTE: to report a detailed error or status to WMI, you can call 
	//ConstructErrorObject() on m_pHelper anywhere in your provider

    pInitSink->SetStatus(WBEM_S_INITIALIZED,0);
    return WBEM_S_NO_ERROR;
}

//////////////////////////////////////////////////////////////////////////////
// [!output CLASS_NAME]::GetObjectAsync
// Refer to MSDN documentation for IWbemServices::GetObjectAsync()
// for details about implementing this method

STDMETHODIMP [!output CLASS_NAME]::GetObjectAsync( 
							 const BSTR bstrObjectPath,
							 long lFlags,
							 IWbemContext  *pCtx,
							 IWbemObjectSink  *pResponseHandler)
{
    
	//bugbug: per-property retrieval?
    [!if SUPPORT_GET ]
	if (NULL == pResponseHandler)
	{
	     return WBEM_E_INVALID_PARAMETER;
	}

	CComPtr<IWbemClassObject> pInstance;
	HRESULT hr = GetInstanceByPath(bstrObjectPath, &pInstance);
	if (FAILED (hr))
	{
		return hr;
	}
			   
   	//if all is well, return the object to WMI and indicate success:
    pResponseHandler->Indicate (1, &pInstance); 
	pResponseHandler->SetStatus(0, WBEM_S_NO_ERROR, NULL, NULL);

    return WBEM_S_NO_ERROR;
	[!else]
    return WBEM_E_PROVIDER_NOT_CAPABLE;
	[!endif]
}

//////////////////////////////////////////////////////////////////////////////
// [!output CLASS_NAME]::PutInstanceAsync()
// Refer to MSDN documentation for IWbemServices::PutInstanceAsync()
// for details about implementing this method

STDMETHODIMP [!output CLASS_NAME]::PutInstanceAsync( 
							IWbemClassObject  *pInst,
							long lFlags,
							IWbemContext  *pCtx,
							IWbemObjectSink  *pResponseHandler)
{
   
	[!if SUPPORT_PUT ]
	if ( NULL == pResponseHandler || NULL == pInst)
	{
        return WBEM_E_INVALID_PARAMETER;
	}
	//TODO: examine possible flag values: WBEM_FLAG_UPDATE_ONLY, 
	//WBEM_FLAG_CREATE_ONLY and WBEM_FLAG_CREATE_OR_UPDATE
	//and choose the level of support you need and return WBEM_E_PROVIDER_NOT_CAPABLE
	//for flag values you do not support

	//TODO: if you are planning to support partial updates, examine pCtx 
	//for "__PUT_EXTENSIONS" and other relevant system context values
	//and update your instance data appropriately
	
	//TODO: handle the instance update or creation here			
	
	pResponseHandler->SetStatus(0, WBEM_S_NO_ERROR, NULL, NULL);
	return WBEM_S_NO_ERROR;
	[!else]
	return WBEM_E_PROVIDER_NOT_CAPABLE;
	[!endif]
}


//////////////////////////////////////////////////////////////////////////////
// [!output CLASS_NAME]::DeleteInstanceAsync()
// Refer to MSDN help for IWbemServices::DeleteInstanceAsync()
// for details about implementing this method

STDMETHODIMP [!output CLASS_NAME]::DeleteInstanceAsync( 
							const BSTR ObjectPath,
							long lFlags,
							IWbemContext  *pCtx,
							IWbemObjectSink  *pResponseHandler)
{
	//To implement this method, an instance provider parses the object path string 
	//specified in the strObjectPath parameter and attempts to locate the corresponding 
	//instance and delete it.
	[!if SUPPORT_DELETE ]

	if (NULL == pResponseHandler)
	{
		return WBEM_E_INVALID_PARAMETER;
	}
    
	[!if IS_COMPOUND_KEY]
	ULONG ulPathTest = WBEMPATH_INFO_IS_INST_REF | WBEMPATH_INFO_IS_COMPOUND;
	[!else]
	[!if IS_SINGLETON]
	ULONG ulPathTest = WBEMPATH_INFO_IS_INST_REF | WBEMPATH_INFO_CONTAINS_SINGLETON;
	[!else]
	ULONG ulPathTest = WBEMPATH_INFO_IS_INST_REF;
	[!endif]
	[!endif]
		
	if (FAILED(m_pHelper->CheckInstancePath(m_pPathFactory,
											ObjectPath,
											CComBSTR(s_pMyClassName),
											ulPathTest)) )
	{
		//syntax error in path or path incorrect for class provided
		return WBEM_E_INVALID_PARAMETER; 
	}			
	
	[!if IS_SINGLETON]
	//NOTE: [!output WMICLASSNAME] is a singleton object. No need to identify the instance.
	//NOTE: If the instance is not present, uncomment the following line to communicate this back to WMI:
	//return WBEM_E_NOT_FOUND;
	[!else]
	//Create path parser object
	CComPtr<IWbemPath>pPath;
	HRESULT hr = m_pPathFactory->CreateInstance(NULL,
												IID_IWbemPath,
												(void **) &pPath);
	if (FAILED(hr))
	{
		return WBEM_E_FAILED;
	}
	
	CComPtr<IWbemPathKeyList> pIKeyList;
	hr = pPath->GetKeyList(&pIKeyList);
	if (FAILED(hr))
	{
		return hr;
	}
	
	unsigned long ulNumKeys;
	hr = pIKeyList->GetCount(&ulNumKeys);

	//Get values of key properties
	unsigned long uKeyNameBufferSize = CComBSTR(ObjectPath).Length() + 1;
	WCHAR * wKeyName = new WCHAR[uKeyNameBufferSize];
	if (NULL == wKeyName)
	{
		return WBEM_E_OUT_OF_MEMORY;
	}
	CComVariant vValue;
	unsigned long ulApparentCimType;
	for (unsigned long i = 0; i < ulNumKeys; i++)
	{			
		hr = pIKeyList->GetKey2(i, 0L, &uKeyNameBufferSize, 
								wKeyName, &vValue, &ulApparentCimType);			
		//TODO: save vValue for later use
	}
	delete[] wKeyName;

	//TODO: iterate through your data source to find the matching object and delete it.
	//NOTE: If you don't find an object that matches key values indicated in the path,
	//uncomment the following line to communicate this back to WMI:
	//return WBEM_E_NOT_FOUND;
	[!endif]	

	pResponseHandler->SetStatus(0, WBEM_S_NO_ERROR, NULL, NULL);	
    return WBEM_S_NO_ERROR;
	
	[!else]
	return WBEM_E_PROVIDER_NOT_CAPABLE;
	[!endif]
}


//////////////////////////////////////////////////////////////////////////////
// [!output CLASS_NAME]::CreateInstanceEnumAsync()
// Refer to MSDN documentation for IWbemServices::CreateInstanceEnumAsync()
// for details about implementing this method

STDMETHODIMP [!output CLASS_NAME]::CreateInstanceEnumAsync( 
							const BSTR Class,
							long lFlags,
							IWbemContext  *pCtx,
							IWbemObjectSink  *pResponseHandler)
{
	

	//NOTE: It is important to note that the instance provider has acquired a thread from WMI 
	//to perform these operations. It may be desirable to call the sink AddRef() method and create 
	//another thread for delivering the objects in the result set. 
	//This strategy allows the current thread to return to WMI without depleting the thread pool. 
	//Whether the provider chooses the single thread design over the dual thread design depends on how 
	//long the provider plans on using the WMI thread.

	[!if SUPPORT_ENUMERATE ]
	if (NULL == pResponseHandler)
	{
	    return WBEM_E_INVALID_PARAMETER;
	}

	HRESULT hr = WBEM_S_NO_ERROR;
	
	[!if IS_SINGLETON]
	// Prepare an empty object to receive the instance data
    CComPtr<IWbemClassObject> pNewInst;
    hr = m_pClass->SpawnInstance(0, &pNewInst);
		
	CComVariant var;
	[!if CLASS_SPECIFIED]
	[!output POPULATE_INSTANCE]
	[!else]
	//TODO: populate the instance with properties, e.g.:
	//CComVariant var;
	//var.ChangeType(VT_BSTR);
	//var = <value>;  //put appropriate value here
	//hr = pNewInst->Put(CComBSTR(pMyProperty), 0, &var, 0);
	//var.Clear();
	[!endif]
		
	// Deliver the class to WMI.
    pResponseHandler->Indicate(1, &pNewInst);
	[!else]
    // Loop through the private source and create each instance
	//while (<there's more instances>)
    {
		// Prepare an empty object to receive the class definition.
        CComPtr<IWbemClassObject> pNewInst;
        hr = m_pClass->SpawnInstance(0, &pNewInst);
		if (FAILED(hr))
		{	
			//TODO: uncomment the line below once the loop condition is in place
			//break;
		}
		
		CComVariant var;
		[!if CLASS_SPECIFIED]
		[!output POPULATE_INSTANCE]
		[!else]
		//TODO: populate the instance with properties, e.g.:
		//CComVariant var;
		//var.ChangeType(VT_BSTR);
		//var = <value>;  //put appropriate value here
		//hr = pNewInst->Put(CComBSTR(pMyProperty), 0, &var, 0);
		//var.Clear();
		[!endif]
		
		// Deliver the class to WMI.
        pResponseHandler->Indicate(1, &pNewInst);
    }  	
	[!endif]
	pResponseHandler->SetStatus(0, hr, NULL, NULL);
   	return WBEM_S_NO_ERROR;
	[!else]
	return WBEM_E_PROVIDER_NOT_CAPABLE;
	[!endif]
}


//////////////////////////////////////////////////////////////////////////////
//[!output CLASS_NAME]::ExecQueryAsync()
// Refer to MSDN documentation for IWbemServices::ExecQueryAsync()
// for details about implementing this method

STDMETHODIMP [!output CLASS_NAME]::ExecQueryAsync( 
							const BSTR QueryLanguage,
							const BSTR Query,
							long lFlags,
							IWbemContext  *pCtx,
							IWbemObjectSink  *pResponseHandler)
{
	
	
   	// Instance providers have the option of supporting query processing or relying on WMI 
	// for that service. To support queries, an instance provider must be capable of parsing 
	// simple Structured Query Language (SQL) statements, executing the requested query, 
	// and delivering the result set objects to the requester's sink. 
	
	//TODO: put your query processing code here
	
	//pResponseHandler->SetStatus(0, WBEM_S_NO_ERROR, NULL, NULL);
	// return WBEM_S_NO_ERROR;

	return WBEM_E_PROVIDER_NOT_CAPABLE;
	
}

[!if PROVIDE_METHODS ]

//////////////////////////////////////////////////////////////////////////////
// [!output CLASS_NAME]::ExecMethodAsync()
// Refer to MSDN documentation for IWbemServices::ExecMethodAsync()
// for details about implementing this method

STDMETHODIMP [!output CLASS_NAME]::ExecMethodAsync( 
							const BSTR strObjectPath,
							const BSTR strMethodName,
							long lFlags,
							IWbemContext  *pCtx,
							IWbemClassObject  *pInParams,
							IWbemObjectSink  *pResponseHandler)
{
	

	[!if CLASS_SPECIFIED]
	[!if  !HAS_IMPL_METHODS]	
	//[!output WMICLASSNAME] has no implemented methods	
	return WBEM_E_NOT_SUPPORTED;
	[!else]
	HRESULT hr = WBEM_E_FAILED;	
    if (NULL == pResponseHandler)
	{
        return WBEM_E_INVALID_PARAMETER;
	}	
	[!output EXEC_METHOD_BODY]
	[!endif]
	[!else]
	
	//Check that class name in the path is correct.
	//Get path parser object:
	CComPtr<IWbemPath>pPath;
	HRESULT hr = m_pPathFactory->CreateInstance(NULL,
												IID_IWbemPath,
												(void **) &pPath);
	if (FAILED(hr))
	{
		return WBEM_E_FAILED;
	}

	HRESULT hr = pPath->SetText(WBEMPATH_CREATE_ACCEPT_ALL, strObjectPath);
	long nPathLen = CComBSTR(strObjectPath).Length();
	unsigned long ulBufLen = nPathLen + 1;
	WCHAR * wClass = new WCHAR[nPathLen];
	if (NULL == wClass)
	{
		return WBEM_E_OUT_OF_MEMORY;
	}
	pPath->GetClassName(&ulBufLen, wClass);
	if ( _wcsicmp(s_pMyClassName, wClass))
	{
		delete[] wClass;
		return WBEM_E_INVALID_PARAMETER;
	}
	delete[] wClass;
	//TODO: compare requested method name with methods of your class
	//if (!_wcsicmp (strMethodName, pMyNonStaticMethod))
	{
		CComVariant var;

		//Get input arguments:
		//TODO: if the method has input arguments, they will be passed as properties of
		//the pInParams object. The commented line below demonstrates how to extract these:
		//hr = pInParams->Get(CComBSTR("InputArgument1"), 0, &var, NULL, NULL);
		//TODO: save input parameter value
		var.Clear();		
		
		//parse path to find instance for method execution: for a non-static method
		CComPtr<IWbemPathKeyList> pIKeyList;
		hr = pPath->GetKeyList(&pIKeyList);
		if (FAILED(hr))
		{
			return WBEM_E_INVALID_PARAMETER;
		}
		unsigned long ulNumKeys;
		hr = pIKeyList->GetCount(&ulNumKeys);
		//Get values of key properties:
		unsigned long uKeyNameBufferSize = nPathLen + 1;
		WCHAR  * wKeyName = new WCHAR[uKeyNameBufferSize];
		if (NULL == wKeyName)
		{
			return WBEM_E_OUT_OF_MEMORY;
		}
		CComVariant vValue;
		unsigned long ulApparentCimType;
		for (unsigned long i = 0; i < ulNumKeys; i++)
		{
			hr = pIKeyList->GetKey2(i, 0L, &uKeyNameBufferSize,
									wKeyName, &vValue, &ulApparentCimType);
			//TODO: save vValue for later use
		}
		delete[] wKeyName;
	
		//TODO: iterate through your data source to find the matching object
		
		//TODO: add code to execute the method here
		//get output parameters class
		CComPtr<IWbemClassObject> pOutClass;
		hr = m_pClass->GetMethod(CComBSTR("Method1"), 0, NULL, &pOutClass);
		CComPtr<IWbemClassObject> pOutParams;
		pOutClass->SpawnInstance(0, &pOutParams);
		//TODO: create output parameters by filling properties
		//of pOutParams class. For example:

		//var.ChangeType(VT_BSTR);
		//fill var with appropriate value
		//hr = pOutParams->Put(CComBSTR("MyOutputParameter"), 0, &var, 0);
		//var.Clear();
		//var.ChangeType(VT_I2);
		//fill var with appropriate value
		//hr = pOutParams->Put(CComBSTR("ReturnValue"), 0, &var, 0);
		//var.Clear();
		// Send the output object back to the client via the sink
		hr = pResponseHandler->Indicate(1, &pOutParams);
		
		pResponseHandler->SetStatus(0, WBEM_S_NO_ERROR, NULL, NULL);
		return WBEM_S_NO_ERROR;
	}
	
	//method name not recognized
	return WBEM_E_INVALID_PARAMETER;
	
	
	[!endif]	
}
[!endif]



//////////////////////////////////////////////////////////////////////////////
// [!output CLASS_NAME]::GetInstanceByPath() parses the path to find out required key values,
// then searhces the internal store for an object with matching key values. If such
// an object is found, the method spawns a new instance, fills all properties and
// returns it in ppInstance. If not, the method returns WBEM_E_NOT_FOUND.
// bugbug: partial-instance provision???  other possible flags?

STDMETHODIMP [!output CLASS_NAME]::GetInstanceByPath (
													/*in*/CComBSTR bstrPath,
													/*out*/IWbemClassObject ** ppInstance )
													
{
		HRESULT hr = WBEM_E_FAILED;				  
		
		[!if IS_COMPOUND_KEY]
		ULONG ulPathTest = WBEMPATH_INFO_IS_INST_REF | WBEMPATH_INFO_IS_COMPOUND;
		[!else]
		[!if IS_SINGLETON]
		ULONG ulPathTest = WBEMPATH_INFO_IS_INST_REF | WBEMPATH_INFO_CONTAINS_SINGLETON;
		[!else]
		ULONG ulPathTest = WBEMPATH_INFO_IS_INST_REF;
		[!endif]
		[!endif]
		
		if (FAILED(m_pHelper->CheckInstancePath(m_pPathFactory,
												bstrPath,
												CComBSTR(s_pMyClassName),
												ulPathTest)))
		{
			//syntax error in path or path incorrect for class provided
			return WBEM_E_INVALID_PARAMETER; 
		}			
		
		[!if IS_SINGLETON]
		//[!output WMICLASSNAME] is a singleton object. No need to identify the instance.
		//NOTE: If the instance is not present, uncomment the following line to communicate this back to WMI:
		//return WBEM_E_NOT_FOUND;
		[!else]
		//Get path parser object:
		CComPtr<IWbemPath>pPath;
		hr = m_pPathFactory->CreateInstance(NULL,
												IID_IWbemPath,
												(void **) &pPath);
		if (FAILED(hr))
		{
			return WBEM_E_FAILED;
		}
		
		hr = pPath->SetText(WBEMPATH_CREATE_ACCEPT_ALL,
									bstrPath);

		CComPtr<IWbemPathKeyList> pIKeyList;
		hr = pPath->GetKeyList(&pIKeyList);
		if (FAILED(hr))
		{
			return hr;
		}
		unsigned long ulNumKeys;
		hr = pIKeyList->GetCount(&ulNumKeys);

		//Get values of key properties
		unsigned long uKeyNameBufferSize = bstrPath.Length() + 1;
		WCHAR  * wKeyName = new WCHAR[uKeyNameBufferSize];
		if (NULL == wKeyName)
		{
			return WBEM_E_OUT_OF_MEMORY;
		}
		CComVariant vValue;		
		unsigned long ulApparentCimType;
		for (unsigned long i = 0; i < ulNumKeys; i++)
		{			
			hr = pIKeyList->GetKey2(i, 0L, &uKeyNameBufferSize, 
									wKeyName, &vValue, &ulApparentCimType);			
			//TODO: save vValue for later use
		}

		delete[] wKeyName;
		
		//TODO: search your internal data source to find the matching object.
		//If no objects with required key values can be found, 
		//return WBEM_E_NOT_FOUND.
		[!endif]
	   
		//spawn new instance
		CComPtr<IWbemClassObject> pNewInst;
		hr = m_pClass->SpawnInstance(0, &pNewInst);
		if(FAILED(hr))
		{
			return hr;
		}
		CComVariant var;

		//TODO: fill the properties of the new instance with those of the matching internal object
		[!if CLASS_SPECIFIED]
		[!output POPULATE_INSTANCE]			
		[!else]
		//Example:
		//var.ChangeType(VT_BSTR);
		//var = <value>; //put appropriate value here
		//hr = pNewInst->Put(CComBSTR(pMyProperty), 0, &var, 0);
		//var.Clear();		
		[!endif]

		return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vc7\system\wbem\wmiscriptutils\filehash.cpp ===
#include "stdafx.h"
#include "FileHash.h"



static DWORD crc_table[256];
static BOOL g_bCRC32Init = FALSE;

void InitCRC32Table()
{
	DWORD crc, poly;
	int i, j;

	poly = 0xEDB88320;
	for (i = 0; i < 256; i++)
	{
		crc = i;
		for (j = 8; j > 0; j--)
		{
			if (crc & 1)
				crc = (crc >> 1) ^ poly;
			else
				crc >>= 1;
		}
		crc_table[i] = crc;
	}
}

DWORD GetCRC32(BYTE *pData, DWORD dwSize)
{
	if(!g_bCRC32Init)
		InitCRC32Table();
	register unsigned long crc;
	BYTE *pEnd = pData + dwSize;
	crc = 0xFFFFFFFF;
	while (pData<pEnd)
		crc = ((crc>>8) & 0x00FFFFFF) ^ crc_table[ (crc^(*(pData++))) & 0xFF ];
	return ( crc^0xFFFFFFFF );
}

HRESULT GetCRC32(HANDLE hFile, DWORD dwSize, DWORD *pdwCRC32)
{
	HRESULT hr = E_FAIL;

	if(0 == dwSize)
	{
		*pdwCRC32 = 0;
		return S_OK;
	}

	HANDLE hMapping = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, dwSize, NULL);
	if(!hMapping)
		return hr;

	BYTE *pData = (BYTE*)MapViewOfFile(hMapping, FILE_MAP_READ, 0, 0, dwSize);

	if(pData)
	{
		*pdwCRC32 = GetCRC32(pData, dwSize);
		hr = S_OK;
		UnmapViewOfFile(pData);
	}
	CloseHandle(hMapping);
	return hr;
}

HRESULT GetCRC32(TCHAR *szFile, DWORD *pdwSize, DWORD *pdwCRC32)
{
	HRESULT hr = E_FAIL;
	HANDLE hFile = CreateFile(szFile, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	if(INVALID_HANDLE_VALUE == hFile)
		return hr;

	DWORD dwHigh = 0;
	*pdwSize = GetFileSize(hFile, &dwHigh);

	// We don't support files larger than 4 gig
	if(0 == dwHigh)
		hr = GetCRC32(hFile, *pdwSize, pdwCRC32);

	CloseHandle(hFile);
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vc7\system\wbem\wmiscriptutils\filehash.h ===
#pragma once

class MD5Hash
{
public:
	MD5Hash() {ZeroMemory(dwHash, sizeof(dwHash));}
	BSTR GetHashBSTR()
	{
		TCHAR szHash[33];
		for(int i=0;i<4;i++)
			wsprintf(&szHash[i*8], _T("%08X"), dwHash[i]);
		CComBSTR bstr(szHash);
		return bstr.Detach();
	}
	HRESULT HashData(LPBYTE pData, DWORD dwSize)
	{
		HRESULT hr = E_FAIL;
		HCRYPTPROV hProv = NULL;
		HCRYPTHASH hHash = NULL;
		__try
		{
			if(!CryptAcquireContext(&hProv, NULL, NULL, PROV_RSA_FULL, 0))
			{
				if(NTE_BAD_KEYSET == GetLastError())
				{
					if(!CryptAcquireContext(&hProv, NULL, NULL, PROV_RSA_FULL, CRYPT_NEWKEYSET))
						__leave;
				}
			}

			if(!CryptCreateHash(hProv, CALG_MD5, 0, 0, &hHash))
				__leave;

			if(!CryptHashData(hHash, pData, dwSize, 0))
				__leave;

			DWORD dwSizeHash = 0;
			DWORD dwSizeDWORD = sizeof(dwSizeHash);
			if(!CryptGetHashParam(hHash, HP_HASHSIZE, (BYTE*)&dwSizeHash, &dwSizeDWORD, 0))
				__leave;

			if(dwSizeDWORD != sizeof(dwSizeHash) || dwSizeHash != sizeof(dwHash))
				__leave;

			if(!CryptGetHashParam(hHash, HP_HASHVAL, (BYTE*)dwHash, &dwSizeHash, 0))
				__leave;

			hr = S_OK;
		}
		__finally
		{
			if(hHash)
				CryptDestroyHash(hHash);
			if(hProv)
				CryptReleaseContext(hProv, 0);
		}
		return hr;
	}
protected:
	DWORD dwHash[4];

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vc7\beta1\vcwiz\classwiz\atl\instance\templates\1031\wmiprov.cpp ===
// [!output IMPL_FILE] : Implementierung von [!output CLASS_NAME]
#include "stdafx.h"
#include "[!output PROJECT_NAME].h"
#include "[!output HEADER_FILE]"


/////////////////////////////////////////////////////////////////////////////
// [!output CLASS_NAME]

//////////////////////////////////////////////////////////////////////////////
// Klassen-, Eigenschaften- und Methodennamen

// Wichtig: Die folgenden Strings sollten nicht lokalisiert werden.

[!if CLASS_SPECIFIED]
const static WCHAR * s_pMyClassName = L"[!output WMICLASSNAME]"; //Klassenname

//Eigenschaften:
[!output PROPERTY_DEFINITIONS]

//Methoden:
[!output METHOD_DEFINITIONS]

[!else]
//Aktion: Definieren Sie den angegebenen Klassenname, z.B.:
const static WCHAR * s_pMyClassName = L"MyClassName"; 

//Aktion: Definieren Sie die Eigenschaftennamen der angegebenen Klasse, z.B.:
//const static WCHAR * pMyProperty = L"MyProperty";

//Aktion: Definieren Sie die Methodennamen der angegebenen Klasse, z.B.:
//const static WCHAR * pMyMethod = L"MyMethod";
[!endif]

//////////////////////////////////////////////////////////////////////////////
// [!output CLASS_NAME]::Initialize
//In der MSDN-Dokumentation fr IWbemProviderInit::Initialize()
//finden Sie weitere Einzelheiten ber die Implementierung dieser Methode.

STDMETHODIMP [!output CLASS_NAME]::Initialize(LPWSTR pszUser,	
									  LONG lFlags,
									  LPWSTR pszNamespace,
									  LPWSTR pszLocale,
									  IWbemServices *pNamespace,
							 		  IWbemContext *pCtx,
									  IWbemProviderInitSink *pInitSink) 
{

	if ( NULL == pNamespace || NULL == pInitSink) 
	{
        return WBEM_E_INVALID_PARAMETER;
	}

  	//IWbemServices-Zeiger zwischenspeichern
	//Hinweis: m_pNamespace ist ein dynamischer Zeiger: AddRef() funktionieren automatisch
	m_pNamespace = pNamespace;
				
	//Definition der angegebenen Klasse zwischenspeichern
	//Hinweis: Der Code unten geht davon aus, dass die Klassendefinition whrend der
	//Anbieterausfhrung unverndert bleibt. Andernfalls mssen Sie einen Benutzer
	//fr Klassennderungen und Klassenlschereignisse implementieren. Weitere
	//Informationen ber Ereignisbenutzer finden Sie auf MSDN in der WMI-Dokumentenation.
	
    HRESULT hr = m_pNamespace->GetObject(CComBSTR(s_pMyClassName), 
											0, 
											pCtx, 	//IWbemContext-Zeiger werden umgangen, um Sperrungen zu verhindern
											&m_pClass, 
											NULL);
    if(FAILED(hr))
	{
        return WBEM_E_FAILED;
	}    
	
	//Pfadverarbeitungs-Klassenherstellung zwischenspeichern
	hr = CoGetClassObject(CLSID_WbemDefPath, 
							CLSCTX_INPROC_SERVER, 
							NULL,
							IID_IClassFactory,
							(void **) &m_pPathFactory);
	if (FAILED(hr))
	{
		return WBEM_E_FAILED;
	}

	//Hilfsobjekt erstellen
	m_pHelper = new CInstanceProviderHelper(pNamespace, pCtx);

	//Hinweis: Rufen Sie ConstructErrorObject() auf m_pHelper irgendwo auf 
	//dem Anbieter auf, um einen Fehler oder Status an WMI zu melden.

    pInitSink->SetStatus(WBEM_S_INITIALIZED,0);
    return WBEM_S_NO_ERROR;
}

//////////////////////////////////////////////////////////////////////////////
// [!output CLASS_NAME]::GetObjectAsync
// In der MSDN-Dokumentation fr IWbemServices::GetObjectAsync()
// finden Sie weitere Einzelheiten ber die Implementierung dieser Methode.

STDMETHODIMP [!output CLASS_NAME]::GetObjectAsync( 
							 const BSTR bstrObjectPath,
							 long lFlags,
							 IWbemContext  *pCtx,
							 IWbemObjectSink  *pResponseHandler)
{
    
	//Fehler: Abrufen pro Eigenschaft?
    [!if SUPPORT_GET ]
	if (NULL == pResponseHandler)
	{
	     return WBEM_E_INVALID_PARAMETER;
	}

	CComPtr<IWbemClassObject> pInstance;
	HRESULT hr = GetInstanceByPath(bstrObjectPath, &pInstance);
	if (FAILED (hr))
	{
		return hr;
	}
			   
   	//Falls der Vorgang richtig ausgefhrt wurde, sollte das Objekt an WMI zurckgegeben werden und der erfolgreiche Vorgang angezeigt werden:
    pResponseHandler->Indicate (1, &pInstance); 
	pResponseHandler->SetStatus(0, WBEM_S_NO_ERROR, NULL, NULL);

    return WBEM_S_NO_ERROR;
	[!else]
    return WBEM_E_PROVIDER_NOT_CAPABLE;
	[!endif]
}

//////////////////////////////////////////////////////////////////////////////
// [!output CLASS_NAME]::PutInstanceAsync()
// In der MSDN-Dokumentation fr IWbemServices::PutInstanceAsync()
// finden Sie weitere Einzelheiten ber die Implementierung dieser Methode.

STDMETHODIMP [!output CLASS_NAME]::PutInstanceAsync( 
							IWbemClassObject  *pInst,
							long lFlags,
							IWbemContext  *pCtx,
							IWbemObjectSink  *pResponseHandler)
{
   
	[!if SUPPORT_PUT ]
	if ( NULL == pResponseHandler || NULL == pInst)
	{
        return WBEM_E_INVALID_PARAMETER;
	}
	//Aktion: berprfen Sie die Flagwerte: WBEM_FLAG_UPDATE_ONLY, 
	//WBEM_FLAG_CREATE_ONLY und WBEM_FLAG_CREATE_OR_UPDATE.
	//Whlen Sie eine Untersttzungsebene, und geben Sie
	//WBEM_E_PROVIDER_NOT_CAPABLE fr nicht untersttzte Flagwerte zurck.

	//Aktion: Falls Updates auch teilweise untersttzt werden sollen, berprfen 
	//Sie pCtx fr "__PUT_EXTENSIONS" und andere relevante Systemkontextwerte,
	//und aktualisieren Sie die Instanzdaten dementsprechend.
	
	//Aktion: Verarbeiten Sie das Instanzupdate oder die -erstellung an dieser Stelle.			
	
	pResponseHandler->SetStatus(0, WBEM_S_NO_ERROR, NULL, NULL);
	return WBEM_S_NO_ERROR;
	[!else]
	return WBEM_E_PROVIDER_NOT_CAPABLE;
	[!endif]
}


//////////////////////////////////////////////////////////////////////////////
// [!output CLASS_NAME]::DeleteInstanceAsync()
// In der MSDN-Dokumentation fr IWbemServices::DeleteInstanceAsync()
// finden Sie weitere Einzelheiten ber die Implementierung dieser Methode.

STDMETHODIMP [!output CLASS_NAME]::DeleteInstanceAsync( 
							const BSTR ObjectPath,
							long lFlags,
							IWbemContext  *pCtx,
							IWbemObjectSink  *pResponseHandler)
{
	//Fr die Methodenimplementierung verarbeitet ein Instanzanbieter die 
	//Objektpfadzeichenfolge, die im Parameter strObjectPath angegeben wird,
	//und versucht die passenden Instanz zu finden und zu lschen.
	[!if SUPPORT_DELETE ]

	if (NULL == pResponseHandler)
	{
		return WBEM_E_INVALID_PARAMETER;
	}
    
	[!if IS_COMPOUND_KEY]
	ULONG ulPathTest = WBEMPATH_INFO_IS_INST_REF | WBEMPATH_INFO_IS_COMPOUND;
	[!else]
	[!if IS_SINGLETON]
	ULONG ulPathTest = WBEMPATH_INFO_IS_INST_REF | WBEMPATH_INFO_CONTAINS_SINGLETON;
	[!else]
	ULONG ulPathTest = WBEMPATH_INFO_IS_INST_REF;
	[!endif]
	[!endif]
		
	if (FAILED(m_pHelper->CheckInstancePath(m_pPathFactory,
											ObjectPath,
											CComBSTR(s_pMyClassName),
											ulPathTest)) )
	{
		//Syntaxfehler im Pfad oder falscher Pfad fr angegebene Klasse
		return WBEM_E_INVALID_PARAMETER; 
	}			
	
	[!if IS_SINGLETON]
	//Hinweis: [!output WMICLASSNAME] ist ein einzelnes Objekt. Instanz muss nicht identifiziert werden.
	//Hinweis: Falls die Instanz nicht vorhanden ist, muss die folgende Zeile auskommentiert werden, damit die Information an WMI zurckgegeben werden kann:
	//return WBEM_E_NOT_FOUND;
	[!else]
	//Pfadverarbeitungsobjekt erstellen
	CComPtr<IWbemPath>pPath;
	HRESULT hr = m_pPathFactory->CreateInstance(NULL,
												IID_IWbemPath,
												(void **) &pPath);
	if (FAILED(hr))
	{
		return WBEM_E_FAILED;
	}
	
	CComPtr<IWbemPathKeyList> pIKeyList;
	hr = pPath->GetKeyList(&pIKeyList);
	if (FAILED(hr))
	{
		return hr;
	}
	
	unsigned long ulNumKeys;
	hr = pIKeyList->GetCount(&ulNumKeys);

	//Werte der wichtigen Eigenschaften abrufen
	unsigned long uKeyNameBufferSize = CComBSTR(ObjectPath).Length() + 1;
	WCHAR * wKeyName = new WCHAR[uKeyNameBufferSize];
	if (NULL == wKeyName)
	{
		return WBEM_E_OUT_OF_MEMORY;
	}
	CComVariant vValue;
	unsigned long ulApparentCimType;
	for (unsigned long i = 0; i < ulNumKeys; i++)
	{			
		hr = pIKeyList->GetKey2(i, 0L, &uKeyNameBufferSize, 
								wKeyName, &vValue, &ulApparentCimType);			
		//Aktion: vValue fr sptere Verwendung speichern
	}
	delete[] wKeyName;

	//Aktion: Suchen Sie in den Daten nach dem bereinstimmenden Objekt, und lschen Sie es.
	//Hinweis: Falls Sie kein Objekt, das mit den im Pfad angezeigten Schlsselwerten bereinstimmt, 
	//finden, muss die folgende Zeile auskommentiert werden, so dass diese Information an WMI bermittelt wird:
	//return WBEM_E_NOT_FOUND;
	[!endif]	

	pResponseHandler->SetStatus(0, WBEM_S_NO_ERROR, NULL, NULL);	
    return WBEM_S_NO_ERROR;
	
	[!else]
	return WBEM_E_PROVIDER_NOT_CAPABLE;
	[!endif]
}


//////////////////////////////////////////////////////////////////////////////
// [!output CLASS_NAME]::CreateInstanceEnumAsync()
// In der MSDN-Dokumentation fr IWbemServices::CreateInstanceEnumAsync()
// finden Sie weitere Einzelheiten ber die Implementierung dieser Methode.

STDMETHODIMP [!output CLASS_NAME]::CreateInstanceEnumAsync( 
							const BSTR Class,
							long lFlags,
							IWbemContext  *pCtx,
							IWbemObjectSink  *pResponseHandler)
{
	

	//Wichtiger Hinweis: Der Instanzanbieter hat einen Thread von WMI bernommen, um diese 
	//Vorgnge auszufhren. Sie sollten die Datensenkmethode AddRef() aufrufen und einen
	//anderen Thread zum Zustellen der Objekte im Ergebnissatz erstellen. 
	//Somit knnen Sie den aktuellen Thread zum Zurckgeben an WMI verwenden, ohne dass der 
	//Threadpool gelscht wird. Abhngig davon wie lange der Anbieter den WMI-Thread 
	//verwenden mchte, wird ein einfacher oder ein doppelter Thread verwendet.

	[!if SUPPORT_ENUMERATE ]
	if (NULL == pResponseHandler)
	{
	    return WBEM_E_INVALID_PARAMETER;
	}

	HRESULT hr = WBEM_S_NO_ERROR;
	
	[!if IS_SINGLETON]
	// Ein leeres Objekt zum Abrufen der Instanzdaten verwenden
    CComPtr<IWbemClassObject> pNewInst;
    hr = m_pClass->SpawnInstance(0, &pNewInst);
		
	CComVariant var;
	[!if CLASS_SPECIFIED]
	[!output POPULATE_INSTANCE]
	[!else]
	//Aktion: Fllen Sie die Instanz mit Eigenschaften auf, z.B.:
	//CComVariant var;
	//var.ChangeType(VT_BSTR);
	//var = <value>;  //richtigen Wert hier setzen
	//hr = pNewInst->Put(CComBSTR(pMyProperty), 0, &var, 0);
	//var.Clear();
	[!endif]
		
	// Klasse an WMI bermitteln
    pResponseHandler->Indicate(1, &pNewInst);
	[!else]
    // Durch die persnliche Quelle schleifen und jede Instanz erstellen,
	//solange (while): (<weitere Instanzen vorhanden>)
    {
		// Ein leeres Objekt zum Empfangen der Klassendefinition vorbereiten
        CComPtr<IWbemClassObject> pNewInst;
        hr = m_pClass->SpawnInstance(0, &pNewInst);
		if (FAILED(hr))
		{	
			//Aktion: Kommentieren Sie die Zeile unten aus, sobald die Schleifenbedingung erstellt wurde
			//break;
		}
		
		CComVariant var;
		[!if CLASS_SPECIFIED]
		[!output POPULATE_INSTANCE]
		[!else]
		//Aktion: Fllen Sie die Instanz mit Eigenschaften auf, z.B.:
		//CComVariant var;
		//var.ChangeType(VT_BSTR);
		//var = <value>;  //richtigen Wert hier angegeben
		//hr = pNewInst->Put(CComBSTR(pMyProperty), 0, &var, 0);
		//var.Clear();
		[!endif]
		
		// Klasse an WMI bermitteln
        pResponseHandler->Indicate(1, &pNewInst);
    }  	
	[!endif]
	pResponseHandler->SetStatus(0, hr, NULL, NULL);
   	return WBEM_S_NO_ERROR;
	[!else]
	return WBEM_E_PROVIDER_NOT_CAPABLE;
	[!endif]
}


//////////////////////////////////////////////////////////////////////////////
//[!output CLASS_NAME]::ExecQueryAsync()
// In der MSDN-Dokumentation fr IWbemServices::ExecQueryAsync()
// finden Sie weitere Einzelheiten ber die Implementierung dieser Methode.

STDMETHODIMP [!output CLASS_NAME]::ExecQueryAsync( 
							const BSTR QueryLanguage,
							const BSTR Query,
							long lFlags,
							IWbemContext  *pCtx,
							IWbemObjectSink  *pResponseHandler)
{
	
	
   	// Instanzanbieter knnen Abfragen entweder selbst verarbeiten oder Abfragen von WMI 
	// verarbeiten lassen. Ein Instanzanbieter muss SQL-Anweisungen (Structured Query Language)  
	// verarbeiten, die angeforderte Anfrage ausfhren und die Ergebnissatzobjekte der 
	// richtigen Datensenke zustellen, um Abfragen untersttzen zu knnen. 
	
	//Aktion: Verwenden Sie den Abfrageverarbeitungscode an dieser Stelle.
	
	//pResponseHandler->SetStatus(0, WBEM_S_NO_ERROR, NULL, NULL);
	// return WBEM_S_NO_ERROR;

	return WBEM_E_PROVIDER_NOT_CAPABLE;
	
}

[!if PROVIDE_METHODS ]

//////////////////////////////////////////////////////////////////////////////
// [!output CLASS_NAME]::ExecMethodAsync()
// In der MSDN-Dokumentation fr IWbemServices::ExecMethodAsync()
// finden Sie weitere Einzelheiten ber die Implementierung dieser Methode.
STDMETHODIMP [!output CLASS_NAME]::ExecMethodAsync( 
							const BSTR strObjectPath,
							const BSTR strMethodName,
							long lFlags,
							IWbemContext  *pCtx,
							IWbemClassObject  *pInParams,
							IWbemObjectSink  *pResponseHandler)
{
	

	[!if CLASS_SPECIFIED]
	[!if  !HAS_IMPL_METHODS]	
	//[!output WMICLASSNAME] enthlt keine implementierten Methoden
	return WBEM_E_NOT_SUPPORTED;
	[!else]
	HRESULT hr = WBEM_E_FAILED;	
    if (NULL == pResponseHandler)
	{
        return WBEM_E_INVALID_PARAMETER;
	}	
	[!output EXEC_METHOD_BODY]
	[!endif]
	[!else]
	
	//Vergewissen Sich, dass der Klassenname im Pfad richtig ist.
	//Pfadverarbeitungsobjekt abrufen:
	CComPtr<IWbemPath>pPath;
	HRESULT hr = m_pPathFactory->CreateInstance(NULL,
												IID_IWbemPath,
												(void **) &pPath);
	if (FAILED(hr))
	{
		return WBEM_E_FAILED;
	}

	HRESULT hr = pPath->SetText(WBEMPATH_CREATE_ACCEPT_ALL, strObjectPath);
	long nPathLen = CComBSTR(strObjectPath).Length();
	unsigned long ulBufLen = nPathLen + 1;
	WCHAR * wClass = new WCHAR[nPathLen];
	if (NULL == wClass)
	{
		return WBEM_E_OUT_OF_MEMORY;
	}
	pPath->GetClassName(&ulBufLen, wClass);
	if ( _wcsicmp(s_pMyClassName, wClass))
	{
		delete[] wClass;
		return WBEM_E_INVALID_PARAMETER;
	}
	delete[] wClass;
	//Aktion: Vergleichen Sie den angeforderten Methodenname mit den Methoden der Klassen.
	//if (!_wcsicmp (strMethodName, pMyNonStaticMethod))
	{
		CComVariant var;

		//Eingabeargumente abrufen:
		//Aktion: Falls die Methode Eingabeargumente enthlt, werden diese wie Eigenschaften vom Objekt 
		//pInParams weitergeleitet. Die kommentierte Zeile unten gibt an, wie diese Argumente abgerufen werden:
		//hr = pInParams->Get(CComBSTR("InputArgument1"), 0, &var, NULL, NULL);
		//Aktion: Eingabeparameterwert speichern
		var.Clear();		
		
		//Verarbeitungspfad zum Suchen der Instanz fr die Methodenausfhrung: fr nicht statische Methode
		CComPtr<IWbemPathKeyList> pIKeyList;
		hr = pPath->GetKeyList(&pIKeyList);
		if (FAILED(hr))
		{
			return WBEM_E_INVALID_PARAMETER;
		}
		unsigned long ulNumKeys;
		hr = pIKeyList->GetCount(&ulNumKeys);
		//Get values of key properties:
		unsigned long uKeyNameBufferSize = nPathLen + 1;
		WCHAR  * wKeyName = new WCHAR[uKeyNameBufferSize];
		if (NULL == wKeyName)
		{
			return WBEM_E_OUT_OF_MEMORY;
		}
		CComVariant vValue;
		unsigned long ulApparentCimType;
		for (unsigned long i = 0; i < ulNumKeys; i++)
		{
			hr = pIKeyList->GetKey2(i, 0L, &uKeyNameBufferSize,
									wKeyName, &vValue, &ulApparentCimType);
			//Aktion: vValue fr sptere Verwendung speichern
		}
		delete[] wKeyName;
	
		//Aktion: Suchen Sie in der Datenquelle nach dem bereinstimmenden Objekt.
		
		//Aktion: Fgen Sie Code hinzu, um die Methode an dieser Stelle auszufhren.
		//Ausgabeparameterklasse abrufen
		CComPtr<IWbemClassObject> pOutClass;
		hr = m_pClass->GetMethod(CComBSTR("Method1"), 0, NULL, &pOutClass);
		CComPtr<IWbemClassObject> pOutParams;
		pOutClass->SpawnInstance(0, &pOutParams);
		//Aktion: Erstellen Sie Ausgabeparameter, indem Sie Eigenschaften
		//von der pOutParams-Klasse auffllen. Zum Beispiel:

		//var.ChangeType(VT_BSTR);
		//Variable mit richtigen Wert auffllen
		//hr = pOutParams->Put(CComBSTR("MyOutputParameter"), 0, &var, 0);
		//var.Clear();
		//var.ChangeType(VT_I2);
		//Variable mit richtigen Wert auffllen
		//hr = pOutParams->Put(CComBSTR("ReturnValue"), 0, &var, 0);
		//var.Clear();
		//Ausgabeobjekt zurck an den Client ber die Datensenke senden
		hr = pResponseHandler->Indicate(1, &pOutParams);
		
		pResponseHandler->SetStatus(0, WBEM_S_NO_ERROR, NULL, NULL);
		return WBEM_S_NO_ERROR;
	}
	
	//Methodenname wurde nicht erkannt
	return WBEM_E_INVALID_PARAMETER;
	
	
	[!endif]	
}
[!endif]



//////////////////////////////////////////////////////////////////////////////
// [!output CLASS_NAME]::GetInstanceByPath() verarbeitet den Pfad, um erforderliche Schlsselwerte
// zu finden. Dann wird der interne Speicher nach einem Objekt mit den passenden Schlsselwerten durchsucht.
// Falls das Objekt gefunden wird, erstellt die Methode eine neue Instanz, fllt die Eigenschaften auf
// und gibt sie in ppInstance zurck. Falls das Objekt nicht gefunden wird, wird WBEM_E_NOT_FOUND zurckgegeben.
// Fehler: Instanzteil einer Provision???  Andere mgliche Flags?

STDMETHODIMP [!output CLASS_NAME]::GetInstanceByPath (
													/*in*/CComBSTR bstrPath,
													/*out*/IWbemClassObject ** ppInstance )
													
{
		HRESULT hr = WBEM_E_FAILED;				  
		
		[!if IS_COMPOUND_KEY]
		ULONG ulPathTest = WBEMPATH_INFO_IS_INST_REF | WBEMPATH_INFO_IS_COMPOUND;
		[!else]
		[!if IS_SINGLETON]
		ULONG ulPathTest = WBEMPATH_INFO_IS_INST_REF | WBEMPATH_INFO_CONTAINS_SINGLETON;
		[!else]
		ULONG ulPathTest = WBEMPATH_INFO_IS_INST_REF;
		[!endif]
		[!endif]
		
		if (FAILED(m_pHelper->CheckInstancePath(m_pPathFactory,
												bstrPath,
												CComBSTR(s_pMyClassName),
												ulPathTest)))
		{
			//Syntaxfehler im Pfad oder falscher Pfad fr angegebene Klasse
			return WBEM_E_INVALID_PARAMETER; 
		}			
		
		[!if IS_SINGLETON]
		//[!output WMICLASSNAME] ist ein einzelnes Objekt. Instanz muss nicht identifiziert werden.
		//Hinweis: Falls die Instanz nicht vorhanden ist, sollte die folgende Zeile auskommentiert werden, 		//so dass diese Informationen an WMI bermittelt wird:
		//return WBEM_E_NOT_FOUND;
		[!else]
		//Pfadverarbeitungsobjekt abrufen:
		CComPtr<IWbemPath>pPath;
		hr = m_pPathFactory->CreateInstance(NULL,
												IID_IWbemPath,
												(void **) &pPath);
		if (FAILED(hr))
		{
			return WBEM_E_FAILED;
		}
		
		hr = pPath->SetText(WBEMPATH_CREATE_ACCEPT_ALL,
									bstrPath);

		CComPtr<IWbemPathKeyList> pIKeyList;
		hr = pPath->GetKeyList(&pIKeyList);
		if (FAILED(hr))
		{
			return hr;
		}
		unsigned long ulNumKeys;
		hr = pIKeyList->GetCount(&ulNumKeys);

		//Werte der Schlsseleigenschaften abrufen
		unsigned long uKeyNameBufferSize = bstrPath.Length() + 1;
		WCHAR  * wKeyName = new WCHAR[uKeyNameBufferSize];
		if (NULL == wKeyName)
		{
			return WBEM_E_OUT_OF_MEMORY;
		}
		CComVariant vValue;		
		unsigned long ulApparentCimType;
		for (unsigned long i = 0; i < ulNumKeys; i++)
		{			
			hr = pIKeyList->GetKey2(i, 0L, &uKeyNameBufferSize, 
									wKeyName, &vValue, &ulApparentCimType);			
			//Aktion: vValue fr sptere Verwendung speichern
		}

		delete[] wKeyName;
		
		//Aktion: Suchen Sie in der Datenquelle nach dem bereinstimmenden Objekt.
		//Falls keine Objekte mit den erforderlichen Schlsselwerten gefunden werden, 
		//WBEM_E_NOT_FOUND zurckgeben.
		[!endif]
	   
		//Neue Instanz erstellen
		CComPtr<IWbemClassObject> pNewInst;
		hr = m_pClass->SpawnInstance(0, &pNewInst);
		if(FAILED(hr))
		{
			return hr;
		}
		CComVariant var;

		//Aktion: Fllen Sie die Eigenschaften der neuen Instanz mit denen des bereinstimmenden internen Objekts auf.
		[!if CLASS_SPECIFIED]
		[!output POPULATE_INSTANCE]			
		[!else]
		//Beispiel:
		//var.ChangeType(VT_BSTR);
		//var = <value>; //put appropriate value here
		//hr = pNewInst->Put(CComBSTR(pMyProperty), 0, &var, 0);
		//var.Clear();		
		[!endif]

		return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vc7\system\wbem\wmiscriptutils\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by WMIScriptUtils.rc
//
#define IDS_PROJNAME                    100
#define IDB_WMIOBJECTBROKER             101
#define IDR_WMIOBJECTBROKER             102
#define IDR_WMIOBJECTBROKERREGISTRATION 103

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           104
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vc7\system\wbem\wmiscriptutils\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vc7\system\wbem\wmiscriptutils\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__ABA61DCB_4742_4DAE_987B_18620A19CDB1__INCLUDED_)
#define AFX_STDAFX_H__ABA61DCB_4742_4DAE_987B_18620A19CDB1__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlctl.h>

#include <comdef.h>
#include <exdisp.h>
#include <shlobj.h>
#include <mshtml.h>


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__ABA61DCB_4742_4DAE_987B_18620A19CDB1__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vc7\system\wbem\wmiscriptutils\wmiobjectbroker.cpp ===
// WMIObjectBroker.cpp : Implementation of CWMIObjectBroker

#include "stdafx.h"
#include "WMIScriptUtils.h"
#include "WMIObjectBroker.h"
#include "CommonFuncs.h"

/////////////////////////////////////////////////////////////////////////////
// CWMIObjectBroker



STDMETHODIMP CWMIObjectBroker::CreateObject(BSTR strProgId, IDispatch **obj)
{
	HRESULT hr = E_FAIL;
	CLSID clsid;
	IUnknown *pUnk = NULL;
	__try
	{
		BOOL fSafetyEnabled = TRUE;

		// TODO: Do we want this check to enable us to work from WSH?

		// BUG in IE/JScript/VBScript: We should be checking to see if 
		// m_dwCurrentSafety != INTERFACE_USES_SECURITY_MANAGER, but current
		// IE/JScript/VBScript versions do not call SetInterfaceSafetyOptions
		// with anything but INTERFACESAFE_FOR_UNTRUSTED_CALLER

		// If we are run though CScript.exe or WScript.exe, we will never be
		// asked to set safety options through SetInterfaceSafetyOptions.  In
		// addition, there will not be an InternetHostSecurityManager available
		// through our 'site'.  In this case, we allow any object to be created.
		if(m_dwCurrentSafety == 0 && !IsInternetHostSecurityManagerAvailable(GetUnknown()))
			fSafetyEnabled = FALSE;

		// We can override the safety check if this insance of the 'broker'
		// control is allowed to create the object specified by strProbId
		if(fSafetyEnabled && SUCCEEDED(IsCreateObjectAllowed(GetUnknown(), strProgId, NULL)))
			fSafetyEnabled = FALSE;

		// Convert the ProgId to a CLSID
		if(FAILED(hr = CLSIDFromProgID(strProgId, &clsid)))
			__leave;

		// Create the requested object
#if 0
		if(FAILED(hr = CoCreateInstance(clsid, NULL, CLSCTX_INPROC_SERVER, IID_IUnknown, (void**)&pUnk)))
			__leave;
#endif
		if(FAILED(hr = SafeCreateObject(GetUnknown(),fSafetyEnabled, clsid, &pUnk)))
			__leave;

		// Get the IDispatch for the caller
		hr = pUnk->QueryInterface(IID_IDispatch, (void**)obj);
	}
	__finally
	{
		if(pUnk)
			pUnk->Release();
	}
	return hr;
}

STDMETHODIMP CWMIObjectBroker::CanCreateObject(BSTR strProgId, VARIANT_BOOL *bResult)
{
	*bResult = VARIANT_FALSE;
	if(SUCCEEDED(IsCreateObjectAllowed(GetUnknown(), strProgId, NULL)))
		*bResult = VARIANT_TRUE;
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vc7\system\wbem\wmiscriptutils\wmiobjectbroker.h ===
// WMIObjectBroker.h : Declaration of the CWMIObjectBroker

#ifndef __WMIOBJECTBROKER_H_
#define __WMIOBJECTBROKER_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CWMIObjectBroker
class ATL_NO_VTABLE CWMIObjectBroker : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CWMIObjectBroker, &CLSID_WMIObjectBroker>,
	public IDispatchImpl<IWMIObjectBroker, &IID_IWMIObjectBroker, &LIBID_WMISCRIPTUTILSLib>,
	public IObjectSafetyImpl<CWMIObjectBroker, INTERFACESAFE_FOR_UNTRUSTED_CALLER|INTERFACESAFE_FOR_UNTRUSTED_DATA|INTERFACE_USES_SECURITY_MANAGER>,
	public IObjectWithSiteImpl<CWMIObjectBroker>
{
public:
	CWMIObjectBroker()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_WMIOBJECTBROKER)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CWMIObjectBroker)
	COM_INTERFACE_ENTRY(IWMIObjectBroker)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IObjectSafety)
	COM_INTERFACE_ENTRY(IObjectWithSite)
END_COM_MAP()

// IWMIObjectBroker
public:
	STDMETHOD(CanCreateObject)(/*[in]*/ BSTR strProgId, /*[out, retval]*/ VARIANT_BOOL *bResult);
	STDMETHOD(CreateObject)(BSTR strProgId, IDispatch **obj);
};

#endif //__WMIOBJECTBROKER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vc7\domofcmp\domofcmp.cpp ===
// Copyright (c) 2000 Microsoft Corporation, All Rights Reserved
//
// DoMofcmp.cpp
//
//	IMPORTANT NOTES
//
//	This exe was developed for the sole purpose of providing a way to mofcomp
//	files silently when called as a custom action from within an MSI install.
//	Because of this narrow focus and the intense time pressure, it is very
//	minimal and makes many assumptions with no error checking.
//
//	- normal operation is with the /s silent switch except when debugging
//	- the silent switch must be the first parameter if specified
//	- there is one space between the silent switch and the file to be mofcomped
//	- because of a need to set the current working directory to something known
//	  to be writable, the full path must be specified for the file to be mofcomped
//	- quotes around the full path are not necessary, even if the path contains spaces
//	- it is assumed that %TEMP% will be defined on the user's machine
//	- probably some other assumptions as well, but this gets most of them
//

#include "stdafx.h"
#include <windows.h>
#include <stdio.h>
#include <tchar.h>
#include <wbemcli.h>
#include <ole2.h>

int APIENTRY WinMain(HINSTANCE hInstance,
                     HINSTANCE hPrevInstance,
                     LPSTR     lpszCmdLine,
                     int       nCmdShow)
{
	if (lpszCmdLine[0] == '\0')
	{
		MessageBox(0, "Exiting -- No parameter passed", _T("Repository Configuration"), MB_ICONINFORMATION | MB_OK | MB_TOPMOST | MB_SYSTEMMODAL);
		return 1;
	}

	// check for silent switch
	bool	bSilent = false;
	char*	pszTemp = strstr(lpszCmdLine, "/s");
	if (pszTemp)
	{
		bSilent = true;
		pszTemp += 3;	// skip over switch and following space
	}
	else
		pszTemp = lpszCmdLine;

	// strip off leading and trailing quotes (with lots of assumptions)
	if (pszTemp[0] == '\"')
		pszTemp++;
	char* pQuote = strstr(pszTemp, "\"");
	if (pQuote)
		*pQuote = '\0';

	// set current directory
	LPCTSTR lpName = "TEMP";
	LPTSTR	lpBuffer = new char[MAX_PATH];

	DWORD dRet = GetEnvironmentVariable(lpName, lpBuffer, MAX_PATH);
	if (dRet)
	{
		BOOL bRet = SetCurrentDirectory((LPCTSTR) lpBuffer);
		if (!bRet)
		{
			if (!bSilent)
			{
				MessageBox(0, _T("Failed to set current working directory."), _T("Repository Configuration"), MB_ICONINFORMATION | MB_OK | MB_TOPMOST | MB_SYSTEMMODAL);
			}
		}
	}
	else
	{
		if (!bSilent)
		{
			MessageBox(0, _T("Failed to retrieve TEMP environment variable."), _T("Repository Configuration"), MB_ICONINFORMATION | MB_OK | MB_TOPMOST | MB_SYSTEMMODAL);
		}
	}

	// init COM
	HRESULT hRes = CoInitialize(NULL);
	if (FAILED(hRes))
	{
		if (!bSilent)
		{
			MessageBox(0, _T("COM runtime failed to intialize"), _T("Repository Configuration"), MB_ICONEXCLAMATION | MB_OK | MB_TOPMOST | MB_SYSTEMMODAL);
		}
		return 1;
	}

	// get interface to mof compiler
	IMofCompiler*	pCompiler = NULL;
    hRes = CoCreateInstance(CLSID_MofCompiler, 0, CLSCTX_INPROC_SERVER, IID_IMofCompiler, (LPVOID*) &pCompiler);
	if (FAILED(hRes))
	{
		if (!bSilent)
		{
			MessageBox(0, _T("The MOF Compiler failed to intialize"), _T("Repository Configuration"), MB_ICONEXCLAMATION | MB_OK | MB_TOPMOST | MB_SYSTEMMODAL);
		}
		CoUninitialize();
		return 1;
	}

	// get expanded filename
	char *szExpandedFilename = NULL;
	DWORD nRes = ExpandEnvironmentStrings(pszTemp,NULL,0); 
	if (nRes == 0)
	{
		szExpandedFilename = new char[strlen(pszTemp) + 1];
		if (szExpandedFilename == NULL)
		{
			CoUninitialize();
			return 1;
		}
		strcpy(szExpandedFilename, pszTemp);
	}
	else
	{
		szExpandedFilename = new char[nRes];
		if (szExpandedFilename == NULL)
		{
			CoUninitialize();
			return 1;
		}
		nRes = ExpandEnvironmentStrings(pszTemp,szExpandedFilename,nRes); 
		if (nRes == 0)
		{
			delete [] szExpandedFilename;
			CoUninitialize();
			return 1;
		}
	}

	//  compile mof
 	WCHAR wFileName[MAX_PATH];
  	mbstowcs(wFileName, szExpandedFilename, MAX_PATH);
	hRes = pCompiler->CompileFile(wFileName, NULL, NULL, NULL, NULL, 0, 0, 0, NULL);
	if (WBEM_S_NO_ERROR == hRes)
	{
		if (!bSilent)
		{
			MessageBox(0, _T("The MOF loaded successfully."), _T("Repository Configuration"), MB_ICONINFORMATION | MB_OK | MB_TOPMOST | MB_SYSTEMMODAL);
		}
	}
	else
	{
		if (!bSilent)
		{
			MessageBox(0, _T("The MOF could not be loaded."), _T("Repository Configuration"), MB_ICONEXCLAMATION | MB_OK | MB_TOPMOST | MB_SYSTEMMODAL);
		}
		pCompiler->Release();
		CoUninitialize();
		return 1;
	}

	// clean up
	delete [] szExpandedFilename;
	delete [] lpBuffer;
	pCompiler->Release();
	CoUninitialize();

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vc7\beta1\vcwiz\classwiz\atl\instance\templates\1041\wmiprov.cpp ===
// [!output IMPL_FILE] :  [!output CLASS_NAME] ̎s
#include "stdafx.h"
#include "[!output PROJECT_NAME].h"
#include "[!output HEADER_FILE]"


/////////////////////////////////////////////////////////////////////////////
// [!output CLASS_NAME]

//////////////////////////////////////////////////////////////////////////////
// NXAvpeBA\bh

// dv: ȉɒ`Ă镶̓[JCYł܂B

[!if CLASS_SPECIFIED]
const static WCHAR * s_pMyClassName = L"[!output WMICLASSNAME]"; //NX

//vpeB:
[!output PROPERTY_DEFINITIONS]

//\bh:
[!output METHOD_DEFINITIONS]

[!else]
//TODO: ^ꂽNX`ĂB:
const static WCHAR * s_pMyClassName = L"MyClassName"; 

//TODO: ^ꂽNX̃voeB`ĂB:
//const static WCHAR * pMyProperty = L"MyProperty";

//TODO: ^ꂽNX̃\bh`ĂB:
//const static WCHAR * pMyMethod = L"MyMethod";
[!endif]

//////////////////////////////////////////////////////////////////////////////
// [!output CLASS_NAME]::Initialize
//̃\bh̎ɂĂ̏ڍׂ́AIWbemProviderInit::Initialize()
// MSDN hLgQƂĂB

STDMETHODIMP [!output CLASS_NAME]::Initialize(LPWSTR pszUser,	
									  LONG lFlags,
									  LPWSTR pszNamespace,
									  LPWSTR pszLocale,
									  IWbemServices *pNamespace,
							 		  IWbemContext *pCtx,
									  IWbemProviderInitSink *pInitSink) 
{

	if ( NULL == pNamespace || NULL == pInitSink) 
	{
        return WBEM_E_INVALID_PARAMETER;
	}

  	//IWbemServices |C^LbV܂B
	//: m_pNamespace ̓X}[g |C^łBI AddRef() ܂B
	m_pNamespace = pNamespace;
				
	//Cxg NX̒`ۑ܂B				
	//: ȉ̃R[h́AvoC_̎s̓Cxg NX̒`A
	//ύXȂƉ肵Ă܂BύXꍇ́ANX̏CCxgƍ폜Cxgp
	//RV[}Kv܂BCxg RV[}ɂẮA
	//MSDN  WMI hLgQƂĂB
	
    HRESULT hr = m_pNamespace->GetObject(CComBSTR(s_pMyClassName), 
											0, 
											pCtx, 	//fbhbNȂ悤 IWbemContext |C^n܂B
											&m_pClass, 
											NULL);
    if(FAILED(hr))
	{
        return WBEM_E_FAILED;
	}    
	
	//pX p[T[ NX t@NgLbV܂B
	hr = CoGetClassObject(CLSID_WbemDefPath, 
							CLSCTX_INPROC_SERVER, 
							NULL,
							IID_IClassFactory,
							(void **) &m_pPathFactory);
	if (FAILED(hr))
	{
		return WBEM_E_FAILED;
	}

	//helper IuWFNg쐬܂B
	m_pHelper = new CInstanceProviderHelper(pNamespace, pCtx);

	//: WMIɏڂG[܂͏Ԃ񍐂邽߂ɁA
	//voC_ m_pHelper ̂ǂłł ConstructErrorObject() ĂяoƂł܂B 

    pInitSink->SetStatus(WBEM_S_INITIALIZED,0);
    return WBEM_S_NO_ERROR;
}

//////////////////////////////////////////////////////////////////////////////
// [!output CLASS_NAME]::GetObjectAsync
// ̃\bh̎ɂĂ̏ڍׂ́ARIWbemServices::GetObjectAsync()
//  MSDN hLgQƂĂB

STDMETHODIMP [!output CLASS_NAME]::GetObjectAsync( 
							 const BSTR bstrObjectPath,
							 long lFlags,
							 IWbemContext  *pCtx,
							 IWbemObjectSink  *pResponseHandler)
{
    
	//bugbug: evpeB̎擾?
    [!if SUPPORT_GET ]
	if (NULL == pResponseHandler)
	{
	     return WBEM_E_INVALID_PARAMETER;
	}

	CComPtr<IWbemClassObject> pInstance;
	HRESULT hr = GetInstanceByPath(bstrObjectPath, &pInstance);
	if (FAILED (hr))
	{
		return hr;
	}
			   
   	//ׂĂ܂ꍇ́AIuWFNg WMI ɖ߂\܂B:
    pResponseHandler->Indicate (1, &pInstance); 
	pResponseHandler->SetStatus(0, WBEM_S_NO_ERROR, NULL, NULL);

    return WBEM_S_NO_ERROR;
	[!else]
    return WBEM_E_PROVIDER_NOT_CAPABLE;
	[!endif]
}

//////////////////////////////////////////////////////////////////////////////
// [!output CLASS_NAME]::PutInstanceAsync()
// ̃\bh̎ɂĂ̏ڍׂ́AIWbemServices::PutInstanceAsync()
//  MSDN hLgQƂĂB

STDMETHODIMP [!output CLASS_NAME]::PutInstanceAsync( 
							IWbemClassObject  *pInst,
							long lFlags,
							IWbemContext  *pCtx,
							IWbemObjectSink  *pResponseHandler)
{
   
	[!if SUPPORT_PUT ]
	if ( NULL == pResponseHandler || NULL == pInst)
	{
        return WBEM_E_INVALID_PARAMETER;
	}
	//TODO: \ȃtOl𒲂ׂĂ: WBEM_FLAG_UPDATE_ONLYA
	//WBEM_FLAG_CREATE_ONLYAWBEM_FLAG_CREATE_OR_UPDATE
	//KvȃT|[g̃xIāAT|[gĂȂtOl̂߂ WBEM_E_PROVIDER_NOT_CAPABLE
	//ԂĂB

	//TODO: IȍXVT|[g\肪ꍇ́A"__PUT_EXTENSIONS"  
	// pCtx Ƃق̊֘AVXe ReLXgl𒲂ׂāA
	//CX^X f[^K؂ɍXVĂB
	
	//TODO: ŃCX^X̍XV܂͍쐬܂B			
	
	pResponseHandler->SetStatus(0, WBEM_S_NO_ERROR, NULL, NULL);
	return WBEM_S_NO_ERROR;
	[!else]
	return WBEM_E_PROVIDER_NOT_CAPABLE;
	[!endif]
}


//////////////////////////////////////////////////////////////////////////////
// [!output CLASS_NAME]::DeleteInstanceAsync()
// ̃\bh̎ɂĂ̏ڍׂ́A IWbemServices::DeleteInstanceAsync()
//  MSDN wvQƂĂB

STDMETHODIMP [!output CLASS_NAME]::DeleteInstanceAsync( 
							const BSTR ObjectPath,
							long lFlags,
							IWbemContext  *pCtx,
							IWbemObjectSink  *pResponseHandler)
{
	//̃\bhCvg邽߂ɁACX^X voC_ strObjectPath p[^
	//Ɏw肳ꂽIuWFNg pX͂AΉCX^X
	//폜܂B
	[!if SUPPORT_DELETE ]

	if (NULL == pResponseHandler)
	{
		return WBEM_E_INVALID_PARAMETER;
	}
    
	[!if IS_COMPOUND_KEY]
	ULONG ulPathTest = WBEMPATH_INFO_IS_INST_REF | WBEMPATH_INFO_IS_COMPOUND;
	[!else]
	[!if IS_SINGLETON]
	ULONG ulPathTest = WBEMPATH_INFO_IS_INST_REF | WBEMPATH_INFO_CONTAINS_SINGLETON;
	[!else]
	ULONG ulPathTest = WBEMPATH_INFO_IS_INST_REF;
	[!endif]
	[!endif]
		
	if (FAILED(m_pHelper->CheckInstancePath(m_pPathFactory,
											ObjectPath,
											CComBSTR(s_pMyClassName),
											ulPathTest)) )
	{
		//pX̍\G[A^ꂽNX̃pX܂B
		return WBEM_E_INVALID_PARAMETER; 
	}			
	
	[!if IS_SINGLETON]
	//: [!output WMICLASSNAME] ̓VOg IuWFNgłB CX^XʂKv͂܂B
	//: CX^X݂Ȃꍇ́AWMIɒʐMԂ߂Ɏ̃RgȂĂ:
	// WBEM_E_NOT_FOUND Ԃ܂;
	[!else]
	//pX p[T[ IuWFNg쐬܂B
	CComPtr<IWbemPath>pPath;
	HRESULT hr = m_pPathFactory->CreateInstance(NULL,
												IID_IWbemPath,
												(void **) &pPath);
	if (FAILED(hr))
	{
		return WBEM_E_FAILED;
	}
	
	CComPtr<IWbemPathKeyList> pIKeyList;
	hr = pPath->GetKeyList(&pIKeyList);
	if (FAILED(hr))
	{
		return hr;
	}
	
	unsigned long ulNumKeys;
	hr = pIKeyList->GetCount(&ulNumKeys);

	//L[ vpeB̒l擾܂B
	unsigned long uKeyNameBufferSize = CComBSTR(ObjectPath).Length() + 1;
	WCHAR * wKeyName = new WCHAR[uKeyNameBufferSize];
	if (NULL == wKeyName)
	{
		return WBEM_E_OUT_OF_MEMORY;
	}
	CComVariant vValue;
	unsigned long ulApparentCimType;
	for (unsigned long i = 0; i < ulNumKeys; i++)
	{			
		hr = pIKeyList->GetKey2(i, 0L, &uKeyNameBufferSize, 
								wKeyName, &vValue, &ulApparentCimType);			
		//TODO: Ŏg߂ vValue ۑ܂B
	}
	delete[] wKeyName;

	//TODO: vIuWFNgoč폜邽߂Ƀf[^ \[XŌJԂ܂B
	//: pXɎꂽL[lɈvIuWFNgołȂꍇA
	// WMI ɒʐM邽߂Ɏ̍sRgɂĂ:
	//return WBEM_E_NOT_FOUND;
	[!endif]	

	pResponseHandler->SetStatus(0, WBEM_S_NO_ERROR, NULL, NULL);	
    return WBEM_S_NO_ERROR;
	
	[!else]
	return WBEM_E_PROVIDER_NOT_CAPABLE;
	[!endif]
}


//////////////////////////////////////////////////////////////////////////////
// [!output CLASS_NAME]::CreateInstanceEnumAsync()
// ̃\bh̎ɂĂ̏ڍׂ́AIWbemServices::CreateInstanceEnumAsync()
//  MSDN hLgQƂĂB

STDMETHODIMP [!output CLASS_NAME]::CreateInstanceEnumAsync( 
							const BSTR Class,
							long lFlags,
							IWbemContext  *pCtx,
							IWbemObjectSink  *pResponseHandler)
{
	

	//: CX^X voC_̑s邽߂ WMI Xbh擾Ă邱Ƃ
	//ɒӂĂBVN AddRef() \bhĂяoČʃZbgɃIuWFNgzz邽߂
	//ʂ̃Xbh쐬ĂB 
	//ɂAXbh v[ՂȂŌ݂̃Xbh WMI ԂƂł܂B
	//voC_fA Xbh fUCVO Xbh fUCI邩ǂ́A
	//voC_ WMI Xbhgp\̊ԂɈˑ܂B

	[!if SUPPORT_ENUMERATE ]
	if (NULL == pResponseHandler)
	{
	    return WBEM_E_INVALID_PARAMETER;
	}

	HRESULT hr = WBEM_S_NO_ERROR;
	
	[!if IS_SINGLETON]
	// CX^X f[^󂯎邽߂ɋ̃IuWFNgpӂ܂B
    CComPtr<IWbemClassObject> pNewInst;
    hr = m_pClass->SpawnInstance(0, &pNewInst);
		
	CComVariant var;
	[!if CLASS_SPECIFIED]
	[!output POPULATE_INSTANCE]
	[!else]
	//TODO: CX^XɃvpeBĂB:
	//CComVariant var;
	//var.ChangeType(VT_BSTR);
	//var = <value>;  //ɓK؂Ȓl͂ĂB
	//hr = pNewInst->Put(CComBSTR(pMyProperty), 0, &var, 0);
	//var.Clear();
	[!endif]
		
	// NX WMI ɔzz܂B
    pResponseHandler->Indicate(1, &pNewInst);
	[!else]
    // vCx[g \[X[vɂAeCX^X쐬ĂB
	//while (<CX^X>)
    {
		// CX^X f[^󂯎邽߂ɋ̃IuWFNgpӂ܂B
        CComPtr<IWbemClassObject> pNewInst;
        hr = m_pClass->SpawnInstance(0, &pNewInst);
		if (FAILED(hr))
		{	
			//TODO: [v͂A̍sRgɂĂB
			//break;
		}
		
		CComVariant var;
		[!if CLASS_SPECIFIED]
		[!output POPULATE_INSTANCE]
		[!else]
		//TODO: CX^XɃvpeB܂B:
		//CComVariant var;
		//var.ChangeType(VT_BSTR);
		//var = <value>;  //ɓK؂Ȓl͂Ă
		//hr = pNewInst->Put(CComBSTR(pMyProperty), 0, &var, 0);
		//var.Clear();
		[!endif]
		
		// NX WMI ɔzz܂B
        pResponseHandler->Indicate(1, &pNewInst);
    }  	
	[!endif]
	pResponseHandler->SetStatus(0, hr, NULL, NULL);
   	return WBEM_S_NO_ERROR;
	[!else]
	return WBEM_E_PROVIDER_NOT_CAPABLE;
	[!endif]
}


//////////////////////////////////////////////////////////////////////////////
//[!output CLASS_NAME]::ExecQueryAsync()
// ̃\bh̎ɂĂ̏ڍׂ́AIWbemServices::ExecQueryAsync()
//  MSDN hLgQƂĂB

STDMETHODIMP [!output CLASS_NAME]::ExecQueryAsync( 
							const BSTR QueryLanguage,
							const BSTR Query,
							long lFlags,
							IWbemContext  *pCtx,
							IWbemObjectSink  *pResponseHandler)
{
	
	
   	// CX^X voC_̓T[rXɑ΂āANG̃T|[g܂͂̃T|[g WMI Ɉˑ
	// IvV܂BNGT|[g邽߂ɂ́ACX^X voC_
	// ȒP SQL (Structured Query Language) Xe[gg̉́AvꂽNG̎sA
	// ʃZbg IuWFNg̗v҂̃VNւ̔zMsKv܂B 
	
	//TODO: NGR[hɓ͂ĂB
	
	//pResponseHandler->SetStatus(0, WBEM_S_NO_ERROR, NULL, NULL);
	// return WBEM_S_NO_ERROR;

	return WBEM_E_PROVIDER_NOT_CAPABLE;
	
}

[!if PROVIDE_METHODS ]

//////////////////////////////////////////////////////////////////////////////
// [!output CLASS_NAME]::ExecMethodAsync()
// ̃\bh̎ɂĂ̏ڍׂ́AIWbemServices::ExecMethodAsync()
//  MSDN hLgQƂĂB

STDMETHODIMP [!output CLASS_NAME]::ExecMethodAsync( 
							const BSTR strObjectPath,
							const BSTR strMethodName,
							long lFlags,
							IWbemContext  *pCtx,
							IWbemClassObject  *pInParams,
							IWbemObjectSink  *pResponseHandler)
{
	

	[!if CLASS_SPECIFIED]
	[!if  !HAS_IMPL_METHODS]	
	//[!output WMICLASSNAME] ɂ͎ꂽ\bh܂B
	return WBEM_E_NOT_SUPPORTED;
	[!else]
	HRESULT hr = WBEM_E_FAILED;	
    if (NULL == pResponseHandler)
	{
        return WBEM_E_INVALID_PARAMETER;
	}	
	[!output EXEC_METHOD_BODY]
	[!endif]
	[!else]
	
	//pX̃NXƂmFĂB
	//pX p[T[ IuWFNg擾܂:
	CComPtr<IWbemPath>pPath;
	HRESULT hr = m_pPathFactory->CreateInstance(NULL,
												IID_IWbemPath,
												(void **) &pPath);
	if (FAILED(hr))
	{
		return WBEM_E_FAILED;
	}

	HRESULT hr = pPath->SetText(WBEMPATH_CREATE_ACCEPT_ALL, strObjectPath);
	long nPathLen = CComBSTR(strObjectPath).Length();
	unsigned long ulBufLen = nPathLen + 1;
	WCHAR * wClass = new WCHAR[nPathLen];
	if (NULL == wClass)
	{
		return WBEM_E_OUT_OF_MEMORY;
	}
	pPath->GetClassName(&ulBufLen, wClass);
	if ( _wcsicmp(s_pMyClassName, wClass))
	{
		delete[] wClass;
		return WBEM_E_INVALID_PARAMETER;
	}
	delete[] wClass;
	//TODO: vꂽ\bhƃNX̃\bhrĂB
	//if (!_wcsicmp (strMethodName, pMyNonStaticMethod))
	{
		CComVariant var;

		//͈擾܂:
		//TODO: \bhɓ͈ꍇ́A͈ pInParams IuWFNg̃voeBƂēn܂B
		//͈̎óAȉ̃RgsQƂĂ:
		//hr = pInParams->Get(CComBSTR("InputArgument1"), 0, &var, NULL, NULL);
		//TODO: ̓p[^̒lۑ܂B
		var.Clear();		
		
		//\bh̎s̃CX^Xo邽߂ɃpX͂܂: ÓIłȂ\bhp
		CComPtr<IWbemPathKeyList> pIKeyList;
		hr = pPath->GetKeyList(&pIKeyList);
		if (FAILED(hr))
		{
			return WBEM_E_INVALID_PARAMETER;
		}
		unsigned long ulNumKeys;
		hr = pIKeyList->GetCount(&ulNumKeys);
		//L[vpeB̒l擾܂:
		unsigned long uKeyNameBufferSize = nPathLen + 1;
		WCHAR  * wKeyName = new WCHAR[uKeyNameBufferSize];
		if (NULL == wKeyName)
		{
			return WBEM_E_OUT_OF_MEMORY;
		}
		CComVariant vValue;
		unsigned long ulApparentCimType;
		for (unsigned long i = 0; i < ulNumKeys; i++)
		{
			hr = pIKeyList->GetKey2(i, 0L, &uKeyNameBufferSize,
									wKeyName, &vValue, &ulApparentCimType);
			//TODO: Ŏg߂ vValue ۑ܂B
		}
		delete[] wKeyName;
	
		//TODO: IuWFNg邽߂Ƀf[^ \[XgČJԂB
		
		//TODO: \bhs邽߂ɂɃR[h𑫂ĂB
		//o̓p[^̃NX󂯎܂B
		CComPtr<IWbemClassObject> pOutClass;
		hr = m_pClass->GetMethod(CComBSTR("Method1"), 0, NULL, &pOutClass);
		CComPtr<IWbemClassObject> pOutParams;
		pOutClass->SpawnInstance(0, &pOutParams);
		//TODO: pOutParams ̃NX̃vpeBt@CāA
		//o̓p[^쐬܂B:

		//var.ChangeType(VT_BSTR);
		//var ɓK؂Ȓl͂ĂB
		//hr = pOutParams->Put(CComBSTR("MyOutputParameter"), 0, &var, 0);
		//var.Clear();
		//var.ChangeType(VT_I2);
		//var ɓK؂Ȓl͂ĂB
		//hr = pOutParams->Put(CComBSTR("ReturnValue"), 0, &var, 0);
		//var.Clear();
		// o̓IuWFNgVNʂăNCAgɑԂĂB
		hr = pResponseHandler->Indicate(1, &pOutParams);
		
		pResponseHandler->SetStatus(0, WBEM_S_NO_ERROR, NULL, NULL);
		return WBEM_S_NO_ERROR;
	}
	
	//FȂ\bhłB
	return WBEM_E_INVALID_PARAMETER;
	
	
	[!endif]	
}
[!endif]



//////////////////////////////////////////////////////////////////////////////
// [!output CLASS_NAME]::GetInstanceByPath() ͗vꂽL[̒lo邽߂ɃpX͂A
// L[̒lɈvIuWFNgXgA܂B
// ̂悤ȃIuWFNgoꍇ́A\bh͐VCX^X𐶐AׂẴvpeB͂āA
// ppInstance ɕԂ܂B oȂꍇ́A\bh WBEM_E_NOT_FOUND Ԃ܂B
// bugbug: IȃCX^X́HHH  قɉ\ȃtÓH

STDMETHODIMP [!output CLASS_NAME]::GetInstanceByPath (
													/*in*/CComBSTR bstrPath,
													/*out*/IWbemClassObject ** ppInstance )
													
{
		HRESULT hr = WBEM_E_FAILED;				  
		
		[!if IS_COMPOUND_KEY]
		ULONG ulPathTest = WBEMPATH_INFO_IS_INST_REF | WBEMPATH_INFO_IS_COMPOUND;
		[!else]
		[!if IS_SINGLETON]
		ULONG ulPathTest = WBEMPATH_INFO_IS_INST_REF | WBEMPATH_INFO_CONTAINS_SINGLETON;
		[!else]
		ULONG ulPathTest = WBEMPATH_INFO_IS_INST_REF;
		[!endif]
		[!endif]
		
		if (FAILED(m_pHelper->CheckInstancePath(m_pPathFactory,
												bstrPath,
												CComBSTR(s_pMyClassName),
												ulPathTest)))
		{
			//pXɍ\G[邩A^ꂽNX̃pX܂B
			return WBEM_E_INVALID_PARAMETER; 
		}			
		
		[!if IS_SINGLETON]
		//[!output WMICLASSNAME] ̓VOg IuWFNgłBCX^XʂKv͂܂B
	//: CX^X݂Ȃꍇ́A WMI ɒʐM邽߂Ɏ̍sRgƂĂ:
		//return WBEM_E_NOT_FOUND;
		[!else]
		//pX p[T[ IuWFNg擾܂:
		CComPtr<IWbemPath>pPath;
		hr = m_pPathFactory->CreateInstance(NULL,
												IID_IWbemPath,
												(void **) &pPath);
		if (FAILED(hr))
		{
			return WBEM_E_FAILED;
		}
		
		hr = pPath->SetText(WBEMPATH_CREATE_ACCEPT_ALL,
									bstrPath);

		CComPtr<IWbemPathKeyList> pIKeyList;
		hr = pPath->GetKeyList(&pIKeyList);
		if (FAILED(hr))
		{
			return hr;
		}
		unsigned long ulNumKeys;
		hr = pIKeyList->GetCount(&ulNumKeys);

		//L[vpeB̒l擾܂B
		unsigned long uKeyNameBufferSize = bstrPath.Length() + 1;
		WCHAR  * wKeyName = new WCHAR[uKeyNameBufferSize];
		if (NULL == wKeyName)
		{
			return WBEM_E_OUT_OF_MEMORY;
		}
		CComVariant vValue;		
		unsigned long ulApparentCimType;
		for (unsigned long i = 0; i < ulNumKeys; i++)
		{			
			hr = pIKeyList->GetKey2(i, 0L, &uKeyNameBufferSize, 
									wKeyName, &vValue, &ulApparentCimType);			
			//TODO:Ŏg߂ vValue ۑ܂B
		}

		delete[] wKeyName;
		
		//TODO: vIuWFNgo邽߂ɓ̃f[^ \[XĂB
		//vꂽL[̒lȂꍇ́A 
		//WBEM_E_NOT_FOUND Ԃ܂B
		[!endif]
	   
		//VCX^X𐶐܂B
		CComPtr<IWbemClassObject> pNewInst;
		hr = m_pClass->SpawnInstance(0, &pNewInst);
		if(FAILED(hr))
		{
			return hr;
		}
		CComVariant var;

		//TODO: VCX^X̃vpeBvIuWFNgœ͂ĂBB
		[!if CLASS_SPECIFIED]
		[!output POPULATE_INSTANCE]			
		[!else]
		//:
		//var.ChangeType(VT_BSTR);
		//var = <value>; //ɓK؂Ȓl͂ĂB
		//hr = pNewInst->Put(CComBSTR(pMyProperty), 0, &var, 0);
		//var.Clear();		
		[!endif]

		return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vc7\system\wbem\wmiscriptutils\wmiobjectbrokerregistration.cpp ===
// WMIObjectBrokerRegistration.cpp : Implementation of CWMIObjectBrokerRegistration
#include "stdafx.h"
#include "WMIScriptUtils.h"
#include "WMIObjectBrokerRegistration.h"
#include "CommonFuncs.h"

/////////////////////////////////////////////////////////////////////////////
// CWMIObjectBrokerRegistration


STDMETHODIMP CWMIObjectBrokerRegistration::Register(BSTR strProgId, VARIANT_BOOL *bResult)
{
	*bResult = VARIANT_FALSE;
	if(SUCCEEDED(RegisterCurrentDoc(GetUnknown(), strProgId)))
		*bResult = VARIANT_TRUE;
	return S_OK;
}

STDMETHODIMP CWMIObjectBrokerRegistration::UnRegister(BSTR strProgId, VARIANT_BOOL *bResult)
{
	*bResult = VARIANT_FALSE;
	if(SUCCEEDED(UnRegisterCurrentDoc(GetUnknown(), strProgId)))
		*bResult = VARIANT_TRUE;
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vc7\system\wbem\wmiscriptutils\wmiobjectbrokerregistration.h ===
// WMIObjectBrokerRegistration.h : Declaration of the CWMIObjectBrokerRegistration

#ifndef __WMIOBJECTBROKERREGISTRATION_H_
#define __WMIOBJECTBROKERREGISTRATION_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CWMIObjectBrokerRegistration
class ATL_NO_VTABLE CWMIObjectBrokerRegistration : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CWMIObjectBrokerRegistration, &CLSID_WMIObjectBrokerRegistration>,
	public IDispatchImpl<IWMIObjectBrokerRegistration, &IID_IWMIObjectBrokerRegistration, &LIBID_WMISCRIPTUTILSLib>,
	public IObjectWithSiteImpl<CWMIObjectBrokerRegistration>
{
public:
	CWMIObjectBrokerRegistration()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_WMIOBJECTBROKERREGISTRATION)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CWMIObjectBrokerRegistration)
	COM_INTERFACE_ENTRY(IWMIObjectBrokerRegistration)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IObjectWithSite)
END_COM_MAP()

// IWMIObjectBrokerRegistration
public:
	STDMETHOD(UnRegister)(/*[in]*/ BSTR strProgId, /*[out, retval]*/ VARIANT_BOOL *bResult);
	STDMETHOD(Register)(/*[in]*/ BSTR strProgId, /*[out, retval]*/ VARIANT_BOOL *bResult);
};

#endif //__WMIOBJECTBROKERREGISTRATION_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vc7\system\wbem\wmiscriptutils\wmiscriptutils.cpp ===
// WMIScriptUtils.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f WMIScriptUtilsps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "WMIScriptUtils.h"

#include "WMIScriptUtils_i.c"
#include "WMIObjectBroker.h"
#include "WMIObjectBrokerRegistration.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_WMIObjectBroker, CWMIObjectBroker)
OBJECT_ENTRY(CLSID_WMIObjectBrokerRegistration, CWMIObjectBrokerRegistration)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_WMISCRIPTUTILSLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vc7\beta1\vcwiz\classwiz\atl\instance\templates\1041\wmiprov.h ===
[!if  !INSTANCE]
//G[: Cxg voC_ wb_[ ev[g͊Ԉނ̃voC_Ăяo܂B
[!else]
// [!output HEADER_FILE] :  [!output CLASS_NAME] ̐錾B

#pragma once
#include "resource.h"       // C V|łB

#include <wbemidl.h>
#include <atlwmiprov.h>
#include <wmiutils.h>	//pX p[T[łB

//////////////////////////////////////////////////////////////////////////////
// NXAvpeBA\bhł: [!output IMPL_FILE] Œ`܂B

extern const WCHAR * s_pMyClassName;	//NXłB

[!if CLASS_SPECIFIED]
//vpeB:
[!output PROPERTY_DECLARATIONS]

//\bh:
[!output METHOD_DECLARATIONS]
[!else]
//TODO: ^ꂽNX̃vpeB錾ĂB:
//extern const WCHAR * pMyProperty;

//TODO: ^ꂽNX̃\bh錾ĂB:
//extern const WCHAR * pMyMethod;
[!endif]

[!if ATTRIBUTED]
[
	coclass,
[!if THREADING_APARTMENT]
	threading("apartment"),
[!endif]
[!if THREADING_BOTH]
	threading("both"),
[!endif]
[!if THREADING_FREE]
	threading("free"),
[!endif]
	aggregatable("never"),
	vi_progid("[!output VERSION_INDEPENDENT_PROGID]"),
	progid("[!output PROGID]"),
	version(1.0),
	uuid("[!output CLSID_REGISTRY_FORMAT]"),
	helpstring("[!output TYPE_NAME]")
]
[!endif]
/////////////////////////////////////////////////////////////////////////////
// [!output CLASS_NAME]

class ATL_NO_VTABLE [!output CLASS_NAME] : 
					[!if !ATTRIBUTED]
					[!if THREADING_APARTMENT]
						public CComObjectRootEx<CComSingleThreadModel>,
					[!endif]
					[!if THREADING_BOTH]
						public CComObjectRootEx<CComMultiThreadModel>,
					[!endif]
					[!if THREADING_FREE]
						public CComObjectRootEx<CComMultiThreadModel>,
					[!endif]
						public CComCoClass<[!output CLASS_NAME], &CLSID_[!output COCLASS]>,
					[!endif]
						public IWbemInstProviderImpl
{
	
	CComPtr<IWbemServices>  m_pNamespace; 	//LbVꂽ IWbemServices |C^łB
	CComPtr<IWbemClassObject> m_pClass;		//LbVꂽ^ꂽNX̒`łB  	
	CComPtr<IWbemClassObject> m_pErrorObject;//LbVꂽG[ IuWFNg NX̒`̃|C^łB
	CComPtr<IClassFactory> m_pPathFactory;	 //p[T[̃NX t@NgpX邽߂̃LbVꂽ|C^łB

	CInstanceProviderHelper * m_pHelper;
	
	STDMETHODIMP GetInstanceByPath (CComBSTR bstrPath,
									IWbemClassObject ** ppInstance );

  public:
	[!output CLASS_NAME]()
	{
		m_pHelper = NULL;					
	}

	~[!output CLASS_NAME]()
	{
	    if (NULL != m_pHelper)
		{
			delete m_pHelper;
		}
		//C^[tFCX |C^ f[^ o̓X}[gŎIɉ܂B
	}
	
	[!if !ATTRIBUTED]
	DECLARE_REGISTRY_RESOURCEID(IDR_[!output UPPER_SHORT_NAME])

	DECLARE_NOT_AGGREGATABLE([!output CLASS_NAME])

	BEGIN_COM_MAP([!output CLASS_NAME])
		COM_INTERFACE_ENTRY(IWbemServices)
		COM_INTERFACE_ENTRY(IWbemProviderInit)
	END_COM_MAP()
	[!endif]

	//IWbemProviderInit
	HRESULT STDMETHODCALLTYPE Initialize( 
										LPWSTR pszUser,
										LONG lFlags,
										LPWSTR pszNamespace,
										LPWSTR pszLocale,
										IWbemServices *pNamespace,
										IWbemContext *pCtx,
										IWbemProviderInitSink *pInitSink);

	//IWbemServices
	HRESULT STDMETHODCALLTYPE GetObjectAsync(
										const BSTR ObjectPath,
										long lFlags,
										IWbemContext __RPC_FAR *pCtx,
										IWbemObjectSink __RPC_FAR *pResponseHandler);


	HRESULT STDMETHODCALLTYPE DeleteInstanceAsync(
										const BSTR ObjectPath,
										long lFlags,
										IWbemContext __RPC_FAR *pCtx,
										IWbemObjectSink __RPC_FAR *pResponseHandler);


	HRESULT STDMETHODCALLTYPE PutInstanceAsync(
										IWbemClassObject __RPC_FAR *pInst,
										long lFlags,
										IWbemContext __RPC_FAR *pCtx,
										IWbemObjectSink __RPC_FAR *pResponseHandler);


	HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync( 
										const BSTR Class,
										long lFlags,
										IWbemContext __RPC_FAR *pCtx,
										IWbemObjectSink __RPC_FAR *pResponseHandler);

	HRESULT STDMETHODCALLTYPE ExecQueryAsync( 
										const BSTR QueryLanguage,
										const BSTR Query,
										long lFlags,
										IWbemContext __RPC_FAR *pCtx,
										IWbemObjectSink __RPC_FAR *pResponseHandler);

	[!if PROVIDE_METHODS]
	HRESULT STDMETHODCALLTYPE ExecMethodAsync( 
										const BSTR strObjectPath,
										const BSTR strMethodName,
										long lFlags,
										IWbemContext __RPC_FAR *pCtx,
										IWbemClassObject __RPC_FAR *pInParams,
										IWbemObjectSink __RPC_FAR *pResponseHandler);
	[!else]
	HRESULT STDMETHODCALLTYPE ExecMethodAsync( 
										const BSTR strObjectPath,
										const BSTR strMethodName,
										long lFlags,
										IWbemContext __RPC_FAR *pCtx,
										IWbemClassObject __RPC_FAR *pInParams,
										IWbemObjectSink __RPC_FAR *pResponseHandler) 
	{	
		//: \bh^ꍇ́A
		//ExecMethodAsync() ̃Cvg쐬Kv܂B
		return WBEM_E_NOT_SUPPORTED;
	}
	[!endif]

};

[!if !ATTRIBUTED]
OBJECT_ENTRY_AUTO(__uuidof([!output COCLASS]), [!output CLASS_NAME])
[!endif]

[!endif]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vc7\system\wbem\wmiscriptutils\commonfuncs.cpp ===
#include "stdafx.h"

#include "CommonFuncs.h"
#include "FileHash.h"

#define SAFE_LOCAL_SCRIPTS_KEY TEXT("Software\\Microsoft\\WBEM\\SafeLocalScripts")


// QUESTIONS:
// - What is passed to SetSite when we are create in script?
// - If we are passed an IOleClientSite, is it a good idea to QueryService for
//   an IWebBrowserApp?
// - Is there a better way to get the IHTMLDocument2 when we are created through
//   script?

// Here are some general notes about what I've observed when creating objects
// in HTML with IE 5.x.

// Observed IE 5.x Behavior
// If an object implements IOleObject AND IObjectWithSite
// - For objects created in an HTML page with an <OBJECT...> tag, IE calls
//   IOleObject::SetClientSite and passes an IOleClientSite object
// - For object created in script of HTML page using JScript
//   'new ActiveXObject' or VBScript 'CreateObject' function, IE calls
//   IObjectWithSite::SetSite with a ??? object

// If an object implements IObjectWithSite (and NOT IOleObject)
// - For object created in HTML page with <OBJECT...> tag, IE calls
//   IObjectWithSite::SetSite and passes an IOleClientSite object
// - For object created in script of HTML page using JScript
//   'new ActiveXObject' or VBScript 'CreateObject' function, IE calls
//   IObjectWithSite::SetSite with a ??? object


//		BYTE *pbData = NULL;
//		DWORD dwSize;
//		GetSourceFromDoc(pDoc, &pbData, &dwSize);
// Get the original source to the document specified by pDoc
HRESULT GetSourceFromDoc(IHTMLDocument2 *pDoc, BYTE **ppbData, DWORD *pdwSize)
{
	HRESULT hr = E_FAIL;
	IPersistStreamInit *pPersistStreamInit = NULL;
	IStream *pStream = NULL;

	*ppbData = NULL;

	__try
	{
		if(FAILED(hr = pDoc->QueryInterface(IID_IPersistStreamInit, (void**) &pPersistStreamInit)))
			__leave;

		if (FAILED(hr = CreateStreamOnHGlobal(NULL, TRUE, &pStream)))
			__leave;

		if(FAILED(hr = pPersistStreamInit->Save(pStream, TRUE)))
			__leave;

		// We are not responsible for freeing this HGLOBAL
		HGLOBAL hGlobal = NULL;
		if(FAILED(hr = GetHGlobalFromStream(pStream, &hGlobal)))
			__leave;

		STATSTG ss;
		if(FAILED(hr = pStream->Stat(&ss, STATFLAG_NONAME)))
			__leave;

		// This should never happen
		if(ss.cbSize.HighPart != 0)
			__leave;

		if(NULL == ((*ppbData) = new BYTE[ss.cbSize.LowPart]))
			__leave;
		
		LPVOID pHTMLText = NULL;
		if(NULL == (pHTMLText = GlobalLock(hGlobal)))
			__leave;

		*pdwSize = ss.cbSize.LowPart;
		memcpy(*ppbData, pHTMLText, ss.cbSize.LowPart);
		GlobalUnlock(hGlobal);
		hr = S_OK;

	}
	__finally
	{
		// If we did not finish, but we allocated memory, we free it.
		if(FAILED(hr) && (*ppbData)!=NULL)
			delete [] (*ppbData);

		if(pPersistStreamInit)
			pPersistStreamInit->Release();
		if(pStream)
			pStream->Release();
	}
	return hr;
}


// For a control specified by pUnk, get the IServiceProvider of the host
HRESULT GetSiteServices(IUnknown *pUnk, IServiceProvider **ppServProv)
{
	HRESULT hr = E_FAIL;
	IOleObject *pOleObj = NULL;
	IObjectWithSite *pObjWithSite = NULL;
	IOleClientSite *pSite = NULL;
	__try
	{
		// Check if the ActiveX control supports IOleObject.
		if(SUCCEEDED(pUnk->QueryInterface(IID_IOleObject, (void**)&pOleObj)))
		{
			// If the control was created through an <OBJECT...> tag, IE will
			// have passed us an IOleClientSite.  If we have not been passed
			// an IOleClientSite, GetClientSite will still SUCCEED, but pSite
			// will be NULL.  In this case, we just go to the next section.
			if(SUCCEEDED(pOleObj->GetClientSite(&pSite)) && pSite)
			{
				hr = pSite->QueryInterface(IID_IServiceProvider, (void**)ppServProv);

				// At this point, we are done and do not want to process the
				// code in the next seciont
				__leave;
			}
		}

		// At this point, one of two things has happened:
		// 1) We didn't support IOleObject
		// 2) We supported IOleObject, but we were never passed an IOleClientSite

		// In either case, we now need to look at IObjectWithSite to try to get
		// to our site
		if(FAILED(hr = pUnk->QueryInterface(IID_IObjectWithSite, (void**)&pObjWithSite)))
			__leave;

		hr = pObjWithSite->GetSite(IID_IServiceProvider, (void**)ppServProv);
	}
	__finally
	{
		// Release any interfaces we used along the way
		if(pOleObj)
			pOleObj->Release();
		if(pObjWithSite)
			pObjWithSite->Release();
		if(pSite)
			pSite->Release();
	}
	return hr;
}

// This function shows how to get to the IHTMLDocument2 that created an
// arbitrary control represented by pUnk
HRESULT GetDocument(IUnknown *pUnk, IHTMLDocument2 **ppDoc)
{
	HRESULT hr = E_FAIL;
	IServiceProvider* pServProv = NULL;
	IDispatch *pDisp = NULL;
	__try
	{
		if(FAILED(hr = GetSiteServices(pUnk, &pServProv)))
			__leave;

		// HACK HACK BUGBUG BUG
		// In IE 5.5, if we use SID_SContainerDispatch, we get to an IHTMLDocument2 that
		// does NOT know about IPersistStreamInit.  It seems that SID_SContainerDispatch
		// gives us a CDocument, and CLSID_HTMLDocument will give us a CDoc.  In IE 5.0,
		// we always got a CDoc that knew how to give us the IPersistStreamInit.
		if(FAILED(hr = pServProv->QueryService(CLSID_HTMLDocument/*SID_SContainerDispatch*/, IID_IDispatch, (void**)&pDisp)))
			__leave;

		hr = pDisp->QueryInterface(IID_IHTMLDocument2, (void**)ppDoc);
	}
	__finally
	{
		if(pServProv)
			pServProv->Release();
		if(pDisp)
			pDisp->Release();
	}
	return hr;
}





// This function will Release() the current document and return a pointer to
// the parent document.  If no parent document is available, this function
// will return NULL (but will still release the current document)
IHTMLDocument2 *GetParentDocument(IHTMLDocument2 *pDoc)
{
	BSTR bstrURL = NULL;
	BSTR bstrURLParent = NULL;
	IHTMLWindow2 *pWndParent = NULL;
	IHTMLWindow2 *pWndParentParent = NULL;
	IHTMLDocument2 *pDocParent = NULL;
	__try
	{
		if(FAILED(pDoc->get_URL(&bstrURL)))
			__leave;
		if(FAILED(pDoc->get_parentWindow(&pWndParent)))
			__leave;
		if(FAILED(pWndParent->get_parent(&pWndParentParent)))
			__leave;
		if(FAILED(pWndParentParent->get_document(&pDocParent)))
			__leave;
		if(FAILED(pDocParent->get_URL(&bstrURLParent)))
			__leave;
		// TODO: Make this more robust
		if(0 == lstrcmpW(bstrURL, bstrURLParent))
		{
			// We are at the top document.  Release the new document pointer we
			// just received.
			pDocParent->Release();
			pDocParent = NULL;
		}
	}
	__finally
	{
		if(bstrURL)
			SysFreeString(bstrURL);
		if(bstrURLParent)
			SysFreeString(bstrURLParent);
		if(pWndParent)
			pWndParent->Release();
		if(pWndParentParent)
			pWndParentParent->Release();
		if(pDoc)
			pDoc->Release();
	}
	return pDocParent;
}


// Try to append bstr2 to pbstr1.  If this function fails, pbstr1 will still
// point to the original valid allocated bstr.
HRESULT AppendBSTR(BSTR *pbstr1, BSTR bstr2)
{
	HRESULT hr = S_OK;
	CComBSTR bstr;
	if(FAILED(bstr.AppendBSTR(*pbstr1)))
		hr = E_FAIL;
	if(FAILED(bstr.AppendBSTR(bstr2)))
		hr = E_FAIL;
	if(SUCCEEDED(hr))
	{
		SysFreeString(*pbstr1);
		*pbstr1 = bstr.Detach();
	}
	return hr;
}

BSTR AllocBSTR(LPCTSTR lpsz)
{
	CComBSTR bstr(lpsz);
	return bstr.Detach();
}

BOOL IsURLLocal(LPWSTR szURL)
{
	CComBSTR bstrURL(szURL);
	if(FAILED(bstrURL.ToLower()))
		return FALSE;
	// Make sure the URL starts with 'file://'
	if(0 != wcsncmp(bstrURL, L"file://", 7))
		return FALSE;
	
	// Make sure the next part is a drive letter, such as 'C:\'
	if(0 != wcsncmp(&(bstrURL[8]), L":\\", 2))
		return FALSE;

	WCHAR drive = bstrURL[7];
	// Make sure the URL points to drive 'a' to 'z'
	if(drive < 'a' || drive > 'z')
		return FALSE;

	TCHAR szDrive[4];
	lstrcpy(szDrive, TEXT("c:\\"));
	szDrive[0] = (TCHAR)drive;

	UINT uDriveType = GetDriveType(szDrive);
	return (DRIVE_FIXED == uDriveType);
}

// Try to convert the BSTR to lower case.  If this function fails, pbstr will
// still point to the original valid allocated bstr.
HRESULT ToLowerBSTR(BSTR *pbstr)
{
	CComBSTR bstr;
	if(FAILED(bstr.AppendBSTR(*pbstr)))
		return E_FAIL;
	if(FAILED(bstr.ToLower()))
		return E_FAIL;
	SysFreeString(*pbstr);
	*pbstr = bstr.Detach();
	return S_OK;
}

// For a given instance of an ActiveX control (represented by pUnk), and a
// specified strProgId, this function creates a 'full path' that can be checked
// in the registry to see if object creation should be allowed.  The full
// location is created from the following information
// 1) The name of the current EXE
// 2) The ProgId requested
// 3) The HREF of the current document
// 4) The HREF of every parent document up the available hierarchy
// All of the documents in the hierarchy must be on a local hard drive or the
// function will fail.  In addition, if any piece of informaiton along the way
// is not available, the function will fail.  This increases the security of
// our process.
// This function will also create a BSTR in *pbstrHash that contains the
// cumulative MD5 hash of the document and its parents.  This BSTR will be
// allocated by the function and should be freed by the caller.  If the
// function returns NULL for the full location, it will also return NULL for
// *pbstrHash
BSTR GetFullLocation(IUnknown *pUnk, BSTR strProgId, BSTR *pbstrHash)
{
	HRESULT hr = E_FAIL;
	IHTMLDocument2 *pDoc = NULL;
	BSTR bstrURL = NULL;
	BSTR bstrFullLocation = NULL;
	*pbstrHash = NULL;
	BYTE *pbData = NULL;
	BSTR bstrHash = NULL;

	__try
	{
		if(FAILED(GetDocument(pUnk, &pDoc)))
			__leave;

		TCHAR szFilename[_MAX_PATH];
		TCHAR szFilenameLong[_MAX_PATH];
		GetModuleFileName(NULL, szFilenameLong, _MAX_PATH);
		GetShortPathName(szFilenameLong, szFilename, _MAX_PATH);
		
		if(NULL == (bstrFullLocation = AllocBSTR(szFilename)))
			__leave;

		if(FAILED(AppendBSTR(&bstrFullLocation, strProgId)))
			__leave;

		if(NULL == (*pbstrHash = AllocBSTR(_T(""))))
			__leave;

		int nDepth = 0;
		do
		{
			// Make sure we don't get stuck in some infinite loop of parent
			// documents.  If we do get more than 100 levels of parent
			// documents, we assume failure
			if(++nDepth >= 100)
				__leave;

			if(FAILED(pDoc->get_URL(&bstrURL)))
				__leave;

			DWORD dwDataSize = 0;
			if(FAILED(GetSourceFromDoc(pDoc, &pbData, &dwDataSize)))
				__leave;

			MD5Hash hash;
			if(FAILED(hash.HashData(pbData, dwDataSize)))
				__leave;

			if(NULL == (bstrHash = hash.GetHashBSTR()))
				__leave;

			if(FAILED(AppendBSTR(pbstrHash, bstrHash)))
				__leave;

			SysFreeString(bstrHash);
			bstrHash = NULL;
			delete [] pbData;
			pbData = NULL;


			// Make sure every document is on the local hard drive
			if(!IsURLLocal(bstrURL))
				__leave;

			if(FAILED(AppendBSTR(&bstrFullLocation, bstrURL)))
				__leave;

			SysFreeString(bstrURL);
			bstrURL = NULL;
		} while (NULL != (pDoc = GetParentDocument(pDoc)));

		// Make sure we do not have any embeded NULLs.  If we do, we just
		// FAIL the call
		if(SysStringLen(bstrFullLocation) != wcslen(bstrFullLocation))
			__leave;

		// Make the location lower case
		if(FAILED(ToLowerBSTR(&bstrFullLocation)))
			__leave;

		// We've now created the normalized full location
		hr = S_OK;
	}
	__finally
	{
		// pDoc should be NULL if we got to the top of the hierarchy.  If not,
		// we should release it
		if(pDoc)
			pDoc->Release();

		// pbData should be NULL unless there was an error calculating the hash
		if(pbData)
			delete [] pbData;

		// bstrHash should be NULL unless there was a problem
		if(bstrHash)
			SysFreeString(bstrHash);

		// bstrURL should be NULL unless there was a problem
		if(bstrURL)
			SysFreeString(bstrURL);

		// If we didn't make it all the way to the end, we free the full location
		if(FAILED(hr) && bstrFullLocation)
		{
			SysFreeString(bstrFullLocation);
			bstrFullLocation = NULL;
		}

		// If we didn't make it all the way to the end, we free the checksum
		if(FAILED(hr) && *pbstrHash)
		{
			SysFreeString(*pbstrHash);
			*pbstrHash = NULL;
		}
	}

	return bstrFullLocation;
}

// For a given instance of an ActiveXControl (specified by pUnk), see if it is
// permitted to create the object specified by bstrProgId.  This is done by
// verifying that the control was created in an allowed HTML document.
HRESULT IsCreateObjectAllowed(IUnknown *pUnk, BSTR strProgId, BSTR *pstrValueName)
{
	BSTR bstrFullLocation = NULL;
	HRESULT hr = E_FAIL;
	HKEY hKey = NULL;
	LPTSTR pszValueName = NULL;
	LPTSTR pszValue = NULL;
	__try
	{
		BSTR bstrHash = NULL;
		// Get the full location
		if(NULL == (bstrFullLocation = GetFullLocation(pUnk, strProgId, &bstrHash)))
			__leave;

		SysFreeString(bstrHash);

		// Make sure we don't have a zero length string
		if(0 == SysStringLen(bstrFullLocation))
			__leave;

		// Open the registry key to see if this full location is registered
		if(ERROR_SUCCESS != RegOpenKey(HKEY_LOCAL_MACHINE, SAFE_LOCAL_SCRIPTS_KEY, &hKey))
			__leave;

		// Get info on the max lenghts of values in this key
		DWORD cValues, cMaxValueNameLen, cMaxValueLen;
		if(ERROR_SUCCESS != RegQueryInfoKey(hKey, NULL, NULL, NULL, NULL, NULL, NULL, &cValues, &cMaxValueNameLen, &cMaxValueLen, NULL, NULL))
			__leave;

		// Allocate space for the value name
		if(NULL == (pszValueName = new TCHAR[cMaxValueNameLen + 1]))
			__leave;

		// Allocate space for the value (this may be twice as big as necessary in UNICODE)
		if(NULL == (pszValue = new TCHAR[cMaxValueLen + 1]))
			__leave;
		for(DWORD dw = 0;dw<cValues;dw++)
		{
			DWORD cValueNameLen = cMaxValueNameLen+1;
			DWORD cbData = (cMaxValueLen+1)*sizeof(TCHAR);
			DWORD dwType;
			if(ERROR_SUCCESS != RegEnumValue(hKey, dw, pszValueName, &cValueNameLen, NULL, &dwType, (LPBYTE)pszValue, &cbData))
				continue;
			if(dwType != REG_SZ)
				continue;

			BSTR bstrValue = T2BSTR(pszValue);
			if(!bstrValue)
				continue;

			// SEE IF WE HAVE A MATCH
			if(0 == wcscmp(bstrFullLocation, bstrValue))
			{
				// Return the ValueName if requested
				if(pstrValueName)
					*pstrValueName = AllocBSTR(pszValueName);

				hr = S_OK;
			}

			SysFreeString(bstrValue);

			if(SUCCEEDED(hr))
				__leave; // WE FOUND A MATCH
		}
	}
	__finally
	{
		if(bstrFullLocation)
			SysFreeString(bstrFullLocation);
		if(hKey)
			RegCloseKey(hKey);
		if(pszValueName)
			delete [] pszValueName;
		if(pszValue)
			delete [] pszValue;
	}
	return hr;
}

// This function will register the location of the current ActiveX control
// (specified by pUnk) to be allowed to create objects of type strProgId
HRESULT RegisterCurrentDoc(IUnknown *pUnk, BSTR strProgId)
{
	USES_CONVERSION;

	HRESULT hr = E_FAIL;
	BSTR bstrFullLocation = NULL;
	LPTSTR pszFullLocation = NULL;
	HKEY hKey = NULL;

	__try
	{
		// See if we are already registered
		if(SUCCEEDED(IsCreateObjectAllowed(pUnk, strProgId, NULL)))
		{
			hr = S_OK;
			__leave;
		}

		// TODO: Maybe reuse some of the code from IsCreateObjectAllowed

		BSTR bstrHash = NULL;
		// Get the full location
		if(NULL == (bstrFullLocation = GetFullLocation(pUnk, strProgId, &bstrHash)))
			__leave;

		SysFreeString(bstrHash);

		// Make sure we don't have a zero length string
		if(0 == SysStringLen(bstrFullLocation))
			__leave;

		// Convert BSTR to normal string
		if(NULL == (pszFullLocation = W2T(bstrFullLocation)))
			__leave;

		// Create or open the registry key to store the registration
		if(ERROR_SUCCESS != RegCreateKey(HKEY_LOCAL_MACHINE, SAFE_LOCAL_SCRIPTS_KEY, &hKey))
			__leave;

		// Find an empty slot (no more than 1000 registrations
		TCHAR sz[10];
		for(int i=1;i<1000;i++)
		{
			wsprintf(sz, TEXT("%i"), i);
			DWORD cbValue;
			if(ERROR_SUCCESS != RegQueryValueEx(hKey, sz, NULL, NULL, NULL, &cbValue))
				break; // There is nothing in this slot
		}

		// See if we found a slot
		if(i>=1000)
			__leave;

		// Register the location
		if(ERROR_SUCCESS != RegSetValueEx(hKey, sz, 0, REG_SZ, (CONST BYTE *)pszFullLocation, lstrlen(pszFullLocation)*sizeof(TCHAR)))
			__leave;

		// Registered!
		hr = S_OK;
	}
	__finally
	{
		if(bstrFullLocation)
			SysFreeString(bstrFullLocation);
		if(hKey)
			RegCloseKey(hKey);
	}
	return hr;
}


// This function will remove any registration for the current document and
// strProgId
HRESULT UnRegisterCurrentDoc(IUnknown *pUnk, BSTR strProgId)
{
	USES_CONVERSION;

	BSTR bstrValueName = NULL;

	HKEY hKey = NULL;
	if(ERROR_SUCCESS != RegOpenKey(HKEY_LOCAL_MACHINE, SAFE_LOCAL_SCRIPTS_KEY, &hKey))
		return E_FAIL;

	// Make sure to remove ALL instances of this doc/strProgId in the registry
	// NOTE: Each iteration of this loop allocates some space off of the stack
	// for the conversion to ANSI (if not UNICODE build).  This should not be a
	// problem since there should not be too many keys ever registered with the
	// same location.
	while(SUCCEEDED(IsCreateObjectAllowed(pUnk, strProgId, &bstrValueName)) && bstrValueName)
	{
		LPTSTR szValueName = W2T(bstrValueName);
		SysFreeString(bstrValueName);
		bstrValueName = NULL;
		RegDeleteValue(hKey, szValueName);
	}
	RegCloseKey(hKey);
	return S_OK;
}


///////////////////////////////////////////////////////////////////////////////
// VC 6.0 did not ship with header files that included the CONFIRMSAFETY
// definition.
#ifndef CONFIRMSAFETYACTION_LOADOBJECT

EXTERN_C const GUID GUID_CUSTOM_CONFIRMOBJECTSAFETY;
#define CONFIRMSAFETYACTION_LOADOBJECT  0x00000001
struct CONFIRMSAFETY
{
    CLSID       clsid;
    IUnknown *  pUnk;
    DWORD       dwFlags;
};
#endif

const GUID GUID_CUSTOM_CONFIRMOBJECTSAFETY = 
	{ 0x10200490, 0xfa38, 0x11d0, { 0xac, 0xe, 0x0, 0xa0, 0xc9, 0xf, 0xff, 0xc0 }};

///////////////////////////////////////////////////////////////////////////////

HRESULT SafeCreateObject(IUnknown *pUnkControl, BOOL fSafetyEnabled, CLSID clsid, IUnknown **ppUnk)
{
	HRESULT hr = E_FAIL;
	IInternetHostSecurityManager *pSecMan = NULL;
	IServiceProvider *pServProv = NULL;
	__try
	{
		if (fSafetyEnabled)
		{
			if(FAILED(hr = GetSiteServices(pUnkControl, &pServProv)))
				__leave;

			if(FAILED(hr = pServProv->QueryService(SID_SInternetHostSecurityManager, IID_IInternetHostSecurityManager, (void**)&pSecMan)))
				__leave;
			
			// Ask security manager if we can create objects.
			DWORD dwPolicy = 0x12345678;
			if(FAILED(hr = pSecMan->ProcessUrlAction(URLACTION_ACTIVEX_RUN, (BYTE *)&dwPolicy, sizeof(dwPolicy), (BYTE *)&clsid, sizeof(clsid), 0, 0)))
				__leave;

			// TODO: BUG: If we are loaded in an HTA, hr returns S_OK, but 
			// dwPolicy only has the first byte set to zero.  See documentation
			// for ProcessUrlAction.
			// NOTE: This bug is caused by CClient::ProcessUrlAction in
			// nt\private\inet\mshtml\src\other\htmlapp\site.cxx.  This line
			// uses *pPolicy = dwPolicy, but pPolicy is a BYTE * so only the
			// first byte of the policy is copied to the output parameter.
			// To fix this, we check for hr==S_OK (as opposed to S_FALSE), and
			// see if dwPolicy is 0x12345600 (in other words, only the lower
			// byte of dwPolicy was changed).  As per the documentation, S_OK
			// alone should be enough to assume the dwPolicy was
			// URL_POLICY_ALLOW
			if(S_OK == hr && 0x12345600 == dwPolicy)
				dwPolicy = URLPOLICY_ALLOW;
			
			if(URLPOLICY_ALLOW != dwPolicy)
			{
				hr = E_FAIL;
				__leave;;
			}
		}

		// Create the requested object
		if (FAILED(hr = CoCreateInstance(clsid, NULL, CLSCTX_INPROC_SERVER, IID_IUnknown, (void**)ppUnk)))
			__leave;
		
		if (fSafetyEnabled)
		{
			// Query the security manager to see if this object is safe to use.
			DWORD dwPolicy, *pdwPolicy;
			DWORD cbPolicy;
			CONFIRMSAFETY csafe;
			csafe.pUnk = *ppUnk;
			csafe.clsid = clsid;
			csafe.dwFlags = 0;
//			csafe.dwFlags = (fWillLoad ? CONFIRMSAFETYACTION_LOADOBJECT : 0);
			
			if(FAILED(hr = pSecMan->QueryCustomPolicy(GUID_CUSTOM_CONFIRMOBJECTSAFETY, (BYTE **)&pdwPolicy, &cbPolicy, (BYTE *)&csafe, sizeof(csafe), 0)))
				__leave;
			
			dwPolicy = URLPOLICY_DISALLOW;
			if (NULL != pdwPolicy)
			{
				if (sizeof(DWORD) <= cbPolicy)
					dwPolicy = *pdwPolicy;
				CoTaskMemFree(pdwPolicy);
			}
			
			if(URLPOLICY_ALLOW != dwPolicy)
			{
				hr = E_FAIL;
				__leave;
			}
		}
		hr = S_OK;
	}
	__finally
	{
		// If we did not succeeded, we need to release the object we created (if any)
		if(FAILED(hr) && (*ppUnk))
		{
			(*ppUnk)->Release();
			*ppUnk = NULL;
		}

		if(pServProv)
			pServProv->Release();
		if(pSecMan)
			pSecMan->Release();
	}
	return hr;
}

BOOL IsInternetHostSecurityManagerAvailable(IUnknown *pUnkControl)
{
	HRESULT hr = E_FAIL;
	IInternetHostSecurityManager *pSecMan = NULL;
	IServiceProvider *pServProv = NULL;
	__try
	{
		if(FAILED(hr = GetSiteServices(pUnkControl, &pServProv)))
			__leave;

		if(FAILED(hr = pServProv->QueryService(SID_SInternetHostSecurityManager, IID_IInternetHostSecurityManager, (void**)&pSecMan)))
			__leave;
	}
	__finally
	{
		if(pServProv)
			pServProv->Release();
		if(pSecMan)
			pSecMan->Release();
	}
	return SUCCEEDED(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vc7\system\wbem\wmiscriptutils\commonfuncsunused.cpp ===
//This was alternative way to get to the internet host security manager (instead of using SID_SInternetHostSecurityManager)
#if 0
			if(FAILED(hr = GetDocument(pUnkControl, &pDoc)))
				__leave;

			if(FAILED(hr = pDoc->QueryInterface(IID_IInternetHostSecurityManager, (void**)&pSecMan)))
				__leave;
#endif









// This function shows how to get to the IHTMLDocument2 that created an
// arbitrary control represented by pUnk
HRESULT GetDocument(IUnknown *pUnk, IHTMLDocument2 **ppDoc)
{
	// If an ActiveX control is created in HTML, this function will return 
	// a pointer to the IHTMLDocument2.  To get to the IHTMLDocument2, controls
	// must implement IObjectWithSite.  If controls also implement IOleObject,
	// the method used to get to the IHTMLDocument2 is slightly different.
	// This function abstracts the difference between controls that implement
	// just IObjectWithSite and controls that implement BOTH IOleObject AND
	// IObjectWithSite.  This function also abstracts the different techniques
	// that need to be used depending on if the control was created through an
	// <OBJECT...> tag or if the control was created through JScript using
	// 'new ActiveXObject' or VBScript using 'CreateObject'
	HRESULT hr = E_FAIL;
	IOleObject *pOleObj = NULL;
	IObjectWithSite *pObjWithSite = NULL;
	IOleClientSite *pSite = NULL;
	IOleContainer *pContainer = NULL;
	IServiceProvider *pServProv = NULL;
	IWebBrowserApp *pWebApp = NULL;
	IDispatch *pDisp = NULL;

	__try
	{
		// Check if the ActiveX control supports IOleObject.
		if(SUCCEEDED(pUnk->QueryInterface(IID_IOleObject, (void**)&pOleObj)))
		{
			// If the control was created through an <OBJECT...> tag, IE will
			// have passed us an IOleClientSite.  If we have not been passed
			// an IOleClientSite, GetClientSite will still SUCCEED, but pSite
			// will be NULL.  In this case, we just go to the next section.
			if(SUCCEEDED(pOleObj->GetClientSite(&pSite)) && pSite)
			{
				// We were passed an IOleClientSite!!! We can call GetContainer
				// and QI for the IHTMLDocument2 that we need
				if(FAILED(hr = pSite->GetContainer(&pContainer)))
					__leave;
				hr = pContainer->QueryInterface(IID_IHTMLDocument2, (void**)ppDoc);

				// At this point, we are done and do not want to process the
				// code in the next seciont
				__leave;
			}
		}

		// At this point, one of two things has happened:
		// 1) We didn't support IOleObject
		// 2) We supported IOleObject, but we were never passed an IOleClientSite

		// In either case, we now need to look at IObjectWithSite to try to get
		// to our site
		if(FAILED(hr = pUnk->QueryInterface(IID_IObjectWithSite, (void**)&pObjWithSite)))
			__leave;

		// In case #1 above, we may have been passed an IOleClientSite to
		// IObjectWithSite::SetSite.  This happens if we were created with
		// an <OBJECT...> tag
		if(SUCCEEDED(pObjWithSite->GetSite(IID_IOleClientSite, (void**)&pSite)))
		{
			// We can now call GetContainer and QI for the IHTMLDocument2
			if(FAILED(hr = pSite->GetContainer(&pContainer)))
				__leave;
			hr = pContainer->QueryInterface(IID_IHTMLDocument2, (void**)ppDoc);
		}
		else
		{
			// If we were not passed an IOleClientSite, it is possible that
			// we were created dynamically (with 'new ActiveXObject' in JScript,
			// or 'CreateObject' in VBScript).  We can use the following steps
			// to get to the IHTMLDocument2 that created the control:
			// 1) QI for IServiceProvider
			// 2) Call QueryService to get an IWebBrowserApp
			// 3) Call get_Document to get the IDispatch of the document
			// 4) QI for the IHTMLDocument2 interface.
			if(FAILED(hr = pObjWithSite->GetSite(IID_IServiceProvider, (void**)&pServProv)))
				__leave;
#if 0
			if(FAILED(hr = pServProv->QueryService(SID_SWebBrowserApp, IID_IWebBrowserApp, (void**)&pWebApp)))
				__leave;
			if(FAILED(hr = pWebApp->get_Document(&pDisp)))
				__leave;
			hr = pDisp->QueryInterface(IID_IHTMLDocument2, (void**)ppDoc);
#endif
//			hr = pServProv->QueryService(SID_SContainerDispatch, IID_IHTMLDocument2, (void**)ppDoc);
			if(FAILED(hr = pServProv->QueryService(SID_SContainerDispatch, IID_IDispatch, (void**)&pDisp)))
				__leave;
			hr = pDisp->QueryInterface(IID_IHTMLDocument2, (void**)ppDoc);
		}
	}
	__finally
	{
		// Release any interfaces we used along the way
		if(pOleObj)
			pOleObj->Release();
		if(pObjWithSite)
			pObjWithSite->Release();
		if(pSite)
			pSite->Release();
		if(pContainer)
			pContainer->Release();
		if(pServProv)
			pServProv->Release();
		if(pWebApp)
			pWebApp->Release();
		if(pDisp)
			pDisp->Release();
	}
	return hr;
}




#if 0
// This function shows how to get to the IHTMLDocument2 that created a control
// in either situation (an <OBJECT...> tag or dynamically created controls in
// script).  It assumes that the control has just implement IObjectWithSite
// and NOT IOleObject.  If IOleObject is implemented, IE will NOT call
// IObjectWithSite::SetSite.
HRESULT GetDocumentFromObjectWithSite(IObjectWithSite *pObject, IHTMLDocument2 **ppDoc)
{
	// If an ActiveX control implements IObjectWithSite, this function will
	// return a pointer to the IHTMLDocument2 that is hosting the control 
	// (assuming that the control was created in an HTML page).
	// NOTE: If the ActiveX control has also implemented IOleObject, this
	// function cannot be used.  In that case, IE calls
	// IOleObject::SetClientSite instead of IObjectWithSite::SetSite to pass
	// the control an IOleClientSite object when the control is created in an
	// <OBJECT...> tag.  If the control is created dynamically in JScript with
	// 'new ActiveXObject' or VBScript with 'CreateObject', then
	// IObjectWithSite::SetSite is called.  If the ActiveXControl does not
	// implement IOleObject (but implements IObjectWithSite), IE will always
	// call IObjectWithSite::SetSite.  However, the object passed to SetSite
	// will still vary depending on if the control was created dynamically or
	// statically in an <OBJECT...> tag.  This function abstracts the
	// difference between the two situations.
	HRESULT hr = S_OK;
	IOleClientSite *pSite = NULL;
	IOleContainer *pContainer = NULL;
	IServiceProvider *pServProv = NULL;
	IWebBrowserApp *pWebApp = NULL;
	IDispatch *pDisp = NULL;

	__try
	{
		if(SUCCEEDED(pObject->GetSite(IID_IOleClientSite, (void**)&pSite)))
		{
			// If the ActiveX control that implemented IObjectWithSite was
			// created on an HTML page using the <OBJECT...> tag, IE will call
			// SetSite with an IID_IOleClientSite.  We can call GetContainer
			// and the QI for the IHTMLDocument2.
			if(FAILED(hr = pSite->GetContainer(&pContainer)))
				__leave;
			hr = pContainer->QueryInterface(IID_IHTMLDocument2, (void**)ppDoc);
		}
		else
		{
			// If the ActiveX control that implement IObjectWithSite was
			// created dynamically (with 'new ActiveXObject' in JScript, or
			// CreateObject in VBScript), we are passed a ??? object.  We can
			// QI for IServiceProvider, and get to an IWebBrowserApp through
			// QueryService.  Then, we can get IDispatch pointer of the 
			// document through get_Document, and finally QI for the
			// IHTMLDocument2 interface.
			if(FAILED(hr = pObject->GetSite(IID_IServiceProvider, (void**)&psp)))
				__leave;
			if(FAILED(hr = psp->QueryService(SID_SWebBrowserApp, IID_IWebBrowserApp, (void**)&pApp)))
				__leave;
			if(FAILED(hr = pApp->get_Document(&pDisp)))
				__leave;
			hr = pDisp->QueryInterface(IID_IHTMLDocument2, (void**)ppDoc);
		}
	}
	__finally
	{
		if(pSite)
			pSite->Release();
		if(pContainer)
			pContainer->Release();
		if(pServProv)
			pServProv->Release();
		if(pWebApp)
			pWebApp->Release();
		if(pDisp)
			pDisp->Release();
	}
	return hr;
}
#endif
#if 0
HRESULT CWMIObjectBroker::GetDocument(IHTMLDocument2 **ppDoc)
{
	HRESULT hr = S_OK;
	IOleClientSite *pSite = NULL;
//	if(SUCCEEDED(GetClientSite(&pSite)) && pSite)
	if(FALSE)
	{
		IOleContainer *pContainer;
		if(SUCCEEDED(hr = pSite->GetContainer(&pContainer)))
		{
			hr = pContainer->QueryInterface(IID_IHTMLDocument2, (void**)ppDoc);
			pContainer->Release();
		}
		pSite->Release();
	}
	else
	{
		IServiceProvider *psp = NULL;
		if(SUCCEEDED(hr = GetSite(IID_IServiceProvider, (void**)&psp)))
		{
			IWebBrowserApp *pApp = NULL;
			if(SUCCEEDED(hr = psp->QueryService(SID_SWebBrowserApp, IID_IWebBrowserApp, (void**)&pApp)))
			{
				IDispatch *pDisp;
				if(SUCCEEDED(hr = pApp->get_Document(&pDisp)))
				{
					hr = pDisp->QueryInterface(IID_IHTMLDocument2, (void**)ppDoc);
					pDisp->Release();
				}
				pApp->Release();
			}
			psp->Release();
		}
	}
	return hr;
}
#endif

#if 0
	IHTMLDocument2 *pDoc2 = NULL;
	GetDocument(&pDoc2);

	IOleClientSite *pSite = NULL;
//	GetClientSite(&pSite);
	if(!pSite)
	{
		HRESULT hr = S_OK;
		hr = GetSite(IID_IOleClientSite, (void**)&pSite);
		hr = GetSite(IID_IServiceProvider, (void**)&pSite);
//		hr = GetSite(IID_IActiveScript, (void**)&pSite);
		hr = GetSite(IID_IOleContainer, (void**)&pSite);
		IServiceProvider *psp = NULL;
		hr = GetSite(IID_IServiceProvider, (void**)&psp);
		IWebBrowserApp *pApp = NULL;
		hr = psp->QueryService(SID_SWebBrowserApp, IID_IWebBrowserApp, (void**)&pApp);
		BSTR bstr;
//		pApp->get_LocationURL(&bstr);
		IHTMLDocument2 *pDoc;
		IDispatch *pDisp;
		pApp->get_Document(&pDisp);
		pDisp->QueryInterface(IID_IHTMLDocument2, (void**)&pDoc);
		pDoc->get_URL(&bstr);
		bstr = NULL;
	}
	IOleContainer *pContainer;
	pSite->GetContainer(&pContainer);
	pSite->Release();
	IHTMLDocument2 *pDoc;
	pContainer->QueryInterface(IID_IHTMLDocument2, (void**)&pDoc);
	BSTR bstrURL = NULL;
	pDoc->get_URL(&bstrURL);
	SysFreeString(bstrURL);
	IHTMLDocument2 *pDocParent = NULL;
	IHTMLWindow2 *pWndParent = NULL;
	pDoc->get_parentWindow(&pWndParent);
	pWndParent->get_document(&pDocParent);
	pDocParent->get_URL(&bstrURL);
	SysFreeString(bstrURL);

	pDocParent->Release();
	IHTMLWindow2 *pWnd2 = NULL;
	pWndParent->get_top(&pWnd2);
	pWnd2->get_document(&pDocParent);
	pDocParent->get_URL(&bstrURL);
	SysFreeString(bstrURL);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vc7\vcwiz\classwiz\atl\event\templates\1031\wmiprov.cpp ===
// [!output IMPL_FILE] : Implementierung von [!output CLASS_NAME]
#include "stdafx.h"
#include "[!output PROJECT_NAME].h"
#include "[!output HEADER_FILE]"


/////////////////////////////////////////////////////////////////////////////
// [!output CLASS_NAME]

// Wichtig: Die folgenden Strings sollten nicht lokalisiert werden.

// Klassenname
[!if CLASS_SPECIFIED]
const static WCHAR * s_pMyClassName = L"[!output WMICLASSNAME]"; 
[!if EXTRINSIC]
//Eigenschaften der Ereignisklasse [!output WMICLASSNAME]:
[!output EXTR_PROPERTY_DEFINITIONS]
[!endif]
[!else]
//Aktion: Definieren Sie den angegebenen Klassenname, z.B.:
const static WCHAR * s_pMyClassName = L"MyClassName"; 
[!endif]


//////////////////////////////////////////////////////////////////////////////
// [!output CLASS_NAME]::Initialize()
// In der MSDN-Dokumentation fr IWbemProviderInit::Initialize()
// finden Sie weitere Einzelheiten ber die Implementierung dieser Methode.

STDMETHODIMP [!output CLASS_NAME]::Initialize(LPWSTR pszUser,	
									  LONG lFlags,
									  LPWSTR pszNamespace,
									  LPWSTR pszLocale,
									  IWbemServices *pNamespace,
									  IWbemContext *pCtx,
																																							IWbemProviderInitSink *pInitSink) 
{
	
	HRESULT hr = WBEM_E_FAILED;
	if ( NULL == pNamespace || NULL == pInitSink) 
	{
        return WBEM_E_INVALID_PARAMETER;
	}

	//IWbemServices-Zeiger zwischenspeichern 
	//Hinweis: m_pNamespace ist ein dynamischer Zeiger: AddRef() funktioniert automatisch
	m_pNamespace = pNamespace;
					
	[!if INTRINSIC]	
	//Hilfsobjekt abrufen
	m_pHelper = new CIntrinsicEventProviderHelper(pNamespace, pCtx);

	[!endif]
	
	[!if EXTRINSIC]	
	//Ereignisklassendefinition speichern				 
	//Hinweis: Der folgende Code geht davon aus, dass die Ereignisklassendefinition 
	//whrend der Anbieterausfhrung unverndert bleibt. Andernfalls mssen Sie einen 
	//Benutzer fr Klassennderungen und Klassenlschereignisse implementieren. Weitere
	//Informationen ber Ereignisbenutzer finden Sie auf MSDN in der WMI-Dokumentenation.
	hr = m_pNamespace->GetObject(CComBSTR(s_pMyClassName), 
								0, 
								pCtx, //IWbemContext-Zeiger umgehen, um Sperrungen zu verhindern
								&m_pEventClass, 
								NULL);

    if(FAILED(hr))
	{
        return hr;
	}

	//Hilfsobjekt abrufen
	m_pHelper = new CProviderHelper(pNamespace, pCtx);

    [!endif]
	[!if INTRINSIC]
	//Zielklassendefinition speichern
	hr = m_pNamespace->GetObject(CComBSTR(s_pMyClassName), 
								 0, 
								 pCtx, //IWbemContext-Zeiger umgehen, um Sperrungen zu verhindern
								 &m_pDataClass, 
								 NULL);
    if(FAILED(hr))
	{
        return hr;
	}
	[!endif]
	    
    pInitSink->SetStatus(WBEM_S_INITIALIZED,0);
    return WBEM_S_NO_ERROR;
}


//////////////////////////////////////////////////////////////////////////////
// [!output CLASS_NAME]::ProvideEvents()
// In der MSDN-Dokumentation fr IWbemEventProvider::ProvideEvents()
// finden Sie weitere Einzelheiten ber die Implementierung dieser Methode.
	
STDMETHODIMP [!output CLASS_NAME]::ProvideEvents(
							IWbemObjectSink *pSink,
							long lFlags)
{
	//	WMI ruft diese Mehode auf, um den Ereigniszeiger zu aktivieren. 
	//  Aktion: Nach der Aufrufzurckgabe, geben Sie die Ereignisse, wenn Sie in 
	//          der Datensenkenschnittstelle erscheinen, an. Sie knnen einen  
	//	    unabhngigen Thread fr die Ereigniszustellungverarbeitung erstellen.
	[!if INTRINSIC]
	//  Rufen Sie FireCreationEvent()-, FireDeletionEvent()- und FireModificationEvent()-
	//  Methoden auf m_pHelper auf, um innere Ereignisse zu bermitteln.  
	[!endif]
	//  Rufen Sie ConstructErrorObject() auf m_pHelper auf, um einen Fehler oder Status an WMI zu melden. 
	
	//  Wichtig: Diesen Aufruf nicht lnger als ein paar Sekunden blockieren.

	if ( NULL == pSink )
	{
		return WBEM_E_INVALID_PARAMETER;
	}

	//Datensenkezeiger zwischenspeichern
	//Hinweis: m_pSink ist ein dynamischer Zeiger: AddRef() funktioniert automatisch
	m_pSink = pSink;
	
	pSink->SetStatus(0, WBEM_S_NO_ERROR, NULL, NULL);	
	return WBEM_S_NO_ERROR;
}

[!if EVENT_SECURITY ]

//////////////////////////////////////////////////////////////////////////////
// [!output CLASS_NAME]::AccessCheck()
// In der MSDN-Dokumentation fr IWbemEventProviderSecurity::AccessCheck()
// finden Sie weitere Einzelheiten ber die Implementierung dieser Methode.

STDMETHODIMP [!output CLASS_NAME]::AccessCheck(
						WBEM_CWSTR wszQueryLanguage,
						WBEM_CWSTR wszQuery,
						long lSidLength,
						const BYTE* pSid)
{
	return WBEM_S_NO_ERROR;
}
[!endif]

[!if QUERY_SINK ]

//////////////////////////////////////////////////////////////////////////////
// [!output CLASS_NAME]::CancelQuery()
// In der MSDN-Dokumentation fr IWbemEventProviderQuerySink::CancelQuery()
// finden Sie weitere Einzelheiten ber die Implementierung dieser Methode.

STDMETHODIMP [!output CLASS_NAME]::CancelQuery(
						unsigned long dwId)
{
	return WBEM_S_NO_ERROR;
}


//////////////////////////////////////////////////////////////////////////////
// [!output CLASS_NAME]::NewQuery()
// In der MSDN-Dokumentation fr IWbemEventProviderQuerySink::NewQuery()
// finden Sie weitere Einzelheiten ber die Implementierung dieser Methode.

STDMETHODIMP [!output CLASS_NAME]::NewQuery(
						unsigned long dwId,
						WBEM_WSTR wszQueryLanguage,
						WBEM_WSTR wszQuery)
{
	return WBEM_S_NO_ERROR;
}
[!endif]

[!if EXTRINSIC]	
//////////////////////////////////////////////////////////////////////////////
// [!output CLASS_NAME]::FireEvent()

STDMETHODIMP [!output CLASS_NAME]::FireEvent()
{
	//OPTIMIERUNGSHINWEIS: Die vom Assistenten erstellte Implementierung ist sehr simpel, 
	//aber falls Sie mehr als 1000 Ereignisse pro Sekunde zustellen, sollten Sie die
	//IWbemObjectAccess-Schnittstelle verwenden, um die Ereigniseigenschaften aufzufllen.
	//Auerdem sollten Sie eine Instanz der Ereignisklasse zwischenspeichern und mehrmals verwenden.

	ATLASSERT(m_pEventClass);

	CComPtr<IWbemClassObject> pEvtInstance;
    HRESULT hr = m_pEventClass->SpawnInstance(0, &pEvtInstance);
    if(FAILED(hr))
	{
		return hr;
	}

	//Eigenschaftenwerte des Ereignisobjekts auffllen:
	[!if CLASS_SPECIFIED]
    [!output EXTRINSIC_PUT_BLOCK]
	[!else]
	//AKTION: ndern Sie den folgenden kommentierten Code, um die Eigenschaftenwerte des Ereignisobjekts aufzufllen.
	//CComVariant var;
	//var.ChangeType(<type>);	//Passenden Variantentyp hier setzen
	//var = <value>;			//Passenden Wert hier setzen
	//hr = pEvtInstance->Put(CComBSTR(L"EventProperty1"), 0, &var, 0);
	//var.Clear();
	[!endif]

	hr = m_pSink->Indicate(1, &(pEvtInstance.p) );

	return hr;
}
[!endif]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vc7\vcwiz\classwiz\atl\event\templates\1041\wmiprov.cpp ===
// [!output IMPL_FILE] : [!output CLASS_NAME] ̎
#include "stdafx.h"
#include "[!output PROJECT_NAME].h"
#include "[!output HEADER_FILE]"


/////////////////////////////////////////////////////////////////////////////
// [!output CLASS_NAME]

// dv: ȉɒ`Ă镶̓[JCYł܂B

// NX
[!if CLASS_SPECIFIED]
const static WCHAR * s_pMyClassName = L"[!output WMICLASSNAME]"; 
[!if EXTRINSIC]
//Cxg NX [!output WMICLASSNAME] ̃vpeB:
[!output EXTR_PROPERTY_DEFINITIONS]
[!endif]
[!else]
//TODO: 񋟂ꂽNX`ĂB:
const static WCHAR * s_pMyClassName = L"MyClassName"; 
[!endif]


//////////////////////////////////////////////////////////////////////////////
// [!output CLASS_NAME]::Initialize()
// ̃\bh̎ɂĂ̏ڍׂ́AIWbemProviderInit::Initialize()
//  MSDN hLgQƂĂB

STDMETHODIMP [!output CLASS_NAME]::Initialize(LPWSTR pszUser,	
									  LONG lFlags,
									  LPWSTR pszNamespace,
									  LPWSTR pszLocale,
									  IWbemServices *pNamespace,
									  IWbemContext *pCtx,
																																							IWbemProviderInitSink *pInitSink) 
{
	
	HRESULT hr = WBEM_E_FAILED;
	if ( NULL == pNamespace || NULL == pInitSink) 
	{
        return WBEM_E_INVALID_PARAMETER;
	}

	//IWbemServices |C^LbV܂B
	//: m_pNamespace ́AX}[g |C^łBI AddRef() ܂B
	m_pNamespace = pNamespace;
					
	[!if INTRINSIC]	
	//helper IuWFNg擾܂B
	m_pHelper = new CIntrinsicEventProviderHelper(pNamespace, pCtx);

	[!endif]
	
	[!if EXTRINSIC]	
	//Cxg NX̒`ۑ܂B				
	//: ȉ̃R[h́AvoC_̎s̓Cxg NX̒`A
	//ύXȂƉ肵Ă܂BύXꍇ́ANX̏CCxgƍ폜Cxgp
	//RV[}Kv܂BCxg RV[}ɂẮA
	//MSDN  WMI hLgQƂĂB
	hr = m_pNamespace->GetObject(CComBSTR(s_pMyClassName), 
								0, 
								pCtx, //fbhbNȂ悤 IWbemContext |C^n܂B
								&m_pEventClass, 
								NULL);

    if(FAILED(hr))
	{
        return hr;
	}

	//helper IuWFNg擾܂B
	m_pHelper = new CProviderHelper(pNamespace, pCtx);

    [!endif]
	[!if INTRINSIC]
	//^[Qbg̃NX̒`ۑ܂B
	hr = m_pNamespace->GetObject(CComBSTR(s_pMyClassName), 
								 0, 
								 pCtx, //fbhbNȂ悤 IWbemContext |C^n܂B
								 &m_pDataClass, 
								 NULL);
    if(FAILED(hr))
	{
        return hr;
	}
	[!endif]
	    
    pInitSink->SetStatus(WBEM_S_INITIALIZED,0);
    return WBEM_S_NO_ERROR;
}


//////////////////////////////////////////////////////////////////////////////
// [!output CLASS_NAME]::ProvideEvents()
// ̃\bh̎ɂĂ̏ڍׂ́AIWbemEventProvider::ProvideEvents()
//  MSDN hLgQƂĂB
	
STDMETHODIMP [!output CLASS_NAME]::ProvideEvents(
							IWbemObjectSink *pSink,
							long lFlags)
{
	//  WMI ̓Cxg voC_ANeBuɂ邽߂ɂ̃\bhĂяo܂B
	//  TODO: ̌ĂяoԂA^ꂽVN C^[tFCX̂
	//  Cxg̔zMJnĂBCxg̔zz邽߂ɁA
	//  ƗXbh쐬邱Ƃł܂B
	[!if INTRINSIC]
	//  gݍ݃Cxgzz邽߂ɁAm_pHelper  FireCreationEvent()AFireDeletionEvent()A
	//  FireModificationEvent() \bhĂяo܂B 
	[!endif]
	//  WMI ɏڂG[܂͏Ԃ񍐂邽߂ɁAm_pHelper  ConstructErrorObject() ĂяoƂł܂B
	
	//  dv: ̌Ăяo𐔕bȏubNȂłB

	if ( NULL == pSink )
	{
		return WBEM_E_INVALID_PARAMETER;
	}

	//LbV VN |C^
	//: m_pSink ̓X}[g|C^ŁAI AddRef() ܂B
	m_pSink = pSink;
	
	pSink->SetStatus(0, WBEM_S_NO_ERROR, NULL, NULL);	
	return WBEM_S_NO_ERROR;
}

[!if EVENT_SECURITY ]

//////////////////////////////////////////////////////////////////////////////
// [!output CLASS_NAME]::AccessCheck()
// ̃\bh̎ɂĂ̏ڍׂ́AIWbemEventProviderSecurity::AccessCheck()
//  MSDN hLgQƂĂB 

STDMETHODIMP [!output CLASS_NAME]::AccessCheck(
						WBEM_CWSTR wszQueryLanguage,
						WBEM_CWSTR wszQuery,
						long lSidLength,
						const BYTE* pSid)
{
	return WBEM_S_NO_ERROR;
}
[!endif]

[!if QUERY_SINK ]

//////////////////////////////////////////////////////////////////////////////
// [!output CLASS_NAME]::CancelQuery()
// ̃\bh̎ɂĂ̏ڍׂ́AIWbemEventProviderQuerySink::CancelQuery()
//  MSDN hLgQƂĂB

STDMETHODIMP [!output CLASS_NAME]::CancelQuery(
						unsigned long dwId)
{
	return WBEM_S_NO_ERROR;
}


//////////////////////////////////////////////////////////////////////////////
// [!output CLASS_NAME]::NewQuery()
// ̃\bh̎ɂĂ̏ڍׂ́AIWbemEventProviderQuerySink::NewQuery() 
//  MSDN hLgQƂĂB

STDMETHODIMP [!output CLASS_NAME]::NewQuery(
						unsigned long dwId,
						WBEM_WSTR wszQueryLanguage,
						WBEM_WSTR wszQuery)
{
	return WBEM_S_NO_ERROR;
}
[!endif]

[!if EXTRINSIC]	
//////////////////////////////////////////////////////////////////////////////
// [!output CLASS_NAME]::FireEvent()

STDMETHODIMP [!output CLASS_NAME]::FireEvent()
{
	//œK̒: ECU[hɂĐCvg͊ȒPłA
	//b 1000 ȏ̃CxgzMꍇ́ACxg voeB
	//͂邽߂ IWbemObjectAccess C^[tFCXgƂł܂B 
	//܂ACxg NX̃CX^XLbVčėp邱Ƃł܂B

	ATLASSERT(m_pEventClass);

	CComPtr<IWbemClassObject> pEvtInstance;
    HRESULT hr = m_pEventClass->SpawnInstance(0, &pEvtInstance);
    if(FAILED(hr))
	{
		return hr;
	}

	//Cxg IuWFNg̃vpeB̒l𐳂͂ĂB:
	[!if CLASS_SPECIFIED]
    [!output EXTRINSIC_PUT_BLOCK]
	[!else]
	//TODO: Cxg̃IuWFNg̃vpeB̒l͂邽߂Ɏ̃R}h R[hCĂB
	//CComVariant var;
	//var.ChangeType(<type>);	//ɓK؂ȃoAg ^Cv͂ĂB
	//var = <value>;			//ɓK؂Ȓl͂ĂB
	//hr = pEvtInstance->Put(CComBSTR(L"EventProperty1"), 0, &var, 0);
	//var.Clear();
	[!endif]

	hr = m_pSink->Indicate(1, &(pEvtInstance.p) );

	return hr;
}
[!endif]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vc7\vcwiz\classwiz\atl\event\templates\1033\wmiprov.cpp ===
// [!output IMPL_FILE] : Implementation of [!output CLASS_NAME]
#include "stdafx.h"
#include "[!output PROJECT_NAME].h"
#include "[!output HEADER_FILE]"


/////////////////////////////////////////////////////////////////////////////
// [!output CLASS_NAME]

// IMPORTANT: the strings defined below are not localizable

// Class name
[!if CLASS_SPECIFIED]
const static WCHAR * s_pMyClassName = L"[!output WMICLASSNAME]"; 
[!if EXTRINSIC]
//properties of the event class [!output WMICLASSNAME]:
[!output EXTR_PROPERTY_DEFINITIONS]
[!endif]
[!else]
//TODO: define provided class name, e.g.:
const static WCHAR * s_pMyClassName = L"MyClassName"; 
[!endif]


//////////////////////////////////////////////////////////////////////////////
// [!output CLASS_NAME]::Initialize()
// Refer to MSDN documentation for IWbemProviderInit::Initialize()
// for details about implementing this method

STDMETHODIMP [!output CLASS_NAME]::Initialize(LPWSTR pszUser,	
									  LONG lFlags,
									  LPWSTR pszNamespace,
									  LPWSTR pszLocale,
									  IWbemServices *pNamespace,
									  IWbemContext *pCtx,
																																							IWbemProviderInitSink *pInitSink) 
{
	
	HRESULT hr = WBEM_E_FAILED;
	if ( NULL == pNamespace || NULL == pInitSink) 
	{
        return WBEM_E_INVALID_PARAMETER;
	}

	//cache IWbemServices pointer 
	//Note: m_pNamespace is a smart pointer, so it AddRef()'s automatically
	m_pNamespace = pNamespace;
					
	[!if INTRINSIC]	
	//get helper object
	m_pHelper = new CIntrinsicEventProviderHelper(pNamespace, pCtx);

	[!endif]
	
	[!if EXTRINSIC]	
	//store event class definition				
	//NOTE: the code below assumes that your event class definition doesn't change while
	//your provider is running.  If this is not true, you should implement a consumer
	//for class modification ans class deletion events. Refer to WMI documentation
	//for event consumers on MSDN.
	hr = m_pNamespace->GetObject(CComBSTR(s_pMyClassName), 
								0, 
								pCtx, //passing IWbemContext pointer to prevent deadlocks
								&m_pEventClass, 
								NULL);

    if(FAILED(hr))
	{
        return hr;
	}

	//get helper object
	m_pHelper = new CProviderHelper(pNamespace, pCtx);

    [!endif]
	[!if INTRINSIC]
	//store target class definition
	hr = m_pNamespace->GetObject(CComBSTR(s_pMyClassName), 
								 0, 
								 pCtx, //passing IWbemContext pointer to prevent deadlocks
								 &m_pDataClass, 
								 NULL);
    if(FAILED(hr))
	{
        return hr;
	}
	[!endif]
	    
    pInitSink->SetStatus(WBEM_S_INITIALIZED,0);
    return WBEM_S_NO_ERROR;
}


//////////////////////////////////////////////////////////////////////////////
// [!output CLASS_NAME]::ProvideEvents()
// Refer to MSDN documentation for  IWbemEventProvider::ProvideEvents()
// for details about implementing this method
	
STDMETHODIMP [!output CLASS_NAME]::ProvideEvents(
							IWbemObjectSink *pSink,
							long lFlags)
{
	//	WMI calls this method to activate the event provider. 
	//  TODO: after you return from this call, start delivering the events as 
	//  they occur to the provided sink interface.You may want to create an independent thread
	//	to handle the event delivery.
	[!if INTRINSIC]
	//  To deliver intrinsic events, invoke FireCreationEvent(), FireDeletionEvent() and
	//  FireModificationEvent() methods on m_pHelper.  
	[!endif]
	//  To report a detailed error or status to WMI, you can call ConstructErrorObject() on m_pHelper. 
	
	//  IMPORTANT: do not block this call for more than a few seconds.

	if ( NULL == pSink )
	{
		return WBEM_E_INVALID_PARAMETER;
	}

	//cache sink pointer
	//Note: m_pSink is a smart pointer, so it AddRef()'s automatically
	m_pSink = pSink;
	
	pSink->SetStatus(0, WBEM_S_NO_ERROR, NULL, NULL);	
	return WBEM_S_NO_ERROR;
}

[!if EVENT_SECURITY ]

//////////////////////////////////////////////////////////////////////////////
// [!output CLASS_NAME]::AccessCheck()
// Refer to MSDN documentation for  IWbemEventProviderSecurity::AccessCheck()
// for details about implementing this method

STDMETHODIMP [!output CLASS_NAME]::AccessCheck(
						WBEM_CWSTR wszQueryLanguage,
						WBEM_CWSTR wszQuery,
						long lSidLength,
						const BYTE* pSid)
{
	return WBEM_S_NO_ERROR;
}
[!endif]

[!if QUERY_SINK ]

//////////////////////////////////////////////////////////////////////////////
// [!output CLASS_NAME]::CancelQuery()
// Refer to MSDN documentation for  IWbemEventProviderQuerySink::CancelQuery()
// for details about implementing this method

STDMETHODIMP [!output CLASS_NAME]::CancelQuery(
						unsigned long dwId)
{
	return WBEM_S_NO_ERROR;
}


//////////////////////////////////////////////////////////////////////////////
// [!output CLASS_NAME]::NewQuery()
// Refer to MSDN documentation for  IWbemEventProviderQuerySink::NewQuery()
// for details about implementing this method

STDMETHODIMP [!output CLASS_NAME]::NewQuery(
						unsigned long dwId,
						WBEM_WSTR wszQueryLanguage,
						WBEM_WSTR wszQuery)
{
	return WBEM_S_NO_ERROR;
}
[!endif]

[!if EXTRINSIC]	
//////////////////////////////////////////////////////////////////////////////
// [!output CLASS_NAME]::FireEvent()

STDMETHODIMP [!output CLASS_NAME]::FireEvent()
{
	//OPTIMIZATION NOTE: the implementation generated by the wizard is straightforward, 
	//but if you are delivering more than 1000 events per second, you would want to use 
	//IWbemObjectAccess interface to fill the event properties. You also want to 
	//consider caching an instance of the event class and re-using it.

	ATLASSERT(m_pEventClass);

	CComPtr<IWbemClassObject> pEvtInstance;
    HRESULT hr = m_pEventClass->SpawnInstance(0, &pEvtInstance);
    if(FAILED(hr))
	{
		return hr;
	}

	//Fill property values of the event object:
	[!if CLASS_SPECIFIED]
    [!output EXTRINSIC_PUT_BLOCK]
	[!else]
	//TODO: modify commented code below to fill the event property values
	//CComVariant var;
	//var.ChangeType(<type>);	//put appropriate vatiant type here
	//var = <value>;			//put appropriate value here
	//hr = pEvtInstance->Put(CComBSTR(L"EventProperty1"), 0, &var, 0);
	//var.Clear();
	[!endif]

	hr = m_pSink->Indicate(1, &(pEvtInstance.p) );

	return hr;
}
[!endif]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vc7\vcwiz\classwiz\atl\event\templates\1031\wmiprov.h ===
[!if !EVENT]
//Fehler: Ereignisanbieter-Headervorlage wurde fr den falschen Anbietertyp aufgerufen.
[!else]
// [!output HEADER_FILE] : Deklaration von [!output CLASS_NAME]

#pragma once
#include "resource.h"       // Hauptsymbole
#include <wbemidl.h>
#include <wmiatlprov.h>


extern const WCHAR * s_pMyClassName;	//Klassenname

[!if EXTRINSIC]
[!output EXTR_PROPERTY_DECLARATIONS]
[!endif]

/////////////////////////////////////////////////////////////////////////////
// [!output CLASS_NAME]

[!if ATTRIBUTED]
[
	coclass,
[!if THREADING_BOTH]
	threading("both"),
[!endif]
[!if THREADING_FREE]
	threading("free"),
[!endif]
	aggregatable("never"),
	vi_progid("[!output VERSION_INDEPENDENT_PROGID]"),
	progid("[!output PROGID]"),
	version(1.0),
	uuid("[!output CLSID_REGISTRY_FORMAT]"),
	helpstring("[!output TYPE_NAME]")
]
[!endif]

class ATL_NO_VTABLE [!output CLASS_NAME] : 
						[!if !ATTRIBUTED]
						[!if THREADING_BOTH]
							public CComObjectRootEx<CComMultiThreadModel>,
						[!endif]
						[!if THREADING_FREE]
							public CComObjectRootEx<CComMultiThreadModel>,
						[!endif]
						public CComCoClass<[!output CLASS_NAME], &CLSID_[!output COCLASS]>,
						[!endif]
						[!if EVENT_SECURITY]
							public IWbemEventProviderSecurity,
						[!endif]
						[!if QUERY_SINK]
							public IWbemEventProviderQuerySink,
						[!endif]
							public IWbemProviderInit,
							public IWbemEventProvider
{
	CComPtr<IWbemServices>  m_pNamespace;	//Zwischengespeicherter IWbemServices-Zeiger
	CComPtr<IWbemObjectSink> m_pSink;	//ZwischengespeicherterDatensenkenereigniszeiger

	[!if INTRINSIC]	
	CComPtr<IWbemClassObject> m_pDataClass;	//Zwischengespeicherte Definition der Klasse, fr die die Ereignisse ausgelst werden

	CIntrinsicEventProviderHelper * m_pHelper;	//Zeiger fr Hilfsklassenobjekt
	[!else]
    CComPtr<IWbemClassObject> m_pEventClass;	//Zwischengespeicherter Zeiger der Ereignisklassendefinition
	
	CProviderHelper * m_pHelper;
  
	STDMETHODIMP FireEvent();
	[!endif]	

public:
    [!output CLASS_NAME]()
	{
		m_pHelper = NULL;		
	}
	
	~[!output CLASS_NAME]()
	{
	    if (NULL != m_pHelper)
		{
			delete m_pHelper;
		}
		//Hinweis: Schnittstellenzeiger-Datenmitglieder sind dynamisch und werden automatisch freigegeben
	}

	[!if !ATTRIBUTED]
	DECLARE_REGISTRY_RESOURCEID(IDR_[!output UPPER_SHORT_NAME])

	DECLARE_NOT_AGGREGATABLE([!output CLASS_NAME])

	BEGIN_COM_MAP([!output CLASS_NAME])
		COM_INTERFACE_ENTRY(IWbemEventProvider)
		[!if EVENT_SECURITY ]
		COM_INTERFACE_ENTRY(IWbemEventProviderSecurity)
		[!endif]
		[!if QUERY_SINK ]
		COM_INTERFACE_ENTRY(IWbemEventProviderQuerySink)
		[!endif]	
		COM_INTERFACE_ENTRY(IWbemProviderInit)
	END_COM_MAP()
	[!endif]


	//IWbemProviderInit
	HRESULT STDMETHODCALLTYPE Initialize( LPWSTR pszUser,
						  LONG lFlags,
						  LPWSTR pszNamespace,
						  LPWSTR pszLocale,
						  IWbemServices *pNamespace,
						  IWbemContext *pCtx,
						  IWbemProviderInitSink *pInitSink);

	//IWbemEventProvider
	HRESULT STDMETHODCALLTYPE ProvideEvents(
							IWbemObjectSink *pSink,
							long lFlags);


	[!if EVENT_SECURITY ]
	//IWbemEventProviderSecurity
	HRESULT STDMETHODCALLTYPE AccessCheck(
							WBEM_CWSTR wszQueryLanguage,
							WBEM_CWSTR wszQuery,
							long lSidLength,
							const BYTE* pSid
	);
	[!endif]

	[!if QUERY_SINK ]
	//IWbemEventProviderQuerySink
	HRESULT STDMETHODCALLTYPE CancelQuery(
	  unsigned long dwId
	);

	HRESULT STDMETHODCALLTYPE NewQuery(
	  unsigned long dwId,
	  WBEM_WSTR wszQueryLanguage,
	  WBEM_WSTR wszQuery
	);
	[!endif]

};

[!if !ATTRIBUTED]
OBJECT_ENTRY_AUTO(__uuidof([!output COCLASS]), [!output CLASS_NAME])
[!endif]

[!endif]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vc7\vcwiz\classwiz\atl\event\templates\1033\wmiprov.h ===
[!if !EVENT]
//error: event provider header template invoked for wrong type of provider
[!else]
// [!output HEADER_FILE] : Declaration of the [!output CLASS_NAME]

#pragma once
#include "resource.h"       // main symbols
#include <wbemidl.h>
#include <wmiatlprov.h>


extern const WCHAR * s_pMyClassName;	//class name

[!if EXTRINSIC]
[!output EXTR_PROPERTY_DECLARATIONS]
[!endif]

/////////////////////////////////////////////////////////////////////////////
// [!output CLASS_NAME]

[!if ATTRIBUTED]
[
	coclass,
[!if THREADING_BOTH]
	threading("both"),
[!endif]
[!if THREADING_FREE]
	threading("free"),
[!endif]
	aggregatable("never"),
	vi_progid("[!output VERSION_INDEPENDENT_PROGID]"),
	progid("[!output PROGID]"),
	version(1.0),
	uuid("[!output CLSID_REGISTRY_FORMAT]"),
	helpstring("[!output TYPE_NAME]")
]
[!endif]

class ATL_NO_VTABLE [!output CLASS_NAME] : 
						[!if !ATTRIBUTED]
						[!if THREADING_BOTH]
							public CComObjectRootEx<CComMultiThreadModel>,
						[!endif]
						[!if THREADING_FREE]
							public CComObjectRootEx<CComMultiThreadModel>,
						[!endif]
						public CComCoClass<[!output CLASS_NAME], &CLSID_[!output COCLASS]>,
						[!endif]
						[!if EVENT_SECURITY]
							public IWbemEventProviderSecurity,
						[!endif]
						[!if QUERY_SINK]
							public IWbemEventProviderQuerySink,
						[!endif]
							public IWbemProviderInit,
							public IWbemEventProvider
{
	CComPtr<IWbemServices>  m_pNamespace;	//cached IWbemServices pointer
	CComPtr<IWbemObjectSink> m_pSink;			//cached event sink pointer

	[!if INTRINSIC]	
	CComPtr<IWbemClassObject> m_pDataClass;		//cached definition of the class for which events are fired

	CIntrinsicEventProviderHelper * m_pHelper;	//pointer to helper class object
	[!else]
    CComPtr<IWbemClassObject> m_pEventClass;	//cached event class definition pointer
	
	CProviderHelper * m_pHelper;
  
	STDMETHODIMP FireEvent();
	[!endif]	

public:
    [!output CLASS_NAME]()
	{
		m_pHelper = NULL;		
	}
	
	~[!output CLASS_NAME]()
	{
	    if (NULL != m_pHelper)
		{
			delete m_pHelper;
		}
		//NOTE: interface pointer data members are smart and get released automatically
	}

	[!if !ATTRIBUTED]
	DECLARE_REGISTRY_RESOURCEID(IDR_[!output UPPER_SHORT_NAME])

	DECLARE_NOT_AGGREGATABLE([!output CLASS_NAME])

	BEGIN_COM_MAP([!output CLASS_NAME])
		COM_INTERFACE_ENTRY(IWbemEventProvider)
		[!if EVENT_SECURITY ]
		COM_INTERFACE_ENTRY(IWbemEventProviderSecurity)
		[!endif]
		[!if QUERY_SINK ]
		COM_INTERFACE_ENTRY(IWbemEventProviderQuerySink)
		[!endif]	
		COM_INTERFACE_ENTRY(IWbemProviderInit)
	END_COM_MAP()
	[!endif]


	//IWbemProviderInit
	HRESULT STDMETHODCALLTYPE Initialize( LPWSTR pszUser,
						  LONG lFlags,
						  LPWSTR pszNamespace,
						  LPWSTR pszLocale,
						  IWbemServices *pNamespace,
						  IWbemContext *pCtx,
						  IWbemProviderInitSink *pInitSink);

	//IWbemEventProvider
	HRESULT STDMETHODCALLTYPE ProvideEvents(
							IWbemObjectSink *pSink,
							long lFlags);


	[!if EVENT_SECURITY ]
	//IWbemEventProviderSecurity
	HRESULT STDMETHODCALLTYPE AccessCheck(
							WBEM_CWSTR wszQueryLanguage,
							WBEM_CWSTR wszQuery,
							long lSidLength,
							const BYTE* pSid
	);
	[!endif]

	[!if QUERY_SINK ]
	//IWbemEventProviderQuerySink
	HRESULT STDMETHODCALLTYPE CancelQuery(
	  unsigned long dwId
	);

	HRESULT STDMETHODCALLTYPE NewQuery(
	  unsigned long dwId,
	  WBEM_WSTR wszQueryLanguage,
	  WBEM_WSTR wszQuery
	);
	[!endif]

};

[!if !ATTRIBUTED]
OBJECT_ENTRY_AUTO(__uuidof([!output COCLASS]), [!output CLASS_NAME])
[!endif]

[!endif]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vc7\vcwiz\classwiz\atl\event\templates\1041\wmiprov.h ===
[!if !EVENT]
//G[: Cxg voC_ wb_[ ev[g͊Ԉނ̃voC_Ăяo܂B
[!else]
// [!output HEADER_FILE] :  [!output CLASS_NAME] ̐錾B

#pragma once
#include "resource.h"       // C V|łB
#include <wbemidl.h>
#include <wmiatlprov.h>


extern const WCHAR * s_pMyClassName;	//NXłB

[!if EXTRINSIC]
[!output EXTR_PROPERTY_DECLARATIONS]
[!endif]

/////////////////////////////////////////////////////////////////////////////
// [!output CLASS_NAME]

[!if ATTRIBUTED]
[
	coclass,
[!if THREADING_BOTH]
	threading("both"),
[!endif]
[!if THREADING_FREE]
	threading("free"),
[!endif]
	aggregatable("never"),
	vi_progid("[!output VERSION_INDEPENDENT_PROGID]"),
	progid("[!output PROGID]"),
	version(1.0),
	uuid("[!output CLSID_REGISTRY_FORMAT]"),
	helpstring("[!output TYPE_NAME]")
]
[!endif]

class ATL_NO_VTABLE [!output CLASS_NAME] : 
						[!if !ATTRIBUTED]
						[!if THREADING_BOTH]
							public CComObjectRootEx<CComMultiThreadModel>,
						[!endif]
						[!if THREADING_FREE]
							public CComObjectRootEx<CComMultiThreadModel>,
						[!endif]
						public CComCoClass<[!output CLASS_NAME], &CLSID_[!output COCLASS]>,
						[!endif]
						[!if EVENT_SECURITY]
							public IWbemEventProviderSecurity,
						[!endif]
						[!if QUERY_SINK]
							public IWbemEventProviderQuerySink,
						[!endif]
							public IWbemProviderInit,
							public IWbemEventProvider
{
	CComPtr<IWbemServices>  m_pNamespace;	//LbVꂽ IWbemServices |C^łB
	CComPtr<IWbemObjectSink> m_pSink;			//LbVꂽCxg VN |C^łB

	[!if INTRINSIC]	
	CComPtr<IWbemClassObject> m_pDataClass;		//CxgJn邽߂̃LbVꂽNX̒`łB

	CIntrinsicEventProviderHelper * m_pHelper;	//helper NX IuWFNgւ̃|C^łB
	[!else]
    CComPtr<IWbemClassObject> m_pEventClass;	//LbVꂽCxg NX`|C^łB
	
	CProviderHelper * m_pHelper;
  
	STDMETHODIMP FireEvent();
	[!endif]	

public:
    [!output CLASS_NAME]()
	{
		m_pHelper = NULL;		
	}
	
	~[!output CLASS_NAME]()
	{
	    if (NULL != m_pHelper)
		{
			delete m_pHelper;
		}
		//: C^[tFCX |C^ f[^ o̓X}[gŎIɉ܂B
	}

	[!if !ATTRIBUTED]
	DECLARE_REGISTRY_RESOURCEID(IDR_[!output UPPER_SHORT_NAME])

	DECLARE_NOT_AGGREGATABLE([!output CLASS_NAME])

	BEGIN_COM_MAP([!output CLASS_NAME])
		COM_INTERFACE_ENTRY(IWbemEventProvider)
		[!if EVENT_SECURITY ]
		COM_INTERFACE_ENTRY(IWbemEventProviderSecurity)
		[!endif]
		[!if QUERY_SINK ]
		COM_INTERFACE_ENTRY(IWbemEventProviderQuerySink)
		[!endif]	
		COM_INTERFACE_ENTRY(IWbemProviderInit)
	END_COM_MAP()
	[!endif]


	//IWbemProviderInit
	HRESULT STDMETHODCALLTYPE Initialize( LPWSTR pszUser,
						  LONG lFlags,
						  LPWSTR pszNamespace,
						  LPWSTR pszLocale,
						  IWbemServices *pNamespace,
						  IWbemContext *pCtx,
						  IWbemProviderInitSink *pInitSink);

	//IWbemEventProvider
	HRESULT STDMETHODCALLTYPE ProvideEvents(
							IWbemObjectSink *pSink,
							long lFlags);


	[!if EVENT_SECURITY ]
	//IWbemEventProviderSecurity
	HRESULT STDMETHODCALLTYPE AccessCheck(
							WBEM_CWSTR wszQueryLanguage,
							WBEM_CWSTR wszQuery,
							long lSidLength,
							const BYTE* pSid
	);
	[!endif]

	[!if QUERY_SINK ]
	//IWbemEventProviderQuerySink
	HRESULT STDMETHODCALLTYPE CancelQuery(
	  unsigned long dwId
	);

	HRESULT STDMETHODCALLTYPE NewQuery(
	  unsigned long dwId,
	  WBEM_WSTR wszQueryLanguage,
	  WBEM_WSTR wszQuery
	);
	[!endif]

};

[!if !ATTRIBUTED]
OBJECT_ENTRY_AUTO(__uuidof([!output COCLASS]), [!output CLASS_NAME])
[!endif]

[!endif]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vc7\vcwiz\classwiz\atl\instance\templates\1031\wmiprov.cpp ===
// [!output IMPL_FILE] : Implementierung von [!output CLASS_NAME]
#include "stdafx.h"
#include "[!output PROJECT_NAME].h"
#include "[!output HEADER_FILE]"


/////////////////////////////////////////////////////////////////////////////
// [!output CLASS_NAME]

//////////////////////////////////////////////////////////////////////////////
// Klassen-, Eigenschaften- und Methodennamen

// Wichtig: Die folgenden Strings sollten nicht lokalisiert werden.

[!if CLASS_SPECIFIED]
const static WCHAR * s_pMyClassName = L"[!output WMICLASSNAME]"; //Klassenname

//Eigenschaften:
[!output PROPERTY_DEFINITIONS]

//Methoden:
[!output METHOD_DEFINITIONS]

[!else]
//Aktion: Definieren Sie den angegebenen Klassenname, z.B.:
const static WCHAR * s_pMyClassName = L"MyClassName"; 

//Aktion: Definieren Sie die Eigenschaftennamen der angegebenen Klasse, z.B.:
//const static WCHAR * pMyProperty = L"MyProperty";

//Aktion: Definieren Sie die Methodennamen der angegebenen Klasse, z.B.:
//const static WCHAR * pMyMethod = L"MyMethod";
[!endif]

//////////////////////////////////////////////////////////////////////////////
// [!output CLASS_NAME]::Initialize
//In der MSDN-Dokumentation fr IWbemProviderInit::Initialize()
//finden Sie weitere Einzelheiten ber die Implementierung dieser Methode.

STDMETHODIMP [!output CLASS_NAME]::Initialize(LPWSTR pszUser,	
									  LONG lFlags,
									  LPWSTR pszNamespace,
									  LPWSTR pszLocale,
									  IWbemServices *pNamespace,
							 		  IWbemContext *pCtx,
									  IWbemProviderInitSink *pInitSink) 
{

	if ( NULL == pNamespace || NULL == pInitSink) 
	{
        return WBEM_E_INVALID_PARAMETER;
	}

  	//IWbemServices-Zeiger zwischenspeichern
	//Hinweis: m_pNamespace ist ein dynamischer Zeiger: AddRef() funktionieren automatisch
	m_pNamespace = pNamespace;
				
	//Definition der angegebenen Klasse zwischenspeichern
	//Hinweis: Der Code unten geht davon aus, dass die Klassendefinition whrend der
	//Anbieterausfhrung unverndert bleibt. Andernfalls mssen Sie einen Benutzer
	//fr Klassennderungen und Klassenlschereignisse implementieren. Weitere
	//Informationen ber Ereignisbenutzer finden Sie auf MSDN in der WMI-Dokumentenation.
	
    HRESULT hr = m_pNamespace->GetObject(CComBSTR(s_pMyClassName), 
											0, 
											pCtx, 	//IWbemContext-Zeiger werden umgangen, um Sperrungen zu verhindern
											&m_pClass, 
											NULL);
    if(FAILED(hr))
	{
        return WBEM_E_FAILED;
	}    
	
	//Pfadverarbeitungs-Klassenherstellung zwischenspeichern
	hr = CoGetClassObject(CLSID_WbemDefPath, 
							CLSCTX_INPROC_SERVER, 
							NULL,
							IID_IClassFactory,
							(void **) &m_pPathFactory);
	if (FAILED(hr))
	{
		return WBEM_E_FAILED;
	}

	//Hilfsobjekt erstellen
	m_pHelper = new CInstanceProviderHelper(pNamespace, pCtx);

	//Hinweis: Rufen Sie ConstructErrorObject() auf m_pHelper irgendwo auf 
	//dem Anbieter auf, um einen Fehler oder Status an WMI zu melden.

    pInitSink->SetStatus(WBEM_S_INITIALIZED,0);
    return WBEM_S_NO_ERROR;
}

//////////////////////////////////////////////////////////////////////////////
// [!output CLASS_NAME]::GetObjectAsync
// In der MSDN-Dokumentation fr IWbemServices::GetObjectAsync()
// finden Sie weitere Einzelheiten ber die Implementierung dieser Methode.

STDMETHODIMP [!output CLASS_NAME]::GetObjectAsync( 
							 const BSTR bstrObjectPath,
							 long lFlags,
							 IWbemContext  *pCtx,
							 IWbemObjectSink  *pResponseHandler)
{
    
	//Fehler: Abrufen pro Eigenschaft?
    [!if SUPPORT_GET ]
	if (NULL == pResponseHandler)
	{
	     return WBEM_E_INVALID_PARAMETER;
	}

	CComPtr<IWbemClassObject> pInstance;
	HRESULT hr = GetInstanceByPath(bstrObjectPath, &pInstance);
	if (FAILED (hr))
	{
		return hr;
	}
			   
   	//Falls der Vorgang richtig ausgefhrt wurde, sollte das Objekt an WMI zurckgegeben werden und der erfolgreiche Vorgang angezeigt werden:
    pResponseHandler->Indicate (1, &(pInstance.p)); 
	pResponseHandler->SetStatus(0, WBEM_S_NO_ERROR, NULL, NULL);

    return WBEM_S_NO_ERROR;
	[!else]
    return WBEM_E_PROVIDER_NOT_CAPABLE;
	[!endif]
}

//////////////////////////////////////////////////////////////////////////////
// [!output CLASS_NAME]::PutInstanceAsync()
// In der MSDN-Dokumentation fr IWbemServices::PutInstanceAsync()
// finden Sie weitere Einzelheiten ber die Implementierung dieser Methode.

STDMETHODIMP [!output CLASS_NAME]::PutInstanceAsync( 
							IWbemClassObject  *pInst,
							long lFlags,
							IWbemContext  *pCtx,
							IWbemObjectSink  *pResponseHandler)
{
   
	[!if SUPPORT_PUT ]
	if ( NULL == pResponseHandler || NULL == pInst)
	{
        return WBEM_E_INVALID_PARAMETER;
	}
	//Aktion: berprfen Sie die Flagwerte: WBEM_FLAG_UPDATE_ONLY, 
	//WBEM_FLAG_CREATE_ONLY und WBEM_FLAG_CREATE_OR_UPDATE.
	//Whlen Sie eine Untersttzungsebene, und geben Sie
	//WBEM_E_PROVIDER_NOT_CAPABLE fr nicht untersttzte Flagwerte zurck.

	//Aktion: Falls Updates auch teilweise untersttzt werden sollen, berprfen 
	//Sie pCtx fr "__PUT_EXTENSIONS" und andere relevante Systemkontextwerte,
	//und aktualisieren Sie die Instanzdaten dementsprechend.
	
	//Aktion: Verarbeiten Sie das Instanzupdate oder die -erstellung an dieser Stelle.			
	
	pResponseHandler->SetStatus(0, WBEM_S_NO_ERROR, NULL, NULL);
	return WBEM_S_NO_ERROR;
	[!else]
	return WBEM_E_PROVIDER_NOT_CAPABLE;
	[!endif]
}


//////////////////////////////////////////////////////////////////////////////
// [!output CLASS_NAME]::DeleteInstanceAsync()
// In der MSDN-Dokumentation fr IWbemServices::DeleteInstanceAsync()
// finden Sie weitere Einzelheiten ber die Implementierung dieser Methode.

STDMETHODIMP [!output CLASS_NAME]::DeleteInstanceAsync( 
							const BSTR ObjectPath,
							long lFlags,
							IWbemContext  *pCtx,
							IWbemObjectSink  *pResponseHandler)
{
	//Fr die Methodenimplementierung verarbeitet ein Instanzanbieter die 
	//Objektpfadzeichenfolge, die im Parameter strObjectPath angegeben wird,
	//und versucht die passenden Instanz zu finden und zu lschen.
	[!if SUPPORT_DELETE ]

	if (NULL == pResponseHandler)
	{
		return WBEM_E_INVALID_PARAMETER;
	}
    
	[!if IS_COMPOUND_KEY]
	ULONG ulPathTest = WBEMPATH_INFO_IS_INST_REF | WBEMPATH_INFO_IS_COMPOUND;
	[!else]
	[!if IS_SINGLETON]
	ULONG ulPathTest = WBEMPATH_INFO_IS_INST_REF | WBEMPATH_INFO_CONTAINS_SINGLETON;
	[!else]
	ULONG ulPathTest = WBEMPATH_INFO_IS_INST_REF;
	[!endif]
	[!endif]
		
	if (FAILED(m_pHelper->CheckInstancePath(m_pPathFactory,
											ObjectPath,
											CComBSTR(s_pMyClassName),
											ulPathTest)) )
	{
		//Syntaxfehler im Pfad oder falscher Pfad fr angegebene Klasse
		return WBEM_E_INVALID_PARAMETER; 
	}			
	
	[!if IS_SINGLETON]
	//Hinweis: [!output WMICLASSNAME] ist ein einzelnes Objekt. Instanz muss nicht identifiziert werden.
	//Hinweis: Falls die Instanz nicht vorhanden ist, muss die folgende Zeile auskommentiert werden, damit die Information an WMI zurckgegeben werden kann:
	//return WBEM_E_NOT_FOUND;
	[!else]
	//Pfadverarbeitungsobjekt erstellen
	CComPtr<IWbemPath>pPath;
	HRESULT hr = m_pPathFactory->CreateInstance(NULL,
												IID_IWbemPath,
												(void **) &pPath);
	if (FAILED(hr))
	{
		return WBEM_E_FAILED;
	}

	hr = pPath->SetText(WBEMPATH_CREATE_ACCEPT_ALL,	ObjectPath);
	
	CComPtr<IWbemPathKeyList> pIKeyList;
	hr = pPath->GetKeyList(&pIKeyList);
	if (FAILED(hr))
	{
		return hr;
	}
	
	unsigned long ulNumKeys;
	hr = pIKeyList->GetCount(&ulNumKeys);

	//Werte der wichtigen Eigenschaften abrufen
	unsigned long uKeyNameBufferSize = CComBSTR(ObjectPath).Length() + 1;
	WCHAR * wKeyName = new WCHAR[uKeyNameBufferSize];
	if (NULL == wKeyName)
	{
		return WBEM_E_OUT_OF_MEMORY;
	}
	CComVariant vValue;
	unsigned long ulApparentCimType;
	for (unsigned long i = 0; i < ulNumKeys; i++)
	{			
		hr = pIKeyList->GetKey2(i, 0L, &uKeyNameBufferSize, 
								wKeyName, &vValue, &ulApparentCimType);			
		//Aktion: vValue fr sptere Verwendung speichern
	}
	delete[] wKeyName;

	//Aktion: Suchen Sie in den Daten nach dem bereinstimmenden Objekt, und lschen Sie es.
	//Hinweis: Falls Sie kein Objekt, das mit den im Pfad angezeigten Schlsselwerten bereinstimmt, 
	//finden, muss die folgende Zeile auskommentiert werden, so dass diese Information an WMI bermittelt wird:
	//return WBEM_E_NOT_FOUND;
	[!endif]	

	pResponseHandler->SetStatus(0, WBEM_S_NO_ERROR, NULL, NULL);	
    return WBEM_S_NO_ERROR;
	
	[!else]
	return WBEM_E_PROVIDER_NOT_CAPABLE;
	[!endif]
}


//////////////////////////////////////////////////////////////////////////////
// [!output CLASS_NAME]::CreateInstanceEnumAsync()
// In der MSDN-Dokumentation fr IWbemServices::CreateInstanceEnumAsync()
// finden Sie weitere Einzelheiten ber die Implementierung dieser Methode.

STDMETHODIMP [!output CLASS_NAME]::CreateInstanceEnumAsync( 
							const BSTR Class,
							long lFlags,
							IWbemContext  *pCtx,
							IWbemObjectSink  *pResponseHandler)
{
	

	//Wichtiger Hinweis: Der Instanzanbieter hat einen Thread von WMI bernommen, um diese 
	//Vorgnge auszufhren. Sie sollten die Datensenkmethode AddRef() aufrufen und einen
	//anderen Thread zum Zustellen der Objekte im Ergebnissatz erstellen. 
	//Somit knnen Sie den aktuellen Thread zum Zurckgeben an WMI verwenden, ohne dass der 
	//Threadpool gelscht wird. Abhngig davon wie lange der Anbieter den WMI-Thread 
	//verwenden mchte, wird ein einfacher oder ein doppelter Thread verwendet.

	[!if SUPPORT_ENUMERATE ]
	if (NULL == pResponseHandler)
	{
	    return WBEM_E_INVALID_PARAMETER;
	}

	HRESULT hr = WBEM_S_NO_ERROR;
	
	[!if IS_SINGLETON]
	// Ein leeres Objekt zum Abrufen der Instanzdaten verwenden
    CComPtr<IWbemClassObject> pNewInst;
    hr = m_pClass->SpawnInstance(0, &pNewInst);
		
	CComVariant var;
	[!if CLASS_SPECIFIED]
	[!output POPULATE_INSTANCE]
	[!else]
	//Aktion: Fllen Sie die Instanz mit Eigenschaften auf, z.B.:
	//CComVariant var;
	//var.ChangeType(VT_BSTR);
	//var = <value>;  //richtigen Wert hier setzen
	//hr = pNewInst->Put(CComBSTR(pMyProperty), 0, &var, 0);
	//var.Clear();
	[!endif]
		
	// Klasse an WMI bermitteln
    pResponseHandler->Indicate(1, &(pNewInst.p));
	[!else]
    // Durch die persnliche Quelle schleifen und jede Instanz erstellen,
	//solange (while): (<weitere Instanzen vorhanden>)
    {
		// Ein leeres Objekt zum Empfangen der Klassendefinition vorbereiten
        CComPtr<IWbemClassObject> pNewInst;
        hr = m_pClass->SpawnInstance(0, &pNewInst);
		if (FAILED(hr))
		{	
			//Aktion: Kommentieren Sie die Zeile unten aus, sobald die Schleifenbedingung erstellt wurde
			//break;
		}
		
		CComVariant var;
		[!if CLASS_SPECIFIED]
		[!output POPULATE_INSTANCE]
		[!else]
		//Aktion: Fllen Sie die Instanz mit Eigenschaften auf, z.B.:
		//CComVariant var;
		//var.ChangeType(VT_BSTR);
		//var = <value>;  //richtigen Wert hier angegeben
		//hr = pNewInst->Put(CComBSTR(pMyProperty), 0, &var, 0);
		//var.Clear();
		[!endif]
		
		// Klasse an WMI bermitteln
        pResponseHandler->Indicate(1, &(pNewInst.p));
    }  	
	[!endif]
	pResponseHandler->SetStatus(0, hr, NULL, NULL);
   	return WBEM_S_NO_ERROR;
	[!else]
	return WBEM_E_PROVIDER_NOT_CAPABLE;
	[!endif]
}


//////////////////////////////////////////////////////////////////////////////
//[!output CLASS_NAME]::ExecQueryAsync()
// In der MSDN-Dokumentation fr IWbemServices::ExecQueryAsync()
// finden Sie weitere Einzelheiten ber die Implementierung dieser Methode.

STDMETHODIMP [!output CLASS_NAME]::ExecQueryAsync( 
							const BSTR QueryLanguage,
							const BSTR Query,
							long lFlags,
							IWbemContext  *pCtx,
							IWbemObjectSink  *pResponseHandler)
{
	
	
   	// Instanzanbieter knnen Abfragen entweder selbst verarbeiten oder Abfragen von WMI 
	// verarbeiten lassen. Ein Instanzanbieter muss SQL-Anweisungen (Structured Query Language)  
	// verarbeiten, die angeforderte Anfrage ausfhren und die Ergebnissatzobjekte der 
	// richtigen Datensenke zustellen, um Abfragen untersttzen zu knnen. 
	
	//Aktion: Verwenden Sie den Abfrageverarbeitungscode an dieser Stelle.
	
	//pResponseHandler->SetStatus(0, WBEM_S_NO_ERROR, NULL, NULL);
	// return WBEM_S_NO_ERROR;

	return WBEM_E_PROVIDER_NOT_CAPABLE;
	
}

[!if PROVIDE_METHODS ]

//////////////////////////////////////////////////////////////////////////////
// [!output CLASS_NAME]::ExecMethodAsync()
// In der MSDN-Dokumentation fr IWbemServices::ExecMethodAsync()
// finden Sie weitere Einzelheiten ber die Implementierung dieser Methode.
STDMETHODIMP [!output CLASS_NAME]::ExecMethodAsync( 
							const BSTR strObjectPath,
							const BSTR strMethodName,
							long lFlags,
							IWbemContext  *pCtx,
							IWbemClassObject  *pInParams,
							IWbemObjectSink  *pResponseHandler)
{
	

	[!if CLASS_SPECIFIED]
	[!if  !HAS_IMPL_METHODS]	
	//[!output WMICLASSNAME] enthlt keine implementierten Methoden
	return WBEM_E_NOT_SUPPORTED;
	[!else]
	HRESULT hr = WBEM_E_FAILED;	
    if (NULL == pResponseHandler)
	{
        return WBEM_E_INVALID_PARAMETER;
	}	
	[!output EXEC_METHOD_BODY]
	[!endif]
	[!else]
	
	//Vergewissen Sich, dass der Klassenname im Pfad richtig ist.
	//Pfadverarbeitungsobjekt abrufen:
	CComPtr<IWbemPath>pPath;
	HRESULT hr = m_pPathFactory->CreateInstance(NULL,
												IID_IWbemPath,
												(void **) &pPath);
	if (FAILED(hr))
	{
		return WBEM_E_FAILED;
	}

	HRESULT hr = pPath->SetText(WBEMPATH_CREATE_ACCEPT_ALL, strObjectPath);
	long nPathLen = CComBSTR(strObjectPath).Length();
	unsigned long ulBufLen = nPathLen + 1;
	WCHAR * wClass = new WCHAR[nPathLen];
	if (NULL == wClass)
	{
		return WBEM_E_OUT_OF_MEMORY;
	}
	pPath->GetClassName(&ulBufLen, wClass);
	if ( _wcsicmp(s_pMyClassName, wClass))
	{
		delete[] wClass;
		return WBEM_E_INVALID_PARAMETER;
	}
	delete[] wClass;
	//Aktion: Vergleichen Sie den angeforderten Methodenname mit den Methoden der Klassen.
	//if (!_wcsicmp (strMethodName, pMyNonStaticMethod))
	{
		CComVariant var;

		//Eingabeargumente abrufen:
		//Aktion: Falls die Methode Eingabeargumente enthlt, werden diese wie Eigenschaften vom Objekt 
		//pInParams weitergeleitet. Die kommentierte Zeile unten gibt an, wie diese Argumente abgerufen werden:
		//hr = pInParams->Get(CComBSTR("InputArgument1"), 0, &var, NULL, NULL);
		//Aktion: Eingabeparameterwert speichern
		var.Clear();		
		
		//Verarbeitungspfad zum Suchen der Instanz fr die Methodenausfhrung: fr nicht statische Methode
		CComPtr<IWbemPathKeyList> pIKeyList;
		hr = pPath->GetKeyList(&pIKeyList);
		if (FAILED(hr))
		{
			return WBEM_E_INVALID_PARAMETER;
		}
		unsigned long ulNumKeys;
		hr = pIKeyList->GetCount(&ulNumKeys);
		//Get values of key properties:
		unsigned long uKeyNameBufferSize = nPathLen + 1;
		WCHAR  * wKeyName = new WCHAR[uKeyNameBufferSize];
		if (NULL == wKeyName)
		{
			return WBEM_E_OUT_OF_MEMORY;
		}
		CComVariant vValue;
		unsigned long ulApparentCimType;
		for (unsigned long i = 0; i < ulNumKeys; i++)
		{
			hr = pIKeyList->GetKey2(i, 0L, &uKeyNameBufferSize,
									wKeyName, &vValue, &ulApparentCimType);
			//Aktion: vValue fr sptere Verwendung speichern
		}
		delete[] wKeyName;
	
		//Aktion: Suchen Sie in der Datenquelle nach dem bereinstimmenden Objekt.
		
		//Aktion: Fgen Sie Code hinzu, um die Methode an dieser Stelle auszufhren.
		//Ausgabeparameterklasse abrufen
		CComPtr<IWbemClassObject> pOutClass;
		hr = m_pClass->GetMethod(CComBSTR("Method1"), 0, NULL, &pOutClass);
		CComPtr<IWbemClassObject> pOutParams;
		pOutClass->SpawnInstance(0, &pOutParams);
		//Aktion: Erstellen Sie Ausgabeparameter, indem Sie Eigenschaften
		//von der pOutParams-Klasse auffllen. Zum Beispiel:

		//var.ChangeType(VT_BSTR);
		//Variable mit richtigen Wert auffllen
		//hr = pOutParams->Put(CComBSTR("MyOutputParameter"), 0, &var, 0);
		//var.Clear();
		//var.ChangeType(VT_I2);
		//Variable mit richtigen Wert auffllen
		//hr = pOutParams->Put(CComBSTR("ReturnValue"), 0, &var, 0);
		//var.Clear();
		//Ausgabeobjekt zurck an den Client ber die Datensenke senden
		hr = pResponseHandler->Indicate(1, &(pOutParams.p));
		
		pResponseHandler->SetStatus(0, WBEM_S_NO_ERROR, NULL, NULL);
		return WBEM_S_NO_ERROR;
	}
	
	//Methodenname wurde nicht erkannt
	return WBEM_E_INVALID_PARAMETER;
	
	
	[!endif]	
}
[!endif]



//////////////////////////////////////////////////////////////////////////////
// [!output CLASS_NAME]::GetInstanceByPath() verarbeitet den Pfad, um erforderliche Schlsselwerte
// zu finden. Dann wird der interne Speicher nach einem Objekt mit den passenden Schlsselwerten durchsucht.
// Falls das Objekt gefunden wird, erstellt die Methode eine neue Instanz, fllt die Eigenschaften auf
// und gibt sie in ppInstance zurck. Falls das Objekt nicht gefunden wird, wird WBEM_E_NOT_FOUND zurckgegeben.
// Fehler: Instanzteil einer Provision???  Andere mgliche Flags?

STDMETHODIMP [!output CLASS_NAME]::GetInstanceByPath (
													/*in*/CComBSTR bstrPath,
													/*out*/IWbemClassObject ** ppInstance )
													
{
		HRESULT hr = WBEM_E_FAILED;				  
		
		[!if IS_COMPOUND_KEY]
		ULONG ulPathTest = WBEMPATH_INFO_IS_INST_REF | WBEMPATH_INFO_IS_COMPOUND;
		[!else]
		[!if IS_SINGLETON]
		ULONG ulPathTest = WBEMPATH_INFO_IS_INST_REF | WBEMPATH_INFO_CONTAINS_SINGLETON;
		[!else]
		ULONG ulPathTest = WBEMPATH_INFO_IS_INST_REF;
		[!endif]
		[!endif]
		
		if (FAILED(m_pHelper->CheckInstancePath(m_pPathFactory,
												bstrPath,
												CComBSTR(s_pMyClassName),
												ulPathTest)))
		{
			//Syntaxfehler im Pfad oder falscher Pfad fr angegebene Klasse
			return WBEM_E_INVALID_PARAMETER; 
		}			
		
		[!if IS_SINGLETON]
		//[!output WMICLASSNAME] ist ein einzelnes Objekt. Instanz muss nicht identifiziert werden.
		//Hinweis: Falls die Instanz nicht vorhanden ist, sollte die folgende Zeile auskommentiert werden, 		//so dass diese Informationen an WMI bermittelt wird:
		//return WBEM_E_NOT_FOUND;
		[!else]
		//Pfadverarbeitungsobjekt abrufen:
		CComPtr<IWbemPath>pPath;
		hr = m_pPathFactory->CreateInstance(NULL,
												IID_IWbemPath,
												(void **) &pPath);
		if (FAILED(hr))
		{
			return WBEM_E_FAILED;
		}
		
		hr = pPath->SetText(WBEMPATH_CREATE_ACCEPT_ALL,
									bstrPath);

		CComPtr<IWbemPathKeyList> pIKeyList;
		hr = pPath->GetKeyList(&pIKeyList);
		if (FAILED(hr))
		{
			return hr;
		}
		unsigned long ulNumKeys;
		hr = pIKeyList->GetCount(&ulNumKeys);

		//Werte der Schlsseleigenschaften abrufen
		unsigned long uKeyNameBufferSize = bstrPath.Length() + 1;
		WCHAR  * wKeyName = new WCHAR[uKeyNameBufferSize];
		if (NULL == wKeyName)
		{
			return WBEM_E_OUT_OF_MEMORY;
		}
		CComVariant vValue;		
		unsigned long ulApparentCimType;
		for (unsigned long i = 0; i < ulNumKeys; i++)
		{			
			hr = pIKeyList->GetKey2(i, 0L, &uKeyNameBufferSize, 
									wKeyName, &vValue, &ulApparentCimType);			
			//Aktion: vValue fr sptere Verwendung speichern
		}

		delete[] wKeyName;
		
		//Aktion: Suchen Sie in der Datenquelle nach dem bereinstimmenden Objekt.
		//Falls keine Objekte mit den erforderlichen Schlsselwerten gefunden werden, 
		//WBEM_E_NOT_FOUND zurckgeben.
		[!endif]
	   
		//Neue Instanz erstellen
		CComPtr<IWbemClassObject> pNewInst;
		hr = m_pClass->SpawnInstance(0, &pNewInst);
		if(FAILED(hr))
		{
			return hr;
		}
		CComVariant var;

		//Aktion: Fllen Sie die Eigenschaften der neuen Instanz mit denen des bereinstimmenden internen Objekts auf.
		[!if CLASS_SPECIFIED]
		[!output POPULATE_INSTANCE]			
		[!else]
		//Beispiel:
		//var.ChangeType(VT_BSTR);
		//var = <value>; //put appropriate value here
		//hr = pNewInst->Put(CComBSTR(pMyProperty), 0, &var, 0);
		//var.Clear();		
		[!endif]

		pNewInst.CopyTo(ppInstance);

		return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vc7\vcwiz\classwiz\atl\instance\templates\1041\wmiprov.cpp ===
// [!output IMPL_FILE] :  [!output CLASS_NAME] ̎s
#include "stdafx.h"
#include "[!output PROJECT_NAME].h"
#include "[!output HEADER_FILE]"


/////////////////////////////////////////////////////////////////////////////
// [!output CLASS_NAME]

//////////////////////////////////////////////////////////////////////////////
// NXAvpeBA\bh

// dv: ȉɒ`Ă镶̓[JCYł܂B

[!if CLASS_SPECIFIED]
const static WCHAR * s_pMyClassName = L"[!output WMICLASSNAME]"; //NX

//vpeB:
[!output PROPERTY_DEFINITIONS]

//\bh:
[!output METHOD_DEFINITIONS]

[!else]
//TODO: ^ꂽNX`ĂB:
const static WCHAR * s_pMyClassName = L"MyClassName"; 

//TODO: ^ꂽNX̃voeB`ĂB:
//const static WCHAR * pMyProperty = L"MyProperty";

//TODO: ^ꂽNX̃\bh`ĂB:
//const static WCHAR * pMyMethod = L"MyMethod";
[!endif]

//////////////////////////////////////////////////////////////////////////////
// [!output CLASS_NAME]::Initialize
//̃\bh̎ɂĂ̏ڍׂ́AIWbemProviderInit::Initialize()
// MSDN hLgQƂĂB

STDMETHODIMP [!output CLASS_NAME]::Initialize(LPWSTR pszUser,	
									  LONG lFlags,
									  LPWSTR pszNamespace,
									  LPWSTR pszLocale,
									  IWbemServices *pNamespace,
							 		  IWbemContext *pCtx,
									  IWbemProviderInitSink *pInitSink) 
{

	if ( NULL == pNamespace || NULL == pInitSink) 
	{
        return WBEM_E_INVALID_PARAMETER;
	}

  	//IWbemServices |C^LbV܂B
	//: m_pNamespace ̓X}[g |C^łBI AddRef() ܂B
	m_pNamespace = pNamespace;
				
	//Cxg NX̒`ۑ܂B				
	//: ȉ̃R[h́AvoC_̎s̓Cxg NX̒`A
	//ύXȂƉ肵Ă܂BύXꍇ́ANX̏CCxgƍ폜Cxgp
	//RV[}Kv܂BCxg RV[}ɂẮA
	//MSDN  WMI hLgQƂĂB
	
    HRESULT hr = m_pNamespace->GetObject(CComBSTR(s_pMyClassName), 
											0, 
											pCtx, 	//fbhbNȂ悤 IWbemContext |C^n܂B
											&m_pClass, 
											NULL);
    if(FAILED(hr))
	{
        return WBEM_E_FAILED;
	}    
	
	//pX p[T[ NX t@NgLbV܂B
	hr = CoGetClassObject(CLSID_WbemDefPath, 
							CLSCTX_INPROC_SERVER, 
							NULL,
							IID_IClassFactory,
							(void **) &m_pPathFactory);
	if (FAILED(hr))
	{
		return WBEM_E_FAILED;
	}

	//helper IuWFNg쐬܂B
	m_pHelper = new CInstanceProviderHelper(pNamespace, pCtx);

	//: WMIɏڂG[܂͏Ԃ񍐂邽߂ɁA
	//voC_ m_pHelper ̂ǂłł ConstructErrorObject() ĂяoƂł܂B 

    pInitSink->SetStatus(WBEM_S_INITIALIZED,0);
    return WBEM_S_NO_ERROR;
}

//////////////////////////////////////////////////////////////////////////////
// [!output CLASS_NAME]::GetObjectAsync
// ̃\bh̎ɂĂ̏ڍׂ́ARIWbemServices::GetObjectAsync()
//  MSDN hLgQƂĂB

STDMETHODIMP [!output CLASS_NAME]::GetObjectAsync( 
							 const BSTR bstrObjectPath,
							 long lFlags,
							 IWbemContext  *pCtx,
							 IWbemObjectSink  *pResponseHandler)
{
    
	//bugbug: evpeB̎擾?
    [!if SUPPORT_GET ]
	if (NULL == pResponseHandler)
	{
	     return WBEM_E_INVALID_PARAMETER;
	}

	CComPtr<IWbemClassObject> pInstance;
	HRESULT hr = GetInstanceByPath(bstrObjectPath, &pInstance);
	if (FAILED (hr))
	{
		return hr;
	}
			   
   	//ׂĂ܂ꍇ́AIuWFNg WMI ɖ߂\܂B:
    pResponseHandler->Indicate (1, &(pInstance.p)); 
	pResponseHandler->SetStatus(0, WBEM_S_NO_ERROR, NULL, NULL);

    return WBEM_S_NO_ERROR;
	[!else]
    return WBEM_E_PROVIDER_NOT_CAPABLE;
	[!endif]
}

//////////////////////////////////////////////////////////////////////////////
// [!output CLASS_NAME]::PutInstanceAsync()
// ̃\bh̎ɂĂ̏ڍׂ́AIWbemServices::PutInstanceAsync()
//  MSDN hLgQƂĂB

STDMETHODIMP [!output CLASS_NAME]::PutInstanceAsync( 
							IWbemClassObject  *pInst,
							long lFlags,
							IWbemContext  *pCtx,
							IWbemObjectSink  *pResponseHandler)
{
   
	[!if SUPPORT_PUT ]
	if ( NULL == pResponseHandler || NULL == pInst)
	{
        return WBEM_E_INVALID_PARAMETER;
	}
	//TODO: \ȃtOl𒲂ׂĂ: WBEM_FLAG_UPDATE_ONLYA
	//WBEM_FLAG_CREATE_ONLYAWBEM_FLAG_CREATE_OR_UPDATE
	//KvȃT|[g̃xIāAT|[gĂȂtOl̂߂ WBEM_E_PROVIDER_NOT_CAPABLE
	//ԂĂB

	//TODO: IȍXVT|[g\肪ꍇ́A"__PUT_EXTENSIONS"  
	// pCtx Ƃق̊֘AVXe ReLXgl𒲂ׂāA
	//CX^X f[^K؂ɍXVĂB
	
	//TODO: ŃCX^X̍XV܂͍쐬܂B			
	
	pResponseHandler->SetStatus(0, WBEM_S_NO_ERROR, NULL, NULL);
	return WBEM_S_NO_ERROR;
	[!else]
	return WBEM_E_PROVIDER_NOT_CAPABLE;
	[!endif]
}


//////////////////////////////////////////////////////////////////////////////
// [!output CLASS_NAME]::DeleteInstanceAsync()
// ̃\bh̎ɂĂ̏ڍׂ́A IWbemServices::DeleteInstanceAsync()
//  MSDN wvQƂĂB

STDMETHODIMP [!output CLASS_NAME]::DeleteInstanceAsync( 
							const BSTR ObjectPath,
							long lFlags,
							IWbemContext  *pCtx,
							IWbemObjectSink  *pResponseHandler)
{
	//̃\bhCvg邽߂ɁACX^X voC_ strObjectPath p[^
	//Ɏw肳ꂽIuWFNg pX͂AΉCX^X
	//폜܂B
	[!if SUPPORT_DELETE ]

	if (NULL == pResponseHandler)
	{
		return WBEM_E_INVALID_PARAMETER;
	}
    
	[!if IS_COMPOUND_KEY]
	ULONG ulPathTest = WBEMPATH_INFO_IS_INST_REF | WBEMPATH_INFO_IS_COMPOUND;
	[!else]
	[!if IS_SINGLETON]
	ULONG ulPathTest = WBEMPATH_INFO_IS_INST_REF | WBEMPATH_INFO_CONTAINS_SINGLETON;
	[!else]
	ULONG ulPathTest = WBEMPATH_INFO_IS_INST_REF;
	[!endif]
	[!endif]
		
	if (FAILED(m_pHelper->CheckInstancePath(m_pPathFactory,
											ObjectPath,
											CComBSTR(s_pMyClassName),
											ulPathTest)) )
	{
		//pX̍\G[A^ꂽNX̃pX܂B
		return WBEM_E_INVALID_PARAMETER; 
	}			
	
	[!if IS_SINGLETON]
	//: [!output WMICLASSNAME] ̓VOg IuWFNgłB CX^XʂKv͂܂B
	//: CX^X݂Ȃꍇ́AWMIɒʐMԂ߂Ɏ̃RgȂĂ:
	// WBEM_E_NOT_FOUND Ԃ܂;
	[!else]
	//pX p[T[ IuWFNg쐬܂B
	CComPtr<IWbemPath>pPath;
	HRESULT hr = m_pPathFactory->CreateInstance(NULL,
												IID_IWbemPath,
												(void **) &pPath);
	if (FAILED(hr))
	{
		return WBEM_E_FAILED;
	}

	hr = pPath->SetText(WBEMPATH_CREATE_ACCEPT_ALL,	ObjectPath);
	
	CComPtr<IWbemPathKeyList> pIKeyList;
	hr = pPath->GetKeyList(&pIKeyList);
	if (FAILED(hr))
	{
		return hr;
	}
	
	unsigned long ulNumKeys;
	hr = pIKeyList->GetCount(&ulNumKeys);

	//L[ vpeB̒l擾܂B
	unsigned long uKeyNameBufferSize = CComBSTR(ObjectPath).Length() + 1;
	WCHAR * wKeyName = new WCHAR[uKeyNameBufferSize];
	if (NULL == wKeyName)
	{
		return WBEM_E_OUT_OF_MEMORY;
	}
	CComVariant vValue;
	unsigned long ulApparentCimType;
	for (unsigned long i = 0; i < ulNumKeys; i++)
	{			
		hr = pIKeyList->GetKey2(i, 0L, &uKeyNameBufferSize, 
								wKeyName, &vValue, &ulApparentCimType);			
		//TODO: Ŏg߂ vValue ۑ܂B
	}
	delete[] wKeyName;

	//TODO: vIuWFNgoč폜邽߂Ƀf[^ \[XŌJԂ܂B
	//: pXɎꂽL[lɈvIuWFNgołȂꍇA
	// WMI ɒʐM邽߂Ɏ̍sRgɂĂ:
	//return WBEM_E_NOT_FOUND;
	[!endif]	

	pResponseHandler->SetStatus(0, WBEM_S_NO_ERROR, NULL, NULL);	
    return WBEM_S_NO_ERROR;
	
	[!else]
	return WBEM_E_PROVIDER_NOT_CAPABLE;
	[!endif]
}


//////////////////////////////////////////////////////////////////////////////
// [!output CLASS_NAME]::CreateInstanceEnumAsync()
// ̃\bh̎ɂĂ̏ڍׂ́AIWbemServices::CreateInstanceEnumAsync()
//  MSDN hLgQƂĂB

STDMETHODIMP [!output CLASS_NAME]::CreateInstanceEnumAsync( 
							const BSTR Class,
							long lFlags,
							IWbemContext  *pCtx,
							IWbemObjectSink  *pResponseHandler)
{
	

	//: CX^X voC_̑s邽߂ WMI Xbh擾Ă邱Ƃ
	//ɒӂĂBVN AddRef() \bhĂяoČʃZbgɃIuWFNgzz邽߂
	//ʂ̃Xbh쐬ĂB 
	//ɂAXbh v[ՂȂŌ݂̃Xbh WMI ԂƂł܂B
	//voC_fA Xbh fUCVO Xbh fUCI邩ǂ́A
	//voC_ WMI Xbhgp\̊ԂɈˑ܂B

	[!if SUPPORT_ENUMERATE ]
	if (NULL == pResponseHandler)
	{
	    return WBEM_E_INVALID_PARAMETER;
	}

	HRESULT hr = WBEM_S_NO_ERROR;
	
	[!if IS_SINGLETON]
	// CX^X f[^󂯎邽߂ɋ̃IuWFNgpӂ܂B
    CComPtr<IWbemClassObject> pNewInst;
    hr = m_pClass->SpawnInstance(0, &pNewInst);
		
	CComVariant var;
	[!if CLASS_SPECIFIED]
	[!output POPULATE_INSTANCE]
	[!else]
	//TODO: CX^XɃvpeBĂB:
	//CComVariant var;
	//var.ChangeType(VT_BSTR);
	//var = <value>;  //ɓK؂Ȓl͂ĂB
	//hr = pNewInst->Put(CComBSTR(pMyProperty), 0, &var, 0);
	//var.Clear();
	[!endif]
		
	// NX WMI ɔzz܂B
    pResponseHandler->Indicate(1, &(pNewInst.p));
	[!else]
    // vCx[g \[X[vɂAeCX^X쐬ĂB
	//while (<CX^X>)
    {
		// CX^X f[^󂯎邽߂ɋ̃IuWFNgpӂ܂B
        CComPtr<IWbemClassObject> pNewInst;
        hr = m_pClass->SpawnInstance(0, &pNewInst);
		if (FAILED(hr))
		{	
			//TODO: [v͂A̍sRgɂĂB
			//break;
		}
		
		CComVariant var;
		[!if CLASS_SPECIFIED]
		[!output POPULATE_INSTANCE]
		[!else]
		//TODO: CX^XɃvpeB܂B:
		//CComVariant var;
		//var.ChangeType(VT_BSTR);
		//var = <value>;  //ɓK؂Ȓl͂Ă
		//hr = pNewInst->Put(CComBSTR(pMyProperty), 0, &var, 0);
		//var.Clear();
		[!endif]
		
		// NX WMI ɔzz܂B
        pResponseHandler->Indicate(1, &(pNewInst.p));
    }  	
	[!endif]
	pResponseHandler->SetStatus(0, hr, NULL, NULL);
   	return WBEM_S_NO_ERROR;
	[!else]
	return WBEM_E_PROVIDER_NOT_CAPABLE;
	[!endif]
}


//////////////////////////////////////////////////////////////////////////////
//[!output CLASS_NAME]::ExecQueryAsync()
// ̃\bh̎ɂĂ̏ڍׂ́AIWbemServices::ExecQueryAsync()
//  MSDN hLgQƂĂB

STDMETHODIMP [!output CLASS_NAME]::ExecQueryAsync( 
							const BSTR QueryLanguage,
							const BSTR Query,
							long lFlags,
							IWbemContext  *pCtx,
							IWbemObjectSink  *pResponseHandler)
{
	
	
   	// CX^X voC_̓T[rXɑ΂āANG̃T|[g܂͂̃T|[g WMI Ɉˑ
	// IvV܂BNGT|[g邽߂ɂ́ACX^X voC_
	// ȒP SQL (Structured Query Language) Xe[gg̉́AvꂽNG̎sA
	// ʃZbg IuWFNg̗v҂̃VNւ̔zMsKv܂B 
	
	//TODO: NGR[hɓ͂ĂB
	
	//pResponseHandler->SetStatus(0, WBEM_S_NO_ERROR, NULL, NULL);
	// return WBEM_S_NO_ERROR;

	return WBEM_E_PROVIDER_NOT_CAPABLE;
	
}

[!if PROVIDE_METHODS ]

//////////////////////////////////////////////////////////////////////////////
// [!output CLASS_NAME]::ExecMethodAsync()
// ̃\bh̎ɂĂ̏ڍׂ́AIWbemServices::ExecMethodAsync()
//  MSDN hLgQƂĂB

STDMETHODIMP [!output CLASS_NAME]::ExecMethodAsync( 
							const BSTR strObjectPath,
							const BSTR strMethodName,
							long lFlags,
							IWbemContext  *pCtx,
							IWbemClassObject  *pInParams,
							IWbemObjectSink  *pResponseHandler)
{
	

	[!if CLASS_SPECIFIED]
	[!if  !HAS_IMPL_METHODS]	
	//[!output WMICLASSNAME] ɂ͎ꂽ\bh܂B
	return WBEM_E_NOT_SUPPORTED;
	[!else]
	HRESULT hr = WBEM_E_FAILED;	
    if (NULL == pResponseHandler)
	{
        return WBEM_E_INVALID_PARAMETER;
	}	
	[!output EXEC_METHOD_BODY]
	[!endif]
	[!else]
	
	//pX̃NXƂmFĂB
	//pX p[T[ IuWFNg擾܂:
	CComPtr<IWbemPath>pPath;
	HRESULT hr = m_pPathFactory->CreateInstance(NULL,
												IID_IWbemPath,
												(void **) &pPath);
	if (FAILED(hr))
	{
		return WBEM_E_FAILED;
	}

	HRESULT hr = pPath->SetText(WBEMPATH_CREATE_ACCEPT_ALL, strObjectPath);
	long nPathLen = CComBSTR(strObjectPath).Length();
	unsigned long ulBufLen = nPathLen + 1;
	WCHAR * wClass = new WCHAR[nPathLen];
	if (NULL == wClass)
	{
		return WBEM_E_OUT_OF_MEMORY;
	}
	pPath->GetClassName(&ulBufLen, wClass);
	if ( _wcsicmp(s_pMyClassName, wClass))
	{
		delete[] wClass;
		return WBEM_E_INVALID_PARAMETER;
	}
	delete[] wClass;
	//TODO: vꂽ\bhƃNX̃\bhrĂB
	//if (!_wcsicmp (strMethodName, pMyNonStaticMethod))
	{
		CComVariant var;

		//͈擾܂:
		//TODO: \bhɓ͈ꍇ́A͈ pInParams IuWFNg̃voeBƂēn܂B
		//͈̎óAȉ̃RgsQƂĂ:
		//hr = pInParams->Get(CComBSTR("InputArgument1"), 0, &var, NULL, NULL);
		//TODO: ̓p[^̒lۑ܂B
		var.Clear();		
		
		//\bh̎s̃CX^Xo邽߂ɃpX͂܂: ÓIłȂ\bhp
		CComPtr<IWbemPathKeyList> pIKeyList;
		hr = pPath->GetKeyList(&pIKeyList);
		if (FAILED(hr))
		{
			return WBEM_E_INVALID_PARAMETER;
		}
		unsigned long ulNumKeys;
		hr = pIKeyList->GetCount(&ulNumKeys);
		//L[vpeB̒l擾܂:
		unsigned long uKeyNameBufferSize = nPathLen + 1;
		WCHAR  * wKeyName = new WCHAR[uKeyNameBufferSize];
		if (NULL == wKeyName)
		{
			return WBEM_E_OUT_OF_MEMORY;
		}
		CComVariant vValue;
		unsigned long ulApparentCimType;
		for (unsigned long i = 0; i < ulNumKeys; i++)
		{
			hr = pIKeyList->GetKey2(i, 0L, &uKeyNameBufferSize,
									wKeyName, &vValue, &ulApparentCimType);
			//TODO: Ŏg߂ vValue ۑ܂B
		}
		delete[] wKeyName;
	
		//TODO: IuWFNg邽߂Ƀf[^ \[XgČJԂB
		
		//TODO: \bhs邽߂ɂɃR[h𑫂ĂB
		//o̓p[^̃NX󂯎܂B
		CComPtr<IWbemClassObject> pOutClass;
		hr = m_pClass->GetMethod(CComBSTR("Method1"), 0, NULL, &pOutClass);
		CComPtr<IWbemClassObject> pOutParams;
		pOutClass->SpawnInstance(0, &pOutParams);
		//TODO: pOutParams ̃NX̃vpeBt@CāA
		//o̓p[^쐬܂B:

		//var.ChangeType(VT_BSTR);
		//var ɓK؂Ȓl͂ĂB
		//hr = pOutParams->Put(CComBSTR("MyOutputParameter"), 0, &var, 0);
		//var.Clear();
		//var.ChangeType(VT_I2);
		//var ɓK؂Ȓl͂ĂB
		//hr = pOutParams->Put(CComBSTR("ReturnValue"), 0, &var, 0);
		//var.Clear();
		// o̓IuWFNgVNʂăNCAgɑԂĂB
		hr = pResponseHandler->Indicate(1, &(pOutParams.p));
		
		pResponseHandler->SetStatus(0, WBEM_S_NO_ERROR, NULL, NULL);
		return WBEM_S_NO_ERROR;
	}
	
	//FȂ\bhłB
	return WBEM_E_INVALID_PARAMETER;
	
	
	[!endif]	
}
[!endif]



//////////////////////////////////////////////////////////////////////////////
// [!output CLASS_NAME]::GetInstanceByPath() ͗vꂽL[̒lo邽߂ɃpX͂A
// L[̒lɈvIuWFNgXgA܂B
// ̂悤ȃIuWFNgoꍇ́A\bh͐VCX^X𐶐AׂẴvpeB͂āA
// ppInstance ɕԂ܂B oȂꍇ́A\bh WBEM_E_NOT_FOUND Ԃ܂B
// bugbug: IȃCX^X́HHH  قɉ\ȃtÓH

STDMETHODIMP [!output CLASS_NAME]::GetInstanceByPath (
													/*in*/CComBSTR bstrPath,
													/*out*/IWbemClassObject ** ppInstance )
													
{
		HRESULT hr = WBEM_E_FAILED;				  
		
		[!if IS_COMPOUND_KEY]
		ULONG ulPathTest = WBEMPATH_INFO_IS_INST_REF | WBEMPATH_INFO_IS_COMPOUND;
		[!else]
		[!if IS_SINGLETON]
		ULONG ulPathTest = WBEMPATH_INFO_IS_INST_REF | WBEMPATH_INFO_CONTAINS_SINGLETON;
		[!else]
		ULONG ulPathTest = WBEMPATH_INFO_IS_INST_REF;
		[!endif]
		[!endif]
		
		if (FAILED(m_pHelper->CheckInstancePath(m_pPathFactory,
												bstrPath,
												CComBSTR(s_pMyClassName),
												ulPathTest)))
		{
			//pXɍ\G[邩A^ꂽNX̃pX܂B
			return WBEM_E_INVALID_PARAMETER; 
		}			
		
		[!if IS_SINGLETON]
		//[!output WMICLASSNAME] ̓VOg IuWFNgłBCX^XʂKv͂܂B
	//: CX^X݂Ȃꍇ́A WMI ɒʐM邽߂Ɏ̍sRgƂĂ:
		//return WBEM_E_NOT_FOUND;
		[!else]
		//pX p[T[ IuWFNg擾܂:
		CComPtr<IWbemPath>pPath;
		hr = m_pPathFactory->CreateInstance(NULL,
												IID_IWbemPath,
												(void **) &pPath);
		if (FAILED(hr))
		{
			return WBEM_E_FAILED;
		}
		
		hr = pPath->SetText(WBEMPATH_CREATE_ACCEPT_ALL,
									bstrPath);

		CComPtr<IWbemPathKeyList> pIKeyList;
		hr = pPath->GetKeyList(&pIKeyList);
		if (FAILED(hr))
		{
			return hr;
		}
		unsigned long ulNumKeys;
		hr = pIKeyList->GetCount(&ulNumKeys);

		//L[vpeB̒l擾܂B
		unsigned long uKeyNameBufferSize = bstrPath.Length() + 1;
		WCHAR  * wKeyName = new WCHAR[uKeyNameBufferSize];
		if (NULL == wKeyName)
		{
			return WBEM_E_OUT_OF_MEMORY;
		}
		CComVariant vValue;		
		unsigned long ulApparentCimType;
		for (unsigned long i = 0; i < ulNumKeys; i++)
		{			
			hr = pIKeyList->GetKey2(i, 0L, &uKeyNameBufferSize, 
									wKeyName, &vValue, &ulApparentCimType);			
			//TODO:Ŏg߂ vValue ۑ܂B
		}

		delete[] wKeyName;
		
		//TODO: vIuWFNgo邽߂ɓ̃f[^ \[XĂB
		//vꂽL[̒lȂꍇ́A 
		//WBEM_E_NOT_FOUND Ԃ܂B
		[!endif]
	   
		//VCX^X𐶐܂B
		CComPtr<IWbemClassObject> pNewInst;
		hr = m_pClass->SpawnInstance(0, &pNewInst);
		if(FAILED(hr))
		{
			return hr;
		}
		CComVariant var;

		//TODO: VCX^X̃vpeBvIuWFNgœ͂ĂBB
		[!if CLASS_SPECIFIED]
		[!output POPULATE_INSTANCE]			
		[!else]
		//:
		//var.ChangeType(VT_BSTR);
		//var = <value>; //ɓK؂Ȓl͂ĂB
		//hr = pNewInst->Put(CComBSTR(pMyProperty), 0, &var, 0);
		//var.Clear();		
		[!endif]

		pNewInst.CopyTo(ppInstance);

		return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vc7\vcwiz\classwiz\atl\instance\templates\1033\wmiprov.cpp ===
// [!output IMPL_FILE] : Implementation of [!output CLASS_NAME]
#include "stdafx.h"
#include "[!output PROJECT_NAME].h"
#include "[!output HEADER_FILE]"


/////////////////////////////////////////////////////////////////////////////
// [!output CLASS_NAME]

//////////////////////////////////////////////////////////////////////////////
// Class, property and method names

// IMPORTANT: the strings defined below are not localizable

[!if CLASS_SPECIFIED]
const static WCHAR * s_pMyClassName = L"[!output WMICLASSNAME]"; //class name

//properies:
[!output PROPERTY_DEFINITIONS]

//methods:
[!output METHOD_DEFINITIONS]

[!else]
//TODO: define provided class name, e.g.:
const static WCHAR * s_pMyClassName = L"MyClassName"; 

//TODO: define property names of the provided class, e.g.:
//const static WCHAR * pMyProperty = L"MyProperty";

//TODO: define method names of the provided class, e.g.:
//const static WCHAR * pMyMethod = L"MyMethod";
[!endif]

//////////////////////////////////////////////////////////////////////////////
// [!output CLASS_NAME]::Initialize
//Refer to MSDN documentation for IWbemProviderInit::Initialize()
//for details about implementing this method

STDMETHODIMP [!output CLASS_NAME]::Initialize(LPWSTR pszUser,	
									  LONG lFlags,
									  LPWSTR pszNamespace,
									  LPWSTR pszLocale,
									  IWbemServices *pNamespace,
							 		  IWbemContext *pCtx,
									  IWbemProviderInitSink *pInitSink) 
{

	if ( NULL == pNamespace || NULL == pInitSink) 
	{
        return WBEM_E_INVALID_PARAMETER;
	}

  	//cache IWbemServices pointer 
	//Note: m_pNamespace is a smart pointer, so it AddRef()'s automatically
	m_pNamespace = pNamespace;
				
	//cache provided class definition
	//NOTE: the code below assumes that your class definition doesn't change while
	//your provider is running.  If this is not true, you should implement a consumer
	//for class modification ans class deletion events. Refer to WMI documentation
	//for event consumers on MSDN.
	
    HRESULT hr = m_pNamespace->GetObject(CComBSTR(s_pMyClassName), 
											0, 
											pCtx, 	//passing IWbemContext pointer to prevent deadlocks
											&m_pClass, 
											NULL);
    if(FAILED(hr))
	{
        return WBEM_E_FAILED;
	}    
	
	//cache path parser class factory
	hr = CoGetClassObject(CLSID_WbemDefPath, 
							CLSCTX_INPROC_SERVER, 
							NULL,
							IID_IClassFactory,
							(void **) &m_pPathFactory);
	if (FAILED(hr))
	{
		return WBEM_E_FAILED;
	}

	//create helper object
	m_pHelper = new CInstanceProviderHelper(pNamespace, pCtx);

	//NOTE: to report a detailed error or status to WMI, you can call 
	//ConstructErrorObject() on m_pHelper anywhere in your provider

    pInitSink->SetStatus(WBEM_S_INITIALIZED,0);
    return WBEM_S_NO_ERROR;
}

//////////////////////////////////////////////////////////////////////////////
// [!output CLASS_NAME]::GetObjectAsync
// Refer to MSDN documentation for IWbemServices::GetObjectAsync()
// for details about implementing this method

STDMETHODIMP [!output CLASS_NAME]::GetObjectAsync( 
							 const BSTR bstrObjectPath,
							 long lFlags,
							 IWbemContext  *pCtx,
							 IWbemObjectSink  *pResponseHandler)
{
    
	//bugbug: per-property retrieval?
    [!if SUPPORT_GET ]
	if (NULL == pResponseHandler)
	{
	     return WBEM_E_INVALID_PARAMETER;
	}

	CComPtr<IWbemClassObject> pInstance;
	HRESULT hr = GetInstanceByPath(bstrObjectPath, &pInstance);
	if (FAILED (hr))
	{
		return hr;
	}
			   
   	//if all is well, return the object to WMI and indicate success:
    pResponseHandler->Indicate (1, &(pInstance.p)); 
	pResponseHandler->SetStatus(0, WBEM_S_NO_ERROR, NULL, NULL);

    return WBEM_S_NO_ERROR;
	[!else]
    return WBEM_E_PROVIDER_NOT_CAPABLE;
	[!endif]
}

//////////////////////////////////////////////////////////////////////////////
// [!output CLASS_NAME]::PutInstanceAsync()
// Refer to MSDN documentation for IWbemServices::PutInstanceAsync()
// for details about implementing this method

STDMETHODIMP [!output CLASS_NAME]::PutInstanceAsync( 
							IWbemClassObject  *pInst,
							long lFlags,
							IWbemContext  *pCtx,
							IWbemObjectSink  *pResponseHandler)
{
   
	[!if SUPPORT_PUT ]
	if ( NULL == pResponseHandler || NULL == pInst)
	{
        return WBEM_E_INVALID_PARAMETER;
	}
	//TODO: examine possible flag values: WBEM_FLAG_UPDATE_ONLY, 
	//WBEM_FLAG_CREATE_ONLY and WBEM_FLAG_CREATE_OR_UPDATE
	//and choose the level of support you need and return WBEM_E_PROVIDER_NOT_CAPABLE
	//for flag values you do not support

	//TODO: if you are planning to support partial updates, examine pCtx 
	//for "__PUT_EXTENSIONS" and other relevant system context values
	//and update your instance data appropriately
	
	//TODO: handle the instance update or creation here			
	
	pResponseHandler->SetStatus(0, WBEM_S_NO_ERROR, NULL, NULL);
	return WBEM_S_NO_ERROR;
	[!else]
	return WBEM_E_PROVIDER_NOT_CAPABLE;
	[!endif]
}


//////////////////////////////////////////////////////////////////////////////
// [!output CLASS_NAME]::DeleteInstanceAsync()
// Refer to MSDN help for IWbemServices::DeleteInstanceAsync()
// for details about implementing this method

STDMETHODIMP [!output CLASS_NAME]::DeleteInstanceAsync( 
							const BSTR ObjectPath,
							long lFlags,
							IWbemContext  *pCtx,
							IWbemObjectSink  *pResponseHandler)
{
	//To implement this method, an instance provider parses the object path string 
	//specified in the strObjectPath parameter and attempts to locate the corresponding 
	//instance and delete it.
	[!if SUPPORT_DELETE ]

	if (NULL == pResponseHandler)
	{
		return WBEM_E_INVALID_PARAMETER;
	}
    
	[!if IS_COMPOUND_KEY]
	ULONG ulPathTest = WBEMPATH_INFO_IS_INST_REF | WBEMPATH_INFO_IS_COMPOUND;
	[!else]
	[!if IS_SINGLETON]
	ULONG ulPathTest = WBEMPATH_INFO_IS_INST_REF | WBEMPATH_INFO_CONTAINS_SINGLETON;
	[!else]
	ULONG ulPathTest = WBEMPATH_INFO_IS_INST_REF;
	[!endif]
	[!endif]
		
	if (FAILED(m_pHelper->CheckInstancePath(m_pPathFactory,
											ObjectPath,
											CComBSTR(s_pMyClassName),
											ulPathTest)) )
	{
		//syntax error in path or path incorrect for class provided
		return WBEM_E_INVALID_PARAMETER; 
	}			
	
	[!if IS_SINGLETON]
	//NOTE: [!output WMICLASSNAME] is a singleton object. No need to identify the instance.
	//NOTE: If the instance is not present, uncomment the following line to communicate this back to WMI:
	//return WBEM_E_NOT_FOUND;
	[!else]
	//Create path parser object
	CComPtr<IWbemPath>pPath;
	HRESULT hr = m_pPathFactory->CreateInstance(NULL,
												IID_IWbemPath,
												(void **) &pPath);
	if (FAILED(hr))
	{
		return WBEM_E_FAILED;
	}

	hr = pPath->SetText(WBEMPATH_CREATE_ACCEPT_ALL,	ObjectPath);
	
	CComPtr<IWbemPathKeyList> pIKeyList;
	hr = pPath->GetKeyList(&pIKeyList);
	if (FAILED(hr))
	{
		return hr;
	}
	
	unsigned long ulNumKeys;
	hr = pIKeyList->GetCount(&ulNumKeys);

	//Get values of key properties
	unsigned long uKeyNameBufferSize = CComBSTR(ObjectPath).Length() + 1;
	WCHAR * wKeyName = new WCHAR[uKeyNameBufferSize];
	if (NULL == wKeyName)
	{
		return WBEM_E_OUT_OF_MEMORY;
	}
	CComVariant vValue;
	unsigned long ulApparentCimType;
	for (unsigned long i = 0; i < ulNumKeys; i++)
	{			
		hr = pIKeyList->GetKey2(i, 0L, &uKeyNameBufferSize, 
								wKeyName, &vValue, &ulApparentCimType);			
		//TODO: save vValue for later use
	}
	delete[] wKeyName;

	//TODO: iterate through your data source to find the matching object and delete it.
	//NOTE: If you don't find an object that matches key values indicated in the path,
	//uncomment the following line to communicate this back to WMI:
	//return WBEM_E_NOT_FOUND;
	[!endif]	

	pResponseHandler->SetStatus(0, WBEM_S_NO_ERROR, NULL, NULL);	
    return WBEM_S_NO_ERROR;
	
	[!else]
	return WBEM_E_PROVIDER_NOT_CAPABLE;
	[!endif]
}


//////////////////////////////////////////////////////////////////////////////
// [!output CLASS_NAME]::CreateInstanceEnumAsync()
// Refer to MSDN documentation for IWbemServices::CreateInstanceEnumAsync()
// for details about implementing this method

STDMETHODIMP [!output CLASS_NAME]::CreateInstanceEnumAsync( 
							const BSTR Class,
							long lFlags,
							IWbemContext  *pCtx,
							IWbemObjectSink  *pResponseHandler)
{
	

	//NOTE: It is important to note that the instance provider has acquired a thread from WMI 
	//to perform these operations. It may be desirable to call the sink AddRef() method and create 
	//another thread for delivering the objects in the result set. 
	//This strategy allows the current thread to return to WMI without depleting the thread pool. 
	//Whether the provider chooses the single thread design over the dual thread design depends on how 
	//long the provider plans on using the WMI thread.

	[!if SUPPORT_ENUMERATE ]
	if (NULL == pResponseHandler)
	{
	    return WBEM_E_INVALID_PARAMETER;
	}

	HRESULT hr = WBEM_S_NO_ERROR;
	
	[!if IS_SINGLETON]
	// Prepare an empty object to receive the instance data
    CComPtr<IWbemClassObject> pNewInst;
    hr = m_pClass->SpawnInstance(0, &pNewInst);
		
	CComVariant var;
	[!if CLASS_SPECIFIED]
	[!output POPULATE_INSTANCE]
	[!else]
	//TODO: populate the instance with properties, e.g.:
	//CComVariant var;
	//var.ChangeType(VT_BSTR);
	//var = <value>;  //put appropriate value here
	//hr = pNewInst->Put(CComBSTR(pMyProperty), 0, &var, 0);
	//var.Clear();
	[!endif]
		
	// Deliver the class to WMI.
    pResponseHandler->Indicate(1, &(pNewInst.p));
	[!else]
    // Loop through the private source and create each instance
	//while (<there's more instances>)
    {
		// Prepare an empty object to receive the class definition.
        CComPtr<IWbemClassObject> pNewInst;
        hr = m_pClass->SpawnInstance(0, &pNewInst);
		if (FAILED(hr))
		{	
			//TODO: uncomment the line below once the loop condition is in place
			//break;
		}
		
		CComVariant var;
		[!if CLASS_SPECIFIED]
		[!output POPULATE_INSTANCE]
		[!else]
		//TODO: populate the instance with properties, e.g.:
		//CComVariant var;
		//var.ChangeType(VT_BSTR);
		//var = <value>;  //put appropriate value here
		//hr = pNewInst->Put(CComBSTR(pMyProperty), 0, &var, 0);
		//var.Clear();
		[!endif]
		
		// Deliver the class to WMI.
        pResponseHandler->Indicate(1, &(pNewInst.p));
    }  	
	[!endif]
	pResponseHandler->SetStatus(0, hr, NULL, NULL);
   	return WBEM_S_NO_ERROR;
	[!else]
	return WBEM_E_PROVIDER_NOT_CAPABLE;
	[!endif]
}


//////////////////////////////////////////////////////////////////////////////
//[!output CLASS_NAME]::ExecQueryAsync()
// Refer to MSDN documentation for IWbemServices::ExecQueryAsync()
// for details about implementing this method

STDMETHODIMP [!output CLASS_NAME]::ExecQueryAsync( 
							const BSTR QueryLanguage,
							const BSTR Query,
							long lFlags,
							IWbemContext  *pCtx,
							IWbemObjectSink  *pResponseHandler)
{
	
	
   	// Instance providers have the option of supporting query processing or relying on WMI 
	// for that service. To support queries, an instance provider must be capable of parsing 
	// simple Structured Query Language (SQL) statements, executing the requested query, 
	// and delivering the result set objects to the requester's sink. 
	
	//TODO: put your query processing code here
	
	//pResponseHandler->SetStatus(0, WBEM_S_NO_ERROR, NULL, NULL);
	// return WBEM_S_NO_ERROR;

	return WBEM_E_PROVIDER_NOT_CAPABLE;
	
}

[!if PROVIDE_METHODS ]

//////////////////////////////////////////////////////////////////////////////
// [!output CLASS_NAME]::ExecMethodAsync()
// Refer to MSDN documentation for IWbemServices::ExecMethodAsync()
// for details about implementing this method

STDMETHODIMP [!output CLASS_NAME]::ExecMethodAsync( 
							const BSTR strObjectPath,
							const BSTR strMethodName,
							long lFlags,
							IWbemContext  *pCtx,
							IWbemClassObject  *pInParams,
							IWbemObjectSink  *pResponseHandler)
{
	

	[!if CLASS_SPECIFIED]
	[!if  !HAS_IMPL_METHODS]	
	//[!output WMICLASSNAME] has no implemented methods	
	return WBEM_E_NOT_SUPPORTED;
	[!else]
	HRESULT hr = WBEM_E_FAILED;	
    if (NULL == pResponseHandler)
	{
        return WBEM_E_INVALID_PARAMETER;
	}	
	[!output EXEC_METHOD_BODY]
	[!endif]
	[!else]
	
	//Check that class name in the path is correct.
	//Get path parser object:
	CComPtr<IWbemPath>pPath;
	HRESULT hr = m_pPathFactory->CreateInstance(NULL,
												IID_IWbemPath,
												(void **) &pPath);
	if (FAILED(hr))
	{
		return WBEM_E_FAILED;
	}

	HRESULT hr = pPath->SetText(WBEMPATH_CREATE_ACCEPT_ALL, strObjectPath);
	long nPathLen = CComBSTR(strObjectPath).Length();
	unsigned long ulBufLen = nPathLen + 1;
	WCHAR * wClass = new WCHAR[nPathLen];
	if (NULL == wClass)
	{
		return WBEM_E_OUT_OF_MEMORY;
	}
	pPath->GetClassName(&ulBufLen, wClass);
	if ( _wcsicmp(s_pMyClassName, wClass))
	{
		delete[] wClass;
		return WBEM_E_INVALID_PARAMETER;
	}
	delete[] wClass;
	//TODO: compare requested method name with methods of your class
	//if (!_wcsicmp (strMethodName, pMyNonStaticMethod))
	{
		CComVariant var;

		//Get input arguments:
		//TODO: if the method has input arguments, they will be passed as properties of
		//the pInParams object. The commented line below demonstrates how to extract these:
		//hr = pInParams->Get(CComBSTR("InputArgument1"), 0, &var, NULL, NULL);
		//TODO: save input parameter value
		var.Clear();		
		
		//parse path to find instance for method execution: for a non-static method
		CComPtr<IWbemPathKeyList> pIKeyList;
		hr = pPath->GetKeyList(&pIKeyList);
		if (FAILED(hr))
		{
			return WBEM_E_INVALID_PARAMETER;
		}
		unsigned long ulNumKeys;
		hr = pIKeyList->GetCount(&ulNumKeys);
		//Get values of key properties:
		unsigned long uKeyNameBufferSize = nPathLen + 1;
		WCHAR  * wKeyName = new WCHAR[uKeyNameBufferSize];
		if (NULL == wKeyName)
		{
			return WBEM_E_OUT_OF_MEMORY;
		}
		CComVariant vValue;
		unsigned long ulApparentCimType;
		for (unsigned long i = 0; i < ulNumKeys; i++)
		{
			hr = pIKeyList->GetKey2(i, 0L, &uKeyNameBufferSize,
									wKeyName, &vValue, &ulApparentCimType);
			//TODO: save vValue for later use
		}
		delete[] wKeyName;
	
		//TODO: iterate through your data source to find the matching object
		
		//TODO: add code to execute the method here
		//get output parameters class
		CComPtr<IWbemClassObject> pOutClass;
		hr = m_pClass->GetMethod(CComBSTR("Method1"), 0, NULL, &pOutClass);
		CComPtr<IWbemClassObject> pOutParams;
		pOutClass->SpawnInstance(0, &pOutParams);
		//TODO: create output parameters by filling properties
		//of pOutParams class. For example:

		//var.ChangeType(VT_BSTR);
		//fill var with appropriate value
		//hr = pOutParams->Put(CComBSTR("MyOutputParameter"), 0, &var, 0);
		//var.Clear();
		//var.ChangeType(VT_I2);
		//fill var with appropriate value
		//hr = pOutParams->Put(CComBSTR("ReturnValue"), 0, &var, 0);
		//var.Clear();
		// Send the output object back to the client via the sink
		hr = pResponseHandler->Indicate(1, &(pOutParams.p));
		
		pResponseHandler->SetStatus(0, WBEM_S_NO_ERROR, NULL, NULL);
		return WBEM_S_NO_ERROR;
	}
	
	//method name not recognized
	return WBEM_E_INVALID_PARAMETER;
	
	
	[!endif]	
}
[!endif]



//////////////////////////////////////////////////////////////////////////////
// [!output CLASS_NAME]::GetInstanceByPath() parses the path to find out required key values,
// then searhces the internal store for an object with matching key values. If such
// an object is found, the method spawns a new instance, fills all properties and
// returns it in ppInstance. If not, the method returns WBEM_E_NOT_FOUND.
// bugbug: partial-instance provision???  other possible flags?

STDMETHODIMP [!output CLASS_NAME]::GetInstanceByPath (
													/*in*/CComBSTR bstrPath,
													/*out*/IWbemClassObject ** ppInstance )
													
{
		HRESULT hr = WBEM_E_FAILED;				  
		
		[!if IS_COMPOUND_KEY]
		ULONG ulPathTest = WBEMPATH_INFO_IS_INST_REF | WBEMPATH_INFO_IS_COMPOUND;
		[!else]
		[!if IS_SINGLETON]
		ULONG ulPathTest = WBEMPATH_INFO_IS_INST_REF | WBEMPATH_INFO_CONTAINS_SINGLETON;
		[!else]
		ULONG ulPathTest = WBEMPATH_INFO_IS_INST_REF;
		[!endif]
		[!endif]
		
		if (FAILED(m_pHelper->CheckInstancePath(m_pPathFactory,
												bstrPath,
												CComBSTR(s_pMyClassName),
												ulPathTest)))
		{
			//syntax error in path or path incorrect for class provided
			return WBEM_E_INVALID_PARAMETER; 
		}			
		
		[!if IS_SINGLETON]
		//[!output WMICLASSNAME] is a singleton object. No need to identify the instance.
		//NOTE: If the instance is not present, uncomment the following line to communicate this back to WMI:
		//return WBEM_E_NOT_FOUND;
		[!else]
		//Get path parser object:
		CComPtr<IWbemPath>pPath;
		hr = m_pPathFactory->CreateInstance(NULL,
												IID_IWbemPath,
												(void **) &pPath);
		if (FAILED(hr))
		{
			return WBEM_E_FAILED;
		}
		
		hr = pPath->SetText(WBEMPATH_CREATE_ACCEPT_ALL,
									bstrPath);

		CComPtr<IWbemPathKeyList> pIKeyList;
		hr = pPath->GetKeyList(&pIKeyList);
		if (FAILED(hr))
		{
			return hr;
		}
		unsigned long ulNumKeys;
		hr = pIKeyList->GetCount(&ulNumKeys);

		//Get values of key properties
		unsigned long uKeyNameBufferSize = bstrPath.Length() + 1;
		WCHAR  * wKeyName = new WCHAR[uKeyNameBufferSize];
		if (NULL == wKeyName)
		{
			return WBEM_E_OUT_OF_MEMORY;
		}
		CComVariant vValue;		
		unsigned long ulApparentCimType;
		for (unsigned long i = 0; i < ulNumKeys; i++)
		{			
			hr = pIKeyList->GetKey2(i, 0L, &uKeyNameBufferSize, 
									wKeyName, &vValue, &ulApparentCimType);			
			//TODO: save vValue for later use
		}

		delete[] wKeyName;
		
		//TODO: search your internal data source to find the matching object.
		//If no objects with required key values can be found, 
		//return WBEM_E_NOT_FOUND.
		[!endif]
	   
		//spawn new instance
		CComPtr<IWbemClassObject> pNewInst;
		hr = m_pClass->SpawnInstance(0, &pNewInst);
		if(FAILED(hr))
		{
			return hr;
		}
		CComVariant var;

		//TODO: fill the properties of the new instance with those of the matching internal object
		[!if CLASS_SPECIFIED]
		[!output POPULATE_INSTANCE]			
		[!else]
		//Example:
		//var.ChangeType(VT_BSTR);
		//var = <value>; //put appropriate value here
		//hr = pNewInst->Put(CComBSTR(pMyProperty), 0, &var, 0);
		//var.Clear();		
		[!endif]

		pNewInst.CopyTo(ppInstance);

		return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vc7\vcwiz\classwiz\atl\instance\templates\1033\wmiprov.h ===
[!if  !INSTANCE]
//error: instance provider header template invoked for wrong provider type
[!else]
// [!output HEADER_FILE] : Declaration of the [!output CLASS_NAME]

#pragma once
#include "resource.h"       // main symbols

#include <wbemidl.h>
#include <wmiatlprov.h>
#include <wmiutils.h>	//path parser

//////////////////////////////////////////////////////////////////////////////
// Class, property  and method names: defined in [!output IMPL_FILE]

extern const WCHAR * s_pMyClassName;	//class name

[!if CLASS_SPECIFIED]
//properties:
[!output PROPERTY_DECLARATIONS]

//methods:
[!output METHOD_DECLARATIONS]
[!else]
//TODO: declare property names of the provided class, e.g.:
//extern const WCHAR * pMyProperty;

//TODO: declare method names of the provided class, e.g.:
//extern const WCHAR * pMyMethod;
[!endif]

[!if ATTRIBUTED]
[
	coclass,
[!if THREADING_APARTMENT]
	threading("apartment"),
[!endif]
[!if THREADING_BOTH]
	threading("both"),
[!endif]
[!if THREADING_FREE]
	threading("free"),
[!endif]
	aggregatable("never"),
	vi_progid("[!output VERSION_INDEPENDENT_PROGID]"),
	progid("[!output PROGID]"),
	version(1.0),
	uuid("[!output CLSID_REGISTRY_FORMAT]"),
	helpstring("[!output TYPE_NAME]")
]
[!endif]
/////////////////////////////////////////////////////////////////////////////
// [!output CLASS_NAME]

class ATL_NO_VTABLE [!output CLASS_NAME] : 
					[!if !ATTRIBUTED]
					[!if THREADING_APARTMENT]
						public CComObjectRootEx<CComSingleThreadModel>,
					[!endif]
					[!if THREADING_BOTH]
						public CComObjectRootEx<CComMultiThreadModel>,
					[!endif]
					[!if THREADING_FREE]
						public CComObjectRootEx<CComMultiThreadModel>,
					[!endif]
						public CComCoClass<[!output CLASS_NAME], &CLSID_[!output COCLASS]>,
					[!endif]
						public IWbemInstProviderImpl
{
	
	CComPtr<IWbemServices>  m_pNamespace; 	//cached IWbemServices pointer
	CComPtr<IWbemClassObject> m_pClass;		//cached provided class definition	   	
	CComPtr<IWbemClassObject> m_pErrorObject;//cached error object class definition pointer
	CComPtr<IClassFactory> m_pPathFactory;	 //cached pointer to path parser's class factory

	CInstanceProviderHelper * m_pHelper;
	
	STDMETHODIMP GetInstanceByPath (CComBSTR bstrPath,
									IWbemClassObject ** ppInstance );

  public:
	[!output CLASS_NAME]()
	{
		m_pHelper = NULL;					
	}

	~[!output CLASS_NAME]()
	{
	    if (NULL != m_pHelper)
		{
			delete m_pHelper;
		}
		//interface pointer data members are smart and get released automatically
	}
	
	[!if !ATTRIBUTED]
	DECLARE_REGISTRY_RESOURCEID(IDR_[!output UPPER_SHORT_NAME])

	DECLARE_NOT_AGGREGATABLE([!output CLASS_NAME])

	BEGIN_COM_MAP([!output CLASS_NAME])
		COM_INTERFACE_ENTRY(IWbemServices)
		COM_INTERFACE_ENTRY(IWbemProviderInit)
	END_COM_MAP()
	[!endif]

	//IWbemProviderInit
	HRESULT STDMETHODCALLTYPE Initialize( 
										LPWSTR pszUser,
										LONG lFlags,
										LPWSTR pszNamespace,
										LPWSTR pszLocale,
										IWbemServices *pNamespace,
										IWbemContext *pCtx,
										IWbemProviderInitSink *pInitSink);

	//IWbemServices
	HRESULT STDMETHODCALLTYPE GetObjectAsync(
										const BSTR ObjectPath,
										long lFlags,
										IWbemContext __RPC_FAR *pCtx,
										IWbemObjectSink __RPC_FAR *pResponseHandler);


	HRESULT STDMETHODCALLTYPE DeleteInstanceAsync(
										const BSTR ObjectPath,
										long lFlags,
										IWbemContext __RPC_FAR *pCtx,
										IWbemObjectSink __RPC_FAR *pResponseHandler);


	HRESULT STDMETHODCALLTYPE PutInstanceAsync(
										IWbemClassObject __RPC_FAR *pInst,
										long lFlags,
										IWbemContext __RPC_FAR *pCtx,
										IWbemObjectSink __RPC_FAR *pResponseHandler);


	HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync( 
										const BSTR Class,
										long lFlags,
										IWbemContext __RPC_FAR *pCtx,
										IWbemObjectSink __RPC_FAR *pResponseHandler);

	HRESULT STDMETHODCALLTYPE ExecQueryAsync( 
										const BSTR QueryLanguage,
										const BSTR Query,
										long lFlags,
										IWbemContext __RPC_FAR *pCtx,
										IWbemObjectSink __RPC_FAR *pResponseHandler);

	[!if PROVIDE_METHODS]
	HRESULT STDMETHODCALLTYPE ExecMethodAsync( 
										const BSTR strObjectPath,
										const BSTR strMethodName,
										long lFlags,
										IWbemContext __RPC_FAR *pCtx,
										IWbemClassObject __RPC_FAR *pInParams,
										IWbemObjectSink __RPC_FAR *pResponseHandler);
	[!else]
	HRESULT STDMETHODCALLTYPE ExecMethodAsync( 
										const BSTR strObjectPath,
										const BSTR strMethodName,
										long lFlags,
										IWbemContext __RPC_FAR *pCtx,
										IWbemClassObject __RPC_FAR *pInParams,
										IWbemObjectSink __RPC_FAR *pResponseHandler) 
	{	
		//NOTE:	if you decide to provide methods, you should 
		//create your implementation of ExecMethodAsync()
		return WBEM_E_NOT_SUPPORTED;
	}
	[!endif]

};

[!if !ATTRIBUTED]
OBJECT_ENTRY_AUTO(__uuidof([!output COCLASS]), [!output CLASS_NAME])
[!endif]

[!endif]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vc7\vcwiz\classwiz\atl\instance\templates\1031\wmiprov.h ===
[!if  !INSTANCE]
//Fehler: Ereignisanbieter-Headervorlage wurde fr den falschen Anbietertyp aufgerufen.
[!else]
// [!output HEADER_FILE] : Deklaration von [!output CLASS_NAME]

#pragma once
#include "resource.h"       // Hauptsymbole

#include <wbemidl.h>
#include <wmiatlprov.h>
#include <wmiutils.h>	//Pfadparser

//////////////////////////////////////////////////////////////////////////////
// Klassen-, Eigenschaften- und Methodennamen: definiert in [!output IMPL_FILE]

extern const WCHAR * s_pMyClassName;	//Klassenname

[!if CLASS_SPECIFIED]
//Eigenschaften:
[!output PROPERTY_DECLARATIONS]

//Methoden:
[!output METHOD_DECLARATIONS]
[!else]
//Aktion: Deklarieren Sie die Eigenschaftennamen der angegebenen Klasse, z.B.:
//extern const WCHAR * pMyProperty;

//Aktion: Deklarieren Sie die Methodennamen der angegebenen Klasse, z.B.:
//extern const WCHAR * pMyMethod;
[!endif]

[!if ATTRIBUTED]
[
	coclass,
[!if THREADING_APARTMENT]
	threading("apartment"),
[!endif]
[!if THREADING_BOTH]
	threading("both"),
[!endif]
[!if THREADING_FREE]
	threading("free"),
[!endif]
	aggregatable("never"),
	vi_progid("[!output VERSION_INDEPENDENT_PROGID]"),
	progid("[!output PROGID]"),
	version(1.0),
	uuid("[!output CLSID_REGISTRY_FORMAT]"),
	helpstring("[!output TYPE_NAME]")
]
[!endif]
/////////////////////////////////////////////////////////////////////////////
// [!output CLASS_NAME]

class ATL_NO_VTABLE [!output CLASS_NAME] : 
					[!if !ATTRIBUTED]
					[!if THREADING_APARTMENT]
						public CComObjectRootEx<CComSingleThreadModel>,
					[!endif]
					[!if THREADING_BOTH]
						public CComObjectRootEx<CComMultiThreadModel>,
					[!endif]
					[!if THREADING_FREE]
						public CComObjectRootEx<CComMultiThreadModel>,
					[!endif]
						public CComCoClass<[!output CLASS_NAME], &CLSID_[!output COCLASS]>,
					[!endif]
						public IWbemInstProviderImpl
{
	
	CComPtr<IWbemServices>  m_pNamespace; 	//Zwischengespeicherter IWbemServices-Zeiger
	CComPtr<IWbemClassObject> m_pClass;	//Zwischengespeicherte angegebene Klassendefinition	   	
	CComPtr<IWbemClassObject> m_pErrorObject;//Zwischengespeicherter Klassendefinitionszeiger des Fehlerobjekts
	CComPtr<IClassFactory> m_pPathFactory;	 //Zwischengespeicherter Zeiger zur Klassenherstellung des Pfadparsers

	CInstanceProviderHelper * m_pHelper;
	
	STDMETHODIMP GetInstanceByPath (CComBSTR bstrPath,
									IWbemClassObject ** ppInstance );

  public:
	[!output CLASS_NAME]()
	{
		m_pHelper = NULL;					
	}

	~[!output CLASS_NAME]()
	{
	    if (NULL != m_pHelper)
		{
			delete m_pHelper;
		}
		//Schnittstellenzeiger-Datenmitglieder sind dynamisch und werden automatisch freigegeben
	}
	
	[!if !ATTRIBUTED]
	DECLARE_REGISTRY_RESOURCEID(IDR_[!output UPPER_SHORT_NAME])

	DECLARE_NOT_AGGREGATABLE([!output CLASS_NAME])

	BEGIN_COM_MAP([!output CLASS_NAME])
		COM_INTERFACE_ENTRY(IWbemServices)
		COM_INTERFACE_ENTRY(IWbemProviderInit)
	END_COM_MAP()
	[!endif]

	//IWbemProviderInit
	HRESULT STDMETHODCALLTYPE Initialize( 
										LPWSTR pszUser,
										LONG lFlags,
										LPWSTR pszNamespace,
										LPWSTR pszLocale,
										IWbemServices *pNamespace,
										IWbemContext *pCtx,
										IWbemProviderInitSink *pInitSink);

	//IWbemServices
	HRESULT STDMETHODCALLTYPE GetObjectAsync(
										const BSTR ObjectPath,
										long lFlags,
										IWbemContext __RPC_FAR *pCtx,
										IWbemObjectSink __RPC_FAR *pResponseHandler);


	HRESULT STDMETHODCALLTYPE DeleteInstanceAsync(
										const BSTR ObjectPath,
										long lFlags,
										IWbemContext __RPC_FAR *pCtx,
										IWbemObjectSink __RPC_FAR *pResponseHandler);


	HRESULT STDMETHODCALLTYPE PutInstanceAsync(
										IWbemClassObject __RPC_FAR *pInst,
										long lFlags,
										IWbemContext __RPC_FAR *pCtx,
										IWbemObjectSink __RPC_FAR *pResponseHandler);


	HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync( 
										const BSTR Class,
										long lFlags,
										IWbemContext __RPC_FAR *pCtx,
										IWbemObjectSink __RPC_FAR *pResponseHandler);

	HRESULT STDMETHODCALLTYPE ExecQueryAsync( 
										const BSTR QueryLanguage,
										const BSTR Query,
										long lFlags,
										IWbemContext __RPC_FAR *pCtx,
										IWbemObjectSink __RPC_FAR *pResponseHandler);

	[!if PROVIDE_METHODS]
	HRESULT STDMETHODCALLTYPE ExecMethodAsync( 
										const BSTR strObjectPath,
										const BSTR strMethodName,
										long lFlags,
										IWbemContext __RPC_FAR *pCtx,
										IWbemClassObject __RPC_FAR *pInParams,
										IWbemObjectSink __RPC_FAR *pResponseHandler);
	[!else]
	HRESULT STDMETHODCALLTYPE ExecMethodAsync( 
										const BSTR strObjectPath,
										const BSTR strMethodName,
										long lFlags,
										IWbemContext __RPC_FAR *pCtx,
										IWbemClassObject __RPC_FAR *pInParams,
										IWbemObjectSink __RPC_FAR *pResponseHandler) 
	{	
		//Hinweis: Wenn Sie Methoden anbieten, sollten Sie
		//eine Implementierung von ExecMethodAsync() erstellen
		return WBEM_E_NOT_SUPPORTED;
	}
	[!endif]

};

[!if !ATTRIBUTED]
OBJECT_ENTRY_AUTO(__uuidof([!output COCLASS]), [!output CLASS_NAME])
[!endif]

[!endif]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vside\fmstocks\fminstprov\classfactory.h ===
////////////////////////////////////////////////////////////////////////
//
//	ClassFactory.h
//
//	Module:	WMI high performance provider for F&M Stocks
//
//  This is the class factory implementation 
//
//  History:
//	a-vkanna      3-April-2000		Initial Version
//
//  Copyright (c) 2000 Microsoft Corporation
//
////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////
//
//	CClassFactory
//
//////////////////////////////////////////////////////////////

class CClassFactory : public IClassFactory
{
	protected:
		long	m_lRef;

	public:

		CClassFactory() : m_lRef(0) {}

		/************ IUNKNOWN METHODS ******************/
		STDMETHODIMP QueryInterface(/* [in]  */ REFIID riid, 
									/* [out] */ void** ppv);
		STDMETHODIMP_(ULONG) AddRef();
		STDMETHODIMP_(ULONG) Release();

		/*********** ICLASSFACTORY METHODS **************/
		STDMETHODIMP CreateInstance(
			/* [in] */ IUnknown* pUnknownOuter, 
			/* [in] */ REFIID iid, 
			/* [out] */ LPVOID *ppv);	

		STDMETHODIMP LockServer(
			/* [in] */ BOOL bLock);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vc7\vcwiz\classwiz\atl\instance\templates\1041\wmiprov.h ===
[!if  !INSTANCE]
//G[: Cxg voC_ wb_[ ev[g͊Ԉނ̃voC_Ăяo܂B
[!else]
// [!output HEADER_FILE] :  [!output CLASS_NAME] ̐錾B

#pragma once
#include "resource.h"       // C V|łB

#include <wbemidl.h>
#include <wmiatlprov.h>
#include <wmiutils.h>	//pX p[T[łB

//////////////////////////////////////////////////////////////////////////////
// NXAvpeBA\bhł: [!output IMPL_FILE] Œ`܂B

extern const WCHAR * s_pMyClassName;	//NXłB

[!if CLASS_SPECIFIED]
//vpeB:
[!output PROPERTY_DECLARATIONS]

//\bh:
[!output METHOD_DECLARATIONS]
[!else]
//TODO: ^ꂽNX̃vpeB錾ĂB:
//extern const WCHAR * pMyProperty;

//TODO: ^ꂽNX̃\bh錾ĂB:
//extern const WCHAR * pMyMethod;
[!endif]

[!if ATTRIBUTED]
[
	coclass,
[!if THREADING_APARTMENT]
	threading("apartment"),
[!endif]
[!if THREADING_BOTH]
	threading("both"),
[!endif]
[!if THREADING_FREE]
	threading("free"),
[!endif]
	aggregatable("never"),
	vi_progid("[!output VERSION_INDEPENDENT_PROGID]"),
	progid("[!output PROGID]"),
	version(1.0),
	uuid("[!output CLSID_REGISTRY_FORMAT]"),
	helpstring("[!output TYPE_NAME]")
]
[!endif]
/////////////////////////////////////////////////////////////////////////////
// [!output CLASS_NAME]

class ATL_NO_VTABLE [!output CLASS_NAME] : 
					[!if !ATTRIBUTED]
					[!if THREADING_APARTMENT]
						public CComObjectRootEx<CComSingleThreadModel>,
					[!endif]
					[!if THREADING_BOTH]
						public CComObjectRootEx<CComMultiThreadModel>,
					[!endif]
					[!if THREADING_FREE]
						public CComObjectRootEx<CComMultiThreadModel>,
					[!endif]
						public CComCoClass<[!output CLASS_NAME], &CLSID_[!output COCLASS]>,
					[!endif]
						public IWbemInstProviderImpl
{
	
	CComPtr<IWbemServices>  m_pNamespace; 	//LbVꂽ IWbemServices |C^łB
	CComPtr<IWbemClassObject> m_pClass;		//LbVꂽ^ꂽNX̒`łB  	
	CComPtr<IWbemClassObject> m_pErrorObject;//LbVꂽG[ IuWFNg NX̒`̃|C^łB
	CComPtr<IClassFactory> m_pPathFactory;	 //p[T[̃NX t@NgpX邽߂̃LbVꂽ|C^łB

	CInstanceProviderHelper * m_pHelper;
	
	STDMETHODIMP GetInstanceByPath (CComBSTR bstrPath,
									IWbemClassObject ** ppInstance );

  public:
	[!output CLASS_NAME]()
	{
		m_pHelper = NULL;					
	}

	~[!output CLASS_NAME]()
	{
	    if (NULL != m_pHelper)
		{
			delete m_pHelper;
		}
		//C^[tFCX |C^ f[^ o̓X}[gŎIɉ܂B
	}
	
	[!if !ATTRIBUTED]
	DECLARE_REGISTRY_RESOURCEID(IDR_[!output UPPER_SHORT_NAME])

	DECLARE_NOT_AGGREGATABLE([!output CLASS_NAME])

	BEGIN_COM_MAP([!output CLASS_NAME])
		COM_INTERFACE_ENTRY(IWbemServices)
		COM_INTERFACE_ENTRY(IWbemProviderInit)
	END_COM_MAP()
	[!endif]

	//IWbemProviderInit
	HRESULT STDMETHODCALLTYPE Initialize( 
										LPWSTR pszUser,
										LONG lFlags,
										LPWSTR pszNamespace,
										LPWSTR pszLocale,
										IWbemServices *pNamespace,
										IWbemContext *pCtx,
										IWbemProviderInitSink *pInitSink);

	//IWbemServices
	HRESULT STDMETHODCALLTYPE GetObjectAsync(
										const BSTR ObjectPath,
										long lFlags,
										IWbemContext __RPC_FAR *pCtx,
										IWbemObjectSink __RPC_FAR *pResponseHandler);


	HRESULT STDMETHODCALLTYPE DeleteInstanceAsync(
										const BSTR ObjectPath,
										long lFlags,
										IWbemContext __RPC_FAR *pCtx,
										IWbemObjectSink __RPC_FAR *pResponseHandler);


	HRESULT STDMETHODCALLTYPE PutInstanceAsync(
										IWbemClassObject __RPC_FAR *pInst,
										long lFlags,
										IWbemContext __RPC_FAR *pCtx,
										IWbemObjectSink __RPC_FAR *pResponseHandler);


	HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync( 
										const BSTR Class,
										long lFlags,
										IWbemContext __RPC_FAR *pCtx,
										IWbemObjectSink __RPC_FAR *pResponseHandler);

	HRESULT STDMETHODCALLTYPE ExecQueryAsync( 
										const BSTR QueryLanguage,
										const BSTR Query,
										long lFlags,
										IWbemContext __RPC_FAR *pCtx,
										IWbemObjectSink __RPC_FAR *pResponseHandler);

	[!if PROVIDE_METHODS]
	HRESULT STDMETHODCALLTYPE ExecMethodAsync( 
										const BSTR strObjectPath,
										const BSTR strMethodName,
										long lFlags,
										IWbemContext __RPC_FAR *pCtx,
										IWbemClassObject __RPC_FAR *pInParams,
										IWbemObjectSink __RPC_FAR *pResponseHandler);
	[!else]
	HRESULT STDMETHODCALLTYPE ExecMethodAsync( 
										const BSTR strObjectPath,
										const BSTR strMethodName,
										long lFlags,
										IWbemContext __RPC_FAR *pCtx,
										IWbemClassObject __RPC_FAR *pInParams,
										IWbemObjectSink __RPC_FAR *pResponseHandler) 
	{	
		//: \bh^ꍇ́A
		//ExecMethodAsync() ̃Cvg쐬Kv܂B
		return WBEM_E_NOT_SUPPORTED;
	}
	[!endif]

};

[!if !ATTRIBUTED]
OBJECT_ENTRY_AUTO(__uuidof([!output COCLASS]), [!output CLASS_NAME])
[!endif]

[!endif]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vside\fmstocks\fminstprov\classfactory.cpp ===
////////////////////////////////////////////////////////////////////////
//
//	ClassFactory.cpp
//
//	Module:	WMI Instance provider for F&M Stocks
//
//  This is the class factory implementation 
//
//  History:
//	a-vkanna      3-April-2000		Initial Version
//
//  Copyright (c) 2000 Microsoft Corporation
//
////////////////////////////////////////////////////////////////////////

#include <windows.h>

#include "ClassFactory.h"
#include "FMInstProvider.h"

extern long g_lObjects;
extern long g_lLocks;

//////////////////////////////////////////////////////////////
//
//
//	CClassFactory
//
//
//////////////////////////////////////////////////////////////

STDMETHODIMP CClassFactory::QueryInterface(REFIID riid, void** ppv)
//////////////////////////////////////////////////////////////
//
//	Standard QueryInterface
//
//	Parameters:
//		riid	- the ID of the requested interface
//		ppv		- a pointer to the interface pointer
//
//////////////////////////////////////////////////////////////
{
    if(riid == IID_IUnknown)
        *ppv = (LPVOID)(IUnknown*)this;
    else if(riid == IID_IClassFactory)
        *ppv = (LPVOID)(IClassFactory*)this;
	else return E_NOINTERFACE;

	((IUnknown*)*ppv)->AddRef();
	return S_OK;
}

STDMETHODIMP_(ULONG) CClassFactory::AddRef()
//////////////////////////////////////////////////////////////
//
//	Standard COM AddRef
//
//////////////////////////////////////////////////////////////
{
    return InterlockedIncrement(&m_lRef);
}

STDMETHODIMP_(ULONG) CClassFactory::Release()
//////////////////////////////////////////////////////////////
//
//	Standard COM Release
//
//////////////////////////////////////////////////////////////
{
    long lRef = InterlockedDecrement(&m_lRef);
    if(lRef == 0)
        delete this;

    return lRef;
}

STDMETHODIMP CClassFactory::CreateInstance(
		/* [in] */ IUnknown* pUnknownOuter, 
		/* [in] */ REFIID iid, 
		/* [out] */ LPVOID *ppv)
//////////////////////////////////////////////////////////////
//
//	Standard COM CreateInstance
//
//////////////////////////////////////////////////////////////
{
	HRESULT hRes;
	*ppv = NULL;

	// We do not support aggregation
	if (pUnknownOuter)
		return CLASS_E_NOAGGREGATION;

	// Create the provider object
	CFMInstProvider *   pProvider = NULL;
	pProvider = new CFMInstProvider();

	if (!pProvider)
		return E_OUTOFMEMORY;

	// Retrieve the requested interface
	hRes = pProvider->QueryInterface(iid, ppv);
	if (FAILED(hRes))
	{
		delete pProvider;
		return hRes;
	}

	return S_OK;
}

STDMETHODIMP CClassFactory::LockServer(
		/* [in] */ BOOL bLock)
//////////////////////////////////////////////////////////////
//
//	Standard COM LockServer
//
//////////////////////////////////////////////////////////////
{
	if (bLock)
		InterlockedIncrement(&g_lLocks);
	else
		InterlockedDecrement(&g_lLocks);

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vside\fmstocks\fminstprov\fmdeceventprov.cpp ===
#include <tchar.h>
#include "FMDecEventProv.h"
#include "WBemDcpl_i.c"
#include <comdef.h>

/************************************************************************
 *																	    *
 *		Class CFMDecEventProv											*
 *																		*
 *			An implementation for Decoupled Event Provider				*
 *																		*
 ************************************************************************/
/************************************************************************/
/*																		*/
/*	NAME	:	CFMDecEventProv::Create()								*/
/*																		*/
/*	PURPOSE :	Initialize COM & create PseudoSink interface			*/
/*																		*/
/*	INPUT	:	IWbemDecoupledEventSink	- pointer to the decoupled		*/
/*										  event sink					*/
/*																		*/ 
/*	OUTPUT	:	Standard COM Interface									*/
/*																		*/
/************************************************************************/
HRESULT CFMDecEventProv::Create(IWbemDecoupledEventSink** ppDecoupledSink) 
{
    HRESULT hr = WBEM_S_NO_ERROR;
    
    // initialize COM
    CoInitialize(NULL);
    hr = CoCreateInstance(CLSID_PseudoSink, NULL, CLSCTX_INPROC_SERVER, IID_IWbemDecoupledEventSink, 
							(void**)ppDecoupledSink);
    
    return hr;
}

/************************************************************************/
/*																		*/
/*	NAME	:	CFMDecEventProv::Connect()								*/
/*																		*/
/*	PURPOSE :	Connect to PseudoSink									*/
/*																		*/
/*	INPUT	:	IWbemDecoupledEventSink* - pointer to the decoupled		*/
/*										   event sink					*/
/*				IWbemServices*			 - Namespace					*/
/*				IWbemObjectSink			 - The object Sink				*/
/*																		*/ 
/*	OUTPUT	:	Standard COM Interface									*/
/*																		*/
/************************************************************************/
HRESULT CFMDecEventProv::Connect(IWbemDecoupledEventSink* pDecoupledSink, IWbemServices** ppNamespace, 
								 IWbemObjectSink** ppEventSink)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    
    // arguments to Connect:
    //      Root\Default        - name of Namespace desired (with the backslash escaped)
    //      SueDoeProvider      - name of our provider
    //      0                   - flags, unused in this release (leave zero, just in case)
    //      ppEventSink         - buffer to receive IWbemObjectSink interface pointer
    //      ppNamespace         - buffer to receive IWbemServices interface pointer
    hr = pDecoupledSink->Connect(L"Root\\default", L"FMStocks_EventProv", 
                                    0,
                                    ppEventSink, ppNamespace);

    return hr;
}

/************************************************************************/
/*																		*/
/*	NAME	:	CFMDecEventProv::RetrieveEventObject()					*/
/*																		*/
/*	PURPOSE :	Obtains an empty class object to use for our events		*/
/*																		*/
/*	INPUT	:	IWbemServices*		- Namespace							*/
/*				IWbemClassObject**	- The craeted class object			*/
/*																		*/ 
/*	OUTPUT	:	Standard COM Interface									*/
/*																		*/
/************************************************************************/
HRESULT CFMDecEventProv::RetrieveEventObject(IWbemServices* pNamespace, IWbemClassObject** ppEventObject)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    BSTR bstr;
    bstr = SysAllocString(L"FMStocks_Event");
    if (bstr)
    {
        // an empty class to use for our events
        IWbemClassObject* pEventClassObject = NULL;
        hr = pNamespace->GetObject(bstr, 0, NULL, &pEventClassObject, NULL);
        SysFreeString(bstr);

        if (SUCCEEDED(hr))
        {
            // create an instance of the event class
            hr = pEventClassObject->SpawnInstance(0, ppEventObject);
        }
    }
    else
	{
        // failed to allocate string
        hr = WBEM_E_OUT_OF_MEMORY;
	}

    return hr;
}

/************************************************************************/
/*																		*/
/*	NAME	:	CFMDecEventProv::RetrieveEventObject()					*/
/*																		*/
/*	PURPOSE :	Obtains class object and generates the event			*/
/*																		*/
/*	INPUT	:	IWbemServices*		- Namespace							*/
/*				IWbemObjectSink*	- The object sink					*/
/*				TCHAR*				- User name which is to be stored	*/
/*									  in the generated event object		*/
/*																		*/ 
/*	OUTPUT	:	Standard COM Interface									*/
/*																		*/
/************************************************************************/
HRESULT CFMDecEventProv::GenerateEvent(IWbemServices* pNamespace, IWbemObjectSink* pEventSink,TCHAR *strUserName)
{
    HRESULT hr = WBEM_S_NO_ERROR;

     // an instance of our event class
    IWbemClassObject* pEvent = NULL;

    hr = RetrieveEventObject(pNamespace, &pEvent);

    if (SUCCEEDED(hr))
    {
		//We should fill in the Event properties here
		VARIANT vt;
		VariantInit(&vt);
		vt.vt = VT_BSTR;
		vt.bstrVal = SysAllocString(_bstr_t(strUserName));
		pEvent->Put(L"UserName",0,&vt,wbemCimtypeString);

		SysFreeString(vt.bstrVal);

        // publish the event
        // arguments to Indicate:
        //      1       - number of events being sent
        //      pEvent  - array of pointers to event objects
        hr = pEventSink->Indicate(1, &pEvent);

        pEvent->Release();
    }
    return hr;
}

/************************************************************************/
/*																		*/
/*	NAME	:	CFMDecEventProv::GenerateLoginFail()					*/
/*																		*/
/*	PURPOSE :	Generated the login fail event							*/
/*																		*/
/*	INPUT	:	TCHAR*				- User name which is to be stored	*/
/*									  in the generated event object		*/
/*																		*/ 
/*	OUTPUT	:	Standard COM Interface									*/
/*																		*/
/************************************************************************/
HRESULT CFMDecEventProv::GenerateLoginFail(TCHAR *strUserName)
{
    // interface pointer to the decoupled sink
    IWbemDecoupledEventSink* pDecoupledSink = NULL;
    // interface pointer to WinMgmt
    IWbemServices*    pNamespace = NULL;
    // sink for our events
    IWbemObjectSink*  pEventSink = NULL;

    if (SUCCEEDED(Create(&pDecoupledSink)))
    {
        if (SUCCEEDED(Connect(pDecoupledSink, &pNamespace, &pEventSink)))
        {
            if(SUCCEEDED(GenerateEvent(pNamespace, pEventSink,strUserName)))
			{

				// call disconnect to notifiy the PseudoProvider
				// that no more events will be forthcoming.
				// you may call connect again to restart providing events
				pDecoupledSink->Disconnect();

				pEventSink->Release();
				pNamespace->Release();
			}
        }
		else
		{
			return E_FAIL;
		}
        pDecoupledSink->Release();
    }
	else
	{
		return E_FAIL;
	}
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vside\fmstocks\fminstprov\fminstprov.cpp ===
////////////////////////////////////////////////////////////////////////
//
//  FMInstProv.cpp
//
//	Module:	WMI high performance provider for F&M Stocks
//
//  Generic COM server framework, 
//
//  History:
//	a-vkanna      3-April-2000		Initial Version
//
//  Copyright (c) 2000 Microsoft Corporation
//
////////////////////////////////////////////////////////////////////////

#include <windows.h>
#include <stdio.h>
#include <time.h>
#include <locale.h>
#include <initguid.h>
#include <tchar.h>

#include "ClassFactory.h"

/////////////////////////////////////////////////////////////////////////////
//
//  BEGIN CLSID SPECIFIC SECTION
//
//

// {C329212F-5D9F-4ed1-8B14-0F57FF248F29}
DEFINE_GUID(CLSID_FMInstProvider,
			0xc329212f, 0x5d9f, 0x4ed1, 0x8b, 0x14, 0xf, 0x57, 0xff, 0x24, 0x8f, 0x29);

#define IMPLEMENTED_CLSID           CLSID_FMInstProvider
#define SERVER_REGISTRY_COMMENT     L"WMI Instance Provider for FMStocks"

HINSTANCE g_hInstance;
long g_lLocks = 0;
long g_lObjects = 0;

//***************************************************************************
//
//  DllMain
//
//  Dll entry point.
//
//  PARAMETERS:
//
//      HINSTANCE hinstDLL      The handle to our DLL.
//      DWORD dwReason          DLL_PROCESS_ATTACH on load,
//                              DLL_PROCESS_DETACH on shutdown,
//                              DLL_THREAD_ATTACH/DLL_THREAD_DETACH otherwise.
//      LPVOID lpReserved       Reserved
//
//  RETURN VALUES:
//
//      TRUE is successful, FALSE if a fatal error occured.
//      NT behaves very ugly if FALSE is returned.
//
//***************************************************************************
BOOL WINAPI DllMain(
    HINSTANCE hinstDLL,
    DWORD dwReason,
    LPVOID lpReserved
    )
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        setlocale(LC_ALL, "");      // Set to the 'current' locale
        g_hInstance = hinstDLL;
    }
    return TRUE;
}

//***************************************************************************
//
//  DllGetClassObject
//
//  Standard OLE In-Process Server entry point to return an class factory
//  instance.
//
//  PARAMETERS:
//
//  RETURNS:
//
//      S_OK                Success
//      E_NOINTERFACE       An interface other that IClassFactory was asked for
//      E_OUTOFMEMORY
//      E_FAILED            Initialization failed, or an unsupported clsid was
//                          asked for.
//
//***************************************************************************

STDAPI DllGetClassObject(
    REFCLSID rclsid,
    REFIID riid,
    LPVOID * ppv
    )
{
    CClassFactory *pClassFactory = NULL;
	HRESULT hRes;

    //  Verify the caller is asking for our type of object
    if (IMPLEMENTED_CLSID == rclsid) 
	{
		// Create the class factory
		pClassFactory = new CClassFactory;

		if (!pClassFactory)
			return E_OUTOFMEMORY;
		
		hRes = pClassFactory->QueryInterface(riid, ppv);
		if (FAILED(hRes))
		{
			delete pClassFactory;
			return hRes;
		}
		hRes = S_OK;
	}
	else 
		hRes = CLASS_E_CLASSNOTAVAILABLE;

    return hRes;
}

//***************************************************************************
//
//  DllCanUnloadNow
//
//  Standard OLE entry point for server shutdown request. Allows shutdown
//  only if no outstanding objects or locks are present.
//
//  RETURN VALUES:
//
//      S_OK        May unload now.
//      S_FALSE     May not.
//
//***************************************************************************

STDAPI DllCanUnloadNow(void)
{
    HRESULT hRes = S_FALSE;

    if (0 == g_lLocks && 0 == g_lObjects)
        hRes = S_OK;

    return hRes;
}

//***************************************************************************
//
//  DllRegisterServer
//
//  Standard OLE entry point for registering the server.
//
//  RETURN VALUES:
//
//      S_OK        Registration was successful
//      E_FAIL      Registration failed.
//
//***************************************************************************

STDAPI DllRegisterServer(void)
{
    wchar_t Path[1024];
    wchar_t *pGuidStr = 0;
    wchar_t KeyPath[1024];

    // Get the dll's filename
    GetModuleFileNameW(g_hInstance, Path, 1024);

    // Convert CLSID to string.
    StringFromCLSID(IMPLEMENTED_CLSID, &pGuidStr);
    swprintf(KeyPath, L"Software\\Classes\\CLSID\\\\%s", pGuidStr);

    // Place it in registry.
	HKEY hKey;
    LONG lRes = RegCreateKeyW(HKEY_LOCAL_MACHINE, KeyPath, &hKey);
    if (lRes)
        return E_FAIL;

    wchar_t *pName = SERVER_REGISTRY_COMMENT; 
    RegSetValueExW(hKey, 0, 0, REG_SZ, (const BYTE *) pName, wcslen(pName) * 2 + 2);

    HKEY hSubkey;
    lRes = RegCreateKey(hKey, _T("InprocServer32"), &hSubkey);

    RegSetValueExW(hSubkey, 0, 0, REG_SZ, (const BYTE *) Path, wcslen(Path) * 2 + 2);
    RegSetValueExW(hSubkey, L"ThreadingModel", 0, REG_SZ, (const BYTE *) L"Both", wcslen(L"Both") * 2 + 2);

    RegCloseKey(hSubkey);
    RegCloseKey(hKey);

    CoTaskMemFree(pGuidStr);

    return S_OK;
}

//***************************************************************************
//
//  DllUnregisterServer
//
//  Standard OLE entry point for unregistering the server.
//
//  RETURN VALUES:
//
//      S_OK        Unregistration was successful
//      E_FAIL      Unregistration failed.
//
//***************************************************************************

STDAPI DllUnregisterServer(void)
{
    wchar_t *pGuidStr = 0;
    HKEY hKey;
    wchar_t KeyPath[256];

    StringFromCLSID(IMPLEMENTED_CLSID, &pGuidStr);
    swprintf(KeyPath, L"Software\\Classes\\CLSID\\\\%s", pGuidStr);

    // Delete InProcServer32 subkey.
    LONG lRes = RegOpenKeyW(HKEY_LOCAL_MACHINE, KeyPath, &hKey);
    if (lRes)
        return E_FAIL;

    RegDeleteKeyW(hKey, L"InprocServer32");
    RegCloseKey(hKey);

    // Delete CLSID GUID key.
    lRes = RegOpenKeyW(HKEY_LOCAL_MACHINE, L"Software\\Classes\\CLSID", &hKey);
    if (lRes)
        return E_FAIL;

    RegDeleteKeyW(hKey, pGuidStr);
    RegCloseKey(hKey);

    CoTaskMemFree(pGuidStr);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vside\fmstocks\fminstprov\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	FMInstProv.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vside\fmstocks\fminstprov\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__A90FFCA6_18DA_4CF1_A822_683F76FF07BD__INCLUDED_)
#define AFX_STDAFX_H__A90FFCA6_18DA_4CF1_A822_683F76FF07BD__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


// Insert your headers here
#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers

#include <windows.h>

// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__A90FFCA6_18DA_4CF1_A822_683F76FF07BD__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vside\fmstocks\fminstprov\fmdeceventprov.h ===
////////////////////////////////////////////////////////////////////////
//
//	FMDecEventProv.h
//
//	Module:	WMI Event provider for F&M Stocks
//
//  This is the Decoupled Event Provider Implementation 
//
//  History:
//	a-vkanna      3-April-2000		Initial Version
//
//  Copyright (c) 2000 Microsoft Corporation
//
////////////////////////////////////////////////////////////////////////

#ifndef _FMStocks_FMDecEventProv_H_
#define _FMStocks_FMDecEventProv_H_

#include <wbemidl.h>
#include <WbemDCpl.h>

class CFMDecEventProv 
{
	public:
		CFMDecEventProv() {};
		~CFMDecEventProv(){};
		
		//This function generates the logon fail event
		HRESULT GenerateLoginFail(TCHAR *strUserName);

	protected:

		// initialize com & create PseudoSink interface
		HRESULT Create(IWbemDecoupledEventSink** pDecoupledSink);

		// connect to the pseudo sink
		HRESULT Connect(IWbemDecoupledEventSink* pDecoupledSink, IWbemServices** ppNamespace, IWbemObjectSink** ppEventSink);  

		// obtain class object, generate event
		HRESULT GenerateEvent(IWbemServices* pNamespace, IWbemObjectSink* pEventSink,TCHAR *strUserName);

		// obtain an empty class object to use for our events
		HRESULT RetrieveEventObject(IWbemServices* pNamespace, IWbemClassObject** ppEventObject);
};

#endif //_FMStocks_FMDecEventProv_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vside\fmstocks\fminstprov\fminstprovider.cpp ===
////////////////////////////////////////////////////////////////////////
//
//	FMInstProvider.cpp
//
//	Module:	WMI Instance provider for F&M Stocks
//
//  This is the class factory and instance provider implementation 
//
//  History:
//	a-vkanna      3-April-2000		Initial Version
//
//  Copyright (c) 2000 Microsoft Corporation
//
////////////////////////////////////////////////////////////////////////

#include <objbase.h>
#include <process.h>
#include <tchar.h>
#include <COMDEF.H>
#include <string.h>

#include "FMInstProvider.h"
#include "FMDecEventProv.h"

#define FILE_MAPPING_NAME	_T("FMSTOCKS_FILE_MAPPING_OBJECT_FOR_HIPERFORMACE_COUNTER")

//The array of fields in the DSN String
TCHAR strFields[NUM_FIELDS][20] = { {_T("Provider=")	},
									{_T("Data Source=")	},
									{_T("Database=")	},
									{_T("User Id=")		},
									{_T("Password=")	}  };

/************************************************************************
 *																	    *
 *		Class CProvider													*
 *																		*
 *			The Instance Provider class for FMStocks implements			*
 *			IWbemServices and IWbemProviderInit							*
 *																		*
 ************************************************************************/
/************************************************************************/
/*																		*/
/*	NAME	:	CFMInstProvider::CFMInstProvider()						*/
/*																		*/
/*	PURPOSE :	Constructor												*/
/*																		*/
/*	INPUT	:	BSTR		 - Object Path								*/
/*				BSTR		 - User Name								*/
/*				BSTR		 - Password									*/
/*				IWbemContext - Context									*/
/*																		*/ 
/*	OUTPUT	:	N/A														*/
/*																		*/
/************************************************************************/
/************************************************************************/
/*																		*/
/*	NAME	:	CFMInstProvider::CFMInstProvider()						*/
/*																		*/
/*	PURPOSE :	Constructor												*/
/*																		*/
/*	INPUT	:	NONE													*/
/*																		*/ 
/*	OUTPUT	:	N/A														*/
/*																		*/
/************************************************************************/
//CFMInstProvider::CFMInstProvider(BSTR ObjectPath, BSTR User, BSTR Password, IWbemContext * pCtx)
CFMInstProvider::CFMInstProvider()
{
    m_pNamespace = NULL;
    m_cRef=0;
    InterlockedIncrement(&g_lObjects);
	m_pInstance = NULL;
	m_hKey = NULL;

/*	//Try to open the registry key and get the name of the file to store the login fail events 
	if(RegOpenKeyEx(HKEY_LOCAL_MACHINE,_T("Software\\VSInteropSample"),0,KEY_ALL_ACCESS,&m_hKey) == ERROR_SUCCESS)
	{
		DWORD dwWritten = 1024*sizeof(TCHAR);
		long lRet = RegQueryValueEx(m_hKey,_T("LoginFail"),0,NULL,(LPBYTE)m_strLogFileName,&dwWritten);
		if(lRet != ERROR_SUCCESS)
			_tcscpy(m_strLogFileName,_T(""));

		if(RegQueryValueEx(m_hKey,_T("LookupTimePerfCtr"),NULL,NULL,NULL,NULL) != ERROR_SUCCESS)
		{
			//Not exists.So create the value and initialize with 0
			DWORD dwZero = 0;
			RegSetValueEx(m_hKey,_T("LookupTimePerfCtr"),0,REG_DWORD,(LPBYTE)&dwZero,sizeof(DWORD));
		}
	}
*/
	SECURITY_DESCRIPTOR sd;
	InitializeSecurityDescriptor(&sd,SECURITY_DESCRIPTOR_REVISION);

	SECURITY_ATTRIBUTES sa;
	sa.nLength = sizeof(SECURITY_ATTRIBUTES);
	sa.lpSecurityDescriptor = &sd;
	sa.bInheritHandle = TRUE;

	m_hFile = NULL;

	m_hFile = CreateFileMapping(INVALID_HANDLE_VALUE,&sa,PAGE_READWRITE | SEC_COMMIT,
									 0L, sizeof(long), FILE_MAPPING_NAME);
	if(m_hFile != NULL)
	{
		m_lCtr = (long *)MapViewOfFile(m_hFile,FILE_MAP_ALL_ACCESS,0L,0L,0L);
		if(m_lCtr != NULL)
			*m_lCtr = 0;
	}

}

/************************************************************************/
/*																		*/
/*	NAME	:	CFMInstProvider::~CFMInstProvider()						*/
/*																		*/
/*	PURPOSE :	Destructor												*/
/*																		*/
/*	INPUT	:	N/A														*/
/*																		*/ 
/*	OUTPUT	:	N/A														*/
/*																		*/
/************************************************************************/
CFMInstProvider::~CFMInstProvider(void)
{
    if(m_pNamespace)
        m_pNamespace->Release();
	m_pInstance = NULL;

	if(m_lCtr != NULL)
	{
		UnmapViewOfFile(m_lCtr);
	}

	if(m_hFile != NULL)
	{
		CloseHandle(m_hFile);
	}

//  	if(m_hKey != NULL)
//		RegCloseKey(m_hKey);

	InterlockedDecrement(&g_lObjects);

}
/************ IUNKNOWN METHODS ******************/
/************************************************************************/
/*																		*/
/*	NAME	:	CFMInstProvider::QueryInterface()						*/
/*																		*/
/*	PURPOSE :	Standard COM interface. Doesn't need description		*/
/*																		*/
/*	INPUT	:	Standard COM Interface									*/
/*																		*/
/*	OUTPUT	:	Standard COM Interface									*/
/*																		*/
/************************************************************************/
STDMETHODIMP CFMInstProvider::QueryInterface(REFIID riid, PPVOID ppv)
{
    *ppv=NULL;

    // Since we have dual inheritance, it is necessary to cast the return type
    if(riid== IID_IWbemServices)
       *ppv=(IWbemServices*)this;

    if(IID_IUnknown==riid || riid== IID_IWbemProviderInit)
       *ppv=(IWbemProviderInit*)this;

    if (NULL!=*ppv) 
	{
        AddRef();
        return NOERROR;
    }
    else
        return E_NOINTERFACE;
}

/************************************************************************/
/*																		*/
/*	NAME	:	CFMInstProvider::AddRef()								*/
/*																		*/
/*	PURPOSE :	Standard COM interface. Doesn't need description		*/
/*																		*/
/*	INPUT	:	Standard COM Interface									*/
/*																		*/
/*	OUTPUT	:	Standard COM Interface									*/
/*																		*/
/************************************************************************/
STDMETHODIMP_(ULONG) CFMInstProvider::AddRef(void)
{
    return ++m_cRef;
}

/************************************************************************/
/*																		*/
/*	NAME	:	CFMInstProvider::Release()								*/
/*																		*/
/*	PURPOSE :	Standard COM interface. Doesn't need description		*/
/*																		*/
/*	INPUT	:	Standard COM Interface									*/
/*																		*/
/*	OUTPUT	:	Standard COM Interface									*/
/*																		*/
/************************************************************************/
STDMETHODIMP_(ULONG) CFMInstProvider::Release(void)
{
    ULONG nNewCount = InterlockedDecrement((long *)&m_cRef);
    if (0L == nNewCount)
	{
		m_pInstance->Release();
		m_pInstance = NULL;
        delete this;
	}
    
    return nNewCount;
}

/********** IWBEMPROVIDERINIT METHODS ************/
/************************************************************************/
/*																		*/
/*	NAME	:	CFMInstProvider::Initialize()							*/
/*																		*/
/*	PURPOSE :	For initializing the Provider object					*/
/*																		*/
/*	INPUT	:	LPWSTR			- Pointer to the user name				*/
/*				long			- reserved								*/
/*				LPWSTR			- Namespace								*/
/*				LPWSTR			- Locale Name							*/
/*				IWbemServices*  - pointer to namespace					*/
/*				IWbemContext*   - The context							*/
/*				IWbemProviderInitSink - The sink object for init		*/
/*																		*/
/*	OUTPUT	:	Standard COM Interface									*/
/*																		*/
/************************************************************************/
STDMETHODIMP CFMInstProvider::Initialize(LPWSTR pszUser, LONG lFlags,
                                    LPWSTR pszNamespace, LPWSTR pszLocale,
                                    IWbemServices *pNamespace, 
                                    IWbemContext *pCtx,
                                    IWbemProviderInitSink *pInitSink)
{
    if(pNamespace)
        pNamespace->AddRef();
    m_pNamespace = pNamespace;

    //Let CIMOM know you are initialized
    pInitSink->SetStatus(WBEM_S_INITIALIZED,0);
    return WBEM_S_NO_ERROR;
}

/************ IWBEMSERVICES METHODS **************/
/************************************************************************/
/*																		*/
/*	NAME	:	CFMInstProvider::CreateInstanceEnumAsync()				*/
/*																		*/
/*	PURPOSE :	Asynchronously enumerates the instances					*/
/*																		*/
/*	INPUT	:	BSTR			 - Class Name							*/
/*				long			 - flag									*/
/*				IWbemContext*    - The context							*/
/*				IWbemObjectSink* - The Sink Object						*/
/*																		*/
/*	OUTPUT	:	Standard COM Interface									*/
/*																		*/
/************************************************************************/
SCODE CFMInstProvider::CreateInstanceEnumAsync( const BSTR RefStr, long lFlags, IWbemContext *pCtx,
       IWbemObjectSink FAR* pHandler)
{
    SCODE sc;

    // Do a check of arguments and make sure we have pointer to Namespace
    if(pHandler == NULL || m_pNamespace == NULL)
        return WBEM_E_INVALID_PARAMETER;

	if(m_pInstance == NULL)
	{
		sc = CreateInst(m_pNamespace,&m_pInstance, RefStr, pCtx);
		if(sc != S_OK)
		{
			m_pInstance = NULL;
		}
	}

    // Send the object to the caller
    pHandler->Indicate(1,&m_pInstance);

    // Set status
    pHandler->SetStatus(0,sc,NULL, NULL);

    return sc;
}

/************************************************************************/
/*																		*/
/*	NAME	:	CFMInstProvider::GetObjectAsync()						*/
/*																		*/
/*	PURPOSE :	Asynchronously enumerates the instances					*/
/*																		*/
/*	INPUT	:	BSTR			 - Object Path							*/
/*				long			 - flag									*/
/*				IWbemContext*    - The context							*/
/*				IWbemObjectSink* - The Sink Object						*/
/*																		*/
/*	OUTPUT	:	Standard COM Interface									*/
/*																		*/
/************************************************************************/
SCODE CFMInstProvider::GetObjectAsync(const BSTR ObjectPath, long lFlags,IWbemContext  *pCtx,
                    IWbemObjectSink FAR* pHandler)
{
    SCODE sc;
    BOOL bOK = FALSE;

    // Do a check of arguments and make sure we have pointer to Namespace
    if(ObjectPath == NULL || pHandler == NULL || m_pNamespace == NULL)
        return WBEM_E_INVALID_PARAMETER;

    // do the get, pass the object on to the notify
    sc = GetByPath(ObjectPath,pCtx);

    if(sc == S_OK) 
    {
        pHandler->Indicate(1,&m_pInstance);
        bOK = TRUE;
    }
	else
	{
		m_pInstance = NULL;
	}

    sc = (bOK) ? S_OK : WBEM_E_NOT_FOUND;

    // Set Status
    pHandler->SetStatus(0,sc, NULL, NULL);

	if(sc != S_OK)
	{
		m_pInstance = NULL;
	}

    return sc;
}
 
/************************************************************************
*                                                                       *      
*CMethodPro::ExecMethodAsync                                            *
*                                                                       *
*Purpose: This is the Async function implementation.                    *
*         The only method supported in this sample is named Echo.  It   * 
*         takes an input string, copies it to the output and returns the* 
*         length.  The mof definition is                                *
*                                                                       *
*    [dynamic: ToInstance, provider("MethProv")]class MethProvSamp      *
*    {                                                                  *
*         [implemented, static]                                         *
*            uint32 Echo([IN]string sInArg="default",                   *
*                [out] string sOutArg);                                 *
*    };                                                                 *
*                                                                       *
************************************************************************/

STDMETHODIMP CFMInstProvider::ExecMethodAsync(const BSTR ObjectPath, const BSTR MethodName, 
            long lFlags, IWbemContext* pCtx, IWbemClassObject* pInParams, 
            IWbemObjectSink* pResultSink)
{
    HRESULT hr;    
	HRESULT sc = E_FAIL;
    IWbemClassObject * pClass = NULL;
    IWbemClassObject * pOutClass = NULL;    
    IWbemClassObject* pOutParams = NULL;
 
	//Check for the method name
    if(_wcsicmp(MethodName, L"UpdateAccountString") == 0)
	{
		// Copy the input arguments 
		VARIANT vtUserId;
		VariantInit(&vtUserId);    // Get the input argument
		pInParams->Get(L"strUserId", 0, &vtUserId, NULL, NULL);   

		VARIANT vtPassword;
		VariantInit(&vtPassword);    // Get the input argument
		pInParams->Get(L"strPassword", 0, &vtPassword, NULL, NULL);   

		TCHAR strConnect[1024];
		VARIANT vtTemp;

		hr = m_pInstance->Get(L"DBProvider",0,&vtTemp,NULL,NULL);
		if(FAILED(hr))
		{
			pResultSink->SetStatus(0,WBEM_E_NOT_FOUND,NULL,NULL);
			return E_FAIL;
		}
		_tcscpy(strConnect,_T("Provider="));
		_tcscat(strConnect,_bstr_t(vtTemp.bstrVal));

		hr = m_pInstance->Get(L"DBDataSource",0,&vtTemp,NULL,NULL);
		if(FAILED(hr))
		{
			pResultSink->SetStatus(0,WBEM_E_NOT_FOUND,NULL,NULL);
			return E_FAIL;
		}
		_tcscat(strConnect,_T(";Data Source="));
		_tcscat(strConnect,_bstr_t(vtTemp.bstrVal));

		hr = m_pInstance->Get(L"DBName",0,&vtTemp,NULL,NULL);
		if(FAILED(hr))
		{
			pResultSink->SetStatus(0,WBEM_E_NOT_FOUND,NULL,NULL);
			return E_FAIL;
		}
		_tcscat(strConnect,_T(";Database="));
		_tcscat(strConnect,_bstr_t(vtTemp.bstrVal));

		//Concatenate the User Id
		_tcscat(strConnect,_T(";User Id="));
		_tcscat(strConnect,_bstr_t(vtUserId.bstrVal));

		//Concatenate the Password
		_tcscat(strConnect,_T(";Password="));
		_tcscat(strConnect,_bstr_t(vtPassword.bstrVal));
		_tcscat(strConnect,_T(";"));

		//Now write it in the registry
		// the key is HKLM\Software\VSInteropSample(MainConnectString)
		HKEY hKey = NULL;
		if(RegOpenKeyEx(HKEY_LOCAL_MACHINE,_T("Software\\VSInteropSample"),0,KEY_ALL_ACCESS,&hKey) == ERROR_SUCCESS)
		{
			if(RegSetValueEx(hKey,_T("MainConnectString"),0,REG_SZ,(LPBYTE)strConnect,_tcslen(strConnect) * sizeof(_TCHAR)) != ERROR_SUCCESS)
			{
				pResultSink->SetStatus(0,WBEM_E_NOT_FOUND,NULL,NULL);
				return E_FAIL;
			}
			else
			{
				//Update the Values in the Instance
				if(m_pInstance != NULL)
				{
					hr = m_pInstance->Put(L"DBUserId", 0, &vtUserId, 0);
					if(FAILED(hr))
					{
						return hr;
					}
					hr = m_pInstance->Put(L"DBPassword", 0, &vtPassword, 0);
					if(FAILED(hr))
					{
						return hr;
					}
				}
			}
		}
		else
		{
			pResultSink->SetStatus(0,WBEM_E_NOT_FOUND,NULL,NULL);
			return E_FAIL;
		}
   
		// all done now, set the status
		hr = pResultSink->SetStatus(0,WBEM_S_NO_ERROR,NULL,NULL);
		sc = WBEM_S_NO_ERROR;
	}
	else if(_wcsicmp(MethodName, L"UpdateGAMStrings") == 0)
	{
		// Copy the input arguments 
		VARIANT vtServer;
		VariantInit(&vtServer);    // Get the input argument
		pInParams->Get(L"strServerName", 0, &vtServer, NULL, NULL);   

		VARIANT vtUserId;
		VariantInit(&vtUserId);    // Get the input argument
		pInParams->Get(L"strUserId", 0, &vtUserId, NULL, NULL);   

		VARIANT vtPassword;
		VariantInit(&vtPassword);    // Get the input argument
		pInParams->Get(L"strPassword", 0, &vtPassword, NULL, NULL);   

		TCHAR  lpSubKey[50];
		TCHAR  szRegValue[255];
		DWORD dwValType;
		HKEY  GamKey;
		DWORD dwDataBuffSize;
		long  lRegRetCode;
		HRESULT hr;

		_tcscpy(lpSubKey, _T("FMGAM.GAM\\CurVer"));

		lRegRetCode = 
		  RegOpenKeyEx( HKEY_CLASSES_ROOT,    // handle to open key
						lpSubKey,             // address of name of subkey to open
						0l,                   // reserved
						KEY_READ,             // security access mask
						&GamKey);             // address of handle to open key

		if ( lRegRetCode != ERROR_SUCCESS )
		{
			return E_FAIL;
		}

		dwDataBuffSize = 255;
		lRegRetCode = 
		  RegQueryValueEx( GamKey,            // handle to key to query
						   NULL,              // address of name of value to query
						   NULL,              // reserved
						   &dwValType,        // address of buffer for value type
						   (LPBYTE)szRegValue,// value
						   &dwDataBuffSize);  // address of data buffer size

		if ( lRegRetCode != ERROR_SUCCESS )
		{
			return E_FAIL;
		}

		lRegRetCode = RegCloseKey(GamKey);
		if( lRegRetCode != ERROR_SUCCESS )    // An error occurred closing the registry
		  return E_FAIL;

		_tcscpy(lpSubKey,szRegValue);
		_tcscat(lpSubKey,_T("\\PlugInParms"));

		lRegRetCode = 
		  RegOpenKeyEx( HKEY_CLASSES_ROOT,    // handle to open key
						lpSubKey,             // address of name of subkey to open
						0l,                   // reserved
						KEY_WRITE,			  // security access mask
						&GamKey);             // address of handle to open key
		if ( lRegRetCode != ERROR_SUCCESS )
		{
			return E_FAIL;
		}

		lRegRetCode = 
		  RegSetValueEx( GamKey,           
						   _T("UserName"), 
						   NULL,           
						   REG_SZ,        
						   (LPBYTE)(LPTSTR)(_bstr_t(vtUserId.bstrVal)),  
						   _tcslen(_bstr_t(vtUserId.bstrVal)) * sizeof(TCHAR));  

		if ( lRegRetCode != ERROR_SUCCESS )
		{
			return E_FAIL;
		}

		lRegRetCode = 
		  RegSetValueEx( GamKey,				  
						   _T("Password"),        
						   NULL,				  
						   REG_SZ,				  
						   (LPBYTE)(LPTSTR)(_bstr_t(vtPassword.bstrVal)), 
						   _tcslen(_bstr_t(vtPassword.bstrVal)) * sizeof(TCHAR));  

		if ( lRegRetCode != ERROR_SUCCESS )
		{
			return E_FAIL;
		}

		lRegRetCode = 
		  RegSetValueEx( GamKey,            
						   _T("ServerName"),
						   NULL,            
						   REG_SZ,        
						   (LPBYTE)(LPTSTR)(_bstr_t(vtServer.bstrVal)),  
						   _tcslen(_bstr_t(vtServer.bstrVal)) * sizeof(TCHAR));  

		if ( lRegRetCode != ERROR_SUCCESS )
		{
			return E_FAIL;
		}

		lRegRetCode = RegCloseKey(GamKey);

		//Update the Values in the Instance
		if(m_pInstance != NULL)
		{
			hr = m_pInstance->Put(L"GAMUserName", 0, &vtUserId, 0);
			if(FAILED(hr))
			{
				return hr;
			}
			hr = m_pInstance->Put(L"GAMPassword", 0, &vtPassword, 0);
			if(FAILED(hr))
			{
				return hr;
			}
			hr = m_pInstance->Put(L"GAMServerName", 0, &vtServer, 0);
			if(FAILED(hr))
			{
				return hr;
			}
		}
		sc = WBEM_S_NO_ERROR;
	}
	else if(_wcsicmp(MethodName, L"GenerateLoginFailure") == 0)
	{
		// Copy the input arguments 
		VARIANT vtUserName;
		VariantInit(&vtUserName);    
		pInParams->Get(L"strUserName", 0, &vtUserName, NULL, NULL);   

		_bstr_t strUserName = vtUserName;
		CFMDecEventProv EvePro;
		sc = EvePro.GenerateLoginFail(strUserName);
	}
	else if(_wcsicmp(MethodName, L"GetLoginFailStrings") == 0)
	{
		//Copy the input arguments
		VARIANT vtNum;
		VariantInit(&vtNum);
		pInParams->Get(L"Index",0,&vtNum,NULL,NULL);

		int nIndex = vtNum.lVal;

		//Now read the event
		HANDLE hFile = CreateFile(m_strLogFileName,GENERIC_READ, 
									FILE_SHARE_READ | FILE_SHARE_WRITE,
									NULL,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL);

		if(hFile == INVALID_HANDLE_VALUE)
		{
			//Whatever error it is, now we can't open the file
			// So better return as no records
			return E_FAIL;
		}

		long offset = (nIndex - 1)*((MAX_LEN_USER_NAME + LEN_DATE_TIME) * sizeof(TCHAR));

		SetFilePointer(hFile,offset,0,FILE_BEGIN);

		//Now read the Values
		DWORD dwBytesRead = 0;
		TCHAR strUserName[MAX_LEN_USER_NAME+sizeof(TCHAR)];
		ReadFile(hFile,(void *)strUserName,MAX_LEN_USER_NAME*sizeof(TCHAR),&dwBytesRead,NULL);

		if(dwBytesRead != MAX_LEN_USER_NAME*sizeof(TCHAR))
		{
			return E_FAIL;
		}
		strUserName[MAX_LEN_USER_NAME] = _T('\0');

		TCHAR strDateTime[LEN_DATE_TIME+sizeof(TCHAR)];
		ReadFile(hFile,(void *)strDateTime,LEN_DATE_TIME*sizeof(TCHAR),&dwBytesRead,NULL);

		if(dwBytesRead != LEN_DATE_TIME*sizeof(TCHAR))
		{
			return E_FAIL;
		}
		strDateTime[LEN_DATE_TIME] = _T('\0');
		CloseHandle(hFile);

		IWbemClassObject * pClass = NULL;
	    IWbemClassObject* pOutParams = NULL;
	    IWbemClassObject * pOutClass = NULL;    

	    BSTR ClassName = SysAllocString(L"FMStocks_InstProv");    

		hr = m_pNamespace->GetObject(ClassName, 0, pCtx, &pClass, NULL);
		if(hr != S_OK)
		{
			 pResultSink->SetStatus(0,hr, NULL, NULL);
			 return hr;
		}

		hr = pClass->GetMethod(MethodName, 0, NULL, &pOutClass);
		if(FAILED(hr))
		{
			return hr;
		}

	    hr = pOutClass->SpawnInstance(0, &pOutParams);
		if(FAILED(hr))
		{
			return hr;
		}

		VARIANT var;
		VariantInit(&var);    
		var.vt = VT_BSTR;
		var.bstrVal = SysAllocString(_bstr_t(strUserName));    
		hr = pOutParams->Put(L"strUserName", 0, &var, 0);
		if(FAILED(hr))
		{
			return hr;
		}
		SysFreeString(var.bstrVal);

		VariantClear(&var);    
		var.vt = VT_BSTR;
		var.bstrVal = SysAllocString(_bstr_t(strDateTime));    
		hr = pOutParams->Put(L"strDateTime", 0, &var, 0);
		if(FAILED(hr))
		{
			return hr;
		}
		SysFreeString(var.bstrVal);

		hr = pResultSink->Indicate(1, &pOutParams);    
	    pOutParams->Release();
		pOutClass->Release();    
		pClass->Release();
		sc = WBEM_S_NO_ERROR;
	}
	else if(_wcsicmp(MethodName, L"GetNumberofLoginFails") == 0)
	{
		if(_tcscmp(m_strLogFileName,_T("")) == 0)
		{
			//Could not get the file name. So can't do anything
			return E_FAIL;
		}

		IWbemClassObject * pClass = NULL;
	    IWbemClassObject* pOutParams = NULL;
	    IWbemClassObject * pOutClass = NULL;    
		long lNumFails = 0;

	    BSTR retValName = SysAllocString(L"ReturnValue");
	    BSTR ClassName = SysAllocString(L"FMStocks_InstProv");    

		hr = m_pNamespace->GetObject(ClassName, 0, pCtx, &pClass, NULL);
		if(hr != S_OK)
		{
			 pResultSink->SetStatus(0,hr, NULL, NULL);
			 return hr;
		}

		hr = pClass->GetMethod(MethodName, 0, NULL, &pOutClass);
		if(FAILED(hr))
		{
			return hr;
		}

	    hr = pOutClass->SpawnInstance(0, &pOutParams);
		if(FAILED(hr))
		{
			return hr;
		}

		//Now find the number of Login Failures
		HANDLE hFile = CreateFile(m_strLogFileName,GENERIC_READ, 
									FILE_SHARE_READ | FILE_SHARE_WRITE,
									NULL,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL);

		if(hFile == INVALID_HANDLE_VALUE)
		{
			//Whatever error it is, now we can't open the file
			// So better return as no records
			lNumFails = 0;
		}
		else
		{
			lNumFails = GetFileSize(hFile,NULL);
			lNumFails = lNumFails / ((MAX_LEN_USER_NAME + LEN_DATE_TIME) * sizeof(TCHAR));
		}

		CloseHandle(hFile);

		VARIANT var;
		VariantInit(&var);    
		var.vt = VT_I4;
		var.lVal = lNumFails;    // special name for return value.
		hr = pOutParams->Put(retValName , 0, &var, 0);
		if(FAILED(hr))
		{
			return hr;
		}

		hr = pResultSink->Indicate(1, &pOutParams);    
	    pOutParams->Release();
		pOutClass->Release();    
		pClass->Release();
		sc = WBEM_S_NO_ERROR;
	}
	else if(_wcsicmp(MethodName, L"ClearLoginFailEvents") == 0)
	{
		DeleteFile(m_strLogFileName);
		sc = WBEM_S_NO_ERROR;
	}
	else if(_wcsicmp(MethodName, L"SetLookupTime") == 0)
	{
		//Copy the input arguments
		VARIANT vtNum;
		VariantInit(&vtNum);
		pInParams->Get(L"LookupTime",0,&vtNum,NULL,NULL);

//		RegSetValueEx(m_hKey,_T("LookupTimePerfCtr"),0,REG_DWORD,(LPBYTE)&(vtNum.lVal),sizeof(long));
		if(m_lCtr != NULL)
			*m_lCtr = vtNum.lVal;

		sc = WBEM_S_NO_ERROR;
	}
    else
	{
        return WBEM_E_INVALID_PARAMETER;
	}
	// all done now, set the status
	hr = pResultSink->SetStatus(0,WBEM_S_NO_ERROR,NULL,NULL);
	return sc;
}
/************************ LOCAL FUNCTIONS *******************************/
/************************************************************************/
/*																		*/
/*	NAME	:	CFMInstProvider::GetByPath()							*/
/*																		*/
/*	PURPOSE :	Creates an instance given a particular Path value.		*/
/*																		*/
/*	INPUT	:	BSTR			 - Object Path							*/
/*				IWbemContext*    - The context							*/
/*																		*/
/*	OUTPUT	:	Standard COM Interface									*/
/*																		*/
/************************************************************************/
SCODE CFMInstProvider::GetByPath(BSTR ObjectPath, IWbemContext  *pCtx)
{
    SCODE sc = S_OK;
    
    // do a simple path parse.  The path will look something like
    // InstProvSamp=@
    // Create a test string with just the part between quotes.

    WCHAR wcTest[MAX_PATH+1];
    wcscpy(wcTest,ObjectPath);
    WCHAR * pwcTest, * pwcCompare = NULL;
    int iNumQuotes = 0;
    for(pwcTest = wcTest; *pwcTest; pwcTest++)
	{
        if(*pwcTest == L'\"')
        {
            iNumQuotes++;
            if(iNumQuotes == 1)
            {
                pwcCompare = pwcTest+1;
            }
            else if(iNumQuotes == 2)
            {
                *pwcTest = NULL;
                break;
            }
        }
        else if((*pwcTest == L'.') || (*pwcTest == L'='))
            *pwcTest = NULL;    // issolate the class name.
	}

    // check the instance list for a match.
	if(m_pInstance == NULL)
	{
		sc = CreateInst(m_pNamespace,&m_pInstance, wcTest, pCtx);
		if(sc == S_OK)
		{
			return sc;
		}
		else
		{
			m_pInstance = NULL;
		}
	}
	else
	{
		return S_OK;
	}

    return WBEM_E_NOT_FOUND;
}

/************************************************************************/
/*																		*/
/*	NAME	:	CFMInstProvider::CreateInst()							*/
/*																		*/
/*	PURPOSE :	Creates a new instance and sets the inital values of	*/
/*				the properties											*/
/*																		*/
/*	INPUT	:	IWbemServices*     - pointer to namespace				*/
/*				IWbemClassObject** - New object							*/
/*				WCHAR *			   - Class Name							*/
/*				IWbemContext       - Context							*/
/*																		*/
/*	OUTPUT	:	Standard COM Interface									*/
/*																		*/
/************************************************************************/
SCODE CFMInstProvider::CreateInst(IWbemServices * pNamespace, IWbemClassObject ** pNewInst,
                                        WCHAR * pwcClassName,
										IWbemContext  *pCtx)
{   
    SCODE sc;
    IWbemClassObject * pClass;
    sc = pNamespace->GetObject(pwcClassName, 0, pCtx, &pClass, NULL);
    if(sc != S_OK)
	{
        return WBEM_E_FAILED;
	}

    sc = pClass->SpawnInstance(0, pNewInst);
    pClass->Release();
    if(FAILED(sc))
	{
        return sc;
	}

	//Populate the Values from the FMStocks_DB DLL
	if(PopulateDBValues(*pNewInst) == E_FAIL)
		return E_FAIL;

	//Populate the Values from FMStocks_Bus DLL
	if(PopulateBusValues(*pNewInst) == E_FAIL)
		return E_FAIL;

	if(PopulatePluginParams(*pNewInst) == E_FAIL)
		return E_FAIL;
		
    return sc;
}

/****************************************************************************/
/*																			*/
/*	NAME	:	CFMInstProvider::ParseDSN()									*/
/*																			*/
/*	PURPOSE :	Parse the DSN string and returns the different parameters	*/
/*				the properties												*/
/*																			*/
/*	INPUT	:	VARIANT   - DSN String 										*/
/*				VARIANT * - array of VARIANT for different values in the	*/
/*							DSN string										*/
/*				WCHAR *			   - Class Name								*/
/*				IWbemContext       - Context								*/
/*																			*/
/*	OUTPUT	:	Standard COM Interface										*/
/*																			*/
/****************************************************************************/
void CFMInstProvider::ParseDSN(VARIANT vt,VARIANT *vtValues)
{
	//Sample DSN
	//Provider=SQLOLEDB;Data Source=a-vkanna1;Database=stocks;User Id=stocks_login;Password=password;
	_bstr_t b(vt.bstrVal);
	TCHAR strTemp[1024];
	int nField = 0;

	while(nField != NUM_FIELDS)
	{
		LPTSTR temp = b;
		int len = _tcslen(strFields[nField]);
		//Check for the string Provider=
		while(*temp != NULL)
		{
			if(_tcsnicmp(temp,strFields[nField],len) == 0)
			{
				temp += len;
				
				//Copy till the next ';'
				int cnt = 0;

				while((*temp != NULL) && (*temp != ';'))
				{
					strTemp[cnt++] = *temp;
					temp++;
				}
				strTemp[cnt] = 0;

				//This is the Value we want
				vtValues[nField].vt = VT_BSTR;
				vtValues[nField].bstrVal = SysAllocString(_bstr_t(strTemp));

				//Go to the next field
				nField++;
				break;
			}
			else
			{
				temp ++;
				if(*temp == NULL)
				{
					//The field is not found. Atleast find the next field
					nField++;
				}
			}
		}
	}
}

/****************************************************************************/
/*																			*/
/*	NAME	:	CFMInstProvider::PopulateDBValues()							*/
/*																			*/
/*	PURPOSE :	Populated the values from the FMStocks_DB COM DLL			*/
/*																			*/
/*	INPUT	:	IWbemClassObject * - The object to which the values are to	*/
/*									 be populated 							*/
/*																			*/
/*	OUTPUT	:	Standard COM Interface										*/
/*																			*/
/****************************************************************************/
HRESULT CFMInstProvider::PopulateDBValues(IWbemClassObject *pNewObj)
{
	//Get the DAL Version Number and populate it
	IDispatch *pDispatch;
	CLSID clsId;

	HRESULT hr = CLSIDFromProgID(L"FMStocks_DB.Version",&clsId);
	if(FAILED(hr))
	{
		return E_FAIL;
	}

	hr = CoCreateInstance(clsId,NULL,CLSCTX_ALL,IID_IDispatch,(void **)&pDispatch);
	if(FAILED(hr))
	{
		return E_FAIL;
	}

	DISPID dispId;
	OLECHAR FAR* szMember = L"Version";
	VARIANT vt;
	DISPPARAMS  dp;

	memset((void *)&dp,0,sizeof(DISPPARAMS));
	VariantInit(&vt);

	hr = pDispatch->GetIDsOfNames(IID_NULL,&szMember,1,LOCALE_SYSTEM_DEFAULT,&dispId);
	if(FAILED(hr))
	{
		pDispatch->Release();
		return E_FAIL;
	}

	hr = pDispatch->Invoke(dispId,IID_NULL,LOCALE_SYSTEM_DEFAULT,DISPATCH_METHOD,&dp,&vt,NULL,NULL);
	if(FAILED(hr))
	{
		pDispatch->Release();
		return E_FAIL;
	}

	hr = pNewObj->Put(L"DBVersion", 0, &vt, 0);

	//Get the ComputerName()

	szMember = L"ComputerName";

	memset((void *)&dp,0,sizeof(DISPPARAMS));
	VariantInit(&vt);

	hr = pDispatch->GetIDsOfNames(IID_NULL,&szMember,1,LOCALE_SYSTEM_DEFAULT,&dispId);
	if(FAILED(hr))
	{
		pDispatch->Release();
		return E_FAIL;
	}

	hr = pDispatch->Invoke(dispId,IID_NULL,LOCALE_SYSTEM_DEFAULT,DISPATCH_METHOD,&dp,&vt,NULL,NULL);
	if(FAILED(hr))
	{
		pDispatch->Release();
		return E_FAIL;
	}

	hr = pNewObj->Put(L"DBCompName", 0, &vt, 0);
	
	//Get the DSN()

	szMember = L"DSN";

	memset((void *)&dp,0,sizeof(DISPPARAMS));
	VariantInit(&vt);

	hr = pDispatch->GetIDsOfNames(IID_NULL,&szMember,1,LOCALE_SYSTEM_DEFAULT,&dispId);
	if(FAILED(hr))
	{
		pDispatch->Release();
		return E_FAIL;
	}

	hr = pDispatch->Invoke(dispId,IID_NULL,LOCALE_SYSTEM_DEFAULT,DISPATCH_METHOD,&dp,&vt,NULL,NULL);
	if(FAILED(hr))
	{
		pDispatch->Release();
		return E_FAIL;
	}

//	hr = pNewObj->Put(L"DBDSN", 0, &vt, 0);

	VARIANT vtVals[5];

	ParseDSN(vt,vtVals);

	hr = pNewObj->Put(L"DBProvider", 0, &vtVals[0], 0);
	hr = pNewObj->Put(L"DBDataSource", 0, &vtVals[1], 0);
	hr = pNewObj->Put(L"DBName", 0, &vtVals[2], 0);
	hr = pNewObj->Put(L"DBUserId", 0, &vtVals[3], 0);
	hr = pNewObj->Put(L"DBPassword", 0, &vtVals[4], 0);

	pDispatch->Release();

	return S_OK;

}

/****************************************************************************/
/*																			*/
/*	NAME	:	CFMInstProvider::PopulateBusValues()						*/
/*																			*/
/*	PURPOSE :	Populated the values from the FMStocks_Bus COM DLL			*/
/*																			*/
/*	INPUT	:	IWbemClassObject * - The object to which the values are to	*/
/*									 be populated 							*/
/*																			*/
/*	OUTPUT	:	Standard COM Interface										*/
/*																			*/
/****************************************************************************/
HRESULT CFMInstProvider::PopulateBusValues(IWbemClassObject *pNewObj)
{
	IDispatch *pDispatch;
	CLSID clsId;

	HRESULT hr;

	hr = CLSIDFromProgID(L"FMStocks_Bus.Version",&clsId);
	if(FAILED(hr))
	{
		return E_FAIL;
	}

	hr = CoCreateInstance(clsId,NULL,CLSCTX_ALL,IID_IDispatch,(void **)&pDispatch);
	if(FAILED(hr))
	{
		return E_FAIL;
	}

	DISPID dispId;
	OLECHAR FAR* szMember = L"Version";
	VARIANT vt;
	DISPPARAMS  dp;

	//Get the Version()

	szMember = L"Version";

	memset((void *)&dp,0,sizeof(DISPPARAMS));
	VariantInit(&vt);

	hr = pDispatch->GetIDsOfNames(IID_NULL,&szMember,1,LOCALE_SYSTEM_DEFAULT,&dispId);
	if(FAILED(hr))
	{
		pDispatch->Release();
		return E_FAIL;
	}

	hr = pDispatch->Invoke(dispId,IID_NULL,LOCALE_SYSTEM_DEFAULT,DISPATCH_METHOD,&dp,&vt,NULL,NULL);
	if(FAILED(hr))
	{
		pDispatch->Release();
		return E_FAIL;
	}

	hr = pNewObj->Put(L"BusVersion", 0, &vt, 0);

	//Get the ComputerName()

	szMember = L"ComputerName";

	memset((void *)&dp,0,sizeof(DISPPARAMS));
	VariantInit(&vt);

	hr = pDispatch->GetIDsOfNames(IID_NULL,&szMember,1,LOCALE_SYSTEM_DEFAULT,&dispId);
	if(FAILED(hr))
	{
		pDispatch->Release();
		return E_FAIL;
	}

	hr = pDispatch->Invoke(dispId,IID_NULL,LOCALE_SYSTEM_DEFAULT,DISPATCH_METHOD,&dp,&vt,NULL,NULL);
	if(FAILED(hr))
	{
		pDispatch->Release();
		return E_FAIL;
	}

	hr = pNewObj->Put(L"BusCompName", 0, &vt, 0);

	pDispatch->Release();

	return S_OK;
}

/****************************************************************************/
/*																			*/
/*	NAME	:	CFMInstProvider::PopulatePluginParams()						*/
/*																			*/
/*	PURPOSE :	Populated the values of the GAM plugin Params				*/
/*																			*/
/*	INPUT	:	IWbemClassObject * - The object to which the values are to	*/
/*									 be populated 							*/
/*																			*/
/*	OUTPUT	:	Standard COM Interface										*/
/*																			*/
/****************************************************************************/
HRESULT CFMInstProvider::PopulatePluginParams(IWbemClassObject *pNewObj)
{
    TCHAR  lpSubKey[50];
    TCHAR  szRegValue[255];
    DWORD dwValType;
    HKEY  GamKey;
    DWORD dwDataBuffSize;
    long  lRegRetCode;
	VARIANT vtValue;
	HRESULT hr;

    _tcscpy(lpSubKey, _T("FMGAM.GAM\\CurVer"));

    lRegRetCode = 
      RegOpenKeyEx( HKEY_CLASSES_ROOT,    // handle to open key
                    lpSubKey,             // address of name of subkey to open
                    0l,                   // reserved
                    KEY_READ,             // security access mask
                    &GamKey);             // address of handle to open key

    if ( lRegRetCode != ERROR_SUCCESS )
      return E_FAIL;

    dwDataBuffSize = 255;
    lRegRetCode = 
      RegQueryValueEx( GamKey,            // handle to key to query
                       NULL,              // address of name of value to query
                       NULL,              // reserved
                       &dwValType,        // address of buffer for value type
                       (LPBYTE)szRegValue,// value
                       &dwDataBuffSize);  // address of data buffer size

    if ( lRegRetCode != ERROR_SUCCESS )
      return E_FAIL;

    lRegRetCode = RegCloseKey(GamKey);
    if( lRegRetCode != ERROR_SUCCESS )    // An error occurred closing the registry
      return E_FAIL;


	_tcscpy(lpSubKey,szRegValue);
	_tcscat(lpSubKey, _T("\\PlugInParms"));

    lRegRetCode = 
      RegOpenKeyEx( HKEY_CLASSES_ROOT,    // handle to open key
                    lpSubKey,             // address of name of subkey to open
                    0l,                   // reserved
                    KEY_READ,             // security access mask
                    &GamKey);             // address of handle to open key

	//Now find out the GAM Plugin 

    dwDataBuffSize = 255;
    lRegRetCode = 
      RegQueryValueEx( GamKey,            // handle to key to query
                       _T("PlugInProgID"),    // address of name of value to query
                       NULL,              // reserved
                       &dwValType,        // address of buffer for value type
                       (LPBYTE)szRegValue,  // value
                       &dwDataBuffSize);  // address of data buffer size

    if( lRegRetCode != ERROR_SUCCESS )
      return E_FAIL;
	
	//Trim the string till the first occurance of a '.'
	for(int i = 0; ((szRegValue[i] != _T('.')) && (szRegValue[i] != _T('\0')));i++);
	szRegValue[i] = _T('\0');

	VariantInit(&vtValue);
	vtValue.vt = VT_BSTR;

	if(_tcsicmp(szRegValue,_T("GAMSQL")) == 0)
	{
		//SQL Plugin
		vtValue.bstrVal = SysAllocString(L"SQL Server");
	}
	else if(_tcsicmp(szRegValue,_T("GAMORACLE")) == 0)
	{
		//Oracle Plugin
		vtValue.bstrVal = SysAllocString(L"Oracle Server");
	}
	else if(_tcsicmp(szRegValue,_T("GAMCOMTI")) == 0)
	{
		//Sql Plugin
		vtValue.bstrVal = SysAllocString(L"COM TI");
	}
	else
	{
		//Unknown Plugin
		vtValue.bstrVal = SysAllocString(L"Unknown");
	}

	hr = pNewObj->Put(L"GAMPlugin", 0, &vtValue, 0);
	SysFreeString(vtValue.bstrVal);
	

    dwDataBuffSize = 255;
    lRegRetCode = 
      RegQueryValueEx( GamKey,            // handle to key to query
                       _T("UserName"),    // address of name of value to query
                       NULL,              // reserved
                       &dwValType,        // address of buffer for value type
                       (LPBYTE)szRegValue,  // value
                       &dwDataBuffSize);  // address of data buffer size

    if( lRegRetCode != ERROR_SUCCESS )
      return E_FAIL;

	VariantInit(&vtValue);

	vtValue.vt = VT_BSTR;
	vtValue.bstrVal = SysAllocString(_bstr_t(szRegValue));
	hr = pNewObj->Put(L"GAMUserName", 0, &vtValue, 0);
	SysFreeString(vtValue.bstrVal);

    dwDataBuffSize = 255;
    lRegRetCode = 
      RegQueryValueEx( GamKey,            // handle to key to query
                       _T("Password"),    // address of name of value to query
                       NULL,              // reserved
                       &dwValType,        // address of buffer for value type
                       (LPBYTE)szRegValue, // value
                       &dwDataBuffSize);  // address of data buffer size

    if( lRegRetCode != ERROR_SUCCESS )
      return E_FAIL;

	VariantInit(&vtValue);

	vtValue.vt = VT_BSTR;
	vtValue.bstrVal = SysAllocString(_bstr_t(szRegValue));
	hr = pNewObj->Put(L"GAMPassword", 0, &vtValue, 0);
	SysFreeString(vtValue.bstrVal);

    dwDataBuffSize = 255;
    lRegRetCode = 
      RegQueryValueEx( GamKey,            // handle to key to query
                       "ServerName",      // address of name of value to query
                       NULL,              // reserved
                       &dwValType,        // address of buffer for value type
                       (LPBYTE)szRegValue, // value
                       &dwDataBuffSize);  // address of data buffer size

    if( lRegRetCode != ERROR_SUCCESS )
      return E_FAIL;

	VariantInit(&vtValue);

	vtValue.vt = VT_BSTR;
	vtValue.bstrVal = SysAllocString(_bstr_t(szRegValue));
	hr = pNewObj->Put(L"GAMServerName", 0, &vtValue, 0);
	SysFreeString(vtValue.bstrVal);

    lRegRetCode = RegCloseKey(GamKey);
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vside\fmstocks\fminstprov\fminstprovider.h ===
////////////////////////////////////////////////////////////////////////
//
//	FMInstProvider.h
//
//	Module:	WMI Instance provider for F&M Stocks
//
//  This is the class factory and instance provider implementation 
//
//  History:
//	a-vkanna      3-April-2000		Initial Version
//
//  Copyright (c) 2000 Microsoft Corporation
//
////////////////////////////////////////////////////////////////////////

#ifndef _FMStocks_InstProvider_H_
#define _FMStocks_InstProvider_H_

#include <wbemprov.h>
#include <tchar.h>

typedef LPVOID * PPVOID;

#define MAX_LEN_USER_NAME   30
#define LEN_DATE_TIME		19
#define NUM_FIELDS			5

/************************************************************************
 *																	    *
 *		Class CFMInstProvider											*
 *																		*
 *			The Instance Provider class for FMStocks implements			*
 *			IWbemServices and IWbemProviderInit							*
 *																		*
 ************************************************************************/
class CFMInstProvider : public IWbemServices, public IWbemProviderInit
{
    protected:
        ULONG m_cRef;					//Object reference count
        IWbemServices *  m_pNamespace;	//Namespace
	    IWbemClassObject * m_pInstance;	//The one and only instance of the object
		TCHAR m_strLogFileName[1024];	//The log File Name to hold the login failure events
		HANDLE m_hFile;					//Handle to the shared ememory for the lookup time
		long *m_lCtr;					//Pointer to the lookuptime counter

		HKEY m_hKey;

     public:
//        CFMInstProvider(BSTR ObjectPath = NULL, BSTR User = NULL, BSTR Password = NULL, IWbemContext * pCtx=NULL);
        CFMInstProvider();
        ~CFMInstProvider();

		/************ IUNKNOWN METHODS ******************/

		STDMETHODIMP QueryInterface(/* [in]  */ REFIID riid, 
									/* [out] */ void** ppv);
		STDMETHODIMP_(ULONG) AddRef();
		STDMETHODIMP_(ULONG) Release();

		/********** IWBEMPROVIDERINIT METHODS ************/

        HRESULT STDMETHODCALLTYPE Initialize(
             /* [in] */ LPWSTR pszUser,
             /* [in] */ LONG lFlags,
             /* [in] */ LPWSTR pszNamespace,
             /* [in] */ LPWSTR pszLocale,
             /* [in] */ IWbemServices *pNamespace,
             /* [in] */ IWbemContext *pCtx,
             /* [in] */ IWbemProviderInitSink *pInitSink
                        );

		/************ IWBEMSERVICES METHODS **************/
		//We will implement only the functions which is of importance to us

		HRESULT STDMETHODCALLTYPE OpenNamespace( 
			/* [in] */ const BSTR Namespace,
			/* [in] */ long lFlags,
			/* [in] */ IWbemContext __RPC_FAR *pCtx,
			/* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
			/* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult) 
		{
			return WBEM_E_NOT_SUPPORTED;
		};
        
        HRESULT STDMETHODCALLTYPE CancelAsyncCall( 
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink) 
		  {
				return WBEM_E_NOT_SUPPORTED;
		  };
        
        HRESULT STDMETHODCALLTYPE QueryObjectSink( 
            /* [in] */ long lFlags,
            /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler) 
		{
			return WBEM_E_NOT_SUPPORTED;
		}
        
        HRESULT STDMETHODCALLTYPE GetObject( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult)
		{
			return WBEM_E_NOT_SUPPORTED;
		}
        
        HRESULT STDMETHODCALLTYPE GetObjectAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        HRESULT STDMETHODCALLTYPE PutClass( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult)
		{
			return WBEM_E_NOT_SUPPORTED;
		}
        
        HRESULT STDMETHODCALLTYPE PutClassAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) 
		{
			return WBEM_E_NOT_SUPPORTED;
		}
        
        HRESULT STDMETHODCALLTYPE DeleteClass( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) 
		{
			return WBEM_E_NOT_SUPPORTED;
		}
        
        HRESULT STDMETHODCALLTYPE DeleteClassAsync( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
		{
			return WBEM_E_NOT_SUPPORTED;
		}
        
        HRESULT STDMETHODCALLTYPE CreateClassEnum( 
            /* [in] */ const BSTR Superclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) 
		{
			return WBEM_E_NOT_SUPPORTED;
		}
        
        HRESULT STDMETHODCALLTYPE CreateClassEnumAsync( 
            /* [in] */ const BSTR Superclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) 
		{
			return WBEM_E_NOT_SUPPORTED;
		}
        
        HRESULT STDMETHODCALLTYPE PutInstance( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult)
		{
			return WBEM_E_NOT_SUPPORTED;
		}
        
        HRESULT STDMETHODCALLTYPE PutInstanceAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) 
		{
			return WBEM_E_NOT_SUPPORTED;
		};
        
        HRESULT STDMETHODCALLTYPE DeleteInstance( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult)
		{
			return WBEM_E_NOT_SUPPORTED;
		};
        
        HRESULT STDMETHODCALLTYPE DeleteInstanceAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
		{
			return WBEM_E_NOT_SUPPORTED;
		};
        
        HRESULT STDMETHODCALLTYPE CreateInstanceEnum( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum)
		{
			return WBEM_E_NOT_SUPPORTED;
		};
        
        HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        HRESULT STDMETHODCALLTYPE ExecQuery( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum)
		{
			return WBEM_E_NOT_SUPPORTED;
		};
        
        HRESULT STDMETHODCALLTYPE ExecQueryAsync( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
		{
			return WBEM_E_NOT_SUPPORTED;
		};
        
        HRESULT STDMETHODCALLTYPE ExecNotificationQuery( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum)
		{
			return WBEM_E_NOT_SUPPORTED;
		};
        
        HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) 
		{
			return WBEM_E_NOT_SUPPORTED;
		};
        
        HRESULT STDMETHODCALLTYPE ExecMethod( const BSTR, const BSTR, long, IWbemContext*,
            IWbemClassObject*, IWbemClassObject**, IWbemCallResult**)
		{
			return WBEM_E_NOT_SUPPORTED;
		};

        HRESULT STDMETHODCALLTYPE ExecMethodAsync( const BSTR, const BSTR, long, 
            IWbemContext*, IWbemClassObject*, IWbemObjectSink*);

		
		/************ LOCAL METHODS **************/

        //used to create an instance given a particular Path value
		SCODE GetByPath( BSTR Path, IWbemContext  *pCtx);

		//used to create an instance of the one & only FMStocks WMI Class
		SCODE CreateInst( IWbemServices * pNamespace, IWbemClassObject ** pNewInst,
                                             WCHAR * pwcClassName,
											 IWbemContext  *pCtx); 

		//Function to parse the given DSN string
		void ParseDSN(VARIANT vt,VARIANT *vtValues);

		//Function to populate the values from the FMStocks_DB COM DLL
		HRESULT PopulateDBValues(IWbemClassObject *pNewObj);

		//Function to populate the values from the FMStocks_Bus COM DLL
		HRESULT PopulateBusValues(IWbemClassObject *pNewObj);

		//Function to populate the FMGAM plugin params
		HRESULT PopulatePluginParams(IWbemClassObject *pNewObj);
};

/************************************************************************
 *																	    *
 *		GLOBAL EXTERN VARIABLES											*
 *																		*
 *			used to keep track of reference counts						*
 *																		*
 ************************************************************************/
// These variables keep track of when the module can be unloaded
extern long g_lObjects;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vside\fmstocks\fminstprov\wbemdcpl_i.c ===
/* this file contains the actual definitions of */
/* the IIDs and CLSIDs */

/* link this file in with the server and any clients */


/* File created by MIDL compiler version 5.01.0164 */
/* at Thu Mar 30 13:56:58 2000
 */
/* Compiler settings for WbemDCpl.idl:
    Os (OptLev=s), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )
#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

const IID IID_IWbemDecoupledEventSink = {0xCD94EBF2,0xE622,0x11d2,{0x9C,0xB3,0x00,0x10,0x5A,0x1F,0x48,0x01}};


const IID LIBID_PassiveSink = {0xE002EEEF,0xE6EA,0x11d2,{0x9C,0xB3,0x00,0x10,0x5A,0x1F,0x48,0x01}};


const CLSID CLSID_PseudoSink = {0xE002E4F0,0xE6EA,0x11d2,{0x9C,0xB3,0x00,0x10,0x5A,0x1F,0x48,0x01}};

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vside\fmstocks\fmstocks_evecons\fmeventconsumer.h ===
////////////////////////////////////////////////////////////////////////
//
//	FMEventConsumer.h
//
//	Module:	WMI Event Consumer for F&M Stocks
//
//  Event consumer class definition
//
//  History:
//	a-vkanna      3-April-2000		Initial Version
//
//  Copyright (c) 2000 Microsoft Corporation
//
////////////////////////////////////////////////////////////////////////
#include <wbemcli.h>
#include <wbemprov.h>

#define MAX_LEN_USER_NAME   30		//Maximum Size of the user name
#define LEN_DATE_TIME		19		//Size of Date Time

//Structure describing a LoginFail Event
struct sLoginFail
{
	TCHAR strUserName[MAX_LEN_USER_NAME+sizeof(TCHAR)];
	TCHAR strDateTime[LEN_DATE_TIME+sizeof(TCHAR)];
};

/************************************************************************
 *																	    *
 *		Class CFMEventConsumer											*
 *																		*
 *			The Event Consumer class for FMStocks implements			*
 *			IWbemUnboundObjectSink										*
 *																		*
 ************************************************************************/
class CFMEventConsumer : public IWbemUnboundObjectSink
{
	public:
		CFMEventConsumer();
		~CFMEventConsumer() {};

		/************ IUNKNOWN METHODS ******************/
		
		STDMETHODIMP QueryInterface(/* [in]  */ REFIID riid, 
									/* [out] */ void** ppv);
		STDMETHODIMP_(ULONG) AddRef();
		STDMETHODIMP_(ULONG) Release();

		/******* IWBEMUNBOUNDOBJECTSINK METHODS ********/

		STDMETHOD(IndicateToConsumer)(/* [in] */ IWbemClassObject *pLogicalConsumer,
									  /* [in] */ long lNumObjects,
									  /* [in] */ IWbemClassObject **ppObjects);

	private:

		DWORD m_cRef;				//Object reference count
		TCHAR m_logFileName[1024];	//Log file name to write the received events
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vside\fmstocks\fmstocks_evecons\classfactory.cpp ===
////////////////////////////////////////////////////////////////////////
//
//	ClassFactory.cpp
//
//	Module:	WMI Event Consumer for F&M Stocks
//
//  This is the class factory implementation 
//
//  History:
//	a-vkanna      3-April-2000		Initial Version
//
//  Copyright (c) 2000 Microsoft Corporation
//
////////////////////////////////////////////////////////////////////////

#include <windows.h>

#include "ClassFactory.h"
#include "FMEventsProv.h"

extern long g_lObjects;
extern long g_lLocks;

//////////////////////////////////////////////////////////////
//
//
//	CClassFactory
//
//
//////////////////////////////////////////////////////////////

STDMETHODIMP CClassFactory::QueryInterface(REFIID riid, void** ppv)
//////////////////////////////////////////////////////////////
//
//	Standard QueryInterface
//
//	Parameters:
//		riid	- the ID of the requested interface
//		ppv		- a pointer to the interface pointer
//
//////////////////////////////////////////////////////////////
{
    if(riid == IID_IUnknown)
        *ppv = (LPVOID)(IUnknown*)this;
    else if(riid == IID_IClassFactory)
        *ppv = (LPVOID)(IClassFactory*)this;
	else return E_NOINTERFACE;

	((IUnknown*)*ppv)->AddRef();
	return S_OK;
}

STDMETHODIMP_(ULONG) CClassFactory::AddRef()
//////////////////////////////////////////////////////////////
//
//	Standard COM AddRef
//
//////////////////////////////////////////////////////////////
{
    return InterlockedIncrement(&m_lRef);
}

STDMETHODIMP_(ULONG) CClassFactory::Release()
//////////////////////////////////////////////////////////////
//
//	Standard COM Release
//
//////////////////////////////////////////////////////////////
{
    long lRef = InterlockedDecrement(&m_lRef);
    if(lRef == 0)
        delete this;

    return lRef;
}

STDMETHODIMP CClassFactory::CreateInstance(
		/* [in] */ IUnknown* pUnknownOuter, 
		/* [in] */ REFIID iid, 
		/* [out] */ LPVOID *ppv)
//////////////////////////////////////////////////////////////
//
//	Standard COM CreateInstance
//
//////////////////////////////////////////////////////////////
{
	HRESULT hRes;
	*ppv = NULL;

	// We do not support aggregation
	if (pUnknownOuter)
		return CLASS_E_NOAGGREGATION;

	// Create the provider object
	CFMEventsProv*   pProvider = NULL;
	pProvider = new CFMEventsProv();

	if (!pProvider)
		return E_OUTOFMEMORY;

	// Retrieve the requested interface
	hRes = pProvider->QueryInterface(iid, ppv);
	if (FAILED(hRes))
	{
		delete pProvider;
		return hRes;
	}

	return S_OK;
}

STDMETHODIMP CClassFactory::LockServer(
		/* [in] */ BOOL bLock)
//////////////////////////////////////////////////////////////
//
//	Standard COM LockServer
//
//////////////////////////////////////////////////////////////
{
	if (bLock)
		InterlockedIncrement(&g_lLocks);
	else
		InterlockedDecrement(&g_lLocks);

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vside\fmstocks\fmstocks_evecons\classfactory.h ===
////////////////////////////////////////////////////////////////////////
//
//	ClassFactory.h
//
//	Module:	WMI Event Consumer for F&M Stocks
//
//  This is the class factory implementation 
//
//  History:
//	a-vkanna      3-April-2000		Initial Version
//
//  Copyright (c) 2000 Microsoft Corporation
//
////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////
//
//	CClassFactory
//
//////////////////////////////////////////////////////////////

class CClassFactory : public IClassFactory
{
	protected:
		long	m_lRef;

	public:

		CClassFactory() : m_lRef(0) {}

		/************ IUNKNOWN METHODS ******************/

		STDMETHODIMP QueryInterface(/* [in]  */ REFIID riid, 
									/* [out] */ void** ppv);
		STDMETHODIMP_(ULONG) AddRef();
		STDMETHODIMP_(ULONG) Release();

		/*********** ICLASSFACTORY METHODS **************/

		STDMETHODIMP CreateInstance(
			/* [in] */ IUnknown* pUnknownOuter, 
			/* [in] */ REFIID iid, 
			/* [out] */ LPVOID *ppv);	

		STDMETHODIMP LockServer(
			/* [in] */ BOOL bLock);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vside\fmstocks\fmstocks_evecons\fmeventsprov.cpp ===
////////////////////////////////////////////////////////////////////////
//
//	FMEventsProv.cpp
//
//	Module:	WMI Event Consumer for F&M Stocks
//
//  Event consumer provider class implemetation
//
//  History:
//	a-vkanna      3-April-2000		Initial Version
//
//  Copyright (c) 2000 Microsoft Corporation
//
////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <objbase.h>
#include <tchar.h>

#include "FMEventsProv.h"
#include "FMEventConsumer.h"
/************************************************************************
 *																	    *
 *		Class CFMEventsProv												*
 *																		*
 *			The Event Consumer Provider class for FMStocks implements	*
 *			IWbemProviderInit and IWbemEventConsumerProvider			*
 *																		*
 ************************************************************************/
/************ IUNKNOWN METHODS ******************/
/************************************************************************/
/*																		*/
/*	NAME	:	CFMEventsProv::QueryInterface()							*/
/*																		*/
/*	PURPOSE :	Standard COM interface. Doesn't need description		*/
/*																		*/
/*	INPUT	:	Standard COM Interface									*/
/*																		*/
/*	OUTPUT	:	Standard COM Interface									*/
/*																		*/
/************************************************************************/
STDMETHODIMP CFMEventsProv::QueryInterface(REFIID riid, LPVOID FAR *ppv)
{
    *ppv=NULL;

	if(riid == IID_IWbemUnboundObjectSink)
	{
		return FindConsumer(NULL,(IWbemUnboundObjectSink **)ppv);
	}

    if ((riid == IID_IUnknown) || (riid == IID_IWbemEventConsumerProvider) || (riid == IID_IWbemProviderInit))
        *ppv = this;

    if (*ppv != NULL)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return E_NOINTERFACE;
}

/************************************************************************/
/*																		*/
/*	NAME	:	CFMEventsProv::AddRef()									*/
/*																		*/
/*	PURPOSE :	Standard COM interface. Doesn't need description		*/
/*																		*/
/*	INPUT	:	Standard COM Interface									*/
/*																		*/
/*	OUTPUT	:	Standard COM Interface									*/
/*																		*/
/************************************************************************/
STDMETHODIMP_(ULONG) CFMEventsProv::AddRef()
{
    return ++m_cRef;
}

/************************************************************************/
/*																		*/
/*	NAME	:	CFMEventsProv::Release()								*/
/*																		*/
/*	PURPOSE :	Standard COM interface. Doesn't need description		*/
/*																		*/
/*	INPUT	:	Standard COM Interface									*/
/*																		*/
/*	OUTPUT	:	Standard COM Interface									*/
/*																		*/
/************************************************************************/
STDMETHODIMP_(ULONG) CFMEventsProv::Release()
{
    if (--m_cRef != 0L)
        return m_cRef;

    delete this;
    return 0L;
}

/********** IWBEMPROVIDERINIT METHODS ************/
/************************************************************************/
/*																		*/
/*	NAME	:	CFMEventsProv::Initialize()								*/
/*																		*/
/*	PURPOSE :	For initializing the Provider object					*/
/*																		*/
/*	INPUT	:	LPWSTR			- Pointer to the user name				*/
/*				long			- reserved								*/
/*				LPWSTR			- Namespace								*/
/*				LPWSTR			- Locale Name							*/
/*				IWbemServices*  - pointer to namespace					*/
/*				IWbemContext*   - The context							*/
/*				IWbemProviderInitSink - The sink object for init		*/
/*																		*/
/*	OUTPUT	:	Standard COM Interface									*/
/*																		*/
/************************************************************************/
STDMETHODIMP CFMEventsProv::Initialize(LPWSTR wszUser, LONG lFlags,
								   LPWSTR wszNamespace, LPWSTR wszLocale,
								   IWbemServices __RPC_FAR *pNamespace,
								   IWbemContext __RPC_FAR *pCtx,
								   IWbemProviderInitSink __RPC_FAR *pInitSink)
{
    // Tell CIMOM that we are initialized
    pInitSink->SetStatus(WBEM_S_INITIALIZED, 0);
    return WBEM_S_NO_ERROR;
}

/********** IWBEMEVENTCONSUMERPROVIDER METHODS ************/
/************************************************************************/
/*																		*/
/*	NAME	:	CFMEventsProv::FindConsumer()							*/
/*																		*/
/*	PURPOSE :	called to obtain the associated consumer event sink		*/
/*																		*/
/*	INPUT	:	IWbemClassObject*	     - The logical consumer object 	*/
/*				IWbemUnboundObjectSink** - event object sink			*/
/*																		*/
/*	OUTPUT	:	Standard COM Interface									*/
/*																		*/
/************************************************************************/
STDMETHODIMP CFMEventsProv::FindConsumer(
						IWbemClassObject* pLogicalConsumer,
						IWbemUnboundObjectSink** ppConsumer)
{
	CFMEventConsumer* pSink = new CFMEventConsumer();
    
	HRESULT hr = pSink->QueryInterface(IID_IWbemUnboundObjectSink, 
                                        (void**)ppConsumer);
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vside\fmstocks\fmstocks_evecons\fmeventsprov.h ===
////////////////////////////////////////////////////////////////////////
//
//	FMEventsProv.h
//
//	Module:	WMI Event Consumer for F&M Stocks
//
//  Event consumer provider class definition
//
//  History:
//	a-vkanna      3-April-2000		Initial Version
//
//  Copyright (c) 2000 Microsoft Corporation
//
////////////////////////////////////////////////////////////////////////
#include <wbemcli.h>
#include <wbemprov.h>

/************************************************************************
 *																	    *
 *		Class CFMEventsProv												*
 *																		*
 *			The Event Consumer Provider class for FMStocks implements	*
 *			IWbemProviderInit and IWbemEventConsumerProvider			*
 *																		*
 ************************************************************************/
class CFMEventsProv : public IWbemProviderInit , public IWbemEventConsumerProvider
{
	public:
		CFMEventsProv() : m_cRef(0L) {};
		~CFMEventsProv() {};

		/************ IUNKNOWN METHODS ******************/
		STDMETHODIMP QueryInterface(/* [in]  */ REFIID riid, 
									/* [out] */ void** ppv);
		STDMETHODIMP_(ULONG) AddRef();
		STDMETHODIMP_(ULONG) Release();

		/********** IWBEMPROVIDERINIT METHODS ************/

        HRESULT STDMETHODCALLTYPE Initialize(
             /* [in] */ LPWSTR pszUser,
             /* [in] */ LONG lFlags,
             /* [in] */ LPWSTR pszNamespace,
             /* [in] */ LPWSTR pszLocale,
             /* [in] */ IWbemServices *pNamespace,
             /* [in] */ IWbemContext *pCtx,
             /* [in] */ IWbemProviderInitSink *pInitSink
                        );

		/****** IWBEMEVENTCONSUMERPROVIDER METHODS *******/

		STDMETHOD(FindConsumer)(/* [in]  */ IWbemClassObject* pLogicalConsumer,
								/* [out] */ IWbemUnboundObjectSink** ppConsumer);

	private:
		DWORD m_cRef;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vside\fmstocks\fmstocks_evecons\fmeventconsumer.cpp ===
////////////////////////////////////////////////////////////////////////
//
//	FMEventConsumer.cpp
//
//	Module:	WMI Event Consumer for F&M Stocks
//
//  Event consumer class implemetation
//
//  History:
//	a-vkanna      3-April-2000		Initial Version
//
//  Copyright (c) 2000 Microsoft Corporation
//
////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include <objbase.h>
#include <tchar.h>
#include <wchar.h>
#include <stdio.h>
#include <comdef.h>

#include "FMEventConsumer.h"

/************************************************************************
 *																	    *
 *		Class CFMEventConsumer											*
 *																		*
 *			The Event Consumer class for FMStocks implements			*
 *			IWbemUnboundObjectSink										*
 *																		*
 ************************************************************************/
/************************************************************************/
/*																		*/
/*	NAME	:	CFMEventConsumer::CFMEventConsumer()					*/
/*																		*/
/*	PURPOSE :	Constructor												*/
/*																		*/
/*	INPUT	:	NONE													*/
/*																		*/ 
/*	OUTPUT	:	N/A														*/
/*																		*/
/************************************************************************/
CFMEventConsumer::CFMEventConsumer() : 	m_cRef(0L) 
{
	HKEY hKey = NULL;
	long lRet = -1;		//Some non zero value
	lRet = RegCreateKeyEx(HKEY_LOCAL_MACHINE,_T("Software\\VSInteropSample"),0,_T(""),
						  REG_OPTION_NON_VOLATILE,KEY_ALL_ACCESS,NULL,&hKey,NULL);

	if( lRet == ERROR_SUCCESS)
	{
		//Read the Data from the key LoginFail
		DWORD dwWritten = 1024*sizeof(TCHAR);
		lRet = RegQueryValueEx(hKey,_T("LoginFail"),0,NULL,(LPBYTE)m_logFileName,&dwWritten);
	}
	else
	{
		// Could not open the key or key does not exists
		// Try creating a default key in the temp directory
		TCHAR strTemp[1024];
		if(GetTempPath(1024*sizeof(TCHAR),strTemp) == 0)
		{
			//Last Chance. Create a directory c:\Logging Files
			CreateDirectory(_T("c:\\Logging Files"),NULL);
			_tcscpy(strTemp,_T("c:\\Logging Files\\"));
		}

		_tcscat(strTemp,_T("loginfail.txt"));
		//Write it to the registry
		RegSetValueEx(hKey,_T("loginFail"),0,REG_SZ,(LPBYTE)strTemp,_tcslen(strTemp)*sizeof(TCHAR));
		_tcscpy(m_logFileName,strTemp);
	}

	RegCloseKey(hKey);
}

/************ IUNKNOWN METHODS ******************/
/************************************************************************/
/*																		*/
/*	NAME	:	CFMEventConsumer::QueryInterface()						*/
/*																		*/
/*	PURPOSE :	Standard COM interface. Doesn't need description		*/
/*																		*/
/*	INPUT	:	Standard COM Interface									*/
/*																		*/
/*	OUTPUT	:	Standard COM Interface									*/
/*																		*/
/************************************************************************/
STDMETHODIMP CFMEventConsumer::QueryInterface(REFIID riid, LPVOID FAR *ppv)
{
    *ppv=NULL;

    if (riid == IID_IUnknown || riid == IID_IWbemUnboundObjectSink)
        *ppv=this;

    if (*ppv != NULL)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }
    return E_NOINTERFACE;
}

/************************************************************************/
/*																		*/
/*	NAME	:	CFMEventConsumer::AddRef()								*/
/*																		*/
/*	PURPOSE :	Standard COM interface. Doesn't need description		*/
/*																		*/
/*	INPUT	:	Standard COM Interface									*/
/*																		*/
/*	OUTPUT	:	Standard COM Interface									*/
/*																		*/
/************************************************************************/
STDMETHODIMP_(ULONG) CFMEventConsumer::AddRef(void)
{
    return ++m_cRef;
}

/************************************************************************/
/*																		*/
/*	NAME	:	CFMEventConsumer::Release()								*/
/*																		*/
/*	PURPOSE :	Standard COM interface. Doesn't need description		*/
/*																		*/
/*	INPUT	:	Standard COM Interface									*/
/*																		*/
/*	OUTPUT	:	Standard COM Interface									*/
/*																		*/
/************************************************************************/
STDMETHODIMP_(ULONG) CFMEventConsumer::Release(void)
{
    if (--m_cRef != 0L)
        return m_cRef;

    delete this;
    return 0L;
}

/********** IWBEMUNBOUNDOBJECTSINK METHODS ************/
/************************************************************************/
/*																		*/
/*	NAME	:	CFMEventConsumer::IndicateToConsumer()					*/
/*																		*/
/*	PURPOSE :	called to deliver the event to the sink					*/
/*																		*/
/*	INPUT	:	IWbemClassObject*  - The logical consumer object 		*/
/*				long			   - Number of objects					*/
/*				IWbemClassObject** - Actual array of event objects		*/
/*																		*/
/*	OUTPUT	:	Standard COM Interface									*/
/*																		*/
/************************************************************************/
STDMETHODIMP CFMEventConsumer::IndicateToConsumer(IWbemClassObject *pLogicalConsumer,
											long lNumObjects,
											IWbemClassObject **ppObjects)
{
	// NOTE: If this routine returns a failure code, including GPFs from called routines,
	// CIMOM will recreate the object and call here again. If you see this routine being
	// called twice for every indication, it means this routine is returning a failure code
	// somehow. Especially watch the AddRef()/Release() semantics for the embedded object.
	// If they're too low, you'll return a GPF.
	HRESULT  hRes;
	BSTR objName = NULL;
	BSTR propName = NULL;
	VARIANT pVal, vUnk;
	IUnknown *pUnk = NULL;
	IWbemClassObject *tgtInst = NULL;

	VariantInit(&pVal);
	VariantInit(&vUnk);

	propName = SysAllocString(L"UserName");

	HANDLE hFile = CreateFile(m_logFileName,GENERIC_READ | GENERIC_WRITE, 
								FILE_SHARE_READ | FILE_SHARE_WRITE,
								NULL,OPEN_ALWAYS,FILE_ATTRIBUTE_NORMAL,NULL);

	if(hFile == NULL)
	{
		return E_FAIL;
	}

	SetFilePointer(hFile,0,0,FILE_END);

	if ((hRes = ppObjects[0]->Get(propName, 0L, 
							&pVal, NULL, NULL)) == S_OK) 
	{
		// compose a string for the listbox.
		_bstr_t b = V_BSTR(&pVal);

		sLoginFail sLog;
		int slen = _tcslen(b);

		//Copy the user name
		_tcsncpy(sLog.strUserName,b,slen);

		while(slen < MAX_LEN_USER_NAME)
		{
			sLog.strUserName[slen] = _T(' ');
			slen++;
		}
		sLog.strUserName[MAX_LEN_USER_NAME] = _T('\0');

		//Copy the received date & time in the format MM/DD/YYYY HH:MM:SS
		SYSTEMTIME st;

		GetLocalTime(&st);
		_stprintf(sLog.strDateTime,_T("%02d/%02d/%02d %02d:%02d:%02d"),st.wMonth,
									st.wDay,st.wYear,st.wHour,st.wMinute,st.wSecond);
		sLog.strDateTime[19] = _T('\0');

		//Now Write the Event to the file
		DWORD dwWritten = 0;

		WriteFile(hFile,(LPVOID)sLog.strUserName,_tcslen(sLog.strUserName)*sizeof(TCHAR),&dwWritten,NULL);

		dwWritten = 0;

		WriteFile(hFile,(LPVOID)sLog.strDateTime,_tcslen(sLog.strDateTime)*sizeof(TCHAR),&dwWritten,NULL);
	}

	CloseHandle(hFile);
	SysFreeString(propName);
	SysFreeString(objName);
	VariantClear(&pVal);
	VariantClear(&vUnk);
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vside\fmstocks\fmstocks_evecons\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	FMStocks_EveCons.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vside\fmstocks\fmstocks_evecons\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__5624814D_B7B2_486A_ADED_3B73053E7C22__INCLUDED_)
#define AFX_STDAFX_H__5624814D_B7B2_486A_ADED_3B73053E7C22__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


// Insert your headers here
#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers

#include <windows.h>

// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__5624814D_B7B2_486A_ADED_3B73053E7C22__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vside\fmstocks\fmstocks_hiperfprovider\classfactory.h ===
////////////////////////////////////////////////////////////////////////
//
//	ClassFactory.h
//
//	Module:	WMI high performance provider for F&M Stocks
//
//  This is the class factory implementation 
//
//  History:
//	a-vkanna      3-April-2000		Initial Version
//
//  Copyright (c) 2000 Microsoft Corporation
//
////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////
//
//	CClassFactory
//
//////////////////////////////////////////////////////////////

class CClassFactory : public IClassFactory
{
	protected:
		long	m_lRef;

	public:
		CClassFactory() : m_lRef(0) {}

		/************ IUNKNOWN METHODS ******************/
		STDMETHODIMP QueryInterface(/* [in]  */ REFIID riid, 
									/* [out] */ void** ppv);
		STDMETHODIMP_(ULONG) AddRef();
		STDMETHODIMP_(ULONG) Release();

		/*********** ICLASSFACTORY METHODS **************/
		STDMETHODIMP CreateInstance(
			/* [in] */ IUnknown* pUnknownOuter, 
			/* [in] */ REFIID iid, 
			/* [out] */ LPVOID *ppv);	

		STDMETHODIMP LockServer(
			/* [in] */ BOOL bLock);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vside\fmstocks\fmstocks_evecons\fmstocks_evecons.cpp ===
////////////////////////////////////////////////////////////////////////
//
//  FMStocks_EveCons.cpp
//
//	Module:	WMI Event Consumer for F&M Stocks
//
//  Standard Com Server Implementation
//
//  History:
//	a-vkanna      3-April-2000		Initial Version
//
//  Copyright (c) 2000 Microsoft Corporation
//
////////////////////////////////////////////////////////////////////////

#include <windows.h>
#include <stdio.h>
#include <time.h>
#include <locale.h>
#include <initguid.h>
#include <tchar.h>

#include "ClassFactory.h"

/////////////////////////////////////////////////////////////////////////////
//
//  BEGIN CLSID SPECIFIC SECTION
//
//

// {F93D7FAE-0550-4ed7-B1E1-12FA9F6B1F49}
static const GUID CLSID_ProviderFactory = 
{0xf93d7fae, 0x550, 0x4ed7, 0xb1, 0xe1, 0x12, 0xfa, 0x9f, 0x6b, 0x1f, 0x49};

#define IMPLEMENTED_CLSID           CLSID_ProviderFactory
#define SERVER_REGISTRY_COMMENT     L"WMI Event Consumer Provider for FMStocks"

HINSTANCE g_hInstance;
long g_lLocks = 0;
long g_lObjects = 0;

//***************************************************************************
//
//  DllMain
//
//  Dll entry point.
//
//  PARAMETERS:
//
//      HINSTANCE hinstDLL      The handle to our DLL.
//      DWORD dwReason          DLL_PROCESS_ATTACH on load,
//                              DLL_PROCESS_DETACH on shutdown,
//                              DLL_THREAD_ATTACH/DLL_THREAD_DETACH otherwise.
//      LPVOID lpReserved       Reserved
//
//  RETURN VALUES:
//
//      TRUE is successful, FALSE if a fatal error occured.
//      NT behaves very ugly if FALSE is returned.
//
//***************************************************************************
BOOL WINAPI DllMain(
    HINSTANCE hinstDLL,
    DWORD dwReason,
    LPVOID lpReserved
    )
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        setlocale(LC_ALL, "");      // Set to the 'current' locale
        g_hInstance = hinstDLL;
    }

    return TRUE;
}

//***************************************************************************
//
//  DllGetClassObject
//
//  Standard OLE In-Process Server entry point to return an class factory
//  instance.
//
//  PARAMETERS:
//
//  RETURNS:
//
//      S_OK                Success
//      E_NOINTERFACE       An interface other that IClassFactory was asked for
//      E_OUTOFMEMORY
//      E_FAILED            Initialization failed, or an unsupported clsid was
//                          asked for.
//
//***************************************************************************

STDAPI DllGetClassObject(
    REFCLSID rclsid,
    REFIID riid,
    LPVOID * ppv
    )
{
    CClassFactory *pClassFactory = NULL;
	HRESULT hRes;

    //  Verify the caller is asking for our type of object
    if (IMPLEMENTED_CLSID == rclsid) 
	{
		// Create the class factory
		pClassFactory = new CClassFactory;

		if (!pClassFactory)
			return E_OUTOFMEMORY;
		
		hRes = pClassFactory->QueryInterface(riid, ppv);
		if (FAILED(hRes))
		{
			delete pClassFactory;
			return hRes;
		}
		hRes = S_OK;
	}
	else 
		hRes = CLASS_E_CLASSNOTAVAILABLE;

    return hRes;
}

//***************************************************************************
//
//  DllCanUnloadNow
//
//  Standard OLE entry point for server shutdown request. Allows shutdown
//  only if no outstanding objects or locks are present.
//
//  RETURN VALUES:
//
//      S_OK        May unload now.
//      S_FALSE     May not.
//
//***************************************************************************

STDAPI DllCanUnloadNow(void)
{
    HRESULT hRes = S_FALSE;

    if (0 == g_lLocks && 0 == g_lObjects)
        hRes = S_OK;

    return hRes;
}

//***************************************************************************
//
//  DllRegisterServer
//
//  Standard OLE entry point for registering the server.
//
//  RETURN VALUES:
//
//      S_OK        Registration was successful
//      E_FAIL      Registration failed.
//
//***************************************************************************

STDAPI DllRegisterServer(void)
{
    wchar_t Path[1024];
    wchar_t *pGuidStr = 0;
    wchar_t KeyPath[1024];

    // Get the dll's filename
    GetModuleFileNameW(g_hInstance, Path, 1024);

    // Convert CLSID to string.
    StringFromCLSID(IMPLEMENTED_CLSID, &pGuidStr);
    swprintf(KeyPath, L"Software\\Classes\\CLSID\\\\%s", pGuidStr);

    // Place it in registry.
	HKEY hKey;
    LONG lRes = RegCreateKeyW(HKEY_LOCAL_MACHINE, KeyPath, &hKey);
    if (lRes)
        return E_FAIL;

    wchar_t *pName = SERVER_REGISTRY_COMMENT; 
    RegSetValueExW(hKey, 0, 0, REG_SZ, (const BYTE *) pName, wcslen(pName) * 2 + 2);

    HKEY hSubkey;
    lRes = RegCreateKey(hKey, _T("InprocServer32"), &hSubkey);

    RegSetValueExW(hSubkey, 0, 0, REG_SZ, (const BYTE *) Path, wcslen(Path) * 2 + 2);
    RegSetValueExW(hSubkey, L"ThreadingModel", 0, REG_SZ, (const BYTE *) L"Both", wcslen(L"Both") * 2 + 2);

    RegCloseKey(hSubkey);
    RegCloseKey(hKey);

    CoTaskMemFree(pGuidStr);

    return S_OK;
}

//***************************************************************************
//
//  DllUnregisterServer
//
//  Standard OLE entry point for unregistering the server.
//
//  RETURN VALUES:
//
//      S_OK        Unregistration was successful
//      E_FAIL      Unregistration failed.
//
//***************************************************************************

STDAPI DllUnregisterServer(void)
{
    wchar_t *pGuidStr = 0;
    HKEY hKey;
    wchar_t KeyPath[256];

    StringFromCLSID(IMPLEMENTED_CLSID, &pGuidStr);
    swprintf(KeyPath, L"Software\\Classes\\CLSID\\\\%s", pGuidStr);

    // Delete InProcServer32 subkey.
    LONG lRes = RegOpenKeyW(HKEY_LOCAL_MACHINE, KeyPath, &hKey);
    if (lRes)
        return E_FAIL;

    RegDeleteKeyW(hKey, L"InprocServer32");
    RegCloseKey(hKey);

    // Delete CLSID GUID key.
    lRes = RegOpenKeyW(HKEY_LOCAL_MACHINE, L"Software\\Classes\\CLSID", &hKey);
    if (lRes)
        return E_FAIL;

    RegDeleteKeyW(hKey, pGuidStr);
    RegCloseKey(hKey);

    CoTaskMemFree(pGuidStr);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vside\fmstocks\fmstocks_hiperfprovider\classfactory.cpp ===
////////////////////////////////////////////////////////////////////////
//
//	ClassFactory.cpp
//
//	Module:	WMI high performance provider for F&M Stocks
//
//  This is the class factory implementation 
//
//  History:
//	a-vkanna      3-April-2000		Initial Version
//
//  Copyright (c) 2000 Microsoft Corporation
//
////////////////////////////////////////////////////////////////////////

#include <windows.h>

#include "HiPerfProvider.h"
#include "ClassFactory.h"

extern long g_lObjects;
extern long g_lLocks;

//////////////////////////////////////////////////////////////
//
//
//	CClassFactory
//
//
//////////////////////////////////////////////////////////////

STDMETHODIMP CClassFactory::QueryInterface(REFIID riid, void** ppv)
//////////////////////////////////////////////////////////////
//
//	Standard QueryInterface
//
//	Parameters:
//		riid	- the ID of the requested interface
//		ppv		- a pointer to the interface pointer
//
//////////////////////////////////////////////////////////////
{
    if(riid == IID_IUnknown)
        *ppv = (LPVOID)(IUnknown*)this;
    else if(riid == IID_IClassFactory)
        *ppv = (LPVOID)(IClassFactory*)this;
	else return E_NOINTERFACE;

	((IUnknown*)*ppv)->AddRef();
	return S_OK;
}

STDMETHODIMP_(ULONG) CClassFactory::AddRef()
//////////////////////////////////////////////////////////////
//
//	Standard COM AddRef
//
//////////////////////////////////////////////////////////////
{
    return InterlockedIncrement(&m_lRef);
}

STDMETHODIMP_(ULONG) CClassFactory::Release()
//////////////////////////////////////////////////////////////
//
//	Standard COM Release
//
//////////////////////////////////////////////////////////////
{
    long lRef = InterlockedDecrement(&m_lRef);
    if(lRef == 0)
        delete this;

    return lRef;
}

STDMETHODIMP CClassFactory::CreateInstance(
		/* [in] */ IUnknown* pUnknownOuter, 
		/* [in] */ REFIID iid, 
		/* [out] */ LPVOID *ppv)
//////////////////////////////////////////////////////////////
//
//	Standard COM CreateInstance
//
//////////////////////////////////////////////////////////////
{
	HRESULT hRes;
	CHiPerfProvider *pProvider = NULL;

	*ppv = NULL;

	// We do not support aggregation
	// =============================

	if (pUnknownOuter)
		return CLASS_E_NOAGGREGATION;

	// Create the provider object
	// ==========================

	pProvider = new CHiPerfProvider;

	if (!pProvider)
		return E_OUTOFMEMORY;

	// Retrieve the requested interface
	// ================================

	hRes = pProvider->QueryInterface(iid, ppv);
	if (FAILED(hRes))
	{
		delete pProvider;
		return hRes;
	}

	return S_OK;
}

STDMETHODIMP CClassFactory::LockServer(
		/* [in] */ BOOL bLock)
//////////////////////////////////////////////////////////////
//
//	Standard COM LockServer
//
//////////////////////////////////////////////////////////////
{
	if (bLock)
		InterlockedIncrement(&g_lLocks);
	else
		InterlockedDecrement(&g_lLocks);

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vside\fmstocks\fmstocks_hiperfprovider\hiperfprovider.cpp ===
////////////////////////////////////////////////////////////////////////
//
//  HiPerfProvider.cpp
//
//	Module:	WMI high performance provider for F&M Stocks
//
//  Implementation of the HiPerfoamce Provider Interfaces, 
//
//  History:
//	a-vkanna      3-April-2000		Initial Version
//
//  Copyright (c) 2000 Microsoft Corporation
//
////////////////////////////////////////////////////////////////////////
#include <windows.h>
#include <objbase.h>
//#include "..\..\unitrace\unitrace.h"

#include "HiPerfProvider.h"
extern long g_lObjects;

#define FILE_MAPPING_NAME	_T("FMSTOCKS_FILE_MAPPING_OBJECT_FOR_HIPERFORMACE_COUNTER")

/************************************************************************
 *																	    *
 *		Class CFMStocks_Refresher										*
 *																		*
 *			The Refresher class for FMStocks implements	IWBemRefresher	*
 *																		*
 ************************************************************************/
/************************************************************************/
/*																		*/
/*	NAME	:	CFMStocks_Refresher::CFMStocks_Refresher()				*/
/*																		*/
/*	PURPOSE :	Constructor												*/
/*																		*/
/*	INPUT	:	IWbemServices* - The namespace							*/
/*				long		   - The property handle identifying ID		*/
/*								 Property								*/
/*				long		   - The property handle identifying		*/
/*								 LookupTime Property					*/
/*																		*/ 
/*	OUTPUT	:	N/A														*/
/*																		*/
/************************************************************************/
CFMStocks_Refresher::CFMStocks_Refresher(long hID,long hLookupTime) : m_hID(hID), m_hLookupTime(hLookupTime)
{
	// Increment the global COM object counter
	InterlockedIncrement(&g_lObjects);

	// Initilialize the number of objects to 0
	m_numObjects = 0;

	//Initialize the Unique Id value 
	m_UniqId = 0;


/*	m_dwCtrSize = sizeof(long);
	DWORD dwDisp;
	if(RegCreateKeyEx(HKEY_LOCAL_MACHINE,_T("Software\\VSInteropSample"),0,_T(""),
					REG_OPTION_NON_VOLATILE,KEY_ALL_ACCESS,NULL,&m_hKey,&dwDisp) == ERROR_SUCCESS)
	{
		// Check to see whether the reg entry is already there.
		// The idea here is that if it is not there we will create 
		// a new one and initialize it to 0
		if(RegQueryValueEx(m_hKey,_T("LookupTimePerfCtr"),NULL,NULL,NULL,NULL) != ERROR_SUCCESS)
		{
			//Not exists.So create the value and initialize with 0
			DWORD dwZero = 0;
			RegSetValueEx(m_hKey,_T("LookupTimePerfCtr"),0,REG_DWORD,(LPBYTE)&dwZero,sizeof(DWORD));
		}
	}
	else
	{
		m_lCtr = 0;
	}

*/
	SECURITY_DESCRIPTOR sd;
	InitializeSecurityDescriptor(&sd,SECURITY_DESCRIPTOR_REVISION);

	SECURITY_ATTRIBUTES sa;
	sa.nLength = sizeof(SECURITY_ATTRIBUTES);
	sa.lpSecurityDescriptor = &sd;
	sa.bInheritHandle = TRUE;

	m_hFile = NULL;

	m_hFile = CreateFileMapping(INVALID_HANDLE_VALUE,&sa,PAGE_READWRITE | SEC_COMMIT,
									 0L, sizeof(long), FILE_MAPPING_NAME);
	if(m_hFile == NULL)
	{
		//Log((_T("Create File Mapping Failed"));
		m_lCtr = (long *)new long();
		*m_lCtr = 0;
	}
	else
	{
		//Log((_T("File Mapping Created Successfully"));
		//Log((_T("Before MapViewOfFile"));

		m_lCtr = (long *)MapViewOfFile(m_hFile,FILE_MAP_ALL_ACCESS,0L,0L,0L);

		if(m_lCtr == NULL)
		{
			//Log((_T("Cannot MapViewOfFile"));
			m_lCtr = (long *)new long();
			*m_lCtr = 0;
		}
		else
		{
			//Log((_T("Mapped View of File"));
			*m_lCtr = 0;
		}
	}
}

/************************************************************************/
/*																		*/
/*	NAME	:	CFMStocks_Refresher::CFMStocks_Refresher()				*/
/*																		*/
/*	PURPOSE :	Destructor												*/
/*																		*/
/*	INPUT	:	N/A														*/
/*																		*/
/*	OUTPUT	:	N/A														*/
/*																		*/
/************************************************************************/
CFMStocks_Refresher::~CFMStocks_Refresher()
{
	// Release all the stored IWBemObjectAccess Pointers
	for(long nCtr = 0 ; nCtr < m_numObjects ; nCtr++)
		m_pAccessCopy[nCtr]->Release();

	// Initialize the reference Counter for the local object
	m_lRef = 0;

	if(m_lCtr != NULL)
	{
		UnmapViewOfFile(m_lCtr);
	}

	if(m_hFile != NULL)
	{
		CloseHandle(m_hFile);
	}
	else
	{
		delete m_lCtr;
	}

	// Close the registry handle (if it is open)
//	if(m_hKey != NULL)
//		RegCloseKey(m_hKey);

	// Decrement the global COM object counter
	InterlockedDecrement(&g_lObjects);
}

/************ IUNKNOWN METHODS ******************/
/************************************************************************/
/*																		*/
/*	NAME	:	CFMStocks_Refresher::QueryInterface()					*/
/*																		*/
/*	PURPOSE :	Standard COM interface. Doesn't need description		*/
/*																		*/
/*	INPUT	:	Standard COM Interface									*/
/*																		*/
/*	OUTPUT	:	Standard COM Interface									*/
/*																		*/
/************************************************************************/
STDMETHODIMP CFMStocks_Refresher::QueryInterface(/* [in]  */ REFIID riid, 
												 /* [out] */ void** ppv)
{
	//We are not going to support any interface other than IUnknown & IWbemRefresher
    if (riid == IID_IUnknown)
	{
        *ppv = (LPVOID)(IUnknown*)this;
	}
	else if (riid == IID_IWbemRefresher)
	{
		*ppv = (LPVOID)(IWbemRefresher*)this;
	}
    else 
	{
		return E_NOINTERFACE;
	}

   	((IUnknown*)*ppv)->AddRef();
    return S_OK;
}

/************************************************************************/
/*																		*/
/*	NAME	:	CFMStocks_Refresher::AddRef()							*/
/*																		*/
/*	PURPOSE :	Standard COM interface. Doesn't need description		*/
/*																		*/
/*	INPUT	:	Standard COM Interface									*/
/*																		*/
/*	OUTPUT	:	Standard COM Interface									*/
/*																		*/
/************************************************************************/
STDMETHODIMP_(ULONG) CFMStocks_Refresher::AddRef()
{
    return InterlockedIncrement(&m_lRef);
}

/************************************************************************/
/*																		*/
/*	NAME	:	CFMStocks_Refresher::Release()							*/
/*																		*/
/*	PURPOSE :	Standard COM interface. Doesn't need description		*/
/*																		*/
/*	INPUT	:	Standard COM Interface									*/
/*																		*/
/*	OUTPUT	:	Standard COM Interface									*/
/*																		*/
/************************************************************************/
STDMETHODIMP_(ULONG) CFMStocks_Refresher::Release()
{
    long lRef = InterlockedDecrement(&m_lRef);
    if(lRef == 0)
        delete this;
    return lRef;
}

/************* IWBEMREFRESHER METHODS *************/
/************************************************************************/
/*																		*/
/*	NAME	:	CFMStocks_Refresher::Refresh()							*/
/*																		*/
/*	PURPOSE :	Updates all refreshable objects, enumerators, and		*/
/*				nested Refreshers.										*/
/*																		*/
/*	INPUT	:	long - Bitmask of flags that modify the behavior of		*/
/*				this method ( see help for more details )				*/
/*																		*/
/*	OUTPUT	:	HRESULT													*/
/*																		*/
/************************************************************************/
HRESULT CFMStocks_Refresher::Refresh(/* [in]  */ long lFlags)
{
	// Update all the instances in the refresher
	if(RegQueryValueEx(m_hKey,_T("LookupTimePerfCtr"),NULL,NULL,(LPBYTE)&m_lCtr,&m_dwCtrSize) != ERROR_SUCCESS)
	{
		//If we can't query the value, we set it to zero
		m_lCtr = 0;
	}

	long lCtr = *m_lCtr;
//	long lCtr = m_lCtr;

	for(long nCtr = 0 ; nCtr < m_numObjects ; nCtr++)
	{
		// Initialize the counter value
		m_pAccessCopy[nCtr]->WriteDWORD(m_hLookupTime,lCtr);
	}

/*	if(RegQueryValueEx(m_hKey,_T("LookupTimePerfCtr"),NULL,NULL,(LPBYTE)&m_lCtr,&m_dwCtrSize) == ERROR_SUCCESS)
	{
		if(lCtr != m_lCtr)
		{
			//Value has been changed so don't reinitialize it to zero
			return WBEM_NO_ERROR;
		}
	}

	m_lCtr =  0;
	RegSetValueEx(m_hKey,_T("LookupTimePerfCtr"),0,REG_DWORD,(LPBYTE)&m_lCtr,sizeof(DWORD));
*/	
	if(lCtr == *m_lCtr)
	{
		//The value is not changed. So set it to zero
		*m_lCtr = 0;
	}

	return WBEM_NO_ERROR;
}

/************** FUNCTIONS OF CFMStocks_Refresher CLASS ************/
/************************************************************************/
/*																		*/
/*	NAME	:	CFMStocks_Refresher::AddObject()						*/
/*																		*/
/*	PURPOSE :	internal function(not inhertied from IWbemRefresher) to */
/*				add an refreshable object to the Refresher				*/
/*																		*/
/*	INPUT	:	IWbemObjectAccess * - Input object						*/
/*				IWbemObjectAccess ** - ouput the new added object		*/
/*				   Actually in this case we are returning the same		*/
/*				   object as we are not cloning the given object and	*/
/*				   storing the same one									*/
/*																		*/
/*	OUTPUT	:	HRESULT													*/
/*																		*/
/************************************************************************/
HRESULT CFMStocks_Refresher::AddObject(IWbemServices* pNamespace,IWbemObjectAccess *pObj, IWbemObjectAccess **ppReturnObj, long *plId)
{
	if (NULL == pObj)
        return WBEM_E_INVALID_PARAMETER;

	// If array was full, report an error
	if (m_numObjects == MAX_OBJECTS)
	{
		return WBEM_E_OUT_OF_MEMORY;
	}

	//Create a new object and add it
	IWbemClassObject*	pObjectCopy = NULL;
	IWbemClassObject*	pTemplate = NULL;

	//Get the template of the class
	BSTR strObject = SysAllocString(CLASS_NAME);
	HRESULT hRes = pNamespace->GetObject(strObject, 0, NULL, &pTemplate, 0);
	if(FAILED(hRes))
	{
		return hRes;
	}
	SysFreeString(strObject);

	//Now spawn an instance of the class
	hRes = pTemplate->SpawnInstance(0, &pObjectCopy);
	if (FAILED(hRes))
	{
		return hRes;
	}
	
	// Obtain the IWbemObjectAccess interface
	hRes = pObjectCopy->QueryInterface(IID_IWbemObjectAccess, (PVOID*)&m_pAccessCopy[m_numObjects]);
	if (FAILED(hRes))
	{
		pObjectCopy->Release();
		return hRes;
	}

	// Initialize the ID
	m_pAccessCopy[m_numObjects]->WriteDWORD(m_hID, m_UniqId);
	m_UniqId++;

	//Initialize the counter value
	m_pAccessCopy[m_numObjects]->WriteDWORD(m_hLookupTime,1);		//Some Value

	//Release the interface
	pObjectCopy->Release();

	// Set the return parameters
	*plId = m_UniqId;
	*ppReturnObj = m_pAccessCopy[m_numObjects];
	(*ppReturnObj)->AddRef();

	//Now we had successfully added the object. So increase the numobjects by one
	m_numObjects++;

	return WBEM_NO_ERROR;
}

/************************************************************************/
/*																		*/
/*	NAME	:	CFMStocks_Refresher::RemoveObject()						*/
/*																		*/
/*	PURPOSE :	internal function(not inhertied from IWbemRefresher) to */
/*				remove an refreshable object to the Refresher			*/
/*																		*/
/*	INPUT	:	lId - Identifier to identify the object					*/
/*																		*/
/*	OUTPUT	:	DWORD													*/
/*																		*/
/************************************************************************/
DWORD CFMStocks_Refresher::RemoveObject(long lId)
{
	DWORD	dwRes = WBEM_E_NOT_FOUND;

	int		nIndex = 0;
	bool	bDone = false;
	long ctrVal = 0;

	//Find out whether the object with the Id exists in our list
	for(long lCtr = 0; lCtr < m_numObjects; lCtr ++)
	{
		m_pAccessCopy[lCtr]->ReadDWORD(m_hLookupTime,(DWORD *)&ctrVal);
		if(ctrVal == lId)
			break;
	}

	if(lCtr == m_numObjects)
	{
		//Id not found. So return error
		return WBEM_E_NOT_FOUND;
	}

	//Assign the value to a temp pointer
	IWbemObjectAccess *pTemp = m_pAccessCopy[lCtr];

	//Since we have to delete an object decrease the object count by 1.
	m_numObjects--;

	//Now loop through the array and move all the values one index up
	for(;lCtr < m_numObjects;lCtr++)
	{
		m_pAccessCopy[lCtr] = m_pAccessCopy[lCtr + 1];
	}

	//Now release the pointer
	pTemp->Release();
	
	return WBEM_NO_ERROR;
}

/************************************************************************
 *																	    *
 *		Class CHiPerfProvider											*
 *																		*
 *			The HiPerformance Provider class for FMStocks implements	*
 *          IWBemProviderInit and IWBemHiPerfProvider					*
 *																		*
 ************************************************************************/
/************************************************************************/
/*																		*/
/*	NAME	:	CHiPerfProvider::CHiPerfProvider()						*/
/*																		*/
/*	PURPOSE :	Constructor												*/
/*																		*/
/*	INPUT	:	NONE													*/ 
/*																		*/
/*	OUTPUT	:	N/A														*/
/*																		*/
/************************************************************************/
CHiPerfProvider::CHiPerfProvider()
{
	// Increment the global COM object counter
	InterlockedIncrement(&g_lObjects);

	//Initialize the local reference count
	m_lRef = 0;

	//Initialize the property handles
	m_hID = 0;
	m_hLookupTime = 0;

	SECURITY_DESCRIPTOR sd;
	InitializeSecurityDescriptor(&sd,SECURITY_DESCRIPTOR_REVISION);

	SECURITY_ATTRIBUTES sa;
	sa.nLength = sizeof(SECURITY_ATTRIBUTES);
	sa.lpSecurityDescriptor = &sd;
	sa.bInheritHandle = TRUE;

	m_hFile = NULL;

	m_hFile = CreateFileMapping(INVALID_HANDLE_VALUE,&sa,PAGE_READWRITE | SEC_COMMIT,
									 0L, sizeof(long), FILE_MAPPING_NAME);
	if(m_hFile == NULL)
	{
		//Log((_T("Create File Mapping Failed"));
		m_lCtr = (long *)new long();
		*m_lCtr = 0;
	}
	else
	{
		//Log((_T("File Mapping Created Successfully"));
		//Log((_T("Before MapViewOfFile"));

		m_lCtr = (long *)MapViewOfFile(m_hFile,FILE_MAP_ALL_ACCESS,0L,0L,0L);

		if(m_lCtr == NULL)
		{
			m_lCtr = (long *)new long();
			*m_lCtr = 0;
			//Log((_T("Cannot MapViewOfFile"));
		}
		else
		{
			//Log((_T("Mapped View of File"));
			*m_lCtr = 0;
		}
	}
/*
	m_dwCtrSize = sizeof(long);
	DWORD dwDisp;
	if(RegCreateKeyEx(HKEY_LOCAL_MACHINE,_T("Software\\VSInteropSample"),0,_T(""),
					REG_OPTION_NON_VOLATILE,KEY_ALL_ACCESS,NULL,&m_hKey,&dwDisp) == ERROR_SUCCESS)
	{
		// Check to see whether the reg entry is already there.
		// The idea here is that if it is not there we will create 
		// a new one and initialize it to 0
		if(RegQueryValueEx(m_hKey,_T("LookupTimePerfCtr"),NULL,NULL,NULL,NULL) != ERROR_SUCCESS)
		{
			//Not exists.So create the value and initialize with 0
			DWORD dwZero = 0;
			RegSetValueEx(m_hKey,_T("LookupTimePerfCtr"),0,REG_DWORD,(LPBYTE)&dwZero,sizeof(DWORD));
		}
	}
	else
	{
		m_lCtr = 0;
	}

*/
}

/************************************************************************/
/*																		*/
/*	NAME	:	CHiPerfProvider::~CHiPerfProvider()						*/
/*																		*/
/*	PURPOSE :	Destructor												*/
/*																		*/
/*	INPUT	:	NONE													*/ 
/*																		*/
/*	OUTPUT	:	N/A														*/
/*																		*/
/************************************************************************/
CHiPerfProvider::~CHiPerfProvider()
{
	if(m_lCtr != NULL)
	{
		UnmapViewOfFile(m_lCtr);
	}

	if(m_hFile != NULL)
	{
		CloseHandle(m_hFile);
	}
	else
	{
		delete m_lCtr;
	}

/*	
	// Close the registry handle (if it is open)
	if(m_hKey != NULL)
		RegCloseKey(m_hKey);
*/
	// Decrement the global COM object counter
	long lObjCount = InterlockedDecrement(&g_lObjects);
}

/************ IUNKNOWN METHODS ******************/

/************************************************************************/
/*																		*/
/*	NAME	:	CHiPerfProvider::QueryInterface()						*/
/*																		*/
/*	PURPOSE :	Standard COM interface. Doesn't need description		*/
/*																		*/
/*	INPUT	:	Standard COM Interface									*/
/*																		*/
/*	OUTPUT	:	Standard COM Interface									*/
/*																		*/
/************************************************************************/

STDMETHODIMP CHiPerfProvider::QueryInterface(/* [in]  */ REFIID riid, 
											 /* [out] */ void** ppv)
{
	// We are not going to support any interfaces other than IID_IWbemProviderInit 
	// and IID_IWbemHiPerfProvider

    if(riid == IID_IUnknown)
        *ppv = (LPVOID)(IUnknown*)(IWbemProviderInit*)this;
    else if(riid == IID_IWbemProviderInit)
        *ppv = (LPVOID)(IWbemProviderInit*)this;
	else if (riid == IID_IWbemHiPerfProvider)
		*ppv = (LPVOID)(IWbemHiPerfProvider*)this;
	else return E_NOINTERFACE;

	((IUnknown*)*ppv)->AddRef();
	return WBEM_NO_ERROR;
}
	
/************************************************************************/
/*																		*/
/*	NAME	:	CHiPerfProvider::AddRef()								*/
/*																		*/
/*	PURPOSE :	Standard COM interface. Doesn't need description		*/
/*																		*/
/*	INPUT	:	Standard COM Interface									*/
/*																		*/
/*	OUTPUT	:	Standard COM Interface									*/
/*																		*/
/************************************************************************/
STDMETHODIMP_(ULONG) CHiPerfProvider::AddRef()
{
    return InterlockedIncrement(&m_lRef);
}

/************************************************************************/
/*																		*/
/*	NAME	:	CHiPerfProvider::Release()								*/
/*																		*/
/*	PURPOSE :	Standard COM interface. Doesn't need description		*/
/*																		*/
/*	INPUT	:	Standard COM Interface									*/
/*																		*/
/*	OUTPUT	:	Standard COM Interface									*/
/*																		*/
/************************************************************************/
STDMETHODIMP_(ULONG) CHiPerfProvider::Release()
{
    long lRef = InterlockedDecrement(&m_lRef);
    if(lRef == 0)
        delete this;

    return lRef;
}

/************* IWBEMPROVIDERINIT METHODS *************/
/************************************************************************/
/*																		*/
/*	NAME	:	CHiPerfProvider::Initialize()							*/
/*																		*/
/*	PURPOSE :	For initializing the Provider object					*/
/*																		*/
/*	INPUT	:	LPWSTR			- Pointer to the user name				*/
/*				long			- reserved								*/
/*				LPWSTR			- Namespace								*/
/*				LPWSTR			- Locale Name							*/
/*				IWbemServices*  - pointer to namespace					*/
/*				IWbemContext*   - The context							*/
/*				IWbemProviderInitSink - The sink object for init		*/
/*																		*/
/*	OUTPUT	:	Standard COM Interface									*/
/*																		*/
/************************************************************************/
STDMETHODIMP CHiPerfProvider::Initialize( 
								/* [in] */ LPWSTR wszUser,
								/* [in] */ long lFlags,
								/* [in] */ LPWSTR wszNamespace,
								/* [in] */ LPWSTR wszLocale,
								/* [in] */ IWbemServices __RPC_FAR *pNamespace,
								/* [in] */ IWbemContext __RPC_FAR *pCtx,
								/* [in] */ IWbemProviderInitSink __RPC_FAR *pInitSink )
{
    IWbemObjectAccess *pAccess = NULL;		
    IWbemClassObject *pTemplate = NULL;		

	if (wszNamespace == 0 || pNamespace == 0 || pInitSink == 0)
        return WBEM_E_INVALID_PARAMETER;

	//Get the template for the object
	BSTR strObject = SysAllocString(CLASS_NAME);
	HRESULT hRes = pNamespace->GetObject(strObject, 0, pCtx, &pTemplate, 0);
	if(FAILED(hRes))
	{
		return hRes;
	}
	SysFreeString(strObject);
    
	//Now get the property handle for ID
	if (NULL == m_hID)
	{
		// Get the IWbemObjectAccess interface to the object
		hRes = pTemplate->QueryInterface(IID_IWbemObjectAccess, (PVOID*)&pAccess);
		if (FAILED(hRes))
		{
			return hRes;
		}
		// Get the ID property access handle
		BSTR strPropName = SysAllocString(L"ID");
		hRes = pAccess->GetPropertyHandle(strPropName, 0, &m_hID);
		pAccess->Release();
		SysFreeString(strPropName);
		if (FAILED(hRes))
		{
			return hRes;
		}

		// Get the LookupTime property access handle
		strPropName = SysAllocString(L"LookupTime");
		hRes = pAccess->GetPropertyHandle(strPropName, 0, &m_hLookupTime);
		pAccess->Release();
		SysFreeString(strPropName);
		if (FAILED(hRes))
		{
			return hRes;
		}
	}

	//Send the status as initialized through the sink
    pInitSink->SetStatus(WBEM_S_INITIALIZED, 0);
    return WBEM_NO_ERROR;
}

/************* IWBEMHIPERFPROVIDER METHODS ************/
/************************************************************************/
/*																		*/
/*	NAME	:	CHiPerfProvider::QueryInstances()						*/
/*																		*/
/*	PURPOSE :	For initializing the Provider object					*/
/*																		*/
/*	INPUT	:	IWbemServices*  - pointer to namespace					*/
/*				WCHAR *			- Class Name							*/
/*				long			- flags									*/
/*				IWbemContext*   - The context							*/
/*				IWbemObjectSink - The sink object						*/
/*																		*/
/*	OUTPUT	:	Standard COM Interface									*/
/*																		*/
/************************************************************************/
HRESULT CHiPerfProvider::QueryInstances( /* [in]  */ IWbemServices* pNamespace,
										 /* [in]  */ WCHAR* wszClass,
										 /* [in]  */ long lFlags,
										 /* [in]  */ IWbemContext* pCtx,
										 /* [in]  */ IWbemObjectSink* pSink)
{
	HRESULT hRes = WBEM_NO_ERROR;
	IWbemClassObject*	pObjectCopy = NULL;
	IWbemClassObject*	pTemplate = NULL;
	IWbemObjectAccess*	pAccessCopy = NULL;

    if (pNamespace == 0 || wszClass == 0 || pSink == 0)
	{
        return WBEM_E_INVALID_PARAMETER;
	}

	//Get the template for the class
	BSTR strObject = SysAllocString(CLASS_NAME);
	hRes = pNamespace->GetObject(strObject, 0, pCtx, &pTemplate, 0);
	if(FAILED(hRes))
	{
		return hRes;
	}
	SysFreeString(strObject);
	
	//Spawn an instance using the template
	hRes = pTemplate->SpawnInstance(0, &pObjectCopy);
	if (FAILED(hRes))
	{
		return hRes;
	}
	
	// Obtain the IWbemObjectAccess interface
	hRes = pObjectCopy->QueryInterface(IID_IWbemObjectAccess, (PVOID*)&pAccessCopy);
	if (FAILED(hRes))
	{
		pObjectCopy->Release();
		return hRes;
	}

	// Initialize the ID
	hRes = pAccessCopy->WriteDWORD(m_hID, 1);
	if (FAILED(hRes))
	{
		pObjectCopy->Release();
		return hRes;
	}

	//Initialize the counter value
/*	if(RegQueryValueEx(m_hKey,_T("LookupTimePerfCtr"),NULL,NULL,(LPBYTE)&m_lCtr,&m_dwCtrSize) != ERROR_SUCCESS)
	{
		//If we can't query the value, we set it to zero
		m_lCtr = 0;
	}
*/
	hRes = pAccessCopy->WriteDWORD(m_hLookupTime,*m_lCtr);
	//Log((_T("Lookup Time = [%ld]"),*m_lCtr);

//	hRes = pAccessCopy->WriteDWORD(m_hLookupTime,m_lCtr);
	if (FAILED(hRes))
	{
		pObjectCopy->Release();
		return hRes;
	}

	//Now reset the counter value
	*m_lCtr =  0;
/*	m_lCtr =  0;
	RegSetValueEx(m_hKey,_T("LookupTimePerfCtr"),0,REG_DWORD,(LPBYTE)&m_lCtr,sizeof(DWORD));
*/
	// Release the IWbemObjectAccess handle 
	hRes = pAccessCopy->Release();
	if (FAILED(hRes))
	{
		pObjectCopy->Release();
		return hRes;
	}

    // Send a copy back to the caller
    hRes = pSink->Indicate(1, &pObjectCopy);
	if (FAILED(hRes))
	{
		pObjectCopy->Release();
		return hRes;
	}

    pObjectCopy->Release();

    // Tell WINMGMT we are all finished supplying objects
    pSink->SetStatus(0, WBEM_NO_ERROR, 0, 0);
    return WBEM_NO_ERROR;
}

/************************************************************************/
/*																		*/
/*	NAME	:	CHiPerfProvider::CreateRefresher()						*/
/*																		*/
/*	PURPOSE :	Called to create a refresher							*/
/*																		*/
/*	INPUT	:	IWbemServices*    - pointer to namespace				*/
/*				long			  - reserved, 0							*/
/*				IWbemRefresher ** - The created refresher object		*/
/*																		*/
/*	OUTPUT	:	Standard COM Interface									*/
/*																		*/
/************************************************************************/
HRESULT CHiPerfProvider::CreateRefresher( /* [in]  */ IWbemServices* pNamespace,
 										  /* [in]  */ long lFlags,
										  /* [out] */ IWbemRefresher** ppRefresher)
{
    // Construct and initialize a new empty refresher
	CFMStocks_Refresher* pNewRefresher = new CFMStocks_Refresher(m_hID,m_hLookupTime);
	pNewRefresher->AddRef();
    *ppRefresher = pNewRefresher;
    
    return WBEM_NO_ERROR;
}

/************************************************************************/
/*																		*/
/*	NAME	:	CHiPerfProvider::CreateRefreshableObject()				*/
/*																		*/
/*	PURPOSE :	Called to create a refreshable Object					*/
/*																		*/
/*	INPUT	:	IWbemServices*        - pointer to namespace			*/
/*				IWbemRefresher **	  - The refresher object			*/
/*				IWbemObjectAccess*    - Template for the refreshable	*/
/*										object							*/
/*				long			      - reserved, 0						*/
/*				IWbemContext*         - The context						*/
/*				IWbemObjectAccess**   - The created Object				*/
/*				long				  - The identifier for the created	*/
/*										object							*/
/*																		*/
/*	OUTPUT	:	Standard COM Interface									*/
/*																		*/
/************************************************************************/
HRESULT CHiPerfProvider::CreateRefreshableObject( 
									 /* [in]  */ IWbemServices* pNamespace,
									 /* [in]  */ IWbemObjectAccess* pTemplate,
									 /* [in]  */ IWbemRefresher* pRefresher,
									 /* [in]  */ long lFlags,
									 /* [in]  */ IWbemContext* pContext,
									 /* [out] */ IWbemObjectAccess** ppRefreshable,
									 /* [out] */ long* plId)
{

	HRESULT hRes = WBEM_NO_ERROR;

    if (pNamespace == 0 || pTemplate == 0 || pRefresher == 0)
        return WBEM_E_INVALID_PARAMETER;

	CFMStocks_Refresher *pOurRefresher = (CFMStocks_Refresher *) pRefresher;

    hRes = pOurRefresher->AddObject(pNamespace,pTemplate, ppRefreshable, plId);

	if (FAILED(hRes))
		return hRes;

    return WBEM_NO_ERROR;
}

/************************************************************************/
/*																		*/
/*	NAME	:	CHiPerfProvider::StopRefreshing()						*/
/*																		*/
/*	PURPOSE :	Called to create a refreshable Object					*/
/*																		*/
/*	INPUT	:	IWbemRefresher *	  - The refresher object			*/
/*				long			      - the ID of the object			*/
/*				long				  - flag							*/
/*																		*/
/*	OUTPUT	:	Standard COM Interface									*/
/*																		*/
/************************************************************************/
HRESULT CHiPerfProvider::StopRefreshing( /* [in]  */ IWbemRefresher* pRefresher,
										 /* [in]  */ long lId,
										 /* [in]  */ long lFlags)
{

	//TODO: I hope i don't have to do anything in this
    CFMStocks_Refresher *pOurRefresher = (CFMStocks_Refresher *) pRefresher;
	HRESULT hRes = pOurRefresher->RemoveObject(lId);
	
	return hRes;
}

/************************************************************************/
/*																		*/
/*	NAME	:	CHiPerfProvider::CreateRefreshableEnum()				*/
/*																		*/
/*	PURPOSE :	Called to create a new refreshable enumeration			*/
/*																		*/
/*	INPUT	:	IWbemServices*        - pointer to namespace			*/
/*				WCHAR *				  - Class Name						*/
/*				IWbemRefresher *	  - The refresher object			*/
/*				long			      - reserved,0						*/
/*				IWbemHiPerfEnum*	  - interface to the enum containing*/
/*										the high-perf enumeration		*/ 
/*				long*				  - identifier for the enum			*/
/*																		*/
/*	OUTPUT	:	Standard COM Interface									*/
/*																		*/
/************************************************************************/
HRESULT CHiPerfProvider::CreateRefreshableEnum(  
									/* [in]  */ IWbemServices* pNamespace,
									/* [in]  */ LPCWSTR wszClass,
									/* [in]  */ IWbemRefresher* pRefresher,
									/* [in]  */ long lFlags,
									/* [in]  */ IWbemContext* pContext,
									/* [in]  */ IWbemHiPerfEnum* pHiPerfEnum,
									/* [out] */ long* plId)
{
	return WBEM_NO_ERROR;
}

/************************************************************************/
/*																		*/
/*	NAME	:	CHiPerfProvider::GetObjects()							*/
/*																		*/
/*	PURPOSE :	Called to create a new refreshable enumeration			*/
/*																		*/
/*	INPUT	:	IWbemServices*        - pointer to namespace			*/
/*				long				  - number of objects				*/
/*				IWbemObjectAccess **  - Pointer to an array of			*/
/*										IWbemObjectAccess objects		*/
/*				long			      - reserved,0						*/
/*				IWbemContext*		  - Context							*/
/*																		*/
/*	OUTPUT	:	Standard COM Interface									*/
/*																		*/
/************************************************************************/
HRESULT CHiPerfProvider::GetObjects( /* [in]  */ IWbemServices* pNamespace,
									 /* [in]  */  long lNumObjects,
									 /* [in,out] */ IWbemObjectAccess** apObj,
									 /* [in]  */ long lFlags,
									 /* [in]  */ IWbemContext* pContext)
{
	return WBEM_NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vside\fmstocks\fmstocks_hiperfprovider\fmstocks_hiperfprovider.cpp ===
////////////////////////////////////////////////////////////////////////
//
//  FMStocks_HiPerfProvider.cpp
//
//	Module:	WMI high performance provider for F&M Stocks
//
//  Generic COM server framework, 
//
//  History:
//	a-vkanna      3-April-2000		Initial Version
//
//  Copyright (c) 2000 Microsoft Corporation
//
////////////////////////////////////////////////////////////////////////

#include <windows.h>
#include <stdio.h>
#include <time.h>
#include <locale.h>
#include <initguid.h>

#include "ClassFactory.h"
//#include "..\..\unitrace\unitrace.h"

/////////////////////////////////////////////////////////////////////////////
//
//  BEGIN CLSID SPECIFIC SECTION
//
//

#include "wbemprov.h"
#include "HiPerfProvider.h"

// {7EA4A291-AD45-4882-80AD-267DA859CE39}
DEFINE_GUID(CLSID_FMStocks_HiPerfProvider, 
0x7ea4a291, 0xad45, 0x4882, 0x80, 0xad, 0x26, 0x7d, 0xa8, 0x59, 0xce, 0x39);

#define IMPLEMENTED_CLSID           CLSID_FMStocks_HiPerfProvider
#define SERVER_REGISTRY_COMMENT     L"FMStocks Lookup Performance Counter"

HINSTANCE g_hInstance;
long g_lLocks = 0;
long g_lObjects = 0;

//***************************************************************************
//
//  DllMain
//
//  Dll entry point.
//
//  PARAMETERS:
//
//      HINSTANCE hinstDLL      The handle to our DLL.
//      DWORD dwReason          DLL_PROCESS_ATTACH on load,
//                              DLL_PROCESS_DETACH on shutdown,
//                              DLL_THREAD_ATTACH/DLL_THREAD_DETACH otherwise.
//      LPVOID lpReserved       Reserved
//
//  RETURN VALUES:
//
//      TRUE is successful, FALSE if a fatal error occured.
//      NT behaves very ugly if FALSE is returned.
//
//***************************************************************************
BOOL WINAPI DllMain(
    HINSTANCE hinstDLL,
    DWORD dwReason,
    LPVOID lpReserved
    )
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        setlocale(LC_ALL, "");      // Set to the 'current' locale
        g_hInstance = hinstDLL;
    }

//	SetModuleName(_T("HIPERF"));
    return TRUE;
}

//***************************************************************************
//
//  DllGetClassObject
//
//  Standard OLE In-Process Server entry point to return an class factory
//  instance.
//
//  PARAMETERS:
//
//  RETURNS:
//
//      S_OK                Success
//      E_NOINTERFACE       An interface other that IClassFactory was asked for
//      E_OUTOFMEMORY
//      E_FAILED            Initialization failed, or an unsupported clsid was
//                          asked for.
//
//***************************************************************************

STDAPI DllGetClassObject(
    REFCLSID rclsid,
    REFIID riid,
    LPVOID * ppv
    )
{
    CClassFactory *pClassFactory = NULL;
	HRESULT hRes;

    //  Verify the caller is asking for our type of object
    if (IMPLEMENTED_CLSID == rclsid) 
	{
		// Create the class factory
		pClassFactory = new CClassFactory;

		if (!pClassFactory)
			return E_OUTOFMEMORY;
		
		hRes = pClassFactory->QueryInterface(riid, ppv);
		if (FAILED(hRes))
		{
			delete pClassFactory;
			return hRes;
		}
		hRes = S_OK;
	}
	else 
		hRes = CLASS_E_CLASSNOTAVAILABLE;

    return hRes;
}

//***************************************************************************
//
//  DllCanUnloadNow
//
//  Standard OLE entry point for server shutdown request. Allows shutdown
//  only if no outstanding objects or locks are present.
//
//  RETURN VALUES:
//
//      S_OK        May unload now.
//      S_FALSE     May not.
//
//***************************************************************************

STDAPI DllCanUnloadNow(void)
{
    HRESULT hRes = S_FALSE;

    if (0 == g_lLocks && 0 == g_lObjects)
        hRes = S_OK;

    return hRes;
}

//***************************************************************************
//
//  DllRegisterServer
//
//  Standard OLE entry point for registering the server.
//
//  RETURN VALUES:
//
//      S_OK        Registration was successful
//      E_FAIL      Registration failed.
//
//***************************************************************************

STDAPI DllRegisterServer(void)
{
    wchar_t Path[1024];
    wchar_t *pGuidStr = 0;
    wchar_t KeyPath[1024];

    // Get the dll's filename
    GetModuleFileNameW(g_hInstance, Path, 1024);

    // Convert CLSID to string.
    StringFromCLSID(IMPLEMENTED_CLSID, &pGuidStr);
    swprintf(KeyPath, L"Software\\Classes\\CLSID\\\\%s", pGuidStr);

    // Place it in registry.
    // CLSID\\CLSID_Nt5PerProvider_v1 : <no_name> : "name"
    //      \\CLSID_Nt5PerProvider_v1\\InProcServer32 : <no_name> : "path to DLL"
    //                                    : ThreadingModel : "both"
    HKEY hKey;
    LONG lRes = RegCreateKeyW(HKEY_LOCAL_MACHINE, KeyPath, &hKey);
    if (lRes)
        return E_FAIL;

    wchar_t *pName = SERVER_REGISTRY_COMMENT; 
    RegSetValueExW(hKey, 0, 0, REG_SZ, (const BYTE *) pName, wcslen(pName) * 2 + 2);

    HKEY hSubkey;
    lRes = RegCreateKey(hKey, _T("InprocServer32"), &hSubkey);

    RegSetValueExW(hSubkey, 0, 0, REG_SZ, (const BYTE *) Path, wcslen(Path) * 2 + 2);
    RegSetValueExW(hSubkey, L"ThreadingModel", 0, REG_SZ, (const BYTE *) L"Both", wcslen(L"Both") * 2 + 2);

    RegCloseKey(hSubkey);
    RegCloseKey(hKey);

    CoTaskMemFree(pGuidStr);

    return S_OK;
}

//***************************************************************************
//
//  DllUnregisterServer
//
//  Standard OLE entry point for unregistering the server.
//
//  RETURN VALUES:
//
//      S_OK        Unregistration was successful
//      E_FAIL      Unregistration failed.
//
//***************************************************************************

STDAPI DllUnregisterServer(void)
{
    wchar_t *pGuidStr = 0;
    HKEY hKey;
    wchar_t KeyPath[256];

    StringFromCLSID(IMPLEMENTED_CLSID, &pGuidStr);
    swprintf(KeyPath, L"Software\\Classes\\CLSID\\\\%s", pGuidStr);

    // Delete InProcServer32 subkey.
    LONG lRes = RegOpenKeyW(HKEY_LOCAL_MACHINE, KeyPath, &hKey);
    if (lRes)
        return E_FAIL;

    RegDeleteKeyW(hKey, L"InprocServer32");
    RegCloseKey(hKey);

    // Delete CLSID GUID key.
    lRes = RegOpenKeyW(HKEY_LOCAL_MACHINE, L"Software\\Classes\\CLSID", &hKey);
    if (lRes)
        return E_FAIL;

    RegDeleteKeyW(hKey, pGuidStr);
    RegCloseKey(hKey);

    CoTaskMemFree(pGuidStr);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vside\fmstocks\fmstocks_hiperfprovider\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	FMStocks_HiPerfProvider.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vside\fmstocks\fmstocks_hiperfprovider\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__B2D27518_F6B0_457E_993A_E2013C19CBB3__INCLUDED_)
#define AFX_STDAFX_H__B2D27518_F6B0_457E_993A_E2013C19CBB3__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


// Insert your headers here
#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers

#include <windows.h>

// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__B2D27518_F6B0_457E_993A_E2013C19CBB3__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vside\fmstocks\fmstocks_hiperfprovider\hiperfprovider.h ===
////////////////////////////////////////////////////////////////////////
//
//  HiPerfProvider.h
//
//	Module:	WMI high performance provider for F&M Stocks
//
//  Implementation of the HiPerformance Provider Interfaces, 
//
//  History:
//	a-vkanna      3-April-2000		Initial Version
//
//  Copyright (c) 2000 Microsoft Corporation
//
////////////////////////////////////////////////////////////////////////

#ifndef _HIPERFPROV_H_
#define _HIPERFPROV_H_

#define MAX_OBJECTS 10
#define CLASS_NAME _T("FMStocks_LookupPerf")
#define NAME_FILEMAPPING_OBJECT _T("FMSTOCKS_HI_PERFORMANCE_COUNTER_MAPPING_OBJECT")

#include <tchar.h> 
#include <wbemprov.h>

/************************************************************************
 *																	    *
 *		Class CFMStocks_Refresher										*
 *																		*
 *			The Refresher class for FMStocks implements	IWBemRefresher	*
 *																		*
 ************************************************************************/
class CFMStocks_Refresher : public IWbemRefresher
{
	public:

		//Constructor
		CFMStocks_Refresher(/* [in] */ long hID,
							/* [in] */ long hLookupTime);

		//Destructor
		~CFMStocks_Refresher();

		/************ IUNKNOWN METHODS ******************/

		STDMETHODIMP QueryInterface(/* [in]  */ REFIID riid, 
									/* [out] */ void** ppv);
		STDMETHODIMP_(ULONG) AddRef();
		STDMETHODIMP_(ULONG) Release();

		/************* IWBEMREFRESHER METHODS *************/

		STDMETHODIMP Refresh(/* [in]  */ long lFlags);

		/************* METHODS LOCAL TO THIS CLASS ********/
		
		STDMETHODIMP AddObject( /* [in]  */ IWbemServices* pNamespace,
								/* [in]  */ IWbemObjectAccess *pObj, 
								/* [out] */ IWbemObjectAccess **ppReturnObj, 
								/* [out] */ long *plId);

		DWORD RemoveObject( /* [in] */ long lId);

	protected:
		long m_lRef;			// The object reference count

		long m_hID;				// Handle to the ID Property

		long m_hLookupTime;		// Handle to the LookupTime property

		long m_numObjects;		// Number of objects in the refresher

		long m_UniqId;			// Variable used to get a Unique ID identifying the object

		HANDLE m_hFile;			//File Mapping Object Handle

		long *m_lCtr;			// Pointer to the counter data
//		long m_lCtr;			// Pointer to the counter data

		DWORD m_dwCtrSize;		// Variable used to store the size of the counter variable. 
								// It is used for reading value from the registry.

		HKEY m_hKey;


		IWbemObjectAccess* m_pAccessCopy[MAX_OBJECTS + 1];	// Pointer to the IWbemObjectAccess
															// of all the objects in the refresher
};

/************************************************************************
 *																	    *
 *		Class CHiPerfProvider											*
 *																		*
 *			The HiPerformance Provider class for FMStocks implements	*
 *          IWBemProviderInit and IWBemHiPerfProvider					*
 *																		*
 ************************************************************************/
class CHiPerfProvider : public IWbemProviderInit , IWbemHiPerfProvider
{
	public:
		//Constructor
		CHiPerfProvider();

		//Destructor
		~CHiPerfProvider();

		/************ IUNKNOWN METHODS ******************/

		STDMETHODIMP QueryInterface(/* [in]  */ REFIID riid, 
									/* [out] */ void** ppv);
	
		STDMETHODIMP_(ULONG) AddRef();

		STDMETHODIMP_(ULONG) Release();

		/************* IWBEMPROVIDERINIT METHODS *************/

		STDMETHODIMP Initialize( /* [in] */ LPWSTR wszUser,
								 /* [in] */ long lFlags,
								 /* [in] */ LPWSTR wszNamespace,
								 /* [in] */ LPWSTR wszLocale,
								 /* [in] */ IWbemServices __RPC_FAR *pNamespace,
								 /* [in] */ IWbemContext __RPC_FAR *pCtx,
								 /* [in] */ IWbemProviderInitSink __RPC_FAR *pInitSink );

		/************* IWBEMHIPERFPROVIDER METHODS ************/
    STDMETHODIMP QueryInstances( /* [in]  */ IWbemServices* pNamespace,
								 /* [in]  */ WCHAR* wszClass,
								 /* [in]  */ long lFlags,
								 /* [in]  */ IWbemContext* pCtx,
								 /* [in]  */ IWbemObjectSink* pSink);

    STDMETHODIMP CreateRefresher( /* [in]  */ IWbemServices* pNamespace,
 							      /* [in]  */ long lFlags,
							      /* [out] */ IWbemRefresher** ppRefresher);

    STDMETHODIMP CreateRefreshableObject( /* [in]  */ IWbemServices* pNamespace,
									      /* [in]  */ IWbemObjectAccess* pTemplate,
									      /* [in]  */ IWbemRefresher* pRefresher,
									      /* [in]  */ long lFlags,
									      /* [in]  */ IWbemContext* pContext,
									      /* [out] */ IWbemObjectAccess** ppRefreshable,
									      /* [out] */ long* plId);

    STDMETHODIMP StopRefreshing( /* [in]  */ IWbemRefresher* pRefresher,
							     /* [in]  */ long lId,
							     /* [in]  */ long lFlags);

	STDMETHODIMP CreateRefreshableEnum(  /* [in]  */ IWbemServices* pNamespace,
									     /* [in]  */ LPCWSTR wszClass,
									     /* [in]  */ IWbemRefresher* pRefresher,
									     /* [in]  */ long lFlags,
									     /* [in]  */ IWbemContext* pContext,
									     /* [in]  */ IWbemHiPerfEnum* pHiPerfEnum,
									     /* [out] */ long* plId);

	STDMETHODIMP GetObjects( /* [in]     */ IWbemServices* pNamespace,
							 /* [in]     */  long lNumObjects,
							 /* [in,out] */ IWbemObjectAccess** apObj,
							 /* [in]     */ long lFlags,
							 /* [in]     */ IWbemContext* pContext);

	protected:

		long m_lRef;			// The object reference count

		long m_hID;				// Handle to the ID Property

		long m_hLookupTime;		// Handle to the LookupTime property

		HANDLE m_hFile;			//File Mapping Object Handle

		long *m_lCtr;			// Pointer to the counter data
//		long m_lCtr;			// Pointer to the counter data

		DWORD m_dwCtrSize;		// Variable used to store the size of the counter variable. 
								// It is used for reading value from the registry.

		HKEY m_hKey;
};

#endif // _HIPERFPROV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vside\servexpl\assocgroupcomponent.cs ===
namespace Microsoft.VSDesigner.WMI {

	using System;
	using System.ComponentModel;
	//using System.Core;
	using System.Collections;
	using System.Windows.Forms;
	using System.Management;

	internal class AssocGroupComponent : Component
	{
		private void InitializeComponent ()
		{
		}
	
		public readonly  string associationPath = "";
		public readonly  string associationClass = "";

		public readonly string targetNS = "";
		public readonly  string targetClass = "";	
		public readonly  string targetRole = "";
		
		public readonly  ManagementObject sourceInst;

        public AssocGroupComponent(ManagementObject assocInstance, ManagementObject sourceObj)
	{					
			sourceInst = sourceObj;

			associationPath = assocInstance.Path.Path;
			associationClass = assocInstance.Path.ClassName;
			
	        //now, inspect assocInstance object to find target role and path
			string targetNamespacePath = WmiHelper.GetAssocTargetNamespacePath(assocInstance, sourceObj.Path);
			int colon = targetNamespacePath.IndexOf(":");
			if (colon >= 0)
			{
				targetClass = targetNamespacePath.Substring(colon + 1);
				targetNS = targetNamespacePath.Substring(0, colon + 1);
			}
			else
			{
				targetClass = targetNamespacePath;
				targetNS = sourceObj.Path.NamespacePath;
			}
			
			
			targetRole = WmiHelper.GetAssocTargetRole(assocInstance, sourceObj.Path);

		
		}

		public AssocGroupComponent(ManagementObject sourceInstIn,
									String associationPathIn,
									String targetClassIn,
									String targetRoleIn)
		{					
			sourceInst = sourceInstIn;
			associationPath = associationPathIn;
			
			//to get association class name from path, leave only 
			//the part after the last backslash
			char[] separ = new char[]{'\\'};
			string[] pathParts = associationPath.Split(separ);
            associationClass = pathParts[pathParts.Length - 1];
			//MessageBox.Show("associationPath is " + associationPath);
			//MessageBox.Show("associationClass is " + associationClass);
			
			targetClass = targetClassIn;
           		
			targetRole = targetRoleIn;		
		}

		
		//overriden Equals method.
		//This is a simplified comparison routine: no class name
		public override bool Equals(Object other)
		{
			if (!(other is AssocGroupComponent))
			{
				return false;
			}
			if ((((AssocGroupComponent)other).associationClass == associationClass) &&
				(((AssocGroupComponent)other).targetClass == targetClass) &&
				(((AssocGroupComponent)other).targetRole == targetRole) )
				//&&	(other.sourceInst.Path_.Path == sourceInst.Path_.Path))
			{
				return true;
			}
			else
			{
				return false;
			}
		}



		[
		Browsable(true),
		ServerExplorerBrowsable(true),
		WMISysDescription("WMISE_AssocGroupClassPropertyDescr")
		]
		public string Class
		{
			get
			{
				return targetClass;
			}
		}

		
		[
		Browsable(true),
		ServerExplorerBrowsable(true),
		WMISysDescription("WMISE_AssocGroupRolePropertyDescr")
		]
		public string Role
		{
			get
			{
				return targetRole;
			}
		}


		[
		Browsable(true),
		ServerExplorerBrowsable(true),
		WMISysDescription("WMISE_AssocGroupAssocPropertyDescr")
		]
		public string RelationshipClass
		{
			get
			{
				return associationClass;
			}
		}
			
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vside\servexpl\cimtypemapper.cs ===
namespace Microsoft.VSDesigner.WMI 
{
	using System;
	using System.ComponentModel;
	//using System.Core;
	using System.Windows.Forms;
	using System.Runtime.InteropServices;
	using System.Drawing;
	using System.Management;
	using System.Collections;
	using System.Diagnostics;
	using System.IO;

	
	internal class CimTypeMapper
	{
		public static string ToString(CimType CimType)
		{
			switch (CimType)
			{
				case (CimType.Boolean):
				{
					return "boolean";
				}
				case (CimType.Char16):
				{
					return "char16";
				}
				case (CimType.DateTime):
				{
					return "datetime";
				}
				case (CimType.Object):
				{
					return "object";
				}
				case (CimType.Real32):
				{
					return "real32";
				}
				case (CimType.Real64):
				{
					return "real64";
				}
				case (CimType.Reference):
				{
					return "reference";
				}
				case (CimType.SInt16):
				{
					return "sint16";
				}
				case (CimType.SInt32):
				{
					return "sint32";
				}
				case (CimType.SInt64):
				{
					return "sint64";
				}
				case (CimType.SInt8):
				{
					return "sint8";
				}
				case (CimType.String):
				{
					return "string";
				}
				case (CimType.UInt16):
				{
					return "uint16";
				}
				case (CimType.UInt32):
				{
					return "uint32";
				}
				case (CimType.UInt64):
				{
					return "uint64";
				}
				case (CimType.UInt8):
				{
					return "uint8";
				}
				
			}

			return string.Empty;

		}

		public static Type ToType(CimType CimType,
									bool bIsArray,
									Property prop)
		{
            Type t = null;
       
			switch (CimType)
			{
				case (CimType.Boolean):
				{					
					if (bIsArray)
					{
						Boolean[] ar = new Boolean[0];
						t = ar.GetType();
					}
					else
					{
						t =  typeof(Boolean);						
					}
				} break;
				case (CimType.Char16):
				{
					if (bIsArray)
					{
						Char[] ar = new Char[0];
						t = ar.GetType();
					}
					else
					{
						t =  typeof(Char);						
					}
				} break;
				case (CimType.DateTime):
				{
					if (WmiHelper.IsInterval(prop))
					{
						if (bIsArray)
						{
							TimeSpan[] ar = new TimeSpan[0];
							t = ar.GetType();
						}
						else
						{
							t =  typeof(TimeSpan);						
						}	
					}
					else
					{
						if (bIsArray)
						{
							DateTime[] ar = new DateTime[0];
							t = ar.GetType();
						}
						else
						{
							t =  typeof(DateTime);						
						}						
					}
					
				} break;
				case (CimType.Object):
				{
					
					if (bIsArray)
					{
						WMIObjectComponent[] ar = new WMIObjectComponent[0];
						t = ar.GetType();
					}
					else
					{
						t =  typeof(WMIObjectComponent);						
					}
				} break;
				case (CimType.Real32):
				{
					if (bIsArray)
					{
						Single[] ar = new Single[0];
						t = ar.GetType();
					}
					else
					{
						t =  typeof(Single);						
					}
				} break;
				case (CimType.Real64):
				{					
					if (bIsArray)
					{
						Double[] ar = new Double[0];
						t = ar.GetType();
					}
					else
					{
						t =  typeof(Double);						
					}
				} break;
				case (CimType.Reference):
				{					
					if (bIsArray)
					{
						String[] ar = new String[0];
						t = ar.GetType();
					}
					else
					{
						t =  typeof(String);						
					}
				} break;
				case (CimType.SInt16):
				{				
					if (bIsArray)
					{
						Int16[] ar = new Int16[0];
						t = ar.GetType();
					}
					else
					{
						t =  typeof(Int16);						
					}
				} break;
				case (CimType.SInt32):
				{					
					if (bIsArray)
					{
						Int32[] ar = new Int32[0];
						t = ar.GetType();
					}
					else
					{
						t =  typeof(Int32);						
					}
				} break;
				case (CimType.SInt64):
				{				
					if (bIsArray)
					{
						Int64[] ar = new Int64[0];
						t = ar.GetType();
					}
					else
					{
						t =  typeof(Int64);						
					}
				} break;
				case (CimType.SInt8):
				{
					if (bIsArray)
					{
						SByte[] ar = new SByte[0];
						t = ar.GetType();
					}
					else
					{
						t =  typeof(SByte);						
					}
				} break;
				case (CimType.String):
				{
					if (bIsArray)
					{
						String[] ar = new String[0];
						t = ar.GetType();
						//return typeof(System.Collections.ArrayList);

					}
					else
					{
						t =  typeof(String);						
					}
				} break;
				case (CimType.UInt16):
				{
					if (bIsArray)
					{
						UInt16[] ar = new UInt16[0];
						t = ar.GetType();
					}
					else
					{
						t =  typeof(UInt16);						
					}
				} break;
				case (CimType.UInt32):
				{
					if (bIsArray)
					{
						UInt32[] ar = new UInt32[0];
						t = ar.GetType();
					}
					else
					{
						t =  typeof(UInt32);						
					}
				} break;
				case (CimType.UInt64):
				{
					if (bIsArray)
					{
						UInt64[] ar = new UInt64[0];
						t = ar.GetType();
					}
					else
					{
						t =  typeof(UInt64);						
					}
				} break;
				case (CimType.UInt8):
				{
					if (bIsArray)
					{
						Byte[] ar = new Byte[0];
						t = ar.GetType();
					}
					else
					{
						t =  typeof(Byte);						
					}
				} break;
                
                default:
				{						
					if (bIsArray)
					{
						Object[] ar = new Object[0];
						t = ar.GetType();
					}
					else
					{
						t =  typeof(Object);						
					}
				}break;
            }           

            return t;
		}
		
		
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vside\servexpl\eventclasspickerdialog.cs ===
namespace Microsoft.VSDesigner.WMI
{
    using System;
    using System.Drawing;
    using System.Collections;
    using System.ComponentModel;
    using System.Windows.Forms;

    /// <summary>
    ///    Summary description for EventClassPickerDialog.
    /// </summary>
    internal class EventClassPickerDialog : System.Windows.Forms.Form
    {
        /// <summary>
        ///    Required designer variable.
        /// </summary>
        private Container components;

		private TextBox DialogDescription = new TextBox();
		private Button NextBtn;
		private Button CancelBtn;
		private Button FinishBtn;
		private Button BackBtn;

		private Label TreeLabel = null;
		private Label QueryLabel = null;
		private TextBox QueryText = null;

		private WMIClassTreeView classTree = null;

		private string server = null;
		private string connectAs = null;
		private string password = null;
		private ClassFilters classFilters;

        public EventClassPickerDialog(string serverIn, 
										string user, 
										string pw,
										ClassFilters filters)
        {
			server = serverIn;
			connectAs = user;
			password = pw;
			classFilters = filters;

            //
            // Required for Windows Form Designer support
            //
            InitializeComponent();

           	DialogDescription.ReadOnly = true;
			DialogDescription.Text = "Select Event Class";
			DialogDescription.Multiline = true;
			DialogDescription.BorderStyle = System.Windows.Forms.BorderStyle.None;
			DialogDescription.Font = new System.Drawing.Font ("Microsoft Sans Serif", 8, System.Drawing.FontStyle.Bold);
			DialogDescription.TabIndex = 10;
			DialogDescription.Size = new System.Drawing.Size (360, 88);
			DialogDescription.Location = new Point(0, 0);
			DialogDescription.BackColor = System.Drawing.Color.White;
			this.Controls.Add(this.DialogDescription);

        }

        /// <summary>
        ///    Clean up any resources being used.
        /// </summary>
        public override void Dispose()
        {
            base.Dispose();
            components.Dispose();
        }

        /// <summary>
        ///    Required method for Designer support - do not modify
        ///    the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
		{
			this.components = new System.ComponentModel.Container ();
			this.NextBtn = new System.Windows.Forms.Button ();
			this.CancelBtn = new System.Windows.Forms.Button ();
			this.FinishBtn = new System.Windows.Forms.Button ();
			this.BackBtn = new System.Windows.Forms.Button();

			this.ShowInTaskbar = false;
			this.MinimizeBox = false;
			this.MaximizeBox = false;

			//@this.TrayHeight = 0;
			//@this.TrayLargeIcon = false;
			//@this.TrayAutoArrange = true;


			TreeLabel = new Label();
			TreeLabel.Text = "Available classes:";
			TreeLabel.Location = new Point(15, 105);
            
			classTree = new WMIClassTreeView(server, 
												connectAs, 
												password,
												classFilters,
												null);

			classTree.Location = new System.Drawing.Point (15, 128);
			classTree.Size = new System.Drawing.Size (330, 200);
			classTree.TabIndex = 0;
			classTree.AfterSelect += (new TreeViewEventHandler (this.AfterNodeSelect));

			QueryLabel = new Label();
			QueryLabel.Location = new Point(15, 340);
			QueryLabel.Text = "Event query:";

			QueryText = new TextBox();
			QueryText.Location = new Point(15, 363);
			QueryText.Size = new Size (330, 160);
			QueryText.Multiline = true;
			QueryText.ReadOnly = false;
			QueryText.ScrollBars = ScrollBars.Vertical;	
			QueryText.TabIndex = 1;
			QueryText.TextChanged += new EventHandler(OnQueryTextChanged);
		
			BackBtn.Location = new System.Drawing.Point (15, 538);
			BackBtn.Size = new System.Drawing.Size (75, 23);
			BackBtn.TabIndex = 2;
			BackBtn.Text = "&Back";
			BackBtn.Enabled = true;
			BackBtn.DialogResult = System.Windows.Forms.DialogResult.Retry;

			NextBtn.Location = new System.Drawing.Point (100, 538);
			NextBtn.Size = new System.Drawing.Size (75, 23);
			NextBtn.TabIndex = 2;
			NextBtn.Text = "&Next";
			NextBtn.Enabled = false;
			NextBtn.DialogResult = System.Windows.Forms.DialogResult.Yes;
			
			CancelBtn.Location = new System.Drawing.Point (185, 538);
			CancelBtn.Size = new System.Drawing.Size (75, 23);
			CancelBtn.TabIndex = 3;
			CancelBtn.Text = "Cancel";
			CancelBtn.DialogResult = System.Windows.Forms.DialogResult.Cancel;

			FinishBtn.Location = new System.Drawing.Point (270, 538);
			FinishBtn.Size = new System.Drawing.Size (75, 23);
			FinishBtn.TabIndex = 4;
			FinishBtn.Text = "&Finish";
			FinishBtn.DialogResult = System.Windows.Forms.DialogResult.OK;
			FinishBtn.Enabled = false;		


			this.Text = "Select an Event Class";
			this.AutoScaleBaseSize = new System.Drawing.Size (5, 13);
			this.ClientSize = new System.Drawing.Size (360, 579);
			this.Controls.Add (this.FinishBtn);
			this.Controls.Add (this.CancelBtn);
			this.Controls.Add (this.NextBtn);
			this.Controls.Add (this.TreeLabel);
			this.Controls.Add (this.classTree);
			this.Controls.Add (this.QueryLabel);
			this.Controls.Add (this.QueryText);
			this.Controls.Add(this.BackBtn);
		}

		public string QueryString
		{
			get 
			{
				return QueryText.Text;
			}
		}

		public string SelectedClass
		{
			get
			{
				if (classTree.SelectedNode.Parent == null)
				{
					//a namespace is selected
					return null;
				}
				return this.classTree.SelectedNode.Text;
			}
		}

		public string SelectedClassPath
		{
			get
			{
				if (classTree.SelectedNode.Parent == null)
				{
					//a namespace is selected
					return null;
				}
				return WmiHelper.MakeClassPath(server,
						classTree.SelectedNode.Parent.Text,
						classTree.SelectedNode.Text);
			}
		}

		public string SelectedNS
		{
			get
			{
				if (classTree.SelectedNode.Parent == null)
				{
					//a namespace is selected
					return null;
				}
				return classTree.SelectedNode.Parent.Text;
			}
		}

		protected virtual void AfterNodeSelect(Object sender, TreeViewEventArgs args)
		{
			TreeNode curNode = args.Node;

			if (curNode.Parent == null )
			{
				return; //do nothing: this is a namespace
			}
		
			if (curNode.Parent != null)
			{
				this.QueryText.Text = "SELECT * FROM " + 
					curNode.Parent.Text + ":" + curNode.Text;
			}

			this.NextBtn.Enabled = true;
			this.FinishBtn.Enabled = true;		

		}

		public void OnQueryTextChanged(object sender,
									   EventArgs e) 
		{
			if (QueryText.Text == string.Empty)
			{
				this.NextBtn.Enabled = false;
				this.FinishBtn.Enabled = false;		
			}
			
		}


    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vside\servexpl\classtreeview.cs ===
namespace Microsoft.VSDesigner.WMI 
{
	using System;
	using System.Management;
	using System.Windows.Forms;
	using System.Net;
	using System.Collections;
	using System.Drawing;
	using System.Threading;

	internal enum ClassFilters 
	{
		ConcreteData,
		ConcreteOrHavingConcreteSubclasses,
		ExtrinsicEvents,
		All
	}


	// A delegate type for hooking up NS expansion start notifications.
	public delegate void NSExpandStartedEventHandler(string nsPath);

	// A delegate type for hooking up NS expansion end notifications.
	public delegate void NSExpandCompleteEventHandler(string nsPath);

	internal class WMIClassTreeView : TreeView
	{
		class ClassTreeNode : TreeNode
		{
			public ClassTreeNode (string serverName,
								string nsName,
								string wmiClass,
								string nodeLabel) :
				base(nodeLabel)
			{
				server = serverName;
				className = wmiClass;
				ns = nsName;
				if (nodeLabel == "")
				{
					base.Text = className;
				}
			}


			private string className = "";
			private string server = "";
			private string ns = "";

			public string ClassName
			{
				get
				{
					return className;
				}
				set 
				{
					className = value;
				}
			}

			public string Server
			{
				get
				{
					return server;
				}
				set 
				{
					server = value;
				}
			}

			public string Namespace
			{
				get
				{
					return ns;
				}
				set 
				{
					ns = value;
				}
			}			
		}
		private string server = string.Empty;
		private string connectAs = null;
		private string password = null;

		public event NSExpandStartedEventHandler NSExpandStarted;
		public event NSExpandCompleteEventHandler NSExpandComplete;

		private TreeCancelDialog cancelDlg = null;
		private bool bCancelled = false;
		private SortedList curClassList = new SortedList(100);
		private TreeNode curNSExpanded = null;

		private ClassFilters currentFilters;

				
		public WMIClassTreeView(string serverIn, 
						string user, 
						string pw,
						ClassFilters filters,
						string[] expandedNS)
		{
			server = serverIn;
			connectAs = user;
			password = pw;	
			currentFilters = filters;

			this.Location = new Point(16, 63);
			this.Size = (Size) new Point(200, 270);
			this.ShowPlusMinus = true;
			this.ShowLines = true;
			this.BeforeExpand += (new TreeViewCancelEventHandler(this.BeforeNodeExpand));
			this.HideSelection = false;
			this.FullRowSelect = true;
			this.Sorted = true;

			EnumNamespaces("root", 0);

			
		}

		public string SelectedClass
		{
			get
			{
				if (this.SelectedNode.Parent == null)
				{
					//ns selected
					return string.Empty;
				}
				return this.SelectedNode.Text;				
			}			
		}

		public string SelectedNS
		{
			get
			{
				if (this.SelectedNode.Parent == null)
				{
					//ns selected
					return this.SelectedNode.Text;	
				}
				else
				{
					return this.SelectedNode.Parent.Text;
				}		
			}
		}

		public ClassFilters CurrentFilters
		{
			get 
			{
				return currentFilters;
			}
			set 
			{
				if (value == currentFilters)
				{
					return;
				}
				currentFilters = value;
				
				//collapse namespaces and delete existing child nodes
				//put one dummy node under each NS instead
				this.Nodes.Clear();
				EnumNamespaces("root", 0);
				this.curClassList.Clear();
				this.curNSExpanded = null;
				
			}
		}


	  // Invoke the NSExpandStarted event
      protected virtual void OnNSExpandStarted(string nsPath) 
      {
         if (NSExpandStarted != null)
            NSExpandStarted(nsPath);
      }

		
	  // Invoke the NSExpandComplete event
      protected virtual void OnNSExpandComplete(string nsPath) 
      {
         if (NSExpandComplete != null)
            NSExpandComplete(nsPath);
      }


	protected virtual void BeforeNodeExpand(Object sender, TreeViewCancelEventArgs args)
	{
		TreeNode curNode = args.Node;
		this.OnNSExpandStarted(curNode.Text);

		//check that this is a namespace
		if (curNode.Parent != null)
		{
			return;
		}

		if ((curNode.Nodes.Count == 1 && curNode.Nodes[0].Text == "")) //list is empty		
		{				
			ShowClasses( args.Node);					
		}	
		
	}


		internal bool ShowClasses(TreeNode curNode)
		{
			try 
			{
				//check that this is a namespace:
				if (curNode.Parent != null)
				{
					return false;
				}

				this.Cursor = Cursors.WaitCursor;
				curNode.Nodes.Clear();
				curNSExpanded = curNode;
				curClassList.Clear();


				//spawn a thread that would handle cancel dialog
				//Thread cancelDlgThread  = new Thread (new ThreadStart(CancelDlgThread));
				//cancelDlgThread.Start();			

				string nsPath = WmiHelper.MakeNSPath(server, curNSExpanded.Text);

				ConnectionOptions connectOpts = new ConnectionOptions(
											"", //locale
											this.connectAs, //username
											this.password, //password
											"", //authority
											ImpersonationLevel.Impersonate,
											AuthenticationLevel.Connect,
											true, //enablePrivileges
											null	//context
										);

				ManagementScope scope = (this.server == WmiHelper.DNS2UNC(Dns.GetHostName())) ?	
					new ManagementScope(nsPath):
					new ManagementScope(nsPath, connectOpts);

				QueryOptions enumOpts = new QueryOptions(null, //context
														new TimeSpan(Int64.MaxValue),	//timeout
														50, //block size
														false,	//non-rewindable
														true,   //return immediately
														true,	//use amended quals
														true,	//ensure locatable
														false, //prototype only
														false	//direct read
														);																													
				

				ManagementObjectSearcher searcher = new ManagementObjectSearcher(scope, 
															new ObjectQuery("select * from meta_class"),
															enumOpts);																


				ManagementObjectCollection objs = searcher.Get();
				ManagementObjectCollection.ManagementObjectEnumerator objEnum = objs.GetEnumerator();

				while (objEnum.MoveNext() && !bCancelled)
				{
					ManagementClass obj = (ManagementClass)objEnum.Current;	
					if (FilterPass(obj))
					{
						TreeNode child = new TreeNode(obj.Path.RelativePath);
						curNSExpanded.Nodes.Add(child);	

						//curClassList.Add(obj.Path.RelativePath, obj.Path.RelativePath);					

					}					
				}

	
				if (!bCancelled)
				{	
						/*		
					for (int i = 0; i < curClassList.Count; i++)
					{
							
						//TreeNode child = new TreeNode(curClassList.GetByIndex(i).ToString());
						//curNSExpanded.Nodes.Add(child);	
					}
										
					
					cancelDlg.DialogResult = DialogResult.None;
					cancelDlg.Hide();
					cancelDlg.Dispose();
					cancelDlg = null;
					*/					
				}
				else
				{
					curClassList.Clear();

					//re-set NS node:
					curNSExpanded.Nodes.Clear();

					//show the node
					TreeNode dummy = new TreeNode("");
		
		            curNSExpanded.Nodes.Add(dummy);
					curNSExpanded.Collapse();

				}

				this.OnNSExpandComplete(curNode.Text);
				this.Cursor = Cursors.Default;
                
				return true;
			}
			catch (Exception e)
			{
				MessageBox.Show(WMISys.GetString("WMISE_Exception", e.Message, e.StackTrace));
				this.Cursor = Cursors.Default;
				return false;

			}
		}

        
		private void CancelDlgThread ()
			{
				try
				{
					if (cancelDlg != null)
					{
						cancelDlg.Hide();
						cancelDlg.Dispose();
						cancelDlg = null;
					}

					cancelDlg = new TreeCancelDialog(WMISys.GetString("WMISE_PleaseWait", curNSExpanded.Text),
														this.Location.X + 40, 
														this.Location.Y + 40);								
					
					DialogResult res = cancelDlg.ShowDialog();
					if (res == DialogResult.Cancel)
					{								
						bCancelled = true;
					}	
				}
				catch (Exception e)
				{
					MessageBox.Show(WMISys.GetString("WMISE_Exception", e.Message, e.StackTrace));
				}
			}


		

		private bool EnumNamespaces(string parent, int num)
			//recursively adds namespaces to the drop-down box
			{		
				try
				{	
					//show the node
					TreeNode dummy = new TreeNode("");
					TreeNode[] children = new TreeNode[] {dummy};
					TreeNode nsNode = new TreeNode(parent, 
													//(int)schema_icons.SCHEMA_NS_CLOSED, 
													//(int)schema_icons.SCHEMA_NS_CLOSED, 
													 children);
									
					nsNode.Collapse();
					this.Nodes.Insert(num, nsNode);
					
					string nsPath = WmiHelper.MakeClassPath(server, parent, "__NAMESPACE");
					string nsScopePath = WmiHelper.MakeNSPath(server, parent);

					ConnectionOptions connectOpts = new ConnectionOptions("", //locale
																			this.connectAs, //username
																			this.password, //password
																			"", //authority
																			ImpersonationLevel.Impersonate,
																			AuthenticationLevel.Connect,
																			true, //enablePrivileges
																			null	//context
																			);

					ManagementScope scope = (this.server == WmiHelper.DNS2UNC(Dns.GetHostName())) ?	
						new ManagementScope(nsScopePath):
						new ManagementScope(nsScopePath, connectOpts);


					ManagementClass nsClass = new ManagementClass(scope, 
														new ManagementPath(nsPath), 
														new ObjectGetOptions(null, true));

					ManagementObjectCollection subNSCollection = nsClass.GetInstances();
				
					IEnumerator eInstances = ((IEnumerable)subNSCollection).GetEnumerator();
				    while(eInstances.MoveNext())
					{
		                num++;
						
						ManagementObject obj = (ManagementObject)eInstances.Current;
						PropertyCollection props = (PropertyCollection)obj.Properties;
		                							
						string NameOut = "";
						string curName = props["Name"].Value.ToString();

						//skip localized namespace
						//NOTE: this assumes that localized namespaces are always leaf
						if (curName.ToUpper().IndexOf("MS_", 0) == 0)
						{
							continue;
						}

						//skip root\security namespace (we don't want to expose it)
						if (curName.ToUpper() == "SECURITY" && parent.ToUpper() == "ROOT")
						{
							continue;
						}

						
						//skip root\directory\ldap namespace (BUGBUG: change this in Beta2 when we can do asynchronous class enumerations)
						if (curName.ToUpper() == "LDAP" && parent.ToUpper() == "ROOT\\DIRECTORY")
						{
							continue;
						}
						

						
						if (parent != "")
						{
							NameOut = parent + "\\" + curName;
						}
						else
						{
							NameOut = curName;
						} 				
						
						EnumNamespaces(NameOut, num);							
					}
					
					return true;
				}
				catch (Exception e)
				{
					MessageBox.Show(WMISys.GetString("WMISE_Exception", e.Message, e.StackTrace));
					return false;
				}	
			}



	/// <summary>
	/// This returns false if the object should be filtered out according to currentFilters value
	/// </summary>
	/// <param name="obj"> </param>
	private bool FilterPass (ManagementClass obj)
	{
		switch (currentFilters)
		{
			case (ClassFilters.ConcreteData) :
			{
				if (!WmiHelper.IsAbstract(obj) &&
					!WmiHelper.IsAssociation(obj))
					return true;
				else
					return false;
			}
			case (ClassFilters.ConcreteOrHavingConcreteSubclasses) :
			{
				if(!WmiHelper.IsAbstract(obj) ||
					WmiHelper.HasNonAbstractChildren(obj))
					return true;
				else
					return false;
				
			}
			case (ClassFilters.ExtrinsicEvents) :
			{
				if (WmiHelper.IsEvent(obj))
					return true;
				else
					return false;

			}
			case (ClassFilters.All) :
			{
				return true;				
			}
			default :
					break;
			}

			return true;
		}		
						
	}

	internal class TreeCancelDialog : Form
	{
		private Button cancelBtn = new Button();
		private Label text = new Label();

		private void InitializeComponent ()
		{
			this.ClientSize = (Size)new Point(250, 100);
			this.ShowInTaskbar = false;
			this.MinimizeBox = false;
			this.MaximizeBox = false;

			this.AcceptButton = cancelBtn;
			this.BorderStyle = FormBorderStyle.FixedSingle;	
			this.AutoScaleBaseSize = (Size) new Point(5, 13);					
							
			text.Location = new Point(15, 15);
			text.TabStop = false;
			text.Size = (Size) new Point(200, 25);
								
			cancelBtn.Location = new Point(95, 70);
			cancelBtn.DialogResult = DialogResult.Cancel;
			cancelBtn.Text = WMISys.GetString("WMISE_Cancel");
			cancelBtn.TabStop = true;
			
		}

		public TreeCancelDialog(string textIn, int x, int y)
		{			
			InitializeComponent();
			text.Text = textIn;

			this.Location = new Point(x, y);

			this.Controls.Add(cancelBtn); 
			this.Controls.Add(text);
		}
		

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vside\servexpl\eventquerycomponent.cs ===
namespace Microsoft.VSDesigner.WMI {

	using System;
	using System.ComponentModel;
	//using System.Core;
	using System.Collections;
	using System.Windows.Forms;


	internal class EventQueryComponent : Component
	{
		public readonly  string server = "";
		public readonly  string ns = "";
		public string query = "";	

		private EventQueryNode queryNode = null;
     
		public EventQueryComponent(String serverIn,
									String nsIn,
									String queryIn,
									EventQueryNode queryNodeIn)
		{					
			server = serverIn;
			ns = nsIn;
			query = queryIn;
			queryNode = queryNodeIn;
		}

		public override bool Equals(Object other)
		{
			if (!(other is EventQueryComponent))
			{
				return false;
			}
			if ((((EventQueryComponent)other).server == server) &&
				(((EventQueryComponent)other).ns == ns) &&
				(((EventQueryComponent)other).query == query) )
			{
				return true;
			}
			else
			{
				return false;
			}
		}


		[
		Browsable(true),
		ServerExplorerBrowsable(true)
		]
		public string Server
		{
			get
			{
				return server;
			}
		}

		
		[
		Browsable(true),
		ServerExplorerBrowsable(true)
		]
		public string WMINamespace
		{
			get
			{
				return ns;
			}
		}


		[
		Browsable(true),
		ServerExplorerBrowsable(true)
		]
		public string Query
		{
			get
			{
				return query;
			}
			set 
			{
				query = value;			
				queryNode.Query = value;				
			}
		}
			
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vside\servexpl\makefile.inc ===
!if 0
    -------------------------------------------------------------------------------------
        Don't modify... user variables are set in "sources"
    -------------------------------------------------------------------------------------
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vside\servexpl\eventtypeselectordialog.cs ===
namespace Microsoft.VSDesigner.WMI
{
    using System;
    using System.Drawing;
    using System.Collections;
    using System.ComponentModel;
    using System.Windows.Forms;

	

    /// <summary>
    ///    Summary description for EventTypeSelectorDialog.
    /// </summary>
    internal class EventTypeSelectorDialog : System.Windows.Forms.Form
    {
        /// <summary>
        ///    Required designer variable.
        /// </summary>
        private System.ComponentModel.Container components;
		private System.Windows.Forms.TextBox DialogDescription;
		private System.Windows.Forms.GroupBox groupBox1;
		private System.Windows.Forms.Button Next;
		private System.Windows.Forms.Button Cancel;
		private System.Windows.Forms.RadioButton ExtrinsicEvents;
		private System.Windows.Forms.RadioButton InstanceEvents;
		private System.Windows.Forms.RadioButton ClassEvents;
		private System.Windows.Forms.RadioButton NSEvents;
		private System.Windows.Forms.TextBox queryName;
		private System.Windows.Forms.Label label1;



		public string QueryName
		{
			get
			{
				return queryName.Text;
			}
		}				

        public EventTypeSelectorDialog(string defaultQueryName)
        {
            //
            // Required for Windows Form Designer support
            //
            InitializeComponent();

            //
            // TODO: Add any constructor code after InitializeComponent call
            //

		}

		public EventType SelectedEventType
		{
			get
			{
				if (ExtrinsicEvents.Checked)
				{
					return EventType.Extrinsic;
				}	
				if (InstanceEvents.Checked)
				{
					return EventType.Instance;
				}					
				if (ClassEvents.Checked)
				{
					return EventType.Class;
				}					
				if (NSEvents.Checked)
				{
					return EventType.Namespace;
				}	
				//default
				return EventType.Extrinsic;
			}		
		}

        /// <summary>
        ///    Clean up any resources being used.
        /// </summary>
        public override void Dispose()
        {
            base.Dispose();
            components.Dispose();
        }

        /// <summary>
        ///    Required method for Designer support - do not modify
        ///    the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
		{
			this.components = new System.ComponentModel.Container ();
			this.queryName = new System.Windows.Forms.TextBox ();
			this.ClassEvents = new System.Windows.Forms.RadioButton ();
			this.groupBox1 = new System.Windows.Forms.GroupBox ();
			this.label1 = new System.Windows.Forms.Label ();
			this.Next = new System.Windows.Forms.Button ();
			this.InstanceEvents = new System.Windows.Forms.RadioButton ();
			this.ExtrinsicEvents = new System.Windows.Forms.RadioButton ();
			this.NSEvents = new System.Windows.Forms.RadioButton ();
			this.Cancel = new System.Windows.Forms.Button ();
			this.DialogDescription = new System.Windows.Forms.TextBox ();
			//@this.TrayHeight = 0;
			//@this.TrayLargeIcon = false;
			//@this.TrayAutoArrange = true;
			queryName.Location = new System.Drawing.Point (8, 120);
			queryName.TabIndex = 1;
			queryName.Size = new System.Drawing.Size (320, 20);
			queryName.TextChanged += new System.EventHandler (this.OnQueryNameChanged);
			ClassEvents.Location = new System.Drawing.Point (16, 248);
			ClassEvents.Text = "C&lass Operation Events";
			ClassEvents.Size = new System.Drawing.Size (288, 23);
			ClassEvents.Enabled = false;
			ClassEvents.TabIndex = 4;
			groupBox1.Location = new System.Drawing.Point (8, 160);
			groupBox1.TabIndex = 9;
			groupBox1.TabStop = false;
			groupBox1.Text = "Select event type:";
			groupBox1.Size = new System.Drawing.Size (320, 160);
			label1.Location = new System.Drawing.Point (8, 104);
			label1.Text = "Query Name:";
			label1.Size = new System.Drawing.Size (152, 16);
			label1.TabIndex = 0;
			Next.Location = new System.Drawing.Point (184, 344);
			Next.DialogResult = System.Windows.Forms.DialogResult.Retry;
			Next.Size = new System.Drawing.Size (75, 23);
			Next.TabIndex = 8;
			Next.Enabled = false;
			Next.Text = "&Next >";
			InstanceEvents.Location = new System.Drawing.Point (16, 216);
			InstanceEvents.Text = "&Data Operation Events";
			InstanceEvents.Size = new System.Drawing.Size (288, 23);
			InstanceEvents.TabIndex = 3;
			ExtrinsicEvents.Checked = true;
			ExtrinsicEvents.Location = new System.Drawing.Point (16, 184);
			ExtrinsicEvents.Text = "&Custom Events";
			ExtrinsicEvents.Size = new System.Drawing.Size (288, 23);
			ExtrinsicEvents.TabIndex = 5;
			ExtrinsicEvents.TabStop = true;
			NSEvents.Location = new System.Drawing.Point (16, 280);
			NSEvents.Text = "Na&mespace Operation Events";
			NSEvents.Size = new System.Drawing.Size (288, 23);
			NSEvents.Enabled = false;
			NSEvents.TabIndex = 6;
			Cancel.Location = new System.Drawing.Point (80, 344);
			Cancel.DialogResult = System.Windows.Forms.DialogResult.Cancel;
			Cancel.Size = new System.Drawing.Size (75, 23);
			Cancel.TabIndex = 7;
			Cancel.Text = "Cancel";
			DialogDescription.ReadOnly = true;
			DialogDescription.Text = "Event Type";
			DialogDescription.Multiline = true;
			DialogDescription.BorderStyle = System.Windows.Forms.BorderStyle.None;
			DialogDescription.Font = new System.Drawing.Font ("Microsoft Sans Serif", 8, System.Drawing.FontStyle.Bold);
			DialogDescription.TabIndex = 10;
			DialogDescription.Size = new System.Drawing.Size (336, 88);
			DialogDescription.BackColor = System.Drawing.Color.White;
			this.Text = "Select Event Type";
			this.MaximizeBox = false;
			this.AutoScaleBaseSize = new System.Drawing.Size (5, 13);
			this.HelpButton = true;
			this.ShowInTaskbar = false;
			this.ControlBox = false;
			this.MinimizeBox = false;
			this.ClientSize = new System.Drawing.Size (336, 381);
			this.Controls.Add (this.DialogDescription);
			this.Controls.Add (this.Next);
			this.Controls.Add (this.Cancel);
			this.Controls.Add (this.NSEvents);
			this.Controls.Add (this.ExtrinsicEvents);
			this.Controls.Add (this.InstanceEvents);
			this.Controls.Add (this.ClassEvents);
			this.Controls.Add (this.queryName);
			this.Controls.Add (this.label1);
			this.Controls.Add (this.groupBox1);
		}

		protected void DialogDescription_TextChanged (object sender, System.EventArgs e)
		{

		}

		protected void OnQueryNameChanged (object sender, System.EventArgs e)
		{
			Next.Enabled = (queryName.Text != string.Empty);
			if (Next.Enabled)
			{
				this.AcceptButton = Next;
				this.UpdateDefaultButton();
			}			
		}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vside\servexpl\eventquerydialog.cs ===
namespace Microsoft.VSDesigner.WMI
{
    using System;
    using System.Drawing;
    using System.Collections;
    using System.ComponentModel;
    using System.Windows.Forms;
	using System.Management;
	using System.Collections.Specialized;

    /// <summary>
    ///    Summary description for EventClassPickerDialog.
    /// </summary>
	internal class EventQueryDialog : System.Windows.Forms.Form
	{
		/// <summary>
		///    Required designer variable.
		/// </summary>
		/// 

		public const string DefaultPollingInterval = "60";

		private System.ComponentModel.Container components;
		private System.Windows.Forms.Button OKBtn = new Button();
		private System.Windows.Forms.Button CancelBtn = new Button();
		private System.Windows.Forms.Button AdvancedBtn = new Button();
		private System.Windows.Forms.Button HelpBtn = new Button();
		private System.Windows.Forms.GroupBox groupBox1 = new GroupBox ();
		private System.Windows.Forms.RadioButton ExtrinsicEvents = new RadioButton();
		private System.Windows.Forms.RadioButton InstanceEvents = new RadioButton();

		private Label TreeLabel = null;
		private Label EventTypeLabel = null;
		private ComboBox EventTypeSelector = null;
		private Label pollingIntervalLbl = new Label();
		private TextBox pollingIntervalBox = new TextBox();
		private Label secondsLbl = new Label();

        private WMIClassTreeView classTree = null;
		private string queryString = string.Empty;

		private string server = null;
		private string connectAs = null;
		private string password = null;
		private ClassFilters classFilters = ClassFilters.ConcreteOrHavingConcreteSubclasses;


		private string[] strIntrinsicEvents = new string[]
		{
			WMISys.GetString("WMISE_IntrinsicEvent_Created"),
			WMISys.GetString("WMISE_IntrinsicEvent_Modified"),
			WMISys.GetString("WMISE_IntrinsicEvent_Deleted"),
			WMISys.GetString("WMISE_IntrinsicEvent_Operated")
		};											

		public EventQueryDialog(string serverIn, 
			string user, 
			string pw)
		{
			server = serverIn;
			connectAs = user;
			password = pw;


			//
			// Required for Windows Form Designer support
			//
			InitializeComponent();

			groupBox1.Location = new System.Drawing.Point (8, 20);
			groupBox1.TabStop = false;
			groupBox1.Text = WMISys.GetString("WMISE_EventQueryDlg_SelectEventType");
			groupBox1.Size = new System.Drawing.Size (330, 80);

			InstanceEvents.Location = new System.Drawing.Point (16, 40);
			InstanceEvents.Text = WMISys.GetString("WMISE_EventQueryDlg_IntrinsicEvents");
			InstanceEvents.Size = new System.Drawing.Size (288, 23);
			InstanceEvents.TabIndex = 0;
			InstanceEvents.Click += new EventHandler (OnCheckIntrinsic);
			InstanceEvents.Checked = true;

			ExtrinsicEvents.Location = new System.Drawing.Point (16, 60);
			ExtrinsicEvents.Text = WMISys.GetString("WMISE_EventQueryDlg_ExtrinsicEvents");
			ExtrinsicEvents.Size = new System.Drawing.Size (288, 23);
			ExtrinsicEvents.TabIndex = 1;
			ExtrinsicEvents.TabStop = true;
			ExtrinsicEvents.Click += new EventHandler (OnCheckExtrinsic);

			TreeLabel = new Label();
			TreeLabel.Text = WMISys.GetString("WMISE_EventQueryDlg_AvailableClasses");
			TreeLabel.Location = new Point(15, 115);		
		
			classTree = new WMIClassTreeView(server, connectAs, password, classFilters, null);
			classTree.Location = new System.Drawing.Point (15, 138);
			classTree.Size = new System.Drawing.Size (330, 200);
			classTree.TabIndex = 0;
			classTree.AfterSelect += (new TreeViewEventHandler (this.OnNodeSelect));

			EventTypeLabel = new Label();
			EventTypeLabel.Text = WMISys.GetString("WMISE_EventQueryDlg_IntrinsicEventComboLabel");
			EventTypeLabel.Location = new Point(15, 358);
			EventTypeLabel.Size = new Size(330, 18);

			EventTypeSelector = new ComboBox();	
			EventTypeSelector.Location = new Point(15, 380);
			EventTypeSelector.Size = new Size(330, 20);
			EventTypeSelector.SelectedIndexChanged += (new EventHandler(OnIntrinsicEventTypeChanged));

			//sort instance operations alphabetically 
			ArrayList operationList = new ArrayList (strIntrinsicEvents);
			operationList.Sort();
			foreach (string eventName in operationList)
			{
				EventTypeSelector.Items.Add(eventName);
			}						
			
			EventTypeSelector.SelectedIndex = 0;

			pollingIntervalLbl.Location = new Point(15, 415);
			pollingIntervalLbl.Text = WMISys.GetString("WMISE_EventQueryDlg_PollingIntervalLabel");
			pollingIntervalLbl.Size = new Size (150, 20);
			
			pollingIntervalBox = new TextBox();
			pollingIntervalBox.Text = DefaultPollingInterval;
			pollingIntervalBox.Location = new Point(15, 435);
			pollingIntervalBox.Size = new Size(60, 20);
			pollingIntervalBox.Leave += new EventHandler(OnPollingChanged);
			
			secondsLbl.Text = WMISys.GetString("WMISE_Seconds");
			secondsLbl.Location = new Point(90, 435);

			HelpBtn.Location = new System.Drawing.Point (15, 470);
			HelpBtn.Size = new System.Drawing.Size (75, 23);
			HelpBtn.TabIndex = 2;
			HelpBtn.Text = WMISys.GetString("WMISE_Help");
			HelpBtn.Enabled = true;

			OKBtn.Location = new System.Drawing.Point (100, 470);
			OKBtn.Size = new System.Drawing.Size (75, 23);
			OKBtn.TabIndex = 2;
			OKBtn.Text = WMISys.GetString("WMISE_SubscribeBtn");
			OKBtn.Enabled = false;
			OKBtn.DialogResult = System.Windows.Forms.DialogResult.OK;
			
			CancelBtn.Location = new System.Drawing.Point (185, 470);
			CancelBtn.Size = new System.Drawing.Size (75, 23);
			CancelBtn.TabIndex = 3;
			CancelBtn.Text = WMISys.GetString("WMISE_Cancel");
			CancelBtn.DialogResult = System.Windows.Forms.DialogResult.Cancel;

			AdvancedBtn.Location = new System.Drawing.Point (270, 470);
			AdvancedBtn.Size = new System.Drawing.Size (75, 23);
			AdvancedBtn.TabIndex = 4;
			AdvancedBtn.Text = WMISys.GetString("WMISE_AdvancedBtn");
			AdvancedBtn.Click += new EventHandler(OnAdvanced);
			AdvancedBtn.Enabled = false;		

			this.Text = WMISys.GetString("WMISE_EventQueryDlg_Title");
			this.BorderStyle = FormBorderStyle.FixedDialog;
			this.ShowInTaskbar = false;
			this.MinimizeBox = false;
			this.MaximizeBox = false;

			this.Controls.Add (TreeLabel);			
			this.Controls.Add (EventTypeLabel);
			this.Controls.Add (EventTypeSelector);
			this.Controls.Add (classTree);
			this.Controls.Add (pollingIntervalLbl);
			this.Controls.Add (pollingIntervalBox);
			this.Controls.Add (secondsLbl);	
			
			this.Controls.Add (ExtrinsicEvents);
			this.Controls.Add (InstanceEvents);
			this.Controls.Add (groupBox1);
			this.Controls.Add(OKBtn);
			this.Controls.Add(HelpBtn);
			this.Controls.Add(CancelBtn);
			this.Controls.Add(AdvancedBtn);

		}

		/// <summary>
		///    Clean up any resources being used.
		/// </summary>
		public override void Dispose()
		{
			base.Dispose();
			components.Dispose();
		}

		/// <summary>
		///    Required method for Designer support - do not modify
		///    the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			this.components = new System.ComponentModel.Container ();
		
			//@this.TrayHeight = 0;
			//@this.TrayLargeIcon = false;
			//@this.TrayAutoArrange = true;
			
			this.MaximizeBox = false;
			this.AutoScaleBaseSize = new System.Drawing.Size (5, 13);			
			this.MinimizeBox = false;
			this.ClientSize = new System.Drawing.Size (360, 520);
			
		}

		public string QueryString
		{
			get 
			{
				return queryString;
			}
		}

		public string SelectedClassPath
		{
			get
			{
				if (classTree.SelectedNode == null)
				{
					return "";
				}
				if (classTree.SelectedNode.Parent == null)
				{
					//a namespace is selected
					return null;
				}
				return WmiHelper.MakeClassPath(server,
					classTree.SelectedNode.Parent.Text,
					classTree.SelectedNode.Text);
			}
		}

		public string SelectedClassName
		{
			get
			{
				if (classTree.SelectedNode == null)
				{
					return "";
				}
				else
				{
					return classTree.SelectedNode.Text;
				}
			}
		}

		public string SelectedClassNSPath
		{
			get
			{
				if (classTree.SelectedNode.Parent == null)
				{
					//a namespace is selected
					return null;
				}
				return 	classTree.SelectedNode.Parent.Text + ":" +
					classTree.SelectedNode.Text;
			}
		}

		public string SelectedNS
		{
			get
			{
				if (classTree.SelectedNode.Parent == null)
				{
					//a namespace is selected
					return null;
				}
				return 	classTree.SelectedNode.Parent.Text;
			}
		}

		protected virtual void OnNodeSelect(Object sender, TreeViewEventArgs args)
		{
			AdvancedBtn.Enabled = (classTree.SelectedClass != string.Empty);			
			OKBtn.Enabled = (classTree.SelectedClass != string.Empty);			

			if (this.InstanceEvents.Checked)
			{
				queryString = "SELECT * FROM " + EventName + " WITHIN " + pollingIntervalBox.Text +
					" WHERE TargetInstance ISA \"" + classTree.SelectedNode.Text + "\"";		
			}
			else
			{
				queryString = "SELECT * FROM " + classTree.SelectedNode.Text;		
				
			}

			
		}

		
		private String EventName 
		{
			get 
			{
				if (EventTypeSelector.Text == WMISys.GetString("WMISE_IntrinsicEvent_Created"))
				{
					return "__InstanceCreationEvent";
				}
				if (EventTypeSelector.Text == WMISys.GetString("WMISE_IntrinsicEvent_Modified"))
				{
					return "__InstanceModificationEvent";					
				}
				if (EventTypeSelector.Text == WMISys.GetString("WMISE_IntrinsicEvent_Deleted"))
				{
					return "__InstanceDeletionEvent";
				}
				if (EventTypeSelector.Text == WMISys.GetString("WMISE_IntrinsicEvent_Operated"))
				{
					return "__InstanceOperationEvent";
				}

				return string.Empty;				
			}
		}

		
		private void OnAdvanced (Object source, EventArgs args)
		{
			try
			{
				QueryConditionDialog dlg = null;

				if (this.SelectedEventType == EventType.Instance)
				{
					//spawn an instance of the appropriate intrinsic event class
					//and set its TargetInstance property to the selected data class
					//Then, pass the instance object to QueryConditionDialog ctor.
					ManagementClass classObj = null;
					ManagementObject instObj = null;

					ManagementScope rootScope = new ManagementScope(new ManagementPath(WmiHelper.MakeNSPath(server, "root")),
						new ConnectionOptions("", connectAs, password, "", ImpersonationLevel.Impersonate,
						AuthenticationLevel.Connect, true, null));						
			
					if (EventTypeSelector.Text == WMISys.GetString("WMISE_IntrinsicEvent_Created"))
					{
						classObj =new ManagementClass(rootScope, new ManagementPath(WmiHelper.MakeClassPath(server,"root","__InstanceCreationEvent")),
							new ObjectGetOptions(null, true));

						instObj = classObj.CreateInstance();

					}		
					else if (EventTypeSelector.Text == WMISys.GetString("WMISE_IntrinsicEvent_Modified"))
					{
						classObj = new ManagementClass(rootScope, new ManagementPath(WmiHelper.MakeClassPath(server,"root","__InstanceModificationEvent")),
							new ObjectGetOptions(null, true));
						instObj = classObj.CreateInstance();
					}
					else if (EventTypeSelector.Text == WMISys.GetString("WMISE_IntrinsicEvent_Deleted"))
					{
						classObj = new ManagementClass(rootScope, new ManagementPath(WmiHelper.MakeClassPath(server,"root","__InstanceDeletionEvent")),
							new ObjectGetOptions(null, true));

						instObj = classObj.CreateInstance();
					}
					else if (EventTypeSelector.Text == WMISys.GetString("WMISE_IntrinsicEvent_Operated"))
					{
						classObj = new ManagementClass(rootScope, new ManagementPath(WmiHelper.MakeClassPath(server,"root","__InstanceOperationEvent")),
							new ObjectGetOptions(null, true));
						instObj = classObj.CreateInstance();
					}

					ManagementObject targetObj = new ManagementObject (WmiHelper.MakeClassPath(server, classTree.SelectedNS, classTree.SelectedClass), 																
																		new ObjectGetOptions(null, false));

					instObj["TargetInstance"] = (Object)targetObj;
								
					dlg = new QueryConditionDialog(instObj, 
													server, 
													classTree.SelectedNS, 
													classTree.SelectedClass,
													queryString);

				}
				else
				{
					dlg = new QueryConditionDialog(server, connectAs, password,
													classTree.SelectedNS, 
													classTree.SelectedClass,
													queryString);				
				}
				
				DialogResult res = dlg.ShowDialog();
				if (res == DialogResult.Cancel)
				{
					return;
				}
				//update query text;
				queryString = dlg.QueryString;
			}
			catch (Exception e)
			{
				MessageBox.Show(WMISys.GetString("WMISE_Exception", e.Message, e.StackTrace));				
			}			
			
		}

		private void OnCheckIntrinsic(Object source, EventArgs args)
		{
            classTree.CurrentFilters = ClassFilters.ConcreteOrHavingConcreteSubclasses;
			 
			//enable polling and intrinsic event type controls
			this.pollingIntervalBox.Enabled = true;
			this.EventTypeSelector.Enabled = true;
		}

		private void OnCheckExtrinsic(Object source, EventArgs args)
		{
			classTree.CurrentFilters = ClassFilters.ExtrinsicEvents; 

 			//disable polling and intrinsic event type controls
			this.pollingIntervalBox.Enabled = false;
			this.EventTypeSelector.Enabled = false;
		}

		private void OnIntrinsicEventTypeChanged(Object source, EventArgs args)
		{
			if (classTree.SelectedNode != null)
			{
				queryString = "SELECT * FROM " + EventName + " WITHIN " + pollingIntervalBox.Text +
					" WHERE TargetInstance ISA \"" + classTree.SelectedNode.Text + "\"";		
			}

		}

		private void OnPollingChanged(Object source, EventArgs args)
		{
			try 
			{
				Convert.ToDouble(pollingIntervalBox.Text);
			}
			catch (Exception)
			{
				MessageBox.Show(WMISys.GetString("WMISE_Polling_Interval_Validation_Failed",
								pollingIntervalBox.Text));

				pollingIntervalBox.Text = DefaultPollingInterval;
				return;
			}

			if (InstanceEvents.Checked)
			{
				queryString = "SELECT * FROM " + EventName + " WITHIN " + pollingIntervalBox.Text +
					" WHERE TargetInstance ISA \"" + classTree.SelectedNode.Text + "\"";		
			}
			else
			{
				//should never get here
				return;				
			}
		}
		
		public EventType SelectedEventType
		{
			get
			{
				if (ExtrinsicEvents.Checked)
				{
					return EventType.Extrinsic;
				}	
				if (InstanceEvents.Checked)
				{
					return EventType.Instance;
				}					
			
				//default
				return EventType.Extrinsic;
			}		
		}


    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vside\servexpl\eventquerynode.cs ===
namespace Microsoft.VSDesigner.WMI {
    using System.Runtime.Serialization;
    using System.Diagnostics;
    using System;
    using System.Windows.Forms;
    using System.Drawing;
    using System.Collections;
    using Microsoft.VSDesigner;
	using Microsoft.VSDesigner.ServerExplorer;
    using System.ComponentModel.Design;
	using System.ComponentModel;
	using System.Resources;
	using System.Reflection;
	using EnvDTE;
	using Microsoft.VSDesigner.Interop;
	using System.Management;
	using System.Threading;


    // <doc>
    // <desc>
    //     This represents the wmi classes node under a server node.
    // </desc>
    // </doc>
    [UserContextAttribute("serveritem", "EventQuery")]
    internal class EventQueryNode : Node, ISerializable  {
        //
        // FIELDS
        //

		//GUID_BuildOutputWindowPane
		Guid OutputWindowGuid = new Guid(0x1BD8A850, 0x02D1, 0x11d1, 0xbe, 0xe7, 0x0, 0xa0, 0xc9, 0x13, 0xd1, 0xf8);

		enum SubscriptionState
		{
			Started,
			Stopped, 
			Error
		};

        private Image icon = null;
        public static readonly Type parentType = typeof(EventsNode);
	    private string label = string.Empty;
		private string serverName = string.Empty;
		private string nsName = string.Empty;
		private string query = string.Empty;
		private string connectAs = null;
		private string password = null;
		private string eventLabel = string.Empty;

		private SubscriptionState state =  SubscriptionState.Stopped;
		private ManagementEventWatcher eventWatcher = null; 
		private EventQueryComponent browseObject = null;

		private OutputWindowPane outputPane = null;

		private ArrayList eventNodes = new ArrayList(50);
	
        //
        // CONSTRUCTORS
        //

        // <doc>
        // <desc>
        //     Main constructor.
		//     Parameters: 
		//	string server (in, machine name)
		//	string pathIn (in, WMI path without the server name , e.g. "root\default:MyClass")
        // </desc>
        // </doc>
        public EventQueryNode(string labelIn,
							string serverIn,
							string nsIn,
							string queryIn,
							string user,
							string pw) {
			try
			{
				if (serverIn == string.Empty ||
					labelIn == string.Empty ||
					nsIn == string.Empty ||
					queryIn == string.Empty)
				{
					throw new ArgumentException();
				}

				serverName = serverIn;
				nsName = nsIn;
				query = queryIn;
				connectAs = user;
				password = pw;
				label = labelIn;

				state =  SubscriptionState.Started;				
						
				browseObject = new EventQueryComponent(serverName, nsName, query, this);

				OnStartReceiving(this, null);				
				
			}
			catch (Exception exc)
			{
				MessageBox.Show(WMISys.GetString("WMISE_Exception", exc.Message, exc.StackTrace));
				throw (exc);
			}
		}

		
		/// <summary>
        ///     The object retrieves its serialization info.
        /// </summary>
        public EventQueryNode(SerializationInfo info, StreamingContext context) {
            
			try 
			{
						
				serverName = info.GetString("Server");
				nsName = info.GetString("NS");
				query = info.GetString("Query");
				connectAs = info.GetString("ConnectAs");
				password = info.GetString("Password");
				eventLabel = info.GetString("EventLabel");

				state =  SubscriptionState.Stopped;				
			
				browseObject = new EventQueryComponent(serverName, nsName, query, this);				
			                        
            }
            catch (Exception exc) {
				MessageBox.Show(WMISys.GetString("WMISE_Exception", exc.Message, exc.StackTrace));
				throw (exc);
            }
        }
		

        //
        // PROPERTIES
        //

        // <doc>
        // <desc>
        //     Returns icon for this node.
        // </desc>
        // </doc>
		
		public override Image Icon 
		{
			get 
			{
				//TODO: display different icons for associations, abstract, etc.
				if (icon == null)
				{	
					if (state ==  SubscriptionState.Started)
					{						
						icon = new Icon(GetType(), "Start.ico").ToBitmap();
					}
					else
					{
						if (state ==  SubscriptionState.Stopped)
						{
							icon = new Icon(GetType(), "Stop.ico").ToBitmap();							
						}
						else
						{
							icon = new Icon(GetType(), "ErrorNode.ico").ToBitmap();							
						}						
					}					
				}				
				return icon;
			}
		}
			
			

		 /// <summary>
		///     This node has no children.
		/// </summary>
		public override bool IsAlwaysLeaf() 
		{
			return true;
		}

		
	
	/// <summary>
	/// Context menu for a class object contains static method names
	/// </summary>
	public override ContextMenuItem[] GetContextMenuItems() 
	{			
		ContextMenuItem[] theMenu = new ContextMenuItem[3];		
		theMenu[0] = new ContextMenuItem(WMISys.GetString("WMISE_EventQueryStart"),
								new EventHandler(OnStartReceiving),
								(state != SubscriptionState.Started));	

		theMenu[1] = new ContextMenuItem(WMISys.GetString("WMISE_EventQueryStop"),
								new EventHandler(OnStopReceiving),
								(state == SubscriptionState.Started));	

		//theMenu[2] = new ContextMenuItem(WMISys.GetString("WMISE_EventQueryPurge"),
		//						new EventHandler(OnPurgeEvents));
		//theMenu[3] = new ContextMenuItem("&Modify query...", 
		//						new EventHandler(OnModifyQuery));

       	return theMenu;
    }

	public override bool CanDeleteNode()
	{
		return true;
	}

	public override bool ConfirmDeletingNode()
	{
		if (eventWatcher != null)
		{
			eventWatcher.Stop();
		}
		return true;
	}


        // <doc>
        // <desc>
        //     Returns label constant for this node.
        // </desc>
        // </doc>
        public override string Label {
             get {
                if (label == null || label.Length == 0) {
                    label = query; 
                }
                return label;
            }
             set {
            }
        }

        //
        // METHODS
        //

        // <doc>
        // <desc>
        //     Create instance nodes under this node.
        // </desc>
        // </doc>
        public override Node[] CreateChildren() 
		{	
			try
			{
				MessageBox.Show(eventNodes.ToString());
				Node[] nodes = new Node[eventNodes.Count];
				eventNodes.CopyTo(nodes);			

				return nodes;									
			}
			catch(Exception exc)
			{
				MessageBox.Show(WMISys.GetString("WMISE_Exception", exc.Message, exc.StackTrace));
				return null;
			}
			
        }

      
        public override int CompareUnique(Node node) {
            if (node is EventQueryNode &&
				((EventQueryNode)node).serverName == this.serverName &&
				((EventQueryNode)node).nsName == this.nsName &&
				((EventQueryNode)node).query == this.query)
			{
				return 0;
			}
			return Label.CompareTo(node.Label);
			
        }
	
	
	/// <summary>
	/// Get component to be displayed in PB window
	/// </summary>
	public override Object GetBrowseComponent() 
	{	
		return browseObject;
		/*
		if (eventWatcher == null)
		{
			ConnectionOptions connectOpts = new ConnectionOptions(
												"", //locale
												this.connectAs, //username
												this.password, //password
												"", //authority
												ImpersonationLevel.Impersonate,
												AuthenticationLevel.Connect,
												true, //enablePrivileges
												null	//context
											);

			ManagementScope scope = new ManagementScope(nsName, connectOpts);
			eventWatcher = new ManagementEventWatcher(scope, new EventQuery(query));
		}

		return eventWatcher;
		*/
    }


	/// <summary>
	/// Subscribes for event notifications
	/// </summary>
	/// <param name="sender"> </param>
	/// <param name="e"> </param>
	private void OnStartReceiving(object sender, EventArgs e)
	{
		try 
		{			
			//spawn a thread that would receive wmi events 
			System.Threading.Thread eventThread  = new System.Threading.Thread (new ThreadStart(GetEvents));
			eventThread.Start();

			while(!eventThread.IsAlive);
			
			state =  SubscriptionState.Started;
			icon = new Icon(GetType(),"Start.ico").ToBitmap();

			if (this.GetNodeSite() != null)
			{
				GetNodeSite().UpdateIcon();
			}
	
		}
		catch(Exception exc)
		{
			state =  SubscriptionState.Error;
			icon = new Icon(GetType(), "ErrorNode.ico").ToBitmap();							
			this.GetNodeSite().UpdateIcon();
			MessageBox.Show(WMISys.GetString("WMISE_Exception", exc.Message, exc.StackTrace));
		}	
	}

	/// <summary>
	/// Un-subscribes from event notifications
	/// </summary>
	/// <param name="sender"> </param>
	/// <param name="e"> </param>
	private void OnStopReceiving(object sender, EventArgs e)
	{
		try 
		{
			if (eventWatcher != null)
			{
				eventWatcher.Stop();
			}

			state =  SubscriptionState.Stopped;
			icon = new Icon(GetType(), "Stop.ico").ToBitmap();
			this.GetNodeSite().UpdateIcon();	
		
		}
		catch(Exception exc)
		{
			MessageBox.Show(WMISys.GetString("WMISE_Exception", exc.Message, exc.StackTrace));
		}	

	}
/*
	/// <summary>
	/// Removes existing event entries
	/// </summary>
	/// <param name="sender"> </param>
	/// <param name="e"> </param>
	private void OnPurgeEvents(object sender, EventArgs e)
	{
		try 
		{
			//TODO: change this to purge event entries only for this event
			if (outputPane != null)
			{
				outputPane.Clear();
			}

			eventNodes.Clear();

			GetNodeSite().ResetChildren();
		
		}
		catch(Exception exc)
		{
			MessageBox.Show(WMISys.GetString("WMISE_Exception", exc.Message, exc.StackTrace));
		}	

	}

	*/
	    /// <summary>
        ///      To determine whether this node supports drag and drop.
        /// </summary>
        /// <returns>
        ///      TRUE to indicate ProcessNode supports drag and drop.
        /// </returns>
        public override bool HasDragComponents() {
            return true;	
        }

		public override IComponent[] CreateDragComponents(IDesignerHost designerHost) {

			try
			{
				if (eventWatcher == null)
				{			
					eventWatcher = new ManagementEventWatcher(this.nsName, 
						this.query,
						new EventWatcherOptions());
				}
				
				return new IComponent[] {(IComponent)eventWatcher};
			}
			catch (Exception exc)
			{
				MessageBox.Show(WMISys.GetString("WMISE_Exception", exc.Message, exc.StackTrace));
				return new IComponent[0];
			}			
        }

		/// <summary>
		/// This allows modification of the query string from outside, 
		/// e.g. from the browse component
		/// </summary>
		public String Query
		{
			get
			{
				return query;
			}
			set
			{
				if (eventWatcher != null && this.state == SubscriptionState.Started)
				{
					eventWatcher.Stop();
				}

				query = value;	
				if (browseObject.Query != query)
				{
					browseObject.Query = query;
				}

				label = query;

				OnStartReceiving(this, null);
				
				GetNodeSite().StartRefresh();
			}
		}

	/// <summary>
    ///     The object should write the serialization info.
    /// </summary>
    public virtual void GetObjectData(SerializationInfo si, StreamingContext context) {
		si.AddValue("Server", serverName);
		si.AddValue("NS", nsName);
		si.AddValue("Query", query);
		si.AddValue("ConnectAs", connectAs);
		si.AddValue("Password", password);
		si.AddValue("EventLabel", eventLabel);
    }

	public void GetEvents()
	{
		//TODO: enter subscription, change icon, disable "start" context menu
		if (eventWatcher != null)
		{
			eventWatcher.Stop();
			eventWatcher = null;
		}
		
		eventWatcher = new ManagementEventWatcher(this.nsName, 
				this.query,
				new EventWatcherOptions());
		

		eventWatcher.EventArrived += new EventArrivedEventHandler(this.OnEventReady);
		eventWatcher.Start();
		
	}

	private void OnEventReady(object sender,
							EventArrivedEventArgs args)
	{

		//output to OutputWindow

		_DTE dteObj = (_DTE)GetNodeSite().GetService(typeof(_DTE));		

		if (outputPane == null)
		{
			OutputWindow ouputWindow = (OutputWindow)dteObj.Windows.Item(EnvDTE.Constants.vsWindowKindOutput).Object;			
			outputPane = ouputWindow.OutputWindowPanes.Item("{1BD8A850-02D1-11d1-bee7-00a0c913d1f8}");			
		}
	
		dteObj.ExecuteCommand("View.Output", "");

		outputPane.Activate();
		outputPane.OutputString(FormEventString(args.NewEvent) + "\n");

		//also, add a child node
		WMIInstanceNode eventNode = new WMIInstanceNode((ManagementObject)args.NewEvent, 
											new ManagementClass(args.NewEvent.ClassPath.Path, null), 
											this.connectAs, 
											this.password);

		eventNodes.Add(eventNode);

		GetNodeSite().AddChild(eventNode);
    }

	private string FormEventString(ManagementBaseObject eventObj)
	{
		string text = Label + ": " + eventObj.GetText(TextFormat.Mof);

		text = text.Replace("\r", "");
		return text.Replace("\n", " ");
	}	

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vside\servexpl\eventsnode.cs ===
namespace Microsoft.VSDesigner.WMI {

    using System.Runtime.Serialization;
    using System.Diagnostics;
    using System;
    using System.Windows.Forms;
    using System.Drawing;
    using System.Collections;
    using Microsoft.VSDesigner;
	using Microsoft.VSDesigner.ServerExplorer;
	using System.Resources;
	using System.Reflection;
	using System.Net;
	using System.Management;
	using EnvDTE;

	internal enum EventType
	{
		Extrinsic,
		Instance,
		Class,
		Namespace
	}

    // <doc>
    // <desc>
    //     This represents the wmi classes node under a server node.
    // </desc>
    // </doc>
    [UserContextAttribute("serveritem", "wmievents")]
    internal class EventsNode : Node, ISerializable  {
        //
        // FIELDS
        //

        static Image icon;
        public static readonly Type parentType = typeof(ServerNode);
        private string label = string.Empty;
		
		private NewChildNode newChildNode = null;		

		private string localhost = WmiHelper.DNS2UNC(Dns.GetHostName());
		private string connectAs = null;
		private string password = null;

		private EventQueryDialog eventQueryDlg = null;

		private OutputWindowPane outputPane = null;


		public string LocalHost
		{
			get
			{
				return localhost;
			}
		}
		/// <summary>
		/// This is the user name specified by the user when he connected to the server node above
		/// </summary>
		public string ConnectAs
		{
			get
			{
				if (connectAs == null)
				{
					connectAs = ((ServerNode)GetNodeSite().GetParentNode()).ConnectAsUser;
					if (connectAs == string.Empty)
					{
						connectAs = null;
					}
				}
				return connectAs;
			}
		}

		/// <summary>
		/// This is the password specified by the user when he connected to the server node above
		/// </summary>
		public string Password
			{
			get
			{
				if (password == null)
				{
					password = ((ServerNode)GetNodeSite().GetParentNode()).Password;
					if (password == string.Empty)
					{
						password = null;
					}
				}
				return password;
			}
		}

        //
        // CONSTRUCTORS
        //

        // <doc>
        // <desc>
        //     Main constructor.
        // </desc>
        // </doc>
        public EventsNode() 
		{
	
		}


		/// <summary>
        ///     The object retrieves its serialization info.
        /// </summary>
        public EventsNode(SerializationInfo info, StreamingContext context) 
		{
				
        }

        //
        // PROPERTIES
        //

        // <doc>
        // <desc>
        //     Returns icon for this node.
        // </desc>
        // </doc>
		
        public override Image Icon {
             get {

				if (icon == null)
				{					
					icon = (Image)new Bitmap(GetType(), "Events.bmp");					
				}				
				return icon;

            }
        }


		public override ContextMenuItem[] GetContextMenuItems() {

            return new ContextMenuItem[] {
                new ContextMenuItem(WMISys.GetString("WMISE_AddEventFilterCM"), new EventHandler(OnAddEventFilter)),
				new ContextMenuItem(WMISys.GetString("WMISE_EventQueryPurge"),
								new EventHandler(OnPurgeEvents)),
            };
        }

		/// <summary>
		/// Removes existing event entries
		/// </summary>
		/// <param name="sender"> </param>
		/// <param name="e"> </param>
		private void OnPurgeEvents(object sender, EventArgs e)
		{
			try 
			{
				_DTE dteObj = (_DTE)GetNodeSite().GetService(typeof(_DTE));		

				if (outputPane == null)
				{
					OutputWindow ouputWindow = (OutputWindow)dteObj.Windows.Item(EnvDTE.Constants.vsWindowKindOutput).Object;			
					outputPane = ouputWindow.OutputWindowPanes.Item("{1BD8A850-02D1-11d1-bee7-00a0c913d1f8}");			
				}

				outputPane.Clear();
				
			}
			catch(Exception exc)
			{
				MessageBox.Show(WMISys.GetString("WMISE_Exception", exc.Message, exc.StackTrace));
			}	
		}

		/// <summary>
        ///      The method returns a NewChildNode that, when double clicked, triggers add filter.
        /// </summary>
        /// <returns>
        ///      A NewChildNode, a child node, that supports add filter node.
        /// </returns>
		 public override Node GetNewChildNode() {
            if (newChildNode == null) {
                newChildNode = new NewChildNode();
				newChildNode.Label = WMISys.GetString("WMISE_AddEventFilterLabel"); 
                newChildNode.WhenToSave = WhenToSaveCondition.Always;
				newChildNode.SetIconImage((Image)new Bitmap(GetType(), "EventsNew.bmp"));				

                newChildNode.DoubleClickHandler = new EventHandler(OnAddEventFilter);
            }
            return newChildNode;
        }

        // <doc>
        // <desc>
        //     Returns label constant for this node.
        // </desc>
        // </doc>
        public override string Label {
             get {
                if (label == null || label.Length == 0) {
                    label = WMISys.GetString("WMISE_EventNodeLbl");
                }
                return label;
            }
             set {
            }
        }

        //
        // METHODS
        //

        // <doc>
        // <desc>
        //     Create process nodes under this node.
        // </desc>
        // </doc>
        public override Node[] CreateChildren() {
			//TODO: if connectAs and password are specified and this is a local server,
			//you cannot connect to WMI.  Offer an option to connect as a current user
			//instead. If rejected, make this node an error node.
	
            Node[] children = GetNodeSite().GetChildNodes();

            if (children == null || children.Length == 0) {
                children = new Node[] {
                                GetNewChildNode()                           
                };
            }

            return children;			
        }

        // <doc>
        // <desc>
        //     This node is a singleton.
        // </desc>
        // </doc>
        public override int CompareUnique(Node node) {
            return 0;
        }


		private void OnAddEventFilter(object sender, EventArgs e) {
 			
			try 
			{		
				//get current server name
				ServerNode server = (ServerNode)GetNodeSite().GetParentNode();				
				String serverName = server.GetUNCName();

				if (eventQueryDlg == null)
				{
					eventQueryDlg = new EventQueryDialog(serverName,
						this.connectAs, this.password);
				}

				DialogResult res = eventQueryDlg.ShowDialog();
				if (res == DialogResult.Cancel)
				{
					return;
				}
				
				//Forming a unique query node label:
			
				//get all child names into a SortedList
				Node[] children = GetNodeSite().GetChildNodes();
				SortedList childNames = new SortedList(children.Length);
				foreach (Node childNode in children)
				{
					childNames.Add(childNode.Label.ToLower(), null);
				}
						
				string newLabel = WMISys.GetString("WMISE_QueryNameBase", eventQueryDlg.SelectedClassName);
				string labelSeed = newLabel;
				//keep adding digits at the end to find a unique label
				UInt16 i = 1;
				while (childNames.Contains(newLabel.ToLower()))
				{
					newLabel = labelSeed + " " + i.ToString();
					i++;
				}

				//add the node
				EventQueryNode newChild = new EventQueryNode(newLabel,
															serverName, 
															eventQueryDlg.SelectedNS, 
															eventQueryDlg.QueryString, 
															connectAs, 
															password);
			
				GetNodeSite().AddChild(newChild);			
															
			}
			catch(Exception exc)
			{
				MessageBox.Show(WMISys.GetString("WMISE_Exception", exc.Message, exc.StackTrace));
			}	

        }

		/// <summary>
        ///     The object should write the serialization info.
        /// </summary>
        public virtual void GetObjectData(SerializationInfo si, StreamingContext context) {
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vside\servexpl\executemethoddialog.cs ===
namespace Microsoft.VSDesigner.WMI 
{

using System;
using System.ComponentModel;
//using System.Core;
using System.Windows.Forms;
using System.Runtime.InteropServices;
using System.Drawing;

using System.Management;
using System.Collections;

//using System.Web.UI.WebControls;

internal class ExecuteMethodDialog : Form
{
	private void InitializeComponent ()
	{
	}

	private	ManagementObject mgmtObj = null; 
	private	ManagementObject mgmtClassObj = null;
	private Method meth = null;
	private ManagementBaseObject inParms = null;
	
	private Button executeBtn = new Button();
	private Button cancelBtn = new Button();

	private WMIObjectGrid gridIn = null;
	private WMIObjectGrid gridOut = null;

	private Label ServerName = new Label();
	private Label NamespaceName = new Label();
	private Label ClassName = new Label();

	private Label NoInParams = new Label();

	private Label labelInParms = new Label();
	private Label labelOutParms = new Label();
	private Label labelDescr = new Label();

	private TextBox descr	= new TextBox ();

	public ExecuteMethodDialog(ManagementObject mgmtObjIn,
								Method methIn,
								ManagementObject mgmtClassObjIn)
	{	

		try
		{
			if (mgmtObjIn == null || methIn == null)
			{
				throw (new NullReferenceException());
			}

			mgmtObj = mgmtObjIn;
			mgmtClassObj = mgmtClassObjIn;
			meth = methIn;
		
			this.Text = WMISys.GetString("WMISE_ExecMethodDlg_Title", mgmtObj.Path.ClassName, meth.Name); 

			//this is a temp workaround for URT bug 48695: uncomment this later
			//this.AcceptButton = executeBtn;
			
			this.AutoScaleBaseSize = (Size) new Point(5, 13);
			this.BorderStyle = FormBorderStyle.FixedDialog;
			int dlgWidth = 400;
			int dlgHeight = 500;
			this.ClientSize =  (Size) new Point(dlgWidth, dlgHeight);
			this.ShowInTaskbar = false;
			this.MinimizeBox = false;
			this.MaximizeBox = false;
		
			ServerName.Location = new Point(16, 16);
			ServerName.Text = WMISys.GetString("WMISE_ExecMethodDlg_ServerName", mgmtObj.Path.Server);

			//NamespaceName.Location = new Point();
			//ClassName.Location = new Point();		

			if (meth.InParameters == null)
			{
				NoInParams.Text = WMISys.GetString("WMISE_ExecMethodDlg_NoInputParams"); 
				NoInParams.Location = new Point(16,40);
			}
			else
			{
				inParms = meth.InParameters;

				gridIn = new WMIObjectGrid(inParms, 
							new PropertyFilters(true, false), 
							GridMode.EditMode,
							false, false, false, false, true, true, true);

				labelInParms.Location = new Point(16,40);
				labelInParms.Text = WMISys.GetString("WMISE_ExecMethodDlg_InputParameters"); 

				gridIn.Location = new Point(16,65);
				gridIn.Size = (Size)new Point(367, 140);
				gridIn.Anchor = AnchorStyles.Top; //.All;
				gridIn.PreferredColumnWidth = 109;
				gridIn.PreferredRowHeight = 19;
				gridIn.TabIndex = 1;
			}
	
			labelOutParms.Location = new Point(16,215);
			labelOutParms.Text = WMISys.GetString("WMISE_ExecMethodDlg_OutputParameters"); 

			gridOut = new WMIObjectGrid(meth.OutParameters, 
						new PropertyFilters(true, false), 
						GridMode.ViewMode,
						false, false, false, false, true, true, true);

			gridOut.Location = new Point(16, 240);
			gridOut.Size = (Size)new Point(367, 100);
			gridOut.Anchor = AnchorStyles.Top; //.All;
			gridOut.PreferredColumnWidth = 109;
			gridOut.PreferredRowHeight = 19;
			gridOut.TabIndex = 2;
			
			descr.Text = WmiHelper.GetMethodDescription(meth.Name, mgmtClassObj, "", "");
			descr.Location = new Point (16, 355);
			descr.Size = (Size) new Point (368, 70);
			descr.Multiline = true;
			descr.ReadOnly = true;
			descr.ScrollBars = ScrollBars.Vertical;

			executeBtn.Text = WMISys.GetString("WMISE_ExecMethodDlg_Execute");
			executeBtn.Location = new Point(225, 440);
			executeBtn.Click += new EventHandler(this.OnExecute);
			executeBtn.TabIndex = 3;

			cancelBtn.Text = WMISys.GetString("WMISE_Cancel");
			cancelBtn.Location = new Point(310, 440);
			cancelBtn.DialogResult = System.Windows.Forms.DialogResult.Cancel;
			cancelBtn.TabIndex = 4;
		
			if (meth.InParameters == null)
			{
				this.Controls.Add (cancelBtn); 
				this.Controls.Add (executeBtn);
				this.Controls.Add (ServerName);
				this.Controls.Add (NoInParams);
				this.Controls.Add (labelOutParms);
				this.Controls.Add (gridOut);
				this.Controls.Add (descr);		
			}
			else
			{
				this.Controls.Add (cancelBtn); 
				this.Controls.Add (executeBtn);
				this.Controls.Add (ServerName);
				this.Controls.Add (labelInParms);
				this.Controls.Add (gridIn);
				this.Controls.Add (labelOutParms);
				this.Controls.Add (gridOut);
				this.Controls.Add (descr);				
			}

		}

		catch (Exception exc)
		{
			MessageBox.Show(WMISys.GetString("WMISE_Exception", exc.Message, exc.StackTrace));
			throw (exc);
		}
	}

	private void OnExecute (Object source, EventArgs args)
	{
		try
		{
			if (gridIn != null)
			{
				gridIn.AcceptChanges();	
			}
							
			ManagementBaseObject objOut = mgmtObj.InvokeMethod(meth.Name, inParms, null);
			gridOut.WMIObject = objOut;
		}
		catch (Exception exc)
		{
			MessageBox.Show(WMISys.GetString("WMISE_Exception", exc.Message, exc.StackTrace));
		}
	}	
	
	

}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vside\servexpl\queryconditiondialog.cs ===
namespace Microsoft.VSDesigner.WMI 
{

using System;
using System.ComponentModel;
//using System.Core;
using System.Windows.Forms;
using System.Runtime.InteropServices;
using System.Drawing;
using System.Collections;
using System.Data;
using System.Management;

//using System.Web.UI.WebControls;

internal class QueryConditionDialog : Form
{
	
	private WMIObjectGrid grid = null;

	private TextBox QueryText = new TextBox ();

	private Button okBtn = new Button();
	private Button cancelBtn = new Button();

	private string serverName = string.Empty;

	private string queryString = string.Empty;

	private string connectAs = null;
	private string password = null;	

	private string className = string.Empty;
	private string nsName = string.Empty;

	private Label gridLabel = new Label();
	private CheckBox inheritedBox = new CheckBox();
	private CheckBox systemBox = new CheckBox();
	private Label queryLabel = new Label();

	private void InitializeComponent ()
	{
			this.Text = "Select Query Conditions and Properties";
			this.AcceptButton = okBtn;
			this.AutoScaleBaseSize = new Size(5, 13);
			this.BorderStyle = FormBorderStyle.FixedDialog;
			int dlgWidth = 500;
			int dlgHeight = 420;
			this.ClientSize =  new Size(dlgWidth, dlgHeight);			
			this.ShowInTaskbar = false;
			this.MinimizeBox = false;
			this.MaximizeBox = false;


			inheritedBox.Location = new Point(16, 215);
			inheritedBox.Size = new Size (250, 20);
			inheritedBox.Checked = false;
			inheritedBox.Text = "Show inherited properties";
			inheritedBox.CheckedChanged += new EventHandler (OnInheritedCheckedChanged);

			systemBox.Location = new Point(16, 235);
			systemBox.Size = new Size (250, 20);
			systemBox.Checked = false;
			systemBox.Text = "Show system properties";
			systemBox.CheckedChanged += new EventHandler (OnSystemCheckedChanged);

			queryLabel.Location = new Point(16, 275);
			queryLabel.Text = "WQL Query:";
			queryLabel.Size = new Size(250, 20);

			QueryText.Text = queryString;							
			QueryText.Location = new Point(16, 305);	
			QueryText.Size = (Size)new Point(468, 30);
			QueryText.Multiline = true;
			QueryText.ReadOnly = true;
			QueryText.WordWrap = true;
			//QueryText.ScrollBars = ScrollBars.Vertical;

			okBtn.Text = WMISys.GetString("WMISE_OK");
			okBtn.TabIndex = 5;
			okBtn.Location = new Point(325, 380);
			okBtn.DialogResult = System.Windows.Forms.DialogResult.OK;

			cancelBtn.Text = WMISys.GetString("WMISE_Cancel");
			cancelBtn.TabIndex = 6;
			cancelBtn.Location = new Point(410, 380);
			cancelBtn.DialogResult = System.Windows.Forms.DialogResult.Cancel;		
					
			Controls.Add(gridLabel);
			Controls.Add(inheritedBox);
			Controls.Add(systemBox);
			Controls.Add(queryLabel);
			Controls.Add(QueryText);
			Controls.Add(okBtn);
			Controls.Add(cancelBtn );
											
	}

	public QueryConditionDialog(ManagementObject mgmtObj, string queryIn)
	{
		serverName = mgmtObj.Path.Server;
		className = mgmtObj.Path.ClassName;
		nsName = mgmtObj.Path.NamespacePath;	

		queryString = queryIn;
	
		InitializeComponent();
	
		gridLabel.Location = new Point(16, 16);
		gridLabel.Text = "Set query conditions:";
		gridLabel.Size = new Size (250, 20);

		grid = new WMIObjectGrid(mgmtObj, 
						new PropertyFilters(true, true),
						GridMode.LocalEditMode,
						true, false, false, true, false, true, true);

		grid.Location = new Point(16, 40);
		grid.Size = (Size)new Point(468, 160);
		grid.Anchor = AnchorStyles.Top; //.All;
		grid.PreferredColumnWidth = 90;
		grid.PreferredRowHeight = 19;
		grid.TabIndex = 3;	
		((DataTable)grid.DataSource).RowChanging += new DataRowChangeEventHandler(this.GridRowChanging);

		Controls.Add(grid);
	
	}

	public QueryConditionDialog(ManagementObject mgmtObj, 
								string serverIn,								
								string nsIn, 
								string classNameIn,
								string queryIn)
	{
		serverName = serverIn;
		className = classNameIn;
		nsName = nsIn;	

		queryString = queryIn;
	
		InitializeComponent();
	
		gridLabel.Location = new Point(16, 16);
		gridLabel.Text = "Set query conditions:";
		gridLabel.Size = new Size (250, 20);

		grid = new WMIObjectGrid(mgmtObj, 
			new PropertyFilters(true, true),
			GridMode.LocalEditMode,
			true, false, false, true, false, true, true);

		grid.Location = new Point(16, 40);
		grid.Size = (Size)new Point(468, 160);
		grid.Anchor = AnchorStyles.Top; //.All;
		grid.PreferredColumnWidth = 90;
		grid.PreferredRowHeight = 19;
		grid.TabIndex = 3;	
		((DataTable)grid.DataSource).RowChanging += new DataRowChangeEventHandler(this.GridRowChanging);

		Controls.Add(grid);
	
	}

	public QueryConditionDialog(string serverIn, 
								string user, 
								string pw,
								string NS,
								string clsName,
								string queryIn)
	{	
		try
		{
			if (serverIn == string.Empty ||
				NS ==  string.Empty ||
				clsName == string.Empty)
			{
				throw new ArgumentException();
			}			
	
			serverName = serverIn;
			connectAs = user;
			password = pw;
			className = clsName;
			nsName = NS;
			queryString = queryIn;

			InitializeComponent();
	
			gridLabel.Location = new Point(16, 16);
			gridLabel.Text = "Set query conditions:";
			gridLabel.Size = new Size (250, 20);

			grid = new WMIObjectGrid(WmiHelper.GetClassObject(serverName, nsName, className, connectAs, password), 
							new PropertyFilters(true, true),
							GridMode.LocalEditMode,
							true, false, false, true, false, true, true);

			grid.Location = new Point(16, 40);
			grid.Size = (Size)new Point(468, 160);
			grid.Anchor = AnchorStyles.Top; //.All;
			grid.PreferredColumnWidth = 90;
			grid.PreferredRowHeight = 19;
			grid.TabIndex = 3;	
			((DataTable)grid.DataSource).RowChanging += new DataRowChangeEventHandler(this.GridRowChanging);
	
			Controls.Add(grid);
		}

		catch (Exception exc)
		{
			throw (exc);
		}
	}

	
	public String QueryString
	{
		get 
		{
			return QueryText.Text;
		}
	}

	private String ClassName
	{
		get
		{
			return this.className;
		}
	}

	public String NS
	{
		get
		{
			return this.nsName;
		}

	}		

	/// <summary>
	/// This updates the "where" clause of the query text
	/// </summary>
	/// <param name="sender"> </param>
	/// <param name="e"> </param>
	protected void GridRowChanging(object sender,
								DataRowChangeEventArgs e) 
	{
		try
		{
		
			if (grid == null || grid.DataSource == null)
			{
				return;
			}
		
			//get rid of current "where" clause, if any
			string phrase = QueryString;
			phrase.ToUpper();
			int nWhere = phrase.IndexOf("WHERE");
			if (nWhere >= 0)
			{
				phrase = QueryString.Substring(0, nWhere);
			}

			QueryText.Text = phrase + 
				((WMIObjectPropertyTable)grid.DataSource).WhereClause;
				
		}
		catch (Exception exc)
		{
			MessageBox.Show(WMISys.GetString("WMISE_Exception", exc.Message, exc.StackTrace));
		}
		
	}

	private void OnInheritedCheckedChanged(object sender,
											EventArgs args)
	{
		//grid.CurrentPropertyFilters = new PropertyFilters(!systemBox.Checked,
		//														!inheritedBox.Checked);

		grid.ShowInherited = inheritedBox.Checked;
		
	}

	private void OnSystemCheckedChanged(object sender,
										EventArgs args)
	{
		//grid.CurrentPropertyFilters = new PropertyFilters(!systemBox.Checked,
		//														!inheritedBox.Checked);

		grid.ShowSystem = systemBox.Checked;
	
	}

	

}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vside\servexpl\vsutils.cs ===
namespace Microsoft.VSDesigner.WMI
		{
		
		using System.Runtime.Serialization;
		using System.Diagnostics;
		using System;
		using System.Collections;
		using Microsoft.VSDesigner.Interop;
		using Microsoft.VSDesigner;
		using Microsoft.VSDesigner.ServerExplorer;
		using System.ComponentModel.Design;
		using System.ComponentModel;
   		using EnvDTE; 
		using VSProject = Microsoft.VSDesigner.Interop.VSProject;
		using IVsHierarchy = Microsoft.VSDesigner.Interop.IVsHierarchy;
		using System.Reflection;	
		using System.Management;
		using System.CodeDom;
		using System.CodeDom.Compiler;
		using Microsoft.CSharp;
		using Microsoft.VisualBasic;
		//using Microsoft.VisualStudio.Shell;

		internal class VSUtils
		{

			static public string MapProjectGuidToSuffix (Guid projGuid)
			{
				if (projGuid == new Guid("F184B08F-C81C-45f6-A57F-5ABD9991F28F"))
				{
					return "VB";
				}
				if (projGuid == new Guid("FAE04EC0-301F-11D3-BF4B-00C04F79EFBC"))
				{
					return "CS";
				}
				return string.Empty;											  
										 
			}

			static public CodeLanguage MapProjectGuidToCodeLanguage (Guid projGuid)
			{
				if (projGuid == new Guid("F184B08F-C81C-45f6-A57F-5ABD9991F28F"))
				{
					return CodeLanguage.VB;
				}
				if (projGuid == new Guid("FAE04EC0-301F-11D3-BF4B-00C04F79EFBC"))
				{
					return CodeLanguage.CSharp;
				}
				throw new Exception ("Unsupported Project type");
										 
			}

			static public ICodeGenerator MapProjectGuidToCodeGenerator (Guid projGuid)
			{
				if (projGuid == new Guid("164B10B9-B200-11D0-8C61-00A0C91E29D5"))
					//Note that this is package Guid. Project for VB is {F184B08F-C81C-45f6-A57F-5ABD9991F28F}
				{
					return (new VBCodeProvider()).CreateGenerator();
				}
				if (projGuid == new Guid("FAE04EC0-301F-11D3-BF4B-00C04F79EFBC"))
				{
					return (new CSharpCodeProvider()).CreateGenerator();
				}
				return null;											  
										 
			}			
		
		static public Project[] GetProjects(INodeSite site) 
		{
			_DTE dteObj = (_DTE)site.GetService(typeof(_DTE));
			if (dteObj == null)
			{
				throw new Exception("Could not get DTE");
			}

			Projects projs = dteObj.Solution.Projects;		

			Project[] projectList = new Project[projs.Count];
			int i = 0;
			foreach (Project proj in projs)
			{
				projectList[i] = proj;
				i++;
			}
			return projectList;			

			/*
			IVsSolution solution = (IVsSolution)site.GetService(typeof(IVsSolution));
			if (solution == null) 
			{
				//if (Switches.ServerExplorer.TraceVerbose) Debug.WriteLine("**** ERROR: DiscoveryItemNode::GetProjects() - GetService(IVsSolution) returns null.");
				return null;
			}
            
			ArrayList list = new ArrayList();
			Guid guid = Guid.Empty;
			IEnumHierarchies heirEnum = solution.GetProjectEnum(1, ref guid);

			Microsoft.VSDesigner.Interop.IVsHierarchy[] hier = new Microsoft.VSDesigner.Interop.IVsHierarchy[1];
			int[] ret = new int[1];
			while (true) 
			{
				heirEnum.Next(1, hier, ret);
				if (ret[0] == 0) 
					break;

				// Get project item from hierarchy by getting VSHPROPID_EXTOBJ property.
				object itemObject;
				hier[0].GetProperty((int)VsItemIds.Root, __VSHPROPID.VSHPROPID_ExtObject, out itemObject);
                
				// Debug.Assert(itemObject != null, "DiscoveryItemNode::GetProjects() - VsHierarchy.GetProperty(ExtObject) return NULL.");
				if (itemObject != null && itemObject is Project) 
				{
					Project projectObject = (Project) itemObject;
					if (projectObject.Object != null) 
					{
						if (projectObject.Object is VSProject) 
						{
							list.Add(projectObject);
						}
					}
				}
			}

			Project[] projectList = new Project[list.Count];
			// UNDONE - npchow - CopyTo() doesn't work on array of COM objects.
			// list.CopyTo(projectList, 0);
			for (int i = 0; i < list.Count; i++) 
			{
				//if (Switches.ServerExplorer.TraceVerbose) Debug.WriteLine("DiscoveryItemNode::GetProjects() - Before Convert itemObject[0] to Project.");
				projectList[i] = (Project) list[i];
				//if (Switches.ServerExplorer.TraceVerbose) Debug.WriteLine("DiscoveryItemNode::GetProjects() - After Convert itemObject[0] to Project.");
			}
			
			return projectList;
			*/
		}

		
		static public  void SetGenerator(ProjectItem fileItem, string generatorName) 
		{
			if (fileItem != null) 
			{
				Properties fileProperties = fileItem.Properties;
				Debug.Assert(fileProperties != null, "SetCodeGeneratorProperty() - ProjectItem properties is NULL.");

				if (fileProperties != null) 
				{
					EnvDTE.Property generatorProperty = fileProperties.Item("CustomTool");
					Debug.Assert(generatorProperty != null, "SetCodeGeneratorProperty() - ProjectItem's Generator property is NULL.");

					if (generatorProperty != null) 
					{
						try 
						{
							generatorProperty.Value = generatorName;
						}
						catch (Exception e) 
						{
							throw e;
						}
					}
				}
			}
		}
		}
		}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vside\servexpl\wmiassocgroupnode.cs ===
namespace Microsoft.VSDesigner.WMI {
    using System.Runtime.Serialization;
    using System.Diagnostics;
    using System;
    using System.Windows.Forms;
    using System.Drawing;
    using System.Collections;
    using Microsoft.VSDesigner;
	using Microsoft.VSDesigner.ServerExplorer;
	using System.Reflection;

	using System.Management;
	using System.Resources;

    // <doc>
    // <desc>
    //     This represents the wmi classes node under a server node.
    // </desc>
    // </doc>
    [UserContextAttribute("serveritem", "wmiassocclass")]
    internal class WMIAssocGroupNode : Microsoft.VSDesigner.ServerExplorer.Node /*, ISerializable*/  {
        //
        // FIELDS
        //
        private Image icon = null;
        public static readonly Type parentType = typeof(WMIInstanceNode);
        private string label = string.Empty;

		
		AssocGroupComponent theComp = null;

		private string connectAs = null;
		private string password = null;

        //
        // CONSTRUCTORS
        //
        // <doc>
        // <desc>
        //     Main constructor.
		//     Parameters: 
		//	string server (in, machine name)
		//	string pathIn (in, WMI path without the server name , e.g. "root\default:MyClass")
        // </desc>
        // </doc>
        public WMIAssocGroupNode (AssocGroupComponent compIn,
									string user, string pw) 
		{
			try
			{
				
				theComp = compIn;
				connectAs = user;
				password = pw;
								
			}
			catch (Exception exc)
			{
				MessageBox.Show(WMISys.GetString("WMISE_Exception", exc.Message, exc.StackTrace));
				throw (exc);
			}
		}



        //
        // PROPERTIES
        //

        // <doc>
        // <desc>
        //     Returns icon for this node.
        // </desc>
        // </doc>
		
        public override Image Icon {
            get {
				
				if (icon == null)
				{	
			
					icon = WmiHelper.GetClassIconFromResource(theComp.targetNS + ":" + theComp.targetClass, 
															true, GetType());
					if (icon == null)
					{
						icon = WmiHelper.defaultClassIcon;
					}
				}			
	            return icon;
            }
        }

        // <doc>
        // <desc>
        //     Returns class name as a label for this node.  
        // </desc>
        // </doc>
        public override string Label {
            get {
		
				if (label == null || label.Length == 0) 
				{
					label = theComp.targetClass + " (" + theComp.targetRole + ")";		
				}
				return label;		
            }
             set {
            }
        }

        //
        // METHODS
        //

        // <doc>
        // <desc>
        //     Create associator instance nodes under this grouping.
        // </desc>
        // </doc>
        public override Node[] CreateChildren() {

			GetRelatedOptions opts = new GetRelatedOptions(null, //context
															TimeSpan.MaxValue, //timeout
															50, //block size
															false, //rewindable
															true, //return immediately
															true,	//use amended
															true, //locatable
															false,//prototype only
															false, //direct read
															theComp.targetClass, //related class
															theComp.associationClass, //RELATIONSHIP CLASS
															string.Empty, //relationship qualifier
															string.Empty, //related qualifier
															theComp.targetRole, //related role
															string.Empty, //this role
															false //classes only
														);
			ManagementObjectCollection assocInstances = theComp.sourceInst.GetRelated(opts);									
	
			if (assocInstances == null)
			{
				return null;
			}	

			ArrayList arNodes = new ArrayList(50);			

			ManagementObjectCollection.ManagementObjectEnumerator enumAssocInst = assocInstances.GetEnumerator();
			
			while(enumAssocInst.MoveNext())
			{
				ManagementObject curObj = (ManagementObject)enumAssocInst.Current;
                arNodes.Add( new WMIInstanceNode(curObj, 
					WmiHelper.GetClassObject(curObj, connectAs, password), 
					connectAs, password));			
			}	

			Node[] childNodes = new Node[arNodes.Count];

			arNodes.CopyTo(childNodes);

			return childNodes;
			
        }

       
		// <doc>
        // <desc>
        //     This node is not a singleton 
        // </desc>
        // </doc>
        public override int CompareUnique(Node node) 
		{           
			if (theComp == ((WMIAssocGroupNode)node).theComp)
			{
				return 0;
			}
			return Label.CompareTo(node.Label);
        }

		
	
	public override Object GetBrowseComponent() {	
	
		return theComp;
	}	

		/*
	/// <summary>
    ///     The object should write the serialization info.
    /// </summary>
    public virtual void GetObjectData(SerializationInfo si, StreamingContext context) {
				
		ManagementPath sourcePath = theComp.sourceInst.Path;

		si.AddValue("sourceServer", sourcePath.Server);
		si.AddValue("sourceNS", sourcePath.NamespacePath);
		si.AddValue("sourcePath", sourcePath.Path);

		si.AddValue("associationPath", theComp.associationPath);
		si.AddValue("targetClass", theComp.targetClass);
		si.AddValue("targetRole", theComp.targetRole);		
		
    }*/

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vside\servexpl\wmiarrayconverter.cs ===
//------------------------------------------------------------------------------
/// <copyright from='1997' to='2001' company='Microsoft Corporation'>           
///    Copyright (c) Microsoft Corporation. All Rights Reserved.                
///    Information Contained Herein is Proprietary and Confidential.            
/// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace Microsoft.VSDesigner.WMI  {
    using System.Runtime.Serialization.Formatters;
    using System.Runtime.Remoting;
    using System.Runtime.InteropServices;
    //using System.Core;
	using System;
    using System.Collections;
    using System.Diagnostics;
	using System.ComponentModel;
	using System.Management;
	using System.Windows.Forms;
	using System.Globalization;

    /// <classonly/>
    /// <summary>
    ///    <para>
    ///       Provides a type converter to convert
    ///       Array objects to and from various other representations.
    ///    </para>
    /// </summary>
    [System.Security.SuppressUnmanagedCodeSecurityAttribute()]
    internal class WMIArrayConverter : CollectionConverter {

		private ManagementObject mgmtObj = null;
		private string propName = null;

		public WMIArrayConverter( ManagementObject mgmtObjIn,									
								String propNameIn)
		{

			if (mgmtObjIn == null || propName == string.Empty)
			{
				throw new ArgumentNullException();
			}
			mgmtObj = mgmtObjIn;
			propName = propNameIn;
			
		}

		
        /// <summary>
        ///    <para>
        ///       Converts the given (value) object to another type. The most common types to convert
        ///       are to and from a string object. The default implementation will make a call
        ///       to ToString on the object if the object is valid and if the destination
        ///       type is string. If this cannot convert to the desitnation type, this will
        ///       throw a NotSupportedException.
        ///    </para>
        /// </summary>
        /// <param name='context'>
        ///    A formatter context. This object can be used to extract additional information about the environment this converter is being invoked from. This may be null, so you should always check. Also, properties on the context object may also return null.
        /// </param>
        /// <param name='value'>
        ///    The object to convert.
        /// </param>
        /// <param name='destinationType'>
        ///    The type to convert the object to.
        /// </param>
        /// <param name='arguments'>
        ///    An optional array of arguments to use when doing the conversion. The number and content of these arguments is dependent on the implementer of the value formatter.
        /// </param>
        /// <returns>
        ///    <para>
        ///       The converted object.
        ///    </para>
        /// </returns>
        public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType) {
            if (destinationType == null) {
                throw new ArgumentNullException("destinationType");
            }

            if (destinationType == typeof(string)) {
                if (value is Array) {
                    //return Sys.GetString("ArrayConverterText", value.GetType().Name);
					return null;					
                }
            }

            return base.ConvertTo(context, culture, value, destinationType);
        }

        /// <summary>
        ///      Retrieves the set of properties for this type.  By default, a type has
        ///      does not return any properties.  An easy implementation of this method
        ///      can just call TypeDescriptor.GetProperties for the correct data type.
        /// </summary>
        /// <param name='context'>
        ///      A type descriptor through which additional context may be provided.
        /// </param>
        /// <param name='value'>
        ///      The value of the object to get the properties for.
        /// </param>
        /// <returns>
        ///      The set of properties that should be exposed for this data type.  If no
        ///      properties should be exposed, thsi may return null.  The default
        ///      implementation always returns null.
        /// </returns>
        public override PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes) {



            PropertyDescriptor[] props = null;

            if (value.GetType().IsArray || value.GetType() == typeof(System.Array)) {
                Array valueArray = (Array)value;
                int length = valueArray.GetLength(0);
                props = new PropertyDescriptor[length];
                
                Type arrayType = value.GetType();
                Type elementType = arrayType.GetElementType();
                
                for (int i = 0; i < length; i++) {
                    props[i] = new ArrayPropertyDescriptor(arrayType, elementType, i);
                }
            }

            return new PropertyDescriptorCollection(props);
        }

        /// <summary>
        ///      Determines if this object supports properties.  
        /// </summary>
        /// <param name='context'>
        ///      A type descriptor through which additional context may be provided.
        /// </param>
        /// <returns>
        ///      Returns true if GetProperties should be called to find
        ///      the properties of this object.
        /// </returns>
        public override bool GetPropertiesSupported(ITypeDescriptorContext context) {
            return true;
        }

        private class ArrayPropertyDescriptor : SimplePropertyDescriptor {
            private int index;
			Type elementType = typeof(System.DBNull);

            public ArrayPropertyDescriptor(Type arrayType, Type elementTypeIn, int index) : base(arrayType, "[" + index + "]", elementTypeIn, null) {
                this.index = index;
				elementType = elementTypeIn;
            }

			public override TypeConverter Converter 
			{
				get 
				{
						
					if (elementType ==typeof(UInt16))
					{
						return new UInt16Converter();
					}
					
					if (elementType ==typeof(UInt32))
					{
						return new UInt32Converter();
					}

					if (elementType ==typeof(UInt64))
					{
						return new UInt64Converter();
					}

					if (elementType ==typeof(SByte))
					{
						return new SByteConverter();
					}
					
					return base.Converter;			
				}
			}
			    
            public override object GetValue(object instance) {


                if (instance is Array) {
                    Array array = (Array)instance;
                    if (array.GetLength(0) > index) {
                        return array.GetValue(index);
                    }
                }
                
                return null;
            }
            
            public override void SetValue(object instance, object value) {


                if (instance is Array) {
                    Array array = (Array)instance;
                    if (array.GetLength(0) > index) {
                        array.SetValue(value, index);
                    }
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vside\servexpl\sbyteconverter.cs ===
//------------------------------------------------------------------------------
/// <copyright from='1997' to='2001' company='Microsoft Corporation'>           
///    Copyright (c) Microsoft Corporation. All Rights Reserved.                
///    Information Contained Herein is Proprietary and Confidential.            
/// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace Microsoft.VSDesigner.WMI {
    using System.Runtime.Serialization.Formatters;
    using System.Globalization;
    using System.Runtime.Remoting;
    using System.Runtime.InteropServices;
    using System.ComponentModel;
	using System;

    using System.Diagnostics;


    /// <classonly/>
    /// <summary>
    ///    <para>
    ///       Provides a type converter to convert
    ///       byte objects to and from various other representations.
    ///    </para>
    /// </summary>
    [System.Security.SuppressUnmanagedCodeSecurityAttribute()]
    internal class SByteConverter : TypeConverter {

        /// <summary>
        ///      Determines if this converter can convert an object in the given source
        ///      type to the native type of the converter.
        /// </summary>
        /// <param name='context'>
        ///      A formatter context.  This object can be used to extract additional information
        ///      about the environment this converter is being invoked from.  This may be null,
        ///      so you should always check.  Also, properties on the context object may also
        ///      return null.
        /// </param>
        /// <param name='sourceType'>
        ///      The type you wish to convert from.
        /// </param>
        /// <returns>
        ///      True if this object can perform the conversion.
        /// </returns>
        /// <seealso cref='System.ComponentModel.TypeConverter' />
        public override bool CanConvertFrom(ITypeDescriptorContext context, System.Type sourceType) {
            if (sourceType == typeof(string)) {
                return true;
            }
            return base.CanConvertFrom(context, sourceType);
        }

        /// <summary>
        ///      Converts the given object to the converter's native type.
        /// </summary>
        /// <param name='context'>
        ///      A formatter context.  This object can be used to extract additional information
        ///      about the environment this converter is being invoked from.  This may be null,
        ///      so you should always check.  Also, properties on the context object may also
        ///      return null.
        /// </param>
        /// <param name='value'>
        ///      The object to convert.
        /// </param>
        /// <param name='arguments'>
        ///      An optional array of arguments to use when doing the conversion.  The arguments here
        ///      match the type and order of the Parse method on SByte.
        /// </param>
        /// <returns>
        ///      The converted object.  This will throw an excetpion if the converson
        ///      could not be performed.
        /// </returns>
        /// <seealso cref='System.ComponentModel.TypeConverter' />
        public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value) {
            if (value is string) {
                string text = ((string)value).Trim();
                
				NumberFormatInfo formatInfo = culture.NumberFormat;
                return SByte.Parse(text, NumberStyles.Any, formatInfo);
                 
            }
            return base.ConvertFrom(context, culture, value);
        }
        
        /// <summary>
        ///      Converts the given object to another type.  The most common types to convert
        ///      are to and from a string object.  The default implementation will make a call
        ///      to ToString on the object if the object is valid and if the destination
        ///      type is string.  If this cannot convert to the desitnation type, this will
        ///      throw a NotSupportedException.
        /// </summary>
        /// <param name='context'>
        ///      A formatter context.  This object can be used to extract additional information
        ///      about the environment this converter is being invoked from.  This may be null,
        ///      so you should always check.  Also, properties on the context object may also
        ///      return null.
        /// </param>
        /// <param name='value'>
        ///      The object to convert.
        /// </param>
        /// <param name='destinationType'>
        ///      The type to convert the object to.
        /// </param>
        /// <param name='arguments'>
        ///      An optional array of arguments to use when doing the conversion.  The arguments here
        ///      match the type and order of the Format method on SByte.
        /// </param>
        /// <returns>
        ///      The converted object.
        /// </returns>
        public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, System.Type destinationType ) {
            if (destinationType == null) {
                throw new ArgumentNullException("destinationType");
            }

            if (destinationType == typeof(string) && value is SByte) {                
                return value.ToString();                
            }
            
            return base.ConvertTo(context, culture, value, destinationType);
        }
    }
}



/*
//------------------------------------------------------------------------------
/// <copyright from='1997' to='2001' company='Microsoft Corporation'>           
///    Copyright (c) Microsoft Corporation. All Rights Reserved.                
///    Information Contained Herein is Proprietary and Confidential.            
/// </copyright>                                                                
//------------------------------------------------------------------------------


namespace Microsoft.VSDesigner.WMI {
    using System.Runtime.Serialization.Formatters;
    using System.Globalization;
    using System.Runtime.Remoting;
    using System.Runtime.InteropServices;
    using System.ComponentModel;
	using System;
	using System.Windows.Forms;

    using System.Diagnostics;

    //using System.Core;

    /// <classonly/>
    /// <summary>
    ///    <para>
    ///       Provides a type converter to convert
    ///       SByte objects to and from various other representations.
    ///    </para>
    /// </summary>
    [System.Security.SuppressUnmanagedCodeSecurityAttribute()]
    internal class SByteConverter : TypeConverter {

        /// <summary>
        ///      Determines if this converter can convert an object in the given source
        ///      type to the native type of the converter.
        /// </summary>
        /// <param name='context'>
        ///      A formatter context.  This object can be used to extract additional information
        ///      about the environment this converter is being invoked from.  This may be null,
        ///      so you should always check.  Also, properties on the context object may also
        ///      return null.
        /// </param>
        /// <param name='sourceType'>
        ///      The type you wish to convert from.
        /// </param>
        /// <returns>
        ///      True if this object can perform the conversion.
        /// </returns>
        /// <seealso cref='System.ComponentModel.TypeConverter' />
        public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType) {
            if (sourceType == typeof(string)) {
                return true;
            }
            return base.CanConvertFrom(context, sourceType);
        }

        /// <summary>
        ///      Converts the given object to the converter's native type.
        /// </summary>
        /// <param name='context'>
        ///      A formatter context.  This object can be used to extract additional information
        ///      about the environment this converter is being invoked from.  This may be null,
        ///      so you should always check.  Also, properties on the context object may also
        ///      return null.
        /// </param>
        /// <param name='value'>
        ///      The object to convert.
        /// </param>
        /// <param name='arguments'>
        ///      An optional array of arguments to use when doing the conversion.  The arguments here
        ///      match the type and order of the Parse method on SByte.
        /// </param>
        /// <returns>
        ///      The converted object.  This will throw an excetpion if the converson
        ///      could not be performed.
        /// </returns>
        /// <seealso cref='System.ComponentModel.TypeConverter' />
        public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value) {
            if (value is string) {
                string text = ((string)value).Trim();

                try {
                    if (arguments == null || arguments.Length == 0) {
                        return SByte.Parse(text);
                    }
                    else if (arguments.Length == 1) {
                        // This argument can either be the beginning to the parse parameters, or it may
                        // be a CultureInfo.
                        //
                        if (arguments[0] is CultureInfo) {
                            CultureInfo ci = (CultureInfo)arguments[0];
                            NumberFormatInfo formatInfo = (NumberFormatInfo)ci.GetServiceObject(typeof(NumberFormatInfo));
                            return SByte.Parse(text, NumberStyles.Any, formatInfo);
                        }
                        else {
                            return SByte.Parse(text, (NumberStyles)arguments[0]);
                        }
                    }
                    else {
                        return SByte.Parse(text, (NumberStyles)arguments[0], (NumberFormatInfo)arguments[1]);
                    }
                }
                catch (Exception e) {
					throw e;
                }
            }
            return base.ConvertFrom(context, value, arguments);
        }
        
        /// <summary>
        ///      Converts the given object to another type.  The most common types to convert
        ///      are to and from a string object.  The default implementation will make a call
        ///      to ToString on the object if the object is valid and if the destination
        ///      type is string.  If this cannot convert to the desitnation type, this will
        ///      throw a NotSupportedException.
        /// </summary>
        /// <param name='context'>
        ///      A formatter context.  This object can be used to extract additional information
        ///      about the environment this converter is being invoked from.  This may be null,
        ///      so you should always check.  Also, properties on the context object may also
        ///      return null.
        /// </param>
        /// <param name='value'>
        ///      The object to convert.
        /// </param>
        /// <param name='destinationType'>
        ///      The type to convert the object to.
        /// </param>
        /// <param name='arguments'>
        ///      An optional array of arguments to use when doing the conversion.  The arguments here
        ///      match the type and order of the Format method on SByte.
        /// </param>
        /// <returns>
        ///      The converted object.
        /// </returns>
        public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType) {
            if (destinationType == null) {
                throw new ArgumentNullException("destinationType");
            }

            if (destinationType == typeof(string) && value is SByte) {
                
                if (arguments == null || arguments.Length == 0) {
                    return value.ToString();
                }
                else if (arguments.Length == 1) {
                    return SByte.Format((SByte)value, (string)arguments[0]);
                }
                else {
                    return SByte.Format((SByte)value, (string)arguments[0], (NumberFormatInfo)arguments[1]);
                }
            }
            
            return base.ConvertTo(context, value, destinationType, arguments);
        }
    }
}

*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vside\servexpl\wmiclassesnode.cs ===
namespace Microsoft.VSDesigner.WMI 

{   
	
	using System.Runtime.Serialization;
    using System.Diagnostics;
    using System;
    using System.Windows.Forms;
    using System.Drawing;
    using System.Collections;
    using Microsoft.VSDesigner;
	using Microsoft.VSDesigner.ServerExplorer;
	using System.Resources;
	using System.IO;
	using System.Reflection;
	using System.Threading;
	using System.Net;


    // <doc>
    // <desc>
    //     This represents the wmi classes node under a server node.
    // </desc>
    // </doc>
    [UserContextAttribute("serveritem", "wmiclasses")]
    internal class WMIClassesNode : Node, ISerializable  {
        //
        // FIELDS
        //

        static Image icon;
        public static readonly Type parentType = typeof(ServerNode);
        private string label = string.Empty;
        private NewChildNode newChildNode = null;


		private string localhost = WmiHelper.DNS2UNC(Dns.GetHostName());
		private string connectAs = null;
		private string password = null;

		public string LocalHost
		{
			get
			{
				return localhost;
			}
		}

		/// <summary>
		/// This is the user name specified by the user when he connected to the server node above
		/// </summary>
		public string ConnectAs
		{
			get
			{
				if (connectAs == null)
				{
					connectAs = ((ServerNode)GetNodeSite().GetParentNode()).ConnectAsUser;
					if (connectAs == string.Empty)
					{
						connectAs = null;
					}
				}
				return connectAs;
			}
		}

		/// <summary>
		/// This is the password specified by the user when he connected to the server node above
		/// </summary>
		public string Password
		{
			get
			{
				if (password == null)
				{
					password = ((ServerNode)GetNodeSite().GetParentNode()).Password;
					if (password == string.Empty)
					{
						password = null;
					}
				}
				return password;
			}
		}

		private static string[] DefaultClasses  = new string[]
		{			
			"Win32_Process",
			"Win32_Thread",
			"Win32_Share",
			"Win32_Service",
			"Win32_Printer",
			"Win32_LogicalDisk",
			"Win32_ComputerSystem",
			"Win32_OperatingSystem",
			"Win32_NetworkAdapter",
			"Win32_Desktop",
			"Win32_NTEventLogFile",
			"Win32_NetworkConnection",
			"Win32_Product",
			"Win32_Processor",
			"Win32_SystemAccount",
		};

		private const string DefaultNS = "root\\CIMV2";

		private Object selectClassDlg;

        //
        // CONSTRUCTORS
        //

        // <doc>
        // <desc>
        //     Main constructor.
        // </desc>
        // </doc>
        public WMIClassesNode() { 
			try
			{				
				
							
			}
			catch(Exception exc)
			{
				MessageBox.Show(WMISys.GetString("WMISE_Exception", exc.Message, exc.StackTrace));
				throw (exc);
			}
		}

		/// <summary>
        ///     The object retrieves its serialization info.
        /// </summary>
        public WMIClassesNode(SerializationInfo info, StreamingContext context) {

			try
			{
				
				
			}
			catch(Exception exc)
			{
				MessageBox.Show(WMISys.GetString("WMISE_Exception", exc.Message, exc.StackTrace));
				throw (exc);
			}

        }

        //
        // PROPERTIES
        //

        // <doc>
        // <desc>
        //     Returns icon for this node.
        // </desc>
        // </doc>
		
        public override Image Icon {
            
			 get {
				if (icon == null)
				{			
				   icon = (Image)new Bitmap(GetType(), "ObjectViewer.bmp");					
				}							
				
				return icon;
			}
        }

		public override ContextMenuItem[] GetContextMenuItems() {
            return new ContextMenuItem[] {
                new ContextMenuItem(WMISys.GetString("WMISE_ClassesNode_AddClass"), new EventHandler(OnSelectWMIClass)),
            };
        }

		/// <summary>
        ///      The method returns a NewChildNode that, when double clicked, triggers add filter.
        /// </summary>
        /// <returns>
        ///      A NewChildNode, a child node, that supports add server node.
        /// </returns>
		 public override Node GetNewChildNode() {
            if (newChildNode == null) {
                newChildNode = new NewChildNode();
				newChildNode.Label = WMISys.GetString("WMISE_ClassesNode_AddClassLbl");
                newChildNode.WhenToSave = WhenToSaveCondition.Always;
				newChildNode.SetIconImage((Image)new Bitmap(GetType(), "ObjectViewerNew.bmp"));			
                newChildNode.DoubleClickHandler = new EventHandler(OnSelectWMIClass);
            }
            return newChildNode;
        }

        // <doc>
        // <desc>
        //     Returns label constant for this node.
        // </desc>
        // </doc>
        public override string Label {
             get {
                if (label == null || label.Length == 0) {
                    label = WMISys.GetString("WMISE_ClassesNodeLbl");
				
                }
                return label;
            }
            set {
            }
        }

        //
        // METHODS
        //

        // <doc>
        // <desc>
        //     Create <Add Classes> node under this node.
        // </desc>
        // </doc>
        public override Node[] CreateChildren() {
	
			//TODO: if connectAs and password are specified and this is a local server,
			//you cannot connect to WMI.  Offer an option to connect as a current user
			//instead. If rejected, make this node an error node.
			
			Node[] children = GetNodeSite().GetChildNodes();

            if (children == null || children.Length == 0) {
				
				children = new Node[DefaultClasses.Length + 1];

				int i, k;
				for (i = 0, k = 0; i < DefaultClasses.Length; i++)
				{
					try
					{
						children[k] = new WMIClassNode(WmiHelper.MakeClassPath(GetNodeSite().GetMachineName(),
														DefaultNS, DefaultClasses[i]),
														this.ConnectAs, this.Password);
						
						
					}
					catch (Exception)
					{
						//children[k] = new ErrorNode(new ErrorComponent(exc));
						continue;	//k wouldn't get increased
					}

					k++;
				}
				children[k] = GetNewChildNode();
              
				Node[] children2 = new Node[k + 1];
				Array.Copy(children, children2, k + 1);
				return children2;
            }
            return children;	
        }

    // <doc>
    // <desc>
    //     This node is a singleton.
    // </desc>
    // </doc>
    public override int CompareUnique(Node node) {
        return 0;
    }

	private void OnSelectWMIClass(object sender, EventArgs e) {
 			
			try 
			{
				
				ArrayList strs = new ArrayList(50);					

				//First, enumerate existing classes to initialize dialog
				Node[] children = GetNodeSite().GetChildNodes();
				
				for (int i = 0; i < children.Length; i++)
				{
					if (children[i] is WMIClassNode)
					{						
						strs.Add (((WMIClassNode)children[i]).pathNoServer);					
					}
				}
				
				//get current server name				
				ServerNode server = (ServerNode)GetNodeSite().GetParentNode();				
				String serverName = server.GetUNCName();				
								
				if (selectClassDlg == null)
				{
				
					selectClassDlg = new SelectWMIClassTreeDialog(						
									serverName,
									this.ConnectAs,
									this.Password,
									ClassFilters.ConcreteData,
									//SchemaFilters.NoEvent|SchemaFilters.NoAbstract|	SchemaFilters.NoSystem |SchemaFilters.NoAssoc,															
									strs);					

				}
				
				else
				{
					//updated selected classes list in the dialog:
					//to account for the case wheen some class node 
					//was deleted
					UpdateSelectClassDialog();

					((SelectWMIClassTreeDialog)selectClassDlg).CleanUpPreviousSelections();
				}
				
				
				DialogResult ret = ((SelectWMIClassTreeDialog)selectClassDlg).ShowDialog();
			
				if (ret != DialogResult.OK) 
				{
				    return;
				}
		
				//inspect strs and add or delete child nodes as necessary
				UpdateChildren (((SelectWMIClassTreeDialog)selectClassDlg).SelectedClasses);
				

			}
			catch(Exception exc)
			{
				MessageBox.Show(WMISys.GetString("WMISE_Exception", exc.Message, exc.StackTrace));
			}	

        }

	private void UpdateChildren (ArrayList stDialog)
	{			
		try
		{
			Node[] children = GetNodeSite().GetChildNodes();
			ArrayList stChildren = new ArrayList();

			//First pass: put existing children into string table: strChildren
			//also, remove children that have been deleted from the list in the dialog
			for (int i = 0; i < children.Length; i++)
			{
				if (children[i] is WMIClassNode)
				{	
					WMIClassNode wmiClass = (WMIClassNode)children[i];
					if (!stDialog.Contains(wmiClass.pathNoServer))
					{
						//remove child						
						children[i].GetNodeSite().Remove();
					}
					else
					{
						stChildren.Add(wmiClass.pathNoServer);
					}	
				}
			}
			String[] arDialog = new String[stDialog.Count];
			stDialog.CopyTo(arDialog, 0);

			//Second pass, see if we need to add any children
			for (int i = 0; i < arDialog.Length; i++)
			{
				if (!stChildren.Contains(arDialog[i]))
				{															
					//add the node
					WMIClassNode newChild = new WMIClassNode("\\\\" + GetNodeSite().GetMachineName() + "\\" + arDialog[i],
															this.ConnectAs, this.Password);
					GetNodeSite().AddChild(newChild);
				}						
			}
		}

		catch (Exception exc)
		{
			MessageBox.Show(WMISys.GetString("WMISE_Exception", exc.Message, exc.StackTrace));
		}	
	}

	/// <summary>
	/// This will update selectClassDlg.selectedClasses with
	///  classes currently selected. This is necessary to make sure
	/// nodes deleted in SE do not appear as selected in the dialog.
	/// </summary>	
	private void UpdateSelectClassDialog ()
	{			
		try
		{
			if (selectClassDlg == null)
			{
				return;
			}

			Node[] children = GetNodeSite().GetChildNodes();

			ArrayList stChildren = new ArrayList(50);
 
			for (int i = 0; i < children.Length; i++)
			{
				if (children[i] is WMIClassNode)
				{	
					WMIClassNode wmiClass = (WMIClassNode)children[i];
					stChildren.Add(wmiClass.pathNoServer);							
				}
			}
			((SelectWMIClassTreeDialog)selectClassDlg).SelectedClasses = stChildren;
		}

		catch (Exception exc)
		{
			MessageBox.Show(WMISys.GetString("WMISE_Exception", exc.Message, exc.StackTrace));
		}	
	}
	


	/// <summary>
        ///     The object should write the serialization info.
        /// </summary>
        public virtual void GetObjectData(SerializationInfo si, StreamingContext context) {
        }


    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vside\servexpl\selectwmiclasstreedialog.cs ===
namespace Microsoft.VSDesigner.WMI {

		using System;
		using System.ComponentModel;
		//using System.Core;
		using System.Windows.Forms;
		using System.Runtime.InteropServices;
		using System.Drawing;
		using System.Collections;
		using System.Resources;
		using System.Reflection;
		using System.Management;
		using System.Threading;
		using System.Net;


		/// <summary>
		/// Filters define which classes will be displayed by the class selector UI
		/// </summary>
		internal enum SchemaFilters
		{
			ShowAll    = 0,
			NoAbstract = 0x1,
			NoSystem   = 0x10,
			NoEvent    = 0x100,
			NoData     = 0x1000,
			NoAssoc    = 0x10000
		}

		

    	internal class SelectWMIClassTreeDialog : Form
		{

			private void InitializeComponent ()
			{
			}
			
			private enum ClassListControls 
			{
				ClassTreeView = 0,
				SelectedClassList = 1				
			}
			
			private ClassFilters currentFilters = ClassFilters.ConcreteData;

			private string machineName = string.Empty;
			private string connectAs = null;
			private string password = null;

			private Button cancelBtn = new Button();
			private Button okBtn = new Button();
			private WMIClassTreeView classList = null;
			private ListBox selectedClassList = new ListBox();

			private Button btnAdd = new Button();
			private Button btnRemove = new Button();

			private CheckBox chkShowAbstract = new CheckBox();
			private CheckBox chkShowSystem	 = new CheckBox();
			private CheckBox chkShowEvent	 = new CheckBox();
			private CheckBox chkShowData	 = new CheckBox();

			private Label labelSearch	= new Label();
			private TextBox descr	= new TextBox ();
			private Label labelSelected = new Label();
			private TextBox editSearch	= new TextBox();
			private Button btnGo = new Button();

			private TreeNode nodeLastFindNS = null;
			private String   strLastFindClass = "";
			
			private Color defaultForeColor = Color.Black;
			private Color defaultBackColor = Color.White;

			private ImageList imgList = new ImageList();

			private ArrayList selectedClasses = null;
			private ArrayList listSearchHits = new ArrayList();

			private SortedList curClassList = new SortedList(100);

			private enum schema_icons 
			{
				SCHEMA_NS_CLOSED =0,
				SCHEMA_NS_OPEN,
				SCHEMA_CLASS,
				SCHEMA_ASSOC,
				SCHEMA_CLASS_ABSTRACT1,
				SCHEMA_CLASS_ABSTRACT2, 
				SCHEMA_ASSOC_ABSTRACT1,
				SCHEMA_ASSOC_ABSTRACT2
			};

	

			public ClassFilters CurrentFilters
			{
				get {
					return currentFilters;
				}			
			}

			
			public ArrayList SelectedClasses 
			{

				get {
					return selectedClasses;
				}

				set {
					if (selectedClasses != value)
					{
						String[] arSel = new String[value.Count];
						value.CopyTo(arSel, 0);

						selectedClassList.Items.Clear();

						for (int i = 0; i < arSel.Length; i++)
						{							
							selectedClassList.Items.Add (arSel[i]);
						}						
					}
				}
			}

			public String CurrentServer
			{
				get {
					return machineName;
				}			
			}


			public SelectWMIClassTreeDialog(string server,
											string connectAsIn,
											string passwordIn,
											ClassFilters filters,
											ArrayList selClasses
											/*TODO: credentials */
											)
											
			{	

				try
				{								
					
					currentFilters = filters;				
					machineName = server;					
					selectedClasses = selClasses;			
					connectAs = connectAsIn;
					password = passwordIn;

					this.Text = WMISys.GetString("WMISE_ClassSelectorLbl");
					this.AcceptButton = okBtn;
					this.AutoScaleBaseSize = (Size) new Point(5, 13);
					this.BorderStyle = FormBorderStyle.FixedDialog;
					this.CancelButton = cancelBtn;
					int dlgWidth = 527;
					int dlgHeight = 480;
					this.ClientSize =  (Size) new Point(dlgWidth, dlgHeight);
					//this.add_KeyUp(new KeyEventHandler(this.OnKeyUp));
					this.ShowInTaskbar = false;
					this.MinimizeBox = false;
					this.MaximizeBox = false;

					labelSearch.Location = new Point(16, 16);	
					labelSearch.Size = (Size) new Point(200, 13);
					labelSearch.TabStop = false;			
					labelSearch.Text = WMISys.GetString("WMISE_ClassSelectorLblSearch");

					editSearch.Location = new Point(16, 33);
					editSearch.Size = (Size) new Point(200, 20);
					editSearch.TabStop = true;
					editSearch.TextChanged += new EventHandler(this.SearchPattern_changed);
					editSearch.AcceptsReturn = true; //???
					editSearch.TabIndex = 0;

					btnGo.Location = new Point(226, 33);
					btnGo.TabStop = true;
					btnGo.Text = WMISys.GetString("WMISE_ClassSelectorBtnSearch");
					btnGo.Click += new EventHandler(this.Search_click);

					classList = new WMIClassTreeView(machineName, 
													connectAs,
													password,
													currentFilters,
													null);												
							
					classList.Location = new Point(16, 63);
					classList.Size = (Size) new Point(200, 270);
					classList.ShowPlusMinus = true;
					classList.ShowLines = true;
					classList.DoubleClick += (new EventHandler(this.Add_click));
					classList.BeforeCollapse += (new TreeViewCancelEventHandler(this.BeforeNodeCollapse));
					classList.AfterSelect += (new TreeViewEventHandler (this.AfterNodeSelect));
					classList.KeyUp += (new KeyEventHandler(this.OnTreeKeyUp));
					classList.HideSelection = false;
					classList.FullRowSelect = true;

				
					//Image symbols = Image.FromFile("symbols.bmp");
					//imgList.Images.AddStrip(symbols);	
					
					imgList.TransparentColor = defaultBackColor; //didn't help!!!!!!!
				
	                imgList.Images.Add ((Image)new Bitmap(GetType(), "closed_fol.bmp"), defaultBackColor);
					imgList.Images.Add ((Image)new Bitmap(GetType(), "open_fol.bmp"), defaultBackColor);

					imgList.Images.Add ((Image)new Bitmap(GetType(), "class.bmp"), defaultBackColor);
					imgList.Images.Add ((Image)new Bitmap(GetType(), "classassoc.bmp"), defaultBackColor);

					imgList.Images.Add ((Image)new Bitmap(GetType(), "abstr1.bmp"), defaultBackColor);
					imgList.Images.Add ((Image)new Bitmap(GetType(), "abstr2.bmp"), defaultBackColor);
					imgList.Images.Add ((Image)new Bitmap(GetType(), "abstr_assoc1.bmp"), defaultBackColor); //SCHEMA_ASSOC_ABSTRACT1
					imgList.Images.Add ((Image)new Bitmap(GetType(), "abstr_assoc2.bmp"), defaultBackColor); //SCHEMA_ASSOC_ABSTRACT2

					
					btnAdd.Location = new Point(226, 150);
					btnAdd.TabStop = true;
					btnAdd.Text = WMISys.GetString("WMISE_ClassSelectorBtnAdd");
					btnAdd.Click += new EventHandler(this.Add_click);
					btnAdd.Enabled = false;

					btnRemove.Location = new Point(226, 200);
					btnRemove.TabStop = true;
					btnRemove.Text = WMISys.GetString("WMISE_ClassSelectorBtnRemove");
					btnRemove.Click += new EventHandler(this.Remove_click);
					btnRemove.Enabled = false;

					labelSelected.Location = new Point(311, 43);
					labelSelected.Size = (Size) new Point(200, 20);
					labelSelected.TabStop = false;			
					labelSelected.Text = WMISys.GetString("WMISE_ClassSelectorSelClassesLbl");

					selectedClassList.Location = new Point(311, 63);
					selectedClassList.Size = (Size) new Point(200, 270);
					selectedClassList.SelectionMode = SelectionMode.MultiExtended;
					selectedClassList.Sorted = true;
					//initialize selected class list
					String[] arSel = new String[selectedClasses.Count];
					selectedClasses.CopyTo(arSel, 0);
					for (int i = 0; i < arSel.Length; i++)
					{
						selectedClassList.Items.Add (arSel[i]);
					}


					selectedClassList.Click += new EventHandler (this.AfterClassSelect);
					selectedClassList.KeyUp += new KeyEventHandler (this.OnClassListKeyUp);
					selectedClassList.DoubleClick += (new EventHandler(this.Remove_click));

/*
					chkShowData.Checked = ((currentFilters & SchemaFilters.NoData) == 0);
					chkShowData.Location = new Point(500, 370);
					chkShowData.Text = "Data";
					chkShowData.Click += new EventHandler(this.Filter_click);
					chkShowData.Visible = false;
		            			
					chkShowSystem.Checked = ((currentFilters & SchemaFilters.NoSystem) == 0);
					chkShowSystem.Location = new Point(550, 370);
					chkShowSystem.Text = "System";
					chkShowSystem.Click += new EventHandler(this.Filter_click);
					chkShowSystem.Visible = false;

					chkShowEvent.Checked = ((currentFilters & SchemaFilters.NoEvent) == 0);
					chkShowEvent.Location = new Point(500, 400);
					chkShowEvent.Text = "Event";
					chkShowEvent.Click += new EventHandler(this.Filter_click);
					chkShowEvent.Visible = false;

					chkShowAbstract.Checked = ((currentFilters & SchemaFilters.NoAbstract) == 0);
					chkShowAbstract.Location = new Point( 550, 400);
					chkShowAbstract.Text = "Abstract";
					chkShowAbstract.Click += new EventHandler(this.Filter_click);
					chkShowAbstract.Visible = false;
*/
					descr.Text = "";
					descr.Location = new Point (16, 342);
					descr.Size = (Size) new Point (500, 75);
					descr.Multiline = true;
					descr.ReadOnly = true;
					descr.ScrollBars = ScrollBars.Vertical;
					
					okBtn.Text = WMISys.GetString("WMISE_OK");
					okBtn.TabIndex = 1;
					okBtn.Location = new Point(350, 427);
					okBtn.DialogResult = DialogResult.OK;
					okBtn.Click += new EventHandler(this.OK_click);
					
					cancelBtn.Text = WMISys.GetString("WMISE_Cancel");
					cancelBtn.TabIndex = 2;
					cancelBtn.Location = new Point(436, 427);
					cancelBtn.DialogResult = DialogResult.Cancel;

					this.Controls.Add(cancelBtn);
					this.Controls.Add(okBtn);
					this.Controls.Add(classList);
					this.Controls.Add(selectedClassList);
									//chkShowAbstract,
									//chkShowSystem,
									//chkShowEvent,
									//chkShowData,
					this.Controls.Add(labelSearch);
					this.Controls.Add(labelSelected);
					this.Controls.Add(editSearch);
					this.Controls.Add(btnGo);
					this.Controls.Add(btnAdd);
					this.Controls.Add(btnRemove);
					this.Controls.Add(descr);										


				}

				catch (Exception exc)
				{
					MessageBox.Show(WMISys.GetString("WMISE_Exception", exc.Message, exc.StackTrace));
				}
			}

			
			

			protected virtual void BeforeNodeCollapse(Object sender, TreeViewCancelEventArgs args)
			{
				TreeNode curNode = args.Node;

				//check that this is a namespace
				if (curNode.Parent != null)
				{
					return;
				}

				curNode.ImageIndex = (int)schema_icons.SCHEMA_NS_CLOSED;
				curNode.SelectedImageIndex = (int)schema_icons.SCHEMA_NS_CLOSED;

			}

			protected virtual void AfterNodeSelect(Object sender, TreeViewEventArgs args)
			{
				try
				{
					if (classList.SelectedNode != null)
					{
						btnAdd.Enabled = true;
					}

					TreeNode curNode = args.Node;

					//check if this is a namespace
					if (curNode.Parent == null)
					{
						descr.Text = GetNSDescription(curNode.Text);						
					}
					else
					{
						//Update description field
						
						UpdateClassDescription(ClassListControls.ClassTreeView);
					}				
					
				}
				
				catch (Exception e)
				{
					MessageBox.Show(WMISys.GetString("WMISE_Exception", e.Message, e.StackTrace));
					
				}

			}

			protected virtual void AfterClassSelect(Object sender, EventArgs args)
			{
				if (selectedClassList.SelectedIndices.Count > 0)
				{
					btnRemove.Enabled = true;
				}		

				UpdateClassDescription(ClassListControls.SelectedClassList);

			}
			
			/*
			private bool UpdateView ()
			{
				try 
				{
					
					classList.Nodes.Clear();
					classList.EnumNamespaces("root", 0);
					

					return true;
				}
				catch (Exception e)
				{
					MessageBox.Show(WMISys.GetString("WMISE_Exception", e.Message, e.StackTrace));
					return false;
				}
			}
			*/

			private void Search_click (Object source, EventArgs args)
			{
				try 
				{
					TreeNode find = DoSearch();
					if (find != null)
					{
						classList.SelectedNode = find;

						//classList.SelectedImageIndex = find.Index;

						nodeLastFindNS = find.Parent;
						strLastFindClass = find.Text;

						find.BackColor = Color.DarkGray;
						find.ForeColor = Color.White;

						
						//add found node to a list, so that the color-coding is removed before 
						//the next search 

						//MessageBox.Show("Length of found nodes list is " + listSearchHits.Count);
						//MessageBox.Show("Found node is " + find.Text);
					
						listSearchHits.Add(find.Handle);
						
					}
								
				}
				catch (Exception e)
				{
					MessageBox.Show(WMISys.GetString("WMISE_Exception", e.Message, e.StackTrace));
					
				}
			}

			private void SearchPattern_changed (Object source, EventArgs args)
			{
				try 
				{
					nodeLastFindNS = null;
					strLastFindClass = "";
					
					if (editSearch.Text != "")
					{		
						this.AcceptButton = btnGo;
						this.UpdateDefaultButton();
					}
					else
					{
						this.AcceptButton = okBtn;
						this.UpdateDefaultButton();
					}
					
					
				}
				catch (Exception e)
				{
					MessageBox.Show(WMISys.GetString("WMISE_Exception", e.Message, e.StackTrace));
					
				}
			}		
			
			private TreeNode DoSearch()
			{
				try 
				{
					if (editSearch.Text == "")
					{
						return null;
					}

					bool bFound = false;					
					
					TreeNode retNode = null;
					if (nodeLastFindNS == null && strLastFindClass == "")	
					//Find first case
					{

						//clean up highlighted nodes from previous search
						
						IEnumerator enumHits = listSearchHits.GetEnumerator();
						while (enumHits.MoveNext())
						{
							IntPtr curHandle = (IntPtr)enumHits.Current;

							TreeNode oldHit = TreeNode.FromHandle(classList, curHandle);
							
							oldHit.BackColor = defaultBackColor;
							oldHit.ForeColor = defaultForeColor;
						}

						//clean up the highlighted indices list
						listSearchHits.Clear();
						
						//enumerate nodes 
						for (int i = 0; i < classList.Nodes.Count; i++)
						{
							TreeNode curNode = classList.Nodes[i]; 
							
							if (curNode.Parent == null ) //this is a namespace
							{
							
								if (curNode.Nodes.Count == 1 &&	curNode.Nodes[0].Text == "")
								// a namespace hasn't been expanded before
								{	
									bool bRes = classList.ShowClasses(curNode);												
								}

								String strPattern = editSearch.Text.ToLower();								
								
								for (int j = 0; j < curNode.Nodes.Count; j ++)
								{									
									String strClassName = curNode.Nodes[j].Text.ToLower();
																
									if  (strClassName.IndexOf(strPattern) >= 0)
									{
										bFound = true;
										retNode = curNode.Nodes[j];
										
										curNode.Expand(); //if a match was found, expand the namespace
										break;
									}
								}						

								if (bFound)
								{
									break;
								}
							}
						}				

					}
					else //Find next funtionality
					{
						//enumerate top-level nodes (namespaces)
						for (int i = 0; i < classList.Nodes.Count; i++)
						{
							TreeNode curNode = classList.Nodes[i]; 
							if (curNode.Parent == null && curNode.Index >= nodeLastFindNS.Index) //this is a namespace
							{
								if (curNode.Nodes.Count == 1 &&	curNode.Nodes[0].Text == "")
								// the namespace hasn't been expanded
								{								
									bool bRes = classList.ShowClasses(curNode);	
								}

								String strPattern = editSearch.Text.ToLower();
								bool bSkipping = (nodeLastFindNS.Text.ToLower() == curNode.Text.ToLower());
								for (int j = 0; j < curNode.Nodes.Count; j ++)
								{
									String strClassName = curNode.Nodes[j].Text.ToLower();
									if (bSkipping)
									{
										if (strClassName == strLastFindClass.ToLower())
										{
											bSkipping = false;
											continue;
										}
									}
									else	//inspect class
									{
										if  (strClassName.IndexOf(strPattern) >= 0)
										{
											
											bFound = true;
											retNode = curNode.Nodes[j];
											
											curNode.Expand(); //if a match was found, expand the namespace

											break;
										}
									}
								}						
								if (bFound)
								{
									break;
								}
							}
						}			
					}

					 //wmi raid 2849: beta2. Don't have a localized string.
					 
					if (!bFound)
					{
						MessageBox.Show (WMISys.GetString("WMISE_Search_Failed", editSearch.Text));
					}

					return retNode;
				}
				catch (Exception e)
				{
					MessageBox.Show(WMISys.GetString("WMISE_Exception", e.Message, e.StackTrace));
					return null;
				}
			}

			private void OnClassDoubleClick (Object source, EventArgs args)
			{
				try 
				{
						
					if (classList.SelectedNode.Parent == null)
					{
						//this is a namespace
						return;
					}
					String path = classList.SelectedNode.Parent.Text + ":" + classList.SelectedNode.Text;

					//SingleViewContainerDlg dlg = new SingleViewContainerDlg(path);
					//DialogResult ret = dlg.ShowDialog(this);

								
				}
				catch (Exception e)
				{
					MessageBox.Show(WMISys.GetString("WMISE_Exception", e.Message, e.StackTrace));
					
				}
			}
			
			private void Add_click (Object source, EventArgs args)
			{
				try 
				{
					if (classList.SelectedNode.Parent == null)
					{
						//this is a namespace
						DialogResult res = 
							MessageBox.Show(WMISys.GetString("WMISE_ClassSelectorAskViewAll"),
											"",
											MessageBoxButtons.YesNo);
						if (res == DialogResult.No)
						{
							return;
						}
						else
						{
							AddWholeNS(classList.SelectedNode);

						}

					}
					else
					{

						DoAddNode (classList.SelectedNode);
					}
				
					classList.SelectedNode = null;
					btnAdd.Enabled = false;
					
					
				}

				catch (Exception e)
				{
					MessageBox.Show(WMISys.GetString("WMISE_Exception", e.Message, e.StackTrace));
				}
			}


			private void Remove_click (Object source, EventArgs args)
			{
				try 
				{	
					while (selectedClassList.SelectedItems.Count > 0)
					{
						selectedClassList.Items.Remove(selectedClassList.SelectedItems[0]);
					}	

					if (selectedClassList.SelectedItems.Count <= 0)
					{
						btnRemove.Enabled = false;
					}					
					
				}

				catch (Exception e)
				{
					MessageBox.Show(WMISys.GetString("WMISE_Exception", e.Message, e.StackTrace));
				}
			}

			private void OK_click (Object source, EventArgs args)
			{
				try 
				{	
					selectedClasses.Clear();

					for (int i = 0; i < selectedClassList.Items.Count; i++)
					{
						selectedClasses.Add (selectedClassList.Items[i].ToString());
					}
				}

				catch (Exception e)
				{
					MessageBox.Show(WMISys.GetString("WMISE_Exception", e.Message, e.StackTrace));
				}
			}

			
			private void AddWholeNS(TreeNode selNode)
			{
				try 
				{
					if (selNode.Parent != null)
					{
						//this is not a namespace
						return;
					}
					if (selNode.Nodes.Count == 1 &&	selNode.Nodes[0].Text == "")
					// the namespace hasn't been expanded before
					{
		            	bool bRes = classList.ShowClasses(selNode);	
					}

					for (int j = 0; j < selNode.Nodes.Count; j ++)
					{
						DoAddNode(selNode.Nodes[j]);
					}
					
				}
				catch (Exception e)
				{
					MessageBox.Show(WMISys.GetString("WMISE_Exception", e.Message, e.StackTrace));
				}
			}

			private void DoAddNode (TreeNode node)
			{
				try 
				{
					String path = 			
						node.Parent.Text + ":" + node.Text;

					//see if the item is already there
					for (int i = 0; i < selectedClassList.Items.Count; i++)
					{
						if (selectedClassList.Items[i].ToString().ToUpper() == path.ToUpper())
						{
							MessageBox.Show(WMISys.GetString("WMISE_ClassSelectorClassAlreadySelected", path));
							//selectedClassList.SelectedItem = selectedClassList.Items.All[i];
							return;
						}
					}

					//if not, add it:			
					selectedClassList.Items.Add(path);	
					
				}
				catch (Exception e)
				{
					MessageBox.Show(WMISys.GetString("WMISE_Exception", e.Message, e.StackTrace));					
				}
			}


			private string GetNSDescription (string nsName)
			{
							
					if (nsName.ToLower() == "root")
					{
						return 	WMISys.GetString("WMISE_NSDescription_Root");
					}
					if (nsName.ToLower() == "root\\default")
					{
						return 	WMISys.GetString("WMISE_NSDescription_Root_Default");
					}
					if (nsName.ToLower() == "root\\cimv2")
					{
						return 	WMISys.GetString("WMISE_NSDescription_Root_Cimv2");
					}
					if (nsName.ToLower() == "root\\cimv2\\applications")
					{
						return 	WMISys.GetString("WMISE_NSDescription_Root_Cimv2_Applications");
					}
					if (nsName.ToLower() == "root\\cimv2\\applications\\microsoftie")
					{
						return 	WMISys.GetString("WMISE_NSDescription_Root_Cimv2_Applications_MicrosoftIE");
					}
					if (nsName.ToLower() == "root\\directory")
					{
						return 	WMISys.GetString("WMISE_NSDescription_Root_Directory");
					}
					if (nsName.ToLower() == "root\\directory\\ldap")
					{
						return 	WMISys.GetString("WMISE_NSDescription_Root_Directory_Ldap");
					}
					if (nsName.ToLower() == "root\\wmi")
					{
						return 	WMISys.GetString("WMISE_NSDescription_Root_Wmi");
					}
					if (nsName.ToLower() == "root\\microsoftsqlserver")
					{
						return 	WMISys.GetString("WMISE_NSDescription_Root_Microsoft_SQLServer");
					}
							
					return string.Empty;

			}

					
			private void OnClassListKeyUp (Object sender, KeyEventArgs args)
			{
				if ((args.KeyData == Keys.Up && args.Modifiers == Keys.None) ||
					(args.KeyData == Keys.Down && args.Modifiers == Keys.None))
				{
					if (selectedClassList.SelectedIndices.Count > 0)
					{
						btnRemove.Enabled = true;
					}

					UpdateClassDescription(ClassListControls.SelectedClassList);
				}				
			}

			private void OnTreeKeyUp (Object sender, KeyEventArgs args)
			{
				if ((args.KeyData == Keys.Up && args.Modifiers == Keys.None) ||
					(args.KeyData == Keys.Down && args.Modifiers == Keys.None))
				{
					if (classList.SelectedNode != null)
					{
						btnAdd.Enabled = true;
					}						

					if (classList.SelectedNode.Parent == null)
					{
						descr.Text = GetNSDescription(classList.SelectedNode.Text);						
					}
					else
					{
						this.UpdateClassDescription(ClassListControls.ClassTreeView);						
					}
				}
			}
			
			private bool UpdateClassDescription (ClassListControls curControl)
			{

				string ns = string.Empty;
				string className = string.Empty;
				if (curControl == ClassListControls.ClassTreeView)
				{
					if (classList.SelectedNode != null)
					{
						ns = classList.SelectedNode.Parent.Text;
						className = classList.SelectedNode.Text;											
					}
				}
				else	//this is a selected class list
				{
					//see if this is a multiple selection (or nothing is selected) and clear description in this case
					if (selectedClassList.SelectedIndices.Count != 1)
					{
						descr.Text = string.Empty; 
						return true;
					}
						
					string relPath = selectedClassList.SelectedItem.ToString();	
					ns = relPath.Substring(0, relPath.IndexOf(":"));
					className = relPath.Substring(relPath.IndexOf(":") + 1);
					
				}							
				
				ManagementObject obj = WmiHelper.GetClassObject(machineName,
															ns, 
															className,
															this.connectAs,
															this.password);				
									
				string theDescr = WmiHelper.GetClassDescription(obj, this.connectAs, this.password);
				if (theDescr != string.Empty)
				{
					//Add special handling for newlines: change all "\n" to System.Environment.NewLine:
					int i = -1;
					string theRest = theDescr;
					string theStart = string.Empty;
					while ((i = theRest.IndexOf("\n")) >= 0)
					{
						theStart = theStart + theRest.Substring(0, i) + System.Environment.NewLine;
						theRest = theRest.Substring(i + 1);
					}
					theDescr = theStart + theRest;

					descr.Text = theDescr;
					return true;
				}
				else
				{
					descr.Text = WMISys.GetString("WMISE_NoDescr");
					return false;
				}
				
			}

			public void CleanUpPreviousSelections ()
			{
				try 
				{												
					IEnumerator enumHits = listSearchHits.GetEnumerator();
					while (enumHits.MoveNext())
					{
						IntPtr curHandle = (IntPtr)enumHits.Current;

						TreeNode oldHit = TreeNode.FromHandle(classList, curHandle);
						
						oldHit.BackColor = defaultBackColor;
						oldHit.ForeColor = defaultForeColor;
					}

					//clean up the highlighted indices list
					listSearchHits.Clear();

					//classList.SelectedNode = null;

					selectedClassList.ClearSelected();

					descr.Text = string.Empty;
					
				}
				catch (Exception e)
				{
					MessageBox.Show(WMISys.GetString("WMISE_Exception", e.Message, e.StackTrace));
					
				}
			}

			/*
			//Handle F3 for searching here
			protected override void OnKeyUp (KeyEventArgs args)
			{
				try 
				{	
					//MessageBox.Show("key up: " + args.ToString());
					if (args.KeyData == Keys.F3)
					{
						Search_click (this, null);
					}
					else
					{
						base.OnKeyUp(args);
					}
					
				}

				catch (Exception e)
				{
					MessageBox.Show(WMISys.GetString("WMISE_Exception", e.Message, e.StackTrace));
				}
			}
*/

		}

	internal class CancelDialog : Form
	{
		private Button cancelBtn = new Button();
		private Label text = new Label();

		private void InitializeComponent ()
		{
			this.ClientSize = (Size)new Point(250, 100);
			this.ShowInTaskbar = false;
			this.MinimizeBox = false;
			this.MaximizeBox = false;

			this.AcceptButton = cancelBtn;
			this.BorderStyle = FormBorderStyle.FixedDialog;	
			this.AutoScaleBaseSize = (Size) new Point(5, 13);					
							
			text.Location = new Point(15, 15);
			text.TabStop = false;
			text.Size = (Size) new Point(200, 25);
								
			cancelBtn.Location = new Point(95, 70);
			cancelBtn.DialogResult = DialogResult.Cancel;
			cancelBtn.Text = WMISys.GetString("WMISE_Cancel");
			cancelBtn.TabStop = true;
			
		}

		public CancelDialog(string textIn, int x, int y)
		{			
			InitializeComponent();
			text.Text = textIn;

			this.Location = new Point(x, y);

			this.Controls.Add(cancelBtn);
			this.Controls.Add(text);
								
		}
		

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vside\servexpl\wmienumpropertydescriptor.cs ===
namespace Microsoft.VSDesigner.WMI 
{
using System;
using System.Collections;
using System.ComponentModel;
using System.Windows.Forms;
using System.Management;

/// <summary>
///    Summary description for Class1.
/// </summary>
/// 
[TypeConverter(typeof(WMIEnumTypeConverter))]
internal class WMIEnumPropertyDescriptor : WMIPropertyDescriptor
{
    public WMIEnumPropertyDescriptor(ManagementObject mgmtObjIn,
										ManagementObject mgmtClassObjIn,
										String propNameIn,
										bool commitImmediately)
		:base(mgmtObjIn, mgmtClassObjIn, propNameIn, commitImmediately)
	{
	
	}
/*
	public override TypeConverter Converter 
	{
		 get
		{
			return new WMIEnumTypeConverter();
		}

	}
	
	public override Object GetValue (Object component)  
	{
		return prop.get_Value();
	}
	*/

	public override void SetValue (Object component, Object value)  
	{     
		try
		{
			prop.Value = value;
			if (CommitImmediately)
			{
				PutOptions putOpts = new PutOptions(null,
													true,	//use amended qualifiers
													PutType.UpdateOrCreate);

				mgmtObj.Put(putOpts);
			}
		}
		catch (Exception exc)
		{
			throw (exc);
		}
	}

}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vside\servexpl\wmienumtypeconverter.cs ===
namespace Microsoft.VSDesigner.WMI 
{
using System;
using System.Diagnostics;
using System.ComponentModel;
using System.Collections;
using System.Windows.Forms;

/// <summary>
///    Summary description for Class1.
/// </summary>
internal class WMIEnumTypeConverter : TypeConverter
{
	

    public override StandardValuesCollection GetStandardValues(ITypeDescriptorContext context)
	{
		//Trace.WriteLine("getting standard values for a " + context.Instance.GetType().FullName);
		MessageBox.Show("getting standard values for a " + context.Instance.GetType().FullName);
		MessageBox.Show ("WMIEnumTypeConverter::GetStandardValues");

		//get ValueMap and Value property qualifiers on the class object

		ArrayList valueList = new ArrayList();

		//.....................

		return new StandardValuesCollection(valueList);

	}

	public override bool GetStandardValuesExclusive(ITypeDescriptorContext context)
	{
		//MessageBox.Show ("WMIEnumTypeConverter::GetStandardValuesExclusive");

		return true;

	}

	public override bool GetStandardValuesSupported(ITypeDescriptorContext context)
	{
		return true;
	}

	public override bool IsValid(ITypeDescriptorContext context, object val) 
	{
		MessageBox.Show ("WMIEnumTypeConverter::IsValid");
		return true;	//later, check if value is valid
	}
     
}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vside\servexpl\wmihelper.cs ===
namespace Microsoft.VSDesigner.WMI {

	using System;
	using System.ComponentModel;
	//using System.Core;
	using System.Windows.Forms;
	using System.Runtime.InteropServices;
	using System.Drawing;
	using System.Management;
	using System.Collections;
	using System.Collections.Specialized;
	using System.Diagnostics;
	using System.Net;
	using System.Resources;

	
    internal class WmiHelper
	{
		const UInt16 DMTF_DATETIME_STR_LENGTH = 25;
		const UInt16 DMTF_DATETIME_INTERVAL_STR_LENGTH = 25;

		public static bool UseFriendlyNames = true;
		
		private static SortedList classesWithIcons = new SortedList(100);

		public readonly static Image defaultClassIcon = (Image)new Bitmap(typeof(WMIClassesNode), "class.bmp");
		public readonly static Image defaultInstanceIcon = (Image)new Bitmap(typeof(WMIClassesNode), "inst.bmp");


		/// <summary>
		/// Property is not writeable only if "read" qualifier is present and its value is "true"
		/// Also, for dynamic classes, absence of "write" qualifier means that the property is read-only.
		/// </summary>
		/// <param name="obj"> </param>
		/// <param name="prop"> </param>
		static public bool IsPropertyWriteable(ManagementObject obj, Property prop) 
		{		
			//collect all the info:
			bool isDynamic = CheckObjectBoolQualifier(obj, "dynamic");

			bool hasWrite = CheckPropertyQualifierExistence(prop, "write");
			bool writeValue = CheckPropertyBoolQualifier (prop, "write");
			bool hasRead = CheckPropertyQualifierExistence(prop, "read");
			bool readValue = CheckPropertyBoolQualifier (prop, "read");

			if ((!isDynamic && !hasWrite && !hasRead)||
				(!isDynamic && hasWrite && writeValue)||
				(isDynamic && hasWrite && writeValue))
			{
				return true;
			}


			return false;
						
		}


		/// <summary>
		/// Converts DMTF datetime property value to System.DateTime
		/// </summary>
		/// <param name="prop"> </param>
		static public DateTime ToDateTime (String dmtf) 
		{					
			try
			{
				
				//set the defaults:
				Int32 year = DateTime.Now.Year;
				Int32 month = 1;
				Int32 day = 1;
				Int32 hour = 0;
				Int32 minute = 0;
				Int32 second = 0;
				Int32 millisec = 0;

				String str = dmtf;

				if (str == String.Empty || 
					str.Length != DMTF_DATETIME_STR_LENGTH )
					//|| str.IndexOf("*") >= 0 )
				{
					return DateTime.MinValue;
				}

				string strYear = str.Substring(0, 4);
				if (strYear != "****")
				{
					year = Int32.Parse (strYear);
				}

				string strMonth = str.Substring(4, 2);
				if (strMonth != "**")
				{
					month = Int32.Parse(strMonth);
				}

				string strDay = str.Substring(6, 2);
				if (strDay != "**")
				{
					day = Int32.Parse(strDay);
				}
				
				string strHour = str.Substring(8, 2);
				if (strHour != "**")
				{
					hour = Int32.Parse(strHour);
				}

				string strMinute = str.Substring(10, 2);
				if (strMinute != "**")
				{
					minute = Int32.Parse(strMinute);
				}
				
				string strSecond = str.Substring(12, 2);
				if (strSecond != "**")
				{
					second = Int32.Parse(strSecond);
				}

				//note: approximation here: DMTF actually stores microseconds
				string strMillisec = str.Substring(15, 3);	
				if (strMillisec != "***")
				{
					millisec = Int32.Parse(strMillisec);
				}

				DateTime ret = new DateTime(year, month, day, hour, minute, second, millisec);

				return ret;
			}
			catch(Exception e)
			{
				MessageBox.Show(WMISys.GetString("WMISE_Exception", e.Message, e.StackTrace));
				throw (e);
			}
				
		}


		static public String ToDMTFTime (DateTime wfcTime) 
		{
			
			String dmtf = string.Empty;

			dmtf +=  wfcTime.Year.ToString();
			dmtf +=  wfcTime.Month.ToString().PadLeft(2, '0');
			dmtf +=  wfcTime.Day.ToString().PadLeft(2, '0');
			dmtf +=  wfcTime.Hour.ToString().PadLeft(2, '0');
			dmtf +=  wfcTime.Minute.ToString().PadLeft(2, '0');
			dmtf +=  wfcTime.Second.ToString().PadLeft(2, '0');
			dmtf +=  ".";
			dmtf +=  wfcTime.Millisecond.ToString().PadLeft(3, '0');

			dmtf += "000";	//this is to compensate for lack of microseconds in DateTime

			TimeZone curZone = TimeZone.CurrentTimeZone;
			long tickOffset = curZone.GetUTCOffset(wfcTime);


			if (tickOffset >= 0)
			{
				dmtf +=  "+";
				dmtf += (tickOffset/60000).ToString();
			}
			else
			{
				dmtf +=  "-";
				dmtf += (tickOffset/60000).ToString().Substring(1, 3);	
			}								

			return dmtf;
				
		}
		
		

		static public bool IsValueMap (Property prop)
		{
			try
			{
				
				QualifierCollection.QualifierEnumerator enumQuals = prop.Qualifiers.GetEnumerator();
				while (enumQuals.MoveNext())
				{
					Qualifier qual = enumQuals.Current;
					if (qual.Name == "Values")
					{

						return true;
					}
				
				}
				return false;
			}
			catch (Exception )
			{

				return false;
			}
		}

				
		


		static public String GetPropertyDescription (String propName, 
													ManagementObject curObj,
													string connectAs,
													string pw)
		{
			try
			{
				if (curObj == null)
				{
					throw new ArgumentNullException("curObj");
				}
				Property verboseProp = null;

				if (!curObj.Path.IsClass)
				{
					ManagementObject classObj = WmiHelper.GetClassObject(curObj, connectAs, pw);					
					verboseProp = classObj.Properties[propName];
				}	
				else
				{
					verboseProp = curObj.Properties[propName];
				}
				
				string descr = string.Empty;
				Qualifier descrQual = verboseProp.Qualifiers["Description"];	
				
				descr = descrQual.Value.ToString();
				return descr;

			}
			catch (Exception )
			{
				return "";
			}
		}


		
		static public String GetClassDescription (ManagementObject obj,
													string connectAs,
													string pw)
		{
			try
			{
				ManagementObject verboseObj = obj;

				if (!obj.Path.IsClass)
				{
					verboseObj = WmiHelper.GetClassObject(obj, connectAs, pw);					
				}	

				Qualifier descrQual = verboseObj.Qualifiers["Description"];	
				return (descrQual.Value.ToString());
			}
			catch (Exception )
			{
				return ""; 						
			}
		}

		
		
		static public String GetMethodDescription (String methName, 
													ManagementObject curObj,
													string connectAs,
													string pw)
		{
			try
			{		
				Qualifier descrQual = null;
				Method verboseMeth = null;

				if (!curObj.Path.IsClass)
				{
					ManagementClass classObj = WmiHelper.GetClassObject(curObj, connectAs, pw);
					verboseMeth = classObj.Methods[methName];
				}	
				else
				{
					verboseMeth = ((ManagementClass)curObj).Methods[methName];
				}

				descrQual = verboseMeth.Qualifiers["Description"];	

				return (descrQual.Value.ToString());
			}
			catch (Exception)
			{
				//2880: removed message here
				return ""; 						
			}
		}

		

		public static ManagementClass GetClassObject (ManagementObject objIn,
														string user, 
														string pw)
		{
			if (objIn == null)
			{
				throw new ArgumentException();
			}

			try
			{

				ManagementPath path = objIn.Path;

				if (path.IsClass)
				{
					return (ManagementClass)objIn;
				}
				
				ManagementPath classPath = new ManagementPath(path.NamespacePath + ":" + path.ClassName);

				ObjectGetOptions options = new ObjectGetOptions(null, true);

				ConnectionOptions connectOpts = new ConnectionOptions(
												"", //locale
												user, //username
												pw, //password
												"", //authority
												ImpersonationLevel.Impersonate,
												AuthenticationLevel.Connect,
												true, //enablePrivileges
												null	//context
											);

				ManagementScope scope = (path.Server == WmiHelper.DNS2UNC(Dns.GetHostName())) ?	
					new ManagementScope(path.NamespacePath) :
					new ManagementScope(path.NamespacePath, connectOpts);


				ManagementClass classObj = new ManagementClass(scope, 
																classPath, 
																options);

				return classObj;
			}

			catch (Exception)
			{
				return null;
			}

		}

	

		public static ManagementObject GetClassObject (string server,
													string ns,
													string className,
													string user, 
													string pw)

		{
			if (ns == string.Empty || className == string.Empty)
			{
				throw new ArgumentException();
			}
            
			try
			{			
				ManagementPath classPath = new ManagementPath(WmiHelper.MakeClassPath(server, ns, className));

				ObjectGetOptions options = new ObjectGetOptions(null, true);

				ConnectionOptions connectOpts = new ConnectionOptions(
												"", //locale
												user, //username
												pw, //password
												"", //authority
												ImpersonationLevel.Impersonate,
												AuthenticationLevel.Connect,
												true, //enablePrivileges
												null	//context
											);

				ManagementScope scope = (server == WmiHelper.DNS2UNC(Dns.GetHostName())) ?	
						new ManagementScope(WmiHelper.MakeNSPath(server, ns)) :
						new ManagementScope(WmiHelper.MakeNSPath(server, ns), connectOpts);

				ManagementObject classObj = new ManagementObject(scope, 
																classPath, 
																options);
				return classObj;
			}

			catch (Exception e)
			{
				MessageBox.Show(WMISys.GetString("WMISE_Exception", e.Message, e.StackTrace));				
				return null;
			}

		}
		
		
		/// <summary>
		/// IsStaticMethod
		/// </summary>
		/// <param name="meth"> </param>
		static public bool IsStaticMethod (Method meth)
		{
			return CheckMethodBoolQualifier(meth, "Static");
	
		}

		

		/// <summary>
		/// IsImplementedMethod
		/// </summary>
		/// <param name="meth"> </param>
		static public bool IsImplementedMethod (Method meth)
		{
			return CheckMethodBoolQualifier(meth, "Implemented");
		}

		/// <summary>
		/// IsKeyProperty
		/// </summary>
		/// <param name="prop"> </param>
		static public bool IsKeyProperty (Property prop)
		{
			return CheckPropertyBoolQualifier(prop, "Key");
		}

		

		
		


		/// <summary>
		/// CheckMethodBoolQualifier
		/// </summary>
		/// <param name="meth"> </param>
		/// <param name="qualName"> </param>
		static private bool CheckMethodBoolQualifier(Method meth, String qualName)
		{
			try 
			{
				QualifierCollection qualSet = meth.Qualifiers;
				Qualifier qual = qualSet[qualName];	
					
				return (Convert.ToBoolean(qual.Value));
			}
			catch(Exception)
			{
				//NOTE that if the qualifier is not present, "Not found" will be returned
				//Return false in this case
				return false;
			}				
		}
		

		
		/// <summary>
		/// CheckPropertyBoolQualifier
		/// </summary>
		/// <param name="prop"> </param>
		/// <param name="qualName"> </param>
		static private bool CheckPropertyBoolQualifier(Property prop, String qualName)
		{
			try 
			{			
				QualifierCollection qualSet = prop.Qualifiers;
				Qualifier qual = (Qualifier)qualSet[qualName];	
				
				return (Convert.ToBoolean(qual.Value));
			}
			catch(Exception)
			{
				//NOTE that if the qualifier is not present, "Not found" will be returned
				//Return false in this case
			

				return false;
			}				
		}


		

		/// <summary>
		/// CheckPropertyQualifierExistence
		/// </summary>
		/// <param name="prop"> </param>
		/// <param name="qualName"> </param>
		static private bool CheckPropertyQualifierExistence(Property prop, String qualName)
		{
			QualifierCollection qualSet = prop.Qualifiers;

			try 
			{
				Qualifier qual = qualSet[qualName];						
				return true;	//previous statement didn't throw, so qualifier must be present
			}
			catch(Exception )
			{
				return false;
			
			}				
		}

		

		/// <summary>
		/// CheckObjectBoolQualifier
		/// </summary>
		/// <param name="obj"> </param>
		/// <param name="qualName"> </param>
		static private bool CheckObjectBoolQualifier(ManagementObject obj, String qualName)
		{
			try 
			{
				QualifierCollection qualSet = obj.Qualifiers;
				Qualifier qual = qualSet[qualName];	
					
				return (Convert.ToBoolean(qual.Value));
			}
			catch(Exception)
			{
				//NOTE that if the qualifier is not present, "Not found" will be returned
				//Return false in this case
				return false;
			}				
		}


		

		/// <summary>
		/// IsAbstract
		/// </summary>
		/// <param name="obj"> </param>
		static public  bool IsAbstract (ManagementObject obj)
		{
				try 
				{
					return CheckObjectBoolQualifier(obj, "abstract");
				}
				catch (Exception e)
				{
					MessageBox.Show(WMISys.GetString("WMISE_Exception", e.Message, e.StackTrace));
					return false;
				}
		}
		
		

		/// <summary>
		/// IsAssociation
		/// </summary>
		/// <param name="obj"> </param>
		static public bool IsAssociation (ManagementObject obj)
		{
				try 
				{
					return CheckObjectBoolQualifier(obj, "association");
				}
				catch (Exception e)
				{
					MessageBox.Show(WMISys.GetString("WMISE_Exception", e.Message, e.StackTrace));
					return false;
				}
		}

	
		/// <summary>
		/// IsSystem
		/// </summary>
		/// <param name="obj"> </param>
		static public bool IsSystem (ManagementObject obj)
		{
				try 
				{
					String NameOut = obj.Path.RelativePath;

					if (NameOut.Length < 2)
					{
						return false;
					}
						
					return (NameOut.Substring(0, 2) == "__");		
				}
				catch (Exception e)
				{
					MessageBox.Show(WMISys.GetString("WMISE_Exception", e.Message, e.StackTrace));
					return false;
				}
		}


		

		/// <summary>
		/// IsEvent
		/// </summary>
		/// <param name="obj"> </param>
		static public bool IsEvent (ManagementObject obj)
		{
				try 
				{
					
					//handle __ExtrinsicEvent class separately, since it is not its own parent
					if (obj.Path.RelativePath.ToString() == "__ExtrinsicEvent")
					{
						return true;
					}
			
					Object[] arParents = (Object[])obj.SystemProperties["__DERIVATION"].Value;
					for (int i =0; i < arParents.Length; i++)
					{
						if (arParents[i].ToString() == "__ExtrinsicEvent")
						{
							return true;
						}
					}
					

					return false;
				}
				catch (Exception e)
				{
					MessageBox.Show(WMISys.GetString("WMISE_Exception", e.Message, e.StackTrace));
					return false;
				}
		}



		/// <summary>
		/// Given an instance of an association object and a path to one of its
		/// endpoints (the "source"), this method returns "path" to the other endpoint
		/// (the "target").  
		/// </summary>
		/// <param name="assocInstance"> </param>
		/// <param name="sourcePath"> </param>
		static public String GetAssocTargetNamespacePath (ManagementObject assocInstance,
												ManagementPath sourcePath)
		{
			try
			{
				PropertyCollection.PropertyEnumerator  enumAssocProps = assocInstance.Properties.GetEnumerator();		
				while(enumAssocProps.MoveNext())
				{
					Property curProp = enumAssocProps.Current;
					if (curProp.Type != CimType.Reference)
					{
						continue;
					}
					else
					{
						//get CimType property qualifier value
						String refValue = curProp.Qualifiers["CimType"].Value.ToString();

						//get rid of "ref:" prefix:
						refValue = refValue.Substring(4);

						//confirm that this is not the source
						if ((String.Compare(refValue, sourcePath.ClassName, true) != 0) &&
							(String.Compare(refValue, sourcePath.Path, true) != 0))
						{
                           return refValue;							
						}
					}
				}

				return String.Empty;				
			}
			catch (Exception e)
			{
				MessageBox.Show(WMISys.GetString("WMISE_Exception", e.Message, e.StackTrace));
				return String.Empty;
			}
		}
		
		/// <summary>
		/// Given an instance of an association object and a path to one of its
		/// endpoints (the "source"), this method returns the role of the other endpoint
		/// (the "target") in this association.
		/// </summary>
		/// <param name="assocInstance"> </param>
		/// <param name="sourcePath"> </param>
		static public String GetAssocTargetRole (ManagementObject assocInstance,
													ManagementPath sourcePath)
		{
			try
			{
				PropertyCollection.PropertyEnumerator  enumAssocProps = assocInstance.Properties.GetEnumerator();		
				while(enumAssocProps.MoveNext())
				{
					Property curProp = enumAssocProps.Current;
					if (curProp.Type != CimType.Reference)
					{
						continue;
					}
					else
					{
						//confirm that this is not the source
						if ((String.Compare(curProp.Value.ToString(),
							sourcePath.Path, true )) != 0)
						{
							return curProp.Name;
						}
						
					}
				}

				return String.Empty;
			}
			catch (Exception e)
			{
				MessageBox.Show(WMISys.GetString("WMISE_Exception", e.Message, e.StackTrace));
				return String.Empty;
			}
		}

		public static Object GetTypedObjectFromString(CimType CimType, String strValue)
		{
			switch (CimType)
			{
				case (CimType.Boolean):
				{
					Boolean bValue = Boolean.Parse(strValue);
					return bValue;
				} 
				case (CimType.Char16):
				{
					Char charValue = Char.Parse(strValue);
					return charValue;
				} 
				case (CimType.DateTime):
				{
					return strValue;
				} 
				case (CimType.Object):
				{
					//VT_UNKNOWN
					//what's the format of strValue?
                    //thios wouldn't work until there is a way to invoke custom type converters and editors
					return null;
				} 
				case (CimType.Real32):
				{					
					Single retValue = Single.Parse(strValue);
					return retValue;
				} 
				case (CimType.Real64):
				{
					Double retValue = Double.Parse(strValue);
					return retValue;
				} 
				case (CimType.Reference):
				{
					return strValue;
				} 
				case (CimType.SInt16):
				{
					Int16 retValue = Int16.Parse(strValue);
					return retValue;
				} 
				case (CimType.SInt32):
				{
					Int32 retValue = Int32.Parse(strValue);
					return retValue;
				} 
				case (CimType.SInt64):
				{
					return strValue;
				} 
				case (CimType.SInt8):
				{
					//NOTE that SInt8 get expanded to VT_I2 in automation layer
					Int16 retValue = Int16.Parse(strValue);
					return retValue;
				} 
				case (CimType.String):
				{
					return strValue;
				} 
				case (CimType.UInt16):
				{
					//NOTE that UInt16 gets expanded to VT_I4 in automation layer
					Int32 retValue = Int32.Parse(strValue);
					return retValue;
				} 
				case (CimType.UInt32):
				{
					Int32 retValue = Int32.Parse(strValue);
					return retValue;
				} 
				case (CimType.UInt64):
				{
					return strValue;
				} 
				case (CimType.UInt8):
				{
					Byte retVal = Byte.Parse(strValue);
					return retVal;
				} 
                
                default:
                  return strValue;
            }

		}

		

		public static String GetDisplayName(ManagementObject obj,
											string connectAs,
											string pw) 
		{
			try
			{
				ManagementObject verboseObj = obj;

				if (!obj.Path.IsClass)
				{
					verboseObj = WmiHelper.GetClassObject(obj, connectAs, pw);					
				}	

				Qualifier dispName = verboseObj.Qualifiers["DisplayName"];	
				return (dispName.Value.ToString());
			}
			catch (Exception )
			{
				return String.Empty; 						
			}
		}


		/// <summary>
		/// Converts DMTF datetime interval property value to System.TimeSpan
		/// </summary>
		/// <param name="prop"> </param>
		static public TimeSpan ToTimeSpan (string dmtf) 
		{					
			try
			{
				
				//set the defaults:
				Int32 days = 0;
				Int32 hours = 0;
				Int32 minutes = 0;
				Int32 seconds = 0;
				Int32 millisecs = 0;

				String str = dmtf;

				if (str == String.Empty || 
					str.Length != DMTF_DATETIME_INTERVAL_STR_LENGTH )
				{
					return TimeSpan.Zero;
				}

				string strDay = str.Substring(0, 8);
				days = Int32.Parse(strDay);
								
				string strHour = str.Substring(8, 2);
				hours = Int32.Parse(strHour);
				
				string strMinute = str.Substring(10, 2);
				minutes = Int32.Parse(strMinute);
				
				
				string strSecond = str.Substring(12, 2);
				seconds = Int32.Parse(strSecond);
				
				//dot in the 14th position
				if (str.Substring(14, 1) != ".")
				{
					return TimeSpan.Zero;
				}
			

				//note: approximation here: DMTF actually stores microseconds
				string strMillisec = str.Substring(15, 3);	
				if (strMillisec != "***")
				{
					millisecs = Int32.Parse(strMillisec);
				}

				TimeSpan ret = new TimeSpan(days, hours, minutes, seconds, millisecs);

				return ret;
			}
			catch(Exception e)
			{
				MessageBox.Show(WMISys.GetString("WMISE_Exception", e.Message, e.StackTrace));
				throw (e);
			}				
		}

/// <summary>
/// 
/// </summary>
/// <param name="wfcTimeSpan"> </param>
		static public String ToDMTFInterval (TimeSpan wfcTimeSpan) 
		{
			
			String dmtf = string.Empty;
		
			dmtf +=  wfcTimeSpan.Days.ToString().PadLeft(8, '0');
			dmtf +=  wfcTimeSpan.Hours.ToString().PadLeft(2, '0');
			dmtf +=  wfcTimeSpan.Minutes.ToString().PadLeft(2, '0');
			dmtf +=  wfcTimeSpan.Seconds.ToString().PadLeft(2, '0');
			dmtf +=  ".";
			dmtf +=  wfcTimeSpan.Milliseconds.ToString().PadLeft(3, '0');

			dmtf += "000";	//this is to compensate for lack of microseconds in TimeSpan

			dmtf +=":000";			

			return dmtf;
				
		}


		static public bool IsInterval (Property prop)
		{
			if (prop.Type != CimType.DateTime)
			{
				throw new ArgumentException();
			}

			try
			{
				string subtype = string.Empty;
				Qualifier subtypeQual = prop.Qualifiers["Subtype"];	
				
				subtype = subtypeQual.Value.ToString();
				if (subtype.ToUpper() == "INTERVAL")
				{
					return true;
				}

				return false;
			}
			catch (Exception )
			{
				return false;
			}
		}

		/// <summary>
		/// Converts Dns name to UNC machine name, where
		///       UNC Name - eg: zinap1.
		///       Dns Name - eg: zinap1.ntdev.microsoft.com
		/// </summary>		
		static public string DNS2UNC (string Dns)
		{
			try
			{
				char[] separator = new char[] {'.'};
				string [] parts = Dns.Split(separator);
				return parts[0];
			}
			catch (Exception)
			{
				return string.Empty;
			}				
		}
		
		/// <summary>
		/// Returns true if classObj has non-abstract subclasses (with deep enumeration)
		/// </summary>
		/// <param name="classObj"> </param>
		static public bool HasNonAbstractChildren (ManagementClass classObj)
		{

				GetSubclassesOptions opts = new GetSubclassesOptions(null,	//context
																	TimeSpan.MaxValue, //timeout
																	50,		//block size
																	false,	 //rewindable																 
																	true,	//return immediately
																	false,	//amended
																	true);	//deep

				ManagementObjectCollection subClasses = classObj.GetSubclasses(opts);
				ManagementObjectCollection.ManagementObjectEnumerator  childEnum = subClasses.GetEnumerator();

				while (childEnum.MoveNext())
				{
					ManagementClass curChild = (ManagementClass)childEnum.Current;
					if (!WmiHelper.IsAbstract(curChild))
					{
						return true;
					}
				}
				return false;						
		}

		public static string MakeClassPath (string server, string ns, string className)
		{
			if (ns  == string.Empty)
			{
				throw new ArgumentException("ns");
			}	
			if (className  == string.Empty)
			{
				throw new ArgumentException("className");
			}
			if (server == string.Empty)
			{
				server = ".";
			}

			return "\\\\" + server + "\\" + ns + ":" + className;
			
		}

		public static string MakeNSPath (string server, string ns)
		{
			if (ns  == string.Empty)
			{
				throw new ArgumentException("ns");
			}				
			if (server == string.Empty)
			{
				server = ".";
			}

			return "\\\\" + server + "\\" + ns;
			
		}

		/// <summary>
		/// Given a class path, this returns the icon from the resource file
		/// </summary>
		/// <param name="classPath">WMI Class path (with or without the server part, which would be ignored anyway)</param>
		/// <param name="isClass">True if requesting a class icon, false if requesting an instance icon</param>
		/// <returns>Class-specific icon (or default if anything goes wrong)</returns>
		/// 
		public static Image GetClassIconFromResource(string classPath, bool isClass, Type loadingType)
		{
			try 
			{		
				string underscoredPath = classPath;

				//remove SERVER part, if any
				int rootIndex = underscoredPath.ToLower().IndexOf("root");
				if (rootIndex < 0)
				{
					throw new Exception();
				}
				underscoredPath = underscoredPath.Substring(rootIndex);

				//replace all colons and backslashes by underscores
				underscoredPath = underscoredPath.Replace("\\", "_");
				underscoredPath = underscoredPath.Replace(":", "_");
				underscoredPath +=".ico";
				underscoredPath = underscoredPath.ToLower();    
				underscoredPath = underscoredPath;

				if (classesWithIcons.Contains(underscoredPath))
				{
					return (Image)classesWithIcons[underscoredPath];
				}
				else
				{          				
					Image retIcon = (new Icon(loadingType, underscoredPath)).ToBitmap();
					//Image retIcon = Bitmap.FromResource( ??? //TODO: try to eliminate conversion to bitmap: bug 3145
					
					if (retIcon != null)
					{
						classesWithIcons.Add(underscoredPath, retIcon);
						return 	retIcon;
					}
					else
						throw new Exception();
				}

			}
			catch (Exception )
			{

				//if anything goes wrong, return the default
				if (isClass)
				{
					return defaultClassIcon;
				}
				else //an instance
				{
					return defaultInstanceIcon;
				}
			}
		}

		public static string[] GetOperators(CimType CimType)
		{
			ArrayList retArray = new ArrayList(10);

			switch(CimType)
			{
				case(CimType.Boolean) :
			{
					retArray.Add ("=");
					retArray.Add ("<>");
					break;
			}
				case (CimType.Char16) :
				
				case (CimType.DateTime) :
				case (CimType.Real32) :
				case (CimType.Real64) :
				case (CimType.SInt16) :
				case (CimType.SInt32 ):
				case (CimType.SInt64) :
				case (CimType.SInt8) :
				case (CimType.UInt16 ):
				case (CimType.UInt32) :
				case (CimType.UInt64) :
				case (CimType.UInt8 ) :
				case (CimType.Reference) :
				case (CimType.String) :
				{
					retArray.Add ("=");
					retArray.Add ("<>");
					retArray.Add (">");
					retArray.Add ("<");
					retArray.Add (">=");
					retArray.Add ("<=");
					break;
				}
				case (CimType.Object) :
				{
					retArray.Add("ISA");
					break;
				}

				
				default:
					break;
			}

			return (string[])retArray.ToArray(typeof(string));
		}

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vside\servexpl\wmiclassnode.cs ===
namespace Microsoft.VSDesigner.WMI {
    using System.Runtime.Serialization;
    using System.Diagnostics;
    using System;
    using System.Windows.Forms;
    using System.Drawing;
    using System.Collections;
    using Microsoft.VSDesigner;
	using Microsoft.VSDesigner.ServerExplorer;
    using System.ComponentModel.Design;
	using System.ComponentModel;
	using System.Resources;
	using System.Reflection;
	using System.Management;
	using System.Threading;
	using System.Net;
	using EnvDTE;
	using System.CodeDom;
	using System.CodeDom.Compiler;
	using System.IO;



    // <doc>
    // <desc>
    //     This represents the wmi classes node under a server node.
    // </desc>
    // </doc>
    [UserContextAttribute("serveritem", "wmiclass")]
    internal class WMIClassNode : Node, ISerializable  {
        //
        // FIELDS
        //

        private Image icon = null;
        public static readonly Type parentType = typeof(WMIClassesNode);
	    private string label = string.Empty;


		public readonly string path = string.Empty;
		public readonly string pathNoServer = string.Empty;
		private string serverName = string.Empty;
		private string nsName = string.Empty;
		private string className = string.Empty;
		private string connectAs = null;
		private string password = null;

		private ManagementClass mgmtObj = null;


       // private NewChildNode newChildNode = null;


        //
        // CONSTRUCTORS
        //

        // <doc>
        // <desc>
        //     Main constructor.
		//     Parameters: 
		//	string server (in, machine name)
		//	string pathIn (in, WMI path without the server name , e.g. "root\default:MyClass")
        // </desc>
        // </doc>
        public WMIClassNode(string pathIn, string user, string pw) {
			try
			{
				path = pathIn;
				connectAs = user;
				password = pw;

				//parse the path to get server, namespace and class name
				Int32 separ = path.IndexOf ("\\", 2 );
				if (separ == -1)
				{
					//invalid path
					throw (new ArgumentException(WMISys.GetString("WMISE_InvalidPath", pathIn), "pathIn"));									
				}

				serverName = path.Substring(2, separ - 2);
				pathNoServer = path.Substring(separ + 1, path.Length - separ - 1);
			
				
				//split pathNoServer into namespace and classname parts (':' is the separator)
				Int32 colon = pathNoServer.IndexOf(':', 0);
				if (colon == -1)
				{
					//invalid path
					throw (new ArgumentException(WMISys.GetString("WMISE_InvalidPath, pathIn"), "pathIn"));
				}			
				nsName = pathNoServer.Substring(0,colon);
				className = pathNoServer.Substring(colon + 1, pathNoServer.Length - colon - 1);
				
				//Get and cache mgmtObj

				ConnectionOptions connectOpts = new ConnectionOptions(
												"", //locale
												this.connectAs, //username
												this.password, //password
												"", //authority
												ImpersonationLevel.Impersonate,
												AuthenticationLevel.Connect,
												true, //enablePrivileges
												null	//context
											);

				ManagementScope scope = (this.serverName == WmiHelper.DNS2UNC(Dns.GetHostName())) ?	
						new ManagementScope(WmiHelper.MakeNSPath(serverName, nsName)):
						new ManagementScope(WmiHelper.MakeNSPath(serverName, nsName), connectOpts);
				
				mgmtObj = new ManagementClass(scope, 
												new ManagementPath(path),
												new ObjectGetOptions(null, 
																	true) //use amended
												);

				//NOTE: let's exercise the retrieved object to validate it
				//This will throw if object is invalid
				string classPath = mgmtObj.ClassPath.Path;
								

			}
			catch (Exception exc)
			{
				//MessageBox.Show(WMISys.GetString("WMISE_Exception", exc.Message, exc.StackTrace));
				throw (exc);
			}
		}

		
		/// <summary>
        ///     The object retrieves its serialization info.
        /// </summary>
        public WMIClassNode(SerializationInfo info, StreamingContext context) {
            
			try 
			{			

				path = info.GetString("Path");
				connectAs = info.GetString("ConnectAs");
				password = info.GetString("Password");

				//parse the path to get server, namespace and class name
				Int32 separ = path.IndexOf ("\\", 2);
				if (separ == -1)
				{
					//invalid path
					throw (new ArgumentException(WMISys.GetString("WMISE_InvalidPath", path), "Path"));
				}

				serverName = path.Substring(2, separ - 2);
				pathNoServer = path.Substring(separ + 1, path.Length - separ - 1);
						
				//split pathNoServer into namespace and classname parts (':' is the separator)
				Int32 colon = pathNoServer.IndexOf(':', 0);
				if (colon == -1)
				{
					//invalid path
					throw (new ArgumentException(WMISys.GetString("WMISE_InvalidPath", path), "Path"));
				}			
				nsName = pathNoServer.Substring(0,colon);
				className = pathNoServer.Substring(colon + 1, pathNoServer.Length - colon - 1);

				//Get and cache mgmtObj
				ConnectionOptions connectOpts = new ConnectionOptions(
												"", //locale
												this.connectAs, //username
												this.password, //password
												"", //authority
												ImpersonationLevel.Impersonate,
												AuthenticationLevel.Connect,
												true, //enablePrivileges
												null	//context
											);

				ManagementScope scope = (this.serverName == WmiHelper.DNS2UNC(Dns.GetHostName())) ?	
						new ManagementScope(WmiHelper.MakeNSPath(serverName, nsName)):
						new ManagementScope(WmiHelper.MakeNSPath(serverName, nsName), connectOpts);

				
				mgmtObj = new ManagementClass(scope, 
												new ManagementPath(path),
												new ObjectGetOptions(null, 
																	true) //use amended
												);

				//NOTE: let's exercise the retrieved object to validate it
				//This will throw if object is invalid (e.g., has been deleted
				// since devenv was run last time)
				string classPath = mgmtObj.ClassPath.Path;
                        
            }
            catch (Exception exc) {
				throw (exc);
            }
        }

		

        //
        // PROPERTIES
        //

        // <doc>
        // <desc>
        //     Returns icon for this node.
        // </desc>
        // </doc>
		
        public override Image Icon {
             get {
				
				if (icon == null)
				{						
					icon = WmiHelper.GetClassIconFromResource(this.pathNoServer, true, GetType());
					if (icon == null)
					{
						icon = WmiHelper.defaultClassIcon;
					}
				}				
				return icon;							
            }
        }

	
	/// <summary>
	/// Context menu for a class object contains static method names
	/// </summary>
	public override ContextMenuItem[] GetContextMenuItems() 
	{
		try 
		{	
			//System.Threading.Thread.CurrentThread.ApartmentState = ApartmentState.MTA;

			ManagementClass localObj = mgmtObj;
			MethodCollection methods = null;

			try
			{
				int methodCount = localObj.Methods.Count;
			}
			catch (Exception)
			{
				ConnectionOptions connectOpts = new ConnectionOptions(
					"", //locale
					this.connectAs, //username
					this.password, //password
					"", //authority
					ImpersonationLevel.Impersonate,
					AuthenticationLevel.Connect,
					true, //enablePrivileges
					null	//context
					);

				ManagementScope scope = (this.serverName == WmiHelper.DNS2UNC(Dns.GetHostName())) ?	
					new ManagementScope(WmiHelper.MakeNSPath(serverName, nsName)):
					new ManagementScope(WmiHelper.MakeNSPath(serverName, nsName), connectOpts);

				
				localObj = new ManagementClass(scope, 
					new ManagementPath(path),
					new ObjectGetOptions(null, 
					true) //use amended
					);

			}

			methods = localObj.Methods;
			/*
			string propNames = "";
			foreach (System.Management.Property prop in mgmtObj.Properties)
			{
				propNames += prop.Name + "\n";
			}
			MessageBox.Show(propNames);
			
			MessageBox.Show("class has " + mgmtObj.Properties.Count + " properties");

			string methNames = "";
			foreach (Method meth in methods)
			{
				methNames += meth.Name + "\n";
			}
			MessageBox.Show(methNames);

*/
			Project[] projects = VSUtils.GetProjects(GetNodeSite());
			bool enableCodeGen = false;
			if (projects != null && projects.Length != 0)
			{
				ICodeGenerator codeGen = VSUtils.MapProjectGuidToCodeGenerator(new Guid(projects[0].Kind));
				if (codeGen == null)
				{
					MessageBox.Show("codeGen is null, project is: " + projects[0].Kind);
				}
				enableCodeGen = (codeGen != null);
			}				
			
			ContextMenuItem[] theMenu = new ContextMenuItem[methods.Count + 2];
			
			//theMenu[0] = new ContextMenuItem("&View All Instances...", new EventHandler(OnExpandAll));
			//theMenu[1] = new ContextMenuItem("&Filter Instances...", new EventHandler(OnAddInstanceFilter));

			theMenu[0] = new ContextMenuItem(WMISys.GetString("WMISE_ClassNode_CreateNewInstance"), 
				new EventHandler(OnCreateNewInstance),
				false);

			theMenu[1] = new ContextMenuItem(WMISys.GetString("WMISE_ClassNode_GenerateWrapper"), 
				new EventHandler(OnGenerateWrapper),
				enableCodeGen);

			int i = 2;	

			//Retrieve static methods for the class and add them to context menu
			MethodCollection.MethodEnumerator methEnum = methods.GetEnumerator();		
			
			while (methEnum.MoveNext())
			{
				Method meth = methEnum.Current;
				
				if (WmiHelper.IsStaticMethod(meth) && WmiHelper.IsImplementedMethod(meth))
				{							
					
					//add method name to context menu
					theMenu[i] = new ContextMenuItem("&" + i.ToString() + " " + meth.Name + "...", //TODO: hotkey???
						new EventHandler(OnExecuteMethod));				
					i++;
				}
			}

			methEnum = null;

			return theMenu;
		}
			/*
		catch (ManagementException exc)
		{
			MessageBox.Show("ManagementException hr is " + exc.ErrorCode.ToString());
			MessageBox.Show(WMISys.GetString("WMISE_Exception", exc.Message, exc.StackTrace));

			return null;
		}
		*/
		catch (Exception exc)
		{
				
			MessageBox.Show(WMISys.GetString("WMISE_Exception", exc.Message, exc.StackTrace));
			return null;			
		}
		
    }
	public override bool CanDeleteNode()
	{
		return true;		
	}

	public override bool ConfirmDeletingNode()
	{
		DialogResult res = MessageBox.Show(WMISys.GetString("WMISE_ClassNode_RemovePrompt", className),
                                        /*SR.GetString("SE_MessageBoxTitle_ServerExplorer"), */ string.Empty,
										MessageBoxButtons.YesNo);
		return (res == DialogResult.Yes);
	}


        // <doc>
        // <desc>
        //     Returns label constant for this node.
        // </desc>
        // </doc>
        public override string Label {
             get {
                if (label == null || label.Length == 0) {
					label = className; 
					if (WmiHelper.UseFriendlyNames)
					{
						string strFriendly = WmiHelper.GetDisplayName(mgmtObj, this.connectAs, this.password);
						if (strFriendly != string.Empty)
						{
							label = strFriendly; 
						}
					}	
                }
                return label;
            }
            set {
            }
        }

        //
        // METHODS
        //

        // <doc>
        // <desc>
        //     Create instance nodes under this node.
        // </desc>
        // </doc>
        public override Node[] CreateChildren() {
	
		try
		{	
			GetInstancesOptions opts = new GetInstancesOptions(null, //context
															new TimeSpan(Int64.MaxValue), //timeout:30 sec
															50,		//block size
															false, //non-rewindable
															false, //return immediately
															true, //use amended
															true, //enumerate deep
															false //direct read
															);
															
																	
			ManagementObjectCollection instCollection = mgmtObj.GetInstances(opts);		
			ArrayList arNodes = new ArrayList(50);
		
			foreach (ManagementObject obj in instCollection)
			{
				arNodes.Add(new WMIInstanceNode(obj, 
												mgmtObj,
												this.connectAs,
												this.password));
			}	
				
			Node[] nodes = new Node[arNodes.Count];	

			arNodes.CopyTo(nodes);
	
			return nodes;
				
		}
		catch(Exception exc)
		{
			MessageBox.Show(WMISys.GetString("WMISE_Exception", exc.Message, exc.StackTrace));
			return null;
		}
			
        }

        // <doc>
        // <desc>
        //     This node is a singleton.
        // </desc>
        // </doc>
        public override int CompareUnique(Node node) {
			if (this.path == ((WMIClassNode)node).path)
			{
				return 0;
			}
			return Label.CompareTo(node.Label);
        }


	private void OnExpandAll(object sender, EventArgs e) {
 			
		try 
		{
			//TODO: this needs to be changed to do something more meaningful
			GetNodeSite().Expand();
			
		}
		catch(Exception exc)
		{
			MessageBox.Show(WMISys.GetString("WMISE_Exception", exc.Message, exc.StackTrace));
		}	
        }

	private void OnAddInstanceFilter(object sender, EventArgs e) {
 			
		try 
		{
			MessageBox.Show("Not implemented yet");
		}
		catch(Exception exc)
		{
			MessageBox.Show(WMISys.GetString("WMISE_Exception", exc.Message, exc.StackTrace));
		}	

    }

	/// <summary>
	/// Get component to be displayed in PB window
	/// </summary>
	public override Object GetBrowseComponent() 
	{	
		
		return new WMIObjectComponent(mgmtObj, mgmtObj);
    }


	/// <summary>
	/// Execute static method against WMI class
	/// </summary>
	/// <param name="sender"> </param>
	/// <param name="e"> </param>
	private void OnExecuteMethod(object sender, EventArgs e)
	{
		try 
		{
			//trim the ordinal prefix (all up to first space)
			//and 3 dots off the end of the context menu text to get method name
			String methName = ((ContextMenuItem)sender).Text.Substring(0, ((ContextMenuItem)sender).Text.Length - 3);
			int spaceIndex = methName.IndexOf(' ', 0);
			methName = methName.Substring(spaceIndex + 1);
		
			//get method object
			Method meth = ((ManagementClass)mgmtObj).Methods[methName];
			ExecuteMethodDialog dlg = new ExecuteMethodDialog(mgmtObj, meth, mgmtObj);
			DialogResult res = dlg.ShowDialog();

		}
		catch(Exception exc)
		{
			MessageBox.Show(WMISys.GetString("WMISE_Exception", exc.Message, exc.StackTrace));
		}	

	}

		/// <summary>
		/// Generates early-bound object wrapper 
		/// </summary>
		/// <param name="sender"> </param>
		/// <param name="e"> </param>
		private void OnGenerateWrapper (object sender, EventArgs e)
		{
			try 
			{
				//Get current Project:
				Project[] projects = VSUtils.GetProjects(GetNodeSite());
				if (projects == null || projects.Length == 0)
				{
					return;
				}				

				//This is an assumtion that's working so far.
				//TODO: verify if this is the right way to determine the startup project
				//in the solution:
				Project curProject = projects[0];

				string curProjSuffix = VSUtils.MapProjectGuidToSuffix(new Guid(curProject.Kind));
				if (curProjSuffix == string.Empty)
				{
					//neither a VB nor a CS project
					throw new Exception(WMISys.GetString("WMISE_Invalid_Project_Type_For_CodeGen"));
				}		

				ProjectItems projItems = curProject.ProjectItems;
				if (projItems == null)
				{
					throw new Exception(WMISys.GetString("WMISE_Could_Not_Add_File_to_Project"));
				}			
				
				Guid curProjectType = new Guid(curProject.Kind);
				string wrapperFileName = className + "."+ curProjSuffix;

				if(!mgmtObj.GetStronglyTypedClassCode(VSUtils.MapProjectGuidToCodeLanguage(curProjectType),
						Path.GetTempPath() + "\\" + wrapperFileName))
				{
					throw new Exception(WMISys.GetString("WMISE_Code_Generation_Failed"));
				}			
				
				ProjectItem newItem = projItems.AddFromFileCopy(Path.GetTempPath() + "\\" + wrapperFileName);
				
				if (newItem == null)
				{
					throw new Exception(WMISys.GetString("WMISE_Could_Not_Add_File_to_Project"));
				}
				File.Delete(Path.GetTempPath() + "\\" + wrapperFileName);			

			}
			catch (Exception exc)
			{
				MessageBox.Show(WMISys.GetString("WMISE_Exception", exc.Message, exc.StackTrace));
			}	
		}

	/// <summary>
	/// Create new instance of the class
	/// </summary>
	/// <param name="sender"> </param>
	/// <param name="e"> </param>
	private void OnCreateNewInstance(object sender, EventArgs e)
	{
		try 
		{
			if (this.GetNodeSite().GetChildCount() == 0)
			{
				Node[] children = this.CreateChildren();
				for (int i = 0; i < children.Length; i++)
				{
					GetNodeSite().AddChild(children[i]);
				}
			}
						
			//spawn new object and add it as a child node
			ManagementObject newInst = ((ManagementClass)mgmtObj).CreateInstance();
			WMIInstanceNode childNode = new WMIInstanceNode(newInst, mgmtObj, this.connectAs, this.password);
			childNode.Label = WMISys.GetString("WMISE_ClassNode_NewInstanceLbl", this.label);
            GetNodeSite().AddChild(childNode);
			childNode.GetNodeSite().Select();
			
		
		}
		catch(Exception exc)
		{
			MessageBox.Show(WMISys.GetString("WMISE_Exception", exc.Message, exc.StackTrace));
		}	

	}

	
	    /// <summary>
        ///      To determine whether this node supports drag and drop.
        /// </summary>
        /// <returns>
        ///      TRUE to indicate ProcessNode supports drag and drop.
        /// </returns>
        public override bool HasDragComponents() {
            return false;	//disable d&d for Beta1
        }

		//disable d&d for Beta1
		/*
		public override IComponent[] CreateDragComponents(IDesignerHost designerHost) {
			Object comp = null;

			
			
			//trim the ordinal prefix (all up to first space)

			comp  = new WMIObjectComponent(wmiObj);

			return new IComponent[] {(IComponent)comp};
        }
		*/

	/// <summary>
    ///     The object should write the serialization info.
    /// </summary>
    public virtual void GetObjectData(SerializationInfo si, StreamingContext context) {
		si.AddValue("Path", path);
		si.AddValue("ConnectAs", this.connectAs);
		si.AddValue("Password", this.password);
    }

	
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vside\servexpl\wmiobjectgrid.cs ===
namespace Microsoft.VSDesigner.WMI 
{

	using System;
	using System.ComponentModel;
	//using System.Core;
	using System.Windows.Forms;
	using System.Runtime.InteropServices;
	using System.Drawing;
	using System.Management;
	using System.Collections;

	/// <summary>
	/// These filters define which properties will be displayed
	/// </summary>
	internal class PropertyFilters
	{
		private bool hideSystem = false;
		private bool hideInherited = false;

		public PropertyFilters(bool hideSystemIn, bool hideInheritedIn)
		{
			hideSystem = hideSystemIn;
			hideInherited = hideInheritedIn;			
		}

		public bool HideSystem
		{
			get
			{
				return hideSystem;				
			}
			set 
			{ lock (this)
			  {
				  hideSystem = value;			
			  }					
			}
		}

		public bool HideInherited
		{
			get
			{
				return hideInherited;
			}
			set 
			{
				lock (this)
				{
					hideInherited = value;
				}
			}
		}

		public bool ShowAll
		{
			get
			{
				return (!hideInherited && !hideSystem);
			}
			set
			{
				lock (this)
				{
					hideInherited = false;
					hideSystem = false;                				
				}
			}
		}
		
	}


	/// <summary>
	/// These filters define whether changing/adding/deleting properties is allowed
	/// </summary>
	internal enum GridMode
	{
		ViewMode,	//properties and valued are displayed for viewing only and are not modifiable
		LocalEditMode,	//user can modify values, but changes are not committed: used in query builder
		EditMode,	//user can modify values and changes are committed to WMI
		DesignMode	//user can change/add/delete properties; changes are committed (names and values)
	}


	internal class WMIObjectGrid : DataGrid
	{
		private void InitializeComponent ()
		{
		}
		
		private ManagementBaseObject mgmtObj = null;
		private PropertyFilters propFilters = new PropertyFilters(false, false);
		private GridMode gridMode = GridMode.ViewMode;

		private bool showOperators = false;
		private bool showOrigin = false;
		private bool showKeys = false;
		private bool showSelectionBoxes = false;
		private bool showValues = true;
		private bool expandEmbedded = false;
		private bool showEmbeddedObjValue = true; //NOTE: this overrides showValues


		public WMIObjectGrid(ManagementBaseObject mgmtObjIn, 
							PropertyFilters propFiltersIn,
							GridMode gridModeIn,
							bool showOperatorsIn,
							bool showOriginIn,
							bool showKeysIn,
							bool showSelectionBoxesIn,
							bool showValuesIn,
							bool expandEmbeddedIn,
							bool showEmbeddedObjValueIn)
		{	
			try
			{

				if (mgmtObjIn == null)
				{
					throw (new ArgumentNullException("mgmtObjIn"));
				}

				mgmtObj = mgmtObjIn;
				propFilters = propFiltersIn;
				gridMode = gridModeIn;

				showOperators = showOperatorsIn;
				showOrigin = showOriginIn;
				showKeys = showKeysIn;
				showSelectionBoxes = showSelectionBoxesIn;
				showValues = showValuesIn;
				expandEmbedded = expandEmbeddedIn;
				showEmbeddedObjValue = showEmbeddedObjValueIn;

				Initialize();		

			}

			catch (Exception exc)
			{
					MessageBox.Show(WMISys.GetString("WMISE_Exception", exc.Message, exc.StackTrace));
			}
		}

		
		public ManagementBaseObject WMIObject
		{
			set
			{
				if (value == null)
				{
					throw (new ArgumentNullException("value"));
				}
				mgmtObj = value;
				ReInit();			
			}
			get
			{
				return mgmtObj;
			}
		}

		public PropertyFilters CurrentPropertyFilters
		{
			set
			{
				propFilters = value;
				ReInit();			
			}
			get
			{
				return propFilters;
			}
		}
		/// <summary>
		/// This property controls whether inherited object properties are displayed by the grid
		/// </summary>
		public bool ShowInherited
		{
			set
			{
				if (value == true && propFilters.HideInherited)
				{
					//need to add inherited properties
					((WMIObjectPropertyTable)DataSource).AddInheritedProperties();

				}
				if (value == false && !propFilters.HideInherited)
				{
					//need to remove inherited properties
					((WMIObjectPropertyTable)DataSource).RemoveInheritedProperties();
				}

				//update propFilters
				propFilters.HideInherited = !value;				
			}
			get
			{
				return !propFilters.HideInherited;				
			}
		}

		/// <summary>
		/// This property controls whether WMI system properties are displayed by the grid
		/// </summary>
		public bool ShowSystem
		{
			set
			{
				if (value == true && propFilters.HideSystem)
				{
					//need to add  system properties
					((WMIObjectPropertyTable)DataSource).AddSystemProperties();
				}

				if (value == false && !propFilters.HideSystem)
				{
					//need to remove system properties
					((WMIObjectPropertyTable)DataSource).RemoveSystemProperties();
				}

				//update propFilters
				propFilters.HideSystem = ! value;				
			}
			get
			{
				return !propFilters.HideSystem;				
			}
		}


		public GridMode CurrentGridMode
		{
			set
			{
				gridMode = value;
				ReInit();			
			}
			get
			{
				return gridMode;
			}
		}

		public void AcceptChanges ()
		{            		
			if (DataSource != null)
			{
				DataGridCell curCell = this.CurrentCell;

				((WMIObjectPropertyTable)DataSource).SetPropertyValue(curCell.RowNumber, this[curCell].ToString());

				((WMIObjectPropertyTable)DataSource).AcceptChanges();				
			}		
		}

		public bool CommitChanges (PutOptions putOptions)
		{
			try
			{
				if (DataSource == null ||
					mgmtObj == null)
				{
					return true;
				}
				((WMIObjectPropertyTable)DataSource).AcceptChanges();


				((ManagementObject)mgmtObj).Put(putOptions);
				return true;
			}

			catch (Exception exc)
			{
				MessageBox.Show(WMISys.GetString("WMISE_Exception", exc.Message, exc.StackTrace));
				return false;
			}
		}

		private void Initialize ()
		{
			try
			{
				if (mgmtObj == null)
				{
					throw (new Exception(WMISys.GetString("WMISE_ObjGrid_InitFailed")));
				}	

				if (DataSource != null)
				{
					DataSource = null;
				}

				DataSource = new WMIObjectPropertyTable(mgmtObj,
														propFilters,
														gridMode,
														showOperators,
														showOrigin,
														showKeys, 
														showSelectionBoxes,
														showValues,
														expandEmbedded,
														showEmbeddedObjValue);

				this.LostFocus += new EventHandler(this.OnLeftGrid);
				this.Leave += new EventHandler(this.OnLeftGrid);

				//this.add_CurrentCellChange(new EventHandler(this.OnCurrentCellChange));

				/*
				//make all columns same width
				DataGridColumn[] cols = this.GridColumns.All;
				for (int i = 0; i < cols.Length; i ++)
				{
					cols[i].Width = this.Width / cols.Length;
				}
				*/		
			}

			catch (Exception exc)
			{
				MessageBox.Show(WMISys.GetString("WMISE_Exception", exc.Message, exc.StackTrace));
			}
		}


		private void ReInit ()
		{
			try
			{
				//TODO: cleanup
				DataSource = null;
				Initialize();
				
			}
			catch (Exception exc)
			{
					MessageBox.Show(WMISys.GetString("WMISE_Exception", exc.Message, exc.StackTrace));
			}
		}	

	protected void OnLeftGrid(object sender, EventArgs e) 
	{
		
		//AcceptChanges();
	}
		

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vside\servexpl\wmiobjectpropertytable.cs ===
namespace Microsoft.VSDesigner.WMI 
{
	using System;
	using System.ComponentModel;
	//using System.Core;
	using System.Windows.Forms;
	using System.Runtime.InteropServices;
	using System.Drawing;
	using System.Management;
	using System.Collections;
	using System.Data;

	internal enum ComparisonOperators 
	{
		Equals = 0,
		NotEquals,
		LessThan,
		LessThanOrEquals,
        GreaterThan,
		GreaterThanOrEquals        		
	}

    
	
	internal class WMIObjectPropertyTable : DataTable
	{
		private void InitializeComponent ()
		{
		}	
			
		private ManagementBaseObject mgmtObj = null;

		private PropertyFilters propFilters = new PropertyFilters(false, false);
		private GridMode gridMode = GridMode.ViewMode;

		private DataColumn propOrigin = null;
		private DataColumn propIsKey = null;

		private DataColumn propNameColumn = null;
		private DataColumn propTypeColumn = null;
		private DataColumn propValueColumn = null;	

		private DataColumn propDescrColumn = null;	
		private DataColumn operatorColumn = null;

		private DataColumn selectionBoxColumn = null;

		private bool showOperators = false;
		private bool showOrigin = false;
		private bool showKeys = false;
		private bool showSelectionBoxes = false;
		private bool showValues = true;
		private bool expandEmbedded = false;
		private bool showEmbeddedObjValue = true; //NOTE: this overrides showValues

		private Hashtable rowPropertyMap = new Hashtable(50);

		public WMIObjectPropertyTable(ManagementBaseObject mgmtObjIn,
									PropertyFilters propFiltersIn,
									GridMode gridModeIn,
									bool showOperatorsIn,
									bool showOriginIn,
									bool showKeysIn,
									bool showSelectionBoxesIn,
									bool showValuesIn,
									bool expandEmbeddedIn,
									bool showEmbeddedObjValueIn)
		{	
			try
			{

				if (mgmtObjIn == null)
				{
					throw (new ArgumentNullException("mgmtObjIn"));
				}

				mgmtObj = mgmtObjIn;
				propFilters = propFiltersIn;
				gridMode = gridModeIn;

				showOperators = showOperatorsIn;
				showOrigin = showOriginIn;
				showKeys = showKeysIn;
				showSelectionBoxes = showSelectionBoxesIn;
				showValues = showValuesIn;
				expandEmbedded = expandEmbeddedIn;
				showEmbeddedObjValue = showEmbeddedObjValueIn;

				Initialize();			
			}

			catch (Exception exc)
			{
				MessageBox.Show(WMISys.GetString("WMISE_Exception", exc.Message, exc.StackTrace));
			}
		}

        
		public ManagementBaseObject WMIObject
		{	
			get
			{
				return mgmtObj;
			}
		}

		/// <summary>
		/// Creates and adds to grid a single row corresponding to a single property. Can be called recursively for embedded
		/// objects.
		/// </summary>
		/// <param name="prop"> </param>
		/// <param name="namePrefix">This is used for embedded objects, so that the propertyof an embedded object
		/// appears to have name of form "Parent.Child" </param>
		private DataRow CreatePropertyRow( Property prop, string namePrefix)
		{
			if (prop == null)
			{
				return null;
			}

			if (propFilters.HideInherited && !prop.IsLocal)
			{
				return null;	//skip this property
			}	


			DataRow propRow = NewRow();
			propRow[propNameColumn] = namePrefix + prop.Name;			

			propRow[propTypeColumn] = CimTypeMapper.ToString(prop.Type);

			if (showOperators)
			{
				//TODO: initialize drop-down. How: in Beta2, a DataGridColumnStyle derived class
				//can be added, DataGridComboBoxColumn. Ask urtuser if they are planning to
				//to add one themselves
				
				propRow[operatorColumn] = string.Empty;
			}	

			if (prop.Type == CimType.Object)
			{
				if ((showValues || showEmbeddedObjValue) 
					&& prop.Value is ManagementBaseObject)
				{
					if (showOperators)
					{
						propRow[operatorColumn] = "ISA";
					}
					propRow[propValueColumn] = ((ManagementBaseObject)prop.Value).SystemProperties["__CLASS"].Value.ToString();
				}
				else
				{
					propRow[propValueColumn] = string.Empty;									
				}
			}
			else
			{
				if (showValues)
				{
					propRow[propValueColumn] = prop.Value;
				}
				else
				{				
					propRow[propValueColumn] = string.Empty;									
				}
			}
			//propRow[propDescrColumn] = WmiHelper.GetPropertyDescription(prop, wmiObj);
							

			//set property origin column
			
			if (showOrigin)
			{
				if (prop.IsLocal)
				{
					propRow[propOrigin] = true;
				}
				else
				{
					propRow[propOrigin] = false;
				}
			}
			
			if (showKeys)
			{
				propRow[propIsKey] = WmiHelper.IsKeyProperty(prop);
			}

			//grey selectionBoxColumn for expanded embedded object properties:
			if (propRow[propNameColumn].ToString().IndexOf(".") > 0)
			{
				//NOTE: this doesn't work!!! is there a way to disable input on an individual cell?
				propRow.SetUnspecified(selectionBoxColumn);
			}

			
			Rows.Add (propRow);

			if (prop.Type == CimType.Object && expandEmbedded)
			{
				if (prop.Value != null && prop.Value is ManagementBaseObject)
				{
					ManagementBaseObject embeddedObj = (ManagementBaseObject)prop.Value;
					foreach (Property embeddedProp in embeddedObj.Properties)
					{
						CreatePropertyRow(embeddedProp, prop.Name + ".");
					}
				}
			}

			rowPropertyMap.Add(propRow, prop);
					
			return propRow;
			
		}


		private void Initialize ()
		{
			try
			{

				try
				{
					this.TableName = mgmtObj.ClassPath.ClassName;
				}
				catch (Exception)
				{
					//if mgmtObj is a newly created instance of an abstract class,
					//ClassPath will be unavailable.  Don't set TableName in this case.
				}
				
				propNameColumn = new DataColumn (WMISys.GetString("WMISE_PropTable_ColumnName")); 
												
				//propNameColumn.AllowNull = false;
				propNameColumn.Unique = true;
				propNameColumn.DataType = typeof(string);
				
				propTypeColumn = new DataColumn (WMISys.GetString("WMISE_PropTable_ColumnType"));
				//propTypeColumn.AllowNull = false;
				propTypeColumn.DataType = typeof(string);
				
				propValueColumn = new DataColumn (WMISys.GetString("WMISE_PropTable_ColumnValue"));
				propValueColumn.DefaultValue = null;

				propDescrColumn = new DataColumn(WMISys.GetString("WMISE_PropTable_ColumnDescription"));
				propDescrColumn.ReadOnly = true;
				propDescrColumn.DefaultValue = string.Empty;
				propDescrColumn.DataType = typeof(string);

				if (showOperators)
				{
					operatorColumn = new DataColumn(WMISys.GetString("WMISE_PropTable_ColumnComparison"), 
													typeof(/*ComparisonOperators*/ string));
					operatorColumn.DefaultValue = string.Empty;
					operatorColumn.DataType = typeof(string);
					operatorColumn.ReadOnly = false;
				}
				
				/*
				ValueEditor dropDownEditor = new ValueEditor();
				dropDownEditor.Style = ValueEditorStyles.DropdownArrow;
				operatorColumn.DataValueEditorType = dropDownEditor.GetType();
				*/


				if (showKeys)
				{
					propIsKey = new DataColumn (WMISys.GetString("WMISE_PropTable_ColumnIsKey"), typeof(Boolean));
					//propIsKey.AllowNull = false;
					propIsKey.DefaultValue = false;
				}				

				if (showOrigin)
				{
					propOrigin = new DataColumn (WMISys.GetString("WMISE_PropTable_ColumnIsLocal"), typeof(Boolean));				              				
					//propOrigin.AllowNull = false;
					propOrigin.DefaultValue = true;
				}		

				if (showSelectionBoxes)
				{				
					selectionBoxColumn = new DataColumn(WMISys.GetString("WMISE_PropertyInResultset"), 
														typeof (bool));
					//selectionBoxColumn.AllowNull = false;
					selectionBoxColumn.DefaultValue = true;
				}

				//set read/write permissions on columns
				//Note that DefaultView takes care of the rest of the restrictions
				//(see below)
				if (gridMode == GridMode.EditMode ||
					gridMode == GridMode.LocalEditMode)
				{					
					propNameColumn.ReadOnly = true;
					propTypeColumn.ReadOnly = true;
					propValueColumn.ReadOnly = false;

					if (showOrigin)
					{
						propOrigin.ReadOnly = true;
					}
					if (showKeys)
					{
						propIsKey.ReadOnly = true;
					}				
				}
				
				if (gridMode == GridMode.DesignMode && showOrigin)
				{
					propOrigin.ReadOnly = true;	
				}
                
				Columns.Add(propNameColumn);
				Columns.Add(propTypeColumn);
				if (showOperators)
				{
					//operatorColumn.DataValueEditorType = typeof(OperatroDataColumnEditor);
					operatorColumn.ReadOnly = false;
					Columns.Add(operatorColumn);
				}

				Columns.Add(propValueColumn);
				//Columns.Add(propDescrColumn);

				if (showOrigin)
				{
					Columns.Add(propOrigin);
				}
				if (showKeys)
				{
					Columns.Add(propIsKey);
				}
				if (showSelectionBoxes)
				{
					Columns.Add (selectionBoxColumn);
				}	
                			
			
				foreach (Property prop in mgmtObj.Properties)
				{
					CreatePropertyRow(prop, string.Empty);					
				}	
				//Add system properties here (if PropertyFilters.ShowAll)
				if (!propFilters.HideSystem)
				{
					foreach (Property sysProp in mgmtObj.SystemProperties)
					{
						CreatePropertyRow(sysProp, string.Empty);

					}
				}

				this.CaseSensitive = false;
				this.RowChanged += new DataRowChangeEventHandler(this.RowChangedEventHandler);
				this.RowChanging += new DataRowChangeEventHandler(this.RowChangingEventHandler);


				DataView view = this.DefaultView;
				switch (gridMode)
				{
					case (GridMode.ViewMode):
						{
							view.AllowEdit = false; //wmi raid 2866?
							view.AllowDelete = false;
							view.AllowNew = false;
							break;
						}
					case (GridMode.EditMode):
						{
							view.AllowEdit = true;
							view.AllowDelete = false;
							view.AllowNew = false;
							break;
						}
					case (GridMode.LocalEditMode) :
						{
							view.AllowEdit = true;
							view.AllowDelete = false;
							view.AllowNew = false;
							break;							
						}
					case (GridMode.DesignMode):
						{
							view.AllowEdit = true;
							view.AllowDelete = true;
							view.AllowNew = true;
							break;
						}	
				}

				
			}

			catch (Exception exc)
			{
					MessageBox.Show(WMISys.GetString("WMISE_Exception", exc.Message, exc.StackTrace));
			}
		}


		
		protected void RowChangedEventHandler(object sender,
							DataRowChangeEventArgs e)
		{
			try
			{
			
				DataRow RowAffected = e.Row;
				switch (e.Action)
				{
					case(DataRowAction.Add):
					{
						/*
						MessageBox.Show("Cannot Add Rows. Deleting...");
						RowAffected.Delete();
						*/
						break;
						
					}
					case(DataRowAction.Change):
					{
						DataRow row = e.Row;
						
						if (gridMode == GridMode.EditMode)
						{
							//this can only be value change
							Property propAffected = (Property)this.rowPropertyMap[row];

							Object newValue = WmiHelper.GetTypedObjectFromString(propAffected.Type,
												row[propValueColumn].ToString());

									
							propAffected.Value = newValue;
							
						}
						
						//possibly handle other modes here

						break;
					}
					case(DataRowAction.Commit):
					{
						//MessageBox.Show("DataRowAction.Commit");
						break;
					}
					case(DataRowAction.Delete):
					{
						MessageBox.Show("Cannot delete nodes.Adding back...");
						RowAffected.CancelEdit();
						break;
					}
					case(DataRowAction.Nothing):
					{
						MessageBox.Show("DataRowAction.Nothing");
						break;
					}
					case(DataRowAction.Rollback):
					{
						MessageBox.Show("DataRowAction.Rollback");
						break;
					}						
				}			
			}
			catch (Exception exc)
			{
					MessageBox.Show(WMISys.GetString("WMISE_Exception", exc.Message, exc.StackTrace));
			}

		}	

		
			
		protected void RowChangingEventHandler(object sender,
								DataRowChangeEventArgs e)
		{
			try
			{

				DataRow row = e.Row;
				switch (e.Action)
				{
					case(DataRowAction.Add):
					{
						//throw (new Exception("Cannot add rows"));	
						break;
						
					}
					case(DataRowAction.Change):
					{
						//if this is an object, datetime, enum or ref property changing,
						//bring up custom UI for editing these!!!!
						if (gridMode == GridMode.EditMode)
						{
							//this can only be value change
							Property propAffected = (Property)this.rowPropertyMap[row]; //mgmtObj.Properties[row[propNameColumn].ToString()];

							if (propAffected.Type == CimType.Object)
							{
								////MessageBox.Show("should bring up custom type editor for objects");
							}

							if (propAffected.Type == CimType.Reference)
							{
								//MessageBox.Show("should bring up custom type editor for refs");
							}

							if (propAffected.Type == CimType.DateTime)
							{
								//MessageBox.Show("should bring up custom type editor for datetime");
							}

							if (WmiHelper.IsValueMap(propAffected))
							{
								//MessageBox.Show("should bring up custom type editor for enums");
							}
							
						}
						break;
					}
					case(DataRowAction.Commit):
					{
						//MessageBox.Show("DataRowAction.Commit");
						break;
					}
					case(DataRowAction.Delete):
					{
						throw (new Exception("Cannot delete rows"));
										}
					case(DataRowAction.Nothing):
					{
						MessageBox.Show("DataRowAction.Nothing");
						break;
					}
					case(DataRowAction.Rollback):
					{
						MessageBox.Show("DataRowAction.Rollback");
						break;
					}						
				}			
			}
			catch (Exception exc)
			{
					MessageBox.Show(WMISys.GetString("WMISE_Exception", exc.Message, exc.StackTrace));
					throw(exc);
			}
		}	

		internal void SetPropertyValue (int rowNum, String val) 
		{	
	        try
			{
			
				DataRow row = this.Rows[rowNum];
			
				Property propAffected = (Property)this.rowPropertyMap[row]; //mgmtObj.Properties[row[propNameColumn].ToString()];

				Object newValue = WmiHelper.GetTypedObjectFromString(propAffected.Type,
												val);
								
				propAffected.Value = newValue;               

				
			}
			catch (Exception exc)
			{
				MessageBox.Show(WMISys.GetString("WMISE_Exception", exc.Message, exc.StackTrace));
				throw (exc);
			}
		}

		public string WhereClause 
		{
			get 
			{
				if (!showOperators || Rows.Count == 0)
				{
					return  string.Empty;
				}
				const String strWhere = " WHERE ";
				const String strAnd = " AND ";
				
				String clause = strWhere;
				for (int i = 0; i < Rows.Count; i++)
				{
					DataRow curRow = Rows[i];

                    Property curProp = (Property)rowPropertyMap[curRow]; //mgmtObj.Properties[curRow[propNameColumn].ToString()];

					if (curRow[propValueColumn].ToString() == "")
					{
						continue;
					}

					clause += curRow[propNameColumn] + " " +
							  curRow[operatorColumn] + " ";

					//if the property is a string, datetime or object,
					//put quotes around the value
					if (curProp.Type == CimType.DateTime ||
						curProp.Type == CimType.Object ||
						curProp.Type == CimType.String)	//any others?
					{
						 clause += "\"" + curRow[propValueColumn] + "\"" + strAnd;
					}
					else
					{
                        clause += curRow[propValueColumn] + strAnd;				
					}
				}

				if (clause == strWhere)
				{
					return string.Empty;
				}
				
				//get rid of the last " AND "
				if (clause.Substring (clause.Length - strAnd.Length, strAnd.Length) == strAnd)
				{
					clause = clause.Substring(0, clause.Length - strAnd.Length);
				}

				return clause;				
			}

		}

		public void AddSystemProperties()
		{			
			if (!propFilters.HideSystem)
			{
				//already there
				return;
			}
			propFilters.HideSystem  = false;

			foreach (Property sysProp in mgmtObj.SystemProperties)
			{
				CreatePropertyRow(sysProp, string.Empty);
			}						
		}

		public void RemoveSystemProperties()
		{ 
			if (propFilters.HideSystem)
			{
				//already not there
				return;
			}
			propFilters.HideSystem  = true;

			ArrayList forRemoval = new ArrayList(this.Rows.Count);

			foreach (DataRow thisRow in this.Rows)
			{
				if (thisRow[propNameColumn].ToString().StartsWith("__"))
				{
					forRemoval.Add(thisRow);					
				}			
			}

			for (int i = 0; i < forRemoval.Count; i++)
			{
				this.Rows.Remove((DataRow)forRemoval[i]);
				this.rowPropertyMap.Remove((DataRow)forRemoval[i]);
			}							
			
		}

		public void AddInheritedProperties()
		{
			if (!propFilters.HideInherited)
			{
				//already there
				return;
			}

			propFilters.HideInherited = false;			

			foreach (Property curProp in mgmtObj.Properties)
			{
				if (!curProp.IsLocal)
				{
					CreatePropertyRow(curProp, string.Empty);
				}
			}

		}

	/// <summary>
	/// 
	/// </summary>
		public void RemoveInheritedProperties()
		{

			if (propFilters.HideInherited)
			{
				//already not there
				return;
			}

			propFilters.HideInherited = true;

			ArrayList forRemoval = new ArrayList(this.Rows.Count);

			foreach (DataRow thisRow in this.Rows)
			{
				//special-case expanded embedded properties
				//if a property name contains a dot, that means
				//this is an expanded embedded property name
				if (thisRow[propNameColumn].ToString().IndexOf(".") >= 0)
				{
					continue;
				}

				Property curProp = (Property)this.rowPropertyMap[thisRow]; //mgmtObj.Properties[thisRow[propNameColumn].ToString()];
				if (!curProp.IsLocal)
				{
					forRemoval.Add(thisRow);					
				}			
			}

			for (int i = 0; i < forRemoval.Count; i++)
			{
				this.Rows.Remove((DataRow)forRemoval[i]);
				this.rowPropertyMap.Remove((DataRow)forRemoval[i]);
			}		
			
		}

	}	

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vside\servexpl\wmiobjectcomponent.cs ===
namespace Microsoft.VSDesigner.WMI {
	using System.Runtime.Serialization;
	using System;
	using System.Diagnostics;
	using System.Collections;
	using System.ComponentModel;
	using System.Windows.Forms;
	using System.Management;

    // <doc>
    // <desc>
    //     This represents the wmi class information for the Property Browser window
    // </desc>
    // </doc>
	
    internal class WMIObjectComponent : Component, ICustomTypeDescriptor {
		private void InitializeComponent ()
		{
		}

		internal enum WMISystemProperties
		{
			__CLASS = 0,
			__DYNASTY,
			__DERIVATION,
			__GENUS,
			__NAMESPACE,
			__RELPATH,
			__PATH,
			__SERVER,
			__SUPERCLASS,
			__PROPERTY_COUNT
		}

		const int NUM_OF_SYSTEM_PROPS = 10;
		
		//fields
		protected string CLASS = String.Empty;
		protected string DYNASTY = String.Empty;
		protected object[] DERIVATION = null;
		protected int GENUS = 0;
		protected string NAMESPACE = String.Empty;
		protected string RELPATH = String.Empty;
		protected string PATH = String.Empty;
		protected string SERVER = String.Empty;
		protected string SUPERCLASS = String.Empty;
		protected int PROPERTY_COUNT = 0;

		protected Hashtable SystemPropertyDictionary = null;

		protected ManagementObject mgmtObj = null;
		protected ManagementObject mgmtClassObj = null;

		private static AttributeCollection emptyMemberAttrCollection = 
			new AttributeCollection(new Attribute[0]);
		private static EventDescriptorCollection emptyEvtDescrCollection = 
			new EventDescriptorCollection(new EventDescriptor[0]);

		private bool IsNewInstance = false;

		// <doc>
		// <desc>
		//     Ctor from SWbemObject
		// </desc>
		// </doc>
		public WMIObjectComponent(ManagementObject mgmtObjIn, 
									ManagementObject mgmtClassObjIn)
		{
			if (mgmtObjIn == null)
			{
				throw (new ArgumentNullException("mgmtObjIn"));
			}

			mgmtObj = mgmtObjIn;
			mgmtClassObj = mgmtClassObjIn;

			SystemPropertyDictionary = new Hashtable(NUM_OF_SYSTEM_PROPS);

			Initialize ();		
		}

		/// <summary>
		/// note that Properties_ on ISWbemObject doesn't return system properties,
		/// so need to reconstruct them:  __SERVER, __PATH, __GENUS are available through
		/// SWbemObjectPath; __DYNASTY, __DERIVATION can be accessed through SWbemObjct.Derivation_
		/// </summary>
		private void Initialize()
		{					
			
			try
			{
				ManagementPath path = mgmtObj.Path;
				if (path.IsClass)
				{
					GENUS = 1;
				}
				else	//instance
				{
					GENUS = 2;							
					
				}

				
				SystemPropertyDictionary.Add("__GENUS", GENUS);
				
				CLASS = path.ClassName;
				SystemPropertyDictionary.Add("__CLASS", CLASS);

				NAMESPACE = path.NamespacePath;
				SystemPropertyDictionary.Add("__NAMESPACE", NAMESPACE);

				PATH = path.Path;
				SystemPropertyDictionary.Add("__PATH", PATH);

				RELPATH = path.RelativePath;
				SystemPropertyDictionary.Add("__RELPATH", RELPATH);

				SERVER = path.Server;
				SystemPropertyDictionary.Add("__SERVER", SERVER);
				
				//get PROPERTY_COUNT
				PropertyCollection props = mgmtObj.Properties;
				PropertyCollection.PropertyEnumerator eProps = props.GetEnumerator();
				while (eProps.MoveNext())
				{
					PROPERTY_COUNT++;
				}
				SystemPropertyDictionary.Add("__PROPERTY_COUNT", PROPERTY_COUNT);


				//get inheritance-related properties
				
				Object[] oaDerivation = (Object[])mgmtObj.SystemProperties["__DERIVATION"].Value;			
				if (oaDerivation.Length == 0)
				{									
					DYNASTY = CLASS;
				}
				else
				{
					SUPERCLASS = oaDerivation[0].ToString();
					DYNASTY = oaDerivation[oaDerivation.Length - 1].ToString();		
				}				
				
				SystemPropertyDictionary.Add("__SUPERCLASS", SUPERCLASS);
				SystemPropertyDictionary.Add("__DYNASTY", DYNASTY);
	
				DERIVATION = new string[oaDerivation.Length];				
				Array.Copy(oaDerivation, DERIVATION, oaDerivation.Length);	
				SystemPropertyDictionary.Add("__DERIVATION", DERIVATION);

				IsNewInstance = ((GENUS == 2) && (PATH == string.Empty));				

									
			}
			catch(Exception exc)
			{
				MessageBox.Show(WMISys.GetString("WMISE_Exception", exc.Message, exc.StackTrace));
			}		

		}

		/// <summary>
		/// Call when a transacted commit of properties is required (e.g., when saving a new instance)
		/// </summary>
		internal bool Commit() 
		{
			try
			{
					
				PutOptions putOpts = new PutOptions(null,
													true,	//use amended qualifiers
													PutType.UpdateOrCreate);
	
				mgmtObj.Put(putOpts);
				return true;
			}
			catch (Exception exc)
			{
				MessageBox.Show(WMISys.GetString("WMISE_ObjComp_PutFailed", PATH, exc.Message));
				return false;
			}		
		}



 	/// <summary>
        ///     Retrieves an array of member attributes for the given object.
        /// </summary>
        /// <returns>
        ///     the array of attributes on the class.  
        /// </returns>
        AttributeCollection ICustomTypeDescriptor.GetAttributes() {
            return emptyMemberAttrCollection;	//TODO: return qualifiers here???
        }

        /// <summary>
        ///     Retrieves the class name for this object.  If null is returned,
        ///     the type name is used.
        /// </summary>
        /// <returns>
        ///     The class name for the object, or null if the default will be used.
        /// </returns>
        string ICustomTypeDescriptor.GetClassName() {
            return CLASS;
        }

        /// <summary>
        ///     Retrieves the name for this object.  If null is returned,
        ///     the default is used.
        /// </summary>
        /// <returns>
        ///     The name for the object, or null if the default will be used.
        /// </returns>
        string ICustomTypeDescriptor.GetComponentName() {
            return null;
        }

        /// <summary>
        ///      Retrieves the type converter for this object.
        /// </summary>
        /// <returns>
        ///     A TypeConverter.  If null is returned, the default is used.
        /// </returns>
        TypeConverter ICustomTypeDescriptor.GetConverter() {
            return null;
        }

        /// <summary>
        ///     Retrieves the default event.
        /// </summary>
        /// <returns>
        ///     the default event, or null if there are no
        ///     events
        /// </returns>
        EventDescriptor ICustomTypeDescriptor.GetDefaultEvent() {
            return null;
        }


        /// <summary>
        ///     Retrieves the default property.
        /// </summary>
        /// <returns>
        ///     the default property, or null if there are no
        ///     properties
        /// </returns>
        PropertyDescriptor ICustomTypeDescriptor.GetDefaultProperty() {

			//returns first property
			PropertyCollection props = mgmtObj.Properties;
			if (props.Count == 0)
			{
				return new WMISystemPropertyDescriptor(mgmtObj,
							"__CLASS",
							(string)SystemPropertyDictionary["__CLASS"]);				
			}

			string defPropName = "";
			foreach (Property prop in props)
			{
				defPropName = prop.Name;
				break;
			}

			return new WMIPropertyDescriptor(mgmtObj,
											mgmtClassObj,											
											defPropName,
											!IsNewInstance);
        }

        /// <summary>
        ///      Retrieves the an editor for this object.
        /// </summary>
        /// <returns>
        ///     An editor of the requested type, or null.
        /// </returns>
        object ICustomTypeDescriptor.GetEditor(Type editorBaseType) {
            return null;
        }

        /// <summary>
        ///     Retrieves an array of events that the given component instance
        ///     provides.  This may differ from the set of events the class
        ///     provides.  If the component is sited, the site may add or remove
        ///     additional events.
        /// </summary>
        /// <returns>
        ///     an array of events this component surfaces.
        /// </returns>
        EventDescriptorCollection ICustomTypeDescriptor.GetEvents() {
            return emptyEvtDescrCollection;
        }

        /// <summary>
        ///     Retrieves an array of events that the given component instance
        ///     provides.  This may differ from the set of events the class
        ///     provides.  If the component is sited, the site may add or remove
        ///     additional events.  The returned array of events will be
        ///     filtered by the given set of attributes.
        /// </summary>
        /// <param name='attributes'>
        ///     A set of attributes to use as a filter.
        ///
        ///     If a Attribute instance is specified and
        ///     the event does not have an instance of that attribute's
        ///     class, this will still include the event if the
        ///     Attribute is the same as it's Default property.
        /// </param>
        /// <returns>
        ///     an array of events this component surfaces that match
        ///     the given set of attributes..
        /// </returns>
        EventDescriptorCollection ICustomTypeDescriptor.GetEvents(Attribute[] attributes) {
            return emptyEvtDescrCollection;
         }

        /// <summary>
        ///     Retrieves an array of properties that the given component instance
        ///     provides.  This may differ from the set of properties the class
        ///     provides.  If the component is sited, the site may add or remove
        ///     additional properties.
        /// </summary>
        /// <returns>
        ///     an array of properties this component surfaces.
        /// </returns>
        PropertyDescriptorCollection ICustomTypeDescriptor.GetProperties() 
		{
			
			PropertyCollection props = mgmtObj.Properties;
			PropertyCollection.PropertyEnumerator eProps = props.GetEnumerator();

			PropertyDescriptor[] propDescrArray = new PropertyDescriptor[props.Count + NUM_OF_SYSTEM_PROPS];
			if (propDescrArray.Length != 0)
			{
				int counter = 0;
				while (eProps.MoveNext())
				{
					Property curProp = eProps.Current;
					
					if (GENUS== 2)
					{
						//get the property on the class object: to get to "Values" qualifier
						curProp = mgmtClassObj.Properties[curProp.Name];
					}

					/*
					if (WmiHelper.IsValueMap(curProp))
					{
						//MessageBox.Show("Value map property " + ((ISWbemProperty)eProps.Current).Name);
						propDescrArray[counter++] = new WMIEnumPropertyDescriptor(mgmtObj,
																				mgmtClassObj,
																				mgmtObj,
																				mgmtClassObj,
																				curProp.Name,
																				!IsNewInstance);										

					}
					else
					*/
					{
						propDescrArray[counter++] = new WMIPropertyDescriptor(	mgmtObj,
																				mgmtClassObj,
																				curProp.Name,
																				!IsNewInstance);										


					}
				}

				//add system properties
				IDictionaryEnumerator enumSys = (IDictionaryEnumerator)((IEnumerable)SystemPropertyDictionary).GetEnumerator();

				while (enumSys.MoveNext())
				{
					propDescrArray[counter++] = new WMISystemPropertyDescriptor(mgmtObj, 
																		enumSys.Key.ToString(),
																		enumSys.Value);										
				}				
				
			}

			return (new PropertyDescriptorCollection (propDescrArray ));

		}

        /// <summary>
        ///     Retrieves an array of properties that the given component instance
        ///     provides.  This may differ from the set of properties the class
        ///     provides.  If the component is sited, the site may add or remove
        ///     additional properties.  The returned array of properties will be
        ///     filtered by the given set of attributes.
        /// </summary>
        /// <param name='attributes'>
        ///     A set of attributes to use as a filter.
        ///
        ///     If a Attribute instance is specified and
        ///     the property does not have an instance of that attribute's
        ///     class, this will still include the property if the
        ///     Attribute is the same as it's Default property.
        /// </param>
        /// <returns>
        ///     an array of properties this component surfaces that match
        ///     the given set of attributes..
        /// </returns>
        PropertyDescriptorCollection ICustomTypeDescriptor.GetProperties(Attribute[] attributes) {
            return ((ICustomTypeDescriptor)this).GetProperties();
        }

		

        /// <summary>
        ///     Retrieves the object that directly depends on this value being edited.  This is
        ///     generally the object that is required for the PropertyDescriptor's GetValue and SetValue
        ///     methods.  If 'null' is passed for the PropertyDescriptor, the ICustomComponent
        ///     descripotor implemementation should return the default object, that is the main
        ///     object that exposes the properties and attributes,
        /// </summary>
        /// <param name='pd'>
        ///    The PropertyDescriptor to find the owner for.  This call should return an object
        ///    such that the call "pd.GetValue(GetPropertyOwner(pd));" will generally succeed.
        ///    If 'null' is passed for pd, the main object that owns the properties and attributes
        ///    should be returned.
        /// </param>
        /// <returns>
        ///     valueOwner
        /// </returns>
        object ICustomTypeDescriptor.GetPropertyOwner(PropertyDescriptor pd) {
            return this;
        }

	
	
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vside\servexpl\wmiinstancenode.cs ===
namespace Microsoft.VSDesigner.WMI {
    using System.Runtime.Serialization;
    using System.Diagnostics;
    using System;
	using System.IO;
    using System.Windows.Forms;
    using System.Drawing;
    using System.Collections;
    using Microsoft.VSDesigner;
	using Microsoft.VSDesigner.ServerExplorer;
    using System.ComponentModel.Design;
	using System.ComponentModel;
	using System.Resources;
	using Microsoft.VSDesigner.Interop;
   	using EnvDTE;
	using System.CodeDom;
	using System.CodeDom.Compiler;
	using VSProject = Microsoft.VSDesigner.Interop.VSProject;
    using IVsHierarchy = Microsoft.VSDesigner.Interop.IVsHierarchy;
	using System.Reflection;	
	using System.Management;
	using System.Threading;
	using System.Net;



    // <doc>
    // <desc>
    //     This represents the wmi classes node under a server node.
    // </desc>
    // </doc>
    [UserContextAttribute("serveritem", "wmiinstance")]
    internal class WMIInstanceNode : Node, ISerializable  {
        //
        // FIELDS
        //

        private Image icon = null;
        //public static readonly Type parentType = typeof(WMIClassNode);

        private string label = string.Empty;


		public readonly string path = string.Empty;
		private string serverName = string.Empty;
		private string nsName = string.Empty;
		private string className = string.Empty;
		private string connectAs = null;
		private string password = null;

		//private ISWbemObject wmiObj = null;
		//private	readonly ISWbemObject wmiClassObj = null;

		private ManagementObject mgmtObj = null;
		private	readonly ManagementClass mgmtClassObj = null;

		private bool IsNewInstance = false;

		private Object browseComponent = null;

       
        //
        // CONSTRUCTORS
        //

        // <doc>
        // <desc>
        //     Main constructor.
	// </desc>
        // </doc>
        public WMIInstanceNode (ManagementObject mgmtObjIn,
								ManagementClass mgmtClassObjIn,
								string user,
								string pw) 
		{
			try
			{			

				mgmtObj = mgmtObjIn;
				mgmtClassObj = mgmtClassObjIn;
				
				ManagementPath mgmtPath = mgmtObj.Path;
				
				path = mgmtPath.Path;
				serverName = mgmtPath.Server;
				nsName = mgmtPath.NamespacePath;
				if (nsName.IndexOf(serverName) == 2 && nsName.Substring(0,2) == "\\\\")
				{
					nsName = nsName.Substring(2);
					nsName = nsName.Substring(nsName.IndexOf("\\") + 1);
				}
				className = mgmtPath.ClassName;
				connectAs = user;
				password = pw;

				IsNewInstance = (path == string.Empty);				
				
				
			}
			catch (Exception exc)
			{
				MessageBox.Show(WMISys.GetString("WMISE_Exception", exc.Message, exc.StackTrace));
				throw (exc);
			}
		}

		public ManagementObject WmiObj
		{
			get
			{
				return mgmtObj;
			}
		}


		/// <summary>
        ///      This property determines whether this node should be serialized.
        ///      We won't serialize instance data, since it can be too volatile.
        ///      If SE is changed to gracefully handle failure to de-serialize, we may change this back to default.
        ///
        ///      WhenToSaveCondition.Never means never save node and its children regardless of its visibility.
        ///      WhenToSaveCondition.Always means always save node, their children depends it their property.
        ///      WhenToSaveCondition.WhenVisible (DEFAULT) when save node if node is expanded and visible.
        /// </summary>
        /// <returns>
        ///      The state of when to save this node.
        /// </returns>
        public override WhenToSaveCondition WhenToSave {
             get {
                return WhenToSaveCondition.Never;
            }
            
        }
	
        //
        // PROPERTIES
        //

        // <doc>
        // <desc>
        //     Returns icon for this node.
        // </desc>
        // </doc>
		
        public override Image Icon {
             get {			
				
				 if (icon == null)
				 {						
					 icon = WmiHelper.GetClassIconFromResource(nsName + ":" + className, false, GetType());
					 if (icon == null)
					 {
						 icon = WmiHelper.defaultInstanceIcon;
					 }
				 }				
				 return icon;
            }
      }


	public override ContextMenuItem[] GetContextMenuItems() 
	{	
		try 
		{
	
			if (this.IsNewInstance)
			{
				return new ContextMenuItem[0];
			}
		
			ManagementClass localObj = this.mgmtClassObj;
			MethodCollection methods = null;

			try
			{
				int methodCount = localObj.Methods.Count;
			}
			catch (Exception)
			{
				ConnectionOptions connectOpts = new ConnectionOptions(
					"", //locale
					this.connectAs, //username
					this.password, //password
					"", //authority
					ImpersonationLevel.Impersonate,
					AuthenticationLevel.Connect,
					true, //enablePrivileges
					null	//context
					);

				ManagementScope scope = (this.serverName == WmiHelper.DNS2UNC(Dns.GetHostName())) ?	
					new ManagementScope(WmiHelper.MakeNSPath(serverName, nsName)):
					new ManagementScope(WmiHelper.MakeNSPath(serverName, nsName), connectOpts);

		

				localObj = new ManagementClass(scope, 
					new ManagementPath(mgmtClassObj.Path.Path),
					new ObjectGetOptions(null, 
					true) //use amended
					);

				
			}
			methods = localObj.Methods;
			
			ContextMenuItem[] theMenu = new ContextMenuItem[methods.Count + 2];

			int i = 0;	

			//TODO: retrieve non-static methods for the class and add them to context menu
			MethodCollection.MethodEnumerator methEnum = methods.GetEnumerator();	
			
			while (methEnum.MoveNext())
			{
				Method meth = methEnum.Current;
				
				if (WmiHelper.IsImplementedMethod(meth) && !WmiHelper.IsStaticMethod(meth))
				{				
					//add method name to context menu
					theMenu[i++] = new ContextMenuItem("&" + i.ToString() + " " + meth.Name + "...", //TODO: hotkey???
						new EventHandler(OnExecuteMethod));				
				}
			}

			if (IsNewInstance)
			{
				theMenu[i] = new ContextMenuItem(WMISys.GetString("WMISE_InstNode_SaveNewInstanceCM"), 
					new EventHandler(CommitNewInstance));
			}
			
			return theMenu;
		}

		catch (Exception exc)
		{
				
			MessageBox.Show(WMISys.GetString("WMISE_Exception", exc.Message, exc.StackTrace));
			return null;			
		}
            
        }

	public override bool CanDeleteNode()
	{
		return false;
	}
	

        // <doc>
        // <desc>
        //     Returns label with the value of the key property.
		//		If object has multiple keys, display them all (comma-separated)
		//
		//		If the object has a non-empty, non-key "Caption" property, 
		//		display its value followed by the key values in parens.
        // </desc>
        // </doc>
        public override string Label {
        get {
		try
		{			
			if (label == null || label.Length == 0) 
			{
				SetLabel();         
			}

	        return label;
		}
		catch (Exception exc)
			{
				MessageBox.Show(WMISys.GetString("WMISE_Exception", exc.Message, exc.StackTrace));
				return label;
			}
       }

            set {
				label = value;
            }
       }

		//
        // METHODS
        //

        // <doc>
        // <desc>
        //     Create associator nodes under this node.
	//     The children of this node are of type WMIAssocGroupNode.
	//     Each WMIAssocGroupNode groups instances that belong to the same class; 
	//     are related to this one through the same association class,
	//     and play the same role.  
        // </desc>
        // </doc>
        public override Node[] CreateChildren() {
		try
		{
			//do not look for associators of a new instance
			if (this.IsNewInstance)
			{
				return null;
			}

			//BUGBUG: wmi raid 2855 
			//for Beta1, we are going to disable the ability to expand 
			//references of Win32_ComputerSystem

			if (className.ToUpper() == "WIN32_COMPUTERSYSTEM" &&
				nsName.ToUpper() == "ROOT\\CIMV2")
			{
				return null;
			}
	
			//First, get association instances related to this

			GetRelationshipOptions opts = new GetRelationshipOptions(null, //context
															TimeSpan.MaxValue, //timeout
															50, //block size
															false, //rewindable
															true, //return immediately
															true,	//use amended
															true, //locatable
															false,//prototype only
															false, //direct read															
															string.Empty, //RELATIONSHIP CLASS
															string.Empty, //relationship qualifier															
															string.Empty, //this role
															false //classes only
														);

			ManagementObjectCollection assocInstances = mgmtObj.GetRelationships(opts);

			if (assocInstances == null)
			{
				return null;
			}		

			//assocGroups will contain a list of unique association/class/role groupings
			ArrayList assocGroups = new ArrayList();

			ManagementObjectCollection.ManagementObjectEnumerator enumAssocInstances = 
																	assocInstances.GetEnumerator();			
			while(enumAssocInstances.MoveNext())
			{
				ManagementObject curObj = (ManagementObject)enumAssocInstances.Current;

				AssocGroupComponent comp = new AssocGroupComponent(curObj,mgmtObj);
				if (!assocGroups.Contains(comp))	//this relies on our implementation of "Equald" in AssocGroupComponent class
				{
					assocGroups.Add (comp);
				}				
			}

			Node[] childNodes = new Node[assocGroups.Count];

			Object[] arAssocGroups = assocGroups.ToArray();
			
			for (int i = 0; i < arAssocGroups.Length; i++)
			{
				childNodes[i] = new WMIAssocGroupNode((AssocGroupComponent)arAssocGroups[i], connectAs, password);					
			}					
			
			return childNodes;

		}
		catch (Exception exc)
		{
			MessageBox.Show(WMISys.GetString("WMISE_Exception", exc.Message, exc.StackTrace));			
			return null;
		}
			
    }

        // <desc>
        //     Two nodes are the same if they refer to the same WMI object 
        // </desc>
        // </doc>
    public override int CompareUnique(Node node) {
            
		if (node is WMIInstanceNode && 
			((WMIInstanceNode)node).WmiObj == this.WmiObj)
		{
			return 0;
		}
		
		return Label.CompareTo(node.Label);
    }
		
	
	public override Object GetBrowseComponent() 
	{		
		browseComponent = new WMIObjectComponent(mgmtObj, mgmtClassObj);		
		return browseComponent;
	}

	/// <summary>
    ///     This brings UI to execute WMI method against the instance.
    /// </summary>
	private void OnExecuteMethod(object sender, EventArgs e)
	{
		try 
		{		

			//trim the ordinal prefix (all up to first space)
			//and 3 dots off the end of the context menu text to get method name
			String methName = ((ContextMenuItem)sender).Text.Substring(0, ((ContextMenuItem)sender).Text.Length - 3);
			int spaceIndex = methName.IndexOf(' ', 0);
			methName = methName.Substring(spaceIndex + 1);
		
			//get method object
			ManagementClass classObject = new ManagementClass(mgmtObj.ClassPath.Path);
			Method meth = classObject.Methods[methName];
			ExecuteMethodDialog dlg = new ExecuteMethodDialog(mgmtObj, meth, mgmtClassObj);
			DialogResult res = dlg.ShowDialog();
		}
		catch(Exception exc)
		{
			MessageBox.Show(WMISys.GetString("WMISE_Exception", exc.Message, exc.StackTrace));
		}	

	}

	/// <summary>
    ///     This saves new instance to WMI
    /// </summary>
	private void CommitNewInstance(object sender, EventArgs e)
	{
		try 
		{
			
			//call Commit on browse object
			if (browseComponent is  WMIObjectComponent)
			{
				bool res = ((WMIObjectComponent)browseComponent).Commit();
				if (res)
				{
					//disable commit menu  (remove? leave?)
					((ContextMenuItem)sender).Enabled = false;
					IsNewInstance = false;

					//update label
					SetLabel();
					this.GetNodeSite().UpdateLabel();
				}
				else
				{
					//Commit failed, remove this node
					this.GetNodeSite().Remove();
				}
			}

		}
		catch(Exception exc)
		{
			MessageBox.Show(WMISys.GetString("WMISE_Exception", exc.Message, exc.StackTrace));
		}	

	}

	    /// <summary>
        ///      To determine whether this node supports drag and drop.
        /// </summary>
        /// <returns>
        ///      TRUE to indicate ProcessNode supports drag and drop.
        /// </returns>
        public override bool HasDragComponents() {
            return true;	
        }

		
		/// <summary>
		/// This will generate an early-bound wrapper for WMI class,
		/// add it as a source file to the current project; instantiate
		/// the newly-generated type and return it as a drag component.
		/// </summary>
		/// <param name="designerHost"> </param>
		public override IComponent[] CreateDragComponents(IDesignerHost designerHost) 
		{
			try
			{			



				Project[] projects = VSUtils.GetProjects(GetNodeSite());
				if (projects == null)
				{
					return null;
				}
				
				//This is an assumtion that's working so far.
				//TODO: verify this is the right way to determine the startup project
				//in the solution:
				Project curProject = projects[0];

				ProjectItems projItems = curProject.ProjectItems;
				if (projItems == null)
				{
					return null;
				}
				
				string curProjSuffix = VSUtils.MapProjectGuidToSuffix(new Guid(curProject.Kind));
				if (curProjSuffix == string.Empty)
				{
					//neither a VB nor a CS project
					throw new Exception(WMISys.GetString("WMISE_Invalid_Project_Type_For_CodeGen"));
				}
									
				Guid curProjectType = new Guid(curProject.Kind);
				string wrapperFileName = className + "."+ curProjSuffix;
				CodeTypeDeclaration newType = null;

				if(!mgmtClassObj.GetStronglyTypedClassCode(true, true, out newType))					
				{
					throw new Exception(WMISys.GetString("WMISE_Code_Generation_Failed"));
				}							
		
				ICodeGenerator cg = VSUtils.MapProjectGuidToCodeGenerator(curProjectType);

				//construct generated code Namespace name (in the form "System.Management.root.cimv2")
				string[] nsParts = nsName.ToLower().Split(new Char[]{'\\'});
				string codeNSName = "System.Management";
				for (int i = 0; i < nsParts.Length; i++)
				{
					codeNSName += nsParts[i] + ".";
				}
				codeNSName  = codeNSName.Substring(0, codeNSName.Length - 1);

				System.CodeDom.CodeNamespace cn = new System.CodeDom.CodeNamespace(codeNSName);

				// Add imports to the code
				cn.Imports.Add (new CodeNamespaceImport("System"));
				cn.Imports.Add (new CodeNamespaceImport("System.ComponentModel"));
				cn.Imports.Add (new CodeNamespaceImport("System.Management"));
				cn.Imports.Add(new CodeNamespaceImport("System.Collections"));

				// Add class to the namespace
				cn.Types.Add (newType);

				//Now create the output file
				TextWriter tw = new StreamWriter(new FileStream (Path.GetTempPath() + "\\" + wrapperFileName,
																FileMode.Create));

				// And write it to the file
				cg.GenerateCodeFromNamespace (cn, tw, new CodeGeneratorOptions());
						
				ProjectItem newItem = projItems.AddFromFileCopy(Path.GetTempPath() + "\\" + wrapperFileName);			
				if (newItem == null)
				{
					throw new Exception(WMISys.GetString("WMISE_Could_Not_Add_File_to_Project"));
				}

				File.Delete(Path.GetTempPath() + "\\" + wrapperFileName);								

				Object comp = Activator.CreateInstance(designerHost.GetType(codeNSName + "." +
																			newType.Name));
				if (comp == null)
				{
					throw new Exception(WMISys.GetString("WMISE_Could_Not_Instantiate_Management_Class"));
				}

				return new IComponent[] {(IComponent)comp};

				//The commented-out block below implements the solution with VS custom code generator:
				/*
				//create a new file containing the path to the instance object				
				string tempFileName = Path.GetTempPath() + this.className + ".wmi";
				StreamWriter sw = File.AppendText(tempFileName);
				if (sw == null)
				{
					return null;
				}
				
				sw.WriteLine(WmiHelper.MakeClassPath(this.serverName,
													this.nsName,
													this.className));
				
				sw.Flush();
				sw.Close();
				ProjectItem newItem = projItems.AddFromFileCopy(tempFileName);
				if (newItem == null)
				{
					return null;
				}
				File.Delete(tempFileName);
                VSUtils.SetGenerator(newItem, "WMICodeGenerator");		
				return null;	//is this OK???
				*/

				
			}
			catch (Exception exc)
			{
				MessageBox.Show(WMISys.GetString("WMISE_Exception", exc.Message, exc.StackTrace));
				return null;
			}
        }		


	/// <summary>
    ///     The object should write the serialization info.
    ///     NOTE: unsaved new instance will not be serialized
    /// </summary>
    public virtual void GetObjectData(SerializationInfo si, StreamingContext context) {

		if (IsNewInstance)
		{
			((WMIObjectComponent)browseComponent).Commit(); 			
		}
		/*
		else
		{
			si.AddValue("path", path);
			si.AddValue("serverName", serverName);
			si.AddValue("nsName", nsName);
			si.AddValue("className", className);			
		}*/
    }	

	void SetLabel()
	{		

		ManagementPath mgmtPath = mgmtObj.Path;
		if (mgmtPath.IsSingleton)
		{
			label = mgmtPath.ClassName;
		}
		else
		{
			//this is not a singleton.  Construct label to consist of comma-separated
			//key property values and caption value.
			bool needCaption = true;
			string keyVals = string.Empty;
			string caption = string.Empty;

			PropertyCollection props = mgmtObj.Properties;
			try
			{
				caption = props["Caption"].Value.ToString();
			}
			catch (Exception )
			{
				//no "Caption" property
				needCaption = false;
			}

			if (caption == string.Empty)
			{
				needCaption = false;
			}	
			
			//get key property values
			PropertyCollection.PropertyEnumerator propEnum = mgmtObj.Properties.GetEnumerator();

			while (propEnum.MoveNext())
			{
				if (WmiHelper.IsKeyProperty(propEnum.Current))
				{
					string keyval = propEnum.Current.Value.ToString();
					if (needCaption && (string.Compare(keyval, caption, true) == 0))
					{
						needCaption = false;
					}
					keyVals+= keyval + ",";
				}
			}		
			

			if (keyVals != string.Empty)
			{
				//get rid of last character (a comma)
				keyVals = keyVals.Substring(0, keyVals.Length - 1);	
			}			

			if (needCaption)
			{
				label = caption + "(" + keyVals + ")";
			}
			else
			{
				label = keyVals;
			}

			if (label == string.Empty)
			{
				label = className;
			}
		}
	}
        
/*
        private IDesignerHost GetActiveDesignerHost() {
            IDesignerHost activeHost = null;
            try {
				
                IDesignerEventService des = (IDesignerEventService)(GetNodeSite().GetServiceObject(typeof(IDesignerEventService)));
                if (des != null) {
                    activeHost = des.GetActiveDocument();
                }
            }
            catch (Exception ) {
                //if (Switches.ServerExplorer.TraceVerbose) Debug.WriteLine("CAUGHT EXCEPTOIN: VsServerExplorer::GetActiveDesignerHost() - " + e.ToString());
            }

            return activeHost;
        }

		private Project GetCurrentProject(IDesignerHost host) {

			try
			{

				Project[] aProjs = GetProjects();
				String projNames = "Open project names are: ";
				for (int i = 0;i < aProjs.Length; i++)
				{
					projNames += aProjs[i].FullName + "\n\r";
				}
				MessageBox.Show(projNames);
				
				Type extensibliityServiceType = typeof(IExtensibilityService);
				object extensibilityService = null;
				INodeSite nodeSite = GetNodeSite();
				if (nodeSite != null) {
				    extensibilityService = nodeSite.GetServiceObject(extensibliityServiceType);
				}

				if ((extensibilityService == null || !(extensibilityService is ProjectItem)) && (host != null)) {
				    extensibilityService = host.GetServiceObject(extensibliityServiceType);
					if (extensibilityService != null)
					{
						MessageBox.Show ("got extensibilityService at second try");
					}

				}
				else
				{
					MessageBox.Show ("got extensibilityService at first try");
				}


				//Debug.Assert(extensibilityService != null, "VsServerExplorer::GetCurrentProject() - GetServiceObject(IExtensibilityService) returns null.");
				if (extensibilityService != null && extensibilityService is ProjectItem) {
					MessageBox.Show ("trying to get ProjectItem");
				    return ((ProjectItem) extensibilityService).ContainingProject;
				}
	

		
				return null;
			}
			catch(Exception exc)
			{
				MessageBox.Show(WMISys.GetString("WMISE_Exception", exc.Message, exc.StackTrace));
				return null;
			}
			

        }
	

		public static void AddFileToProject (Project project, string fileName, string fileContent) {

			if (fileName == string.Empty) {
                return;
            }

            if (project == null) {
                throw new ArgumentNullException("project");
            }

			// First, create new file
			//find out project directory:
			String projPath = project.FullName.Substring(project.FullName.IndexOf(project.FileName, 0));

			MessageBox.Show("Project directory is " + projPath);
            //ProjectReferences projectReferences = ((Microsoft.VisualStudio.Interop.VSProject) project.Object).References;
            
        }

		
		

	 public static void AddComponentReferences(Project project, string[] references) {
            if (references == null || references.Length == 0) {
                return;
            }

            if (project == null) {
                throw new ArgumentNullException("project");
            }

            ProjectReferences projectReferences = ((VSProject) project.Object).References;
            for (int i = 0; i < references.Length; i++) {
                try {
                    projectReferences.Add(references[i]);
                }
                catch (Exception e) {
                    Debug.Assert(false, "VsServerExplorer::AddComponentReferences() - ProjectReferences.Add(" + references[i] + " throw Exception: " + e.ToString());
                    if (Switches.ServerExplorer.TraceVerbose) Debug.WriteLine("**** ERROR: VsServerExplorer::AddComponentReferences() - ProjectReferences.Add(" + references[i] + " throw Exception: " + e.ToString());

                    MessageBox.Show(VSDSys.GetString("SE_AddReferenceFail_UnableToAddReference", references[i], e.Message), VSDSys.GetString("SE_MessageBoxTitle_ServerExplorer"));
                }
            }
        }

*/

	}      

		
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vside\servexpl\wmisystempropertydescriptor.cs ===
//------------------------------------------------------------------------------
/// <copyright from='1997' to='2001' company='Microsoft Corporation'>           
///    Copyright (c) Microsoft Corporation. All Rights Reserved.                
///    Information Contained Herein is Proprietary and Confidential.            
/// </copyright>                                                                
//------------------------------------------------------------------------------


namespace Microsoft.VSDesigner.WMI {

	using System;
	using System.Collections;
	using System.ComponentModel;
	using System.Windows.Forms;
	using System.Management;


    // <doc>
    // <desc>
    //     This represents the wmi class information for PB
    // </desc>
    // </doc>
	internal class WMISystemPropertyDescriptor :  PropertyDescriptor {
		
		//fields:

		protected string propName = String.Empty;

		protected ManagementObject mgmtObj = null;
		protected ManagementObject mgmtClassObj = null;

		//protected ISWbemProperty prop = null;
		//protected WMIObjectComponent.WMISystemProperties wmiProp = 0;

		//if wmiObj is a class, genus = 1, if wmiObj is an instance, it's 2
		protected int genus = 1;	
		
		protected Object propValue = null;
				
		// <doc>
		// <desc>
		//     Ctor from WMIPropertyDescriptor
		// </desc>
		// </doc>
		internal WMISystemPropertyDescriptor(ManagementObject wbemObjIn,
											String propNameIn,
											Object propValueIn
											)
					:base(propNameIn, null)
		{
			if (wbemObjIn == null)
			{
				throw (new ArgumentNullException("wbemObjIn"));
			}

			if ( propNameIn == string.Empty)
			{
				throw  (new ArgumentException(WMISys.GetString("WMISE_PropDescr_NoProp"), 
												"propNameIn"));
			}

		

			mgmtObj = wbemObjIn;			
			propValue = propValueIn;
			propName = propNameIn;
			
		}	
		
				
		public override String Category  
		{
			get
			{
				return "System";
				
			}
		}

		public override String Description  
		{
			 get
			{
				return string.Empty;

			}
		}

		public override Boolean IsBrowsable  
		{
			get
			{
				return true;
			}
		}
		public override Boolean IsReadOnly 
		{
			get
			{
				return true;	
			}
		}

		
		public override String Name
		{
			get
			{				
				return propName;
			}
		}
			
		public override Type ComponentType  
		{
			get
			{
				return typeof (WMIObjectComponent);
			}
		}

		public override Type PropertyType {

		    get 
			{

				if (propValue.GetType() != typeof(System.DBNull) /*&& prop.CimType != WbemCimtypeEnum.wbemCimtypeDatetime*/)
				{
					return propValue.GetType();
				}
				else
				{
					if (propName == "__PROPERTY_COUNT" ||	propName == "__GENUS") 
					{
						return  typeof(Int32);
					}
					else 
					{						
						if (propName.ToUpper() == "__DERIVATION")
						{
							return typeof(String[]);						
						}
						else
						{
							return typeof (String);
						}					
					}
				}
			}
		}

		
		public override void ResetValue (Object component)  
		{
		}
		

		public override Boolean ShouldSerializeValue (Object component)  
		{
			return false;
		}
	
		
		public override Boolean CanResetValue (Object component)  
		{
			return false;
		}
		
		public override string DisplayName
		{
			get
			{
				return propName;
			}
		}

		public override Object GetValue (Object component)  
		{
			return propValue;
		}

		
		public override void SetValue (Object component, Object value)  
		{     
			
		}
		    
        public override bool Equals(object other) {
            if (other is WMISystemPropertyDescriptor) {
                WMISystemPropertyDescriptor descriptor = (WMISystemPropertyDescriptor) other;
                return ((descriptor.propName == propName) &&
						(descriptor.mgmtObj.Path.Path == mgmtObj.Path.Path ));
            }
            return false;
        }		                    
     
    }   
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vside\servexpl\wmisysdescriptionattribute.cs ===
//------------------------------------------------------------------------------
/// <copyright from='1997' to='2001' company='Microsoft Corporation'>           
///    Copyright (c) Microsoft Corporation. All Rights Reserved.                
///    Information Contained Herein is Proprietary and Confidential.            
/// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace Microsoft.VSDesigner.WMI {
    

    using System.Diagnostics;
    using System;
	using System.ComponentModel;
    

    /// <internalonly/>
    /// <summary>
    ///    <para>
    ///       DescriptionAttribute marks a property, event, or extender with a
    ///       description. Visual designers can display this description when referencing
    ///       the member.
    ///    </para>
    /// </summary>
    /// <seealso cref='System.ComponentModel.MemberAttribute'/>
    /// <seealso cref='System.ComponentModel.PropertyDescriptor'/>
    /// <seealso cref='System.ComponentModel.EventDescriptor'/>
    /// <seealso cref='System.ComponentModel.ExtendedPropertyDescriptor'/>
    [AttributeUsage(AttributeTargets.All)]
    internal class WMISysDescriptionAttribute : DescriptionAttribute {

        private bool replaced = false;

        /// <summary>
        ///     Constructs a new sys description.
        /// </summary>
        /// <param name='description'>
        ///     description text.
        /// </param>
        public WMISysDescriptionAttribute(string description) : base(description) {
        }

        /// <summary>
        ///     Retrieves the description text.
        /// </summary>
        /// <returns>
        ///     description
        /// </returns>
        public override string Description {
			get
			{
				if (!replaced) 
				{
					replaced = true;
					DescriptionValue = WMISys.GetString(base.DescriptionValue);
				}
				return DescriptionValue;
			}
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vside\servexpl\beta1\cimtypemapper.cs ===
namespace Microsoft.VSDesigner.WMI 
{
	using System;
	using System.ComponentModel;
	using System.Core;
	using System.WinForms;
	using Microsoft.Win32.Interop;
	using System.Drawing;
	using WbemScripting;
	using System.Management;
	using System.Collections;
	using System.Diagnostics;
	using System.IO;

	
	public class CIMTypeMapper
	{
		public static string ToString(WbemCimtypeEnum cimtype)
		{
			switch (cimtype)
			{
				case (WbemCimtypeEnum.wbemCimtypeBoolean):
				{
					return "boolean";
				}
				case (WbemCimtypeEnum.wbemCimtypeChar16):
				{
					return "char16";
				}
				case (WbemCimtypeEnum.wbemCimtypeDatetime):
				{
					return "datetime";
				}
				case (WbemCimtypeEnum.wbemCimtypeObject):
				{
					return "object";
				}
				case (WbemCimtypeEnum.wbemCimtypeReal32):
				{
					return "real32";
				}
				case (WbemCimtypeEnum.wbemCimtypeReal64):
				{
					return "real64";
				}
				case (WbemCimtypeEnum.wbemCimtypeReference):
				{
					return "reference";
				}
				case (WbemCimtypeEnum.wbemCimtypeSint16):
				{
					return "sint16";
				}
				case (WbemCimtypeEnum.wbemCimtypeSint32):
				{
					return "sint32";
				}
				case (WbemCimtypeEnum.wbemCimtypeSint64):
				{
					return "sint64";
				}
				case (WbemCimtypeEnum.wbemCimtypeSint8):
				{
					return "sint8";
				}
				case (WbemCimtypeEnum.wbemCimtypeString):
				{
					return "string";
				}
				case (WbemCimtypeEnum.wbemCimtypeUint16):
				{
					return "uint16";
				}
				case (WbemCimtypeEnum.wbemCimtypeUint32):
				{
					return "uint32";
				}
				case (WbemCimtypeEnum.wbemCimtypeUint64):
				{
					return "uint64";
				}
				case (WbemCimtypeEnum.wbemCimtypeUint8):
				{
					return "uint8";
				}
				
			}

			return string.Empty;

		}

		public static Type ToType(CIMType cimtype,
									bool bIsArray,
									Property prop)
		{
            Type t = null;
       
			switch (cimtype)
			{
				case (CIMType.Boolean):
				{					
					if (bIsArray)
					{
						Boolean[] ar = new Boolean[0];
						t = ar.GetType();
					}
					else
					{
						t =  typeof(Boolean);						
					}
				} break;
				case (CIMType.Char16):
				{
					if (bIsArray)
					{
						Char[] ar = new Char[0];
						t = ar.GetType();
					}
					else
					{
						t =  typeof(Char);						
					}
				} break;
				case (CIMType.DateTime):
				{
					if (WmiHelper.IsInterval(prop))
					{
						if (bIsArray)
						{
							TimeSpan[] ar = new TimeSpan[0];
							t = ar.GetType();
						}
						else
						{
							t =  typeof(TimeSpan);						
						}	
					}
					else
					{
						if (bIsArray)
						{
							DateTime[] ar = new DateTime[0];
							t = ar.GetType();
						}
						else
						{
							t =  typeof(DateTime);						
						}						
					}
					
				} break;
				case (CIMType.Object):
				{
					
					if (bIsArray)
					{
						WMIObjectComponent[] ar = new WMIObjectComponent[0];
						t = ar.GetType();
					}
					else
					{
						t =  typeof(WMIObjectComponent);						
					}
				} break;
				case (CIMType.Real32):
				{
					if (bIsArray)
					{
						Single[] ar = new Single[0];
						t = ar.GetType();
					}
					else
					{
						t =  typeof(Single);						
					}
				} break;
				case (CIMType.Real64):
				{					
					if (bIsArray)
					{
						Double[] ar = new Double[0];
						t = ar.GetType();
					}
					else
					{
						t =  typeof(Double);						
					}
				} break;
				case (CIMType.Reference):
				{					
					if (bIsArray)
					{
						String[] ar = new String[0];
						t = ar.GetType();
					}
					else
					{
						t =  typeof(String);						
					}
				} break;
				case (CIMType.Sint16):
				{				
					if (bIsArray)
					{
						Int16[] ar = new Int16[0];
						t = ar.GetType();
					}
					else
					{
						t =  typeof(Int16);						
					}
				} break;
				case (CIMType.Sint32):
				{					
					if (bIsArray)
					{
						Int32[] ar = new Int32[0];
						t = ar.GetType();
					}
					else
					{
						t =  typeof(Int32);						
					}
				} break;
				case (CIMType.Sint64):
				{				
					if (bIsArray)
					{
						Int64[] ar = new Int64[0];
						t = ar.GetType();
					}
					else
					{
						t =  typeof(Int64);						
					}
				} break;
				case (CIMType.Sint8):
				{
					if (bIsArray)
					{
						SByte[] ar = new SByte[0];
						t = ar.GetType();
					}
					else
					{
						t =  typeof(SByte);						
					}
				} break;
				case (CIMType.String):
				{
					if (bIsArray)
					{
						String[] ar = new String[0];
						t = ar.GetType();
						//return typeof(System.Collections.ArrayList);

					}
					else
					{
						t =  typeof(String);						
					}
				} break;
				case (CIMType.Uint16):
				{
					if (bIsArray)
					{
						UInt16[] ar = new UInt16[0];
						t = ar.GetType();
					}
					else
					{
						t =  typeof(UInt16);						
					}
				} break;
				case (CIMType.Uint32):
				{
					if (bIsArray)
					{
						UInt32[] ar = new UInt32[0];
						t = ar.GetType();
					}
					else
					{
						t =  typeof(UInt32);						
					}
				} break;
				case (CIMType.Uint64):
				{
					if (bIsArray)
					{
						UInt64[] ar = new UInt64[0];
						t = ar.GetType();
					}
					else
					{
						t =  typeof(UInt64);						
					}
				} break;
				case (CIMType.Uint8):
				{
					if (bIsArray)
					{
						Byte[] ar = new Byte[0];
						t = ar.GetType();
					}
					else
					{
						t =  typeof(Byte);						
					}
				} break;
                
                default:
				{						
					if (bIsArray)
					{
						Object[] ar = new Object[0];
						t = ar.GetType();
					}
					else
					{
						t =  typeof(Object);						
					}
				}
            }           

            return t;
		}
		
		
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vside\servexpl\beta1\executemethoddialog.cs ===
namespace Microsoft.VSDesigner.WMI 
{

using System;
using System.ComponentModel;
using System.Core;
using System.WinForms;
using Microsoft.Win32.Interop;
using System.Drawing;
using WbemScripting;
using System.Collections;

//using System.Web.UI.WebControls;

public class ExecuteMethodDialog : Form
{
	private void InitializeComponent ()
	{
	}

	private	ISWbemObject wmiObj = null; 
	private	ISWbemObject wmiClassObj = null;
	private ISWbemMethod meth = null;
	private ISWbemObject inParms = null;
	
	private Button executeBtn = new Button();
	private Button cancelBtn = new Button();

	private WMIObjectGrid gridIn = null;
	private WMIObjectGrid gridOut = null;

	private Label ServerName = new Label();
	private Label NamespaceName = new Label();
	private Label ClassName = new Label();

	private Label NoInParams = new Label();

	private Label labelInParms = new Label();
	private Label labelOutParms = new Label();
	private Label labelDescr = new Label();

	private TextBox descr	= new TextBox ();

	public ExecuteMethodDialog(ISWbemObject wbemObjIn,
								ISWbemMethod methIn,
								ISWbemObject wbemClassObjIn)
	{	

		try
		{
			if (wbemObjIn == null || methIn == null)
			{
				throw (new NullReferenceException());
			}

			wmiObj = wbemObjIn;
			wmiClassObj = wbemClassObjIn;
			meth = methIn;
		
			this.Text = WMISys.GetString("WMISE_ExecMethodDlg_Title", wmiObj.Path_.Class, meth.Name); 

			//this is a temp workaround for URT bug 48695: uncomment this later
			//this.AcceptButton = executeBtn;
			
			this.AutoScaleBaseSize = (Size) new Point(5, 13);
			this.BorderStyle = FormBorderStyle.FixedSingle;
			int dlgWidth = 400;
			int dlgHeight = 500;
			this.ClientSize =  (Size) new Point(dlgWidth, dlgHeight);
			this.ShowInTaskbar = false;
		
			ServerName.Location = new Point(16, 16);
			ServerName.Text = WMISys.GetString("WMISE_ExecMethodDlg_ServerName", wmiObj.Path_.Server);

			//NamespaceName.Location = new Point();
			//ClassName.Location = new Point();		

			if (meth.InParameters == null)
			{
				NoInParams.Text = WMISys.GetString("WMISE_ExecMethodDlg_NoInputParams"); 
				NoInParams.Location = new Point(16,40);
			}
			else
			{
				inParms = meth.InParameters.SpawnInstance_(0);
				gridIn = new WMIObjectGrid(inParms, 
							PropertyFilters.NoSystem, 
							GridMode.EditMode,
							false, false, false);

				labelInParms.Location = new Point(16,40);
				labelInParms.Text = WMISys.GetString("WMISE_ExecMethodDlg_InputParameters"); 

				gridIn.Location = new Point(16,65);
				gridIn.Size = (Size)new Point(367, 140);
				gridIn.Anchor = AnchorStyles.All;
				gridIn.PreferredColumnWidth = 109;
				gridIn.PreferredRowHeight = 19;
				gridIn.TabIndex = 1;
			}
	
			labelOutParms.Location = new Point(16,215);
			labelOutParms.Text = WMISys.GetString("WMISE_ExecMethodDlg_OutputParameters"); 

			gridOut = new WMIObjectGrid(meth.OutParameters, 
						PropertyFilters.NoSystem, 
						GridMode.ViewMode,
						false, false, false);

			gridOut.Location = new Point(16, 240);
			gridOut.Size = (Size)new Point(367, 100);
			gridOut.Anchor = AnchorStyles.All;
			gridOut.PreferredColumnWidth = 109;
			gridOut.PreferredRowHeight = 19;
			gridOut.TabIndex = 2;
			
			descr.Text = WmiHelper.GetMethodDescription(meth.Name, wmiClassObj);
			descr.Location = new Point (16, 355);
			descr.Size = (Size) new Point (368, 70);
			descr.Multiline = true;
			descr.ReadOnly = true;
			descr.ScrollBars = ScrollBars.Vertical;

			executeBtn.Text = WMISys.GetString("WMISE_ExecMethodDlg_Execute");
			executeBtn.Location = new Point(225, 440);
			executeBtn.Click += new EventHandler(this.OnExecute);
			executeBtn.TabIndex = 3;

			cancelBtn.Text = WMISys.GetString("WMISE_Cancel");
			cancelBtn.Location = new Point(310, 440);
			cancelBtn.DialogResult = DialogResult.Cancel;
			cancelBtn.TabIndex = 4;
		
			if (meth.InParameters == null)
			{
				this.Controls.All = new Control[] {cancelBtn, 
				executeBtn,
				ServerName,
				NoInParams,
				labelOutParms,
				gridOut,
				descr
				};
			}
			else
			{
				this.Controls.All = new Control[] {cancelBtn, 
				executeBtn,
				ServerName,
				labelInParms,
				gridIn,
				labelOutParms,
				gridOut,
				descr
				};
			}

		}

		catch (Exception exc)
		{
			MessageBox.Show(WMISys.GetString("WMISE_Exception", exc.Message, exc.StackTrace));
			throw (exc);
		}
	}

	private void OnExecute (Object source, EventArgs args)
	{
		try
		{
			if (gridIn != null)
			{
				gridIn.AcceptChanges();	
			}
							
			ISWbemObject objOut = wmiObj.ExecMethod_(meth.Name, inParms, 0, null);
			gridOut.WMIObject = objOut;
		}
		catch (Exception exc)
		{
			MessageBox.Show(WMISys.GetString("WMISE_Exception", exc.Message, exc.StackTrace));
		}
	}	

	private void OnO (Object source, EventArgs args)
	{
		try
		{
			if (gridIn != null)
			{
				gridIn.AcceptChanges();	
			}
							
			ISWbemObject objOut = wmiObj.ExecMethod_(meth.Name, inParms, 0, null);
			gridOut.WMIObject = objOut;
		}
		catch (Exception exc)
		{
			MessageBox.Show(WMISys.GetString("WMISE_Exception", exc.Message, exc.StackTrace));
		}
	}	
	

}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vside\servexpl\beta1\assocgroupcomponent.cs ===
namespace Microsoft.VSDesigner.WMI {

	using System;
	using System.ComponentModel;
	using System.Core;
	using System.Collections;
	using System.WinForms;
	using WbemScripting;

	public class AssocGroupComponent : Component
	{
		public readonly  string associationPath = "";
		public readonly  string associationClass = "";

		public readonly  string targetClass = "";	
		public readonly  string targetRole = "";
		
		public readonly  ISWbemObject sourceInst;

        public AssocGroupComponent(ISWbemObject assocInstance, ISWbemObject sourceObj)
	{					
			sourceInst = sourceObj;

			associationPath = assocInstance.Path_.Path;
			associationClass = assocInstance.Path_.Class;
			
	        //now, inspect assocInstance object to find target role and path
			targetClass = WmiHelper.GetAssocTargetClass(assocInstance, sourceObj.Path_);
			
			targetRole = WmiHelper.GetAssocTargetRole(assocInstance, sourceObj.Path_);

		
		}

		public AssocGroupComponent(ISWbemObject sourceInstIn,
									String associationPathIn,
									String targetClassIn,
									String targetRoleIn)
		{					
			sourceInst = sourceInstIn;
			associationPath = associationPathIn;
			
			//to get association class name from path, leave only 
			//the part after the last backslash
			char[] separ = new char[]{'\\'};
			string[] pathParts = associationPath.Split(separ);
            associationClass = pathParts[pathParts.Length - 1];
			//MessageBox.Show("associationPath is " + associationPath);
			//MessageBox.Show("associationClass is " + associationClass);
			
			targetClass = targetClassIn;
           		
			targetRole = targetRoleIn;		
		}

		//overriden Equals method.
		//This is a simplified comparison routine: no class name
		public override bool Equals(Object other)
		{
			if (!(other is AssocGroupComponent))
			{
				return false;
			}
			if ((((AssocGroupComponent)other).associationClass == associationClass) &&
				(((AssocGroupComponent)other).targetClass == targetClass) &&
				(((AssocGroupComponent)other).targetRole == targetRole) )
				//&&	(other.sourceInst.Path_.Path == sourceInst.Path_.Path))
			{
				return true;
			}
			else
			{
				return false;
			}
		}


		[
		Browsable(true),
		ServerExplorerBrowsable(true),
		WMISysDescription("WMISE_AssocGroupClassPropertyDescr")
		]
		public string Class
		{
			get
			{
				return targetClass;
			}
		}

		
		[
		Browsable(true),
		ServerExplorerBrowsable(true),
		WMISysDescription("WMISE_AssocGroupRolePropertyDescr")
		]
		public string Role
		{
			get
			{
				return targetRole;
			}
		}


		[
		Browsable(true),
		ServerExplorerBrowsable(true),
		WMISysDescription("WMISE_AssocGroupAssocPropertyDescr")
		]
		public string RelationshipClass
		{
			get
			{
				return associationClass;
			}
		}
			
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vside\servexpl\beta1\extrinsiceventquerycomponent.cs ===
namespace Microsoft.VSDesigner.WMI {

	using System;
	using System.ComponentModel;
	using System.Core;
	using System.Collections;
	using System.WinForms;
	using WbemScripting;

	public class ExtrinsicEventQueryComponent : Component
	{
		public readonly  string server = "";
		public readonly  string ns = "";
		public string query = "";	

		private ExtrinsicEventQueryNode queryNode = null;
     
		public ExtrinsicEventQueryComponent(String serverIn,
									String nsIn,
									String queryIn,
									ExtrinsicEventQueryNode queryNodeIn)
		{					
			server = serverIn;
			ns = nsIn;
			query = queryIn;
			queryNode = queryNodeIn;
		}

		public override bool Equals(Object other)
		{
			if (!(other is ExtrinsicEventQueryComponent))
			{
				return false;
			}
			if ((((ExtrinsicEventQueryComponent)other).server == server) &&
				(((ExtrinsicEventQueryComponent)other).ns == ns) &&
				(((ExtrinsicEventQueryComponent)other).query == query) )
			{
				return true;
			}
			else
			{
				return false;
			}
		}


		[
		Browsable(true),
		ServerExplorerBrowsable(true)
		]
		public string Server
		{
			get
			{
				return server;
			}
		}

		
		[
		Browsable(true),
		ServerExplorerBrowsable(true)
		]
		public string WMINamespace
		{
			get
			{
				return ns;
			}
		}


		[
		Browsable(true),
		ServerExplorerBrowsable(true)
		]
		public string Query
		{
			get
			{
				return query;
			}
			set 
			{
				query = value;			
				queryNode.Query = value;				
			}
		}
			
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vside\servexpl\wmipropertydescriptor.cs ===
//------------------------------------------------------------------------------
/// <copyright from='1997' to='2001' company='Microsoft Corporation'>           
///    Copyright (c) Microsoft Corporation. All Rights Reserved.                
///    Information Contained Herein is Proprietary and Confidential.            
/// </copyright>                                                                
//------------------------------------------------------------------------------


namespace Microsoft.VSDesigner.WMI {
	using System.Diagnostics;
	
	using System;
	using System.Collections;
	using System.ComponentModel;
	using System.Reflection;
	using System.Windows.Forms;
	using System.Management;

    // <doc>
    // <desc>
    //     This represents the wmi class information for PB
    // </desc>
    // </doc>
	
	internal class WMIPropertyDescriptor :  PropertyDescriptor {
		
		//fields

		protected string propName = String.Empty;

		//protected ISWbemObject wmiObj = null;
		//protected ISWbemObject wmiClassObj = null;

		protected ManagementObject mgmtObj = null;
		protected ManagementObject mgmtClassObj = null;
		protected Property prop = null;
		protected Property classProp = null; //this one has a description

		//if wmiObj is a class, genus = 1, if wmiObj is an instance, it's 2
		protected int genus = 1;	
		
		//CommitImmediately variable determines whether the object is saved 
		//each time SetValue() is invoked on the property.
		//For certain scenarios, we may want to call Commit() explicitly after 
		//all the properties have been set
		protected internal bool CommitImmediately = true;

		protected Object initialValue = null;

				
		// <doc>
		// <desc>
		//     Ctor from WMIPropertyDescriptor
		// </desc>
		// </doc>
		internal WMIPropertyDescriptor(	ManagementObject mgmtObjIn,
										ManagementObject mgmtClassObjIn,
										String propNameIn,
										bool commitImmediately)
				:base(propNameIn, null)
		{
			if (mgmtObjIn == null)
			{
				throw (new ArgumentNullException("wbemObjIn"));
			}

			if (mgmtClassObjIn == null)
			{
				throw (new ArgumentNullException("mgmtClassObjIn"));
			}

			if ( propNameIn == string.Empty)
			{
				throw  (new ArgumentNullException("propNameIn"));
			}

			mgmtObj = mgmtObjIn;
			mgmtClassObj = mgmtClassObjIn;
			propName = propNameIn;

			CommitImmediately = commitImmediately;

			Initialize ();		
		}

		
		
		private void Initialize()
		{					
			
			try
			{
											
				//get the property
				PropertyCollection props = mgmtObj.Properties;
				prop = props[propName];	
							
				if (mgmtObj.Path.IsClass)
				{
					genus = 1;
					classProp = prop;
				}
				else	//instance
				{
					genus = 2;
					classProp = mgmtClassObj.Properties[propName];
				}
	
				

			}
			catch(Exception exc)
			{
				MessageBox.Show(WMISys.GetString("WMISE_Exception", exc.Message, exc.StackTrace));
			}		

		}

		
		public override String Category  
		{
			 get
			{
				if (WmiHelper.IsKeyProperty(prop))
				{
					return "Key";
				}
				else
				{
					return "Local";
				}
			}
		}

		public override String Description  
		{
			get
			{				
				return WmiHelper.GetPropertyDescription(propName, mgmtClassObj, "", "");								
			}
		}

		public override Boolean IsBrowsable  
		{
			 get
			{
				return true;
			}
		}

		public override TypeConverter Converter 
		{
			get
			{
				
				if (prop.IsArray)
				{
					return new WMIArrayConverter(mgmtObj, propName);
				}	
					
				if (prop.Type == CimType.UInt16)
				{
					return new UInt16Converter();
				}
				
				if (prop.Type == CimType.UInt32)
				{
					return new UInt32Converter();
				}

				if (prop.Type == CimType.UInt64)
				{
					return new UInt64Converter();
				}

				if (prop.Type == CimType.SInt8)
				{
					return new SByteConverter();
				}
				
				return base.Converter;			
				
				
			}
		}
		public override Boolean IsReadOnly 
		{
			get
			{
				
				if (!CommitImmediately)	//this is a new instance or an object that requires transacted commit
				{
					return false;	//every property is writeable if this is a new instance
				}
				else
				{
					bool bIsWriteable = WmiHelper.IsPropertyWriteable(mgmtClassObj, classProp);
					return !bIsWriteable;
				}
			}
		}

		
		public override String Name
		{
			get
			{				
				return propName;
			}
		}
			
		public override Type ComponentType  
		{
			get
			{
				return typeof (WMIObjectComponent);
			}
		}

		
		public override Type PropertyType {
		    get 
			{
				return CimTypeMapper.ToType(prop.Type, prop.IsArray, prop);
			}
		}

				/*

				//Report the type of the actual property value.
				//This is important for numeric properties, where
				//CIM Type is different than the type of value (automation layer problem).

				Object val = prop.get_Value();

				if (val.GetType() != typeof(System.DBNull) && prop.CimType != WbemCimTypeEnum.wbemCimTypeDatetime )
				{
					return val.GetType();
				}
				else
				{					
					return CimTypeMapper.ToType(prop.CimType, prop.IsArray, prop);
				}
				*/

		

		public override void ResetValue (Object component)  
		{
			try
			{
				/*
				Object defValue = wmiClassObj.Properties_.Item(propName, 0).get_Value();
				prop.set_Value(ref defValue);
				if (CommitImmediately)
				{
					wmiObj.Put_((int)WbemChangeFlagEnum.wbemChangeFlagCreateOrUpdate
								| (int)WbemFlagEnum.wbemFlagUseAmendedQualifiers, 
								null);
				}*/

				prop.Value = classProp.Value;
				if (CommitImmediately)
				{
					PutOptions putOpts = new PutOptions(null,
													true,	//use amended qualifiers
													PutType.UpdateOrCreate);
	
					mgmtObj.Put(putOpts);
				}

			}
			catch (Exception exc)
			{
				throw (exc);
			}			
		}

		public override Boolean ShouldSerializeValue (Object component)  
		{
			return true;
		}
	
		
		public override Boolean CanResetValue (Object component)  
		{
			//Cannot reset key property (this would create a new instance)
			if (WmiHelper.IsKeyProperty(prop))
			{
				return false;
			}
			else
			{
				return !IsReadOnly;
			}
						
		}
		
		public override string DisplayName
		{
			get
			{
				return propName;
			}
		}

		public override Object GetValue (Object component)  
		{
			CimType CimType = prop.Type;

			if (prop == null)
			{
				return null;
			}

			
			//handle embedded objects and array of embedded objects
			if (CimType == CimType.Object)
			{
				return null;	//disabled for Beta1: too many problems
				//throw new Exception("Displaying embedded objects is not supported in Beta1");
				
			}
			

			if (prop.Value == null)
			{
				if (prop.IsArray)
				{
					return Array.CreateInstance(CimTypeMapper.ToType(CimType, false, prop), 0);
				}
				return null;
			}							
			
			//handle datetimes, intervals and arrays of datetimes and intervals
			if (CimType == CimType.DateTime)			
			{
				if (WmiHelper.IsInterval(prop))
				{
					if (prop.IsArray)
					{
						string[] strAr = (string[])prop.Value;
						TimeSpan[] retAr = new TimeSpan[strAr.Length];
						for (int i = 0; i < strAr.Length; i++)
						{
							retAr[i] = WmiHelper.ToTimeSpan(strAr[i]);
						}
						return retAr;
					}
					else
					{
						return WmiHelper.ToTimeSpan(prop.Value.ToString());
					}						
				}
				else
				{
					if (prop.IsArray)
					{
						string[] strAr = (string[])prop.Value;
						DateTime[] retAr = new DateTime[strAr.Length];
						for (int i = 0; i < strAr.Length; i++)
						{
							retAr[i] = WmiHelper.ToDateTime(strAr[i]);
						}
						return retAr;

					}
					else
					{
						return WmiHelper.ToDateTime(prop.Value.ToString());
					}
				}
			}

			return prop.Value;
	} 			
		

		public override void SetValue (Object component, Object val)  
		{     
			try
			{
				
				if (val == null || val == string.Empty || 
					((val.GetType().IsArray  || val.GetType() == typeof(System.Array))
						&& ((Array)val).Length == 0 ))
				{
					prop.Value = val;
					//Object obj = null;
					//prop.set_Value(ref obj);
				}

				if (val != null && (val.GetType().IsArray || val.GetType() == typeof(System.Array)))
				{
					if (((Array)val).GetValue(0).GetType() == typeof(DateTime))
					{
						Array arDT = (Array)val;	
						string[] strVal = new string[arDT.Length];
						for (int i = 0; i < strVal.Length; i++)
						{
							strVal[i] = WmiHelper.ToDMTFTime((DateTime)arDT.GetValue(i));
						}
						prop.Value = strVal;
					}
					else if (((Array)val).GetValue(0).GetType() == typeof(TimeSpan))
						{				
							Array arTS = (Array)val;	
							string[] strVal = new string[arTS.Length];
							for (int i = 0; i < strVal.Length; i++)
							{
								strVal[i] = WmiHelper.ToDMTFInterval((TimeSpan)arTS.GetValue(i));
							}
							prop.Value = strVal;
						}
						else
						{
		
							prop.Value = (Array)val;						
						}
				}

				if (val != null && !val.GetType().IsArray && val.GetType() != typeof(System.Array))
				{
					if (val.GetType() == typeof(DateTime))
					{
						string dmtf = WmiHelper.ToDMTFTime((DateTime)val);
						prop.Value = dmtf;
					}
					else if (val.GetType() == typeof(TimeSpan))
					{
						string dmtf = WmiHelper.ToDMTFInterval((TimeSpan)val);
						prop.Value = dmtf;
					}
					else
					{
						prop.Value = val;						
					}
				}
								
				if (CommitImmediately)
				{
					PutOptions putOpts = new PutOptions(null,
													true,	//use amended qualifiers
													PutType.UpdateOrCreate);
	
					mgmtObj.Put(putOpts);
				}
			}
			catch (Exception exc)
			{
				throw (exc);
			}
		}

		    
        public override bool Equals(object other) 
		{
            if (other is WMIPropertyDescriptor) 
			{
                WMIPropertyDescriptor descriptor = (WMIPropertyDescriptor) other;
                return ((descriptor.propName == propName) &&
						(descriptor.mgmtObj.Path.Path == mgmtObj.Path.Path ));
            }
            return false;
        }
/*
		public override MemberAttributeCollection Attributes 
		{
			get 
			{
				//MemberAttribute[] attrAr = new MemberAttribute[1];
				ArrayList attrAr = new ArrayList(10);
				
				if (prop.IsArray)
				{
					attrAr.Add (new TypeConverterAttribute("WMIArrayConverter"));
					attrAr.Add (new DescriptionAttribute("WMIArrayConverter attribute added"));
				}

				if (prop.CimType == WbemCimTypeEnum.wbemCimTypeUint16)
				{
					attrAr.Add (new TypeConverterAttribute("UInt16Converter"));
					attrAr.Add (new DescriptionAttribute("UInt16Converter attribute added"));
				}
				
				if (prop.CimType == WbemCimTypeEnum.wbemCimTypeUint32)
				{
					attrAr.Add (new TypeConverterAttribute("UInt32Converter"));
					attrAr.Add (new DescriptionAttribute("UInt32Converter attribute added"));
				}

				if (prop.CimType == WbemCimTypeEnum.wbemCimTypeUint64)
				{
					attrAr.Add (new TypeConverterAttribute("UInt64Converter"));
					attrAr.Add (new DescriptionAttribute("UInt64Converter attribute added"));
				}

				
				return new MemberAttributeCollection ((MemberAttribute[])attrAr.ToArray(typeof(MemberAttribute)));
				
			}
		}		
		*/
        
     
    }   
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vside\servexpl\beta1\extrinsiceventquerydialog.cs ===
namespace Microsoft.VSDesigner.WMI 
{

using System;
using System.ComponentModel;
using System.Core;
using System.WinForms;
using Microsoft.Win32.Interop;
using System.Drawing;
using WbemScripting;
using System.Collections;
using System.Data;

//using System.Web.UI.WebControls;

public class ExtrinsicEventQueryDialog : Form
{
	private Label eventClassLbl = new Label();
	private TextBox eventClassBox = new TextBox();	
	private Button selectClassBtn = new Button();

	private WMIObjectGrid grid = null;

	private TextBox QueryText = new TextBox ();

	private Button okBtn = new Button();
	private Button cancelBtn = new Button();

	private String serverName = string.Empty;

	private String queryString = string.Empty;
	

	public ExtrinsicEventQueryDialog(String serverIn)
	{	
		try
		{							
			serverName = serverIn;

			this.Text = WMISys.GetString("WMISE_ExtrEventQueryDlg_Title"); //loc
			this.AcceptButton = okBtn;
			this.AutoScaleBaseSize = (Size) new Point(5, 13);
			this.BorderStyle = FormBorderStyle.FixedSingle;
			int dlgWidth = 400;
			int dlgHeight = 400;
			this.ClientSize =  (Size) new Point(dlgWidth, dlgHeight);			
			this.ShowInTaskbar = false;
		
			eventClassLbl.Location = new Point(16, 16);
			eventClassLbl.Text = WMISys.GetString("WMISE_ExtrEventQueryDlg_EventClassLbl");

			eventClassBox.Location = new Point(16, 40);
			eventClassBox.Size = (Size) new Point(274, 18);
			eventClassBox.TabIndex = 1;

			selectClassBtn.Location = new Point(300, 40);
			selectClassBtn.Text = WMISys.GetString("WMISE_SelectClassBtn");
			selectClassBtn.Size = (Size)new Point(84, 25);

			selectClassBtn.Click += new EventHandler(this.OnSelectClass);
			selectClassBtn.TabIndex = 2;

			/*
			grid = new WMIObjectGrid(null, 
							PropertyFilters.NoSystem, 
							GridMode.EditMode,
							true, false, false);

			grid.Location = new Point(16, 70);
			grid.Size = (Size)new Point(368, 180);
			*/
			
			QueryText.Location = new Point(16, 270);	
			QueryText.Size = (Size)new Point(368, 60);
			QueryText.Multiline = true;
			QueryText.ReadOnly = false;
			QueryText.ScrollBars = ScrollBars.Vertical;	
			QueryText.TabIndex = 4;

			okBtn.Text = WMISys.GetString("WMISE_SubscribeBtn");
			okBtn.TabIndex = 5;
			okBtn.Location = new Point(225, 360);
			//okBtn.Click += new EventHandler(this.OnSubscribe);
			okBtn.DialogResult = DialogResult.OK;

			cancelBtn.Text = WMISys.GetString("WMISE_Cancel");
			cancelBtn.TabIndex = 6;
			cancelBtn.Location = new Point(310, 360);
			cancelBtn.DialogResult = DialogResult.Cancel;		
					
			this.Controls.All = new Control[] {eventClassLbl,
												eventClassBox,	
												selectClassBtn,
												//grid,
												QueryText,
												okBtn ,
												cancelBtn 
												};

		}

		catch (Exception exc)
		{
			MessageBox.Show(WMISys.GetString("WMISE_Exception", exc.Message, exc.StackTrace));
			throw (exc);
		}
	}

	
	public String QueryString
	{
		get 
		{
			return QueryText.Text;
		}
	}

	private String ClassName
	{
		get
		{
			if (eventClassBox.Text == string.Empty)
			{
				return "";
			}
			//split selClass into NS and ClassName parts (separated by ':')	
			char[] separ = new char[]{':'};
			String[] parts = eventClassBox.Text.Split(separ);
			if (parts.Length != 2)
			{
				return "";
			}				
			return parts[1];
		}
	}

	public String NS
	{
		get
		{
			if (eventClassBox.Text == string.Empty)
			{
				return "";
			}
			//split selClass into NS and ClassName parts (separated by ':')	
			char[] separ = new char[]{':'};
			String[] parts = eventClassBox.Text.Split(separ);
			if (parts.Length != 2)
			{
				return "";
			}		
			return parts[0];
		}

	}
	
	

	private void OnSelectClass (Object source, EventArgs args)
	{
		try
		{
				StringTable strs = new StringTable(50);					
								
				SelectWMIClassTreeDialog selectClassDlg = new SelectWMIClassTreeDialog(						
									serverName,	
									ClassFilters.ExtrinsicEvents,
									//SchemaFilters.NoSystem |SchemaFilters.NoAssoc,															
									strs);							
				
				
				DialogResult ret = ((SelectWMIClassTreeDialog)selectClassDlg).ShowDialog();
			
				if (ret != DialogResult.OK) 
				{
				    return;
				}

				String selClass = ((SelectWMIClassTreeDialog)selectClassDlg).SelectedClasses.ToArray()[0];
				eventClassBox.Text = selClass;

				if (grid != null)
				{
					this.Controls.Remove(grid);
					grid = null;
				}
				
				grid = new WMIObjectGrid(WmiHelper.GetClassObject(serverName, NS, ClassName), 
							PropertyFilters.NoSystem, 
							GridMode.EditMode,
							true, false, false);

				grid.Location = new Point(16, 70);
				grid.Size = (Size)new Point(368, 180);
				grid.Anchor = AnchorStyles.All;
				grid.PreferredColumnWidth = 90;
				grid.PreferredRowHeight = 19;
				grid.TabIndex = 3;	
				((DataTable)grid.DataSource).RowChanging += new DataRowChangeEventHandler(this.GridRowChanging);
	
				this.Controls.Add(grid);
			
				QueryText.Text = "SELECT * FROM " + ClassName;		


		}
		catch (Exception exc)
		{
			MessageBox.Show(WMISys.GetString("WMISE_Exception", exc.Message, exc.StackTrace));
		}
	}	
	

	private void OnSubscribe (Object source, EventArgs args)
	{
		try
		{

		}
		catch (Exception exc)
		{
			MessageBox.Show(WMISys.GetString("WMISE_Exception", exc.Message, exc.StackTrace));
		}
	}	

	/// <summary>
	/// This updates the "where" clause of the query text
	/// </summary>
	/// <param name="sender"> </param>
	/// <param name="e"> </param>
	protected void GridRowChanging(object sender,
								DataRowChangeEventArgs e) 
	{
		if (grid == null || grid.DataSource == null)
		{
			return;
		}

		//get rid of current "where" clause, if any
		string phrase = QueryString;
		phrase.ToUpper();
		int nWhere = phrase.IndexOf("WHERE");
		if (nWhere >= 0)
		{
			phrase = QueryString.Substring(0, nWhere);
		}

		QueryText.Text = phrase + 
			((WMIObjectPropertyTable)grid.DataSource).WhereClause;
	}
	

}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vside\servexpl\beta1\makefile.inc ===
!if 0
    -------------------------------------------------------------------------------------
        Don't modify... user variables are set in "sources"
    -------------------------------------------------------------------------------------
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vside\servexpl\beta1\extrinsiceventquerynode.cs ===
namespace Microsoft.VSDesigner.WMI {
    using System.Runtime.Serialization;
    using System.Diagnostics;
    using System;
    using System.WinForms;
    using System.Drawing;
    using System.Collections;
    using Microsoft.VSDesigner;
	using Microsoft.VSDesigner.ServerExplorer;
    using System.ComponentModel.Design;
	using System.ComponentModel;
	using System.Resources;

	using WbemScripting;


    // <doc>
    // <desc>
    //     This represents the wmi classes node under a server node.
    // </desc>
    // </doc>
    [UserContextAttribute("serveritem", "ExtrinsicEventQuery")]
    public class ExtrinsicEventQueryNode : Node, ISerializable  {
        //
        // FIELDS
        //

		enum SubscriptionState
		{
			Started,
			Stopped, 
			Error
		};

        static Image icon;
        public static readonly Type parentType = typeof(WMIExtrinsicEventsNode);
	    private string label = string.Empty;

		private ResourceManager rm = null;
		
		private string serverName = string.Empty;
		private string nsName = string.Empty;
		private string query = string.Empty;

		private ISWbemServices wbemServices = null;

		private SubscriptionState state =  SubscriptionState.Stopped;

		private SWbemSink theSink = null;

		private ExtrinsicEventQueryComponent browseObject = null;
	
        //
        // CONSTRUCTORS
        //

        // <doc>
        // <desc>
        //     Main constructor.
		//     Parameters: 
		//	string server (in, machine name)
		//	string pathIn (in, WMI path without the server name , e.g. "root\default:MyClass")
        // </desc>
        // </doc>
        public ExtrinsicEventQueryNode(string serverIn,
										string nsIn,
										string queryIn) {
			try
			{

				serverName = serverIn;
				nsName = nsIn;
				query = queryIn;

				state =  SubscriptionState.Stopped;
				
				try
				{
					rm = new ResourceManager( "Microsoft.VSDesigner.WMI.Res",     // Name of the resource.
							".",            // Use current directory.
							null);	
				}
				catch (Exception)
				{
					//do nothing, will use static RM
				}

				//Get and cache wbemServices
				ISWbemLocator wbemLocator = WmiHelper.WbemLocator;//(ISWbemLocator)(new SWbemLocator());

				wbemServices = wbemLocator.ConnectServer(serverName, 
									nsName, 
									"",	//user: blank defaults to current logged-on user
									"",	//password: blank defaults to current logged-on user
									"",	//locale: blank for current locale
									"",	//authority: NTLM or Kerberos. Blank lets DCOM negotiate.
									0,	//flags: reserved
									null);	//context info: not needed here
				if (wbemServices == null)
				{
					throw new Exception(WMISys.GetString("WMISE_WMIConnectFailed"));
				}	
				
				browseObject = new ExtrinsicEventQueryComponent(serverName, nsName, query, this);

				
			}
			catch (Exception exc)
			{
				MessageBox.Show(WMISys.GetString("WMISE_Exception", exc.Message, exc.StackTrace));
				throw (exc);
			}
		}

		
		/// <summary>
        ///     The object retrieves its serialization info.
        /// </summary>
        public ExtrinsicEventQueryNode(SerializationInfo info, StreamingContext context) {
            
			try 
			{
				try
				{
					rm = new ResourceManager( "Microsoft.VSDesigner.WMI.Res",     // Name of the resource.
							".",            // Use current directory.
							null);	
				}
				catch (Exception)
				{
					//do nothing, will use static RM
				}
			
				serverName = info.GetString("Server");
				nsName = info.GetString("NS");
				query = info.GetString("Query");

				state =  SubscriptionState.Stopped;
				
				rm = new ResourceManager( "Microsoft.VSDesigner.WMI.Res",     // Name of the resource.
							".",            // Use current directory.
							null);	

				//Get and cache wbemServices
				ISWbemLocator wbemLocator = WmiHelper.WbemLocator;//(ISWbemLocator)(new SWbemLocator());

				wbemServices = wbemLocator.ConnectServer(serverName, 
									nsName, 
									"",	//user: blank defaults to current logged-on user
									"",	//password: blank defaults to current logged-on user
									"",	//locale: blank for current locale
									"",	//authority: NTLM or Kerberos. Blank lets DCOM negotiate.
									0,	//flags: reserved
									null);	//context info: not needed here
				if (wbemServices == null)
				{
					throw new Exception(WMISys.GetString("WMISE_WMIConnectFailed"));
				}		
				
				browseObject = new ExtrinsicEventQueryComponent(serverName, nsName, query, this);				
			
                        
            }
            catch (Exception exc) {
				MessageBox.Show(WMISys.GetString("WMISE_Exception", exc.Message, exc.StackTrace));
				throw (exc);
            }
        }
		

        //
        // PROPERTIES
        //

        // <doc>
        // <desc>
        //     Returns icon for this node.
        // </desc>
        // </doc>
		
        public Image Icon {
            override get {
				//TODO: display different icons for associations, abstract, etc.
				if (icon == null)
				{	
					if (state ==  SubscriptionState.Started)
					{
						if (rm != null)
						{
							icon = (Image)rm.GetObject ("Microsoft.VSDesigner.WMI.Start.ico");
						}
						else
						{
		                    icon = new Icon(GetType(), "Start.ico").ToBitmap();
						}
					}
					else
					{
						if (state ==  SubscriptionState.Stopped)
						{
							if (rm != null)
							{
								icon = (Image)rm.GetObject ("Microsoft.VSDesigner.WMI.Stop.ico");
							}
							else
							{
							    icon = new Icon(GetType(), "Stop.ico").ToBitmap();
							}
						}
						else
						{
							if (rm != null)
							{
								icon = (Image)rm.GetObject ("Microsoft.VSDesigner.WMI.ErrorNode.ico");
							}
							else
							{
							    icon = new Icon(GetType(), "ErrorNode.ico").ToBitmap();
							}

						}
						
					}
					
				}				
				return icon;

            }
        }

	
	/// <summary>
	/// Context menu for a class object contains static method names
	/// </summary>
	public override ContextMenuItem[] GetContextMenuItems() 
	{			
		ContextMenuItem[] theMenu = new ContextMenuItem[4];		
		theMenu[0] = new ContextMenuItem(WMISys.GetString("WMISE_EventQueryStart"),
								new EventHandler(OnStartReceiving),
								(state != SubscriptionState.Started));	

		theMenu[1] = new ContextMenuItem(WMISys.GetString("WMISE_EventQueryStop"),
								new EventHandler(OnStopReceiving),
								(state == SubscriptionState.Started));	

		theMenu[2] = new ContextMenuItem(WMISys.GetString("WMISE_EventQueryPurge"),
								new EventHandler(OnPurgeEvents));
		//theMenu[3] = new ContextMenuItem("&Modify query...", 
		//						new EventHandler(OnModifyQuery));

       	return theMenu;
    }

	public override bool CanDeleteNode()
	{
		return true;
	}

	public override bool ConfirmDeletingNode()
	{
		return true;
	}

/*
	/// <summary>
    ///      The method returns a NewChildNode that, when double clicked, triggers add filter.
    /// </summary>
    /// <returns>
    ///      A NewChildNode, a child node, that supports add server node.
    /// </returns>
	 public override Node GetNewChildNode() {
        
		if (newChildNode == null) 
		{
            newChildNode = new NewChildNode();
			newChildNode.Label = "<Create New Instance...>"; //VSDSys.GetString("SE_NewServerNodeLabel_AddServer");
            newChildNode.WhenToSave = WhenToSaveCondition.Always;
			newChildNode.SetIconImage((Image)rm.GetObject ("inst.bmp"));
            newChildNode.DoubleClickHandler = new EventHandler(OnCreateNewInstance);
        }
        return newChildNode;
    }
*/
        // <doc>
        // <desc>
        //     Returns label constant for this node.
        // </desc>
        // </doc>
        public string Label {
            override get {
                if (label == null || label.Length == 0) {
                    label = query; 
                }
                return label;
            }
            override set {
            }
        }

        //
        // METHODS
        //

        // <doc>
        // <desc>
        //     Create instance nodes under this node.
        // </desc>
        // </doc>
        public override Node[] CreateChildren() {
	
		try
		{
			
			Node[] nodes = new Node[0];
			return nodes;
				
		}
		catch(Exception exc)
		{
			MessageBox.Show(WMISys.GetString("WMISE_Exception", exc.Message, exc.StackTrace));
			return null;
		}
			
        }

        // <doc>
        // <desc>
        //     This node is a singleton.
        // </desc>
        // </doc>
        public override int CompareUnique(Node node) {
            if (node is ExtrinsicEventQueryNode &&
				((ExtrinsicEventQueryNode)node).serverName == this.serverName &&
				((ExtrinsicEventQueryNode)node).nsName == this.nsName &&
				((ExtrinsicEventQueryNode)node).query == this.query)
			{
				return 1;
			}
			return 0;
        }
	
	
	/// <summary>
	/// Get component to be displayed in PB window
	/// </summary>
	public override Object GetBrowseComponent() 
	{	
		return browseObject;
    }


	/// <summary>
	/// Subscribes for event notifications
	/// </summary>
	/// <param name="sender"> </param>
	/// <param name="e"> </param>
	private void OnStartReceiving(object sender, EventArgs e)
	{
		try 
		{
			//TODO: enter subscription, change icon, disable "start" context menu
			if (theSink != null)
			{
				theSink = null;
			}

			theSink = (SWbemSink)(new SWbemSink());
			theSink.OnObjectReady += new ISWbemSinkEvents_OnObjectReadyEventHandler(this.OnEventReady);

			wbemServices.ExecNotificationQueryAsync(theSink, query, "WQL", 
													0, null, null);


			state =  SubscriptionState.Started;
			icon = (Image)rm.GetObject("Microsoft.VSDesigner.WMI.Start.ico");
			this.GetNodeSite().UpdateIcon();

            //GetNodeSite().AddChild(childNode);
		
		}
		catch(Exception exc)
		{
			state =  SubscriptionState.Error;
			icon = (Image)rm.GetObject("Microsoft.VSDesigner.WMI.ErrorNode.ico");
			this.GetNodeSite().UpdateIcon();
			MessageBox.Show(WMISys.GetString("WMISE_Exception", exc.Message, exc.StackTrace));
		}	
	}

	/// <summary>
	/// Un-subscribes from event notifications
	/// </summary>
	/// <param name="sender"> </param>
	/// <param name="e"> </param>
	private void OnStopReceiving(object sender, EventArgs e)
	{
		try 
		{
			//TODO: cancel subscription, change icon, disable "stop" context menu
			if (theSink != null)
			{
				theSink.Cancel();
			}

			state =  SubscriptionState.Stopped;
			icon = (Image)rm.GetObject("Microsoft.VSDesigner.WMI.Stop.ico");
			this.GetNodeSite().UpdateIcon();	
		
		}
		catch(Exception exc)
		{
			MessageBox.Show(WMISys.GetString("WMISE_Exception", exc.Message, exc.StackTrace));
		}	

	}

	/// <summary>
	/// Removes existing event entries
	/// </summary>
	/// <param name="sender"> </param>
	/// <param name="e"> </param>
	private void OnPurgeEvents(object sender, EventArgs e)
	{
		try 
		{
			//TODO: purge event entries
		
		}
		catch(Exception exc)
		{
			MessageBox.Show(WMISys.GetString("WMISE_Exception", exc.Message, exc.StackTrace));
		}	

	}

	
	    /// <summary>
        ///      To determine whether this node supports drag and drop.
        /// </summary>
        /// <returns>
        ///      TRUE to indicate ProcessNode supports drag and drop.
        /// </returns>
        public override bool HasDragComponents() {
            return false;	//change this!
        }

		public override IComponent[] CreateDragComponents(IDesignerHost designerHost) {
			/*
			Object comp = null;

			if (pathNoServer.ToLower() == "root\\cimv2:win32_share")
			{			
				comp = new Win32_Share (wmiObj);
			}
			else
			{
				comp  = new WMIObjectComponent(wmiObj);
			}

			return new IComponent[] {(IComponent)comp};
			*/

			return new IComponent[0];
        }

		/// <summary>
		/// This allows modification of the query string from outside, 
		/// e.g. from the browse component
		/// </summary>
		public String Query
		{
			get
			{
				return query;
			}
			set
			{
				if (state == SubscriptionState.Started)
				{
					OnStopReceiving(null, null);
				}

				query = value;	
				if (browseObject.Query != query)
				{
					browseObject.Query = query;
				}

				label = query;
				
				GetNodeSite().StartRefresh();
			}
		}

	/// <summary>
    ///     The object should write the serialization info.
    /// </summary>
    public virtual void GetObjectData(SerializationInfo si, StreamingContext context) {
		si.AddValue("Server", serverName);
		si.AddValue("NS", nsName);
		si.AddValue("Query", query);
    }

	private void OnEventReady(ISWbemObject obj, ISWbemNamedValueSet context)
	{
		MessageBox.Show("Event received: " + obj.GetObjectText_(0));
	}

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vside\servexpl\beta1\extrinsiceventsnode.cs ===
namespace Microsoft.VSDesigner.WMI {
    using System.Runtime.Serialization;
    using System.Diagnostics;
    using System;
    using System.WinForms;
    using System.Drawing;
    using System.Collections;
    using Microsoft.VSDesigner;
	using Microsoft.VSDesigner.ServerExplorer;
	using System.Resources;

	using WbemScripting;

    // <doc>
    // <desc>
    //     This represents the wmi classes node under a server node.
    // </desc>
    // </doc>
    [UserContextAttribute("serveritem", "wmiextrinsicevents")]
    public class WMIExtrinsicEventsNode : Node, ISerializable  {
        //
        // FIELDS
        //

        static Image icon;
        public static readonly Type parentType = typeof(ServerNode);
        private string label = string.Empty;
		
		private NewChildNode newChildNode = null;
		
		private ResourceManager rm = null;

        //
        // CONSTRUCTORS
        //

        // <doc>
        // <desc>
        //     Main constructor.
        // </desc>
        // </doc>
        public WMIExtrinsicEventsNode() {
				try
				{
					rm = new ResourceManager( "Microsoft.VSDesigner.WMI.Res",     // Name of the resource.
											".",            // Use current directory.
											null);	
				}
				catch (Exception)
				{
					//do nothing, will use static RM
				}

		}


		/// <summary>
        ///     The object retrieves its serialization info.
        /// </summary>
        public WMIExtrinsicEventsNode(SerializationInfo info, StreamingContext context) {
				try
				{
					rm = new ResourceManager( "Microsoft.VSDesigner.WMI.Res",     // Name of the resource.
											".",            // Use current directory.
											null);	
				}
				catch (Exception)
				{
					//do nothing, will use static RM
				}

        }

        //
        // PROPERTIES
        //

        // <doc>
        // <desc>
        //     Returns icon for this node.
        // </desc>
        // </doc>
		
        public Image Icon {
            override get {

				if (icon == null)
				{						
					if (rm != null)
					{
						icon = (Image)rm.GetObject ("Microsoft.VSDesigner.WMI.Events.bmp");
					}
					else
					{
	                    icon = (Image)new Bitmap(GetType(), "Events.bmp");
					}

				}				
				return icon;

            }
        }

		public override ContextMenuItem[] GetContextMenuItems() {
            return new ContextMenuItem[] {
                new ContextMenuItem(WMISys.GetString("WMISE_AddEventFilterCM"), new EventHandler(OnAddEventFilter)),
            };
        }

		/// <summary>
        ///      The method returns a NewChildNode that, when double clicked, triggers add filter.
        /// </summary>
        /// <returns>
        ///      A NewChildNode, a child node, that supports add filter node.
        /// </returns>
		 public override Node GetNewChildNode() {
            if (newChildNode == null) {
                newChildNode = new NewChildNode();
				newChildNode.Label = WMISys.GetString("WMISE_AddEventFilterLabel"); 
                newChildNode.WhenToSave = WhenToSaveCondition.Always;
				if (rm != null)
				{
					newChildNode.SetIconImage((Image)rm.GetObject ("Microsoft.VSDesigner.WMI.EventsNew.bmp"));
				}
				else
				{
	                newChildNode.SetIconImage((Image)new Bitmap(GetType(), "EventsNew.bmp"));
				}

                newChildNode.DoubleClickHandler = new EventHandler(OnAddEventFilter);
            }
            return newChildNode;
        }

        // <doc>
        // <desc>
        //     Returns label constant for this node.
        // </desc>
        // </doc>
        public string Label {
            override get {
                if (label == null || label.Length == 0) {
                    label = WMISys.GetString("WMISE_ExtrinsicEventNodeLbl");
                }
                return label;
            }
            override set {
            }
        }

        //
        // METHODS
        //

        // <doc>
        // <desc>
        //     Create process nodes under this node.
        // </desc>
        // </doc>
        public override Node[] CreateChildren() {
			/*
            Process[] processes = Process.GetProcesses(GetNodeSite().GetMachineName());
            Node[] nodes = new Node[processes.Length];
            for (int i = 0; i < processes.Length; i++) {
                Process process = processes[i];
                nodes[i] = new ProcessNode(process.Id, process.ProcessName);
            }

            return nodes;
			*/
	
            Node[] children = GetNodeSite().GetChildNodes();

            if (children == null || children.Length == 0) {
                children = new Node[] {
                                GetNewChildNode()                           
                };
            }

            return children;			
        }

        // <doc>
        // <desc>
        //     This node is a singleton.
        // </desc>
        // </doc>
        public override int CompareUnique(Node node) {
            return 0;
        }


		private void OnAddEventFilter(object sender, EventArgs e) {
 			
			try 
			{
				//get curretn server name
				ServerNode server = (ServerNode)GetNodeSite().GetParentNode();				
				String serverName = server.GetUNCName();

				ExtrinsicEventQueryDialog dlg = new ExtrinsicEventQueryDialog(serverName);
				DialogResult res = dlg.ShowDialog();

				if (res == DialogResult.Cancel)
				{
					return;
				}

				//add the node
				ExtrinsicEventQueryNode newChild = new ExtrinsicEventQueryNode(serverName,
													dlg.NS, dlg.QueryString);
				GetNodeSite().AddChild(newChild);

				
			}
			catch(Exception exc)
			{
				MessageBox.Show(WMISys.GetString("WMISE_Exception", exc.Message, exc.StackTrace));
			}	

        }

		/// <summary>
        ///     The object should write the serialization info.
        /// </summary>
        public virtual void GetObjectData(SerializationInfo si, StreamingContext context) {
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vside\servexpl\beta1\intrinsiceventquerydialog.cs ===
namespace Microsoft.VSDesigner.WMI 
{

using System;
using System.ComponentModel;
using System.Core;
using System.WinForms;
using Microsoft.Win32.Interop;
using System.Drawing;
using WbemScripting;
using System.Collections;

//using System.Web.UI.WebControls;

public class IntrinsicEventQueryDialog : Form
{

	private Label targetClassLbl = new Label();
	private TextBox targetClassBox = new TextBox();	
	private Button selectClassBtn = new Button();

	private Label selectEventLbl = new Label();
	private ComboBox eventBox = new ComboBox();

	private Label pollingIntervalLbl = new Label();
	private TextBox pollingIntervalBox = new TextBox();

	private Label secondsLbl = new Label();

	private TextBox QueryText = new TextBox ();

	private Button okBtn = new Button();
	private Button cancelBtn = new Button();

	private String serverName = string.Empty;

	private String[] arIntrinsicEvents = new String[] 	{
												WMISys.GetString("WMISE_IntrinsicEvent_Created"), 
												WMISys.GetString("WMISE_IntrinsicEvent_Modified"), 
												WMISys.GetString("WMISE_IntrinsicEvent_Deleted"), 
												WMISys.GetString("WMISE_IntrinsicEvent_Operated")
											};

	private String queryString = string.Empty;
	
	public IntrinsicEventQueryDialog(String serverIn)
	{	
		try
		{							
			serverName = serverIn;

			this.Text = WMISys.GetString("WMISE_IntrEventQueryDlg_Title");
			this.AcceptButton = okBtn;
			this.AutoScaleBaseSize = (Size) new Point(5, 13);
			this.BorderStyle = FormBorderStyle.FixedSingle;
			int dlgWidth = 400;
			int dlgHeight = 290;
			this.ClientSize =  (Size) new Point(dlgWidth, dlgHeight);
			this.ShowInTaskbar = false;
		
			targetClassLbl.Location = new Point(16, 16);
			targetClassLbl.Text = WMISys.GetString("WMISE_IntrEventQueryDlg_EventClassLbl");

			targetClassBox.Location = new Point(16, 40);
			targetClassBox.Size = (Size) new Point(200, 18);
			targetClassBox.TabIndex = 1;

			selectClassBtn.Location = new Point(230, 40);
			selectClassBtn.Text = WMISys.GetString("WMISE_SelectClassBtn");
			selectClassBtn.Click += new EventHandler(this.OnSelectClass);
			selectClassBtn.TabIndex = 2;

			selectEventLbl.Location = new Point(16, 82);
			selectEventLbl.Text = WMISys.GetString("WMISE_IntrEventQueryDlg_EventName");
			selectEventLbl.Size = (Size)new Point(210, 20);			

			eventBox.Style = ComboBoxStyle.DropDownList;
			eventBox.Items.Add(arIntrinsicEvents[0]);//loc
			eventBox.Items.Add(arIntrinsicEvents[1]);//loc
			eventBox.Items.Add(arIntrinsicEvents[2]);  //loc
			eventBox.Items.Add(arIntrinsicEvents[3]);  //loc

			eventBox.SelectedIndex = 0;
			eventBox.Location = new Point(230, 82);
			eventBox.Size = (Size)new Point(150, 20);
			eventBox.SelectedIndexChanged += new EventHandler(this.OnSelectEvent);
			eventBox.TabIndex = 3;

			pollingIntervalLbl.Location = new Point(16, 120);
			pollingIntervalLbl.Text = WMISys.GetString("WMISE_IntrEventQueryDlg_PollingInterval"); //loc
			pollingIntervalLbl.Size = (Size)new Point(210, 20);

			pollingIntervalBox.Location = new Point(230, 120);
			pollingIntervalBox.Size = (Size)new Point(50, 20);
			pollingIntervalBox.Text = "10";
			pollingIntervalBox.TextChanged += new EventHandler(this.OnPollingChanged);
			pollingIntervalBox.TabIndex = 4;

			secondsLbl.Location = new Point(290, 120);
			secondsLbl.Text = "WMISE_Seconds"; 

			QueryText.Location = new Point(16, 160);	
			QueryText.Size = (Size)new Point(368, 60);
			QueryText.Multiline = true;
			QueryText.ReadOnly = false;
			QueryText.ScrollBars = ScrollBars.Vertical;	
			QueryText.TabIndex = 5;

			okBtn.Text = WMISys.GetString("WMISE_SubscribeBtn");
			okBtn.TabIndex = 6;
			okBtn.Location = new Point(225, 250);
			//okBtn.Click += new EventHandler(this.OnSubscribe);
			okBtn.DialogResult = DialogResult.OK;	

			cancelBtn.Text = WMISys.GetString("WMISE_Cancel");

			cancelBtn.TabIndex = 7;
			cancelBtn.Location = new Point(310, 250);
			cancelBtn.DialogResult = DialogResult.Cancel;		
					
			this.Controls.All = new Control[] {targetClassLbl,
												targetClassBox,	
												selectClassBtn,
												selectEventLbl,
												eventBox,
												pollingIntervalLbl,
												pollingIntervalBox,
												secondsLbl,
												QueryText,
												okBtn ,
												cancelBtn 
												};												

		}

		catch (Exception exc)
		{
			MessageBox.Show(WMISys.GetString("WMISE_Exception", exc.Message, exc.StackTrace));
			throw (exc);
		}
	}

	private String EventName 
	{
		 get 
		{
			switch(eventBox.SelectedIndex)
			{
				case (0):
			{
				return "__InstanceCreationEvent";
			}
				case(1):
			{
				return "__InstanceModificationEvent";
			}
				case(2):
			{
				return "__InstanceDeletionEvent";
			}
				case(3):
			{
				return "__InstanceOperationEvent";
			}
				default:
					return "";
			}
		}	
	
	}
	public String QueryString
	{
		get 
		{
			return QueryText.Text;
		}
	}

	public String ClassName
	{
		get
		{
			if (targetClassBox.Text == string.Empty)
			{
				return "";
			}
			//split selClass into NS and ClassName parts (separated by ':')	
			char[] separ = new char[]{':'};
			String[] parts = targetClassBox.Text.Split(separ);
			if (parts.Length != 2)
			{
				return "";
			}				
			return parts[1];
		}
	}

	public String NS
	{
		get
		{
			if (targetClassBox.Text == string.Empty)
			{
				return "";
			}
			//split selClass into NS and ClassName parts (separated by ':')	
			char[] separ = new char[]{':'};
			String[] parts = targetClassBox.Text.Split(separ);
			if (parts.Length != 2)
			{
				return "";
			}		
			return parts[0];
		}

	}
	
	

	private void OnSelectClass (Object source, EventArgs args)
	{
		try
		{
				StringTable strs = new StringTable(50);					
								
				SelectWMIClassTreeDialog selectClassDlg = new SelectWMIClassTreeDialog(						
									serverName,			
									ClassFilters.ConcreteData,
									//SchemaFilters.NoEvent|SchemaFilters.NoAbstract|	SchemaFilters.NoSystem |SchemaFilters.NoAssoc,															
									strs);							
				
				
				DialogResult ret = ((SelectWMIClassTreeDialog)selectClassDlg).ShowDialog();
			
				if (ret != DialogResult.OK) 
				{
				    return;
				}

				String selClass = ((SelectWMIClassTreeDialog)selectClassDlg).SelectedClasses.ToArray()[0];
				targetClassBox.Text = selClass;

						
				QueryText.Text = "SELECT * FROM " + EventName + " WITHIN " + pollingIntervalBox.Text +
					" WHERE TargetInstance ISA \"" + ClassName + "\"";		


		}
		catch (Exception exc)
		{
			MessageBox.Show(WMISys.GetString("WMISE_Exception", exc.Message, exc.StackTrace));
		}
	}	
	

	private void OnSubscribe (Object source, EventArgs args)
	{
		try
		{

		}
		catch (Exception exc)
		{
			MessageBox.Show(WMISys.GetString("WMISE_Exception", exc.Message, exc.StackTrace));
		}
	}	

	private void OnSelectEvent (Object source, EventArgs args)
	{
		try
		{
			QueryText.Text = "SELECT * FROM " + EventName + " WITHIN " + pollingIntervalBox.Text +
					" WHERE TargetInstance ISA \"" + ClassName + "\"";		

		}
		catch (Exception exc)
		{
			MessageBox.Show(WMISys.GetString("WMISE_Exception", exc.Message, exc.StackTrace));
		}
	}	

	private void OnPollingChanged (Object source, EventArgs args)
	{
		try
		{
			QueryText.Text = "SELECT * FROM " + EventName + " WITHIN " + pollingIntervalBox.Text +
					" WHERE TargetInstance ISA \"" + ClassName + "\"";		

		}
		catch (Exception exc)
		{
			MessageBox.Show(WMISys.GetString("WMISE_Exception", exc.Message, exc.StackTrace));
		}
	}

}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vside\servexpl\beta1\intrinsiceventquerycomponent.cs ===
namespace Microsoft.VSDesigner.WMI {

	using System;
	using System.ComponentModel;
	using System.Core;
	using System.Collections;
	using System.WinForms;
	using WbemScripting;

	public class IntrinsicEventQueryComponent : Component
	{
		public readonly  string server = "";
		public readonly  string ns = "";
		public string query = "";	

		private IntrinsicEventQueryNode queryNode = null;
     
		public IntrinsicEventQueryComponent(String serverIn,
									String nsIn,
									String queryIn,
									IntrinsicEventQueryNode queryNodeIn)
		{					
			server = serverIn;
			ns = nsIn;
			query = queryIn;
			queryNode = queryNodeIn;
		}

		public override bool Equals(Object other)
		{
			if (!(other is IntrinsicEventQueryComponent))
			{
				return false;
			}
			if ((((IntrinsicEventQueryComponent)other).server == server) &&
				(((IntrinsicEventQueryComponent)other).ns == ns) &&
				(((IntrinsicEventQueryComponent)other).query == query) )
			{
				return true;
			}
			else
			{
				return false;
			}
		}


		[
		Browsable(true),
		ServerExplorerBrowsable(true)
		]
		public string Server
		{
			get
			{
				return server;
			}
		}

		
		[
		Browsable(true),
		ServerExplorerBrowsable(true)
		]
		public string WMINamespace
		{
			get
			{
				return ns;
			}
		}


		[
		Browsable(true),
		ServerExplorerBrowsable(true)
		]
		public string Query
		{
			get
			{
				return query;
			}
			set 
			{
				query = value;			
				queryNode.Query = value;				
			}
		}
			
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vside\servexpl\beta1\intrinsiceventsnode.cs ===
namespace Microsoft.VSDesigner.WMI {
    using System.Runtime.Serialization;
    using System.Diagnostics;
    using System;
    using System.WinForms;
    using System.Drawing;
    using System.Collections;
    using Microsoft.VSDesigner;
	using Microsoft.VSDesigner.ServerExplorer;
	using System.Resources;

	using WbemScripting;

    // <doc>
    // <desc>
    //     This represents the wmi classes node under a server node.
    // </desc>
    // </doc>
    [UserContextAttribute("serveritem", "wmiintrinsicevents")]
    public class WMIIntrinsicEventsNode : Node, ISerializable  {
        //
        // FIELDS
        //

        static Image icon;
        public static readonly Type parentType = typeof(ServerNode);
        private string label = string.Empty;
		
		private NewChildNode newChildNode = null;
		
		private ResourceManager rm = null;

        //
        // CONSTRUCTORS
        //

        // <doc>
        // <desc>
        //     Main constructor.
        // </desc>
        // </doc>
        public WMIIntrinsicEventsNode() {
			
			try
			{
				rm = new ResourceManager( "Microsoft.VSDesigner.WMI.Res",     // Name of the resource.
						".",            // Use current directory.
						null);	
			}
			catch (Exception)
			{
				//do nothing, will use static RM
			}
		}


		/// <summary>
        ///     The object retrieves its serialization info.
        /// </summary>
        public WMIIntrinsicEventsNode(SerializationInfo info, StreamingContext context) {
			rm = new ResourceManager( "Microsoft.VSDesigner.WMI.Res",     // Name of the resource.
							".",            // Use current directory.
							null);	

        }

        //
        // PROPERTIES
        //

        // <doc>
        // <desc>
        //     Returns icon for this node.
        // </desc>
        // </doc>
		
        public Image Icon {
            override get {

				if (icon == null)
				{						
					if (rm != null)
					{
						icon = (Image)rm.GetObject ("Microsoft.VSDesigner.WMI.Events.bmp");
					}
					else
					{
	                    icon = (Image)new Bitmap(GetType(), "Events.bmp");
					}

				}				
				return icon;

            }
        }

		public override ContextMenuItem[] GetContextMenuItems() {
            return new ContextMenuItem[] {
                new ContextMenuItem(WMISys.GetString("WMISE_AddEventFilterCM"), new EventHandler(OnAddEventFilter)),
            };
        }

		/// <summary>
        ///      The method returns a NewChildNode that, when double clicked, triggers add filter.
        /// </summary>
        /// <returns>
        ///      A NewChildNode, a child node, that supports add filter node.
        /// </returns>
		 public override Node GetNewChildNode() {
            if (newChildNode == null) {
                newChildNode = new NewChildNode();
				newChildNode.Label = WMISys.GetString("WMISE_AddEventFilterLabel"); 
                newChildNode.WhenToSave = WhenToSaveCondition.Always;
				if (rm != null)
				{
					newChildNode.SetIconImage((Image)rm.GetObject ("Microsoft.VSDesigner.WMI.EventsNew.bmp"));
				}
				else
				{
	                newChildNode.SetIconImage((Image)new Bitmap(GetType(), "EventsNew.bmp"));
				}

                newChildNode.DoubleClickHandler = new EventHandler(OnAddEventFilter);
            }
            return newChildNode;
        }

        // <doc>
        // <desc>
        //     Returns label constant for this node.
        // </desc>
        // </doc>
        public string Label {
            override get {
                if (label == null || label.Length == 0) {
                    label = WMISys.GetString("WMISE_IntrinsicEventNodeLbl");
                }
                return label;
            }
            override set {
            }
        }

        //
        // METHODS
        //

        // <doc>
        // <desc>
        //     Create process nodes under this node.
        // </desc>
        // </doc>
        public override Node[] CreateChildren() {
			/*
            Process[] processes = Process.GetProcesses(GetNodeSite().GetMachineName());
            Node[] nodes = new Node[processes.Length];
            for (int i = 0; i < processes.Length; i++) {
                Process process = processes[i];
                nodes[i] = new ProcessNode(process.Id, process.ProcessName);
            }

            return nodes;
			*/
	
            Node[] children = GetNodeSite().GetChildNodes();

            if (children == null || children.Length == 0) {
                children = new Node[] {
                                GetNewChildNode()                           
                };
            }

            return children;			
        }

        // <doc>
        // <desc>
        //     This node is a singleton.
        // </desc>
        // </doc>
        public override int CompareUnique(Node node) {
            return 0;
        }


		private void OnAddEventFilter(object sender, EventArgs e) {
 			
			try 
			{
				//get curretn server name
				ServerNode server = (ServerNode)GetNodeSite().GetParentNode();				
				String serverName = server.GetUNCName();

				IntrinsicEventQueryDialog dlg = new IntrinsicEventQueryDialog(serverName);
				DialogResult res = dlg.ShowDialog();
				if (res == DialogResult.Cancel)
				{
					return;
				}

				//add the node
				IntrinsicEventQueryNode newChild = new IntrinsicEventQueryNode(serverName,
													dlg.NS, dlg.QueryString);
				GetNodeSite().AddChild(newChild);

			}
			catch(Exception exc)
			{
				MessageBox.Show(WMISys.GetString("WMISE_Exception", exc.Message, exc.StackTrace));
			}	

        }

		/// <summary>
        ///     The object should write the serialization info.
        /// </summary>
        public virtual void GetObjectData(SerializationInfo si, StreamingContext context) {
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vside\servexpl\beta1\resourcecreator.cs ===
namespace Microsoft.VSDesigner.WMI {

using System;  
using System.Collections;
using System.Resources;
using System.Drawing;

class ResourceCreator {
   public static void Main() {

	  try
	  {

		ResourceWriter rw = new ResourceWriter("Microsoft.VSDesigner.WMI.Res.resources");

		rw.AddResource("Microsoft.VSDesigner.WMI.closed_fol.bmp",System.Drawing.Image.FromFile("c:\\lab\\SE Nodes\\art\\closed_fol.bmp"));
		rw.AddResource("Microsoft.VSDesigner.WMI.open_fol.bmp",System.Drawing.Image.FromFile("c:\\lab\\SE Nodes\\art\\open_fol.bmp"));
		rw.AddResource("Microsoft.VSDesigner.WMI.class.bmp",Image.FromFile("c:\\lab\\SE Nodes\\art\\class.bmp"));
		rw.AddResource("Microsoft.VSDesigner.WMI.classassoc.bmp",Image.FromFile("c:\\lab\\SE Nodes\\art\\classassoc.bmp"));
		rw.AddResource("Microsoft.VSDesigner.WMI.abstr1.bmp",Image.FromFile("c:\\lab\\SE Nodes\\art\\abstr1.bmp"));
		rw.AddResource("Microsoft.VSDesigner.WMI.abstr2.bmp",Image.FromFile("c:\\lab\\SE Nodes\\art\\abstr2.bmp"));
		rw.AddResource("Microsoft.VSDesigner.WMI.abstr_assoc1.bmp",Image.FromFile("c:\\lab\\SE Nodes\\art\\abstr_assoc1.bmp"));
		rw.AddResource("Microsoft.VSDesigner.WMI.abstr_assoc2.bmp",Image.FromFile("c:\\lab\\SE Nodes\\art\\abstr_assoc2.bmp"));					

		rw.AddResource("Microsoft.VSDesigner.WMI.ObjectViewer.bmp",Image.FromFile("c:\\lab\\SE Nodes\\art\\ObjectViewer.bmp"));					
		rw.AddResource("Microsoft.VSDesigner.WMI.Events.bmp",Image.FromFile("c:\\lab\\SE Nodes\\art\\Events.bmp"));					
		rw.AddResource("Microsoft.VSDesigner.WMI.EventsNew.bmp",Image.FromFile("c:\\lab\\SE Nodes\\art\\EventsNew.bmp"));					
		rw.AddResource("Microsoft.VSDesigner.WMI.inst.bmp",Image.FromFile("c:\\lab\\SE Nodes\\art\\inst.bmp"));					
		rw.AddResource("Microsoft.VSDesigner.WMI.ObjectViewerNew.bmp",Image.FromFile("c:\\lab\\SE Nodes\\art\\ObjectViewerNew.bmp"));					

  		rw.AddResource("Microsoft.VSDesigner.WMI.Start.ico",Image.FromFile("c:\\lab\\SE Nodes\\art\\Start.ico"));					
		rw.AddResource("Microsoft.VSDesigner.WMI.Stop.ico",Image.FromFile("c:\\lab\\SE Nodes\\art\\Stop.ico"));					
		rw.AddResource("Microsoft.VSDesigner.WMI.ErrorNode.ico",Image.FromFile("c:\\lab\\SE Nodes\\art\\ErrorNode.ico"));					

		//generic
	    rw.AddResource("WMISE_Cancel", "Cancel");			
		rw.AddResource("WMISE_Exception","Exception: {0}\n\rTrace: {1}");
		rw.AddResource("WMISE_SelectClassBtn", "Sele&ct class...");
		rw.AddResource("WMISE_SubscribeBtn", "Su&bscribe");
		rw.AddResource("WMISE_AddEventFilterCM", "&Add event filter...");
   		rw.AddResource("WMISE_AddEventFilterLabel", "<Add event filter...>");
   		rw.AddResource("WMISE_Seconds", "seconds");
		rw.AddResource("WMISE_OK", "OK");
		rw.AddResource("WMISE_NoDescr", "No description");
		rw.AddResource("WMISE_InvalidPath", "Invalid Object Path: {0}");

		//AssocGroupComponent.cs
		rw.AddResource("WMISE_AssocGroupClassPropertyDescr", "The name of the class to which the child nodes belong");
		rw.AddResource("WMISE_AssocGroupRolePropertyDescr",  "The role of the child nodes in the relationship");
		rw.AddResource("WMISE_AssocGroupAssocPropertyDescr", "The name of the relationship class");

		//ExecuteMethodDialog.cs
		rw.AddResource("WMISE_ExecMethodDlg_Title", "Execute Method {0}.{1}");
  		rw.AddResource("WMISE_ExecMethodDlg_ServerName", "Server: {0}");
  		rw.AddResource("WMISE_ExecMethodDlg_NoInputParams", "No Input Parameters");
  		rw.AddResource("WMISE_ExecMethodDlg_Execute", "Execute");
   		rw.AddResource("WMISE_ExecMethodDlg_InputParameters", "Input Parameters");
  		rw.AddResource("WMISE_ExecMethodDlg_OutputParameters", "Output Parameters");


		//ExtrinsicEventQueryDialog.cs
		rw.AddResource("WMISE_ExtrEventQueryDlg_Title",   "Build Management Event Query");
  		rw.AddResource("WMISE_ExtrEventQueryDlg_EventClassLbl",   "Event class: ");

		//ExtrinsicEventQueryNode.cs
		rw.AddResource("WMISE_EventQueryStop", "Sto&p");
		rw.AddResource("WMISE_EventQueryStart", "S&tart");
		rw.AddResource("WMISE_EventQueryPurge", "P&urge");

		//ExtrinsicEventNode.cs
		rw.AddResource("WMISE_ExtrinsicEventNodeLbl", "Management Events");

		//IntrinsicEventQueryDialog.cs
		rw.AddResource("WMISE_IntrinsicEvent_Created","Created");
 		rw.AddResource("WMISE_IntrinsicEvent_Modified","Modified");
  		rw.AddResource("WMISE_IntrinsicEvent_Deleted","Deleted");
  		rw.AddResource("WMISE_IntrinsicEvent_Operated","Created, Modified or Deleted");

  		rw.AddResource("WMISE_IntrEventQueryDlg_Title",   "Build Object Operation Event Query");
   		rw.AddResource("WMISE_IntrEventQueryDlg_EventClassLbl",   "Target class: ");

		rw.AddResource("WMISE_IntrEventQueryDlg_EventName", "Raise event when instance is: ");
		rw.AddResource("WMISE_IntrEventQueryDlg_PollingInterval", "Poll for events every: ");

	    //IntrinsicEventNode.cs
		rw.AddResource("WMISE_IntrinsicEventNodeLbl", "Management Data Events");

		//SelectWMIClassTreeDialog.cs
		rw.AddResource("WMISE_ClassSelectorLbl", "Add Objects");
		rw.AddResource("WMISE_ClassSelectorLblSearch", "&Find class containing:");
		rw.AddResource("WMISE_ClassSelectorBtnSearch", "Find &Next");
		rw.AddResource("WMISE_ClassSelectorBtnAdd", "&Add  >>");
		rw.AddResource("WMISE_ClassSelectorBtnRemove", "<<  &Remove");
		rw.AddResource("WMISE_ClassSelectorSelClassesLbl", "Se&lected classes:");
		rw.AddResource("WMISE_ClassSelectorAskViewAll", "Do you want to add all classes in this namespace?");
		rw.AddResource("WMISE_ClassSelectorClassAlreadySelected", "Class {0} is already selected");
  		rw.AddResource("WMISE_ClassSelectorDlgHelp", "This dialog allows you to select one or more Management classes. " +
			"The objects belonging to these classes will be then added as nodes to the Server Explorer tree");
		

		//WMIClassesNode.cs
		rw.AddResource("WMISE_ClassesNode_AddClass", "&Add Objects...");
		rw.AddResource("WMISE_ClassesNode_AddClassLbl", "<Add Objects...>");
		rw.AddResource("WMISE_ClassesNodeLbl", "Management Data");

		//WMIClassNode.cs
		rw.AddResource("WMISE_ClassNode_CreateNewInstance", "Create &New Object...");
		rw.AddResource("WMISE_ClassNode_NewInstanceLbl",  "<New {0}>");
		rw.AddResource("WMISE_ClassNode_RemovePrompt", "Are you sure you want to remove {0} from the view?");

		//WMIInstanceNode.cs
		rw.AddResource("WMISE_InstNode_SaveNewInstanceCM",  "Save");

		//WMIObjectComponent.cs
		rw.AddResource("WMISE_ObjComp_PutFailed",  "Could not save object {0}: {1}");

		
		//WMIObjectPropertyTable.cs
		rw.AddResource("WMISE_PropTable_ColumnName", "Name");
  		rw.AddResource("WMISE_PropTable_ColumnType", "Type");
		rw.AddResource("WMISE_PropTable_ColumnValue", "Value");
		rw.AddResource("WMISE_PropTable_ColumnDescription", "Description");
		rw.AddResource("WMISE_PropTable_ColumnComparison", "Operator");
		rw.AddResource("WMISE_PropTable_ColumnIsKey", "Key");
  		rw.AddResource("WMISE_PropTable_ColumnIsLocal", "Local");

		//namespace descriptions
		rw.AddResource("WMISE_NSDescription_Root", "The Root namespace is primarily designed to contain other namespaces. Typically, you should not use root to store your objects.");
  		rw.AddResource("WMISE_NSDescription_Root_Default", "The Default namespace is the default location where objects are stored if a namespace has not been specified.");
		rw.AddResource("WMISE_NSDescription_Root_Cimv2", "The CIMV2 namespace contains the majority of information about the status and configuration of the local system.");
		rw.AddResource("WMISE_NSDescription_Root_Cimv2_Applications", "The Applications namespace contains management objects for many applications installed on the local system.");
		rw.AddResource("WMISE_NSDescription_Root_Cimv2_Applications_MicrosoftIE", "The MicrosoftIE namespace contains object for managing Internet Explorer on the local system.");
		rw.AddResource("WMISE_NSDescription_Root_Directory", "The Directory namespace contains objects for directory services such as the Active Directory.");
		rw.AddResource("WMISE_NSDescription_Root_Directory_Ldap", "The LDAP namespace contains Active Directory schema and data. You may use this namespace to browse the Active Directory information visible to the local machine.");
		rw.AddResource("WMISE_NSDescription_Root_Wmi", "The WMI namespace contains detailed data supplied by Windows Driver Model (WDM) drivers installed on the local system.");
		rw.AddResource("WMISE_NSDescription_Root_Microsoft_SQLServer", "The MicrosoftSQLServer namespace contains objects for managing SQL Server 7.0 and 2000 systems.");






		rw.Write();	
		rw.Close();


		ResourceReader reader = new ResourceReader("Microsoft.VSDesigner.WMI.Res.resources");
		IDictionaryEnumerator enumRes = (IDictionaryEnumerator)((IEnumerable)reader).GetEnumerator();
		while (enumRes.MoveNext()) {
		  Console.WriteLine();
		  Console.WriteLine("Name: {0}", enumRes.Key);
		  Console.WriteLine("Value: {0}", enumRes.Value);
		}
		reader.Close();
  		

	  }
	  catch (Exception e)
	  {
		  System.Console.WriteLine(e.Message);
	  }

   }
}




}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vside\servexpl\beta1\intrinsiceventquerynode.cs ===
namespace Microsoft.VSDesigner.WMI {
    using System.Runtime.Serialization;
    using System.Diagnostics;
    using System;
    using System.WinForms;
    using System.Drawing;
    using System.Collections;
    using Microsoft.VSDesigner;
	using Microsoft.VSDesigner.ServerExplorer;
    using System.ComponentModel.Design;
	using System.ComponentModel;
	using System.Resources;

	using WbemScripting;


    // <doc>
    // <desc>
    //     This represents the wmi classes node under a server node.
    // </desc>
    // </doc>
    [UserContextAttribute("serveritem", "IntrinsicEventQuery")]
    public class IntrinsicEventQueryNode : Node, ISerializable  {
        //
        // FIELDS
        //

		enum SubscriptionState
		{
			Started,
			Stopped, 
			Error
		};

        static Image icon;
        public static readonly Type parentType = typeof(WMIIntrinsicEventsNode);
	    private string label = string.Empty;

		private ResourceManager rm = null;
		
		private string serverName = string.Empty;
		private string nsName = string.Empty;
		private string query = string.Empty;

		private ISWbemServices wbemServices = null;

		private SubscriptionState state =  SubscriptionState.Stopped;

		private SWbemSink theSink = null;

		private IntrinsicEventQueryComponent browseObject = null;
	
        //
        // CONSTRUCTORS
        //

        // <doc>
        // <desc>
        //     Main constructor.
		//     Parameters: 
		//	string server (in, machine name)
		//	string pathIn (in, WMI path without the server name , e.g. "root\default:MyClass")
        // </desc>
        // </doc>
        public IntrinsicEventQueryNode(string serverIn,
										string nsIn,
										string queryIn) {
			try
			{

				serverName = serverIn;
				nsName = nsIn;
				query = queryIn;

				state =  SubscriptionState.Stopped;
				
				try
				{
					rm = new ResourceManager( "Microsoft.VSDesigner.WMI.Res",     // Name of the resource.
							".",            // Use current directory.
							null);	
				}
				catch (Exception)
				{
					//do nothing, will use static RM
				}

				//Get and cache wbemServices
				ISWbemLocator wbemLocator = WmiHelper.WbemLocator;//(ISWbemLocator)(new SWbemLocator());

				wbemServices = wbemLocator.ConnectServer(serverName, 
									nsName, 
									"",	//user: blank defaults to current logged-on user
									"",	//password: blank defaults to current logged-on user
									"",	//locale: blank for current locale
									"",	//authority: NTLM or Kerberos. Blank lets DCOM negotiate.
									0,	//flags: reserved
									null);	//context info: not needed here
				if (wbemServices == null)
				{
					throw new Exception(WMISys.GetString("WMISE_WMIConnectFailed"));
				}	
				
				browseObject = new IntrinsicEventQueryComponent(serverName, nsName, query, this);

				
			}
			catch (Exception exc)
			{
				MessageBox.Show(WMISys.GetString("WMISE_Exception", exc.Message, exc.StackTrace));
				throw (exc);
			}
		}

		
		/// <summary>
        ///     The object retrieves its serialization info.
        /// </summary>
        public IntrinsicEventQueryNode(SerializationInfo info, StreamingContext context) {
            
			try 
			{
				try
				{
					rm = new ResourceManager( "Microsoft.VSDesigner.WMI.Res",     // Name of the resource.
											".",            // Use current directory.
											null);	
				}
				catch (Exception)
				{
					//do nothing, will use static RM
				}
			
				serverName = info.GetString("Server");
				nsName = info.GetString("NS");
				query = info.GetString("Query");

				state =  SubscriptionState.Stopped;
				
				rm = new ResourceManager( "Microsoft.VSDesigner.WMI.Res",     // Name of the resource.
							".",            // Use current directory.
							null);	

				//Get and cache wbemServices
				ISWbemLocator wbemLocator = WmiHelper.WbemLocator;//(ISWbemLocator)(new SWbemLocator());

				wbemServices = wbemLocator.ConnectServer(serverName, 
									nsName, 
									"",	//user: blank defaults to current logged-on user
									"",	//password: blank defaults to current logged-on user
									"",	//locale: blank for current locale
									"",	//authority: NTLM or Kerberos. Blank lets DCOM negotiate.
									0,	//flags: reserved
									null);	//context info: not needed here
				
				
				browseObject = new IntrinsicEventQueryComponent(serverName, nsName, query, this);				
			
                        
            }
            catch (Exception exc) {
				MessageBox.Show(WMISys.GetString("WMISE_Exception", exc.Message, exc.StackTrace));
				throw (exc);
            }
        }
		

        //
        // PROPERTIES
        //

        // <doc>
        // <desc>
        //     Returns icon for this node.
        // </desc>
        // </doc>
		
        public Image Icon {
            override get {
				//TODO: display different icons for associations, abstract, etc.
				if (icon == null)
				{

					if (state ==  SubscriptionState.Started)
					{
						if (rm != null)
						{
							icon = (Image)rm.GetObject ("Microsoft.VSDesigner.WMI.Start.ico");
						}
						else
						{
		                    icon = new Icon(GetType(), "Start.ico").ToBitmap();
						}
					}
					else
					{
						if (state ==  SubscriptionState.Stopped)
						{
							if (rm != null)
							{
								icon = (Image)rm.GetObject ("Microsoft.VSDesigner.WMI.Stop.ico");
							}
							else
							{
							    icon = new Icon(GetType(), "Stop.ico").ToBitmap();
							}
						}
						else
						{
							if (rm != null)
							{
								icon = (Image)rm.GetObject ("Microsoft.VSDesigner.WMI.ErrorNode.ico");
							}
							else
							{
							    icon = new Icon(GetType(), "ErrorNode.ico").ToBitmap();
							}

						}
						
					}
					
				}				
				return icon;

            }
        }

	
	/// <summary>
	/// Context menu for a class object contains static method names
	/// </summary>
	public override ContextMenuItem[] GetContextMenuItems() 
	{			
		ContextMenuItem[] theMenu = new ContextMenuItem[4];		
		theMenu[0] = new ContextMenuItem(WMISys.GetString("WMISE_EventQueryStart"),
								new EventHandler(OnStartReceiving),
								(state != SubscriptionState.Started));	

		theMenu[1] = new ContextMenuItem(WMISys.GetString("WMISE_EventQueryStop"),
								new EventHandler(OnStopReceiving),
								(state == SubscriptionState.Started));	

		theMenu[2] = new ContextMenuItem(WMISys.GetString("WMISE_EventQueryPurge"),
								new EventHandler(OnPurgeEvents));
		//theMenu[3] = new ContextMenuItem("&Modify query...", 
		//						new EventHandler(OnModifyQuery));

       	return theMenu;
    }

	public override bool CanDeleteNode()
	{
		return true;
	}

	public override bool ConfirmDeletingNode()
	{
		return true;
	}

/*
	/// <summary>
    ///      The method returns a NewChildNode that, when double clicked, triggers add filter.
    /// </summary>
    /// <returns>
    ///      A NewChildNode, a child node, that supports add server node.
    /// </returns>
	 public override Node GetNewChildNode() {
        
		if (newChildNode == null) 
		{
            newChildNode = new NewChildNode();
			newChildNode.Label = "<Create New Instance...>"; //VSDSys.GetString("SE_NewServerNodeLabel_AddServer");
            newChildNode.WhenToSave = WhenToSaveCondition.Always;
			newChildNode.SetIconImage((Image)rm.GetObject ("inst.bmp"));
            newChildNode.DoubleClickHandler = new EventHandler(OnCreateNewInstance);
        }
        return newChildNode;
    }
*/
        // <doc>
        // <desc>
        //     Returns label constant for this node.
        // </desc>
        // </doc>
        public string Label {
            override get {
                if (label == null || label.Length == 0) {
                    label = query; 
                }
                return label;
            }
            override set {
            }
        }

        //
        // METHODS
        //

        // <doc>
        // <desc>
        //     Create instance nodes under this node.
        // </desc>
        // </doc>
        public override Node[] CreateChildren() {
	
		try
		{
			
			Node[] nodes = new Node[0];
			return nodes;
				
		}
		catch(Exception exc)
		{
			MessageBox.Show(WMISys.GetString("WMISE_Exception", exc.Message, exc.StackTrace));
			return null;
		}
			
        }

        // <doc>
        // <desc>
        //     This node is a singleton.
        // </desc>
        // </doc>
        public override int CompareUnique(Node node) {
            if (node is IntrinsicEventQueryNode &&
				((IntrinsicEventQueryNode)node).serverName == this.serverName &&
				((IntrinsicEventQueryNode)node).nsName == this.nsName &&
				((IntrinsicEventQueryNode)node).query == this.query)
			{
				return 1;
			}
			return 0;
        }
	
	
	/// <summary>
	/// Get component to be displayed in PB window
	/// </summary>
	public override Object GetBrowseComponent() 
	{	
		return browseObject;
    }


	/// <summary>
	/// Subscribes for event notifications
	/// </summary>
	/// <param name="sender"> </param>
	/// <param name="e"> </param>
	private void OnStartReceiving(object sender, EventArgs e)
	{
		try 
		{
			//TODO: enter subscription, change icon, disable "start" context menu
			if (theSink != null)
			{
				theSink.Cancel();
				theSink = null;
			}

			theSink = new SWbemSink();
			theSink.OnObjectReady += new ISWbemSinkEvents_OnObjectReadyEventHandler(OnEventReady);
			theSink.OnProgress += new ISWbemSinkEvents_OnProgressEventHandler(OnQueryProgress);


			//MessageBox.Show("About to enter notification query: " + query); 

			wbemServices.ExecNotificationQueryAsync(theSink, query, "WQL", 
													(int)WbemFlagEnum.wbemFlagSendStatus, 
													null, null);


			state =  SubscriptionState.Started;
			icon = (Image)rm.GetObject("Microsoft.VSDesigner.WMI.Start.ico");
			this.GetNodeSite().UpdateIcon();

            //GetNodeSite().AddChild(childNode);
		
		}
		catch(Exception exc)
		{
			state =  SubscriptionState.Error;
			icon = (Image)rm.GetObject("Microsoft.VSDesigner.WMI.ErrorNode.ico");
			this.GetNodeSite().UpdateIcon();
			MessageBox.Show(WMISys.GetString("WMISE_Exception", exc.Message, exc.StackTrace));
		}	
	}

	/// <summary>
	/// Un-subscribes from event notifications
	/// </summary>
	/// <param name="sender"> </param>
	/// <param name="e"> </param>
	private void OnStopReceiving(object sender, EventArgs e)
	{
		try 
		{
			//TODO: cancel subscription, change icon, disable "stop" context menu
			if (theSink != null)
			{
				theSink.Cancel();
			}

			state =  SubscriptionState.Stopped;
			icon = (Image)rm.GetObject("Microsoft.VSDesigner.WMI.Stop.ico");
			this.GetNodeSite().UpdateIcon();	
		
		}
		catch(Exception exc)
		{
			MessageBox.Show(WMISys.GetString("WMISE_Exception", exc.Message, exc.StackTrace));
		}	

	}

	/// <summary>
	/// Removes existing event entries
	/// </summary>
	/// <param name="sender"> </param>
	/// <param name="e"> </param>
	private void OnPurgeEvents(object sender, EventArgs e)
	{
		try 
		{
			//TODO: purge event entries
		
		}
		catch(Exception exc)
		{
			MessageBox.Show(WMISys.GetString("WMISE_Exception", exc.Message, exc.StackTrace));
		}	

	}

	
	    /// <summary>
        ///      To determine whether this node supports drag and drop.
        /// </summary>
        /// <returns>
        ///      TRUE to indicate ProcessNode supports drag and drop.
        /// </returns>
        public override bool HasDragComponents() {
            return false;	//change this!
        }

		public override IComponent[] CreateDragComponents(IDesignerHost designerHost) {
			/*
			Object comp = null;

			if (pathNoServer.ToLower() == "root\\cimv2:win32_share")
			{			
				comp = new Win32_Share (wmiObj);
			}
			else
			{
				comp  = new WMIObjectComponent(wmiObj);
			}

			return new IComponent[] {(IComponent)comp};
			*/

			return new IComponent[0];
        }

		/// <summary>
		/// This allows modification of the query string from outside, 
		/// e.g. from the browse component
		/// </summary>
		public String Query
		{
			get
			{
				return query;
			}
			set
			{
				if (state == SubscriptionState.Started)
				{
					OnStopReceiving(null, null);
				}

				query = value;	
				if (browseObject.Query != query)
				{
					browseObject.Query = query;
				}

				label = query;
				
				GetNodeSite().StartRefresh();
			}
		}

	/// <summary>
    ///     The object should write the serialization info.
    /// </summary>
    public virtual void GetObjectData(SerializationInfo si, StreamingContext context) {
		si.AddValue("Server", serverName);
		si.AddValue("NS", nsName);
		si.AddValue("Query", query);
    }

	private static void OnEventReady(ISWbemObject obj, 
									ISWbemNamedValueSet context)
	{
		MessageBox.Show("Event received: " + obj.GetObjectText_(0));
	}

	private static void OnQueryProgress(int numTasks, 
										int curTask, 
										string message, 
										ISWbemNamedValueSet context)
	{
		MessageBox.Show("OnQueryProgress received: " + message);
	}

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vside\servexpl\beta1\uint32converter.cs ===
//------------------------------------------------------------------------------
/// <copyright from='1997' to='2001' company='Microsoft Corporation'>           
///    Copyright (c) Microsoft Corporation. All Rights Reserved.                
///    Information Contained Herein is Proprietary and Confidential.            
/// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace Microsoft.VSDesigner.WMI {
    using System.Runtime.Serialization.Formatters;
    using System.Globalization;
    using System.Runtime.Remoting;
    using System.Runtime.InteropServices;
	using System.ComponentModel;
    using System;
    using System.WinForms;

    using System.Diagnostics;

    using System.Core;

    /// <classonly/>
    /// <summary>
    ///    <para>
    ///       Provides a type converter to convert 32-bit signed integer objects to and
    ///       from various other representations.
    ///    </para>
    /// </summary>
    [System.Security.SuppressUnmanagedCodeSecurityAttribute()]
    public class UInt32Converter : TypeConverter {

        /// <summary>
        ///      Determines if this converter can convert an object in the given source
        ///      type to the native type of the converter.
        /// </summary>
        /// <param name='context'>
        ///      A formatter context.  This object can be used to extract additional information
        ///      about the environment this converter is being invoked from.  This may be null,
        ///      so you should always check.  Also, properties on the context object may also
        ///      return null.
        /// </param>
        /// <param name='sourceType'>
        ///      The type you wish to convert from.
        /// </param>
        /// <returns>
        ///      True if this object can perform the conversion.
        /// </returns>
        /// <seealso cref='System.ComponentModel.TypeConverter' />
        public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType) {
            if (sourceType == typeof(string)) {
                return true;
            }
            return base.CanConvertFrom(context, sourceType);
        }

        /// <summary>
        ///      Converts the given object to the converter's native type.
        /// </summary>
        /// <param name='context'>
        ///      A formatter context.  This object can be used to extract additional information
        ///      about the environment this converter is being invoked from.  This may be null,
        ///      so you should always check.  Also, properties on the context object may also
        ///      return null.
        /// </param>
        /// <param name='value'>
        ///      The object to convert.
        /// </param>
        /// <param name='arguments'>
        ///      An optional array of arguments to use when doing the conversion.  The arguments here
        ///      match the type and order of the Parse method on UInt32.
        /// </param>
        /// <returns>
        ///      The converted object.  This will throw an excetpion if the converson
        ///      could not be performed.
        /// </returns>
        /// <seealso cref='System.ComponentModel.TypeConverter' />
        public override object ConvertFrom(ITypeDescriptorContext context, object value, object[] arguments) {
            if (value is string) {
                string text = ((string)value).Trim();

                try {
                    if (text[0] == '#') {
                        return Convert.ToUInt32(text.Substring(1), 16);
                    }
                    else if (text.StartsWith("0x") 
                             || text.StartsWith("0X")
                             || text.StartsWith("&h")
                             || text.StartsWith("&H")) {
                        return Convert.ToUInt32(text.Substring(2), 16);
                    }
                    else {
                    
                        if (arguments == null || arguments.Length == 0) {
                            return UInt32.Parse(text);
                        }
                        else if (arguments.Length == 1) {
                            // This argument can either be the beginning to the parse parameters, or it may
                            // be a CultureInfo.
                            //
                            if (arguments[0] is CultureInfo) {
                                CultureInfo ci = (CultureInfo)arguments[0];
                                NumberFormatInfo formatInfo = (NumberFormatInfo)ci.GetServiceObject(typeof(NumberFormatInfo));
                                return UInt32.Parse(text, NumberStyles.Any, formatInfo);
                            }
                            else {
                                return UInt32.Parse(text, (NumberStyles)arguments[0]);
                            }
                        }
                        else {
                            return UInt32.Parse(text, (NumberStyles)arguments[0], (NumberFormatInfo)arguments[1]);
                        }
                    }
                }
                catch (Exception e) {
                    //throw new Exception(WMISys.GetString("ConvertInvalidPrimitive", text, "UInt32"), e);
					throw e;
                }
            }
            return base.ConvertFrom(context, value, arguments);
        }
        
        /// <summary>
        ///      Converts the given object to another type.  The most common types to convert
        ///      are to and from a string object.  The default implementation will make a call
        ///      to ToString on the object if the object is valid and if the destination
        ///      type is string.  If this cannot convert to the desitnation type, this will
        ///      throw a NotSupportedException.
        /// </summary>
        /// <param name='context'>
        ///      A formatter context.  This object can be used to extract additional information
        ///      about the environment this converter is being invoked from.  This may be null,
        ///      so you should always check.  Also, properties on the context object may also
        ///      return null.
        /// </param>
        /// <param name='value'>
        ///      The object to convert.
        /// </param>
        /// <param name='destinationType'>
        ///      The type to convert the object to.
        /// </param>
        /// <param name='arguments'>
        ///      An optional array of arguments to use when doing the conversion.  The arguments here
        ///      match the type and order of the Format method on UInt32.
        /// </param>
        /// <returns>
        ///      The converted object.
        /// </returns>
        public override Object ConvertTo(ITypeDescriptorContext context, Object value, Type destinationType, Object[] arguments) {
            if (destinationType == null) {
                throw new ArgumentNullException("destinationType");
            }

            if (destinationType == typeof(string) && value is UInt32) {
                
                if (arguments == null || arguments.Length == 0) {
                    return value.ToString();
                }
                else if (arguments.Length == 1) {
                    return UInt32.Format((UInt32)value, (string)arguments[0]);
                }
                else {
                    return UInt32.Format((UInt32)value, (string)arguments[0], (NumberFormatInfo)arguments[1]);
                }
            }
            
            return base.ConvertTo(context, value, destinationType, arguments);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vside\servexpl\beta1\wmiarrayconverter.cs ===
//------------------------------------------------------------------------------
/// <copyright from='1997' to='2001' company='Microsoft Corporation'>           
///    Copyright (c) Microsoft Corporation. All Rights Reserved.                
///    Information Contained Herein is Proprietary and Confidential.            
/// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace Microsoft.VSDesigner.WMI  {
    using System.Runtime.Serialization.Formatters;
    using System.Runtime.Remoting;
    using System.Runtime.InteropServices;
    using System.Core;
	using System;
    using System.Collections;
    using System.Diagnostics;
	using System.ComponentModel;
	using System.Management;
	using WbemScripting;
	using System.WinForms;

    /// <classonly/>
    /// <summary>
    ///    <para>
    ///       Provides a type converter to convert
    ///       Array objects to and from various other representations.
    ///    </para>
    /// </summary>
    [System.Security.SuppressUnmanagedCodeSecurityAttribute()]
    public class WMIArrayConverter : CollectionConverter {

		private ISWbemObject wbemObj = null;
		private ManagementObject mgmtObj = null;
		private string propName = null;

		public WMIArrayConverter( ISWbemObject wbemObjIn,									
									String propNameIn)
		{

			if (wbemObjIn == null || propName == string.Empty)
			{
				throw new ArgumentNullException();
			}
			wbemObj = wbemObjIn;
			propName = propNameIn;
			
		}

		
        /// <summary>
        ///    <para>
        ///       Converts the given (value) object to another type. The most common types to convert
        ///       are to and from a string object. The default implementation will make a call
        ///       to ToString on the object if the object is valid and if the destination
        ///       type is string. If this cannot convert to the desitnation type, this will
        ///       throw a NotSupportedException.
        ///    </para>
        /// </summary>
        /// <param name='context'>
        ///    A formatter context. This object can be used to extract additional information about the environment this converter is being invoked from. This may be null, so you should always check. Also, properties on the context object may also return null.
        /// </param>
        /// <param name='value'>
        ///    The object to convert.
        /// </param>
        /// <param name='destinationType'>
        ///    The type to convert the object to.
        /// </param>
        /// <param name='arguments'>
        ///    An optional array of arguments to use when doing the conversion. The number and content of these arguments is dependent on the implementer of the value formatter.
        /// </param>
        /// <returns>
        ///    <para>
        ///       The converted object.
        ///    </para>
        /// </returns>
        public override object ConvertTo(ITypeDescriptorContext context, object value, Type destinationType, object[] arguments) {
            if (destinationType == null) {
                throw new ArgumentNullException("destinationType");
            }

            if (destinationType == typeof(string)) {
                if (value is Array) {
                    return Sys.GetString("ArrayConverterText", value.GetType().Name);
                }
            }

            return base.ConvertTo(context, value, destinationType, arguments);
        }

        /// <summary>
        ///      Retrieves the set of properties for this type.  By default, a type has
        ///      does not return any properties.  An easy implementation of this method
        ///      can just call TypeDescriptor.GetProperties for the correct data type.
        /// </summary>
        /// <param name='context'>
        ///      A type descriptor through which additional context may be provided.
        /// </param>
        /// <param name='value'>
        ///      The value of the object to get the properties for.
        /// </param>
        /// <returns>
        ///      The set of properties that should be exposed for this data type.  If no
        ///      properties should be exposed, thsi may return null.  The default
        ///      implementation always returns null.
        /// </returns>
        public override PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, MemberAttribute[] attributes) {



            PropertyDescriptor[] props = null;

            if (value.GetType().IsArray) {
                Array valueArray = (Array)value;
                int length = valueArray.GetLength(0);
                props = new PropertyDescriptor[length];
                
                Type arrayType = value.GetType();
                Type elementType = arrayType.GetElementType();
                
                for (int i = 0; i < length; i++) {
                    props[i] = new ArrayPropertyDescriptor(arrayType, elementType, i);
                }
            }

            return new PropertyDescriptorCollection(props);
        }

        /// <summary>
        ///      Determines if this object supports properties.  
        /// </summary>
        /// <param name='context'>
        ///      A type descriptor through which additional context may be provided.
        /// </param>
        /// <returns>
        ///      Returns true if GetProperties should be called to find
        ///      the properties of this object.
        /// </returns>
        public override bool GetPropertiesSupported(ITypeDescriptorContext context) {
            return true;
        }

        private class ArrayPropertyDescriptor : SimplePropertyDescriptor {
            private int index;
			Type elementType = typeof(System.DBNull);

            public ArrayPropertyDescriptor(Type arrayType, Type elementTypeIn, int index) : base(arrayType, "[" + index + "]", elementTypeIn, null) {
                this.index = index;
				elementType = elementTypeIn;
            }

			public override TypeConverter Converter 
			{
				override get 
				{
						
					if (elementType ==typeof(UInt16))
					{
						return new UInt16Converter();
					}
					
					if (elementType ==typeof(UInt32))
					{
						return new UInt32Converter();
					}

					if (elementType ==typeof(UInt64))
					{
						return new UInt64Converter();
					}

					if (elementType ==typeof(SByte))
					{
						return new SByteConverter();
					}
					
					return base.Converter;			
				}
			}
			    
            public override object GetValue(object instance) {


                if (instance is Array) {
                    Array array = (Array)instance;
                    if (array.GetLength(0) > index) {
                        return array.GetValue(index);
                    }
                }
                
                return null;
            }
            
            public override void SetValue(object instance, object value) {


                if (instance is Array) {
                    Array array = (Array)instance;
                    if (array.GetLength(0) > index) {
                        array.SetValue(value, index);
                    }
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vside\servexpl\beta1\sbyteconverter.cs ===
//------------------------------------------------------------------------------
/// <copyright from='1997' to='2001' company='Microsoft Corporation'>           
///    Copyright (c) Microsoft Corporation. All Rights Reserved.                
///    Information Contained Herein is Proprietary and Confidential.            
/// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace Microsoft.VSDesigner.WMI {
    using System.Runtime.Serialization.Formatters;
    using System.Globalization;
    using System.Runtime.Remoting;
    using System.Runtime.InteropServices;
    using System.ComponentModel;
	using System;
	using System.WinForms;

    using System.Diagnostics;

    using System.Core;

    /// <classonly/>
    /// <summary>
    ///    <para>
    ///       Provides a type converter to convert
    ///       SByte objects to and from various other representations.
    ///    </para>
    /// </summary>
    [System.Security.SuppressUnmanagedCodeSecurityAttribute()]
    public class SByteConverter : TypeConverter {

        /// <summary>
        ///      Determines if this converter can convert an object in the given source
        ///      type to the native type of the converter.
        /// </summary>
        /// <param name='context'>
        ///      A formatter context.  This object can be used to extract additional information
        ///      about the environment this converter is being invoked from.  This may be null,
        ///      so you should always check.  Also, properties on the context object may also
        ///      return null.
        /// </param>
        /// <param name='sourceType'>
        ///      The type you wish to convert from.
        /// </param>
        /// <returns>
        ///      True if this object can perform the conversion.
        /// </returns>
        /// <seealso cref='System.ComponentModel.TypeConverter' />
        public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType) {
            if (sourceType == typeof(string)) {
                return true;
            }
            return base.CanConvertFrom(context, sourceType);
        }

        /// <summary>
        ///      Converts the given object to the converter's native type.
        /// </summary>
        /// <param name='context'>
        ///      A formatter context.  This object can be used to extract additional information
        ///      about the environment this converter is being invoked from.  This may be null,
        ///      so you should always check.  Also, properties on the context object may also
        ///      return null.
        /// </param>
        /// <param name='value'>
        ///      The object to convert.
        /// </param>
        /// <param name='arguments'>
        ///      An optional array of arguments to use when doing the conversion.  The arguments here
        ///      match the type and order of the Parse method on SByte.
        /// </param>
        /// <returns>
        ///      The converted object.  This will throw an excetpion if the converson
        ///      could not be performed.
        /// </returns>
        /// <seealso cref='System.ComponentModel.TypeConverter' />
        public override object ConvertFrom(ITypeDescriptorContext context, object value, object[] arguments) {
            if (value is string) {
                string text = ((string)value).Trim();

                try {
                    if (arguments == null || arguments.Length == 0) {
                        return SByte.Parse(text);
                    }
                    else if (arguments.Length == 1) {
                        // This argument can either be the beginning to the parse parameters, or it may
                        // be a CultureInfo.
                        //
                        if (arguments[0] is CultureInfo) {
                            CultureInfo ci = (CultureInfo)arguments[0];
                            NumberFormatInfo formatInfo = (NumberFormatInfo)ci.GetServiceObject(typeof(NumberFormatInfo));
                            return SByte.Parse(text, NumberStyles.Any, formatInfo);
                        }
                        else {
                            return SByte.Parse(text, (NumberStyles)arguments[0]);
                        }
                    }
                    else {
                        return SByte.Parse(text, (NumberStyles)arguments[0], (NumberFormatInfo)arguments[1]);
                    }
                }
                catch (Exception e) {
					throw e;
                }
            }
            return base.ConvertFrom(context, value, arguments);
        }
        
        /// <summary>
        ///      Converts the given object to another type.  The most common types to convert
        ///      are to and from a string object.  The default implementation will make a call
        ///      to ToString on the object if the object is valid and if the destination
        ///      type is string.  If this cannot convert to the desitnation type, this will
        ///      throw a NotSupportedException.
        /// </summary>
        /// <param name='context'>
        ///      A formatter context.  This object can be used to extract additional information
        ///      about the environment this converter is being invoked from.  This may be null,
        ///      so you should always check.  Also, properties on the context object may also
        ///      return null.
        /// </param>
        /// <param name='value'>
        ///      The object to convert.
        /// </param>
        /// <param name='destinationType'>
        ///      The type to convert the object to.
        /// </param>
        /// <param name='arguments'>
        ///      An optional array of arguments to use when doing the conversion.  The arguments here
        ///      match the type and order of the Format method on SByte.
        /// </param>
        /// <returns>
        ///      The converted object.
        /// </returns>
        public override object ConvertTo(ITypeDescriptorContext context, object value, Type destinationType, object[] arguments) {
            if (destinationType == null) {
                throw new ArgumentNullException("destinationType");
            }

            if (destinationType == typeof(string) && value is SByte) {
                
                if (arguments == null || arguments.Length == 0) {
                    return value.ToString();
                }
                else if (arguments.Length == 1) {
                    return SByte.Format((SByte)value, (string)arguments[0]);
                }
                else {
                    return SByte.Format((SByte)value, (string)arguments[0], (NumberFormatInfo)arguments[1]);
                }
            }
            
            return base.ConvertTo(context, value, destinationType, arguments);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vside\servexpl\beta1\uint16converter.cs ===
//------------------------------------------------------------------------------
/// <copyright from='1997' to='2001' company='Microsoft Corporation'>           
///    Copyright (c) Microsoft Corporation. All Rights Reserved.                
///    Information Contained Herein is Proprietary and Confidential.            
/// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace Microsoft.VSDesigner.WMI {
    using System.Runtime.Serialization.Formatters;
    using System.Globalization;
    using System.Runtime.Remoting;
    using System.Runtime.InteropServices;
	using System;    
	using System.ComponentModel;   
    using System.WinForms;

    using System.Diagnostics;

    using System.Core;

    /// <classonly/>
    /// <summary>
    ///    <para>
    ///       Provides a type converter to convert 16-bit signed integer objects to and
    ///       from various other representations.
    ///    </para>
    /// </summary>
    [System.Security.SuppressUnmanagedCodeSecurityAttribute()]
    public class UInt16Converter : TypeConverter {

        /// <summary>
        ///      Determines if this converter can convert an object in the given source
        ///      type to the native type of the converter.
        /// </summary>
        /// <param name='context'>
        ///      A formatter context.  This object can be used to extract additional information
        ///      about the environment this converter is being invoked from.  This may be null,
        ///      so you should always check.  Also, properties on the context object may also
        ///      return null.
        /// </param>
        /// <param name='sourceType'>
        ///      The type you wish to convert from.
        /// </param>
        /// <returns>
        ///      True if this object can perform the conversion.
        /// </returns>
        /// <seealso cref='System.ComponentModel.TypeConverter' />
        public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType) {
            if (sourceType == typeof(string)) {
                return true;
            }
            return base.CanConvertFrom(context, sourceType);
        }

        /// <summary>
        ///      Converts the given object to the converter's native type.
        /// </summary>
        /// <param name='context'>
        ///      A formatter context.  This object can be used to extract additional information
        ///      about the environment this converter is being invoked from.  This may be null,
        ///      so you should always check.  Also, properties on the context object may also
        ///      return null.
        /// </param>
        /// <param name='value'>
        ///      The object to convert.
        /// </param>
        /// <param name='arguments'>
        ///      An optional array of arguments to use when doing the conversion.  The arguments here
        ///      match the type and order of the Parse method on UInt16.
        /// </param>
        /// <returns>
        ///      The converted object.  This will throw an excetpion if the converson
        ///      could not be performed.
        /// </returns>
        /// <seealso cref='System.ComponentModel.TypeConverter' />
        public override object ConvertFrom(ITypeDescriptorContext context, object value, object[] arguments) {
            if (value is string) {
                string text = ((string)value).Trim();

                try {
                    if (text[0] == '#') {
                        return Convert.ToUInt16(text.Substring(1), 16);
                    }
                    else if (text.StartsWith("0x") 
                             || text.StartsWith("0X")
                             || text.StartsWith("&h")
                             || text.StartsWith("&H")) {
                        return Convert.ToUInt16(text.Substring(2), 16);
                    }
                    else {
                    
                        if (arguments == null || arguments.Length == 0) {
                            return UInt16.Parse(text);
                        }
                        else if (arguments.Length == 1) {
                            // This argument can either be the beginning to the parse parameters, or it may
                            // be a CultureInfo.
                            //
                            if (arguments[0] is CultureInfo) {
                                CultureInfo ci = (CultureInfo)arguments[0];
                                NumberFormatInfo formatInfo = (NumberFormatInfo)ci.GetServiceObject(typeof(NumberFormatInfo));
                                return UInt16.Parse(text, NumberStyles.Any, formatInfo);
                            }
                            else {
                                return UInt16.Parse(text, (NumberStyles)arguments[0]);
                            }
                        }
                        else {
                            return UInt16.Parse(text, (NumberStyles)arguments[0], (NumberFormatInfo)arguments[1]);
                        }
                    }
                }
                catch (Exception e) {
                    //throw new Exception(WMISys.GetString("ConvertInvalidPrimitive", text, "UInt16"), e);
					throw e;

                }
            }
            return base.ConvertFrom(context, value, arguments);
        }
        
        /// <summary>
        ///      Converts the given object to another type.  The most common types to convert
        ///      are to and from a string object.  The default implementation will make a call
        ///      to ToString on the object if the object is valid and if the destination
        ///      type is string.  If this cannot convert to the desitnation type, this will
        ///      throw a NotSupportedException.
        /// </summary>
        /// <param name='context'>
        ///      A formatter context.  This object can be used to extract additional information
        ///      about the environment this converter is being invoked from.  This may be null,
        ///      so you should always check.  Also, properties on the context object may also
        ///      return null.
        /// </param>
        /// <param name='value'>
        ///      The object to convert.
        /// </param>
        /// <param name='destinationType'>
        ///      The type to convert the object to.
        /// </param>
        /// <param name='arguments'>
        ///      An optional array of arguments to use when doing the conversion.  The arguments here
        ///      match the type and order of the Format method on UInt16.
        /// </param>
        /// <returns>
        ///      The converted object.
        /// </returns>
        public  override object ConvertTo(ITypeDescriptorContext context, object value, Type destinationType, object[] arguments) {
            if (destinationType == null) {
                throw new ArgumentNullException("destinationType");
            }

            if (destinationType == typeof(string) && value is UInt16) {
                
                if (arguments == null || arguments.Length == 0) {
                    return value.ToString();
                }
                else if (arguments.Length == 1) {
                    return UInt16.Format((UInt16)value, (string)arguments[0]);
                }
                else {
                    return UInt16.Format((UInt16)value, (string)arguments[0], (NumberFormatInfo)arguments[1]);
                }
            }
            
            return base.ConvertTo(context, value, destinationType, arguments);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vside\servexpl\beta1\uint64converter.cs ===
//------------------------------------------------------------------------------
/// <copyright from='1997' to='2001' company='Microsoft Corporation'>           
///    Copyright (c) Microsoft Corporation. All Rights Reserved.                
///    Information Contained Herein is Proprietary and Confidential.            
/// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace Microsoft.VSDesigner.WMI {
    using System.Runtime.Serialization.Formatters;
    using System.Globalization;
    using System.Runtime.Remoting;
    using System.Runtime.InteropServices;
	using System;
    using System.WinForms;
	using System.ComponentModel;    

    using System.Diagnostics;

    using System.Core;

    /// <classonly/>
    /// <summary>
    ///    <para>
    ///       Provides a type converter to convert 64-bit signed integer objects to and
    ///       from various other representations.
    ///    </para>
    /// </summary>
    /// <seealso cref='System.ComponentModel.TypeConverter'/>
    [System.Security.SuppressUnmanagedCodeSecurityAttribute()]
    public class UInt64Converter : TypeConverter {

        /// <summary>
        ///      Determines if this converter can convert an object in the given source
        ///      type to the native type of the converter.
        /// </summary>
        /// <param name='context'>
        ///      A formatter context.  This object can be used to extract additional information
        ///      about the environment this converter is being invoked from.  This may be null,
        ///      so you should always check.  Also, properties on the context object may also
        ///      return null.
        /// </param>
        /// <param name='sourceType'>
        ///      The type you wish to convert from.
        /// </param>
        /// <returns>
        ///      True if this object can perform the conversion.
        /// </returns>
        /// <seealso cref='System.ComponentModel.TypeConverter' />
        public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType) {
            if (sourceType == typeof(string)) {
                return true;
            }
            return base.CanConvertFrom(context, sourceType);
        }

        /// <summary>
        ///      Converts the given object to the converter's native type.
        /// </summary>
        /// <param name='context'>
        ///      A formatter context.  This object can be used to extract additional information
        ///      about the environment this converter is being invoked from.  This may be null,
        ///      so you should always check.  Also, properties on the context object may also
        ///      return null.
        /// </param>
        /// <param name='value'>
        ///      The object to convert.
        /// </param>
        /// <param name='arguments'>
        ///      An optional array of arguments to use when doing the conversion.  The arguments here
        ///      match the type and order of the Parse method on UInt64.
        /// </param>
        /// <returns>
        ///      The converted object.  This will throw an excetpion if the converson
        ///      could not be performed.
        /// </returns>
        /// <seealso cref='System.ComponentModel.TypeConverter' />
        public override object ConvertFrom(ITypeDescriptorContext context, object value, object[] arguments) {
            if (value is string) {
                string text = ((string)value).Trim();

                try {
                    if (text[0] == '#') {
                        return Convert.ToUInt64(text.Substring(1), 16);
                    }
                    else if (text.StartsWith("0x") 
                             || text.StartsWith("0X")
                             || text.StartsWith("&h")
                             || text.StartsWith("&H")) {
                        return Convert.ToUInt64(text.Substring(2), 16);
                    }
                    else {
                    
                        if (arguments == null || arguments.Length == 0) {
                            return UInt64.Parse(text);
                        }
                        else if (arguments.Length == 1) {
                            // This argument can either be the beginning to the parse parameters, or it may
                            // be a CultureInfo.
                            //
                            if (arguments[0] is CultureInfo) {
                                CultureInfo ci = (CultureInfo)arguments[0];
                                NumberFormatInfo formatInfo = (NumberFormatInfo)ci.GetServiceObject(typeof(NumberFormatInfo));
                                return UInt64.Parse(text, NumberStyles.Any, formatInfo);
                            }
                            else {
                                return UInt64.Parse(text, (NumberStyles)arguments[0]);
                            }
                        }
                        else {
                            return UInt64.Parse(text, (NumberStyles)arguments[0], (NumberFormatInfo)arguments[1]);
                        }
                    }
                }
                catch (Exception e) {

                    //throw new Exception(WMISys.GetString("ConvertInvalidPrimitive", text, "UInt16"), e);                   
					throw e;

                }
            }
            return base.ConvertFrom(context, value, arguments);
        }
        
        /// <summary>
        ///      Converts the given object to another type.  The most common types to convert
        ///      are to and from a string object.  The default implementation will make a call
        ///      to ToString on the object if the object is valid and if the destination
        ///      type is string.  If this cannot convert to the desitnation type, this will
        ///      throw a NotSupportedException.
        /// </summary>
        /// <param name='context'>
        ///      A formatter context.  This object can be used to extract additional information
        ///      about the environment this converter is being invoked from.  This may be null,
        ///      so you should always check.  Also, properties on the context object may also
        ///      return null.
        /// </param>
        /// <param name='value'>
        ///      The object to convert.
        /// </param>
        /// <param name='destinationType'>
        ///      The type to convert the object to.
        /// </param>
        /// <param name='arguments'>
        ///      An optional array of arguments to use when doing the conversion.  The arguments here
        ///      match the type and order of the Format method on UInt64.
        /// </param>
        /// <returns>
        ///      The converted object.
        /// </returns>
        public override object ConvertTo(ITypeDescriptorContext context, object value, Type destinationType, object[] arguments) {
            if (destinationType == null) {
                throw new ArgumentNullException("destinationType");
            }

            if (destinationType == typeof(string) && value is UInt64) {
                
                if (arguments == null || arguments.Length == 0) {
                    return value.ToString();
                }
                else if (arguments.Length == 1) {
                    return UInt64.Format((UInt64)value, (string)arguments[0]);
                }
                else {
                    return UInt64.Format((UInt64)value, (string)arguments[0], (NumberFormatInfo)arguments[1]);
                }
            }
            
            return base.ConvertTo(context, value, destinationType, arguments);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vside\servexpl\beta1\selectwmiclasstreedialog.cs ===
namespace Microsoft.VSDesigner.WMI {

		using System;
		using System.ComponentModel;
		using System.Core;
		using System.WinForms;
		using Microsoft.Win32.Interop;
		using System.Drawing;
		using WbemScripting;
		using System.Collections;
		using System.Resources;



		/// <summary>
		/// Filters define which classes will be displayed by the class selector UI
		/// </summary>
		public enum SchemaFilters
		{
			ShowAll    = 0,
			NoAbstract = 0x1,
			NoSystem   = 0x10,
			NoEvent    = 0x100,
			NoData     = 0x1000,
			NoAssoc    = 0x10000
		}

		public enum ClassFilters 
		{
			ConcreteData = 0,
			ExtrinsicEvents = 0x1,
			All = 0x10
		}


		public class SelectWMIClassTreeDialog : Form
		{
			private void InitializeComponent ()
			{
			}
			
			private enum ClassListControls 
			{
				ClassTreeView = 0,
				SelectedClassList = 1				
			}
			
			private ClassFilters currentFilters = ClassFilters.ConcreteData;
								/*
								SchemaFilters.NoAbstract |
								SchemaFilters.NoSystem | 
								SchemaFilters.NoEvent |
								SchemaFilters.NoAssoc ;*/

			private String machineName = String.Empty;

			private ResourceManager rm = null;


			private	ISWbemLocator wbemLocator = null;     
			private ISWbemServices wbemServices = null;
			
			private Button cancelBtn = new Button();
			private Button okBtn = new Button();
			//private ComboBox nsPicker = new ComboBox();
			private TreeView classList = new TreeView();
			private ListBox selectedClassList = new ListBox();

			private Button btnAdd = new Button();
			private Button btnRemove = new Button();

			private CheckBox chkShowAbstract = new CheckBox();
			private CheckBox chkShowSystem	 = new CheckBox();
			private CheckBox chkShowEvent	 = new CheckBox();
			private CheckBox chkShowData	 = new CheckBox();

			private Label labelSearch	= new Label();
			private TextBox descr	= new TextBox ();
			private Label labelSelected = new Label();
			private TextBox editSearch	= new TextBox();
			private Button btnGo = new Button();

			private TreeNode nodeLastFindNS = null;
			private String   strLastFindClass = "";
			
			private ArrayList listSearchHits = new ArrayList();

			private Color defaultForeColor = Color.Black;
			private Color defaultBackColor = Color.White;

			private ImageList imgList = new ImageList();

			private /*CaseInsensitiveHashtable*/ StringTable selectedClasses = null;



		/*
			//THIS IS THE STRIP:
			private enum schema_icons {
					SCHEMA_CLASS = 0,
					SCHEMA_CLASS_ABSTRACT1,
					SCHEMA_CLASS_ABSTRACT2,
					SCHEMA_CLASS_1,
					SCHEMA_4,
					SCHEMA_5,
					SCHEMA_6,
					SCHEMA_7,
					SCHEMA_ASSOC,
					SCHEMA_ASSOC_ABSTRACT1,
					SCHEMA_ASSOC_ABSTRACT2,
					SCHEMA_ASSOC_1,
					SCHEMA_ASSOC_2,
					SCHEMA_ASSOC_3,
					SCHEMA_14,
					SCHEMA_15,
					SCHEMA_NS_CLOSED,
					SCHEMA_NS_OPEN
				};
			*/
			private enum schema_icons 
			{
				SCHEMA_NS_CLOSED =0,
				SCHEMA_NS_OPEN,
				SCHEMA_CLASS,
				SCHEMA_ASSOC,
				SCHEMA_CLASS_ABSTRACT1,
				SCHEMA_CLASS_ABSTRACT2, 
				SCHEMA_ASSOC_ABSTRACT1,
				SCHEMA_ASSOC_ABSTRACT2
			};

	

			public ClassFilters CurrentFilters
			{
				get {
					return currentFilters;
				}			
			}

			
			public StringTable SelectedClasses 
			{

				get {
					return selectedClasses;
				}

				set {
					if (selectedClasses != value)
					{
						String [] arSel = value.ToArray();

						selectedClassList.Items.Clear();

						for (int i = 0; i < arSel.Length; i++)
						{							
							selectedClassList.Items.Add (arSel[i]);
						}						
					}
				}
			}

			public String CurrentServer
			{
				get {
					return machineName;
				}			
			}


			public SelectWMIClassTreeDialog(String server,
											ClassFilters filters,
											StringTable selClasses
											/*TODO: credentials */
											)
											
			{	

				try
				{
					try
					{
						rm = new ResourceManager( "Microsoft.VSDesigner.WMI.Res",     // Name of the resource.
								".",            // Use current directory.
								null);	
					}
					catch (Exception)
					{
						//do nothing, will use static RM
					}

					currentFilters = filters;				
					machineName = server;					
					selectedClasses = selClasses;							

					this.Text = WMISys.GetString("WMISE_ClassSelectorLbl");
					this.AcceptButton = okBtn;
					this.AutoScaleBaseSize = (Size) new Point(5, 13);
					this.BorderStyle = FormBorderStyle.FixedSingle;
					this.CancelButton = cancelBtn;
					int dlgWidth = 527;
					int dlgHeight = 480;
					this.ClientSize =  (Size) new Point(dlgWidth, dlgHeight);
					//this.add_KeyUp(new KeyEventHandler(this.OnKeyUp));
					this.ShowInTaskbar = false;

					labelSearch.Location = new Point(16, 16);	
					labelSearch.Size = (Size) new Point(200, 13);
					labelSearch.TabStop = false;			
					labelSearch.Text = WMISys.GetString("WMISE_ClassSelectorLblSearch");

					editSearch.Location = new Point(16, 33);
					editSearch.Size = (Size) new Point(200, 20);
					editSearch.TabStop = true;
					editSearch.TextChanged += new EventHandler(this.SearchPattern_changed);
					editSearch.AcceptsReturn = true; //???
					editSearch.TabIndex = 0;

					btnGo.Location = new Point(226, 33);
					btnGo.TabStop = true;
					btnGo.Text = WMISys.GetString("WMISE_ClassSelectorBtnSearch");
					btnGo.Click += new EventHandler(this.Search_click);
							
					classList.Location = new Point(16, 63);
					classList.Size = (Size) new Point(200, 270);
					classList.ShowPlusMinus = true;
					classList.ShowLines = true;
					classList.BeforeExpand += (new TreeViewCancelEventHandler(this.BeforeNodeExpand));
					classList.DoubleClick += (new EventHandler(this.Add_click));
					classList.BeforeCollapse += (new TreeViewCancelEventHandler(this.BeforeNodeCollapse));
					classList.AfterSelect += (new TreeViewEventHandler (this.AfterNodeSelect));
					classList.KeyUp += (new KeyEventHandler(this.OnTreeKeyUp));
					classList.HideSelection = false;
					classList.FullRowSelect = true;

				
					//Image symbols = Image.FromFile("symbols.bmp");
					//imgList.Images.AddStrip(symbols);	
					
					imgList.TransparentColor = defaultBackColor; //didn't help!!!!!!!
					if (rm != null)
					{
						imgList.Images.Add ((Image)rm.GetObject("Microsoft.VSDesigner.WMI.closed_fol.bmp"), defaultBackColor);
						imgList.Images.Add ((Image)rm.GetObject("Microsoft.VSDesigner.WMI.open_fol.bmp"), defaultBackColor);

						imgList.Images.Add ((Image)rm.GetObject("Microsoft.VSDesigner.WMI.class.bmp"), defaultBackColor);
						imgList.Images.Add ((Image)rm.GetObject("Microsoft.VSDesigner.WMI.classassoc.bmp"), defaultBackColor);

						imgList.Images.Add ((Image)rm.GetObject("Microsoft.VSDesigner.WMI.abstr1.bmp"), defaultBackColor);
						imgList.Images.Add ((Image)rm.GetObject("Microsoft.VSDesigner.WMI.abstr2.bmp"), defaultBackColor);
						imgList.Images.Add ((Image)rm.GetObject("Microsoft.VSDesigner.WMI.abstr_assoc1.bmp"), defaultBackColor); //SCHEMA_ASSOC_ABSTRACT1
						imgList.Images.Add ((Image)rm.GetObject("Microsoft.VSDesigner.WMI.abstr_assoc2.bmp"), defaultBackColor); //SCHEMA_ASSOC_ABSTRACT2

					}
					else	
					{
	                    imgList.Images.Add ((Image)new Bitmap(GetType(), "closed_fol.bmp"), defaultBackColor);
						imgList.Images.Add ((Image)new Bitmap(GetType(), "open_fol.bmp"), defaultBackColor);

						imgList.Images.Add ((Image)new Bitmap(GetType(), "class.bmp"), defaultBackColor);
						imgList.Images.Add ((Image)new Bitmap(GetType(), "classassoc.bmp"), defaultBackColor);

						imgList.Images.Add ((Image)new Bitmap(GetType(), "abstr1.bmp"), defaultBackColor);
						imgList.Images.Add ((Image)new Bitmap(GetType(), "abstr2.bmp"), defaultBackColor);
						imgList.Images.Add ((Image)new Bitmap(GetType(), "abstr_assoc1.bmp"), defaultBackColor); //SCHEMA_ASSOC_ABSTRACT1
						imgList.Images.Add ((Image)new Bitmap(GetType(), "abstr_assoc2.bmp"), defaultBackColor); //SCHEMA_ASSOC_ABSTRACT2

					}
					//classList.ImageList = imgList;


					/*
					TODO:
						ADD 
						MORE IMAGES 
						TO THE STRIP AND USE THE STRIP
						closed & open folder, assoc folders, obj groups etc.? */
					/*

					TODO: USE TRANSPARENT COLOR
					RIGHT NOW, BITMAPS HAVE WHITE INSTEAD OF TRANSPARENT
					*/

					btnAdd.Location = new Point(226, 150);
					btnAdd.TabStop = true;
					btnAdd.Text = WMISys.GetString("WMISE_ClassSelectorBtnAdd");
					btnAdd.Click += new EventHandler(this.Add_click);
					btnAdd.Enabled = false;

					btnRemove.Location = new Point(226, 200);
					btnRemove.TabStop = true;
					btnRemove.Text = WMISys.GetString("WMISE_ClassSelectorBtnRemove");
					btnRemove.Click += new EventHandler(this.Remove_click);
					btnRemove.Enabled = false;

					labelSelected.Location = new Point(311, 43);
					labelSelected.Size = (Size) new Point(200, 20);
					labelSelected.TabStop = false;			
					labelSelected.Text = WMISys.GetString("WMISE_ClassSelectorSelClassesLbl");

					selectedClassList.Location = new Point(311, 63);
					selectedClassList.Size = (Size) new Point(200, 270);
					selectedClassList.SelectionMode = SelectionMode.MultiExtended;
					selectedClassList.Sorted = true;
					//initialize selected class list
					String[] arSel = selectedClasses.ToArray();
					for (int i = 0; i < arSel.Length; i++)
					{
						selectedClassList.Items.Add (arSel[i]);
					}


					selectedClassList.Click += new EventHandler (this.AfterClassSelect);
					selectedClassList.KeyUp += new KeyEventHandler (this.OnClassListKeyUp);
					selectedClassList.DoubleClick += (new EventHandler(this.Remove_click));

/*
					chkShowData.Checked = ((currentFilters & SchemaFilters.NoData) == 0);
					chkShowData.Location = new Point(500, 370);
					chkShowData.Text = "Data";
					chkShowData.Click += new EventHandler(this.Filter_click);
					chkShowData.Visible = false;
		            			
					chkShowSystem.Checked = ((currentFilters & SchemaFilters.NoSystem) == 0);
					chkShowSystem.Location = new Point(550, 370);
					chkShowSystem.Text = "System";
					chkShowSystem.Click += new EventHandler(this.Filter_click);
					chkShowSystem.Visible = false;

					chkShowEvent.Checked = ((currentFilters & SchemaFilters.NoEvent) == 0);
					chkShowEvent.Location = new Point(500, 400);
					chkShowEvent.Text = "Event";
					chkShowEvent.Click += new EventHandler(this.Filter_click);
					chkShowEvent.Visible = false;

					chkShowAbstract.Checked = ((currentFilters & SchemaFilters.NoAbstract) == 0);
					chkShowAbstract.Location = new Point( 550, 400);
					chkShowAbstract.Text = "Abstract";
					chkShowAbstract.Click += new EventHandler(this.Filter_click);
					chkShowAbstract.Visible = false;
*/
					descr.Text = "";
					descr.Location = new Point (16, 342);
					descr.Size = (Size) new Point (500, 75);
					descr.Multiline = true;
					descr.ReadOnly = true;
					descr.ScrollBars = ScrollBars.Vertical;
					
					okBtn.Text = WMISys.GetString("WMISE_OK");
					okBtn.TabIndex = 1;
					okBtn.Location = new Point(350, 427);
					okBtn.DialogResult = DialogResult.OK;
					okBtn.Click += new EventHandler(this.OK_click);
					
					cancelBtn.Text = WMISys.GetString("WMISE_Cancel");
					cancelBtn.TabIndex = 2;
					cancelBtn.Location = new Point(436, 427);
					cancelBtn.DialogResult = DialogResult.Cancel;

					this.Controls.All = new Control[] {cancelBtn, 
									okBtn,
									classList,
									selectedClassList,
									//chkShowAbstract,
									//chkShowSystem,
									//chkShowEvent,
									//chkShowData,
									labelSearch,
									labelSelected,
									editSearch,
									btnGo,
									btnAdd,
									btnRemove,
									descr
									};


					wbemLocator = WmiHelper.WbemLocator;//(ISWbemLocator)(new SWbemLocator());     
					
					EnumNamespaces("root", 0);


				}

				catch (Exception exc)
				{
					MessageBox.Show(WMISys.GetString("WMISE_Exception", exc.Message, exc.StackTrace));
				}
			}

			private bool EnumNamespaces(String parent, int num)
			//recursively adds namespaces to the drop-down box
			{		
				try
				{	
					
					try
					{
						wbemServices = wbemLocator.ConnectServer(machineName, 
																parent, 
																"", "", "", "", 0, null);												
					}
					catch (Exception e)
					{
						//could not connect to the namespace
						//The most common cause is "Access denied"
						if (parent.ToLower() == "root")
						{
							//could not connect to Root, put error description text in the treeview
							TreeNode errNode = new TreeNode(e.Message);
							classList.Nodes.Add(num, errNode);

						}
						
						return false;
					}

					//show the node
					TreeNode dummy = new TreeNode("");
					TreeNode[] children = new TreeNode[] {dummy};
					TreeNode nsNode = new TreeNode(parent, 
													//(int)schema_icons.SCHEMA_NS_CLOSED, 
													//(int)schema_icons.SCHEMA_NS_CLOSED, 
													 children);
									
					nsNode.Collapse();
					classList.Nodes.Add(num, nsNode);

					
					ISWbemObjectSet objSet = wbemServices.InstancesOf("__NAMESPACE", 0, null);
				
					IEnumerator eInstances = ((IEnumerable)objSet).GetEnumerator();
				    while(eInstances.MoveNext())
					{
		                num++;
						
						ISWbemObject obj = (ISWbemObject)eInstances.Current;
						ISWbemPropertySet props = (ISWbemPropertySet)obj.Properties_;
		                							
						string NameOut = "";
						string curName = props.Item("Name", 0).get_Value().ToString();

						//skip localized namespace
						//NOTE: this assumes that localized namespaces are always leaf
						if (curName.ToUpper().IndexOf("MS_", 0) == 0)
						{
							continue;
						}

						//skip root\security namespace (we don't want to expose it)
						if (curName.ToUpper() == "SECURITY" && parent.ToUpper() == "ROOT")
						{
							continue;
						}

						//skip root\directory\ldap namespace (BUGBUG: change this in Beta2 when we can do asynchronous class enumerations)
						if (curName.ToUpper() == "LDAP" && parent.ToUpper() == "ROOT\\DIRECTORY")
						{
							continue;
						}

						
						if (parent != "")
						{
							NameOut = parent + "\\" + curName;
						}
						else
						{
							NameOut = curName;
						} 
					
						
						EnumNamespaces(NameOut, num);							
					}
					
					return true;
				}
				catch (Exception e)
				{
					MessageBox.Show(WMISys.GetString("WMISE_Exception", e.Message, e.StackTrace));
					return false;
				}	
			}

			protected virtual void BeforeNodeExpand(Object sender, TreeViewCancelEventArgs args)
			{
				TreeNode curNode = args.node;

				//check that this is a namespace
				if (curNode.Parent != null)
				{
					return;
				}

				//if list is empty (one empty child node is an indicator), get new classes
				curNode.ImageIndex = (int)schema_icons.SCHEMA_NS_OPEN;
				curNode.SelectedImageIndex = (int)schema_icons.SCHEMA_NS_OPEN;

				if ((curNode.Nodes.Count == 1 && curNode.Nodes[0].Text == "")) //list is empty		
				{
					
					ShowClasses( args.node);

				}	
			}

			protected virtual void BeforeNodeCollapse(Object sender, TreeViewCancelEventArgs args)
			{
				TreeNode curNode = args.node;

				//check that this is a namespace
				if (curNode.Parent != null)
				{
					return;
				}

				curNode.ImageIndex = (int)schema_icons.SCHEMA_NS_CLOSED;
				curNode.SelectedImageIndex = (int)schema_icons.SCHEMA_NS_CLOSED;

			}

			protected virtual void AfterNodeSelect(Object sender, TreeViewEventArgs args)
			{
				try
				{
					if (classList.SelectedNode != null)
					{
						btnAdd.Enabled = true;
					}

					TreeNode curNode = args.node;

					//check if this is a namespace
					if (curNode.Parent == null)
					{
						descr.Text = GetNSDescription(curNode.Text);						
					}
					else
					{
						//Update description field
						
						UpdateClassDescription(ClassListControls.ClassTreeView);
					}				
					
				}
				
				catch (Exception e)
				{
					MessageBox.Show(WMISys.GetString("WMISE_Exception", e.Message, e.StackTrace));
					
				}

			}

			protected virtual void AfterClassSelect(Object sender, EventArgs args)
			{
				if (selectedClassList.SelectedIndices.Count > 0)
				{
					btnRemove.Enabled = true;
				}		

				UpdateClassDescription(ClassListControls.SelectedClassList);

			}



			private bool ShowClasses(TreeNode curNode)
			{
				//show hourglass
				Cursor curSave = classList.Cursor;
				classList.Cursor = Cursors.WaitCursor;

				try 
				{
					//check that this is a namespace:
					if (curNode.Parent != null)
					{
						return false;
					}

					curNode.Nodes.Clear();			
				
					ISWbemServices  services = (ISWbemServices)wbemLocator.ConnectServer(machineName, 
																					curNode.Text,																	
																					"", "", "", "", 0, null);												
					ISWbemObjectSet objSet = services.SubclassesOf("", 0, null); 		
						
					IEnumerator eClasses = ((IEnumerable)objSet).GetEnumerator();
					
					SortedList classNameList = new SortedList(100);

					while (eClasses.MoveNext())
					{
						ISWbemObject obj = (ISWbemObject)eClasses.Current;	
						string childName = FilterPass(obj);
						if (childName != string.Empty)
						{
							classNameList.Add(childName, childName);									
						}				
					}	

					for (int i = 0; i < classNameList.Count; i++)
					{
						TreeNode child = new TreeNode(classNameList.GetByIndex(i).ToString());
						curNode.Nodes.Add(child);	
					}		

					classList.Cursor = curSave;

					return true;
				}
				catch (Exception e)
				{
					MessageBox.Show(WMISys.GetString("WMISE_Exception", e.Message, e.StackTrace));
					classList.Cursor = curSave;
					return false;

				}
			}

			private string FilterPass (ISWbemObject obj)
			{
				try 
				{
					String strLabel = ((ISWbemObjectPath)(obj.Path_)).RelPath;

					//TreeNode child = new TreeNode(strLabel);
					//child.ImageIndex = (int)schema_icons.SCHEMA_CLASS;
					//child.SelectedImageIndex = (int)schema_icons.SCHEMA_CLASS;				

					if (WmiHelper.IsAbstract(obj))
					{
						if (currentFilters == ClassFilters.ConcreteData)
						{
							return string.Empty;
						}
						if (!WmiHelper.IsEvent(obj) && (currentFilters == ClassFilters.ExtrinsicEvents))
						{
							return string.Empty;
						}
						//child.ImageIndex = (int)schema_icons.SCHEMA_CLASS_ABSTRACT2;
						//child.SelectedImageIndex = (int)schema_icons.SCHEMA_CLASS_ABSTRACT2;						
						
					}

					if (WmiHelper.IsAssociation(obj))
					{
						if (currentFilters != ClassFilters.All)
						{
							return string.Empty;
						}
						else
		                {
							if (!WmiHelper.IsAbstract (obj))
							{
								//child.ImageIndex = (int)schema_icons.SCHEMA_ASSOC;
								//child.SelectedImageIndex = (int)schema_icons.SCHEMA_ASSOC;	
							}
							//else
							//{//covered before, in the "abstract" case}
						}
					}

					if (WmiHelper.IsSystem(obj))
					{
						if (currentFilters != ClassFilters.All)
						{
							return string.Empty;
						}
						else
						{
							//child.ImageIndex = (int)schema_icons.SCHEMA_CLASS_ABSTRACT2;
							//child.SelectedImageIndex = (int)schema_icons.SCHEMA_CLASS_ABSTRACT2;
						}
					}

					if (WmiHelper.IsEvent(obj))
					{
						if (currentFilters == ClassFilters.ConcreteData)
						{
							return string.Empty;
						}
						else
						{
							//child.ImageIndex = (int)schema_icons.SCHEMA_CLASS_ABSTRACT2;
							//child.SelectedImageIndex = (int)schema_icons.SCHEMA_CLASS_ABSTRACT2;

						}
					}
					else
					{
						if (currentFilters == ClassFilters.ExtrinsicEvents)
						{
							return string.Empty;
						}

					}
				
					
					return strLabel;
				}
				catch (Exception e)
				{
					MessageBox.Show(WMISys.GetString("WMISE_Exception", e.Message, e.StackTrace));
					return string.Empty;
				}
			}

			

			private bool UpdateView ()
			{
				try 
				{
					
					classList.Nodes.Clear();
					EnumNamespaces("root", 0);
					

					return true;
				}
				catch (Exception e)
				{
					MessageBox.Show(WMISys.GetString("WMISE_Exception", e.Message, e.StackTrace));
					return false;
				}
			}

			private void Search_click (Object source, EventArgs args)
			{
				try 
				{
					TreeNode find = DoSearch();
					if (find != null)
					{
						classList.SelectedNode = find;

						//classList.SelectedImageIndex = find.Index;

						nodeLastFindNS = find.Parent;
						strLastFindClass = find.Text;

						find.BackColor = Color.DarkGray;
						find.ForeColor = Color.White;

						
						//add found node to a list, so that the color-coding is removed before 
						//the next search 

						//MessageBox.Show("Length of found nodes list is " + listSearchHits.Count);
						//MessageBox.Show("Found node is " + find.Text);
					
						listSearchHits.Add(find.Handle);
						
					}
								
				}
				catch (Exception e)
				{
					MessageBox.Show(WMISys.GetString("WMISE_Exception", e.Message, e.StackTrace));
					
				}
			}

			private void SearchPattern_changed (Object source, EventArgs args)
			{
				try 
				{
					nodeLastFindNS = null;
					strLastFindClass = "";


					//this is a temp workaround for URT bug 48695: uncomment this later
					/*
					if (editSearch.Text != "")
					{		
						this.AcceptButton = btnGo;
						this.UpdateDefaultButton();
					}
					else
					{
						this.AcceptButton = okBtn;
						this.UpdateDefaultButton();
					}
					*/
					
				}
				catch (Exception e)
				{
					MessageBox.Show(WMISys.GetString("WMISE_Exception", e.Message, e.StackTrace));
					
				}
			}		
			
			private TreeNode DoSearch()
			{
				try 
				{
					if (editSearch.Text == "")
					{
						return null;
					}

					bool bFound = false;					
					
					TreeNode retNode = null;
					if (nodeLastFindNS == null && strLastFindClass == "")	
					//Find first case
					{

						//clean up highlighted nodes from previous search
						
						IEnumerator enumHits = listSearchHits.GetEnumerator();
						while (enumHits.MoveNext())
						{
							Int32 curHandle = (Int32)enumHits.Current;

							TreeNode oldHit = TreeNode.FromHandle(classList, curHandle);
							
							oldHit.BackColor = defaultBackColor;
							oldHit.ForeColor = defaultForeColor;
						}

						//clean up the highlighted indices list
						listSearchHits.Clear();
						
						//enumerate nodes 
						for (int i = 0; i < classList.Nodes.Count; i++)
						{
							TreeNode curNode = classList.Nodes.All[i]; 
							
							if (curNode.Parent == null ) //this is a namespace
							{
							
								if (curNode.Nodes.Count == 1 &&	curNode.Nodes[0].Text == "")
								// a namespace hasn't been expanded before
								{	
									bool bRes = ShowClasses(curNode);												
								}

								String strPattern = editSearch.Text.ToLower();								
								
								for (int j = 0; j < curNode.Nodes.Count; j ++)
								{									
									String strClassName = curNode.Nodes.All[j].Text.ToLower();
																
									if  (strClassName.IndexOf(strPattern) >= 0)
									{
										bFound = true;
										retNode = curNode.Nodes.All[j];
										
										curNode.Expand(); //if a match was found, expand the namespace
										break;
									}
								}						

								if (bFound)
								{
									break;
								}
							}
						}				

					}
					else //Find next funtionality
					{
						//enumerate top-level nodes (namespaces)
						for (int i = 0; i < classList.Nodes.Count; i++)
						{
							TreeNode curNode = classList.Nodes.All[i]; 
							if (curNode.Parent == null && curNode.Index >= nodeLastFindNS.Index) //this is a namespace
							{
								if (curNode.Nodes.Count == 1 &&	curNode.Nodes[0].Text == "")
								// the namespace hasn't been expanded
								{								
									bool bRes = ShowClasses(curNode);	
								}

								String strPattern = editSearch.Text.ToLower();
								bool bSkipping = (nodeLastFindNS.Text.ToLower() == curNode.Text.ToLower());
								for (int j = 0; j < curNode.Nodes.Count; j ++)
								{
									String strClassName = curNode.Nodes.All[j].Text.ToLower();
									if (bSkipping)
									{
										if (strClassName == strLastFindClass.ToLower())
										{
											bSkipping = false;
											continue;
										}
									}
									else	//inspect class
									{
										if  (strClassName.IndexOf(strPattern) >= 0)
										{
											
											bFound = true;
											retNode = curNode.Nodes.All[j];
											
											curNode.Expand(); //if a match was found, expand the namespace

											break;
										}
									}
								}						
								if (bFound)
								{
									break;
								}
							}
						}			
					}

					/* wmi raid 2849: beta2. Don't have a localized string.
					 
					if (!bFound)
					{
						MessageBox.Show (WMISys.GetString("WMISE_Search_Failed", editSearch.Text));
					}*/

					return retNode;
				}
				catch (Exception e)
				{
					MessageBox.Show(WMISys.GetString("WMISE_Exception", e.Message, e.StackTrace));
					return null;
				}
			}

			private void OnClassDoubleClick (Object source, EventArgs args)
			{
				try 
				{
						
					if (classList.SelectedNode.Parent == null)
					{
						//this is a namespace
						return;
					}
					String path = classList.SelectedNode.Parent.Text + ":" + classList.SelectedNode.Text;

					//SingleViewContainerDlg dlg = new SingleViewContainerDlg(path);
					//DialogResult ret = dlg.ShowDialog(this);

								
				}
				catch (Exception e)
				{
					MessageBox.Show(WMISys.GetString("WMISE_Exception", e.Message, e.StackTrace));
					
				}
			}
			
			private void Add_click (Object source, EventArgs args)
			{
				try 
				{
					if (classList.SelectedNode.Parent == null)
					{
						//this is a namespace
						DialogResult res = 
							MessageBox.Show(WMISys.GetString("WMISE_ClassSelectorAskViewAll"),
											"",
											MessageBox.YesNo);
						if (res == DialogResult.No)
						{
							return;
						}
						else
						{
							AddWholeNS(classList.SelectedNode);

						}

					}
					else
					{

						DoAddNode (classList.SelectedNode);
					}
				
					classList.SelectedNode = null;
					btnAdd.Enabled = false;
					
					
				}

				catch (Exception e)
				{
					MessageBox.Show(WMISys.GetString("WMISE_Exception", e.Message, e.StackTrace));
				}
			}


			private void Remove_click (Object source, EventArgs args)
			{
				try 
				{	
					while (selectedClassList.SelectedItems.All.Length > 0)
					{
						selectedClassList.Items.Remove(selectedClassList.SelectedItems.All[0]);
					}	

					if (selectedClassList.SelectedItems.Count <= 0)
					{
						btnRemove.Enabled = false;
					}					
					
				}

				catch (Exception e)
				{
					MessageBox.Show(WMISys.GetString("WMISE_Exception", e.Message, e.StackTrace));
				}
			}

			private void OK_click (Object source, EventArgs args)
			{
				try 
				{	
					selectedClasses.Clear();

					for (int i = 0; i < selectedClassList.Items.All.Length; i++)
					{
						selectedClasses.Add (selectedClassList.Items.All[i].ToString());
					}
				}

				catch (Exception e)
				{
					MessageBox.Show(WMISys.GetString("WMISE_Exception", e.Message, e.StackTrace));
				}
			}

			
			private void AddWholeNS(TreeNode selNode)
			{
				try 
				{
					if (selNode.Parent != null)
					{
						//this is not a namespace
						return;
					}
					if (selNode.Nodes.Count == 1 &&	selNode.Nodes[0].Text == "")
					// the namespace hasn't been expanded before
					{
		            			bool bRes = ShowClasses(selNode);	
					}

					for (int j = 0; j < selNode.Nodes.Count; j ++)
					{
						DoAddNode(selNode.Nodes.All[j]);
					}
					
				}
				catch (Exception e)
				{
					MessageBox.Show(WMISys.GetString("WMISE_Exception", e.Message, e.StackTrace));
				}
			}

			private void DoAddNode (TreeNode node)
			{
				try 
				{
					String path = 			
						node.Parent.Text + ":" + node.Text;

					//see if the item is already there
					for (int i = 0; i < selectedClassList.Items.All.Length; i++)
					{
						if (selectedClassList.Items.All[i].ToString().ToUpper() == path.ToUpper())
						{
							MessageBox.Show(WMISys.GetString("WMISE_ClassSelectorClassAlreadySelected", path));
							//selectedClassList.SelectedItem = selectedClassList.Items.All[i];
							return;
						}
					}

					//if not, add it:			
					selectedClassList.Items.Add(path);	
					
				}
				catch (Exception e)
				{
					MessageBox.Show(WMISys.GetString("WMISE_Exception", e.Message, e.StackTrace));					
				}
			}


			private string GetNSDescription (string nsName)
			{
							
					if (nsName.ToLower() == "root")
					{
						return 	WMISys.GetString("WMISE_NSDescription_Root");
					}
					if (nsName.ToLower() == "root\\default")
					{
						return 	WMISys.GetString("WMISE_NSDescription_Root_Default");
					}
					if (nsName.ToLower() == "root\\cimv2")
					{
						return 	WMISys.GetString("WMISE_NSDescription_Root_Cimv2");
					}
					if (nsName.ToLower() == "root\\cimv2\\applications")
					{
						return 	WMISys.GetString("WMISE_NSDescription_Root_Cimv2_Applications");
					}
					if (nsName.ToLower() == "root\\cimv2\\applications\\microsoftie")
					{
						return 	WMISys.GetString("WMISE_NSDescription_Root_Cimv2_Applications_MicrosoftIE");
					}
					if (nsName.ToLower() == "root\\directory")
					{
						return 	WMISys.GetString("WMISE_NSDescription_Root_Directory");
					}
					if (nsName.ToLower() == "root\\directory\\ldap")
					{
						return 	WMISys.GetString("WMISE_NSDescription_Root_Directory_Ldap");
					}
					if (nsName.ToLower() == "root\\wmi")
					{
						return 	WMISys.GetString("WMISE_NSDescription_Root_Wmi");
					}
					if (nsName.ToLower() == "root\\microsoftsqlserver")
					{
						return 	WMISys.GetString("WMISE_NSDescription_Root_Microsoft_SQLServer");
					}
							
					return string.Empty;

			}

					
			private void OnClassListKeyUp (Object sender, KeyEventArgs args)
			{
				if ((args.KeyData == Keys.Up && args.Modifiers == Keys.None) ||
					(args.KeyData == Keys.Down && args.Modifiers == Keys.None))
				{
					if (selectedClassList.SelectedIndices.Count > 0)
					{
						btnRemove.Enabled = true;
					}

					UpdateClassDescription(ClassListControls.SelectedClassList);
				}				
			}

			private void OnTreeKeyUp (Object sender, KeyEventArgs args)
			{
				if ((args.KeyData == Keys.Up && args.Modifiers == Keys.None) ||
					(args.KeyData == Keys.Down && args.Modifiers == Keys.None))
				{
					if (classList.SelectedNode != null)
					{
						btnAdd.Enabled = true;
					}						

					if (classList.SelectedNode.Parent == null)
					{
						descr.Text = GetNSDescription(classList.SelectedNode.Text);						
					}
					else
					{
						this.UpdateClassDescription(ClassListControls.ClassTreeView);						
					}
				}
			}
			
			private bool UpdateClassDescription (ClassListControls curControl)
			{

				string ns = string.Empty;
				string className = string.Empty;
				if (curControl == ClassListControls.ClassTreeView)
				{
					if (classList.SelectedNode != null)
					{
						ns = classList.SelectedNode.Parent.Text;
						className = classList.SelectedNode.Text;											
					}
				}
				else	//this is a selected class list
				{
					//see if this is a multiple selection (or nothing is selected) and clear description in this case
					if (selectedClassList.SelectedIndices.Count != 1)
					{
						descr.Text = string.Empty; 
						return true;
					}
						
					string relPath = selectedClassList.SelectedItem.ToString();	
					ns = relPath.Substring(0, relPath.IndexOf(":"));
					className = relPath.Substring(relPath.IndexOf(":") + 1);
					
					// MessageBox.Show(path);						
				}							
				
				ISWbemObject obj = WmiHelper.GetClassObject(machineName,
															ns, 
															className);				
									
				string theDescr = WmiHelper.GetClassDescription(obj);
				if (theDescr != string.Empty)
				{
					//Add special handling for newlines: change all "\n" to System.Environment.NewLine:
					int i = -1;
					string theRest = theDescr;
					string theStart = string.Empty;
					while ((i = theRest.IndexOf("\n")) >= 0)
					{
						theStart = theStart + theRest.Substring(0, i) + System.Environment.NewLine;
						theRest = theRest.Substring(i + 1);
					}
					theDescr = theStart + theRest;

					descr.Text = theDescr;
					return true;
				}
				else
				{
					descr.Text = WMISys.GetString("WMISE_NoDescr");
					return false;
				}
				
			}

			public void CleanUpPreviousSelections ()
			{
				try 
				{												
					IEnumerator enumHits = listSearchHits.GetEnumerator();
					while (enumHits.MoveNext())
					{
						Int32 curHandle = (Int32)enumHits.Current;

						TreeNode oldHit = TreeNode.FromHandle(classList, curHandle);
						
						oldHit.BackColor = defaultBackColor;
						oldHit.ForeColor = defaultForeColor;
					}

					//clean up the highlighted indices list
					listSearchHits.Clear();

					//classList.SelectedNode = null;

					selectedClassList.SelectedIndices.Clear();

					descr.Text = string.Empty;
					
				}
				catch (Exception e)
				{
					MessageBox.Show(WMISys.GetString("WMISE_Exception", e.Message, e.StackTrace));
					
				}
			}


			/*
			private void Filter_click(Object source, EventArgs args)
			{
				try 
				{

					SchemaFilters newFilters = SchemaFilters.ShowAll;

					if (!chkShowAbstract.Checked)
					{
						newFilters |= SchemaFilters.NoAbstract;
					}
					if (!chkShowSystem.Checked)
					{
						newFilters |= SchemaFilters.NoSystem;
					}
					if (!chkShowEvent.Checked)
					{
						newFilters |= SchemaFilters.NoEvent;
					}
					if (!chkShowData.Checked)
					{
						newFilters |= SchemaFilters.NoData;
					}
					
					currentFilters = newFilters;

					//TODO: Re-filter open classes;
					UpdateView();
					
					
				}
				catch (Exception e)
				{
					MessageBox.Show(WMISys.GetString("WMISE_Exception", e.Message, e.StackTrace));
					return;
				}
			}*/

		/*
			
		private void something ()
			{
				try 
				{
					
				}
				catch (Exception e)
				{
					MessageBox.Show(WMISys.GetString("WMISE_Exception", e.Message, e.StackTrace));
					
				}
			}
		*/

			/*
			//Handle F3 for searching here
			protected override void OnKeyUp (KeyEventArgs args)
			{
				try 
				{	
					//MessageBox.Show("key up: " + args.ToString());
					if (args.KeyData == Keys.F3)
					{
						Search_click (this, null);
					}
					else
					{
						base.OnKeyUp(args);
					}
					
				}

				catch (Exception e)
				{
					MessageBox.Show(WMISys.GetString("WMISE_Exception", e.Message, e.StackTrace));
				}
			}
*/

		}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vside\servexpl\beta1\wmiclassesnode.cs ===
namespace Microsoft.VSDesigner.WMI 

{   
	
	using System.Runtime.Serialization;
    using System.Diagnostics;
    using System;
    using System.WinForms;
    using System.Drawing;
    using System.Collections;
    using Microsoft.VSDesigner;
	using Microsoft.VSDesigner.ServerExplorer;
	using System.Resources;
	using System.IO;


	using WbemScripting;

    // <doc>
    // <desc>
    //     This represents the wmi classes node under a server node.
    // </desc>
    // </doc>
    [UserContextAttribute("serveritem", "wmiclasses")]
    public class WMIClassesNode : Node, ISerializable  {
        //
        // FIELDS
        //

        static Image icon;
        public static readonly Type parentType = typeof(ServerNode);
        private string label = string.Empty;
        private NewChildNode newChildNode = null;

		private ResourceManager rm = null;

		private static string[] DefaultClasses  = new string[]
		{			
			"Win32_Process",
			"Win32_Thread",
			"Win32_Share",
			"Win32_Service",
			"Win32_Printer",
			"Win32_LogicalDisk",
			"Win32_ComputerSystem",
			"Win32_OperatingSystem",
			"Win32_NetworkAdapter",
			"Win32_Desktop",
			"Win32_NTEventLogFile",
			"Win32_NetworkConnection",
			"Win32_Product",
			"Win32_Processor",
			"Win32_SystemAccount"
		};

		private const string DefaultNS = "root\\CIMV2";

	private Object selectClassDlg;

        //
        // CONSTRUCTORS
        //

        // <doc>
        // <desc>
        //     Main constructor.
        // </desc>
        // </doc>
        public WMIClassesNode() { 
			try
			{
				try
				{
					rm = new ResourceManager( "Microsoft.VSDesigner.WMI.Res",     // Name of the resource.
							".",            // Use current directory.
							null);	
				}
				catch (Exception)
				{
					//do nothing, will use static RM
				}

				//TextWriterTraceListener lstnr = new TextWriterTraceListener(File.OpenWrite("d:\\temp\\WMI-se.log"));
				Trace.AutoFlush = true;
				//Trace.Listeners.Add(lstnr);

				IEnumerator enumListeners = ((IEnumerable)Trace.Listeners).GetEnumerator();

				/*
				while (enumListeners.MoveNext())
				{
					MessageBox.Show ("Listener " + enumListeners.Current.GetType().FullName + ", " + 
						((TraceListener)enumListeners.Current).Name);				
				}
				*/
                
				
			}
			catch(Exception exc)
			{
				MessageBox.Show(WMISys.GetString("WMISE_Exception", exc.Message, exc.StackTrace));
				throw (exc);
			}
		}

		/// <summary>
        ///     The object retrieves its serialization info.
        /// </summary>
        public WMIClassesNode(SerializationInfo info, StreamingContext context) {

			try
			{
				try
				{
					rm = new ResourceManager( "Microsoft.VSDesigner.WMI.Res",     // Name of the resource.
							".",            // Use current directory.
							null);	
				}
				catch (Exception)
				{
					//do nothing, will use static RM
				}
				
			}
			catch(Exception exc)
			{
				MessageBox.Show(WMISys.GetString("WMISE_Exception", exc.Message, exc.StackTrace));
				throw (exc);
			}

        }

        //
        // PROPERTIES
        //

        // <doc>
        // <desc>
        //     Returns icon for this node.
        // </desc>
        // </doc>
		
        public Image Icon {
            override get {
				if (icon == null)
				{						
					if (rm != null)
					{
						icon = (Image)rm.GetObject ("Microsoft.VSDesigner.WMI.ObjectViewer.bmp");
					}
					else
					{
	                    icon = (Image)new Bitmap(GetType(), "ObjectViewer.bmp");
					}

				}							
				
				return icon;
			}
        }

		public override ContextMenuItem[] GetContextMenuItems() {
            return new ContextMenuItem[] {
                new ContextMenuItem(WMISys.GetString("WMISE_ClassesNode_AddClass"), new EventHandler(OnSelectWMIClass)),
            };
        }

		/// <summary>
        ///      The method returns a NewChildNode that, when double clicked, triggers add filter.
        /// </summary>
        /// <returns>
        ///      A NewChildNode, a child node, that supports add server node.
        /// </returns>
		 public override Node GetNewChildNode() {
            if (newChildNode == null) {
                newChildNode = new NewChildNode();
				newChildNode.Label = WMISys.GetString("WMISE_ClassesNode_AddClassLbl");
                newChildNode.WhenToSave = WhenToSaveCondition.Always;
				if (rm != null)
				{
					newChildNode.SetIconImage((Image)rm.GetObject ("Microsoft.VSDesigner.WMI.ObjectViewerNew.bmp"));
				}
				else
				{
	                newChildNode.SetIconImage((Image)new Bitmap(GetType(), "ObjectViewerNew.bmp"));
				}
				//newChildNode.SetIconImage(new Icon("c:\\lab\\SE Nodes\\art\\ObjectViewerNew.ico").ToBitmap());
                newChildNode.DoubleClickHandler = new EventHandler(OnSelectWMIClass);
            }
            return newChildNode;
        }

        // <doc>
        // <desc>
        //     Returns label constant for this node.
        // </desc>
        // </doc>
        public string Label {
            override get {
                if (label == null || label.Length == 0) {
                    label = WMISys.GetString("WMISE_ClassesNodeLbl");

					/*
					ResourceReader reader = new ResourceReader("WMIServerExplorer.resources");
					IDictionaryEnumerator enumRes = (IDictionaryEnumerator)((IEnumerable)reader).GetEnumerator();
					string outString = "";
					while (enumRes.MoveNext()) {
					  outString += "\n\r";
					  outString += "Name: "+ enumRes.Key;
					  outString += "Value: " + enumRes.Value;
					}
					reader.Close();
					MessageBox.Show(outString);
					*/
                }
                return label;
            }
            override set {
            }
        }

        //
        // METHODS
        //

        // <doc>
        // <desc>
        //     Create <Add Classes> node under this node.
        // </desc>
        // </doc>
        public override Node[] CreateChildren() {
	
				Node[] children = GetNodeSite().GetChildNodes();

            if (children == null || children.Length == 0) {
				
				children = new Node[DefaultClasses.Length + 1];

				int i, k;
				for (i = 0, k = 0; i < DefaultClasses.Length; i++)
				{
					try
					{
						children[k] = new WMIClassNode("\\\\" + GetNodeSite().GetMachineName() +
												"\\" + DefaultNS + ":" + DefaultClasses[i]);

						k++;
						
					}
					catch (Exception)
					{
						//do nothing; k won't get incremented
					}
				}
				children[k] = GetNewChildNode();
              
				Node[] children2 = new Node[k + 1];
				Array.Copy(children, children2, k + 1);
				return children2;
            }
            return children;	
        }

    // <doc>
    // <desc>
    //     This node is a singleton.
    // </desc>
    // </doc>
    public override int CompareUnique(Node node) {
        return 0;
    }

	private void OnSelectWMIClass(object sender, EventArgs e) {
 			
			try 
			{
				StringTable strs = new StringTable(50);					

				//First, enumerate existing classes to initialize dialog
				Node[] children = GetNodeSite().GetChildNodes();
				
				for (int i = 0; i < children.Length; i++)
				{
					if (children[i] is WMIClassNode)
					{						
						strs.Add (((WMIClassNode)children[i]).pathNoServer);					
					}
				}
				
				//get current server name				
				ServerNode server = (ServerNode)GetNodeSite().GetParentNode();				
				String serverName = server.GetUNCName();
				
								
				if (selectClassDlg == null)
				{
					

					selectClassDlg = new SelectWMIClassTreeDialog(						
									serverName,			
									ClassFilters.ConcreteData,
									//SchemaFilters.NoEvent|SchemaFilters.NoAbstract|	SchemaFilters.NoSystem |SchemaFilters.NoAssoc,															
									strs);					

				}
				
				else
				{
					//updated selected classes list in the dialog:
					//to account for the case wheen some class node 
					//was deleted
					UpdateSelectClassDialog();

					((SelectWMIClassTreeDialog)selectClassDlg).CleanUpPreviousSelections();
				}
				
				
				DialogResult ret = ((SelectWMIClassTreeDialog)selectClassDlg).ShowDialog();
			
				if (ret != DialogResult.OK) 
				{
				    return;
				}
		
				//inspect strs and add or delete child nodes as necessary
				UpdateChildren (((SelectWMIClassTreeDialog)selectClassDlg).SelectedClasses);
				

			}
			catch(Exception exc)
			{
				MessageBox.Show(WMISys.GetString("WMISE_Exception", exc.Message, exc.StackTrace));
			}	

        }

	private void UpdateChildren (StringTable stDialog)
	{			
		try
		{
			Node[] children = GetNodeSite().GetChildNodes();
			StringTable stChildren = new StringTable(50);

			//First pass: put existing children into string table: strChildren
			//also, remove children that have been deleted from the list in the dialog
			for (int i = 0; i < children.Length; i++)
			{
				if (children[i] is WMIClassNode)
				{	
					WMIClassNode wmiClass = (WMIClassNode)children[i];
					if (!stDialog.Contains(wmiClass.pathNoServer))
					{
						//remove child						
						children[i].GetNodeSite().Remove();
					}
					else
					{
						stChildren.Add(wmiClass.pathNoServer);
					}	
				}
			}
			String[] arDialog = stDialog.ToArray();

			//Second pass, see if we need to add any children
			for (int i = 0; i < arDialog.Length; i++)
			{
				if (!stChildren.Contains(arDialog[i]))
				{															
					//add the node
					WMIClassNode newChild = new WMIClassNode("\\\\" + GetNodeSite().GetMachineName() +
																"\\" + arDialog[i]);
					GetNodeSite().AddChild(newChild);
				}						
			}
		}

		catch (Exception exc)
		{
			MessageBox.Show(WMISys.GetString("WMISE_Exception", exc.Message, exc.StackTrace));
		}	
	}

	/// <summary>
	/// This will update selectClassDlg.selectedClasses with
	///  classes currently selected. This is necessary to make sure
	/// nodes deleted in SE do not appear as selected in the dialog.
	/// </summary>	
	private void UpdateSelectClassDialog ()
	{			
		try
		{
			if (selectClassDlg == null)
			{
				return;
			}

			Node[] children = GetNodeSite().GetChildNodes();

			StringTable stChildren = new StringTable(50);
			for (int i = 0; i < children.Length; i++)
			{
				if (children[i] is WMIClassNode)
				{	
					WMIClassNode wmiClass = (WMIClassNode)children[i];
					stChildren.Add(wmiClass.pathNoServer);							
				}
			}
			((SelectWMIClassTreeDialog)selectClassDlg).SelectedClasses = stChildren;
		}

		catch (Exception exc)
		{
			MessageBox.Show(WMISys.GetString("WMISE_Exception", exc.Message, exc.StackTrace));
		}	
	}
	


	/// <summary>
        ///     The object should write the serialization info.
        /// </summary>
        public virtual void GetObjectData(SerializationInfo si, StreamingContext context) {
        }


    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vside\servexpl\beta1\wmienumtypeconverter.cs ===
namespace Microsoft.VSDesigner.WMI 
{
using System;
using System.Diagnostics;
using System.ComponentModel;
using System.Collections;
using WbemScripting;
using System.WinForms;

/// <summary>
///    Summary description for Class1.
/// </summary>
public class WMIEnumTypeConverter : TypeConverter
{
	

    public override StandardValuesCollection GetStandardValues(ITypeDescriptorContext context)
	{
		//Trace.WriteLine("getting standard values for a " + context.Instance.GetType().FullName);
		MessageBox.Show("getting standard values for a " + context.Instance.GetType().FullName);
		MessageBox.Show ("WMIEnumTypeConverter::GetStandardValues");

		//get ValueMap and Value property qualifiers on the class object

		ArrayList valueList = new ArrayList();

		//.....................

		return new StandardValuesCollection(valueList);

	}

	public override bool GetStandardValuesExclusive(ITypeDescriptorContext context)
	{
		//MessageBox.Show ("WMIEnumTypeConverter::GetStandardValuesExclusive");

		return true;

	}

	public override bool GetStandardValuesSupported(ITypeDescriptorContext context)
	{
		return true;
	}

	public override bool IsValid(ITypeDescriptorContext context, object val) 
	{
		MessageBox.Show ("WMIEnumTypeConverter::IsValid");
		return true;	//later, check if value is valid
	}
     
}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vside\servexpl\beta1\wmiassocgroupnode.cs ===
namespace Microsoft.VSDesigner.WMI {
    using System.Runtime.Serialization;
    using System.Diagnostics;
    using System;
    using System.WinForms;
    using System.Drawing;
    using System.Collections;
    using Microsoft.VSDesigner;
	using Microsoft.VSDesigner.ServerExplorer;

	using WbemScripting;
	using System.Resources;

    // <doc>
    // <desc>
    //     This represents the wmi classes node under a server node.
    // </desc>
    // </doc>
    [UserContextAttribute("serveritem", "wmiassocclass")]
    public class WMIAssocGroupNode : Node, ISerializable  {
        //
        // FIELDS
        //
        static Image icon;
        public static readonly Type parentType = typeof(WMIInstanceNode);
        private string label = string.Empty;

		private ResourceManager rm = null;
		
		AssocGroupComponent theComp = null;

        //
        // CONSTRUCTORS
        //
        // <doc>
        // <desc>
        //     Main constructor.
		//     Parameters: 
		//	string server (in, machine name)
		//	string pathIn (in, WMI path without the server name , e.g. "root\default:MyClass")
        // </desc>
        // </doc>
        public WMIAssocGroupNode (AssocGroupComponent compIn) 
		{
			try
			{
				try
				{
					rm = new ResourceManager( "Microsoft.VSDesigner.WMI.Res",     // Name of the resource.
												".",            // Use current directory.
												null);	
				}
				catch (Exception)
				{
					//do nothing, will use static RM
				}

				theComp = compIn;
								
			}
			catch (Exception exc)
			{
				MessageBox.Show(WMISys.GetString("WMISE_Exception", exc.Message, exc.StackTrace));
				throw (exc);
			}
		}


		/// <summary>
        ///     The object retrieves its serialization info.
        /// </summary>
        public WMIAssocGroupNode(SerializationInfo info, StreamingContext context) {
            
			try 
			{
				try
				{
					rm = new ResourceManager( "Microsoft.VSDesigner.WMI.Res",     // Name of the resource.
												".",            // Use current directory.
												null);	
				}
				catch (Exception)
				{
					//do nothing, will use static RM
				}

	
				//De-serialize string data mambers
				String associationPath = info.GetString("associationPath");
				String targetClass = info.GetString("targetClass");
				String targetRole = info.GetString("targetRole");
				

				//De-serialize strings necessary to restore the source object
				String sourcePath = info.GetString("sourcePath");
				String sourceNS = info.GetString("sourceNS");
				String sourceServer = info.GetString("sourceServer");

				//Restore SWbemObject for "source"
				ISWbemLocator wbemLocator = WmiHelper.WbemLocator;//(ISWbemLocator)(new SWbemLocator());

				ISWbemServices wbemServices = wbemLocator.ConnectServer(sourceServer, 
														sourceNS, 
														"",	//user: blank defaults to current logged-on user
														"",	//password: blank defaults to current logged-on user
														"",	//locale: blank for current locale
														"",	//authority: NTLM or Kerberos. Blank lets DCOM negotiate.
														0,	//flags: reserved
														null);	//context info: not needed here
											
				ISWbemObject sourceInst = wbemServices.Get (sourcePath,
											(int)WbemFlagEnum.wbemFlagUseAmendedQualifiers,
											null);				
							
				
				theComp = new AssocGroupComponent(sourceInst,
									associationPath,
									targetClass,
									targetRole);
				
			}

			catch (Exception exc)
			{
				MessageBox.Show(WMISys.GetString("WMISE_Exception", exc.Message, exc.StackTrace));
				throw (exc);
			}

		}


        //
        // PROPERTIES
        //

        // <doc>
        // <desc>
        //     Returns icon for this node.
        // </desc>
        // </doc>
		
        public Image Icon {
            override get {
				if (icon == null)
				{						
					if (rm != null)
					{
						icon = (Image)rm.GetObject ("Microsoft.VSDesigner.WMI.class.bmp");
					}
					else
					{
	                    icon = (Image)new Bitmap(GetType(), "class.bmp");
					}

				}				
				return icon;

            }
        }

        // <doc>
        // <desc>
        //     Returns class name as a label for this node.  
        // </desc>
        // </doc>
        public string Label {
            override get {
		
			if (label == null || label.Length == 0) 
			{
				label = theComp.targetClass + " (" + theComp.targetRole + ")";		
			}
			return label;		
            }
            override set {
            }
        }

        //
        // METHODS
        //

        // <doc>
        // <desc>
        //     Create associator instance nodes under this grouping.
        // </desc>
        // </doc>
        public override Node[] CreateChildren() {

			ISWbemObjectSet assocInstances = theComp.sourceInst.Associators_(
													theComp.associationClass, //association class name
													theComp.targetClass,	//result class name
													theComp.targetRole,   //target role
													String.Empty,   //source role
													false,			//bClassesOnly
													false,			//bSchemaOnly
													String.Empty,	//required association qualifier
													String.Empty,	//required qualifier
													(int)WbemFlagEnum.wbemFlagReturnImmediately, // |WbemFlagEnum.wbemFlagForwardOnly),
													null);

			if (assocInstances == null)
			{
				return null;
			}	

			Node[] childNodes = new Node[assocInstances.Count];
			
			int i = 0;

			IEnumerator enumAssocInst = ((IEnumerable)assocInstances).GetEnumerator();
			
			while(enumAssocInst.MoveNext())
			{
				ISWbemObject curObj = (ISWbemObject)enumAssocInst.Current;

				childNodes[i++] = new WMIInstanceNode(curObj, WmiHelper.GetClassObject(curObj));
				
			}
	

			return childNodes;

			
        }

          /// <summary>
        /// Compares two nodes to aid in discovering whether they
        /// are duplicates (that is, whether they represent the same
        /// resource). This function must return 0 if and only if the
        /// given node represents the same resource as this node, and
        /// only one of them should appear in the tree. The compare order (as determined
        /// by returning values other than 0) must be consistent
        /// across all calls, but it can be arbitrary. This order is
        /// not used to determine the visible order in the tree.
        /// </summary>
	// <doc>
        // <desc>
        //     This node is not a singleton (TODO: decide on this!)
        // </desc>
        // </doc>
        public override int CompareUnique(Node node) {           
			return 1;
        }

		
	
	public override Object GetBrowseComponent() {	
	
		return theComp;
	}	

	/// <summary>
    ///     The object should write the serialization info.
    /// </summary>
    public virtual void GetObjectData(SerializationInfo si, StreamingContext context) {
				
		ISWbemObjectPath sourcePath = theComp.sourceInst.Path_;

		si.AddValue("sourceServer", sourcePath.Server);
		si.AddValue("sourceNS", sourcePath.Namespace);
		si.AddValue("sourcePath", sourcePath.Path);

		si.AddValue("associationPath", theComp.associationPath);
		si.AddValue("targetClass", theComp.targetClass);
		si.AddValue("targetRole", theComp.targetRole);		
		
    }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vside\servexpl\beta1\wmihelper.cs ===
namespace Microsoft.VSDesigner.WMI {

	using System;
	using System.ComponentModel;
	using System.Core;
	using System.WinForms;
	using Microsoft.Win32.Interop;
	using System.Drawing;
	using WbemScripting;
	using System.Management;
	using System.Collections;
	using System.Diagnostics;

	
    public class WmiHelper
	{
		const UInt16 DMTF_DATETIME_STR_LENGTH = 25;
		const UInt16 DMTF_DATETIME_INTERVAL_STR_LENGTH = 25;

		private static ISWbemLocator wbemLocator = (ISWbemLocator)(new SWbemLocator());

		public static bool UseFriendlyNames = false;

		public static ISWbemLocator WbemLocator
		{
			get
			{
				try
				{
					ISWbemSecurity sec = wbemLocator.Security_;					
				}
				catch (Exception)
				{
					wbemLocator = null;
					wbemLocator = (ISWbemLocator)(new SWbemLocator());
				}
				return wbemLocator;
			}
		}

		/// <summary>
		/// 
		/// </summary>
		/// <param name="serverName"> </param>
		/// <param name="nsName"> </param>
		static public ISWbemServices GetServices(string serverName,
												string nsName) 
		{
			//MessageBox.Show ("refreshing services in wmihelper");

			return (WbemLocator.ConnectServer(serverName, 
												nsName, 
												string.Empty,
												string.Empty, 
												string.Empty, 
												string.Empty, 
												0, 
												null));					
		}

		/// <summary>
		/// This is the method to call in case you cannot QI for ISWbemObject
		/// on the cached SWbemObject (bug in interop? urt?)
		/// </summary>
		/// <param name="objPath"> </param>
		/// <param name="services">  propriately</param>
		/// <param name="serverName"> </param>
		/// <param name="nsName"> </param>
		static public ISWbemObject GetObject (string objPath,
												ISWbemServices services,	//in - out
												string serverName,
												string nsName)
		{
			try
			{
				try 
				{
					ISWbemSecurity sec = services.Security_;
				}
				catch (Exception)
				{							
				
					//MessageBox.Show ("refreshing services in wmihelper");
					services = null;
					services = WbemLocator.ConnectServer(serverName, 
														nsName, 
														string.Empty,
														string.Empty, 
														string.Empty, 
														string.Empty, 
														0, 
														null);
				}
				ISWbemObject obj = services.Get(objPath, 
												(int)WbemFlagEnum.wbemFlagUseAmendedQualifiers,
												null);
				//MessageBox.Show ("refreshing object in wmihelper");


				return obj;
				
			}
			catch (Exception e)
			{
				MessageBox.Show(WMISys.GetString("WMISE_Exception", e.Message, e.StackTrace));

				return null;
			}
		}

		static public bool IsPropertyWriteableWithTest(ISWbemObject obj, ISWbemProperty prop) 
		{
			
			Object curValue = prop.get_Value();
			prop.set_Value (ref curValue);

			int flags = (int)((int)WbemChangeFlagEnum.wbemChangeFlagUpdateSafeMode
							| (int)WbemChangeFlagEnum.wbemChangeFlagUpdateOnly
							| (int)WbemFlagEnum.wbemFlagUseAmendedQualifiers);
			
			try 
			{
				obj.Put_(flags, null);
				return true;
			}
			catch (Exception )
			{
				return false;
			}
		}
		
		/// <summary>
		/// Property is not writeable only if "read" qualifier is present and its value is "true"
		/// Also, for dynamic classes, absence of "write" qualifier means that the property is read-only.
		/// </summary>
		/// <param name="obj"> </param>
		/// <param name="prop"> </param>
		static public bool IsPropertyWriteable(ISWbemObject obj, ISWbemProperty prop) 
		{		
			//collect all the info:
			bool isDynamic = CheckObjectBoolQualifier(obj, "dynamic");

			bool hasWrite = CheckPropertyQualifierExistence(prop, "write");
			bool writeValue = CheckPropertyBoolQualifier (prop, "write");
			bool hasRead = CheckPropertyQualifierExistence(prop, "read");
			bool readValue = CheckPropertyBoolQualifier (prop, "read");

			if ((!isDynamic && !hasWrite && !hasRead)||
				(!isDynamic && hasWrite && writeValue)||
				(isDynamic && hasWrite && writeValue))
			{
				return true;
			}

			return false;
						
		}

		/// <summary>
		/// Converts DMTF datetime property value to System.DateTime
		/// </summary>
		/// <param name="prop"> </param>
		static public DateTime ToDateTime (String dmtf) 
		{					
			try
			{
				
				//set the defaults:
				Int32 year = DateTime.Now.Year;
				Int32 month = 1;
				Int32 day = 1;
				Int32 hour = 0;
				Int32 minute = 0;
				Int32 second = 0;
				Int32 millisec = 0;

				String str = dmtf;

				if (str == String.Empty || 
					str.Length != DMTF_DATETIME_STR_LENGTH )
					//|| str.IndexOf("*") >= 0 )
				{
					return DateTime.Empty;
				}

				string strYear = str.Substring(0, 4);
				if (strYear != "****")
				{
					year = Int32.FromString (strYear);
				}

				string strMonth = str.Substring(4, 2);
				if (strMonth != "**")
				{
					month = Int32.FromString(strMonth);
				}

				string strDay = str.Substring(6, 2);
				if (strDay != "**")
				{
					day = Int32.FromString(strDay);
				}
				
				string strHour = str.Substring(8, 2);
				if (strHour != "**")
				{
					hour = Int32.FromString(strHour);
				}

				string strMinute = str.Substring(10, 2);
				if (strMinute != "**")
				{
					minute = Int32.FromString(strMinute);
				}
				
				string strSecond = str.Substring(12, 2);
				if (strSecond != "**")
				{
					second = Int32.FromString(strSecond);
				}

				//note: approximation here: DMTF actually stores microseconds
				string strMillisec = str.Substring(15, 3);	
				if (strMillisec != "***")
				{
					millisec = Int32.FromString(strMillisec);
				}

				DateTime ret = new DateTime(year, month, day, hour, minute, second, millisec);

				return ret;
			}
			catch(Exception e)
			{
				MessageBox.Show(WMISys.GetString("WMISE_Exception", e.Message, e.StackTrace));
				throw (e);
			}
				
		}


		static public String ToDMTFTime (DateTime wfcTime) 
		{
			
			String dmtf = string.Empty;

			dmtf +=  wfcTime.Year.ToString();
			dmtf +=  wfcTime.Month.ToString().PadLeft(2, '0');
			dmtf +=  wfcTime.Day.ToString().PadLeft(2, '0');
			dmtf +=  wfcTime.Hour.ToString().PadLeft(2, '0');
			dmtf +=  wfcTime.Minute.ToString().PadLeft(2, '0');
			dmtf +=  wfcTime.Second.ToString().PadLeft(2, '0');
			dmtf +=  ".";
			dmtf +=  wfcTime.Millisecond.ToString().PadLeft(3, '0');

			dmtf += "000";	//this is to compensate for lack of microseconds in DateTime

			TimeZone curZone = TimeZone.CurrentTimeZone;
			long tickOffset = curZone.GetUTCOffset(wfcTime);


			if (tickOffset >= 0)
			{
				dmtf +=  "+";
				dmtf += (tickOffset/60000).ToString();
			}
			else
			{
				dmtf +=  "-";
				dmtf += (tickOffset/60000).ToString().Substring(1, 3);	
			}								

			return dmtf;
				
		}
		
		static public bool IsValueMap (ISWbemProperty prop)
		{
			try
			{
				
				IEnumerator enumQuals = ((IEnumerable)(prop.Qualifiers_)).GetEnumerator();
				while (enumQuals.MoveNext())
				{
					ISWbemQualifier qual = (ISWbemQualifier)enumQuals.Current;
					if (qual.Name == "Values")
					{

						return true;
					}
				
				}
				return false;
			}
			catch (Exception )
			{

				return false;
			}
		}

				
		static public String GetPropertyDescription (String propName, ISWbemObject curObj)
		{
			try
			{
				if (curObj == null)
				{
					throw new ArgumentNullException("curObj");
				}
				ISWbemProperty verboseProp = null;

				if (!curObj.Path_.IsClass)
				{
					ISWbemObject classObj = WmiHelper.GetClassObject(curObj);					
					verboseProp = classObj.Properties_.Item(propName, 0);
				}	
				else
				{
					verboseProp = curObj.Properties_.Item(propName, 0);
				}
				
				string descr = string.Empty;
				ISWbemQualifier descrQual = verboseProp.Qualifiers_.Item("Description", 0);	
				
				descr = descrQual.get_Value().ToString();
				return descr;

			}
			catch (Exception )
			{
				return "";
			}
		}

		static public String GetClassDescription (ISWbemObject obj) 
		{

			try
			{
				ISWbemObject verboseObj = obj;

				if (!obj.Path_.IsClass)
				{
					verboseObj = WmiHelper.GetClassObject(obj);					
				}	

				ISWbemQualifier descrQual = verboseObj.Qualifiers_.Item("Description", 0);	
				return (descrQual.get_Value().ToString());
			}
			catch (Exception )
			{
				return ""; 						
			}
		}

		static public String GetMethodDescription (String methName, ISWbemObject curObj) 
		{
			try
			{				

				ISWbemQualifier descrQual = null;
				ISWbemMethod verboseMeth = null;

				if (!curObj.Path_.IsClass)
				{
					ISWbemObject classObj = WmiHelper.GetClassObject(curObj);
					verboseMeth = classObj.Methods_.Item(methName, 0);
				}	
				else
				{
					verboseMeth = curObj.Methods_.Item(methName, 0);
				}

				descrQual = verboseMeth.Qualifiers_.Item("Description", 0);	

				return (descrQual.get_Value().ToString());
			}
			catch (Exception)
			{
				//2880: removed message here
				return ""; 						
			}
		}
		

		public static ISWbemObject GetClassObject (ISWbemObject objIn)
		{
			if (objIn == null)
			{
				throw new ArgumentException();
			}

			try
			{


				ISWbemObjectPath path = objIn.Path_;

				if (path.IsClass)
				{
					return objIn;
				}
							
				ISWbemLocator wbemLocator = WmiHelper.wbemLocator;//(ISWbemLocator)(new SWbemLocator());

				ISWbemServices wbemServices = wbemLocator.ConnectServer(path.Server, 
															path.Namespace, 
															"",	//user: blank defaults to current logged-on user
															"",	//password: blank defaults to current logged-on user
															"",	//locale: blank for current locale
															"",	//authority: NTLM or Kerberos. Blank lets DCOM negotiate.
															0,	//flags: reserved
															null);	//context info: not needed here
												
				ISWbemObject classObj = wbemServices.Get (path.Class,
												(int)WbemFlagEnum.wbemFlagUseAmendedQualifiers,
												null);				
				return classObj;
			}

			catch (Exception e)
			{
				//MessageBox.Show(WMISys.GetString("WMISE_Exception", e.Message, e.StackTrace));				
				return null;
			}

		}

		public static ISWbemObject GetClassObject (String server,
													String ns,
													String className)
		{
			if (ns == string.Empty || className == string.Empty)
			{
				throw new ArgumentException();
			}
            
			try
			{			
							
				ISWbemLocator wbemLocator = WmiHelper.wbemLocator;//(ISWbemLocator)(new SWbemLocator());

				ISWbemServices wbemServices = wbemLocator.ConnectServer(server, 
															ns, 
															"",	//user: blank defaults to current logged-on user
															"",	//password: blank defaults to current logged-on user
															"",	//locale: blank for current locale
															"",	//authority: NTLM or Kerberos. Blank lets DCOM negotiate.
															0,	//flags: reserved
															null);	//context info: not needed here
												
				ISWbemObject classObj = wbemServices.Get (className,
												(int)WbemFlagEnum.wbemFlagUseAmendedQualifiers,
												null);				
				return classObj;
			}

			catch (Exception e)
			{
				MessageBox.Show(WMISys.GetString("WMISE_Exception", e.Message, e.StackTrace));				
				return null;
			}

		}
		
		/// <summary>
		/// IsStaticMethod
		/// </summary>
		/// <param name="meth"> </param>
		static public bool IsStaticMethod (ISWbemMethod meth)
		{
			return CheckMethodBoolQualifier(meth, "Static");
	
		}

		/// <summary>
		/// IsImplementedMethod
		/// </summary>
		/// <param name="meth"> </param>
		static public bool IsImplementedMethod (ISWbemMethod meth)
		{
			return CheckMethodBoolQualifier(meth, "Implemented");
		}

		/// <summary>
		/// IsKeyProperty
		/// </summary>
		/// <param name="prop"> </param>
		static public bool IsKeyProperty (ISWbemProperty prop)
		{
			return CheckPropertyBoolQualifier(prop, "Key");
		}


		
		/// <summary>
		/// CheckMethodBoolQualifier
		/// </summary>
		/// <param name="meth"> </param>
		/// <param name="qualName"> </param>
		static private bool CheckMethodBoolQualifier(ISWbemMethod meth, String qualName)
		{
			try 
			{
				ISWbemQualifierSet qualSet = meth.Qualifiers_;
				ISWbemQualifier qual = (ISWbemQualifier)qualSet.Item(qualName, 0);	
					
				return (Convert.ToBoolean(qual.get_Value()));
			}
			catch(Exception)
			{
				//NOTE that if the qualifier is not present, "Not found" will be returned
				//Return false in this case
				return false;
			}				
		}
		

		/// <summary>
		/// CheckPropertyBoolQualifier
		/// </summary>
		/// <param name="prop"> </param>
		/// <param name="qualName"> </param>
		static private bool CheckPropertyBoolQualifier(ISWbemProperty prop, String qualName)
		{
			try 
			{
				
				ISWbemQualifierSet qualSet = prop.Qualifiers_;


				ISWbemQualifier qual = (ISWbemQualifier)qualSet.Item(qualName, 0);	
				
				return (Convert.ToBoolean(qual.get_Value()));
		
			}
			catch(Exception)
			{
				//NOTE that if the qualifier is not present, "Not found" will be returned
				//Return false in this case
			

				return false;
			}				
		}


		/// <summary>
		/// CheckPropertyQualifierExistence
		/// </summary>
		/// <param name="prop"> </param>
		/// <param name="qualName"> </param>
		static private bool CheckPropertyQualifierExistence(ISWbemProperty prop, String qualName)
		{
			ISWbemQualifierSet qualSet = prop.Qualifiers_;

			try 
			{
				ISWbemQualifier qual = (ISWbemQualifier)qualSet.Item(qualName, 0);						
				return true;	//previous statement didn't throw, so qualifier must be present
			}
			catch(Exception )
			{
				return false;
			
			}				
		}

		/// <summary>
		/// CheckObjectBoolQualifier
		/// </summary>
		/// <param name="obj"> </param>
		/// <param name="qualName"> </param>
		static private bool CheckObjectBoolQualifier(ISWbemObject obj, String qualName)
		{
			try 
			{
				ISWbemQualifierSet qualSet = obj.Qualifiers_;
				ISWbemQualifier qual = (ISWbemQualifier)qualSet.Item(qualName, 0);	
					
				return (Convert.ToBoolean(qual.get_Value()));
			}
			catch(Exception)
			{
				//NOTE that if the qualifier is not present, "Not found" will be returned
				//Return false in this case
				return false;
			}				
		}


		/// <summary>
		/// IsAbstract
		/// </summary>
		/// <param name="obj"> </param>
		static public  bool IsAbstract (ISWbemObject obj)
		{
				try 
				{
					return CheckObjectBoolQualifier(obj, "abstract");
				}
				catch (Exception e)
				{
					MessageBox.Show(WMISys.GetString("WMISE_Exception", e.Message, e.StackTrace));
					return false;
				}
		}

		
		/// <summary>
		/// IsAssociation
		/// </summary>
		/// <param name="obj"> </param>
		static public bool IsAssociation (ISWbemObject obj)
		{
				try 
				{
					return CheckObjectBoolQualifier(obj, "association");
				}
				catch (Exception e)
				{
					MessageBox.Show(WMISys.GetString("WMISE_Exception", e.Message, e.StackTrace));
					return false;
				}
		}

		/// <summary>
		/// IsSystem
		/// </summary>
		/// <param name="obj"> </param>
		static public bool IsSystem (ISWbemObject obj)
		{
				try 
				{
					String NameOut = obj.Path_.RelPath;
						
					return (NameOut.Substring(0, 2) == "__");		
				}
				catch (Exception e)
				{
					MessageBox.Show(WMISys.GetString("WMISE_Exception", e.Message, e.StackTrace));
					return false;
				}
		}


		/// <summary>
		/// IsEvent
		/// </summary>
		/// <param name="obj"> </param>
		static public bool IsEvent (ISWbemObject obj)
		{
				try 
				{
					
					//handle __ExtrinsicEvent class separately, since it is not its own parent
					if (obj.Path_.RelPath.ToString() == "__ExtrinsicEvent")
					{
						return true;
					}
			
					Object[] arParents = (Object[])obj.Derivation_;
					for (int i =0; i < arParents.Length; i++)
					{
						if (arParents[i].ToString() == "__ExtrinsicEvent")
						{
							return true;
						}
					}
					

					return false;
				}
				catch (Exception e)
				{
					MessageBox.Show(WMISys.GetString("WMISE_Exception", e.Message, e.StackTrace));
					return false;
				}
		}

		/// <summary>
		/// Given an instance of an association object and a path to one of its
		/// endpoints (the "source"), this method returns "path" to the other endpoint
		/// (the "target").  
		/// </summary>
		/// <param name="assocInstance"> </param>
		/// <param name="sourcePath"> </param>
		static public String GetAssocTargetClass (ISWbemObject assocInstance,
													ISWbemObjectPath sourcePath)
		{
			try
			{
				IEnumerator enumAssocProps = ((IEnumerable)(assocInstance.Properties_)).GetEnumerator();		
				while(enumAssocProps.MoveNext())
				{
					ISWbemProperty curProp = (ISWbemProperty)enumAssocProps.Current;
					if (curProp.CIMType != WbemCimtypeEnum.wbemCimtypeReference)
					{
						continue;
					}
					else
					{
						//get CIMTYPE property qualifier value
						String refValue = curProp.Qualifiers_.Item("CIMTYPE", 0).get_Value().ToString();

						//get rid of "ref:" prefix:
						refValue = refValue.Substring(4);

						//confirm that this is not the source
						if ((String.Compare(refValue, sourcePath.Class, true) != 0) &&
							(String.Compare(refValue, sourcePath.Path, true) != 0))
						{
                            //if this is a path, leave only the class name,
							//which is the part after the last backslash
							char[] separ = new char[]{'\\'};

							string[] pathParts = refValue.Split(separ);
							refValue = pathParts[pathParts.Length - 1];

							return refValue;							
						}
					}
				}

				return String.Empty;				
			}
			catch (Exception e)
			{
				MessageBox.Show(WMISys.GetString("WMISE_Exception", e.Message, e.StackTrace));
				return String.Empty;
			}
		}
		
		/// <summary>
		/// Given an instance of an association object and a path to one of its
		/// endpoints (the "source"), this method returns the role of the other endpoint
		/// (the "target") in this association.
		/// </summary>
		/// <param name="assocInstance"> </param>
		/// <param name="sourcePath"> </param>
		static public String GetAssocTargetRole (ISWbemObject assocInstance,
													ISWbemObjectPath sourcePath)
		{
			try
			{
				IEnumerator enumAssocProps = ((IEnumerable)(assocInstance.Properties_)).GetEnumerator();		
				while(enumAssocProps.MoveNext())
				{
					ISWbemProperty curProp = (ISWbemProperty)enumAssocProps.Current;
					if (curProp.CIMType != WbemCimtypeEnum.wbemCimtypeReference)
					{
						continue;
					}
					else
					{
						//confirm that this is not the source
						if ((String.Compare(curProp.get_Value().ToString(),
							sourcePath.Path, true )) != 0)
						{
							return curProp.Name;
						}
						
					}
				}

				return String.Empty;
			}
			catch (Exception e)
			{
				MessageBox.Show(WMISys.GetString("WMISE_Exception", e.Message, e.StackTrace));
				return String.Empty;
			}
		}

		public static Object GetTypedObjectFromString(WbemCimtypeEnum cimType, String strValue)
		{
			switch (cimType)
			{
				case (WbemCimtypeEnum.wbemCimtypeBoolean):
				{
					Boolean bValue = Boolean.FromString(strValue);
					return bValue;
				} 
				case (WbemCimtypeEnum.wbemCimtypeChar16):
				{
					Char charValue = Char.FromString(strValue);
					return charValue;
				} 
				case (WbemCimtypeEnum.wbemCimtypeDatetime):
				{
					return strValue;
				} 
				case (WbemCimtypeEnum.wbemCimtypeObject):
				{
					//VT_UNKNOWN
					//what's the format of strValue?
                    //thios wouldn't work until there is a way to invoke custom type converters and editors
					return null;
				} 
				case (WbemCimtypeEnum.wbemCimtypeReal32):
				{					
					Single retValue = Single.FromString(strValue);
					return retValue;
				} 
				case (WbemCimtypeEnum.wbemCimtypeReal64):
				{
					Double retValue = Double.FromString(strValue);
					return retValue;
				} 
				case (WbemCimtypeEnum.wbemCimtypeReference):
				{
					return strValue;
				} 
				case (WbemCimtypeEnum.wbemCimtypeSint16):
				{
					Int16 retValue = Int16.FromString(strValue);
					return retValue;
				} 
				case (WbemCimtypeEnum.wbemCimtypeSint32):
				{
					Int32 retValue = Int32.FromString(strValue);
					return retValue;
				} 
				case (WbemCimtypeEnum.wbemCimtypeSint64):
				{
					return strValue;
				} 
				case (WbemCimtypeEnum.wbemCimtypeSint8):
				{
					//NOTE that wbemCimtypeSint8 get expanded to VT_I2 in automation layer
					Int16 retValue = Int16.FromString(strValue);
					return retValue;
				} 
				case (WbemCimtypeEnum.wbemCimtypeString):
				{
					return strValue;
				} 
				case (WbemCimtypeEnum.wbemCimtypeUint16):
				{
					//NOTE that wbemCimtypeUint16 gets expanded to VT_I4 in automation layer
					Int32 retValue = Int32.FromString(strValue);
					return retValue;
				} 
				case (WbemCimtypeEnum.wbemCimtypeUint32):
				{
					Int32 retValue = Int32.FromString(strValue);
					return retValue;
				} 
				case (WbemCimtypeEnum.wbemCimtypeUint64):
				{
					return strValue;
				} 
				case (WbemCimtypeEnum.wbemCimtypeUint8):
				{
					Byte retVal = Byte.FromString(strValue);
					return retVal;
				} 
                
                default:
                  return strValue;
            }

		}

		public static String GetDisplayName(ISWbemObject obj) 
		{
			try
			{
				ISWbemObject verboseObj = obj;

				if (!obj.Path_.IsClass)
				{
					verboseObj = WmiHelper.GetClassObject(obj);					
				}	

				ISWbemQualifier dispName = verboseObj.Qualifiers_.Item("DisplayName", 0);	
				return (dispName.get_Value().ToString());
			}
			catch (Exception )
			{
				return String.Empty; 						
			}
		}


		/// <summary>
		/// Converts DMTF datetime interval property value to System.TimeSpan
		/// </summary>
		/// <param name="prop"> </param>
		static public TimeSpan ToTimeSpan (string dmtf) 
		{					
			try
			{
				
				//set the defaults:
				Int32 days = 0;
				Int32 hours = 0;
				Int32 minutes = 0;
				Int32 seconds = 0;
				Int32 millisecs = 0;

				String str = dmtf;

				if (str == String.Empty || 
					str.Length != DMTF_DATETIME_INTERVAL_STR_LENGTH )
				{
					return TimeSpan.Empty;
				}

				string strDay = str.Substring(0, 8);
				days = Int32.FromString(strDay);
								
				string strHour = str.Substring(8, 2);
				hours = Int32.FromString(strHour);
				
				string strMinute = str.Substring(10, 2);
				minutes = Int32.FromString(strMinute);
				
				
				string strSecond = str.Substring(12, 2);
				seconds = Int32.FromString(strSecond);
				
				//dot in the 14th position
				if (str.Substring(14, 1) != ".")
				{
					return TimeSpan.Empty;
				}
			

				//note: approximation here: DMTF actually stores microseconds
				string strMillisec = str.Substring(15, 3);	
				if (strMillisec != "***")
				{
					millisecs = Int32.FromString(strMillisec);
				}

				TimeSpan ret = new TimeSpan(days, hours, minutes, seconds, millisecs);

				return ret;
			}
			catch(Exception e)
			{
				MessageBox.Show(WMISys.GetString("WMISE_Exception", e.Message, e.StackTrace));
				throw (e);
			}				
		}

/// <summary>
/// 
/// </summary>
/// <param name="wfcTimeSpan"> </param>
		static public String ToDMTFInterval (TimeSpan wfcTimeSpan) 
		{
			
			String dmtf = string.Empty;
		
			dmtf +=  wfcTimeSpan.Days.ToString().PadLeft(8, '0');
			dmtf +=  wfcTimeSpan.Hours.ToString().PadLeft(2, '0');
			dmtf +=  wfcTimeSpan.Minutes.ToString().PadLeft(2, '0');
			dmtf +=  wfcTimeSpan.Seconds.ToString().PadLeft(2, '0');
			dmtf +=  ".";
			dmtf +=  wfcTimeSpan.Milliseconds.ToString().PadLeft(3, '0');

			dmtf += "000";	//this is to compensate for lack of microseconds in TimeSpan

			dmtf +=":000";			

			return dmtf;
				
		}


		static public bool IsInterval (Property prop)
		{
			if (prop.Type != CIMType.DateTime)
			{
				throw new ArgumentException();
			}

			try
			{
				string subtype = string.Empty;
				Qualifier subtypeQual = prop.Qualifiers["Subtype"];	
				
				subtype = subtypeQual.Value.ToString();
				if (subtype.ToUpper() == "INTERVAL")
				{
					return true;
				}

				return false;
			}
			catch (Exception )
			{
				return false;
			}
		}
		

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vside\servexpl\beta1\wmieventsnode.cs ===
namespace Microsoft.WMI.SDK.VisualStudio {
    using System.Runtime.Serialization;
    using System.Diagnostics;
    using System;
    using System.WinForms;
    using System.Drawing;
    using System.Collections;
    using Microsoft.VSDesigner;
	using Microsoft.VSDesigner.ServerExplorer;
	using System.Resources;

	using WbemScripting;

    // <doc>
    // <desc>
    //     This represents the wmi classes node under a server node.
    // </desc>
    // </doc>
    [UserContextAttribute("serveritem", "wmievents")]
    public class WMIEventsNode : Node, ISerializable  {
        //
        // FIELDS
        //

        static Image icon;
        public static readonly Type parentType = typeof(ServerNode);
        private string label = string.Empty;
		
		//private NewChildNode newChildNode = null;
		
		private ResourceManager rm = null;

        //
        // CONSTRUCTORS
        //

        // <doc>
        // <desc>
        //     Main constructor.
        // </desc>
        // </doc>
        public WMIEventsNode() {
			rm = new ResourceManager( "WMI-SE",     // Name of the resource.
										".",            // Use current directory.
										null);	

		}


		/// <summary>
        ///     The object retrieves its serialization info.
        /// </summary>
        public WMIEventsNode(SerializationInfo info, StreamingContext context) {
			rm = new ResourceManager( "WMI-SE",     // Name of the resource.
							".",            // Use current directory.
							null);	

        }

        //
        // PROPERTIES
        //

        // <doc>
        // <desc>
        //     Returns icon for this node.
        // </desc>
        // </doc>
		
        public Image Icon {
            override get {

				if (icon == null)
				{						
					icon = (Image)rm.GetObject ("Events.bmp");
				}				
				return icon;

            }
        }

        // <doc>
        // <desc>
        //     Returns label constant for this node.
        // </desc>
        // </doc>
        public string Label {
            override get {
                if (label == null || label.Length == 0) {
                    label = "Management Events";//VSSys.GetString("SE_ProcessesLabel_Processes");
                }
                return label;
            }
            override set {
            }
        }

        //
        // METHODS
        //

        // <doc>
        // <desc>
        //     Create process nodes under this node.
        // </desc>
        // </doc>
        public override Node[] CreateChildren() {
			/*
            Process[] processes = Process.GetProcesses(GetNodeSite().GetMachineName());
            Node[] nodes = new Node[processes.Length];
            for (int i = 0; i < processes.Length; i++) {
                Process process = processes[i];
                nodes[i] = new ProcessNode(process.Id, process.ProcessName);
            }

            return nodes;
			*/
	
            Node[] children = GetNodeSite().GetChildNodes();

            if (children == null || children.Length == 0) {
                children = new Node[] {
                                GetNewChildNode()                           
                };
            }

            return children;			
        }

        // <doc>
        // <desc>
        //     This node is a singleton.
        // </desc>
        // </doc>
        public override int CompareUnique(Node node) {
            return 0;
        }


		private void OnAddEventFilter(object sender, EventArgs e) {
 			
			try 
			{
				MessageBox.Show("Not implemented yet");
				/*
				StringTable strs = new StringTable(5);				
				SelectWMIClassTreeDialog dlg = new SelectWMIClassTreeDialog("" ,
														SchemaFilters.NoEvent|
														SchemaFilters.NoAbstract|
														SchemaFilters.NoSystem,
														strs);
				DialogResult ret = dlg.ShowDialog();
			
				if (ret != DialogResult.OK) {
				    return;
				}*/
			}
			catch(Exception exc)
			{
				MessageBox.Show("Exception: " + exc.Message + "\n\rTrace: " + exc.StackTrace);
			}	

        }

		/// <summary>
        ///     The object should write the serialization info.
        /// </summary>
        public virtual void GetObjectData(SerializationInfo si, StreamingContext context) {
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vside\servexpl\beta1\wmienumpropertydescriptor.cs ===
namespace Microsoft.VSDesigner.WMI 
{
using System;
using System.Collections;
using System.ComponentModel;
using System.WinForms;
using WbemScripting;
using System.Management;

/// <summary>
///    Summary description for Class1.
/// </summary>
/// 
[TypeConverter(typeof(WMIEnumTypeConverter))]
public class WMIEnumPropertyDescriptor : WMIPropertyDescriptor
{
    public WMIEnumPropertyDescriptor(ManagementObject mgmtObjIn,
										ManagementObject mgmtClassObjIn,
										ISWbemObject wbemObjIn,
										ISWbemObject wmiClassObjIn,
										String propNameIn,
										bool commitImmediately)
		:base(mgmtObjIn, mgmtClassObjIn, wbemObjIn, wmiClassObjIn, propNameIn, commitImmediately)
	{
	
	}
/*
	public TypeConverter Converter 
	{
		override get
		{
			return new WMIEnumTypeConverter();
		}

	}
	
	public override Object GetValue (Object component)  
	{
		return prop.get_Value();
	}
	*/

	public override void SetValue (Object component, Object value)  
	{     
		try
		{
			prop.set_Value(ref value);
			if (CommitImmediately)
			{
				wmiObj.Put_((int)WbemChangeFlagEnum.wbemChangeFlagCreateOrUpdate
							| (int)WbemFlagEnum.wbemFlagUseAmendedQualifiers, 
							null);
			}
		}
		catch (Exception exc)
		{
			throw (exc);
		}
	}

}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vside\servexpl\beta1\wmiclassnode.cs ===
namespace Microsoft.VSDesigner.WMI {
    using System.Runtime.Serialization;
    using System.Diagnostics;
    using System;
    using System.WinForms;
    using System.Drawing;
    using System.Collections;
    using Microsoft.VSDesigner;
	using Microsoft.VSDesigner.ServerExplorer;
    using System.ComponentModel.Design;
	using System.ComponentModel;
	using System.Resources;

	using WbemScripting;


    // <doc>
    // <desc>
    //     This represents the wmi classes node under a server node.
    // </desc>
    // </doc>
    [UserContextAttribute("serveritem", "wmiclass")]
    public class WMIClassNode : Node, ISerializable  {
        //
        // FIELDS
        //

        static Image icon;
        public static readonly Type parentType = typeof(WMIClassesNode);
	    private string label = string.Empty;

		private ResourceManager rm = null;

		public readonly string path = string.Empty;
		public readonly string pathNoServer = string.Empty;
		private string serverName = string.Empty;
		private string nsName = string.Empty;
		private string className = string.Empty;

		private ISWbemObject wmiObj = null;
		private ISWbemServices wbemServices = null;

       // private NewChildNode newChildNode = null;


        //
        // CONSTRUCTORS
        //

        // <doc>
        // <desc>
        //     Main constructor.
		//     Parameters: 
		//	string server (in, machine name)
		//	string pathIn (in, WMI path without the server name , e.g. "root\default:MyClass")
        // </desc>
        // </doc>
        public WMIClassNode(string pathIn) {
			try
			{
				try
				{
					rm = new ResourceManager( "Microsoft.VSDesigner.WMI.Res",     // Name of the resource.
							".",            // Use current directory.
							null);	
				}
				catch (Exception)
				{
					//do nothing, will use static RM
				}
				

				path = pathIn;

				//parse the path to get server, namespace and class name
				Int32 separ = path.IndexOf ("\\", 2 );
				if (separ == -1)
				{
					//invalid path
					throw (new ArgumentException(WMISys.GetString("WMISE_InvalidPath", pathIn), "pathIn"));									
				}

				serverName = path.Substring(2, separ - 2);
				pathNoServer = path.Substring(separ + 1, path.Length - separ - 1);
			
				
				//split pathNoServer into namespace and classname parts (':' is the separator)
				Int32 colon = pathNoServer.IndexOf(':', 0);
				if (colon == -1)
				{
					//invalid path
					throw (new ArgumentException(WMISys.GetString("WMISE_InvalidPath, pathIn"), "pathIn"));
				}			
				nsName = pathNoServer.Substring(0,colon);
				className = pathNoServer.Substring(colon + 1, pathNoServer.Length - colon - 1);

				//Get and cache wmiObj
				ISWbemLocator wbemLocator = WmiHelper.WbemLocator;//(ISWbemLocator)(new SWbemLocator());

				wbemServices = wbemLocator.ConnectServer(serverName, 
									nsName, 
									"",	//user: blank defaults to current logged-on user
									"",	//password: blank defaults to current logged-on user
									"",	//locale: blank for current locale
									"",	//authority: NTLM or Kerberos. Blank lets DCOM negotiate.
									0,	//flags: reserved
									null);	//context info: not needed here
				
							
				wmiObj = wbemServices.Get (className,
							(int)WbemFlagEnum.wbemFlagUseAmendedQualifiers,
							null);
								

			}
			catch (Exception exc)
			{
				//MessageBox.Show(WMISys.GetString("WMISE_Exception", exc.Message, exc.StackTrace));
				throw (exc);
			}
		}

		
		/// <summary>
        ///     The object retrieves its serialization info.
        /// </summary>
        public WMIClassNode(SerializationInfo info, StreamingContext context) {
            
			try 
			{
				try
				{
					rm = new ResourceManager( "Microsoft.VSDesigner.WMI.Res",     // Name of the resource.
							".",            // Use current directory.
							null);	
				}
				catch (Exception)
				{
					//do nothing, will use static RM
				}

				path = info.GetString("Path");

				//parse the path to get server, namespace and class name
				Int32 separ = path.IndexOf ("\\", 2);
				if (separ == -1)
				{
					//invalid path
					throw (new ArgumentException(WMISys.GetString("WMISE_InvalidPath", path), "Path"));
				}

				serverName = path.Substring(2, separ - 2);
				pathNoServer = path.Substring(separ + 1, path.Length - separ - 1);
						
				//split pathNoServer into namespace and classname parts (':' is the separator)
				Int32 colon = pathNoServer.IndexOf(':', 0);
				if (colon == -1)
				{
					//invalid path
					throw (new ArgumentException(WMISys.GetString("WMISE_InvalidPath", path), "Path"));
				}			
				nsName = pathNoServer.Substring(0,colon);
				className = pathNoServer.Substring(colon + 1, pathNoServer.Length - colon - 1);

				//Get and cache wmiObj
				ISWbemLocator wbemLocator = WmiHelper.WbemLocator;//(ISWbemLocator)(new SWbemLocator());


				wbemServices = wbemLocator.ConnectServer(serverName, 
									nsName, 
									"",	//user: blank defaults to current logged-on user
									"",	//password: blank defaults to current logged-on user
									"",	//locale: blank for current locale
									"",	//authority: NTLM or Kerberos. Blank lets DCOM negotiate.
									0,	//flags: reserved
									null);	//context info: not needed here
				
							
				wmiObj = wbemServices.Get (className,
							//0,
							(int)WbemFlagEnum.wbemFlagUseAmendedQualifiers,
							null);

                        
            }
            catch (Exception exc) {
				MessageBox.Show(WMISys.GetString("WMISE_Exception", exc.Message, exc.StackTrace));
				throw (exc);
            }
        }

		

        //
        // PROPERTIES
        //

        // <doc>
        // <desc>
        //     Returns icon for this node.
        // </desc>
        // </doc>
		
        public Image Icon {
            override get {
				//TODO: display different icons for associations, abstract, etc.
				if (icon == null)
				{						
					if (rm != null)
					{
						icon = (Image)rm.GetObject ("Microsoft.VSDesigner.WMI.class.bmp");
					}
					else
					{
	                    icon = (Image)new Bitmap(GetType(), "class.bmp");
					}

				}				
				return icon;

            }
        }

	
	/// <summary>
	/// Context menu for a class object contains static method names
	/// </summary>
	public override ContextMenuItem[] GetContextMenuItems() {

		
		//This is a temporary work around for a bug (in GC?) where cached wmiObj
		//becomes unusable
		try 
		{
			string path = wmiObj.Path_.Path;
		}
		catch (Exception)
		{
			//refresh the object
			wmiObj = null;
			wmiObj = WmiHelper.GetObject(path, wbemServices, serverName, nsName);
		}
	

		ISWbemMethodSet methods = wmiObj.Methods_;
		
		ContextMenuItem[] theMenu = new ContextMenuItem[methods.Count + 1];
		
		//theMenu[0] = new ContextMenuItem("&View All Instances...", new EventHandler(OnExpandAll));
		//theMenu[1] = new ContextMenuItem("&Filter Instances...", new EventHandler(OnAddInstanceFilter));

		theMenu[0] = new ContextMenuItem(WMISys.GetString("WMISE_ClassNode_CreateNewInstance"), 
										new EventHandler(OnCreateNewInstance),
										false);

		int i = 1;	

		//TODO: retrieve static methods for the class and add them to context menu
		IEnumerator methEnum = ((IEnumerable)methods).GetEnumerator();		

		
		while (methEnum.MoveNext())
		{
			ISWbemMethod meth = (ISWbemMethod)methEnum.Current;
			
			if (WmiHelper.IsStaticMethod(meth) && WmiHelper.IsImplementedMethod(meth))
			{							
				
				//add method name to context menu
				theMenu[i] = new ContextMenuItem("&" + i.ToString() + " " + meth.Name + "...", //TODO: hotkey???
							new EventHandler(OnExecuteMethod));				
				i++;
			}
		}

		return theMenu;
    }
	public override bool CanDeleteNode()
	{
		return true;		
	}

	public override bool ConfirmDeletingNode()
	{
		DialogResult res = MessageBox.Show(WMISys.GetString("WMISE_ClassNode_RemovePrompt", className),
                                        VSDSys.GetString("SE_MessageBoxTitle_ServerExplorer"), 
										MessageBox.YesNo);
		return (res == DialogResult.Yes);
	}


        // <doc>
        // <desc>
        //     Returns label constant for this node.
        // </desc>
        // </doc>
        public string Label {
            override get {
                if (label == null || label.Length == 0) {
					label = className; 
					if (WmiHelper.UseFriendlyNames)
					{
						string strFriendly = WmiHelper.GetDisplayName(wmiObj);
						if (strFriendly != string.Empty)
						{
							label = strFriendly; 
						}
					}	
                }
                return label;
            }
            override set {
            }
        }

        //
        // METHODS
        //

        // <doc>
        // <desc>
        //     Create instance nodes under this node.
        // </desc>
        // </doc>
        public override Node[] CreateChildren() {
	
		try
		{
			//This is a temporary work around for a bug (Interop? GC?) where cached wmiObj
			//becomes unusable
			try 
			{
				string path = wmiObj.Path_.Path;
			}
			catch (Exception)
			{
				//refresh the object
				wmiObj = null;
				wmiObj = WmiHelper.GetObject(path, wbemServices, serverName, nsName);
			}
			
			int flags = (int)(WbemFlagEnum.wbemFlagReturnImmediately); // | WbemFlagEnum.wbemFlagForwardOnly);

			try 
			{
				ISWbemSecurity sec = wbemServices.Security_;
			}
			catch (Exception)
			{					
				wbemServices = null;
				wbemServices = WmiHelper.GetServices(serverName, nsName);
			}
		    ISWbemObjectSet objs = wbemServices.InstancesOf(className, flags, null);
			IEnumerator enumInst = ((IEnumerable)objs).GetEnumerator();

			Node[] nodes = new Node[objs.Count];	
			
			UInt32 i = 0;	
			
			while(enumInst.MoveNext())
			{
				nodes[i++] = new WMIInstanceNode((ISWbemObject)enumInst.Current, wmiObj);									
			}			

			return nodes;
				
		}
		catch(Exception exc)
		{
			MessageBox.Show(WMISys.GetString("WMISE_Exception", exc.Message, exc.StackTrace));
			return null;
		}
			
        }

        // <doc>
        // <desc>
        //     This node is a singleton.
        // </desc>
        // </doc>
        public override int CompareUnique(Node node) {
            return 0;
        }


	private void OnExpandAll(object sender, EventArgs e) {
 			
		try 
		{
			//TODO: this needs to be changed to do something more meaningful
			GetNodeSite().Expand();
			
		}
		catch(Exception exc)
		{
			MessageBox.Show(WMISys.GetString("WMISE_Exception", exc.Message, exc.StackTrace));
		}	
        }

	private void OnAddInstanceFilter(object sender, EventArgs e) {
 			
		try 
		{
			MessageBox.Show("Not implemented yet");
		}
		catch(Exception exc)
		{
			MessageBox.Show(WMISys.GetString("WMISE_Exception", exc.Message, exc.StackTrace));
		}	

    }

	/// <summary>
	/// Get component to be displayed in PB window
	/// </summary>
	public override Object GetBrowseComponent() 
	{	

		//This is a temporary work around for a bug (Interop? GC?) where cached wmiObj
		//becomes unusable
		try 
		{
				string path = wmiObj.Path_.Path;
		}
		catch (Exception)
		{
			//refresh the object
			wmiObj = null;
			wmiObj = WmiHelper.GetObject(path, wbemServices, serverName, nsName);
		}

		return new WMIObjectComponent(wmiObj, wmiObj);
    }


	/// <summary>
	/// Execute static method against WMI class
	/// </summary>
	/// <param name="sender"> </param>
	/// <param name="e"> </param>
	private void OnExecuteMethod(object sender, EventArgs e)
	{
		try 
		{
			//This is a temporary work around for a bug (Interop? GC?) where cached wmiObj
			//becomes unusable
			try 
			{
				string path = wmiObj.Path_.Path;
			}
			catch (Exception)
			{
				//refresh the object
				wmiObj = null;
				wmiObj = WmiHelper.GetObject(path, wbemServices, serverName, nsName);
			}
				//trim the ordinal prefix (all up to first space)
			//and 3 dots off the end of the context menu text to get method name
			String methName = ((ContextMenuItem)sender).Text.Substring(0, ((ContextMenuItem)sender).Text.Length - 3);
			int spaceIndex = methName.IndexOf(' ', 0);
			methName = methName.Substring(spaceIndex + 1);
		
			//get method object
			ISWbemMethod meth = wmiObj.Methods_.Item(methName, 0);
			ExecuteMethodDialog dlg = new ExecuteMethodDialog(wmiObj, meth, wmiObj);
			DialogResult res = dlg.ShowDialog();

		}
		catch(Exception exc)
		{
			MessageBox.Show(WMISys.GetString("WMISE_Exception", exc.Message, exc.StackTrace));
		}	

	}

	/// <summary>
	/// Create new instance of the class
	/// </summary>
	/// <param name="sender"> </param>
	/// <param name="e"> </param>
	private void OnCreateNewInstance(object sender, EventArgs e)
	{
		try 
		{
			if (this.GetNodeSite().GetChildCount() == 0)
			{
				Node[] children = this.CreateChildren();
				for (int i = 0; i < children.Length; i++)
				{
					GetNodeSite().AddChild(children[i]);
				}
			}
						
			//This is a temporary work around for a bug (Interop? GC?) where cached wmiObj
			//becomes unusable
			try 
			{
				string path = wmiObj.Path_.Path;
			}
			catch (Exception)
			{
				//refresh the object
				wmiObj = null;
				wmiObj = WmiHelper.GetObject(path, wbemServices, serverName, nsName);
			}

			//spawn new object and add it as a child node
			ISWbemObject newInst = wmiObj.SpawnInstance_(0);
			WMIInstanceNode childNode = new WMIInstanceNode(newInst, wmiObj);
			childNode.Label = WMISys.GetString("WMISE_ClassNode_NewInstanceLbl", this.label);
            GetNodeSite().AddChild(childNode);
			childNode.GetNodeSite().Select();
			
		
		}
		catch(Exception exc)
		{
			MessageBox.Show(WMISys.GetString("WMISE_Exception", exc.Message, exc.StackTrace));
		}	

	}

	
	    /// <summary>
        ///      To determine whether this node supports drag and drop.
        /// </summary>
        /// <returns>
        ///      TRUE to indicate ProcessNode supports drag and drop.
        /// </returns>
        public override bool HasDragComponents() {
            return false;	//disable d&d for Beta1
        }

		//disable d&d for Beta1
		/*
		public override IComponent[] CreateDragComponents(IDesignerHost designerHost) {
			Object comp = null;

			
			//This is a temporary work around for a bug (Interop? GC?) where cached wmiObj
			//becomes unusable
			try 
			{
				string path = wmiObj.Path_.Path;
			}
			catch (Exception)
			{
				//refresh the object
				wmiObj = null;
				wmiObj = WmiHelper.GetObject(path, wbemServices, serverName, nsName);
			}
				//trim the ordinal prefix (all up to first space)

			comp  = new WMIObjectComponent(wmiObj);

			return new IComponent[] {(IComponent)comp};
        }
		*/

	/// <summary>
    ///     The object should write the serialization info.
    /// </summary>
    public virtual void GetObjectData(SerializationInfo si, StreamingContext context) {
		si.AddValue("Path", path);
    }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vside\servexpl\beta1\wmisysdescriptionattribute.cs ===
//------------------------------------------------------------------------------
/// <copyright from='1997' to='2001' company='Microsoft Corporation'>           
///    Copyright (c) Microsoft Corporation. All Rights Reserved.                
///    Information Contained Herein is Proprietary and Confidential.            
/// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace Microsoft.VSDesigner.WMI {
    

    using System.Diagnostics;
    using System;
	using System.ComponentModel;
    

    /// <internalonly/>
    /// <summary>
    ///    <para>
    ///       DescriptionAttribute marks a property, event, or extender with a
    ///       description. Visual designers can display this description when referencing
    ///       the member.
    ///    </para>
    /// </summary>
    /// <seealso cref='System.ComponentModel.MemberAttribute'/>
    /// <seealso cref='System.ComponentModel.PropertyDescriptor'/>
    /// <seealso cref='System.ComponentModel.EventDescriptor'/>
    /// <seealso cref='System.ComponentModel.ExtendedPropertyDescriptor'/>
    [AttributeUsage(AttributeTargets.All)]
    public class WMISysDescriptionAttribute : DescriptionAttribute {

        private bool replaced = false;

        /// <summary>
        ///     Constructs a new sys description.
        /// </summary>
        /// <param name='description'>
        ///     description text.
        /// </param>
        public WMISysDescriptionAttribute(string description) : base(description) {
        }

        /// <summary>
        ///     Retrieves the description text.
        /// </summary>
        /// <returns>
        ///     description
        /// </returns>
        public override string GetDescription() {
            if (!replaced) {
                replaced = true;
                description = WMISys.GetString(base.GetDescription());
            }
            return base.GetDescription();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vside\servexpl\beta1\wmiobjectpropertytable.cs ===
namespace Microsoft.VSDesigner.WMI 
{
	using System;
	using System.ComponentModel;
	using System.Core;
	using System.WinForms;
	using Microsoft.Win32.Interop;
	using System.Drawing;
	using WbemScripting;
	using System.Collections;
	using System.Data;

	public enum ComparisonOperators 
	{
		Equals = 0,
		NotEquals,
		LessThan,
		LessThanOrEquals,
        GreaterThan,
		GreaterThanOrEquals        		
	}

	
	public class WMIObjectPropertyTable : DataTable
	{	
			
		private	ISWbemObject wmiObj = null;   
		private PropertyFilters propFilters = PropertyFilters.ShowAll;
		private GridMode gridMode = GridMode.ViewMode;

		private DataColumn propOrigin = null;
		private DataColumn propIsKey = null;

		private DataColumn propNameColumn = null;
		private DataColumn propTypeColumn = null;
		private DataColumn propValueColumn = null;	

		private DataColumn propDescrColumn = null;	
		private DataColumn operatorColumn = null;

		bool showOperators = false;
		bool showOrigin = false;
		bool showKeys = false;

		public WMIObjectPropertyTable(ISWbemObject wmiObjIn,
									PropertyFilters propFiltersIn,
									GridMode gridModeIn,
									bool showOperatorsIn,
									bool showOriginIn,
									bool showKeysIn)
		{	
			try
			{

				if (wmiObjIn == null)
				{
					throw (new ArgumentNullException("wmiObj"));
				}

				wmiObj = wmiObjIn;
				propFilters = propFiltersIn;
				gridMode = gridModeIn;

				showOperators = showOperatorsIn;
				showOrigin = showOriginIn;
				showKeys = showKeysIn;

				Initialize();			
			}

			catch (Exception exc)
			{
				MessageBox.Show(WMISys.GetString("WMISE_Exception", exc.Message, exc.StackTrace));
			}
		}

        
		public ISWbemObject WMIObject
		{	
			get
			{
				return wmiObj;
			}
		}


		private void Initialize ()
		{
			try
			{

				this.TableName = wmiObj.Path_.Class;
				
				propNameColumn = new DataColumn (WMISys.GetString("WMISE_PropTable_ColumnName")); 
												
				propNameColumn.AllowNull = false;
				propNameColumn.Unique = true;
				propNameColumn.DataType = typeof(string);
				
				propTypeColumn = new DataColumn (WMISys.GetString("WMISE_PropTable_ColumnType"));
				propTypeColumn.AllowNull = false;
				propTypeColumn.DataType = typeof(string);
				
				propValueColumn = new DataColumn (WMISys.GetString("WMISE_PropTable_ColumnValue"));
				propValueColumn.DefaultValue = null;

				propDescrColumn = new DataColumn(WMISys.GetString("WMISE_PropTable_ColumnDescription"));
				propDescrColumn.ReadOnly = true;
				propDescrColumn.DefaultValue = string.Empty;
				propDescrColumn.DataType = typeof(string);

				if (showOperators)
				{
					operatorColumn = new DataColumn(WMISys.GetString("WMISE_PropTable_ColumnComparison"), 
													typeof(ComparisonOperators));
				}
				//operatorColumn.AllowNull = false;
				/*
				ValueEditor dropDownEditor = new ValueEditor();
				dropDownEditor.Style = ValueEditorStyles.DropdownArrow;
				operatorColumn.DataValueEditorType = dropDownEditor.GetType();
				*/


				if (showKeys)
				{
					propIsKey = new DataColumn (WMISys.GetString("WMISE_PropTable_ColumnIsKey"), typeof(Boolean));
					propIsKey.AllowNull = false;
					propIsKey.DefaultValue = false;
				}				

				if (showOrigin)
				{
					propOrigin = new DataColumn (WMISys.GetString("WMISE_PropTable_ColumnIsLocal"), typeof(Boolean));				              				
					propOrigin.AllowNull = false;
					propOrigin.DefaultValue = true;
				}		

				//set read/write permissions on columns
				//Note that DefaultView takes care of the rest of the restrictions
				//(see below)
				if (gridMode == GridMode.EditMode)
				{					
					propNameColumn.ReadOnly = true;
					propTypeColumn.ReadOnly = true;
					propValueColumn.ReadOnly = false;

					if (showOrigin)
					{
						propOrigin.ReadOnly = true;
					}
					if (showKeys)
					{
						propIsKey.ReadOnly = true;
					}				
				}

				if (gridMode == GridMode.DesignMode && showOrigin)
				{
					propOrigin.ReadOnly = true;	
				}
                
				Columns.Add(propNameColumn);
				Columns.Add(propTypeColumn);
				if (showOperators)
				{
					//operatorColumn.DataValueEditorType = typeof(OperatroDataColumnEditor);
					operatorColumn.ReadOnly = false;
					Columns.Add(operatorColumn);
				}

				Columns.Add(propValueColumn);
				//Columns.Add(propDescrColumn);

				if (showOrigin)
				{
					Columns.Add(propOrigin);
				}
				if (showKeys)
				{
					Columns.Add(propIsKey);
				}

			
				ISWbemPropertySet props = wmiObj.Properties_;

				IEnumerator propEnum = ((IEnumerable)props).GetEnumerator();	
			
				while (propEnum.MoveNext())
				{
					ISWbemProperty prop = (ISWbemProperty)propEnum.Current;

					
					if (propFilters == PropertyFilters.NoInherited && 
						!prop.IsLocal)
					{
						continue;	//skip this property
					}		

					DataRow propRow = NewRow();

					propRow[propNameColumn] = prop.Name;
					propRow[propTypeColumn] = CIMTypeMapper.ToString(prop.CIMType);
					propRow[propValueColumn] = prop.get_Value();
					//propRow[propDescrColumn] = WmiHelper.GetPropertyDescription(prop, wmiObj);
					if (showOperators)
					{
						propRow[operatorColumn] = "=";
					}					

					//set property origin column
					
					if (showOrigin)
					{
						if (prop.IsLocal)
						{
							propRow[propOrigin] = true;
						}
						else
						{
							propRow[propOrigin] = false;
						}
					}
					
					if (showKeys)
					{
						propRow[propIsKey] = WmiHelper.IsKeyProperty(prop);
					}
					
					
					Rows.Add (propRow);
				}	
				//TODO: add system properties here (if PropertyFilters.ShowAll)

				this.CaseSensitive = false;
				this.RowChanged += new DataRowChangeEventHandler(this.RowChangedEventHandler);
				this.RowChanging += new DataRowChangeEventHandler(this.RowChangingEventHandler);


				DataView view = this.DefaultView;
				switch (gridMode)
				{
					case (GridMode.ViewMode):
						{
							view.AllowEdit = false; //wmi raid 2866?
							view.AllowDelete = false;
							view.AllowNew = false;
							break;
						}
					case (GridMode.EditMode):
						{
							view.AllowEdit = true;
							view.AllowDelete = false;
							view.AllowNew = false;
							break;
						}
					case (GridMode.DesignMode):
						{
							view.AllowEdit = true;
							view.AllowDelete = true;
							view.AllowNew = true;
							break;
						}	
				}

				
			}

			catch (Exception exc)
			{
					MessageBox.Show(WMISys.GetString("WMISE_Exception", exc.Message, exc.StackTrace));
			}
		}


		
		protected void RowChangedEventHandler(object sender,
							DataRowChangeEventArgs e)
		{
			try
			{
				//MessageBox.Show("RowChangedEventHandler");

				DataRow RowAffected = e.Row;
				switch (e.Action)
				{
					case(DataRowAction.Add):
					{
						MessageBox.Show("Cannot Add Rows. Deleting...");
						RowAffected.Delete();
						break;
					}
					case(DataRowAction.Change):
					{
						DataRow row = e.Row;
						if (gridMode == GridMode.EditMode)
						{
							//this can only be value change
							ISWbemProperty propAffected = wmiObj.Properties_.Item(row[propNameColumn].ToString(), 0);

							Object newValue = WmiHelper.GetTypedObjectFromString(propAffected.CIMType,
												row[propValueColumn].ToString());

									
							propAffected.set_Value(ref newValue);
							
						}
						//TODO: handle other modes here, too!!!
						break;
					}
					case(DataRowAction.Commit):
					{
						MessageBox.Show("DataRowAction.Commit");
						break;
					}
					case(DataRowAction.Delete):
					{
						MessageBox.Show("Cannot delete nodes.Adding back...");
						RowAffected.CancelEdit();
						break;
					}
					case(DataRowAction.Nothing):
					{
						MessageBox.Show("DataRowAction.Nothing");
						break;
					}
					case(DataRowAction.Rollback):
					{
						MessageBox.Show("DataRowAction.Rollback");
						break;
					}						
				}			
			}
			catch (Exception exc)
			{
					MessageBox.Show(WMISys.GetString("WMISE_Exception", exc.Message, exc.StackTrace));
			}

		}	

		
			
		protected void RowChangingEventHandler(object sender,
								DataRowChangeEventArgs e)
		{
			try
			{

				DataRow row = e.Row;
				switch (e.Action)
				{
					case(DataRowAction.Add):
					{
						//throw (new Exception("Cannot add rows"));	
						break;
						
					}
					case(DataRowAction.Change):
					{
						//if this is an object, datetime, enum or ref property changing,
						//bring up custom UI for editing these!!!!
						if (gridMode == GridMode.EditMode)
						{
							//this can only be value change
							ISWbemProperty propAffected = wmiObj.Properties_.Item(row[propNameColumn].ToString(), 0);

							if (propAffected.CIMType == WbemCimtypeEnum.wbemCimtypeObject)
							{
								MessageBox.Show("should bring up custom type editor for objects");
							}

							if (propAffected.CIMType == WbemCimtypeEnum.wbemCimtypeReference)
							{
								MessageBox.Show("should bring up custom type editor for refs");
							}

							if (propAffected.CIMType == WbemCimtypeEnum.wbemCimtypeDatetime)
							{
								MessageBox.Show("should bring up custom type editor for datetime");
							}

							if (WmiHelper.IsValueMap(propAffected))
							{
								MessageBox.Show("should bring up custom type editor for enums");
							}
							
						}
						break;
					}
					case(DataRowAction.Commit):
					{
						MessageBox.Show("DataRowAction.Commit");
						break;
					}
					case(DataRowAction.Delete):
					{
						throw (new Exception("Cannot delete rows"));
										}
					case(DataRowAction.Nothing):
					{
						MessageBox.Show("DataRowAction.Nothing");
						break;
					}
					case(DataRowAction.Rollback):
					{
						MessageBox.Show("DataRowAction.Rollback");
						break;
					}						
				}			
			}
			catch (Exception exc)
			{
					MessageBox.Show(WMISys.GetString("WMISE_Exception", exc.Message, exc.StackTrace));
					throw(exc);
			}
		}	

		internal void SetPropertyValue (int rowNum, String val) 
		{	
	        try
			{
			
				DataRow row = this.Rows.All[rowNum];
			
				ISWbemProperty propAffected = wmiObj.Properties_.Item(row[propNameColumn].ToString(), 0);

				Object newValue = WmiHelper.GetTypedObjectFromString(propAffected.CIMType,
												val);
								
				propAffected.set_Value(ref newValue);               

				
			}
			catch (Exception exc)
			{
				MessageBox.Show(WMISys.GetString("WMISE_Exception", exc.Message, exc.StackTrace));
				throw (exc);
			}
		}

		public String WhereClause 
		{
			get 
			{
				if (showOperators == false || Rows.Count == 0)
				{
					return  string.Empty;
				}
				const String strWhere = " WHERE ";
				const String strAnd = " AND ";
				
				String clause = strWhere;
				for (int i = 0; i < Rows.Count; i++)
				{
					DataRow curRow = Rows.All[i];
					ISWbemProperty curProp = wmiObj.Properties_.Item(curRow[propNameColumn].ToString(), 0);

					if (curRow[propValueColumn].ToString() == "")
					{
						continue;
					}

					clause += curRow[propNameColumn] + " " +
							  curRow[operatorColumn] + " ";

					//if the property is a string, datetime or object,
					//put quotes around the value
					if (curProp.CIMType == WbemCimtypeEnum.wbemCimtypeDatetime ||
						curProp.CIMType == WbemCimtypeEnum.wbemCimtypeObject ||
						curProp.CIMType == WbemCimtypeEnum.wbemCimtypeString)	//any others?
					{
						 clause += "\"" + curRow[propValueColumn] + "\"" + strAnd;
					}
					else
					{
                        clause += curRow[propValueColumn] + strAnd;				
					}
				}

				if (clause == strWhere)
				{
					return string.Empty;
				}
				
				//get rid of the last " AND "
				if (clause.Substring (clause.Length - strAnd.Length, strAnd.Length) == strAnd)
				{
					clause = clause.Substring(0, clause.Length - strAnd.Length);
				}
				
				return clause;
				
			}
		}


		}	
		


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vside\servexpl\beta1\wmisys.cs ===
//------------------------------------------------------------------------------
/// <copyright from='1997' to='2001' company='Microsoft Corporation'>           
///    Copyright (c) Microsoft Corporation. All Rights Reserved.                
///    Information Contained Herein is Proprietary and Confidential.            
/// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VSDesigner.WMI {

    using System.Diagnostics;

    using System;
    using System.WinForms;
    using System.IO;
    using System.Globalization;
    using System.ComponentModel;
    using System.Core;
    using System.Resources;

    public class WMISys : StaticResourceManager {
        private static bool loading = false;
        private static WMISys loader = null;

        private WMISys() {
        }

        protected override string GetResourceBaseName() {
			return "Res";
        }

        private static WMISys GetLoader() {
            lock(typeof(WMISys)) {
                // loading is used to avoid recursing.
                if (loader == null && !loading) {
                    loading = true;
                    try {
                        loader = new WMISys();
                    }
                    finally {
                        loading = false;
                    }
                }
                return loader;
            }
        }

        public static string GetString(string name, object arg1) {
            return GetString(Application.CurrentCulture,
                name,
                new object[] {arg1});
        }
        public static string GetString(CultureInfo culture, string name, object arg1) {
            return GetString(culture,
                name,
                new object[] {arg1});
        }
        public static string GetString(string name, object arg1, object arg2) {
            return GetString(Application.CurrentCulture,
                name,
                new object[] {arg1, arg2});
        }
        public static string GetString(CultureInfo culture, string name, object arg1, object arg2) {
            return GetString(culture,
                name,
                new object[] {arg1, arg2});
        }
        public static string GetString(string name, object arg1, object arg2, object arg3) {
            return GetString(Application.CurrentCulture,
                name,
                new object[] {arg1, arg2, arg3});
        }
        public static string GetString(CultureInfo culture, string name, object arg1, object arg2, object arg3) {
            return GetString(culture,
                name,
                new object[] {arg1, arg2, arg3});
        }
        public static string GetString(string name, object arg1, object arg2, object arg3, object arg4) {
            return GetString(Application.CurrentCulture,
                name,
                new object[] {arg1, arg2, arg3, arg4});
        }
        public static string GetString(CultureInfo culture, string name, object arg1, object arg2, object arg3, object arg4) {
            return GetString(culture,
                name,
                new object[] {arg1, arg2, arg3, arg4});
        }
        public static string GetString(string name, object arg1, object arg2, object arg3, object arg4, object arg5) {
            return GetString(Application.CurrentCulture,
                name,
                new object[] {arg1, arg2, arg3, arg4, arg5});
        }
        public static string GetString(CultureInfo culture, string name, object arg1, object arg2, object arg3, object arg4, object arg5) {
            return GetString(culture,
                name,
                new object[] {arg1, arg2, arg3, arg4, arg5});
        }
        public static string GetString(string name, object[] args) {
            return GetString(Application.CurrentCulture, name, args);
        }
        public static string GetString(CultureInfo culture, string name, object[] args) {
            WMISys sys = GetLoader();
            if (sys == null)
                return null;
            return sys.ReadString(culture, name, args);
        }

        public static string GetString(string name) {
            return GetString(Application.CurrentCulture, name);
        }
        public static string GetString(CultureInfo culture, string name) {
            WMISys sys = GetLoader();
            if (sys == null)
                return null;
            return sys.ReadString(culture, name);
        }
        public static bool GetBoolean(string name) {
            return GetBoolean(Application.CurrentCulture, name);
        }
        public static bool GetBoolean(CultureInfo culture, string name) {
            bool val = false;;

            WMISys sys = GetLoader();
            if (sys != null)
                val = sys.ReadBoolean(culture, name);
            return val;
        }
        public static char GetChar(string name) {
            return GetChar(Application.CurrentCulture, name);
        }
        public static char GetChar(CultureInfo culture, string name) {
            char val = (char)0;

            WMISys sys = GetLoader();
            if (sys != null) {
                val = sys.ReadChar(culture, name);
            }
            return val;
        }
        public static byte GetByte(string name) {
            return GetByte(Application.CurrentCulture, name);
        }
        public static byte GetByte(CultureInfo culture, string name) {
            byte val = (byte)0;

            WMISys sys = GetLoader();
            if (sys != null) {
                val = sys.ReadByte(culture, name);
            }
            return val;
        }
        public static short GetShort(string name) {
            return GetShort(Application.CurrentCulture, name);
        }
        public static short GetShort(CultureInfo culture, string name) {
            short val = (short)0;

            WMISys sys = GetLoader();
            if (sys != null) {
                val = sys.ReadInt16(culture, name);
            }
            return val;
        }
        public static int GetInt(string name) {
            return GetInt(Application.CurrentCulture, name);
        }
        public static int GetInt(CultureInfo culture, string name) {
            int val = 0;

            WMISys sys = GetLoader();
            if (sys != null) {
                val = sys.ReadInt32(culture, name);
            }
            return val;
        }
        public static long GetLong(string name) {
            return GetLong(Application.CurrentCulture, name);
        }
        public static long GetLong(CultureInfo culture, string name) {
            long val = 0l;

            WMISys sys = GetLoader();
            if (sys != null) {
                val = sys.ReadInt64(culture, name);
            }
            return val;
        }
        public static float GetFloat(string name) {
            return GetFloat(Application.CurrentCulture, name);
        }
        public static float GetFloat(CultureInfo culture, string name) {
            float val = 0.0f;

            WMISys sys = GetLoader();
            if (sys == null) {
                val = sys.ReadSingle(culture, name);
            }
            return val;
        }
        public static double GetDouble(string name) {
            return GetDouble(Application.CurrentCulture, name);
        }
        public static double GetDouble(CultureInfo culture, string name) {
            double val = 0.0;

            WMISys sys = GetLoader();
            if (sys == null) {
                val = sys.ReadDouble(culture, name);
            }
            return val;
        }
        
		public static object GetObject(string name) {
            return GetObject(Application.CurrentCulture, name);
        }

        public static object GetObject(CultureInfo culture, string name) {
            WMISys sys = GetLoader();
            if (sys == null)
                return null;
            return sys.ReadObject(culture, name);
        }
    }


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vside\servexpl\beta1\wmiobjectgrid.cs ===
namespace Microsoft.VSDesigner.WMI 
{

	using System;
	using System.ComponentModel;
	using System.Core;
	using System.WinForms;
	using Microsoft.Win32.Interop;
	using System.Drawing;
	using WbemScripting;
	using System.Collections;

	/// <summary>
	/// These filters define which properties will be displayed
	/// </summary>
	public enum PropertyFilters
	{
		ShowAll		= 0,
		NoSystem	= 0x1,
		NoInherited = 0x10	
	}


	/// <summary>
	/// These filters define whether changing/adding/deleting properties is allowed
	/// </summary>
	public enum GridMode
	{
		ViewMode	= 0,
		EditMode	= 0x1,
		DesignMode  = 0x10	
	}


	public class WMIObjectGrid : DataGrid
	{
		private void InitializeComponent ()
		{
		}
		
		private	ISWbemObject wmiObj = null; 
		private PropertyFilters propFilters = PropertyFilters.ShowAll;
		private GridMode gridMode = GridMode.ViewMode;

		bool showOperators = false;
		bool showOrigin = false;
		bool showKeys = false;
		
		public WMIObjectGrid()
		{	
			try
			{
			
			}

			catch (Exception exc)
			{
					MessageBox.Show(WMISys.GetString("WMISE_Exception", exc.Message, exc.StackTrace));
			}
		}


		public WMIObjectGrid(ISWbemObject wmiObjIn, 
							PropertyFilters propFiltersIn,
							GridMode gridModeIn,
							bool showOperatorsIn,
							bool showOriginIn,
							bool showKeysIn)
		{	
			try
			{

				if (wmiObjIn == null)
				{
					throw (new ArgumentNullException("wmiObjIn"));
				}

				wmiObj = wmiObjIn;
				propFilters = propFiltersIn;
				gridMode = gridModeIn;

				showOperators = showOperatorsIn;
				showOrigin = showOriginIn;
				showKeys = showKeysIn;

				Initialize();		

			}

			catch (Exception exc)
			{
					MessageBox.Show(WMISys.GetString("WMISE_Exception", exc.Message, exc.StackTrace));
			}
		}

		
		public ISWbemObject WMIObject
		{
			set
			{
				if (value == null)
				{
					throw (new ArgumentNullException("value"));
				}
				wmiObj = value;
				ReInit();			
			}
			get
			{
				return wmiObj;
			}
		}

		public PropertyFilters CurrentPropertyFilters
		{
			set
			{
				propFilters = value;
				ReInit();			
			}
			get
			{
				return propFilters;
			}
		}


		public GridMode CurrentGridMode
		{
			set
			{
				gridMode = value;
				ReInit();			
			}
			get
			{
				return gridMode;
			}
		}

		public void AcceptChanges ()
		{            		
			if (DataSource != null)
			{
				DataGridCell curCell = this.CurrentCell;

				((WMIObjectPropertyTable)DataSource).SetPropertyValue(curCell.RowNumber, this[curCell].ToString());

				((WMIObjectPropertyTable)DataSource).AcceptChanges();				
			}		
		}

		public bool CommitChanges (int flags)
		{
			try
			{
				if (DataSource == null ||
					wmiObj == null)
				{
					return true;
				}
				((WMIObjectPropertyTable)DataSource).AcceptChanges();

				wmiObj.Put_((int)flags, null);
				return true;
			}

			catch (Exception exc)
			{
				MessageBox.Show(WMISys.GetString("WMISE_Exception", exc.Message, exc.StackTrace));
				return false;
			}
		}

		private void Initialize ()
		{
			try
			{
				if (wmiObj == null)
				{
					throw (new Exception(WMISys.GetString("WMISE_ObjGrid_InitFailed")));
				}	

				if (DataSource != null)
				{
					DataSource = null;
				}

				DataSource = new WMIObjectPropertyTable(wmiObj,
														propFilters,
														gridMode,
														showOperators,
														showOrigin,
														showKeys);

				this.LostFocus += new EventHandler(this.OnLeftGrid);
				this.Leave += new EventHandler(this.OnLeftGrid);

				//this.add_CurrentCellChange(new EventHandler(this.OnCurrentCellChange));

				/*
				//make all columns same width
				DataGridColumn[] cols = this.GridColumns.All;
				for (int i = 0; i < cols.Length; i ++)
				{
					cols[i].Width = this.Width / cols.Length;
				}
				*/		
			}

			catch (Exception exc)
			{
				MessageBox.Show(WMISys.GetString("WMISE_Exception", exc.Message, exc.StackTrace));
			}
		}


		private void ReInit ()
		{
			try
			{
				//TODO: cleanup
				DataSource = null;
				Initialize();
				
			}
			catch (Exception exc)
			{
					MessageBox.Show(WMISys.GetString("WMISE_Exception", exc.Message, exc.StackTrace));
			}
		}	

	protected void OnLeftGrid(object sender, EventArgs e) 
	{
		
		//AcceptChanges();
	}
		

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vside\servexpl\beta1\wmiinstancenode.cs ===
namespace Microsoft.VSDesigner.WMI {
    using System.Runtime.Serialization;
    using System.Diagnostics;
    using System;
    using System.WinForms;
    using System.Drawing;
    using System.Collections;
    using Microsoft.VSDesigner;
	using Microsoft.VSDesigner.ServerExplorer;
    using System.ComponentModel.Design;
	using System.ComponentModel;
	using System.Resources;
	using Microsoft.VSDesigner.Interop;
   	using EnvDTE;

	
	using WbemScripting;

    // <doc>
    // <desc>
    //     This represents the wmi classes node under a server node.
    // </desc>
    // </doc>
    [UserContextAttribute("serveritem", "wmiinstance")]
    public class WMIInstanceNode : Node, ISerializable  {
        //
        // FIELDS
        //

        static Image icon;
        //public static readonly Type parentType = typeof(WMIClassNode);

        private string label = string.Empty;

		private ResourceManager rm = null;

		public readonly string path = string.Empty;
		private string serverName = string.Empty;
		private string nsName = string.Empty;
		private string className = string.Empty;

		private ISWbemObject wmiObj = null;
		private	readonly ISWbemObject wmiClassObj = null;

		private bool IsNewInstance = false;

		private Object browseComponent = null;

        //
        // CONSTRUCTORS
        //

        // <doc>
        // <desc>
        //     Main constructor.
	// </desc>
        // </doc>
        public WMIInstanceNode (ISWbemObject instObj,
								ISWbemObject classObj) {
			try
			{
				try
				{
					rm = new ResourceManager( "Microsoft.VSDesigner.WMI.Res",     // Name of the resource.
							".",            // Use current directory.
							null);	
				}
				catch (Exception)
				{
					//do nothing, will use static RM
				}
					
				wmiObj = instObj;
				wmiClassObj = classObj;
				
				ISWbemObjectPath wbemPath = wmiObj.Path_;
				
				path = wbemPath.Path;
				serverName = wbemPath.Server;
				nsName = wbemPath.Namespace;
				className = wbemPath.Class;

				IsNewInstance = (path == string.Empty);
				
			}
			catch (Exception exc)
			{
				MessageBox.Show(WMISys.GetString("WMISE_Exception", exc.Message, exc.StackTrace));
				throw (exc);
			}
		}

		public ISWbemObject WmiObj
		{
			get
			{
				return wmiObj;
			}
		}


		/// <summary>
        ///      This property determines whether this node should be serialized.
        ///      We won't serialize instance data, since it can be too volatile.
        ///      If SE is changed to gracefully handle failure to de-serialize, we may change this back to default.
        ///
        ///      WhenToSaveCondition.Never means never save node and its children regardless of its visibility.
        ///      WhenToSaveCondition.Always means always save node, their children depends it their property.
        ///      WhenToSaveCondition.WhenVisible (DEFAULT) when save node if node is expanded and visible.
        /// </summary>
        /// <returns>
        ///      The state of when to save this node.
        /// </returns>
        public  WhenToSaveCondition WhenToSave {
            override get {
                return WhenToSaveCondition.Never;
            }
            
        }

	/// <summary>
        ///     The object retrieves its serialization info.
        /// </summary>
        public WMIInstanceNode(SerializationInfo info, StreamingContext context) {
            
			try {
				rm = new ResourceManager( "Microsoft.VSDesigner.WMI.Res",     // Name of the resource.
						".",            // Use current directory.
						null);	

	
				path = info.GetString("path");
				serverName = info.GetString("serverName");
				nsName = info.GetString("nsName");
				className = info.GetString("className");

				//Get and cache wmiObj
				ISWbemLocator wbemLocator = WmiHelper.WbemLocator;//(ISWbemLocator)(new SWbemLocator());
				
				ISWbemServices wbemServices = wbemLocator.ConnectServer(serverName, 
									nsName, 
									"",	//user: blank defaults to current logged-on user
									"",	//password: blank defaults to current logged-on user
									"",	//locale: blank for current locale
									"",	//authority: NTLM or Kerberos. Blank lets DCOM negotiate.
									0,	//flags: reserved
									null);	//context info: not needed here
				
							
				wmiObj = wbemServices.Get (path,
							//0,
							(int)WbemFlagEnum.wbemFlagUseAmendedQualifiers,
							null);
			

				IsNewInstance = (path == string.Empty);


			}
			catch (Exception exc)
			{
				MessageBox.Show(WMISys.GetString("WMISE_Exception", exc.Message, exc.StackTrace));
				throw (exc);
			}
		}

        //
        // PROPERTIES
        //

        // <doc>
        // <desc>
        //     Returns icon for this node.
        // </desc>
        // </doc>
		
        public Image Icon {
            override get {
			
				if (icon == null)
				{						
					if (rm != null)
					{
						icon = (Image)rm.GetObject ("Microsoft.VSDesigner.WMI.inst.bmp");
					}
					else
					{
	                    icon = (Image)new Bitmap(GetType(), "inst.bmp");
					}

				}							
				
				return icon;

            }
        }


	public override ContextMenuItem[] GetContextMenuItems() {
			
			//This is a temporary work around for a bug (in GC?) where cached wmiObj
			//becomes unusable
			try 
			{
				string path = wmiObj.Path_.Path;
			}
			catch (Exception)
			{
				//refresh the object
				wmiObj = null;
				wmiObj = WmiHelper.GetObject(path, null, serverName, nsName);
			}
			           		
			ISWbemMethodSet methods = wmiObj.Methods_;
			
			ContextMenuItem[] theMenu = new ContextMenuItem[methods.Count + 2];

			int i = 0;	

			//TODO: retrieve non-static methods for the class and add them to context menu
			IEnumerator methEnum = ((IEnumerable)methods).GetEnumerator();	
			
			while (methEnum.MoveNext())
			{
				ISWbemMethod meth = (ISWbemMethod)methEnum.Current;
				
				if (WmiHelper.IsImplementedMethod(meth) && !WmiHelper.IsStaticMethod(meth))
				{				
					//add method name to context menu
					theMenu[i++] = new ContextMenuItem("&" + i.ToString() + " " + meth.Name + "...", //TODO: hotkey???
									new EventHandler(OnExecuteMethod));				
				}
			}

			if (IsNewInstance)
			{
				theMenu[i] = new ContextMenuItem(WMISys.GetString("WMISE_InstNode_SaveNewInstanceCM"), 
												new EventHandler(CommitNewInstance));
			}
			
			return theMenu;
            
        }

	public override bool CanDeleteNode()
	{
		return false;
	}
	

        // <doc>
        // <desc>
        //     Returns label with the value of the key property.
		//		If object has multiple keys, display them all (comma-separated)
		//
		//		If the object has a non-empty, non-key "Caption" property, 
		//		display its value followed by the key values in parens.
        // </desc>
        // </doc>
        public string Label {
        override get {
		try
		{			
			if (label == null || label.Length == 0) 
			{
				SetLabel();         
			}

	        return label;
		}
		catch (Exception exc)
			{
				MessageBox.Show(WMISys.GetString("WMISE_Exception", exc.Message, exc.StackTrace));
				return label;
			}
       }

            override set {
				label = value;
            }
       }

		//
        // METHODS
        //

        // <doc>
        // <desc>
        //     Create associator nodes under this node.
	//     The children of this node are of type WMIAssocGroupNode.
	//     Each WMIAssocGroupNode groups instances that belong to the same class; 
	//     are related to this one through the same association class,
	//     and play the same role.  
        // </desc>
        // </doc>
        public override Node[] CreateChildren() {
		try
		{
			//do not look for associators of a new instance
			if (this.IsNewInstance)
			{
				return null;
			}

			//BUGBUG: wmi raid 2855 
			//for Beta1, we are going to disable the ability to expand 
			//references of Win32_ComputerSystem

			if (className.ToUpper() == "WIN32_COMPUTERSYSTEM" &&
				nsName.ToUpper() == "ROOT\\CIMV2")
			{
				return null;
			}


			//This is a temporary work around for a bug (in GC?) where cached wmiObj
			//becomes unusable
			try 
			{
				string path = wmiObj.Path_.Path;
			}
			catch (Exception)
			{
				//refresh the object
				wmiObj = null;
				wmiObj = WmiHelper.GetObject(path, null, serverName, nsName);
			}

			//First, get association instances related to this

			ISWbemObjectSet assocInstances = wmiObj.References_(String.Empty,	//result class name
									String.Empty,   	//result role								
									false,			//bClassesOnly
									false,			//bSchemaOnly								
									String.Empty,	//required qualifier
									(int)WbemFlagEnum.wbemFlagReturnImmediately, // |WbemFlagEnum.wbemFlagForwardOnly),
									null
									);
			if (assocInstances == null)
			{
				return null;
			}		

			//assocGroups will contain a list of unique association/class/role groupings
			ArrayList assocGroups = new ArrayList();

			IEnumerator enumAssocInstances = ((IEnumerable)assocInstances).GetEnumerator();			
			while(enumAssocInstances.MoveNext())
			{
				ISWbemObject curObj = (ISWbemObject)enumAssocInstances.Current;

				AssocGroupComponent comp = new AssocGroupComponent(curObj, wmiObj);
				if (!assocGroups.Contains(comp))	//this relies on our implementation of "Equald" in AssocGroupComponent class
				{
					assocGroups.Add (comp);
				}				
			}

			Node[] childNodes = new Node[assocGroups.Count];

			Object[] arAssocGroups = assocGroups.ToArray();
			
			for (int i = 0; i < arAssocGroups.Length; i++)
			{
				childNodes[i] = new WMIAssocGroupNode((AssocGroupComponent)arAssocGroups[i]);					
			}		
	
			
			
			return childNodes;
		}
		catch (Exception exc)
		{
			MessageBox.Show(WMISys.GetString("WMISE_Exception", exc.Message, exc.StackTrace));			
			return null;
		}
			
        }

          /// <summary>
        /// Compares two nodes to aid in discovering whether they
        /// are duplicates (that is, whether they represent the same
        /// resource). This function must return 0 if and only if the
        /// given node represents the same resource as this node, and
        /// only one of them should appear in the tree. The compare order (as determined
        /// by returning values other than 0) must be consistent
        /// across all calls, but it can be arbitrary. This order is
        /// not used to determine the visible order in the tree.
        /// </summary>
	// <doc>
        // <desc>
        //     Two nodes are the same if they refer to the same WMI object (path)
        // </desc>
        // </doc>
        public override int CompareUnique(Node node) {
            
			if (node is WMIInstanceNode && 
				((WMIInstanceNode)node).WmiObj == this.WmiObj)
			{
				return 0;
			}
			else
			{
				return 1;
			}
        }

		
	
	public override Object GetBrowseComponent() {	
	
		//This is a temporary work around for a bug (in GC?) where cached wmiObj
		//becomes unusable
		try 
		{
			string path = wmiObj.Path_.Path;
		}
		catch (Exception)
		{
			//refresh the object
			wmiObj = null;
			wmiObj = WmiHelper.GetObject(path, null, serverName, nsName);
		}

		browseComponent = new WMIObjectComponent(wmiObj, wmiClassObj);		

		return browseComponent;
	}

	/// <summary>
    ///     This brings UI to execute WMI method against the instance.
    /// </summary>
	private void OnExecuteMethod(object sender, EventArgs e)
	{
		try 
		{
			//This is a temporary work around for a bug (in GC?) where cached wmiObj
			//becomes unusable
			try 
			{
				string path = wmiObj.Path_.Path;
			}
			catch (Exception)
			{
				//refresh the object
				wmiObj = null;
				wmiObj = WmiHelper.GetObject(path, null, serverName, nsName);
			}

			//trim the ordinal prefix (all up to first space)
			//and 3 dots off the end of the context menu text to get method name
			String methName = ((ContextMenuItem)sender).Text.Substring(0, ((ContextMenuItem)sender).Text.Length - 3);
			int spaceIndex = methName.IndexOf(' ', 0);
			methName = methName.Substring(spaceIndex + 1);
		
			//get method object
			ISWbemMethod meth = wmiObj.Methods_.Item(methName, 0);
			ExecuteMethodDialog dlg = new ExecuteMethodDialog(wmiObj, meth, wmiClassObj);
			DialogResult res = dlg.ShowDialog();
		}
		catch(Exception exc)
		{
			MessageBox.Show(WMISys.GetString("WMISE_Exception", exc.Message, exc.StackTrace));
		}	

	}

	/// <summary>
    ///     This saves new instance to WMI
    /// </summary>
	private void CommitNewInstance(object sender, EventArgs e)
	{
		try 
		{
			//This is a temporary work around for a bug (in GC?) where cached wmiObj
			//becomes unusable
			try 
			{
				string path = wmiObj.Path_.Path;
			}
			catch (Exception)
			{
				//refresh the object
				wmiObj = null;
				wmiObj = WmiHelper.GetObject(path, null, serverName, nsName);
			}

			//call Commit on browse object
			if (browseComponent is  WMIObjectComponent)
			{
				bool res = ((WMIObjectComponent)browseComponent).Commit();
				if (res)
				{
					//disable commit menu  (remove? leave?)
					((ContextMenuItem)sender).Enabled = false;
					IsNewInstance = false;

					//update label
					SetLabel();
					this.GetNodeSite().UpdateLabel();
				}
				else
				{
					//Commit failed, remove this node
					this.GetNodeSite().Remove();
				}
			}

		}
		catch(Exception exc)
		{
			MessageBox.Show(WMISys.GetString("WMISE_Exception", exc.Message, exc.StackTrace));
		}	

	}

	    /// <summary>
        ///      To determine whether this node supports drag and drop.
        /// </summary>
        /// <returns>
        ///      TRUE to indicate ProcessNode supports drag and drop.
        /// </returns>
        public override bool HasDragComponents() {
            return false;	//disable d&d for Beta1
        }
/*
		public override IComponent[] CreateDragComponents(IDesignerHost designerHost) 
		{
			//This is a temporary work around for a bug (in GC?) where cached wmiObj
			//becomes unusable
			try 
			{
				string path = wmiObj.Path_.Path;
			}
			catch (Exception)
			{
				//refresh the object
				wmiObj = null;
				wmiObj = WmiHelper.GetObject(path, null, serverName, nsName);
			}

			Object comp = null;

			
			comp  = new WMIObjectComponent(wmiObj, wmiClassObj);

			return new IComponent[] {(IComponent)comp};
        }
		*/


	/// <summary>
    ///     The object should write the serialization info.
    ///     NOTE: unsaved new instance will not be serialized
    /// </summary>
    public virtual void GetObjectData(SerializationInfo si, StreamingContext context) {

		if (IsNewInstance)
		{
			((WMIObjectComponent)browseComponent).Commit(); 			
		}
		/*
		else
		{
			si.AddValue("path", path);
			si.AddValue("serverName", serverName);
			si.AddValue("nsName", nsName);
			si.AddValue("className", className);			
		}*/
    }	

	void SetLabel()
	{
		//This is a temporary work around for a bug (in GC?) where cached wmiObj
		//becomes unusable
		try 
		{
			string path = wmiObj.Path_.Path;
		}
		catch (Exception)
		{
			//refresh the object
			wmiObj = null;
			wmiObj = WmiHelper.GetObject(path, null, serverName, nsName);
		}

		ISWbemObjectPath wbemPath = wmiObj.Path_;
		if (wbemPath.IsSingleton)
		{
			label = wbemPath.Class;
		}
		else
		{
			//this is not a singleton.  Construct label to consist of comma-separated
			//key property values and caption value.
			bool needCaption = true;
			string keyVals = string.Empty;
			string caption = string.Empty;

			ISWbemPropertySet props = wmiObj.Properties_;
			try
			{
				caption = props.Item("Caption", 0).get_Value().ToString();
			}
			catch (Exception )
			{
				//no "Caption" property
				needCaption = false;
			}

			if (caption == string.Empty)
			{
				needCaption = false;
			}							
			
			IEnumerator enumKeys = ((IEnumerable)wbemPath.Keys).GetEnumerator();
			while (enumKeys.MoveNext())
			{
				string keyval = ((ISWbemNamedValue)enumKeys.Current).get_Value().ToString();
				if (needCaption && (string.Compare(keyval, caption, true) == 0))
				{
					needCaption = false;
				}
				keyVals+= keyval + ",";
							
			}

			if (keyVals != string.Empty)
			{
				//get rid of last character (a comma)
				keyVals = keyVals.Substring(0, keyVals.Length - 1);	
			}			

			if (needCaption)
			{
				label = caption + "(" + keyVals + ")";
			}
			else
			{
				label = keyVals;
			}

			if (label == string.Empty)
			{
				label = className;
			}
		}          
}
/*
        private IDesignerHost GetActiveDesignerHost() {
            IDesignerHost activeHost = null;
            try {
				
                IDesignerEventService des = (IDesignerEventService)(GetNodeSite().GetServiceObject(typeof(IDesignerEventService)));
                if (des != null) {
                    activeHost = des.GetActiveDocument();
                }
            }
            catch (Exception ) {
                //if (Switches.ServerExplorer.TraceVerbose) Debug.WriteLine("CAUGHT EXCEPTOIN: VsServerExplorer::GetActiveDesignerHost() - " + e.ToString());
            }

            return activeHost;
        }

		private Project GetCurrentProject(IDesignerHost host) {

			try
			{

				Project[] aProjs = GetProjects();
				String projNames = "Open project names are: ";
				for (int i = 0;i < aProjs.Length; i++)
				{
					projNames += aProjs[i].FullName + "\n\r";
				}
				MessageBox.Show(projNames);
				
				Type extensibliityServiceType = typeof(IExtensibilityService);
				object extensibilityService = null;
				INodeSite nodeSite = GetNodeSite();
				if (nodeSite != null) {
				    extensibilityService = nodeSite.GetServiceObject(extensibliityServiceType);
				}

				if ((extensibilityService == null || !(extensibilityService is ProjectItem)) && (host != null)) {
				    extensibilityService = host.GetServiceObject(extensibliityServiceType);
					if (extensibilityService != null)
					{
						MessageBox.Show ("got extensibilityService at second try");
					}

				}
				else
				{
					MessageBox.Show ("got extensibilityService at first try");
				}


				//Debug.Assert(extensibilityService != null, "VsServerExplorer::GetCurrentProject() - GetServiceObject(IExtensibilityService) returns null.");
				if (extensibilityService != null && extensibilityService is ProjectItem) {
					MessageBox.Show ("trying to get ProjectItem");
				    return ((ProjectItem) extensibilityService).ContainingProject;
				}
	

		
				return null;
			}
			catch(Exception exc)
			{
				MessageBox.Show(WMISys.GetString("WMISE_Exception", exc.Message, exc.StackTrace));
				return null;
			}
			

        }

		private Project[] GetProjects() 
		{
			System.Diagnostics.Debugger.Break();

            IVsSolution solution = (IVsSolution)GetNodeSite().GetServiceObject(typeof(IVsSolution));
            if (solution == null) {
                MessageBox.Show("**** ERROR: DiscoveryItemNode::GetProjects() - GetServiceObject(IVsSolution) returns null.");
                return null;
            }
			            
            ObjectList list = new ObjectList();
            Guid guid = Guid.Empty;

            IEnumHierarchies heirEnum = solution.GetProjectEnum(1, ref guid);
		
            Microsoft.VisualStudio.Interop.IVsHierarchy[] hier = new Microsoft.VisualStudio.Interop.IVsHierarchy[1];
            int[] ret = new int[1];
            while (true) {
                heirEnum.Next(1, hier, ret);
                if (ret[0] == 0) 
                    break;

                // Get project item from hierarchy by getting VSHPROPID_EXTOBJ property.
                object[] itemObject = new object[1];
                hier[0].GetProperty((int)VsItemIds.Root, __VSHPROPID.VSHPROPID_ExtObject, itemObject);
                
                if (itemObject[0] == null)
				{
					MessageBox.Show("DiscoveryItemNode::GetProjects() - VsHierarchy.GetProperty(ExtObject) return NULL.");
				}
                if (itemObject[0] != null && itemObject[0] is Project) {
                    Project projectObject = (Project) itemObject[0];
                    if (projectObject.Object != null) {
                        if (projectObject.Object is Microsoft.VisualStudio.Interop.VSProject) {
                            list.Add(projectObject);
                        }
                    }
                }
            }

            Project[] projectList = new Project[list.Count];
            // UNDONE - npchow - CopyTo() doesn't work on array of COM objects.
            // list.CopyTo(projectList, 0);
            for (int i = 0; i < list.Count; i++) {
                MessageBox.Show("DiscoveryItemNode::GetProjects() - Before Convert itemObject[0] to Project.");
                projectList[i] = (Project) list[i];
                MessageBox.Show("DiscoveryItemNode::GetProjects() - After Convert itemObject[0] to Project.");
            }

            return projectList;
        }

		public static void AddFileToProject (Project project, string fileName, string fileContent) {

			if (fileName == string.Empty) {
                return;
            }

            if (project == null) {
                throw new ArgumentNullException("project");
            }

			// First, create new file
			//find out project directory:
			String projPath = project.FullName.Substring(project.FullName.IndexOf(project.FileName, 0));

			MessageBox.Show("Project directory is " + projPath);
            //ProjectReferences projectReferences = ((Microsoft.VisualStudio.Interop.VSProject) project.Object).References;
            
        }

		//will be in DesignUtils ???
		private void SetGenerator(ProjectItem fileItem, string generatorName) {
            if (fileItem != null) {
                Properties fileProperties = fileItem.Properties;
                Debug.Assert(fileProperties != null, "SetCodeGeneratorProperty() - ProjectItem properties is NULL.");

                if (fileProperties != null) {
                    Property generatorProperty = fileProperties.Item("CustomTool");
                    Debug.Assert(generatorProperty != null, "SetCodeGeneratorProperty() - ProjectItem's Generator property is NULL.");

                    if (generatorProperty != null) {
                        try {
                            generatorProperty.Value = generatorName;
                        }
                        catch (Exception e) {
                            //if (Switches.ServerExplorer.TraceVerbose) Debug.WriteLine("Set CustomTool property generators an exception: " + e.ToString());
                            throw e;
                        }
                    }
                }
            }
		}


	 public static void AddComponentReferences(Project project, string[] references) {
            if (references == null || references.Length == 0) {
                return;
            }

            if (project == null) {
                throw new ArgumentNullException("project");
            }

            ProjectReferences projectReferences = ((VSProject) project.Object).References;
            for (int i = 0; i < references.Length; i++) {
                try {
                    projectReferences.Add(references[i]);
                }
                catch (Exception e) {
                    Debug.Assert(false, "VsServerExplorer::AddComponentReferences() - ProjectReferences.Add(" + references[i] + " throw Exception: " + e.ToString());
                    if (Switches.ServerExplorer.TraceVerbose) Debug.WriteLine("**** ERROR: VsServerExplorer::AddComponentReferences() - ProjectReferences.Add(" + references[i] + " throw Exception: " + e.ToString());

                    MessageBox.Show(VSDSys.GetString("SE_AddReferenceFail_UnableToAddReference", references[i], e.Message), VSDSys.GetString("SE_MessageBoxTitle_ServerExplorer"));
                }
            }
        }

        

		*/
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vside\servexpl\beta1\wmiobjectcomponent.cs ===
namespace Microsoft.VSDesigner.WMI {
	using System.Runtime.Serialization;
	using System;
	using System.Diagnostics;
	using System.Collections;
	using System.ComponentModel;
	using System.WinForms;
	using WbemScripting;
	using System.Management;

    // <doc>
    // <desc>
    //     This represents the wmi class information for PB
    // </desc>
    // </doc>
	
    public class WMIObjectComponent : Component, ICustomTypeDescriptor {
		private void InitializeComponent ()
		{
		}

		public enum WMISystemProperties
		{
			__CLASS = 0,
			__DYNASTY,
			__DERIVATION,
			__GENUS,
			__NAMESPACE,
			__RELPATH,
			__PATH,
			__SERVER,
			__SUPERCLASS,
			__PROPERTY_COUNT
		}

		const int NUM_OF_SYSTEM_PROPS = 10;
		
		//fields
		protected string CLASS = String.Empty;
		protected string DYNASTY = String.Empty;
		protected object[] DERIVATION = null;
		protected int GENUS = 0;
		protected string NAMESPACE = String.Empty;
		protected string RELPATH = String.Empty;
		protected string PATH = String.Empty;
		protected string SERVER = String.Empty;
		protected string SUPERCLASS = String.Empty;
		protected int PROPERTY_COUNT = 0;

		protected Dictionary SystemPropertyDictionary = null;

		protected ISWbemObject wmiObj = null;
		protected ISWbemObject wmiClassObj = null;

		protected ManagementObject mgmtObj = null;
		protected ManagementObject mgmtClassObj = null;

		private static MemberAttributeCollection emptyMemberAttrCollection = 
			new MemberAttributeCollection(new MemberAttribute[0]);
		private static EventDescriptorCollection emptyEvtDescrCollection = 
			new EventDescriptorCollection(new EventDescriptor[0]);

		private bool IsNewInstance = false;

		// <doc>
		// <desc>
		//     Ctor from SWbemObject
		// </desc>
		// </doc>
		public WMIObjectComponent(ISWbemObject wbemObjIn, ISWbemObject wbemClassObjIn)
		{
			if (wbemObjIn == null)
			{
				throw (new ArgumentNullException("wbemObjIn"));
			}

			wmiObj = wbemObjIn;
			wmiClassObj = wbemClassObjIn;

			SystemPropertyDictionary = new Dictionary(NUM_OF_SYSTEM_PROPS);

			Initialize ();		
		}

		/// <summary>
		/// note that Properties_ on ISWbemObject doesn't return system properties,
		/// so need to reconstruct them:  __SERVER, __PATH, __GENUS are available through
		/// SWbemObjectPath; __DYNASTY, __DERIVATION can be accessed through SWbemObjct.Derivation_
		/// </summary>
		private void Initialize()
		{					
			
			try
			{
				ISWbemObjectPath path = (ISWbemObjectPath)wmiObj.Path_;
				if (path.IsClass)
				{
					GENUS = 1;
				}
				else	//instance
				{
					GENUS = 2;							
					
				}

				
				SystemPropertyDictionary.Add("__GENUS", GENUS);
				
				CLASS = path.Class;
				SystemPropertyDictionary.Add("__CLASS", CLASS);

				NAMESPACE = path.Namespace;
				SystemPropertyDictionary.Add("__NAMESPACE", NAMESPACE);

				PATH = path.Path;
				SystemPropertyDictionary.Add("__PATH", PATH);

				RELPATH = path.RelPath;
				SystemPropertyDictionary.Add("__RELPATH", RELPATH);

				SERVER = path.Server;
				SystemPropertyDictionary.Add("__SERVER", SERVER);
				
				//get PROPERTY_COUNT
				ISWbemPropertySet props = (ISWbemPropertySet) wmiObj.Properties_;
				IEnumerator eProps = ((IEnumerable)props).GetEnumerator();
				while (eProps.MoveNext())
				{
					PROPERTY_COUNT++;
				}
				SystemPropertyDictionary.Add("__PROPERTY_COUNT", PROPERTY_COUNT);


				//get inheritance-related properties
				
				Object[] oaDerivation = (Object[])wmiObj.Derivation_;			
				if (oaDerivation.Length == 0)
				{									
					DYNASTY = CLASS;
				}
				else
				{
					SUPERCLASS = oaDerivation[0].ToString();
					DYNASTY = oaDerivation[oaDerivation.Length - 1].ToString();		
				}				
				
				SystemPropertyDictionary.Add("__SUPERCLASS", SUPERCLASS);
				SystemPropertyDictionary.Add("__DYNASTY", DYNASTY);
	
				DERIVATION = new string[oaDerivation.Length];				
				Array.Copy(oaDerivation, DERIVATION, oaDerivation.Length);	
				SystemPropertyDictionary.Add("__DERIVATION", DERIVATION);

				IsNewInstance = ((GENUS == 2) && (PATH == string.Empty));				
									
			}
			catch(Exception exc)
			{
				MessageBox.Show(WMISys.GetString("WMISE_Exception", exc.Message, exc.StackTrace));
			}		

		}

		/// <summary>
		/// Call when a transacted commit of properties is required (e.g., when saving a new instance)
		/// </summary>
		internal bool Commit() 
		{
			try
			{
		
				/*
				wmiObj.Put_((int)WbemChangeFlagEnum.wbemChangeFlagCreateOrUpdate
							| (int)WbemFlagEnum.wbemFlagUseAmendedQualifiers, 
							null);	*/
				PutOptions putOpts = new PutOptions(null,
													true,	//use amended qualifiers
													PutType.UpdateOrCreate);
	
				mgmtObj.Put(putOpts);
				return true;
			}
			catch (Exception exc)
			{
				MessageBox.Show(WMISys.GetString("WMISE_ObjComp_PutFailed", PATH, exc.Message));
				return false;
			}		
		}



 	/// <summary>
        ///     Retrieves an array of member attributes for the given object.
        /// </summary>
        /// <returns>
        ///     the array of attributes on the class.  
        /// </returns>
        MemberAttributeCollection ICustomTypeDescriptor.GetAttributes() {
            return emptyMemberAttrCollection;	//TODO: return qualifiers here???
        }

        /// <summary>
        ///     Retrieves the class name for this object.  If null is returned,
        ///     the type name is used.
        /// </summary>
        /// <returns>
        ///     The class name for the object, or null if the default will be used.
        /// </returns>
        string ICustomTypeDescriptor.GetClassName() {
            return CLASS;
        }

        /// <summary>
        ///     Retrieves the name for this object.  If null is returned,
        ///     the default is used.
        /// </summary>
        /// <returns>
        ///     The name for the object, or null if the default will be used.
        /// </returns>
        string ICustomTypeDescriptor.GetComponentName() {
            return null;
        }

        /// <summary>
        ///      Retrieves the type converter for this object.
        /// </summary>
        /// <returns>
        ///     A TypeConverter.  If null is returned, the default is used.
        /// </returns>
        TypeConverter ICustomTypeDescriptor.GetConverter() {
            return null;
        }

        /// <summary>
        ///     Retrieves the default event.
        /// </summary>
        /// <returns>
        ///     the default event, or null if there are no
        ///     events
        /// </returns>
        EventDescriptor ICustomTypeDescriptor.GetDefaultEvent() {
            return null;
        }


        /// <summary>
        ///     Retrieves the default property.
        /// </summary>
        /// <returns>
        ///     the default property, or null if there are no
        ///     properties
        /// </returns>
        PropertyDescriptor ICustomTypeDescriptor.GetDefaultProperty() {

			//returns first property
			ISWbemPropertySet props = (ISWbemPropertySet) wmiObj.Properties_;
			IEnumerator eProps = ((IEnumerable)props).GetEnumerator();
			eProps.MoveNext();	

			if (eProps.Current == null)
			{
				return null;
			}

			String defPropName = ((ISWbemProperty)eProps.Current).Name;

			return new WMIPropertyDescriptor(mgmtObj,
											mgmtClassObj,
											wmiObj, 
											wmiClassObj,
											defPropName,
											!IsNewInstance);
        }

        /// <summary>
        ///      Retrieves the an editor for this object.
        /// </summary>
        /// <returns>
        ///     An editor of the requested type, or null.
        /// </returns>
        object ICustomTypeDescriptor.GetEditor(Type editorBaseType) {
            return null;
        }

        /// <summary>
        ///     Retrieves an array of events that the given component instance
        ///     provides.  This may differ from the set of events the class
        ///     provides.  If the component is sited, the site may add or remove
        ///     additional events.
        /// </summary>
        /// <returns>
        ///     an array of events this component surfaces.
        /// </returns>
        EventDescriptorCollection ICustomTypeDescriptor.GetEvents() {
            return emptyEvtDescrCollection;
        }

        /// <summary>
        ///     Retrieves an array of events that the given component instance
        ///     provides.  This may differ from the set of events the class
        ///     provides.  If the component is sited, the site may add or remove
        ///     additional events.  The returned array of events will be
        ///     filtered by the given set of attributes.
        /// </summary>
        /// <param name='attributes'>
        ///     A set of attributes to use as a filter.
        ///
        ///     If a MemberAttribute instance is specified and
        ///     the event does not have an instance of that attribute's
        ///     class, this will still include the event if the
        ///     MemberAttribute is the same as it's Default property.
        /// </param>
        /// <returns>
        ///     an array of events this component surfaces that match
        ///     the given set of attributes..
        /// </returns>
        EventDescriptorCollection ICustomTypeDescriptor.GetEvents(MemberAttribute[] attributes) {
            return emptyEvtDescrCollection;
         }

        /// <summary>
        ///     Retrieves an array of properties that the given component instance
        ///     provides.  This may differ from the set of properties the class
        ///     provides.  If the component is sited, the site may add or remove
        ///     additional properties.
        /// </summary>
        /// <returns>
        ///     an array of properties this component surfaces.
        /// </returns>
        PropertyDescriptorCollection ICustomTypeDescriptor.GetProperties() 
		{
			//NOTE: this re-initializing of mgmtObj and mgmtClassObj is a workaround:
			//apparently, the cached pointers that were created on a different thread
			//don't work: Interop marshalling problems?

			mgmtObj = null;
			mgmtObj = new ManagementObject(wmiObj.Path_.Path);

			mgmtClassObj = null;
			mgmtClassObj = new ManagementObject(wmiClassObj.Path_.Path);

			ISWbemPropertySet props = (ISWbemPropertySet) wmiObj.Properties_;
			IEnumerator eProps = ((IEnumerable)props).GetEnumerator();

			PropertyDescriptor[] propDescrArray = new PropertyDescriptor[((ISWbemPropertySet)props).Count + NUM_OF_SYSTEM_PROPS];
			if (propDescrArray.Length != 0)
			{
				int counter = 0;
				while (eProps.MoveNext())
				{
					ISWbemProperty curProp = (ISWbemProperty)eProps.Current;
					
					if (GENUS== 2)
					{
						//get the property on the class object: to get to "Values" qualifier
						curProp = wmiClassObj.Properties_.Item(curProp.Name, 0);
					}

					/*
					if (WmiHelper.IsValueMap(curProp))
					{
						//MessageBox.Show("Value map property " + ((ISWbemProperty)eProps.Current).Name);
						propDescrArray[counter++] = new WMIEnumPropertyDescriptor(mgmtObj,
																				mgmtClassObj,
																				wmiObj,
																				wmiClassObj,
																				curProp.Name,
																				!IsNewInstance);										

					}
					else
					*/
					{
						propDescrArray[counter++] = new WMIPropertyDescriptor(	mgmtObj,
																				mgmtClassObj,
																				wmiObj,
																				wmiClassObj,
																				curProp.Name,
																				!IsNewInstance);										


					}
				}

				//add system properties
				IDictionaryEnumerator enumSys = (IDictionaryEnumerator)((IEnumerable)SystemPropertyDictionary).GetEnumerator();

				while (enumSys.MoveNext())
				{
					propDescrArray[counter++] = new WMISystemPropertyDescriptor(wmiObj, 
																		enumSys.Key.ToString(),
																		enumSys.Value);										
				}				
				
			}

			return (new PropertyDescriptorCollection (propDescrArray ));

		}

        /// <summary>
        ///     Retrieves an array of properties that the given component instance
        ///     provides.  This may differ from the set of properties the class
        ///     provides.  If the component is sited, the site may add or remove
        ///     additional properties.  The returned array of properties will be
        ///     filtered by the given set of attributes.
        /// </summary>
        /// <param name='attributes'>
        ///     A set of attributes to use as a filter.
        ///
        ///     If a MemberAttribute instance is specified and
        ///     the property does not have an instance of that attribute's
        ///     class, this will still include the property if the
        ///     MemberAttribute is the same as it's Default property.
        /// </param>
        /// <returns>
        ///     an array of properties this component surfaces that match
        ///     the given set of attributes..
        /// </returns>
        PropertyDescriptorCollection ICustomTypeDescriptor.GetProperties(MemberAttribute[] attributes) {
            return ((ICustomTypeDescriptor)this).GetProperties();
        }

		

        /// <summary>
        ///     Retrieves the object that directly depends on this value being edited.  This is
        ///     generally the object that is required for the PropertyDescriptor's GetValue and SetValue
        ///     methods.  If 'null' is passed for the PropertyDescriptor, the ICustomComponent
        ///     descripotor implemementation should return the default object, that is the main
        ///     object that exposes the properties and attributes,
        /// </summary>
        /// <param name='pd'>
        ///    The PropertyDescriptor to find the owner for.  This call should return an object
        ///    such that the call "pd.GetValue(GetPropertyOwner(pd));" will generally succeed.
        ///    If 'null' is passed for pd, the main object that owns the properties and attributes
        ///    should be returned.
        /// </param>
        /// <returns>
        ///     valueOwner
        /// </returns>
        object ICustomTypeDescriptor.GetPropertyOwner(PropertyDescriptor pd) {
            return this;
        }

	
	
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vside\servexpl\beta1\wmipropertydescriptor.cs ===
//------------------------------------------------------------------------------
/// <copyright from='1997' to='2001' company='Microsoft Corporation'>           
///    Copyright (c) Microsoft Corporation. All Rights Reserved.                
///    Information Contained Herein is Proprietary and Confidential.            
/// </copyright>                                                                
//------------------------------------------------------------------------------


namespace Microsoft.VSDesigner.WMI {
	using System.Diagnostics;
	
	using System;
	using System.Collections;
	using System.ComponentModel;
	using System.Reflection;
	using System.WinForms;
	using WbemScripting;
	using System.Management;

    // <doc>
    // <desc>
    //     This represents the wmi class information for PB
    // </desc>
    // </doc>
	
	public class WMIPropertyDescriptor :  PropertyDescriptor {
		
		//fields

		protected string propName = String.Empty;

		protected ISWbemObject wmiObj = null;
		protected ISWbemObject wmiClassObj = null;
		protected ISWbemProperty prop = null;
		protected ISWbemProperty classProp = null;	//this one has description

		protected ManagementObject mgmtObj = null;
		protected ManagementObject mgmtClassObj = null;
		protected Property mgmtProp = null;
		protected Property mgmtClassProp = null;

		//if wmiObj is a class, genus = 1, if wmiObj is an instance, it's 2
		protected int genus = 1;	
		
		//CommitImmediately variable determines whether the object is saved 
		//each time SetValue() is invoked on the property.
		//For certain scenarios, we may want to call Commit() explicitly after 
		//all the properties have been set
		protected internal bool CommitImmediately = true;

		protected Object initialValue = null;

				
		// <doc>
		// <desc>
		//     Ctor from WMIPropertyDescriptor
		// </desc>
		// </doc>
		internal WMIPropertyDescriptor(	ManagementObject mgmtObjIn,
										ManagementObject mgmtClassObjIn,
										ISWbemObject wbemObjIn,
										ISWbemObject wmiClassObjIn,
										String propNameIn,
										bool commitImmediately)
				:base(propNameIn, null)
		{
			if (wbemObjIn == null)
			{
				throw (new ArgumentNullException("wbemObjIn"));
			}

			if ( propNameIn == string.Empty)
			{
				throw  (new ArgumentNullException("propNameIn"));
			}


			wmiObj = wbemObjIn;
			wmiClassObj = wmiClassObjIn;
			mgmtObj = mgmtObjIn;
			mgmtClassObj = mgmtClassObjIn;
			propName = propNameIn;

			CommitImmediately = commitImmediately;

			Initialize (wbemObjIn);		
		}

		
		
		private void Initialize(ISWbemObject wbemObj)
		{					
			
			try
			{
				ISWbemObjectPath path = (ISWbemObjectPath)wbemObj.Path_;
											
				//get the property
				ISWbemPropertySet props = (ISWbemPropertySet) wbemObj.Properties_;
				prop = props.Item(propName, 0);	
							
				if (path.IsClass)
				{
					genus = 1;
					classProp = prop;
				}
				else	//instance
				{
					genus = 2;
					classProp = ((ISWbemPropertySet)wmiClassObj.Properties_).Item(propName, 0);
				}

			
				mgmtProp = mgmtObj.Properties[propName];
				mgmtClassProp = mgmtClassObj.Properties[propName];

			}
			catch(Exception exc)
			{
				MessageBox.Show(WMISys.GetString("WMISE_Exception", exc.Message, exc.StackTrace));
			}		

		}

		
		public  String Category  
		{
			override get
			{
				if (WmiHelper.IsKeyProperty(prop))
				{
					return "Key";
				}
				else
				{
					return "Local";
				}
			}
		}

		public String Description  
		{
			override get
			{	
				
				return WmiHelper.GetPropertyDescription(propName, wmiClassObj);					
				
			}
		}

		public  Boolean IsBrowsable  
		{
			override get
			{
				return true;
			}
		}

		public TypeConverter Converter 
		{
			override get
			{
				
				if (prop.IsArray)
				{
					return new WMIArrayConverter(wmiObj, propName);
				}	
					
				if (prop.CIMType == WbemCimtypeEnum.wbemCimtypeUint16)
				{
					return new UInt16Converter();
				}
				
				if (prop.CIMType == WbemCimtypeEnum.wbemCimtypeUint32)
				{
					return new UInt32Converter();
				}

				if (prop.CIMType == WbemCimtypeEnum.wbemCimtypeUint64)
				{
					return new UInt64Converter();
				}

				if (prop.CIMType == WbemCimtypeEnum.wbemCimtypeSint8)
				{
					return new SByteConverter();
				}
				
				return base.Converter;			
				
				
			}
		}
		public  Boolean IsReadOnly 
		{
			override get
			{
				
				if (!CommitImmediately)	//this is a new instance or an object that requires transacted commit
				{
					return false;	//every property is writeable if this is a new instance
				}
				else
				{
					bool bIsWriteable = WmiHelper.IsPropertyWriteable(wmiClassObj, classProp);
					return !bIsWriteable;
				}
			}
		}

		public  Boolean IsRealProperty
		{
			override get
			{
				return false;	
			}
		}
		public  String Name
		{
			override get
			{				
				return propName;
			}
		}
			
		public  Type ComponentType  
		{
			override get
			{
				return typeof (WMIObjectComponent);
			}
		}

		
		public Type PropertyType {
		    override get {

				return CIMTypeMapper.ToType(mgmtProp.Type, mgmtProp.IsArray, mgmtProp);
				
			}
		}

				/*

				//Report the type of the actual property value.
				//This is important for numeric properties, where
				//CIM Type is different than the type of value (automation layer problem).

				Object val = prop.get_Value();

				if (val.GetType() != typeof(System.DBNull) && prop.CIMType != WbemCimtypeEnum.wbemCimtypeDatetime )
				{
					return val.GetType();
				}
				else
				{					
					return CIMTypeMapper.ToType(prop.CIMType, prop.IsArray, prop);
				}
				*/

		

		public override void ResetValue (Object component)  
		{
			try
			{
				/*
				Object defValue = wmiClassObj.Properties_.Item(propName, 0).get_Value();
				prop.set_Value(ref defValue);
				if (CommitImmediately)
				{
					wmiObj.Put_((int)WbemChangeFlagEnum.wbemChangeFlagCreateOrUpdate
								| (int)WbemFlagEnum.wbemFlagUseAmendedQualifiers, 
								null);
				}*/

				mgmtProp.Value = mgmtClassProp.Value;
				if (CommitImmediately)
				{
					PutOptions putOpts = new PutOptions(null,
													true,	//use amended qualifiers
													PutType.UpdateOrCreate);
	
					mgmtObj.Put(putOpts);
				}

			}
			catch (Exception exc)
			{
				throw (exc);
			}			
		}

		public override Boolean ShouldPersistValue (Object component)  
		{
			return true;
		}
	
		
		public override Boolean CanResetValue (Object component)  
		{
			//Cannot reset key property (this would create a new instance)
			if (WmiHelper.IsKeyProperty(prop))
			{
				return false;
			}
			else
			{
				return !IsReadOnly;
			}
						
		}
		
		public override String GetDisplayName ( )  
		{
			return propName;
		}

		public override Object GetValue (Object component)  
		{
			CIMType cimType = mgmtProp.Type;

			if (mgmtProp == null || prop == null)
			{
				return null;
			}

			
			//handle embedded objects and array of embedded objects
			if (cimType == CIMType.Object)
			{
				return null;	//disabled for Beta1: too many problems
				//throw new Exception("Displaying embedded objects is not supported in Beta1");
				
			}
			

			if (mgmtProp.Value == null)
			{
				if (mgmtProp.IsArray)
				{
					return Array.CreateInstance(CIMTypeMapper.ToType(cimType, false, mgmtProp), 0);
				}
				return null;
			}							
			
			//handle datetimes, intervals and arrays of datetimes and intervals
			if (cimType == CIMType.DateTime)			
			{
				if (WmiHelper.IsInterval(mgmtProp))
				{
					if (mgmtProp.IsArray)
					{
						string[] strAr = (string[])mgmtProp.Value;
						TimeSpan[] retAr = new TimeSpan[strAr.Length];
						for (int i = 0; i < strAr.Length; i++)
						{
							retAr[i] = WmiHelper.ToTimeSpan(strAr[i]);
						}
						return retAr;
					}
					else
					{
						return WmiHelper.ToTimeSpan(mgmtProp.Value.ToString());
					}						
				}
				else
				{
					if (mgmtProp.IsArray)
					{
						string[] strAr = (string[])mgmtProp.Value;
						DateTime[] retAr = new DateTime[strAr.Length];
						for (int i = 0; i < strAr.Length; i++)
						{
							retAr[i] = WmiHelper.ToDateTime(strAr[i]);
						}
						return retAr;

					}
					else
					{
						return WmiHelper.ToDateTime(mgmtProp.Value.ToString());
					}
				}
			}

			return mgmtProp.Value;
	} 			
		

		public override void SetValue (Object component, Object val)  
		{     
			try
			{
				
				if (val == null || val == string.Empty || 
					(val.GetType().IsArray && ((Array)val).Length == 0 ))
				{
					mgmtProp.Value = val;
					//Object obj = null;
					//prop.set_Value(ref obj);
				}

				if (val != null && val.GetType().IsArray)
				{
					if (((Array)val).GetValue(0).GetType() == typeof(DateTime))
					{
						Array arDT = (Array)val;	
						string[] strVal = new string[arDT.Length];
						for (int i = 0; i < strVal.Length; i++)
						{
							strVal[i] = WmiHelper.ToDMTFTime((DateTime)arDT.GetValue(i));
						}
						mgmtProp.Value = strVal;
					}
					else if (((Array)val).GetValue(0).GetType() == typeof(TimeSpan))
						{				
							Array arTS = (Array)val;	
							string[] strVal = new string[arTS.Length];
							for (int i = 0; i < strVal.Length; i++)
							{
								strVal[i] = WmiHelper.ToDMTFInterval((TimeSpan)arTS.GetValue(i));
							}
							mgmtProp.Value = strVal;
						}
						else
						{
		
							mgmtProp.Value = (Array)val;						
						}
				}

				if (val != null && !val.GetType().IsArray)
				{
					if (val.GetType() == typeof(DateTime))
					{
						string dmtf = WmiHelper.ToDMTFTime((DateTime)val);
						mgmtProp.Value = dmtf;
					}
					else if (val.GetType() == typeof(TimeSpan))
					{
						string dmtf = WmiHelper.ToDMTFInterval((TimeSpan)val);
						mgmtProp.Value = dmtf;
					}
					else
					{
						mgmtProp.Value = val;						
					}
				}
								
				if (CommitImmediately)
				{
					PutOptions putOpts = new PutOptions(null,
													true,	//use amended qualifiers
													PutType.UpdateOrCreate);
	
					mgmtObj.Put(putOpts);
				}
			}
			catch (Exception exc)
			{
				throw (exc);
			}
		}

		    
        public override bool Equals(object other) 
		{
            if (other is WMIPropertyDescriptor) 
			{
                WMIPropertyDescriptor descriptor = (WMIPropertyDescriptor) other;
                return ((descriptor.propName == propName) &&
						(descriptor.wmiObj.Path_.Path == wmiObj.Path_.Path ));
            }
            return false;
        }
/*
		public MemberAttributeCollection Attributes 
		{
			override get 
			{
				//MemberAttribute[] attrAr = new MemberAttribute[1];
				ArrayList attrAr = new ArrayList(10);
				
				if (prop.IsArray)
				{
					attrAr.Add (new TypeConverterAttribute("WMIArrayConverter"));
					attrAr.Add (new DescriptionAttribute("WMIArrayConverter attribute added"));
				}

				if (prop.CIMType == WbemCimtypeEnum.wbemCimtypeUint16)
				{
					attrAr.Add (new TypeConverterAttribute("UInt16Converter"));
					attrAr.Add (new DescriptionAttribute("UInt16Converter attribute added"));
				}
				
				if (prop.CIMType == WbemCimtypeEnum.wbemCimtypeUint32)
				{
					attrAr.Add (new TypeConverterAttribute("UInt32Converter"));
					attrAr.Add (new DescriptionAttribute("UInt32Converter attribute added"));
				}

				if (prop.CIMType == WbemCimtypeEnum.wbemCimtypeUint64)
				{
					attrAr.Add (new TypeConverterAttribute("UInt64Converter"));
					attrAr.Add (new DescriptionAttribute("UInt64Converter attribute added"));
				}

				
				return new MemberAttributeCollection ((MemberAttribute[])attrAr.ToArray(typeof(MemberAttribute)));
				
			}
		}		
		*/
        
     
    }   
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vside\servexpl\beta1\generator\wmigenerator\basecodegenerator.cs ===
//------------------------------------------------------------------------------
/// <copyright from='1997' to='2001' company='Microsoft Corporation'>           
///    Copyright (c) Microsoft Corporation. All Rights Reserved.                
///    Information Contained Herein is Proprietary and Confidential.            
/// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VSDesigner.CodeGenerator {

    using System.Diagnostics;

    using System;
    using System.IO;
    using System.Runtime.InteropServices;
//    using System.Data;
    using System.ComponentModel;
    using Microsoft.Win32;
    using Microsoft.VisualStudio.Interop;
    using Microsoft.Win32.Interop;

    /// <summary>
    ///     This class exists to be cocreated a in a preprocessor build step.
    ///     At this time we would generate the strongly typed dataSet/datasource objects
    /// </summary>
    public abstract class BaseCodeGenerator : IVsSingleFileGenerator {
        private string codeFileNameSpace = string.Empty;
        private string codeFilePath = string.Empty;

        private IVsGeneratorProgress codeGeneratorProgress;

        // **************************** PROPERTIES ****************************
        public abstract string GetDefaultExtension();

        public string FileNameSpace {
            get {
                return codeFileNameSpace;
            }
        }

        public string InputFilePath {
            get {
                return codeFilePath;
            }
        }

        public IVsGeneratorProgress CodeGeneratorProgress {
            get {
                return codeGeneratorProgress;
            }
        }

        // **************************** METHODS **************************

        // MUST implement this abstract method.
        public abstract byte[] GenerateCode(string inputFileName, string inputFileContent);


        protected virtual void GeneratorErrorCallback(bool warning, int level, string message, int line, int column) {
            IVsGeneratorProgress progress = CodeGeneratorProgress;
            if (progress != null) {
                progress.GeneratorError(warning, level, message, line, column);
            }
        }

		public void Generate(string wszInputFilePath, string bstrInputFileContents, string wszDefaultNamespace, 
                             out int pbstrOutputFileContents, out int pbstrOutputFileContentSize, IVsGeneratorProgress pGenerateProgress) {

            if (bstrInputFileContents == null) {
                throw new ArgumentNullException(bstrInputFileContents);
            }
            codeFilePath = wszInputFilePath;
            codeFileNameSpace = wszDefaultNamespace;
            codeGeneratorProgress = pGenerateProgress;

            byte[] bytes = GenerateCode(wszInputFilePath, bstrInputFileContents);
            if (bytes == null) {
                pbstrOutputFileContents = 0;
                pbstrOutputFileContentSize = 0;
            }
            else {
                pbstrOutputFileContentSize = bytes.Length;
				pbstrOutputFileContents = Marshal.AllocCoTaskMem(pbstrOutputFileContentSize);
				Marshal.Copy(bytes, 0, pbstrOutputFileContents, pbstrOutputFileContentSize);                
            }
        }

		protected byte[] StreamToBytes(Stream stream) {
			if (stream.Length == 0)
                return new byte[] { };
            long position = stream.Position;
            stream.Position = 0;
            byte[] bytes = new byte[(int)stream.Length];
            stream.Read(bytes, 0, bytes.Length);
            stream.Position = position;
            return bytes;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vside\servexpl\beta1\generator\wmigenerator\wmicustomgenerator.cs ===
//------------------------------------------------------------------------------
/// <copyright from='1997' to='2001' company='Microsoft Corporation'>           
///    Copyright (c) Microsoft Corporation. All Rights Reserved.                
///    Information Contained Herein is Proprietary and Confidential.            
/// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VSDesigner.CodeGenerator {

    using System.Diagnostics;

    using System;
    using System.IO;
	using System.Text;
	using System.Management;

    using System.CodeDOM.Compiler;
    using Microsoft.VSDesigner.Interop;
    using Microsoft.VisualStudio.Interop;
    using Microsoft.VisualStudio.Data.CodeGen;

    /// <summary>
    ///     This class exists to be cocreated a in a preprocessor build step.
    ///     At this time we would generate the strongly typed WMI objects
    /// </summary>
    public abstract class WMICodeGenerator : BaseCodeGenerator {

        protected ICodeGenerator CodeGenerator {abstract get;}

		public override byte[] GenerateCode(string inputFileName, string inputFileContent) {

            // Validate parameters.
            if (inputFileContent == null || inputFileContent.Length == 0) {
                string errorMessage = "WMICodeGenerator - Input file content is null or empty.";
                GeneratorErrorCallback(false, 1, errorMessage, 0, 0);
                // Should I throw an exception?
                // throw new ArgumentException(inputFileContent);
                return null;
            }

			//Here parse the input file and get all the necessary info
			
            // Set generator progress to 0 out of 100.
            IVsGeneratorProgress progress = CodeGeneratorProgress;
            if (progress != null) {
                progress.Progress(0, 100);
            }

			StreamWriter writer = new StreamWriter(new MemoryStream(), Encoding.UTF8);
			writer.Write((char) 0xFEFF);

            ICodeGenerator codeGenerator = CodeGenerator;
            if (codeGenerator == null) {
                string errorMessage = "WMICodeGenerator - No code generator available for this language.";
                GeneratorErrorCallback(false, 1, errorMessage, 0, 0);

                Debug.Fail(errorMessage);
                return null;
            }

            try {
				ManagementClassGenerator mcg = new ManagementClassGenerator();
				string language = "CS";
				switch(GetDefaultExtension().ToUpper ())
				{
					case ".VB":
						language = "VB";
						break;
					case ".JScript":
						language = "JS";
						break;
					default:
						language = "CS";
						break;
				}

				mcg.GenerateCode(inputFileContent,codeGenerator,writer,language);
              }
            catch (Exception e) {
                string errorMessage = "Code generator: " + codeGenerator.GetType().Name + " failed.  Exception = " + e.Message;
                GeneratorErrorCallback(false, 1, errorMessage, 0, 0);

                Debug.Fail(errorMessage);
                return null;
            }

            // Set generator progress to 0 out of 100.
            if (progress != null) {
                progress.Progress(100, 100);
            }

			writer.Flush();
			return StreamToBytes(writer.BaseStream);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vside\servexpl\generator\genwmiclass\makefile.inc ===
!if 0
    -------------------------------------------------------------------------------------
        Don't modify... user variables are set in "sources"
    -------------------------------------------------------------------------------------
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vside\servexpl\beta1\wmisystempropertydescriptor.cs ===
//------------------------------------------------------------------------------
/// <copyright from='1997' to='2001' company='Microsoft Corporation'>           
///    Copyright (c) Microsoft Corporation. All Rights Reserved.                
///    Information Contained Herein is Proprietary and Confidential.            
/// </copyright>                                                                
//------------------------------------------------------------------------------


namespace Microsoft.VSDesigner.WMI {

	using System;
	using System.Collections;
	using System.ComponentModel;
	using System.WinForms;
	using WbemScripting;



    // <doc>
    // <desc>
    //     This represents the wmi class information for PB
    // </desc>
    // </doc>
	public class WMISystemPropertyDescriptor :  PropertyDescriptor {
		
		//fields:

		protected string propName = String.Empty;

		protected ISWbemObject wmiObj = null;
		protected ISWbemObject wmiClassObj = null;
		//protected ISWbemProperty prop = null;

		//protected WMIObjectComponent.WMISystemProperties wmiProp = 0;

		//if wmiObj is a class, genus = 1, if wmiObj is an instance, it's 2
		protected int genus = 1;	
		
		protected Object propValue = null;
				
		// <doc>
		// <desc>
		//     Ctor from WMIPropertyDescriptor
		// </desc>
		// </doc>
		internal WMISystemPropertyDescriptor(ISWbemObject wbemObjIn,
											String propNameIn,
											Object propValueIn
											)
					:base(propNameIn, null)
		{
			if (wbemObjIn == null)
			{
				throw (new ArgumentNullException("wbemObjIn"));
			}

			if ( propNameIn == string.Empty)
			{
				throw  (new ArgumentException(WMISys.GetString("WMISE_PropDescr_NoProp"), 
												"propNameIn"));
			}

		

			wmiObj = wbemObjIn;			
			propValue = propValueIn;
			propName = propNameIn;
			
		}	
		
				
		public  String Category  
		{
			override get
			{
				return "System";
				
			}
		}

		public String Description  
		{
			override get
			{
				return string.Empty;

			}
		}

		public  Boolean IsBrowsable  
		{
			override get
			{
				return true;
			}
		}
		public  Boolean IsReadOnly 
		{
			override get
			{
				return true;	
			}
		}

		public  Boolean IsRealProperty
		{
			override get
			{
				return false;	
			}
		}
		public  String Name
		{
			override get
			{				
				return propName;
			}
		}
			
		public  Type ComponentType  
		{
			override get
			{
				return typeof (WMIObjectComponent);
			}
		}


		public Type PropertyType {

		    override get 
			{

				if (propValue.GetType() != typeof(System.DBNull) /*&& prop.CIMType != WbemCimtypeEnum.wbemCimtypeDatetime*/)
				{
					return propValue.GetType();
				}
				else
				{
					if (propName == "__PROPERTY_COUNT" ||	propName == "__GENUS") 
					{
						return  typeof(Int32);
					}
					else 
					{						
						if (propName.ToUpper() == "__DERIVATION")
						{
							return typeof(String[]);						
						}
						else
						{
							return typeof (String);
						}					
					}
				}
			}
		}

		
		public override void ResetValue (Object component)  
		{
		}
		

		public override Boolean ShouldPersistValue (Object component)  
		{
			return false;
		}
	
		
		public override Boolean CanResetValue (Object component)  
		{
			return false;
		}
		
		public override String GetDisplayName ( )  
		{
			return propName;
		}

		public override Object GetValue (Object component)  
		{
			return propValue;
		}

		
		public override void SetValue (Object component, Object value)  
		{     
			
		}
		    
        public override bool Equals(object other) {
            if (other is WMISystemPropertyDescriptor) {
                WMISystemPropertyDescriptor descriptor = (WMISystemPropertyDescriptor) other;
                return ((descriptor.propName == propName) &&
						(descriptor.wmiObj.Path_.Path == wmiObj.Path_.Path ));
            }
            return false;
        }		                    
     
    }   
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vside\servexpl\generator\wmigenerator\makefile.inc ===
!if 0
    -------------------------------------------------------------------------------------
        Don't modify... user variables are set in "sources"
    -------------------------------------------------------------------------------------
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vside\servexpl\beta1\generator\wmigenerator\wmicustomgeneratorcs.cs ===
//------------------------------------------------------------------------------
/// <copyright from='1997' to='2001' company='Microsoft Corporation'>           
///    Copyright (c) Microsoft Corporation. All Rights Reserved.                
///    Information Contained Herein is Proprietary and Confidential.            
/// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VSDesigner.CodeGenerator {

    using System;
    using System.CodeDOM.Compiler;

    /// <summary>
    ///     This class exists to be cocreated a in a preprocessor build step.
    ///     At this time we would generate the strongly typed dataSet/datasource objects
    /// </summary>
    [guid("0538E4B1-DDA8-43cc-85A0-F7DE1A14C769")]
    public class WMICustomGeneratorCS : WMICodeGenerator {

        public override string GetDefaultExtension() {
            return ".cs";
        }

        protected ICodeGenerator CodeGenerator {
            override get {
                return new CSharpCodeGenerator();
            }
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vside\servexpl\beta1\generator\genwmiclass\genwmiclass.cs ===
//#define PAUSE

namespace System.Management
{
using System;
using System.Management;

/// <summary>
///    Summary description for GenWMIClass.
/// </summary>
public class GenWMIClass
{
    public GenWMIClass()
    {
        //
        // TODO: Add Constructor Logic here
        //
    }

	public static int Main(String[] args)
	{
		Console.WriteLine("GenWMIClass : Generate managed code wrapper for a WMI Class.");
		if(args.Length < 2)
		{
			Console.WriteLine("Invalid Arguments !!!");
			return GenWMIClass.ShowUsage();
		}

		String machineName = String.Empty;
		String nameSpace = "root\\CimV2";
		String className = String.Empty;
		String language = "CS";
		String filePath = String.Empty;

		for (int i = 0; i < args.Length; i++)
		{
			if (args[i].ToUpper() == "-L") 
			{
				if ((args[i+1].ToUpper() == "JS") || (args[i+1].ToUpper() == "VB"))
				{
					language = args[i+1];
				}
			}
			else if (args[i].ToUpper() == "-C")
			{
			    className = args[i+1];
			}
			else if (args[i].ToUpper() == "-N")
			{
			    nameSpace = args[i+1];
			}
			else if (args[i].ToUpper() == "-M")
			{
			    machineName = args[i+1];
			}
			else if (args[i].ToUpper() == "-P")
			{
				filePath = args[i+1];
			}
		}
		
		if(className == string.Empty)
		{
			Console.WriteLine("Error!!!!. You should specify the class name.");
			return GenWMIClass.ShowUsage();
		}

		Console.WriteLine("Generating Code for WMI Class {0}...",className);
		try
		{
			ManagementClassGenerator mcg = new ManagementClassGenerator();
			if(mcg.GenerateCode(machineName,nameSpace,className,language,filePath) == true)
			{
				Console.WriteLine("Code Generated Successfully!!!!");
			}
			else
			{
				Console.WriteLine("Code Generation Failed.");
			}
		}
		catch(Exception e)
		{
			Console.WriteLine("Exception Occured!!!! Reason : {0}\n\nStack Trace : \n{1}.",e.Message,e.StackTrace);
		}
#if PAUSE
		Console.WriteLine("Press a Key...!");
		Console.Read();
#endif
		return 0;
	}

	public static int ShowUsage()
	{
		Console.WriteLine("Usage : ");
		Console.WriteLine("GenWMIClass -C WMIClass <-M Machine> <-N Namespace> <-L Language> <-P FilePath>.");
		Console.WriteLine("\n Where ");
		Console.WriteLine("\t NameSpace is the WMI Namespace where the class resides. Defaulted to Root\\CimV2");
		Console.WriteLine("\t Language is the language for which the code should be generated. Defaulted to CS");
		Console.WriteLine("\t\t CS - CSharp");
		Console.WriteLine("\t\t VB - Visual Basic");
		Console.WriteLine("\t\t JS - JavaScript");
		Console.WriteLine("\t FilePath is the output file path. Defaulted to local directory");
		Console.WriteLine("\t Machine is the machine to which WMI should connect to. Defaulted to the local machine");
		return -1;
	}
}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vside\servexpl\beta1\art\wmiclassnode.cs ===
namespace Microsoft.WMI.SDK.VisualStudio {
    using System.Runtime.Serialization;
    using System.Diagnostics;
    using System;
    using System.WinForms;
    using System.Drawing;
    using System.Collections;
    using Microsoft.VSDesigner;
	using Microsoft.VSDesigner.ServerExplorer;
	using Microsoft.WMI.SDK.VisualStudio.EarlyBound;

	using WbemScripting;

    // <doc>
    // <desc>
    //     This represents the wmi classes node under a server node.
    // </desc>
    // </doc>
    [UserContextAttribute("serveritem", "wmiclass", true)]
    public class WMIClassNode : Node, ISerializable  {
        //
        // FIELDS
        //

        static Image icon;
        public static readonly Type parentType = typeof(WMIClassesNode);

        private string label = string.Empty;

		public readonly string path = string.Empty;
		public readonly string pathNoServer = string.Empty;
		private string serverName = string.Empty;
		private string nsName = string.Empty;
		private string className = string.Empty;

		public readonly ISWbemObject wmiObj = null;
		private ISWbemServices wbemServices = null;

        //
        // CONSTRUCTORS
        //

        // <doc>
        // <desc>
        //     Main constructor.
		//     Parameters: 
		//	string server (in, machine name)
		//	string pathIn (in, WMI path without the server name , e.g. "root\default:MyClass")
        // </desc>
        // </doc>
        public WMIClassNode(string pathIn) {
			try
			{						
				path = pathIn;

				//parse the path to get server, namespace and class name
				Int32 separ = path.IndexOf ("\\", 2 );
				if (separ == -1)
				{
					//invalid path
					throw (new Exception("Invalid argument"));					
				}

				serverName = path.Substring(2, separ - 2);
				pathNoServer = path.Substring(separ + 1, path.Length - separ - 1);
			
				
				//split pathNoServer into namespace and classname parts (':' is the separator)
				Int32 colon = pathNoServer.IndexOf(':', 0);
				if (colon == -1)
				{
					//invalid path
					throw (new Exception("Invalid argument"));					
				}			
				nsName = pathNoServer.Substring(0,colon);
				className = pathNoServer.Substring(colon + 1, pathNoServer.Length - colon - 1);

				//Get and cache wmiObj
				ISWbemLocator wbemLocator = (ISWbemLocator)(new SWbemLocator());

				wbemServices = wbemLocator.ConnectServer(serverName, 
									nsName, 
									"",	//user: blank defaults to current logged-on user
									"",	//password: blank defaults to current logged-on user
									"",	//locale: blank for current locale
									"",	//authority: NTLM or Kerberos. Blank lets DCOM negotiate.
									0,	//flags: reserved
									null);	//context info: not needed here
				if (wbemServices == null)
				{
					throw new Exception("Could not connect to WMI");
				}
							
				wmiObj = wbemServices.Get (className,
							0,
							//(int)WbemFlagEnum.wbemFlagUseAmendedQualifiers,
							null);
				if (wmiObj == null)
				{
					throw new Exception("Could not get WMI object" + path);
				}				

			}
			catch (Exception exc)
			{
				MessageBox.Show("Exception: " + exc.Message + "\n\rTrace: " + exc.StackTrace);
				throw (exc);
			}
		}

		
		/// <summary>
        ///     The object retrieves its serialization info.
        /// </summary>
        public WMIClassNode(SerializationInfo info, StreamingContext context) {
            
			try 
			{
				path = info.GetString("Path");

				//parse the path to get server, namespace and class name
				Int32 separ = path.IndexOf ("\\", 2);
				if (separ == -1)
				{
					//invalid path
					throw (new Exception("Invalid argument"));					
				}

				serverName = path.Substring(2, separ - 2);
				pathNoServer = path.Substring(separ + 1, path.Length - separ - 1);
						
				//split pathNoServer into namespace and classname parts (':' is the separator)
				Int32 colon = pathNoServer.IndexOf(':', 0);
				if (colon == -1)
				{
					//invalid path
					throw (new Exception("Invalid argument"));					
				}			
				nsName = pathNoServer.Substring(0,colon);
				className = pathNoServer.Substring(colon + 1, pathNoServer.Length - colon - 1);

				//Get and cache wmiObj
				ISWbemLocator wbemLocator = (ISWbemLocator)(new SWbemLocator());


				wbemServices = wbemLocator.ConnectServer(serverName, 
									nsName, 
									"",	//user: blank defaults to current logged-on user
									"",	//password: blank defaults to current logged-on user
									"",	//locale: blank for current locale
									"",	//authority: NTLM or Kerberos. Blank lets DCOM negotiate.
									0,	//flags: reserved
									null);	//context info: not needed here
				if (wbemServices == null)
				{
					throw new Exception("Could not connect to WMI");
				}
							
				wmiObj = wbemServices.Get (className,
							0,
							//(int)WbemFlagEnum.wbemFlagUseAmendedQualifiers,
							null);
				if (wmiObj == null)
				{
					throw new Exception("Could not get WMI object" + path);
				}				

                        
            }
            catch (Exception exc) {
				MessageBox.Show("Exception: " + exc.Message + "\n\rTrace: " + exc.StackTrace);
				throw (exc);
            }
        }

		

        //
        // PROPERTIES
        //

        // <doc>
        // <desc>
        //     Returns icon for this node.
        // </desc>
        // </doc>
		
        public Image Icon {
            override get {
		//TODO: display different icons for associations, abstract, etc.
                if (icon == null)
					icon = new Bitmap (Image.FromFile("c:\\lab\\SE Nodes\\art\\class.bmp"));
					//icon = new Icon("c:\\lab\\SE Nodes\\art\\Object Viewer.ico"); //(GetType(), "Process.ico");
                //return icon.ToBitmap();
				return icon;

            }
        }

	
	/// <summary>
	/// Context menu for a class object contains static method names
	/// </summary>
	public override ContextMenuItem[] GetContextMenuItems() {

		ISWbemMethodSet methods = wmiObj.Methods_;
		
		ContextMenuItem[] theMenu = new ContextMenuItem[methods.Count + 2];
		
		//theMenu[0] = new ContextMenuItem("&View All Instances...", new EventHandler(OnExpandAll));
		//theMenu[1] = new ContextMenuItem("&Filter Instances...", new EventHandler(OnAddInstanceFilter));

		int i = 0;	//2;

		//TODO: retrieve static methods for the class and add them to context menu
		IEnumerator methEnum = ((IEnumerable)methods).GetEnumerator();		

		
		while (methEnum.MoveNext())
		{
			ISWbemMethod meth = (ISWbemMethod)methEnum.Current;
			
			if (WmiHelper.IsStaticMethod(meth) && WmiHelper.IsImplementedMethod(meth))
			{							
				
				//add method name to context menu
				theMenu[i++] = new ContextMenuItem(meth.Name + "...", //TODO: hotkey???
								new EventHandler(ExecuteMethod));				
			}
		}

		
            	return theMenu;
        }



	public override bool CanDeleteNode()
	{
		return true;
	}

	public override bool ConfirmDeletingNode()
	{
		return true;
	}

/*
	/// <summary>
        ///      The method returns a NewChildNode that, when double clicked, triggers add filter.
        /// </summary>
        /// <returns>
        ///      A NewChildNode, a child node, that supports add server node.
        /// </returns>
		 public override Node GetNewChildNode() {
            if (newChildNode == null) {
                newChildNode = new NewChildNode();
				newChildNode.Label = "<Explore WMI Class...>"; //VSDSys.GetString("SE_NewServerNodeLabel_AddServer");
                newChildNode.WhenToSave = WhenToSaveCondition.Always;
                //newChildNode.SetIconImage(new Icon(GetType(), "c:\\lab\\SE Nodes\\art\\EventsNew.ico").ToBitmap());
				newChildNode.SetIconImage(new Icon("c:\\lab\\SE Nodes\\art\\ObjectViewerNew.ico").ToBitmap());
                newChildNode.DoubleClickHandler = new EventHandler(OnSelectWMIClass);
            }
            return newChildNode;
        }
*/
        // <doc>
        // <desc>
        //     Returns label constant for this node.
        // </desc>
        // </doc>
        public string Label {
            override get {
                if (label == null || label.Length == 0) {
                    label = className; //VSSys.GetString("SE_ProcessesLabel_Processes");
                }
                return label;
            }
            override set {
            }
        }

        //
        // METHODS
        //

        // <doc>
        // <desc>
        //     Create instance nodes under this node.
        // </desc>
        // </doc>
        public override Node[] CreateChildren() {
	
		try
		{
			//TODO: enumerate instances
/*
			
			ISWbemObjectSet instSet = null;
			try
			{
				instSet = (ISWbemObjectSet)wmiObj.Instances_((int)WbemFlagEnum.wbemFlagReturnImmediately, 
										null);
			}
			catch(Exception exc)
			{
				MessageBox.Show("Exception: " + exc.Message + "\n\rTrace: " + exc.StackTrace);	
				
				
			}
*/
			
			int flags = (int)(WbemFlagEnum.wbemFlagReturnImmediately); // | WbemFlagEnum.wbemFlagForwardOnly);

			//IEnumerator enumInst = ((IEnumerable)(ISWbemObjectSet)wmiObj.Instances_(flags,null)).GetEnumerator();
		
		        ISWbemObjectSet objs = wbemServices.InstancesOf(className, flags, null);
			//	MessageBox.Show("Number of instances is " + objs.Count);
			IEnumerator enumInst = ((IEnumerable)objs).GetEnumerator();

			//	WMIInstanceNode[] nodes = new WMIInstanceNode[objs.Count];
			Node[] nodes = new Node[objs.Count];	
			
			UInt32 i = 0;	
			
			while(enumInst.MoveNext())
			{
				nodes[i++] = new WMIInstanceNode((ISWbemObject)enumInst.Current);									
			}			

			return nodes;
				
		}
		catch(Exception exc)
		{
			MessageBox.Show("Exception: " + exc.Message + "\n\rTrace: " + exc.StackTrace);
			return null;
		}
			
        }

        // <doc>
        // <desc>
        //     This node is a singleton.
        // </desc>
        // </doc>
        public override int CompareUnique(Node node) {
            return 0;
        }


	private void OnExpandAll(object sender, EventArgs e) {
 			
		try 
		{
			//TODO: this needs to be changed to do something more meaningful
			GetNodeSite().Expand();
			
		}
		catch(Exception exc)
		{
			MessageBox.Show("Exception: " + exc.Message + "\n\rTrace: " + exc.StackTrace);
		}	
        }

	private void OnAddInstanceFilter(object sender, EventArgs e) {
 			
		try 
		{
			MessageBox.Show("Not implemented yet");
		}
		catch(Exception exc)
		{
			MessageBox.Show("Exception: " + exc.Message + "\n\rTrace: " + exc.StackTrace);
		}	

    }

	/// <summary>
	/// Get component to be displayed in PB window
	/// </summary>
	public override Object GetBrowseComponent() 
	{	
		if (pathNoServer.ToLower() == "root\\cimv2:win32_share")
		{			
			return new Win32_Share (wmiObj);
		}
		else
			return new WMIObjectComponent(wmiObj);
    }


	/// <summary>
	/// Execute static method against WMI class
	/// </summary>
	/// <param name="sender"> </param>
	/// <param name="e"> </param>
	private void ExecuteMethod(object sender, EventArgs e)
	{
		try 
		{
			//trim the 3 dots off the end of the context menu text to get method name
			String methName = ((ContextMenuItem)sender).Text.Substring(0, ((ContextMenuItem)sender).Text.Length - 3);
			MessageBox.Show("Should execute method " + methName);

			//TODO: bring up UI to edit parameters
		}
		catch(Exception exc)
		{
			MessageBox.Show("Exception: " + exc.Message + "\n\rTrace: " + exc.StackTrace);
		}	

	}

	/// <summary>
    ///     The object should write the serialization info.
    /// </summary>
    public virtual void GetObjectData(SerializationInfo si, StreamingContext context) {
		si.AddValue("Path", path);
    }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\setup\bin\wbemupgradedll\dbarry.h ===
/*++

Copyright (C) 1996-2000 Microsoft Corporation

Module Name:

    DBARRAY.H

Abstract:

    CDbArray implementation.

	These objects can operate from any allocator, and be constructed
	on arbitrary memory blocks.

History:

	11-Apr-96   a-raymcc    Created.
	06-Dec-96   raymcc      Updated to use offset-based addresses.
	19-Apr-00	a-shawnb	Stole and butchered for use in wbemupgradedll

--*/

#ifndef _DBARRY_H_
#define _DBARRY_H_

class CDbArray_PTR;

class CDbArray
{
    int     m_nSize;            // apparent size
    int     m_nExtent;          // de facto size
    int     m_nGrowBy;
    void**  m_pArray;

private:
    CDbArray(
        IN int nInitialSize = 32,
        IN int nGrowBy = 32
        ) {}

	~CDbArray() {}
public:

};

class CDbArray_PTR : public Offset_Ptr<CDbArray>
{
public:
	CDbArray_PTR& operator =(CDbArray *val) { SetValue(val); return *this; }
	CDbArray_PTR& operator =(CDbArray_PTR &val) { SetValue(val); return *this; }
	CDbArray_PTR(CDbArray *val) { SetValue(val); }
	CDbArray_PTR() { }
};

#endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vside\servexpl\generator\wmigenerator\wmicustomgeneratorcs.cs ===
//------------------------------------------------------------------------------
/// <copyright from='1997' to='2001' company='Microsoft Corporation'>           
///    Copyright (c) Microsoft Corporation. All Rights Reserved.                
///    Information Contained Herein is Proprietary and Confidential.            
/// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VSDesigner.CodeGenerator {

    using System;
    using System.CodeDom.Compiler;
	using System.Runtime.InteropServices;
	using Microsoft.CSharp;

    /// <summary>
    ///     This class exists to be cocreated a in a preprocessor build step.
    ///     At this time we would generate the strongly typed dataSet/datasource objects
    /// </summary>
    [Guid("0538E4B1-DDA8-43cc-85A0-F7DE1A14C769")]
    public class WMICustomGeneratorCS : WMICodeGenerator {

        public override string GetDefaultExtension() {
            return ".cs";
        }

        protected override ICodeGenerator CodeGenerator {
             get {
                return (new CSharpCodeProvider()).CreateGenerator();
            }
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vside\servexpl\generator\wmigenerator\wmicustomgenerator.cs ===
//------------------------------------------------------------------------------
/// <copyright from='1997' to='2001' company='Microsoft Corporation'>           
///    Copyright (c) Microsoft Corporation. All Rights Reserved.                
///    Information Contained Herein is Proprietary and Confidential.            
/// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VSDesigner.CodeGenerator {

    using System.Diagnostics;

    using System;
    using System.IO;
	using System.Text;
	using System.Management;

    using System.CodeDom.Compiler;
    using Microsoft.VSDesigner.Interop;
    //using Microsoft.VisualStudio.Interop;
    //using Microsoft.VisualStudio.Data.CodeGen;

    /// <summary>
    ///     This class exists to be cocreated a in a preprocessor build step.
    ///     At this time we would generate the strongly typed WMI objects
    /// </summary>
    public abstract class WMICodeGenerator : BaseCodeGenerator {

        protected abstract ICodeGenerator CodeGenerator { get;}

		public override byte[] GenerateCode(string inputFileName, string inputFileContent) {

            // Validate parameters.
            if (inputFileContent == null || inputFileContent.Length == 0) {
                string errorMessage = "WMICodeGenerator - Input file content is null or empty.";
                GeneratorErrorCallback(false, 1, errorMessage, 0, 0);
                // Should I throw an exception?
                // throw new ArgumentException(inputFileContent);
                return null;
            }

			//Here parse the input file and get all the necessary info
			
            // Set generator progress to 0 out of 100.
            IVsGeneratorProgress progress = CodeGeneratorProgress;
            if (progress != null) {
                progress.Progress(0, 100);
            }

			StreamWriter writer = new StreamWriter(new MemoryStream(), Encoding.UTF8);
			//writer.Write((char) 0xFEFF);

			/*
			tw = new StreamWriter(new FileStream (genFileName,
				FileMode.Create));
				*/

            ICodeGenerator codeGenerator = CodeGenerator;
            if (codeGenerator == null) {
                string errorMessage = "WMICodeGenerator - No code generator available for this language.";
                GeneratorErrorCallback(false, 1, errorMessage, 0, 0);

                Debug.Fail(errorMessage);
                return null;
            }

            try {
				ManagementClassGenerator mcg = new ManagementClassGenerator();
				string language = "CS";
				switch(GetDefaultExtension().ToUpper ())
				{
					case ".VB":
						language = "VB";
						break;
					case ".JScript":
						language = "JS";
						break;
					default:
						language = "CS";
						break;
				}

				if (!mcg.GenerateCode(inputFileContent,codeGenerator,writer,language))
				{
                    throw new Exception("GenerateCode() failed");
				}
              }
            catch (Exception e) {
                string errorMessage = "Code generator: " + codeGenerator.GetType().Name + " failed.  Exception = " + e.Message;
                GeneratorErrorCallback(false, 1, errorMessage, 0, 0);

                Debug.Fail(errorMessage);
                return null;
            }

            // Set generator progress to 0 out of 100.
            if (progress != null) {
                progress.Progress(100, 100);
            }

			writer.Flush();
			return StreamToBytes(writer.BaseStream);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\setup\bin\wbemupgradedll\dbavl.h ===
/*++

Copyright (C) 1996-2000 Microsoft Corporation

Module Name:

    DBAVL.CPP

Abstract:

	Class CDbAvlTree

History:

	raymcc      20-May-96   Created.
	raymcc      06-Dec-96   Updated to use offset-based MMF Arena.
	a-shawnb	19-Apr-00	Stole and butchered for use in wbemupgradedll

--*/
#ifndef _DBAVL_H_
#define _DBAVL_H_

struct AVLNode;
class CDbAvlTree;

class AVLNode_PTR : public Offset_Ptr<AVLNode>
{
public:
	AVLNode_PTR& operator =(AVLNode *val) { SetValue(val); return *this; }
	AVLNode_PTR& operator =(AVLNode_PTR &val) { SetValue(val); return *this; }
	AVLNode_PTR(AVLNode *val) { SetValue(val); }
	AVLNode_PTR() { }
};

class CDbAvlTree_PTR : public Offset_Ptr<CDbAvlTree>
{
public:
	CDbAvlTree_PTR& operator =(CDbAvlTree *val) { SetValue(val); return *this; }
	CDbAvlTree_PTR& operator =(CDbAvlTree_PTR &val) { SetValue(val); return *this; }
	CDbAvlTree_PTR(CDbAvlTree *val) { SetValue(val); }
	CDbAvlTree_PTR() { }
};


struct AVLNode
{
    int nBal;
    INT_PTR nKey;
    DWORD_PTR poData;
    AVLNode *poLeft;
    AVLNode *poRight;
	AVLNode *poIterLeft;
	AVLNode *poIterRight;

	//Initialise the object
	static int Initialize(AVLNode_PTR poThis) {return 0;}

	//Deinitialise the object and delete everything in the object
	static int Deinitialize(AVLNode_PTR poThis) {return 0;}

	//Allocate memory in the MMF arena
	static AVLNode *AllocateObject() { return (AVLNode*)g_pDbArena->Alloc(sizeof(AVLNode)); }

	//Deallocate memory from the MMF arena
	static int DeallocateObject(AVLNode_PTR poThis) { return g_pDbArena->Free(poThis.GetDWORD_PTR()); }
};

typedef AVLNode *PAVLNode;

class CDbAvlTree
{
    friend class CDbAvlTreeIterator;

    AVLNode *m_poRoot;
	AVLNode *m_poIterStart;
	AVLNode *m_poIterEnd;
    int      m_nKeyType;
    int      m_nNodeCount;

private:
    CDbAvlTree(int nKeyType){}
	~CDbAvlTree(){}

public:

};

#endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\setup\bin\wbemupgradedll\export.cpp ===
/*++

Copyright (C) 1996-2000 Microsoft Corporation

Module Name:

    EXPORT.CPP

Abstract:

    Exporting

History:

--*/

#include "precomp.h"
#include "Time.h"
#include "WbemCli.h"
#include "DbRep.h"
#include "Export.h"
#include "WbemUtil.h"


void CRepExporter::DumpInstanceString(INSTDEF* pInstDef, const wchar_t *wszKey, const wchar_t *pszClass)
{
    if (wszKey)
    {
        //Dump an instance block header
        DWORD dwSize = 0;
        DWORD adwBuffer[2];
        adwBuffer[0] = REP_EXPORT_INST_STR_TAG;
        adwBuffer[1] = (wcslen(wszKey) + 1) * sizeof (wchar_t);
        if ((WriteFile(g_hFile, adwBuffer, 8, &dwSize, NULL) == 0) || (dwSize != 8))
        {
            DEBUGTRACE((LOG_WBEMCORE, "Failed to write instance %S for class %S header.\n", wszKey, pszClass));
            throw FAILURE_WRITE;
        }
        if ((WriteFile(g_hFile, wszKey, (wcslen(wszKey) + 1) * sizeof (wchar_t), &dwSize, NULL) == 0) || (dwSize != (wcslen(wszKey) + 1) * sizeof (wchar_t)))
        {
            DEBUGTRACE((LOG_WBEMCORE, "Failed to write instance %S for class %S.\n", wszKey, pszClass));
            throw FAILURE_WRITE;
        }
    }

    {
        //Dump the block
        DWORD dwSize = 0;
        DWORD *pdwObjectStream = Fixup((DWORD*)pInstDef->m_poObjectStream);
        DWORD dwCurSize = *(pdwObjectStream - 1);
        dwCurSize -= GetMMFBlockOverhead();
        if ((WriteFile(g_hFile, &dwCurSize, 4, &dwSize, NULL) == 0) || (dwSize != 4))
        {
            if (wszKey)
            {
                DEBUGTRACE((LOG_WBEMCORE, "Failed to write data header of instance %S for class %S.\n", wszKey, pszClass));
            }
            else
            {
                DEBUGTRACE((LOG_WBEMCORE, "Failed to write data header of class definition for class %S.\n", pszClass));
            }
            throw FAILURE_WRITE;
        }
        if ((WriteFile(g_hFile, pdwObjectStream, dwCurSize, &dwSize, NULL) == 0) || (dwSize != dwCurSize))
        {
            if (wszKey)
            {
                DEBUGTRACE((LOG_WBEMCORE, "Failed to write instance %S for class %S.\n", wszKey, pszClass));
            }
            else
            {
                DEBUGTRACE((LOG_WBEMCORE, "Failed to write class definition for class %S.\n", pszClass));
            }
            throw FAILURE_WRITE;
        }
    }
}
void CRepExporter::DumpInstanceInt(INSTDEF* pInstDef, INT_PTR nKey, const wchar_t *pszClass)
{
    {
        //Dump an instance block header
        DWORD dwSize = 0;
        DWORD dwBuffer;
        dwBuffer = REP_EXPORT_INST_INT_TAG;
        if ((WriteFile(g_hFile, &dwBuffer, 4, &dwSize, NULL) == 0) || (dwSize != 8))
        {
            DEBUGTRACE((LOG_WBEMCORE, "Failed to write instance %d for class %S object and header.\n", nKey, pszClass));
            throw FAILURE_WRITE;
        }
        if ((WriteFile(g_hFile, &nKey, sizeof(INT_PTR), &dwSize, NULL) == 0) || (dwSize != 8))
        {
            DEBUGTRACE((LOG_WBEMCORE, "Failed to write instance %d for class %S object and header.\n", nKey, pszClass));
            throw FAILURE_WRITE;
        }
    }
    {
        //Dump the block
        DWORD dwSize = 0;
        DWORD *pObjectStream = Fixup((DWORD*)pInstDef->m_poObjectStream);
        DWORD dwCurSize = *(pObjectStream - 1);
        dwCurSize -= GetMMFBlockOverhead();
        if ((WriteFile(g_hFile, &dwCurSize, 4, &dwSize, NULL) == 0) || (dwSize != 4))
        {
            DEBUGTRACE((LOG_WBEMCORE, "Failed to write data header of instance %%d for class %S.\n", nKey, pszClass));
            throw FAILURE_WRITE;
        }
        if ((WriteFile(g_hFile, pObjectStream, dwCurSize, &dwSize, NULL) == 0) || (dwSize != dwCurSize))
        {
            DEBUGTRACE((LOG_WBEMCORE, "Failed to write instance %d for class %S.\n", nKey, pszClass));
            throw FAILURE_WRITE;
        }
    }
}
void CRepExporter::IterateKeyTree(const wchar_t *wszClassName, CLASSDEF *pOwningClass, AVLNode *pInstNode, BOOL bStringKey)
{
    if (pInstNode->poLeft)
    {
        IterateKeyTree(wszClassName, pOwningClass, Fixup(pInstNode->poLeft), bStringKey);
    }

    //If this is a top-level class then we dump the class, otherwise the class dump will get child classes...
    INSTDEF *pInstDef = Fixup((INSTDEF*)pInstNode->poData);
    if (Fixup(pInstDef->m_poOwningClass) == pOwningClass)
    {
        if (bStringKey)
            DumpInstanceString(pInstDef, Fixup((wchar_t*)pInstNode->nKey), wszClassName);
        else
            DumpInstanceInt(pInstDef, pInstNode->nKey, wszClassName);
    }

    if (pInstNode->poRight)
    {
        IterateKeyTree(wszClassName, pOwningClass, Fixup(pInstNode->poRight), bStringKey);
    }
}

void CRepExporter::DumpClass(CLASSDEF* pClassDef, const wchar_t *wszClassName)
{
    DWORD dwSize = 0;
    DWORD adwBuffer[6];
    adwBuffer[0] = REP_EXPORT_CLASS_TAG;
    adwBuffer[1] = (wcslen(wszClassName) + 1) * sizeof (wchar_t);
    if ((WriteFile(g_hFile, adwBuffer, 8, &dwSize, NULL) == 0) || (dwSize != 8))
    {
        DEBUGTRACE((LOG_WBEMCORE, "Failed to write clas %S header.\n", wszClassName));
        throw FAILURE_WRITE;
    }
    if ((WriteFile(g_hFile, wszClassName, (wcslen(wszClassName) + 1) * sizeof (wchar_t), &dwSize, NULL) == 0) || (dwSize != (wcslen(wszClassName) + 1) * sizeof (wchar_t)))
    {
        DEBUGTRACE((LOG_WBEMCORE, "Failed to write clas %S class name.\n", wszClassName));
        throw FAILURE_WRITE;
    }

    DumpInstanceString(Fixup(pClassDef->m_poClassDef), NULL, wszClassName);

    //Dump the children classes...
    AVLNode *pTreeNode = Fixup((AVLNode*)(((DWORD_PTR*)Fixup(Fixup(pClassDef->m_poOwningNs)->m_poClassTree))[0]));
    IterateClassNodes(pTreeNode, Fixdown(pClassDef));

    //Special cases!  We do not dump instances for the following classes...
    if ((_wcsicmp(wszClassName, L"__CIMOMIdentification") != 0))
    {
        //If we own the key tree, then we need to iterate through this...
        if (pClassDef->m_poKeyTree)
        {
            DWORD_PTR dwTreeNode = (((DWORD*)Fixup(pClassDef->m_poKeyTree))[0]);
            if (dwTreeNode)
            {
                AVLNode *pTreeNode2 = Fixup((AVLNode*)dwTreeNode);
                int keyType = GetAvlTreeNodeType(Fixup(pClassDef->m_poKeyTree));
                IterateKeyTree(wszClassName, pClassDef, pTreeNode2, (keyType == 0x1f));
            }

        }
    }
    adwBuffer[0] = REP_EXPORT_CLASS_END_TAG;
    adwBuffer[1] = REP_EXPORT_END_TAG_SIZE;
    memset(&(adwBuffer[2]), REP_EXPORT_END_TAG_MARKER, REP_EXPORT_END_TAG_SIZE);
    if ((WriteFile(g_hFile, adwBuffer, 24, &dwSize, NULL) == 0) || (dwSize != 24))
    {
        DEBUGTRACE((LOG_WBEMCORE, "Failed to write class %S end marker.\n", wszClassName));
        throw FAILURE_WRITE;
    }
}

void CRepExporter::IterateClassNodes(AVLNode *pClassNode, CLASSDEF *poParentClass)
{
    if (pClassNode->poLeft)
    {
        IterateClassNodes(Fixup((AVLNode *)pClassNode->poLeft), poParentClass);
    }

    //If this is a top-level class then we dump the class, otherwise the class dump will get child classes...
    CLASSDEF *pClassDef = Fixup((CLASSDEF*)pClassNode->poData);
    if (pClassDef->m_poSuperclass == poParentClass)
    {
        DumpClass(pClassDef, Fixup((wchar_t*)pClassNode->nKey));
    }

    if (pClassNode->poRight)
    {
        IterateClassNodes(Fixup((AVLNode *)pClassNode->poRight), poParentClass);
    }
}
void CRepExporter::IterateChildNamespaceTree(AVLNode *pNsNode)
{
    if (pNsNode->poLeft)
    {
        IterateChildNamespaceTree(Fixup((AVLNode *)pNsNode->poLeft));
    }

    //If this is a top-level class then we dump the class, otherwise the class dump will get child classes...
    NSREP *pNsDef = Fixup((NSREP*)pNsNode->poData);
    DumpNamespace(pNsDef);

    if (pNsNode->poRight)
    {
        IterateChildNamespaceTree(Fixup((AVLNode *)pNsNode->poRight));
    }
}

void CRepExporter::IterateChildNamespaces(RepCollection *childNamespaces)
{
    DWORD dwType;
    DWORD dwSize;
    DWORD_PTR dwItems;

    dwType = ((DWORD*)childNamespaces)[0];
    dwSize = ((DWORD*)childNamespaces)[1];
    dwItems = ((DWORD*)childNamespaces)[2];

    if ((dwType == 0) || (dwSize == 0))
        return;
    else if (dwType == 1)
    {
        //This is a pointer to a RepCollectionItem!
        RepCollectionItem *pRepCollectionItem = Fixup((RepCollectionItem*)dwItems);
        DumpNamespace(Fixup((NSREP*)pRepCollectionItem->poItem));
    }
    else if (dwType == 2)
    {
        CDbArray *pDbArray = Fixup((CDbArray*)dwItems);
        RepCollectionItem** apNsRepItem;
        apNsRepItem = Fixup((RepCollectionItem**)(((DWORD_PTR*)pDbArray)[3]));
        for (DWORD i = 0; i != dwSize; i++)
        {
            DumpNamespace(Fixup((NSREP*)(Fixup(apNsRepItem[i])->poItem)));
        }
    }
    else if (dwType == 3)
    {
        //This is a tree
        AVLNode *pTreeNode = Fixup((AVLNode*)(((DWORD_PTR*)Fixup(dwItems))[0]));
        IterateChildNamespaceTree(pTreeNode);
    }
    else
    {
        //this is a bug!
    }
}

void CRepExporter::DumpNamespace(NSREP *pNsRep)
{
    wchar_t *pszCurNs = Fixup(pNsRep->m_poName);

    DWORD dwSize = 0;
    DWORD dwBuffer[6];
    dwBuffer[0] = REP_EXPORT_NAMESPACE_TAG;
    dwBuffer[1] = (wcslen(pszCurNs) + 1) * sizeof(wchar_t);

    if ((WriteFile(g_hFile, dwBuffer, 8, &dwSize, NULL) == 0) || (dwSize != 8))
    {
        DEBUGTRACE((LOG_WBEMCORE, "Failed to write namespace %S header.\n", pszCurNs));
        throw FAILURE_WRITE;
    }
    if ((WriteFile(g_hFile, pszCurNs, (wcslen(pszCurNs) + 1) * sizeof(wchar_t), &dwSize, NULL) == 0) || (dwSize != (wcslen(pszCurNs) + 1) * sizeof(wchar_t)))
    {
        DEBUGTRACE((LOG_WBEMCORE, "Failed to write namespace %S.\n", pszCurNs));
        throw FAILURE_WRITE;
    }

    DumpNamespaceSecurity(pNsRep);

    AVLNode *pTreeNode = Fixup((AVLNode*)(((DWORD_PTR*)Fixup(pNsRep->m_poClassTree))[0]));

    IterateClassNodes(pTreeNode, 0);

    IterateChildNamespaces(Fixup(pNsRep->m_poNamespaces));

    dwBuffer[0] = REP_EXPORT_NAMESPACE_END_TAG;
    dwBuffer[1] = REP_EXPORT_END_TAG_SIZE;
    memset(&(dwBuffer[2]), REP_EXPORT_END_TAG_MARKER, REP_EXPORT_END_TAG_SIZE);
    if ((WriteFile(g_hFile, dwBuffer, 24, &dwSize, NULL) == 0) || (dwSize != 24))
    {
        DEBUGTRACE((LOG_WBEMCORE, "Failed to write namespace %S end marker.\n", pszCurNs));
        throw FAILURE_WRITE;
    }
}

void CRepExporter::DumpNamespaceSecurity(NSREP *pNsRep)
{
    //Default version does not have a security descriptor, so we need to
    //just dump a blank entry.
    DWORD dwSize = 0;
    DWORD dwBuffer[2];
    dwBuffer[0] = REP_EXPORT_NAMESPACE_SEC_TAG;
    dwBuffer[1] = dwSize;

    if ((WriteFile(g_hFile, dwBuffer, 8, &dwSize, NULL) == 0) || (dwSize != 8))
    {
        DEBUGTRACE((LOG_WBEMCORE, "Failed to write namespace security, %S.\n", Fixup(pNsRep->m_poName)));
        throw FAILURE_WRITE;
    }
}

void CRepExporter::DumpRootBlock(DBROOT *pRootBlock)
{
    if (pRootBlock->m_dwFlags & DB_ROOT_INUSE)
    {
        DEBUGTRACE((LOG_WBEMCORE, "Failed to write file header block.\n"));
        throw FAILURE_DIRTY;
    }
    char *pBuffer = REP_EXPORT_FILE_START_TAG;
    DWORD dwSizeBuffer = strlen(pBuffer);
    DWORD dwSize = 0;

    if ((WriteFile(g_hFile, pBuffer, dwSizeBuffer, &dwSize, NULL) == 0) || (dwSize != dwSizeBuffer))
    {
        throw(FAILURE_WRITE);
    }
    DumpNamespace(Fixup((NSREP*)pRootBlock->m_poRootNs));

    DWORD dwBuffer[6];
    dwBuffer[0] = REP_EXPORT_FILE_END_TAG;
    dwBuffer[1] = REP_EXPORT_END_TAG_SIZE;
    memset(&(dwBuffer[2]), REP_EXPORT_END_TAG_MARKER, REP_EXPORT_END_TAG_SIZE);
    if ((WriteFile(g_hFile, dwBuffer, 24, &dwSize, NULL) == 0) || (dwSize != 24))
    {
        DEBUGTRACE((LOG_WBEMCORE, "Failed to write file trailer block.\n"));
        throw FAILURE_WRITE;
    }

}

void CRepExporter::DumpMMFHeader()
{
    MMF_ARENA_HEADER *pMMFHeader = m_pDbArena->GetMMFHeader();
    DumpRootBlock(Fixup((DBROOT*)pMMFHeader->m_dwRootBlock));

}

int CRepExporter::Export(CMMFArena2 *pDbArena, const TCHAR *pszFilename)
{
    DWORD dwVersion = NULL;
    HMODULE hModule = NULL;
    const char *pszDllName = NULL;
    int nRet = 0;

    m_pDbArena = pDbArena;

    g_hFile = CreateFile(pszFilename, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

    if (g_hFile != INVALID_HANDLE_VALUE)
    {
        try
        {
            DumpMMFHeader();
            CloseHandle(g_hFile);
        }
        catch (int dProblem)
        {
            switch(dProblem)
            {
            case FAILURE_DIRTY:
                DEBUGTRACE((LOG_WBEMCORE, "Repository is marked as corrupt, therefore cannot export it.\n"));
                break;
            case FAILURE_WRITE:
                DEBUGTRACE((LOG_WBEMCORE, "Failure writing to the export file.  May be out of disk space, or may not have write access to this directory.\n"));
                break;
            default:
                DEBUGTRACE((LOG_WBEMCORE, "An unknown problem happened while traversing the repository.\n"));
                break;
            }
            CloseHandle(g_hFile);
            nRet = 1;
        }
        catch (...)
        {
            DEBUGTRACE((LOG_WBEMCORE, "Traversal of repository file failed.  It may be corrupt.\n"));
            CloseHandle(g_hFile);
            DeleteFile(pszFilename);
            nRet = 1;
        }

    }
    else
    {
        DEBUGTRACE((LOG_WBEMCORE, "Failed to create file %s to export the repository.\n", pszFilename));
        nRet = 1;
    }
    return nRet;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vside\servexpl\generator\genwmiclass\genwmiclass.cs ===
//#define PAUSE

namespace GenWMIClass
{
	using System;
	using System.CodeDom.Compiler;
	using System.Management;

	/// <summary>
	///    <para>Main class for the application</para>
	/// </summary>
	public class GenWMIClass
	{
		/// <summary>
		///    <para>Default Constructor</para>
		/// </summary>
		public GenWMIClass()
		{
		}

		// Declare and initialize the static variables
		static string Server = String.Empty;
		static string WMINamespace = "root\\CimV2";
		static string ClassName = String.Empty;
		static string Username = String.Empty;
		static string Password = String.Empty;
		static string Authority = String.Empty;

		/// <summary>
		///    <para>Main entry point for the executable</para>
		/// </summary>
		public static int Main(String[] args)
		{
			// check if the number of arguments is at least 2...
			// ie. genwmiclass -c <className>
			Console.WriteLine("GenWMIClass : Generate managed code wrapper for a WMI Class.");
			// If the argument is helper option then display syntax
			if(args.Length == 0 || (args.Length > 0 && (args[0] == "/?" || args[0] == "-?")))
			{
				GenWMIClass.ShowUsage();
				return 0;
			}

			if(args.Length < 1)
			{
				Console.WriteLine("Invalid Arguments !!!");
				return GenWMIClass.ShowUsage();
			}
			
			String			language		= "CS";				// Initializing to default language
			String			filePath		= String.Empty;
			String			ClassNamespace	= String.Empty;
			CodeLanguage		lang;
			ManagementClass cls;

			// Navigate thru arguments to get the various arguments
			for (int i = 0; i < args.Length; i++)
			{
				if (args[i].ToUpper() == "-L" && (i + 1) < args.Length) 
				{
					language = args[++i];
				}
				else if (args[i].ToUpper() == "-N" && (i + 1) < args.Length)
				{
					WMINamespace = args[++i];
				}
				else if (args[i].ToUpper() == "-M" && (i + 1) < args.Length)
				{
					Server = args[++i];
				}
				else if (args[i].ToUpper() == "-P" && (i + 1) < args.Length)
				{
					filePath = args[++i];
				}
				else if (args[i].ToUpper() == "-U" && (i + 1) < args.Length)
				{
					Username = args[++i];
				}
				else if (args[i].ToUpper() == "-PW" && (i + 1) < args.Length)
				{
					Password = args[++i];
				}
				else if (args[i].ToUpper() == "-O" && (i + 1) < args.Length)
				{
					ClassNamespace = args[++i];
				}
				else
				{
					if (ClassName == string.Empty)
					{
						ClassName = args[i];
					}
					else
					{
						return GenWMIClass.ShowUsage();
					}
				}
			}
			
			// check if className is valid
			if(ClassName == string.Empty)
			{
				Console.WriteLine("Error!!!!. You should specify the class name.");
				return GenWMIClass.ShowUsage();
			}

			try
			{
				// Get the ManagementClass for the given class
				if(InitializeClassObject(out cls) == false)
				{
					Console.WriteLine("Getting the given class Failed");
					return -1;
				}

				// Get the fileName ( if not specified) and also the Language
				if((InitializeCodeGenerator(language,ref filePath,ClassName,out lang)) == false)
				{
					Console.WriteLine("Invalid Language {0}",language);
					return -1;
				}

				Console.WriteLine("Generating Code for WMI Class {0}...",ClassName);
				// Call this function to genrate code to be written to a file
				if(cls.GetStronglyTypedClassCode(lang,filePath,ClassNamespace) == true)
				{
					Console.WriteLine("Code Generated Successfully!!!!");
				}
				else
				{
					Console.WriteLine("Code Generation Failed.");
				}
			}
			catch(Exception e)
			{
				Console.WriteLine("Errors Occured!!!! Reason : {0}\n",e.Message);
//				Console.WriteLine("Exception Occured!!!! Reason : {0}\n\nStack Trace : \n{1}.",e.Message,e.StackTrace);
			}
	#if PAUSE
			Console.WriteLine("Press a Key...!");
			Console.Read();
	#endif
			return 0;
		}

		/// <summary>
		/// Function to print the syntax of the utility
		/// </summary>
		/// <returns></returns>

		public static int ShowUsage()
		{
			Console.WriteLine("Usage : ");
			Console.WriteLine("GenWMIClass WMIClass <-M Machine> <-N WMINamespace> <-L Language> <-P FilePath> <-U UserName> <-PW Password> <-O ClassNamespace.");
			Console.WriteLine("\n Where ");
			Console.WriteLine("\t WMINamespce is the WMI Namespace where the class resides. Defaulted to Root\\CimV2");
			Console.WriteLine("\t Language is the language for which the code should be generated. Defaulted to CS");
			Console.WriteLine("\t\t CS - CSharp");
			Console.WriteLine("\t\t VB - Visual Basic");
			Console.WriteLine("\t\t JS - JavaScript");
			Console.WriteLine("\t FilePath is the output file path. Defaulted to local directory");
			Console.WriteLine("\t Machine is the machine to which WMI should connect to. Defaulted to the local machine");
			Console.WriteLine("\t UserName is the user name in which the utility has to connect to WMI");
			Console.WriteLine("\t Password for the user to connect to WMI");
			Console.WriteLine("\t ClassNamespace is the namespace in which the class has to generated");
			return -1;
		}

		/// <summary>
		/// This function initializes the code generator object. It initializes the 
		/// code generators namespace and the class objects also.
		/// </summary>
		/// <param name="Language">Input Language as string </param>
		/// <param name="FilePath">Path of the file to which code has to written </param>
		/// <param name="ClassName">Name of the WMI class </param>
		/// <param name="lang" > Language in which code is to be generated </param>
		static bool InitializeCodeGenerator(string Language,ref string FilePath,string ClassName,out CodeLanguage lang)
		{
			bool bRet = true;
			
			lang = CodeLanguage.CSharp;
			string suffix = ".CS";		///Defaulted to CS
			switch(Language.ToUpper ())
			{
				case "VB":
					suffix = ".VB";
					lang = CodeLanguage.VB;
					break;

				case "JS":
					suffix = ".JS";
					lang = CodeLanguage.JScript;
					break;

				case "":
				case "CS":
					lang = CodeLanguage.CSharp;
					break;

				default :
					bRet = false;
					return false;
			}

			// if filepath is empty then create
			if(bRet == true && FilePath == string.Empty)
			{
				string FileName  = string.Empty;
				if(ClassName.IndexOf('_') > 0)
				{
					FileName = ClassName.Substring(0,ClassName.IndexOf('_'));
					//Now trim the class name without the first '_'
					FileName = ClassName.Substring(ClassName.IndexOf('_')+1);
				}
				else
				{
					FileName = ClassName;
				}
				FilePath = FileName + suffix;
			}

			return bRet;
		}
		
		/// <summary>
		/// Functionn to get ManagementClass object for the given class
		/// </summary>
		/// <param name="cls"> Management class object returned </param>
		/// <returns>bool value indicating the success of the method</returns>
		static bool InitializeClassObject(out ManagementClass cls)
		{
			cls = null;
			//First try to connect to WMI and get the class object.
			// If it fails then no point in continuing
			try
			{
				ConnectionOptions	ConOps		= null;
				ManagementPath	thePath			= null;
				
				if(Username != string.Empty)
				{
					ConOps = new ConnectionOptions();
					ConOps.Username = Username;
					ConOps.Password = Password;
					ConOps.Authority = Authority;
				}

				thePath = new ManagementPath();

				if(Server != String.Empty)
				{
					thePath.Server = Server;
				}
				thePath.Path = ClassName;
				thePath.NamespacePath = WMINamespace;

				if(ConOps != null)
				{
					ManagementScope MgScope = new ManagementScope(thePath,ConOps);
					cls = new ManagementClass(MgScope,thePath,null);
				}
				else
				{
					cls = new ManagementClass (thePath);
				}
				// Get the object to check if the object is valid
				cls.Get();
				
				// get the className if the path of the class is passed as argument
				ClassName = thePath.ClassName;
				return true;
			}
			catch(Exception e)
			{
				throw e;
			}
		}

	}


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\setup\bin\wbemupgradedll\dbrep.h ===
/*++

Copyright (C) 1996-2000 Microsoft Corporation

Module Name:

    DBREP.H

Abstract:

	Object database class representations which are stored in the database.

History:

--*/
#ifndef _DBREP_H_
#define _DBREP_H_

#include <stdio.h>
#include <wbemcli.h>
#include <TIME.H>
#include "MMFArena2.h"
#include "dbavl.h"
#include "dbarry.h"
#include <wbemutil.h>

class CAutoReadLock;
class CWbemObject;
class CWbemClass;
#define NEWOBJECT
class CDestination;
class CVar;
class CFlexArray;
class CWStringArray;
class CDbLowMemSink;

extern CMMFArena2* g_pDbArena;

struct NSREP;
class  NSREP_PTR;
struct CLASSDEF;
class  CLASSDEF_PTR;
struct INSTDEF;
class  INSTDEF_PTR;
struct RepCollectionItem;
class  RepCollectionItem_PTR;
struct RepCollection;
class  RepCollection_PTR;
struct PtrCollection;
class  PtrCollection_PTR;
struct SINDEXTABLE;
class  SINDEXTABLE_PTR;
struct DANGREF;
class  DANGREF_PTR;
struct DANGREFCLASS;
class  DANGREFCLASS_PTR;
struct DANGREFKEY;
class  DANGREFKEY_PTR;
struct DANGLREFSCHEMA;
class  DANGLREFSCHEMA_PTR;
struct DANGREFSCHEMA;
class  DANGREFSCHEMA_PTR;
struct DANGREFSCHEMACLASS;
class  DANGREFSCHEMACLASS_PTR;
struct DBROOT;
class  DBROOT_PTR;

class DATABASE_CRITICAL_ERROR : public CX_Exception
{
};

//=============================================================================
//
//	RepCollectionItem
//
//	This structure is used to associate a key to the stored pointer when
//	we have a single item or an array of items.  The AvlTree has it's own
//	object to do this task so we do not need it for that.
//=============================================================================
struct RepCollectionItem
{
public:
	DWORD_PTR poKey;	//Offset within MMF of key.  We own this key value.
	DWORD_PTR poItem;	//Offset within MMF of item.  We do not own the object this points to!

	//Allocate memory in the MMF arena
	static RepCollectionItem *AllocateObject();

	//Deallocate memory from the MMF arena
	static int DeallocateObject(RepCollectionItem_PTR poThis);
};

struct RepCollection
{
private:
	enum { none, single_item, array, tree} m_repType;
	enum { MAX_ARRAY_SIZE = 10 };
	DWORD	m_dwSize;
	union
	{
		DWORD_PTR	 m_poSingleItem;
		CDbArray	*m_poDbArray;
		CDbAvlTree	*m_poDbAvlTree;
	};

	static int GetSingleItem(RepCollection_PTR poThis, CFlexArray &allItems);
	static int GetAllArrayItems(RepCollection_PTR poThis, CFlexArray &allItems);
	static int GetAllTreeItems(RepCollection_PTR poThis, CFlexArray &allItems);

	static int GetSingleKey(RepCollection_PTR poThis, CWStringArray &allItems);
	static int GetAllArrayKeys(RepCollection_PTR poThis, CWStringArray &allItems);
	static int GetAllTreeKeys(RepCollection_PTR poThis, CWStringArray &allItems);

	static int FindSingleItem(RepCollection_PTR poThis, const wchar_t *pszKey, DWORD_PTR &poItem);
	static int FindUsingArray(RepCollection_PTR poThis, const wchar_t *pszKey, int &nLocus, DWORD_PTR &poItem);
	static int FindUsingTree(RepCollection_PTR poThis, const wchar_t *pszKey, DWORD_PTR &poItem);

	static int InsertSingleItem(RepCollection_PTR poThis, const wchar_t *pszKey, DWORD_PTR poItem );
	static int InsertIntoArray(RepCollection_PTR poThis, const wchar_t *pszKey, DWORD_PTR poItem, int nLocus);
	static int InsertIntoTree(RepCollection_PTR poThis, const wchar_t *pszKey, DWORD_PTR poItem);

	static int RemoveSingleItem(RepCollection_PTR poThis, const wchar_t *pszKey, BOOL &bUpdated);
	static int RemoveFromArray(RepCollection_PTR poThis, const wchar_t *pszKey, BOOL &bUpdated);
	static int RemoveFromTree(RepCollection_PTR poThis, const wchar_t *pszKey, BOOL &bUpdated);

	static int PromoteToArray(RepCollection_PTR poThis);
	static int PromoteToTree(RepCollection_PTR poThis);

	//Creates a new RepCollectionItem and populates it
	static int CreateRepItem(RepCollection_PTR poThis, const wchar_t *pszKey, DWORD_PTR poItem, DWORD_PTR &poRepItem);
	
	//Deletes a RepCollectionItem
	static int DeleteRepItem(RepCollection_PTR poThis, DWORD_PTR poRepItem);

	RepCollection() {};
	~RepCollection() {};
public:
	//Initialise the object
	static int Initialize(RepCollection_PTR poThis);

	//Deinitialise the object and delete everything in the object
	static int Deinitialize(RepCollection_PTR poThis);

	static void ValidateObject(RepCollection_PTR poThis);

	//Inserts an item into the collection given the key and the item.  Returns
	//a flag to say if the item was actually added, or if the item was already
	//there (i.e. if already there, bUpdated is FALSE).
	static int Insert(RepCollection_PTR poThis, const wchar_t *pszKey, DWORD_PTR poItem, BOOL &bUpdated);

	//removes an item from the collection given the key.  Returns
	//a flag to say if the item was actually deleted, or if the item was not
	//there (i.e. if not there, bUpdated is FALSE).
	static int Remove(RepCollection_PTR poThis, const wchar_t *pszKey, BOOL &bUpdated);

	//Remove all items.  Just tidies up our own memory, does not
	//delete the actual objects passed in because we do not know how to!
	static int RemoveAllItems(RepCollection_PTR poThis);

	//retrieves an item based on a key.
	static int Get(RepCollection_PTR poThis, const wchar_t *pszKey, DWORD_PTR &dwItem);

	//Retrieve all items
	static int GetAll(RepCollection_PTR poThis, CFlexArray &allItems);

	//Retrieves all the keys and stores them as wchar_t*.  User needs to
	//delete this!
	static int GetAllKeys(RepCollection_PTR poThis, CWStringArray &allKeys);

	//retrieves a count of how many items are in the collection.
	static DWORD GetCount(RepCollection_PTR poThis);

	//Allocate memory in the MMF arena
	static RepCollection *AllocateObject();

	//Deallocate memory from the MMF arena
	static int DeallocateObject(RepCollection_PTR poThis);
};

//Repository of pointers stored in reference tables.
//If the list is one item it is a direct pointer, if a small number of items
//(say 10) it is a CDbArray, otherwise we use a CDbAvlTree.
struct PtrCollection
{
	enum { none, single_item, array, tree} m_repType;
	enum { MAX_ARRAY_SIZE = 10 };

	DWORD	m_dwSize;
	union
	{
		DWORD_PTR	m_poPtr;
		CDbArray   *m_poDbArray;
		CDbAvlTree *m_poDbAvlTree;
	};

	static int FindUsingArray(PtrCollection_PTR poThis, DWORD_PTR poPtr, int &nLocus);
	static int FindUsingTree(PtrCollection_PTR poThis, DWORD_PTR poPtr);

private:
	PtrCollection(): m_repType(none), m_dwSize(0), m_poPtr(0) {}
	~PtrCollection() {}

public:
	//Initialise the object contents
	static int Initialize(PtrCollection_PTR poThis);

	//Deinitialise the object and delete any objects it points to
	static int Deinitialize(PtrCollection_PTR poThis);

	static void ValidateObject(PtrCollection_PTR poThis);

	static int InsertPtr(PtrCollection_PTR poThis, DWORD_PTR poPtr);
	static int RemovePtr(PtrCollection_PTR poThis, DWORD_PTR poPtr, BOOL &bDatabaseChanged);
	static int GetAllPtrs(PtrCollection_PTR poThis, CFlexArray &references);
	static DWORD GetPtrCount(PtrCollection_PTR poThis);

	//Allocate memory in the MMF arena
	static PtrCollection *AllocateObject();

	//Deallocate memory from the MMF arena
	static int DeallocateObject(PtrCollection_PTR poThis);
};

struct NSREP
{
	enum { flag_normal = 0x1, flag_hidden = 0x2, flag_temp = 0x4,
		   flag_system = 0x8
		 };

	// Data members.
	// =============
	RepCollection *m_poNamespaces;		// Child namespaces, based ptr
	LPWSTR		m_poName;			 // Namespace name, based ptr
	INSTDEF	   *m_poObjectDef;		 // 'Real' object definition, based ptr
	DWORD		m_dwFlags;			 // Hidden, normal, temp, system, etc.
	CDbAvlTree *m_poClassTree;		 // Class tree by Name, CLASSDEF structs, based tr
	NSREP	   *m_poParentNs;		 // Owning namespace, based ptr
	DWORD_PTR	m_poSecurity;

	// Functions.
	// ==========
private:
	NSREP() {}
	~NSREP() {}

public:
	//Initialise the object for the first time
	static int Initialize(NSREP_PTR poThis, NSREP_PTR poParent, LPCWSTR pName, DWORD dwFlags, INSTDEF_PTR poObjInParentNs);

	//Deinitialise the object and delete all the objects it points to
	static int Deinitialize(NSREP_PTR poThis);

	static void ValidateObject(NSREP_PTR poThis);

	static int CreateInstance(NSREP_PTR poThis, CWbemObject *pObj, INSTDEF_PTR* ppoInst = NULL);
	static int CreateStdClasses(NSREP_PTR poThis);
	static int CreateCacheControl(NSREP_PTR poThis, LPCWSTR wszClassName, DWORD dwSeconds);
	static int CreateRootClasses(NSREP_PTR poThis);
	static int CreateSecurityClasses(NSREP_PTR poThis);

	static int GetInstance(NSREP_PTR poThis, DWORD dwKeyType, LPCWSTR pKey, CWbemObject **pObj, INSTDEF_PTR *poInstDef = 0);

	static int UpdateInstance(NSREP_PTR poThis, DWORD dwKeyType, LPCWSTR pKey, CWbemObject *poObj);

	static int DeleteInstance(NSREP_PTR poThis, IN DWORD dwKeyType, IN LPCWSTR pClass, IN LPCWSTR  pKeyString);

	static int CreateClass(NSREP_PTR poThis, CWbemObject *pObj, DWORD dwUpdateFlags = 0);

	static int UpdateClass(NSREP_PTR poThis, DWORD dwKeyType, LPCWSTR pKey, CWbemObject *pObj);
	
	static int UpdateClassV2(NSREP_PTR poThis, IN LPCWSTR pwszClassKey, IN CWbemClass *pNewClassObject, IN DWORD dwClassUpdateFlags);

	//Get the class specified in pKey, returning the CWbemObject, INSTDEF and CLASSDEF if requested
	static int GetClass(NSREP_PTR poThis, DWORD dwKeyType, LPCWSTR pKey, CWbemObject **pObj, INSTDEF_PTR *poInstDef = 0, CLASSDEF_PTR *poClassDef = 0);
		
	//Deletes all classes in the namespace (as well as all instances)
	static int DeleteAllClasses(NSREP_PTR poThis);

	//DE;ete all child namespaces
	static int DeleteChildNamespaces(NSREP_PTR poThis);
	static int DeleteClass(NSREP_PTR poThis, DWORD dwKeyType, LPCWSTR pKey);

	//Returns a path of a namespace in the form...
	//root\<namespace>\<namespace>...
	static wchar_t *GetFullPath(NSREP_PTR poThis);

	//Adds "\\<machine name> to the szFullPath and passes it through to GetFullPath
	static wchar_t *GetFullPathPlusServer(NSREP_PTR poThis);

	//Sets the security on the namespace
	static int SetSecurityOnNamespace(NSREP_PTR poThis, const void *pSecurityBlob, DWORD dwSize);

	//Returns the security for a namespace
	static int GetSecurityOnNamespace(NSREP_PTR poThis, void **pSecurityBlob);
	
	//Returns all classes which have the [HasClassRefs] class qualifier
	static int GetClassesWithRefs(NSREP_PTR poThis, CDbLowMemSink *pDest);

	//Allocate memory in the MMF arena
	static NSREP *AllocateObject();

	//Deallocate memory from the MMF arena
	static int DeallocateObject(NSREP_PTR poThis);
};

/////////////////////////////////////////////////////////////////////////////

struct INSTDEF
{
	enum
	{
		genus_class = WBEM_GENUS_CLASS, 		//defined in IDL, 1
		genus_instance = WBEM_GENUS_INSTANCE,	//defined in IDL, 2
		compressed = 0x100
	};

	NSREP	 *m_poOwningNs; 			  // back ptr for debugging, based ptr
	CLASSDEF *m_poOwningClass;			  // back ptr for debugging, based ptr
	DWORD	  m_dwFlags;				  // Genus, etc.
	LPVOID	  m_poObjectStream; 		  // Ptr to object stream, based ptr
	PtrCollection *m_poRefTable;		   // List of references to this object
										
	// Functions.
	// ==========
	//Retrieves the class name from the INSTDEF memory blob
	static wchar_t *GetClassName(INSTDEF_PTR poThis);

	static LPBYTE UncompressObjectStream(INSTDEF_PTR poThis);
	static int CompressObjectStream(LPBYTE pMem, LONG lLength, LPBYTE &pCompressedStream, LONG &lNewLength);

private:
	INSTDEF(NSREP_PTR poOwningNs, CLASSDEF_PTR poOwningClass);
	~INSTDEF();

public:
	//Initialise the object contents
	static int Initialize(INSTDEF_PTR poThis, NSREP_PTR poOwningNs, CLASSDEF_PTR poOwningClass);

	//Deinitialise the object and delete any objects it points to
	static int Deinitialize(INSTDEF_PTR poThis);

	static void ValidateObject(INSTDEF_PTR poThis);

	static int SetObject(INSTDEF_PTR poThis, CWbemObject *pObj, INSTDEF_PTR poOldDef, CWbemObject  *pOldObj, bool bDoDangRefFixups = true);
	static int GetObject(INSTDEF_PTR poThis, NEWOBJECT CWbemObject **pObj, bool bLookInCacheFirst = true);
	static int _GetObject(INSTDEF_PTR poThis, NEWOBJECT CWbemObject **pObj);	//Does the work for GetObject

	// Records that <pReferent> has an obj ref to this object.
	static int SetRef(INSTDEF_PTR poThis, INSTDEF_PTR poReferent);
		
	static int UpdateObjectRefs(INSTDEF_PTR poThis, CWbemObject *pBefore, CWbemObject *pAfter, const wchar_t *wszThisClassPath);

	//Works through each of the object's references.  It checks to make sure
	//all the references are fixed up which can be.  If there are any dangling
	//references at the end of the operation bHasDanglingRefs is set to TRUE.
	static int ResolveRefs(INSTDEF_PTR poThis, IN CWbemObject *pCurrent, OUT BOOL &bHasDanglingRefs);
				
	// Removes the reference if it is exists; harmless if not.
	static int RemoveRef(INSTDEF_PTR poThis, INSTDEF_PTR poReferent);

	//Marks all references as dangling and removes the reference table
	static int DangleAllRefs(INSTDEF_PTR poThis, const wchar_t *wszPath);

	//Return the owning class of this instance
	static CLASSDEF *GetOwningClass(INSTDEF_PTR poThis);

	//Fixes up any dangling references there are to this object
	static int FixupDangRefsToThisObject(INSTDEF_PTR poThis, CWbemObject *pObj);


	//Allocate memory in the MMF arena
	static INSTDEF *AllocateObject();

	//Deallocate memory from the MMF arena
	static int DeallocateObject(INSTDEF_PTR poThis);
};


/////////////////////////////////////////////////////////////////////////////

#define MAX_SECONDARY_INDICES	4

struct SINDEXTABLE
{
	DWORD		m_aPropTypes[MAX_SECONDARY_INDICES];		// VT_ type of the property.
	LPWSTR		m_aPropertyNames[MAX_SECONDARY_INDICES];	// NULL entries indicate nothing
	CDbAvlTree *m_apoLookupTrees[MAX_SECONDARY_INDICES];		// Parallel to above names

private:
	SINDEXTABLE() {}
	~SINDEXTABLE() {}

	
public:
	//Initialise the object contents
	static int Initialize(SINDEXTABLE_PTR poThis);

	//Allocate memory in the MMF arena
	static SINDEXTABLE *AllocateObject();

	//Deallocate memory from the MMF arena
	static int DeallocateObject(SINDEXTABLE_PTR poThis);
};

/////////////////////////////////////////////////////////////////////////////
struct CLASSDEF
{
	enum {	keyed = 0x1,
			unkeyed = 0x2,
			indexed = 0x4,
			abstract = 0x08,
			borrowed_index = 0x10,
			dynamic = 0x20,
//			has_refs = 0x40,
			singleton = 0x80,
			compressed = 0x100,
			has_class_refs = 0x200
		 };
	
	// Data members.
	// =============
	NSREP		 *m_poOwningNs;		// Back reference to owning namespace, based ptr
	INSTDEF	     *m_poClassDef;		// Local definition mixed with instances, based ptr
	CLASSDEF	 *m_poSuperclass;	// Immediate parent class, based ptr
	DWORD		  m_dwFlags; 		// Various combinations of the above enum flags
	CDbAvlTree	 *m_poKeyTree;		// Instances by key, based ptr
	PtrCollection*m_poSubclasses;	// Child classes, based ptr
	SINDEXTABLE  *m_poSecondaryIx;	// Based ptr to secondary indices
	PtrCollection*m_poInboundRefClasses;	// Classes which may have dyn instances which reference
											// objects of this class
private:			
	//Traverses up a class hierarchy from the class specified until we find the base-most
	//class which needs to own the key tree.  Then we need to create the key tree and
	//propagate it recursively down to all child classes.
	static int CreateKeyTree(CLASSDEF_PTR poThis);

	//Find the name of the class which owns the key tree
	static wchar_t *GetKeyedClassName(CLASSDEF_PTR poThis);

	//Does phase 1 of the key tree update
	static int Phase1KeyTreeUpdate(CLASSDEF_PTR poThis, CWbemClass *pNewClassObject, bool &bKeyChanged);

	//Does phase 2 of the key tree update
	static int Phase2KeyTreeUpdate(CLASSDEF_PTR poThis, CWbemClass *pNewClassObject);

	//Finds a key tree in the class hierarchy from this class down, deletes
	//the tee and propagates the request to child classes
	static int FindKeyTreesThenDeleteAndPropagate(CLASSDEF_PTR poThis);

	//Deletes the key tree at this node and propagates it to child classes
	static int DeleteKeyTreeAndPropagate(CLASSDEF_PTR poThis);

	//Propagates a key removel request to all child classes
	static int PropagateKeyRemoval(CLASSDEF_PTR poThis);

	static int PropagateKeyCreation(CLASSDEF_PTR poThis, CDbAvlTree_PTR poKeyTree);

	static BOOL ClassOwnsKey(CLASSDEF_PTR poThis);

	//Based on the index type and value, returns the key value used to lookup the value in the
	//index tree.  returns FALSE if it is not a valid or supported type...
	static BOOL ConvertIndexTypeToKeyValue(int nIndexType, CVar &varValue, int &nKey);

	static int UpdateClassRefs(CLASSDEF_PTR poThis, CWbemClass *pNewClassObject, CWbemClass *pOldClassObject);

public:
	//Initialise the object contents
	static int Initialize(CLASSDEF_PTR poThis, NSREP_PTR poOwner, CWbemObject *pObj, CLASSDEF_PTR poSuperclass);

	//Deinitialise the object and delete any objects it points to
	static int Deinitialize(CLASSDEF_PTR poThis, const wchar_t *wszClassName);

	static void ValidateObject(CLASSDEF_PTR poThis);

	//Phase 2 of the constructor!
	static int FinishInit(CLASSDEF_PTR poThis, NSREP_PTR poOwner, CWbemObject *pObj, const wchar_t *wszClassName);

	static int AddInboundRefClass(CLASSDEF_PTR poThis, IN LPCWSTR pClass);

	static BOOL RemoveInboundRefClass(CLASSDEF_PTR poThis, IN LPCWSTR pClass);

	static int ClearInboundRefClasses(CLASSDEF_PTR poThis, wchar_t *wszClassName);

	static int  CreateOutboundRefs(CLASSDEF_PTR poThis, CWbemObject *pObj, BOOL bAddDanglingRefs, BOOL &bStillRefsDangling, const wchar_t *wszClassName);
	static int RemoveOutboundRefs(CLASSDEF_PTR poThis, CWbemObject *pObj, const wchar_t *wszThisClassName);

	static int GetRefClasses(CLASSDEF_PTR poThis, OUT CWStringArray &aClasses);

	static int GetClassDef(CLASSDEF_PTR poThis, CWbemObject **pObj);

	//Retrieves the class name from the INSTDEF memory blob
	static wchar_t *GetClassName(CLASSDEF_PTR poThis);
	static wchar_t *GetSuperclassName(CLASSDEF_PTR poThis);

	//returns path of class in format <namespace_path>:<classname>
	static wchar_t *GetFullPath(CLASSDEF_PTR poThis);
	
	//returns path of class in format \\<server_name>\<namespace_path>:<classname>
	static wchar_t *GetFullPathPlusServer(CLASSDEF_PTR poThis);

	static int CreateInstance(CLASSDEF_PTR poThis, CWbemObject *pObj, INSTDEF_PTR* ppInst = NULL);
	static CDbAvlTree *FindIndex(CLASSDEF_PTR poThis, LPCWSTR pPropName);

	static int GetInstance(CLASSDEF_PTR poThis, DWORD  dwKeyType,LPCWSTR KeyString, CWbemObject **pObj, INSTDEF_PTR *poInstDef = 0);

	static int UpdateInstance(CLASSDEF_PTR poThis, DWORD dwKeyType,LPCWSTR pKey,CWbemObject *pObj);
		
	static int UpdateClassDef(CLASSDEF_PTR poThis, CWbemObject *pObj);

	//Does this class have any instances associated with it.  This also includes
	//any child classes.  If we return bCheckChildClasses as FALSE, no more
	//child classes under us need to be checked.  This basically happens a
	//soon as we hit a keyed node.
	static BOOL ClassHasInstances(CLASSDEF_PTR poThis, BOOL &bCheckChildClasses);

	//Does a quick walk up the class hierarchy of the given class to see if we
	//are included in its hierarchy.  If it is we return TRUE.	FALSE otherwise.
	static BOOL ClassInheritsFromUs(CLASSDEF_PTR poThis, CLASSDEF_PTR poClass);

	//Updates the class based on the new class definition.	
	//dwClassUpdateFlags tells it if it is a safe or force update.
	static int UpdateClassV2(CLASSDEF_PTR poThis, IN CWbemClass *pNewClassObject,IN DWORD dwClassUpdateFlags,IN BOOL bValidateOnly);

	//Updates a child class based on the new parent class definition.
	//dwClassUpdateFlags tells it if it is a safe or force update.
	static int UpdateChildClassV2(CLASSDEF_PTR poThis, IN CWbemClass *pNewClassObject,IN DWORD dwClassUpdateFlags,IN BOOL bValidateOnly,IN BOOL	bCheckChildrenForInstances);
	
	//Reparents the class to a new parent
	static int UpdateParentClass(CLASSDEF_PTR poThis, CWbemClass *pNewClassObject);
	
	//Checks to make sure the parent class exists in this namespace
	static int CheckParentClassExists(CLASSDEF_PTR poThis, CWbemClass *pNewClassObject);

	//Returns TRUE if the key tree changed classes
	static BOOL HasKeyChanged(CLASSDEF_PTR poThis, CWbemClass *pNewClassObject);

	//Returns TRUE if the index tree changed classes
	static BOOL HasIndexChanged(CLASSDEF_PTR poThis, CWbemClass *pNewClassObject);

	static int CreateSecondaryIndices(CLASSDEF_PTR poThis, CWbemObject *pObj);

	static int RemoveSecondaryIndexEntry(CLASSDEF_PTR poThis, IN LPCWSTR pPropName,IN CVar *pValue,IN INSTDEF_PTR poInst);

	static int UpdateSecondaryIndices(CLASSDEF_PTR poThis, IN CWbemObject *pOld,IN CWbemObject *pNew,IN INSTDEF_PTR poInst);

	static int DropSecondaryIndices(CLASSDEF_PTR poThis);

	static int AddSecondaryIndexEntry(CLASSDEF_PTR poThis, IN LPCWSTR PropName,IN CVar *pValue,IN INSTDEF_PTR poInst);

	static int QueryIndexedInstances(CLASSDEF_PTR poThis, IN LPCWSTR pProperty,IN CVar *pValue,IN int nType, IN CDestination* pSink,IN CAutoReadLock &readLock);

	static int DeleteInstance(CLASSDEF_PTR poThis, DWORD dwKeyType, LPCWSTR pKey);
	static int AddSubclass(CLASSDEF_PTR poThis, CLASSDEF_PTR poSubclass);
	static int RemoveSubclass(CLASSDEF_PTR poThis, CLASSDEF_PTR poSubclass);

	static int CanChange(CLASSDEF_PTR poThis);
	static BOOL CanBeReconciledWith(CLASSDEF_PTR poThis, CWbemObject* pObj);

	static CLASSDEF *GetSuperclass(CLASSDEF_PTR poThis);
		
	static int RemoveAllInstances(CLASSDEF_PTR poThis);

	static void RemoveChildClassesFromCache(CLASSDEF_PTR poThis);

	//Allocate memory in the MMF arena
	static CLASSDEF *AllocateObject();

	//Deallocate memory from the MMF arena
	static int DeallocateObject(CLASSDEF_PTR poThis);
};

/////////////////////////////////////////////////////////////////////////////

struct DANGREF : public RepCollection
{
private:
	DANGREF();
	~DANGREF();

public:
	//Initialise the object contents
	static int Initialize(DANGREF_PTR poThis);

	//Deinitialise the object and delete any objects it points to
	static int Deinitialize(DANGREF_PTR poThis);

	//Specifies the full path of the target reference along with the full path of the source object.
	//The target is the object a reference points to (must contain the full path).
	//The source is the object which has the reference which cannot be satisfied.
	static int AddReferenceTarget(DANGREF_PTR poThis, const wchar_t *wszFullPathTarget, const wchar_t *wszFullPathSource);

	//Retrieves all entries from the structure (in INSTDEF* format which is what we
	//actually need to store the reference) which have references to the specified
	//target.  Note that this will cause (potentially) many GetObjByPath calls
	//to be generated on any entries which kind of match.
	static int ResolveReferencesToTarget(DANGREF_PTR poThis, const wchar_t *wszFullPathTarget, CWStringArray &aTargetClassHierarchy);

	//Finds any reference to the source path and removes it from the dangling
	//reference table.
	static int RemoveSourcePath(DANGREF_PTR poThis, const wchar_t *wszFullPathSource);

	//Returns all objects that have dangling references stored.
	static int GetAllRefs(DANGREF_PTR poThis, CDestination *pDest);

	//Allocate memory in the MMF arena
	static DANGREF *AllocateObject();

	//Deallocate memory from the MMF arena
	static int DeallocateObject(DANGREF_PTR poThis);
};

struct DANGREFCLASS : public RepCollection
{
private:
	DANGREFCLASS();
	~DANGREFCLASS();
public:
	//Initialise the object contents
	static int Initialize(DANGREFCLASS_PTR poThis);

	//Deinitialise the object and delete any objects it points to
	static int Deinitialize(DANGREFCLASS_PTR poThis);

	//Allocate memory in the MMF arena
	static DANGREFCLASS *AllocateObject();

	//Deallocate memory from the MMF arena
	static int DeallocateObject(DANGREFCLASS_PTR poThis);
};
struct DANGREFKEY : public RepCollection
{
private:
	DANGREFKEY();
	~DANGREFKEY();

public:
	//Initialise the object contents
	static int Initialize(DANGREFKEY_PTR poThis);

	//Deinitialise the object and delete any objects it points to
	static int Deinitialize(DANGREFKEY_PTR poThis);

	//Allocate memory in the MMF arena
	static DANGREFKEY *AllocateObject();

	//Deallocate memory from the MMF arena
	static int DeallocateObject(DANGREFKEY_PTR poThis);
};

/////////////////////////////////////////////////////////////////////////////
struct DANGLREFSCHEMA : public RepCollection
{
private:
	DANGLREFSCHEMA();
	~DANGLREFSCHEMA();

public:
	//Initialise the object contents
	static int Initialize(DANGLREFSCHEMA_PTR poThis);

	//Deinitialise the object and delete any objects it points to
	static int Deinitialize(DANGLREFSCHEMA_PTR poThis);

	//Resolves all inbound references associated with a specified target.
	//The target must be a fully qualifies path.
	static int ResolveInboundRefsToTarget(DANGLREFSCHEMA_PTR poThis, const wchar_t *wszTarget);

	//Inserts a reference endpoint as being a dangling reference.
	static int InsertDanglingReference(DANGLREFSCHEMA_PTR poThis, const wchar_t *wszTarget, CWStringArray aTargetClassHierarchy);

	static int RemoveDanglingReference(DANGLREFSCHEMA_PTR poThis, const wchar_t *wszTarget);

	//Returns all objects that have dangling references stored.
	static int GetAllRefs(DANGLREFSCHEMA_PTR poThis, CDestination *pDest);

	//Allocate memory in the MMF arena
	static DANGLREFSCHEMA *AllocateObject();

	//Deallocate memory from the MMF arena
	static int DeallocateObject(DANGLREFSCHEMA_PTR poThis);
};

struct DANGREFSCHEMA : public RepCollection
{
private:
	DANGREFSCHEMA();
	~DANGREFSCHEMA();
public:
	//Initialise the object contents
	static int Initialize(DANGREFSCHEMA_PTR poThis);

	//Deinitialise the object and delete any objects it points to
	static int Deinitialize(DANGREFSCHEMA_PTR poThis);

	//Mark a target schema object as being dangling and remember the object which
	//needs to be fixed up when the target is created (full path)
	static int InsertSchemaDanglingReference(DANGREFSCHEMA_PTR poThis, const wchar_t *wszTargetObjPath,const wchar_t *wszSourceObject);

	//Remove any entries in the schema dangling reference table which refers
	//to a given source path (full path!)
	static int RemoveSchemaDanglingReferences(DANGREFSCHEMA_PTR poThis, const wchar_t *wszSourcePath);

	//Resolve any schema references which refer to any of the target classes
	//in the array which kind of match what is given.
	static int ResolveSchemaReferencesToTarget(DANGREFSCHEMA_PTR poThis, const wchar_t *wszTargetClass);

	//Returns all objects that have dangling references stored.
	static int GetAllRefs(DANGREFSCHEMA_PTR poThis, CDestination *pDest);

	//Allocate memory in the MMF arena
	static DANGREFSCHEMA *AllocateObject();

	//Deallocate memory from the MMF arena
	static int DeallocateObject(DANGREFSCHEMA_PTR poThis);
};

struct DANGREFSCHEMACLASS : public RepCollection
{
private:
	DANGREFSCHEMACLASS();
	~DANGREFSCHEMACLASS();
public:
	//Initialise the object contents
	static int Initialize(DANGREFSCHEMACLASS_PTR poThis);

	//Deinitialise the object and delete any objects it points to
	static int Deinitialize(DANGREFSCHEMACLASS_PTR poThis);

	//Allocate memory in the MMF arena
	static DANGREFSCHEMACLASS *AllocateObject();

	//Deallocate memory from the MMF arena
	static int DeallocateObject(DANGREFSCHEMACLASS_PTR poThis);
};

/////////////////////////////////////////////////////////////////////////////

#define DB_ROOT_CLEAN		0x0
#define DB_ROOT_INUSE		0x1

struct DBROOT
{
private:
	DBROOT(){}
	~DBROOT(){}
public:
	time_t			m_tCreate;
	time_t			m_tUpdate;
	DWORD			m_dwFlags;				// in-use, stable, etc.
	NSREP		   *m_poRootNs; 			// ROOT namespace
	DANGREF 	   *m_poDanglingRefTbl; 	// Dangling reference table
	DANGREFSCHEMA  *m_poSchemaDanglingRefTbl;// Same as above but for schema-based fixups

	//Allocate memory in the MMF arena
	static DBROOT *AllocateObject();

	//Deallocate memory from the MMF arena
	static int DeallocateObject(DBROOT_PTR poThis);
};

/////////////////////////////////////////////////////////////////////////////

class NSREP_PTR : public Offset_Ptr<NSREP>
{
public:
	NSREP_PTR& operator =(NSREP *val) { SetValue(val); return *this; }
	NSREP_PTR& operator =(NSREP_PTR &val) { SetValue(val); return *this; }
	NSREP_PTR(NSREP *val) { SetValue(val); }
	NSREP_PTR() { }
};
class CLASSDEF_PTR : public Offset_Ptr<CLASSDEF>
{
public:
	CLASSDEF_PTR& operator =(CLASSDEF *val) { SetValue(val); return *this; }
	CLASSDEF_PTR& operator =(CLASSDEF_PTR &val) { SetValue(val); return *this; }
	CLASSDEF_PTR(CLASSDEF *val) { SetValue(val); }
	CLASSDEF_PTR() { }
};
class INSTDEF_PTR : public Offset_Ptr<INSTDEF>
{
public:
	INSTDEF_PTR& operator =(INSTDEF *val) { SetValue(val); return *this; }
	INSTDEF_PTR& operator =(INSTDEF_PTR &val) { SetValue(val); return *this; }
	INSTDEF_PTR(INSTDEF *val) { SetValue(val); }
	INSTDEF_PTR() { }
};
class RepCollectionItem_PTR : public Offset_Ptr<RepCollectionItem>
{
public:
	RepCollectionItem_PTR& operator =(RepCollectionItem *val) { SetValue(val); return *this; }
	RepCollectionItem_PTR& operator =(RepCollectionItem_PTR &val) { SetValue(val); return *this; }

	RepCollectionItem_PTR() {}
	RepCollectionItem_PTR(RepCollectionItem *val) { SetValue(val); }
	RepCollectionItem_PTR(RepCollectionItem_PTR &val) { SetValue(val); }
};
class RepCollection_PTR : public Offset_Ptr<RepCollection>
{
public:
	RepCollection_PTR& operator =(RepCollection *val) { SetValue(val); return *this; }
	RepCollection_PTR& operator =(RepCollection_PTR &val) { SetValue(val); return *this; }
	RepCollection_PTR(RepCollection *val) { SetValue(val); }
	RepCollection_PTR() { }
};
class PtrCollection_PTR : public Offset_Ptr<PtrCollection>
{
public:
	PtrCollection_PTR& operator =(PtrCollection *val) { SetValue(val); return *this; }
	PtrCollection_PTR& operator =(PtrCollection_PTR &val) { SetValue(val); return *this; }
	PtrCollection_PTR(PtrCollection *val) { SetValue(val); }
	PtrCollection_PTR() { }
};
class SINDEXTABLE_PTR : public Offset_Ptr<SINDEXTABLE>
{
public:
	SINDEXTABLE_PTR& operator =(SINDEXTABLE *val) { SetValue(val); return *this; }
	SINDEXTABLE_PTR& operator =(SINDEXTABLE_PTR &val) { SetValue(val); return *this; }
	SINDEXTABLE_PTR(SINDEXTABLE *val) { SetValue(val); }
	SINDEXTABLE_PTR() { }
};
class DANGREF_PTR : public RepCollection_PTR
{
public:
	DANGREF_PTR& operator =(DANGREF *val) { SetValue(val); return *this; }
	DANGREF_PTR& operator =(DANGREF_PTR &val) { SetValue(val); return *this; }
	DANGREF_PTR(DANGREF *val) { SetValue(val); }
	DANGREF_PTR() { }
};
class DANGREFCLASS_PTR : public RepCollection_PTR
{
public:
	DANGREFCLASS_PTR& operator =(DANGREFCLASS *val) { SetValue(val); return *this; }
	DANGREFCLASS_PTR& operator =(DANGREFCLASS_PTR &val) { SetValue(val); return *this; }
	DANGREFCLASS_PTR(DANGREFCLASS *val) { SetValue(val); }
	DANGREFCLASS_PTR() { }
};
class DANGREFKEY_PTR : public RepCollection_PTR
{
public:
	DANGREFKEY_PTR& operator =(DANGREFKEY *val) { SetValue(val); return *this; }
	DANGREFKEY_PTR& operator =(DANGREFKEY_PTR &val) { SetValue(val); return *this; }
	DANGREFKEY_PTR(DANGREFKEY *val) { SetValue(val); }
	DANGREFKEY_PTR() { }
};
class DANGLREFSCHEMA_PTR : public RepCollection_PTR
{
public:
	DANGLREFSCHEMA_PTR& operator =(DANGLREFSCHEMA *val) { SetValue(val); return *this; }
	DANGLREFSCHEMA_PTR& operator =(DANGLREFSCHEMA_PTR &val) { SetValue(val); return *this; }
	DANGLREFSCHEMA_PTR(DANGLREFSCHEMA *val) { SetValue(val); }
	DANGLREFSCHEMA_PTR() { }
};
class DANGREFSCHEMA_PTR : public RepCollection_PTR
{
public:
	DANGREFSCHEMA_PTR& operator =(DANGREFSCHEMA *val) { SetValue(val); return *this; }
	DANGREFSCHEMA_PTR& operator =(DANGREFSCHEMA_PTR &val) { SetValue(val); return *this; }
	DANGREFSCHEMA_PTR(DANGREFSCHEMA *val) { SetValue(val); }
	DANGREFSCHEMA_PTR() { }
};
class DBROOT_PTR : public Offset_Ptr<DBROOT>
{
public:
	DBROOT_PTR& operator =(DBROOT *val) { SetValue(val); return *this; }
	DBROOT_PTR& operator =(DBROOT_PTR &val) { SetValue(val); return *this; }
	DBROOT_PTR(DBROOT *val) { SetValue(val); }
	DBROOT_PTR() { }
};
class DANGREFSCHEMACLASS_PTR : public RepCollection_PTR
{
public:
	DANGREFSCHEMACLASS_PTR& operator =(DANGREFSCHEMACLASS *val) { SetValue(val); return *this; }
	DANGREFSCHEMACLASS_PTR& operator =(DANGREFSCHEMACLASS_PTR &val) { SetValue(val); return *this; }
	DANGREFSCHEMACLASS_PTR(DANGREFSCHEMACLASS *val) { SetValue(val); }
	DANGREFSCHEMACLASS_PTR() { }
};

inline
RepCollectionItem *RepCollectionItem::AllocateObject()
{
	return (RepCollectionItem*)g_pDbArena->Alloc(sizeof(RepCollectionItem));
}

inline
int RepCollectionItem::DeallocateObject(RepCollectionItem_PTR poThis)
{
	return g_pDbArena->Free(poThis.GetDWORD_PTR());
}

inline
int RepCollection::Initialize(RepCollection_PTR poThis)
{
	poThis->m_repType = none;
	poThis->m_dwSize = 0;
	poThis->m_poSingleItem = 0;
	return 0;
}

inline
void RepCollection::ValidateObject(RepCollection_PTR poThis)
#if (defined DEBUG || defined _DEBUG)
	{
		g_pDbArena->IsValidBlock(poThis.GetDWORD_PTR());
		if (g_pDbArena->IsDeleted(poThis.GetDWORD_PTR()))
		{
			_ASSERT(0, "Accessing a deleted block");
		}
	}
#else
	{
	}
#endif

inline
DWORD RepCollection::GetCount(RepCollection_PTR poThis)
{
	return poThis->m_dwSize;
}

inline
RepCollection *RepCollection::AllocateObject()
{
	return (RepCollection*)g_pDbArena->Alloc(sizeof(RepCollection));
}

inline
int RepCollection::DeallocateObject(RepCollection_PTR poThis)
{
	return g_pDbArena->Free(poThis.GetDWORD_PTR());
}
inline
int PtrCollection::Initialize(PtrCollection_PTR poThis)
{
	poThis->m_repType = none;
	poThis->m_dwSize = 0;
	poThis->m_poPtr = 0;
	return 0;
}

inline
void PtrCollection::ValidateObject(PtrCollection_PTR poThis)
#if (defined DEBUG || defined _DEBUG)
	{
		g_pDbArena->IsValidBlock(poThis.GetDWORD_PTR());
		if (g_pDbArena->IsDeleted(poThis.GetDWORD_PTR()))
		{
			_ASSERT(0, "Accessing a deleted block");
		}
	}
#else
	{
	}
#endif

inline
DWORD PtrCollection::GetPtrCount(PtrCollection_PTR poThis)
{
	return poThis->m_dwSize;
}

inline
PtrCollection *PtrCollection::AllocateObject()
{
	return (PtrCollection *)g_pDbArena->Alloc(sizeof(PtrCollection));
}

inline
int PtrCollection::DeallocateObject(PtrCollection_PTR poThis)
{
	return g_pDbArena->Free(poThis.GetDWORD_PTR());
}

inline
void NSREP::ValidateObject(NSREP_PTR poThis)
#if (defined DEBUG || defined _DEBUG)
	{
		g_pDbArena->IsValidBlock(poThis.GetDWORD_PTR());
		if (g_pDbArena->IsDeleted(poThis.GetDWORD_PTR()))
		{
			_ASSERT(0, "Accessing a deleted block");
		}
	}
#else
	{
	}
#endif

inline
NSREP *NSREP::AllocateObject()
{
	return (NSREP*)g_pDbArena->Alloc(sizeof(NSREP));
}

//Deallocate memory from the MMF arena
inline
int NSREP::DeallocateObject(NSREP_PTR poThis)
{
	return g_pDbArena->Free(poThis.GetDWORD_PTR());
}

inline
INSTDEF::INSTDEF(NSREP_PTR poOwningNs, CLASSDEF_PTR poOwningClass)
{
}

inline 	
INSTDEF::~INSTDEF()
{
}
inline
void INSTDEF::ValidateObject(INSTDEF_PTR poThis)
#if (defined DEBUG || defined _DEBUG)
	{
		g_pDbArena->IsValidBlock(poThis.GetDWORD_PTR());
		if (g_pDbArena->IsDeleted(poThis.GetDWORD_PTR()))
		{
			_ASSERT(0, "Accessing a deleted block");
		}
	}
#else
	{
	}
#endif

inline
CLASSDEF *INSTDEF::GetOwningClass(INSTDEF_PTR poThis)
{
	return poThis->m_poOwningClass;
}

inline
INSTDEF *INSTDEF::AllocateObject()
{
	return (INSTDEF *)g_pDbArena->Alloc(sizeof(INSTDEF));
}

inline int INSTDEF::DeallocateObject(INSTDEF_PTR poThis)
{
	return g_pDbArena->Free(poThis.GetDWORD_PTR());
}

inline
void CLASSDEF::ValidateObject(CLASSDEF_PTR poThis)
#if (defined DEBUG || defined _DEBUG)
	{
		g_pDbArena->IsValidBlock(poThis.GetDWORD_PTR());
		if (g_pDbArena->IsDeleted(poThis.GetDWORD_PTR()))
		{
			_ASSERT(0, "Accessing a deleted block");
		}
	}
#else
	{
	}
#endif

inline
int CLASSDEF::GetClassDef(CLASSDEF_PTR poThis, CWbemObject **pObj)
{
	return INSTDEF::GetObject(poThis->m_poClassDef, pObj);
}

inline
wchar_t *CLASSDEF::GetClassName(CLASSDEF_PTR poThis)
{
	return INSTDEF::GetClassName(poThis->m_poClassDef);
}

inline
wchar_t *CLASSDEF::GetSuperclassName(CLASSDEF_PTR poThis)
{
	if (poThis->m_poSuperclass)
		return CLASSDEF::GetClassName(poThis->m_poSuperclass);
	else
	{
		register wchar_t *wsz = new wchar_t[1];
		if (wsz)
			*wsz = L'\0';
		else
			throw CX_MemoryException();
		return wsz;
	}
}
inline
CLASSDEF *CLASSDEF::GetSuperclass(CLASSDEF_PTR poThis)
{
	return poThis->m_poSuperclass;
}

inline
CLASSDEF *CLASSDEF::AllocateObject()
{
	return (CLASSDEF *)g_pDbArena->Alloc(sizeof(CLASSDEF));
}

inline
int CLASSDEF::DeallocateObject(CLASSDEF_PTR poThis)
{
	return g_pDbArena->Free(poThis.GetDWORD_PTR());
}

inline
int DANGREF::Initialize(DANGREF_PTR poThis)
{
	return RepCollection::Initialize(poThis.GetOffset());
}

inline int DANGREF::Deinitialize(DANGREF_PTR poThis)
{
	return RepCollection::Deinitialize(poThis.GetOffset());
}

inline
DANGREF *DANGREF::AllocateObject()
{
	return (DANGREF *)g_pDbArena->Alloc(sizeof(DANGREF));
}

inline
int DANGREF::DeallocateObject(DANGREF_PTR poThis)
{
	return g_pDbArena->Free(poThis.GetDWORD_PTR());
}

inline
int DANGREFCLASS::Initialize(DANGREFCLASS_PTR poThis)
{
	return RepCollection::Initialize(poThis.GetOffset());
}

inline
int DANGREFCLASS::Deinitialize(DANGREFCLASS_PTR poThis)
{
	return RepCollection::Deinitialize(poThis.GetOffset());
}

inline
DANGREFCLASS *DANGREFCLASS::AllocateObject()
{
	return (DANGREFCLASS *)g_pDbArena->Alloc(sizeof(DANGREFCLASS));
}

inline
int DANGREFCLASS::DeallocateObject(DANGREFCLASS_PTR poThis)
{
	return g_pDbArena->Free(poThis.GetDWORD_PTR());
}

inline
int DANGREFKEY::Initialize(DANGREFKEY_PTR poThis)
{
	return RepCollection::Initialize(poThis.GetOffset());
}

inline
int DANGREFKEY::Deinitialize(DANGREFKEY_PTR poThis)
{
	return RepCollection::Deinitialize(poThis.GetOffset());
}

inline
DANGREFKEY *DANGREFKEY::AllocateObject()
{
	return (DANGREFKEY *)g_pDbArena->Alloc(sizeof(DANGREFKEY));
}

inline
int DANGREFKEY::DeallocateObject(DANGREFKEY_PTR poThis)
{
	return g_pDbArena->Free(poThis.GetDWORD_PTR());
}

inline
int DANGLREFSCHEMA::Initialize(DANGLREFSCHEMA_PTR poThis)
{
	return RepCollection::Initialize(poThis.GetOffset());
}

//Deinitialise the object and delete any objects it points to
inline
int DANGLREFSCHEMA::Deinitialize(DANGLREFSCHEMA_PTR poThis)
{
	return RepCollection::Deinitialize(poThis.GetOffset());
}

inline
DANGLREFSCHEMA *DANGLREFSCHEMA::AllocateObject()
{
	return (DANGLREFSCHEMA *)g_pDbArena->Alloc(sizeof(DANGLREFSCHEMA));
}

inline
int DANGLREFSCHEMA::DeallocateObject(DANGLREFSCHEMA_PTR poThis)
{
	return g_pDbArena->Free(poThis.GetDWORD_PTR());
}

inline
int DANGREFSCHEMA::Initialize(DANGREFSCHEMA_PTR poThis)
{
	return RepCollection::Initialize(poThis.GetOffset());
}

inline
int DANGREFSCHEMA::Deinitialize(DANGREFSCHEMA_PTR poThis)
{
	return RepCollection::Deinitialize(poThis.GetOffset());
}

inline
DANGREFSCHEMA *DANGREFSCHEMA::AllocateObject()
{
	return (DANGREFSCHEMA *)g_pDbArena->Alloc(sizeof(DANGREFSCHEMA));
}

inline
int DANGREFSCHEMA::DeallocateObject(DANGREFSCHEMA_PTR poThis)
{
	return g_pDbArena->Free(poThis.GetDWORD_PTR());
}

inline
int DANGREFSCHEMACLASS::Initialize(DANGREFSCHEMACLASS_PTR poThis)
{
	return RepCollection::Initialize(poThis.GetOffset());
}

inline
int DANGREFSCHEMACLASS::Deinitialize(DANGREFSCHEMACLASS_PTR poThis)
{
	return RepCollection::Deinitialize(poThis.GetOffset());
}

inline
DANGREFSCHEMACLASS *DANGREFSCHEMACLASS::AllocateObject()
{
	return (DANGREFSCHEMACLASS *)g_pDbArena->Alloc(sizeof(DANGREFSCHEMACLASS));
}

inline
int DANGREFSCHEMACLASS::DeallocateObject(DANGREFSCHEMACLASS_PTR poThis)
{
	return g_pDbArena->Free(poThis.GetDWORD_PTR());
}

inline
DBROOT *DBROOT::AllocateObject()
{
	return (DBROOT *)g_pDbArena->Alloc(sizeof(DBROOT));
}

inline
int DBROOT::DeallocateObject(DBROOT_PTR poThis)
{
	return g_pDbArena->Free(poThis.GetDWORD_PTR());
}

inline
int SINDEXTABLE::Initialize(SINDEXTABLE_PTR poThis)
{
	memset(poThis.GetPtr(), 0, sizeof(SINDEXTABLE));
	return 0;
}

inline
SINDEXTABLE *SINDEXTABLE::AllocateObject()
{
	return (SINDEXTABLE *)g_pDbArena->Alloc(sizeof(SINDEXTABLE));
}

inline
int SINDEXTABLE::DeallocateObject(SINDEXTABLE_PTR poThis)
{
	return g_pDbArena->Free(poThis.GetDWORD_PTR());
}

#endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\setup\bin\wbemupgradedll\exportv1.cpp ===
/*++

Copyright (C) 1996-2000 Microsoft Corporation

Module Name:

    EXPORTV1.CPP

Abstract:

    Exporting

History:

--*/

#include "precomp.h"
#include "corepol.h"
#include "Export.h"

struct DBROOT;

void CRepExporterV1::DumpMMFHeader()
{
    DWORD_PTR*	pdwArena	= (DWORD_PTR*) Fixup((DWORD_PTR*)0);
    DBROOT*		pRootBlock	= (DBROOT*)pdwArena[9];

    DumpRootBlock(Fixup(pRootBlock));
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\setup\bin\wbemupgradedll\exportv5.cpp ===
/*++

Copyright (C) 1996-2000 Microsoft Corporation

Module Name:

    EXPORTV5.CPP

Abstract:

    Exporting

History:

--*/

#include "precomp.h"

#include "corepol.h"
#include "Export.h"

void CRepExporterV5::DumpMMFHeader()
{
    MMF_ARENA_HEADER *pMMFHeader = m_pDbArena->GetMMFHeader();
    DumpRootBlock(Fixup((DBROOT*)pMMFHeader->m_dwRootBlock));

}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\setup\bin\wbemupgradedll\export.h ===
/*++

Copyright (C) 1996-2000 Microsoft Corporation

Module Name:

    EXPORT.H

Abstract:

    Exporting

History:

--*/
#ifndef __export_h__
#define __export_h__

/*================================================================================
 *
 * EXPORT FILE FORMAT
 * ==================
 *
 * File Header Block:
 *		wchar_t wszFileHeader								= REP_EXPORT_FILE_START_TAG ("repexp2")
 *
 * Namespace Block:
 *		DWORD   dwObjectType								= REP_EXPORT_NAMESPACE_TAG (0x00000001)
 *		DWORD   dwNamespaceNameSize
 *		wchar_t wszNamespaceName[dwNamespaceNameSize]		= Full namespace name
 *															  (\root\default\fred)
 *
 * Class Block:
 *		DWORD   dwObjectType								= REP_EXPORT_CLASS_TAG (0x00000002)
 *		DWORD   dwClassNameSize
 *		wchar_t wszClassName[dwClassNameSize]				= Class name (my_class_name)
 *		DWORD   dwClassObjectSize
 *		DWORD	adwClassObject[dwClassObjectSize]
 *
 * Instance Block - key of type int:
 *		DWORD   dwObjectType								= REP_EXPORT_INST_INT_TAG (0x00000003)
 *		DWORD   dwInstanceKey
 *		DWORD	dwInstanceObjectSize
 *		DWORD	adwInstanceObject[dwInstanceObjectSize]
 *
 * Instance Block - key of type string
 *		DWORD	dwObjectType								= REP_EXPORT_INST_STR_TAG (0x00000004)
 *		DWORD	dwInstanceKeySize
 *		DWORD	dwInstanceKey[dwInstanceKeySize]			= Instance key (MyKeyValue)
 *		DWORD	dwInstanceObjectSize
 *		DWORD	adwInstanceObject[dwInstanceObjectSize]
 *		
 * End of class block
 *		DWORD	dwObjectType								= REP_EXPORT_CLASS_END_TAG (0x00000005)
 *		DWORD	dwEndOfBlockSize							= REP_EXPORT_END_TAG_SIZE (0x00000010)
 *		DWORD	adwEndOfBlock[dwEndOfBlockSize]				= REP_EXPORT_END_TAG_MARKER * 16
 *															  (0xFF, 0xFF, 0xFF, 0xFF,
 *															   0xFF, 0xFF, 0xFF, 0xFF,
 *															   0xFF, 0xFF, 0xFF, 0xFF,
 *															   0xFF, 0xFF, 0xFF, 0xFF)
 *
 * End of namespace block
 *		DWORD	dwObjectType								= REP_EXPORT_NAMESPACE_END_TAG (0x00000006)
 *		DWORD	dwEndOfBlockSize							= REP_EXPORT_END_TAG_SIZE (0x00000010)
 *		DWORD	adwEndOfBlock[dwEndOfBlockSize]				= REP_EXPORT_END_TAG_MARKER * 16
 *															  (0xFF, 0xFF, 0xFF, 0xFF,
 *															   0xFF, 0xFF, 0xFF, 0xFF,
 *															   0xFF, 0xFF, 0xFF, 0xFF,
 *															   0xFF, 0xFF, 0xFF, 0xFF)
 *
 * Namespace security block
 *		DWORD	dwObjectType								= REP_EXPORT_NAMESPACE_SEC_TAG (0x00000007)
 *		DWORD	dwSecurityBlobSize
 *		DWORD	dwSecurityBlob[dwSecurityBlobSize]			= Security blob
 *		
 * End of file block
 *		DWORD	dwObjectType								= REP_EXPORT_FILE_END_TAG (0xFFFFFFFF)
 *		DWORD	dwEndOfBlockSize							= REP_EXPORT_END_TAG_SIZE (0x00000010)
 *		DWORD	adwEndOfBlock[dwEndOfBlockSize]				= REP_EXPORT_END_TAG_MARKER * 16
 *															  (0xFF, 0xFF, 0xFF, 0xFF,
 *															   0xFF, 0xFF, 0xFF, 0xFF,
 *															   0xFF, 0xFF, 0xFF, 0xFF,
 *															   0xFF, 0xFF, 0xFF, 0xFF)
 *
 * Ordering:
 *		File Header Block
 *			(one or more)
 *			Namespace Block
 *              Namespace security block
 *				(zero or more)
 *				{
 *					Namespace Block
 *	                  Namespace security block
 *						etc...
 *					End namespace block
 *					(or)
 *					Class Block
 *						(zero or more)
 *						{
 *							Instance Block
 *							(or)
 *							Class Block
 *								etc...
 *							End class block
 *						}
 *					End class block
 *				}
 *			End namespace block
 *		End of file block
 *
 *================================================================================
 */


#define FAILURE_DIRTY 1
#define FAILURE_WRITE 2

#define REP_EXPORT_FILE_START_TAG	 "repexp3"
#define REP_EXPORT_NAMESPACE_TAG	 0x00000001
#define REP_EXPORT_CLASS_TAG		 0x00000002
#define REP_EXPORT_INST_INT_TAG		 0x00000003
#define REP_EXPORT_INST_STR_TAG		 0x00000004
#define REP_EXPORT_CLASS_END_TAG	 0x00000005
#define REP_EXPORT_NAMESPACE_END_TAG 0x00000006
#define REP_EXPORT_NAMESPACE_SEC_TAG 0x00000007
#define REP_EXPORT_FILE_END_TAG		 0xFFFFFFFF

#define REP_EXPORT_END_TAG_SIZE		 0x00000010
#define REP_EXPORT_END_TAG_MARKER	 0xFF

#include "MMFArena2.h"

class CDbAvlTree;
struct DBROOT;
struct NSREP;
struct INSTDEF;
struct CLASSDEF;
struct AVLNode;
struct RepCollection;

class CRepExporter
{
protected:
	CMMFArena2 *m_pDbArena;
	HANDLE g_hFile;

	virtual void DumpInstanceString(INSTDEF* pInstDef, const wchar_t *wszKey, const wchar_t *pszClass);
	virtual void DumpInstanceInt(INSTDEF* pInstDef, INT_PTR nKey, const wchar_t *pszClass);
	virtual void IterateKeyTree(const wchar_t *wszClassName, CLASSDEF *pOwningClass, AVLNode *pInstNode, BOOL bStringKey);
	virtual void DumpClass(CLASSDEF* pClassDef, const wchar_t *wszClassName);
	virtual void IterateClassNodes(AVLNode *pClassNode, CLASSDEF *poParentClass);
	virtual void IterateChildNamespaceTree(AVLNode *pNsNode);
	virtual void IterateChildNamespaces(RepCollection *childNamespaces);
	virtual void DumpNamespace(NSREP *pNsRep);
	virtual void DumpNamespaceSecurity(NSREP *pNsRep);
	virtual void DumpRootBlock(DBROOT *pRootBlock);
	virtual void DumpMMFHeader();

	virtual DWORD GetMMFBlockOverhead() = 0;
	virtual int GetAvlTreeNodeType(CDbAvlTree *pTree) = 0;

public:
	virtual int Export(CMMFArena2 *pDbArena, const TCHAR *pszFilename);
	CRepExporter(){}
	virtual ~CRepExporter() {};
};

class  CRepExporterV1 : public CRepExporter
{
protected:
	//This is different from the standard base-class definition!
	DWORD GetMMFBlockOverhead() { return sizeof(MMF_BLOCK_HEADER); }
	virtual int GetAvlTreeNodeType(CDbAvlTree *pTree) { return ((int*)pTree)[1]; }
	void DumpMMFHeader();
};

class  CRepExporterV5 : public CRepExporterV1
{
protected:
	//This works in the same way as the standard base-class definition!
	virtual DWORD GetMMFBlockOverhead() { return (sizeof(MMF_BLOCK_HEADER) + sizeof(MMF_BLOCK_TRAILER)); }
	void DumpMMFHeader();
};

class  CRepExporterV7 : public CRepExporterV5
{
protected:
	//This is different from the standard base-class definition!
	int GetAvlTreeNodeType(CDbAvlTree *pTree) { return ((int*)pTree)[3]; }
};

class  CRepExporterV9 : public CRepExporterV7
{
protected:
	void DumpNamespaceSecurity(NSREP *pNsRep);
};
#endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\setup\bin\wbemupgradedll\exportv9.cpp ===
/*++

Copyright (C) 1996-2000 Microsoft Corporation

Module Name:

    EXPORTV9.CPP

Abstract:

    Exporting

History:

--*/

#include "precomp.h"
#include "Time.h"
#include "WbemCli.h"
#include "DbRep.h"
#include "Export.h"
#include "WbemUtil.h"


void CRepExporterV9::DumpNamespaceSecurity(NSREP *pNsRep)
{
    //Default version does not have a security descriptor, so we need to
    //just dump a blank entry.
    DWORD dwSize = 0;
    DWORD dwBuffer[2];
    dwBuffer[0] = REP_EXPORT_NAMESPACE_SEC_TAG;
    if (pNsRep->m_poSecurity)
        dwBuffer[1] = g_pDbArena->Size(pNsRep->m_poSecurity);
    else
        dwBuffer[1] = 0;

    if ((WriteFile(g_hFile, dwBuffer, 8, &dwSize, NULL) == 0) || (dwSize != 8))
    {
        DEBUGTRACE((LOG_WBEMCORE, "Failed to write namespace security header, %S.\n", Fixup(pNsRep->m_poName)));
        throw FAILURE_WRITE;
    }

    if (dwBuffer[1] != 0)
    {
        if ((WriteFile(g_hFile, (void*)Fixup(pNsRep->m_poSecurity), dwBuffer[1], &dwSize, NULL) == 0) || (dwSize != dwBuffer[1]))
        {
            DEBUGTRACE((LOG_WBEMCORE, "Failed to write namespace security block, %S.\n", Fixup(pNsRep->m_poName)));
            throw FAILURE_WRITE;
        }
    }
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\setup\bin\wbemupgradedll\import.cpp ===
/*++

Copyright (C) 1996-2000 Microsoft Corporation

Module Name:

    IMPORT.CPP

Abstract:

History:

--*/

#include "precomp.h"
#include <StdIo.h>
#include <ConIo.h>
#include <WbemUtil.h>
#include <corex.h>
#include "upgrade.h"
#include "Import.h"
#include "export.h"
#include "reg.h"

template <class T> class CMyRelMe
{
    T m_p;
    public:
        CMyRelMe(T p) : m_p(p) {};
        ~CMyRelMe() { if (m_p) m_p->Release(); }
        void Set(T p) { m_p = p; }
};

class CSysFreeMe
{
protected:
    BSTR m_str;

public:
    CSysFreeMe(BSTR str) : m_str(str){}
    ~CSysFreeMe() {SysFreeString(m_str);}
};

bool CRepImporter::CheckOldSecurityClass(const wchar_t* wszClass)
{
	// check whether it is an old security class
	bool bOldSecurityClass = false;
	if(m_bSecurityMode)
	{
		if(!_wcsicmp(wszClass, L"__SecurityRelatedClass"))
			bOldSecurityClass = true;
		else if(!_wcsicmp(wszClass, L"__Subject"))
			bOldSecurityClass = true;
		else if(!_wcsicmp(wszClass, L"__User"))
			bOldSecurityClass = true;
		else if(!_wcsicmp(wszClass, L"__NTLMUser"))
			bOldSecurityClass = true;
		else if(!_wcsicmp(wszClass, L"__Group"))
			bOldSecurityClass = true;
		else if(!_wcsicmp(wszClass, L"__NTLMGroup"))
			bOldSecurityClass = true;
	}
	return bOldSecurityClass;
}

void CRepImporter::DecodeTrailer()
{
    DWORD dwTrailerSize = 0;
    DWORD dwTrailer[4];
    DWORD dwSize = 0;
    if ((ReadFile(m_hFile, &dwTrailerSize, 4, &dwSize, NULL) == 0) || (dwSize != 4))
    {
		LogMessage(MSG_ERROR, "Failed to read a block trailer size.");
        throw FAILURE_READ;
    }
    if (dwTrailerSize != REP_EXPORT_END_TAG_SIZE)
    {
		LogMessage(MSG_ERROR, "Block trailer size is invalid.");
        throw FAILURE_INVALID_TRAILER;
    }
    if ((ReadFile(m_hFile, dwTrailer, REP_EXPORT_END_TAG_SIZE, &dwSize, NULL) == 0) || (dwSize != REP_EXPORT_END_TAG_SIZE))
    {
		LogMessage(MSG_ERROR, "Failed to read a block trailer.");
        throw FAILURE_READ;
    }
    for (int i = 0; i < 4; i++)
    {
        if (dwTrailer[i] != REP_EXPORT_FILE_END_TAG)
        {
			LogMessage(MSG_ERROR, "Block trailer has invalid contents.");
            throw FAILURE_INVALID_TRAILER;
        }
    }

}

void CRepImporter::DecodeInstanceInt(IWbemServices* pNamespace, const wchar_t *wszFullPath, const wchar_t *pszParentClass, _IWmiObject* pOldParentClass, _IWmiObject *pNewParentClass)
{
	char szMsg[MAX_MSG_TEXT_LENGTH];

    //Read the key and object size
    INT_PTR dwKey = 0;
    DWORD dwSize = 0;
    if ((ReadFile(m_hFile, &dwKey, sizeof(INT_PTR), &dwSize, NULL) == 0) || (dwSize != sizeof(INT_PTR)))
    {
		_snprintf(szMsg, MAX_MSG_TEXT_LENGTH - 1, "Failed to retrieve instance key for class %S. (i)", pszParentClass);
		LogMessage(MSG_ERROR, szMsg);
        throw FAILURE_READ;
    }

    DWORD dwHeader;
    if ((ReadFile(m_hFile, &dwHeader, 4, &dwSize, NULL) == 0) || (dwSize != 4))
    {
		_snprintf(szMsg, MAX_MSG_TEXT_LENGTH - 1, "Failed to retrieve instance object size for class %S. (i)", pszParentClass);
		LogMessage(MSG_ERROR, szMsg);
        throw FAILURE_READ;
    }

    char *pObjectBlob = new char[dwHeader];
    if (pObjectBlob == 0)
    {
        throw FAILURE_OUT_OF_MEMORY;
    }
    CVectorDeleteMe<char> delMe(pObjectBlob);

    //Read the blob
    if ((ReadFile(m_hFile, pObjectBlob, dwHeader, &dwSize, NULL) == 0) || (dwSize != dwHeader))
    {
		_snprintf(szMsg, MAX_MSG_TEXT_LENGTH - 1, "Failed to retrieve instance information for class %S. (i)", pszParentClass);
		LogMessage(MSG_ERROR, szMsg);
        throw FAILURE_READ;
    }

    if (pNewParentClass == (_IWmiObject*)-1)
    {
        //We are working with a class which has problems... we need to ignore this instance...
        return;
    }

	// create old Nova-style instance
	HRESULT hr;
    _IWmiObject* pOldInstance = 0;
    CMyRelMe<_IWmiObject*> relMe(pOldInstance);
    _IWmiObject* pNewInstance = 0;
    CMyRelMe<_IWmiObject*> relMe2(pNewInstance);

	hr = pOldParentClass->Merge(WMIOBJECT_MERGE_FLAG_INSTANCE, dwSize, pObjectBlob, &pOldInstance);
	if (FAILED(hr))
	{
		_snprintf(szMsg, MAX_MSG_TEXT_LENGTH - 1, "Unable to merge old instance (i); HRESULT = %#lx", hr);
		LogMessage(MSG_ERROR, szMsg);
		throw FAILURE_CANNOT_MERGE_INSTANCE;
	}
	if (pOldInstance == 0)
	{
		throw FAILURE_OUT_OF_MEMORY;
	}
	relMe.Set(pOldInstance);

	// put the new instance into the repository
	hr = pNamespace->PutInstance(pOldInstance, WBEM_FLAG_CREATE_OR_UPDATE, NULL, NULL);
	if (FAILED(hr))
	{

		// Original put failed, so we will try to upgrade the instance and retry the put
		// upgrade to new Whistler instance
		hr = pOldInstance->Upgrade(pNewParentClass, 0L, &pNewInstance);
		if (FAILED(hr))
		{
			_snprintf(szMsg, MAX_MSG_TEXT_LENGTH - 1, "Unable to upgrade to new instance (i); HRESULT = %#lx", hr);
			LogMessage(MSG_ERROR, szMsg);
			throw FAILURE_CANNOT_UPGRADE_INSTANCE;
		}
		if (pNewInstance == 0)
		{
			throw FAILURE_OUT_OF_MEMORY;
		}
		relMe2.Set(pNewInstance);

		hr = pNamespace->PutInstance(pNewInstance, WBEM_FLAG_CREATE_OR_UPDATE, NULL, NULL);

		if ( FAILED(hr))
		{
			if (!CheckOldSecurityClass(pszParentClass))
			{
				_snprintf(szMsg, MAX_MSG_TEXT_LENGTH - 1, "Failed to create instance %S.%d in repository. (i); HRESULT = %#lx", pszParentClass, dwKey, hr);
				LogMessage(MSG_ERROR, szMsg);
				throw FAILURE_CANNOT_CREATE_INSTANCE;
			}
			else
			{
				// This is an old Win9x security class, but it can't be put yet because the win9x users haven't been migrated at this point in setup.
				// Instead, write it out to the win9x security blob file so it can be processed later after setup is completed
				if (!AppendWin9xBlobFile(wszFullPath, pszParentClass, pNewInstance))
				{
					_snprintf(szMsg, MAX_MSG_TEXT_LENGTH - 1, "Unable to write Win9x security class to file for instance %S.%d", pszParentClass, dwKey);
					LogMessage(MSG_ERROR, szMsg);
				}
			}
		}

	}
}

void CRepImporter::DecodeInstanceString(IWbemServices* pNamespace, const wchar_t *wszFullPath, const wchar_t *pszParentClass, _IWmiObject* pOldParentClass, _IWmiObject *pNewParentClass)
{
	char szMsg[MAX_MSG_TEXT_LENGTH];

    //Read the key and object size
    DWORD dwKeySize;
    DWORD dwSize = 0;
    if ((ReadFile(m_hFile, &dwKeySize, 4, &dwSize, NULL) == 0) || (dwSize != 4))
    {
		_snprintf(szMsg, MAX_MSG_TEXT_LENGTH - 1, "Failed to retrieve instance key size for class %S. (s)", pszParentClass);
		LogMessage(MSG_ERROR, szMsg);
        throw FAILURE_READ;
    }

    wchar_t *wszKey = new wchar_t[dwKeySize];
    if (wszKey == NULL)
    {
        throw FAILURE_OUT_OF_MEMORY;
    }
    CVectorDeleteMe<wchar_t> delMe(wszKey);
    if ((ReadFile(m_hFile, wszKey, dwKeySize, &dwSize, NULL) == 0) || (dwSize != dwKeySize))
    {
		_snprintf(szMsg, MAX_MSG_TEXT_LENGTH - 1, "Failed to retrieve instance key for class %S. (s)", pszParentClass);
		LogMessage(MSG_ERROR, szMsg);
        throw FAILURE_READ;
    }

    DWORD dwBlobSize;
    if ((ReadFile(m_hFile, &dwBlobSize, 4, &dwSize, NULL) == 0) || (dwSize != 4))
    {
		_snprintf(szMsg, MAX_MSG_TEXT_LENGTH - 1, "Failed to retrieve instance object size for %S.%S from import file. (s)", pszParentClass, wszKey);
		LogMessage(MSG_ERROR, szMsg);
        throw FAILURE_READ;
    }

    char *pObjectBlob = new char[dwBlobSize];
    if (pObjectBlob == NULL)
    {
        throw FAILURE_OUT_OF_MEMORY;
    }
    CVectorDeleteMe<char> delMe2(pObjectBlob);

    //Read the blob
    if ((ReadFile(m_hFile, pObjectBlob, dwBlobSize, &dwSize, NULL) == 0) || (dwSize != dwBlobSize))
    {
		_snprintf(szMsg, MAX_MSG_TEXT_LENGTH - 1, "Failed to retrieve instance %S.%S from import file. (s)", pszParentClass, wszKey);
		LogMessage(MSG_ERROR, szMsg);
        throw FAILURE_READ;
    }

    if (pNewParentClass == (_IWmiObject*)-1)
    {
        //We are working with a class which has problems... we need to ignore this instance...
        return;
    }

	// create old Nova-style instance
	HRESULT hr;
    _IWmiObject* pOldInstance = 0;
    CMyRelMe<_IWmiObject*> relMe(pOldInstance);
    _IWmiObject* pNewInstance = 0;
    CMyRelMe<_IWmiObject*> relMe2(pNewInstance);

	hr = pOldParentClass->Merge(WMIOBJECT_MERGE_FLAG_INSTANCE, dwSize, pObjectBlob, &pOldInstance);
	if (FAILED(hr))
	{
		_snprintf(szMsg, MAX_MSG_TEXT_LENGTH - 1, "Unable to merge old instance (s); HRESULT = %#lx", hr);
		LogMessage(MSG_ERROR, szMsg);
		throw FAILURE_CANNOT_MERGE_INSTANCE;
	}
	if (pOldInstance == 0)
	{
		throw FAILURE_OUT_OF_MEMORY;
	}
	relMe.Set(pOldInstance);

	// put the instance into the repository
	// if this fails, upgrade and retry
	hr = pNamespace->PutInstance(pOldInstance, WBEM_FLAG_CREATE_OR_UPDATE, NULL, NULL);
	if (FAILED(hr))
	{

		// upgrade to new Whistler instance
		hr = pOldInstance->Upgrade(pNewParentClass, 0L, &pNewInstance);
		if (FAILED(hr))
		{
			_snprintf(szMsg, MAX_MSG_TEXT_LENGTH - 1, "Unable to upgrade to new instance (s); HRESULT = %#lx", hr);
			LogMessage(MSG_ERROR, szMsg);
			throw FAILURE_CANNOT_UPGRADE_INSTANCE;
		}
		if (pNewInstance == 0)
		{
			throw FAILURE_OUT_OF_MEMORY;
		}
		relMe2.Set(pNewInstance);

		hr = pNamespace->PutInstance(pNewInstance, WBEM_FLAG_CREATE_OR_UPDATE, NULL, NULL);

		if ( FAILED(hr))
		{
			if (!CheckOldSecurityClass(pszParentClass))
			{
				_snprintf(szMsg, MAX_MSG_TEXT_LENGTH - 1, "Failed to create instance %S.%S in repository. (s); HRESULT = %#lx", pszParentClass, wszKey, hr);
				LogMessage(MSG_ERROR, szMsg);
				throw FAILURE_CANNOT_CREATE_INSTANCE;
			}
			else
			{
				// This is an old Win9x security class, but it can't be put yet because the win9x users haven't been migrated at this point in setup.
				// Instead, write it out to the win9x security blob file so it can be processed later after setup is completed
				if (!AppendWin9xBlobFile(wszFullPath, pszParentClass, pNewInstance))
				{
					_snprintf(szMsg, MAX_MSG_TEXT_LENGTH - 1, "Unable to write Win9x security class to file for instance %S.%S", pszParentClass, wszKey);
					LogMessage(MSG_ERROR, szMsg);
				}
			}
		}
	}
}

void CRepImporter::DecodeClass(IWbemServices* pNamespace, const wchar_t *wszFullPath, const wchar_t *wszParentClass, _IWmiObject* pOldParentClass, _IWmiObject *pNewParentClass)
{
	char szMsg[MAX_MSG_TEXT_LENGTH];

    //Read our current class from the file...
	HRESULT hr;
    DWORD dwClassSize = 0;
    DWORD dwSize = 0;
    _IWmiObject* pOldClass = 0;
    CMyRelMe<_IWmiObject*> relMe(pOldClass);
    _IWmiObject* pNewClass = 0;
    CMyRelMe<_IWmiObject*> relMe2(pNewClass);

    if ((ReadFile(m_hFile, &dwClassSize, 4, &dwSize, NULL) == 0) || (dwSize != 4))
    {
		_snprintf(szMsg, MAX_MSG_TEXT_LENGTH - 1, "Failed to retrieve class size for class with parent class %S.", wszParentClass);
		LogMessage(MSG_ERROR, szMsg);
        throw FAILURE_READ;
    }
    wchar_t *wszClass = new wchar_t[dwClassSize];
    if (wszClass == NULL)
    {
        throw FAILURE_OUT_OF_MEMORY;
    }
    CVectorDeleteMe<wchar_t> delMe(wszClass);
    if ((ReadFile(m_hFile, wszClass, dwClassSize, &dwSize, NULL) == 0) || (dwSize != dwClassSize))
    {
		_snprintf(szMsg, MAX_MSG_TEXT_LENGTH - 1, "Failed to retrieve class information for class with parent class %S.", wszParentClass);
		LogMessage(MSG_ERROR, szMsg);
        throw FAILURE_READ;
    }

    //Now we have the class blob...
    if ((ReadFile(m_hFile, &dwClassSize, 4, &dwSize, NULL) == 0) || (dwSize != 4))
    {
		_snprintf(szMsg, MAX_MSG_TEXT_LENGTH - 1, "Failed to retrieve class size for class %S.", wszClass);
		LogMessage(MSG_ERROR, szMsg);
        throw FAILURE_READ;
    }

    if (dwClassSize)
    {
        char *pClassBlob = new char[dwClassSize];
        if (pClassBlob == NULL)
        {
            throw FAILURE_OUT_OF_MEMORY;
        }
        CVectorDeleteMe<char> delMe2(pClassBlob);
        if ((ReadFile(m_hFile, pClassBlob, dwClassSize, &dwSize, NULL) == 0) || (dwSize != dwClassSize))
        {
			_snprintf(szMsg, MAX_MSG_TEXT_LENGTH - 1, "Failed to retrieve class information for class %S.", wszClass);
			LogMessage(MSG_ERROR, szMsg);
            throw FAILURE_READ;
        }

		if (pNewParentClass == (_IWmiObject*)-1)
		{
			// parent class was bad, so don't process this class
			pNewClass = (_IWmiObject*)-1;
		}
		else
		{
			// create old Nova-style class
			hr = pOldParentClass->Merge(WMIOBJECT_MERGE_FLAG_CLASS, dwSize, pClassBlob, &pOldClass);
			if (FAILED(hr))
			{
				_snprintf(szMsg, MAX_MSG_TEXT_LENGTH - 1, "Unable to merge old class; HRESULT = %#lx", hr);
				LogMessage(MSG_ERROR, szMsg);
				throw FAILURE_CANNOT_MERGE_CLASS;
			}
			if (pOldClass == 0)
			{
				throw FAILURE_OUT_OF_MEMORY;
			}
			relMe.Set(pOldClass);

			//If the class is a system class then we do not write it... it may have changed for starters,
			//but also we create all system classes when a new database/namespace is created...
			if (_wcsnicmp(wszClass, L"__", 2) != 0)
			{
				// put the class into the repository
				// if this fails, upgrade it and retry
				hr = pNamespace->PutClass(pOldClass, WBEM_FLAG_CREATE_OR_UPDATE | WBEM_FLAG_UPDATE_FORCE_MODE, NULL, NULL);
				if (FAILED(hr))
				{

					// upgrade to new Whistler class (note: pNewParentClass will be NULL for base classes)
					hr = pOldClass->Upgrade(pNewParentClass, 0L, &pNewClass);
					if (FAILED(hr))
					{
						_snprintf(szMsg, MAX_MSG_TEXT_LENGTH - 1, "Unable to upgrade to new class; HRESULT = %#lx", hr);
						LogMessage(MSG_ERROR, szMsg);
						throw FAILURE_CANNOT_UPGRADE_CLASS;
					}
					if (pNewClass == 0)
					{
						throw FAILURE_OUT_OF_MEMORY;
					}
					relMe2.Set(pNewClass);

					// retry the put
					hr = pNamespace->PutClass(pNewClass, WBEM_FLAG_CREATE_OR_UPDATE | WBEM_FLAG_UPDATE_FORCE_MODE, NULL, NULL);

					if ( FAILED(hr) )
					{
						_snprintf(szMsg, MAX_MSG_TEXT_LENGTH - 1, "Failed to create class for class %S; HRESULT = %#lx", wszClass, hr);
						LogMessage(MSG_ERROR, szMsg);
						throw FAILURE_CANNOT_CREATE_CLASS;
					}
				}
			}

			// We need to re-get the class as class comparisons may fail to see
			// that this class is in fact the same as the one in the database!
			if ( NULL != pNewClass )
			{
				pNewClass->Release();
				pNewClass = 0;
				relMe2.Set(NULL);
			}

			BSTR bstrClassName = SysAllocString(wszClass);
            if (!bstrClassName)
				throw FAILURE_OUT_OF_MEMORY;
        	CSysFreeMe fm(bstrClassName);
			hr = pNamespace->GetObject(bstrClassName, 0L, NULL, (IWbemClassObject**) &pNewClass, NULL);
			if (FAILED(hr))
			{
				if (_wcsnicmp(wszClass, L"__", 2) != 0)
				{
					_snprintf(szMsg, MAX_MSG_TEXT_LENGTH - 1, "Failed to retrieve class %S from the repository after creating it; HRESULT = %#lx", wszClass, hr);
					LogMessage(MSG_ERROR, szMsg);
					throw FAILURE_CANNOT_GET_PARENT_CLASS;
				}
				else
				{
					if (_wcsicmp(wszClass, L"__CIMOMIdentification") != 0) // we don't want to warn about failures to retrieve this class
					{
						// couldn't get the system class
						_snprintf(szMsg, MAX_MSG_TEXT_LENGTH - 1, "Failed to retrieve system class %S from the repository; HRESULT = %#lx", wszClass, hr);
						LogMessage(MSG_WARNING, szMsg);
					}

					// set pointer to -1 and continue processing file
					// old comment said: If this does not exist then it cannot be important!
					pNewClass = (_IWmiObject*)-1;
				}
			}
			else
				relMe2.Set(pNewClass);
		}
    }
    else
    {
		// This is a situation where we have a class in the export file,
		// but the size is zero, so we just get the class from the repository.

		// ***** So what do we do about pOldClass?  At this point it is NULL.        *****
		// ***** We need the old class to be able to upgrade child classes properly. *****

		if (pNewParentClass == (_IWmiObject*)-1)
		{
			// parent class was bad, so don't process this class
			pNewClass = (_IWmiObject*)-1;
		}
		else
		{
			// get the class from the repository
			BSTR bstrClassName = SysAllocString(wszClass);
            if (!bstrClassName)
				throw FAILURE_OUT_OF_MEMORY;
        	CSysFreeMe fm(bstrClassName);
			hr = pNamespace->GetObject(bstrClassName, 0L, NULL, (IWbemClassObject**) &pNewClass, NULL);
			if (FAILED(hr))
			{
				_snprintf(szMsg, MAX_MSG_TEXT_LENGTH - 1, "Failed to retrieve class %S from the repository; HRESULT = %#lx", wszClass, hr);
				LogMessage(MSG_ERROR, szMsg);
				throw FAILURE_CANNOT_GET_PARENT_CLASS;
			}
			relMe2.Set(pNewClass);
		}
    }

    //Now we iterate through all child classes and instances until we get an end of class marker...
    while (1)
    {
        DWORD dwType = 0;
        if ((ReadFile(m_hFile, &dwType, 4, &dwSize, NULL) == 0) || (dwSize != 4))
        {
			LogMessage(MSG_ERROR, "Failed to read next block type from import file.");
            throw FAILURE_READ;
        }
        if (dwType == REP_EXPORT_CLASS_TAG)
        {
            DecodeClass(pNamespace, wszFullPath, wszClass, pOldClass, pNewClass);
        }
        else if (dwType == REP_EXPORT_INST_INT_TAG)
        {
            DecodeInstanceInt(pNamespace, wszFullPath, wszClass, pOldClass, pNewClass);
        }
        else if (dwType == REP_EXPORT_INST_STR_TAG)
        {
            DecodeInstanceString(pNamespace, wszFullPath, wszClass, pOldClass, pNewClass);
        }
        else if (dwType == REP_EXPORT_CLASS_END_TAG)
        {
            //That's the end of this class...
            DecodeTrailer();
            break;
        }
        else
        {
			LogMessage(MSG_ERROR, "Next block type in import file is invalid.");
            throw FAILURE_INVALID_TYPE;
        }
    }
}

void CRepImporter::DecodeNamespace(IWbemServices* pParentNamespace, const wchar_t *wszParentNamespace)
{
	char szMsg[MAX_MSG_TEXT_LENGTH];

    //Read our current namespace from the file...
    DWORD dwNsSize = 0;
    DWORD dwSize = 0;
    if ((ReadFile(m_hFile, &dwNsSize, 4, &dwSize, NULL) == 0) || (dwSize != 4))
    {
		_snprintf(szMsg, MAX_MSG_TEXT_LENGTH - 1, "Failed to retrieve a namespace whose parent namespace is %S.", wszParentNamespace);
		LogMessage(MSG_ERROR, szMsg);
        throw FAILURE_READ;
    }
    wchar_t *wszNs = new wchar_t[dwNsSize];
    if (wszNs == NULL)
    {
        throw FAILURE_OUT_OF_MEMORY;
    }
    CVectorDeleteMe<wchar_t> delMe(wszNs);
    if ((ReadFile(m_hFile, wszNs, dwNsSize, &dwSize, NULL) == 0) || (dwSize != dwNsSize))
    {
		_snprintf(szMsg, MAX_MSG_TEXT_LENGTH - 1, "Failed to retrieve a namespace whose parent namespace is %S.", wszParentNamespace);
		LogMessage(MSG_ERROR, szMsg);
        throw FAILURE_READ;
    }
    if (wbem_wcsicmp(wszNs, L"security") == 0)
    {
        m_bSecurityMode = true;
    }

    wchar_t *wszFullPath = new wchar_t[wcslen(wszParentNamespace) + 1 + wcslen(wszNs) + 1];
    if (wszFullPath == NULL)
    {
        throw FAILURE_OUT_OF_MEMORY;
    }
    CVectorDeleteMe<wchar_t> delMe2(wszFullPath);
    wcscpy(wszFullPath, wszParentNamespace);
    if (wcslen(wszParentNamespace) != 0)
    {
        wcscat(wszFullPath, L"\\");
    }
    wcscat(wszFullPath, wszNs);

	// open the namespace
	IWbemServices* pNamespace = NULL;
	CMyRelMe<IWbemServices*> relMe2(pNamespace);
	HRESULT hr;

	if (pParentNamespace)
	{
		BSTR bstrNamespace = SysAllocString(wszNs);
        if (!bstrNamespace)
			throw FAILURE_OUT_OF_MEMORY;
       	CSysFreeMe fm(bstrNamespace);
		hr = pParentNamespace->OpenNamespace(bstrNamespace, WBEM_FLAG_CONNECT_REPOSITORY_ONLY, NULL, &pNamespace, NULL);
		if (FAILED(hr))
		{
			_snprintf(szMsg, MAX_MSG_TEXT_LENGTH - 1, "Failed to retrieve namespace %S from the repository; HRESULT = %#lx", wszFullPath, hr);
			LogMessage(MSG_ERROR, szMsg);
			throw FAILURE_CANNOT_FIND_NAMESPACE;
		}
	}
	else // special start case for root
	{
		IWbemLocator* pLocator = NULL;
		CMyRelMe<IWbemLocator*> relMe(pLocator);
		hr = CoCreateInstance(CLSID_WbemLocator, NULL, CLSCTX_ALL, IID_IWbemLocator, (void**) &pLocator);
		if(FAILED(hr))
		{
			_snprintf(szMsg, MAX_MSG_TEXT_LENGTH - 1, "Failed to create instance of IWbemLocator; HRESULT = %#lx", hr);
			LogMessage(MSG_ERROR, szMsg);
			throw FAILURE_CANNOT_CREATE_IWBEMLOCATOR;
		}
		else
		{
			relMe.Set(pLocator);
			BSTR bstrNamespace = SysAllocString(L"root");
            if (!bstrNamespace)
			    throw FAILURE_OUT_OF_MEMORY;
           	CSysFreeMe fm(bstrNamespace);
			hr = pLocator->ConnectServer(bstrNamespace, NULL, NULL, NULL, WBEM_FLAG_CONNECT_REPOSITORY_ONLY, NULL, NULL, &pNamespace);
			if (FAILED(hr))
			{
				_snprintf(szMsg, MAX_MSG_TEXT_LENGTH - 1, "Failed to connect server; HRESULT = %#lx", hr);
				LogMessage(MSG_ERROR, szMsg);
				throw FAILURE_CANNOT_CONNECT_SERVER;
			}
		}
	}

	if (pNamespace == NULL)
	{
		throw FAILURE_OUT_OF_MEMORY;
	}
	relMe2.Set(pNamespace);

    //Get and set the namespace security...
    DWORD dwBuffer[2];
    if ((ReadFile(m_hFile, dwBuffer, 8, &dwSize, NULL) == 0) || (dwSize != 8))
    {
		_snprintf(szMsg, MAX_MSG_TEXT_LENGTH - 1, "Failed to retrieve a namespace security header for namespace %S.", wszFullPath);
		LogMessage(MSG_ERROR, szMsg);
        throw FAILURE_READ;
    }
    if (dwBuffer[0] != REP_EXPORT_NAMESPACE_SEC_TAG)
    {
		LogMessage(MSG_ERROR, "Expecting a namespace security blob and did not find it.");
        throw FAILURE_INVALID_TYPE;
    }
    if (dwBuffer[1] != 0)
    {
        char *pNsSecurity = new char[dwBuffer[1]];
	    CVectorDeleteMe<char> delMe3(pNsSecurity);

        if (pNsSecurity == NULL)
        {
            throw FAILURE_OUT_OF_MEMORY;
        }
        if ((ReadFile(m_hFile, pNsSecurity, dwBuffer[1], &dwSize, NULL) == 0) || (dwSize != dwBuffer[1]))
        {
			_snprintf(szMsg, MAX_MSG_TEXT_LENGTH - 1, "Failed to retrieve a namespace security blob for namespace %S.", wszFullPath);
			LogMessage(MSG_ERROR, szMsg);
            throw FAILURE_READ;
        }

        // we have the security blob, now set the SECURITY_DESCRIPTOR property in the namespace
        DecodeNamespaceSecurity(pNamespace, pParentNamespace, pNsSecurity, dwBuffer[1], wszFullPath);
    }

	// create empty Nova-style class object for use in decoding base classes
	_IWmiObjectFactory* pObjFactory = NULL;
    CMyRelMe<_IWmiObjectFactory*> relMe3(pObjFactory);
	hr = CoCreateInstance(CLSID__WmiObjectFactory, NULL, CLSCTX_ALL, IID__IWmiObjectFactory, (void**) &pObjFactory);
	if(FAILED(hr))
	{
		_snprintf(szMsg, MAX_MSG_TEXT_LENGTH - 1, "Failed to create instance of IWmiObjectFactory; HRESULT = %#lx", hr);
		LogMessage(MSG_ERROR, szMsg);
		throw FAILURE_CANNOT_CREATE_OBJECTFACTORY;
	}
	if (pObjFactory == NULL)
	{
		throw FAILURE_OUT_OF_MEMORY;
	}
	relMe3.Set(pObjFactory);

	_IWmiObject* pBaseObject = NULL;
    CMyRelMe<_IWmiObject*> relMe4(pBaseObject);
	hr = pObjFactory->Create(NULL, 0L, CLSID__WbemEmptyClassObject, IID__IWmiObject, (void**) &pBaseObject);
	if(FAILED(hr))
	{
		_snprintf(szMsg, MAX_MSG_TEXT_LENGTH - 1, "Failed to create instance of IWmiObject; HRESULT = %#lx", hr);
		LogMessage(MSG_ERROR, szMsg);
		throw FAILURE_CANNOT_CREATE_IWMIOBJECT;
	}
	if (pBaseObject == NULL)
	{
		throw FAILURE_OUT_OF_MEMORY;
	}
	relMe4.Set(pBaseObject);

    //Now we need to iterate through the next set of blocks of namespace or class
    //until we get to an end of NS marker
    while (1)
    {
        DWORD dwType = 0;
        if ((ReadFile(m_hFile, &dwType, 4, &dwSize, NULL) == 0) || (dwSize != 4))
        {
			LogMessage(MSG_ERROR, "Failed to read next block type (namespace/class) from import file.");
            throw FAILURE_READ;
        }
        if (dwType == REP_EXPORT_NAMESPACE_TAG)
        {
            DecodeNamespace(pNamespace, wszFullPath);
        }
        else if (dwType == REP_EXPORT_CLASS_TAG)
        {
            DecodeClass(pNamespace, wszFullPath, L"", pBaseObject, NULL);
        }
        else if (dwType == REP_EXPORT_NAMESPACE_END_TAG)
        {
            //That's the end of this namespace...
            DecodeTrailer();
            break;
        }
        else
        {
			LogMessage(MSG_ERROR, "Next block type (namespace/class) in import file is invalid.");
            throw FAILURE_INVALID_TYPE;
        }
    }

    m_bSecurityMode = false;
}

void CRepImporter::DecodeNamespaceSecurity(IWbemServices* pNamespace, IWbemServices* pParentNamespace, const char* pNsSecurity, DWORD dwSize, const wchar_t* wszFullPath)
{
	char szMsg[MAX_MSG_TEXT_LENGTH];

	// determine whether we have an old Win9x pseudo-blob
	DWORD dwStoredAsNT = 0;
	if (pNsSecurity)
	{
		DWORD* pdwData = (DWORD*)pNsSecurity;
		DWORD dwBlobSize = *pdwData;
		pdwData++;
		DWORD dwVersion = *pdwData;
		if(dwVersion != 1 || dwBlobSize == 0 || dwBlobSize > 64000)
		{
			_snprintf(szMsg, MAX_MSG_TEXT_LENGTH - 1, "Invalid namespace security blob header for namespace %S.", wszFullPath);
			LogMessage(MSG_ERROR, szMsg);
			return;
		}

		pdwData++;
		dwStoredAsNT = *pdwData;
	}

	if (!dwStoredAsNT)
	{
		// Do not process Win9x security blobs, because Win9x users haven't been migrated over yet at this point in setup.
		// Instead, write them out to a file to be processed after setup is complete.

		if (!AppendWin9xBlobFile(wszFullPath, dwSize, pNsSecurity))
		{
			_snprintf(szMsg, MAX_MSG_TEXT_LENGTH - 1, "Unable to write Win9x security blob to file for namespace %S.", wszFullPath);
			LogMessage(MSG_ERROR, szMsg);
		}
		return;
	}

	// now transform the old security blob that consisted of a header and array of ACE's
	// into a proper Security Descriptor that can be stored in the property

	CNtSecurityDescriptor mmfNsSD;
	if (!TransformBlobToSD(pParentNamespace, pNsSecurity, dwStoredAsNT, mmfNsSD))
	{
		_snprintf(szMsg, MAX_MSG_TEXT_LENGTH - 1, "Failed to convert security blob to SD for namespace %S.", wszFullPath);
		LogMessage(MSG_ERROR, szMsg);
		return;
    }

    // now set the security
	if (!SetNamespaceSecurity(pNamespace, mmfNsSD))
	{
		_snprintf(szMsg, MAX_MSG_TEXT_LENGTH - 1, "Failed to set namespace security for namespace %S.", wszFullPath);
		LogMessage(MSG_ERROR, szMsg);
		return;
    }
}

void CRepImporter::Decode()
{
    char pszBuff[7];
    DWORD dwSize = 0;
    if ((ReadFile(m_hFile, pszBuff, 7, &dwSize, NULL) == 0) || (dwSize != 7))
    {
		LogMessage(MSG_ERROR, "Failed to retrieve the import file header information.");
        throw FAILURE_READ;
    }
    if (strncmp(pszBuff, REP_EXPORT_FILE_START_TAG, 7) != 0)
    {
		LogMessage(MSG_ERROR, "The import file specified is not an import file.");
        throw FAILURE_INVALID_FILE;
    }

    //We should have a tag for a namespace...
    DWORD dwType = 0;
    if ((ReadFile(m_hFile, &dwType, 4, &dwSize, NULL) == 0) || (dwSize != 4))
    {
		LogMessage(MSG_ERROR, "Failed to read next block type from import file.");
        throw FAILURE_READ;
    }
    if (dwType != REP_EXPORT_NAMESPACE_TAG)
    {
		LogMessage(MSG_ERROR, "Next block type in import file is invalid.");
        throw FAILURE_INVALID_TYPE;
    }
    DecodeNamespace(NULL, L"");

	// if we opened a Win9x security blob upgrade file, close it
	CloseWin9xBlobFile();

	// force ROOT\DEFAULT and ROOT\SECURITY namespaces to inherit their inheritable security settings
	ForceInherit();

    //Now we should have the file trailer
    if ((ReadFile(m_hFile, &dwType, 4, &dwSize, NULL) == 0) || (dwSize != 4))
    {
		LogMessage(MSG_ERROR, "Failed to read next block type (trailer) from import file.");
        throw FAILURE_READ;
    }
    if (dwType != REP_EXPORT_FILE_END_TAG)
    {
		LogMessage(MSG_ERROR, "Next block type (trailer) in import file is invalid.");
        throw FAILURE_INVALID_TYPE;
    }
    DecodeTrailer();
}

int CRepImporter::ImportRepository(const TCHAR *pszFromFile)
{
	LogMessage(MSG_INFO, "Beginning ImportRepository");

    int nRet = no_error;
    m_hFile = CreateFile(pszFromFile, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

    if (m_hFile != INVALID_HANDLE_VALUE)
    {
		try
		{
			Decode();
		}
		catch (CX_MemoryException)
		{
			LogMessage(MSG_ERROR, "Memory Exception.");
			nRet = out_of_memory;
		}
		catch (...)
		{
			LogMessage(MSG_ERROR, "Traversal of import file failed.");
			nRet = critical_error;
		}
        CloseHandle(m_hFile);
    }
    else
    {
		char szMsg[MAX_MSG_TEXT_LENGTH];
		_snprintf(szMsg, MAX_MSG_TEXT_LENGTH - 1, "Could not open the import file \"%s\" for reading.", pszFromFile);
		LogMessage(MSG_ERROR, szMsg);
        nRet = critical_error;
    }

    if (nRet == no_error)
		LogMessage(MSG_INFO, "ImportRepository completed successfully.");
	else
		LogMessage(MSG_ERROR, "ImportRepository failed to complete.");

    return nRet;
}

//***************************************************************************
//***************************************************************************
//
//  Helper functions for DecodeNamespaceSecurity
//
//***************************************************************************
//***************************************************************************

bool CRepImporter::TransformBlobToSD(IWbemServices* pParentNamespace, const char* pNsSecurity, DWORD dwStoredAsNT, CNtSecurityDescriptor& mmfNsSD)
{
	// now transform the old security blob that consisted of a header and array of ACE's
	// into a proper Security Descriptor that can be stored in the property

	// build up an ACL from our blob, if we have one
	CNtAcl acl;

	if (pNsSecurity)
	{
		DWORD* pdwData = (DWORD*) pNsSecurity;
		pdwData += 3;
		int iAceCount = (int)*pdwData;
		pdwData += 2;
		BYTE* pAceData = (BYTE*)pdwData;

		PGENERIC_ACE pAce = NULL;
		for (int iCnt = 0; iCnt < iAceCount; iCnt++)
		{
			pAce = (PGENERIC_ACE)pAceData;
			if (!pAce)
			{
				LogMessage(MSG_ERROR, "Failed to access GENERIC_ACE within security blob");
				return false;
			}

			CNtAce ace(pAce);
			if(ace.GetStatus() != 0)
			{
				LogMessage(MSG_ERROR, "Failed to construct CNtAce from GENERIC_ACE");
				return false;
			}

			acl.AddAce(&ace);
			if (acl.GetStatus() != 0)
			{
				LogMessage(MSG_ERROR, "Failed to add ACE to ACL");
				return false;
			}

			pAceData += ace.GetSize();
		}
	}

	// a real SD was constructed and passed in by reference, now set it up properly
	SetOwnerAndGroup(mmfNsSD);
	mmfNsSD.SetDacl(&acl);
	if (mmfNsSD.GetStatus() != 0)
	{
		LogMessage(MSG_ERROR, "Failed to convert namespace security blob to SD");
		return false;
	}

	// add in the parent's inheritable aces, if this is not ROOT
	if (pParentNamespace)
	{
		if (!GetParentsInheritableAces(pParentNamespace, mmfNsSD))
		{
			LogMessage(MSG_ERROR, "Failed to inherit parent's inheritable ACE's");
			return false;
		}
	}

	return true;
}

bool CRepImporter::SetNamespaceSecurity(IWbemServices* pNamespace, CNtSecurityDescriptor& mmfNsSD)
{
    // now set the security

	if (!pNamespace)
		return false;

    IWbemClassObject* pThisNamespace = NULL;
	BSTR bstrNamespace = SysAllocString(L"__thisnamespace=@");
    if (!bstrNamespace)
		throw FAILURE_OUT_OF_MEMORY;
   	CSysFreeMe fm(bstrNamespace);
	HRESULT hr = pNamespace->GetObject(bstrNamespace, 0, NULL, &pThisNamespace, NULL);
	if (FAILED(hr))
    {
		LogMessage(MSG_ERROR, "Failed to get singleton namespace object");
		return false;
    }
	CMyRelMe<IWbemClassObject*> relMe(pThisNamespace);

	//
	// Check to see if namespace contains any ALLOW or DENY ACEs for NETWORK/LOCAL SERVICE
	// If they do exist, we leave them as is, otherwise we want to add them to the SD.
	//
	if ( CheckNetworkLocalService ( mmfNsSD ) == false )
	{
		LogMessage(MSG_ERROR, "Failed to add NETWORK/LOCAL service ACEs");
		return false;
	}

	SAFEARRAY FAR* psa;
	SAFEARRAYBOUND rgsabound[1];
	rgsabound[0].lLbound = 0;
	rgsabound[0].cElements = mmfNsSD.GetSize();
	psa = SafeArrayCreate( VT_UI1, 1 , rgsabound );
	if (!psa)
		throw FAILURE_OUT_OF_MEMORY;

	char* pData = NULL;
	hr = SafeArrayAccessData(psa, (void HUGEP* FAR*)&pData);
	if (FAILED(hr))
	{
		LogMessage(MSG_ERROR, "Failed SafeArrayAccessData");
		return false;
	}
	memcpy(pData, mmfNsSD.GetPtr(), mmfNsSD.GetSize());
	hr = SafeArrayUnaccessData(psa);
	if (FAILED(hr))
	{
		LogMessage(MSG_ERROR, "Failed SafeArrayUnaccessData");
		return false;
	}
	pData = NULL;

	VARIANT var;
	var.vt = VT_UI1|VT_ARRAY;
	var.parray = psa;
	hr = pThisNamespace->Put(L"SECURITY_DESCRIPTOR" , 0, &var, 0);
	VariantClear(&var);
	if (FAILED(hr))
	{
		if (hr == WBEM_E_OUT_OF_MEMORY)
			throw FAILURE_OUT_OF_MEMORY;
		else
		{
			LogMessage(MSG_ERROR, "Failed to put SECURITY_DESCRIPTOR property");
			return false;
		}
	}

	hr = pNamespace->PutInstance(pThisNamespace, WBEM_FLAG_CREATE_OR_UPDATE, NULL, NULL);
	if (FAILED(hr))
	{
		if (hr == WBEM_E_OUT_OF_MEMORY)
			throw FAILURE_OUT_OF_MEMORY;
		else
		{
			LogMessage(MSG_ERROR, "Failed to put back singleton instance");
			return false;
		}
	}
	return true;
}

/*
    --------------------------------------------------------------------------
   |
   | Checks to see if the namespace had a previous ACE with NETWORK or LOCAL
   | service accounts. If so, it simply leaves them, otherwise, it adds a 
   | ACE with default settings for these accounts. The default settings are:
   | WBEM_ENABLE | WBEM_METHOD_EXECUTE | WBEM_WRITE_PROVIDER
   | The characteristics of the ACE is irrelevant. Only SID comparison applies.
   |
	--------------------------------------------------------------------------
*/
bool CRepImporter::CheckNetworkLocalService ( CNtSecurityDescriptor& mmfNsSD )
{
	DWORD dwAccessMaskNetworkLocalService = WBEM_ENABLE | WBEM_METHOD_EXECUTE | WBEM_WRITE_PROVIDER ;
	PSID pRawSid = NULL ;
	SID_IDENTIFIER_AUTHORITY id = SECURITY_NT_AUTHORITY;
	BOOL bStatus = TRUE ;
	BYTE flags = 0 ;

	CNtAcl* pAcl = mmfNsSD.GetDacl ( ) ;
	CDeleteMe<CNtAcl> AclDelete ( pAcl ) ;

    //
	// Start with NETWORK_SERVICE account
	//
	if(AllocateAndInitializeSid( &id, 1,
        SECURITY_NETWORK_SERVICE_RID,0,0,0,0,0,0,0,&pRawSid))
    {
        CNtSid SidNetworkService (pRawSid);
		FreeSid(pRawSid);
	
#if 0
// Just don't check 504554	
		BOOL bRet = pAcl->ContainsSid ( SidNetworkService, flags ) ;
		if ( ! bRet || ( bRet && ( flags & INHERIT_ONLY_ACE ) == INHERIT_ONLY_ACE ) )
#endif
		{
			CNtAce * pace = new CNtAce(dwAccessMaskNetworkLocalService, ACCESS_ALLOWED_ACE_TYPE,
													0, SidNetworkService );
			if ( NULL == pace )
			{
				bStatus = FALSE ;
			}
			else
			{
				CDeleteMe<CNtAce> dm(pace);
				pAcl->AddAce(pace);
			}
		}
	}

    //
	// Next, LOCAL_SERVICE account
	//
	if ( bStatus == TRUE )
	{
		pRawSid = NULL ;
		if(AllocateAndInitializeSid( &id, 1,
			SECURITY_LOCAL_SERVICE_RID,0,0,0,0,0,0,0,&pRawSid))
		{
			CNtSid SidLocalService (pRawSid);
			FreeSid(pRawSid);
		
#if 0
// Just don't check 504554	
	
			BOOL bRet = pAcl->ContainsSid ( SidLocalService , flags ) ;
			if ( ! bRet || ( bRet && ( flags & INHERIT_ONLY_ACE ) == INHERIT_ONLY_ACE ) )
#endif
			{
				CNtAce * pace = new CNtAce(dwAccessMaskNetworkLocalService, ACCESS_ALLOWED_ACE_TYPE,
														0, SidLocalService );
				if ( NULL == pace )
				{
					bStatus = FALSE ;
				}
				else
				{
					CDeleteMe<CNtAce> dm(pace);
					pAcl->AddAce(pace);
				}
			}
		}
	}
	if ( bStatus == TRUE )
	{
		mmfNsSD.SetDacl ( pAcl ) ;
	}
	return bStatus ? true : false ;
}

bool CRepImporter::AddDefaultRootAces(CNtAcl * pacl)
{
	if (!pacl)
		return false;

    PSID pRawSid;
    SID_IDENTIFIER_AUTHORITY id = SECURITY_NT_AUTHORITY;

    if(AllocateAndInitializeSid( &id, 2,
        SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS,
        0,0,0,0,0,0,&pRawSid))
    {
        CNtSid SidAdmin(pRawSid);
        FreeSid(pRawSid);
        DWORD dwMask = FULL_RIGHTS;
        CNtAce * pace = new CNtAce(dwMask, ACCESS_ALLOWED_ACE_TYPE, CONTAINER_INHERIT_ACE, SidAdmin);
		if ( NULL == pace )
			throw FAILURE_OUT_OF_MEMORY;

        CDeleteMe<CNtAce> dm(pace);
        pacl->AddAce(pace);
		if (pacl->GetStatus() != 0)
			return false;
    }

    SID_IDENTIFIER_AUTHORITY id2 = SECURITY_WORLD_SID_AUTHORITY;

    if(AllocateAndInitializeSid( &id2, 1,
        0,0,0,0,0,0,0,0,&pRawSid))
    {
        CNtSid SidUsers(pRawSid);
        FreeSid(pRawSid);
        DWORD dwMask = WBEM_ENABLE | WBEM_METHOD_EXECUTE | WBEM_WRITE_PROVIDER;
        CNtAce * pace = new CNtAce(dwMask, ACCESS_ALLOWED_ACE_TYPE, CONTAINER_INHERIT_ACE, SidUsers);
		if ( NULL == pace )
			throw FAILURE_OUT_OF_MEMORY;

        CDeleteMe<CNtAce> dm(pace);
        pacl->AddAce(pace);
		if (pacl->GetStatus() != 0)
			return false;
	}

	return true;
}

bool CRepImporter::GetParentsInheritableAces(IWbemServices* pParentNamespace, CNtSecurityDescriptor &sd)
{
	if (!pParentNamespace)
		return false;

    // Get the parent namespace's SD
	CNtSecurityDescriptor sdParent;
	if (!GetSDFromNamespace(pParentNamespace, sdParent))
		return false;

	// strip out the inherited aces so we have a consistent SD
	if (!StripOutInheritedAces(sd))
		return false;

    // Go through the parents dacl and add any inheritable aces to ours.
	if (!CopyInheritAces(sd, sdParent))
		return false;

	return true;
}

bool CRepImporter::GetSDFromNamespace(IWbemServices* pNamespace, CNtSecurityDescriptor& sd)
{
	if (!pNamespace)
		return false;

	// get the singleton object
    IWbemClassObject* pThisNamespace = NULL;
	BSTR bstrNamespace = SysAllocString(L"__thisnamespace=@");
    if (!bstrNamespace)
		throw FAILURE_OUT_OF_MEMORY;
   	CSysFreeMe fm(bstrNamespace);
	HRESULT hr = pNamespace->GetObject(bstrNamespace, 0, NULL, &pThisNamespace, NULL);
	if (FAILED(hr))
    {
		LogMessage(MSG_ERROR, "Failed to get singleton namespace object");
		return false;
    }
	CMyRelMe<IWbemClassObject*> relMe(pThisNamespace);

    // Get the security descriptor argument
    VARIANT var;
    VariantInit(&var);
    hr = pThisNamespace->Get(L"SECURITY_DESCRIPTOR", 0, &var, NULL, NULL);
    if (FAILED(hr))
    {
        VariantClear(&var);
		LogMessage(MSG_ERROR, "Failed to get SECURITY_DESCRIPTOR property");
		return false;
    }

    if(var.vt != (VT_ARRAY | VT_UI1))
    {
        VariantClear(&var);
		LogMessage(MSG_ERROR, "Failed to get SECURITY_DESCRIPTOR property due to incorrect variant type");
		return false;
    }

    SAFEARRAY* psa = var.parray;
    PSECURITY_DESCRIPTOR pSD;
    hr = SafeArrayAccessData(psa, (void HUGEP* FAR*)&pSD);
    if (FAILED(hr))
    {
        VariantClear(&var);
		LogMessage(MSG_ERROR, "GetSDFromNamespace failed SafeArrayAccessData");
		return false;
    }

    BOOL bValid = IsValidSecurityDescriptor(pSD);
    if (!bValid)
    {
        VariantClear(&var);
		LogMessage(MSG_ERROR, "GetSDFromNamespace retrieved an invalid security descriptor");
		return false;
    }

    CNtSecurityDescriptor sdNew(pSD);

    // Check to make sure the owner and group is not NULL!!!!
	CNtSid *pTmpSid = sdNew.GetOwner();
	if (pTmpSid == NULL)
	{
        LogMessage(MSG_ERROR, "Security descriptor was retrieved and it had no owner");
	}
	delete pTmpSid;

	pTmpSid = sdNew.GetGroup();
	if (pTmpSid == NULL)
	{
        LogMessage(MSG_ERROR, "Security descriptor was retrieved and it had no group");
	}
	delete pTmpSid;
	
	sd = sdNew;
    SafeArrayUnaccessData(psa);
    VariantClear(&var);
	return true;
}

bool CRepImporter::StripOutInheritedAces(CNtSecurityDescriptor &sd)
{
    // Get the DACL
    CNtAcl* pAcl;
    pAcl = sd.GetDacl();
    if(!pAcl)
        return false;
    CDeleteMe<CNtAcl> dm(pAcl);

    // enumerate through the aces
    DWORD dwNumAces = pAcl->GetNumAces();
    BOOL bChanged = FALSE;
    for(long nIndex = (long)dwNumAces-1; nIndex >= 0; nIndex--)
    {
        CNtAce *pAce = pAcl->GetAce(nIndex);
        if(pAce)
        {
            long lFlags = pAce->GetFlags();
            if(lFlags & INHERITED_ACE)
            {
                pAcl->DeleteAce(nIndex);
                bChanged = TRUE;
            }
        }
    }
    if(bChanged)
        sd.SetDacl(pAcl);
    return true;
}

bool CRepImporter::CopyInheritAces(CNtSecurityDescriptor& sd, CNtSecurityDescriptor& sdParent)
{
	// Get the acl list for both SDs

    CNtAcl * pacl = sd.GetDacl();
    if(pacl == NULL)
        return false;
    CDeleteMe<CNtAcl> dm0(pacl);

    CNtAcl * paclParent = sdParent.GetDacl();
    if(paclParent == NULL)
        return false;
    CDeleteMe<CNtAcl> dm1(paclParent);

	int iNumParent = paclParent->GetNumAces();
	for(int iCnt = 0; iCnt < iNumParent; iCnt++)
	{
	    CNtAce *pParentAce = paclParent->GetAce(iCnt);
        CDeleteMe<CNtAce> dm2(pParentAce);

		long lFlags = pParentAce->GetFlags();
		if(lFlags & CONTAINER_INHERIT_ACE)
		{

			if(lFlags & NO_PROPAGATE_INHERIT_ACE)
				lFlags ^= CONTAINER_INHERIT_ACE;
			lFlags |= INHERITED_ACE;

			// If this is an inherit only ace we need to clear this
			// in the children.
			// NT RAID: 161761		[marioh]
			if ( lFlags & INHERIT_ONLY_ACE )
				lFlags ^= INHERIT_ONLY_ACE;

			pParentAce->SetFlags(lFlags);
			pacl->AddAce(pParentAce);
		}
	}
	sd.SetDacl(pacl);
	return true;
}

BOOL CRepImporter::SetOwnerAndGroup(CNtSecurityDescriptor &sd)
{
    PSID pRawSid;
    BOOL bRet = FALSE;

    SID_IDENTIFIER_AUTHORITY id = SECURITY_NT_AUTHORITY;
    if(AllocateAndInitializeSid( &id, 2,
        SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS,
        0,0,0,0,0,0,&pRawSid))
    {
        CNtSid SidAdmins(pRawSid);
        bRet = sd.SetGroup(&SidAdmins);		// Access check doesn't really care what you put,
											// so long as you put something for the owner
        if(bRet)
            bRet = sd.SetOwner(&SidAdmins);
        FreeSid(pRawSid);
        return bRet;
    }
    return bRet;
}

void CRepImporter::ForceInherit()
{
	// force ROOT\DEFAULT and ROOT\SECURITY namespaces to inherit their inheritable security settings

	char szMsg[MAX_MSG_TEXT_LENGTH];

	IWbemLocator* pLocator = NULL;
	HRESULT hr = CoCreateInstance(CLSID_WbemLocator, NULL, CLSCTX_ALL, IID_IWbemLocator, (void**) &pLocator);
	if(FAILED(hr))
	{
		_snprintf(szMsg, MAX_MSG_TEXT_LENGTH - 1, "Failed to create instance of IWbemLocator; HRESULT = %#lx", hr);
		LogMessage(MSG_ERROR, szMsg);
		throw FAILURE_CANNOT_CREATE_IWBEMLOCATOR;
	}
	CMyRelMe<IWbemLocator*> relMe1(pLocator);

	IWbemServices* pRootNamespace = NULL;
	ConnectNamespace(pLocator, L"root", &pRootNamespace);
	CMyRelMe<IWbemServices*> relMe2(pRootNamespace);

	if (!InheritSecurity(pLocator, pRootNamespace, L"root\\default"))
		LogMessage(MSG_ERROR, "Failed to force inherit for root\\default");

	if (!InheritSecurity(pLocator, pRootNamespace, L"root\\security"))
		LogMessage(MSG_ERROR, "Failed to force inherit for root\\security");
}

bool CRepImporter::InheritSecurity(IWbemLocator* pLocator, IWbemServices* pRootNamespace, const wchar_t* wszNamespace)
{
	IWbemServices* pNamespace = NULL;
	ConnectNamespace(pLocator, wszNamespace, &pNamespace);
	CMyRelMe<IWbemServices*> relMe(pNamespace);

	CNtSecurityDescriptor sdNamespace;
	if (!GetSDFromNamespace(pNamespace, sdNamespace))
		return false;

	if (!GetParentsInheritableAces(pRootNamespace, sdNamespace))
		return false;

	if (!SetNamespaceSecurity(pNamespace, sdNamespace))
		return false;

	return true;
}

void CRepImporter::ConnectNamespace(IWbemLocator* pLocator, const wchar_t* wszNamespaceName, IWbemServices** ppNamespace)
{
	char szMsg[MAX_MSG_TEXT_LENGTH];

	// get the namespace
	BSTR bstrNamespace = SysAllocString(wszNamespaceName);
    if (!bstrNamespace)
		throw FAILURE_OUT_OF_MEMORY;
    CSysFreeMe fm(bstrNamespace);

	HRESULT hres = pLocator->ConnectServer(bstrNamespace, NULL, NULL, NULL, WBEM_FLAG_CONNECT_REPOSITORY_ONLY, NULL, NULL, ppNamespace);
	if (FAILED(hres))
	{
		_snprintf(szMsg, MAX_MSG_TEXT_LENGTH - 1, "Failed to connect server for namespace %S; HRESULT = %#lx", wszNamespaceName, hres);
		LogMessage(MSG_ERROR, szMsg);
		throw FAILURE_CANNOT_CONNECT_SERVER;
	}
	if (!*ppNamespace)
	{
		throw FAILURE_OUT_OF_MEMORY;
	}
}

//***************************************************************************
//***************************************************************************
//
//  Helper functions for Win9x security processing
//
//***************************************************************************
//***************************************************************************

bool CRepImporter::AppendWin9xBlobFile(const wchar_t* wszFullPath, DWORD dwBlobSize, const char* pNsSecurity)
{
	// check whether we need to create the blob file
	if (m_h9xBlobFile == INVALID_HANDLE_VALUE)
	{
		if (!CreateWin9xBlobFile())
			return false;
	}

	// write the blob header containing the type, namespace name size, and blob size to the file
	BLOB9X_SPACER header;
	header.dwSpacerType = BLOB9X_TYPE_SECURITY_BLOB;
	header.dwNamespaceNameSize = (wcslen(wszFullPath)+1)*sizeof(wchar_t);
	header.dwParentClassNameSize = 0;
	header.dwBlobSize = dwBlobSize;
	DWORD dwSize = 0;
	if (WriteFile(m_h9xBlobFile, &header, sizeof(header), &dwSize, NULL) && (dwSize == sizeof(header)))
	{
		// write the namespace name to the file
		dwSize = 0;
		if (WriteFile(m_h9xBlobFile, wszFullPath, header.dwNamespaceNameSize, &dwSize, NULL) && (dwSize == header.dwNamespaceNameSize))
		{
			// write the blob to the file
			dwSize = 0;
			if (WriteFile(m_h9xBlobFile, pNsSecurity, dwBlobSize, &dwSize, NULL) && (dwSize == dwBlobSize))
				return true;
		}
	}
	
	// if we failed to write to the file, something is wrong with the file, so close and delete it
	DeleteWin9xBlobFile();
	return false;
}

bool CRepImporter::AppendWin9xBlobFile(const wchar_t* wszFullPath, const wchar_t* wszParentClass, _IWmiObject* pInstance)
{
	// check whether we need to create the blob file
	if (m_h9xBlobFile == INVALID_HANDLE_VALUE)
	{
		if (!CreateWin9xBlobFile())
			return false;
	}

	//Get the size of the object
	DWORD dwObjPartLen = 0;
	HRESULT hRes = pInstance->Unmerge(0, 0, &dwObjPartLen, 0);

	//Allocate the size of the object
	BYTE *pObjPart = NULL;
	if (hRes == WBEM_E_BUFFER_TOO_SMALL)
	{
		hRes = WBEM_S_NO_ERROR;
		pObjPart = new BYTE[dwObjPartLen];
		if (pObjPart == NULL)
			hRes = WBEM_E_OUT_OF_MEMORY;
	}
	CVectorDeleteMe<BYTE> delMe(pObjPart);

	//retrieve the object blob
	if (SUCCEEDED(hRes))
	{
		DWORD dwLen;
		hRes = pInstance->Unmerge(0, dwObjPartLen, &dwLen, pObjPart);
	}
		
	if (SUCCEEDED(hRes))
	{
		// write the blob header containing the type, namespace name size, parent class name size, and blob size to the file
		BLOB9X_SPACER header;
		header.dwSpacerType = BLOB9X_TYPE_SECURITY_INSTANCE;
		header.dwNamespaceNameSize = (wcslen(wszFullPath)+1)*sizeof(wchar_t);
		header.dwParentClassNameSize = (wcslen(wszParentClass)+1)*sizeof(wchar_t);
		header.dwBlobSize = dwObjPartLen;
		DWORD dwSize = 0;
		if (WriteFile(m_h9xBlobFile, &header, sizeof(header), &dwSize, NULL) && (dwSize == sizeof(header)))
		{
			// write the namespace name to the file
			dwSize = 0;
			if (WriteFile(m_h9xBlobFile, wszFullPath, header.dwNamespaceNameSize, &dwSize, NULL) && (dwSize == header.dwNamespaceNameSize))
			{
				// write the parent class name to the file
				dwSize = 0;
				if (WriteFile(m_h9xBlobFile, wszParentClass, header.dwParentClassNameSize, &dwSize, NULL) && (dwSize == header.dwParentClassNameSize))
				{
					// write the blob to the file
					dwSize = 0;
					if (WriteFile(m_h9xBlobFile, pObjPart, dwObjPartLen, &dwSize, NULL) && (dwSize == dwObjPartLen))
						return true;
				}
			}
		}
	}
	
	// if we failed to write to the file, something is wrong with the file, so close and delete it
	DeleteWin9xBlobFile();
	return false;
}

bool CRepImporter::CreateWin9xBlobFile()
{
	// get the root directory of the repository
	wchar_t wszFilePath[MAX_PATH+1];
	if (!GetRepositoryDirectory(wszFilePath))
		return false;

	// append blob file name
	wcscat(wszFilePath, BLOB9X_FILENAME);

	// create a new file in which to store blob info
	m_h9xBlobFile = CreateFileW(wszFilePath, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
	if (m_h9xBlobFile == INVALID_HANDLE_VALUE)
		return false;

	// write the blob file header
	BLOB9X_HEADER header;
	strcpy(header.szSignature, BLOB9X_SIGNATURE);
	DWORD dwSize = 0;
	if (WriteFile(m_h9xBlobFile, &header, sizeof(header), &dwSize, NULL) && (dwSize == sizeof(header)))
		return true;

	// if we failed to write to the file we should close the handle and delete the file
	CloseHandle(m_h9xBlobFile);
	DeleteFileW(wszFilePath);
	m_h9xBlobFile = INVALID_HANDLE_VALUE;
	return false;
}

void CRepImporter::DeleteWin9xBlobFile()
{
	// close and invalidate the handle if necessary
	if (m_h9xBlobFile != INVALID_HANDLE_VALUE)
	{
		CloseHandle(m_h9xBlobFile);
		m_h9xBlobFile = INVALID_HANDLE_VALUE;
	}

	// delete the file
	wchar_t wszFilePath[MAX_PATH+1];
	if (GetRepositoryDirectory(wszFilePath))
	{
		wcscat(wszFilePath, BLOB9X_FILENAME);
		DeleteFileW(wszFilePath);
	}
}

bool CRepImporter::GetRepositoryDirectory(wchar_t wszRepositoryDirectory[MAX_PATH+1])
{
    HKEY hKey;
    if (RegOpenKeyExW(HKEY_LOCAL_MACHINE, L"SOFTWARE\\Microsoft\\WBEM\\CIMOM", 0, KEY_READ, &hKey))
        return false;

    wchar_t wszTmp[MAX_PATH + 1];
    DWORD dwLen = MAX_PATH + 1;
    long lRes = RegQueryValueExW(hKey, L"Repository Directory", NULL, NULL, (LPBYTE)wszTmp, &dwLen);
	RegCloseKey(hKey);
    if(lRes)
        return false;

	if (ExpandEnvironmentStringsW(wszTmp,wszRepositoryDirectory, MAX_PATH + 1) == 0)
		return false;

	return true;
}

bool CRepImporter::CloseWin9xBlobFile()
{
	// if no valid handle, then we don't have a file to close, return success
	if (m_h9xBlobFile == INVALID_HANDLE_VALUE)
		return true;

	// write the end of blob file marker
	BLOB9X_SPACER trailer;
	trailer.dwSpacerType = BLOB9X_TYPE_END_OF_FILE;
	trailer.dwNamespaceNameSize = 0;
	trailer.dwParentClassNameSize = 0;
	trailer.dwBlobSize = 0;
	DWORD dwSize = 0;
	if ((WriteFile(m_h9xBlobFile, &trailer, sizeof(trailer), &dwSize, NULL) == 0) || (dwSize != sizeof(trailer)))
	{
		// if we failed to write the trailer, something is wrong with the file, so close and delete it
		DeleteWin9xBlobFile();
		return false;
	}

	CloseHandle(m_h9xBlobFile);
	m_h9xBlobFile = INVALID_HANDLE_VALUE;
	return true;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

extern HRESULT Traverse ( 

	IWbemServices *a_Service ,
	BSTR a_Namespace
) ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

PSID g_NetworkServiceSid = NULL ;
PSID g_LocalServiceSid = NULL ;

ACCESS_ALLOWED_ACE *g_NetworkService_Ace = NULL ;
WORD g_NetworkService_AceSize = 0 ;

ACCESS_ALLOWED_ACE *g_LocalService_Ace = NULL ;
WORD g_LocalService_AceSize = 0 ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT TraverseSetSecurity ( IWbemServices *a_Service ) 
{
	IClientSecurity *t_Security = NULL ;
	HRESULT t_Result = a_Service->QueryInterface ( IID_IClientSecurity , ( void ** ) & t_Security ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = t_Security->SetBlanket ( 

			a_Service , 
			RPC_C_AUTHN_DEFAULT, 
			RPC_C_AUTHZ_DEFAULT, 
			NULL,
			RPC_C_AUTHN_LEVEL_DEFAULT , 
			RPC_C_IMP_LEVEL_IDENTIFY, 
			NULL,
			EOAC_NONE
		) ;

		t_Security->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT InsertServiceAccess (

	SAFEARRAY *a_Array ,
	SAFEARRAY *&a_NewArray
)
{
	HRESULT t_Result = S_OK ;

	if ( SafeArrayGetDim ( a_Array ) == 1 )
	{
		LONG t_Dimension = 1 ; 

		LONG t_Lower ;
		SafeArrayGetLBound ( a_Array , t_Dimension , & t_Lower ) ;

		LONG t_Upper ;
		SafeArrayGetUBound ( a_Array , t_Dimension , & t_Upper ) ;

		LONG t_Count = ( t_Upper - t_Lower ) + 1 ;

		BYTE *t_SecurityDescriptor = new BYTE [ t_Count ] ;
		if ( t_SecurityDescriptor )
		{
			if ( t_Count ) 
			{
				for ( LONG t_ElementIndex = t_Lower ; t_ElementIndex <= t_Upper ; t_ElementIndex ++ )
				{
					BYTE t_Element ;
					if ( SUCCEEDED ( SafeArrayGetElement ( a_Array , & t_ElementIndex , & t_Element ) ) )
					{
						t_SecurityDescriptor [ t_ElementIndex - t_Lower ] = t_Element ;
					}
					else
					{
						t_Result = WBEM_E_CRITICAL_ERROR ;
						break ;
					}
				}
			}
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( IsValidSecurityDescriptor ( t_SecurityDescriptor ) == FALSE )
			{
				t_Result = WBEM_E_CRITICAL_ERROR ;
			}
		}

		bool t_Everyone = false ;
		bool t_NetworkServicePresent = false ;
		bool t_LocalServicePresent = false ;
		if ( SUCCEEDED ( t_Result ) )
		{
			BOOL t_AclPresent = FALSE ;
			BOOL t_AclDefaulted = FALSE ;
			ACL *t_Dacl = NULL ;

			BOOL t_Status = GetSecurityDescriptorDacl (

				t_SecurityDescriptor ,
				& t_AclPresent ,
				& t_Dacl ,
				& t_AclDefaulted 
			) ;

			if ( t_Status && t_AclPresent && t_Dacl == NULL )
			{
				t_Everyone = true ;
			}

			if ( t_Status && t_AclPresent == FALSE )
			{
				t_Everyone = true ;
			}

			if ( ! t_Status )
			{
				t_Result = WBEM_E_CRITICAL_ERROR ;
			}
		}

		if ( SUCCEEDED ( t_Result ) && ( t_Everyone == false ) && ( ( t_NetworkServicePresent == false ) || ( t_LocalServicePresent == false ) ) ) 
		{
			SECURITY_DESCRIPTOR *t_AbsoluteSecurityDescriptor = NULL ;
			DWORD t_AbsoluteSecurityDescriptorSize = sizeof ( SECURITY_DESCRIPTOR ) ;

			PACL t_Dacl = NULL ;
			PACL t_Sacl = NULL ;
			PSID t_Owner = NULL ;
			PSID t_PrimaryGroup = NULL ;

			DWORD t_DaclSize = 0 ;
			DWORD t_SaclSize = 0 ;
			DWORD t_OwnerSize = 0 ;
			DWORD t_PrimaryGroupSize = 0 ;

			BOOL t_Status = MakeAbsoluteSD (

				t_SecurityDescriptor ,
				t_AbsoluteSecurityDescriptor ,
				& t_AbsoluteSecurityDescriptorSize ,
				t_Dacl,
				& t_DaclSize,
				t_Sacl,
				& t_SaclSize,
				t_Owner,
				& t_OwnerSize,
				t_PrimaryGroup,
				& t_PrimaryGroupSize
			) ;

			if ( ( t_Status == FALSE ) && GetLastError () == ERROR_INSUFFICIENT_BUFFER )
			{
				WORD t_Extra = 0 ;
				if ( t_NetworkServicePresent == false )
				{
					t_Extra = t_Extra +  g_NetworkService_AceSize ;
				}

				if ( t_LocalServicePresent == false ) 
				{
					t_Extra = t_Extra + g_LocalService_AceSize ;
				}

				t_DaclSize = t_DaclSize + t_Extra ;

				t_Dacl = ( PACL ) new BYTE [ t_DaclSize ] ;
				t_Sacl = ( PACL ) new BYTE [ t_SaclSize ] ;
				t_Owner = ( PSID ) new BYTE [ t_OwnerSize ] ;
				t_PrimaryGroup = ( PSID ) new BYTE [ t_PrimaryGroupSize ] ;
			
				t_AbsoluteSecurityDescriptor = ( SECURITY_DESCRIPTOR * ) new BYTE [ t_AbsoluteSecurityDescriptorSize ] ;

				if ( t_AbsoluteSecurityDescriptor && t_Dacl && t_Sacl && t_Owner && t_PrimaryGroup )
				{
					BOOL t_Status = InitializeSecurityDescriptor ( t_AbsoluteSecurityDescriptor , SECURITY_DESCRIPTOR_REVISION ) ;
					if ( t_Status )
					{
						t_Status = MakeAbsoluteSD (

							t_SecurityDescriptor ,
							t_AbsoluteSecurityDescriptor ,
							& t_AbsoluteSecurityDescriptorSize ,
							t_Dacl ,
							& t_DaclSize ,
							t_Sacl,
							& t_SaclSize,
							t_Owner,
							& t_OwnerSize,
							t_PrimaryGroup,
							& t_PrimaryGroupSize
						) ;

						WORD t_AceCount = t_Dacl->AceCount ;

						if ( t_Status )
						{
							t_Dacl->AclSize = ( WORD ) t_DaclSize ;

							if ( t_NetworkServicePresent == false )
							{
								t_Status = AddAce ( 

									t_Dacl , 
									ACL_REVISION, 
									t_AceCount ++ , 
									g_NetworkService_Ace , 
									g_NetworkService_AceSize
								) ;
							}
						}

						if ( t_Status )
						{
							if ( t_LocalServicePresent == false )
							{
								t_Status = AddAce ( 

									t_Dacl , 
									ACL_REVISION, 
									t_AceCount ++ , 
									g_LocalService_Ace , 
									g_LocalService_AceSize
								) ;
							}
						}

						if ( t_Status == FALSE )
						{
							t_Result = WBEM_E_CRITICAL_ERROR ;
						}
					}
				}
			}

			if ( SUCCEEDED ( t_Result ) )
			{
				SECURITY_DESCRIPTOR *t_SecurityDescriptorRelative = NULL ;
				DWORD t_FinalLength = 0 ;

				t_Status = MakeSelfRelativeSD (

					t_AbsoluteSecurityDescriptor ,
					t_SecurityDescriptorRelative ,
					& t_FinalLength 
				) ;

				if ( t_Status == FALSE && GetLastError () == ERROR_INSUFFICIENT_BUFFER )
				{
					t_SecurityDescriptorRelative = ( SECURITY_DESCRIPTOR * ) new BYTE [ t_FinalLength ] ;
					if ( t_SecurityDescriptorRelative )
					{
						t_Status = InitializeSecurityDescriptor ( t_SecurityDescriptorRelative , SECURITY_DESCRIPTOR_REVISION ) ;
						if ( t_Status )
						{
							t_Status = MakeSelfRelativeSD (

								t_AbsoluteSecurityDescriptor ,
								t_SecurityDescriptorRelative ,
								& t_FinalLength 
							) ;

							if ( t_Status == FALSE )
							{
								t_Result = WBEM_E_CRITICAL_ERROR ;
							}
						}
						else
						{
							t_Result = WBEM_E_CRITICAL_ERROR ;
						}
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;									
					}
				}
				else
				{
					t_Result = WBEM_E_CRITICAL_ERROR ;
				}

				if ( SUCCEEDED ( t_Result ) )		
				{
					SAFEARRAYBOUND t_Bounds ;
					t_Bounds.lLbound = 0;
					t_Bounds.cElements = t_FinalLength ;

					a_NewArray = SafeArrayCreate ( VT_UI1 , 1 , & t_Bounds ) ;
					if ( a_NewArray )
					{
						for ( LONG t_Index = 0 ; ( ( ULONG ) t_Index ) < t_FinalLength ; t_Index ++ )
						{
							BYTE t_Byte = * ( ( ( BYTE * ) t_SecurityDescriptorRelative ) + t_Index ) ;
							t_Result = SafeArrayPutElement ( a_NewArray , & t_Index , & t_Byte ) ;
							if ( FAILED ( t_Result ) )
							{
								break ;
							}
						}
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;									
					}
				}

				delete [] ( BYTE * ) t_SecurityDescriptorRelative ;
			}

			delete [] ( BYTE * ) t_Dacl ;
			delete [] ( BYTE * ) t_Sacl ;
			delete [] ( BYTE * ) t_Owner ;
			delete [] ( BYTE * ) t_PrimaryGroup ;
		}

		delete [] t_SecurityDescriptor ;
	}
	else
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ConfigureSecurity (

	IWbemServices *a_Service 
)
{
	HRESULT t_Result = S_OK ;

	BSTR t_ObjectPath = SysAllocString ( L"__SystemSecurity" ) ;
	BSTR t_MethodName = SysAllocString ( L"GetSD" ) ;
	if ( t_ObjectPath && t_MethodName )
	{
		IWbemClassObject *t_Object = NULL ;

		t_Result = a_Service->ExecMethod (

			t_ObjectPath ,
			t_MethodName ,
			0 ,
			NULL ,
			NULL ,
			& t_Object ,
			NULL
        );

		if ( SUCCEEDED ( t_Result ) )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;

			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			HRESULT t_Result = t_Object->Get ( L"SD" , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				if ( t_Variant.vt == ( VT_UI1 | VT_ARRAY ) )
				{
					SAFEARRAY *t_Array = t_Variant.parray ;
					SAFEARRAY *t_NewArray = NULL ;

					t_Result = InsertServiceAccess (

						t_Array ,
						t_NewArray 
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						BSTR t_Class = SysAllocString ( L"__SystemSecurity" ) ;
						if ( t_Class )
						{
							IWbemClassObject *t_InObject = NULL ;
							t_Result = a_Service->GetObject (

								t_Class ,
								0 , 
								NULL , 
								& t_InObject ,
								NULL 
							) ;

							if ( SUCCEEDED ( t_Result ) )
							{
								BSTR t_SetMethodName = SysAllocString ( L"SetSD" ) ;
								if ( t_SetMethodName )
								{
									IWbemClassObject *t_InArgsClass = NULL ;
									t_Result = t_InObject->GetMethod (

										t_SetMethodName ,
										0 ,
										& t_InArgsClass ,
										NULL 
									) ;

									if ( SUCCEEDED ( t_Result ) )
									{
										IWbemClassObject *t_InArgs = NULL ;

									    t_Result = t_InArgsClass->SpawnInstance ( 0 , & t_InArgs ) ;
										if ( SUCCEEDED ( t_Result ) )
										{
											VARIANT t_Variant ;
											VariantInit ( & t_Variant ) ;
											t_Variant.vt = VT_UI1 | VT_ARRAY ;
											t_Variant.parray = t_NewArray ;

											t_Result = t_InArgs->Put ( 

												L"SD" ,
												0 ,
												& t_Variant ,
												CIM_UINT8 | CIM_FLAG_ARRAY
											) ;

											if ( SUCCEEDED ( t_Result ) )
											{
												IWbemClassObject *t_OutArgs = NULL ;
												a_Service->ExecMethod (

													t_ObjectPath ,
													t_SetMethodName ,
													0 ,
													NULL ,
													t_InArgs ,
													& t_OutArgs ,
													NULL 
												) ;

												if ( SUCCEEDED ( t_Result ) )
												{
													if ( t_OutArgs )
													{
														t_OutArgs->Release () ;
													}
												}
											}

											t_InArgs->Release () ;
										}

										t_InArgsClass->Release () ;
									}

									SysFreeString ( t_SetMethodName ) ;
								}

								t_InObject->Release () ;
							}
						}
						else
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}

						SafeArrayDestroy ( t_NewArray ) ;
					}
				}
				else
				{
					t_Result = WBEM_E_CRITICAL_ERROR ;
				}

				VariantClear ( & t_Variant ) ;
			}

			t_Object->Release () ;
		}
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	SysFreeString ( t_ObjectPath ) ;
	SysFreeString ( t_MethodName ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT Traverse ( 

	IWbemServices *a_Service ,
	BSTR a_Namespace
)
{
	HRESULT t_Result = ConfigureSecurity (

		a_Service 
	) ;

	if ( FAILED ( t_Result ) )
	{
		char t_Buffer [ MAX_MSG_TEXT_LENGTH ] ;
		sprintf ( t_Buffer , "\nConfiguration of Security failed [%lx]" , t_Result ) ;
		LogMessage(MSG_INFO, t_Buffer);
	}
	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ConfigureServiceSecurity ()
{
	IWbemLocator *t_Locator = NULL ;
	HRESULT t_Result = CoCreateInstance (
  
		CLSID_WbemLocator ,
		NULL ,
		CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER ,
		IID_IUnknown ,
		( void ** )  & t_Locator
	);

	if ( SUCCEEDED ( t_Result ) )
	{
		BSTR t_Root = SysAllocString ( L"root" ) ;
		if ( t_Root )
		{
			IWbemServices *t_Service = NULL ;
			HRESULT t_Result = t_Locator->ConnectServer (

				t_Root ,
				NULL ,
				NULL,
				NULL ,
				0 ,
				NULL,
				NULL,
				&t_Service
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = TraverseSetSecurity ( t_Service ) ;
				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = Traverse (

						t_Service ,
						t_Root 
					) ;
				}

				t_Service->Release () ;
			}
			else
			{
				char t_Buffer [ MAX_MSG_TEXT_LENGTH ] ;
				sprintf ( t_Buffer , "\nFailing Connecting to Namespace [%s] with result [%lx]" , t_Root , t_Result ) ;
				LogMessage(MSG_INFO, t_Buffer);
			}

			SysFreeString ( t_Root ) ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}

		t_Locator->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT InitializeConstants ()
{
	HRESULT t_Result = S_OK ;

	SID_IDENTIFIER_AUTHORITY t_NtAuthoritySid = SECURITY_NT_AUTHORITY ;

	BOOL t_Status = AllocateAndInitializeSid (

		& t_NtAuthoritySid ,
		1 ,
		SECURITY_NETWORK_SERVICE_RID,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		& g_NetworkServiceSid
	) ;

	if ( t_Status )
	{
		DWORD t_SidLength = :: GetLengthSid ( g_NetworkServiceSid );
		g_NetworkService_AceSize = sizeof(ACCESS_ALLOWED_ACE) + (WORD) ( t_SidLength - sizeof(DWORD) ) ;
		g_NetworkService_Ace = (ACCESS_ALLOWED_ACE*) new BYTE [ g_NetworkService_AceSize ] ;
		if ( g_NetworkService_Ace )
		{
			CopySid ( t_SidLength, (PSID) & g_NetworkService_Ace->SidStart, g_NetworkServiceSid ) ;
			g_NetworkService_Ace->Mask = WBEM_ENABLE | WBEM_METHOD_EXECUTE | WBEM_WRITE_PROVIDER ;
			g_NetworkService_Ace->Header.AceType = ACCESS_ALLOWED_ACE_TYPE ;
			g_NetworkService_Ace->Header.AceFlags = CONTAINER_INHERIT_ACE ;
			g_NetworkService_Ace->Header.AceSize = g_NetworkService_AceSize ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Status = AllocateAndInitializeSid (

			& t_NtAuthoritySid ,
			1 ,
			SECURITY_LOCAL_SERVICE_RID,
			0,
			0,
			0,
			0,
			0,
			0,
			0,
			& g_LocalServiceSid
		) ;

		if ( t_Status )
		{
			DWORD t_SidLength = :: GetLengthSid ( g_LocalServiceSid );
			g_LocalService_AceSize = sizeof(ACCESS_ALLOWED_ACE) + (WORD) ( t_SidLength - sizeof(DWORD) ) ;
			g_LocalService_Ace = (ACCESS_ALLOWED_ACE*) new BYTE [ g_LocalService_AceSize ] ;
			if ( g_LocalService_Ace )
			{
				CopySid ( t_SidLength, (PSID) & g_LocalService_Ace->SidStart, g_LocalServiceSid ) ;
				g_LocalService_Ace->Mask = WBEM_ENABLE | WBEM_METHOD_EXECUTE | WBEM_WRITE_PROVIDER ;
				g_LocalService_Ace->Header.AceType = ACCESS_ALLOWED_ACE_TYPE ;
				g_LocalService_Ace->Header.AceFlags = CONTAINER_INHERIT_ACE ;
				g_LocalService_Ace->Header.AceSize = g_LocalService_AceSize ;
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}

		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT UnInitializeConstants ()
{
	if ( g_NetworkServiceSid )
	{
		FreeSid ( g_NetworkServiceSid ) ;
	}
	if ( g_LocalServiceSid )
	{
		FreeSid ( g_LocalServiceSid ) ;
	}

	delete [] ( ( BYTE * ) g_NetworkService_Ace ) ;
	delete [] ( ( BYTE * ) g_LocalService_Ace ) ;

	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT UpdateServiceSecurity ()
{
	HRESULT t_Result = InitializeConstants () ;
	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = ConfigureServiceSecurity () ;

		UnInitializeConstants () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CheckForServiceSecurity ()
{
	Registry r(WBEM_REG_WBEM);
	if (r.GetStatus() != no_error)
	{
		if ( r.GetLastError ( ) != ERROR_FILE_NOT_FOUND )
		{
			LogMessage(MSG_ERROR, "Unable to access registry for UpdateServiceSecurity.");
			return WBEM_E_CRITICAL_ERROR ;
		}
		else
		{
			LogMessage(MSG_ERROR, "Unable to access registry (key not found) for UpdateServiceSecurity. Progressing with upgrade.");
			return S_OK ;
		}
	}

	char *t_BuildVersion = NULL ;
	if ( r.GetStr ("Build", & t_BuildVersion ) )
	{
		LogMessage(MSG_ERROR, "Unable to get build version number for UpdateServiceSecurity.");
		return WBEM_E_CRITICAL_ERROR ;
	}

	if ( strlen ( t_BuildVersion ) >= 4 )
	{
		t_BuildVersion [ 4 ] = 0 ;
	}
	else
	{
		LogMessage(MSG_ERROR, "Unexpected build version number for UpdateServiceSecurity.");
		return WBEM_E_CRITICAL_ERROR ;
	}

	DWORD t_BuildVersionNumber = 0 ;
	if ( sscanf ( t_BuildVersion , "%lu" , & t_BuildVersionNumber ) == NULL )
	{
		LogMessage(MSG_ERROR, "Unable to convert build version number for UpdateServiceSecurity.");
		return WBEM_E_CRITICAL_ERROR ;
	}

	if ( t_BuildVersionNumber < 2600 )
	{
		LogMessage(MSG_INFO, "Operating System Version < WindowsXP (2600) UpdateServiceSecurity.");
		return S_OK ;
	}
	else
	{
		return S_FALSE ;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\setup\bin\wbemupgradedll\exportv7.cpp ===
/*++

Copyright (C) 1996-2000 Microsoft Corporation

Module Name:

    EXPORTV7.CPP

Abstract:

    Exporting

History:

--*/

#include "precomp.h"

//There is nothing different here from the base class.  All changes are in-line to the class definition!
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\setup\bin\wbemupgradedll\import.h ===
/*++

Copyright (C) 1997-2000 Microsoft Corporation

Module Name:

    Import.h

Abstract:

    Upgrade code

History:


--*/

#ifndef __wmi_import_h__
#define __wmi_import_h__

/*================================================================================
 *
 * EXPORT FILE FORMAT
 * ==================
 *
 * File Header Block:
 *		wchar_t wszFileHeader								= "repexp1"
 *
 * Namespace Block:
 *		DWORD   dwObjectType								= 0x00000001
 *		DWORD   dwNamespaceNameSize
 *		wchar_t wszNamespaceName[dwNamespaceNameSize]		= Full namespace name
 *															  (\root\default\fred)
 *
 * Class Block:
 *		DWORD   dwObjectType								= 0x00000002
 *		DWORD   dwClassNameSize
 *		wchar_t wszClassName[dwClassNameSize]				= Class name (my_class_name)
 *		DWORD   dwClassObjectSize
 *		DWORD	adwClassObject[dwClassObjectSize]
 *
 * Instance Block - key of type int:
 *		DWORD   dwObjectType								= 0x00000003
 *		DWORD   dwInstanceKey
 *		DWORD	dwInstanceObjectSize
 *		DWORD	adwInstanceObject[dwInstanceObjectSize]
 *
 * Instance Block - key of type string
 *		DWORD	dwObjectType								= 0x00000004
 *		DWORD	dwInstanceKeySize
 *		DWORD	dwInstanceKey[dwInstanceKeySize]			= Instance key (MyKeyValue)
 *		DWORD	dwInstanceObjectSize
 *		DWORD	adwInstanceObject[dwInstanceObjectSize]
 *		
 * End of class block
 *		DWORD	dwObjectType								= 0x00000005
 *		DWORD	dwEndOfBlockSize							= 0x00000010
 *		DWORD	adwEndOfBlock[dwEndOfBlockSize]				= 0xFFFFFFFF,
 *															  0xFFFFFFFF,
 *															  0xFFFFFFFF,
 *															  0xFFFFFFFF
 *
 * End of namespace block
 *		DWORD	dwObjectType								= 0x00000006
 *		DWORD	dwEndOfBlockSize							= 0x00000010
 *		DWORD	adwEndOfBlock[dwEndOfBlockSize]				= 0xFFFFFFFF,
 *															  0xFFFFFFFF,
 *															  0xFFFFFFFF,
 *															  0xFFFFFFFF
 *
 * End of file block
 *		DWORD	dwObjectType								= 0xFFFFFFFF
 *		DWORD	dwEndOfBlockSize							= 0x00000010
 *		DWORD	adwEndOfBlock[dwEndOfBlockSize]				= 0xFFFFFFFF,
 *															  0xFFFFFFFF,
 *															  0xFFFFFFFF,
 *															  0xFFFFFFFF
 *
 * Ordering:
 *		File Header Block
 *			(one or more)
 *			Namespace Block
 *				(zero or more)
 *				{
 *					Namespace Block
 *						etc...
 *					End namespace block
 *					(or)
 *					Class Block
 *						(zero or more)
 *						{
 *							Instance Block
 *							(or)
 *							Class Block
 *								etc...
 *							End class block
 *						}
 *					End class block
 *				}
 *			End namespace block
 *		End of file block
 *
 *================================================================================
 */

#include <wbemint.h>
#include <strutils.h>
#include "flexarry.h"
#include "winntsec.h"

#ifndef FULL_RIGHTS
#define FULL_RIGHTS WBEM_METHOD_EXECUTE | WBEM_FULL_WRITE_REP | WBEM_PARTIAL_WRITE_REP | \
                    WBEM_WRITE_PROVIDER | WRITE_DAC | READ_CONTROL | WBEM_ENABLE | WBEM_REMOTE_ACCESS
#endif

#define BLOB9X_FILENAME L"\\WBEM9xUpgd.dat"
#define BLOB9X_SIGNATURE "9xUpgrade"			//NOTE!  MAXIMUM OF 10 CHARACTERS (INCLUDING TERMINATOR!)

#define BLOB9X_TYPE_SECURITY_BLOB		1
#define BLOB9X_TYPE_SECURITY_INSTANCE	2
#define BLOB9X_TYPE_END_OF_FILE			3

typedef struct _BLOB9X_HEADER
{
	char szSignature[10];
} BLOB9X_HEADER;

typedef struct _BLOB9X_SPACER
{
	DWORD dwSpacerType;
	DWORD dwNamespaceNameSize;
	DWORD dwParentClassNameSize;
	DWORD dwBlobSize;
} BLOB9X_SPACER;

class CRepImporter
{
private:
	HANDLE m_hFile;
	HANDLE m_h9xBlobFile;
	bool m_bSecurityMode;

	bool CheckOldSecurityClass(const wchar_t* wszClass);
	void DecodeTrailer();
	void DecodeInstanceInt(IWbemServices* pNamespace, const wchar_t *wszFullPath, const wchar_t *pszParentClass, _IWmiObject* pOldParentClass, _IWmiObject *pNewParentClass);
	void DecodeInstanceString(IWbemServices* pNamespace, const wchar_t *wszFullPath, const wchar_t *pszParentClass, _IWmiObject* pOldParentClass, _IWmiObject *pNewParentClass);
	void DecodeClass(IWbemServices* pNamespace, const wchar_t *wszFullPath, const wchar_t *wszParentClass, _IWmiObject *pOldParentClass, _IWmiObject *pNewParentClass);
	void DecodeNamespace(IWbemServices* pNamespace, const wchar_t *wszParentNamespace);
	void DecodeNamespaceSecurity(IWbemServices* pNamespace, IWbemServices* pParentNamespace, const char* pNsSecurity, DWORD dwSize, const wchar_t* wszFullPath);
	void Decode();

	// helpers for DecodeNamespaceSecurity
	bool TransformBlobToSD(IWbemServices* pParentNamespace, const char* pNsSecurity, DWORD dwStoredAsNT, CNtSecurityDescriptor& mmfNsSD);
	bool SetNamespaceSecurity(IWbemServices* pNamespace, CNtSecurityDescriptor& mmfNsSD);
	bool AddDefaultRootAces(CNtAcl * pacl);
	bool GetParentsInheritableAces(IWbemServices* pParentNamespace, CNtSecurityDescriptor &sd);
	bool StripOutInheritedAces(CNtSecurityDescriptor &sd);
	bool GetSDFromNamespace(IWbemServices* pNamespace, CNtSecurityDescriptor& sd);
	bool CopyInheritAces(CNtSecurityDescriptor& sd, CNtSecurityDescriptor& sdParent);
	BOOL SetOwnerAndGroup(CNtSecurityDescriptor &sd);
	void ForceInherit();
	bool InheritSecurity(IWbemLocator* pLocator, IWbemServices* pRootNamespace, const wchar_t* wszNamespace);
	void ConnectNamespace(IWbemLocator* pLocator, const wchar_t* wszNamespaceName, IWbemServices** ppNamespace);
	bool CheckNetworkLocalService ( CNtSecurityDescriptor& sd ) ;

	// helpers for Win9x security processing
	bool AppendWin9xBlobFile(const wchar_t* wszFullPath, DWORD dwBlobSize, const char* pNsSecurity);
	bool AppendWin9xBlobFile(const wchar_t* wszFullPath, const wchar_t* wszParentClass, _IWmiObject* pInstance);
	bool CreateWin9xBlobFile();
	void DeleteWin9xBlobFile();
	bool GetRepositoryDirectory(wchar_t wszRepositoryDirectory[MAX_PATH+1]);
	bool CloseWin9xBlobFile();

public:
	CRepImporter() : m_hFile(INVALID_HANDLE_VALUE), m_h9xBlobFile(INVALID_HANDLE_VALUE), m_bSecurityMode(false){};

	int ImportRepository(const TCHAR *pszFromFile);

	enum { FAILURE_READ							= 1,
		   FAILURE_INVALID_FILE					= 2,
		   FAILURE_INVALID_TYPE					= 3,
		   FAILURE_INVALID_TRAILER				= 4,
		   FAILURE_CANNOT_FIND_NAMESPACE		= 5,
		   FAILURE_CANNOT_GET_PARENT_CLASS		= 6,
		   FAILURE_CANNOT_CREATE_INSTANCE		= 7,
		   FAILURE_CANNOT_ADD_NAMESPACE			= 8,
		   FAILURE_CANNOT_ADD_NAMESPACE_SECURITY= 9,
		   FAILURE_OUT_OF_MEMORY				= 10,
		   FAILURE_CANNOT_CREATE_IWBEMLOCATOR	= 11,
		   FAILURE_CANNOT_CONNECT_SERVER		= 12,
		   FAILURE_CANNOT_MERGE_INSTANCE		= 13,
		   FAILURE_CANNOT_UPGRADE_INSTANCE		= 14,
		   FAILURE_CANNOT_MERGE_CLASS			= 15,
		   FAILURE_CANNOT_UPGRADE_CLASS			= 16,
		   FAILURE_CANNOT_CREATE_CLASS			= 17,
		   FAILURE_CANNOT_CREATE_OBJECTFACTORY	= 18,
		   FAILURE_CANNOT_CREATE_IWMIOBJECT		= 19
	};
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\setup\bin\wbemupgradedll\localloc.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


#include "precomp.h"
#include <arena.h>

void* __cdecl operator new ( size_t size )
{
    return CWin32DefaultArena::WbemMemAlloc( size );
}
    
void __cdecl operator delete ( void* pv )
{
    CWin32DefaultArena::WbemMemFree( pv );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vside\servexpl\beta1\generator\wmigenerator\wmigenerator.cs ===
namespace System.Management
{
using System;
using System.CodeDOM;
using System.CodeDOM.Compiler;
using System.IO;
using System.Reflection;
using System.Management;
using System.Collections;

public enum Languages
{
	CSharp,
	JScript,
	VB
}
/// <summary>
///    This class is used for the automatic generation of 
///    early bound managed code class for a given WMI class
/// </summary>
public class ManagementClassGenerator
{
	private Languages OutputLanguage;
	private string OriginalServer = string.Empty;
	private string OriginalNamespace = string.Empty;
	private string OriginalClassName = string.Empty;
	private bool bSingletonClass = false;
	private string ExceptionString = "Class name doesn't match.";


	private ManagementClass classobj;
	private ICodeGenerator cg;
	private TextWriter tw ;
	private CodeClass cc;
	private CodeClass ccc;
	private CodeClass ecc;
	private CodeClass EnumObj;
	private CodeCommentStatement ccs;
	private CodeNamespace cn;
	private CodeMemberProperty  cmp;
	private CodeConstructor cctor;
	private CodeMemberField cf;
	private CodeObjectCreateExpression coce;
	private CodeLiteralExpression cle;
	private CodeParameterDeclarationExpression cpde;
	private CodeIndexerExpression cie;
	private CodeMemberField cmf;
	private CodeMemberMethod cmm;
	private CodePropertyReferenceExpression cpre;
	private CodeMethodInvokeExpression cmie;
	private CodeMethodInvokeStatement cmis;
	private CodeIfStatement cis;
	private CodeBinaryOperatorExpression cboe;
	private CodeForLoopStatement cfls;
	private CodeAttributeArgument caa;
	private CodeAttributeDeclaration cad;

	private ArrayList arrKeyType = new ArrayList(5);
	private ArrayList arrKeys = new ArrayList(5);
	private ArrayList BitMap = new ArrayList(5);
	private ArrayList BitValues = new ArrayList(5);
	private ArrayList ValueMap = new ArrayList(5);
	private ArrayList Values = new ArrayList(5);

	private CaseInsensitiveSortedList PublicProperties = new CaseInsensitiveSortedList();
	private CaseInsensitiveSortedList PublicMethods = new CaseInsensitiveSortedList();
	private CaseInsensitiveSortedList PublicNamesUsed = new CaseInsensitiveSortedList();
	private CaseInsensitiveSortedList PrivateNamesUsed = new CaseInsensitiveSortedList();

	/// <summary>
	/// The constructor.
	/// </summary>
	/// <param name="MachineName"> The Server to which we should connect to.</param>
	/// <param name="NameSpace">  The WMI namespace which contains the class to be generated</param>
	/// <param name="ClassName"> The WMI class for which the early bound wrapper is needed</param>
	public ManagementClassGenerator()
	{
	}

	public bool GenerateCode(string Server,string Namespace,string ClassName,string Language, string FilePath)
	{
		if(InitializeCodeGeneration(Server,Namespace,ClassName,Language) == true)
		{
			InitializeCodeGenerator(Language,FilePath);
			GenerateCodeNow();
			return true;
		}
		return false;
	}

	public bool GenerateCode(string strPath,ICodeGenerator icg,TextWriter textStream,string Language)
	{
		ManagementPath thePath = new ManagementPath(strPath);
		if(InitializeCodeGeneration(thePath.Server,thePath.NamespacePath, thePath.ClassName,Language) == true)
		{
			cg = icg;
			tw = textStream;
			GenerateCodeNow();
			return true;
		}
		return false;
	}

	public bool InitializeCodeGeneration(string Server,string NameSpace,string ClassName,string Language)
	{
		switch(Language.ToUpper ())
		{
			case "VB":
				OutputLanguage = Languages.VB;
				break;
			case "JS":
				OutputLanguage = Languages.JScript;
				break;
			default:
				OutputLanguage = Languages.CSharp;
				break;
		}

		if(Server != string.Empty)
			OriginalServer = Server.ToUpper();
		else
			OriginalServer = string.Empty;
		OriginalNamespace = ConvertToTitleCase(NameSpace);
		OriginalClassName = ConvertToTitleCase(ClassName);

		//First try to get the class object for the given WMI Class.
		//If we cannot get it then there is no point in continuing 
		//as we won't have any information for the code generation.
		if(InitializeClassObject() == false)
		{
			return false;
		}

		//Initialize the public attributes . private variables
		InitilializePublicPrivateMembers();

		//First form the namespace for the generated class.
		//The namespace will look like System.Wmi.Root.Cimv2.Win32
		//for the path \\root\cimv2:Win32_Service and the class name will be
		//Service.
		ProcessNamespaceAndClassName();

		//First we will sort out the different naming collision that might occur 
		//in the generated code.
		ProcessNamingCollisions();
		return true;
	}

	/// <summary>
 	/// This function will generate the code. This is the function which 
	/// should be called for generating the code.
	/// </summary>
	/// <param name="Language"> The target language for the generated code.
	///		The supported Values as of now are 
	///				"VB" - Visual Basic
	///				"JS" - JavaScript
	///				"CS" - CSharp
	///		If you pass an invalid parameter, it will be defaulted to CSharp </param>
	/// <param name="FilePath"> This is the path where you want the 
	///		generated code to reside</param>
    public bool GenerateCodeNow()
    {
		//Now Initialize the code class for generation
		InitializeCodeClass();

		//Generate the code for defaultNamespace
		//public string defNamespace {
		//	get {
		//			return (<defNamespace>);
		//		}
		//}
		GeneratePublicReadOnlyProperty(PublicNamesUsed["NamespaceProperty"].ToString(),"String",
											OriginalNamespace,false,true);

		//Generate the code for defaultClassName
		//public string defClassName {
		//	get {
		//			return (<defClassName>);
		//		}
		//}
		GeneratePublicReadOnlyProperty(PublicNamesUsed["ClassNameProperty"].ToString(),"String",
											OriginalClassName,false,true);

		//public SystemPropertiesClass _SystemProps{
		//	get {
		//			return (privSysProps);
		//		}
		//}
		GeneratePublicReadOnlyProperty(PublicNamesUsed["SystemPropertiesProperty"].ToString(),PublicNamesUsed["SystemPropertiesClass"].ToString(),
										PrivateNamesUsed["SystemPropertiesObject"].ToString(),true,true);

		//public wmiObjectClass _Object{
		//	get {
		//			return (privWmiObject);
		//		}
		//}
		GeneratePublicReadOnlyProperty(PublicNamesUsed["LateBoundObjectProperty"].ToString(),PublicNamesUsed["LateBoundClass"].ToString(),
										PrivateNamesUsed["LateBoundObject"].ToString(),true,false);

		//public ManagementScope Scope {
		//	get {
		//			return privScope;
		//		}
		//	set {
		//			privScope = value;
		//		}
		//}
		GeneratePublicProperty(PublicNamesUsed["ScopeProperty"].ToString(),PublicNamesUsed["ScopeClass"].ToString(),
								new CodePropertyReferenceExpression(
												new CodeLiteralExpression(PrivateNamesUsed["LateBoundObject"].ToString())
												,"Scope"),true);

		//public ManagementPath Path {
		//	get {
		//			return privWmiObject.Path;
		//		}
		//	set {
		//			if(String.Compare(value.ClassName,className,true) != 0)
		//				throw new ArgumentException("Class name doesn\'t match.");
		//			privWmiObject.Path = value;
		//		}
		//}
		GeneratePathProperty();

		//Now generate properties of the WMI Class
		GenerateProperties();

		//Now Generate static ConstructPath()
		GenerateConstructPath();
		
		//Now create the default constructor
		GenerateDefaultConstructor();

		if(bSingletonClass == true)
		{
			//Now Generate a constructor which accepts only the scope
			GenerateConstructorWithScope();

			//Now Generate a constructor which accepts only the get options
			GenerateConstructorWithOptions();

			//Now generate a constructor which accepts both scope and options
			GenerateConstructorWithScopeOptions();
		}
		else
		{
			//Now create the constuctor which accepts the key values
			GenerateConstructorWithKeys();

			//Also generate a constructor which accepts a scope and keys
			GenerateConstructorWithScopeKeys();

			//Now create constructor with path object
			GenerateConstructorWithPath();

			//Now generate constructor with Path & Options
			GenerateConstructorWithPathOptions();

			//Now Generate a constructor with scope & path
			GenerateConstructorWithScopePath();

			//Now Generate the GetInstances()
			GenerateGetInstancesWithNoParameters();

			//Now Generate the GetInstances(condition)
			GenerateGetInstancesWithCondition();

			//Now Generate the GetInstances(propertylist)
			GenerateGetInstancesWithProperties();

			//Now Generate the GetInstances(condition,propertylist)
			GenerateGetInstancesWithWhereProperties();

			//Now Generate the GetInstances(scope)
			GenerateGetInstancesWithScope();

			//Now Generate the GetInstances(scope,condition)
			GenerateGetInstancesWithScopeCondition();

			//Now Generate the GetInstances(scope,propertylist)
			GenerateGetInstancesWithScopeProperties();

			//Now Generate the GetInstances(scope,condition,propertylist)
			GenerateGetInstancesWithScopeWhereProperties();

			//Generate the Collection Class
			GenerateCollectionClass();
		}

		//Now Generate the constructor with path,scope,options
		GenerateConstructorWithScopePathOptions();

		//Now generate Constructor with latebound Object
		GenarateConstructorWithLateBound();

		//Now Enumerate all the methods
		GenerateMethods();

		//Now declare the private class variables
		//private Wmi_SystemProps SystemProps
		GeneratePrivateMember(PrivateNamesUsed["SystemPropertiesObject"].ToString(),PublicNamesUsed["SystemPropertiesClass"].ToString());

		//private WmiObject privObject
		GeneratePrivateMember(PrivateNamesUsed["LateBoundObject"].ToString(),PublicNamesUsed["LateBoundClass"].ToString());

		//Also add the custom attribute to the generated class
		caa = new CodeAttributeArgument();
		caa.Value = new CodeTypeOfExpression(PrivateNamesUsed["ConverterClass"].ToString());
		cad = new CodeAttributeDeclaration();
		cad.Name = PublicNamesUsed["TypeConverter"].ToString();
		cad.Arguments.Add(caa);
		cc.CustomAttributes = new CodeAttributeBlock();
		cc.CustomAttributes.Attributes.Add(cad);

		//As we have finished the class definition, generate the class code NOW!!!!!
		cn.Classes.Add (cc);

		GenerateSystemPropertiesClass();

		//Now generate the Type Converter class also
		GenerateTypeConverterClass();

		cg.GenerateCodeFromNamespace (tw,cn);
		tw.Close();
		return true;
    }

/// <summary>
/// Function for initializing the class object that will be used to get all the 
/// method and properties of the WMI Class for generating the code.
/// </summary>
	public bool InitializeClassObject()
	{
		//First try to connect to WMI and get the class object.
		// If it fails then no point in continuing
		try
		{
			ManagementPath thePath = new ManagementPath();
			if(OriginalServer != String.Empty)
				thePath.Server = OriginalServer;
			thePath.ClassName = OriginalClassName;
			thePath.NamespacePath = OriginalNamespace;

			classobj = new ManagementClass (thePath);
			//By default all classes are non-singleton(???)
			bSingletonClass = false;				
			foreach (Qualifier q in classobj.Qualifiers)
			{
				if(String.Compare(q.Name,"singleton",true) == 0)
				{
					//This is a singleton class
					bSingletonClass = true;
					break;
				}
			}
			return true;
		}
		catch(Exception e)
		{
			//TODO: Decide what to do here???????
			Console.WriteLine("Exception Occured on Create.Reason [{0}]\n\nStack Trace : \n{1}",e.Message,e.StackTrace);
			return false;
		}
	}
	/// <summary>
	/// This functrion initializes the public attributes and private variables 
	/// list that will be used in the generated code. 
	/// </summary>
	void InitilializePublicPrivateMembers()
	{
		//Initialize the public members
		PublicNamesUsed.Add("SystemPropertiesProperty","SystemProperties");
		PublicNamesUsed.Add("LateBoundObjectProperty","LateBoundObject");
		PublicNamesUsed.Add("NamespaceProperty","OriginatingNamespace");
		PublicNamesUsed.Add("ClassNameProperty","ManagementClassName");
		PublicNamesUsed.Add("ScopeProperty","Scope");
		PublicNamesUsed.Add("PathProperty","Path");
		PublicNamesUsed.Add("SystemPropertiesClass","ManagementSystemProperties");
		PublicNamesUsed.Add("LateBoundClass","ManagementObject");
		PublicNamesUsed.Add("PathClass","ManagementPath");
		PublicNamesUsed.Add("ScopeClass","ManagementScope");
		PublicNamesUsed.Add("QueryOptionsClass","QueryOptions");
		PublicNamesUsed.Add("GetOptionsClass","ObjectGetOptions");
		PublicNamesUsed.Add("ArgumentExceptionClass","ArgumentException");
		PublicNamesUsed.Add("QueryClass","SelectQuery");
		PublicNamesUsed.Add("ObjectSearcherClass","ManagementObjectSearcher");
		PublicNamesUsed.Add("FilterFunction","GetInstances");
		PublicNamesUsed.Add("ConstructPathFunction","ConstructPath");
		PublicNamesUsed.Add("TypeConverter","TypeConverter");

		//Initialize the Private Members
		PrivateNamesUsed.Add("SystemPropertiesObject","PrivateSystemProperties");	
		PrivateNamesUsed.Add("LateBoundObject","PrivateLateBoundObject");			
	}

/// <summary>
/// This function will solve the naming collisions that might occur
/// due to the collision between the local objects of the generated
/// class and the properties/methos of the original WMI Class.
/// </summary>
	void ProcessNamingCollisions()
	{
		if(classobj.Properties != null)
		{
			foreach(Property prop in classobj.Properties)
			{
				PublicProperties.Add(prop.Name,prop.Name);
			}
		}

		if(classobj.Methods != null)
		{
			foreach(Method meth in classobj.Methods)
			{
				PublicMethods.Add(meth.Name,meth.Name);
			}
		}

		int nIndex;

		//Process the collisions here
		//We will check each public names with the property names here.
		foreach(String s in PublicNamesUsed.Values)
		{
			nIndex = IsContainedIn(s,ref PublicProperties);
			if( nIndex != -1)
			{
				//We had found a collision with a public property
				//So we will resolve the collision by changing the property name 
				//and continue
				PublicProperties.SetByIndex(nIndex,ResolveCollision(s,false));
				continue;
			}
			
			nIndex = IsContainedIn(s,ref PublicMethods);
			if(nIndex != -1)
			{
				//We had found a collision with a public method
				//So we will resolve the collision by changing the method name 
				//and continue
				PublicMethods.SetByIndex(nIndex,ResolveCollision(s,false));
				continue;
			}
		}

		//Now we will check for collision against private variables
		foreach(String s in PublicProperties.Values)
		{
			nIndex = IsContainedIn(s,ref PrivateNamesUsed);
			if(nIndex != -1)
			{
				//We had found a collision with a public property
				//So we will resolve the collision by changing the private name 
				//and continue
				PrivateNamesUsed.SetByIndex(nIndex,ResolveCollision(s,false));
			}
		}
		
		foreach(String s in PublicMethods.Values)
		{
			nIndex = IsContainedIn(s,ref PrivateNamesUsed);
			if(nIndex != -1)
			{
				//We had found a collision with a public method
				//So we will resolve the collision by changing the private name 
				//and continue
				PrivateNamesUsed.SetByIndex(nIndex,ResolveCollision(s,false));
			}
		}

		//Now we will create the CollectionClass and Enumerator Class names as they are dependent on the
		//generated class name and the generated class name might have changed due to collision
		string strTemp = PrivateNamesUsed["GeneratedClassName"].ToString()+"Collection";
		PrivateNamesUsed.Add("CollectionClass",ResolveCollision(strTemp,true));

		strTemp = PrivateNamesUsed["GeneratedClassName"].ToString()+"Enumerator";
		PrivateNamesUsed.Add("EnumeratorClass",ResolveCollision(strTemp,true));
}

	/// <summary>
	/// This function is used to resolve (actually generate a new name) collision
	/// between the generated class properties/variables with WMI methods/properties.
	/// This function safely assumes that there will be atleast one string left 
	/// in the series prop0, prop1 ...prop<maxint>. Otherwise this function will
	/// enter an infinite loop. May be we can avoid this through something, which 
	/// i will think about it later
	/// </summary>
	/// <param name="inString"> </param>
	public String ResolveCollision(string inString,bool bCheckthisFirst)
	{
		string strTemp = inString;
		bool bCollision = true;
		int k = -1;
		if(bCheckthisFirst == false)
		{
			k++;
			strTemp = strTemp + k.ToString();
		}

		while(bCollision == true)
		{
			if(IsContainedIn(strTemp,ref PublicProperties) == -1)
			{
				if(IsContainedIn(strTemp,ref PublicMethods) == -1)
				{
					if(IsContainedIn(strTemp,ref PublicNamesUsed) == -1)
					{
						if(IsContainedIn(strTemp,ref PrivateNamesUsed) == -1)
						{
							//So this is not colliding with anything.
							bCollision = false;
							break;
						}
					}
				}
			}
			
			k++;
			strTemp = strTemp + k.ToString();
		}
		return strTemp;
	}

/// <summary>
/// This function processes the WMI namespace and WMI classname and converts them to
/// the namespace used to generate the class and the classname.
/// </summary>
/// <param name="strNs"> </param>
/// <param name="strClass"> </param>
	public void ProcessNamespaceAndClassName()
	{
		string strClass;
		string strNs;

        strNs = OriginalNamespace;
		strNs = strNs.Replace ('\\','.');
		strNs = "System.Management." + strNs;

		if(OriginalClassName.IndexOf('_') > 0)
		{
			strNs += ".";
			strClass = OriginalClassName.Substring(0,OriginalClassName.IndexOf('_'));
			strNs += strClass;
			//Now trim the class name without the first '_'
			strClass = OriginalClassName.Substring(OriginalClassName.IndexOf('_')+1);
		}
		else
		{
			strClass = OriginalClassName;
		}

		PrivateNamesUsed.Add("GeneratedClassName",strClass);
		PrivateNamesUsed.Add("GeneratedNamespace",strNs);
		PrivateNamesUsed.Add("ConverterClass",strClass+"Converter");
	}
/// <summary>
/// This function initializes the code generator object. It initializes the 
/// code generators namespace and the class objects also.
/// </summary>
/// <param name="strNs"> </param>
/// <param name="strClass"> </param>
	public void InitializeCodeGenerator(string Language, string FilePath)
	{
		string suffix = ".CS";		///Defaulted to CS
		switch(Language.ToUpper ())
		{
			case "VB":
				suffix = ".VB";
				cg = new VBCodeGenerator ();
				OutputLanguage = Languages.VB;
				break;
			case "JS":
				suffix = ".JScript";
				cg = new JSCodeGenerator ();
				OutputLanguage = Languages.JScript;
				break;
			default:
				cg = new CSharpCodeGenerator ();
				OutputLanguage = Languages.CSharp;
				break;
		}

		//Now create the filestream (output file)
		tw = new StreamWriter(new FileStream (FilePath+PrivateNamesUsed["GeneratedClassName"].ToString()+suffix,
									FileMode.Create));
	}

	public void InitializeCodeClass()
	{
		//Comment statement //Early Bound Managed Code Wrapper for WMI class <WMiClass> 
		ccs = new CodeCommentStatement (String.Format ("Early Bound Managed Code Wrapper for WMI class {0}",OriginalClassName));
		cg.GenerateCodeFromStatement (tw, ccs);

		//Now add the import statements
		cn = new CodeNamespace(PrivateNamesUsed["GeneratedNamespace"].ToString());
		cn.Imports.Add (new CodeNamespaceImport("System"));
		cn.Imports.Add (new CodeNamespaceImport("System.ComponentModel"));
		cn.Imports.Add (new CodeNamespaceImport("System.Management"));
		cn.Imports.Add(new CodeNamespaceImport("System.Collections"));

		//Now create the class
		cc = new CodeClass (PrivateNamesUsed["GeneratedClassName"].ToString());
	}
/// <summary>
/// This function generates the code for the read only property.
/// The generated code will be of the form
///		public <propType> <propName> {
///			get {
///					return (<propValue>);
///				}
///		}
/// </summary>
/// <param name="propName"> </param>
/// <param name="propType"> </param>
/// <param name="propValue"> </param>
	public void GeneratePublicReadOnlyProperty(string propName, string propType, object propValue,bool isLiteral,bool isBrowsable)
	{
		cmp = new CodeMemberProperty ();
		cmp.Name = propName;
		cmp.Attributes = MemberAttributes.Public | MemberAttributes.Final ;
		cmp.Type = propType;

		caa = new CodeAttributeArgument();
		caa.Value = new CodePrimitiveExpression(isBrowsable);
		cad = new CodeAttributeDeclaration();
		cad.Name = "Browsable";
		cad.Arguments.Add(caa);
		cmp.CustomAttributes = new CodeAttributeBlock();
		cmp.CustomAttributes.Attributes.Add(cad);

		if(isLiteral == true)
		{
			cmp.GetStatements.Add (new CodeMethodReturnStatement (new CodeLiteralExpression(propValue.ToString())));
		}
		else
		{
			cmp.GetStatements.Add (new CodeMethodReturnStatement (new CodePrimitiveExpression(propValue)));
		}
		cc.Members.Add (cmp);
	}

	public void GeneratePublicProperty(string propName,string propType, CodeExpression Value,bool isBrowsable)
	{
		cmp = new CodeMemberProperty();
		cmp.Name = propName;
		cmp.Attributes = MemberAttributes.Public | MemberAttributes.Final;
		cmp.Type = propType;

		caa = new CodeAttributeArgument();
		caa.Value = new CodePrimitiveExpression(isBrowsable);
		cad = new CodeAttributeDeclaration();
		cad.Name = "Browsable";
		cad.Arguments.Add(caa);
		cmp.CustomAttributes = new CodeAttributeBlock();
		cmp.CustomAttributes.Attributes.Add(cad);

		cmp.GetStatements.Add(new CodeMethodReturnStatement(Value));

		cmp.SetStatements.Add(new CodeAssignStatement(Value,
														new CodeLiteralExpression("value")));
		cc.Members.Add(cmp);
	}

	void GeneratePathProperty()
	{
		cmp = new CodeMemberProperty();
		cmp.Name = PublicNamesUsed["PathProperty"].ToString();
		cmp.Attributes = MemberAttributes.Public | MemberAttributes.Final;
		cmp.Type = PublicNamesUsed["PathClass"].ToString();

		caa = new CodeAttributeArgument();
		caa.Value = new CodePrimitiveExpression(true);
		cad = new CodeAttributeDeclaration();
		cad.Name = "Browsable";
		cad.Arguments.Add(caa);
		cmp.CustomAttributes = new CodeAttributeBlock();
		cmp.CustomAttributes.Attributes.Add(cad);

		cpre = new CodePropertyReferenceExpression(new CodeLiteralExpression(
														PrivateNamesUsed["LateBoundObject"].ToString()),
														"Path");

		cmp.GetStatements.Add(new CodeMethodReturnStatement(cpre));

		cis = new CodeIfStatement();
		cmie = new CodeMethodInvokeExpression();
		cmie.MethodName = "Compare";
		cmie.TargetObject = new CodeLiteralExpression("String");
		cmie.Parameters.Add(new CodePropertyReferenceExpression(new CodeLiteralExpression("value"),"ClassName"));
		cmie.Parameters.Add(new CodeLiteralExpression(PublicNamesUsed["ClassNameProperty"].ToString()));
		cmie.Parameters.Add(new CodePrimitiveExpression(true));
		cboe = new CodeBinaryOperatorExpression();
		cboe.Left = cmie;
		cboe.Right = new CodePrimitiveExpression(0);
		cboe.Operator = CodeBinaryOperatorType.IdentityInequality;
		cis.Condition = cboe;
		coce = new CodeObjectCreateExpression();
		coce.CreateType = PublicNamesUsed["ArgumentExceptionClass"].ToString();
		coce.Parameters.Add(new CodePrimitiveExpression(ExceptionString));
		cis.TrueStatements.Add(new CodeThrowExceptionStatement(coce));
		cmp.SetStatements.Add(cis);	
	
		cmp.SetStatements.Add(new CodeAssignStatement(cpre,
														new CodeLiteralExpression("value")));
		cc.Members.Add(cmp);
	}

/// <summary>
/// Function for generating the helper class "ManagementSystemProperties" which is 
/// used for seperating the system properties from the other properties. This is used 
/// just to make the drop down list in the editor to look good.
/// </summary>
	public void GenerateSystemPropertiesClass()
	{
		CodeClass SysPropsClass = new CodeClass(PublicNamesUsed["SystemPropertiesClass"].ToString());

		//First create the constructor
		//	public ManagementSystemProperties(ManagementObject obj)

		cctor = new CodeConstructor();		
		cctor.Attributes = MemberAttributes.Public;
		cpde = new CodeParameterDeclarationExpression();
		cpde.Type = PublicNamesUsed["LateBoundClass"].ToString();
		cpde.Name = "ManagedObject";
		cctor.Parameters.Add(cpde);
		cctor.Statements.Add(new CodeAssignStatement(new CodeLiteralExpression(PrivateNamesUsed["LateBoundObject"].ToString()),new CodeLiteralExpression("ManagedObject")));
		SysPropsClass.Members.Add(cctor);

		char [] strPropTemp;
		char [] strPropName;
		int i = 0;

		foreach (Property prop in classobj.SystemProperties)
		{
			cmp = new CodeMemberProperty ();
			//All properties are browsable by default.
			caa = new CodeAttributeArgument();
			caa.Value = new CodePrimitiveExpression(true);
			cad = new CodeAttributeDeclaration();
			cad.Name = "Browsable";
			cad.Arguments.Add(caa);
			cmp.CustomAttributes = new CodeAttributeBlock();
			cmp.CustomAttributes.Attributes.Add(cad);

			//Now we will have to find the occurance of the first character and trim all the characters before that
			strPropTemp = prop.Name.ToCharArray();
			for(i=0;i < strPropTemp.Length;i++)
			{
				if(Char.IsLetterOrDigit(strPropTemp[i]) == true)
				{
					break;
				}
			}
			if(i == strPropTemp.Length)
			{
				i = 0;
			}
			strPropName = new char[strPropTemp.Length - i];
			for(int j=i;j < strPropTemp.Length;j++)
			{
				strPropName[j - i] = strPropTemp[j];
			}
                        			
			cmp.Name = ConvertToTitleCase(new string(strPropName));
			cmp.Attributes = MemberAttributes.Public | MemberAttributes.Final;
			cmp.Type = ManagementClassGenerator.ConvertCIMType(prop.Type,prop.IsArray,OutputLanguage);

			cie = new CodeIndexerExpression();
			cie.Index = new CodePrimitiveExpression(prop.Name);
			cie.TargetObject = new CodeLiteralExpression(PrivateNamesUsed["LateBoundObject"].ToString());
			cmp.GetStatements.Add (new CodeMethodReturnStatement (new CodeCastExpression(cmp.Type,cie)));
			SysPropsClass.Members.Add(cmp);
		}
		//private WmiObject _privObject
		cf = new CodeMemberField();
		cf.Name = PrivateNamesUsed["LateBoundObject"].ToString();
		cf.Attributes = MemberAttributes.Private | MemberAttributes.Final ;
		cf.Type = PublicNamesUsed["LateBoundClass"].ToString();
		SysPropsClass.Members.Add(cf);

        cc.Members.Add(SysPropsClass);

	}
/// <summary>
/// This function will enumerate all the properties (except systemproperties)
/// of the WMI class and will generate them as properties of the managed code
/// wrapper class.
/// </summary>
	void GenerateProperties()
	{
		bool bRead;
		bool bWrite;
		bool bStatic;

		for(int i=0;i< PublicProperties.Count;i++)
		{
			Property prop = classobj.Properties[PublicProperties.GetKey(i).ToString()];
			bRead = true;		//All properties are readable by default
			bWrite = true;		//All properties are writeable by default
			bStatic = false;	//By default all properties are non static

			cmp = new CodeMemberProperty ();
			cmp.Name = PublicProperties[prop.Name].ToString();
			cmp.Attributes = MemberAttributes.Public | MemberAttributes.Final;
			cmp.Type = ManagementClassGenerator.ConvertCIMType(prop.Type,prop.IsArray,OutputLanguage);

			//All properties are browsable, by default
			caa = new CodeAttributeArgument();
			caa.Value = new CodePrimitiveExpression(true);
			cad = new CodeAttributeDeclaration();
			cad.Name = "Browsable";
			cad.Arguments.Add(caa);
			cmp.CustomAttributes = new CodeAttributeBlock();
			cmp.CustomAttributes.Attributes.Add(cad);

			cie = new CodeIndexerExpression();
			cie.Index = new CodePrimitiveExpression(prop.Name);
			cie.TargetObject = new CodeLiteralExpression(PrivateNamesUsed["LateBoundObject"].ToString());
			
			ProcessPropertyQualifiers(prop,ref bRead,ref bWrite,ref bStatic);

			GeneratePropertyHelperEnums(prop,PublicProperties[prop.Name].ToString());

			if(bRead == true)
			{
				cmp.GetStatements.Add (new CodeMethodReturnStatement (new CodeCastExpression(cmp.Type,cie)));
			}

			if(bWrite == true)
			{
	            cmp.SetStatements.Add(new CodeAssignStatement(cie,new CodeLiteralExpression("value"))); 
				cmie = new CodeMethodInvokeExpression();
				cmie.TargetObject = new CodeLiteralExpression(PrivateNamesUsed["LateBoundObject"].ToString());
				cmie.MethodName = "Put";
				cmp.SetStatements.Add(new CodeMethodInvokeStatement(cmie));
			}
			cc.Members.Add (cmp);
		}
	}
/// <summary>
/// This function will process the qualifiers for a given WMI property and set the 
/// attributes of the generated property accordingly.
/// </summary>
	void ProcessPropertyQualifiers(Property prop,ref bool bRead, ref bool bWrite, ref bool bStatic)
	{
		foreach (Qualifier q in prop.Qualifiers)
		{
			if(String.Compare(q.Name,"key",true) == 0)
			{
				//This is a key. So push it in to the key array
				arrKeyType.Add(cmp.Type);
				arrKeys.Add(prop.Name);
				break;
			}
			else if(string.Compare(q.Name,"static",true) == 0)
			{
				//This property is static. So add static to the Type of the object
				bStatic = true;
				cmp.Attributes |= MemberAttributes.Static;
			}
			else if(string.Compare(q.Name,"read",true) == 0)
			{
				if((bool)q.Value == false)
				{
					bRead = false;
				}
				else
				{
					bRead = true;
				}
			}
			else if(string.Compare(q.Name,"write",true) == 0)
			{
				if((bool)q.Value == true)
				{
					bWrite = true;
				}
				else
				{
					bWrite = false;
				}
			}
			// check for ValueMap/Values and BitMap/BitValues pair and create
			// Enum Accordingly
			else if(string.Compare(q.Name,"ValueMap",true) == 0)
			{
				ValueMap.Clear();
				//Now check whether the type of the property is int
				if(isTypeInt(prop.Type) == true)
				{
					string [] strArray = (string [])q.Value;
					for(int i=0;i < strArray.Length;i++)
					{
						ValueMap.Add(strArray[i].ToInt32());
					}
				}
			}
			else if(string.Compare(q.Name,"Values",true) == 0)
			{
				Values.Clear();
				if(isTypeInt(prop.Type) == true)
				{
					string [] strArray = (string [])q.Value;
					for(int i=0;i < strArray.Length;i++)
					{
						Values.Add(strArray[i]);
					}
				}
			}
			else if(string.Compare(q.Name,"BitMap",true) == 0)
			{
				BitMap.Clear();
				if(isTypeInt(prop.Type) == true)
				{
					string [] strArray = (string [])q.Value;
					for(int i=0;i < strArray.Length;i++)
					{
						BitMap.Add(strArray[i].ToInt32());
					}
				}
			}
			else if(string.Compare(q.Name,"BitValues",true) == 0)
			{
				BitValues.Clear();
				if(isTypeInt(prop.Type) == true)
				{
					string [] strArray = (string [])q.Value;
					for(int i=0;i < strArray.Length;i++)
					{
						BitValues.Add(strArray[i]);
					}
				}
			}
		}
	}
/// <summary>
/// This function will generate enums corresponding to the Values/Valuemap pair
/// and for the BitValues/Bitmap pair.
/// </summary>
void GeneratePropertyHelperEnums(Property prop,string strPropertyName)
{
	//Only if the property is of type int and there is atleast values qualifier on it
	//then we will generate an enum for the values/valuemap(if available)
	//Here we don't have to check explicitly for type of the property as the size of 
	//values array will be zero if the type is not int.
	string strEnum = ResolveCollision(strPropertyName+"Values",true);

	if(Values.Count > 0)
	{
		//Now we will have to create an enum.
		EnumObj = new CodeClass(strEnum);
	    cc.Members.Add(EnumObj);

		//Now convert the type to the generated enum type
		cmp.Type = strEnum;

		EnumObj.Attributes = TypeAttributes.Public | TypeAttributes.ValueType | TypeAttributes.Enum;
		for(int i=0; i < Values.Count;i++)
		{
			cmf = new CodeMemberField ();
			cmf.Name = Values[i].ToString();
			if(ValueMap.Count > 0)
			{
				cmf.InitExpression = new CodePrimitiveExpression(ValueMap[i]);
			}
			EnumObj.Members.Add(cmf);
		}
		//Now clear the Values & ValueMap Array
		Values.Clear();
		ValueMap.Clear();
	}
	//Only if the property is of type int and there is atleast values qualifier on it
	//then we will generate an enum for the values/valuemap(if available)
	//Here we don't have to check explicitly for type of the property as the size of 
	//values array will be zero if the type is not int.
	if(BitValues.Count > 0)
	{
		//Now we will create the enum
		EnumObj = new CodeClass(strEnum);
	    cc.Members.Add(EnumObj);

		//Now convert the type to the generated enum type
		cmp.Type = strEnum;

		EnumObj.Attributes = TypeAttributes.Public | TypeAttributes.ValueType | TypeAttributes.Enum;
		Int32 bitValue = 1;
		for(int i=0; i < BitValues.Count;i++)
		{
			cmf = new CodeMemberField ();
			cmf.Name = BitValues[i].ToString();
			if(ValueMap.Count > 0)
			{
				cmf.InitExpression = new CodePrimitiveExpression(BitMap[i]);
			}
			else
			{
				cmf.InitExpression = new CodePrimitiveExpression(bitValue);
				//Now shift 1 more bit so that we can put it for the next element in the enum
				bitValue = bitValue << 1;
			}
			EnumObj.Members.Add(cmf);
		}

		//Now clear the Bitmap and BitValues Array
		BitValues.Clear();
		BitMap.Clear();
	}
}
/// <summary>
/// This function generated the static function which s used to construct the path
/// 	private static String ConstructPath(String keyName)
///		{
///			//FOR NON SINGLETON CLASSES
///			String strPath;
///		    strPath = ((("\\<defNamespace>:<defClassName>";
///		    strPath = ((_strPath) + (((".Key1=") + (key_Key1))));
///		    strPath = ((_strPath) + (((",Key2=") + ((("\"") + (((key_Key2) + ("\""))))))));
///			return strPath;
///			
///			//FOR SINGLETON CLASS
///			return "\\<defNameSpace>:<defClassName>=@";
///		}
/// </summary>
	void GenerateConstructPath()
	{
		cmm = new CodeMemberMethod();
        cmm.Name = PublicNamesUsed["ConstructPathFunction"].ToString();
		cmm.Attributes = MemberAttributes.Private | MemberAttributes.Static | MemberAttributes.Final;
		cmm.ReturnType = "String";

		for(int i=0; i < arrKeys.Count;i++)
		{
			cmm.Parameters.Add(new CodeParameterDeclarationExpression(arrKeyType[i].ToString(),
																		"key"+arrKeys[i].ToString()));
		}

		string strPath = "\\" + OriginalNamespace + ":" + OriginalClassName;
		if(bSingletonClass == true)
		{
			strPath = strPath + "=@";
			cmm.Statements.Add(new CodeMethodReturnStatement(new CodePrimitiveExpression(strPath)));
		}
		else
		{
			string strPathObject = "strPath";
			//Declare the String strPath;
			cmm.Statements.Add(new CodeVariableDeclarationStatement("String",strPathObject,new CodePrimitiveExpression(strPath)));

			for(int i=0; i < arrKeys.Count;i++)
			{
				if(arrKeyType[i] == "String")
				{
					cboe = new CodeBinaryOperatorExpression(new CodeLiteralExpression("key"+arrKeys[i]),
															CodeBinaryOperatorType.Add,
															new CodePrimitiveExpression("\""));

					cboe = new CodeBinaryOperatorExpression(new CodePrimitiveExpression("\""),
															CodeBinaryOperatorType.Add,
															cboe);

					cboe = new CodeBinaryOperatorExpression(new CodePrimitiveExpression(
														((i==0)?("."+arrKeys[i]+"="):(","+arrKeys[i]+"="))),
														CodeBinaryOperatorType.Add,
														cboe);
					cboe = new CodeBinaryOperatorExpression(new CodeLiteralExpression(strPathObject),
															CodeBinaryOperatorType.Add,
															cboe);
				}
				else
				{
					cboe = new CodeBinaryOperatorExpression(new CodePrimitiveExpression(
														((i==0)?("."+arrKeys[i]+"="):(","+arrKeys[i]+"="))),
															CodeBinaryOperatorType.Add,
															new CodeLiteralExpression("key"+arrKeys[i]));
					cboe = new CodeBinaryOperatorExpression(new CodeLiteralExpression(strPathObject),
															CodeBinaryOperatorType.Add,
															cboe);
				}
				cmm.Statements.Add(new CodeAssignStatement(new CodeLiteralExpression(strPathObject),cboe));
			}
			cmm.Statements.Add(new CodeMethodReturnStatement(new CodeLiteralExpression(strPathObject)));
		}
		cc.Members.Add(cmm);
	}
/// <summary>
/// This function generates the default constructor.
/// public Cons() {
///		_privObject = new ManagementObject();
///     _privSystemProps = new ManagementSystemProperties(_privObject);
/// }
/// </summary>
	void GenerateDefaultConstructor()
	{
		cctor = new CodeConstructor();
		cctor.Attributes = MemberAttributes.Public;

		cctor.ChainedConstructorArgs.Add(new CodePrimitiveExpression(null));
		//If it is a singleton class, then we will make the default constructor to point to the
		//only object available
		if(bSingletonClass == true)
		{
			cmie = new CodeMethodInvokeExpression();
			cmie.TargetObject = new CodeLiteralExpression(PrivateNamesUsed["GeneratedClassName"].ToString());
			cmie.MethodName = PublicNamesUsed["ConstructPathFunction"].ToString();
			cctor.ChainedConstructorArgs.Add(cmie);
		}
		else
		{
			cctor.ChainedConstructorArgs.Add(new CodePrimitiveExpression(null));
		}
		cctor.ChainedConstructorArgs.Add(new CodePrimitiveExpression(null));
		cc.Members.Add(cctor);
	}
/// <summary>
///This function create the constuctor which accepts the key values.
///public cons(UInt32 key_Key1, String key_Key2) :this(null,<ClassName>.ConstructPath(<key1,key2>),null) {
/// }
///</summary>
	void GenerateConstructorWithKeys()
	{
		if(arrKeyType.Count > 0)
		{
			cctor = new CodeConstructor();		
			cctor.Attributes = MemberAttributes.Public;
			for(int i=0; i < arrKeys.Count;i++)
			{
				cpde = new CodeParameterDeclarationExpression();
				cpde.Type = arrKeyType[i].ToString();
				cpde.Name = "key"+arrKeys[i].ToString();
				cctor.Parameters.Add(cpde);
			}

			cctor.ChainedConstructorArgs.Add(new CodePrimitiveExpression(null));

			cmie = new CodeMethodInvokeExpression();
			cmie.TargetObject = new CodeLiteralExpression(PrivateNamesUsed["GeneratedClassName"].ToString());
			cmie.MethodName = PublicNamesUsed["ConstructPathFunction"].ToString();

			for(int i=0; i < arrKeys.Count;i++)
			{
				cmie.Parameters.Add(new CodeLiteralExpression("key"+arrKeys[i]));
			}

			coce = new CodeObjectCreateExpression();
			coce.CreateType = PublicNamesUsed["PathClass"].ToString();
			coce.Parameters.Add(cmie);
			cctor.ChainedConstructorArgs.Add(coce);
			cctor.ChainedConstructorArgs.Add(new CodePrimitiveExpression(null));
			cc.Members.Add(cctor);
		}		
	}

/// <summary>
///This function create the constuctor which accepts a scope and key values.
///public cons(ManagementScope scope,UInt32 key_Key1, String key_Key2) :this(scope,<ClassName>.ConstructPath(<key1,key2>),null) {
/// }
///</summary>
	void GenerateConstructorWithScopeKeys()
	{
		cctor = new CodeConstructor();		
		cctor.Attributes = MemberAttributes.Public;
		string strScopeObject = "scope";
		cctor.Parameters.Add(new CodeParameterDeclarationExpression(PublicNamesUsed["ScopeClass"].ToString(),strScopeObject));

		if(arrKeyType.Count > 0)
		{
			for(int i=0; i < arrKeys.Count;i++)
			{
				cpde = new CodeParameterDeclarationExpression();
				cpde.Type = arrKeyType[i].ToString();
				cpde.Name = "key"+arrKeys[i].ToString();
				cctor.Parameters.Add(cpde);
			}

			cctor.ChainedConstructorArgs.Add(new CodeLiteralExpression(strScopeObject));

			cmie = new CodeMethodInvokeExpression();
			cmie.TargetObject = new CodeLiteralExpression(PrivateNamesUsed["GeneratedClassName"].ToString());
			cmie.MethodName = PublicNamesUsed["ConstructPathFunction"].ToString();

			for(int i=0; i < arrKeys.Count;i++)
			{
				cmie.Parameters.Add(new CodeLiteralExpression("key"+arrKeys[i]));
			}

			coce = new CodeObjectCreateExpression();
			coce.CreateType = PublicNamesUsed["PathClass"].ToString();
			coce.Parameters.Add(cmie);
			cctor.ChainedConstructorArgs.Add(coce);
			cctor.ChainedConstructorArgs.Add(new CodePrimitiveExpression(null));
			cc.Members.Add(cctor);
		}		
	}


	/// <summary>
	/// This function generates code for the constructor which accepts ManagementPath as the parameter.
	/// The generated code will look something like this
	///		public Cons(ManagementPath path) : this (null, path,null){
	///		}
	/// </summary>
	void GenerateConstructorWithPath()
	{
		string strPathObject = "path";
		cctor = new CodeConstructor();		
		cctor.Attributes = MemberAttributes.Public;
		cpde = new CodeParameterDeclarationExpression();
		cpde.Type = PublicNamesUsed["PathClass"].ToString();
		cpde.Name = strPathObject;
		cctor.Parameters.Add(cpde);

		cctor.ChainedConstructorArgs.Add(new CodePrimitiveExpression(null));
		cctor.ChainedConstructorArgs.Add(new CodeLiteralExpression(strPathObject));
		cctor.ChainedConstructorArgs.Add(new CodePrimitiveExpression(null));
		cc.Members.Add(cctor);
	}
	/// <summary>
	/// This function generates code for the constructor which accepts ManagementPath and GetOptions
	/// as parameters.
	/// The generated code will look something like this
	///		public Cons(ManagementPath path, ObjectGetOptions options) : this (null, path,options){
	///		}
	/// </summary>
	void GenerateConstructorWithPathOptions()
	{
		string strPathObject = "path";
		string strGetOptions = "getOptions";

		cctor = new CodeConstructor();		
		cctor.Attributes = MemberAttributes.Public;
		cctor.Parameters.Add(new CodeParameterDeclarationExpression(PublicNamesUsed["PathClass"].ToString(),
																	strPathObject));
		cctor.Parameters.Add(new CodeParameterDeclarationExpression(PublicNamesUsed["GetOptionsClass"].ToString(),
																	strGetOptions));

		cctor.ChainedConstructorArgs.Add(new CodePrimitiveExpression(null));
		cctor.ChainedConstructorArgs.Add(new CodeLiteralExpression(strPathObject));
		cctor.ChainedConstructorArgs.Add(new CodeLiteralExpression(strGetOptions));
		cc.Members.Add(cctor);
	}
	/// <summary>
	/// This function generates code for the constructor which accepts Scope as a string, path as a 
	/// string and GetOptions().
	/// The generated code will look something like this
	///		public Cons(String scope, String path, ObjectGetOptions options) : 
	///							this (new ManagementScope(scope), new ManagementPath(path),options){
	///		}
	/// </summary>
	void GenerateConstructorWithScopePath()
	{
		string strScopeObject = "scope";
		string strPathObject = "path";

		cctor = new CodeConstructor();		
		cctor.Attributes = MemberAttributes.Public;
		cctor.Parameters.Add(new CodeParameterDeclarationExpression(PublicNamesUsed["ScopeClass"].ToString(),strScopeObject));
		cctor.Parameters.Add(new CodeParameterDeclarationExpression(PublicNamesUsed["PathClass"].ToString(),strPathObject));
		cctor.ChainedConstructorArgs.Add(new CodeLiteralExpression(strScopeObject));
		cctor.ChainedConstructorArgs.Add(new CodeLiteralExpression(strPathObject));
		cctor.ChainedConstructorArgs.Add(new CodePrimitiveExpression(null));
		cc.Members.Add(cctor);
	}
	/// <summary>
	/// This function generates code for the constructor which accepts ManagementScope as parameters.
	/// The generated code will look something like this
	///		public Cons(ManagementScope scope, ObjectGetOptions options) : this (scope, <ClassName>.ConstructPath(),null){
	///		}
	/// </summary>
	void GenerateConstructorWithScope()
	{
		string strScopeObject = "scope";

		cctor = new CodeConstructor();		
		cctor.Attributes = MemberAttributes.Public;
		cctor.Parameters.Add(new CodeParameterDeclarationExpression(PublicNamesUsed["ScopeClass"].ToString(),
																	strScopeObject));
		cctor.ChainedConstructorArgs.Add(new CodeLiteralExpression(strScopeObject));
		cmie = new CodeMethodInvokeExpression();
		cmie.TargetObject = new CodeLiteralExpression(PrivateNamesUsed["GeneratedClassName"].ToString());
		cmie.MethodName = PublicNamesUsed["ConstructPathFunction"].ToString();
		cctor.ChainedConstructorArgs.Add(cmie);
		cctor.ChainedConstructorArgs.Add(new CodePrimitiveExpression(null));
		cc.Members.Add(cctor);
	}

	/// <summary>
	/// This function generates code for the constructor which accepts GetOptions
	/// as parameters.
	/// The generated code will look something like this
	///		public Cons(ObjectGetOptions options) : this (null, <ClassName>.ConstructPath(),options){
	///		}
	/// </summary>
	void GenerateConstructorWithOptions()
	{
		string strGetOptions = "getOptions";

		cctor = new CodeConstructor();		
		cctor.Attributes = MemberAttributes.Public;
		cctor.Parameters.Add(new CodeParameterDeclarationExpression(PublicNamesUsed["GetOptionsClass"].ToString(),
																	strGetOptions));

		cctor.ChainedConstructorArgs.Add(new CodePrimitiveExpression(null));
		cmie = new CodeMethodInvokeExpression();
		cmie.TargetObject = new CodeLiteralExpression(PrivateNamesUsed["GeneratedClassName"].ToString());
		cmie.MethodName = PublicNamesUsed["ConstructPathFunction"].ToString();
		cctor.ChainedConstructorArgs.Add(cmie);
		cctor.ChainedConstructorArgs.Add(new CodeLiteralExpression(strGetOptions));
		cc.Members.Add(cctor);
	}

	/// <summary>
	/// This function generates code for the constructor which accepts ManagementScope and GetOptions
	/// as parameters.
	/// The generated code will look something like this
	///		public Cons(ManagementScope scope, ObjectGetOptions options) : this (scope, <ClassName>.ConstructPath(),options){
	///		}
	/// </summary>
	void GenerateConstructorWithScopeOptions()
	{
		string strScopeObject = "scope";
		string strGetOptions = "getOptions";

		cctor = new CodeConstructor();		
		cctor.Attributes = MemberAttributes.Public;
		cctor.Parameters.Add(new CodeParameterDeclarationExpression(PublicNamesUsed["ScopeClass"].ToString(),
																	strScopeObject));
		cctor.Parameters.Add(new CodeParameterDeclarationExpression(PublicNamesUsed["GetOptionsClass"].ToString(),
																	strGetOptions));

		cctor.ChainedConstructorArgs.Add(new CodeLiteralExpression(strScopeObject));
		cmie = new CodeMethodInvokeExpression();
		cmie.TargetObject = new CodeLiteralExpression(PrivateNamesUsed["GeneratedClassName"].ToString());
		cmie.MethodName = PublicNamesUsed["ConstructPathFunction"].ToString();
		cctor.ChainedConstructorArgs.Add(cmie);
		cctor.ChainedConstructorArgs.Add(new CodeLiteralExpression(strGetOptions));
		cc.Members.Add(cctor);
	}


	/// <summary>
	/// This function generated the constructor like
	///		public cons(ManagementScope scope, ManagamentPath path,ObjectGetOptions getOptions)
	///		{
	///			PrivateObject = new ManagementObject(scope,path,getOptions);
	///			PrivateSystemProperties = new ManagementSystemProperties(PrivateObject);
	///		}
	/// </summary>
	void GenerateConstructorWithScopePathOptions()
	{
		string strScopeObject = "scope";
		string strPathObject = "path";
		string strGetOptions = "getOptions";

		cctor = new CodeConstructor();		
		cctor.Attributes = MemberAttributes.Public;
		cctor.Parameters.Add(new CodeParameterDeclarationExpression(PublicNamesUsed["ScopeClass"].ToString(),strScopeObject));
		cctor.Parameters.Add(new CodeParameterDeclarationExpression(PublicNamesUsed["PathClass"].ToString(),strPathObject));
		cctor.Parameters.Add(new CodeParameterDeclarationExpression(PublicNamesUsed["GetOptionsClass"].ToString(),strGetOptions));

		//First if path is not null, then we will check whether the class name is the same.
		//if it is not the same, then we will throw an exception
		cis = new CodeIfStatement();
		cis.Condition = new CodeBinaryOperatorExpression(new CodeLiteralExpression(strPathObject),
															CodeBinaryOperatorType.IdentityInequality,
															new CodePrimitiveExpression(null));
		CodeIfStatement cis1 = new CodeIfStatement();

		cmie = new CodeMethodInvokeExpression();
		cmie.MethodName = "Compare";
		cmie.TargetObject = new CodeLiteralExpression("String");
		cmie.Parameters.Add(new CodePropertyReferenceExpression(new CodeLiteralExpression(strPathObject),"ClassName"));
		cmie.Parameters.Add(new CodeLiteralExpression(PublicNamesUsed["ClassNameProperty"].ToString()));
		cmie.Parameters.Add(new CodePrimitiveExpression(true));
		cboe = new CodeBinaryOperatorExpression();
		cboe.Left = cmie;
		cboe.Right = new CodePrimitiveExpression(0);
		cboe.Operator = CodeBinaryOperatorType.IdentityInequality;
		cis1.Condition = cboe;
		coce = new CodeObjectCreateExpression();
		coce.CreateType = PublicNamesUsed["ArgumentExceptionClass"].ToString();
		coce.Parameters.Add(new CodePrimitiveExpression(ExceptionString));
		cis1.TrueStatements.Add(new CodeThrowExceptionStatement(coce));

		cis.TrueStatements.Add(cis1);
		cctor.Statements.Add(cis);

		coce = new CodeObjectCreateExpression();
		coce.CreateType = PublicNamesUsed["LateBoundClass"].ToString();
		coce.Parameters.Add(new CodeLiteralExpression(strScopeObject));
		coce.Parameters.Add(new CodeLiteralExpression(strPathObject));
		coce.Parameters.Add(new CodeLiteralExpression(strGetOptions));
		cctor.Statements.Add(new CodeAssignStatement(new CodeLiteralExpression(
																	PrivateNamesUsed["LateBoundObject"].ToString()),
													  coce));
		coce = new CodeObjectCreateExpression();
		coce.CreateType = PublicNamesUsed["SystemPropertiesClass"].ToString();
		cle = new CodeLiteralExpression(PrivateNamesUsed["LateBoundObject"].ToString());
		coce.Parameters.Add(cle);
		cctor.Statements.Add(new CodeAssignStatement(new CodeLiteralExpression(
																	PrivateNamesUsed["SystemPropertiesObject"].ToString()),
													  coce));
		cc.Members.Add(cctor);
		
	}
	/// <summary>
	/// This function generates code for the constructor which accepts ManagementObject as the parameter.
	/// The generated code will look something like this
	///		public Cons(ManagementObject theObject) {
	///		if(String.Compare(theObject.SystemProperties["__CLASS"].Value.ToString(),ClassName,true) == 0) {
	///				privObject = theObject;
	///				privSystemProps = new WmiSystemProps(privObject);
	///			}
	///			else {
	///				throw new ArgumentException("Class name doesn't match");
	///			}
	///		}
	/// </summary>
	void GenarateConstructorWithLateBound()
	{
		string strLateBoundObject = "theObject";
		string LateBoundSystemProperties = "SystemProperties";

		cctor = new CodeConstructor();		
		cctor.Attributes = MemberAttributes.Public;
		cpde = new CodeParameterDeclarationExpression();
		cpde.Type = PublicNamesUsed["LateBoundClass"].ToString();
		cpde.Name = strLateBoundObject;
		cctor.Parameters.Add(cpde);

		cis = new CodeIfStatement();
        cpre = new CodePropertyReferenceExpression(new CodeLiteralExpression(strLateBoundObject),LateBoundSystemProperties);
		cie = new CodeIndexerExpression(cpre,new CodePrimitiveExpression("__CLASS"));
        cpre = new CodePropertyReferenceExpression(cie,"Value");
        cmie = new CodeMethodInvokeExpression();
		cmie.MethodName = "Compare";
		cmie.TargetObject = new CodeLiteralExpression("String");
		cmie.Parameters.Add(new CodeMethodInvokeExpression(cpre,"ToString"));
		cmie.Parameters.Add(new CodeLiteralExpression(PublicNamesUsed["ClassNameProperty"].ToString()));
		cmie.Parameters.Add(new CodePrimitiveExpression(true));
		cboe = new CodeBinaryOperatorExpression();
		cboe.Left = cmie;
		cboe.Right = new CodePrimitiveExpression(0);
		cboe.Operator = CodeBinaryOperatorType.ValueEquality;
		cis.Condition = cboe;

		cis.TrueStatements.Add(new CodeAssignStatement(
								new CodeLiteralExpression(PrivateNamesUsed["LateBoundObject"].ToString()),
								new CodeLiteralExpression(strLateBoundObject)));

		coce = new CodeObjectCreateExpression();
		coce.CreateType = PublicNamesUsed["SystemPropertiesClass"].ToString();
		cle = new CodeLiteralExpression(PrivateNamesUsed["LateBoundObject"].ToString());
		coce.Parameters.Add(cle);
		cis.TrueStatements.Add(new CodeAssignStatement(new CodeLiteralExpression(PrivateNamesUsed["SystemPropertiesObject"].ToString()),coce));

		coce = new CodeObjectCreateExpression();
		coce.CreateType = PublicNamesUsed["ArgumentExceptionClass"].ToString();
		coce.Parameters.Add(new CodePrimitiveExpression(ExceptionString));
		cis.FalseStatements.Add(new CodeThrowExceptionStatement(coce));

		cctor.Statements.Add(cis);
		cc.Members.Add(cctor);
	}
/// <summary>
/// This function generates the WMI methods as the methods in the generated class.
/// The generated code will look something like this
///		public <retType> Method1(<type> param1, <type> param2,...) {
///            ManagementBaseObject inParams = null;
///            inParams = _privObject.GetMethodParameters("ChangeStartMode");
///            inParams["<inparam1>"] = <Value>;
///            inParams["<inoutparam2>"] = <Value>;
///            ................................
///            ManagementBaseObject outParams = _privObject.InvokeMethod("ChangeStartMode", inParams, null);
///            inoutParam3 = (<type>)(outParams.Properties["<inoutParam3>"]);
///            outParam4 = (String)(outParams.Properties["<outParam4>"]);
///            ................................
///            return (<retType>)(outParams.Properties["ReturnValue"].Value);
///     }
/// </summary>
	void GenerateMethods()
	{
		string strInParams = "inParams";
		string strOutParams = "outParams";

		ArrayList outParamsName = new ArrayList(5);
		ArrayList inoutParams = new ArrayList(5);
		ArrayList inoutParamsType = new ArrayList(5);

		for(int k=0;k< PublicMethods.Count;k++)
		{
			Method meth = classobj.Methods[PublicMethods.GetKey(k).ToString()];
			if(meth.OutParameters.Properties != null)
			{
				//First Populate the out Params name so that we can find in/out parameters
				foreach (Property prop in meth.OutParameters.Properties)
				{
					outParamsName.Add(prop.Name);
				}
			}

			cmm = new CodeMemberMethod();
			cmm.Attributes = MemberAttributes.Public | MemberAttributes.Final;
			cmm.Name = PublicMethods[meth.Name].ToString();			

			//Check if the method is static
			foreach (Qualifier q in meth.Qualifiers)
			{
				if(string.Compare(q.Name,"static",true) == 0)
				{
					//It is a static function
					cmm.Attributes |= MemberAttributes.Static;
					break;
				}
			}

			bool bfirst = true;
			//Generate the statement 
			//	ManagementBaseObject inParams = null;
			cmm.Statements.Add(new CodeVariableDeclarationStatement("ManagementBaseObject",
											strInParams,new CodePrimitiveExpression(null)));

			//Do these things only when there is a valid InParameters
			if(meth.InParameters != null)
			{
				//Now put the in parameters
				if(meth.InParameters.Properties != null)
				{
					foreach (Property prop in meth.InParameters.Properties)
					{
						if(bfirst == true)
						{
							//Now Generate the statement
							//	inParams = privObject.GetMethodParameters(<MethodName>);
							cmie = new CodeMethodInvokeExpression();
							cmie.MethodName = "GetMethodParameters";
							cmie.TargetObject = new CodeLiteralExpression(PrivateNamesUsed["LateBoundObject"].ToString());
							cmie.Parameters.Add(new CodePrimitiveExpression(meth.Name));
							cmm.Statements.Add(new CodeAssignStatement(new CodeLiteralExpression(strInParams),cmie));
							bfirst = false;
						}

						cpde = new CodeParameterDeclarationExpression();
						cpde.Name = prop.Name;
						cpde.Type = ManagementClassGenerator.ConvertCIMType(prop.Type,prop.IsArray,OutputLanguage);
						cpde.Direction = FieldDirection.In;
						//Find out whether it is a in/out Parameter
						for(int i=0; i < outParamsName.Count;i++)
						{
							if(string.Compare(prop.Name,outParamsName[i].ToString(),true) == 0)
							{
								//It is an in/out Parameter
								cpde.Direction = FieldDirection.Ref;
								inoutParams.Add(prop.Name);
								inoutParamsType.Add(cpde.Type);
							}
						}
						
						cmm.Parameters.Add(cpde);
						//Also generate the statement
						//inParams["PropName"] = Value;
						cie = new CodeIndexerExpression(new CodeLiteralExpression(strInParams),new CodePrimitiveExpression(prop.Name));
						
						cmm.Statements.Add(new CodeAssignStatement(cie,new CodeLiteralExpression(cpde.Name)));
					}
				}
			}
			//Now clear the outParamsName array
			outParamsName.Clear();
			bool bInOut;
			bool bRetVal = false;
			bfirst = true;
			bool bInvoke = false;
			//Do these only when the outParams is Valid
			if(meth.OutParameters != null)
			{
				if(meth.OutParameters.Properties != null)
				{
					foreach (Property prop in meth.OutParameters.Properties)
					{
						if(bfirst == true)
						{
							//Now generate the statement
							//	ManagementBaseObject outParams = privObject.InvokeMethod(<methodName>,inParams,options);
							cmie = new CodeMethodInvokeExpression();
							cmie.MethodName = "InvokeMethod";
							cmie.TargetObject = new CodeLiteralExpression(PrivateNamesUsed["LateBoundObject"].ToString());
							cmie.Parameters.Add(new CodePrimitiveExpression(meth.Name));
							cmie.Parameters.Add(new CodeLiteralExpression(strInParams));
							cmie.Parameters.Add(new CodePrimitiveExpression(null));
							cmm.Statements.Add(new CodeVariableDeclarationStatement("ManagementBaseObject",strOutParams,cmie));
							bfirst = false;
							bInvoke = true;
						}

						bInOut = false;
						for(int i=0; i < inoutParams.Count;i++)
						{
							if(string.Compare(prop.Name,inoutParams[i].ToString(),true) == 0)
							{
								bInOut = true;
							}
						}
						if(bInOut == true)
							continue;

						if(string.Compare(prop.Name,"ReturnValue",true) == 0)
						{
							cmm.ReturnType = ManagementClassGenerator.ConvertCIMType(prop.Type,prop.IsArray,OutputLanguage);
							bRetVal = true;
						}
						else
						{
							cpde = new CodeParameterDeclarationExpression();
							cpde.Name = prop.Name;
							cpde.Type = ManagementClassGenerator.ConvertCIMType(prop.Type,prop.IsArray,OutputLanguage);
							cpde.Direction = FieldDirection.Out;
							cmm.Parameters.Add(cpde);

							//Now for each out params generate the statement
							//	<outParam> = outParams.Properties["<outParam>"];
							cpre = new CodePropertyReferenceExpression(new CodeLiteralExpression(strOutParams),"Properties");
							cie = new CodeIndexerExpression(cpre,new CodePrimitiveExpression(prop.Name));
							cmm.Statements.Add(new CodeAssignStatement(new CodeLiteralExpression(prop.Name),
												new CodeCastExpression(cpde.Type,cie)));
						}
					}
				}
			}

			if(bInvoke == false)
			{
				//Now there is no out parameters to invoke the function
				//So just call Invoke.
				cmie = new CodeMethodInvokeExpression();
				cmie.MethodName = "InvokeMethod";
				cmie.TargetObject = new CodeLiteralExpression(PrivateNamesUsed["LateBoundObject"].ToString());
				cmie.Parameters.Add(new CodePrimitiveExpression(meth.Name));
				cmie.Parameters.Add(new CodeLiteralExpression(strInParams));

				cmis = new CodeMethodInvokeStatement();
				cmis.MethodInvoke = cmie;
				cmm.Statements.Add(cmis);
			}

			//Now for each in/out params generate the statement
			//	<inoutParam> = outParams.Properties["<inoutParam>"];
			for(int i=0;i < inoutParams.Count;i++)
			{
				cpre = new CodePropertyReferenceExpression(new CodeLiteralExpression(strOutParams),"Properties");
				cie = new CodeIndexerExpression(cpre,new CodePrimitiveExpression(inoutParams[i].ToString()));
				cmm.Statements.Add(new CodeAssignStatement(new CodeLiteralExpression(inoutParams[i].ToString()),
									new CodeCastExpression(inoutParamsType[i].ToString(),cie)));
			}
			inoutParams.Clear();

			//Now check if there is a return value. If there is one then return it from the function
			if(bRetVal == true)
			{
				cpre = new CodePropertyReferenceExpression(new CodeLiteralExpression(strOutParams),"Properties");
				cie = new CodeIndexerExpression(cpre,new CodePrimitiveExpression("ReturnValue"));
				cmm.Statements.Add(new CodeMethodReturnStatement(new CodeCastExpression(cmm.ReturnType,
									new CodePropertyReferenceExpression(cie,"Value"))));
			}

			cc.Members.Add(cmm);
		}
	}
	/// <summary>
	/// This function returns a Collectionclass for the query 
	///		"Select * from <ClassName>"
	///	This is a static method. The output is like this
	///		public static ServiceCollection All()
	///		{
	///			return GetInstances(null,null,null);
	///		}        

	/// </summary>
	void GenerateGetInstancesWithNoParameters()
	{
		cmm = new CodeMemberMethod();
        	
		cmm.Attributes = MemberAttributes.Public | MemberAttributes.Final | MemberAttributes.Static ;
		cmm.Name = PublicNamesUsed["FilterFunction"].ToString();
		cmm.ReturnType = PrivateNamesUsed["CollectionClass"].ToString();

		cmie = new CodeMethodInvokeExpression();
		cmie.MethodName = PublicNamesUsed["FilterFunction"].ToString();
		cmie.Parameters.Add(new CodePrimitiveExpression(null));
		cmie.Parameters.Add(new CodePrimitiveExpression(null));
		cmie.Parameters.Add(new CodePrimitiveExpression(null));
		cmm.Statements.Add(new CodeMethodReturnStatement(cmie));

		cc.Members.Add(cmm);
	}

/// <summary>
/// This function will accept the condition and will return collection for the query
///		"select * from <ClassName> where <condition>"
///	The generated code will be like
///		public static ServiceCollection GetInstances(String Condition) {
///			return GetInstances(null,Condition,null);
///     }
/// </summary>
	void GenerateGetInstancesWithCondition()
	{
		string strCondition = "condition";
		cmm = new CodeMemberMethod();
        	
		cmm.Attributes = MemberAttributes.Public | MemberAttributes.Final | MemberAttributes.Static ;
		cmm.Name = PublicNamesUsed["FilterFunction"].ToString();
		cmm.ReturnType = PrivateNamesUsed["CollectionClass"].ToString();
		cmm.Parameters.Add(new CodeParameterDeclarationExpression("String",strCondition));

		cmie = new CodeMethodInvokeExpression();
		cmie.MethodName = PublicNamesUsed["FilterFunction"].ToString();
		cmie.Parameters.Add(new CodePrimitiveExpression(null));
		cmie.Parameters.Add(new CodeLiteralExpression(strCondition));
		cmie.Parameters.Add(new CodePrimitiveExpression(null));
		cmm.Statements.Add(new CodeMethodReturnStatement(cmie));

		cc.Members.Add(cmm);
	}

	/// <summary>
	/// This function returns the collection for the query 
	///		"select <parameterList> from <ClassName>"
	///	The generated output is like
	///		public static ServiceCollection GetInstances(String []selectedProperties) {
	///			return GetInstances(null,null,selectedProperties);
    ///		}
	/// </summary>
	void GenerateGetInstancesWithProperties()
	{
		string strSelectedProperties = "selectedProperties";
		cmm = new CodeMemberMethod();
        	
		cmm.Attributes = MemberAttributes.Public | MemberAttributes.Final | MemberAttributes.Static ;
		cmm.Name = PublicNamesUsed["FilterFunction"].ToString();
		cmm.ReturnType = PrivateNamesUsed["CollectionClass"].ToString();
		cmm.Parameters.Add(new CodeParameterDeclarationExpression("String []",strSelectedProperties));

		cmie = new CodeMethodInvokeExpression();
		cmie.MethodName = PublicNamesUsed["FilterFunction"].ToString();
		cmie.Parameters.Add(new CodePrimitiveExpression(null));
		cmie.Parameters.Add(new CodePrimitiveExpression(null));
		cmie.Parameters.Add(new CodeLiteralExpression(strSelectedProperties));
		cmm.Statements.Add(new CodeMethodReturnStatement(cmie));

		cc.Members.Add(cmm);
	}

	/// <summary>
	/// This function returns the collection for the query 
	///		"select <parameterList> from <ClassName> where <WhereClause>"
	///	The generated output is like
	///		public static ServiceCollection GetInstances(String condition, String []selectedProperties) {
	///			return GetInstances(null,condition,selectedProperties);
    ///		}
	/// </summary>
	void GenerateGetInstancesWithWhereProperties()
	{
		string strSelectedProperties = "selectedProperties";
		string strCondition = "condition";
		cmm = new CodeMemberMethod();
        	
		cmm.Attributes = MemberAttributes.Public | MemberAttributes.Final | MemberAttributes.Static ;
		cmm.Name = PublicNamesUsed["FilterFunction"].ToString();
		cmm.ReturnType = PrivateNamesUsed["CollectionClass"].ToString();
		cmm.Parameters.Add(new CodeParameterDeclarationExpression("String",strCondition));
		cmm.Parameters.Add(new CodeParameterDeclarationExpression("String []",strSelectedProperties));

		cmie = new CodeMethodInvokeExpression();
		cmie.MethodName = PublicNamesUsed["FilterFunction"].ToString();
		cmie.Parameters.Add(new CodePrimitiveExpression(null));
		cmie.Parameters.Add(new CodeLiteralExpression(strCondition));
		cmie.Parameters.Add(new CodeLiteralExpression(strSelectedProperties));
		cmm.Statements.Add(new CodeMethodReturnStatement(cmie));

		cc.Members.Add(cmm);
	}

	/// <summary>
	/// This function returns a Collectionclass for the query 
	///		"Select * from <ClassName>"
	///	This is a static method. The output is like this
	///		public static ServiceCollection All()
	///		{
	///			return GetInstances(scope,null,null);
	///		}        
	///	This method takes the scope which is useful for connection to remote machine
	/// </summary>
	void GenerateGetInstancesWithScope()
	{
		string strScope = "scope";
		cmm = new CodeMemberMethod();
        	
		cmm.Attributes = MemberAttributes.Public | MemberAttributes.Final | MemberAttributes.Static ;
		cmm.Name = PublicNamesUsed["FilterFunction"].ToString();
		cmm.ReturnType = PrivateNamesUsed["CollectionClass"].ToString();
		cmm.Parameters.Add(new CodeParameterDeclarationExpression(PublicNamesUsed["ScopeClass"].ToString(),strScope));

		cmie = new CodeMethodInvokeExpression();
		cmie.MethodName = PublicNamesUsed["FilterFunction"].ToString();
		cmie.Parameters.Add(new CodeLiteralExpression(strScope));
		cmie.Parameters.Add(new CodePrimitiveExpression(null));
		cmie.Parameters.Add(new CodePrimitiveExpression(null));
		cmm.Statements.Add(new CodeMethodReturnStatement(cmie));

		cc.Members.Add(cmm);
	}

/// <summary>
/// This function will accept the condition and will return collection for the query
///		"select * from <ClassName> where <condition>"
///	The generated code will be like
///		public static ServiceCollection GetInstances(String Condition) {
///			return GetInstances(scope,Condition,null);
///     }
/// </summary>
	void GenerateGetInstancesWithScopeCondition()
	{
		string strScope = "scope";
		string strCondition = "condition";
		cmm = new CodeMemberMethod();
        	
		cmm.Attributes = MemberAttributes.Public | MemberAttributes.Final | MemberAttributes.Static ;
		cmm.Name = PublicNamesUsed["FilterFunction"].ToString();
		cmm.ReturnType = PrivateNamesUsed["CollectionClass"].ToString();
		cmm.Parameters.Add(new CodeParameterDeclarationExpression(PublicNamesUsed["ScopeClass"].ToString(),strScope));
		cmm.Parameters.Add(new CodeParameterDeclarationExpression("String",strCondition));

		cmie = new CodeMethodInvokeExpression();
		cmie.MethodName = PublicNamesUsed["FilterFunction"].ToString();
		cmie.Parameters.Add(new CodeLiteralExpression(strScope));
		cmie.Parameters.Add(new CodeLiteralExpression(strCondition));
		cmie.Parameters.Add(new CodePrimitiveExpression(null));
		cmm.Statements.Add(new CodeMethodReturnStatement(cmie));

		cc.Members.Add(cmm);
	}

	/// <summary>
	/// This function returns the collection for the query 
	///		"select <parameterList> from <ClassName>"
	///	The generated output is like
	///		public static ServiceCollection GetInstances(String []selectedProperties) {
	///			return GetInstances(scope,null,selectedProperties);
    ///		}
	/// </summary>
	void GenerateGetInstancesWithScopeProperties()
	{
		string strScope = "scope";
		string strSelectedProperties = "selectedProperties";
		cmm = new CodeMemberMethod();
        	
		cmm.Attributes = MemberAttributes.Public | MemberAttributes.Final | MemberAttributes.Static ;
		cmm.Name = PublicNamesUsed["FilterFunction"].ToString();
		cmm.ReturnType = PrivateNamesUsed["CollectionClass"].ToString();
		cmm.Parameters.Add(new CodeParameterDeclarationExpression(PublicNamesUsed["ScopeClass"].ToString(),strScope));
		cmm.Parameters.Add(new CodeParameterDeclarationExpression("String []",strSelectedProperties));

		cmie = new CodeMethodInvokeExpression();
		cmie.MethodName = PublicNamesUsed["FilterFunction"].ToString();
		cmie.Parameters.Add(new CodeLiteralExpression(strScope));
		cmie.Parameters.Add(new CodePrimitiveExpression(null));
		cmie.Parameters.Add(new CodeLiteralExpression(strSelectedProperties));
		cmm.Statements.Add(new CodeMethodReturnStatement(cmie));

		cc.Members.Add(cmm);
	}

	/// <summary>
	/// This function generates the code like 
	/// 	public static ServiceCollection GetInstances(ManagementScope scope,String Condition, String[] selectedProperties)	{
	/// 		ManagementObjectSearcher ObjectSearcher = new ManagementObjectSearcher(scope,new SelectQuery("Win32_Service",Condition,selectedProperties));
	///			QueryOptions query = new QueryOptions();
	///			query.EnsureLocatable = true;
	///			ObjectSearcher.Options = query;
    ///	        return new ServiceCollection(ObjectSearcher.Get());
	///		}
	/// </summary>
	void GenerateGetInstancesWithScopeWhereProperties()
	{
		string strScope = "scope";
		string strCondition = "condition";
		string strSelectedProperties = "selectedProperties";
		string strObjectSearcher = "ObjectSearcher";
		string strQuery = "query";

		cmm = new CodeMemberMethod();
		cmm.Attributes = MemberAttributes.Public | MemberAttributes.Final | MemberAttributes.Static ;
		cmm.Name = PublicNamesUsed["FilterFunction"].ToString();
		cmm.ReturnType = PrivateNamesUsed["CollectionClass"].ToString();

		cmm.Parameters.Add(new CodeParameterDeclarationExpression(PublicNamesUsed["ScopeClass"].ToString(),strScope));
		cmm.Parameters.Add(new CodeParameterDeclarationExpression("String",strCondition));
		cmm.Parameters.Add(new CodeParameterDeclarationExpression("String []",strSelectedProperties));

		CodeObjectCreateExpression coce1 = new CodeObjectCreateExpression();
		coce1.CreateType = PublicNamesUsed["QueryClass"].ToString();
		coce1.Parameters.Add(new CodePrimitiveExpression(OriginalClassName));
		coce1.Parameters.Add(new CodeLiteralExpression(strCondition));
		coce1.Parameters.Add(new CodeLiteralExpression(strSelectedProperties));

		coce = new CodeObjectCreateExpression();
		coce.CreateType = PublicNamesUsed["ObjectSearcherClass"].ToString();
		coce.Parameters.Add(new CodeLiteralExpression(strScope));
		coce.Parameters.Add(coce1);
	
		cmm.Statements.Add(new CodeVariableDeclarationStatement(PublicNamesUsed["ObjectSearcherClass"].ToString(),
																strObjectSearcher,coce));

		coce = new CodeObjectCreateExpression();
		coce.CreateType = PublicNamesUsed["QueryOptionsClass"].ToString();
		cmm.Statements.Add(new CodeVariableDeclarationStatement(PublicNamesUsed["QueryOptionsClass"].ToString(),strQuery,coce));

		cmm.Statements.Add(new CodeAssignStatement(new CodePropertyReferenceExpression(
														new CodeLiteralExpression(strQuery),
														"EnsureLocatable"),
													new CodePrimitiveExpression(true)));


		cmm.Statements.Add(new CodeAssignStatement(new CodePropertyReferenceExpression(
														new CodeLiteralExpression(strObjectSearcher),
														"Options"),
													new CodeLiteralExpression(strQuery)));
	
		coce = new CodeObjectCreateExpression();
		coce.CreateType = PrivateNamesUsed["CollectionClass"].ToString();
		coce.Parameters.Add(new CodeMethodInvokeExpression(new CodeLiteralExpression(strObjectSearcher),
															"Get"));
		cmm.Statements.Add(new CodeMethodReturnStatement(coce));

		cc.Members.Add(cmm);
	}

	/// <summary>
	/// This function will add the variable as a private member to the class.
	/// The generated code will look like this
	///         private <MemberType> <MemberName>;
	/// </summary>
	void GeneratePrivateMember(string memberName,string MemberType)
	{
		GeneratePrivateMember(memberName,MemberType,null);
	}

	/// <summary>
	/// This function will add the variable as a private member to the class.
	/// The generated code will look like this
	///         private <MemberType> <MemberName> = <initValue>;
	/// </summary>
	void GeneratePrivateMember(string memberName,string MemberType,CodeExpression initExpression)
	{
		cf = new CodeMemberField();
		cf.Name = memberName;
		cf.Attributes = MemberAttributes.Private | MemberAttributes.Final ;
		cf.Type = MemberType;
		if(initExpression != null)
		{
			cf.InitExpression = initExpression;
		}
		cc.Members.Add(cf);
	}
/// <summary>
/// This is a simple helper function used to convert a given string to title case.
/// </summary>
/// <param name="str"> </param>
	public string ConvertToTitleCase(string str)
	{
		if(str.Length == 0)
		{
			return string.Copy("");
		}

		char[] arrString = str.ToLower().ToCharArray();
		//Convert the first character to uppercase
		arrString[0] = Char.ToUpper(arrString[0]);

		for(int i=0;i < str.Length;i++)
		{
			if(Char.IsLetterOrDigit(arrString[i]) == false)
			{
				//Some other character. So convert the next character to Upper case
				arrString[i+1] = Char.ToUpper(arrString[i+1]);
			}
		}
		return new string(arrString);
	}

	void GenerateTypeConverterClass()
	{
		string TypeDescriptorContextClass = "ITypeDescriptorContext";
		string contextObject = "context";
		string ActualObject = "obj";
		string CreationBundleClass = "CreationBundle";
		string CreationBundleObject = "objectCreationBundle";
		string InternalName = "Value";
		string creationArgumentClass = "CreationArgument";
		string strPath = "Path";
		
		CodeClass CodeConvertorClass = new CodeClass(PrivateNamesUsed["ConverterClass"].ToString());
		CodeConvertorClass.BaseTypes.Add(PublicNamesUsed["TypeConverter"].ToString());

		cmm = new CodeMemberMethod();
		cmm.Attributes = MemberAttributes.Public | MemberAttributes.Override;
		cmm.Name = "GetPersistInfo";
		cmm.Parameters.Add(new CodeParameterDeclarationExpression(TypeDescriptorContextClass,contextObject));
		cmm.Parameters.Add(new CodeParameterDeclarationExpression("Object",ActualObject));
		cmm.ReturnType = "PersistInfo";

		cmm.Statements.Add(new CodeVariableDeclarationStatement(CreationBundleClass,
																CreationBundleObject,
																new CodePrimitiveExpression(null)));

		cboe = new CodeBinaryOperatorExpression();
		cboe.Left = new CodeLiteralExpression(ActualObject);
		cboe.Right = new CodeLiteralExpression(PrivateNamesUsed["GeneratedClassName"].ToString());
		cboe.Operator = CodeBinaryOperatorType.IdentityEquality;

		cis = new CodeIfStatement();
		cmie = new CodeMethodInvokeExpression();
		cmie.MethodName = "Compare";
		cmie.TargetObject = new CodeLiteralExpression("String");
		cmie.Parameters.Add(new CodeMethodInvokeExpression(
								new CodeMethodInvokeExpression(new CodeLiteralExpression(ActualObject),
																"GetType"),
								"ToString"));

		cmie.Parameters.Add(new CodePrimitiveExpression(PrivateNamesUsed["GeneratedClassName"].ToString()));
		cmie.Parameters.Add(new CodePrimitiveExpression(true));
		cboe = new CodeBinaryOperatorExpression();
		cboe.Left = cmie;
		cboe.Right = new CodePrimitiveExpression(0);
		cboe.Operator = CodeBinaryOperatorType.ValueEquality;
		cis.Condition = cboe;

		cis.TrueStatements.Add(new CodeVariableDeclarationStatement(
													PrivateNamesUsed["GeneratedClassName"].ToString(),
													InternalName,
								new CodeCastExpression(PrivateNamesUsed["GeneratedClassName"].ToString(),
								new CodeLiteralExpression(ActualObject))));

		coce = new CodeObjectCreateExpression();
		coce.CreateType = CreationBundleClass;
		coce.Parameters.Add(new CodeTypeOfExpression(PrivateNamesUsed["GeneratedClassName"].ToString()));
		coce.Parameters.Add(new CodePrimitiveExpression(null));

		CodeArrayCreateExpression cace = new CodeArrayCreateExpression();
		cace.CreateType = creationArgumentClass;
		CodeObjectCreateExpression coce1 = new CodeObjectCreateExpression();
		coce1.CreateType = creationArgumentClass;
		coce1.Parameters.Add(new CodePropertyReferenceExpression(new CodePropertyReferenceExpression(new CodeLiteralExpression(InternalName),
																			strPath),"ClassName"));
		coce1.Parameters.Add(new CodeTypeOfExpression("String"));
		cace.Initializers.Add(coce1);
		coce.Parameters.Add(cace);

		cis.TrueStatements.Add(new CodeAssignStatement(new CodeLiteralExpression(CreationBundleObject),
															coce));
		cmm.Statements.Add(cis);
		cmm.Statements.Add(new CodeMethodReturnStatement(new CodeLiteralExpression(CreationBundleObject)));
	
		CodeConvertorClass.Members.Add(cmm);

		//For GetProperties Function

		string MemberAttribiutesArrayClass = "MemberAttribute[]";
		string MemberAttributesObject = "attributes";
		string PropertyDescriptorCollectionClass = "PropertyDescriptorCollection";

		cmm = new CodeMemberMethod();
		cmm.Attributes = MemberAttributes.Public | MemberAttributes.Override;
		cmm.Name = "GetProperties";
		cmm.Parameters.Add(new CodeParameterDeclarationExpression(TypeDescriptorContextClass,contextObject));
		cmm.Parameters.Add(new CodeParameterDeclarationExpression("Object",ActualObject));
		cmm.Parameters.Add(new CodeParameterDeclarationExpression(MemberAttribiutesArrayClass,MemberAttributesObject));
        cmm.ReturnType = PropertyDescriptorCollectionClass;

		cmie = new CodeMethodInvokeExpression();
		cmie.TargetObject =  new CodeLiteralExpression("TypeDescriptor");
		cmie.MethodName = "GetProperties";
		cmie.Parameters.Add(new CodeTypeOfExpression(PrivateNamesUsed["GeneratedClassName"].ToString()));
		cmie.Parameters.Add(new CodeLiteralExpression(MemberAttributesObject));
		cmm.Statements.Add(new CodeMethodReturnStatement(cmie));

		CodeConvertorClass.Members.Add(cmm);

		//For GetPropertiesSupported Function
		cmm = new CodeMemberMethod();
		cmm.Attributes = MemberAttributes.Public | MemberAttributes.Override;
		cmm.Name = "GetPropertiesSupported";
		cmm.Parameters.Add(new CodeParameterDeclarationExpression(TypeDescriptorContextClass,contextObject));
        cmm.ReturnType = "Boolean";

		cmm.Statements.Add(new CodeMethodReturnStatement(new CodePrimitiveExpression(true)));
		CodeConvertorClass.Members.Add(cmm);
		
		cn.Classes.Add(CodeConvertorClass);
	}

	public void GenerateCollectionClass()
	{
		string strManagementObjectCollectionType = "ManagementObjectCollection";
		string strObjectCollection = "ObjectCollection";
		string strobjCollection = "objCollection";

		//public class ServiceCollection : ICollection, IEnumerable
		ccc = new CodeClass(PrivateNamesUsed["CollectionClass"].ToString());
		ccc.BaseTypes.Add("ICollection");
		ccc.BaseTypes.Add("IEnumerable");

		//private ManagementObjectCollection objCollection;
		cf = new CodeMemberField();
		cf.Name = strObjectCollection;
		cf.Attributes = MemberAttributes.Private | MemberAttributes.Final ;
		cf.Type = strManagementObjectCollectionType;
		ccc.Members.Add(cf);

		//internal ServiceCollection(ManagementObjectCollection obj)
		//{
		//	objCollection = obj;
		//}

		cctor = new CodeConstructor();
//		cctor.Attributes = MemberAttributes.Assembly;
		cctor.Attributes = MemberAttributes.Public;
		cpde = new CodeParameterDeclarationExpression();
		cpde.Name = strobjCollection;
		cpde.Type = strManagementObjectCollectionType;
		cctor.Parameters.Add(cpde);

		cctor.Statements.Add(new CodeAssignStatement(new CodeLiteralExpression(strObjectCollection),
													new CodeLiteralExpression(strobjCollection)));
		ccc.Members.Add(cctor);
		
		
		//public Int32 Count {
		//	get { 
		//			return objCollection.Count; 
		//		}
		//}

		cmp = new CodeMemberProperty();
		cmp.Type = "Int32";
		cmp.Attributes = MemberAttributes.Public | MemberAttributes.Final;
		cmp.Name = "Count";
		cmp.ImplementsType = "ICollection";
		cmp.GetStatements.Add(new CodeMethodReturnStatement(new CodePropertyReferenceExpression(
															new CodeLiteralExpression(strObjectCollection),
															"Count")));
		ccc.Members.Add(cmp);

		//public bool IsReadOnly {
		//		get {
		//			return objCollection.IsReadOnly;
		//		}
		//	}

		cmp = new CodeMemberProperty();
		cmp.Type = "Boolean";
		cmp.Attributes = MemberAttributes.Public | MemberAttributes.Final;
		cmp.Name = "IsReadOnly";
		cmp.ImplementsType = "ICollection";
		cmp.GetStatements.Add(new CodeMethodReturnStatement(new CodePropertyReferenceExpression(
															new CodeLiteralExpression(strObjectCollection),
															"IsReadOnly")));
		ccc.Members.Add(cmp);

 		//public bool IsSynchronized {
		//	get {
		//		return objCollection.IsSynchronized;
		//	}
		//}

		cmp = new CodeMemberProperty();
		cmp.Type = "Boolean";
		cmp.Attributes = MemberAttributes.Public | MemberAttributes.Final;
		cmp.Name = "IsSynchronized";
		cmp.ImplementsType = "ICollection";
		cmp.GetStatements.Add(new CodeMethodReturnStatement(new CodePropertyReferenceExpression(
															new CodeLiteralExpression(strObjectCollection),
															"IsSynchronized")));
		ccc.Members.Add(cmp);

		//public Object SyncRoot { 
		//	get { 
		//		return this; 
		//	} 
		//}

		cmp = new CodeMemberProperty();
		cmp.Type = "Object";
		cmp.Attributes = MemberAttributes.Public | MemberAttributes.Final;
		cmp.Name = "SyncRoot";
		cmp.ImplementsType = "ICollection";
		cmp.GetStatements.Add(new CodeMethodReturnStatement(new CodeThisReferenceExpression()));
		ccc.Members.Add(cmp);

		//public void CopyTo (Array array, Int32 index) 
		//{
		//	objCollection.CopyTo(array,index);
		//	for(int iCtr=0;iCtr < array.Length ;iCtr++)
		//	{
		//		array.SetValue(new Service((ManagementObject)array.GetValue(iCtr)),iCtr);
		//	}
		//}

		string strArray = "array";
		string strIndex = "index";
		string strnCtr = "nCtr";

		cmm = new CodeMemberMethod();
		cmm.Attributes = MemberAttributes.Public | MemberAttributes.Final;
		cmm.Name = "CopyTo";
		cmm.ImplementsType = "ICollection";

		cpde = new CodeParameterDeclarationExpression();
		cpde.Name = strArray;
		cpde.Type = "Array";
		cmm.Parameters.Add(cpde);

		cpde = new CodeParameterDeclarationExpression();
		cpde.Name = strIndex;
		cpde.Type = "Int32";
		cmm.Parameters.Add(cpde);

		cmie = new CodeMethodInvokeExpression();
		cmie.MethodName = "CopyTo";
		cmie.TargetObject = new CodeLiteralExpression(strObjectCollection);
		cmie.Parameters.Add(new CodeLiteralExpression(strArray));
		cmie.Parameters.Add(new CodeLiteralExpression(strIndex));
		cmm.Statements.Add(new CodeMethodInvokeStatement(cmie));

		cfls = new CodeForLoopStatement();
		cfls.InitStatement = new CodeVariableDeclarationStatement("Int32",strnCtr,new CodePrimitiveExpression(0));
		cboe = new CodeBinaryOperatorExpression();
		cboe.Left = new CodeLiteralExpression(strnCtr);
		cboe.Operator = CodeBinaryOperatorType.LessThan;
		cboe.Right = new CodePropertyReferenceExpression(new CodeLiteralExpression(strArray),"Length");
		cfls.TestExpression = cboe;
		cfls.IncrementStatement = new CodeAssignStatement(new CodeLiteralExpression(strnCtr),
														  new CodeBinaryOperatorExpression(
																new CodeLiteralExpression(strnCtr),
																CodeBinaryOperatorType.Add,
																new CodePrimitiveExpression(1)));

		cmie = new CodeMethodInvokeExpression();
		cmie.MethodName = "SetValue";
		cmie.TargetObject = new CodeLiteralExpression(strArray);
		
		CodeMethodInvokeExpression cmie1 = new CodeMethodInvokeExpression();
		cmie1.MethodName = "GetValue";
		cmie1.TargetObject = new CodeLiteralExpression(strArray);
		cmie1.Parameters.Add(new CodeLiteralExpression(strnCtr));

		coce = new CodeObjectCreateExpression();
		coce.CreateType = PrivateNamesUsed["GeneratedClassName"].ToString();
		coce.Parameters.Add(new CodeCastExpression(PublicNamesUsed["LateBoundClass"].ToString(),cmie1));

		cmie.Parameters.Add(coce);
		cmie.Parameters.Add(new CodeLiteralExpression(strnCtr));
		cfls.Statements.Add(new CodeMethodInvokeStatement(cmie));

		cmm.Statements.Add(cfls);
		ccc.Members.Add(cmm);

		//ServiceEnumerator GetEnumerator()
		//{
		//	return new ServiceEnumerator (objCollection.GetEnumerator());
		//}

		cmm = new CodeMemberMethod();
		cmm.Attributes = MemberAttributes.Public | MemberAttributes.Final;
		cmm.Name = "GetEnumerator";
//		cmm.ReturnType = PrivateNamesUsed["EnumeratorClass"].ToString();
		cmm.ReturnType = "IEnumerator";
		coce = new CodeObjectCreateExpression();
		coce.CreateType = PrivateNamesUsed["EnumeratorClass"].ToString();
		coce.Parameters.Add(new CodeMethodInvokeExpression(new CodeLiteralExpression(strObjectCollection),"GetEnumerator"));
		cmm.Statements.Add(new CodeMethodReturnStatement(coce));
		ccc.Members.Add(cmm);

		//IEnumerator IEnumerable.GetEnumerator()
		//{
		//	return GetEnumerator ();
		//}

		cmm = new CodeMemberMethod();
		cmm.Attributes = MemberAttributes.VTableMask;
		cmm.Name = "GetEnumerator";
		cmm.ReturnType = "IEnumerator";
		cmm.ImplementsType = "IEnumerable";
		cmie = new CodeMethodInvokeExpression();
		cmie.MethodName = "GetEnumerator";
		cmm.Statements.Add(new CodeMethodReturnStatement(cmie));
		ccc.Members.Add(cmm);

		//Now generate the Enumerator Class
		GenerateEnumeratorClass();
		cc.Members.Add(ccc);
	}

	public void GenerateEnumeratorClass()
	{
		string strObjectEnumerator = "ObjectEnumerator";
		string strManagementObjectEnumeratorType = "ManagementObjectEnumerator";
		string strManagementObjectCollectionType = "ManagementObjectCollection";
		string strobjEnum = "objEnum";


		//public class ServiceEnumerator : IEnumerator
		ecc = new CodeClass(PrivateNamesUsed["EnumeratorClass"].ToString());
		ecc.BaseTypes.Add("IEnumerator");

		//private ManagementObjectCollection.ManagementObjectEnumerator ObjectEnumerator;
		cf = new CodeMemberField();
		cf.Name = strObjectEnumerator;
		cf.Attributes = MemberAttributes.Private | MemberAttributes.Final ;
		cf.Type = strManagementObjectCollectionType+"."+strManagementObjectEnumeratorType;
		ecc.Members.Add(cf);

		//constructor
		//internal ServiceEnumerator(ManagementObjectCollection.ManagementObjectEnumerator objEnum)
		//{
		//	ObjectEnumerator = objEnum;
		//}
		cctor = new CodeConstructor();
//		cctor.Attributes = MemberAttributes.Assembly;
		cctor.Attributes = MemberAttributes.Public;
		cpde = new CodeParameterDeclarationExpression();
		cpde.Name = strobjEnum;
		cpde.Type = strManagementObjectCollectionType+"."+strManagementObjectEnumeratorType;
		cctor.Parameters.Add(cpde);

		cctor.Statements.Add(new CodeAssignStatement(new CodeLiteralExpression(strObjectEnumerator),
													new CodeLiteralExpression(strobjEnum)));
		ecc.Members.Add(cctor);

		//public Service Current {
		//get {
		//		return new Service((ManagementObject)ObjectEnumerator.Current);
		//	}
		//}

		cmp = new CodeMemberProperty();
//		cmp.Type = PrivateNamesUsed["GeneratedClassName"].ToString();
		cmp.Type = "Object";
		cmp.Attributes = MemberAttributes.Public | MemberAttributes.Final;
		cmp.Name = "Current";
		cmp.ImplementsType = "IEnumerator";
		coce = new CodeObjectCreateExpression();
		coce.CreateType = PrivateNamesUsed["GeneratedClassName"].ToString();
		coce.Parameters.Add(new CodeCastExpression(PublicNamesUsed["LateBoundClass"].ToString(),
													new CodePropertyReferenceExpression(
														new CodeLiteralExpression(strObjectEnumerator),
														"Current")));
		cmp.GetStatements.Add(new CodeMethodReturnStatement(coce));
		ecc.Members.Add(cmp);

/*		//object IEnumerator.Current {
		//get {
		//		return Current;
		//	}
		//}

		cmp = new CodeMemberProperty();
		cmp.Attributes = MemberAttributes.VTableMask;
		cmp.Type = "object";
		cmp.Name = "IEnumerator.Current";
		cmp.GetStatements.Add(new CodeMethodReturnStatement(new CodeLiteralExpression("Current")));
		ecc.Members.Add(cmp);
*/
		//public bool MoveNext ()
		//{
		//	return ObjectEnumerator.MoveNext();
		//}

		cmm = new CodeMemberMethod();
		cmm.Attributes = MemberAttributes.Public | MemberAttributes.Final;
		cmm.Name = "MoveNext";
		cmm.ImplementsType = "IEnumerator";
		cmm.ReturnType = "Boolean";
		cmie = new CodeMethodInvokeExpression();
		cmie.MethodName = "MoveNext";
		cmie.TargetObject = new CodeLiteralExpression(strObjectEnumerator);
		cmm.Statements.Add(new CodeMethodReturnStatement(cmie));
		ecc.Members.Add(cmm);

		//public void Reset ()
		//{
		//	ObjectEnumerator.Reset();
		//}

		cmm = new CodeMemberMethod();
		cmm.Attributes = MemberAttributes.Public | MemberAttributes.Final;
		cmm.Name = "Reset";
		cmm.ImplementsType = "IEnumerator";
		cmie = new CodeMethodInvokeExpression();
		cmie.MethodName = "Reset";
		cmie.TargetObject = new CodeLiteralExpression(strObjectEnumerator);
		cmm.Statements.Add(new CodeMethodInvokeStatement(cmie));
		ecc.Members.Add(cmm);

		ccc.Members.Add(ecc);
	}
/// <summary>
/// This function will find a given string in the passed 
/// in a case insensitive manner and will return true if the string is found.
/// </summary>
	int IsContainedIn(String strToFind, ref CaseInsensitiveSortedList sortedList)
	{
		int nIndex = -1;
		for (int i=0; i < sortedList.Count; i++)
		{
			if(String.Compare(sortedList.GetByIndex(i).ToString(),strToFind,true) == 0)
			{
				//The string is found. This is the index
				nIndex = i;
				break;
			}
		}
		return nIndex;
	}
/// <summary>
/// This function will convert the given CIMTYPE to an acceptable .NET type.
/// Since CLS doen't support lotz of the basic types, we are using .NET helper 
/// classes here. We safely assume that there won't be any problem using them
/// since .NET has to be there for the System.Management.Dll to work.
/// </summary>
/// <param name="cType"> </param>
/// <param name="Name"> </param>
	public static string ConvertCIMType(CIMType cType,bool isArray,Languages Language)
	{
		string retVal;
		switch(cType)
		{
			case CIMType.Sint8:
			{
				retVal = "SByte";
				break;
			}
			case CIMType.Uint8: //TODO : is this fine???
			{
				retVal = "Byte";
				break;
			}
			case CIMType.Sint16:
			{
				retVal = "Int16";
				break;
			}
			case CIMType.Uint16:
			{
				if(ManagementClassGenerator.UnsignedNotSupported(Language) == true)
				{
					retVal = "Int16";
				}
				else
				{
					retVal = "UInt16";
				}
				break;
			}
			case CIMType.Sint32:
			{
				retVal = "Int32";
				break;
			}
			case CIMType.Uint32:
			{
				if(ManagementClassGenerator.UnsignedNotSupported(Language) == true)
				{
					retVal = "Int32";
				}
				else
				{
					retVal = "UInt32";
				}
				break;
			}
			case CIMType.Sint64:
			{
				retVal = "Int64";
				break;
			}
			case CIMType.Uint64:
			{
				if(ManagementClassGenerator.UnsignedNotSupported(Language) == true)
				{
					retVal = "Int64";
				}
				else
				{
					retVal = "UInt64";
				}
				break;
			}
			case CIMType.Real32:
			{
				retVal = "Single";
				break;
			}
			case CIMType.Real64:
			{
				retVal = "Double";
				break;
			}
			case CIMType.Boolean:
			{
				retVal = "Boolean";
				break;
			}
			case CIMType.String:
			{
				retVal = "String";
				break;
			}
			case CIMType.DateTime:
			{
				retVal = "DateTime";
				break;
			}
			case CIMType.Reference:
			{
				retVal = "";		//????
				break;
			}
			case CIMType.Char16:
			{
				retVal = "Char";
				break;
			}
			case CIMType.Object:
			default:
				retVal = "ManagementObject";
				break;
		}

		if(isArray == true)
		{
			retVal += " []";
		}
		return retVal;
	}
/// <summary>
/// This function is used to determine whether the given CIMTYPE can be represented as an integer.
/// This helper function is mainly used to determine whether this type will be support by enums.
/// </summary>
/// <param name="cType"> </param>
	public bool isTypeInt(CIMType cType)
	{
		bool retVal;
		switch(cType)
		{
			case CIMType.Uint8: //TODO : is this fine???
			case CIMType.Uint16:
			case CIMType.Uint32:
			case CIMType.Sint8:
			case CIMType.Sint16:
			case CIMType.Sint32:
			{
				retVal = true;
				break;
			}
			case CIMType.Sint64:
			case CIMType.Uint64:
			case CIMType.Real32:
			case CIMType.Real64:
			case CIMType.Boolean:
			case CIMType.String:
			case CIMType.DateTime:
			case CIMType.Reference:
			case CIMType.Char16:
			case CIMType.Object:
			default:
				retVal = false;
				break;
		}

		return retVal;

	}

	public static bool UnsignedNotSupported(Languages Language)
	{
		bool isNotSupported = true;
		switch(Language)
		{
			case Languages.CSharp:
				isNotSupported = false;
				break;
			default:
				break;
		}	
		return isNotSupported;
	}
}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\setup\bin\wbemupgradedll\main.cpp ===
/*++

Copyright (C) 1997-2000 Microsoft Corporation

Module Name:

    main.cpp

Abstract:

    DllRegServer implementation, and other important DLL entry points

History:


--*/

#include "precomp.h"
#include "upgrade.h"
#include <cominit.h>
#include <stdio.h>

char g_szLangId[LANG_ID_STR_SIZE];

//***************************************************************************
//
// DllRegisterServer
//
// Purpose: Called during NT setup to perform various setup tasks
//          (This is not the normal use of DllRegisterServer!)
//
// Return:  NOERROR
//***************************************************************************

STDAPI DllRegisterServer(void)
{ 
	LogMessage(MSG_INFO, "================================================================================");
	LogMessage(MSG_INFO, "Beginning Wbemupgd.dll Registration");

	RecordFileVersion();

	InitializeCom();

	CallEscapeRouteBeforeMofCompilation();
	DoCoreUpgrade(Core);
	CallEscapeRouteAfterMofCompilation();

	HRESULT t_Result = UpdateServiceSecurity () ;
	if ( SUCCEEDED ( t_Result ) )
	{
		LogMessage(MSG_INFO, "Wbemupgd.dll Service Security upgrade succeeded.");
	}
	else
	{
		LogMessage(MSG_ERROR, "Wbemupgd.dll Service Security upgrade failed.");
	}

	DoWDMNamespaceInit();

	SetWBEMBuildRegValue();

	EnableESS();

#ifdef _X86_
	RemoveOldODBC();
#endif

	CoUninitialize();

	ClearWMISetupRegValue();

	LogMessage(MSG_INFO, "Wbemupgd.dll Registration completed.");
	LogMessage(MSG_INFO, "================================================================================");

    return NOERROR;
}

const CHAR WDMProvRegistration[] =
"#pragma namespace (\"\\\\\\\\.\\\\Root\\\\WMI\")"
"instance of __Win32Provider"
"{"
"	ClientLoadableCLSID = \"{B0A2AB46-F612-4469-BEC4-7AB038BC476C}\";"
"	CLSID = \"{B0A2AB46-F612-4469-BEC4-7AB038BC476C}\";"
"	Name = \"HiPerfCooker_v1\";"
"	HostingModel = \"LocalSystemHost\";"
"};"
"instance of __Win32Provider"
"{"
"    Name = \"WMIProv\";"
"    ClsId   = \"{D2D588B5-D081-11d0-99E0-00C04FC2F8EC}\" ;"
"    ClientLoadableCLSID= \"{35B78F79-B973-48c8-A045-CAEC732A35D5}\" ;"
"    PerUserInitialization = \"TRUE\";"
"    UnloadTimeOut = \"00000000000500.000000:000\";"
"    HostingModel = \"LocalSystemHost\";"
"};";


//***************************************************************************
//
// DllInstall
//
// Purpose: Called during XP SP update to perform various setup tasks
//
// Return:  NOERROR
//***************************************************************************

extern "C" HRESULT DllInstall( BOOL bInstall, LPCWSTR pszCmdLine)
{
	if (bInstall && !lstrcmpiW(pszCmdLine, L"XPSP1_UPDATE"))
	{
		LogMessage(MSG_INFO, "================================================================================");
		LogMessage(MSG_INFO, "Beginning WBEM Service Pack Installation");

		InitializeCom();

             IMofCompiler * pCompiler = NULL;
             SCODE sc = CoCreateInstance(CLSID_MofCompiler, 0, CLSCTX_INPROC_SERVER, IID_IMofCompiler, (LPVOID *) &pCompiler);
             if (SUCCEEDED(sc))
             {
                WBEM_COMPILE_STATUS_INFO CompInfo;
                memset(&CompInfo,0,sizeof(CompInfo));
                sc = pCompiler->CompileBuffer(sizeof(WDMProvRegistration),
                                                                (BYTE *)WDMProvRegistration,
                                                                NULL,NULL,NULL,NULL,
                                                                0,0,0,&CompInfo);
                if (FAILED(sc))
                {
                    char pBuff[128];
                    StringCchPrintfA(pBuff,128,"Wbemupgd.dll CompileBuffer hr = %08x\n",sc);
                    LogMessage(MSG_ERROR,pBuff);
                    StringCchPrintfA(pBuff,128, "    Phase %x hRes %08x Obj %d FirstLine %d LastLine %d\n",
                                                          CompInfo.lPhaseError,
                                                          CompInfo.hRes,
                                                          CompInfo.ObjectNum,
                                                          CompInfo.FirstLine,
                                                          CompInfo.LastLine);
                    LogMessage(MSG_ERROR,pBuff);
                    
                }
                pCompiler->Release();
             }
             else
             {
                 LogMessage(MSG_ERROR, "Wbemupgd.dll could not CoCreate CLSID_MofCompiler.\n");
             }
        

		HRESULT t_Result = UpdateServiceSecurity () ;
		if ( SUCCEEDED ( t_Result ) )
		{
			LogMessage(MSG_INFO, "Wbemupgd.dll Service Security upgrade succeeded (XP SP update).");
		}
		else
		{
			LogMessage(MSG_ERROR, "Wbemupgd.dll Service Security upgrade failed (XP SP update).");
		}

		CoUninitialize();

		LogMessage(MSG_INFO, "WBEM Service Pack Installation completed.");
		LogMessage(MSG_INFO, "================================================================================");
	}

	return NOERROR;
}


//***************************************************************************
//
// MUI_InstallMFLFiles
//
// Purpose: Do the MUI MFL install
//
// Return:  bRet -- true indicates success
//***************************************************************************

BOOL CALLBACK MUI_InstallMFLFiles(wchar_t* pMUIInstallLanguage)
{
	LogMessage(MSG_INFO, "================================================================================");
	if (!pMUIInstallLanguage || !wcslen(pMUIInstallLanguage) || (wcslen(pMUIInstallLanguage) > MAX_MSG_TEXT_LENGTH))
	{
		LogMessage(MSG_ERROR, "MUI installation failed because no language code was passed.");
		LogMessage(MSG_INFO, "================================================================================");
		return FALSE;
	}

	char szTemp[MAX_MSG_TEXT_LENGTH+1];
	sprintf(szTemp, "Beginning MUI installation for language %S.", pMUIInstallLanguage);
	LogMessage(MSG_INFO, szTemp);

	wcstombs(g_szLangId, pMUIInstallLanguage, LANG_ID_STR_SIZE);

	InitializeCom();

	CMultiString mszSystemMofs;
	GetStandardMofs(mszSystemMofs, MUI);
	
	bool bRet = DoMofLoad(L"MUI", mszSystemMofs);

	CoUninitialize();

	LogMessage(MSG_INFO, "MUI installation completed.");
	LogMessage(MSG_INFO, "================================================================================");

	return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\setup\bin\wbemupgradedll\reg.cpp ===
/*++

Copyright (C) 1997-2000 Microsoft Corporation

Module Name:

    reg.cpp

Abstract:

    Implementation of the registry helper class

History:


--*/
#include "precomp.h"
#include "reg.h"
#include <stdio.h>

Registry::Registry(char *pszLocalMachineStartKey)
{
    hPrimaryKey	= 0;
    hSubkey = 0;
    m_nStatus = Open(HKEY_LOCAL_MACHINE, pszLocalMachineStartKey);
    hSubkey = hPrimaryKey;
}
Registry::~Registry()
{
    if (hSubkey)
        RegCloseKey(hSubkey);
    if (hPrimaryKey != hSubkey)
        RegCloseKey(hPrimaryKey);
}
int Registry::Open(HKEY hStart, const char *pszStartKey)
{
    int nStatus = no_error;
    DWORD dwDisp = 0;

	m_nLastError = RegCreateKeyEx(hStart, pszStartKey,
									0, 0, 0,
									KEY_ALL_ACCESS, 0, &hPrimaryKey, &dwDisp);

    if (m_nLastError != 0)
            nStatus = failed;

    return nStatus;
}
char* Registry::GetMultiStr(const char *pszValueName, DWORD &dwSize)
{
	//Find out the size of the buffer required
	DWORD dwType;
	m_nLastError = RegQueryValueEx(hSubkey, pszValueName, 0, &dwType, NULL, &dwSize);

	//If the error is an unexpected one bail out
	if ((m_nLastError != ERROR_SUCCESS) || (dwType != REG_MULTI_SZ))
	{
		dwSize = 0;
		return NULL;
	}
	if (dwSize == 0)
	{
		return NULL;
	}

	//allocate the buffer required
	char *pData = new char[dwSize];
	if (!pData)
	{
		dwSize = 0;
		return NULL;
	}
	
	//get the values
	m_nLastError = RegQueryValueEx(hSubkey, 
								   pszValueName, 
								   0, 
								   &dwType, 
								   LPBYTE(pData), 
								   &dwSize);

	//if an error bail out
	if (m_nLastError != 0)
	{
		delete [] pData;
		dwSize = 0;
		return NULL;
	}

	return pData;
}

int Registry::SetMultiStr(const char *pszValueName, const char*pszValue, DWORD dwSize)
{
	m_nLastError = RegSetValueEx(hSubkey, 
								 pszValueName, 
								 0, 
								 REG_MULTI_SZ, 
								 LPBYTE(pszValue), 
								 dwSize);

    if (m_nLastError != 0)
		return failed;

    return no_error;
}

int Registry::GetStr(const char *pszValueName, char **pValue)
{
    *pValue = 0;
    DWORD dwSize = 0;
    DWORD dwType = 0;

	m_nLastError = RegQueryValueEx(hSubkey, pszValueName, 0, &dwType,
									0, &dwSize);
    if (m_nLastError != 0)
		return failed;

    if (dwType != REG_SZ && dwType != REG_EXPAND_SZ)
        return failed;

    char *p = new char[dwSize];
	if (!p)
		return failed;

	m_nLastError = RegQueryValueEx(hSubkey, pszValueName, 0, &dwType,
									LPBYTE(p), &dwSize);
    if (m_nLastError != 0)
    {
        delete [] p;
		return failed;
    }

    if(dwType == REG_EXPAND_SZ)
    {
		char tTemp;

		// Get the initial length
        DWORD nSize = ExpandEnvironmentStrings(p,&tTemp,1) + 1;
        TCHAR* pTemp = new TCHAR[nSize+1];
		if (!pTemp)
			return failed;

        if (!ExpandEnvironmentStrings(p,pTemp,nSize+1))
		{
			delete [] p;
			delete [] pTemp;
			return failed;
		}

        delete [] p;
        *pValue = pTemp;
    }
    else
        *pValue = p;
    return no_error;
}

int Registry::DeleteEntry(const char *pszValueName)
{
	m_nLastError = RegDeleteValue(  hSubkey, pszValueName);
	if (m_nLastError != 0)
	{
		return failed;
	}
	else
		return no_error;
}
int Registry::SetStr(char *pszValueName, char *pszValue)
{
	m_nLastError = RegSetValueEx(hSubkey, pszValueName, 0, REG_SZ, LPBYTE(pszValue),
        strlen(pszValue) + 1);

    if (m_nLastError != 0)
		return failed;
    return no_error;
}

int Registry::GetDWORD(TCHAR *pszValueName, DWORD *pdwValue)
{
    DWORD dwSize = sizeof(DWORD);
    DWORD dwType = 0;

    m_nLastError = RegQueryValueEx(hSubkey, pszValueName, 0, &dwType,
                                LPBYTE(pdwValue), &dwSize);
    if (m_nLastError != 0)
            return failed;

    if (dwType != REG_DWORD)
        return failed;

    return no_error;
}

int Registry::SetDWORDStr(char *pszValueName, DWORD dwVal)
{
    char cTemp[30];
    sprintf(cTemp, "%d", dwVal);

    m_nLastError = RegSetValueEx(hSubkey, pszValueName, 0, REG_SZ, LPBYTE(cTemp),
		strlen(cTemp) + 1);

    if (m_nLastError != 0)
        return failed;

    return no_error;
}

int Registry::SetDWORD(char *pszValueName, DWORD dwVal)
{
    m_nLastError = RegSetValueEx(hSubkey, pszValueName, 0, REG_DWORD, LPBYTE(&dwVal), sizeof(DWORD));

    if (m_nLastError != 0)
        return failed;

    return no_error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\setup\bin\wbemupgradedll\reg.h ===
/*++

Copyright (C) 1997-2000 Microsoft Corporation

Module Name:

    reg.H

Abstract:

    Registry helper class

History:


--*/

#define WBEM_REG_WBEM					"Software\\Microsoft\\WBEM"
#define WBEM_REG_WINMGMT				"Software\\Microsoft\\WBEM\\CIMOM"
#define WBEM_REG_AUTORECOVER			"Autorecover MOFs"
#define WBEM_REG_AUTORECOVER_EMPTY		"Autorecover MOFs (empty)"
#define WBEM_REG_AUTORECOVER_RECOVERED	"Autorecover MOFs (recovered)"
#define SYSTEM_SETUP_REG				"System\\Setup"

class Registry
{
    HKEY	hPrimaryKey;
    HKEY	hSubkey;
    int		m_nStatus;
	LONG	m_nLastError;
public:
    enum { no_error, failed };

	Registry(char *pszLocalMachineStartKey);
	~Registry();
	int Open(HKEY hStart, const char *pszStartKey);
	int GetStr(const char *pszValueName, char **pValue);
	char* GetMultiStr(const char *pszValueName, DWORD &dwSize);
	int SetMultiStr(const char *pszValueName, const char*pData, DWORD dwSize);
	int DeleteEntry(const char *pszValueName);
	int SetStr(char *pszValueName, char *pszValue);
    int GetDWORD(TCHAR *pszValueName, DWORD *pdwValue);
    int SetDWORD(TCHAR *pszValueName, DWORD dwValue);
    int SetDWORDStr(char *pszValueName, DWORD dwValue);
	int GetStatus() { return m_nStatus;};
	LONG GetLastError() { return m_nLastError;};
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\setup\bin\wbemupgradedll\str.cpp ===
/*++

Copyright (C) 1997-2000 Microsoft Corporation

Module Name:

    str.cpp

Abstract:

    Implementation file for the string class

History:


--*/
#include "precomp.h"

char *__g_pszStringBlank = "\0";	//Needs to be double terminated for the multi-string!
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\setup\bin\wbemupgradedll\precomp.cpp ===
/*++

Copyright (C) 1997-2000 Microsoft Corporation

Module Name:

    precomp.cpp

Abstract:

    Pre-compiled header file CPP

History:

--*/

#include "precomp.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\setup\bin\wbemupgradedll\precomp.h ===
/*++

Copyright (C) 1997-2000 Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    Pre-compiled header file

History:

--*/
#ifndef __PRECOMP_H_
#define __PRECOMP_H_

#include <ole2.h>
#include <windows.h>

#include <comdef.h>
#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\setup\bin\wbemupgradedll\mmfarena2.h ===
/*++

Copyright (C) 1997-2000 Microsoft Corporation

Module Name:

    MMFARENA.H

Abstract:

    CArena derivative based on memory mapped files.

History:

    a-raymcc    23-Apr-96       Created
    paulall     23-Mar-98       Re-worked

--*/

#ifndef _MMFARENA_H_
#define _MMFARENA_H_

#include "corepol.h"
#include "FlexArry.h"

#if defined _WIN32
#define MMF_DELETED_MASK        0x80000000
#define MMF_REMOVE_DELETED_MASK 0x7FFFFFFF
#define MMF_DEBUG_DELETED_TAG   0xFFFFFFFF
#define MMF_DEBUG_INUSE_TAG     0xFEFEFEFE
#elif defined _WIN64
#define MMF_DELETED_MASK        0x8000000000000000
#define MMF_REMOVE_DELETED_MASK 0x7FFFFFFFFFFFFFFF
#define MMF_DEBUG_DELETED_TAG   0xFFFFFFFFFFFFFFFF
#define MMF_DEBUG_INUSE_TAG     0xFEFEFEFEFEFEFEFE
#endif

struct MMFOffsetItem;

#include "corex.h"
class DATABASE_FULL_EXCEPTION : public CX_Exception
{
};

//***************************************************************************
//
//  struct MMF_ARENA_HEADER
//
//  Root structure for MMF Arena.  This is recorded on the disk
//  image at the very beginning of the file.
//
//***************************************************************************

#pragma pack(4)                 // Require fixed aligment.

typedef struct
{
    // Version used to create file
    // vvvvvv MUST BE FIRST VALUE vvvvvvv
    DWORD  m_dwVersion;         // <<<<<< MUST BE FIRST VALUE!
    // ^^^^^^ MUST BE FIRST VALUE ^^^^^^^
    DWORD  m_dwGranularity;     // Granularity of allocation
    DWORD  m_dwCurrentSize;     // Current size of heap
    DWORD  m_dwMaxSize;         // Max heap size, -1= no limit
    DWORD  m_dwGrowBy;          // Bytes to grow by during out-of-heap

    DWORD_PTR  m_dwHeapExtent;      // First unused address
    DWORD_PTR  m_dwEndOfHeap;       // Last valid address + 1
    DWORD_PTR  m_dwFreeList;        // NULL if empty
    DWORD_PTR  m_dwRootBlock;       // Root block
    DWORD m_dwSizeOfFirstPage;  //Size of the first block

}   MMF_ARENA_HEADER;

typedef struct
{
    DWORD m_dwSize;         //Size of block.  Highest bit set when deleted.

}   MMF_BLOCK_HEADER;

typedef struct
{
    DWORD_PTR m_dwFLback;   //previous free block in the chain, NULL if not deleted
    DWORD m_dwCheckBlock[2];

}   MMF_BLOCK_TRAILER;

typedef struct
{
    DWORD_PTR m_dwFLnext;       //Next free block in the chain

}   MMF_BLOCK_DELETED;

typedef struct
{
    DWORD m_dwSize;             //Size of page

}   MMF_PAGE_HEADER;            //Page header... not there for first page.
#pragma pack()                  // Restore previous aligment.


//***************************************************************************
//
//  class CMMFArena2
//
//  Implements an offset-based heap over a memory-mapped file.
//
//***************************************************************************

class CMMFArena2
{
    DWORD  m_dwStatus;
    HANDLE m_hFile;
    MMF_ARENA_HEADER *m_pHeapDescriptor;
    DWORD m_dwCursor;
    DWORD m_dwMappingGranularity;
    bool m_bReadOnlyAccess;
    DWORD m_dwMaxPageSize;
    CFlexArray m_OffsetManager;

    //Adds the header and trailer items to the specified block.
    BOOL DecorateUsedBlock(DWORD_PTR dwBlock, DWORD dwBytes);

    //Adds header and trailer items to the specified block and marks it as deleted
    BOOL DecorateAsDeleted(DWORD_PTR dwBlock,
                           DWORD dwBytes,
                           DWORD_PTR dwNextFreeListOffset,
                           DWORD_PTR dwPrevFreeListOffset);

    //Retrieves the size of the block from the header and removes the deleted bit
    DWORD GetSize(MMF_BLOCK_HEADER *pBlock) { return pBlock->m_dwSize & MMF_REMOVE_DELETED_MASK; }

    MMF_BLOCK_DELETED *GetUserBlock(MMF_BLOCK_HEADER *pBlockHeader) { return (MMF_BLOCK_DELETED*)(LPBYTE(pBlockHeader) + sizeof(MMF_BLOCK_HEADER)); }
    MMF_BLOCK_TRAILER *GetTrailerBlock(MMF_BLOCK_HEADER *pBlockHeader) { return (MMF_BLOCK_TRAILER*)(LPBYTE(pBlockHeader) + GetSize(pBlockHeader) - sizeof(MMF_BLOCK_TRAILER)); }


    //Removes a deleted block from the free-list
    BOOL RemoveBlockFromFreeList(MMF_BLOCK_HEADER *pBlock);

    //Gets the previous block pointer if the block is deleted, otherwise return NULL
    MMF_BLOCK_HEADER *GetPreviousDeletedBlock(MMF_BLOCK_HEADER *pBlockHeader);

    //Zero's out a block (not including the header and trailer!)
    BOOL ZeroOutBlock(DWORD_PTR dwBlock, int cFill)
#if (defined DEBUG || defined _DEBUG)
        ;
#else
    { return TRUE;}
#endif

    //Some debugging functions...
    void    Reset();
    BOOL    Next(LPBYTE *ppAddress, DWORD *pdwSize, BOOL *pbActive);

    //Checks the deleted bit of the size block
    BOOL IsDeleted(MMF_BLOCK_HEADER *pBlock) { return (pBlock->m_dwSize & MMF_DELETED_MASK) ? TRUE : FALSE; }
    //Validates a pointer
    BOOL ValidateBlock(DWORD_PTR dwBlock)
#if (defined DEBUG || defined _DEBUG)
        ;
#pragma message("MMF heap validation enabled.")
#else
    { return TRUE;}
#endif

    // Grows the size of the arena by a minumum of the specified amount
    DWORD_PTR GrowArena(DWORD dwGrowBySize);

    //For a given offset, return the mapped base offset and size
    DWORD_PTR GetBlockBaseAddress(DWORD_PTR dwOffset, DWORD &dwSize);

    MMFOffsetItem *CreateNewPage(DWORD_PTR dwBaseOffset, DWORD dwSize);
    MMFOffsetItem *CreateBasePage(DWORD dwInitSize, DWORD dwGanularity);
    MMFOffsetItem *OpenBasePage(DWORD &dwSizeOfRepository);
    MMFOffsetItem *OpenExistingPage(DWORD_PTR dwBaseOffset);
    void ClosePage(MMFOffsetItem *pOffsetItem);
    void CloseAllPages();

public:
    enum { create_new, use_existing };

    // Constructor.
    CMMFArena2(bool bReadOnly = false);

    // Destructor.
    ~CMMFArena2();

    //Methods to open an MMF
    bool LoadMMF(const TCHAR *pszFile);
    bool CreateNewMMF(const TCHAR *pszFile,
                      DWORD dwGranularity,
                      DWORD dwInitSize);

    // Allocates a block of memory.
    DWORD_PTR Alloc(IN DWORD dwBytes);

    // Reallocates a block of memory.
    DWORD_PTR Realloc(DWORD_PTR dwOriginal, DWORD dwNewSize);

    // Frees a block of memory.
    BOOL Free(DWORD_PTR dwBlock);

    DWORD Size(DWORD_PTR dwBlock);

    //Writes any changes not already commited in the MMF to disk.
    BOOL Flush();
    BOOL Flush(DWORD_PTR dwOffsetToFlush);

    void SetVersion(DWORD dwVersion) { if (m_pHeapDescriptor) m_pHeapDescriptor->m_dwVersion = dwVersion; }
    DWORD GetVersion() { return (m_pHeapDescriptor? m_pHeapDescriptor->m_dwVersion : 0); }

    DWORD_PTR GetRootBlock();
    void SetRootBlock(DWORD_PTR dwRootBlock) { if (m_pHeapDescriptor) m_pHeapDescriptor->m_dwRootBlock = dwRootBlock; }

    DWORD GetStatus() { return m_dwStatus; }

    // Tells the amount of memory remaining without a remap or new extent.
    // ===================================================================
    DWORD_PTR   ExtentMemAvail()
        { return (m_pHeapDescriptor ? (m_pHeapDescriptor->m_dwEndOfHeap - m_pHeapDescriptor->m_dwHeapExtent) : 0);
        }

    //Given an offset, returns a fixed up pointer
    LPBYTE OffsetToPtr(DWORD_PTR dwOffset);

    //Given a pointer, returns an offset from the start of the MMF
    DWORD_PTR  PtrToOffset(LPBYTE pBlock);

    // Gets summary heap information.
    // ==============================
    void GetHeapInfo(
         DWORD *pdwTotalSize,
         DWORD *pdwActiveBlocks,
         DWORD *pdwActiveBytes,
         DWORD *pdwFreeBlocks,
         DWORD *pdwFreeBytes
         );

    MMF_ARENA_HEADER *GetMMFHeader() { return m_pHeapDescriptor; }

    //Dumps the heap to a file
    void TextDump(const char *pszFile);

    //Checks the deleted bit of the size block
    BOOL IsDeleted(DWORD_PTR dwBlock) { return IsDeleted((MMF_BLOCK_HEADER*)(OffsetToPtr(dwBlock - sizeof(MMF_BLOCK_HEADER)))); }

    BOOL IsValidBlock(DWORD_PTR dwBlock) { return ValidateBlock(dwBlock - sizeof(MMF_BLOCK_HEADER)); }

    //Does a check of the MMF file to make sure it is valid.  At time of writing this only
    //checks the file size.
    static BOOL FileValid(const TCHAR *pszFilename);

    bool MappingGood() { return true; }

};

//***************************************************************************
//
//  Fixup helpers.
//
//  These are all strongly type variations of the same thing: they fix
//  up the based ptr to a dereferenceable pointer or take the ptr and
//  fix it back down to an offset.
//
//***************************************************************************
extern CMMFArena2* g_pDbArena;
template <class T> T Fixup(T ptr)
{ return T(g_pDbArena->OffsetToPtr(DWORD_PTR(ptr))); }
template <class T> T Fixdown(T ptr)
{ return T(g_pDbArena->PtrToOffset(LPBYTE(ptr))); }

template <class T> class Offset_Ptr
{
private:
    T *m_pTarget;
    T *m_poTarget;

protected:
    void SetValue(T *val) { m_pTarget = Fixup(val); m_poTarget = val;}
    void SetValue(Offset_Ptr &val) { m_pTarget = val.m_pTarget; m_poTarget = val.m_poTarget; }

public:
    Offset_Ptr() : m_pTarget(0), m_poTarget(0) {}

    T* operator ->() { return m_pTarget; }
    DWORD_PTR GetDWORD_PTR() { return DWORD_PTR(m_poTarget); }
    T* GetOffset() { return m_poTarget; }
    T* GetPtr() { return m_pTarget; }
};
#endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\setup\bin\wbemupgradedll\mmfarena2.cpp ===
/*++

Copyright (C) 1996-2000 Microsoft Corporation

Module Name:

    mmfarena2.cpp

Abstract:

    CMMFArena2 implementation (arenas based on memory-mapped files).
    Used for database upgrade

History:

--*/

#include "precomp.h"
#include <stdio.h>
#include "wbemutil.h"
#include "mmfarena2.h"

extern CMMFArena2 *  g_pDbArena;

#define MAX_PAGE_SIZE_WIN9X     0x200000    /*2MB*/
#define MAX_PAGE_SIZE_NT        0x3200000   /*50MB*/

struct MMFOffsetItem
{
    DWORD_PTR m_dwBaseOffset;
    LPBYTE    m_pBasePointer;
    HANDLE    m_hMappingHandle;
    DWORD     m_dwBlockSize;
};

#if (defined DEBUG || defined _DEBUG)
void MMFDebugBreak()
{
    DebugBreak();
}
#else
inline void MMFDebugBreak() {}
#endif

//***************************************************************************
//
//  CMMFArena2::CMMFArena2
//
//  Constructor.  Initialises a few things.
//
//***************************************************************************
CMMFArena2::CMMFArena2(bool bReadOnly)
: m_bReadOnlyAccess(bReadOnly), m_dwStatus(0), m_hFile(INVALID_HANDLE_VALUE)
{
    g_pDbArena = this;

    //Get processor granularity
    SYSTEM_INFO sysInfo;
    GetSystemInfo(&sysInfo);
    m_dwMappingGranularity = sysInfo.dwAllocationGranularity;
    m_dwMaxPageSize = MAX_PAGE_SIZE_NT;
}

//***************************************************************************
//
//  CMMFArena2::CreateNewMMF
//
//  Creates a new MMF.  This creates a single page with the header initialised
//  for with the MMF header information.
//
//  pszFile         : Filename of the MMF to open
//  dwGranularity   : Minimum block allocation size
//  dwInitSize      : Initial size of the repository.
//
//  Return value    : false if we failed, true if we succeed.
//
//***************************************************************************
bool CMMFArena2::CreateNewMMF(const TCHAR *pszFile,     //File of MMF to open
                              DWORD dwGranularity,      // Granularity per allocation (min block size)
                              DWORD dwInitSize)         // Initial heap size
{
    //Size should be of a specific granularity...
    if (dwInitSize % m_dwMappingGranularity)
        dwInitSize += (m_dwMappingGranularity - (dwInitSize % m_dwMappingGranularity));

    // Create a new file
    // =================
    m_hFile = CreateFile(
         pszFile,
         GENERIC_READ | (m_bReadOnlyAccess ? 0 : GENERIC_WRITE),
         FILE_SHARE_READ | (m_bReadOnlyAccess ? FILE_SHARE_WRITE : 0),
         0,
         CREATE_NEW,
         FILE_ATTRIBUTE_NORMAL | FILE_FLAG_RANDOM_ACCESS,
         0
         );

    if (m_hFile == INVALID_HANDLE_VALUE)
    {
        _ASSERT(0, "WinMgmt: Failed to create a new repository file");
        m_dwStatus = 7;
        return false;
    }

    //Create the end page marker here in case we have no memory...
    MMFOffsetItem *pOffsetEnd = 0;
    pOffsetEnd = new MMFOffsetItem;
    if (pOffsetEnd == 0)
    {
        _ASSERT(0, "WinMgmt: Out of memory");
        CloseHandle(m_hFile);
        m_hFile = INVALID_HANDLE_VALUE;
        m_dwStatus = 7;
        throw CX_MemoryException();
    }

    //Create the base page...
    MMFOffsetItem *pOffsetItem = CreateBasePage(dwInitSize, dwGranularity);
    if (pOffsetItem == 0)
    {
        _ASSERT(0, "WinMgmt: Failed to create base MMF page");
        delete pOffsetEnd;
        CloseHandle(m_hFile);
        m_hFile = INVALID_HANDLE_VALUE;
        m_dwStatus = 7;
        return false;
    }
    int nStatus = -1;
    //Add this page information to the offset manager...
    nStatus = m_OffsetManager.Add(pOffsetItem);
    if (nStatus != 0)
    {
        _ASSERT(0, "WinMgmt: Failed to add offset information into offset table");
        //We are out of memory... lets tidy up...
        ClosePage(pOffsetItem);
        delete pOffsetItem;
        delete pOffsetEnd;

        CloseHandle(m_hFile);
        m_hFile = INVALID_HANDLE_VALUE;
        m_dwStatus = 7;
        throw CX_MemoryException();
    }

    //Fill in the end page marker information and add it to the offset manager...
    pOffsetEnd->m_dwBaseOffset = m_pHeapDescriptor->m_dwCurrentSize;
    pOffsetEnd->m_pBasePointer = 0;
    pOffsetEnd->m_hMappingHandle = 0;
    pOffsetEnd->m_dwBlockSize = 0;

    nStatus = -1;
    nStatus = m_OffsetManager.Add(pOffsetEnd);
    if (nStatus != 0)
    {
        _ASSERT(0, "WinMgmt: Failed to add end block marker into offset table");
        //We are out of memory... lets tidy up...
        ClosePage(pOffsetItem);
        m_OffsetManager.Empty();
        delete pOffsetItem;
        delete pOffsetEnd;

        CloseHandle(m_hFile);
        m_hFile = INVALID_HANDLE_VALUE;
        m_dwStatus = 7;
        throw CX_MemoryException();
    }

    return true;
}

//***************************************************************************
//
//  CMMFArena2::LoadMMF
//
//  Loads an existing MMF.  Loads in the base page and all pages following
//  that
//
//  pszFile         : Filename of the MMF to open
//
//  Return value    : false if we failed, true if we succeed.
//
//***************************************************************************
bool CMMFArena2::LoadMMF(const TCHAR *pszFile)
{
    //Open the file...
    m_hFile = CreateFile(
         pszFile,
         GENERIC_READ | (m_bReadOnlyAccess ? 0 : GENERIC_WRITE),
         FILE_SHARE_READ | (m_bReadOnlyAccess ? FILE_SHARE_WRITE : 0),
         0,
         OPEN_EXISTING,
         FILE_ATTRIBUTE_NORMAL | FILE_FLAG_RANDOM_ACCESS,
         0
         );

    if (m_hFile == INVALID_HANDLE_VALUE)
    {
        _ASSERT(0, "WinMgmt: Failed to open existing repository file");
        m_dwStatus = 7;
        return false;
    }
    DWORD dwSizeOfRepository = 0;
    MMFOffsetItem *pOffsetItem = 0;

    //Open the base page...
    pOffsetItem = OpenBasePage(dwSizeOfRepository);
    if (pOffsetItem == 0)
    {
        _ASSERT(0, "WinMgmt: Failed to open base page in MMF");
        CloseHandle(m_hFile);
        m_hFile = INVALID_HANDLE_VALUE;
        m_dwStatus = 7;
        return false;
    }

    //Add the details to the offset manager...
    int nStatus = -1;
    nStatus = m_OffsetManager.Add(pOffsetItem);
    if (nStatus)
    {
        _ASSERT(0, "WinMgmt: Failed to add offset information into offset table");
        ClosePage(pOffsetItem);
        delete pOffsetItem;

        CloseHandle(m_hFile);
        m_hFile = INVALID_HANDLE_VALUE;
        m_dwStatus = 7;
        throw CX_MemoryException();
    }

    DWORD_PTR dwPageBase = 0;

    if (m_pHeapDescriptor->m_dwVersion == 9)
    {
        //Now loop through all the following pages and load them...
        DWORD dwSizeLastPage = 0;
        nStatus = -1;
        for (dwPageBase = pOffsetItem->m_dwBlockSize; dwPageBase < dwSizeOfRepository; dwPageBase += dwSizeLastPage)
        {
            //Open the next...
            pOffsetItem = OpenExistingPage(dwPageBase);
            if (pOffsetItem == 0)
            {
                _ASSERT(0, "WinMgmt: Failed to open an existing page in the MMF");
                //Failed to do that!
                CloseAllPages();
                CloseHandle(m_hFile);
                m_hFile = INVALID_HANDLE_VALUE;
                m_dwStatus = 7;
                return false;
            }
            //Add the information to the offset manager...
            nStatus = -1;
            nStatus = m_OffsetManager.Add(pOffsetItem);
            if (nStatus)
            {
                _ASSERT(0, "WinMgmt: Failed to add offset information into offset table");
                //Failed to do that!
                ClosePage(pOffsetItem);
                delete pOffsetItem;
                CloseAllPages();
                CloseHandle(m_hFile);
                m_hFile = INVALID_HANDLE_VALUE;
                m_dwStatus = 7;
                throw CX_MemoryException();
            }
            dwSizeLastPage = pOffsetItem->m_dwBlockSize;
        }
    }
    else if ((m_pHeapDescriptor->m_dwVersion == 10) || (m_pHeapDescriptor->m_dwVersion < 9))
    {
        dwPageBase = pOffsetItem->m_dwBlockSize;
    }
    else
    {
        _ASSERT(0, "WinMgmt: Database error... Code has not been added to support the opening of this database!!!!!");
        ERRORTRACE((LOG_WBEMCORE, "Database error... Code has not been added to support the opening of this database!!!!!\n"));
    }

    //Create a mapping entry to mark the end of the MMF
    pOffsetItem = new MMFOffsetItem;
    if (pOffsetItem == 0)
    {
        _ASSERT(0, "WinMgmt: Out of memory");
        //Failed to do that!
        CloseAllPages();
        CloseHandle(m_hFile);
        m_hFile = INVALID_HANDLE_VALUE;
        m_dwStatus = 7;
        throw CX_MemoryException();
    }
    pOffsetItem->m_dwBaseOffset = dwPageBase;
    pOffsetItem->m_dwBlockSize = 0;
    pOffsetItem->m_hMappingHandle = 0;
    pOffsetItem->m_pBasePointer = 0;
    nStatus = -1;
    nStatus = m_OffsetManager.Add(pOffsetItem);
    if (nStatus)
    {
        _ASSERT(0, "WinMgmt: Failed to add offset information into offset table");
        //Failed to do that!
        ClosePage(pOffsetItem);
        delete pOffsetItem;
        CloseAllPages();
        CloseHandle(m_hFile);
        m_hFile = INVALID_HANDLE_VALUE;
        m_dwStatus = 7;
        throw CX_MemoryException();
    }

    return true;
};

//***************************************************************************
//
//  CMMFArena2::OpenBasePage
//
//  Opens the MMF first page which has all the information about the rest
//  of the MMF as well as the first page of data.
//
//  dwSizeOfRepository  : Returns the current size of the repository
//
//  Return value    : Pointer to an offset item filled in with the base
//                    page information.  NULL if we fail to open the
//                    base page.
//
//***************************************************************************
MMFOffsetItem *CMMFArena2::OpenBasePage(DWORD &dwSizeOfRepository)
{
    MMFOffsetItem *pOffsetItem = 0;
    pOffsetItem = new MMFOffsetItem;
    if (pOffsetItem == 0)
        throw CX_MemoryException();

    //Seek to the start of this page...
    if (SetFilePointer(m_hFile, 0, NULL, FILE_BEGIN) == INVALID_SET_FILE_POINTER)
    {
        _ASSERT(0, "WinMgmt: Failed to set file pointer on MMF");
        delete pOffsetItem;
        return 0;
    }

    //Read in the hear information so we can find the size of this block...
    DWORD dwActualRead;
    MMF_ARENA_HEADER mmfHeader;
    if ((ReadFile(m_hFile, &mmfHeader, sizeof(MMF_ARENA_HEADER), &dwActualRead, 0) == 0) || (dwActualRead != sizeof(MMF_ARENA_HEADER)))
    {
        _ASSERT(0, "WinMgmt: Failed to read MMF header information");
        delete pOffsetItem;
        return 0;
    }

    //Record the current size information...
    dwSizeOfRepository = mmfHeader.m_dwCurrentSize;

    DWORD dwSizeToMap = 0;

    if ((mmfHeader.m_dwVersion < 9) || (mmfHeader.m_dwVersion == 10))
    {
        //old style database, we map in everything...
        dwSizeToMap = mmfHeader.m_dwCurrentSize;
    }
    else if (mmfHeader.m_dwVersion == 9)
    {
        //We get the first page...
        dwSizeToMap = mmfHeader.m_dwSizeOfFirstPage;
    }
    else
    {
        _ASSERT(0, "WinMgmt: Database error... Code has not been added to support the opening of this database!!!!!");
        ERRORTRACE((LOG_WBEMCORE, "Database error... Code has not been added to support the opening of this database!!!!!\n"));
    }

    //Create the file mapping for this page...
    HANDLE hMapping = CreateFileMapping(
        m_hFile,                            // Disk file
        0,                                  // No security
        (m_bReadOnlyAccess ? PAGE_READONLY : PAGE_READWRITE) | SEC_COMMIT,      // Extend the file to match the heap size
        0,                                  // High-order max size
        dwSizeToMap,        // Low-order max size
        0                                   // No name for the mapping object
        );

    if (hMapping == NULL)
    {
        _ASSERT(0, "WinMgmt: Failed to create file mapping");
        delete pOffsetItem;
        return 0;
    }

    // Map this into memory...
    LPBYTE pBindingAddress = (LPBYTE)MapViewOfFile(hMapping,
                                                (m_bReadOnlyAccess ? FILE_MAP_READ : FILE_MAP_ALL_ACCESS),
                                                 0,
                                                 0,
                                                 dwSizeToMap
                                                 );

    if (pBindingAddress == NULL)
    {
        _ASSERT(0, "WinMgmt: Failed to map MMF into memory");
        delete pOffsetItem;
        CloseHandle(hMapping);
        return 0;
    }

    //Record the base address of this because we need easy access to the header...
    m_pHeapDescriptor = (MMF_ARENA_HEADER*) pBindingAddress;

    //Create a mapping entry for this...
    pOffsetItem->m_dwBaseOffset = 0;
    pOffsetItem->m_dwBlockSize = dwSizeToMap;
    pOffsetItem->m_hMappingHandle = hMapping;
    pOffsetItem->m_pBasePointer = pBindingAddress;

    return pOffsetItem;
}

//***************************************************************************
//
//  CMMFArena2::OpenExistingPage
//
//  Opens the specified page from the repostory.
//
//  dwBaseOffset    : Offset within the MMF to map in.
//
//  Return value    : Pointer to an offset item filled in with the
//                    page information.  NULL if we fail to open the
//                    page.
//
//***************************************************************************
MMFOffsetItem *CMMFArena2::OpenExistingPage(DWORD_PTR dwBaseOffset)
{
    MMFOffsetItem *pOffsetItem = 0;
    pOffsetItem = new MMFOffsetItem;
    if (pOffsetItem == 0)
        throw CX_MemoryException();

    //Set the file pointer to the start of this page...
    if (SetFilePointer(m_hFile, (LONG)dwBaseOffset, NULL, FILE_BEGIN) == INVALID_SET_FILE_POINTER)
    {
        //We are in trouble!
        _ASSERT(0, "WinMgmt: Failed to determine the size of the next block to load");
		delete pOffsetItem;
        return 0;
    }

    //Read in the page information so we can find out how big the page is...
    DWORD dwActualRead = 0;
    MMF_PAGE_HEADER pageHeader;
    if ((ReadFile(m_hFile, &pageHeader, sizeof(MMF_PAGE_HEADER), &dwActualRead, 0) == 0) || (dwActualRead != sizeof(MMF_PAGE_HEADER)))
    {
        _ASSERT(0, "WinMgmt: Failed to read the next page block size");
		delete pOffsetItem;
        return 0;
    }

    //Create the file mapping...
    HANDLE hMapping;
    hMapping = CreateFileMapping(m_hFile,
                                 0,
                                 (m_bReadOnlyAccess ? PAGE_READONLY : PAGE_READWRITE) | SEC_COMMIT,
                                 0,
                                 (LONG)dwBaseOffset + pageHeader.m_dwSize,
                                 0);

    if (hMapping == 0)
    {
        _ASSERT(0, "WinMgmt: Failed to map in part of the memory mapped file!");
		delete pOffsetItem;
        return 0;
    }

    //Map this into memory...
    LPBYTE pBindingAddress;
    pBindingAddress= (LPBYTE)MapViewOfFile(hMapping,
                                            (m_bReadOnlyAccess ? FILE_MAP_READ : FILE_MAP_ALL_ACCESS),
                                            0,
                                            (LONG)dwBaseOffset,
                                            pageHeader.m_dwSize);
    if (pBindingAddress == 0)
    {
        _ASSERT(0, "WinMgmt: Failed to bind part of the memory mapped file into memory!");
		delete pOffsetItem;
        return 0;
    }

    //Record the information...
    pOffsetItem->m_dwBaseOffset = dwBaseOffset;
    pOffsetItem->m_dwBlockSize = pageHeader.m_dwSize;
    pOffsetItem->m_hMappingHandle = hMapping;
    pOffsetItem->m_pBasePointer = pBindingAddress;

    return pOffsetItem;
}

//***************************************************************************
//
//  CMMFArena2::CreateBasePage
//
//  Creates a new base page and initialises it.
//
//  dwInitSize      : Initial size of the repotitory, which is also the size
//                    of the first page.
//  dwGranularity   : Size of mimimmum block allocation size...
//
//  Return value    : Pointer to an offset item filled in with the
//                    page information.  NULL if we fail to open the
//                    page.
//
//***************************************************************************
MMFOffsetItem *CMMFArena2::CreateBasePage(DWORD dwInitSize, DWORD dwGranularity)
{
    MMFOffsetItem *pOffsetItem = 0;
    pOffsetItem = new MMFOffsetItem;
    if (pOffsetItem == 0)
        throw CX_MemoryException();

    // Create a file mapping for this base page...
    // ===========================================
    HANDLE hMapping = CreateFileMapping(
        m_hFile,                            // Disk file
        0,                                  // No security
        (m_bReadOnlyAccess ? PAGE_READONLY : PAGE_READWRITE) | SEC_COMMIT,      // Extend the file to match the heap size
        0,                                  // High-order max size
        dwInitSize,                         // Low-order max size
        0                                   // No name for the mapping object
        );

    if (hMapping == NULL)
    {
        _ASSERT(0, "WinMgmt: Failed to create a new file mapping");
		delete pOffsetItem;
        return 0;
    }

    // Map this page into memory...
    // ============================
    LPBYTE pBindingAddress = (LPBYTE)MapViewOfFile(hMapping,
                                                (m_bReadOnlyAccess ? FILE_MAP_READ : FILE_MAP_ALL_ACCESS),
                                                 0,
                                                 0,
                                                 dwInitSize
                                                 );

    if (pBindingAddress == NULL)
    {
		_ASSERT(0, "WinMgmt: Failed to map in new page into memory");
		CloseHandle(hMapping);
		delete pOffsetItem;
		return 0;
    }

    //Record the base pointer which is used throughout to hold important items
    //and information about the MMF.
    m_pHeapDescriptor = (MMF_ARENA_HEADER*) pBindingAddress;

    // Record the final heap address and set up the other related pointers.
    m_pHeapDescriptor->m_dwVersion = 0;
    m_pHeapDescriptor->m_dwGranularity = dwGranularity;
    m_pHeapDescriptor->m_dwCurrentSize = dwInitSize;
    m_pHeapDescriptor->m_dwMaxSize = 0;
    m_pHeapDescriptor->m_dwGrowBy = 0;
    m_pHeapDescriptor->m_dwHeapExtent = sizeof(MMF_ARENA_HEADER);
    m_pHeapDescriptor->m_dwEndOfHeap = dwInitSize;
    m_pHeapDescriptor->m_dwFreeList = 0;
    m_pHeapDescriptor->m_dwRootBlock = 0;
    m_pHeapDescriptor->m_dwSizeOfFirstPage = dwInitSize;

    //Now we have to add this information to the offset manager...
    pOffsetItem->m_dwBaseOffset = 0;
    pOffsetItem->m_pBasePointer = pBindingAddress;
    pOffsetItem->m_hMappingHandle = hMapping;
    pOffsetItem->m_dwBlockSize = dwInitSize;

    return pOffsetItem;
}

//***************************************************************************
//
//  CMMFArena2::CreateNewPage
//
//  Creates a new page and initialises the header, returning a structure
//  detailing the page.
//
//  dwBaseOffset    : Base offset of this new page
//  dwSize          : Size of this page
//
//  Return value    : Pointer to an offset item filled in with the
//                    page information.  NULL if we fail to open the
//                    page.
//
//***************************************************************************
MMFOffsetItem *CMMFArena2::CreateNewPage(DWORD_PTR dwBaseOffset, DWORD dwSize)
{
    MMFOffsetItem *pOffsetItem = 0;
    pOffsetItem = new MMFOffsetItem;
    if (pOffsetItem == 0)
        throw CX_MemoryException();

    //Create the file mapping, this may grow the file...
    HANDLE hNewMapping;
    LPBYTE pNewBindingAddress = NULL;
    hNewMapping = CreateFileMapping(
        m_hFile,                                        // Disk file
        0,                                              // No security
        (m_bReadOnlyAccess ? PAGE_READONLY : PAGE_READWRITE) | SEC_COMMIT,                  // Extend the file to match the heap size
        0,                                              // High-order max size
        (LONG)dwBaseOffset + dwSize,                          // Low-order max size
        0                                               // No name for the mapping object
        );

    DWORD dwErr = GetLastError();

    if (hNewMapping != 0 && dwErr == 0)
    {

        //Map this into memory...
        pNewBindingAddress = (LPBYTE)MapViewOfFile(
            hNewMapping,
            (m_bReadOnlyAccess ? FILE_MAP_READ : FILE_MAP_ALL_ACCESS),
            0,
            (LONG)dwBaseOffset,                           // Old size used here!!!
            dwSize                                  // Size of new part of mapping
            );

        if (pNewBindingAddress)
        {
            //Record the information...
            pOffsetItem->m_dwBaseOffset = dwBaseOffset;
            pOffsetItem->m_pBasePointer = pNewBindingAddress;
            pOffsetItem->m_hMappingHandle = hNewMapping;
            pOffsetItem->m_dwBlockSize = dwSize;

            //Fill in the page header...
            MMF_PAGE_HEADER *pPageHeader = (MMF_PAGE_HEADER *)pNewBindingAddress;
            pPageHeader->m_dwSize = dwSize;
        }
        else
        {
            _ASSERT(0, "WinMgmt: Failed to map in page of MMF into memory");
            ERRORTRACE((LOG_WBEMCORE, "Failed to map the new file mapping into memory for block size of %lu.  Last Error = %lu\n", dwSize, GetLastError()));
            CloseHandle(hNewMapping);
            delete pOffsetItem;
            pOffsetItem = 0;
        }
    }
    else
    {
        _ASSERT(0, "WinMgmt: Failed to create a file mapping for the MMF");
        if (hNewMapping != 0)
            CloseHandle(hNewMapping);
        ERRORTRACE((LOG_WBEMCORE, "Failed to create a new file mapping for %lu bytes block.  Last Error = %lu\n", dwSize, dwErr));
        delete pOffsetItem;
        pOffsetItem = 0;
    }

    return pOffsetItem;
}

//***************************************************************************
//
//  CMMFArena2::ClosePage
//
//  Closes the page specified
//
//  pOffsetItem : Information about the page to close.
//
//  Return value    : None
//
//***************************************************************************
void CMMFArena2::ClosePage(MMFOffsetItem *pOffsetItem)
{
    if (pOffsetItem->m_hMappingHandle)
    {
        UnmapViewOfFile(pOffsetItem->m_pBasePointer);
        CloseHandle(pOffsetItem->m_hMappingHandle);
    }
}

//***************************************************************************
//
//  CMMFArena2::CloseAllPages
//
//  Closes all pages in the offset manager, deleting the pointers of the
//  objects in there.
//
//  Return value    : None
//
//***************************************************************************
void CMMFArena2::CloseAllPages()
{
    //Close each of the file mappings...
    for (int i = 0; i != m_OffsetManager.Size(); i++)
    {
        MMFOffsetItem *pItem = (MMFOffsetItem*)m_OffsetManager[i];
        ClosePage(pItem);
        delete pItem;
    }
    m_OffsetManager.Empty();
}

//***************************************************************************
//
//  CMMFArena2::~CMMFArena2
//
//  Destructor flushes the heap, unmaps the view and closes handles.
//
//***************************************************************************

CMMFArena2::~CMMFArena2()
{
    if (m_hFile != INVALID_HANDLE_VALUE)
    {
        //Make sure what is in the MMF is flushed...
        Flush();

        //Remember the size of the file....
        DWORD dwFileSize = m_pHeapDescriptor->m_dwCurrentSize;

        //Close each of the file mappings...
        CloseAllPages();

        //Set the size in case we messed it up if we failed to do a grow...
        SetFilePointer(m_hFile, dwFileSize, NULL, FILE_BEGIN);
        SetEndOfFile(m_hFile);

        //Close the file handle
        CloseHandle(m_hFile);
    }
}

//***************************************************************************
//
//  CMMFArena2::Alloc
//
//  Allocates a new memory block.   Uses the free list if a suitable block
//  can be found; grows the heap if required.
//
//  Parameters:
//  <dwBytes>       Number of bytes to allocate.
//
//  Return value:
//  Offsete of memory, or 0 on failure.
//
//***************************************************************************
DWORD_PTR CMMFArena2::Alloc(DWORD dwBytes)
{
    //Allocation of 0 bytes returns 0!
    if (dwBytes == 0)
        return 0;

    if (m_dwStatus != 0)
        throw DATABASE_FULL_EXCEPTION();

    //Make sure we are large enough block for any information we store in the
    //block when it is deleted
    if (dwBytes < sizeof(MMF_BLOCK_DELETED))
        dwBytes = sizeof(MMF_BLOCK_DELETED);

    //Check the granularity of the size...
    DWORD dwGran = m_pHeapDescriptor->m_dwGranularity;
    dwBytes = (dwBytes - 1 + dwGran) / dwGran * dwGran;

    //Now adjust the size to include the header and trailer blocks...
    dwBytes += sizeof(MMF_BLOCK_HEADER) + sizeof(MMF_BLOCK_TRAILER);

    //Get the first item in the free-list pointer
    DWORD_PTR dwFreeBlock = m_pHeapDescriptor->m_dwFreeList;
    MMF_BLOCK_HEADER *pFreeBlock = (MMF_BLOCK_HEADER*)OffsetToPtr(dwFreeBlock);
	if (!pFreeBlock)
		return 0;

    //While free-list pointer is not NULL, and the size of the free-list pointer
    //block is too small
    while (dwFreeBlock && (GetSize(pFreeBlock) < dwBytes))
    {
        ValidateBlock(dwFreeBlock);

        //Get the next block in the free-list pointer
        MMF_BLOCK_DELETED *pUserBlock = GetUserBlock(pFreeBlock);
        dwFreeBlock = pUserBlock->m_dwFLnext;
        pFreeBlock = (MMF_BLOCK_HEADER*)OffsetToPtr(dwFreeBlock);
    }

    //If the free-list pointer is NULL, we need to allocate more space in the arena
    if (dwFreeBlock == NULL)
    {
        //If there is not enough space at the end of the heap unused, we need to
        //grow the heap
        if (dwBytes > (m_pHeapDescriptor->m_dwEndOfHeap - m_pHeapDescriptor->m_dwHeapExtent))
        {
            //Mark the chunk of memory at the end of the arena as deleted as it is too
            //small to use...
            if (m_pHeapDescriptor->m_dwEndOfHeap != m_pHeapDescriptor->m_dwHeapExtent)
            {
                DecorateUsedBlock(m_pHeapDescriptor->m_dwHeapExtent, LONG(m_pHeapDescriptor->m_dwEndOfHeap - m_pHeapDescriptor->m_dwHeapExtent));
                Free(DWORD_PTR((LPBYTE)m_pHeapDescriptor->m_dwHeapExtent + sizeof(MMF_BLOCK_HEADER)));
                m_pHeapDescriptor->m_dwHeapExtent = m_pHeapDescriptor->m_dwEndOfHeap;
            }

            //If (Grow the arena by at least dwBytes) fails
            if (GrowArena(dwBytes) == 0)
            {
                //Fail the operation
                throw DATABASE_FULL_EXCEPTION();
                m_dwStatus = 1;
                return 0;
            }
        }

        //We have a chunk of memory at the end of the arena which is not in the
        //free-list.  We need to extend the size of the working arena and
        //use this.
        if ((m_pHeapDescriptor->m_dwEndOfHeap - m_pHeapDescriptor->m_dwHeapExtent - dwBytes) <= (sizeof(MMF_BLOCK_HEADER) + sizeof(MMF_BLOCK_TRAILER) + max(sizeof(MMF_BLOCK_DELETED), m_pHeapDescriptor->m_dwGranularity)))
        {
            dwBytes += DWORD(m_pHeapDescriptor->m_dwEndOfHeap - m_pHeapDescriptor->m_dwHeapExtent) - dwBytes;
        }
        DWORD_PTR dwFreeBlock2 = m_pHeapDescriptor->m_dwHeapExtent;
        m_pHeapDescriptor->m_dwHeapExtent += dwBytes;
        DecorateUsedBlock(dwFreeBlock2, dwBytes);

//      _ASSERT((m_pHeapDescriptor->m_dwEndOfHeap - m_pHeapDescriptor->m_dwHeapExtent) > (sizeof(MMF_BLOCK_HEADER) + sizeof(MMF_BLOCK_TRAILER) + sizeof(MMF_BLOCK_DELETED)), "Space left at end of arena is too small");
        ZeroOutBlock(dwFreeBlock2, 0xCD);
        return dwFreeBlock2 + sizeof(MMF_BLOCK_HEADER);
    }

    ValidateBlock(dwFreeBlock);

    //If this block is large enough to split
    if ((GetSize(pFreeBlock) - dwBytes) >=
            (sizeof(MMF_BLOCK_HEADER) +
             sizeof(MMF_BLOCK_TRAILER) +
             max(sizeof(MMF_BLOCK_DELETED), m_pHeapDescriptor->m_dwGranularity)))
    {
        //We need to split this large block into two and put the free-list
        //information from the start of this block into the newly
        //slit off bit
        MMF_BLOCK_DELETED *pFreeBlockUser = GetUserBlock(pFreeBlock);
        MMF_BLOCK_TRAILER *pFreeBlockTrailer = GetTrailerBlock(pFreeBlock);
        DecorateAsDeleted(dwFreeBlock + dwBytes,
                          GetSize(pFreeBlock) - dwBytes,
                          pFreeBlockUser->m_dwFLnext,
                          pFreeBlockTrailer->m_dwFLback);

        //Now need to point the previous blocks and next blocks free-list pointers to point
        //to this new starting point.
        MMF_BLOCK_HEADER *pNewFreeBlockHeader = (MMF_BLOCK_HEADER *)OffsetToPtr(dwFreeBlock + dwBytes);
        MMF_BLOCK_DELETED *pNewFreeBlockUser = GetUserBlock(pNewFreeBlockHeader);
        MMF_BLOCK_TRAILER *pNewBlockTrailer = GetTrailerBlock(pNewFreeBlockHeader);

        //Deal with previous block...
        if (pNewBlockTrailer->m_dwFLback)
        {
            MMF_BLOCK_HEADER *pPrevFreeBlockHeader = (MMF_BLOCK_HEADER *)OffsetToPtr(pNewBlockTrailer->m_dwFLback);
            MMF_BLOCK_DELETED *pPrevFreeBlockUser = GetUserBlock(pPrevFreeBlockHeader);
            pPrevFreeBlockUser->m_dwFLnext = dwFreeBlock + dwBytes;
        }
        else
        {
            m_pHeapDescriptor->m_dwFreeList = dwFreeBlock + dwBytes;
        }

        //Deal with next block...if there is one
        if (pNewFreeBlockUser->m_dwFLnext)
        {
            MMF_BLOCK_HEADER *pNextFreeBlockHeader = (MMF_BLOCK_HEADER *)OffsetToPtr(pNewFreeBlockUser->m_dwFLnext);
            MMF_BLOCK_TRAILER *pNextFreeBlockTrailer = GetTrailerBlock(pNextFreeBlockHeader);
            pNextFreeBlockTrailer->m_dwFLback = dwFreeBlock + dwBytes;
        }

        //Set up the header and footer of this newly slit block
        DecorateUsedBlock(dwFreeBlock, dwBytes);
    }
    else
    {
        //Otherwise we need to remove this block from the free-list.
        RemoveBlockFromFreeList(pFreeBlock);

        //Populate this block with header and trailer information
        DecorateUsedBlock(dwFreeBlock, GetSize(pFreeBlock));
    }
    ZeroOutBlock(dwFreeBlock, 0xCD);

    _ASSERT(!(((m_pHeapDescriptor->m_dwEndOfHeap - m_pHeapDescriptor->m_dwHeapExtent) != 0) &&
            ((m_pHeapDescriptor->m_dwEndOfHeap - m_pHeapDescriptor->m_dwHeapExtent) < (sizeof(MMF_BLOCK_HEADER) + sizeof(MMF_BLOCK_TRAILER) + sizeof(MMF_BLOCK_DELETED)))),
            "Space left at end of arena is too small");

    //Return the offset to the caller.
    return dwFreeBlock + sizeof(MMF_BLOCK_HEADER);
}

//***************************************************************************
//
//  CMMFArena2::Realloc
//
//  Allocates a new block of the requested size, copies the current
//  contents to it and frees up the original.  If the original is
//  large enough it returns that.
//
//  Parameters:
//  <dwAddress>     The address to reallocate
//  <dwNewSize>     New requested size
//
//  Return value:
//  TRUE on success, FALSE if not enough memory of corruption detected
//
//***************************************************************************
DWORD_PTR CMMFArena2::Realloc(DWORD_PTR dwOriginal, DWORD dwNewSize)
{
    if (m_dwStatus != 0)
        throw DATABASE_FULL_EXCEPTION();

    //Validate original block...
    ValidateBlock(dwOriginal - sizeof(MMF_BLOCK_HEADER));

    MMF_BLOCK_HEADER *pHeader = (MMF_BLOCK_HEADER *)OffsetToPtr(dwOriginal - sizeof(MMF_BLOCK_HEADER));
	if (!pHeader)
		return 0;

    //If the original block is large enough, return the original
    if ((GetSize(pHeader) - sizeof(MMF_BLOCK_HEADER) - sizeof(MMF_BLOCK_TRAILER))  >= dwNewSize)
        return dwOriginal;

    //Allocate a new block
    DWORD_PTR dwNewBlock = Alloc(dwNewSize);

    //If the allocation failed return NULL
    if (dwNewBlock == 0)
        return 0;

    //Copy orignial contents into it
    memcpy(OffsetToPtr(dwNewBlock), OffsetToPtr(dwOriginal), GetSize(pHeader) - sizeof(MMF_BLOCK_HEADER) - sizeof(MMF_BLOCK_TRAILER));

    //Free original block
    Free(dwOriginal);

    //Return newly allocated block
    return dwNewBlock;
}

//***************************************************************************
//
//  CMMFArena2::Free
//
//  Frees a block of memory and places it on the free list.
//
//  Parameters:
//  <dwAddress>     The address to 'free'.
//
//  Return value:
//  TRUE on success, FALSE on erroneous address.
//
//***************************************************************************

BOOL CMMFArena2::Free(DWORD_PTR dwAddress)
{
    //Freeing of NULL is OK!
    if (dwAddress == 0)
        return TRUE;

    if (m_dwStatus != 0)
        throw DATABASE_FULL_EXCEPTION();

    //Set the address to point to the actual start of the block
    dwAddress -= sizeof(MMF_BLOCK_HEADER);

    //Check the block is valid...
    ValidateBlock(dwAddress);

    MMF_BLOCK_HEADER *pBlockHeader = (MMF_BLOCK_HEADER*)OffsetToPtr(dwAddress);
	if (!pBlockHeader)
		return FALSE;

    DWORD     dwMappedBlockSize = 0;
    DWORD_PTR dwMappedBlockBaseAddress = GetBlockBaseAddress(dwAddress, dwMappedBlockSize);

    //If there is a block following this and it is deleted we should remove it from the free-list
    //chain and merge it with this block... That is if this is not the last block
    //in the heap!
    DWORD_PTR dwNextBlockAddress = dwAddress + GetSize(pBlockHeader);
    if ((dwNextBlockAddress < (dwMappedBlockBaseAddress + dwMappedBlockSize)) && (dwNextBlockAddress < m_pHeapDescriptor->m_dwHeapExtent))
    {
        MMF_BLOCK_HEADER *pNextBlockHeader = (MMF_BLOCK_HEADER*)OffsetToPtr(dwNextBlockAddress);
		if (!pNextBlockHeader)
			return FALSE;

        if (IsDeleted(pNextBlockHeader))
        {
            //OK, we can now remove this block from the free-list
            RemoveBlockFromFreeList(pNextBlockHeader);

            DecorateUsedBlock(dwAddress, GetSize(pBlockHeader) + GetSize(pNextBlockHeader));
        }
    }

    //If there is a deleted block before we have to merge this block into the previous one
    //The previous block is deleted if there is something in the FL back-pointer of the
    //previous blocks trailer.  Make sure this is not the first block in the heap though!!!
    MMF_BLOCK_HEADER *pPrevBlockHeader = 0;
    if ((dwAddress != (dwMappedBlockBaseAddress + sizeof(MMF_PAGE_HEADER))) && (pPrevBlockHeader = GetPreviousDeletedBlock(pBlockHeader)))
    {
        //There is a deleted block prior to this one!  We need to merge them
        MMF_BLOCK_DELETED *pPrevBlockUser = GetUserBlock(pPrevBlockHeader);
        MMF_BLOCK_TRAILER *pPrevBlockTrailer = GetTrailerBlock(pPrevBlockHeader);
        DecorateAsDeleted(PtrToOffset(LPBYTE(pPrevBlockHeader)),
                          GetSize(pPrevBlockHeader) + GetSize(pBlockHeader),
                          pPrevBlockUser->m_dwFLnext,
                          pPrevBlockTrailer->m_dwFLback);

        //This block is now fully set up in the free-list!!!
        dwAddress = PtrToOffset(LPBYTE(pPrevBlockHeader));

        ValidateBlock(dwAddress);
    }
    else
    {
        //We just add this block as it stands to the free-list chain.
        DecorateAsDeleted(dwAddress, GetSize(pBlockHeader), m_pHeapDescriptor->m_dwFreeList, NULL);

        //Point the free-list header pointer at us
        m_pHeapDescriptor->m_dwFreeList = dwAddress;

        //If there is a next block, set the next blocks previous FL pointer to us
        MMF_BLOCK_DELETED *pBlockUser = GetUserBlock(pBlockHeader);
        if (pBlockUser->m_dwFLnext)
        {
            MMF_BLOCK_HEADER *pNextBlockHeader = (MMF_BLOCK_HEADER*)(OffsetToPtr(pBlockUser->m_dwFLnext));
            MMF_BLOCK_TRAILER *pNextBlockTrailer = GetTrailerBlock(pNextBlockHeader);
            pNextBlockTrailer->m_dwFLback = dwAddress;
        }

        ValidateBlock(dwAddress);
    }

    ZeroOutBlock(dwAddress, 0xDD);
    return TRUE;
}

//***************************************************************************
//
//  CMMFArena2::GrowArena
//
//  Grows the head of the MMF by atleast the amount specified.  It does not
//  add the space to the free-list.
//
//  Parameters:
//  <dwGrowBySize>      Number of bytes to allocate.
//
//  Return value:
//  FALSE if cannot grow the heap (either because it is locked, or due to
//  a failure).  TRUE otherwise.
//
//***************************************************************************
DWORD_PTR CMMFArena2::GrowArena(DWORD dwGrowBySize)
{
    //Check that the arena is valid before continuing...
    if (m_dwStatus != 0)
        return 0;

    //Validation of heap and no grow passes 0 in!
    if (dwGrowBySize == 0)
        return 0;

    // We check the current size and see if applying
    // the m_dwGrowBy factor would increase the size beyond
    // the maximum heap size.
    // ======================================================
    DWORD dwIncrement = 0;

    while (dwIncrement < dwGrowBySize)
    {
        if (((m_pHeapDescriptor->m_dwCurrentSize + dwIncrement) / 10) < m_dwMappingGranularity )
            dwIncrement += m_dwMappingGranularity;
        else
            dwIncrement += (m_pHeapDescriptor->m_dwCurrentSize + dwIncrement) / 10;
    }

    //Cap the size of the page...
    //If we are a larger block that the max size allowed... cap it...
    if (dwIncrement > m_dwMaxPageSize)
    {
        dwIncrement = m_dwMaxPageSize;
    }

    // If here, we can try to increase the heap size by remapping.
    // ===========================================================
    MMFOffsetItem *pOffsetItem = 0;
    bool bLastTry = false;
    while (pOffsetItem == 0)
    {
        //Try and use a smaller increment until we fail to allocate the smallest block size possible...
        //---------------------------------------------------------------------------------------------

        //Make sure this block is big enough for the request plus the page header...
        if (dwIncrement < (dwGrowBySize + sizeof(MMF_PAGE_HEADER)))
        {
            dwIncrement = dwGrowBySize + sizeof(MMF_PAGE_HEADER);
            bLastTry = true;
        }

        if (dwIncrement <= m_dwMappingGranularity)
        {
            bLastTry = true;
        }
        //Size should be of a specific granularity...
        if (dwIncrement % m_dwMappingGranularity)
            dwIncrement += (m_dwMappingGranularity - (dwIncrement % m_dwMappingGranularity));

        pOffsetItem = CreateNewPage(m_pHeapDescriptor->m_dwCurrentSize, dwIncrement);

        if (pOffsetItem == 0)
        {
            //We failed!  Can we try again...
            if (bLastTry)
            {
                //No!  This was the smallest we could make the block
                return 0;
            }

            dwIncrement /= 2;
        }

    }
    if (pOffsetItem == 0)
    {
        return 0;
    }

    int nStatus = -1;
    nStatus = m_OffsetManager.InsertAt(m_OffsetManager.Size()-1, pOffsetItem);
    if (nStatus)
    {
        ClosePage(pOffsetItem);
        delete pOffsetItem;
        throw CX_MemoryException();
    }

    DWORD dwNewSize = m_pHeapDescriptor->m_dwCurrentSize + dwIncrement;

    // If here, we succeeded completely
    // ================================
    m_pHeapDescriptor->m_dwHeapExtent = m_pHeapDescriptor->m_dwCurrentSize + sizeof(MMF_PAGE_HEADER);
    m_pHeapDescriptor->m_dwCurrentSize = dwNewSize;
    m_pHeapDescriptor->m_dwEndOfHeap = dwNewSize;

    //get end of file item... and update it with new end offset
    MMFOffsetItem *pEndOffsetItem = (MMFOffsetItem *)m_OffsetManager[m_OffsetManager.Size() - 1];
    pEndOffsetItem->m_dwBaseOffset = dwNewSize;

    return pOffsetItem->m_dwBaseOffset;
}

//***************************************************************************
//
//  CMMFArena2::Flush
//
//  Flushes all uncommited changed to disk.
//
//  Parameters:
//
//  Return value:
//  TRUE if success.
//
//***************************************************************************
BOOL CMMFArena2::Flush()
{
    //Need to loop through all mappings and flush them all...
    //Close each of the file mappings...
    for (int i = 0; i != m_OffsetManager.Size(); i++)
    {
        MMFOffsetItem *pItem = (MMFOffsetItem*)m_OffsetManager[i];
        if (pItem->m_hMappingHandle)
        {
            FlushViewOfFile(pItem->m_pBasePointer, 0);
        }
    }
    return TRUE;
}
//***************************************************************************
//
//  CMMFArena2::Flush
//
//  Flushes the page associated with the specified address
//
//  Parameters:
//      <dwAddress> offset within the MMF to flush
//
//  Return value:
//  TRUE if success.
//
//***************************************************************************
BOOL CMMFArena2::Flush(DWORD_PTR dwAddress)
{
	if (dwAddress > sizeof(MMF_BLOCK_HEADER))
	{
		MMF_BLOCK_HEADER *pHeader = (MMF_BLOCK_HEADER*)OffsetToPtr(dwAddress - sizeof(MMF_BLOCK_HEADER));

		if (!FlushViewOfFile(pHeader, GetSize(pHeader)))
			return FALSE;

		return TRUE;
	}
	else
		return FALSE;
}

//***************************************************************************
//
//  CMMFArena2::DecorateUsedBlock
//
//  Populates the header and trailer blocks in the specified block.
//
//  Parameters:
//      <dwBlock>   Offset of block to decorate
//      <dwBytes>   Size of block
//
//  Return value:
//  TRUE if success.
//
//***************************************************************************
BOOL CMMFArena2::DecorateUsedBlock(DWORD_PTR dwBlock, DWORD dwBytes)
{
    MMF_BLOCK_HEADER *pHeader = (MMF_BLOCK_HEADER *)OffsetToPtr(dwBlock);
	if (!pHeader)
		return FALSE;

    pHeader->m_dwSize = (dwBytes & MMF_REMOVE_DELETED_MASK);
    MMF_BLOCK_TRAILER *pTrailer = GetTrailerBlock(pHeader);
    pTrailer->m_dwFLback = NULL;

    if (sizeof(pTrailer->m_dwCheckBlock))
    {
        for (DWORD dwIndex = 0; dwIndex != (sizeof(pTrailer->m_dwCheckBlock) / sizeof(DWORD)); dwIndex++)
        {
            pTrailer->m_dwCheckBlock[dwIndex] = MMF_DEBUG_INUSE_TAG;
        }
    }

    return TRUE;
}

//***************************************************************************
//
//  CMMFArena2::DecorateAsDeleted
//
//  Populates the header and trailer blocks in the specified block with
//  everything needed to make it look like a deleted block. Updates
//  the items associated with the free list within the block
//
//  Parameters:
//      <dwBlock>               Offset of block to decorate
//      <dwBytes>               Size of block
//      <dwNextFreeListOffset>  next item in the free-list
//      dwPrevFreeListOffset<>  previous item in the free list.
//
//  Return value:
//  TRUE if success.
//
//***************************************************************************
BOOL CMMFArena2::DecorateAsDeleted(DWORD_PTR dwBlock,
                                   DWORD dwBytes,
                                   DWORD_PTR dwNextFreeListOffset,
                                   DWORD_PTR dwPrevFreeListOffset)
{
    MMF_BLOCK_HEADER *pHeader = (MMF_BLOCK_HEADER *)OffsetToPtr(dwBlock);
	if (!pHeader)
		return FALSE;

    pHeader->m_dwSize = (dwBytes | MMF_DELETED_MASK);
    MMF_BLOCK_DELETED *pUserBlock = GetUserBlock(pHeader);
    MMF_BLOCK_TRAILER *pTrailer = GetTrailerBlock(pHeader);
    pTrailer->m_dwFLback = dwPrevFreeListOffset;
    pUserBlock->m_dwFLnext = dwNextFreeListOffset;

    if (sizeof(pTrailer->m_dwCheckBlock))
    {
        for (DWORD dwIndex = 0; dwIndex != (sizeof(pTrailer->m_dwCheckBlock) / sizeof(DWORD)); dwIndex++)
        {
            pTrailer->m_dwCheckBlock[dwIndex] = MMF_DEBUG_DELETED_TAG;
        }
    }

    return TRUE;
}

//***************************************************************************
//
//  CMMFArena2::ValidateBlock
//
//  Validates the memory block as much as possible and calls a debug break
//  point if an error is detected.  Does this by analysing the size and
//  the trailer DWORDs
//
//  Parameters:
//      <dwBlock>               Offset of block to check
//
//  Return value:
//  TRUE if success.
//
//***************************************************************************
#if (defined DEBUG || defined _DEBUG)
BOOL CMMFArena2::ValidateBlock(DWORD_PTR dwBlock)
{
    try
    {
        MMF_BLOCK_HEADER *pHeader = (MMF_BLOCK_HEADER *)OffsetToPtr(dwBlock);
        MMF_BLOCK_TRAILER *pTrailer = GetTrailerBlock(pHeader);
        if (sizeof(pTrailer->m_dwCheckBlock))
        {
            DWORD dwCheckBit;

            //Is it deleted?
            if (pHeader->m_dwSize & MMF_DELETED_MASK)
            {
                //Yes it is, so the we check for 0xFFFF
                dwCheckBit = MMF_DEBUG_DELETED_TAG;
            }
            else
            {
                dwCheckBit = MMF_DEBUG_INUSE_TAG;
            }

            for (DWORD dwIndex = 0; dwIndex != (sizeof(pTrailer->m_dwCheckBlock) / sizeof(DWORD)); dwIndex++)
            {
                if (pTrailer->m_dwCheckBlock[dwIndex] != dwCheckBit)
                {
                    TCHAR string[200];
                    wsprintf(string, __TEXT("WinMgmt: MMF Arena heap corruption,offset = 0x%p\n"), dwBlock);
                    OutputDebugString(string);
                    MMFDebugBreak();
                    _ASSERT(0, string);
                    return FALSE;
                }
            }
        }
        if (!(pHeader->m_dwSize & MMF_DELETED_MASK))
        {
            //We are not deleted, so we should have a trailer back pointer of NULL
            if (pTrailer->m_dwFLback != 0)
            {
                TCHAR string[200];
                wsprintf(string, __TEXT("WinMgmt: MMF Arena heap corruption, offset = 0x%p\n"), dwBlock);
                OutputDebugString(string);
                MMFDebugBreak();
                _ASSERT(0, string);
                return FALSE;
            }

        }
    }
    catch (...)
    {
        TCHAR string[200];
        wsprintf(string, __TEXT("WinMgmt: MMF Arena heap corruption, offset = 0x%p\n"), dwBlock);
        OutputDebugString(string);
        MMFDebugBreak();
        _ASSERT(0, string);
        return FALSE;
    }

    return TRUE;
}
#endif
//***************************************************************************
//
//  CMMFArena2::RemoveBlockFromFreeList
//
//  Removes the specified block from the free-list.
//
//  Parameters:
//      <pBlockHeader>              pointer of block to remove
//
//  Return value:
//  TRUE if success.
//
//***************************************************************************
BOOL CMMFArena2::RemoveBlockFromFreeList(MMF_BLOCK_HEADER *pBlockHeader)
{
    //Bit of validation...
    if (!IsDeleted(pBlockHeader))
    {
        TCHAR string[200];
        wsprintf(string, __TEXT("WinMgmt: MMF Arena heap corruption: deleting deleted block, offset = 0x%p\n"), Fixdown(pBlockHeader));
        OutputDebugString(string);
        MMFDebugBreak();
        _ASSERT(0, string);
        return FALSE;
    }

    MMF_BLOCK_DELETED *pUserBlock = GetUserBlock(pBlockHeader);
    MMF_BLOCK_TRAILER *pTrailerBlock = GetTrailerBlock(pBlockHeader);

    //Deal with next block if it exists
    if (pUserBlock->m_dwFLnext != 0)
    {
        //This has a next block.  Its back pointer needs to point to our back pointer
        MMF_BLOCK_HEADER *pNextFreeBlock = (MMF_BLOCK_HEADER *)OffsetToPtr(pUserBlock->m_dwFLnext);
		if (!pNextFreeBlock)
			return FALSE;

        MMF_BLOCK_TRAILER *pNextTrailerBlock = GetTrailerBlock(pNextFreeBlock);
        pNextTrailerBlock->m_dwFLback = pTrailerBlock->m_dwFLback;
    }

    //Deal with previous block if it exists
    if (pTrailerBlock->m_dwFLback == 0)
    {
        //This is the first item in the free-list so the heap descriptor points to it.
        //Now needs to point to the next item.
        m_pHeapDescriptor->m_dwFreeList = pUserBlock->m_dwFLnext;
    }
    else
    {
        //This has a previous block in the list
        MMF_BLOCK_HEADER *pPrevFreeBlock = (MMF_BLOCK_HEADER *)OffsetToPtr(pTrailerBlock->m_dwFLback);
        MMF_BLOCK_DELETED *pPrevUserBlock = GetUserBlock(pPrevFreeBlock);
        pPrevUserBlock->m_dwFLnext = pUserBlock->m_dwFLnext;
    }

    return TRUE;
}

//***************************************************************************
//
//  CMMFArena2::GetPreviousDeletedBlock
//
//  If the previous block in the MMF is deleted it returns the pointer to
//  it.  If there the previous block is not deleted or there is no
//  previous block it returns NULL
//
//  Parameters:
//      <pBlockHeader>              pointer to the current block
//
//  Return value:
//  NULL if no previous deleted block, otherwise pointer to one.
//
//***************************************************************************
MMF_BLOCK_HEADER *CMMFArena2::GetPreviousDeletedBlock(MMF_BLOCK_HEADER *pBlockHeader)
{
    //If this is the first block there is no previous block...
    if (PtrToOffset(LPBYTE(pBlockHeader)) == sizeof(MMF_ARENA_HEADER))
        return NULL;

    //Only do anything if there are deleted blocks (we have to do this check for the
    //special case, so might as well use it around everything!)
    if (m_pHeapDescriptor->m_dwFreeList)
    {
        //Special case of when the previous block is the head block, in which case the trailer of the
        //previous block is NULL!
        MMF_BLOCK_HEADER *pHeadFreeBlock = (MMF_BLOCK_HEADER*)OffsetToPtr(m_pHeapDescriptor->m_dwFreeList);
		if (!pHeadFreeBlock)
			return NULL;

        if ((LPBYTE(pHeadFreeBlock) + GetSize(pHeadFreeBlock)) == LPBYTE(pBlockHeader))
        {
            //The head block is the previous deleted block!
            return pHeadFreeBlock;
        }

        //Get the trailer pointer to the previous block...
        MMF_BLOCK_TRAILER *pPrevBlockTrailer = (MMF_BLOCK_TRAILER *)(LPBYTE(pBlockHeader) - sizeof(MMF_BLOCK_TRAILER));
        if (pPrevBlockTrailer->m_dwFLback == NULL)
        {
            //The previous block is not deleted. (if this was the head free-list item we would
            //have returned it in the special case!)
            return NULL;
        }

        //Now we need to get the previous deleted block to this previous block!
        MMF_BLOCK_HEADER *pPrevPrevBlockHeader = (MMF_BLOCK_HEADER *)OffsetToPtr(pPrevBlockTrailer->m_dwFLback);

        //Now need this blocks user section so we can get the start of the next free-list item (the one we
        //want!)
        MMF_BLOCK_DELETED *pPrevPrevBlockUser = (MMF_BLOCK_DELETED *)(LPBYTE(pPrevPrevBlockHeader) + sizeof(MMF_BLOCK_HEADER));
        return (MMF_BLOCK_HEADER *)OffsetToPtr(pPrevPrevBlockUser->m_dwFLnext);
    }

    //There are no deleted blocks!
    return NULL;
}

#if (defined DEBUG || defined _DEBUG)
BOOL CMMFArena2::ZeroOutBlock(DWORD_PTR dwBlock, int cFill)
{
    MMF_BLOCK_HEADER *pBlockHeader = (MMF_BLOCK_HEADER *)OffsetToPtr(dwBlock);
    if (IsDeleted(pBlockHeader))
    {
        memset(LPBYTE(pBlockHeader) + sizeof(MMF_BLOCK_HEADER) + sizeof(MMF_BLOCK_DELETED), cFill, GetSize(pBlockHeader) - sizeof(MMF_BLOCK_HEADER) - sizeof(MMF_BLOCK_TRAILER) - sizeof(MMF_BLOCK_DELETED));
    }
    else
    {
        memset(LPBYTE(pBlockHeader) + sizeof(MMF_BLOCK_HEADER), cFill, GetSize(pBlockHeader) - sizeof(MMF_BLOCK_HEADER) - sizeof(MMF_BLOCK_TRAILER));
    }
    return TRUE;
}
#endif

//Some debugging functions...
void CMMFArena2::Reset()
{
    // Move cursor to first block.
    // ===========================

    m_dwCursor = sizeof(MMF_ARENA_HEADER);
}

BOOL CMMFArena2::Next(LPBYTE *ppBlock, DWORD *pdwSize, BOOL *pbActive)
{
    if (m_dwCursor >= m_pHeapDescriptor->m_dwHeapExtent)
        return FALSE;

    // Return the block address and block size values to the caller.
    // We strip out the MS bit of the block size, since it is not
    // part of the size, but indicates whether or not the block is
    // part of the free list or part of the active chain.
    // =============================================================

    MMF_BLOCK_HEADER *pBlockHeader = (MMF_BLOCK_HEADER *)OffsetToPtr(m_dwCursor);

	if (!pBlockHeader)
		return FALSE;

	*ppBlock = LPBYTE(pBlockHeader) + sizeof(MMF_BLOCK_HEADER);  // Move past the head block.
	*pdwSize = GetSize(pBlockHeader) - sizeof(MMF_BLOCK_HEADER) - sizeof(MMF_BLOCK_TRAILER);

	*pbActive = !IsDeleted(pBlockHeader);

	// Advance our cursor.
	// ===================

	m_dwCursor += GetSize(pBlockHeader);

	return TRUE;
}

//***************************************************************************
//
//  CMMFArena::TextDump
//
//  Dumps a summary of the heap to a text file.
//
//  Parameters:
//  <pszFile>       The text file to which to perform the dump. This
//                  file is appended to.
//
//***************************************************************************

void CMMFArena2::TextDump(const char *pszFile)
{
    FILE *f = fopen(pszFile, "at");
    if (!f)
        return;

    LPBYTE pAddress = 0;
    DWORD dwSize = 0;
    BOOL bActive = 0;

    // Primary heap.
    // =============

    fprintf(f, "---Primary Heap Contents---\n");

    Reset();
    while (Next(&pAddress, &dwSize, &bActive))
    {
        fprintf(f, "BLOCK 0x%X  Size=%06d ", PtrToOffset(pAddress), dwSize);
        if (bActive)
            fprintf(f, "(active)  :");
        else
            fprintf(f, "(deleted) :");

        for (int i = 0; i < (int) dwSize && i < 32; i++)
            if (pAddress[i] < 32)
                fprintf(f, ".");
            else
                fprintf(f, "%c", pAddress[i]);
        fprintf(f, "\n");
    }

    fclose(f);
}

//***************************************************************************
//
//  CMMFArena::GetHeapInfo
//
//  Gets detailed summary info about the heap.  Completely walks the
//  heap to do this.
//
//  Parameters:
//      <pdwTotalSize>          Receives the heap size.
//      <pdwActiveBlocks>       Receives the number of allocated blocks.
//      <pdwActiveBytes>        Receives the total allocated bytes.
//      <pdwFreeBlocks>         Receives the number of 'free' blocks.
//      <pdwFreeByte>           Receives the number of 'free' bytes.
//
//***************************************************************************

void CMMFArena2::GetHeapInfo(
    DWORD *pdwTotalSize,
    DWORD *pdwActiveBlocks,
    DWORD *pdwActiveBytes,
    DWORD *pdwFreeBlocks,
    DWORD *pdwFreeBytes
    )
{
    LPBYTE pAddress = 0;
    DWORD dwSize = 0;
    BOOL bActive = 0;

    if (pdwTotalSize)
        *pdwTotalSize = m_pHeapDescriptor->m_dwCurrentSize;

    if (pdwActiveBlocks)
        *pdwActiveBlocks = 0;
    if (pdwActiveBytes)
        *pdwActiveBytes = 0;
    if (pdwFreeBlocks)
        *pdwFreeBlocks = 0;
    if (pdwFreeBytes)
        *pdwFreeBytes = 0;


    Reset();
    while (Next(&pAddress, &dwSize, &bActive))
    {
        if (bActive)
        {
            if (pdwActiveBytes)
                (*pdwActiveBytes) += dwSize;
            if (pdwActiveBlocks)
                (*pdwActiveBlocks)++;
        }
        else
        {
            if (pdwFreeBytes)
                (*pdwFreeBytes) += dwSize;
            if (pdwFreeBlocks)
                (*pdwFreeBlocks)++;
        }
    }
}

BOOL CMMFArena2::FileValid(const TCHAR *pszFilename)
{
    BOOL bValid = FALSE;
    HANDLE hFile = CreateFile(
         pszFilename,
         GENERIC_READ | GENERIC_WRITE,
         FILE_SHARE_READ,                                   // Share mode = exclusive
         0,                                                 // Security
         OPEN_EXISTING,                                     // Creation distribution
         FILE_ATTRIBUTE_NORMAL | FILE_FLAG_RANDOM_ACCESS,   // Attribute
         0                                                  // Template file
         );

    if (hFile == INVALID_HANDLE_VALUE)
    {
        //This means the file does not exist or something screwy has happened.
        return FALSE;
    }

    MMF_ARENA_HEADER header;
    DWORD dwBytesRead;
    if (ReadFile(hFile, &header, sizeof(MMF_ARENA_HEADER), &dwBytesRead, NULL))
    {
        if (sizeof(MMF_ARENA_HEADER) == dwBytesRead)
        {
            if (header.m_dwVersion <= 3)
            {
                //The header exists, now we need to check to make sure the file length is
                //correct...
                //Magic numbers :-)  This is how the Version 3 or less size was calculated.
                //actually it was sizeof the header, which was 568 in those days.
                if (GetFileSize(hFile, NULL) == (header.m_dwCurrentSize + 568))
                {
                    bValid = TRUE;
                }
                else
                {
                    //The sizes are not the same...
                }
            }
            else
            {
                //The header exists, now we need to check to make sure the file length is
                //correct...
                if (GetFileSize(hFile, NULL) == header.m_dwCurrentSize)
                {
                    bValid = TRUE;
                }
                else
                {
                    //The sizes are not the same...
                }
            }

        }
        else
        {
            //Implies the file length may have been zeroed out or something
        }
    }
    else
    {
        //Implies the file length may have been zeroed out or something
    }

    CloseHandle(hFile);

    _ASSERT(bValid == TRUE, "Repository size is not the same as the size we think it should be.");

    return bValid;
}

DWORD_PTR CMMFArena2::GetRootBlock()
{
    if (m_pHeapDescriptor->m_dwVersion <= 3)
    {
        DWORD_PTR *pMem = (DWORD_PTR*) m_pHeapDescriptor;
        return pMem[9];
    }
    else
    {
        return (m_pHeapDescriptor ? m_pHeapDescriptor->m_dwRootBlock : 0);
    }
}

DWORD CMMFArena2::Size(DWORD_PTR dwBlock)
{
    if (m_dwStatus != 0)
        throw DATABASE_FULL_EXCEPTION();

    //Set the address to point to the actual start of the block
    dwBlock -= sizeof(MMF_BLOCK_HEADER);

    //Check the block is valid...
    ValidateBlock(dwBlock);

    MMF_BLOCK_HEADER *pBlockHeader = (MMF_BLOCK_HEADER*)OffsetToPtr(dwBlock);

	if (pBlockHeader)
		return GetSize(pBlockHeader);
	else
		return 0;
}

//Given an offset, returns a fixed up pointer
LPBYTE CMMFArena2::OffsetToPtr(DWORD_PTR dwOffset)
{
    if (dwOffset == 0)
        return 0;

    if (m_dwStatus != 0)
        throw DATABASE_FULL_EXCEPTION();

    try
    {
        LPBYTE pBlock = 0;
        int l = 0, u = m_OffsetManager.Size() - 1;

        while (l <= u)
        {
            int m = (l + u) / 2;
            if (dwOffset < ((MMFOffsetItem *)m_OffsetManager[m])->m_dwBaseOffset)
            {
                u = m - 1;
            }
            else if (dwOffset >= ((MMFOffsetItem *)m_OffsetManager[m+1])->m_dwBaseOffset)
            {
                l = m + 1;
            }
            else
            {
                return ((MMFOffsetItem *)m_OffsetManager[m])->m_pBasePointer + (dwOffset - ((MMFOffsetItem *)m_OffsetManager[m])->m_dwBaseOffset);
            }
        }
    }
    catch (...)
    {
    }
    TCHAR string[220];
    wsprintf(string, __TEXT("WinMgmt: Could not find the block requested in the repository, offset requested = 0x%p, end of repository = 0x%p\n"), dwOffset, ((MMFOffsetItem *)m_OffsetManager[m_OffsetManager.Size()-1])->m_dwBaseOffset);
    OutputDebugString(string);
    _ASSERT(0, string);
    MMFDebugBreak();
    return 0;
}

//Given a pointer, returns an offset from the start of the MMF
DWORD_PTR  CMMFArena2::PtrToOffset(LPBYTE pBlock)
{
    if (m_dwStatus != 0)
        throw DATABASE_FULL_EXCEPTION();

    for (int i = 0; i < m_OffsetManager.Size(); i++)
    {
        register MMFOffsetItem *pItem = (MMFOffsetItem *)m_OffsetManager[i];
        if ((pBlock >= pItem->m_pBasePointer) &&
            (pBlock < (pItem->m_pBasePointer + pItem->m_dwBlockSize)))
        {
            return pItem->m_dwBaseOffset + (pBlock - pItem->m_pBasePointer);
        }
    }
    TCHAR string[220];
    wsprintf(string, __TEXT("WinMgmt: Could not find the offset requested in the repository, pointer requested = 0x%p\n"), pBlock);
    OutputDebugString(string);
    _ASSERT(0, string);
    MMFDebugBreak();
    return 0;
}

DWORD_PTR CMMFArena2::GetBlockBaseAddress(DWORD_PTR dwOffset, DWORD &dwSize)
{
    LPBYTE pBlock = 0;
    int l = 0, u = m_OffsetManager.Size() - 1;

    while (l <= u)
    {
        int m = (l + u) / 2;
        if (dwOffset < ((MMFOffsetItem *)m_OffsetManager[m])->m_dwBaseOffset)
        {
            u = m - 1;
        }
        else if (dwOffset >= ((MMFOffsetItem *)m_OffsetManager[m+1])->m_dwBaseOffset)
        {
            l = m + 1;
        }
        else
        {
            register MMFOffsetItem *pItem = (MMFOffsetItem *)m_OffsetManager[m];
            dwSize = pItem->m_dwBlockSize;
            return pItem->m_dwBaseOffset;
        }
    }
    TCHAR string[220];
    wsprintf(string, __TEXT("WinMgmt: Could not find the block requested in the repository, offset requested = 0x%p, end of repository = 0x%p\n"), dwOffset, ((MMFOffsetItem *)m_OffsetManager[m_OffsetManager.Size()-1])->m_dwBaseOffset);
    OutputDebugString(string);
    _ASSERT(0, string);
    MMFDebugBreak();
    return 0;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\vs7\vside\servexpl\generator\wmigenerator\wmigenerator.cs ===
namespace System.Management
{
using System;
using System.CodeDom;
using System.CodeDom.Compiler;
using System.IO;
using System.Reflection;
using System.Management;
using System.Collections;
using Microsoft.CSharp;
using Microsoft.JScript;
using Microsoft.VisualBasic;
using Microsoft.VSDesigner;


public enum Languages
{
	CSharp,
	JScript,
	VB
}
/// <summary>
///    This class is used for the automatic generation of 
///    early bound managed code class for a given WMI class
/// </summary>
public class ManagementClassGenerator
{
	private Languages OutputLanguage;
	private string OriginalServer = string.Empty;
	private string OriginalNamespace = string.Empty;
	private string OriginalClassName = string.Empty;
	private string OriginalPath = string.Empty;
	private bool bSingletonClass = false;
	private string ExceptionString = "Class name doesn't match.";


	private ManagementClass classobj;
	private ICodeGenerator cg;
	private TextWriter tw = null;
	private string genFileName = string.Empty;
	private CodeTypeDeclaration cc;
	private CodeTypeDeclaration ccc;
	private CodeTypeDeclaration ecc;
	private CodeTypeDeclaration EnumObj;
	private CodeCommentStatement ccs;
	private CodeNamespace cn;
	private CodeMemberProperty  cmp;
	private CodeConstructor cctor;
	private CodeMemberField cf;
	private CodeObjectCreateExpression coce;
	private CodeSnippetExpression cle;
	private CodeParameterDeclarationExpression cpde;
	private CodeIndexerExpression cie;
	private CodeMemberField cmf;
	private CodeMemberMethod cmm;
	private CodePropertyReferenceExpression cpre;
	private CodeMethodInvokeExpression cmie;
	private CodeExpressionStatement cmis;
	private CodeConditionStatement cis;
	private CodeBinaryOperatorExpression cboe;
	private CodeIterationStatement cfls;
	private CodeAttributeArgument caa;
	private CodeAttributeDeclaration cad;

	private ArrayList arrKeyType = new ArrayList(5);
	private ArrayList arrKeys = new ArrayList(5);
	private ArrayList BitMap = new ArrayList(5);
	private ArrayList BitValues = new ArrayList(5);
	private ArrayList ValueMap = new ArrayList(5);
	private ArrayList Values = new ArrayList(5);

	private SortedList PublicProperties = new SortedList(new CaseInsensitiveComparer());
	private SortedList PublicMethods = new SortedList (new CaseInsensitiveComparer());
	private SortedList PublicNamesUsed = new SortedList(new CaseInsensitiveComparer());
	private SortedList PrivateNamesUsed = new SortedList(new CaseInsensitiveComparer());

	/// <summary>
	/// The constructor.
	/// </summary>
	/// <param name="MachineName"> The Server to which we should connect to.</param>
	/// <param name="NameSpace">  The WMI namespace which contains the class to be generated</param>
	/// <param name="ClassName"> The WMI class for which the early bound wrapper is needed</param>
	public ManagementClassGenerator()
	{
	}

	public bool GenerateCode(string Server,string Namespace,string ClassName,string Language, string FilePath)
	{
		if(InitializeCodeGeneration(Server,Namespace,ClassName,Language) == true)
		{
			InitializeCodeGenerator(Language,FilePath);
			return GenerateCodeNow();
		}
		return false;
	}

	public bool GenerateCode(string strPath,ICodeGenerator icg,TextWriter textStream,string Language)
	{
		if (strPath == string.Empty)
		{
			throw new ArgumentOutOfRangeException ("strPath");
		}
		OriginalPath = strPath;

		//cut off the last character (byte-order-mark):
		strPath = strPath.Substring(0, strPath.Length - 1);

		//parse the path to get server, namespace and class name
		Int32 separ = strPath.IndexOf("\\", 2);
		if (separ == -1)
		{
			throw new ArgumentOutOfRangeException ("strPath");
		}

		string serverName = strPath.Substring(2, separ - 2);

		string pathNoServer = strPath.Substring(separ + 1, strPath.Length - separ - 1);
					
		//split pathNoServer into namespace and classname parts (':' is the separator)
		Int32 colon = pathNoServer.IndexOf(':', 0);		
		if (colon == -1)
		{
			throw new ArgumentOutOfRangeException ("strPath");
		}

		string className = string.Empty;
		string nsName = string.Empty;
			
		nsName = pathNoServer.Substring(0,colon);
		className = pathNoServer.Substring(colon + 1, pathNoServer.Length - colon - 1);		
	
		//ManagementPath thePath = new ManagementPath(strPath);
		//MessageBox.Show("Server is " + thePath.Server + " ns is " + thePath.NamespacePath +
		//	" class is " + thePath.ClassName);
		//if(InitializeCodeGeneration(thePath.Server,thePath.NamespacePath, thePath.ClassName,Language) == true)
		if(InitializeCodeGeneration(serverName, nsName, className,Language) == true)
		{
			cg = icg;
			tw = textStream;
			return GenerateCodeNow();
		}
		
		return false;
		
	}

	public bool InitializeCodeGeneration(string Server,string NameSpace,string ClassName,string Language)
	{
		switch(Language.ToUpper ())
		{
			case "VB":
				OutputLanguage = Languages.VB;
				break;
			case "JS":
				OutputLanguage = Languages.JScript;
				break;
			default:
				OutputLanguage = Languages.CSharp;
				break;
		}

		if(Server != string.Empty)
			OriginalServer = Server.ToUpper();
		else
			OriginalServer = string.Empty;
		OriginalNamespace = NameSpace.ToUpper(); //ConvertToTitleCase(NameSpace);
		OriginalClassName = ClassName.ToUpper(); //ConvertToTitleCase(ClassName);

		//First try to get the class object for the given WMI Class.
		//If we cannot get it then there is no point in continuing 
		//as we won't have any information for the code generation.
		if(InitializeClassObject() == false)
		{
			return false;
		}

		//Initialize the public attributes . private variables
		InitilializePublicPrivateMembers();

		//First form the namespace for the generated class.
		//The namespace will look like System.Wmi.Root.Cimv2.Win32
		//for the path \\root\cimv2:Win32_Service and the class name will be
		//Service.
		ProcessNamespaceAndClassName();

		//First we will sort out the different naming collision that might occur 
		//in the generated code.
		ProcessNamingCollisions();
		return true;
	}

	/// <summary>
 	/// This function will generate the code. This is the function which 
	/// should be called for generating the code.
	/// </summary>
	/// <param name="Language"> The target language for the generated code.
	///		The supported Values as of now are 
	///				"VB" - Visual Basic
	///				"JS" - JavaScript
	///				"CS" - CSharp
	///		If you pass an invalid parameter, it will be defaulted to CSharp </param>
	/// <param name="FilePath"> This is the path where you want the 
	///		generated code to reside</param>
    public bool GenerateCodeNow()
    {
		try
		{
			//Now Initialize the code class for generation
			InitializeCodeTypeDeclaration();

			//Generate the code for defaultNamespace
			//public string defNamespace {
			//	get {
			//			return (<defNamespace>);
			//		}
			//}
			GeneratePublicReadOnlyProperty(PublicNamesUsed["NamespaceProperty"].ToString(),"String",
				OriginalNamespace,false,true);

			//Generate the code for defaultClassName
			//public string defClassName {
			//	get {
			//			return (<defClassName>);
			//		}
			//}
			GeneratePublicReadOnlyProperty(PublicNamesUsed["ClassNameProperty"].ToString(),"String",
				OriginalClassName,false,true);

			//public SystemPropertiesClass _SystemProps{
			//	get {
			//			return (privSysProps);
			//		}
			//}
			GeneratePublicReadOnlyProperty(PublicNamesUsed["SystemPropertiesProperty"].ToString(),PublicNamesUsed["SystemPropertiesClass"].ToString(),
				PrivateNamesUsed["SystemPropertiesObject"].ToString(),true,true);

			//public wmiObjectClass _Object{
			//	get {
			//			return (privWmiObject);
			//		}
			//}
			GeneratePublicReadOnlyProperty(PublicNamesUsed["LateBoundObjectProperty"].ToString(),PublicNamesUsed["LateBoundClass"].ToString(),
				PrivateNamesUsed["LateBoundObject"].ToString(),true,false);

			//public ManagementScope Scope {
			//	get {
			//			return privScope;
			//		}
			//	set {
			//			privScope = value;
			//		}
			//}
			GeneratePublicProperty(PublicNamesUsed["ScopeProperty"].ToString(),PublicNamesUsed["ScopeClass"].ToString(),
				new CodePropertyReferenceExpression(
				new CodeSnippetExpression(PrivateNamesUsed["LateBoundObject"].ToString())
				,"Scope"),true);

			//public ManagementPath Path {
			//	get {
			//			return privWmiObject.Path;
			//		}
			//	set {
			//			if(String.Compare(value.ClassName,className,true) != 0)
			//				throw new ArgumentException("Class name doesn\'t match.");
			//			privWmiObject.Path = value;
			//		}
			//}
			GeneratePathProperty();

			//Now generate properties of the WMI Class
			GenerateProperties();

			//Now Generate static ConstructPath()
			GenerateConstructPath();
			
			//Now create the default constructor
			GenerateDefaultConstructor();

			if(bSingletonClass == true)
			{
				//Now Generate a constructor which accepts only the scope
				GenerateConstructorWithScope();

				//Now Generate a constructor which accepts only the get options
				GenerateConstructorWithOptions();

				//Now generate a constructor which accepts both scope and options
				GenerateConstructorWithScopeOptions();
			}
			else
			{
				//Now create the constuctor which accepts the key values
				GenerateConstructorWithKeys();

				//Also generate a constructor which accepts a scope and keys
				GenerateConstructorWithScopeKeys();

				//Now create constructor with path object
				GenerateConstructorWithPath();

				//Now generate constructor with Path & Options
				GenerateConstructorWithPathOptions();

				//Now Generate a constructor with scope & path
				GenerateConstructorWithScopePath();

				//Now Generate the GetInstances()
				GenerateGetInstancesWithNoParameters();

				//Now Generate the GetInstances(condition)
				GenerateGetInstancesWithCondition();

				//Now Generate the GetInstances(propertylist)
				GenerateGetInstancesWithProperties();

				//Now Generate the GetInstances(condition,propertylist)
				GenerateGetInstancesWithWhereProperties();

				//Now Generate the GetInstances(scope)
				GenerateGetInstancesWithScope();

				//Now Generate the GetInstances(scope,condition)
				GenerateGetInstancesWithScopeCondition();

				//Now Generate the GetInstances(scope,propertylist)
				GenerateGetInstancesWithScopeProperties();

				//Now Generate the GetInstances(scope,condition,propertylist)
				GenerateGetInstancesWithScopeWhereProperties();

				//Generate the Collection Class
				GenerateCollectionClass();
			}

			//Now Generate the constructor with path,scope,options
			GenerateConstructorWithScopePathOptions();

			//Now generate Constructor with latebound Object
			GenarateConstructorWithLateBound();

			//Now Enumerate all the methods
			GenerateMethods();

			//Now declare the private class variables
			//private Wmi_SystemProps SystemProps
			GeneratePrivateMember(PrivateNamesUsed["SystemPropertiesObject"].ToString(),PublicNamesUsed["SystemPropertiesClass"].ToString());

			//private WmiObject privObject
			GeneratePrivateMember(PrivateNamesUsed["LateBoundObject"].ToString(),PublicNamesUsed["LateBoundClass"].ToString());

			//Also add the custom attribute to the generated class

			//ZINA: commenting this out since all persistence description mechanism
			//has completely changed in Beta2 (see http://net/change_details.aspx?change%5Fid=512)
			//Uncomment the lines below once the method implementation is fixed.
/*
			caa = new CodeAttributeArgument();
			caa.Value = new CodeTypeOfExpression(PrivateNamesUsed["ConverterClass"].ToString());
			cad = new CodeAttributeDeclaration();
			cad.Name = PublicNamesUsed["TypeConverter"].ToString();
			cad.Arguments.Add(caa);
			cc.CustomAttributes = new CodeAttributeDeclarationCollection();
			cc.CustomAttributes.Add(cad);
*/

			//As we have finished the class definition, generate the class code NOW!!!!!
			cn.Types.Add (cc);

			GenerateSystemPropertiesClass();

			//Now generate the Type Converter class also

			//ZINA: commenting this out since all persistence description mechanism
			//has completely changed in Beta2 (see http://net/change_details.aspx?change%5Fid=512)
			//Uncomment the line below once the method implementation is fixed.
			//GenerateTypeConverterClass();

			//throw new Exception("about to call GenerateCodeFromNamespace");

			cg.GenerateCodeFromNamespace (cn, tw, new CodeGeneratorOptions());

			//tw.Flush();
			tw.Close();
			return true;
		}
		catch (Exception exc)
		{
			throw (exc);
			//return false;
		}
    }

/// <summary>
/// Function for initializing the class object that will be used to get all the 
/// method and properties of the WMI Class for generating the code.
/// </summary>
	public bool InitializeClassObject()
	{
		//First try to connect to WMI and get the class object.
		// If it fails then no point in continuing
		try
		{

			if (OriginalPath != string.Empty)
			{
				classobj = new ManagementClass (OriginalPath);
			}
			else
			{
				ManagementPath thePath = new ManagementPath();
				if(OriginalServer != String.Empty)
					thePath.Server = OriginalServer;
				thePath.ClassName = OriginalClassName;
				thePath.NamespacePath = OriginalNamespace;

				classobj = new ManagementClass (thePath);

				/*
				throw new Exception("OriginalServer is " + OriginalServer +
					" OriginalNamespace is " + OriginalNamespace +
					" OriginalClassName is " + OriginalClassName +
					" results in " + thePath.Path);
					*/
			}

			//throw new Exception("classobj's path is " + classobj.Path.Path);				
			

			//By default all classes are non-singleton(???)
			bSingletonClass = false;				
			foreach (Qualifier q in classobj.Qualifiers)
			{
				if(String.Compare(q.Name,"singleton",true) == 0)
				{
					//This is a singleton class
					bSingletonClass = true;
					break;
				}
			}
			return true;
		}
		catch(Exception e)
		{
			//TODO: Decide what to do here???????
			Console.WriteLine("Exception Occured on Create.Reason [{0}]\n\nStack Trace : \n{1}",e.Message,e.StackTrace);
			throw e;
			return false;
		}
	}
	/// <summary>
	/// This functrion initializes the public attributes and private variables 
	/// list that will be used in the generated code. 
	/// </summary>
	void InitilializePublicPrivateMembers()
	{
		//Initialize the public members
		PublicNamesUsed.Add("SystemPropertiesProperty","SystemProperties");
		PublicNamesUsed.Add("LateBoundObjectProperty","LateBoundObject");
		PublicNamesUsed.Add("NamespaceProperty","OriginatingNamespace");
		PublicNamesUsed.Add("ClassNameProperty","ManagementClassName");
		PublicNamesUsed.Add("ScopeProperty","Scope");
		PublicNamesUsed.Add("PathProperty","Path");
		PublicNamesUsed.Add("SystemPropertiesClass","ManagementSystemProperties");
		PublicNamesUsed.Add("LateBoundClass","ManagementObject");
		PublicNamesUsed.Add("PathClass","ManagementPath");
		PublicNamesUsed.Add("ScopeClass","ManagementScope");
		PublicNamesUsed.Add("QueryOptionsClass","QueryOptions");
		PublicNamesUsed.Add("GetOptionsClass","ObjectGetOptions");
		PublicNamesUsed.Add("ArgumentExceptionClass","ArgumentException");
		PublicNamesUsed.Add("QueryClass","SelectQuery");
		PublicNamesUsed.Add("ObjectSearcherClass","ManagementObjectSearcher");
		PublicNamesUsed.Add("FilterFunction","GetInstances");
		PublicNamesUsed.Add("ConstructPathFunction","ConstructPath");
		PublicNamesUsed.Add("TypeConverter","TypeConverter");

		//Initialize the Private Members
		PrivateNamesUsed.Add("SystemPropertiesObject","PrivateSystemProperties");	
		PrivateNamesUsed.Add("LateBoundObject","PrivateLateBoundObject");			
	}

/// <summary>
/// This function will solve the naming collisions that might occur
/// due to the collision between the local objects of the generated
/// class and the properties/methos of the original WMI Class.
/// </summary>
	void ProcessNamingCollisions()
	{
		if(classobj.Properties != null)
		{
			foreach(Property prop in classobj.Properties)
			{
				PublicProperties.Add(prop.Name,prop.Name);
			}
		}

		if(classobj.Methods != null)
		{
			foreach(Method meth in classobj.Methods)
			{
				PublicMethods.Add(meth.Name,meth.Name);
			}
		}

		int nIndex;

		//Process the collisions here
		//We will check each public names with the property names here.
		foreach(String s in PublicNamesUsed.Values)
		{
			nIndex = IsContainedIn(s,ref PublicProperties);
			if( nIndex != -1)
			{
				//We had found a collision with a public property
				//So we will resolve the collision by changing the property name 
				//and continue
				PublicProperties.SetByIndex(nIndex,ResolveCollision(s,false));
				continue;
			}
			
			nIndex = IsContainedIn(s,ref PublicMethods);
			if(nIndex != -1)
			{
				//We had found a collision with a public method
				//So we will resolve the collision by changing the method name 
				//and continue
				PublicMethods.SetByIndex(nIndex,ResolveCollision(s,false));
				continue;
			}
		}

		//Now we will check for collision against private variables
		foreach(String s in PublicProperties.Values)
		{
			nIndex = IsContainedIn(s,ref PrivateNamesUsed);
			if(nIndex != -1)
			{
				//We had found a collision with a public property
				//So we will resolve the collision by changing the private name 
				//and continue
				PrivateNamesUsed.SetByIndex(nIndex,ResolveCollision(s,false));
			}
		}
		
		foreach(String s in PublicMethods.Values)
		{
			nIndex = IsContainedIn(s,ref PrivateNamesUsed);
			if(nIndex != -1)
			{
				//We had found a collision with a public method
				//So we will resolve the collision by changing the private name 
				//and continue
				PrivateNamesUsed.SetByIndex(nIndex,ResolveCollision(s,false));
			}
		}

		//Now we will create the CollectionClass and Enumerator Class names as they are dependent on the
		//generated class name and the generated class name might have changed due to collision
		string strTemp = PrivateNamesUsed["GeneratedClassName"].ToString()+"Collection";
		PrivateNamesUsed.Add("CollectionClass",ResolveCollision(strTemp,true));

		strTemp = PrivateNamesUsed["GeneratedClassName"].ToString()+"Enumerator";
		PrivateNamesUsed.Add("EnumeratorClass",ResolveCollision(strTemp,true));
}

	/// <summary>
	/// This function is used to resolve (actually generate a new name) collision
	/// between the generated class properties/variables with WMI methods/properties.
	/// This function safely assumes that there will be atleast one string left 
	/// in the series prop0, prop1 ...prop<maxint>. Otherwise this function will
	/// enter an infinite loop. May be we can avoid this through something, which 
	/// i will think about it later
	/// </summary>
	/// <param name="inString"> </param>
	public String ResolveCollision(string inString,bool bCheckthisFirst)
	{
		string strTemp = inString;
		bool bCollision = true;
		int k = -1;
		if(bCheckthisFirst == false)
		{
			k++;
			strTemp = strTemp + k.ToString();
		}

		while(bCollision == true)
		{
			if(IsContainedIn(strTemp,ref PublicProperties) == -1)
			{
				if(IsContainedIn(strTemp,ref PublicMethods) == -1)
				{
					if(IsContainedIn(strTemp,ref PublicNamesUsed) == -1)
					{
						if(IsContainedIn(strTemp,ref PrivateNamesUsed) == -1)
						{
							//So this is not colliding with anything.
							bCollision = false;
							break;
						}
					}
				}
			}
			
			k++;
			strTemp = strTemp + k.ToString();
		}
		return strTemp;
	}

/// <summary>
/// This function processes the WMI namespace and WMI classname and converts them to
/// the namespace used to generate the class and the classname.
/// </summary>
/// <param name="strNs"> </param>
/// <param name="strClass"> </param>
	public void ProcessNamespaceAndClassName()
	{
		string strClass;
		string strNs;

        strNs = OriginalNamespace;
		strNs = strNs.Replace ('\\','.');
		strNs = "System.Management." + strNs;

		if(OriginalClassName.IndexOf('_') > 0)
		{
			strNs += ".";
			strClass = OriginalClassName.Substring(0,OriginalClassName.IndexOf('_'));
			strNs += strClass;
			//Now trim the class name without the first '_'
			strClass = OriginalClassName.Substring(OriginalClassName.IndexOf('_')+1);
		}
		else
		{
			strClass = OriginalClassName;
		}

		PrivateNamesUsed.Add("GeneratedClassName",strClass);
		PrivateNamesUsed.Add("GeneratedNamespace",strNs);
		PrivateNamesUsed.Add("ConverterClass",strClass+"Converter");
	}
/// <summary>
/// This function initializes the code generator object. It initializes the 
/// code generators namespace and the class objects also.
/// </summary>
/// <param name="strNs"> </param>
/// <param name="strClass"> </param>
	public void InitializeCodeGenerator(string Language, string FilePath)
	{
		string suffix = ".CS";		///Defaulted to CS
		switch(Language.ToUpper ())
		{
			case "VB":
				suffix = ".VB";
				cg = (new VBCodeProvider()).CreateGenerator ();
				OutputLanguage = Languages.VB;
				break;
			case "JS":
				suffix = ".JScript";
				cg = (new JScriptCodeProvider()).CreateGenerator ();
				OutputLanguage = Languages.JScript;
				break;
			default:
				cg = (new CSharpCodeProvider()).CreateGenerator ();
				OutputLanguage = Languages.CSharp;
				break;
		}

		genFileName = FilePath+PrivateNamesUsed["GeneratedClassName"].ToString()+suffix;
		//Now create the filestream (output file)
		tw = new StreamWriter(new FileStream (genFileName,
									FileMode.Create));
	}

	
	public void InitializeCodeTypeDeclaration()
	{
		//Comment statement //Early Bound Managed Code Wrapper for WMI class <WMiClass> 
		ccs = new CodeCommentStatement (String.Format ("Early Bound Managed Code Wrapper for WMI class {0}",OriginalClassName));
		cg.GenerateCodeFromStatement (ccs, tw, new CodeGeneratorOptions());

		//Now add the import statements
		cn = new CodeNamespace(PrivateNamesUsed["GeneratedNamespace"].ToString());
		cn.Imports.Add (new CodeNamespaceImport("System"));
		cn.Imports.Add (new CodeNamespaceImport("System.ComponentModel"));
		cn.Imports.Add (new CodeNamespaceImport("System.Management"));
		cn.Imports.Add(new CodeNamespaceImport("System.Collections"));

		//Now create the class
		cc = new CodeTypeDeclaration (PrivateNamesUsed["GeneratedClassName"].ToString());
	}
/// <summary>
/// This function generates the code for the read only property.
/// The generated code will be of the form
///		public <propType> <propName> {
///			get {
///					return (<propValue>);
///				}
///		}
/// </summary>
/// <param name="propName"> </param>
/// <param name="propType"> </param>
/// <param name="propValue"> </param>
	public void GeneratePublicReadOnlyProperty(string propName, string propType, object propValue,bool isLiteral,bool isBrowsable)
	{
		cmp = new CodeMemberProperty ();
		cmp.Name = propName;
		cmp.Attributes = MemberAttributes.Public | MemberAttributes.Final ;
		cmp.Type = new CodeTypeReference(propType);

		caa = new CodeAttributeArgument();
		caa.Value = new CodePrimitiveExpression(isBrowsable);
		cad = new CodeAttributeDeclaration();
		cad.Name = "Browsable";
		cad.Arguments.Add(caa);
		cmp.CustomAttributes = new CodeAttributeDeclarationCollection();
		cmp.CustomAttributes.Add(cad);

		if(isLiteral == true)
		{
			cmp.GetStatements.Add (new CodeMethodReturnStatement (new CodeSnippetExpression(propValue.ToString())));
		}
		else
		{
			cmp.GetStatements.Add (new CodeMethodReturnStatement (new CodePrimitiveExpression(propValue)));
		}
		cc.Members.Add (cmp);
	}

	public void GeneratePublicProperty(string propName,string propType, CodeExpression Value,bool isBrowsable)
	{
		cmp = new CodeMemberProperty();
		cmp.Name = propName;
		cmp.Attributes = MemberAttributes.Public | MemberAttributes.Final;
		cmp.Type = new CodeTypeReference(propType);

		caa = new CodeAttributeArgument();
		caa.Value = new CodePrimitiveExpression(isBrowsable);
		cad = new CodeAttributeDeclaration();
		cad.Name = "Browsable";
		cad.Arguments.Add(caa);
		cmp.CustomAttributes = new CodeAttributeDeclarationCollection();
		cmp.CustomAttributes.Add(cad);

		cmp.GetStatements.Add(new CodeMethodReturnStatement(Value));

		cmp.SetStatements.Add(new CodeAssignStatement(Value,
														new CodeSnippetExpression("value")));
		cc.Members.Add(cmp);
	}

	void GeneratePathProperty()
	{
		cmp = new CodeMemberProperty();
		cmp.Name = PublicNamesUsed["PathProperty"].ToString();
		cmp.Attributes = MemberAttributes.Public | MemberAttributes.Final;
		cmp.Type = new CodeTypeReference(PublicNamesUsed["PathClass"].ToString());

		caa = new CodeAttributeArgument();
		caa.Value = new CodePrimitiveExpression(true);
		cad = new CodeAttributeDeclaration();
		cad.Name = "Browsable";
		cad.Arguments.Add(caa);
		cmp.CustomAttributes = new CodeAttributeDeclarationCollection();
		cmp.CustomAttributes.Add(cad);

		cpre = new CodePropertyReferenceExpression(new CodeSnippetExpression(
														PrivateNamesUsed["LateBoundObject"].ToString()),
														"Path");

		cmp.GetStatements.Add(new CodeMethodReturnStatement(cpre));

		cis = new CodeConditionStatement();

		CodeExpression[] parms = new CodeExpression[]
			{
				new CodePropertyReferenceExpression(new CodeSnippetExpression("value"),"ClassName"),
				new CodeSnippetExpression(PublicNamesUsed["ClassNameProperty"].ToString()),
				new CodePrimitiveExpression(true)
			};

		cmie = new CodeMethodInvokeExpression(
						new CodeSnippetExpression("String"),
						"Compare",
						parms
						);

		cboe = new CodeBinaryOperatorExpression();
		cboe.Left = cmie;
		cboe.Right = new CodePrimitiveExpression(0);
		cboe.Operator = CodeBinaryOperatorType.IdentityInequality;
		cis.Condition = cboe;
		coce = new CodeObjectCreateExpression();
		coce.CreateType = new CodeTypeReference(PublicNamesUsed["ArgumentExceptionClass"].ToString());
		coce.Parameters.Add(new CodePrimitiveExpression(ExceptionString));
		cis.TrueStatements.Add(new CodeThrowExceptionStatement(coce));
		cmp.SetStatements.Add(cis);	
	
		cmp.SetStatements.Add(new CodeAssignStatement(cpre,
														new CodeSnippetExpression("value")));
		cc.Members.Add(cmp);
	}

/// <summary>
/// Function for generating the helper class "ManagementSystemProperties" which is 
/// used for seperating the system properties from the other properties. This is used 
/// just to make the drop down list in the editor to look good.
/// </summary>
	public void GenerateSystemPropertiesClass()
	{
		CodeTypeDeclaration SysPropsClass = new CodeTypeDeclaration(PublicNamesUsed["SystemPropertiesClass"].ToString());

		//First create the constructor
		//	public ManagementSystemProperties(ManagementObject obj)

		cctor = new CodeConstructor();		
		cctor.Attributes = MemberAttributes.Public;
		cpde = new CodeParameterDeclarationExpression();
		cpde.Type = new CodeTypeReference(PublicNamesUsed["LateBoundClass"].ToString());
		cpde.Name = "ManagedObject";
		cctor.Parameters.Add(cpde);
		cctor.Statements.Add(new CodeAssignStatement(new CodeSnippetExpression(PrivateNamesUsed["LateBoundObject"].ToString()),new CodeSnippetExpression("ManagedObject")));
		SysPropsClass.Members.Add(cctor);

		char [] strPropTemp;
		char [] strPropName;
		int i = 0;

		foreach (Property prop in classobj.SystemProperties)
		{
			cmp = new CodeMemberProperty ();
			//All properties are browsable by default.
			caa = new CodeAttributeArgument();
			caa.Value = new CodePrimitiveExpression(true);
			cad = new CodeAttributeDeclaration();
			cad.Name = "Browsable";
			cad.Arguments.Add(caa);
			cmp.CustomAttributes = new CodeAttributeDeclarationCollection();
			cmp.CustomAttributes.Add(cad);

			//Now we will have to find the occurance of the first character and trim all the characters before that
			strPropTemp = prop.Name.ToCharArray();
			for(i=0;i < strPropTemp.Length;i++)
			{
				if(Char.IsLetterOrDigit(strPropTemp[i]) == true)
				{
					break;
				}
			}
			if(i == strPropTemp.Length)
			{
				i = 0;
			}
			strPropName = new char[strPropTemp.Length - i];
			for(int j=i;j < strPropTemp.Length;j++)
			{
				strPropName[j - i] = strPropTemp[j];
			}
                        			
			cmp.Name = (new string(strPropName)).ToUpper(); //ConvertToTitleCase(new string(strPropName));
			cmp.Attributes = MemberAttributes.Public | MemberAttributes.Final;
			cmp.Type = new CodeTypeReference(ManagementClassGenerator.ConvertCIMType(prop.Type,prop.IsArray,OutputLanguage));

			cie = new CodeIndexerExpression(
				new CodeSnippetExpression(PrivateNamesUsed["LateBoundObject"].ToString()),
				new CodeExpression[] {new CodePrimitiveExpression(prop.Name)});

			cmp.GetStatements.Add (new CodeMethodReturnStatement (new CodeCastExpression(cmp.Type,cie)));
			SysPropsClass.Members.Add(cmp);
		}
		//private WmiObject _privObject
		cf = new CodeMemberField();
		cf.Name = PrivateNamesUsed["LateBoundObject"].ToString();
		cf.Attributes = MemberAttributes.Private | MemberAttributes.Final ;
		cf.Type = new CodeTypeReference(PublicNamesUsed["LateBoundClass"].ToString());
		SysPropsClass.Members.Add(cf);

        cc.Members.Add(SysPropsClass);

	}
/// <summary>
/// This function will enumerate all the properties (except systemproperties)
/// of the WMI class and will generate them as properties of the managed code
/// wrapper class.
/// </summary>
	void GenerateProperties()
	{
		bool bRead;
		bool bWrite;
		bool bStatic;

		for(int i=0;i< PublicProperties.Count;i++)
		{
			Property prop = classobj.Properties[PublicProperties.GetKey(i).ToString()];
			bRead = true;		//All properties are readable by default
			bWrite = true;		//All properties are writeable by default
			bStatic = false;	//By default all properties are non static

			cmp = new CodeMemberProperty ();
			cmp.Name = PublicProperties[prop.Name].ToString();
			cmp.Attributes = MemberAttributes.Public | MemberAttributes.Final;
			cmp.Type = new CodeTypeReference(ManagementClassGenerator.ConvertCIMType(prop.Type,prop.IsArray,OutputLanguage));

			//All properties are browsable, by default
			caa = new CodeAttributeArgument();
			caa.Value = new CodePrimitiveExpression(true);
			cad = new CodeAttributeDeclaration();
			cad.Name = "Browsable";
			cad.Arguments.Add(caa);
			cmp.CustomAttributes = new CodeAttributeDeclarationCollection();
			cmp.CustomAttributes.Add(cad);

			cie = new CodeIndexerExpression(
				new CodeSnippetExpression(PrivateNamesUsed["LateBoundObject"].ToString()),
				new CodeExpression[] {new CodePrimitiveExpression(prop.Name)});
			
			ProcessPropertyQualifiers(prop,ref bRead,ref bWrite,ref bStatic);

			//BUGBUG: WMI Values qualifier values cannot be used as
			//enumerator constants: they contain spaces, dots, dashes, etc.
			//These need to be modified, otherwise the generated file won't compile.
			//Uncomment the line below when that is fixed.
			//GeneratePropertyHelperEnums(prop,PublicProperties[prop.Name].ToString());

			if(bRead == true)
			{
				cmp.GetStatements.Add (new CodeMethodReturnStatement (new CodeCastExpression(cmp.Type,cie)));
			}

			if(bWrite == true)
			{
	            cmp.SetStatements.Add(new CodeAssignStatement(cie,new CodeSnippetExpression("value"))); 
				cmie = new CodeMethodInvokeExpression();
				cmie.Method.TargetObject = new CodeSnippetExpression(PrivateNamesUsed["LateBoundObject"].ToString());
				cmie.Method.MethodName = "Put";

				cmp.SetStatements.Add(new CodeExpressionStatement(cmie));
			}
			cc.Members.Add (cmp);
		}
	}
/// <summary>
/// This function will process the qualifiers for a given WMI property and set the 
/// attributes of the generated property accordingly.
/// </summary>
	void ProcessPropertyQualifiers(Property prop,ref bool bRead, ref bool bWrite, ref bool bStatic)
	{
		foreach (Qualifier q in prop.Qualifiers)
		{
			if(String.Compare(q.Name,"key",true) == 0)
			{
				//This is a key. So push it in to the key array
				arrKeyType.Add(cmp.Type);
				arrKeys.Add(prop.Name);
				break;
			}
			else if(string.Compare(q.Name,"static",true) == 0)
			{
				//This property is static. So add static to the Type of the object
				bStatic = true;
				cmp.Attributes |= MemberAttributes.Static;
			}
			else if(string.Compare(q.Name,"read",true) == 0)
			{
				if((bool)q.Value == false)
				{
					bRead = false;
				}
				else
				{
					bRead = true;
				}
			}
			else if(string.Compare(q.Name,"write",true) == 0)
			{
				if((bool)q.Value == true)
				{
					bWrite = true;
				}
				else
				{
					bWrite = false;
				}
			}
			// check for ValueMap/Values and BitMap/BitValues pair and create
			// Enum Accordingly
			else if(string.Compare(q.Name,"ValueMap",true) == 0)
			{
				ValueMap.Clear();
				//Now check whether the type of the property is int
				if(isTypeInt(prop.Type) == true)
				{
					string [] strArray = (string [])q.Value;
					for(int i=0;i < strArray.Length;i++)
					{
						ValueMap.Add(Convert.ToInt32(strArray[i]));
					}
				}
			}
			else if(string.Compare(q.Name,"Values",true) == 0)
			{
				Values.Clear();
				if(isTypeInt(prop.Type) == true)
				{
					string [] strArray = (string [])q.Value;
					for(int i=0;i < strArray.Length;i++)
					{
						Values.Add(strArray[i]);
					}
				}
			}
			else if(string.Compare(q.Name,"BitMap",true) == 0)
			{
				BitMap.Clear();
				if(isTypeInt(prop.Type) == true)
				{
					string [] strArray = (string [])q.Value;
					for(int i=0;i < strArray.Length;i++)
					{
						BitMap.Add(Convert.ToInt32(strArray[i]));
					}
				}
			}
			else if(string.Compare(q.Name,"BitValues",true) == 0)
			{
				BitValues.Clear();
				if(isTypeInt(prop.Type) == true)
				{
					string [] strArray = (string [])q.Value;
					for(int i=0;i < strArray.Length;i++)
					{
						BitValues.Add(strArray[i]);
					}
				}
			}
		}
	}
/// <summary>
/// This function will generate enums corresponding to the Values/Valuemap pair
/// and for the BitValues/Bitmap pair.
/// </summary>
void GeneratePropertyHelperEnums(Property prop,string strPropertyName)
{
	//Only if the property is of type int and there is atleast values qualifier on it
	//then we will generate an enum for the values/valuemap(if available)
	//Here we don't have to check explicitly for type of the property as the size of 
	//values array will be zero if the type is not int.
	string strEnum = ResolveCollision(strPropertyName+"Values",true);

	if(Values.Count > 0)
	{
		//Now we will have to create an enum.
		EnumObj = new CodeTypeDeclaration(strEnum);
	    cc.Members.Add(EnumObj);

		//Now convert the type to the generated enum type
		cmp.Type = new CodeTypeReference(strEnum);

		EnumObj.IsEnum = true;
		EnumObj.TypeAttributes = TypeAttributes.Public; // | TypeAttributes.ValueType | TypeAttributes.Enum;
		for(int i=0; i < Values.Count;i++)
		{
			cmf = new CodeMemberField ();
			cmf.Name = Values[i].ToString();
			if(ValueMap.Count > 0)
			{
				cmf.InitExpression = new CodePrimitiveExpression(ValueMap[i]);
			}
			EnumObj.Members.Add(cmf);
		}
		//Now clear the Values & ValueMap Array
		Values.Clear();
		ValueMap.Clear();
	}
	//Only if the property is of type int and there is atleast values qualifier on it
	//then we will generate an enum for the values/valuemap(if available)
	//Here we don't have to check explicitly for type of the property as the size of 
	//values array will be zero if the type is not int.
	if(BitValues.Count > 0)
	{
		//Now we will create the enum
		EnumObj = new CodeTypeDeclaration(strEnum);
	    cc.Members.Add(EnumObj);

		//Now convert the type to the generated enum type
		cmp.Type = new CodeTypeReference(strEnum);

		EnumObj.IsEnum = true;
		EnumObj.TypeAttributes = TypeAttributes.Public; // | TypeAttributes.ValueType | TypeAttributes.Enum;
		Int32 bitValue = 1;
		for(int i=0; i < BitValues.Count;i++)
		{
			cmf = new CodeMemberField ();
			cmf.Name = BitValues[i].ToString();
			if(ValueMap.Count > 0)
			{
				cmf.InitExpression = new CodePrimitiveExpression(BitMap[i]);
			}
			else
			{
				cmf.InitExpression = new CodePrimitiveExpression(bitValue);
				//Now shift 1 more bit so that we can put it for the next element in the enum
				bitValue = bitValue << 1;
			}
			EnumObj.Members.Add(cmf);
		}

		//Now clear the Bitmap and BitValues Array
		BitValues.Clear();
		BitMap.Clear();
	}
}
/// <summary>
/// This function generated the static function which s used to construct the path
/// 	private static String ConstructPath(String keyName)
///		{
///			//FOR NON SINGLETON CLASSES
///			String strPath;
///		    strPath = ((("\\<defNamespace>:<defClassName>";
///		    strPath = ((_strPath) + (((".Key1=") + (key_Key1))));
///		    strPath = ((_strPath) + (((",Key2=") + ((("\"") + (((key_Key2) + ("\""))))))));
///			return strPath;
///			
///			//FOR SINGLETON CLASS
///			return "\\<defNameSpace>:<defClassName>=@";
///		}
/// </summary>
	void GenerateConstructPath()
	{
		cmm = new CodeMemberMethod();
        cmm.Name = PublicNamesUsed["ConstructPathFunction"].ToString();
		cmm.Attributes = MemberAttributes.Private | MemberAttributes.Static | MemberAttributes.Final;
		cmm.ReturnType = new CodeTypeReference("string");

		for(int i=0; i < arrKeys.Count;i++)
		{
			cmm.Parameters.Add(new CodeParameterDeclarationExpression(arrKeyType[i].ToString(),
																		"key"+arrKeys[i].ToString()));
		}

		string strPath = "\\" + OriginalNamespace + ":" + OriginalClassName;
		if(bSingletonClass == true)
		{
			strPath = strPath + "=@";
			cmm.Statements.Add(new CodeMethodReturnStatement(new CodePrimitiveExpression(strPath)));
		}
		else
		{
			string strPathObject = "strPath";
			//Declare the String strPath;
			cmm.Statements.Add(new CodeVariableDeclarationStatement("String",strPathObject,new CodePrimitiveExpression(strPath)));

			for(int i=0; i < arrKeys.Count;i++)
			{
				if(arrKeyType[i] == "String")
				{
					cboe = new CodeBinaryOperatorExpression(new CodeSnippetExpression("key"+arrKeys[i]),
															CodeBinaryOperatorType.Add,
															new CodePrimitiveExpression("\""));

					cboe = new CodeBinaryOperatorExpression(new CodePrimitiveExpression("\""),
															CodeBinaryOperatorType.Add,
															cboe);

					cboe = new CodeBinaryOperatorExpression(new CodePrimitiveExpression(
														((i==0)?("."+arrKeys[i]+"="):(","+arrKeys[i]+"="))),
														CodeBinaryOperatorType.Add,
														cboe);
					cboe = new CodeBinaryOperatorExpression(new CodeSnippetExpression(strPathObject),
															CodeBinaryOperatorType.Add,
															cboe);
				}
				else
				{
					cboe = new CodeBinaryOperatorExpression(new CodePrimitiveExpression(
														((i==0)?("."+arrKeys[i]+"="):(","+arrKeys[i]+"="))),
															CodeBinaryOperatorType.Add,
															new CodeSnippetExpression("key"+arrKeys[i]));
					cboe = new CodeBinaryOperatorExpression(new CodeSnippetExpression(strPathObject),
															CodeBinaryOperatorType.Add,
															cboe);
				}
				cmm.Statements.Add(new CodeAssignStatement(new CodeSnippetExpression(strPathObject),cboe));
			}
			cmm.Statements.Add(new CodeMethodReturnStatement(new CodeSnippetExpression(strPathObject)));
		}
		cc.Members.Add(cmm);
	}
/// <summary>
/// This function generates the default constructor.
/// public Cons() {
///		_privObject = new ManagementObject();
///     _privSystemProps = new ManagementSystemProperties(_privObject);
/// }
/// </summary>
	void GenerateDefaultConstructor()
	{
		cctor = new CodeConstructor();
		cctor.Attributes = MemberAttributes.Public;

		cctor.ChainedConstructorArgs.Add(new CodePrimitiveExpression(null));
		//If it is a singleton class, then we will make the default constructor to point to the
		//only object available
		if(bSingletonClass == true)
		{
			cmie = new CodeMethodInvokeExpression();
			cmie.Method.TargetObject = new CodeSnippetExpression(PrivateNamesUsed["GeneratedClassName"].ToString());
			cmie.Method.MethodName = PublicNamesUsed["ConstructPathFunction"].ToString();
					

			cctor.ChainedConstructorArgs.Add(cmie);
		}
		else
		{
			cctor.ChainedConstructorArgs.Add(new CodePrimitiveExpression(null));
		}
		cctor.ChainedConstructorArgs.Add(new CodePrimitiveExpression(null));
		cc.Members.Add(cctor);
	}
/// <summary>
///This function create the constuctor which accepts the key values.
///public cons(UInt32 key_Key1, String key_Key2) :this(null,<ClassName>.ConstructPath(<key1,key2>),null) {
/// }
///</summary>
	void GenerateConstructorWithKeys()
	{
		if(arrKeyType.Count > 0)
		{
			cctor = new CodeConstructor();		
			cctor.Attributes = MemberAttributes.Public;
			for(int i=0; i < arrKeys.Count;i++)
			{
				cpde = new CodeParameterDeclarationExpression();
				cpde.Type = new CodeTypeReference(arrKeyType[i].ToString());
				cpde.Name = "key"+arrKeys[i].ToString();
				cctor.Parameters.Add(cpde);
			}

			cctor.ChainedConstructorArgs.Add(new CodePrimitiveExpression(null));

			cmie = new CodeMethodInvokeExpression();
			cmie.Method.TargetObject = new CodeSnippetExpression(PrivateNamesUsed["GeneratedClassName"].ToString());
			cmie.Method.MethodName = PublicNamesUsed["ConstructPathFunction"].ToString(); 

			for(int i=0; i < arrKeys.Count;i++)
			{
				cmie.Parameters.Add(new CodeSnippetExpression("key"+arrKeys[i]));
			}

			coce = new CodeObjectCreateExpression();
			coce.CreateType = new CodeTypeReference(PublicNamesUsed["PathClass"].ToString());
			coce.Parameters.Add(cmie);
			cctor.ChainedConstructorArgs.Add(coce);
			cctor.ChainedConstructorArgs.Add(new CodePrimitiveExpression(null));
			cc.Members.Add(cctor);
		}		
	}

/// <summary>
///This function create the constuctor which accepts a scope and key values.
///public cons(ManagementScope scope,UInt32 key_Key1, String key_Key2) :this(scope,<ClassName>.ConstructPath(<key1,key2>),null) {
/// }
///</summary>
	void GenerateConstructorWithScopeKeys()
	{
		cctor = new CodeConstructor();		
		cctor.Attributes = MemberAttributes.Public;
		string strScopeObject = "scope";
		cctor.Parameters.Add(new CodeParameterDeclarationExpression(PublicNamesUsed["ScopeClass"].ToString(),strScopeObject));

		if(arrKeyType.Count > 0)
		{
			for(int i=0; i < arrKeys.Count;i++)
			{
				cpde = new CodeParameterDeclarationExpression();
				cpde.Type = new CodeTypeReference(arrKeyType[i].ToString());
				cpde.Name = "key"+arrKeys[i].ToString();
				cctor.Parameters.Add(cpde);
			}

			cctor.ChainedConstructorArgs.Add(new CodeSnippetExpression(strScopeObject));

			cmie = new CodeMethodInvokeExpression();
			cmie.Method.TargetObject = new CodeSnippetExpression(PrivateNamesUsed["GeneratedClassName"].ToString());
			cmie.Method.MethodName = PublicNamesUsed["ConstructPathFunction"].ToString();				

			for(int i=0; i < arrKeys.Count;i++)
			{
				cmie.Parameters.Add(new CodeSnippetExpression("key"+arrKeys[i]));
			}

			coce = new CodeObjectCreateExpression();
			coce.CreateType = new CodeTypeReference(PublicNamesUsed["PathClass"].ToString());
			coce.Parameters.Add(cmie);
			cctor.ChainedConstructorArgs.Add(coce);
			cctor.ChainedConstructorArgs.Add(new CodePrimitiveExpression(null));
			cc.Members.Add(cctor);
		}		
	}


	/// <summary>
	/// This function generates code for the constructor which accepts ManagementPath as the parameter.
	/// The generated code will look something like this
	///		public Cons(ManagementPath path) : this (null, path,null){
	///		}
	/// </summary>
	void GenerateConstructorWithPath()
	{
		string strPathObject = "path";
		cctor = new CodeConstructor();		
		cctor.Attributes = MemberAttributes.Public;
		cpde = new CodeParameterDeclarationExpression();
		cpde.Type = new CodeTypeReference(PublicNamesUsed["PathClass"].ToString());
		cpde.Name = strPathObject;
		cctor.Parameters.Add(cpde);

		cctor.ChainedConstructorArgs.Add(new CodePrimitiveExpression(null));
		cctor.ChainedConstructorArgs.Add(new CodeSnippetExpression(strPathObject));
		cctor.ChainedConstructorArgs.Add(new CodePrimitiveExpression(null));
		cc.Members.Add(cctor);
	}
	/// <summary>
	/// This function generates code for the constructor which accepts ManagementPath and GetOptions
	/// as parameters.
	/// The generated code will look something like this
	///		public Cons(ManagementPath path, ObjectGetOptions options) : this (null, path,options){
	///		}
	/// </summary>
	void GenerateConstructorWithPathOptions()
	{
		string strPathObject = "path";
		string strGetOptions = "getOptions";

		cctor = new CodeConstructor();		
		cctor.Attributes = MemberAttributes.Public;
		cctor.Parameters.Add(new CodeParameterDeclarationExpression(PublicNamesUsed["PathClass"].ToString(),
																	strPathObject));
		cctor.Parameters.Add(new CodeParameterDeclarationExpression(PublicNamesUsed["GetOptionsClass"].ToString(),
																	strGetOptions));

		cctor.ChainedConstructorArgs.Add(new CodePrimitiveExpression(null));
		cctor.ChainedConstructorArgs.Add(new CodeSnippetExpression(strPathObject));
		cctor.ChainedConstructorArgs.Add(new CodeSnippetExpression(strGetOptions));
		cc.Members.Add(cctor);
	}
	/// <summary>
	/// This function generates code for the constructor which accepts Scope as a string, path as a 
	/// string and GetOptions().
	/// The generated code will look something like this
	///		public Cons(String scope, String path, ObjectGetOptions options) : 
	///							this (new ManagementScope(scope), new ManagementPath(path),options){
	///		}
	/// </summary>
	void GenerateConstructorWithScopePath()
	{
		string strScopeObject = "scope";
		string strPathObject = "path";

		cctor = new CodeConstructor();		
		cctor.Attributes = MemberAttributes.Public;
		cctor.Parameters.Add(new CodeParameterDeclarationExpression(PublicNamesUsed["ScopeClass"].ToString(),strScopeObject));
		cctor.Parameters.Add(new CodeParameterDeclarationExpression(PublicNamesUsed["PathClass"].ToString(),strPathObject));
		cctor.ChainedConstructorArgs.Add(new CodeSnippetExpression(strScopeObject));
		cctor.ChainedConstructorArgs.Add(new CodeSnippetExpression(strPathObject));
		cctor.ChainedConstructorArgs.Add(new CodePrimitiveExpression(null));
		cc.Members.Add(cctor);
	}
	/// <summary>
	/// This function generates code for the constructor which accepts ManagementScope as parameters.
	/// The generated code will look something like this
	///		public Cons(ManagementScope scope, ObjectGetOptions options) : this (scope, <ClassName>.ConstructPath(),null){
	///		}
	/// </summary>
	void GenerateConstructorWithScope()
	{
		string strScopeObject = "scope";

		cctor = new CodeConstructor();		
		cctor.Attributes = MemberAttributes.Public;
		cctor.Parameters.Add(new CodeParameterDeclarationExpression(PublicNamesUsed["ScopeClass"].ToString(),
																	strScopeObject));
		cctor.ChainedConstructorArgs.Add(new CodeSnippetExpression(strScopeObject));
		cmie = new CodeMethodInvokeExpression();
		cmie.Method.TargetObject =new CodeSnippetExpression(PrivateNamesUsed["GeneratedClassName"].ToString());
		cmie.Method.MethodName = PublicNamesUsed["ConstructPathFunction"].ToString();					
					

		cctor.ChainedConstructorArgs.Add(cmie);
		cctor.ChainedConstructorArgs.Add(new CodePrimitiveExpression(null));
		cc.Members.Add(cctor);
	}

	/// <summary>
	/// This function generates code for the constructor which accepts GetOptions
	/// as parameters.
	/// The generated code will look something like this
	///		public Cons(ObjectGetOptions options) : this (null, <ClassName>.ConstructPath(),options){
	///		}
	/// </summary>
	void GenerateConstructorWithOptions()
	{
		string strGetOptions = "getOptions";

		cctor = new CodeConstructor();		
		cctor.Attributes = MemberAttributes.Public;
		cctor.Parameters.Add(new CodeParameterDeclarationExpression(PublicNamesUsed["GetOptionsClass"].ToString(),
																	strGetOptions));

		cctor.ChainedConstructorArgs.Add(new CodePrimitiveExpression(null));
		cmie = new CodeMethodInvokeExpression();
		cmie.Method.TargetObject = new CodeSnippetExpression(PrivateNamesUsed["GeneratedClassName"].ToString());
		cmie.Method.MethodName = PublicNamesUsed["ConstructPathFunction"].ToString();
				
		cctor.ChainedConstructorArgs.Add(cmie);
		cctor.ChainedConstructorArgs.Add(new CodeSnippetExpression(strGetOptions));
		cc.Members.Add(cctor);
	}

	/// <summary>
	/// This function generates code for the constructor which accepts ManagementScope and GetOptions
	/// as parameters.
	/// The generated code will look something like this
	///		public Cons(ManagementScope scope, ObjectGetOptions options) : this (scope, <ClassName>.ConstructPath(),options){
	///		}
	/// </summary>
	void GenerateConstructorWithScopeOptions()
	{
		string strScopeObject = "scope";
		string strGetOptions = "getOptions";

		cctor = new CodeConstructor();		
		cctor.Attributes = MemberAttributes.Public;
		cctor.Parameters.Add(new CodeParameterDeclarationExpression(PublicNamesUsed["ScopeClass"].ToString(),
																	strScopeObject));
		cctor.Parameters.Add(new CodeParameterDeclarationExpression(PublicNamesUsed["GetOptionsClass"].ToString(),
																	strGetOptions));

		cctor.ChainedConstructorArgs.Add(new CodeSnippetExpression(strScopeObject));
		cmie = new CodeMethodInvokeExpression();
		cmie.Method.TargetObject = new CodeSnippetExpression(PrivateNamesUsed["GeneratedClassName"].ToString());
		cmie.Method.MethodName = PublicNamesUsed["ConstructPathFunction"].ToString();				

		cctor.ChainedConstructorArgs.Add(cmie);
		cctor.ChainedConstructorArgs.Add(new CodeSnippetExpression(strGetOptions));
		cc.Members.Add(cctor);
	}


	/// <summary>
	/// This function generated the constructor like
	///		public cons(ManagementScope scope, ManagamentPath path,ObjectGetOptions getOptions)
	///		{
	///			PrivateObject = new ManagementObject(scope,path,getOptions);
	///			PrivateSystemProperties = new ManagementSystemProperties(PrivateObject);
	///		}
	/// </summary>
	void GenerateConstructorWithScopePathOptions()
	{
		string strScopeObject = "scope";
		string strPathObject = "path";
		string strGetOptions = "getOptions";

		cctor = new CodeConstructor();		
		cctor.Attributes = MemberAttributes.Public;
		cctor.Parameters.Add(new CodeParameterDeclarationExpression(PublicNamesUsed["ScopeClass"].ToString(),strScopeObject));
		cctor.Parameters.Add(new CodeParameterDeclarationExpression(PublicNamesUsed["PathClass"].ToString(),strPathObject));
		cctor.Parameters.Add(new CodeParameterDeclarationExpression(PublicNamesUsed["GetOptionsClass"].ToString(),strGetOptions));

		//First if path is not null, then we will check whether the class name is the same.
		//if it is not the same, then we will throw an exception
		cis = new CodeConditionStatement();
		cis.Condition = new CodeBinaryOperatorExpression(new CodeSnippetExpression(strPathObject),
															CodeBinaryOperatorType.IdentityInequality,
															new CodePrimitiveExpression(null));
		CodeConditionStatement cis1 = new CodeConditionStatement();

		cmie = new CodeMethodInvokeExpression();
		cmie.Method.TargetObject = new CodeSnippetExpression("String");
		cmie.Method.MethodName = "Compare";
						

		cmie.Parameters.Add(new CodePropertyReferenceExpression(new CodeSnippetExpression(strPathObject),"ClassName"));
		cmie.Parameters.Add(new CodeSnippetExpression(PublicNamesUsed["ClassNameProperty"].ToString()));
		cmie.Parameters.Add(new CodePrimitiveExpression(true));
		cboe = new CodeBinaryOperatorExpression();
		cboe.Left = cmie;
		cboe.Right = new CodePrimitiveExpression(0);
		cboe.Operator = CodeBinaryOperatorType.IdentityInequality;
		cis1.Condition = cboe;
		coce = new CodeObjectCreateExpression();
		coce.CreateType = new CodeTypeReference(PublicNamesUsed["ArgumentExceptionClass"].ToString());
		coce.Parameters.Add(new CodePrimitiveExpression(ExceptionString));
		cis1.TrueStatements.Add(new CodeThrowExceptionStatement(coce));

		cis.TrueStatements.Add(cis1);
		cctor.Statements.Add(cis);

		coce = new CodeObjectCreateExpression();
		coce.CreateType = new CodeTypeReference(PublicNamesUsed["LateBoundClass"].ToString());
		coce.Parameters.Add(new CodeSnippetExpression(strScopeObject));
		coce.Parameters.Add(new CodeSnippetExpression(strPathObject));
		coce.Parameters.Add(new CodeSnippetExpression(strGetOptions));
		cctor.Statements.Add(new CodeAssignStatement(new CodeSnippetExpression(
																	PrivateNamesUsed["LateBoundObject"].ToString()),
													  coce));
		coce = new CodeObjectCreateExpression();
		coce.CreateType = new CodeTypeReference(PublicNamesUsed["SystemPropertiesClass"].ToString());
		cle = new CodeSnippetExpression(PrivateNamesUsed["LateBoundObject"].ToString());
		coce.Parameters.Add(cle);
		cctor.Statements.Add(new CodeAssignStatement(new CodeSnippetExpression(
																	PrivateNamesUsed["SystemPropertiesObject"].ToString()),
													  coce));
		cc.Members.Add(cctor);
		
	}
	/// <summary>
	/// This function generates code for the constructor which accepts ManagementObject as the parameter.
	/// The generated code will look something like this
	///		public Cons(ManagementObject theObject) {
	///		if(String.Compare(theObject.SystemProperties["__CLASS"].Value.ToString(),ClassName,true) == 0) {
	///				privObject = theObject;
	///				privSystemProps = new WmiSystemProps(privObject);
	///			}
	///			else {
	///				throw new ArgumentException("Class name doesn't match");
	///			}
	///		}
	/// </summary>
	void GenarateConstructorWithLateBound()
	{
		string strLateBoundObject = "theObject";
		string LateBoundSystemProperties = "SystemProperties";

		cctor = new CodeConstructor();		
		cctor.Attributes = MemberAttributes.Public;
		cpde = new CodeParameterDeclarationExpression();
		cpde.Type = new CodeTypeReference(PublicNamesUsed["LateBoundClass"].ToString());
		cpde.Name = strLateBoundObject;
		cctor.Parameters.Add(cpde);

		cis = new CodeConditionStatement();
        cpre = new CodePropertyReferenceExpression(new CodeSnippetExpression(strLateBoundObject),LateBoundSystemProperties);
		cie = new CodeIndexerExpression(cpre,new CodePrimitiveExpression("__CLASS"));
        cpre = new CodePropertyReferenceExpression(cie,"Value");
        cmie = new CodeMethodInvokeExpression();
		cmie.Method.TargetObject = new CodeSnippetExpression("String");
		cmie.Method.MethodName = "Compare";
					
		cmie.Parameters.Add(new CodeMethodInvokeExpression(cpre,"ToString"));
		cmie.Parameters.Add(new CodeSnippetExpression(PublicNamesUsed["ClassNameProperty"].ToString()));
		cmie.Parameters.Add(new CodePrimitiveExpression(true));
		cboe = new CodeBinaryOperatorExpression();
		cboe.Left = cmie;
		cboe.Right = new CodePrimitiveExpression(0);
		cboe.Operator = CodeBinaryOperatorType.ValueEquality;
		cis.Condition = cboe;

		cis.TrueStatements.Add(new CodeAssignStatement(
								new CodeSnippetExpression(PrivateNamesUsed["LateBoundObject"].ToString()),
								new CodeSnippetExpression(strLateBoundObject)));

		coce = new CodeObjectCreateExpression();
		coce.CreateType = new CodeTypeReference(PublicNamesUsed["SystemPropertiesClass"].ToString());
		cle = new CodeSnippetExpression(PrivateNamesUsed["LateBoundObject"].ToString());
		coce.Parameters.Add(cle);
		cis.TrueStatements.Add(new CodeAssignStatement(new CodeSnippetExpression(PrivateNamesUsed["SystemPropertiesObject"].ToString()),coce));

		coce = new CodeObjectCreateExpression();
		coce.CreateType = new CodeTypeReference(PublicNamesUsed["ArgumentExceptionClass"].ToString());
		coce.Parameters.Add(new CodePrimitiveExpression(ExceptionString));
		cis.FalseStatements.Add(new CodeThrowExceptionStatement(coce));

		cctor.Statements.Add(cis);
		cc.Members.Add(cctor);
	}
/// <summary>
/// This function generates the WMI methods as the methods in the generated class.
/// The generated code will look something like this
///		public <retType> Method1(<type> param1, <type> param2,...) {
///            ManagementBaseObject inParams = null;
///            inParams = _privObject.GetMethodParameters("ChangeStartMode");
///            inParams["<inparam1>"] = <Value>;
///            inParams["<inoutparam2>"] = <Value>;
///            ................................
///            ManagementBaseObject outParams = _privObject.InvokeMethod("ChangeStartMode", inParams, null);
///            inoutParam3 = (<type>)(outParams.Properties["<inoutParam3>"]);
///            outParam4 = (String)(outParams.Properties["<outParam4>"]);
///            ................................
///            return (<retType>)(outParams.Properties["ReturnValue"].Value);
///     }
/// </summary>
	void GenerateMethods()
	{
		string strInParams = "inParams";
		string strOutParams = "outParams";

		ArrayList outParamsName = new ArrayList(5);
		ArrayList inoutParams = new ArrayList(5);
		ArrayList inoutParamsType = new ArrayList(5);

		for(int k=0;k< PublicMethods.Count;k++)
		{
			Method meth = classobj.Methods[PublicMethods.GetKey(k).ToString()];
			if(meth.OutParameters.Properties != null)
			{
				//First Populate the out Params name so that we can find in/out parameters
				foreach (Property prop in meth.OutParameters.Properties)
				{
					outParamsName.Add(prop.Name);
				}
			}

			cmm = new CodeMemberMethod();
			cmm.Attributes = MemberAttributes.Public | MemberAttributes.Final;
			cmm.Name = PublicMethods[meth.Name].ToString();			

			//Check if the method is static
			foreach (Qualifier q in meth.Qualifiers)
			{
				if(string.Compare(q.Name,"static",true) == 0)
				{
					//It is a static function
					cmm.Attributes |= MemberAttributes.Static;
					break;
				}
			}

			bool bfirst = true;
			//Generate the statement 
			//	ManagementBaseObject inParams = null;
			cmm.Statements.Add(new CodeVariableDeclarationStatement("ManagementBaseObject",
											strInParams,new CodePrimitiveExpression(null)));

			//Do these things only when there is a valid InParameters
			if(meth.InParameters != null)
			{
				//Now put the in parameters
				if(meth.InParameters.Properties != null)
				{
					foreach (Property prop in meth.InParameters.Properties)
					{
						if(bfirst == true)
						{
							//Now Generate the statement
							//	inParams = privObject.GetMethodParameters(<MethodName>);
							cmie = new CodeMethodInvokeExpression(
										new CodeSnippetExpression(PrivateNamesUsed["LateBoundObject"].ToString()),
										"GetMethodParameters",
										new CodePrimitiveExpression(meth.Name));
							//cmie.MethodName = "GetMethodParameters";
							//cmie.TargetObject = new CodeSnippetExpression(PrivateNamesUsed["LateBoundObject"].ToString());
							//cmie.Parameters.Add(new CodePrimitiveExpression(meth.Name));
							cmm.Statements.Add(new CodeAssignStatement(new CodeSnippetExpression(strInParams),cmie));
							bfirst = false;
						}

						cpde = new CodeParameterDeclarationExpression();
						cpde.Name = prop.Name;
						cpde.Type = new CodeTypeReference(ManagementClassGenerator.ConvertCIMType(prop.Type,prop.IsArray,OutputLanguage));
						cpde.Direction = FieldDirection.In;
						//Find out whether it is a in/out Parameter
						for(int i=0; i < outParamsName.Count;i++)
						{
							if(string.Compare(prop.Name,outParamsName[i].ToString(),true) == 0)
							{
								//It is an in/out Parameter
								cpde.Direction = FieldDirection.Ref;
								inoutParams.Add(prop.Name);
								inoutParamsType.Add(cpde.Type);
							}
						}
						
						cmm.Parameters.Add(cpde);
						//Also generate the statement
						//inParams["PropName"] = Value;
						cie = new CodeIndexerExpression(new CodeSnippetExpression(strInParams),new CodePrimitiveExpression(prop.Name));
						
						cmm.Statements.Add(new CodeAssignStatement(cie,new CodeSnippetExpression(cpde.Name)));
					}
				}
			}
			//Now clear the outParamsName array
			outParamsName.Clear();
			bool bInOut;
			bool bRetVal = false;
			bfirst = true;
			bool bInvoke = false;
			//Do these only when the outParams is Valid
			if(meth.OutParameters != null)
			{
				if(meth.OutParameters.Properties != null)
				{
					foreach (Property prop in meth.OutParameters.Properties)
					{
						if(bfirst == true)
						{
							//Now generate the statement
							//	ManagementBaseObject outParams = privObject.InvokeMethod(<methodName>,inParams,options);
							cmie = new CodeMethodInvokeExpression(
										new CodeSnippetExpression(PrivateNamesUsed["LateBoundObject"].ToString()),
										"InvokeMethod");

							cmie.Parameters.Add(new CodePrimitiveExpression(meth.Name));
							cmie.Parameters.Add(new CodeSnippetExpression(strInParams));
							cmie.Parameters.Add(new CodePrimitiveExpression(null));
							cmm.Statements.Add(new CodeVariableDeclarationStatement("ManagementBaseObject",strOutParams,cmie));
							bfirst = false;
							bInvoke = true;
						}

						bInOut = false;
						for(int i=0; i < inoutParams.Count;i++)
						{
							if(string.Compare(prop.Name,inoutParams[i].ToString(),true) == 0)
							{
								bInOut = true;
							}
						}
						if(bInOut == true)
							continue;

						if(string.Compare(prop.Name,"ReturnValue",true) == 0)
						{
							cmm.ReturnType = new CodeTypeReference(
								ManagementClassGenerator.ConvertCIMType(prop.Type,prop.IsArray,OutputLanguage));
							bRetVal = true;
						}
						else
						{
							cpde = new CodeParameterDeclarationExpression();
							cpde.Name = prop.Name;
							cpde.Type = new CodeTypeReference(ManagementClassGenerator.ConvertCIMType(prop.Type,prop.IsArray,OutputLanguage));
							cpde.Direction = FieldDirection.Out;
							cmm.Parameters.Add(cpde);

							//Now for each out params generate the statement
							//	<outParam> = outParams.Properties["<outParam>"];
							cpre = new CodePropertyReferenceExpression(new CodeSnippetExpression(strOutParams),"Properties");
							cie = new CodeIndexerExpression(cpre,new CodePrimitiveExpression(prop.Name));
							cmm.Statements.Add(new CodeAssignStatement(new CodeSnippetExpression(prop.Name),
												new CodeCastExpression(cpde.Type,cie)));
						}
					}
				}
			}

			if(bInvoke == false)
			{
				//Now there is no out parameters to invoke the function
				//So just call Invoke.
				cmie = new CodeMethodInvokeExpression(
								new CodeSnippetExpression(PrivateNamesUsed["LateBoundObject"].ToString()),
								"InvokeMethod"
								);

				cmie.Parameters.Add(new CodePrimitiveExpression(meth.Name));
				cmie.Parameters.Add(new CodeSnippetExpression(strInParams));

				cmis = new CodeExpressionStatement(cmie);
				cmm.Statements.Add(cmis);
			}

			//Now for each in/out params generate the statement
			//	<inoutParam> = outParams.Properties["<inoutParam>"];
			for(int i=0;i < inoutParams.Count;i++)
			{
				cpre = new CodePropertyReferenceExpression(new CodeSnippetExpression(strOutParams),"Properties");
				cie = new CodeIndexerExpression(cpre,new CodePrimitiveExpression(inoutParams[i].ToString()));
				cmm.Statements.Add(new CodeAssignStatement(new CodeSnippetExpression(inoutParams[i].ToString()),
									new CodeCastExpression(inoutParamsType[i].ToString(),cie)));
			}
			inoutParams.Clear();

			//Now check if there is a return value. If there is one then return it from the function
			if(bRetVal == true)
			{
				cpre = new CodePropertyReferenceExpression(new CodeSnippetExpression(strOutParams),"Properties");
				cie = new CodeIndexerExpression(cpre,new CodePrimitiveExpression("ReturnValue"));
				cmm.Statements.Add(new CodeMethodReturnStatement(new CodeCastExpression(cmm.ReturnType,
									new CodePropertyReferenceExpression(cie,"Value"))));
			}

			cc.Members.Add(cmm);
		}
	}
	/// <summary>
	/// This function returns a Collectionclass for the query 
	///		"Select * from <ClassName>"
	///	This is a static method. The output is like this
	///		public static ServiceCollection All()
	///		{
	///			return GetInstances(null,null,null);
	///		}        

	/// </summary>
	void GenerateGetInstancesWithNoParameters()
	{
		cmm = new CodeMemberMethod();
        	
		cmm.Attributes = MemberAttributes.Public | MemberAttributes.Final | MemberAttributes.Static ;
		cmm.Name = PublicNamesUsed["FilterFunction"].ToString();
		cmm.ReturnType = new CodeTypeReference(PrivateNamesUsed["CollectionClass"].ToString());

		cmie = new CodeMethodInvokeExpression();
		cmie.Method.MethodName = PublicNamesUsed["FilterFunction"].ToString();
		cmie.Parameters.Add(new CodePrimitiveExpression(null));
		cmie.Parameters.Add(new CodePrimitiveExpression(null));
		cmie.Parameters.Add(new CodePrimitiveExpression(null));
		cmm.Statements.Add(new CodeMethodReturnStatement(cmie));

		cc.Members.Add(cmm);
	}

/// <summary>
/// This function will accept the condition and will return collection for the query
///		"select * from <ClassName> where <condition>"
///	The generated code will be like
///		public static ServiceCollection GetInstances(String Condition) {
///			return GetInstances(null,Condition,null);
///     }
/// </summary>
	void GenerateGetInstancesWithCondition()
	{
		string strCondition = "condition";
		cmm = new CodeMemberMethod();
        	
		cmm.Attributes = MemberAttributes.Public | MemberAttributes.Final | MemberAttributes.Static ;
		cmm.Name = PublicNamesUsed["FilterFunction"].ToString();
		cmm.ReturnType = new CodeTypeReference(PrivateNamesUsed["CollectionClass"].ToString());
		cmm.Parameters.Add(new CodeParameterDeclarationExpression("String",strCondition));

		cmie = new CodeMethodInvokeExpression(
					null, //no TargetObject?
					PublicNamesUsed["FilterFunction"].ToString()
					);

		cmie.Parameters.Add(new CodePrimitiveExpression(null));
		cmie.Parameters.Add(new CodeSnippetExpression(strCondition));
		cmie.Parameters.Add(new CodePrimitiveExpression(null));
		cmm.Statements.Add(new CodeMethodReturnStatement(cmie));

		cc.Members.Add(cmm);
	}

	/// <summary>
	/// This function returns the collection for the query 
	///		"select <parameterList> from <ClassName>"
	///	The generated output is like
	///		public static ServiceCollection GetInstances(String []selectedProperties) {
	///			return GetInstances(null,null,selectedProperties);
    ///		}
	/// </summary>
	void GenerateGetInstancesWithProperties()
	{
		string strSelectedProperties = "selectedProperties";
		cmm = new CodeMemberMethod();
        	
		cmm.Attributes = MemberAttributes.Public | MemberAttributes.Final | MemberAttributes.Static ;
		cmm.Name = PublicNamesUsed["FilterFunction"].ToString();
		cmm.ReturnType = new CodeTypeReference(PrivateNamesUsed["CollectionClass"].ToString());
		cmm.Parameters.Add(new CodeParameterDeclarationExpression("String []",strSelectedProperties));

		cmie = new CodeMethodInvokeExpression(
						null,
						PublicNamesUsed["FilterFunction"].ToString()
						);
		//cmie.MethodName = PublicNamesUsed["FilterFunction"].ToString();
		cmie.Parameters.Add(new CodePrimitiveExpression(null));
		cmie.Parameters.Add(new CodePrimitiveExpression(null));
		cmie.Parameters.Add(new CodeSnippetExpression(strSelectedProperties));
		cmm.Statements.Add(new CodeMethodReturnStatement(cmie));

		cc.Members.Add(cmm);
	}

	/// <summary>
	/// This function returns the collection for the query 
	///		"select <parameterList> from <ClassName> where <WhereClause>"
	///	The generated output is like
	///		public static ServiceCollection GetInstances(String condition, String []selectedProperties) {
	///			return GetInstances(null,condition,selectedProperties);
    ///		}
	/// </summary>
	void GenerateGetInstancesWithWhereProperties()
	{
		string strSelectedProperties = "selectedProperties";
		string strCondition = "condition";
		cmm = new CodeMemberMethod();
        	
		cmm.Attributes = MemberAttributes.Public | MemberAttributes.Final | MemberAttributes.Static ;
		cmm.Name = PublicNamesUsed["FilterFunction"].ToString();
		cmm.ReturnType = new CodeTypeReference(PrivateNamesUsed["CollectionClass"].ToString());
		cmm.Parameters.Add(new CodeParameterDeclarationExpression("String",strCondition));
		cmm.Parameters.Add(new CodeParameterDeclarationExpression("String []",strSelectedProperties));

		cmie = new CodeMethodInvokeExpression(
						null, //no TargetObject?
						PublicNamesUsed["FilterFunction"].ToString()
						);

		cmie.Parameters.Add(new CodePrimitiveExpression(null));
		cmie.Parameters.Add(new CodeSnippetExpression(strCondition));
		cmie.Parameters.Add(new CodeSnippetExpression(strSelectedProperties));
		cmm.Statements.Add(new CodeMethodReturnStatement(cmie));

		cc.Members.Add(cmm);
	}

	/// <summary>
	/// This function returns a Collectionclass for the query 
	///		"Select * from <ClassName>"
	///	This is a static method. The output is like this
	///		public static ServiceCollection All()
	///		{
	///			return GetInstances(scope,null,null);
	///		}        
	///	This method takes the scope which is useful for connection to remote machine
	/// </summary>
	void GenerateGetInstancesWithScope()
	{
		string strScope = "scope";
		cmm = new CodeMemberMethod();
        	
		cmm.Attributes = MemberAttributes.Public | MemberAttributes.Final | MemberAttributes.Static ;
		cmm.Name = PublicNamesUsed["FilterFunction"].ToString();
		cmm.ReturnType = new CodeTypeReference(PrivateNamesUsed["CollectionClass"].ToString());
		cmm.Parameters.Add(new CodeParameterDeclarationExpression(PublicNamesUsed["ScopeClass"].ToString(),strScope));

		cmie = new CodeMethodInvokeExpression(
						null, //no TargetObject?
						PublicNamesUsed["FilterFunction"].ToString()
						);

		cmie.Parameters.Add(new CodeSnippetExpression(strScope));
		cmie.Parameters.Add(new CodePrimitiveExpression(null));
		cmie.Parameters.Add(new CodePrimitiveExpression(null));
		cmm.Statements.Add(new CodeMethodReturnStatement(cmie));

		cc.Members.Add(cmm);
	}

/// <summary>
/// This function will accept the condition and will return collection for the query
///		"select * from <ClassName> where <condition>"
///	The generated code will be like
///		public static ServiceCollection GetInstances(String Condition) {
///			return GetInstances(scope,Condition,null);
///     }
/// </summary>
	void GenerateGetInstancesWithScopeCondition()
	{
		string strScope = "scope";
		string strCondition = "condition";
		cmm = new CodeMemberMethod();
        	
		cmm.Attributes = MemberAttributes.Public | MemberAttributes.Final | MemberAttributes.Static ;
		cmm.Name = PublicNamesUsed["FilterFunction"].ToString();
		cmm.ReturnType = new CodeTypeReference(PrivateNamesUsed["CollectionClass"].ToString());
		cmm.Parameters.Add(new CodeParameterDeclarationExpression(PublicNamesUsed["ScopeClass"].ToString(),strScope));
		cmm.Parameters.Add(new CodeParameterDeclarationExpression("String",strCondition));

		cmie = new CodeMethodInvokeExpression(
					null,
					PublicNamesUsed["FilterFunction"].ToString()
					);
		//cmie.MethodName = PublicNamesUsed["FilterFunction"].ToString();
		cmie.Parameters.Add(new CodeSnippetExpression(strScope));
		cmie.Parameters.Add(new CodeSnippetExpression(strCondition));
		cmie.Parameters.Add(new CodePrimitiveExpression(null));
		cmm.Statements.Add(new CodeMethodReturnStatement(cmie));

		cc.Members.Add(cmm);
	}

	/// <summary>
	/// This function returns the collection for the query 
	///		"select <parameterList> from <ClassName>"
	///	The generated output is like
	///		public static ServiceCollection GetInstances(String []selectedProperties) {
	///			return GetInstances(scope,null,selectedProperties);
    ///		}
	/// </summary>
	void GenerateGetInstancesWithScopeProperties()
	{
		string strScope = "scope";
		string strSelectedProperties = "selectedProperties";
		cmm = new CodeMemberMethod();
        	
		cmm.Attributes = MemberAttributes.Public | MemberAttributes.Final | MemberAttributes.Static ;
		cmm.Name = PublicNamesUsed["FilterFunction"].ToString();
		cmm.ReturnType = new CodeTypeReference(PrivateNamesUsed["CollectionClass"].ToString());
		cmm.Parameters.Add(new CodeParameterDeclarationExpression(PublicNamesUsed["ScopeClass"].ToString(),strScope));
		cmm.Parameters.Add(new CodeParameterDeclarationExpression("String []",strSelectedProperties));

		cmie = new CodeMethodInvokeExpression(
					null, //no TargetObject?
					PublicNamesUsed["FilterFunction"].ToString()
					);

		cmie.Parameters.Add(new CodeSnippetExpression(strScope));
		cmie.Parameters.Add(new CodePrimitiveExpression(null));
		cmie.Parameters.Add(new CodeSnippetExpression(strSelectedProperties));
		cmm.Statements.Add(new CodeMethodReturnStatement(cmie));

		cc.Members.Add(cmm);
	}

	/// <summary>
	/// This function generates the code like 
	/// 	public static ServiceCollection GetInstances(ManagementScope scope,String Condition, String[] selectedProperties)	{
	/// 		ManagementObjectSearcher ObjectSearcher = new ManagementObjectSearcher(scope,new SelectQuery("Win32_Service",Condition,selectedProperties));
	///			QueryOptions query = new QueryOptions();
	///			query.EnsureLocatable = true;
	///			ObjectSearcher.Options = query;
    ///	        return new ServiceCollection(ObjectSearcher.Get());
	///		}
	/// </summary>
	void GenerateGetInstancesWithScopeWhereProperties()
	{
		string strScope = "scope";
		string strCondition = "condition";
		string strSelectedProperties = "selectedProperties";
		string strObjectSearcher = "ObjectSearcher";
		string strQuery = "query";

		cmm = new CodeMemberMethod();
		cmm.Attributes = MemberAttributes.Public | MemberAttributes.Final | MemberAttributes.Static ;
		cmm.Name = PublicNamesUsed["FilterFunction"].ToString();
		cmm.ReturnType = new CodeTypeReference(PrivateNamesUsed["CollectionClass"].ToString());

		cmm.Parameters.Add(new CodeParameterDeclarationExpression(PublicNamesUsed["ScopeClass"].ToString(),strScope));
		cmm.Parameters.Add(new CodeParameterDeclarationExpression("String",strCondition));
		cmm.Parameters.Add(new CodeParameterDeclarationExpression("String []",strSelectedProperties));

		CodeObjectCreateExpression coce1 = new CodeObjectCreateExpression();
		coce1.CreateType = new CodeTypeReference(PublicNamesUsed["QueryClass"].ToString());
		coce1.Parameters.Add(new CodePrimitiveExpression(OriginalClassName));
		coce1.Parameters.Add(new CodeSnippetExpression(strCondition));
		coce1.Parameters.Add(new CodeSnippetExpression(strSelectedProperties));

		coce = new CodeObjectCreateExpression();
		coce.CreateType = new CodeTypeReference(PublicNamesUsed["ObjectSearcherClass"].ToString());
		coce.Parameters.Add(new CodeSnippetExpression(strScope));
		coce.Parameters.Add(coce1);
	
		cmm.Statements.Add(new CodeVariableDeclarationStatement(PublicNamesUsed["ObjectSearcherClass"].ToString(),
																strObjectSearcher,coce));

		coce = new CodeObjectCreateExpression();
		coce.CreateType = new CodeTypeReference(PublicNamesUsed["QueryOptionsClass"].ToString());
		cmm.Statements.Add(new CodeVariableDeclarationStatement(PublicNamesUsed["QueryOptionsClass"].ToString(),strQuery,coce));

		cmm.Statements.Add(new CodeAssignStatement(new CodePropertyReferenceExpression(
														new CodeSnippetExpression(strQuery),
														"EnsureLocatable"),
													new CodePrimitiveExpression(true)));


		cmm.Statements.Add(new CodeAssignStatement(new CodePropertyReferenceExpression(
														new CodeSnippetExpression(strObjectSearcher),
														"Options"),
													new CodeSnippetExpression(strQuery)));
	
		coce = new CodeObjectCreateExpression();
		coce.CreateType = new CodeTypeReference(PrivateNamesUsed["CollectionClass"].ToString());
		coce.Parameters.Add(new CodeMethodInvokeExpression(new CodeSnippetExpression(strObjectSearcher),
															"Get"));
		cmm.Statements.Add(new CodeMethodReturnStatement(coce));

		cc.Members.Add(cmm);
	}

	/// <summary>
	/// This function will add the variable as a private member to the class.
	/// The generated code will look like this
	///         private <MemberType> <MemberName>;
	/// </summary>
	void GeneratePrivateMember(string memberName,string MemberType)
	{
		GeneratePrivateMember(memberName,MemberType,null);
	}

	/// <summary>
	/// This function will add the variable as a private member to the class.
	/// The generated code will look like this
	///         private <MemberType> <MemberName> = <initValue>;
	/// </summary>
	void GeneratePrivateMember(string memberName,string MemberType,CodeExpression initExpression)
	{
		cf = new CodeMemberField();
		cf.Name = memberName;
		cf.Attributes = MemberAttributes.Private | MemberAttributes.Final ;
		cf.Type = new CodeTypeReference(MemberType);
		if(initExpression != null)
		{
			cf.InitExpression = initExpression;
		}
		cc.Members.Add(cf);
	}
/// <summary>
/// This is a simple helper function used to convert a given string to title case.
/// </summary>
/// <param name="str"> </param>
	public string ConvertToTitleCase(string str)
	{
		if(str.Length == 0)
		{
			return string.Copy("");
		}

		char[] arrString = str.ToLower().ToCharArray();
		//Convert the first character to uppercase
		arrString[0] = Char.ToUpper(arrString[0]);

		for(int i=0;i < str.Length;i++)
		{
			if(Char.IsLetterOrDigit(arrString[i]) == false)
			{
				//Some other character. So convert the next character to Upper case
				arrString[i+1] = Char.ToUpper(arrString[i+1]);
			}
		}
		return new string(arrString);
	}

	void GenerateTypeConverterClass()
	{
		string TypeDescriptorContextClass = "ITypeDescriptorContext";
		string contextObject = "context";
		string ActualObject = "obj";
		string CreationBundleClass = "CreationBundle";
		string CreationBundleObject = "objectCreationBundle";
		string InternalName = "Value";
		string creationArgumentClass = "CreationArgument";
		string strPath = "Path";
		
		CodeTypeDeclaration CodeConvertorClass = new CodeTypeDeclaration(PrivateNamesUsed["ConverterClass"].ToString());
		CodeConvertorClass.BaseTypes.Add(PublicNamesUsed["TypeConverter"].ToString());

		cmm = new CodeMemberMethod();
		cmm.Attributes = MemberAttributes.Public | MemberAttributes.Override;
		cmm.Name = "GetPersistInfo";
		cmm.Parameters.Add(new CodeParameterDeclarationExpression(TypeDescriptorContextClass,contextObject));
		cmm.Parameters.Add(new CodeParameterDeclarationExpression("Object",ActualObject));
		cmm.ReturnType = new CodeTypeReference("PersistInfo");

		cmm.Statements.Add(new CodeVariableDeclarationStatement(CreationBundleClass,
																CreationBundleObject,
																new CodePrimitiveExpression(null)));

		cboe = new CodeBinaryOperatorExpression();
		cboe.Left = new CodeSnippetExpression(ActualObject);
		cboe.Right = new CodeSnippetExpression(PrivateNamesUsed["GeneratedClassName"].ToString());
		cboe.Operator = CodeBinaryOperatorType.IdentityEquality;

		cis = new CodeConditionStatement();
		cmie = new CodeMethodInvokeExpression(
					new CodeSnippetExpression("String"),
					"Compare"
					);
		cmie.Parameters.Add(new CodeMethodInvokeExpression(
								new CodeMethodInvokeExpression(new CodeSnippetExpression(ActualObject),
																"GetType"),
								"ToString"));

		cmie.Parameters.Add(new CodePrimitiveExpression(PrivateNamesUsed["GeneratedClassName"].ToString()));
		cmie.Parameters.Add(new CodePrimitiveExpression(true));
		cboe = new CodeBinaryOperatorExpression();
		cboe.Left = cmie;
		cboe.Right = new CodePrimitiveExpression(0);
		cboe.Operator = CodeBinaryOperatorType.ValueEquality;
		cis.Condition = cboe;

		cis.TrueStatements.Add(new CodeVariableDeclarationStatement(
													PrivateNamesUsed["GeneratedClassName"].ToString(),
													InternalName,
								new CodeCastExpression(PrivateNamesUsed["GeneratedClassName"].ToString(),
								new CodeSnippetExpression(ActualObject))));

		coce = new CodeObjectCreateExpression();
		coce.CreateType = new CodeTypeReference(CreationBundleClass);
		coce.Parameters.Add(new CodeTypeOfExpression(PrivateNamesUsed["GeneratedClassName"].ToString()));
		coce.Parameters.Add(new CodePrimitiveExpression(null));

		CodeArrayCreateExpression cace = new CodeArrayCreateExpression();
		cace.CreateType = new CodeTypeReference(creationArgumentClass);
		CodeObjectCreateExpression coce1 = new CodeObjectCreateExpression();
		coce1.CreateType = new CodeTypeReference(creationArgumentClass);
		coce1.Parameters.Add(new CodePropertyReferenceExpressi