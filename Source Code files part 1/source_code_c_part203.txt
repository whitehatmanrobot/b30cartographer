he filename of the target file. Filename part
        only.

    CopyStyle - supplies flags that control the behavior of the copy operation
        for this file.

    SecurityDescriptor - describes the permissions for the target file

    CacheName - if supplied this is the name of the driver cache we should
                use to copy the file out of instead of the specified source path

Return Value:

    Boolean value indicating outcome. If FALSE, GetLastError() returns
    extended error information.

--*/

{
    BOOL b;
    UINT SourceId;
    DWORD SizeRequired;
    PTSTR TargetDirectory;
    PCTSTR SourceDescription,SourceTagfile,SourceRelativePath;
    PCTSTR TmpCacheName = CacheName;
    UINT SourceFlags;
    DWORD rc;
    TCHAR FileSubdir[MAX_PATH];
    TCHAR RelativePath[MAX_PATH];
    INFCONTEXT LineContext;
    PINFCONTEXT pLineContext;
    SP_FILE_COPY_PARAMSEX CopyParams;
    HINF CabInf = INVALID_HANDLE_VALUE;
    PSETUP_LOG_CONTEXT lc = NULL;
    BOOL AlreadyLoggedError = FALSE;

    if(!ListInfHandle || (ListInfHandle == INVALID_HANDLE_VALUE)) {
        ListInfHandle = InfHandle;
    }

    //
    // Determine the source disk id and subdir where the file is located.
    //
    try {

        if((QueueHandle != NULL) &&
           (QueueHandle != INVALID_HANDLE_VALUE) &&
           (((PSP_FILE_QUEUE)QueueHandle)->Signature == SP_FILE_QUEUE_SIG)) {

            lc = ((PSP_FILE_QUEUE)QueueHandle)->LogContext;

            b = _SetupGetSourceFileLocation(
                    InfHandle,
                    NULL,
                    SourceFilename,
                    (((PSP_FILE_QUEUE)QueueHandle)->Flags & FQF_USE_ALT_PLATFORM)
                       ? &(((PSP_FILE_QUEUE)QueueHandle)->AltPlatformInfo)
                       : NULL,
                    &SourceId,
                    FileSubdir,
                    MAX_PATH,
                    &rc,
                    &LineContext
                    );

            if(!b) {
                rc = GetLastError();
            }

        } else {
            b = FALSE;
            rc = ERROR_INVALID_HANDLE;
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        b = FALSE;
        rc = ERROR_INVALID_HANDLE;
        lc = NULL;
    }

    if(!b) {

        if((rc == ERROR_INVALID_PARAMETER) || (rc == ERROR_INVALID_HANDLE)) {
            //
            // if we failed due to a bad parameter, bail now
            //
            goto clean1;
        }

        //
        // Try to fetch just the id and assume there is no subdir.
        //
        try {

            b = _SetupGetSourceFileLocation(
                    InfHandle,
                    NULL,
                    SourceFilename,
                    (((PSP_FILE_QUEUE)QueueHandle)->Flags & FQF_USE_ALT_PLATFORM)
                       ? &(((PSP_FILE_QUEUE)QueueHandle)->AltPlatformInfo)
                       : NULL,
                    &SourceId,
                    NULL,
                    0,
                    NULL,
                    &LineContext
                    );

        } except(EXCEPTION_EXECUTE_HANDLER) {
            b = FALSE;
        }

        if(b) {
            FileSubdir[0] = 0;
        }
    }

    if(b) {
        //
        // Get information about the source. Need the tag file,
        // description, and relative source path.
        //
        try {

            b = pSetupGetSourceAllInfo(
                    InfHandle,
                    &LineContext,
                    SourceId,
                    (((PSP_FILE_QUEUE)QueueHandle)->Flags & FQF_USE_ALT_PLATFORM)
                       ? &(((PSP_FILE_QUEUE)QueueHandle)->AltPlatformInfo)
                       : NULL,
                    &SourceDescription,
                    &SourceTagfile,
                    &SourceRelativePath,
                    &SourceFlags
                    );

            if(!b) {
                rc = GetLastError();
                if((rc == ERROR_LINE_NOT_FOUND) || (rc == ERROR_SECTION_NOT_FOUND)) {
                    WriteLogEntry(
                        lc,
                        SETUP_LOG_ERROR,
                        MSG_LOG_NO_SOURCE,
                        NULL,
                        SourceId
                        );
                    AlreadyLoggedError = TRUE;
                }
            }

        } except(EXCEPTION_EXECUTE_HANDLER) {
            b = FALSE;
            rc = ERROR_INVALID_PARAMETER;
        }

        if(!b) {
            goto clean1;
        }

        //
        // Set a value that causes _SetupQueueCopy to skip looking for the
        // [SourceDisksFiles] section -- we just found it, so we just pass
        // the info along!
        //
        pLineContext = &LineContext;

    } else {
        //
        // Assume there is no SourceDisksFiles section and fake it as best we can.
        // Assume the media has a description of "Unknown," set the source path to
        // the source root if there is one, and assume no tag file.
        //
        // We also set a special value that tells _SetupQueueCopy not to bother trying
        // to look for the [SourceDisksFiles] section itself, since there isn't one.
        //
        FileSubdir[0] = 0;
        SourceDescription = NULL;
        SourceTagfile = NULL;
        SourceRelativePath = NULL;
        pLineContext = (PINFCONTEXT)(-1);
    }

    if(ServicePackCachePath
       && pLineContext
       && (pLineContext != (PINFCONTEXT)(-1))
       && (((PLOADED_INF)pLineContext->CurrentInf)->OriginalInfName == NULL)
       && !pSetupInfIsFromOemLocation( ((PLOADED_INF)pLineContext->CurrentInf)->VersionBlock.Filename,TRUE)) {
        //
        // consider getting this from SP CACHE instead
        //
        CopyStyle |= PSP_COPY_USE_SPCACHE;
    }

    if ( CopyStyle & PSP_COPY_CHK_DRIVERCACHE) {
        CabInf = SetupOpenInfFile( STR_DRIVERCACHEINF, NULL, INF_STYLE_WIN4, NULL );
        if (CabInf != INVALID_HANDLE_VALUE) {
            if (pIsFileInDriverCache(CabInf, SourceFilename, SourceRelativePath, &TmpCacheName)) {
                CopyStyle |= PSP_COPY_USE_DRIVERCACHE;
                CopyStyle &= ~PSP_COPY_CHK_DRIVERCACHE;
            }

            SetupCloseInfFile(CabInf);

        }
    }

    if (CopyStyle & PSP_COPY_USE_DRIVERCACHE) {
        //
        // check if the inf we want to copy from is an OEM inf
        //
        if (!pLineContext || pLineContext==(PINFCONTEXT)-1) {
            CopyStyle &= ~PSP_COPY_USE_DRIVERCACHE;
        } else if (pSetupInfIsFromOemLocation( ((PLOADED_INF)pLineContext->CurrentInf)->VersionBlock.Filename,TRUE )) {
            CopyStyle &= ~PSP_COPY_USE_DRIVERCACHE;
        } else if ( ((PLOADED_INF)pLineContext->CurrentInf)->OriginalInfName
                    && pSetupInfIsFromOemLocation( ((PLOADED_INF)pLineContext->CurrentInf)->OriginalInfName, TRUE) ) {
            CopyStyle &= ~PSP_COPY_USE_DRIVERCACHE;
        }
    }

    //
    // Determine the target path for the file.
    //
    if(b = SetupGetTargetPath(ListInfHandle,NULL,SectionName,NULL,0,&SizeRequired)) {

        if(TargetDirectory = MyMalloc(SizeRequired*sizeof(TCHAR))) {

            if(b = SetupGetTargetPath(ListInfHandle,NULL,SectionName,TargetDirectory,SizeRequired,NULL)) {

                try {
                    WriteLogEntry(
                        lc,
                        SETUP_LOG_VVERBOSE,
                        SectionName ? MSG_LOG_COPY_QUEUE : MSG_LOG_DEFCOPY_QUEUE,
                        NULL,
                        SectionName ? SectionName : TEXT(""),
                        ((PLOADED_INF)ListInfHandle)->VersionBlock.Filename,
                        TargetFilename ? TargetFilename : TEXT(""),
                        SourceFilename ? SourceFilename : TEXT(""),
                        CopyStyle,
                        TargetDirectory ? TargetDirectory : TEXT(""));
                    if (pLineContext && (pLineContext != (PINFCONTEXT)(-1))) {
                        LPCTSTR SrcSecName = NULL;
                        LPCTSTR SrcInfName = NULL;
                        PLOADED_INF pInf = (PLOADED_INF)(pLineContext->CurrentInf);

                        MYASSERT(pInf);
                        SrcSecName = pStringTableStringFromId(
                                                pInf->StringTable,
                                                pInf->SectionBlock[pLineContext->Section].SectionName);
                        SrcInfName = pInf->VersionBlock.Filename;
                        WriteLogEntry(
                            lc,
                            SETUP_LOG_VVERBOSE,
                            (CopyStyle & PSP_COPY_USE_DRIVERCACHE) ? MSG_LOG_COPY_QUEUE_DRIVERCACHE : MSG_LOG_COPY_QUEUE_SOURCE,
                            NULL,
                            SrcSecName ? SrcSecName : TEXT(""),
                            SrcInfName ? SrcInfName : TEXT(""),
                            SourceId ? SourceId : TEXT('\0'),
                            SourceDescription ? SourceDescription : TEXT(""),
                            SourceTagfile ? SourceTagfile : TEXT(""),
                            SourceRelativePath ? SourceRelativePath : TEXT(""));

                    } else {
                        WriteLogEntry(
                            lc,
                            SETUP_LOG_VVERBOSE,
                            MSG_LOG_COPY_QUEUE_DEFAULT,
                            NULL);
                    }
                } except(EXCEPTION_EXECUTE_HANDLER) {
                }
                //
                // Append the source relative path and the file subdir.
                //
                if(SourceRelativePath) {
                    lstrcpyn(RelativePath,SourceRelativePath,MAX_PATH);
                    if(FileSubdir[0]) {
                        pSetupConcatenatePaths(RelativePath,FileSubdir,MAX_PATH,NULL);
                    }
                } else {
                    RelativePath[0] = 0;
                }

                //
                // Add to queue.
                //
                CopyParams.cbSize            = sizeof(SP_FILE_COPY_PARAMSEX);
                CopyParams.QueueHandle       = QueueHandle;
                CopyParams.SourceRootPath    = SourceRootPath;
                CopyParams.SourcePath        = RelativePath[0] ? RelativePath : NULL ;
                CopyParams.SourceFilename    = SourceFilename;
                CopyParams.SourceDescription = SourceDescription;
                CopyParams.SourceTagfile     = SourceTagfile;
                CopyParams.TargetDirectory   = TargetDirectory;
                CopyParams.TargetFilename    = TargetFilename;
                CopyParams.CopyStyle         = CopyStyle;
                CopyParams.LayoutInf         = InfHandle;
                CopyParams.SecurityDescriptor= SecurityDescriptor;
                CopyParams.CacheName         = TmpCacheName;
                //
                // first item indicates source flag information
                // second item indicates that we've already retrieved
                // this information, so even if the SourceFlags are zero,
                // we won't go looking for it again
                //
                CopyParams.SourceFlags       = SourceFlags;
                CopyParams.SourceFlagsSet    = TRUE;

                b = _SetupQueueCopy(&CopyParams,
                                    pLineContext,
                                    ((InfHandle == ListInfHandle) ? NULL : ListInfHandle)
                                   );

                rc = GetLastError();
            }

            MyFree(TargetDirectory);

        } else {
            rc = ERROR_NOT_ENOUGH_MEMORY;
        }
    } else {
        rc = GetLastError();
    }

    if(SourceDescription) {
        MyFree(SourceDescription);
    }
    if(SourceTagfile) {
        MyFree(SourceTagfile);
    }
    if(SourceRelativePath) {
        MyFree(SourceRelativePath);
    }
    if(TmpCacheName && TmpCacheName != CacheName) {
        MyFree(TmpCacheName);
    }

clean1:
    if(!b) {

        BOOL FreeLC = FALSE;

        if(!lc) {
            if(CreateLogContext(NULL, TRUE, &lc) == NO_ERROR) {
                //
                // success
                //
                FreeLC = TRUE;
            } else {
                lc = NULL;
            }
        }

        //
        // If we couldn't create a log context (i.e., due to out-of-memory),
        // don't bother calling WriteLogEntry, because it's not going to have
        // any better luck...
        //
        if(lc) {

            if(!AlreadyLoggedError) {
                try {
                    WriteLogEntry(
                        lc,
                        SETUP_LOG_ERROR|SETUP_LOG_BUFFER,
                        MSG_LOG_COPY_QUEUE_ERROR,
                        NULL,
                        SectionName ? SectionName : TEXT(""),
                        ((PLOADED_INF)ListInfHandle)->VersionBlock.Filename,
                        TargetFilename ? TargetFilename : TEXT(""),
                        SourceFilename ? SourceFilename : TEXT(""));
                    WriteLogError(
                        lc,
                        SETUP_LOG_ERROR,
                        rc
                        );
                } except(EXCEPTION_EXECUTE_HANDLER) {
                }
            }

            if(FreeLC) {
                DeleteLogContext(lc);
            }
        }

        SetLastError(rc);
    }

    return(b);
}


#ifdef UNICODE
//
// ANSI version
//
BOOL
SetupQueueDefaultCopyA(
    IN HSPFILEQ QueueHandle,
    IN HINF     InfHandle,
    IN PCSTR    SourceRootPath,
    IN PCSTR    SourceFilename,
    IN PCSTR    TargetFilename,
    IN DWORD    CopyStyle
    )
{
    PWSTR sourcerootpath;
    PWSTR sourcefilename;
    PWSTR targetfilename;
    DWORD rc;
    BOOL b;

    b = FALSE;
    rc = pSetupCaptureAndConvertAnsiArg(SourceRootPath,&sourcerootpath);
    if(rc == NO_ERROR) {

        rc = pSetupCaptureAndConvertAnsiArg(SourceFilename,&sourcefilename);
        if(rc == NO_ERROR) {

            rc = pSetupCaptureAndConvertAnsiArg(TargetFilename,&targetfilename);
            if(rc == NO_ERROR) {

                b = SetupQueueDefaultCopyW(
                        QueueHandle,
                        InfHandle,
                        sourcerootpath,
                        sourcefilename,
                        targetfilename,
                        CopyStyle
                        );

                rc = GetLastError();

                MyFree(targetfilename);
            }

            MyFree(sourcefilename);
        }

        MyFree(sourcerootpath);
    }

    SetLastError(rc);
    return(b);
}
#else
//
// Unicode stub
//
BOOL
SetupQueueDefaultCopyW(
    IN HSPFILEQ QueueHandle,
    IN HINF     InfHandle,
    IN PCWSTR   SourceRootPath,
    IN PCWSTR   SourceFilename,
    IN PCWSTR   TargetFilename,
    IN DWORD    CopyStyle
    )
{
    UNREFERENCED_PARAMETER(QueueHandle);
    UNREFERENCED_PARAMETER(InfHandle);
    UNREFERENCED_PARAMETER(SourceRootPath);
    UNREFERENCED_PARAMETER(SourceFilename);
    UNREFERENCED_PARAMETER(TargetFilename);
    UNREFERENCED_PARAMETER(CopyStyle);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif


BOOL
SetupQueueDefaultCopy(
    IN HSPFILEQ QueueHandle,
    IN HINF     InfHandle,
    IN PCTSTR   SourceRootPath,
    IN PCTSTR   SourceFilename,
    IN PCTSTR   TargetFilename,
    IN DWORD    CopyStyle
    )

/*++

Routine Description:

    Add a single file to the copy queue, using the default source media
    and destination as specified in an inf file.

Arguments:

    QueueHandle - supplies a handle to a setup file queue, as returned
        by SetupOpenFileQueue.

    InfHandle - supplies a handle to an open inf file, that contains the
        [SourceDisksFiles] and [SourceDisksNames] sections.
        This handle must be for a win95-style inf.

    SourceRootPath - supplies the root directory for the intended source.
        This should be a sharepoint or a device root such as a:\ or g:\.

    SourceFilename - supplies the filename of the source file. Filename part
        only.

    TargetFilename - supplies the filename of the target file. Filename part
        only.

    CopyStyle - supplies flags that control the behavior of the copy operation
        for this file.

Return Value:

    Boolean value indicating outcome. If FALSE, GetLastError() returns
    extended error information.

--*/

{
    BOOL b;

    b = pSetupQueueSingleCopy(
            QueueHandle,
            InfHandle,
            NULL,
            NULL,
            SourceRootPath,
            SourceFilename,
            TargetFilename,
            CopyStyle | PSP_COPY_CHK_DRIVERCACHE,
            NULL,
            NULL
            );

    return(b);
}


PSOURCE_MEDIA_INFO
pSetupQueueSourceMedia(
    IN OUT PSP_FILE_QUEUE      Queue,
    IN OUT PSP_FILE_QUEUE_NODE QueueNode,
    IN     LONG                SourceRootStringId,
    IN     PCTSTR              SourceDescription,   OPTIONAL
    IN     PCTSTR              SourceTagfile,       OPTIONAL
    IN     PCTSTR              SourceCabfile,       OPTIONAL
    IN     DWORD               MediaFlags
    )

/*++

Routine Description:

    Set up a file queue node's source media descriptor pointer, creating a new
    source media descriptor if necessary.

Arguments:

    Queue - supplies pointer to file queue with which the queue node
        is associated.

    QueueNode - supplies file queue node whose source media descriptor pointer
        is to be set.

    SourceRootStringId - supplies string id of root to source (something like a:\).

    SourceDescription - if specified, supplies a description for the media.

    SourceTagfile - if specified, supplies a tag file for the media.

    SourceCabfile - if specified, supplies a cabfile for the media different to the tagfile.

    MediaFlags - specifies additional information used in searching for an
        existing source media descriptor in the specified queue, and in adding
        new source media descriptors to that queue.  May be a combination of
        the following values:

        SMI_FLAG_NO_SOURCE_ROOT_PATH : The caller didn't supply a SourceRootPath
            for this copy action, so we're using a default path.  This flag
            causes us to not include the SourceRootStringId as part of our
            match criteria when searching to see if the specified source media
            information is already present in an existing media descriptor.  If
            we don't find a match (i.e., we have to create a new descriptor),
            we'll store this flag away in the SOURCE_MEDIA_INFO.Flags field so
            that if we come along later to add source media descriptors where
            the caller did specify SourceRootPath, then we'll re-use this
            descriptor and overwrite the existing (default) source root path
            with the caller-specified one.

        SMI_FLAG_USE_SVCPACK_SOURCE_ROOT_PATH : The caller didn't supply a SourceRootPath
            for this copy action, and it's a tagged source media, so we're using a
            service pack path.  This flag  causes us to not include the SourceRootStringId
            as part of our match criteria when searching to see if the specified source media
            information is already present in an existing media descriptor.  If
            we don't find a match (i.e., we have to create a new descriptor),
            we'll store this flag away in the SOURCE_MEDIA_INFO.Flags field so
            that if we come along later to add source media descriptors where
            the caller did specify SourceRootPath, then we'll re-use this
            descriptor and overwrite the existing (default) source root path
            with the caller-specified one.

        SMI_FLAG_USE_LOCAL_SOURCE_CAB : The caller wants to use the local source cab containing
            driver files, etc.  In this case, we supply the source description and tagfile,
            ignoring what the caller passes in.  At this point we know the media is present, as
            the caller provided this check.  If it wasnt't, we default to the OS Source path location.
            Mutually exclusive with SMI_FLAG_USE_LOCAL_SPCACHE

        SMI_FLAG_USE_LOCAL_SPCACHE : The caller wants to get files from the ServicePackCache
            directory. This is used to make hotfixes etc "sticky".


Return Value:

    Pointer to source media info structure, or NULL if out of memory.

--*/

{
    LONG DescriptionStringId;
    LONG TagfileStringId;
    LONG CabfileStringId;
    PSOURCE_MEDIA_INFO Source,LastSource, TempSource;
    BOOL b1,b2,b3;
    TCHAR TempTagfileString[MAX_PATH];
    TCHAR TempCabfileString[MAX_PATH];
    TCHAR TempSrcDescString[LINE_LEN];


    if (MediaFlags & SMI_FLAG_USE_LOCAL_SOURCE_CAB) {
        LoadString( MyDllModuleHandle, IDS_DRIVERCACHE_DESC, TempSrcDescString, sizeof(TempSrcDescString)/sizeof(TCHAR) );
        SourceDescription = TempSrcDescString;
    } else {
        //
        // For the optional SourceDescription and SourceTagfile parameters, treat
        // empty strings as if the parameter had not been specified.
        //
        if(SourceDescription && !(*SourceDescription)) {
            SourceDescription = NULL;
        }
        if(SourceTagfile && !(*SourceTagfile)) {
            SourceTagfile = NULL;
        }

        //
        // If no description is specified, force the tagfile to none.
        //
        if(!SourceDescription) {
            SourceTagfile = NULL;
        }
    }

    if(SourceDescription) {
        //
        // Description specified. See if it's in the table. If not,
        // no need to search the list of media descriptors because we know
        // we can't find a match.
        //
        // (We must first copy this string to a writeable buffer, to speed up the
        // case-insensitive lookup.
        //
        lstrcpyn(TempSrcDescString, SourceDescription, SIZECHARS(TempSrcDescString));
        DescriptionStringId = pSetupStringTableLookUpString(Queue->StringTable,
                                                      TempSrcDescString,
                                                      STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE
                                                     );
        b1 = (DescriptionStringId != -1);
    } else {
        //
        // No description specified, look for a source media with -1 as the
        // description string id
        //
        DescriptionStringId = -1;
        b1 = TRUE;
    }

    if(SourceTagfile) {
        //
        // Tagfile specified. See if it's in the table. If not,
        // no need to search the list of media descriptors because we know
        // we can't find a match.
        //
        // (Again, we must first copy the string to a writeable buffer.
        //
        lstrcpyn(TempTagfileString, SourceTagfile, SIZECHARS(TempTagfileString));
        TagfileStringId = pSetupStringTableLookUpString(Queue->StringTable,
                                                  TempTagfileString,
                                                  STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE
                                                 );
        b2 = (TagfileStringId != -1);
    } else {
        //
        // No tagfile specified, look for a source media with -1 as the
        // tagfile string id
        //
        TagfileStringId = -1;
        b2 = TRUE;
    }

    if(SourceCabfile) {
        //
        // Cabfile specified. See if it's in the table. If not,
        // no need to search the list of media descriptors because we know
        // we can't find a match.
        //
        // (Again, we must first copy the string to a writeable buffer.
        //
        lstrcpyn(TempCabfileString, SourceCabfile, SIZECHARS(TempCabfileString));
        CabfileStringId = pSetupStringTableLookUpString(Queue->StringTable,
                                                  TempCabfileString,
                                                  STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE
                                                 );
        b3 = (CabfileStringId != -1);
    } else {
        //
        // No cabfile specified, merge Cabfile&Tagfile together
        // since b2==b3, then we have the identities b2|b3 == b2 and b2&b3 == b2
        // ie, old behavior
        //
        CabfileStringId = TagfileStringId;
        b3 = b2;
    }

    //
    // If we think there's a possibility of finding an existing source that
    // matches the caller's parameters, scan the source media list looking
    // for a match.
    //
    if(b1 && b2 && b3) {

        for(Source=Queue->SourceMediaList; Source; Source=Source->Next) {

            if (((Source->Flags ^ MediaFlags) &
                    (SMI_FLAG_USE_LOCAL_SPCACHE | SMI_FLAG_USE_LOCAL_SOURCE_CAB | SMI_FLAG_USE_SVCPACK_SOURCE_ROOT_PATH))==0) {
                //
                // only check everything else if special media's match
                //
                if((Source->Description == DescriptionStringId)
                   && (Source->Tagfile == TagfileStringId)
                   && (Source->Cabfile == CabfileStringId)) {
                    //
                    // We only consider the SourceRootPath when both existing
                    // media descriptor and new media descriptor have actual
                    // caller-supplied paths (as opposed to something we made up).
                    //
                    if((Source->Flags & SMI_FLAG_NO_SOURCE_ROOT_PATH) ||
                       (MediaFlags & SMI_FLAG_NO_SOURCE_ROOT_PATH) ||
                       (Source->SourceRootPath == SourceRootStringId)) {
                        //
                        // Got a match. Point the queue node at this source and return.
                        //
                        QueueNode->SourceMediaInfo = Source;
                        //
                        // If the existing media descriptor had a made-up source
                        // root path, but the new media information had an actual
                        // caller-supplied one, then replace the made-up one with
                        // the real one and clear the no-source-root-path flag.
                        //
                        if((Source->Flags & SMI_FLAG_NO_SOURCE_ROOT_PATH) &&
                           !(MediaFlags & SMI_FLAG_NO_SOURCE_ROOT_PATH)) {

                            Source->SourceRootPath = SourceRootStringId;
                            Source->Flags &= ~SMI_FLAG_NO_SOURCE_ROOT_PATH;
                        }

                        return(Source);
                    }
                }
            }
        }
    }

    //
    // Need to add a new source media descriptor.
    // Allocate the structure and fill it in.
    //
    Source = MyMalloc(sizeof(SOURCE_MEDIA_INFO));
    if(!Source) {
        return(NULL);
    }

    Source->Next = NULL;
    Source->CopyQueue = NULL;
    Source->CopyNodeCount = 0;
    Source->Flags = MediaFlags;

    if(SourceDescription) {
        //
        // Since we already passed this in for a case-insensitive lookup with a writeable
        // buffer, we can add it case-sensitively, because it's already lower-cased.
        //
        Source->Description = pSetupStringTableAddString(Queue->StringTable,
                                                   TempSrcDescString,
                                                   STRTAB_CASE_SENSITIVE | STRTAB_ALREADY_LOWERCASE
                                                  );
        //
        // We also must add the description in its original case, since this is a displayable string.
        // (We're safe in casting away the CONST-ness of this string, since it won't be modified.)
        //
        Source->DescriptionDisplayName = pSetupStringTableAddString(Queue->StringTable,
                                                              (PTSTR)SourceDescription,
                                                              STRTAB_CASE_SENSITIVE
                                                             );

        if((Source->Description == -1) || (Source->DescriptionDisplayName == -1)) {
            MyFree(Source);
            return(NULL);
        }
    } else {
        Source->Description = Source->DescriptionDisplayName = -1;
    }

    if(SourceTagfile) {
        //
        // Again, we already lower-cased this in a writeable buffer above.
        //
        Source->Tagfile = pSetupStringTableAddString(Queue->StringTable,
                                               TempTagfileString,
                                               STRTAB_CASE_SENSITIVE | STRTAB_ALREADY_LOWERCASE
                                              );
        if(Source->Tagfile == -1) {
            MyFree(Source);
            return(NULL);
        }
    } else {
        Source->Tagfile = -1;
    }

    if(SourceCabfile) {
        //
        // Again, we already lower-cased this in a writeable buffer above.
        //
        Source->Cabfile = pSetupStringTableAddString(Queue->StringTable,
                                               TempCabfileString,
                                               STRTAB_CASE_SENSITIVE | STRTAB_ALREADY_LOWERCASE
                                              );
        if(Source->Cabfile == -1) {
            MyFree(Source);
            return(NULL);
        }
    } else {
        Source->Cabfile = Source->Tagfile;
    }

    Source->SourceRootPath = SourceRootStringId;

    //
    // insert our media descriptor into the list of descriptors
    // Note: if the new descriptor has the "service pack" or
    // "local cab driver cache" tag set, then we insert it into
    // the head of the list, otherwise we put it into the end
    // of the list.  This ensures that if the user get's a
    // need media complaint for os binaries, and overrides
    // the source path, then the user will first be prompted for service
    // pack media, then the os media. This saves us from adding lots of
    // code to handle need media overrides in this case, since we would
    // potentially have the os source files first in the media list, which
    // would cause us to install the os media files instead of the service
    // pack media files
    //
    // another potential service pack issue is if we get Tag==Cab entries mixed with Tag!=Cab
    // for exactly the same cab
    // nothing much we can do here, other than ensure that any change where Tag!=Cab
    // is done across the board
    //
    LastSource = NULL;
    for(TempSource=Queue->SourceMediaList; TempSource; LastSource=TempSource,TempSource=LastSource->Next) {
        if ((Source->Flags ^ TempSource->Flags) & (SMI_FLAG_USE_LOCAL_SPCACHE | SMI_FLAG_USE_LOCAL_SOURCE_CAB | SMI_FLAG_USE_SVCPACK_SOURCE_ROOT_PATH)) {
            //
            // one is either normal, local source cab, or source root path, and the other is different
            //
            // media with \ comes before media without
            // (not critical that this comes before SMI_FLAG_USE_LOCAL_SOURCE_CAB
            // but good housekeeping, keeping like media together)
            //
            if(TempSource->Flags & SMI_FLAG_USE_LOCAL_SPCACHE) {
                if(!(Source->Flags & SMI_FLAG_USE_LOCAL_SPCACHE)) {
                    continue;
                }
            }
            else if(Source->Flags & SMI_FLAG_USE_LOCAL_SPCACHE) {
                break;
            }
            //
            // media with SMI_FLAG_USE_LOCAL_SOURCE_CAB comes before media without
            // (not critical that this comes before SMI_FLAG_USE_SVCPACK_SOURCE_ROOT_PATH
            // but good housekeeping, keeping like media together)
            //
            if(TempSource->Flags & SMI_FLAG_USE_LOCAL_SOURCE_CAB) {
                if(!(Source->Flags & SMI_FLAG_USE_LOCAL_SOURCE_CAB)) {
                    continue;
                }
            }
            else if(Source->Flags & SMI_FLAG_USE_LOCAL_SOURCE_CAB) {
                break;
            }
            //
            // SMI_FLAG_USE_SVCPACK_SOURCE_ROOT_PATH comes before media without
            //
            if(TempSource->Flags & SMI_FLAG_USE_SVCPACK_SOURCE_ROOT_PATH) {
                if(!(Source->Flags & SMI_FLAG_USE_SVCPACK_SOURCE_ROOT_PATH)) {
                    continue;
                }
            }
            else if(Source->Flags & SMI_FLAG_USE_SVCPACK_SOURCE_ROOT_PATH) {
                break;
            }
            MYASSERT(FALSE); // we should have gone one way or the other
        }
        //
        // group same tagfiles together (needed because of tag+cab combinations)
        //
        if( LastSource && (Source->Tagfile == LastSource->Tagfile)
                       && (Source->Tagfile != TempSource->Tagfile)) {
            break;
        }
    }
    if (LastSource) {
        //
        // insert after this one
        //
        Source->Next = LastSource->Next;
        LastSource->Next = Source;
    } else {
        //
        // TempSource will either be NULL (no media) or first media (insert before first)
        //
        Source->Next = TempSource;
        Queue->SourceMediaList = Source;
    }

    Queue->SourceMediaCount++;

    QueueNode->SourceMediaInfo = Source;
    return(Source);
}


BOOL
pSetupGetSourceAllInfo(
    IN  HINF                     InfHandle,
    IN  PINFCONTEXT              LayoutLineContext, OPTIONAL
    IN  UINT                     SourceId,
    IN  PSP_ALTPLATFORM_INFO_V2  AltPlatformInfo,   OPTIONAL
    OUT PCTSTR                  *Description,
    OUT PCTSTR                  *Tagfile,
    OUT PCTSTR                  *RelativePath,
    OUT PUINT                    SourceFlags
    )
{
    BOOL b;
    DWORD RequiredSize;
    PTSTR p;
    DWORD ec;
    TCHAR Buffer[MAX_PATH];

    //
    // Get path relative to the source.
    //
    b = pSetupGetSourceInfo(InfHandle,
                            LayoutLineContext,
                            SourceId,
                            AltPlatformInfo,
                            SRCINFO_PATH,
                            NULL,
                            0,
                            &RequiredSize
                           );
    if(!b) {
        ec = GetLastError();
        goto clean0;
    }

    p = MyMalloc(RequiredSize*sizeof(TCHAR));
    if(!p) {
        ec = ERROR_NOT_ENOUGH_MEMORY;
        goto clean0;
    }
    pSetupGetSourceInfo(InfHandle,
                        LayoutLineContext,
                        SourceId,
                        AltPlatformInfo,
                        SRCINFO_PATH,
                        p,
                        RequiredSize,
                        NULL
                       );
    *RelativePath = p;

    //
    // Get description.
    //
    b = pSetupGetSourceInfo(InfHandle,
                            LayoutLineContext,
                            SourceId,
                            AltPlatformInfo,
                            SRCINFO_DESCRIPTION,
                            NULL,
                            0,
                            &RequiredSize
                           );
    if(!b) {
        ec = GetLastError();
        goto clean1;
    }

    p = MyMalloc(RequiredSize*sizeof(TCHAR));
    if(!p) {
        ec =  ERROR_NOT_ENOUGH_MEMORY;
        goto clean1;
    }
    pSetupGetSourceInfo(InfHandle,
                        LayoutLineContext,
                        SourceId,
                        AltPlatformInfo,
                        SRCINFO_DESCRIPTION,
                        p,
                        RequiredSize,
                        NULL
                       );
    *Description = p;

    //
    // Get tagfile, if any.
    //
    b = pSetupGetSourceInfo(InfHandle,
                            LayoutLineContext,
                            SourceId,
                            AltPlatformInfo,
                            SRCINFO_TAGFILE,
                            NULL,
                            0,
                            &RequiredSize
                           );
    if(!b) {
        ec = GetLastError();
        goto clean2;
    }

    p = MyMalloc(RequiredSize*sizeof(TCHAR));
    if(!p) {
        ec =  ERROR_NOT_ENOUGH_MEMORY;
        goto clean2;
    }
    pSetupGetSourceInfo(InfHandle,
                        LayoutLineContext,
                        SourceId,
                        AltPlatformInfo,
                        SRCINFO_TAGFILE,
                        p,
                        RequiredSize,
                        NULL
                       );
    if(*p) {
        *Tagfile = p;
    } else {
        MyFree(p);
        *Tagfile = NULL;
    }

    //
    // Get flags, if any.
    //
    b = pSetupGetSourceInfo(InfHandle,
                            LayoutLineContext,
                            SourceId,
                            AltPlatformInfo,
                            SRCINFO_FLAGS,
                            Buffer,
                            SIZECHARS(Buffer),
                            NULL
                           );
    if(!b) {
        ec = GetLastError();
        goto clean3;
    }

    pAToI( Buffer, SourceFlags );


    return(TRUE);

clean3:
    MyFree(*Tagfile);
clean2:
    MyFree(*Description);
clean1:
    MyFree(*RelativePath);
clean0:
    SetLastError(ec);
    return(FALSE);
}


BOOL
pIsFileInDriverCache(
    IN  HINF   CabInf,
    IN  PCTSTR TargetFilename,
    IN  PCTSTR SubDirectory,
    OUT PCTSTR *CacheName
    )
{
    INFCONTEXT Context,SectionContext;
    PCTSTR      SectionName,CabName;
    TCHAR      TempBuffer[MAX_PATH];

    UINT Field, FieldCount;

    MYASSERT(CabInf != INVALID_HANDLE_VALUE);
    MYASSERT(TargetFilename);
    MYASSERT(CacheName);

    if (!SetupFindFirstLine(CabInf, TEXT("Version"), TEXT("CabFiles"), &SectionContext)) {
        return(FALSE);
    }

    do  {


        FieldCount = SetupGetFieldCount(&SectionContext);
        for(Field=1; Field<=FieldCount; Field++) {

            SectionName = pSetupGetField(&SectionContext,Field);

            if (SetupFindFirstLine(CabInf,SectionName,TargetFilename,&Context)) {
                //
                // we found a match
                //
                if (SetupFindFirstLine(CabInf,TEXT("Cabs"),SectionName,&Context)) {
                    CabName= pSetupGetField(&Context,1);
                    //if (pIsDriverCachePresent(CabName,SubDirectory,TempBuffer)) {
                        *CacheName = DuplicateString( CabName );
                        if (*CacheName) {
                            return(TRUE);
                        }
                    //}
                }
            }
        } // end for

    } while (SetupFindNextMatchLine(&SectionContext,TEXT("CabFiles"),&SectionContext));

    return(FALSE);

}

BOOL
pIsFileInServicePackCache(
    IN  PCTSTR SourceFilename,
    IN  PCTSTR SubDirectory
    )
{
    TCHAR           TempBuffer[MAX_PATH];
    PTSTR           ActName;
    BOOL            Compressed;
    WIN32_FIND_DATA FindData;

    lstrcpyn(TempBuffer,ServicePackCachePath,MAX_PATH);
    if(SubDirectory) {
        if(!pSetupConcatenatePaths(TempBuffer,SubDirectory,MAX_PATH,NULL)) {
            return FALSE;
        }
    }
    if(!pSetupConcatenatePaths(TempBuffer,SourceFilename,MAX_PATH,NULL)) {
        return FALSE;
    }

    if(SetupDetermineSourceFileName(TempBuffer,&Compressed,&ActName,NULL)!=NO_ERROR) {
        return FALSE;
    }
    if(ActName) {
        MyFree(ActName);
        return TRUE;
    }
    return FALSE;
}

BOOL
pIsDriverCachePresent(
    IN     PCTSTR DriverName,
    IN     PCTSTR Subdirectory,
    IN OUT PTSTR DriverBuffer
    )
/*++

Routine Description:

    Looks at the proper location for the driver cache cab-file, and if it's
    present, return TRUE.  If present, it returns the partial path to the
    cab file

Arguments:

    DriveName    - the cab file we're looking for

    Subdirectory - if specified, use this as the subdirectory from the root of the driver
                   cache, otherwise use the specified architecture's subdirectory

    DriverBuffer - if the cab file is present, return the source root to the cab file


Return Value:

    TRUE if the cab file is present

--*/

{

    TCHAR TempBuffer[MAX_PATH];

    if (!DriverCacheSourcePath || !DriverName) {
        return FALSE;
    }

    if (!Subdirectory) {
        Subdirectory =
#if defined(_X86_)
         IsNEC98() ? TEXT("nec98") : TEXT("i386");
#elif defined(_IA64_)
         TEXT("ia64");
#elif defined(_AMD64_)
         TEXT("amd64");
#endif
    }

    lstrcpy(TempBuffer, DriverCacheSourcePath);
    pSetupConcatenatePaths(TempBuffer, Subdirectory , MAX_PATH, NULL);
    pSetupConcatenatePaths(TempBuffer, DriverName, MAX_PATH, NULL);

    if (FileExists(TempBuffer,NULL)) {
        lstrcpy(DriverBuffer,DriverCacheSourcePath);
        return(TRUE);
    }

    return(FALSE);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\setupapi\fileq4.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    fileq4.c

Abstract:

    Setup file queue routines for commit (ie, performing enqueued actions).

Author:

    Ted Miller (tedm) 15-Feb-1995

Revision History:

    Jamie Hunter (jamiehun) 28-Jan-1997

    Added backup queue capabilities
    backup on demand capabilities
    and unwind capabilities

--*/

#include "precomp.h"
#pragma hdrstop

#define LINK_START (TEXT("<A>"))
#define LINK_END (TEXT("</A>"))

typedef struct _Q_CAB_CB_DATA {

    PSP_FILE_QUEUE     Queue;
    PSOURCE_MEDIA_INFO SourceMedia;

    PSP_FILE_QUEUE_NODE CurrentFirstNode;

    PVOID              MsgHandler;
    PVOID              Context;
    BOOL               IsMsgHandlerNativeCharWidth;
    PSETUP_LOG_CONTEXT LogContext;

} Q_CAB_CB_DATA, *PQ_CAB_CB_DATA;

typedef struct _CERT_PROMPT {
    LPCTSTR lpszDescription;
    LPCTSTR lpszFile;
    SetupapiVerifyProblem ProblemType;
    ULONG DriverSigningPolicy;
} CERT_PROMPT, *PCERT_PROMPT;

typedef struct _AUTHENTICODE_CERT_PROMPT {
    LPCTSTR lpszDescription;
    HANDLE hWVTStateData;
    DWORD Error;
} AUTHENTICODE_CERT_PROMPT, *PAUTHENTICODE_CERT_PROMPT;

typedef struct _DRIVERBLOCK_PROMPT {
    LPCTSTR lpszFile;
    SDBENTRYINFO entryinfo;
} DRIVERBLOCK_PROMPT, *PDRIVERBLOCK_PROMPT;


DWORD
pSetupCommitSingleBackup(
    IN PSP_FILE_QUEUE    Queue,
    IN PCTSTR            FullTargetPath,
    IN LONG              TargetRootPath,
    IN LONG              TargetSubDir,
    IN LONG              TargetFilename,
    IN PVOID             MsgHandler,
    IN PVOID             Context,
    IN BOOL              IsMsgHandlerNativeCharWidth,
    IN BOOL              RenameExisting,
    OUT PBOOL            InUse
    );

DWORD
pCommitCopyQueue(
    IN PSP_FILE_QUEUE Queue,
    IN PVOID          MsgHandler,
    IN PVOID          Context,
    IN BOOL           IsMsgHandlerNativeCharWidth
    );

DWORD
pCommitBackupQueue(
    IN PSP_FILE_QUEUE Queue,
    IN PVOID          MsgHandler,
    IN PVOID          Context,
    IN BOOL           IsMsgHandlerNativeCharWidth
    );

DWORD
pCommitDeleteQueue(
    IN PSP_FILE_QUEUE Queue,
    IN PVOID          MsgHandler,
    IN PVOID          Context,
    IN BOOL           IsMsgHandlerNativeCharWidth
    );

DWORD
pCommitRenameQueue(
    IN PSP_FILE_QUEUE Queue,
    IN PVOID          MsgHandler,
    IN PVOID          Context,
    IN BOOL           IsMsgHandlerNativeCharWidth
    );

UINT
pSetupCabinetQueueCallback(
    IN PVOID Context,
    IN UINT  Notification,
    IN UINT_PTR  Param1,
    IN UINT_PTR  Param2
    );


DWORD
pSetupCopySingleQueuedFile(
    IN  PSP_FILE_QUEUE      Queue,
    IN  PSP_FILE_QUEUE_NODE QueueNode,
    IN  PCTSTR              FullSourceName,
    IN  PVOID               MsgHandler,
    IN  PVOID               Context,
    OUT PTSTR               NewSourcePath,
    IN  BOOL                IsMsgHandlerNativeCharWidth,
    IN  DWORD               CopyStyleFlags
    );

DWORD
pSetupCopySingleQueuedFileCabCase(
    IN  PSP_FILE_QUEUE      Queue,
    IN  PSP_FILE_QUEUE_NODE QueueNode,
    IN  PCTSTR              CabinetName,
    IN  PCTSTR              FullSourceName,
    IN  PVOID               MsgHandler,
    IN  PVOID               Context,
    IN  BOOL                IsMsgHandlerNativeCharWidth
    );

VOID
pSetupSetPathOverrides(
    IN     PVOID StringTable,
    IN OUT PTSTR RootPath,
    IN OUT PTSTR SubPath,
    IN     LONG  RootPathId,
    IN     LONG  SubPathId,
    IN     PTSTR NewPath
    );

VOID
pSetupBuildSourceForCopy(
    IN  PCTSTR              UserRoot,
    IN  PCTSTR              UserPath,
    IN  LONG                MediaRoot,
    IN  PSP_FILE_QUEUE      Queue,
    IN  PSP_FILE_QUEUE_NODE QueueNode,
    OUT PTSTR               FullPath
    );

INT_PTR
CALLBACK
CertifyDlgProc(
    IN HWND hwnd,
    IN UINT msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

INT_PTR
CALLBACK
AuthenticodeCertifyDlgProc(
    IN HWND hwnd,
    IN UINT msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

INT_PTR
CALLBACK
NoAuthenticodeCertifyDlgProc(
    IN HWND hwnd,
    IN UINT msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

INT_PTR
CALLBACK
DriverBlockDlgProc(
    IN HWND hwnd,
    IN UINT msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

VOID
RestoreBootReplacedFile(
    IN PSP_FILE_QUEUE      Queue,
    IN PSP_FILE_QUEUE_NODE QueueNode
    );

VOID
pSetupExemptFileFromProtection(
    IN  PCTSTR             FileName,
    IN  DWORD              FileChangeFlags,
    IN  PSETUP_LOG_CONTEXT LogContext,      OPTIONAL
    OUT PDWORD             QueueNodeFlags   OPTIONAL
    );

VOID
pSetupUninstallNewCatalogNodes(
    IN PSP_FILE_QUEUE     Queue,
    IN PSETUP_LOG_CONTEXT LogContext OPTIONAL
    );


BOOL
_SetupCommitFileQueue(
    IN HWND     Owner,         OPTIONAL
    IN HSPFILEQ QueueHandle,
    IN PVOID    MsgHandler,
    IN PVOID    Context,
    IN BOOL     IsMsgHandlerNativeCharWidth
    )

/*++

Routine Description:

    Implementation for SetupCommitFileQueue; handles ANSI and Unicode
    callback routines.

Arguments:

    Same as for SetupCommitFileQueue().

    IsMsgHandlerNativeCharWidth - indicates whether the MsgHandler callback
        expects native char width args (or ansi ones, in the unicode build
        of this dll).

Return Value:

    Boolean value indicating outcome.  If FALSE, the GetLastError() indicates
    cause of failure.

--*/

{
    PSP_FILE_QUEUE Queue;
    DWORD rc;
    BOOL Success = TRUE;
    BOOL ChangedThreadLogContext = FALSE;
    PSETUP_LOG_CONTEXT SavedLogContext = NULL;
    PSETUP_LOG_CONTEXT LogContext = NULL;

    //
    // Queue handle is actually a pointer to the queue structure.
    //
    Queue = (PSP_FILE_QUEUE)QueueHandle;

    //
    // do a quick handle validation before anything else
    //
    try {
        Success = ((Queue != NULL) && (Queue != INVALID_HANDLE_VALUE) && (Queue->Signature == SP_FILE_QUEUE_SIG));
        if (Success) {
            LogContext = Queue->LogContext;
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
        Success = FALSE;
    }
    if (!Success) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }
    //
    // If there's nothing to do, bail now. This prevents an empty
    // progress dialog from flashing on the screen. Don't return out
    // of the body of the try -- that is bad news performance-wise.
    //
    try {
        Success = (!Queue->DeleteNodeCount && !Queue->RenameNodeCount && !Queue->CopyNodeCount && !Queue->BackupNodeCount);
    } except (EXCEPTION_EXECUTE_HANDLER) {
        SetLastError(ERROR_INVALID_HANDLE);
        return(FALSE);
    }
    if(Success) {

        //
        // We are successful in that we had no file operations to do.  However,
        // we still need to validate the queued catalogs at this time, because
        // we always do validation in the context of file copying.  If we don't
        // do this, we have a hole where a device INF that doesn't copy files
        // (e.g., a modem INF) can circumvent driver signing checking.
        //
        WriteLogEntry(
            LogContext,
            SETUP_LOG_TIME,
            MSG_LOG_BEGIN_VERIFY3_CAT_TIME,
            NULL);       // text message

        rc = _SetupVerifyQueuedCatalogs(Owner,
                                        Queue,
                                        VERCAT_INSTALL_INF_AND_CAT,
                                        NULL,
                                        NULL
                                       );
        WriteLogEntry(
            LogContext,
            SETUP_LOG_TIME,
            MSG_LOG_END_VERIFY3_CAT_TIME,
            NULL);       // text message

        if (rc == NO_ERROR) {

            //
            // If we performed a backup and this is a device install then call
            // the pSetupCompleteBackup API to create the Reinstall instance
            // subkey and do other device rollback cleanup.
            //
            if (Queue->Flags & FQF_DEVICE_BACKUP) {

                pSetupCompleteBackup(Queue);
            }

            Queue->Flags |= FQF_QUEUE_ALREADY_COMMITTED;

        } else {
            //
            // Go uninstall any newly-copied INFs/PNFs/CATs.
            //
            pSetupUninstallNewCatalogNodes(Queue, LogContext);
        }

        SetLastError(rc);
        return(rc == NO_ERROR);
    }

    ASSERT_HEAP_IS_VALID();

    //
    // make a note of default logging context for duration of queue processing
    // this will catch, eg, INF being opened as part of a callback
    //
    MYASSERT(!ChangedThreadLogContext);
    ChangedThreadLogContext = SetThreadLogContext(LogContext,&SavedLogContext);
    if (ChangedThreadLogContext) {
        //
        // add one more ref to protext log context
        //
        RefLogContext(LogContext);
    }

    Success = pSetupCallMsgHandler(
            LogContext,
            MsgHandler,
            IsMsgHandlerNativeCharWidth,
            Context,
            SPFILENOTIFY_STARTQUEUE,
            (UINT_PTR)Owner,
            0
            );
    if(!Success) {
        rc = GetLastError();
        if(!rc) {
            rc = ERROR_OPERATION_ABORTED;
        }
        goto final;
    }

    try {
        //
        // Verify catalogs/infs.
        //
        WriteLogEntry(
            LogContext,
            SETUP_LOG_TIME,
            MSG_LOG_BEGIN_VERIFY2_CAT_TIME,
            NULL);       // text message

        rc = _SetupVerifyQueuedCatalogs(Owner,
                                        Queue,
                                        VERCAT_INSTALL_INF_AND_CAT,
                                        NULL,
                                        NULL
                                       );
        WriteLogEntry(
            LogContext,
            SETUP_LOG_TIME,
            MSG_LOG_END_VERIFY2_CAT_TIME,
            NULL);       // text message

        Success = (rc == NO_ERROR);

        if(rc != NO_ERROR) {
            goto Bail;
        }

        ASSERT_HEAP_IS_VALID();

        //
        // Handle backup first
        // don't commit if there's nothing to do
        //

        rc = Queue->BackupNodeCount
           ? pCommitBackupQueue(Queue,MsgHandler,Context,IsMsgHandlerNativeCharWidth)
           : NO_ERROR;

        Success = (rc == NO_ERROR);

        ASSERT_HEAP_IS_VALID();

        if (!Success) {
            goto Bail;
        }

        //
        // Handle deletes
        // now done after backups, but may incorporate a per-delete backup
        // don't commit if there's nothing to do
        //

        rc = Queue->DeleteNodeCount
           ? pCommitDeleteQueue(Queue,MsgHandler,Context,IsMsgHandlerNativeCharWidth)
           : NO_ERROR;

        Success = (rc == NO_ERROR);

        ASSERT_HEAP_IS_VALID();

        if (!Success) {
            goto Bail;
        }

        //
        // Handle renames next.
        // don't commit if there's nothing to do
        //

        rc = Queue->RenameNodeCount
           ? pCommitRenameQueue(Queue,MsgHandler,Context,IsMsgHandlerNativeCharWidth)
           : NO_ERROR;

        Success = (rc == NO_ERROR);

        ASSERT_HEAP_IS_VALID();

        if (!Success) {
            goto Bail;
        }

        //
        // Handle copies last. Don't bother calling the copy commit routine
        // if there are no files to copy.
        //
        rc = Queue->CopyNodeCount
           ? pCommitCopyQueue(Queue,MsgHandler,Context,IsMsgHandlerNativeCharWidth)
           : NO_ERROR;

        Success = (rc == NO_ERROR);

        ASSERT_HEAP_IS_VALID();

        if (!Success) {
            goto Bail;
        }

        rc = DoAllDelayedMoves(Queue);

        Success = (rc == NO_ERROR);

        if(Success) {
            //
            // Set a flag indicating we've committed the file queue (used to keep
            // us from attempting to prune the queue after having committed it).
            //
            Queue->Flags |= FQF_QUEUE_ALREADY_COMMITTED;
        }

        //
        // If we performed a backup and this is a device install then call
        // the pSetupCompleteBackup API to create the Reinstall instance
        // subkey and do other device rollback cleanup.
        //
        if (Queue->Flags & FQF_DEVICE_BACKUP) {

            pSetupCompleteBackup(Queue);
        }

    Bail:
        ;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Success = FALSE;
        rc = ERROR_INVALID_DATA;
    }

    pSetupCallMsgHandler(
        LogContext,
        MsgHandler,
        IsMsgHandlerNativeCharWidth,
        Context,
        SPFILENOTIFY_ENDQUEUE,
        Success,
        0
        );

    pSetupUnwindAll(Queue, Success);

final:

    //
    // If we didn't succeed, then uninstall any new INFs/PNFs/CATs we may have
    // installed.
    //
    if(!Success) {
        pSetupUninstallNewCatalogNodes(Queue, LogContext);
    }

    if (ChangedThreadLogContext) {
        //
        // restore thread log context
        //
        SetThreadLogContext(SavedLogContext,NULL);
        DeleteLogContext(LogContext); // counter RefLogContext
    }

    SetLastError(rc);

    return(Success);
}

//
// ANSI version. Also need undecorated (Unicode) version for compatibility
// with apps that were linked before we had A and W versions.
//
BOOL
SetupCommitFileQueueA(
    IN HWND                Owner,         OPTIONAL
    IN HSPFILEQ            QueueHandle,
    IN PSP_FILE_CALLBACK_A MsgHandler,
    IN PVOID               Context
    )
{
    return(_SetupCommitFileQueue(Owner,QueueHandle,MsgHandler,Context,FALSE));
}

#undef SetupCommitFileQueue
SetupCommitFileQueue(
    IN HWND                Owner,         OPTIONAL
    IN HSPFILEQ            QueueHandle,
    IN PSP_FILE_CALLBACK_W MsgHandler,
    IN PVOID               Context
    )
{
    return(_SetupCommitFileQueue(Owner,QueueHandle,MsgHandler,Context,TRUE));
}

BOOL
SetupCommitFileQueueW(
    IN HWND              Owner,         OPTIONAL
    IN HSPFILEQ          QueueHandle,
    IN PSP_FILE_CALLBACK MsgHandler,
    IN PVOID             Context
    )

/*++

Routine Description:

    Perform file operations enqueued on a setup file queue.

Arguments:

    OwnerWindow - if specified, supplies the window handle of a window
        that is to be used as the parent of any progress dialogs.

    QueueHandle - supplies a handle to a setup file queue, as returned
        by SetupOpenFileQueue.

    MsgHandler - Supplies a callback routine to be notified
        of various significant events in the queue processing.

    Context - Supplies a value that is passed to the MsgHandler
        callback function.

Return Value:

    Boolean value indicating outcome.

--*/

{
    return(_SetupCommitFileQueue(Owner,QueueHandle,MsgHandler,Context,TRUE));
}


DWORD
pCommitBackupQueue(
    IN PSP_FILE_QUEUE    Queue,
    IN PVOID             MsgHandler,
    IN PVOID             Context,
    IN BOOL              IsMsgHandlerNativeCharWidth
    )
/*++

Routine Description:

    Process the backup Queue
    Backup each file specified in the queue if it exists
    File is marked as backup
    Location of backup is recorded
    Files are not added to unwind queue here
    They get added to unwind queue the first time they are potentially modified

    See also pCommitDeleteQueue, pCommitRenameQueue and pCommitCopyQueue

Arguments:

    Queue - queue that contains the backup sub-queue

    MsgHandler - Supplies a callback routine to be notified
        of various significant events in the queue processing.

    Context - Supplies a value that is passed to the MsgHandler
        callback function.

    IsMsgHandlerNativeCharWidth - For Unicode/Ansi support

Return Value:

    DWORD indicating status or success

--*/
{
    PSP_FILE_QUEUE_NODE QueueNode,queueNode;
    UINT u;
    BOOL b;
    DWORD rc;
    PCTSTR FullTargetPath,FullBackupPath;
    FILEPATHS FilePaths;
    BOOL Skipped = FALSE;
    DWORD BackupFlags = SP_BACKUP_BACKUPPASS;

    MYASSERT(Queue->BackupNodeCount);

    b = pSetupCallMsgHandler(
            Queue->LogContext,
            MsgHandler,
            IsMsgHandlerNativeCharWidth,
            Context,
            SPFILENOTIFY_STARTSUBQUEUE,
            FILEOP_BACKUP,
            Queue->BackupNodeCount
            );

    if(!b) {
        rc = GetLastError();
        if(!rc) {
            rc = ERROR_OPERATION_ABORTED;
        }
        goto clean0;
    }
    for(QueueNode=Queue->BackupQueue; QueueNode; QueueNode=QueueNode->Next) {

        //
        // Form the full path of the file to be backed up
        //
        FullBackupPath = pSetupFormFullPath(
                            Queue->StringTable,
                            QueueNode->SourceRootPath,
                            QueueNode->SourcePath,
                            QueueNode->SourceFilename
                            );

        if(!FullBackupPath) {
            rc = ERROR_NOT_ENOUGH_MEMORY;
            goto clean0;
        }

        FullTargetPath = pSetupFormFullPath(
                            Queue->StringTable,
                            QueueNode->TargetDirectory,
                            QueueNode->TargetFilename,
                            -1
                            );

        if(!FullTargetPath) {
            MyFree(FullBackupPath);
            rc = ERROR_NOT_ENOUGH_MEMORY;
            goto clean0;
        }

        FilePaths.Source = FullTargetPath; // copying from
        FilePaths.Target = FullBackupPath; // copying to (backup)
        FilePaths.Win32Error = NO_ERROR;
        FilePaths.Flags = BackupFlags;

        Skipped = FALSE;

        //
        // Inform the callback that we are about to start a backup operation.
        //
        u = pSetupCallMsgHandler(
                Queue->LogContext,
                MsgHandler,
                IsMsgHandlerNativeCharWidth,
                Context,
                SPFILENOTIFY_STARTBACKUP,
                (UINT_PTR)&FilePaths,
                FILEOP_BACKUP
                );

        if(u == FILEOP_ABORT) {
            rc = GetLastError();
            if(!rc) {
                rc = ERROR_OPERATION_ABORTED;
            }
            MyFree(FullTargetPath);
            MyFree(FullBackupPath);
            goto clean0;
        }
        if(u == FILEOP_DOIT) {
            //
            // Attempt the backup. If it fails inform the callback,
            // which may decide to abort, retry. or skip the file.
            //
            //SetFileAttributes(FullTargetPath,FILE_ATTRIBUTE_NORMAL);

            do {
                rc = pSetupBackupFile((HSPFILEQ)Queue,
                    FullTargetPath,
                    FullBackupPath,
                    -1, // TargetID not known
                    QueueNode->TargetDirectory, // what to backup
                    -1, // Queue Node's don't maintain this intermediate path
                    QueueNode->TargetFilename,
                    QueueNode->SourceRootPath, // backup as...
                    QueueNode->SourcePath,
                    QueueNode->SourceFilename,
                    &b
                    );
                if (rc == NO_ERROR) {
                    if (b) {
                        // delayed (in use)

                        QueueNode->InternalFlags |= INUSE_IN_USE;
                        //
                        // Tell the callback.
                        //
                        FilePaths.Win32Error = NO_ERROR;
                        FilePaths.Flags = FILEOP_BACKUP;

                        pSetupCallMsgHandler(
                            Queue->LogContext,
                            MsgHandler,
                            IsMsgHandlerNativeCharWidth,
                            Context,
                            SPFILENOTIFY_FILEOPDELAYED,
                            (UINT_PTR)&FilePaths,
                            0
                            );
                    }
                } else {
                    FilePaths.Win32Error = rc;
                    FilePaths.Flags = BackupFlags;

                    u = pSetupCallMsgHandler(
                            Queue->LogContext,
                            MsgHandler,
                            IsMsgHandlerNativeCharWidth,
                            Context,
                            SPFILENOTIFY_BACKUPERROR,
                            (UINT_PTR)&FilePaths,
                            0
                            );

                    if(u == FILEOP_ABORT) {
                        rc = GetLastError();
                        if(!rc) {
                            rc = ERROR_OPERATION_ABORTED;
                        }
                        MyFree(FullTargetPath);
                        MyFree(FullBackupPath);
                        goto clean0;
                    }
                    if(u == FILEOP_SKIP) {
                        // we skipped the backup
                        Skipped = TRUE;
                        break;
                    }
                }
            } while(rc != NO_ERROR);
        } else {
            // we skipped the backup
            Skipped = TRUE;
            rc = NO_ERROR;
        }

        FilePaths.Win32Error = rc;
        FilePaths.Flags = BackupFlags;

        pSetupCallMsgHandler(
            Queue->LogContext,
            MsgHandler,
            IsMsgHandlerNativeCharWidth,
            Context,
            SPFILENOTIFY_ENDBACKUP,
            (UINT_PTR)&FilePaths,
            0
            );

        MyFree(FullTargetPath);
        MyFree(FullBackupPath);
    }

    pSetupCallMsgHandler(
        Queue->LogContext,
        MsgHandler,
        IsMsgHandlerNativeCharWidth,
        Context,
        SPFILENOTIFY_ENDSUBQUEUE,
        FILEOP_BACKUP,
        0
        );

    rc = NO_ERROR;

clean0:

    SetLastError(rc);

    return rc;
}

DWORD
pSetupCommitSingleBackup(
    IN PSP_FILE_QUEUE    Queue,
    IN PCTSTR            FullTargetPath,
    IN LONG              TargetRootPath,
    IN LONG              TargetSubDir,
    IN LONG              TargetFilename,
    IN PVOID             MsgHandler,
    IN PVOID             Context,
    IN BOOL              IsMsgHandlerNativeCharWidth,
    IN BOOL              RenameExisting,
    OUT PBOOL            InUse
    )
/*++

Routine Description:

    Check a single file that is potentially about to be modified

    If the target file doesn't exist, then this routine does nothing
    If the target file hasn't been backed up, back it up
    If the target file has been backed up, but is not on unwind queue,
        add to unwind queue

    The default target location of the backup is used, which is either
    into a backup directory tree, or a temporary backup location
    Location of backup is recorded

Arguments:

    Queue - queue that contains the backup sub-queue
    FullTargetPath - String giving target path, or NULL if not formed
    TargetRootPath - String ID giving RootPath, or -1 if not specified
    TargetSubDir   - String ID giving SubDir (relative to RootPath),
                     or -1 if not specified
    TargetFilename - String ID giving Filename, or -1 if not specified
    MsgHandler - Supplies a callback routine to be notified
        of various significant events in the queue processing.
    Context - Supplies a value that is passed to the MsgHandler
        callback function.
    IsMsgHandlerNativeCharWidth - For Unicode/Ansi support
    RenameExisting - Should existing file be renamed?
    InUse - if specified, set to indicate if file is in use or not
            This should never be the case

Return Value:

    DWORD indicating status or success

--*/
{
    UINT u;
    BOOL b;
    DWORD rc;
    DWORD rc2;
    FILEPATHS FilePaths;
    LONG TargetID;
    PTSTR TargetPathLocal = NULL;
    PSP_UNWIND_NODE UnwindNode = NULL;
    SP_TARGET_ENT TargetInfo;
    BOOL FileOfSameNameExists;
    BOOL DoBackup = TRUE;
    BOOL NeedUnwind = FALSE;
    BOOL Skipped = FALSE;
    WIN32_FILE_ATTRIBUTE_DATA FileAttribData;
    UINT OldMode;
    BOOL DoRename;
    DWORD BackupFlags = SP_BACKUP_DEMANDPASS;

    //
    // used in this function to init time field
    //
    static const FILETIME zeroTime = {
         0,0
    };

    OldMode = SetErrorMode(SEM_FAILCRITICALERRORS); // inhibit unexpected dialog boxes

    MYASSERT(Queue);

    if (FullTargetPath == NULL) {
        TargetPathLocal = pSetupFormFullPath(
                            Queue->StringTable,
                            TargetRootPath,
                            TargetSubDir,
                            TargetFilename);

        if(!TargetPathLocal) {
            rc = ERROR_NOT_ENOUGH_MEMORY;
            goto clean0;
        }

        FullTargetPath = TargetPathLocal;
    }

    FileOfSameNameExists = GetFileAttributesEx(FullTargetPath, GetFileExInfoStandard, &FileAttribData);

    if (!FileOfSameNameExists) {
        // file doesn't exist, so no need to backup
        rc = NO_ERROR;
        goto clean0;
    }

    rc = pSetupBackupGetTargetByPath((HSPFILEQ)Queue,
                                     NULL, // use Queue's string table
                                     FullTargetPath,
                                     TargetRootPath,
                                     TargetSubDir,
                                     TargetFilename,
                                     &TargetID,
                                     &TargetInfo
                                    );

    if (rc != NO_ERROR) {
        // failed for some strange reason
        goto clean0;

    }

    if (TargetInfo.InternalFlags & SP_TEFLG_INUSE) {
        //
        // was "inuse'd" before
        // we mark as still INUSE
        if (InUse != NULL) {
            *InUse = TRUE;
        }
        //
        // Don't consider this an error, unless we were supposed to rename the
        // existing file.
        //
        rc = RenameExisting ? ERROR_SHARING_VIOLATION : NO_ERROR;
        goto clean0;
    }

    if (TargetInfo.InternalFlags & SP_TEFLG_SKIPPED) {
        //
        // was skipped before
        // we can't rely on it now
        //
        rc = NO_ERROR;
        goto clean0;
    }

    //
    // If we've been asked to backup the existing file, then make sure the
    // SP_TEFLG_RENAMEEXISTING flag is set in the TargetInfo.  Also, figure out
    // if we've already done the rename.
    //
    if(RenameExisting &&
       !(TargetInfo.InternalFlags & SP_TEFLG_RENAMEEXISTING)) {
        //
        // We'd better not think we already renamed this file!
        //
        MYASSERT(!(TargetInfo.InternalFlags & SP_TEFLG_MOVED));

        TargetInfo.InternalFlags |= SP_TEFLG_RENAMEEXISTING;

        //
        // update internal info (this call should never fail)
        //
        pSetupBackupSetTargetByID((HSPFILEQ)Queue,
                                  TargetID,
                                  &TargetInfo
                                 );
    }

    //
    // Figure out whether we've been asked to rename the existing file to a
    // temp name in the same directory, but haven't yet done so.
    //
    DoRename = ((TargetInfo.InternalFlags & (SP_TEFLG_RENAMEEXISTING | SP_TEFLG_MOVED)) == SP_TEFLG_RENAMEEXISTING);

    if(TargetInfo.InternalFlags & SP_TEFLG_SAVED) {
        //
        // already backed up
        //
        DoBackup = FALSE;

        if((TargetInfo.InternalFlags & SP_TEFLG_UNWIND) && !DoRename) {
            //
            // already added to unwind queue, and we don't need to do a rename--
            // don't need to do anything at all
            //
            rc = NO_ERROR;
            goto clean0;
        }
        //
        // we don't need to backup
        // but we still need to add to unwind queue, rename the existing file,
        // or both.
        //
    }

    if(DoBackup) {
        BackupFlags |= SP_BACKUP_DEMANDPASS;
    }
    if(DoRename) {
        BackupFlags |= SP_BACKUP_BOOTFILE | SP_BACKUP_SPECIAL;
    }

    FilePaths.Source = FullTargetPath;  // what we are backing up
    FilePaths.Target = NULL;            // indicates an automatic backup
    FilePaths.Win32Error = NO_ERROR;
    FilePaths.Flags = BackupFlags;

    if (DoRename) {
        pSetupExemptFileFromProtection(
                    FullTargetPath,
                    SFC_ACTION_ADDED | SFC_ACTION_REMOVED | SFC_ACTION_MODIFIED
                    | SFC_ACTION_RENAMED_OLD_NAME |SFC_ACTION_RENAMED_NEW_NAME,
                    Queue->LogContext,
                    NULL
                    );
    }

    if (DoBackup && (Queue->Flags & FQF_BACKUP_AWARE)) {
        //
        // Inform the callback that we are about to start a backup operation.
        //
        u = pSetupCallMsgHandler(
                Queue->LogContext,
                MsgHandler,
                IsMsgHandlerNativeCharWidth,
                Context,
                SPFILENOTIFY_STARTBACKUP,
                (UINT_PTR)&FilePaths,
                FILEOP_BACKUP
                );
    } else {
        //
        // no backup, or not backup aware, assume a default
        //
        u = FILEOP_DOIT;
    }

    if(u == FILEOP_ABORT) {
        rc = GetLastError();
        if(!rc) {
            rc = ERROR_OPERATION_ABORTED;
        }
        goto clean0;
    }
    if((u == FILEOP_DOIT) || (BackupFlags & SP_BACKUP_SPECIAL)) {
        //
        // Attempt the backup. If it fails inform the callback,
        // which may decide to abort, retry. or skip the file.
        //
        //SetFileAttributes(FullTargetPath,FILE_ATTRIBUTE_NORMAL);

        //
        // Setup an unwind node, unless we already have one.
        //
        if(!(TargetInfo.InternalFlags & SP_TEFLG_UNWIND)) {

            UnwindNode = MyMalloc(sizeof(SP_UNWIND_NODE));
            if (UnwindNode == NULL) {
                rc = ERROR_NOT_ENOUGH_MEMORY;
                goto clean0;
            }
            UnwindNode->NextNode = Queue->UnwindQueue;
            UnwindNode->TargetID = TargetID;
            if (RetreiveFileSecurity( FullTargetPath, &(UnwindNode->SecurityDesc)) != NO_ERROR) {
                // failed, but not fatal
                UnwindNode->SecurityDesc = NULL;
            }
            if (GetSetFileTimestamp( FullTargetPath, &(UnwindNode->CreateTime),
                                                    &(UnwindNode->AccessTime),
                                                    &(UnwindNode->WriteTime),
                                                    FALSE) != NO_ERROR) {
                // failed, but not fatal
                UnwindNode->CreateTime = zeroTime;
                UnwindNode->AccessTime = zeroTime;
                UnwindNode->WriteTime = zeroTime;
            }
        }

        if (DoBackup || DoRename) {
            do {
                rc = pSetupBackupFile((HSPFILEQ)Queue,
                    FullTargetPath,     // since we know this, pass it
                    NULL,               // automatic destination
                    TargetID,           // we got this earlier
                    TargetRootPath,     // since we know this, pass it
                    TargetSubDir,
                    TargetFilename,
                    -1,                 // use the details from TargetID (or temp)
                    -1,
                    -1,
                    &b                  // in use (should always return FALSE)
                    );
                if (rc == NO_ERROR) {
                    if (InUse != NULL) {
                        *InUse = b;
                    }
                    if (b) {
                        //
                        // if file is in use, callback can decide what to do
                        //
                        if (Queue->Flags & FQF_BACKUP_AWARE) {
                            //
                            // Tell the callback.
                            //
                            FilePaths.Win32Error = ERROR_SHARING_VIOLATION;
                            FilePaths.Flags = BackupFlags;

                            if (Queue->Flags & FQF_BACKUP_AWARE) {
                                u = pSetupCallMsgHandler(
                                    Queue->LogContext,
                                    MsgHandler,
                                    IsMsgHandlerNativeCharWidth,
                                    Context,
                                    SPFILENOTIFY_BACKUPERROR,
                                    (UINT_PTR)&FilePaths,
                                    0
                                    );
                                if(u == FILEOP_ABORT) {
                                    rc = GetLastError();
                                    if(!rc) {
                                        rc = ERROR_OPERATION_ABORTED;
                                    }
                                    goto clean0;
                                }
                            } else {
                                rc = ERROR_OPERATION_ABORTED;
                                goto clean0;
                            }
                        }
                    } else {
                        //
                        // success!!!!!
                        // we would have to unwind this if setup fails
                        //
                        NeedUnwind = TRUE;
                    }
                } else {
                    FilePaths.Win32Error = rc;
                    FilePaths.Flags = BackupFlags;

                    if (Queue->Flags & FQF_BACKUP_AWARE) {
                        //
                        // inform about error
                        //
                        u = pSetupCallMsgHandler(
                                Queue->LogContext,
                                MsgHandler,
                                IsMsgHandlerNativeCharWidth,
                                Context,
                                SPFILENOTIFY_BACKUPERROR,
                                (UINT_PTR)&FilePaths,
                                0
                                );
                        if(u == FILEOP_ABORT) {
                            rc = GetLastError();
                            if(!rc) {
                                rc = ERROR_OPERATION_ABORTED;
                            }
                            goto clean0;
                        }
                    } else {
                        //
                        // if caller is not backup aware, abort
                        //
                        rc = ERROR_OPERATION_ABORTED;
                        goto clean0;
                    }

                    if(u == FILEOP_SKIP) {
                        //
                        // we skipped the backup
                        //
                        Skipped = TRUE;
                        break;
                    }
                }
            } while(rc != NO_ERROR);

        } else {
            //
            // didn't need to backup, only need to add to unwind queue
            //
            NeedUnwind = TRUE;
        }

    } else {
        //
        // we skipped the backup
        //
        Skipped = TRUE;
        rc = NO_ERROR;
    }

    if (DoBackup) {

        FilePaths.Win32Error = rc;

        if (Queue->Flags & FQF_BACKUP_AWARE) {
            //
            // report result only if backup aware
            //
            pSetupCallMsgHandler(
                Queue->LogContext,
                MsgHandler,
                IsMsgHandlerNativeCharWidth,
                Context,
                SPFILENOTIFY_ENDBACKUP,
                (UINT_PTR)&FilePaths,
                0
                );
        }
    }

    if (Skipped) {
        //
        // once we return, file may get overwritten or deleted
        // we have to save the fact it has been skipped once
        // so we always skip this file
        //
        if (pSetupBackupGetTargetByID((HSPFILEQ)Queue, TargetID, &TargetInfo) == NO_ERROR) {
            //
            // flag the file should always be skipped
            //
            TargetInfo.InternalFlags|=SP_TEFLG_SKIPPED;
            pSetupBackupSetTargetByID((HSPFILEQ)Queue, TargetID, &TargetInfo);
        }
    }
    else if (NeedUnwind) {
        //
        // We only want to add this to unwind queue
        //
        if (pSetupBackupGetTargetByID((HSPFILEQ)Queue, TargetID, &TargetInfo) == NO_ERROR) {
            if ((TargetInfo.InternalFlags&SP_TEFLG_UNWIND)==FALSE) {
                //
                // node needs to be added to unwind queue
                // we only ever do this once
                //
                Queue->UnwindQueue = UnwindNode;
                //
                // set to NULL so we don't clean it up later
                //
                UnwindNode = NULL;

                //
                // flag that we've added it to unwind queue
                // so we don't try and do it again later
                //
                TargetInfo.InternalFlags|=SP_TEFLG_UNWIND;

                pSetupBackupSetTargetByID((HSPFILEQ)Queue, TargetID, &TargetInfo);
            }

        }
    }


    rc = NO_ERROR;

clean0:

    if (UnwindNode != NULL) {
        //
        // we allocated, but didn't use this structure
        //
        if (UnwindNode->SecurityDesc != NULL) {
            MyFree(UnwindNode->SecurityDesc);
        }
        MyFree(UnwindNode);
    }
    if (TargetPathLocal != NULL) {
        MyFree(TargetPathLocal);
    }

    SetErrorMode(OldMode);

    SetLastError(rc);

    return rc;
}

DWORD
pCommitDeleteQueue(
    IN PSP_FILE_QUEUE    Queue,
    IN PVOID             MsgHandler,
    IN PVOID             Context,
    IN BOOL              IsMsgHandlerNativeCharWidth
    )
/*++

Routine Description:

    Process the delete Queue
    Delete each file specified in the queue
    Files are backed up before they are deleted (if not already backed up)

    See also pCommitBackupQueue, pCommitRenameQueue and pCommitCopyQueue

Arguments:

    Queue - queue that contains the delete sub-queue

    MsgHandler - Supplies a callback routine to be notified
        of various significant events in the queue processing.

    Context - Supplies a value that is passed to the MsgHandler
        callback function.

    IsMsgHandlerNativeCharWidth - For Unicode/Ansi support

Return Value:

    DWORD indicating status or success

--*/
{
    PSP_FILE_QUEUE_NODE QueueNode,queueNode;
    UINT u;
    BOOL b;
    DWORD rc;
    PCTSTR FullTargetPath;
    FILEPATHS FilePaths;
    BOOL BackupInUse = FALSE;
    BOOL TargetIsProtected;

    MYASSERT(Queue->DeleteNodeCount);

    b = pSetupCallMsgHandler(
            Queue->LogContext,
            MsgHandler,
            IsMsgHandlerNativeCharWidth,
            Context,
            SPFILENOTIFY_STARTSUBQUEUE,
            FILEOP_DELETE,
            Queue->DeleteNodeCount
            );

    if(!b) {
        rc = GetLastError();
        if(!rc) {
            rc = ERROR_OPERATION_ABORTED;
        }
        goto clean0;
    }

    for(QueueNode=Queue->DeleteQueue; QueueNode; QueueNode=QueueNode->Next) {

        //
        // Form the full path of the file to be deleted.
        //
        FullTargetPath = pSetupFormFullPath(
                            Queue->StringTable,
                            QueueNode->TargetDirectory,
                            QueueNode->TargetFilename,
                            -1
                            );

        if(!FullTargetPath) {
            rc = ERROR_NOT_ENOUGH_MEMORY;
            goto clean0;
        }

        //
        // Backup the file we're about to delete
        //
        if((rc=pSetupDoLastKnownGoodBackup(Queue,
                                           FullTargetPath,
                                           LASTGOOD_OPERATION_DELETE,
                                           NULL)) != NO_ERROR) {
            MyFree(FullTargetPath);
            goto clean0;
        }
        rc = pSetupCommitSingleBackup(Queue,
                                      FullTargetPath,
                                      QueueNode->TargetDirectory,
                                      -1,
                                      QueueNode->TargetFilename,
                                      MsgHandler,
                                      Context,
                                      IsMsgHandlerNativeCharWidth,
                                      FALSE,
                                      &BackupInUse
                                     );
        if (rc != NO_ERROR) {
            MyFree(FullTargetPath);
            goto clean0;
        }

        FilePaths.Source = NULL;
        FilePaths.Target = FullTargetPath;
        FilePaths.Win32Error = NO_ERROR;
        FilePaths.Flags = 0;

        //
        // Inform the callback that we are about to start a delete operation.
        //
        u = pSetupCallMsgHandler(
                Queue->LogContext,
                MsgHandler,
                IsMsgHandlerNativeCharWidth,
                Context,
                SPFILENOTIFY_STARTDELETE,
                (UINT_PTR)&FilePaths,
                FILEOP_DELETE
                );

        if(u == FILEOP_ABORT) {
            rc = GetLastError();
            if(!rc) {
                rc = ERROR_OPERATION_ABORTED;
            }
            MyFree(FullTargetPath);
            goto clean0;
        }
        if(u == FILEOP_DOIT) {
            //
            // Attempt the delete. If it fails inform the callback,
            // which may decide to abort, retry. or skip the file.
            //
            SetFileAttributes(FullTargetPath,FILE_ATTRIBUTE_NORMAL);

            do {
                if (BackupInUse) {
                    rc = ERROR_SHARING_VIOLATION;
                } else {
                    rc = DeleteFile(FullTargetPath) ? NO_ERROR : GetLastError();
                }
                if((rc == ERROR_ACCESS_DENIED)
                || (rc == ERROR_SHARING_VIOLATION)
                || (rc == ERROR_USER_MAPPED_FILE)) {
                    //
                    // The file is probably in use.
                    //
                    if(QueueNode->InternalFlags & IQF_DELAYED_DELETE_OK) {
                        //
                        // Inf wanted delete on next reboot.  Check to see if
                        // we're being asked to delete a protected system file.
                        // If so (and all the catalog nodes associated with the
                        // queue were OK), then we'll allow this to happen.
                        // Otherwise, we'll silently skip the deletion (and log
                        // it).
                        //
                        MYASSERT((Queue->Flags & FQF_DID_CATALOGS_OK) ||
                                 (Queue->Flags & FQF_DID_CATALOGS_FAILED));

                        if(Queue->Flags & FQF_DID_CATALOGS_OK) {

                            QueueNode->InternalFlags |= INUSE_IN_USE;

                            TargetIsProtected = IsFileProtected(FullTargetPath,
                                                                Queue->LogContext,
                                                                NULL
                                                               );

                            if(b = PostDelayedMove(Queue,
                                                   FullTargetPath,
                                                   NULL,
                                                   -1,
                                                   TargetIsProtected)) {
                                //
                                // Tell the callback.
                                //
                                FilePaths.Source = NULL;
                                FilePaths.Target = FullTargetPath;
                                FilePaths.Win32Error = NO_ERROR;
                                FilePaths.Flags = FILEOP_DELETE;

                                pSetupCallMsgHandler(
                                    Queue->LogContext,
                                    MsgHandler,
                                    IsMsgHandlerNativeCharWidth,
                                    Context,
                                    SPFILENOTIFY_FILEOPDELAYED,
                                    (UINT_PTR)&FilePaths,
                                    0
                                    );
                            }
                        } else {
                            //
                            // We're installing an unsigned package.  Skip the
                            // delayed delete operation, and generate a log
                            // entry about this.
                            //
                            WriteLogEntry(Queue->LogContext,
                                          SETUP_LOG_ERROR,
                                          MSG_LOG_DELAYED_DELETE_SKIPPED_FOR_SFC,
                                          NULL,
                                          FullTargetPath
                                         );
                        }

                    } else {
                        //
                        // Just skip this file.
                        //
                        b = TRUE;
                    }

                    rc = b ? NO_ERROR : GetLastError();

                    if(rc) {
                        WriteLogEntry(
                            Queue->LogContext,
                            SETUP_LOG_ERROR | SETUP_LOG_BUFFER,
                            MSG_LOG_DELAYDELETE_FILE_ERROR,
                            NULL,
                            FullTargetPath);
                        WriteLogError(Queue->LogContext,SETUP_LOG_ERROR,rc);
                    } else {
                        WriteLogEntry(
                            Queue->LogContext,
                            SETUP_LOG_INFO,
                            MSG_LOG_DELAYDELETED_FILE,
                            NULL,
                            FullTargetPath);
                    }

                } else if(rc) {
                    WriteLogEntry(
                        Queue->LogContext,
                        DEL_ERR_LOG_LEVEL(rc) | SETUP_LOG_BUFFER,
                        MSG_LOG_DELETE_FILE_ERROR,
                        NULL,
                        FullTargetPath);
                    WriteLogError(Queue->LogContext,DEL_ERR_LOG_LEVEL(rc),rc);
                } else {
                    WriteLogEntry(
                        Queue->LogContext,
                        SETUP_LOG_INFO,
                        MSG_LOG_DELETED_FILE,
                        NULL,
                        FullTargetPath);
                }

                if( rc == NO_ERROR )
                {
                    rc = pSetupCallSCE(
                            ST_SCE_DELETE,
                            FullTargetPath,
                            NULL,
                            NULL,
                            -1,
                            NULL
                            );
                    SetLastError( rc );
                }

                if(rc != NO_ERROR) {
                    FilePaths.Win32Error = rc;

                    u = pSetupCallMsgHandler(
                            Queue->LogContext,
                            MsgHandler,
                            IsMsgHandlerNativeCharWidth,
                            Context,
                            SPFILENOTIFY_DELETEERROR,
                            (UINT_PTR)&FilePaths,
                            0
                            );

                    if(u == FILEOP_ABORT) {
                        rc = GetLastError();
                        if(!rc) {
                            rc = ERROR_OPERATION_ABORTED;
                        }
                        MyFree(FullTargetPath);
                        goto clean0;
                    }
                    if(u == FILEOP_SKIP) {
                        break;
                    }
                }
            } while(rc != NO_ERROR);
        } else {
            rc = NO_ERROR;
        }

        FilePaths.Win32Error = rc;

        pSetupCallMsgHandler(
            Queue->LogContext,
            MsgHandler,
            IsMsgHandlerNativeCharWidth,
            Context,
            SPFILENOTIFY_ENDDELETE,
            (UINT_PTR)&FilePaths,
            0
            );

        MyFree(FullTargetPath);
    }

    pSetupCallMsgHandler(
        Queue->LogContext,
        MsgHandler,
        IsMsgHandlerNativeCharWidth,
        Context,
        SPFILENOTIFY_ENDSUBQUEUE,
        FILEOP_DELETE,
        0
        );

    rc = NO_ERROR;

clean0:
    SetLastError(rc);
    return rc;
}

DWORD
pCommitRenameQueue(
    IN PSP_FILE_QUEUE    Queue,
    IN PVOID             MsgHandler,
    IN PVOID             Context,
    IN BOOL              IsMsgHandlerNativeCharWidth
    )
/*++

Routine Description:

    Process the rename Queue
    Rename each file specified in the queue
    Files are backed up before they are renamed (if not already backed up)
    If the target exists, it is also backed up (if not already backed up)

    Performance: this can get optimized by treating the newly named files
                as a backup

    See also pCommitBackupQueue, pCommitDeleteQueue and pCommitCopyQueue

Arguments:

    Queue - queue that contains the rename sub-queue

    MsgHandler - Supplies a callback routine to be notified
        of various significant events in the queue processing.

    Context - Supplies a value that is passed to the MsgHandler
        callback function.

    IsMsgHandlerNativeCharWidth - For Unicode/Ansi support

Return Value:

    DWORD indicating status or success

--*/
{
    PSP_FILE_QUEUE_NODE QueueNode,queueNode;
    UINT u;
    BOOL b;
    DWORD rc;
    PCTSTR FullTargetPath;
    PCTSTR FullSourcePath;
    FILEPATHS FilePaths;
    BOOL BackupInUse = FALSE;
    BOOL TargetIsProtected;

    MYASSERT(Queue->RenameNodeCount);

    b = pSetupCallMsgHandler(
            Queue->LogContext,
            MsgHandler,
            IsMsgHandlerNativeCharWidth,
            Context,
            SPFILENOTIFY_STARTSUBQUEUE,
            FILEOP_RENAME,
            Queue->RenameNodeCount
            );

    if(!b) {
        rc = GetLastError();
        if(!rc) {
            rc = ERROR_OPERATION_ABORTED;
        }
        goto clean0;
    }
    for(QueueNode=Queue->RenameQueue; QueueNode; QueueNode=QueueNode->Next) {

        //
        // Form the full source path of the file to be renamed.
        //
        FullSourcePath = pSetupFormFullPath(
                            Queue->StringTable,
                            QueueNode->SourcePath,
                            QueueNode->SourceFilename,
                            -1
                            );

        if(!FullSourcePath) {
            rc = ERROR_NOT_ENOUGH_MEMORY;
            goto clean0;
        }

        //
        // Form the full target path of the file to be renamed.
        //
        FullTargetPath = pSetupFormFullPath(
                            Queue->StringTable,
                            QueueNode->TargetDirectory == -1 ? QueueNode->SourcePath : QueueNode->TargetDirectory,
                            QueueNode->TargetFilename,
                            -1
                            );

        if(!FullTargetPath) {
            MyFree(FullSourcePath);
            rc = ERROR_NOT_ENOUGH_MEMORY;
            goto clean0;
        }

        //
        // Backup the file we may be overwriting
        //
        if((rc=pSetupDoLastKnownGoodBackup(Queue,
                                           FullTargetPath,
                                           0,
                                           NULL)) != NO_ERROR) {
            MyFree(FullSourcePath);
            MyFree(FullTargetPath);
            goto clean0;
        }
        rc = pSetupCommitSingleBackup(Queue,
                                      FullTargetPath,
                                      QueueNode->TargetDirectory == -1 ? QueueNode->SourcePath : QueueNode->TargetDirectory,
                                      -1, // we don't use this
                                      QueueNode->TargetFilename,
                                      MsgHandler,
                                      Context,
                                      IsMsgHandlerNativeCharWidth,
                                      FALSE,
                                      &BackupInUse
                                     );
        if (rc != NO_ERROR) {
            MyFree(FullSourcePath);
            MyFree(FullTargetPath);
            goto clean0;
        }

        //
        // Backup the file we're about to rename
        //

        if((rc=pSetupDoLastKnownGoodBackup(Queue,
                                           FullSourcePath,
                                           LASTGOOD_OPERATION_DELETE,
                                           NULL)) != NO_ERROR) {
            MyFree(FullSourcePath);
            MyFree(FullTargetPath);
            goto clean0;
        }
        rc = pSetupCommitSingleBackup(Queue,
                                      FullSourcePath,
                                      QueueNode->SourcePath,
                                      -1, // we don't use this????
                                      QueueNode->SourceFilename,
                                      MsgHandler,
                                      Context,
                                      IsMsgHandlerNativeCharWidth,
                                      FALSE,
                                      &b
                                     );
        if (rc != NO_ERROR) {
            MyFree(FullSourcePath);
            MyFree(FullTargetPath);
            goto clean0;
        }
        if (b) {
            //
            // BackupInUse is the "OR" of the two backup In-Use flags
            //
            BackupInUse = TRUE;
        }

        FilePaths.Source = FullSourcePath;
        FilePaths.Target = FullTargetPath;
        FilePaths.Win32Error = NO_ERROR;

        //
        // Inform the callback that we are about to start a rename operation.
        //
        u = pSetupCallMsgHandler(
                Queue->LogContext,
                MsgHandler,
                IsMsgHandlerNativeCharWidth,
                Context,
                SPFILENOTIFY_STARTRENAME,
                (UINT_PTR)&FilePaths,
                FILEOP_RENAME
                );

        if(u == FILEOP_ABORT) {
            rc = GetLastError();
            if(!rc) {
                rc = ERROR_OPERATION_ABORTED;
            }
            MyFree(FullSourcePath);
            MyFree(FullTargetPath);
            goto clean0;
        }
        if(u == FILEOP_DOIT) {
            //
            // Attempt the rename. If it fails inform the callback,
            // which may decide to abort, retry. or skip the file.
            //
            do {
                if (BackupInUse) {
                    //
                    // backup is in use, must delay op.  Check to see if either
                    // the source or target files are protected system files.
                    // If so (and all the catalog nodes associated with the
                    // queue were OK), then we'll allos this to happen.
                    // Otherwise, we'll silently fail the rename (and log it).
                    //
                    MYASSERT((Queue->Flags & FQF_DID_CATALOGS_OK) ||
                             (Queue->Flags & FQF_DID_CATALOGS_FAILED));

                    if(Queue->Flags & FQF_DID_CATALOGS_OK) {

                        TargetIsProtected = IsFileProtected(FullSourcePath,
                                                            Queue->LogContext,
                                                            NULL
                                                           );
                        if(!TargetIsProtected) {
                            TargetIsProtected = IsFileProtected(FullTargetPath,
                                                                Queue->LogContext,
                                                                NULL
                                                               );
                        }

                        if(b = PostDelayedMove(Queue,
                                               FullSourcePath,
                                               FullTargetPath,
                                               -1,
                                               TargetIsProtected)) {
                            rc = NO_ERROR;
                        }
                        else
                        {
                            rc = GetLastError();
                        }
                        if(rc) {
                            WriteLogEntry(
                                Queue->LogContext,
                                DEL_ERR_LOG_LEVEL(rc) | SETUP_LOG_BUFFER,
                                MSG_LOG_DELAYRENAME_FILE_ERROR,
                                NULL,
                                FullSourcePath,
                                FullTargetPath);
                            WriteLogError(Queue->LogContext,DEL_ERR_LOG_LEVEL(rc),rc);
                        } else {
                            WriteLogEntry(
                                Queue->LogContext,
                                SETUP_LOG_INFO,
                                MSG_LOG_DELAYRENAMED_FILE,
                                NULL,
                                FullSourcePath,
                                FullTargetPath);
                        }

                    } else {
                        //
                        // We're installing an unsigned package.  Skip the
                        // delayed rename operation, and generate a log
                        // entry about this.
                        //
                        WriteLogEntry(Queue->LogContext,
                                      SETUP_LOG_ERROR,
                                      MSG_LOG_DELAYED_MOVE_SKIPPED_FOR_SFC,
                                      NULL,
                                      FullTargetPath
                                     );
                        //
                        // act as if no error occurred.
                        //
                        rc = NO_ERROR;
                    }

                } else {
                    rc = MoveFile(FullSourcePath,FullTargetPath) ? NO_ERROR : GetLastError();
                    if(rc) {
                        WriteLogEntry(
                            Queue->LogContext,
                            DEL_ERR_LOG_LEVEL(rc) | SETUP_LOG_BUFFER,
                            MSG_LOG_RENAME_FILE_ERROR,
                            NULL,
                            FullSourcePath,
                            FullTargetPath);
                        WriteLogError(Queue->LogContext,DEL_ERR_LOG_LEVEL(rc),rc);
                    } else {
                        WriteLogEntry(
                            Queue->LogContext,
                            SETUP_LOG_INFO,
                            MSG_LOG_RENAMED_FILE,
                            NULL,
                            FullSourcePath,
                            FullTargetPath);
                    }
                }

                if( rc == NO_ERROR )
                {
                    rc = pSetupCallSCE(
                            ST_SCE_RENAME,
                            FullSourcePath,
                            NULL,
                            FullTargetPath,
                            -1,
                            NULL
                            );
                    SetLastError( rc );
                }

                if((rc == ERROR_FILE_NOT_FOUND) || (rc == ERROR_PATH_NOT_FOUND)) {
                    rc = NO_ERROR;
                }

                if(rc != NO_ERROR) {
                    FilePaths.Win32Error = rc;

                    u = pSetupCallMsgHandler(
                            Queue->LogContext,
                            MsgHandler,
                            IsMsgHandlerNativeCharWidth,
                            Context,
                            SPFILENOTIFY_RENAMEERROR,
                            (UINT_PTR)&FilePaths,
                            0
                            );

                    if(u == FILEOP_ABORT) {
                        rc = GetLastError();
                        if(!rc) {
                            rc = ERROR_OPERATION_ABORTED;
                        }
                        MyFree(FullSourcePath);
                        MyFree(FullTargetPath);
                        goto clean0;
                    }
                    if(u == FILEOP_SKIP) {
                        break;
                    }
                }
            } while(rc != NO_ERROR);
        } else {
            rc = NO_ERROR;
        }

        FilePaths.Win32Error = rc;

        pSetupCallMsgHandler(
            Queue->LogContext,
            MsgHandler,
            IsMsgHandlerNativeCharWidth,
            Context,
            SPFILENOTIFY_ENDRENAME,
            (UINT_PTR)&FilePaths,
            0
            );

        MyFree(FullSourcePath);
        MyFree(FullTargetPath);
    }

    pSetupCallMsgHandler(
        Queue->LogContext,
        MsgHandler,
        IsMsgHandlerNativeCharWidth,
        Context,
        SPFILENOTIFY_ENDSUBQUEUE,
        FILEOP_RENAME,
        0
        );

    rc = NO_ERROR;

clean0:
    SetLastError(rc);
    return rc;
}

DWORD
pCommitCopyQueue(
    IN PSP_FILE_QUEUE    Queue,
    IN PVOID             MsgHandler,
    IN PVOID             Context,
    IN BOOL              IsMsgHandlerNativeCharWidth
    )
/*++

Routine Description:

    Process the copy sub-Queues
    Copy each file specified in the sub-queues
    Files are backed up before they are overwritten (if not already backed up)
    See also pCommitBackupQueue, pCommitDeleteQueue and pCommitRenameQueue

Arguments:

    Queue - queue that contains the copy sub-queues

    MsgHandler - Supplies a callback routine to be notified
        of various significant events in the queue processing.

    Context - Supplies a value that is passed to the MsgHandler
        callback function.

    IsMsgHandlerNativeCharWidth - For Unicode/Ansi support

Return Value:

    DWORD indicating status or success

--*/
{
    PSOURCE_MEDIA_INFO SourceMediaInfo;
    SOURCE_MEDIA SourceMedia;
    PTCHAR p, temp;
    UINT SourcePathLen;
    UINT u;
    DWORD rc;
    Q_CAB_CB_DATA QData;
    BOOL b;
    BOOL FirstIteration;
    PSP_FILE_QUEUE_NODE QueueNode,queueNode;
    TCHAR UserSourceRoot[MAX_PATH];
    TCHAR UserSourcePath[MAX_PATH];
    TCHAR FullSourcePath[MAX_PATH];
    TCHAR UserOverride[MAX_PATH];
    LPCTSTR RestorePath = NULL;
    UINT    DriveType;
    BOOL    IsRemovable, AnyProcessed, AnyNotProcessed, SkipMedia;
    BOOL  SpecialMedia = FALSE;
    BOOL  LocateCab;
    PCTSTR MediaRoot;
    DWORD MediaLogTag;
    LONG Cabfile;
    LONG Tagfile;

    //
    // The caller is supposed to skip calling us if there are no files
    // to be copied.
    //
    MYASSERT(Queue->CopyNodeCount);

    //
    // Inform the callback that we are starting.
    //
    b = pSetupCallMsgHandler(
            Queue->LogContext,
            MsgHandler,
            IsMsgHandlerNativeCharWidth,
            Context,
            SPFILENOTIFY_STARTSUBQUEUE,
            FILEOP_COPY,
            Queue->CopyNodeCount
            );

    if(!b) {
        rc = GetLastError();
        if(!rc) {
            rc = ERROR_OPERATION_ABORTED;
        }
       return(rc);
    }

    if(Queue->RestorePathID != -1) {
        RestorePath = pSetupStringTableStringFromId(Queue->StringTable, Queue->RestorePathID);
        DiskPromptGetDriveType(RestorePath, &DriveType, &IsRemovable);
        if(IsRemovable) {
            //
            // do not allow restore from removable media
            //
            RestorePath = NULL;
        }
    }

    //
    // Initially, no user-specified override path exists.
    //
    UserSourceRoot[0] = TEXT('\0');
    UserSourcePath[0] = TEXT('\0');

    //
    // The outermost loop iterates through all the source media descriptors.
    //
    for(SourceMediaInfo=Queue->SourceMediaList; SourceMediaInfo; SourceMediaInfo=SourceMediaInfo->Next) {

        //
        // If there are no files on this particular media, skip it.
        // Otherwise get pointer to queue node for first file on this media.
        //
        if(!SourceMediaInfo->CopyNodeCount) {
            continue;
        }
        MYASSERT(SourceMediaInfo->CopyQueue);

        //
        // if last media was special media (see long discussion above),
        // then forget about any user override
        //
        if (SpecialMedia) {
            UserSourceRoot[0] = TEXT('\0');
            UserSourcePath[0] = TEXT('\0');
            SpecialMedia = FALSE;
        }

        //
        // see if this media is special media
        //
        if (SourceMediaInfo->Flags & ( SMI_FLAG_USE_SVCPACK_SOURCE_ROOT_PATH |
                                       SMI_FLAG_USE_LOCAL_SPCACHE |
                                       SMI_FLAG_USE_LOCAL_SOURCE_CAB ) ) {
            SpecialMedia = TRUE;
        }

        //
        // If we're in restore-mode
        // we've been given a directory to restore from
        // ignore the media root, and use restore-point root
        // restore as many files as we can
        //
        // note, we check for file presence via FileExists
        // rather than trying to determine file name
        // since we'll always backup in uncompressed form
        // with same name as listed in [SourceDisksNames]
        //

        if(RestorePath) {
            //
            // Restore Symantics - prior to prompting for media, see
            // if we can restore backup
            //
            QueueNode = NULL;
            for(queueNode = SourceMediaInfo->CopyQueue;
                queueNode;
                queueNode=queueNode->Next) {

                pSetupBuildSourceForCopy(
                    RestorePath,
                    NULL,
                    SourceMediaInfo->SourceRootPath,
                    Queue,
                    queueNode,
                    FullSourcePath
                    );

                //
                // don't allow alternate sourcenames in this case
                //
                if(FileExists(FullSourcePath,NULL)) {
                    //
                    // backup exists, copy it
                    //
                    rc = pSetupCopySingleQueuedFile(
                            Queue,
                            queueNode,
                            FullSourcePath,
                            MsgHandler,
                            Context,
                            UserOverride,
                            IsMsgHandlerNativeCharWidth,
                            SP_COPY_ALREADYDECOMP // backup already decomp'd.
                            );
                    if(rc == NO_ERROR) {
                        //
                        // we restored this file through backup
                        // carry on to next file
                        //
                        queueNode->InternalFlags |= IQF_PROCESSED;
                        continue;
                    }
                    //
                    // we know backup existed so if this failed
                    // consider it major enough to abort restore
                    // (eg, file unsigned, user specified abort)
                    //
                    SetLastError(rc);
                    return(rc);
                }
                if(!QueueNode) {
                    //
                    // first problematic file
                    //
                    QueueNode = queueNode;
                }
            }
            if(!QueueNode) {
                //
                // we copied all files of this media from backup
                // carry on to next media
                //
                continue;
            }
        } else {
            //
            // not restoring, start at first file
            //
            QueueNode = SourceMediaInfo->CopyQueue;
        }


        //
        // We will need to prompt for media, which requires some preparation.
        // We need to get the first file in the queue for this media, because
        // its path is where we will expect to find it or its cabinet or tag
        // file.  If there is no tag file, then we will look for the file
        // itself.
        //

        FirstIteration = TRUE;
        SkipMedia = FALSE;
        LocateCab = FALSE;
        Tagfile = SourceMediaInfo->Tagfile;
        Cabfile = SourceMediaInfo->Cabfile;

RepromptMedia:
        //
        // The case where we have non-removeable media and the path was
        // previously overridden must be handled specially.  For example, we
        // could have files queued on the same source root but different
        // subdirs.  If the user changes the network location, for example,
        // we have to be careful or we'll ignore the change in subdirectories
        // as we move among the media.
        //
        // To work around this, we check on non-removable media to see if the
        // queue node we're presently working with is in a subdirectory.  If it
        // is, then we reset our UserSourcePath string.
        //
        // (andrewr)...I don't get this comment above.  The current code
        // iterates through each source media info structure, which doesn't include
        // subdirectory information, only source root path information.  If it
        // does, then the caller is doing something really wierd, since they
        // should be using the SourcePath to define subdirectories from one master
        // root.
        //
        // It appears that the reasoning behind the code below is as follows:
        //
        // The assumption is that if we have removable media and multiple source
        // paths, then we will have to swap media out of the drive.  We don't
        // override source root paths if we are dealing with removable media.
        // If the source root path is non removable, then all of the source media
        // is "tied together."  If the user overrides the source root path, then
        // we override subsequent fixed media source root paths.
        //
        // In the case of dealing with service pack source media or a local cab-file
        // drivers cache, the source media info for a queue will not be tied together,
        // even though we're dealing with fixed media.
        //
        // To reconcile the comments above and the reasoning it uses with the
        // contradiction that svc pack media imposes, we have 2 options:
        //
        // 1.  If we encounter flags that indicate one of our special cases, then don't
        //     use any user override for the new source media.  (or, put another way,
        //     if we know that the last media was actually one of these special media,
        //     then don't allow an override of the normal media.
        //
        // 2.  Introduce some sort of hueristic that determines if the prior source media
        //     and the current source media are similar.  If they are, then go ahead and
        //     use any user specified override, otherwise use the proper path.
        //
        //
        // For simplicities sake, I use approach 1 above.  This is made a little simpler
        // by following the following rule.  When adding source media to the media list,
        // insert special media (ie, has flags identifying the media as svc pack media)
        // at the head of the list, insert normal media after that.  By following this
        // approach we know that we can just "zero out" the user overrides for the special
        // media and we'll just do the right thing for the regular media.
        //
        // In the case where there is an explicit cab-file to use
        // then we ask the user to point to cab-file instead of source file (first iteration)
        //

        MediaRoot = *UserSourceRoot
                  ? UserSourceRoot
                  : pSetupStringTableStringFromId(Queue->StringTable, SourceMediaInfo->SourceRootPath);

        DiskPromptGetDriveType(MediaRoot, &DriveType, &IsRemovable);
        if(!IsRemovable && (QueueNode->SourcePath != -1)) {
            *UserSourcePath = TEXT('\0');
        }

        pSetupBuildSourceForCopy(
            UserSourceRoot,
            UserSourcePath,
            SourceMediaInfo->SourceRootPath,
            Queue,
            QueueNode,
            FullSourcePath
            );

        if (FirstIteration
            && (Tagfile != Cabfile)
            && (Cabfile != -1)) {

            MYASSERT(!SkipMedia);
            MYASSERT(!(SourceMediaInfo->Flags & SMI_FLAG_USE_LOCAL_SOURCE_CAB));

            //
            // build location of cab file
            //
            temp = _tcsrchr(FullSourcePath,TEXT('\\'));
            MYASSERT( temp );
            if(temp) {
                *(temp+1) = 0;
            } else {
                FullSourcePath[0] = 0;
            }


            //
            // obtain path of (potential) cab file
            //
            pSetupConcatenatePaths( FullSourcePath, pSetupStringTableStringFromId(Queue->StringTable,Cabfile), MAX_PATH, NULL );
            LocateCab = TRUE;

        } else {
            LocateCab = FALSE;
        }

        if((p = _tcsrchr(FullSourcePath,TEXT('\\')))!=NULL) {
            *p++ = TEXT('\0');
        } else {
            //
            // I'm being pedantic here, this should never happen
            //
            MYASSERT(p);
            p = FullSourcePath;
        }

        //
        // Now FullSourcePath has the path part and p has the file part
        // for the first file in the queue for this media (or explicit cab file)
        // Get the media in the drive by calling the callback function.
        //
        // Although it would be nice to not have to
        // call this callback if we know that we don't have to (there is media
        // where the caller said there should be (local media, media already in, etc.)
        // we do need to call this so that we afford the caller the luxury of
        // changing their mind one last time.
        //
        // the only exception to this rule is if we are using the local driver
        // cache cab-file.  In this case, we don't want the user to ever get
        // prompted for this file, so we skip any media prompting.  We know that
        // if we have media added that has this flag set, then the cab already exists
        // and we can just use it (otherwise we wouldn't have initialized it in the
        // first place, we'd just use the os source path!)
        //
        SourceMedia.Tagfile = (Tagfile != -1 && FirstIteration)
                            ?  pSetupStringTableStringFromId(
                                    Queue->StringTable,
                                    Tagfile
                                    )
                            : NULL;

        SourceMedia.Description = (SourceMediaInfo->Description != -1)
                                ? pSetupStringTableStringFromId(
                                        Queue->StringTable,
                                        SourceMediaInfo->DescriptionDisplayName
                                        )
                                : NULL;

        SourceMedia.SourcePath = FullSourcePath;
        SourceMedia.SourceFile = p;
        SourceMedia.Flags = (QueueNode->StyleFlags & (SP_COPY_NOSKIP | SP_COPY_WARNIFSKIP | SP_COPY_NOBROWSE));

        MediaLogTag = AllocLogInfoSlotOrLevel(Queue->LogContext,SETUP_LOG_INFO,FALSE);
        WriteLogEntry(
                    Queue->LogContext,
                    MediaLogTag,
                    MSG_LOG_NEEDMEDIA,
                    NULL,
                    SourceMedia.Tagfile ? SourceMedia.Tagfile : TEXT(""),
                    SourceMedia.Description ? SourceMedia.Description : TEXT(""),
                    SourceMedia.SourcePath ? SourceMedia.SourcePath : TEXT(""),
                    SourceMedia.SourceFile ? SourceMedia.SourceFile : TEXT(""),
                    SourceMedia.Flags
                    );

        if( SkipMedia || (FirstIteration && (SourceMediaInfo->Flags & SMI_FLAG_USE_LOCAL_SOURCE_CAB)) ) {
            u = FILEOP_DOIT;
            WriteLogEntry(
                        Queue->LogContext,
                        SETUP_LOG_VERBOSE,
                        MSG_LOG_NEEDMEDIA_AUTOSKIP,
                        NULL
                        );
        } else {
            u = pSetupCallMsgHandler(
                Queue->LogContext,
                MsgHandler,
                IsMsgHandlerNativeCharWidth,
                Context,
                SPFILENOTIFY_NEEDMEDIA,
                (UINT_PTR)&SourceMedia,
                (UINT_PTR)UserOverride
                );
        }


        if(u == FILEOP_ABORT) {
            rc = GetLastError();
            if(!rc) {
                rc = ERROR_OPERATION_ABORTED;
            }
            WriteLogEntry(
                        Queue->LogContext,
                        SETUP_LOG_ERROR|SETUP_LOG_BUFFER,
                        MSG_LOG_NEEDMEDIA_ABORT,
                        NULL);
            WriteLogError(Queue->LogContext,
                        SETUP_LOG_ERROR,
                        rc
                        );
            ReleaseLogInfoSlot(Queue->LogContext,MediaLogTag);
            MediaLogTag = 0;
            SetLastError(rc);
            return(rc);
        }
        if(u == FILEOP_SKIP) {
            //
            // If this file was a bootfile replacement, then we need to restore
            // the original file that was renamed to a temporary filename.
            //
            WriteLogEntry(
                        Queue->LogContext,
                        SETUP_LOG_WARNING,
                        MSG_LOG_NEEDMEDIA_SKIP,
                        NULL
                        );
            ReleaseLogInfoSlot(Queue->LogContext,MediaLogTag);
            MediaLogTag = 0;
            if(QueueNode->StyleFlags & SP_COPY_REPLACE_BOOT_FILE) {
                RestoreBootReplacedFile(Queue, QueueNode);
            }

            //
            // If there are more files on this media, then try another one.
            // Otherwise we're done with this media.
            //
            QueueNode->InternalFlags |= IQF_PROCESSED;
            for(QueueNode=QueueNode->Next; QueueNode; QueueNode=QueueNode->Next) {
                if(!(QueueNode->InternalFlags & IQF_PROCESSED)) {
                    FirstIteration = FALSE;
                    goto RepromptMedia;
                }
            }
            continue;
        }
        if(u == FILEOP_NEWPATH) {
            //
            // User gave us a new source path. See which parts of the new path
            // match the existing path/overrides we are using.
            //
            WriteLogEntry(
                        Queue->LogContext,
                        SETUP_LOG_INFO,
                        MSG_LOG_NEEDMEDIA_NEWPATH,
                        NULL,
                        UserOverride
                        );
            ReleaseLogInfoSlot(Queue->LogContext,MediaLogTag);
            MediaLogTag = 0;
            pSetupSetPathOverrides(
                        Queue->StringTable,
                        UserSourceRoot,
                        UserSourcePath,
                        SourceMediaInfo->SourceRootPath,
                        QueueNode->SourcePath,
                        UserOverride
                        );
        }
        //
        // logging specific stuff
        //
        if(MediaLogTag!=0) {
            //
            // we explicitly cleared MediaLogTag for each case we handled
            //
            if (u != FILEOP_DOIT) {
                WriteLogEntry(
                            Queue->LogContext,
                            SETUP_LOG_WARNING,
                            MSG_LOG_NEEDMEDIA_BADRESULT,
                            NULL,
                            u);
            }
            ReleaseLogInfoSlot(Queue->LogContext,MediaLogTag);
            MediaLogTag = 0;
        }

        //
        // If we get here, the media is now accessible.
        // Some or all of the files might be in a cabinet whose name is the tagfile.
        //
        // NOTE: Win95 used the tagfile field to be the cabinet name instead.
        // If present it is used as a tagfile of sorts. The absence of a tagfile
        // means the files are not in cabinets. For NT, we don't bother
        // with all of this but instead try to be a little smarter.
        //
        // Scan the media for all source files we expect to find on it.
        // If we find a file, process it. Later we hit the cabinet and only
        // process the files we didn't already find outside the cabinet.
        //
        // exception to this is "explicit cabinet"
        //
        if(LocateCab) {
            //
            // an explicit cabinet was specified
            // this is first iteration
            // we've gone through NEED_MEDIA to obtain disk for this cabinet
            // don't try to process files outside cabinet
            // we know there is at least one file not processed
            //
            b = TRUE;
            queueNode=QueueNode;
        } else {
            //
            // tagfile may also be a cabfile
            // but process all files outside the cabfile first
            //
            for(queueNode=QueueNode; queueNode; queueNode=queueNode->Next) {

                if(queueNode->InternalFlags & IQF_PROCESSED) {
                    //
                    // Already processed. Skip to next file.
                    //
                    continue;
                }

                pSetupBuildSourceForCopy(
                    UserSourceRoot,
                    UserSourcePath,
                    SourceMediaInfo->SourceRootPath,
                    Queue,
                    queueNode,
                    FullSourcePath
                    );

                rc = SetupDetermineSourceFileName(FullSourcePath,&b,&p,NULL);
                if(rc == NO_ERROR || SkipMedia) {
                    //
                    // Found the file outside a cabinet. Process it now.
                    //
                    if(rc == NO_ERROR) {
                        rc = pSetupCopySingleQueuedFile(
                                Queue,
                                queueNode,
                                p,
                                MsgHandler,
                                Context,
                                UserOverride,
                                IsMsgHandlerNativeCharWidth,
                                0
                                );
                        MyFree(p);
                    } else {
                        //
                        // We didn't find the source file, but we're going to try
                        // to copy it anyway since we've decided not to skip the
                        // prompt for media.
                        //
                        rc = pSetupCopySingleQueuedFile(
                                Queue,
                                queueNode,
                                FullSourcePath,
                                MsgHandler,
                                Context,
                                UserOverride,
                                IsMsgHandlerNativeCharWidth,
                                0
                                );
                    }

                    if(rc != NO_ERROR) {
                        return(rc);
                    }

                    //
                    // See if we have a new source path.
                    //
                    if(UserOverride[0]) {
                        pSetupSetPathOverrides(
                            Queue->StringTable,
                            UserSourceRoot,
                            UserSourcePath,
                            SourceMediaInfo->SourceRootPath,
                            queueNode->SourcePath,
                            UserOverride
                            );
                    }
                }
            }
            //
            // See if any files still need to be processed.
            //
            for(b=FALSE,queueNode=QueueNode; queueNode; queueNode=queueNode->Next) {
                if(!(queueNode->InternalFlags & IQF_PROCESSED)) {
                    b = TRUE;
                    break;
                }
            }
        }

        //
        // If any files still need to be processed and we have a potential
        // cabinet file, go try to extract them from a cabinet.
        //
        if(b && (Cabfile != -1) && FirstIteration) {

            pSetupBuildSourceForCopy(
                UserSourceRoot,
                UserSourcePath,
                SourceMediaInfo->SourceRootPath,
                Queue,
                queueNode,
                FullSourcePath
                );

            temp = _tcsrchr(FullSourcePath,TEXT('\\'));
            MYASSERT( temp );
            if(temp) {
                *(temp+1) = 0;
            }

            //
            // obtain path of (potential) cab file
            //
            pSetupConcatenatePaths( FullSourcePath, pSetupStringTableStringFromId(Queue->StringTable,Cabfile), MAX_PATH, NULL );

            if(DiamondIsCabinet(FullSourcePath)) {

                QData.Queue = Queue;
                QData.SourceMedia = SourceMediaInfo;
                QData.MsgHandler = MsgHandler;
                QData.IsMsgHandlerNativeCharWidth = IsMsgHandlerNativeCharWidth;
                QData.Context = Context;
                QData.LogContext = Queue->LogContext;

                rc = DiamondProcessCabinet(
                        FullSourcePath,
                        0,
                        pSetupCabinetQueueCallback,
                        &QData,
                        TRUE
                        );

                if(rc != NO_ERROR) {
                    return(rc);
                }

                //
                // Now reset the cabfile to indicate that there is no cabinet.
                // If we don't do this and there are still files that have not
                // been processed, we'll end up in an infinite loop -- the prompt
                // will come back successfully, and we'll just keep going around
                // and around looking through the cabinet, etc.
                //
                Cabfile = -1;
                Tagfile = -1; // for compatability
            }
        }

        //
        // If we get here and files *still* need to be processed,
        // assume the files are in a different directory somewhere
        // and start all over with this media.
        //
        FirstIteration = FALSE;
        DiskPromptGetDriveType(FullSourcePath, &DriveType, &IsRemovable);
        AnyProcessed = FALSE;
        AnyNotProcessed = FALSE;

        for(QueueNode = SourceMediaInfo->CopyQueue;
            QueueNode;
            QueueNode=QueueNode->Next) {

            if(IsRemovable) {
                if(!(QueueNode->InternalFlags & IQF_PROCESSED)) {
                    if(Tagfile != -1) {
                        SkipMedia = TRUE;
                    }
                    goto RepromptMedia;
                }
            } else { // Fixed media
                if(QueueNode->InternalFlags & IQF_PROCESSED) {
                    AnyProcessed = TRUE;
                } else {
                    AnyNotProcessed = TRUE;
                }
            }
        }

        if(!IsRemovable) {
            if(AnyNotProcessed) {

                //
                // If some of the files are present on fixed media, we don't
                // want to look elsewhere.
                //
                if(AnyProcessed) {
                    SkipMedia = TRUE;
                }

                //
                // Find the first unprocessed file
                //
                for(QueueNode = SourceMediaInfo->CopyQueue;
                    QueueNode;
                    QueueNode = QueueNode->Next) {

                    if(!(QueueNode->InternalFlags & IQF_PROCESSED)) {
                        break;
                    }
                }
                MYASSERT(QueueNode);

                goto RepromptMedia;
            }
        }

    } // end for each source media info

    //
    // Tell handler we're done with the copy queue and return.
    //
    pSetupCallMsgHandler(
        Queue->LogContext,
        MsgHandler,
        IsMsgHandlerNativeCharWidth,
        Context,
        SPFILENOTIFY_ENDSUBQUEUE,
        FILEOP_COPY,
        0
        );

    return(NO_ERROR);
}


VOID
pSetupBuildSourceForCopy(
    IN  PCTSTR              UserRoot,
    IN  PCTSTR              UserPath,
    IN  LONG                MediaRoot,
    IN  PSP_FILE_QUEUE      Queue,
    IN  PSP_FILE_QUEUE_NODE QueueNode,
    OUT PTSTR               FullPath
    )
{
    PCTSTR p;


    //
    // If there is a user-specified override root path, use that instead of
    // the root path specified in the source media descriptor.
    //
    MYASSERT(Queue);
    MYASSERT(QueueNode);
    MYASSERT(FullPath);

    p = (UserRoot && UserRoot[0])
      ? UserRoot
      : pSetupStringTableStringFromId(Queue->StringTable,MediaRoot);


    lstrcpyn(FullPath,p,MAX_PATH);

    //
    // If there is a user-specified override path, use that instead of any
    // path specified in the copy node.
    //
    if(UserPath && UserPath[0]) {
        p = UserPath;
    } else {
        if(QueueNode->SourcePath == -1) {
            p = NULL;
        } else {
            p = pSetupStringTableStringFromId(Queue->StringTable,QueueNode->SourcePath);
        }
    }

    if(p) {
        pSetupConcatenatePaths(FullPath,p,MAX_PATH,NULL);
    }

    //
    // Fetch the filename and append.
    //
    p = pSetupStringTableStringFromId(Queue->StringTable,QueueNode->SourceFilename),
    pSetupConcatenatePaths(FullPath,p,MAX_PATH,NULL);

}

VOID
pSetupSetPathOverrides(
    IN     PVOID StringTable,
    IN OUT PTSTR RootPath,
    IN OUT PTSTR SubPath,
    IN     LONG  RootPathId,
    IN     LONG  SubPathId,
    IN     PTSTR NewPath
    )
{
    PCTSTR root,path;
    UINT u,l;

    //
    // See if the existing root override or root path is a prefix
    // of the path the user gave us.
    //
    MYASSERT(RootPath);
    MYASSERT(SubPath);
    root = RootPath[0] ? RootPath : pSetupStringTableStringFromId(StringTable,RootPathId);
    u = lstrlen(root);

    path = SubPath[0]
         ? SubPath
         : ((SubPathId == -1) ? NULL : pSetupStringTableStringFromId(StringTable,SubPathId));

    if(path && (*path == TEXT('\\'))) {
        path++;
    }

    if(_tcsnicmp(NewPath,root,u)) {
        //
        // Root path does not match what we're currently using, ie, the user
        // supplied a new path. In this case, we will see if the currently in-use
        // subpath matches the suffix of the new path, and if so, we'll assume
        // that is the override subpath and shorten the override root path.
        //
        lstrcpy(RootPath,NewPath);
        if(path) {
            u = lstrlen(NewPath);
            l = lstrlen(path);

            if((u > l) && (NewPath[(u-l)-1] == TEXT('\\')) && !lstrcmpi(NewPath+u-l,path)) {
                //
                // Subpath tail matches. Truncate the root override and
                // leave the subpath override alone.
                //
                RootPath[(u-l)-1] = 0;
            } else {
                //
                // In this case, we need to indicate an override subpath of the root,
                // or else all subsequent accesses will still try to append the subpath
                // specified in the copy node, which is not what we want.
                //
                SubPath[0] = TEXT('\\');
                SubPath[1] = 0;
            }
        }
    } else {
        //
        // Root path matches what we are currently using.
        //
        // See if the tail of the user-specified path matches the existing
        // subpath. If not, then use the rest of the root path as the subpath
        // override. If the tail matches, then extend the user override root.
        //
        // Examples:
        //
        //  File was queued with root = f:\, subpath = \amd64
        //
        //  User override path is f:\amd64
        //
        //  The new status will be leave override root alone;
        //  override subpath = \amd64
        //
        //  File was queued with root = \\foo\bar, subpath = \i386
        //
        //  User override path is \\foo\bar\new\i386
        //
        //  The new status will be a root override of \\foo\bar\new;
        //  no override subpath.
        //
        NewPath += u;
        if(*NewPath == TEXT('\\')) {
            NewPath++;
        }

        if(path) {
            u = lstrlen(NewPath);
            l = lstrlen(path);

            if((u >= l) && !lstrcmpi(NewPath+u-l,path)) {
                //
                // Change root override and indicate no override subpath.
                //
                SubPath[0] = TEXT('\0');
                NewPath[u-l] = TEXT('\0');
                lstrcpy(RootPath,root);
                pSetupConcatenatePaths(RootPath,NewPath,MAX_PATH,NULL);
                u = lstrlen(RootPath);
                if(u && (*CharPrev(RootPath,RootPath+u) == TEXT('\\'))) {
                    RootPath[u-1] = TEXT('\0'); // valid to do if last char is '\'
                }
            } else {
                //
                // Leave override root alone but change subpath.
                //
                lstrcpy(SubPath,NewPath);
                if(!SubPath[0]) {
                    SubPath[0] = TEXT('\\');
                    SubPath[1] = TEXT('\0');
                }
            }
        } else {
            //
            // File was queued without a subpath. If there's a subpath
            // in what the user gave us, use it as the override.
            //
            if(*NewPath) {
                lstrcpy(SubPath,NewPath);
            }
        }
    }
}


UINT
pSetupCabinetQueueCallback(
    IN PVOID Context,
    IN UINT  Notification,
    IN UINT_PTR  Param1,
    IN UINT_PTR  Param2
    )
{
    UINT rc;
    PCABINET_INFO CabinetInfo;
    PFILE_IN_CABINET_INFO FileInfo;
    TCHAR TempPath[MAX_PATH];
    PTSTR CabinetFile;
    PTSTR QueuedFile;
    PTSTR FilePart1,FilePart2;
    PTSTR FullTargetPath;
    PFILEPATHS FilePaths;
    PSP_FILE_QUEUE_NODE QueueNode,FirstNode,LastNode;
    PQ_CAB_CB_DATA QData;
    UINT h;
    SOURCE_MEDIA SourceMedia;
    DWORD status;

    QData = (PQ_CAB_CB_DATA)Context;

    switch(Notification) {

    case SPFILENOTIFY_CABINETINFO:
        //
        // We don't do anything with this.
        //
        rc = NO_ERROR;
        break;

    case SPFILENOTIFY_FILEINCABINET:
        //
        // New file within a cabinet.
        //
        // Determine whether we want to copy this file.
        // The context we get has all the stuff we need in it
        // to make this determination.
        //
        // Note that the queue could contain multiple copy operations
        // involving this file, but we only want to extract it once!
        //
        FileInfo = (PFILE_IN_CABINET_INFO)Param1;
        CabinetFile = (PTSTR)Param2;

        if(FilePart1 = _tcsrchr(FileInfo->NameInCabinet,TEXT('\\'))) {
            FilePart1++;
        } else {
            FilePart1 = (PTSTR)FileInfo->NameInCabinet;
        }

        rc = FILEOP_SKIP;
        FileInfo->Win32Error = NO_ERROR;
        FirstNode = NULL;

        //
        // Find ALL instances of this file in the queue and mark them.
        //
        for(QueueNode=QData->SourceMedia->CopyQueue; QueueNode; QueueNode=QueueNode->Next) {

            if(QueueNode->InternalFlags & IQF_PROCESSED) {
                //
                // This file was already processed. Ignore it.
                //
                continue;
            }

            //
            // Check the filename in the cabinet against the file
            // in the media's copy queue.
            //
            QueuedFile = pSetupStringTableStringFromId(
                            QData->Queue->StringTable,
                            QueueNode->SourceFilename
                            );

            if(FilePart2 = _tcsrchr(QueuedFile,TEXT('\\'))) {
                FilePart2++;
            } else {
                FilePart2 = QueuedFile;
            }

            if(!lstrcmpi(FilePart1,FilePart2)) {
                //
                // We want this file.
                //
                rc = FILEOP_DOIT;
                QueueNode->InternalFlags |= IQF_PROCESSED | IQF_MATCH;
                if(!FirstNode) {
                    FirstNode = QueueNode;
                }
                LastNode = QueueNode;
            }
        }

        if(rc == FILEOP_DOIT) {
            //
            // We want this file. Tell the caller the full target pathname
            // to be used, which is a temporary file in the directory
            // where the first instance of the file will ultimately go.
            // We do this so we can call SetupInstallFile later (perhaps
            // multiple times), which will handle version checks, etc.
            //
            // Before attempting to create a temp file make sure the path exists.
            //
            lstrcpyn(
                TempPath,
                pSetupStringTableStringFromId(QData->Queue->StringTable,FirstNode->TargetDirectory),
                MAX_PATH
                );
            pSetupConcatenatePaths(TempPath,TEXT("x"),MAX_PATH,NULL); // last component ignored
            status = pSetupMakeSurePathExists(TempPath);
            if(status == NO_ERROR) {
                LastNode->InternalFlags |= IQF_LAST_MATCH;
                if(GetTempFileName(
                        pSetupStringTableStringFromId(QData->Queue->StringTable,FirstNode->TargetDirectory),
                        TEXT("SETP"),
                        0,
                        FileInfo->FullTargetName
                        )) {
                    QData->CurrentFirstNode = FirstNode;
                } else {
                    status = GetLastError();
                    if(status == ERROR_ACCESS_DENIED) {
                        FileInfo->Win32Error = ERROR_INVALID_TARGET;
                    } else {
                        FileInfo->Win32Error = status;
                    }
                    rc = FILEOP_ABORT;
                    SetLastError(FileInfo->Win32Error);
                }
            } else {
                if(status == ERROR_ACCESS_DENIED) {
                    FileInfo->Win32Error = ERROR_INVALID_TARGET;
                } else {
                    FileInfo->Win32Error = status;
                }
                rc = FILEOP_ABORT;
                SetLastError(FileInfo->Win32Error);
            }
        }

        break;

    case SPFILENOTIFY_FILEEXTRACTED:

        FilePaths = (PFILEPATHS)Param1;
        //
        // The current file was extracted. If this was successful,
        // then we need to call SetupInstallFile on it to perform version
        // checks and move it into its final location or locations.
        //
        // The .Source member of FilePaths is the cabinet file.
        //
        // The .Target member is the name of the temporary file, which is
        // very useful, as it is the name if the file to use as the source
        // in copy operations.
        //
        // Process each file in the queue that we care about.
        //
        if((rc = FilePaths->Win32Error) == NO_ERROR) {

            for(QueueNode=QData->CurrentFirstNode; QueueNode && (rc==NO_ERROR); QueueNode=QueueNode->Next) {
                //
                // If we don't care about this file, skip it.
                //
                if(!(QueueNode->InternalFlags & IQF_MATCH)) {
                    continue;
                }

                QueueNode->InternalFlags &= ~IQF_MATCH;


                rc = pSetupCopySingleQueuedFileCabCase(
                        QData->Queue,
                        QueueNode,
                        FilePaths->Source,
                        FilePaths->Target,
                        QData->MsgHandler,
                        QData->Context,
                        QData->IsMsgHandlerNativeCharWidth
                        );

                //
                // If this was the last file that matched, break out.
                //
                if(QueueNode->InternalFlags & IQF_LAST_MATCH) {
                    QueueNode->InternalFlags &= ~IQF_LAST_MATCH;
                    break;
                }
            }
        }

        //
        // Delete the temporary file we extracted -- we don't need it any more.
        //
        DeleteFile(FilePaths->Target);

        break;

    case SPFILENOTIFY_NEEDNEWCABINET:
        //
        // Need a new cabinet.
        //
        CabinetInfo = (PCABINET_INFO)Param1;

        SourceMedia.Tagfile = NULL;
        SourceMedia.Description = CabinetInfo->DiskName;
        SourceMedia.SourcePath = CabinetInfo->CabinetPath;
        SourceMedia.SourceFile = CabinetInfo->CabinetFile;
        SourceMedia.Flags = SP_FLAG_CABINETCONTINUATION | SP_COPY_NOSKIP;

        h = pSetupCallMsgHandler(
                QData->LogContext,
                QData->MsgHandler,
                QData->IsMsgHandlerNativeCharWidth,
                QData->Context,
                SPFILENOTIFY_NEEDMEDIA,
                (UINT_PTR)&SourceMedia,
                Param2
                );

        switch(h) {

        case FILEOP_NEWPATH:
        case FILEOP_DOIT:
            rc = NO_ERROR;
            break;

        case FILEOP_ABORT:
            rc = GetLastError();
            if(!rc) {
                rc = ERROR_OPERATION_ABORTED;
            }
            break;

        default:
            rc = ERROR_OPERATION_ABORTED;
            break;

        }
        //
        // in this case, rc is a status code
        // but also set it as last error
        //
        SetLastError(rc);
        break;

    default:
        MYASSERT(0);
        rc = 0; // indeterminate
    }

    return(rc);
}


DWORD
pSetupCopySingleQueuedFile(
    IN  PSP_FILE_QUEUE      Queue,
    IN  PSP_FILE_QUEUE_NODE QueueNode,
    IN  PCTSTR              FullSourceName,
    IN  PVOID               MsgHandler,
    IN  PVOID               Context,
    OUT PTSTR               NewSourcePath,
    IN  BOOL                IsMsgHandlerNativeCharWidth,
    IN  DWORD               CopyStyleFlags
    )
{
    PTSTR FullTargetName;
    FILEPATHS FilePaths;
    UINT u;
    BOOL InUse;
    TCHAR source[MAX_PATH],PathBuffer[MAX_PATH];
    DWORD rc;
    BOOL b;
    BOOL BackupInUse = FALSE;
    BOOL SignatureVerifyFailed;

    NewSourcePath[0] = 0;
    PathBuffer[0] = 0;

    QueueNode->InternalFlags |= IQF_PROCESSED;

    //
    // Form the full target path of the file.
    //
    FullTargetName = pSetupFormFullPath(
                        Queue->StringTable,
                        QueueNode->TargetDirectory,
                        QueueNode->TargetFilename,
                        -1
                        );

    if(!FullTargetName) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    lstrcpyn(source,FullSourceName,MAX_PATH);

    //
    // check if we need to backup before we copy
    //
    if((rc=pSetupDoLastKnownGoodBackup(Queue,
                                       FullTargetName,
                                       0,
                                       NULL)) != NO_ERROR) {
        MyFree(FullTargetName);
        goto clean0;
    }
    rc = pSetupCommitSingleBackup(Queue,
                                  FullTargetName,
                                  QueueNode->TargetDirectory,
                                  -1,
                                  QueueNode->TargetFilename,
                                  MsgHandler,
                                  Context,
                                  IsMsgHandlerNativeCharWidth,
                                  (QueueNode->StyleFlags & SP_COPY_REPLACE_BOOT_FILE),
                                  &BackupInUse
                                 );
    if (rc != NO_ERROR) {
        MyFree(FullTargetName);
        goto clean0;
    }

    if (BackupInUse) {
        //
        // if we couldn't do backup, force the IN_USE flag
        //
        QueueNode->StyleFlags |= SP_COPY_FORCE_IN_USE;

    }

    do {
        //
        // Form the full source name.
        //
        FilePaths.Source = source;
        FilePaths.Target = FullTargetName;
        FilePaths.Win32Error = NO_ERROR;

        //
        // Also, pass the callback routine the CopyStyle flags we're about to
        // use.
        //
        // Callback flags are read-only.
        //
        FilePaths.Flags = QueueNode->StyleFlags;

        //
        // Notify the callback that the copy is starting.
        //
        u = pSetupCallMsgHandler(
                Queue->LogContext,
                MsgHandler,
                IsMsgHandlerNativeCharWidth,
                Context,
                SPFILENOTIFY_STARTCOPY,
                (UINT_PTR)&FilePaths,
                FILEOP_COPY
                );

        if(u == FILEOP_ABORT) {
            rc = GetLastError();
            if(!rc) {
                rc = ERROR_OPERATION_ABORTED;
            }
            WriteLogEntry(
                        Queue->LogContext,
                        SETUP_LOG_ERROR|SETUP_LOG_BUFFER,
                        MSG_LOG_STARTCOPY_ABORT,
                        NULL);
            WriteLogError(Queue->LogContext,
                        SETUP_LOG_ERROR,
                        rc);
            break;
        }

        if(u == FILEOP_DOIT) {

            //
            // Attempt the copy.
            //
            //

            b = _SetupInstallFileEx(
                    Queue,
                    QueueNode,
                    NULL,                   // no inf handle
                    NULL,                   // no inf context
                    source,
                    NULL,                   // source path root is part of FullSourcePath
                    FullTargetName,
                    QueueNode->StyleFlags | SP_COPY_SOURCE_ABSOLUTE | CopyStyleFlags,
                    MsgHandler,
                    Context,
                    &InUse,
                    IsMsgHandlerNativeCharWidth,
                    &SignatureVerifyFailed
                    );

            rc = b ? NO_ERROR : GetLastError();

            if(b || (rc == NO_ERROR)) {
                if(!InUse && (QueueNode->SecurityDesc != -1)){
                    //
                    // Set security on the file
                    //
                    rc = pSetupCallSCE(ST_SCE_SET,
                                       FullTargetName,
                                       Queue,
                                       NULL,
                                       QueueNode->SecurityDesc,
                                       NULL
                                      );
                }
            }
            
            if(rc == NO_ERROR) {
                //
                // File was copied or not copied, but it if was not copied
                // the callback funtcion was already notified about why
                // (version check failed, etc).
                //
                if(QueueNode->StyleFlags & SP_COPY_REPLACE_BOOT_FILE) {
                    //
                    // _SetupInstallFileEx is responsible for failing the copy
                    // when some yahoo comes and copies over a new file (and
                    // locks it) before we get a chance to.
                    //
                    MYASSERT(!InUse);

                    //
                    // If the file was copied, we need to set the wants-reboot
                    // flag.  Otherwise, we need to put back the original file.
                    //
                    if(b) {
                        QueueNode->InternalFlags |= INUSE_INF_WANTS_REBOOT;
                    } else {
                        RestoreBootReplacedFile(Queue, QueueNode);
                    }

                } else {

                    if(InUse) {
                        QueueNode->InternalFlags |= (QueueNode->StyleFlags & SP_COPY_IN_USE_NEEDS_REBOOT)
                                                  ? INUSE_INF_WANTS_REBOOT
                                                  : INUSE_IN_USE;
                    }
                }

            } else {
                DWORD LogTag = 0;
                //
                // File was not copied and a real error occurred.
                // Notify the callback (unless the failure was due to a 
                // signature verification problem). Disallow skip if that is 
                // specified in the node's flags.
                //
                if(SignatureVerifyFailed) {
                    break;
                } else {
                    LogTag = AllocLogInfoSlotOrLevel(Queue->LogContext,SETUP_LOG_INFO,FALSE);

                    FilePaths.Win32Error = rc;
                    FilePaths.Flags = QueueNode->StyleFlags & (SP_COPY_NOSKIP | SP_COPY_WARNIFSKIP | SP_COPY_NOBROWSE);

                    WriteLogEntry(
                                Queue->LogContext,
                                LogTag,
                                MSG_LOG_COPYERROR,
                                NULL,
                                FilePaths.Source,
                                FilePaths.Target,
                                FilePaths.Flags,
                                FilePaths.Win32Error
                                );

                    u = pSetupCallMsgHandler(
                            Queue->LogContext,
                            MsgHandler,
                            IsMsgHandlerNativeCharWidth,
                            Context,
                            SPFILENOTIFY_COPYERROR,
                            (UINT_PTR)&FilePaths,
                            (UINT_PTR)PathBuffer
                            );
                    if(u == FILEOP_ABORT) {
                        rc = GetLastError();
                        if(!rc) {
                            rc = ERROR_OPERATION_ABORTED;
                        }
                    }
                }

                if(u == FILEOP_ABORT) {
                    WriteLogEntry(
                                Queue->LogContext,
                                SETUP_LOG_ERROR|SETUP_LOG_BUFFER,
                                MSG_LOG_COPYERROR_ABORT,
                                NULL
                                );
                    WriteLogError(Queue->LogContext,
                                SETUP_LOG_ERROR,
                                rc
                                );
                    ReleaseLogInfoSlot(Queue->LogContext,LogTag);
                    LogTag = 0;

                    break;
                } else {
                    if(u == FILEOP_SKIP) {
                        //
                        // If this file was a bootfile replacement, then we need
                        // to restore the original file that was renamed to a
                        // temporary filename.
                        //
                        if(QueueNode->StyleFlags & SP_COPY_REPLACE_BOOT_FILE) {
                            RestoreBootReplacedFile(Queue, QueueNode);
                        }

                        WriteLogEntry(
                                    Queue->LogContext,
                                    SETUP_LOG_WARNING,
                                    MSG_LOG_COPYERROR_SKIP,
                                    NULL
                                    );
                        ReleaseLogInfoSlot(Queue->LogContext,LogTag);
                        LogTag = 0;
                        //
                        // Force termination of processing for this file.
                        //
                        rc = NO_ERROR;
                        break;

                    } else {
                        if((u == FILEOP_NEWPATH) || ((u == FILEOP_RETRY) && PathBuffer[0])) {
                            WriteLogEntry(
                                        Queue->LogContext,
                                        SETUP_LOG_WARNING,
                                        MSG_LOG_COPYERROR_NEWPATH,
                                        NULL,
                                        u,
                                        PathBuffer
                                        );
                            ReleaseLogInfoSlot(Queue->LogContext,LogTag);
                            LogTag = 0;

                            //
                            // Note that rc is already set to something other than
                            // NO_ERROR or we wouldn't be here.
                            //
                            lstrcpyn(NewSourcePath,PathBuffer,MAX_PATH);
                            lstrcpyn(source,NewSourcePath,MAX_PATH);
                            pSetupConcatenatePaths(
                                source,
                                pSetupStringTableStringFromId(Queue->StringTable,QueueNode->SourceFilename),
                                MAX_PATH,
                                NULL
                                );
                        }

                        //
                        // Else we don't have a new path.
                        // Just keep using the one we had.
                        //
                    }
                }
                if (LogTag != 0) {
                    //
                    // haven't done anything regards logging yet, do it now
                    //
                    WriteLogEntry(
                                Queue->LogContext,
                                SETUP_LOG_INFO,
                                MSG_LOG_COPYERROR_RETRY,
                                NULL,
                                u
                                );
                    ReleaseLogInfoSlot(Queue->LogContext,LogTag);
                    LogTag = 0;
                }
            }
        } else {
            //
            // skip file
            //
            WriteLogEntry(
                        Queue->LogContext,
                        SETUP_LOG_INFO, // info level as this would be due to override of callback
                        MSG_LOG_STARTCOPY_SKIP,
                        NULL,
                        u
                        );
            rc = NO_ERROR;
        }
    } while(rc != NO_ERROR);

    //
    // Notify the callback that the copy is done.
    //
    FilePaths.Win32Error = rc;
    pSetupCallMsgHandler(
        Queue->LogContext,
        MsgHandler,
        IsMsgHandlerNativeCharWidth,
        Context,
        SPFILENOTIFY_ENDCOPY,
        (UINT_PTR)&FilePaths,
        0
        );


    MyFree(FullTargetName);

clean0:

    return(rc);
}


DWORD
pSetupCopySingleQueuedFileCabCase(
    IN  PSP_FILE_QUEUE      Queue,
    IN  PSP_FILE_QUEUE_NODE QueueNode,
    IN  PCTSTR              CabinetName,
    IN  PCTSTR              FullSourceName,
    IN  PVOID               MsgHandler,
    IN  PVOID               Context,
    IN  BOOL                IsMsgHandlerNativeCharWidth
    )
{
    PTSTR FullTargetName;
    FILEPATHS FilePaths;
    UINT u;
    BOOL InUse;
    TCHAR PathBuffer[MAX_PATH];
    DWORD rc;
    BOOL b;
    BOOL BackupInUse = FALSE;
    BOOL DontCare;
    DWORD LogTag = 0;
    LPCTSTR SourceName;

    //
    // Form the full target path of the file.
    //
    SourceName = pSetupStringTableStringFromId(Queue->StringTable,QueueNode->SourceFilename);
    FullTargetName = pSetupFormFullPath(
                        Queue->StringTable,
                        QueueNode->TargetDirectory,
                        QueueNode->TargetFilename,
                        -1
                        );

    if(!FullTargetName) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }


    LogTag = AllocLogInfoSlotOrLevel(Queue->LogContext,SETUP_LOG_INFO,FALSE);
    WriteLogEntry(
                Queue->LogContext,
                LogTag,
                MSG_LOG_COPY_FROM_CAB,
                NULL,
                CabinetName,
                SourceName,
                FullSourceName,
                FullTargetName
                );

    //
    // check if we need to backup before we copy
    //
    if((rc=pSetupDoLastKnownGoodBackup(Queue,
                                       FullTargetName,
                                       0,
                                       NULL)) != NO_ERROR) {
        MyFree(FullTargetName);
        goto clean0;
    }
    rc = pSetupCommitSingleBackup(Queue,
                                  FullTargetName,
                                  QueueNode->TargetDirectory,
                                  -1,
                                  QueueNode->TargetFilename,
                                  MsgHandler,
                                  Context,
                                  IsMsgHandlerNativeCharWidth,
                                  (QueueNode->StyleFlags & SP_COPY_REPLACE_BOOT_FILE),
                                  &BackupInUse
                                 );
    if (rc != NO_ERROR) {
        MyFree(FullTargetName);
        goto clean0;
    }

    if (BackupInUse) {
        //
        // if we couldn't do backup, force the IN_USE flag
        //
        QueueNode->StyleFlags |= SP_COPY_FORCE_IN_USE;

    }
    //
    // We use the cabinet name as the source name so the display looks right
    // to the user. Otherwise he sees the name of some temp file in the
    // source field.
    //
    FilePaths.Source = CabinetName;
    FilePaths.Target = FullTargetName;
    FilePaths.Win32Error = NO_ERROR;

    //
    // Also, pass the callback routine the CopyStyle flags we're about to
    // use.
    //
    // Callback flags are read-only.
    //
    FilePaths.Flags = QueueNode->StyleFlags;

    do {
        //
        // Notify the callback that the copy is starting.
        //
        u = pSetupCallMsgHandler(
                Queue->LogContext,
                MsgHandler,
                IsMsgHandlerNativeCharWidth,
                Context,
                SPFILENOTIFY_STARTCOPY,
                (UINT_PTR)&FilePaths,
                FILEOP_COPY
                );

        if(u == FILEOP_ABORT) {
            rc = GetLastError();
            if(!rc) {
                rc = ERROR_OPERATION_ABORTED;
            }
            break;
        }

        if(u == FILEOP_DOIT) {
            //
            // Attempt the copy.
            //
            b = _SetupInstallFileEx(
                    Queue,
                    QueueNode,
                    NULL,                   // no inf handle
                    NULL,                   // no inf context
                    FullSourceName,
                    NULL,                   // source path root is part of FullSourcePath
                    FullTargetName,
                    QueueNode->StyleFlags | SP_COPY_SOURCE_ABSOLUTE,
                    MsgHandler,
                    Context,
                    &InUse,
                    IsMsgHandlerNativeCharWidth,
                    &DontCare
                    );

            if(b || ((rc = GetLastError()) == NO_ERROR)) {
                if(!InUse && (QueueNode->SecurityDesc != -1) ){
                    // Set security on the file

                    rc = pSetupCallSCE(
                            ST_SCE_SET,
                            FullTargetName,
                            Queue,
                            NULL,
                            QueueNode->SecurityDesc,
                            NULL
                            );
                    SetLastError( rc );
                }

            }

            if(b || ((rc = GetLastError()) == NO_ERROR)) {
                //
                // File was copied or not copied, but it if was not copied
                // the callback funtcion was already notified about why
                // (version check failed, etc).
                //
                if(InUse) {
                    QueueNode->InternalFlags |= (QueueNode->StyleFlags & SP_COPY_IN_USE_NEEDS_REBOOT)
                                              ? INUSE_INF_WANTS_REBOOT
                                              : INUSE_IN_USE;
                }
                rc = NO_ERROR;
            } else {
                //
                // File was not copied and a real error occurred.
                // Break out and return the error.
                //
                break;
            }
        } else {
            //
            // skip file
            //
            rc = NO_ERROR;
        }
    } while(rc != NO_ERROR);

    //
    // Notify the callback that the copy is done.
    //
    FilePaths.Win32Error = rc;
    pSetupCallMsgHandler(
        Queue->LogContext,
        MsgHandler,
        IsMsgHandlerNativeCharWidth,
        Context,
        SPFILENOTIFY_ENDCOPY,
        (UINT_PTR)&FilePaths,
        0
        );

    MyFree(FullTargetName);

clean0:
    if(LogTag) {
        ReleaseLogInfoSlot(Queue->LogContext,LogTag);
    }

    return(rc);
}


PTSTR
pSetupFormFullPath(
    IN PVOID  StringTable,
    IN LONG   PathPart1,
    IN LONG   PathPart2,    OPTIONAL
    IN LONG   PathPart3     OPTIONAL
    )

/*++

Routine Description:

    Form a full path based on components whose strings are in a string
    table.

Arguments:

    StringTable - supplies handle to string table.

    PathPart1 - Supplies first part of path

    PathPart2 - if specified, supplies second part of path

    PathPart3 - if specified, supplies third part of path

Return Value:

    Pointer to buffer containing full path. Caller can free with MyFree().
    NULL if out of memory.

--*/

{
    UINT RequiredSize;
    PCTSTR p1,p2,p3;
    TCHAR Buffer[MAX_PATH];

    p1 = pSetupStringTableStringFromId(StringTable,PathPart1);
    if (!p1) {
        return NULL;
    }
    p2 = (PathPart2 == -1) ? NULL : pSetupStringTableStringFromId(StringTable,PathPart2);
    p3 = (PathPart3 == -1) ? NULL : pSetupStringTableStringFromId(StringTable,PathPart3);

    lstrcpy(Buffer,p1);
    if(!p2 || pSetupConcatenatePaths(Buffer,p2,MAX_PATH,NULL)) {
        if(p3) {
            pSetupConcatenatePaths(Buffer,p3,MAX_PATH,NULL);
        }
    }

    return(DuplicateString(Buffer));
}


DWORD
pSetupVerifyQueuedCatalogs(
    IN HSPFILEQ FileQueue
    )
/*++

Routine Description:

    Silently verify all catalog nodes in the specified queue.

Arguments:

    FileQueue - supplies a handle to the file queue containing catalog nodes
        to be verified.

Return Value:

    If all catalog nodes are valid, the return value is NO_ERROR.  Otherwise,
    it is a Win32 error code indicating the problem.

--*/
{
    return _SetupVerifyQueuedCatalogs(NULL,  // No UI, thus no HWND needed
                                      (PSP_FILE_QUEUE)FileQueue,
                                      VERCAT_NO_PROMPT_ON_ERROR,
                                      NULL,
                                      NULL
                                     );
}


DWORD
_SetupVerifyQueuedCatalogs(
    IN  HWND           Owner,
    IN  PSP_FILE_QUEUE Queue,
    IN  DWORD          Flags,
    OUT PTSTR          DeviceInfFinalName,  OPTIONAL
    OUT PBOOL          DeviceInfNewlyCopied OPTIONAL
    )

/*++

Routine Description:

    This routine verifies catalogs and infs in a given queue by traversing
    the catalog node list associated with the queue and operating on the
    catalog/inf pair described by each one.

    If any catalog/inf fails verification, the user is notified via a dialog,
    depending on current policy.

    ** Behavior for native platform verification (w/o catalog override)

    If an INF is from a system location, we assume that the catalog is
    already installed on the system. Really there is no other option here,
    since we would have no idea where to get the catalog in order to install it
    even if we wanted to try. But the inf might have originally been an
    oem inf which was copied and renamed by the Di stuff at device install
    time. The catalog file knows nothing about the renamed file, so we must
    track mappings from current inf filename to original inf filename.

    In this case, we calculate the inf's hash value and then using that,
    we ask the system for a catalog file that contains signing data
    for that hash value. We then ask the system for info
    about that catalog file. We keep repeating this process until we get
    at the catalog we want (based on name). Finally we can call WinVerifyTrust
    verify the catalog itself and the inf.

    If an INF file is instead from an oem location, we copy the oem inf to a
    unique name in the system inf directory (or create a zero-length placeholder
    there, depending on whether or not the VERCAT_INSTALL_INF_AND_CAT flag is
    set), and add the catalog using a filename based on that unique filename.

    ** Behavior for non-native platform verification (w/o catalog override) **

    We will validate the catalogs and INFs using the alternate platform info
    provided in the file queue.  Otherwise, the logic is the same as in the
    native case.

    ** Behavior for verification (w/catalog override) **

    The actual verification will be done using native or non-native parameters
    as discussed above, but INFs without a CatalogFile= entry will be validated
    against the specified overriding catalog.  This means that system INFs won't
    get validated globally, and INF in OEM locations can be validated even if
    they don't have a CatalogFile= entry.  The overriding catalog file will be
    installed under its current name, thus blowing away any existing catalog
    having that name.

    ** Behavior for verification via Authenticode catalog **
    
    If the specified queue has the DRIVERSIGN_ALLOW_AUTHENTICODE bit set in its
    driver signing policy, then we'll allow catalogs to be signed via
    Authenticode, instead of our default (requiring MS cert chain and OS code-
    signing usage OID).
    
    Here's the algorithm for how we'll do digital signature verification for a
    self-contained driver package:
    
    * Check for WHQL signature on driver package INF using corresponding CAT.
        * If valid WHQL signature - Install Driver (no UI)
        * If invalid or no WHQL signature - log an entry to setupapi.log, check
          if there's a WHQL program for this device setup class (list of 
          classes in %windir%\Inf\certclas.inf)
            * If yes - check driver signing policy
                * If Block - terminate installation
                * If Warn - issue warning, install driver (customer option)
                * If Ignore - install driver (no UI)
            * If no - check for Authenticode (TM) signature on driver package
              INF using corresponding CAT.  (signature must chain up through an 
              existing root certificate)
                * If valid Authenticode signature - check for matching signing 
                  certificate in Authenticode certificate store
                    * If Authenticode signing certificate installed, install 
                      driver (no UI)
                    * If Authenticode signing certificate not installed, check 
                      driver signing policy
                        * If Block - terminate installation (Authenticode 
                          signature does not allow vendors to by-pass Block 
                          policy)
                        * If Warn - issue warning (but indicate that package is 
                          signed by vendor), install driver (customer option)
                        * If Ignore - install driver (no UI)
                * If invalid or no Authenticode signature, check driver signing 
                  policy
                    * If Block, terminate installation
                    * If Warn, issue warning (indicating package's author/
                      integrity cannot be established), install driver 
                      (customer option)
                    * If Ignore, install driver (no UI)
    
    See the documentation on SetupSetFileQueueAlternatePlatform for more
    details.

Arguments:

    Owner - supplies window handle of window to own any ui.  This HWND is stored
        away in the queue for use later if any individual files fail verification.

    Queue - supplies pointer to queue structure.

    Flags - supplies flags that control behavior of this routine.

        VERCAT_INSTALL_INF_AND_CAT - if this flag is set, any infs from
            oem locations will be installed on the system, along with
            their catalog files.

        VERCAT_NO_PROMPT_ON_ERROR - if this flag is set, the user will _not_ be
            notified about verification failures we encounter.  If this flag is
            set, then this was only a 'test', and no user prompting should take
            place (nor should any PSS logging take place).  If this flag is set,
            then the VERCAT_INSTALL_INF_AND_CAT _should not_ be specified.

        VERCAT_PRIMARY_DEVICE_INF_FROM_INET - specifies that the primary device
            INF in the queue is from the internet, and should be marked as such
            in the corresponding PNF when installed into the %windir%\Inf
            directory via _SetupCopyOEMInf.

    DeviceInfFinalName - optionally, supplies the address of a character buffer,
        _at least_ MAX_PATH characters long, that upon success receives the
        final name given to the INF under the %windir%\Inf directory (this will
        be different than the INF's original name if it was an OEM INF).

    DeviceInfNewlyCopied - optionally, supplies the address of a boolean
        variable that, upon success, is set to indicate whether the INF name
        returned in DeviceInfFinalName was newly-created.  If this parameter is
        supplied, then DeviceInfFinalName must also be specified.

Return Value:

    If all catalogs/infs were verified and installed, or the user accepted
        the risk if a verification failed, then the return value is NO_ERROR.

    If one or more catalogs/infs were not verified, the return value is a Win32
        error code indicating the cause of the failure.  NOTE:  This error will
        only be returned if the policy is "block", or it it's "warn" and the
        user decided to abort.  In this case, the error returned is for the
        catalog/INF where the error was encountered, and any subsequent catalog
        nodes will not have been verified.  An exception to this is when the
        VERCAT_NO_PROMPT_ON_ERROR flag is set.  In that case, we'll verify all
        catalogs, even if we encounter improperly-signed ones.

Remarks:

    There are some system INFs (for which global verification is required) that
    don't live in %windir%\Inf.  The OCM INFs are an example of this.  Those
    INFs use layout.inf (which _is_ located in %windir%\Inf) for the source
    media information for any files they copy.  There are other INFs that don't
    live in %windir%\Inf which are extracted out of a binary as-needed (into a
    temporary filename), processed in order to do registry munging, and then
    deleted.  Such INFs do not do file copying (thus their 'package' consists
    of just the INF).  To accommodate such INFs, we allow "OEM" INFs (i.e.,
    those INFs not in %windir%\Inf) to be verified globally, but we remember the
    fact that these INFs didn't contain a CatalogFile= entry, and if any files
    are ever queued for copy using such INFs for source media information, then
    we'll fail digital signature verification for such files, since there's no
    way for us to know what catalog should be used for verification.

--*/

{
    PSPQ_CATALOG_INFO CatalogNode;
    LPCTSTR InfFullPath;
    LPCTSTR CatName;
    TCHAR PathBuffer[MAX_PATH];
    TCHAR InfNameBuffer[MAX_PATH];
    TCHAR CatalogName[MAX_PATH];
    TCHAR *p;
    DWORD Err, CatalogNodeStatus, ReturnStatus;
    SetupapiVerifyProblem Problem;
    LPCTSTR ProblemFile;
    BOOL DeleteOemInfOnError;
    BOOL OriginalNameDifferent;
    LPCTSTR AltCatalogFile;
    LONG CatStringId;
    ULONG RequiredSize;
    DWORD InfVerifyType;
    DWORD SCOIFlags;
    HANDLE hWVTStateData = NULL;
    DWORD AuthSigPromptCount = 0;
    DWORD CopyStyleFlags;
    BOOL OemInfIsDeviceInf;

//
// Define values used to indicate how validation should be done on the INFs.
//
#define VERIFY_INF_AS_OEM       0  // verify solely against the specific
                                   // catalog referenced by the INF

#define VERIFY_INF_AS_SYSTEM    1  // verify globally (using all catalogs)

#define VERIFY_OEM_INF_GLOBALLY 2  // verify OEM INF globally, but remember the
                                   // original error, in case copy operations
                                   // are queued using media descriptor info
                                   // within this INF.


    MYASSERT((Flags & (VERCAT_INSTALL_INF_AND_CAT | VERCAT_NO_PROMPT_ON_ERROR))
             != (VERCAT_INSTALL_INF_AND_CAT | VERCAT_NO_PROMPT_ON_ERROR)
            );

    MYASSERT(!DeviceInfNewlyCopied || DeviceInfFinalName);

    if(Queue->Flags & FQF_DID_CATALOGS_OK) {
        //
        // If the caller wants information about the primary device INF, then
        // find the applicable catalog node.
        //
        if(DeviceInfFinalName) {
            for(CatalogNode=Queue->CatalogList; CatalogNode; CatalogNode=CatalogNode->Next) {

                if(CatalogNode->Flags & CATINFO_FLAG_PRIMARY_DEVICE_INF) {
                    MYASSERT(CatalogNode->InfFinalPath != -1);
                    InfFullPath = pSetupStringTableStringFromId(Queue->StringTable, CatalogNode->InfFinalPath);
                    lstrcpy(DeviceInfFinalName, InfFullPath);
                    if(DeviceInfNewlyCopied) {
                        *DeviceInfNewlyCopied = (CatalogNode->Flags & CATINFO_FLAG_NEWLY_COPIED);
                    }
                }
            }
        }

        return NO_ERROR;
    }

    if(Queue->Flags & FQF_DID_CATALOGS_FAILED) {
        //
        // Scan the catalog nodes until we find the first one that failed
        // verification, and return that failure code.
        //
        for(CatalogNode=Queue->CatalogList; CatalogNode; CatalogNode=CatalogNode->Next) {

            if(CatalogNode->VerificationFailureError != NO_ERROR) {
                return CatalogNode->VerificationFailureError;
            }
        }

        //
        // We didn't find a failed catalog node in our catalog list--something's
        // seriously wrong!
        //
        MYASSERT(0);
        return ERROR_INVALID_DATA;
    }

    if(Queue->Flags & FQF_DID_CATALOGS_PROMPT_FOR_TRUST) {
        //
        // We've previously validated these catalogs, but we came across one
        // Authenticode-signed catalog that we needed to prompt the user for in
        // order to establish trust of the publisher.  Unfortunately, we were
        // invoked in "silent mode" (i.e., VERCAT_NO_PROMPT_ON_ERROR), so we
        // simply flagged the queue as having an outstanding issue to resolve
        // this.
        //
        for(CatalogNode=Queue->CatalogList; CatalogNode; CatalogNode=CatalogNode->Next) {

            if(CatalogNode->Flags & CATINFO_FLAG_PROMPT_FOR_TRUST) {
                //
                // Count how many of these we find (there'd better be exactly
                // one).
                //
                AuthSigPromptCount++;

                MYASSERT(CatalogNode->VerificationFailureError == ERROR_AUTHENTICODE_TRUST_NOT_ESTABLISHED);

                //
                // ...and we'd better have some WinVerifyTrust state data!
                //
                MYASSERT(CatalogNode->hWVTStateData);

                if(Flags & VERCAT_NO_PROMPT_ON_ERROR) {
                    //
                    // We _still_ can't make any progress here. :-(
                    //
                    return CatalogNode->VerificationFailureError;

                } else {
                    //
                    // OK, now we can finally ask the user if they trust this
                    // catalog's publisher!
                    //
                    MYASSERT(!(Queue->Flags & FQF_DIGSIG_ERRORS_NOUI));

                    if(_HandleFailedVerification(
                           Owner,
                           SetupapiVerifyCatalogProblem,
                           CatalogNode->CatalogFilenameOnSystem,
                           ((Queue->DeviceDescStringId == -1)
                               ? NULL
                               : pStringTableStringFromId(Queue->StringTable, Queue->DeviceDescStringId)),
                           Queue->DriverSigningPolicy,
                           FALSE,
                           CatalogNode->VerificationFailureError,
                           Queue->LogContext,
                           NULL,
                           NULL,
                           CatalogNode->hWVTStateData)) {
                        //
                        // The user said they trust the publisher--this catalog
                        // node can now be marked as successfully validated.
                        //
                        CatalogNode->Flags &= ~CATINFO_FLAG_PROMPT_FOR_TRUST;
                        CatalogNode->Flags |= CATINFO_FLAG_AUTHENTICODE_SIGNED;
                        CatalogNode->InfFinalPath = CatalogNode->InfFullPath;

                        //
                        // Unless policy is "Ignore", we want to update the 
                        // error value to indicate the user confirmed their 
                        // trust of this Authenticode publisher.
                        //
                        MYASSERT(Queue->DriverSigningPolicy & DRIVERSIGN_ALLOW_AUTHENTICODE);
                        MYASSERT((Queue->DriverSigningPolicy & ~DRIVERSIGN_ALLOW_AUTHENTICODE)
                                 != DRIVERSIGN_BLOCKING);

                        if((Queue->DriverSigningPolicy & ~DRIVERSIGN_ALLOW_AUTHENTICODE)
                           != DRIVERSIGN_NONE) {

                            CatalogNode->VerificationFailureError = ERROR_AUTHENTICODE_TRUSTED_PUBLISHER;

                            Queue->Flags |= FQF_DIGSIG_ERRORS_NOUI;
                        }

                        //
                        // We can free the WinVerifyTrust state data now that
                        // the user has indicated they trust the publisher.
                        //
                        pSetupCloseWVTStateData(CatalogNode->hWVTStateData);
                        CatalogNode->hWVTStateData = NULL;

                    } else {
                        //
                        // The user doesn't trust the publisher--clear the
                        // string buffer containing the Authenticode catalog's
                        // filename.
                        //
                        CatalogNode->CatalogFilenameOnSystem[0] = TEXT('\0');

                        //
                        // Also, clear the "prompt for trust" flag on this
                        // catalog node, since we've already done this.
                        //
                        CatalogNode->Flags &= ~CATINFO_FLAG_PROMPT_FOR_TRUST;

                        //
                        // Likewise, we can clear the "prompt for trust" flag
                        // for the queue, and in its place set the "catalog
                        // verification failed" flag.
                        //
                        Queue->Flags &= ~FQF_DID_CATALOGS_PROMPT_FOR_TRUST;
                        Queue->Flags |= FQF_DID_CATALOGS_FAILED;

                        //
                        // Go ahead and free the WinVerifyTrust state data...
                        //
                        pSetupCloseWVTStateData(CatalogNode->hWVTStateData);
                        CatalogNode->hWVTStateData = NULL;

                        //
                        // Change our error to now indicate that the user
                        // explicitly indicated they didn't want to trust the
                        // publisher (unless policy was block, in which case
                        // they didn't have a choice).
                        //
                        CatalogNode->VerificationFailureError =
                            ERROR_AUTHENTICODE_PUBLISHER_NOT_TRUSTED;

                        return CatalogNode->VerificationFailureError;
                    }
                }

            } else {
                //
                // We'd better have a successful validation reported for this
                // node!
                //
                MYASSERT((CatalogNode->VerificationFailureError == NO_ERROR) ||
                         (CatalogNode->VerificationFailureError == ERROR_AUTHENTICODE_TRUSTED_PUBLISHER));

                //
                // ...and we'd better not have any WinVerifyTrust state data!
                //
                MYASSERT(!(CatalogNode->hWVTStateData));
            }
        }

        MYASSERT(AuthSigPromptCount == 1);

        //
        // OK, we've gotten confirmation from the user that they trust the
        // Authenticode publisher (thus, the validation of the catalogs in this
        // queue can be considered successful).
        //
        Queue->Flags &= ~FQF_DID_CATALOGS_PROMPT_FOR_TRUST;
        Queue->Flags |= FQF_DID_CATALOGS_OK;

        //
        // If the caller wants information about the primary device INF, then
        // find the applicable catalog node.
        //
        if(DeviceInfFinalName) {
            for(CatalogNode=Queue->CatalogList; CatalogNode; CatalogNode=CatalogNode->Next) {

                if(CatalogNode->Flags & CATINFO_FLAG_PRIMARY_DEVICE_INF) {
                    MYASSERT(CatalogNode->InfFinalPath != -1);
                    InfFullPath = pSetupStringTableStringFromId(Queue->StringTable, CatalogNode->InfFinalPath);
                    lstrcpy(DeviceInfFinalName, InfFullPath);
                    if(DeviceInfNewlyCopied) {
                        *DeviceInfNewlyCopied = (CatalogNode->Flags & CATINFO_FLAG_NEWLY_COPIED);
                    }
                }
            }
        }

        return NO_ERROR;
    }

    //
    // If the queue has an alternate default catalog file associated with it,
    // then retrieve that catalog's name for use later.
    //
    AltCatalogFile = (Queue->AltCatalogFile != -1)
                   ? pSetupStringTableStringFromId(Queue->StringTable, Queue->AltCatalogFile)
                   : NULL;

    Queue->hWndDriverSigningUi = Owner;
    ReturnStatus = NO_ERROR;

    for(CatalogNode=Queue->CatalogList; CatalogNode; CatalogNode=CatalogNode->Next) {
        //
        // Assume success for verification of this catalog node.
        //
        CatalogNodeStatus = NO_ERROR;

        MYASSERT(CatalogNode->InfFullPath != -1);
        InfFullPath = pStringTableStringFromId(Queue->StringTable, CatalogNode->InfFullPath);

        if(Queue->Flags & FQF_USE_ALT_PLATFORM) {
            //
            // We have an alternate platform override, so use the alternate
            // platform's CatalogFile= entry.
            //
            CatStringId = CatalogNode->AltCatalogFileFromInf;
        } else {
            //
            // We're running native--use the native CatalogFile= entry.
            //
            CatStringId = CatalogNode->CatalogFileFromInf;
        }
        CatName = (CatStringId != -1)
                  ? pStringTableStringFromId(Queue->StringTable, CatStringId)
                  : NULL;

        InfVerifyType = pSetupInfIsFromOemLocation(InfFullPath, TRUE)
                      ? VERIFY_INF_AS_OEM
                      : VERIFY_INF_AS_SYSTEM;

        if(InfVerifyType == VERIFY_INF_AS_OEM) {
            //
            // If the caller wants us to, we'll now install the catalog.  In
            // addition, if it's a (native platform) device installation, we'll
            // install the INF as well.
            //
            // (Note: we specify the 'no overwrite' switch so that we won't
            // blow away any existing PNF source path information for this INF.
            // We'll only consider an OEM INF to match up with an existing
            // %windir%\Inf\Oem*.INF entry if the catalogs also match up, so
            // we're not going to get into any trouble doing this.
            //
            if(Flags & VERCAT_INSTALL_INF_AND_CAT) {
                //
                // Check to see whether the INF is a device INF.  The queue may
                // not be marked as a device install queue, even though we have
                // a device INF.  This could happen if a device INF is being
                // used for some purpose other than a device install.  It could
                // also happen if we're explicitly forcing non-driver signing
                // policy (i.e., the INF's class isn't listed in certclas.inf).
                //
                OemInfIsDeviceInf = TRUE; // assume INF is a device INF.

                if(!(Queue->Flags & FQF_DEVICE_INSTALL)) {

                    HINF hInf;

                    //
                    // The queue isn't marked as a device install queue, but we
                    // still may be dealing with a device INF.  Check to be
                    // sure...
                    //
                    hInf = SetupOpenInfFile(InfFullPath,
                                            NULL,
                                            INF_STYLE_WIN4,
                                            NULL
                                           );

                    if(hInf != INVALID_HANDLE_VALUE) {

                        try {
                            //
                            // We don't need to lock the INF because it'll 
                            // never be accessible outside of this routine.
                            //
                            if(!IsInfForDeviceInstall(Queue->LogContext,
                                                      NULL,
                                                      (PLOADED_INF)hInf,
                                                      NULL,
                                                      NULL,
                                                      NULL,
                                                      NULL,
                                                      FALSE)) {
                                //
                                // The INF really isn't a device INF.
                                //
                                OemInfIsDeviceInf = FALSE;
                            }

                        } except(pSetupExceptionFilter(GetExceptionCode())) {

                            pSetupExceptionHandler(GetExceptionCode(), 
                                                   ERROR_INVALID_PARAMETER, 
                                                   NULL
                                                  );
                        }

                        SetupCloseInfFile(hInf);

                    } else {
                        //
                        // This shouldn't happen.  For now, just assume the INF
                        // isn't a device INF.  We're probably going to fail
                        // down below when we actually try to copy the INF.
                        //
                        OemInfIsDeviceInf = FALSE;
                    }
                }

                CopyStyleFlags = SP_COPY_NOOVERWRITE;

                if(OemInfIsDeviceInf) {

                    SCOIFlags = 0;

                    //
                    // If we're doing a non-native install, then we only want
                    // to install the INF's associated catalog (if any).
                    //
                    if(Queue->Flags & FQF_USE_ALT_PLATFORM) {
                        CopyStyleFlags |= SP_COPY_OEMINF_CATALOG_ONLY;
                    }

                } else {
                    //
                    // Since we're not working with a device INF, we want to 
                    // suppress popups and error log entries if the INF doesn't 
                    // reference a catalog.  This is because we want to allow 
                    // such INFs to be validated globally, unless they 
                    // subsequently try to copy files.
                    //
                    SCOIFlags = SCOI_NO_ERRLOG_ON_MISSING_CATALOG;

                    //
                    // We always want to do catalog-only installs for 
                    // non-device INFs.
                    //
                    CopyStyleFlags |= SP_COPY_OEMINF_CATALOG_ONLY;
                }

                //
                // If we're not supposed to generate popups/log entries at all
                // for signature verification failures (e.g., because we've
                // already done so previously), then set that flag as well.
                //
                if(Queue->Flags & FQF_DIGSIG_ERRORS_NOUI) {
                    SCOIFlags |= SCOI_NO_UI_ON_SIGFAIL;
                }

                if(Queue->Flags & FQF_KEEP_INF_AND_CAT_ORIGINAL_NAMES) {
                    SCOIFlags |= SCOI_KEEP_INF_AND_CAT_ORIGINAL_NAMES;
                    //
                    // This is an exception package, so we'd better not even
                    // think about allowing Authenticode signed files!
                    //
                    MYASSERT(!(Queue->DriverSigningPolicy & DRIVERSIGN_ALLOW_AUTHENTICODE));
                }

                if(Queue->Flags & FQF_ABORT_IF_UNSIGNED) {
                    SCOIFlags |= SCOI_ABORT_IF_UNSIGNED;
                }

                CatalogNodeStatus = 
                    GLE_FN_CALL(FALSE,
                                _SetupCopyOEMInf(
                                    InfFullPath,
                                    NULL, // default source location to where INF presently is
                                    ((Flags & VERCAT_PRIMARY_DEVICE_INF_FROM_INET)
                                        ? SPOST_URL
                                        : SPOST_PATH),
                                    CopyStyleFlags,
                                    PathBuffer,
                                    SIZECHARS(PathBuffer),
                                    NULL,
                                    &p,
                                    ((CatalogNode->InfOriginalName != -1)
                                        ? pStringTableStringFromId(Queue->StringTable,
                                                                   CatalogNode->InfOriginalName)
                                        : pSetupGetFileTitle(InfFullPath)),
                                    CatName,
                                    Owner,
                                    ((Queue->DeviceDescStringId == -1)
                                        ? NULL
                                        : pStringTableStringFromId(Queue->StringTable,
                                                                   Queue->DeviceDescStringId)),
                                    Queue->DriverSigningPolicy,
                                    SCOIFlags,
                                    AltCatalogFile,
                                    ((Queue->Flags & FQF_USE_ALT_PLATFORM)
                                        ? &(Queue->AltPlatformInfo)
                                        : Queue->ValidationPlatform),
                                    &Err,
                                    CatalogNode->CatalogFilenameOnSystem,
                                    Queue->LogContext,
                                    &(Queue->VerifyContext),
                                    &hWVTStateData)
                               );

                if(CatalogNodeStatus == NO_ERROR) {
                    //
                    // If we got back a WinVerifyTrust state data handle, we'd
                    // better have gotten one of our two Authenticode status
                    // codes back...
                    //
                    MYASSERT(!hWVTStateData || 
                             ((Err == ERROR_AUTHENTICODE_TRUSTED_PUBLISHER) || (Err == ERROR_AUTHENTICODE_TRUST_NOT_ESTABLISHED)));

                    //
                    // If Err indicates that there was a digital signature
                    // problem that the user chose to ignore (or was silently
                    // ignored), then set a flag in the queue indicating the
                    // user should not be warned about subsequent failures.
                    // Don't set this flag if the queue's policy is "Ignore",
                    // however, on the chance that the policy might be altered
                    // later, and we'd want the user to get informed on any
                    // subsequent errors.
                    //
                    // (Note: if the error was due to the INF not having a
                    // CatalogFile= entry, and if we're supposed to ignore such
                    // problems, then just set the flag to do global validation
                    // later.)
                    //
                    if((Err == ERROR_NO_CATALOG_FOR_OEM_INF) &&
                       (SCOIFlags & SCOI_NO_ERRLOG_ON_MISSING_CATALOG)) {

                        MYASSERT(!hWVTStateData);
                        InfVerifyType = VERIFY_OEM_INF_GLOBALLY;

                    } else if(Err != NO_ERROR) {
                         
                        if((Queue->DriverSigningPolicy & ~DRIVERSIGN_ALLOW_AUTHENTICODE) 
                           != DRIVERSIGN_NONE) {

                            MYASSERT(Err != ERROR_AUTHENTICODE_TRUST_NOT_ESTABLISHED);

                            Queue->Flags |= FQF_DIGSIG_ERRORS_NOUI;
                        }
                    }

                    if(*PathBuffer) {
                        //
                        // Store the INF's final path into our catalog node.
                        // This will be under %windir%\Inf unless the INF didn't
                        // specify a CatalogFile= entry and we did an alternate
                        // catalog installation (i.e., because the file queue had
                        // an associated alternate catalog).
                        //
                        CatalogNode->InfFinalPath = pSetupStringTableAddString(
                                                        Queue->StringTable,
                                                        PathBuffer,
                                                        STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE
                                                       );
                    } else {
                        //
                        // _SetupCopyOEMInf returned an empty string for the
                        // destination INF name, which means that we were doing
                        // a catalog-only install, and it didn't find the INF
                        // already existing in %windir%\Inf.  In this case, just
                        // use the INF's original pathname as its final pathname.
                        //
                        CatalogNode->InfFinalPath = CatalogNode->InfFullPath;
                    }

                    if(CatalogNode->InfFinalPath == -1) {

                        CatalogNodeStatus = ERROR_NOT_ENOUGH_MEMORY;
                        if(Err == NO_ERROR) {
                            Err = CatalogNodeStatus;
                        }

                        //
                        // Since we couldn't add this filename to the string
                        // table, we won't be able to undo this copy later--it
                        // must be done here.  Delete the INF, PNF, and CAT.
                        //
                        // NOTE: we should never get here if we did an alternate
                        // catalog file-only install, because in that case our
                        // new INF name is the same as the INF's original name,
                        // thus the string is already in the buffer and there's
                        // no way we could run out of memory.
                        //
                        MYASSERT(lstrcmpi(PathBuffer, InfFullPath));

                        pSetupUninstallOEMInf(PathBuffer,
                                              Queue->LogContext,
                                              SUOI_FORCEDELETE,
                                              NULL
                                             );

                    } else {
                        //
                        // Set a flag in the catalog node indicating that this
                        // INF was newly-copied into %windir%\Inf.  If the
                        // string ID for our INF's original name and that of its
                        // new name are equal, then we know we did an alternate
                        // catalog installation only, and we don't want to set
                        // this flag.
                        //
                        if(CatalogNode->InfFinalPath != CatalogNode->InfFullPath) {
                            CatalogNode->Flags |= CATINFO_FLAG_NEWLY_COPIED;
                        }

                        //
                        // If this is the primary device INF, and the caller
                        // requested information about that INF's final
                        // pathname, then store that information in the caller-
                        // supplied buffer(s) now.
                        //
                        if(DeviceInfFinalName &&
                           (CatalogNode->Flags & CATINFO_FLAG_PRIMARY_DEVICE_INF)) {
                            //
                            // We'd better not just've done an alternate catalog
                            // installation.
                            //
                            MYASSERT(CatalogNode->InfFinalPath != CatalogNode->InfFullPath);

                            lstrcpy(DeviceInfFinalName, PathBuffer);
                            if(DeviceInfNewlyCopied) {
                                *DeviceInfNewlyCopied = TRUE;
                            }
                        }

                        //
                        // If this INF was signed by an Authenticode catalog,
                        // then set a flag indicating that.
                        //
                        if((Err == ERROR_AUTHENTICODE_TRUSTED_PUBLISHER) ||
                           (Err == ERROR_AUTHENTICODE_TRUST_NOT_ESTABLISHED)) {
                            //
                            // In either case, we should trust the catalog's
                            // publisher, because either the cert was in the
                            // TrustedPublisher store, or the user agreed to
                            // trust the publisher.
                            //
                            CatalogNode->Flags |= CATINFO_FLAG_AUTHENTICODE_SIGNED;
                            MYASSERT(hWVTStateData);
                            pSetupCloseWVTStateData(hWVTStateData);
                            hWVTStateData = NULL;
                        }
                    }

                } else {

                    if(CatalogNodeStatus == ERROR_FILE_EXISTS) {
                        //
                        // INF and CAT already there--this isn't a failure.
                        //
                        // Store the name under which we found this OEM INF 
                        // into the catalog node's InfFinalPath field.
                        //
                        CatalogNode->InfFinalPath = pSetupStringTableAddString(
                                                        Queue->StringTable,
                                                        PathBuffer,
                                                        STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE
                                                       );

                        if(CatalogNode->InfFinalPath == -1) {
                            CatalogNodeStatus = ERROR_NOT_ENOUGH_MEMORY;
                        } else {
                            CatalogNodeStatus = NO_ERROR;
                            //
                            // If Err indicates that there was a digital 
                            // signature problem that the user chose to ignore
                            // (or was silently ignored), then set a flag in 
                            // the queue indicating the user should not be
                            // warned about subsequent failures.  Don't set
                            // this flag if the queue's policy is "Ignore",
                            // however, on the chance that the policy might be 
                            // altered later, and we'd want the user to get 
                            // informed on any subsequent errors.
                            //
                            if(Err != NO_ERROR) {

                                if((Queue->DriverSigningPolicy & ~DRIVERSIGN_ALLOW_AUTHENTICODE)
                                   != DRIVERSIGN_NONE) {

                                    MYASSERT(Err != ERROR_AUTHENTICODE_TRUST_NOT_ESTABLISHED);

                                    Queue->Flags |= FQF_DIGSIG_ERRORS_NOUI;
                                }
                            }

                            //
                            // If this is the primary device INF, and the 
                            // caller requested information about that INF's 
                            // final pathname, then store that information in 
                            // the caller-supplied buffer(s) now.
                            //
                            if(DeviceInfFinalName &&
                               (CatalogNode->Flags & CATINFO_FLAG_PRIMARY_DEVICE_INF)) {

                                lstrcpy(DeviceInfFinalName, PathBuffer);
                                if(DeviceInfNewlyCopied) {
                                    *DeviceInfNewlyCopied = FALSE;
                                }
                            }

                            //
                            // If this INF was signed by an Authenticode 
                            // catalog, then set a flag indicating that.
                            //
                            if((Err == ERROR_AUTHENTICODE_TRUSTED_PUBLISHER) ||
                               (Err == ERROR_AUTHENTICODE_TRUST_NOT_ESTABLISHED)) {
                                //
                                // In either case, we should trust the 
                                // catalog's publisher, because either the cert 
                                // was in the TrustedPublisher store, or the 
                                // user agreed to trust the publisher.
                                //
                                CatalogNode->Flags |= CATINFO_FLAG_AUTHENTICODE_SIGNED;
                                pSetupCloseWVTStateData(hWVTStateData);
                                hWVTStateData = NULL;
                            }
                        }

                    } else {
                        //
                        // For any error other than ERROR_FILE_EXISTS, we
                        // shouldn't be getting any WinVerifyTrust state data.
                        //
                        MYASSERT(!hWVTStateData);
                         
                        if(CatalogNodeStatus == ERROR_SET_SYSTEM_RESTORE_POINT) {
                            //
                            // We should only get this error if the queue flag is
                            // set that causes us to abort unsigned installations.
                            //
                            MYASSERT(Queue->Flags & FQF_ABORT_IF_UNSIGNED);

                            //
                            // We don't want the user to see the driver signing
                            // UI again when the queue is re-committed...
                            //
                            if((Queue->DriverSigningPolicy & ~DRIVERSIGN_ALLOW_AUTHENTICODE)
                               != DRIVERSIGN_NONE) {

                                Queue->Flags |= FQF_DIGSIG_ERRORS_NOUI;
                            }

                            //
                            // Make sure that Err is also set to this same
                            // "special" error code...
                            //
                            Err = CatalogNodeStatus;
                        }
                    }

                    //
                    // If we had a real failure from _SetupCopyOEMInf (or we're
                    // out of memory and couldn't add a string to the string
                    // table above), then we need to propagate the value of
                    // CatalogNodeStatus to Err, if Err doesn't already have a
                    // failure code.
                    //
                    if((CatalogNodeStatus != NO_ERROR) && (Err == NO_ERROR)) {
                        Err = CatalogNodeStatus;
                    }
                }

            } else {
                //
                // We were told not to copy any files, but we've encountered an
                // OEM INF that needs to be installed. Hence, we have a failure.
                // Note that we _don't_ look to see if this OEM INF (and its
                // corresponding catalog) might happen to already be properly
                // installed.  That isn't necessary, because
                // _SetupDiInstallDevice calls _SetupVerifyQueuedCatalogs with
                // the VERCAT_INSTALL_INF_AND_CAT flag _before_ calling
                // SetupScanFileQueue, thus all INFs/CATs should be present when
                // we're called to do simple verification of the catalog nodes.
                //
                Err = CatalogNodeStatus = ERROR_CANNOT_COPY;
            }
        }

        if(InfVerifyType != VERIFY_INF_AS_OEM) {
            //
            // Inf is in system location (%windir%\Inf), or we're going to try
            // validating an "OEM" INF globally. Figure out the expected name
            // of the catalog file. If the file was originally copied in by the
            // Di stuff, then we need to use a name based on the name Di gave
            // the inf. Otherwise we use the name from the inf's CatalogFile=
            // entry, if present.  Finally, if the INF doesn't specify a
            // CatalogFile= entry, we assume it's a system component and
            // attempt to validate against any catalog that we find a hash
            // match in.
            //
            Err = NO_ERROR; // assume success
            ProblemFile = PathBuffer; // default buffer to store problem file

            if(CatalogNode->InfOriginalName != -1) {

                RequiredSize = SIZECHARS(InfNameBuffer);
                if(pSetupStringTableStringFromIdEx(Queue->StringTable,
                                                   CatalogNode->InfOriginalName,
                                                   InfNameBuffer,
                                                   &RequiredSize)) {

                    OriginalNameDifferent = TRUE;
                } else {
                    //
                    // This should never fail!
                    //
                    MYASSERT(0);
                    Err = ERROR_INVALID_DATA;

                    //
                    // Blame the INF!
                    //
                    Problem = SetupapiVerifyInfProblem;
                    MYVERIFY(SUCCEEDED(StringCchCopy(PathBuffer, 
                                                     SIZECHARS(PathBuffer), 
                                                     InfFullPath)));
                }

            } else {
                OriginalNameDifferent = FALSE;
            }

            if(Err == NO_ERROR) {

                if(CatName) {
                    //
                    // If there is a catalog name, then we'd better not be
                    // doing our "verify OEM INF globally" trick!
                    //
                    MYASSERT(InfVerifyType == VERIFY_INF_AS_SYSTEM);

                    if(OriginalNameDifferent) {
                        //
                        // If the INF specified a catalog file, then we know we
                        // would've installed that catalog file using a name 
                        // based on the unique name we assigned the INF when 
                        // copying it into the INF directory.
                        //
                        lstrcpy(CatalogName, pSetupGetFileTitle(InfFullPath));
                        p = _tcsrchr(CatalogName, TEXT('.'));
                        if(!p) {
                            p = CatalogName + lstrlen(CatalogName);
                        }
                        lstrcpy(p, pszCatSuffix);
                    } else {
                        lstrcpy(CatalogName, CatName);
                    }

                } else {
                    //
                    // This system INF didn't specify a CatalogFile= entry.  If
                    // an alternate catalog is associated with this file queue,
                    // then use that catalog for verification.
                    //
                    if(AltCatalogFile) {
                        lstrcpy(CatalogName, AltCatalogFile);
                        CatName = pSetupGetFileTitle(CatalogName);
                    }
                }

                //
                // (Note: in the call below, we don't want to store the
                // validating catalog filename in our CatalogFilenameOnSystem
                // field if the INF didn't specify a CatalogFile= entry (and
                // there was no alternate catalog specified), because we want
                // any queue nodes that reference this catalog entry to use
                // global validation as well.)
                //
                if(GlobalSetupFlags & PSPGF_MINIMAL_EMBEDDED) {
                    //
                    // Don't attempt to call _VerifyFile, because we're
                    // asking for the validating catalog's name, and that makes
                    // no sense in the "minimal embedded" case.
                    //
                    *(CatalogNode->CatalogFilenameOnSystem) = TEXT('\0');

                    //
                    // (Err is already set to NO_ERROR.)
                    //

                } else {

                    if(!CatName) {
                        *(CatalogNode->CatalogFilenameOnSystem) = TEXT('\0');
                    }

                    Err = _VerifyFile(
                              Queue->LogContext,
                              &(Queue->VerifyContext),
                              (CatName ? CatalogName : NULL),
                              NULL,
                              0,
                              (OriginalNameDifferent ? InfNameBuffer : pSetupGetFileTitle(InfFullPath)),
                              InfFullPath,
                              &Problem,
                              PathBuffer,
                              FALSE,
                              ((Queue->Flags & FQF_USE_ALT_PLATFORM)
                                  ? &(Queue->AltPlatformInfo)
                                  : Queue->ValidationPlatform),
                              (VERIFY_FILE_IGNORE_SELFSIGNED
                               | VERIFY_FILE_NO_DRIVERBLOCKED_CHECK),
                              (CatName ? CatalogNode->CatalogFilenameOnSystem : NULL),
                              NULL,
                              NULL,
                              NULL,
                              NULL
                             );

                    if((Err != NO_ERROR) && (Err != ERROR_SIGNATURE_OSATTRIBUTE_MISMATCH) && 
                       CatName &&
                       !(Queue->Flags & FQF_QUEUE_FORCE_BLOCK_POLICY) &&
                       (Queue->DriverSigningPolicy & DRIVERSIGN_ALLOW_AUTHENTICODE)) {

                        //
                        // We failed to validate via OS codesigning policy--now
                        // we should see if the INF validates using
                        // Authenticode policy.
                        //
                        Err = _VerifyFile(Queue->LogContext,
                                          &(Queue->VerifyContext),
                                          CatalogName,
                                          NULL,
                                          0,
                                          (OriginalNameDifferent 
                                              ? InfNameBuffer 
                                              : pSetupGetFileTitle(InfFullPath)),
                                          InfFullPath,
                                          &Problem,
                                          PathBuffer,
                                          FALSE,
                                          ((Queue->Flags & FQF_USE_ALT_PLATFORM)
                                              ? &(Queue->AltPlatformInfo)
                                              : Queue->ValidationPlatform),
                                          (VERIFY_FILE_IGNORE_SELFSIGNED
                                           | VERIFY_FILE_NO_DRIVERBLOCKED_CHECK
                                           | VERIFY_FILE_USE_AUTHENTICODE_CATALOG),
                                          CatalogNode->CatalogFilenameOnSystem,
                                          NULL,
                                          NULL,
                                          NULL,
                                          &hWVTStateData
                                         );

                        if(Err == ERROR_AUTHENTICODE_TRUSTED_PUBLISHER) {

                            CatalogNode->VerificationFailureError = Err;

                            //
                            // Treat this as success...
                            //
                            Err = NO_ERROR;
                            Problem = SetupapiVerifyNoProblem;
                            CatalogNode->Flags |= CATINFO_FLAG_AUTHENTICODE_SIGNED;
                            pSetupCloseWVTStateData(hWVTStateData);
                            hWVTStateData = NULL;

                        } else if(Err == ERROR_AUTHENTICODE_TRUST_NOT_ESTABLISHED) {
                            //
                            // This isn't really a verification error, but
                            // since we're going to have to prompt the user
                            // to establish trust of this publisher, we
                            // need to have a problem and problem file
                            // identified.  We'll blame the catalog...
                            //
                            Problem = SetupapiVerifyCatalogProblem;
                            ProblemFile = CatalogNode->CatalogFilenameOnSystem;

                            //
                            // We only support one Authenticode-signed 
                            // catalog (that isn't pre-trusted) per file 
                            // queue, so we keep a count to make sure we  
                            // don't find more than one.
                            //
                            AuthSigPromptCount++; 
                        }
                    }
                }
            }

            if(Err == NO_ERROR) {
                //
                // INF/CAT was successfully verified--store the INF's final 
                // path (which is the same as its current path) into the 
                // catalog node.
                //
                CatalogNode->InfFinalPath = CatalogNode->InfFullPath;

            } else {

                MYASSERT(Problem != SetupapiVerifyNoProblem);

                if(Problem != SetupapiVerifyCatalogProblem) {
                    //
                    // If the problem was not a catalog problem, then it's an
                    // INF problem (the _VerifyFile routine doesn't know the
                    // file we passed it is an INF).
                    //
                    Problem = SetupapiVerifyInfProblem;
                }

                if(AuthSigPromptCount > 1) {
                    //
                    // We don't want to popup more than one Authenticode trust
                    // dialog!
                    //
                    CatalogNodeStatus = Err = ERROR_AUTHENTICODE_PUBLISHER_NOT_TRUSTED;

                    MYASSERT(hWVTStateData);

                    pSetupCloseWVTStateData(hWVTStateData);
                    hWVTStateData = NULL;

                } else if(Flags & VERCAT_NO_PROMPT_ON_ERROR) {

                    if(hWVTStateData) {
                        //
                        // The INF is signed via an Authenticode catalog, but
                        // the signing certificate isn't in the trusted
                        // publisher store.  Since we're prevented from asking
                        // the user whether they trust the publisher, we'll
                        // simply set a flag on this catalog node for the time
                        // being indicating that the user needs to be so
                        // prompted.  We'll also store the WinVerifyTrust data
                        // in the catalog node so that when we do get around to
                        // prompting the user, we'll be able to give them info
                        // on who the publisher was, when the catalog was
                        // signed, etc.
                        //
                        MYASSERT(AuthSigPromptCount == 1);
                        MYASSERT(Err == ERROR_AUTHENTICODE_TRUST_NOT_ESTABLISHED);

                        CatalogNode->Flags |= CATINFO_FLAG_PROMPT_FOR_TRUST;
                        CatalogNode->hWVTStateData = hWVTStateData;
                        hWVTStateData = NULL; // successfully transferred to catalog node
                    }

                    CatalogNodeStatus = Err;

                } else if(Queue->Flags & FQF_QUEUE_FORCE_BLOCK_POLICY) {
                    //
                    // Don't notify the caller or log anything--just remember
                    // the error.  (Note: we never want to consider 
                    // Authenticode signatures in this case.
                    //
                    CatalogNodeStatus = Err;

                    MYASSERT(!hWVTStateData);

                } else {
                    //
                    // Notify the caller of the failure (based on policy).
                    //
                    if(_HandleFailedVerification(
                           Owner,
                           Problem,
                           ProblemFile,
                           ((Queue->DeviceDescStringId == -1)
                               ? NULL
                               : pStringTableStringFromId(Queue->StringTable, Queue->DeviceDescStringId)),
                           Queue->DriverSigningPolicy,
                           Queue->Flags & FQF_DIGSIG_ERRORS_NOUI,
                           Err,
                           Queue->LogContext,
                           NULL,
                           NULL,
                           hWVTStateData))
                    {
                        if(hWVTStateData) {
                            //
                            // The user agreed that they trust the publisher of
                            // this Authenticode catalog (or, trust was
                            // implicitly granted because policy was Ignore).
                            //
                            CatalogNode->Flags |= CATINFO_FLAG_AUTHENTICODE_SIGNED;

                            //
                            // Unless policy is "Ignore", we want to update the 
                            // error value to indicate the user confirmed their 
                            // trust of this Authenticode publisher.
                            //
                            MYASSERT((Queue->DriverSigningPolicy & ~DRIVERSIGN_ALLOW_AUTHENTICODE)
                                     != DRIVERSIGN_BLOCKING);

                            if((Queue->DriverSigningPolicy & ~DRIVERSIGN_ALLOW_AUTHENTICODE)
                               != DRIVERSIGN_NONE) {

                                Err = ERROR_AUTHENTICODE_TRUSTED_PUBLISHER;

                                Queue->Flags |= FQF_DIGSIG_ERRORS_NOUI;
                            }

                            //
                            // INF/CAT was successfully verified--store the 
                            // INF's final path (which is the same as its 
                            // current path) into the catalog node.
                            //
                            CatalogNode->InfFinalPath = CatalogNode->InfFullPath;

                        } else {
                            //
                            // If the user actally saw UI (i.e., policy isn't
                            // "Ignore", then set a flag so we don't popup any
                            // more digital signature verification UI...
                            //
                            if((Queue->DriverSigningPolicy & ~DRIVERSIGN_ALLOW_AUTHENTICODE)
                               != DRIVERSIGN_NONE) {

                                Queue->Flags |= FQF_DIGSIG_ERRORS_NOUI;
                            }

                            //
                            // If the caller wants a chance to set a system 
                            // restore point prior to doing any unsigned 
                            // installations, then we abort now with a 
                            // "special" error code that tells them what to 
                            // do...
                            //
                            if(Queue->Flags & FQF_ABORT_IF_UNSIGNED) {

                                CatalogNodeStatus = Err = ERROR_SET_SYSTEM_RESTORE_POINT;

                            } else {
                                //
                                // Since we're going to use the INF/CAT anyway, 
                                // in spite of digital signature problems, then 
                                // we need to set the INF's final path to be
                                // the same as its current path.
                                //
                                CatalogNode->InfFinalPath = CatalogNode->InfFullPath;
                            }
                        }

                    } else {
                        //
                        // The caller doesn't want to proceed (or policy was
                        // block)
                        //
                        if(Err == ERROR_AUTHENTICODE_TRUST_NOT_ESTABLISHED) {
                            //
                            // Change error to indicate that we have a real
                            // failure (instead of a "wait and see" condition).
                            //
                            Err = ERROR_AUTHENTICODE_PUBLISHER_NOT_TRUSTED;
                        }

                        CatalogNodeStatus = Err;
                    }

                    if(hWVTStateData) {
                        //
                        // Don't need the WinVerifyTrust state data any
                        // longer...
                        //
                        pSetupCloseWVTStateData(hWVTStateData);
                        hWVTStateData = NULL;
                    }
                }
            }

            if((CatalogNodeStatus == NO_ERROR) ||
               (CatalogNodeStatus == ERROR_AUTHENTICODE_TRUST_NOT_ESTABLISHED)) {
                //
                // If this is the primary device INF, and the caller requested
                // information about that INF's final pathname, then store that
                // information in the caller-supplied buffer(s) now.
                //
                if(DeviceInfFinalName &&
                   (CatalogNode->Flags & CATINFO_FLAG_PRIMARY_DEVICE_INF)) {

                    lstrcpy(DeviceInfFinalName, InfFullPath);
                    if(DeviceInfNewlyCopied) {
                        *DeviceInfNewlyCopied = FALSE;
                    }
                }
            }
        }

        //
        // At this point, there are really 3 successful status codes we can
        // have...
        //
        if((Err == NO_ERROR) ||
           (Err == ERROR_AUTHENTICODE_TRUST_NOT_ESTABLISHED) ||
           (Err == ERROR_AUTHENTICODE_TRUSTED_PUBLISHER)) {
            //
            // If we successfully validated an "OEM" INF globally, then we want
            // to remember this fact.  This will allow us to generate a
            // signature verification failure against any file copy nodes
            // associated with this catalog node.
            //
            if(InfVerifyType == VERIFY_OEM_INF_GLOBALLY) {

                MYASSERT(!(CatalogNode->Flags & 
                           (CATINFO_FLAG_PROMPT_FOR_TRUST | CATINFO_FLAG_AUTHENTICODE_SIGNED)));

                MYASSERT(Err == NO_ERROR);

                CatalogNode->VerificationFailureError = ERROR_NO_CATALOG_FOR_OEM_INF;

            } else {
                CatalogNode->VerificationFailureError = Err;
            }

        } else {
            //
            // CatalogNodeStatus may or may not be NO_ERROR, since it's
            // possible we encountered a digital signature verification failure
            // for this catalog node, but the user elected to proceed anyway.
            // Mark this node with the failure encountered...
            //
            CatalogNode->VerificationFailureError = Err;
            CatalogNode->CatalogFilenameOnSystem[0] = TEXT('\0');
        }

        if((ReturnStatus == NO_ERROR) && (CatalogNodeStatus != NO_ERROR)) {
            //
            // First critical error we've encountered--propagate the failure
            // for this catalog to our return status that will be returned to
            // the caller once we've finished looking at all the catalogs.
            //
            ReturnStatus = CatalogNodeStatus;

            //
            // Unless the VERCAT_NO_PROMPT_ON_ERROR flag has been set, we
            // should abort right now--there's no sense in going any further.
            //
            if(!(Flags & VERCAT_NO_PROMPT_ON_ERROR)) {
                break;
            }

            //
            // If we've found more than one untrusted publisher, we should also
            // break.
            //
            if(AuthSigPromptCount > 1) {
                MYASSERT(CatalogNodeStatus == ERROR_AUTHENTICODE_PUBLISHER_NOT_TRUSTED);
                break;
            }
        }
    }

    //
    // If the caller requested no prompting, then we don't want to mark this
    // queue as 'failed', since the user never heard about it.  However, if the
    // verification succeeded, then we _do_ want to mark it as successful.
    //
    if(Flags & VERCAT_NO_PROMPT_ON_ERROR) {

        if(ReturnStatus == NO_ERROR) {

            Queue->Flags |= FQF_DID_CATALOGS_OK;

            //
            // We'd better not have any outstanding Authenticode trust issues.
            //
            MYASSERT(AuthSigPromptCount == 0);

        } else {
            //
            // If we were still need to confirm with the user that they trust 
            // the publisher of an Authenticode-signed catalog, then set a flag 
            // so we can track that.
            //
            if((ReturnStatus == ERROR_AUTHENTICODE_TRUST_NOT_ESTABLISHED) &&
               (AuthSigPromptCount == 1)) {

                Queue->Flags |= FQF_DID_CATALOGS_PROMPT_FOR_TRUST;
            }
        }

    } else {

        Queue->Flags |= (ReturnStatus == NO_ERROR) ? FQF_DID_CATALOGS_OK
                                                   : FQF_DID_CATALOGS_FAILED;

        //
        // If we were successful, then we would've encountered at most 1
        // Authenticode-signed catalog that required user-prompting to confirm
        // trust of the publisher...
        //
        MYASSERT((ReturnStatus != NO_ERROR) || (AuthSigPromptCount < 2));
    }

    return ReturnStatus;
}


VOID
LogFailedVerification(
    IN PSETUP_LOG_CONTEXT LogContext,           OPTIONAL
    IN DWORD MessageId,
    IN DWORD Error,
    IN LPCTSTR ProblemFile,
    IN LPCTSTR DeviceDesc,                      OPTIONAL
    IN DWORD LogLevel
    )

/*++

Routine Description:

    This routine logs when a verification failed but the file was installed
    anyway.

Arguments:

    LogContext - optionally supplies a pointer to the context for logging.
        If this is not supplied, errors will be logged to the default context.

    MessageId - Message to display

    Error - supplies the code the the error that caused the failure.

    ProblemFile - supplies the file path to the file associated with
        the problem. In some cases this is a full path, in others it's just a
        filename. The caller decides which makes sense in a particular
        scenario. For example, a system catalog is in some funky directory
        and there is no need to tell the user the full path. But in the case
        where a catalog comes from an oem location, there might be some benefit
        to telling the user the full path.

    DeviceDesc - Optionally, supplies the device description to be used in the
        digital signature verification error dialogs that may be popped up.

    LogLevel - Either SETUP_LOG_ERROR, SETUP_LOG_WARNING, or SETUP_LOG_INFO.
    
Return Value:

    NONE.

--*/

{
    PSETUP_LOG_CONTEXT lc = NULL;

    MYASSERT(Error != NO_ERROR);
    MYASSERT(ProblemFile && *ProblemFile);

    if (!LogContext) {
        if (CreateLogContext(NULL, TRUE, &lc) == NO_ERROR) {
            //
            // success
            //
            LogContext = lc;
        } else {
            lc = NULL;
        }
    }

    //
    // a device install failed
    //
    WriteLogEntry(
        LogContext,
        LogLevel | SETUP_LOG_BUFFER,
        MessageId,
        NULL,
        ProblemFile,
        DeviceDesc);

    WriteLogError(
        LogContext,
        LogLevel,
        Error);

    if (lc) {
        DeleteLogContext(lc);
    }
}

BOOL
pSetupHandleFailedVerification(
    IN HWND                  Owner,
    IN SetupapiVerifyProblem Problem,
    IN LPCTSTR               ProblemFile,
    IN LPCTSTR               DeviceDesc,          OPTIONAL
    IN DWORD                 DriverSigningPolicy,
    IN BOOL                  NoUI,
    IN DWORD                 Error,
    IN PVOID                 LogContext,          OPTIONAL
    OUT PDWORD               Flags,               OPTIONAL
    IN LPCTSTR               TargetFile           OPTIONAL
    )

/*++

Routine Description:

    This routine deals with a failed verification.

    System policy is checked. If the policy is block, UI is displayed telling
    the user that they're hosed. If the policy is ask-user, then ui is
    displayed requesting the user's decision about whether to ignore the
    verification failure and take the risk. If the policy is ignore, nothing
    is done.

Arguments:

    Owner - supplies window to own the dialog.

    Problem - supplies a constant indicating what caused the failure.  This
        value indicates what type of file is specified in the ProblemFile
        argument.

    ProblemFile - supplies the file path to the file associated with
        the problem. In some cases this is a full path, in others it's just a
        filename. The caller decides which makes sense in a particular
        scenario. For example, a system catalog is in some funky directory
        and there is no need to tell the user the full path. But in the case
        where a catalog comes from an oem location, there might be some benefit
        to telling the user the full path.
        NOTE: if this API is being called because of a blocked driver then a
        full path should always be passed in.

    DeviceDesc - Optionally, supplies the device description to be used in the
        digital signature verification error dialogs that may be popped up.

    DriverSigningPolicy - supplies the driver signing policy currently in
        effect.  May be one of the three following values:

        DRIVERSIGN_NONE    -  silently succeed installation of unsigned/
                              incorrectly-signed files.  A PSS log entry will
                              be generated, however.
        DRIVERSIGN_WARNING -  warn the user, but let them choose whether or not
                              they still want to install the problematic file.
                              If the user elects to proceed with the
                              installation,  A PSS log entry will be generated
                              noting this fact.
        DRIVERSIGN_BLOCKING - do not allow the file to be installed
        
        The above values may be OR'ed with DRIVERSIGN_ALLOW_AUTHENTICODE. This
        indicates that Authenticode-signed catalogs are permissable.  The fact
        that we were called with this bit set means that either:
        
            (a) the catalog was Authenticode-signed, but the publisher's cert
                wasn't contained in the TrustedPublisher cert store.  Thus, the
                user must be prompted in order to establish their trust of the
                publisher.  (This is only allowed for "Warn"--in the "Block"
                case, the user doesn't get the chance to trust the publisher--
                that requires that the publisher's cert is in the 
                TrustedPublisher store.)
                
            (b) the file isn't signed at all.  The fact that this bit is set
                indicates that we should give the user that tells them that the
                package could've been signed by Authenticode, but wasn't.
                Without this bit, we want to give the standard driver signing
                dialog that extolls the merits of WHQL.

    NoUI - if TRUE, then a dialog box should not be displayed to the user, even
        if policy is warn or block.  This will typically be set to TRUE after
        the user has previously been informed of a digital signature problem
        with the package they're attempting to install, but have elected to
        proceed with the installation anyway.  The behavior of the "Yes" button,
        then, is really a "yes to all".

    Error - supplies the code of the error that caused the failure.

    LogContext - optionally supplies a pointer to the context for logging.
        If this is not supplied, errors will be logged to the default context.
        This is declared as a PVOID so external functions don't need to know
        what a SETUP_LOG_CONTEXT is.

    Flags - optionally supplies a pointer to a DWORD that receives one or more
        of the following file queue node flags indicating that we made an
        exemption for installing a protected system file:

        IQF_TARGET_PROTECTED - TargetFile (see below) is a protected system
                               file.
        IQF_ALLOW_UNSIGNED   - An exception has been granted so that TargetFile
                               (see below) may be replaced by an unsigned file.

    TargetFile - optionally supplies a pointer to a string that specifies a
       destination file if one exists.  This is only used if we want to exempt
       a file operation on this file.  If this parameter is not specified, then
       it is assumed the file will _not_ be replaced (i.e., it may already be
       on the system in its unsigned state), and no SFP exemption will be
       attempted.

Return Value:

    Boolean value indicating whether the caller should continue.
    If FALSE, then the current operation should be aborted, as the combination
    of system policy and user input indicated that the risk should not
    be taken.

--*/

{
    //
    // This routine should not be called when Authenticode validation is a
    // possibility...
    //
    MYASSERT((DriverSigningPolicy == DRIVERSIGN_NONE) ||
             (DriverSigningPolicy == DRIVERSIGN_WARNING) ||
             (DriverSigningPolicy == DRIVERSIGN_BLOCKING));

    MYASSERT(Problem != SetupapiVerifyNoProblem);
    MYASSERT(ProblemFile && *ProblemFile);
    MYASSERT(Error != ERROR_AUTHENTICODE_TRUST_NOT_ESTABLISHED);

    return _HandleFailedVerification(Owner,
                                     Problem,
                                     ProblemFile,
                                     DeviceDesc,
                                     DriverSigningPolicy,
                                     NoUI,
                                     Error,
                                     LogContext,
                                     Flags,
                                     TargetFile,
                                     NULL
                                    );
}


BOOL
_HandleFailedVerification(
    IN HWND                  Owner,
    IN SetupapiVerifyProblem Problem,
    IN LPCTSTR               ProblemFile,
    IN LPCTSTR               DeviceDesc,          OPTIONAL
    IN DWORD                 DriverSigningPolicy,
    IN BOOL                  NoUI,
    IN DWORD                 Error,
    IN PVOID                 LogContext,          OPTIONAL
    OUT PDWORD               Flags,               OPTIONAL
    IN LPCTSTR               TargetFile,          OPTIONAL
    IN HANDLE                hWVTStateData        OPTIONAL
    )

/*++

Routine Description:

    (See pSetupHandleFailedVerification)

Arguments:

    See pSetupHandleFailedVerification, with following differences:

    DriverSigningPolicy - supplies the driver signing policy currently in
        effect.  May be one of the three following values...

        DRIVERSIGN_NONE    -  silently succeed installation of unsigned/
                              incorrectly-signed files.  A PSS log entry will
                              be generated, however.
        DRIVERSIGN_WARNING -  warn the user, but let them choose whether or not
                              they still want to install the problematic file.
                              If the user elects to proceed with the
                              installation,  A PSS log entry will be generated
                              noting this fact.
        DRIVERSIGN_BLOCKING - do not allow the file to be installed
        
    ...potentially OR'ed with DRIVERSIGN_ALLOW_AUTHENTICODE (i.e., high bit
    set).  This flag indicates that policy allows for validation via an
    Authenticode catalog.
                        
    hWVTStateData - optionally supplies a handle that provides WinVerifyTrust
        state data retrieved upon successful validation of an Authenticode
        catalog, in the case where the publisher isn't in the TrustedPublisher
        store.  This handle is used for the Authenticode confirmation dialog
        in order to present the user with explicit information about the
        Authenticode package they're about to install (i.e., publisher, signed
        date, etc.).  NOTE: if this handle is non-NULL, then the 
        DRIVERSIGN_ALLOW_AUTHENTICODE bit must also be set in the specified
        DriverSigningPolicy.

Return Value:

    Boolean value indicating whether the caller should continue.
    If FALSE, then the current operation should be aborted, as the combination
    of system policy and user input indicated that the risk should not
    be taken.
    
    NOTE: If this function returns TRUE (i.e., non-zero), and if the caller
    specified (via the AuthSigPromptUser) that the user was to be prompted 
    regarding their trust of the publisher, then the caller should subsequently
    treat the file and catalog as valid, and validate subsequent files via that
    catalog as if its publisher were in the trusted store (because the user's
    choice last for the duration of the queue committal currently underway).

--*/

{
    BOOL b;
    INT_PTR iRes;
    HANDLE hDialogEvent = NULL;

    MYASSERT(Error != NO_ERROR);
    MYASSERT((Problem != SetupapiVerifyNoProblem) && ProblemFile && *ProblemFile);

    //
    // If we're being called to prompt the user about whether they trust an
    // Authenticode publisher, then our ProblemFile had better be a catalog...
    //
    MYASSERT((Error != ERROR_AUTHENTICODE_TRUST_NOT_ESTABLISHED) ||
             (Problem == SetupapiVerifyCatalogProblem));

    //
    // If we already established that the Authenticode publisher should be
    // trusted, then we shouldn't be calling this routine...
    //
    MYASSERT(Error != ERROR_AUTHENTICODE_TRUSTED_PUBLISHER);

    //
    // If we've been asked to prompt the user about whether they trust the
    // publisher of an Authenticode catalog, then policy had better indicate
    // that this is OK!
    //
    MYASSERT(!hWVTStateData || (DriverSigningPolicy & DRIVERSIGN_ALLOW_AUTHENTICODE));

    //
    // If we're running non-interactive, then we always silently block,
    // regardless of policy.
    //
    if(GlobalSetupFlags & PSPGF_NONINTERACTIVE) {
        //
        // SPLOG -- log a PSS entry recording this event.
        //
        if(Problem == SetupapiVerifyDriverBlocked) {

            LogFailedVerification(
                (PSETUP_LOG_CONTEXT) LogContext,
                DeviceDesc ? MSG_LOG_DRIVER_BLOCKED_FOR_DEVICE_ERROR_NONINTERACTIVE : MSG_LOG_DRIVER_BLOCKED_ERROR_NONINTERACTIVE,
                Error,
                ProblemFile,
                DeviceDesc,
                DRIVER_LOG_ERROR
                );

        } else {

            LogFailedVerification(
                (PSETUP_LOG_CONTEXT) LogContext,
                DeviceDesc ? MSG_LOG_DRIVER_SIGNING_ERROR_NONINTERACTIVE : MSG_LOG_SIGNING_ERROR_NONINTERACTIVE,
                Error,
                ProblemFile,
                DeviceDesc,
                DRIVER_LOG_ERROR
                );
        }

        return FALSE;
    }

    if(GuiSetupInProgress) {
        hDialogEvent = CreateEvent(NULL,TRUE,FALSE,SETUP_HAS_OPEN_DIALOG_EVENT);
    }

    if(Problem == SetupapiVerifyDriverBlocked) {
        //
        // Handle a driver block failure.
        // only applicable to UNICODE
        // ANSI won't report this problem code
        //
        HSDB hSDBDrvMain = NULL;
        TAGREF tagref = TAGREF_NULL;
        DRIVERBLOCK_PROMPT DriverBlockPrompt = {0};

        //
        // Never continue if the driver is in the bad driver database!
        //
        b = FALSE;

        LogFailedVerification(
            (PSETUP_LOG_CONTEXT) LogContext,
            DeviceDesc ? MSG_LOG_DRIVER_BLOCKED_FOR_DEVICE_ERROR : MSG_LOG_DRIVER_BLOCKED_ERROR,
            Error,
            ProblemFile,
            DeviceDesc,
            DRIVER_LOG_ERROR
            );

        if(!(GlobalSetupFlags & PSPGF_UNATTENDED_SETUP)) {
            //
            // Show the driver blocking UI
            //
            DriverBlockPrompt.lpszFile = (TargetFile != NULL)
                                         ? TargetFile
                                         : ProblemFile;

            if((hSDBDrvMain = SdbInitDatabaseEx(SDB_DATABASE_MAIN_DRIVERS, 
                                                NULL,
                                                DEFAULT_IMAGE))) {

                HANDLE hFile = INVALID_HANDLE_VALUE;

                //
                // We are probably dealing with a temp file name at this point,
                // so we need to get a file handle to pass to SdbGetDatabaseMatch
                // along with the final destination file name.
                //
                hFile = CreateFile(ProblemFile,
                                   GENERIC_READ,
                                   FILE_SHARE_READ,
                                   NULL,
                                   OPEN_EXISTING,
                                   0,
                                   NULL
                                  );
                if (hFile != INVALID_HANDLE_VALUE) {
                    //
                    // Pass the TargetFile (the destination filename) to
                    // SdbGetDatabaseMatch because that will be what is
                    // in the bad driver database.
                    //
                    tagref = SdbGetDatabaseMatch(hSDBDrvMain,
                                                 (TargetFile != NULL)
                                                   ? pSetupGetFileTitle(TargetFile)
                                                   : ProblemFile,
                                                 hFile,
                                                 NULL,
                                                 0);

                    if (tagref != TAGREF_NULL) {
                        SdbReadDriverInformation(hSDBDrvMain,
                                                 tagref,
                                                 &(DriverBlockPrompt.entryinfo));
                    }

                    CloseHandle(hFile);
                }

                SdbReleaseDatabase(hSDBDrvMain);
            }

            //
            // Always call the dialog code, even if we could access the database.
            //
            iRes =  DialogBoxParam(MyDllModuleHandle,
                                   MAKEINTRESOURCE(IDD_DRIVERBLOCK),
                                   IsWindow(Owner) ? Owner : NULL,
                                   DriverBlockDlgProc,
                                   (LPARAM)&DriverBlockPrompt
                                   );
        }

    } else {
        //
        // Handle a digital signature failure.
        //
        // If the policy is block, then the user always gets informed of a 
        // problem (i.e., there is no "yes" option, hence no "yes to all" 
        // semantics).
        //
        CERT_PROMPT CertPrompt;
        AUTHENTICODE_CERT_PROMPT AuthenticodeCertPrompt;

        MYASSERT(((DriverSigningPolicy & ~DRIVERSIGN_ALLOW_AUTHENTICODE) != DRIVERSIGN_BLOCKING) 
                 || !NoUI);

        CertPrompt.lpszDescription = DeviceDesc;
        CertPrompt.lpszFile = ProblemFile;
        CertPrompt.ProblemType = Problem;
        CertPrompt.DriverSigningPolicy = DriverSigningPolicy;

        AuthenticodeCertPrompt.lpszDescription = DeviceDesc;
        AuthenticodeCertPrompt.hWVTStateData = hWVTStateData;
        AuthenticodeCertPrompt.Error = Error;

        switch(DriverSigningPolicy & ~DRIVERSIGN_ALLOW_AUTHENTICODE) {

            case DRIVERSIGN_NONE :

                //
                // SPLOG -- log a PSS entry recording this event.
                //
                LogFailedVerification(
                    (PSETUP_LOG_CONTEXT) LogContext,
                    DeviceDesc ? MSG_LOG_DRIVER_SIGNING_ERROR_POLICY_NONE : MSG_LOG_SIGNING_ERROR_POLICY_NONE,
                    Error,
                    ProblemFile,
                    DeviceDesc,
                    DRIVER_LOG_WARNING
                    );
                //
                // If requested, find out if the file is protected (we may need 
                // to skip it if it's being queued up for delayed copy).
                //
                if(Flags && TargetFile) {

                    MYASSERT(Error != ERROR_AUTHENTICODE_TRUST_NOT_ESTABLISHED);

                    if(IsFileProtected(TargetFile,
                                       (PSETUP_LOG_CONTEXT)LogContext,
                                       NULL)) {

                        *Flags = IQF_TARGET_PROTECTED;
                    }
                }

                b = TRUE;
                goto exit;

            case DRIVERSIGN_WARNING :
                if(NoUI) {
                    //
                    // SPLOG -- log a PSS entry recording this event.
                    //
                    LogFailedVerification(
                        (PSETUP_LOG_CONTEXT) LogContext,
                        DeviceDesc ? MSG_LOG_DRIVER_SIGNING_ERROR_AUTO_YES : MSG_LOG_SIGNING_ERROR_AUTO_YES,
                        Error,
                        ProblemFile,
                        DeviceDesc,
                        ((Error == ERROR_AUTHENTICODE_TRUST_NOT_ESTABLISHED)
                            ? DRIVER_LOG_INFO
                            : DRIVER_LOG_WARNING)
                        );

                    iRes = IDC_VERIFY_WARN_YES;

                } else if(GlobalSetupFlags & PSPGF_UNATTENDED_SETUP) {
                    //
                    // SPLOG -- log a PSS entry recording this event.
                    //
                    LogFailedVerification(
                        (PSETUP_LOG_CONTEXT) LogContext,
                        DeviceDesc ? MSG_LOG_DRIVER_SIGNING_ERROR_AUTO_NO : MSG_LOG_SIGNING_ERROR_AUTO_NO,
                        Error,
                        ProblemFile,
                        DeviceDesc,
                        DRIVER_LOG_ERROR
                        );

                    iRes = IDC_VERIFY_WARN_NO;

                } else {
                    if (hDialogEvent) {
                       SetEvent(hDialogEvent);
                    }

                    if(DriverSigningPolicy & DRIVERSIGN_ALLOW_AUTHENTICODE) {

                        if(AuthenticodeCertPrompt.Error == ERROR_AUTHENTICODE_TRUST_NOT_ESTABLISHED) {

                            iRes =  DialogBoxParam(MyDllModuleHandle,
                                                   AuthenticodeCertPrompt.lpszDescription ?
                                                       MAKEINTRESOURCE(IDD_DEVICE_VERIFY_AUTHENTICODE) :
                                                       MAKEINTRESOURCE(IDD_SOFTWARE_VERIFY_AUTHENTICODE),
                                                   IsWindow(Owner) ? Owner : NULL,
                                                   AuthenticodeCertifyDlgProc,
                                                   (LPARAM)&AuthenticodeCertPrompt
                                                  );
                        } else {
                            iRes =  DialogBoxParam(MyDllModuleHandle,
                                                   AuthenticodeCertPrompt.lpszDescription ?
                                                       MAKEINTRESOURCE(IDD_DEVICE_VERIFY_NO_AUTHENTICODE) :
                                                       MAKEINTRESOURCE(IDD_SOFTWARE_VERIFY_NO_AUTHENTICODE),
                                                   IsWindow(Owner) ? Owner : NULL,
                                                   NoAuthenticodeCertifyDlgProc,
                                                   (LPARAM)&AuthenticodeCertPrompt
                                                  );
                        }

                    } else {
                        iRes =  DialogBoxParam(MyDllModuleHandle,
                                               CertPrompt.lpszDescription ?
                                                   MAKEINTRESOURCE(IDD_DEVICE_VERIFY_WARNING) :
                                                   MAKEINTRESOURCE(IDD_SOFTWARE_VERIFY_WARNING),
                                               IsWindow(Owner) ? Owner : NULL,
                                               CertifyDlgProc,
                                               (LPARAM)&CertPrompt
                                              );
                    }

                    LogFailedVerification(
                        (PSETUP_LOG_CONTEXT) LogContext,
                        DeviceDesc
                            ?(iRes == IDC_VERIFY_WARN_YES ? MSG_LOG_DRIVER_SIGNING_ERROR_WARN_YES : MSG_LOG_DRIVER_SIGNING_ERROR_WARN_NO)
                            :(iRes == IDC_VERIFY_WARN_YES ? MSG_LOG_SIGNING_ERROR_WARN_YES : MSG_LOG_SIGNING_ERROR_WARN_NO),
                        Error,
                        ProblemFile,
                        DeviceDesc,
                        ((Error == ERROR_AUTHENTICODE_TRUST_NOT_ESTABLISHED)
                            ? ((iRes == IDC_VERIFY_WARN_YES) ? DRIVER_LOG_INFO    : DRIVER_LOG_ERROR)
                            : ((iRes == IDC_VERIFY_WARN_YES) ? DRIVER_LOG_WARNING : DRIVER_LOG_ERROR))
                        );
                }
                break;

        case DRIVERSIGN_BLOCKING :

                if(GlobalSetupFlags & PSPGF_UNATTENDED_SETUP) {
                    //
                    // During UNATTENDED, we block silently
                    //
                    LogFailedVerification(
                        (PSETUP_LOG_CONTEXT) LogContext,
                        DeviceDesc ? MSG_LOG_DRIVER_SIGNING_ERROR_SILENT_BLOCK : MSG_LOG_SIGNING_ERROR_SILENT_BLOCK,
                        Error,
                        ProblemFile,
                        DeviceDesc,
                        DRIVER_LOG_ERROR
                        );

                    iRes = IDC_VERIFY_BLOCK_OK;

                } else {

                    LogFailedVerification(
                        (PSETUP_LOG_CONTEXT) LogContext,
                        DeviceDesc ? MSG_LOG_DRIVER_SIGNING_ERROR_POLICY_BLOCK : MSG_LOG_SIGNING_ERROR_POLICY_BLOCK,
                        Error,
                        ProblemFile,
                        DeviceDesc,
                        DRIVER_LOG_ERROR
                        );

                    if (hDialogEvent) {
                        SetEvent(hDialogEvent);
                    }
                    iRes =  DialogBoxParam(MyDllModuleHandle,
                                           CertPrompt.lpszDescription ?
                                               MAKEINTRESOURCE(IDD_DEVICE_VERIFY_BLOCK) :
                                               MAKEINTRESOURCE(IDD_SOFTWARE_VERIFY_BLOCK),
                                           IsWindow(Owner) ? Owner : NULL,
                                           CertifyDlgProc,
                                           (LPARAM)&CertPrompt
                                          );
                }
                break;

            default :
                //
                // We don't know about any other policy values!
                //
                MYASSERT(0);
                b = FALSE;
                goto exit;
        }

        switch(iRes) {

            case IDC_VERIFY_WARN_NO:
            case IDC_VERIFY_BLOCK_OK:
                b = FALSE;
                break;

            case IDC_VERIFY_WARN_YES:
                if(TargetFile) {
                    pSetupExemptFileFromProtection(TargetFile,
                                                   (DWORD) -1,
                                                   (PSETUP_LOG_CONTEXT)LogContext,
                                                   Flags
                                                  );
                }

                b = TRUE;
                break;

            default:
                //
                // Shouldn't get any other values.
                //
                MYASSERT(0);
                b = FALSE;
        }
    }

exit:
    if(hDialogEvent) {
        ResetEvent(hDialogEvent);
        CloseHandle(hDialogEvent);
    }

    return b;
}


INT_PTR
CALLBACK
CertifyDlgProc(
    IN HWND hwnd,
    IN UINT msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )

/*++

Routine Description:

    This is the dialog procedure for the driver signing UI that is presented to
    the user when a verification failure is encountered.  This dialog handles
    both the 'warn' and 'block' cases.

--*/

{
    LOGFONT LogFont;
    HFONT hFontBold = NULL;
    HICON hIcon = NULL;
    OSVERSIONINFOEX osVersionInfoEx;

    PCERT_PROMPT lpCertPrompt;

    lpCertPrompt = (PCERT_PROMPT)GetWindowLongPtr(hwnd, DWLP_USER);

    switch(msg) {

        case WM_INITDIALOG:
            SetWindowLongPtr(hwnd, DWLP_USER, lParam);
            MessageBeep(MB_ICONASTERISK);
            lpCertPrompt = (PCERT_PROMPT)lParam;

            //
            // If lpszDescription is not NULL then this is the device verify
            // warning dialog, otherwise it is the software warning dialog.
            //
            if(lpCertPrompt->lpszDescription != NULL) {
                SetDlgItemText(hwnd, IDC_VERIFY_FILENAME, lpCertPrompt->lpszDescription);
                SetDlgText(hwnd, IDC_VERIFY_BOLD, IDS_DEVICE_VERIFY_MSG1, IDS_DEVICE_VERIFY_MSG2);
            } else {
                SetDlgText(hwnd, IDC_VERIFY_BOLD, IDS_SOFTWARE_VERIFY_MSG1, IDS_SOFTWARE_VERIFY_MSG2);
            }

            //
            // Create the bold font and bold any necessary text.
            //
            hFontBold = (HFONT)SendMessage(GetDlgItem(hwnd, IDC_VERIFY_BOLD),
                                           WM_GETFONT, 0, 0);
            GetObject(hFontBold, sizeof(LogFont), &LogFont);
            LogFont.lfWeight = FW_BOLD;
            hFontBold = CreateFontIndirect(&LogFont);
            if (hFontBold) {
                SetWindowFont(GetDlgItem(hwnd, IDC_VERIFY_BOLD), hFontBold, TRUE);
            }

            //
            // Set the appropriate warning or error icon.
            //
            // (We shouldn't be here if policy is "Ignore", nor if we're
            // allowing for Authenticode signatures.)
            //
            MYASSERT((lpCertPrompt->DriverSigningPolicy == DRIVERSIGN_WARNING) ||
                     ((lpCertPrompt->DriverSigningPolicy & ~DRIVERSIGN_ALLOW_AUTHENTICODE) == DRIVERSIGN_BLOCKING));

            hIcon = LoadIcon(NULL,
                            (lpCertPrompt->DriverSigningPolicy == DRIVERSIGN_WARNING) ?
                                IDI_WARNING :
                                IDI_ERROR
                            );
            SendDlgItemMessage(hwnd, IDC_VERIFY_ICON, STM_SETICON, (WPARAM)hIcon, 0L);

            //
            // The link won't work in GUI mode setup since help center has not yet
            // been installed, so we will just show the static text instead.
            //
            ShowWindow(GetDlgItem(hwnd, IDC_VERIFY_TESTING_LINK), !GuiSetupInProgress);
            ShowWindow(GetDlgItem(hwnd, IDC_VERIFY_TESTING_TEXT), GuiSetupInProgress);

            //
            // If we are in GUI mode setup then we want to change the text of
            // the buttons to be "Yes" and "No".  We also add the following line
            // of text: "Do you want to continue installing the software for
            // this hardware?"
            //
            ShowWindow(GetDlgItem(hwnd, IDC_VERIFY_SETUP_TEXT), GuiSetupInProgress);

            if (GuiSetupInProgress) {
                TCHAR szButtonText[MAX_PATH];

                if (LoadString(MyDllModuleHandle, IDS_YES, szButtonText, SIZECHARS(szButtonText))) {
                    SetDlgItemText(hwnd, IDC_VERIFY_WARN_YES, szButtonText);
                }

                if (LoadString(MyDllModuleHandle, IDS_NO, szButtonText, SIZECHARS(szButtonText))) {
                    SetDlgItemText(hwnd, IDC_VERIFY_WARN_NO, szButtonText);
                }
            }

            //
            // Make sure this dialog is in the foreground (at least for this
            // process).
            //
            SetForegroundWindow(hwnd);

            if(lpCertPrompt->DriverSigningPolicy == DRIVERSIGN_WARNING) {
                SetFocus(GetDlgItem(hwnd, IDC_VERIFY_WARN_NO));
            }

            return FALSE;

        case WM_DESTROY:
            if (hFontBold) {
                DeleteObject(hFontBold);
                hFontBold = NULL;
            }

            if (hIcon) {
                DestroyIcon(hIcon);
            }
            break;

        case WM_NOTIFY:
            switch (((NMHDR FAR *)lParam)->code) {
            case NM_RETURN:
            case NM_CLICK:
                //
                // We need to know if this is a server machine or a workstation
                // machine since there are different help topic structures for
                // the different products.
                //
                ZeroMemory(&osVersionInfoEx, sizeof(osVersionInfoEx));
                osVersionInfoEx.dwOSVersionInfoSize = sizeof(osVersionInfoEx);
                if (!GetVersionEx((LPOSVERSIONINFO)&osVersionInfoEx)) {
                    //
                    // If GetVersionEx fails then assume this is a workstation
                    // machine.
                    //
                    osVersionInfoEx.wProductType = VER_NT_WORKSTATION;
                }

                ShellExecute(hwnd,
                             TEXT("open"),
                             TEXT("HELPCTR.EXE"),
                             (osVersionInfoEx.wProductType == VER_NT_WORKSTATION)
                                ? TEXT("HELPCTR.EXE -url hcp://services/subsite?node=TopLevelBucket_4/Hardware&topic=MS-ITS%3A%25HELP_LOCATION%25%5Csysdm.chm%3A%3A/logo_testing.htm")
                                : TEXT("HELPCTR.EXE -url hcp://services/subsite?node=Hardware&topic=MS-ITS%3A%25HELP_LOCATION%25%5Csysdm.chm%3A%3A/logo_testing.htm"),
                             NULL,
                             SW_SHOWNORMAL
                             );
                break;
            }
            break;

        case WM_COMMAND:
            switch(wParam) {

                case IDC_VERIFY_WARN_NO:
                case IDC_VERIFY_WARN_YES:
                case IDC_VERIFY_BLOCK_OK:
                    EndDialog(hwnd, (int)wParam);
                    break;

                default:
                    break;
            }

            break;

        default:
            break;
    }

    return FALSE;
}


PTSTR
GetCryptoErrorString(
    HRESULT hr
    )

/*++

Routine Description:

    This routine takes in an HRESULT error result returned by WinVerifyTrust
    and returns a buffer containing a friendly error string that can be 
    presented to the user.
    
    NOTE: This API calls FormatMessage and so the returned string MUST be freed
    using LocalFree and not MyFree

Arguments:

    hr - HRESULT returned from WinVerifyTrust.

Return Value:

    Pointer to the error string, or NULL if an error occured.

--*/

{
    UINT  ResourceId = 0;
    DWORD_PTR MessageArgument;
    ULONG CchLength;
    PTSTR CryptoError = NULL;
    PTSTR TempBuffer = NULL;
    TCHAR Error[33];

    try {
    
        //
        // See if it maps to some non system error code
        //
        switch (hr) {
            
        case TRUST_E_SYSTEM_ERROR:
        case ERROR_NOT_ENOUGH_MEMORY:
        case ERROR_INVALID_PARAMETER:
            //
            //  Set the resourceid to zero...  these will be mapped to
            //  IDS_SPC_UNKNOWN and the error code displayed.
            //
            ResourceId = 0;
            break;
    
        case HRESULT_FROM_WIN32(ERROR_NOT_FOUND):
            ResourceId = IDS_ELEMENT_NOT_FOUND;
            break;

        case CRYPT_E_FILE_ERROR:
            ResourceId = IDS_FILE_NOT_FOUND;
            break;
    
        case TRUST_E_PROVIDER_UNKNOWN:
            ResourceId = IDS_SPC_PROVIDER;
            break;
    
        case TRUST_E_SUBJECT_FORM_UNKNOWN:
            ResourceId = IDS_SPC_SUBJECT;
            break;
    
        case TRUST_E_NOSIGNATURE:
            ResourceId = IDS_SPC_NO_SIGNATURE;
            break;
    
        case CRYPT_E_BAD_MSG:
            ResourceId = IDS_SPC_BAD_SIGNATURE;
            break;
    
        case TRUST_E_BAD_DIGEST:
            ResourceId = IDS_SPC_BAD_FILE_DIGEST;
            break;
    
        case CRYPT_E_NO_SIGNER:
            ResourceId = IDS_SPC_NO_VALID_SIGNER;
            break;
    
        case TRUST_E_NO_SIGNER_CERT:
            ResourceId = IDS_SPC_SIGNER_CERT;
            break;
    
        case TRUST_E_COUNTER_SIGNER:
            ResourceId = IDS_SPC_VALID_COUNTERSIGNER;
            break;
    
        case CERT_E_EXPIRED:
            ResourceId = IDS_SPC_CERT_EXPIRED;
            break;
    
        case TRUST_E_CERT_SIGNATURE:
            ResourceId = IDS_SPC_CERT_SIGNATURE;
            break;
    
        case CERT_E_CHAINING:
            ResourceId = IDS_SPC_CHAINING;
            break;
    
        case CERT_E_UNTRUSTEDROOT:
            ResourceId = IDS_SPC_UNTRUSTED_ROOT;
            break;
    
        case CERT_E_UNTRUSTEDTESTROOT:
            ResourceId = IDS_SPC_UNTRUSTED_TEST_ROOT;
            break;
    
        case CERT_E_VALIDITYPERIODNESTING:
            ResourceId = IDS_SPC_INVALID_CERT_NESTING;
            break;
    
        case CERT_E_PURPOSE:
            ResourceId = IDS_SPC_INVALID_PURPOSE;
            break;
    
        case TRUST_E_BASIC_CONSTRAINTS:
            ResourceId = IDS_SPC_INVALID_BASIC_CONSTRAINTS;
            break;
    
        case TRUST_E_FINANCIAL_CRITERIA:
            ResourceId = IDS_SPC_INVALID_FINANCIAL;
            break;
    
        case TRUST_E_TIME_STAMP:
            ResourceId = IDS_SPC_TIMESTAMP;
            break;
    
        case CERT_E_REVOKED:
            ResourceId = IDS_SPC_CERT_REVOKED;
            break;
    
        case CERT_E_REVOCATION_FAILURE:
            ResourceId = IDS_SPC_REVOCATION_ERROR;
            break;
    
        case CRYPT_E_SECURITY_SETTINGS:
            ResourceId = IDS_SPC_SECURITY_SETTINGS;
            break;
    
        case CERT_E_MALFORMED:
            ResourceId = IDS_SPC_INVALID_EXTENSION;
            break;
    
        case CERT_E_WRONG_USAGE:
            ResourceId = IDS_WRONG_USAGE;
            break;
    
        default:
            ResourceId = 0;
            break;
        }
    
        //
        // If it does, load the string out of our resource string tables and
        // return that. Otherwise, try to format the message from the system
        //
        if (ResourceId != 0) {
            
            CryptoError = LocalAlloc(LPTR, (MAX_PATH*sizeof(TCHAR)));
            if (CryptoError) {
                CchLength = LoadString(MyDllModuleHandle,
                                       ResourceId,
                                       CryptoError,
                                       MAX_PATH);
    
                //
                // Assert that CchLength is between 0 and MAX_PATH, if it is
                // greater than MAX_PATH then the whole string won't fit into
                // the buffer.
                //
                MYASSERT((CchLength > 0) && (CchLength < MAX_PATH));
    
                //
                // if LoadString returned 0 then free the memory we just allocated
                // and return NULL.
                //
                if (!CchLength) {
                    LocalFree(CryptoError);
                    CryptoError = NULL;
                    leave;
                }
            }
        
        } else if (( hr >= 0x80093000) && (hr <= 0x80093999)) {
    
            TempBuffer = LocalAlloc(LPTR, (MAX_PATH*sizeof(TCHAR)));
            
            if (!TempBuffer) {
                leave;
            }
            
            CchLength = LoadString(MyDllModuleHandle,
                                   IDS_SPC_OSS_ERROR,
                                   TempBuffer,
                                   MAX_PATH);

            //
            // Assert that CchLength is between 0 and MAX_PATH, if it is
            // greater than MAX_PATH then the whole string won't fit into
            // the buffer.
            //
            MYASSERT((CchLength > 0) && (CchLength < MAX_PATH));

            //
            // if LoadString returned 0 then free the memory we just allocated
            // and return NULL.
            //
            if (!CchLength) {
                LocalFree(TempBuffer);
                TempBuffer = NULL;
                leave;
            }

            StringCchPrintf(Error, SIZECHARS(Error), TEXT("%lx"), hr);
            MessageArgument = (DWORD_PTR)Error;
    
            if (FormatMessage(
                      FORMAT_MESSAGE_ALLOCATE_BUFFER |
                      FORMAT_MESSAGE_FROM_STRING |
                      FORMAT_MESSAGE_ARGUMENT_ARRAY,
                      TempBuffer,
                      0,
                      0,
                      (LPWSTR)&CryptoError,
                      0,
                      (va_list *)&MessageArgument
                      ) == 0) {

                CryptoError = NULL;
                leave;
            }
        
        } else {
            
            if (FormatMessage(
                       FORMAT_MESSAGE_ALLOCATE_BUFFER |
                       FORMAT_MESSAGE_IGNORE_INSERTS |
                       FORMAT_MESSAGE_FROM_SYSTEM,
                       NULL,
                       hr,
                       0,
                       (LPWSTR)&CryptoError,
                       0,
                       NULL
                       ) == 0) {
    
                TempBuffer = LocalAlloc(LPTR, (MAX_PATH*sizeof(TCHAR)));
                if (!TempBuffer) {
                    leave;
                }
        
                CchLength = LoadString(MyDllModuleHandle,
                                       IDS_SPC_UNKNOWN,
                                       TempBuffer,
                                       MAX_PATH);
    
                //
                // Assert that CchLength is between 0 and MAX_PATH, if it is
                // greater than MAX_PATH then the whole string won't fit into
                // the buffer.
                //
                MYASSERT((CchLength > 0) && (CchLength < MAX_PATH));
    
                //
                // if LoadString returned 0 then free the memory we just allocated
                // and return NULL.
                //
                if (!CchLength) {
                    LocalFree(TempBuffer);
                    TempBuffer = NULL;
                    leave;
                } 
        
                StringCchPrintf(Error, SIZECHARS(Error), TEXT("%lx"), hr);
                MessageArgument = (DWORD_PTR)Error;
    
                if (FormatMessage(
                        FORMAT_MESSAGE_ALLOCATE_BUFFER |
                        FORMAT_MESSAGE_FROM_STRING |
                        FORMAT_MESSAGE_ARGUMENT_ARRAY,
                        TempBuffer,
                        0,
                        0,
                        (LPWSTR)&CryptoError,
                        0,
                        (va_list *)&MessageArgument
                        ) == 0) {
    
                    MYASSERT(0);
                    CryptoError = NULL;
                    leave;
                }
            }
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        if(CryptoError) {
            LocalFree(CryptoError);
            CryptoError = NULL;
        }
    }

    if (TempBuffer) {
        LocalFree(TempBuffer);
    }

    return CryptoError;
}


INT_PTR
CALLBACK
AuthenticodeCertifyDlgProc(
    IN HWND hwnd,
    IN UINT msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )

/*++

Routine Description:

    This is the dialog procedure for the Authenticode driver signing UI that is 
    presented to the user when a verification failure is encountered for a non-
    WHQL tested class but there is a valid Authenticode signature associated
    with the package.

--*/

{
    HICON hIcon = NULL;
    PAUTHENTICODE_CERT_PROMPT AuthenticodePrompt;
    PCRYPT_PROVIDER_DATA ProviderData;
    PCRYPT_PROVIDER_SGNR ProviderSigner;
    PCRYPT_PROVIDER_CERT ProviderCert;
    FILETIME ftTimestamp;
    SYSTEMTIME stTimestamp;
    PTSTR Provider, Issuer, Timestamp;
    ULONG CchSize;
    TCHAR UnknownBuffer[MAX_PATH];

    AuthenticodePrompt = (PAUTHENTICODE_CERT_PROMPT)GetWindowLongPtr(hwnd, DWLP_USER);

    switch(msg) {

        case WM_INITDIALOG:
            SetWindowLongPtr(hwnd, DWLP_USER, lParam);
            MessageBeep(MB_ICONASTERISK);
            AuthenticodePrompt = (PAUTHENTICODE_CERT_PROMPT)lParam;

            //
            // If lpszDescription is not NULL then this is the device verify
            // warning dialog, otherwise it is the software warning dialog.
            //
            if(AuthenticodePrompt->lpszDescription != NULL) {
                SetDlgItemText(hwnd, IDC_VERIFY_FILENAME, AuthenticodePrompt->lpszDescription);
            }

            //
            // In order to get the publisher, issuer, and timestamp, we have
            // to get the PCRYPT_PROVIDER_CERT structure, which we get from
            // the CRYPT_PROVIDER_SGNR structure, which we get from the
            // CRYPT_PROVIDER_DATA structure.
            //
            Provider = Issuer = Timestamp = NULL;

            ProviderData = WTHelperProvDataFromStateData(AuthenticodePrompt->hWVTStateData);
            MYASSERT(ProviderData);
            if (ProviderData) {
                ProviderSigner = WTHelperGetProvSignerFromChain(ProviderData,
                                                                0,
                                                                FALSE,
                                                                0);
                MYASSERT(ProviderSigner);
                if (ProviderSigner) {
                    ProviderCert = WTHelperGetProvCertFromChain(ProviderSigner, 
                                                                0);
                    MYASSERT(ProviderCert);
                    if (ProviderCert) {
                        //
                        // Get the publisher. 
                        // Note that we want the string to be of the form:
                        // <A>publisher</A> so it will show up as a link.
                        //
                        CchSize = CertGetNameString(ProviderCert->pCert,
                                                    CERT_NAME_SIMPLE_DISPLAY_TYPE,
                                                    0,
                                                    NULL,
                                                    NULL,
                                                    0);
                        if (CchSize > 1) {
                            CchSize += lstrlen(LINK_START) + lstrlen(LINK_END);
                            Provider = MyMalloc(CchSize * sizeof(TCHAR));

                            if (Provider) {
                                if (FAILED(StringCchCopy(Provider, CchSize, LINK_START)) ||
                                    (0 == CertGetNameString(ProviderCert->pCert,
                                                           CERT_NAME_SIMPLE_DISPLAY_TYPE,
                                                           0,
                                                           NULL,
                                                           &Provider[lstrlen(LINK_START)],
                                                           CchSize)) ||
                                    FAILED(StringCchCat(Provider, CchSize, LINK_END))) {
                                    //
                                    // We failed to create the string so just
                                    // free the memory and set Provider to NULL,
                                    // which will cause us to use the generic
                                    // string down below.
                                    //
                                    MYASSERT(0);
                                    MyFree(Provider);
                                    Provider = NULL;
                                }
                            }
                        }

                        //
                        // Get the issuer
                        //
                        CchSize = CertGetNameString(ProviderCert->pCert,
                                                    CERT_NAME_SIMPLE_DISPLAY_TYPE,
                                                    CERT_NAME_ISSUER_FLAG,
                                                    NULL,
                                                    NULL,
                                                    0);
                        if (CchSize > 1) {
                            Issuer = MyMalloc(CchSize * sizeof(TCHAR));

                            if (0 == CertGetNameString(ProviderCert->pCert,
                                                       CERT_NAME_SIMPLE_DISPLAY_TYPE,
                                                       CERT_NAME_ISSUER_FLAG,
                                                       NULL,
                                                       Issuer,
                                                       CchSize)) {
                                //
                                // We failed to create the Issuer string so just
                                // free the memory and set Issuer to NULL, which
                                // will cause us to use the generic string down
                                // below.
                                //
                                MYASSERT(0);
                                MyFree(Issuer);
                                Issuer = NULL;
                            }
                        }

                        //
                        // Get the timestamp
                        //
                        if (FileTimeToLocalFileTime(&ProviderSigner->sftVerifyAsOf,
                                                    &ftTimestamp) &&
                            FileTimeToSystemTime(&ftTimestamp, &stTimestamp)) {

                            int CchDate, CchTime;

                            CchDate = GetDateFormat(LOCALE_USER_DEFAULT,
                                                    DATE_SHORTDATE,
                                                    &stTimestamp,
                                                    NULL,
                                                    NULL,
                                                    0);
                            
                            CchTime = GetTimeFormat(LOCALE_USER_DEFAULT,
                                                    TIME_NOSECONDS,
                                                    &stTimestamp,
                                                    NULL,
                                                    NULL,
                                                    0);

                            MYASSERT(CchDate);
                            MYASSERT(CchTime);
                            if ((CchDate > 0) && (CchTime > 0)) {
                                //
                                // Allocate enough memory to hold the date, the 
                                // time, plus a space inbetween them as well as
                                // the terminating NULL.
                                //
                                Timestamp = MyMalloc((CchDate + CchTime + 2) * sizeof(TCHAR));
                                if (Timestamp) {
                                    if ((0 == GetDateFormat(LOCALE_USER_DEFAULT,
                                                            DATE_SHORTDATE,
                                                            &stTimestamp,
                                                            NULL,
                                                            Timestamp,
                                                            CchDate + 1)) ||
                                        FAILED(StringCchCat(Timestamp, 
                                                            (CchDate + CchTime + 2), 
                                                            TEXT(" "))) ||
                                        (0 == GetTimeFormat(LOCALE_USER_DEFAULT,
                                                            TIME_NOSECONDS,
                                                            &stTimestamp,
                                                            NULL,
                                                            &Timestamp[CchDate+1],
                                                            CchTime + 1))) {
                                        //
                                        // We failed to create the Timestamp 
                                        // string so just free the memory and 
                                        // set Timestamp to NULL, which will 
                                        // cause us to use the generic string 
                                        // down below.
                                        //
                                        MYASSERT(0);
                                        MyFree(Timestamp);
                                        Timestamp = NULL;
                                    }
                                }
                            }
                        }
                    }
                }
            }

            //
            // Set the Provider, Issuer, and Timestamp strings. Note that we
            // will provide "unknown" defaults for Provider and Issuer if
            // they don't exist.
            //
            if (Provider) {
                SetDlgItemText(hwnd, IDC_VERIFY_PUBLISHER_LINK, Provider);
            } else {
                if (LoadString(MyDllModuleHandle,
                               IDS_UNKNOWNPUBLISHER,
                               UnknownBuffer,
                               SIZECHARS(UnknownBuffer))) {
                    SetDlgItemText(hwnd, IDC_VERIFY_PUBLISHER_LINK, UnknownBuffer);
                }
            }

            if (Issuer) {
                if (LoadString(MyDllModuleHandle,
                               IDS_AUTHENTICITY,
                               UnknownBuffer,
                               SIZECHARS(UnknownBuffer))) {
                    StringCchCat(UnknownBuffer, SIZECHARS(UnknownBuffer), Issuer);
                    SetDlgItemText(hwnd, IDC_VERIFY_IDENTITY, UnknownBuffer);
                }
            } else {
                if (LoadString(MyDllModuleHandle,
                               IDS_AUTHENTICITY,
                               UnknownBuffer,
                               SIZECHARS(UnknownBuffer)) &&
                     LoadString(MyDllModuleHandle,
                                IDS_UNKNOWNPUBLISHERCERTISSUER,
                                &UnknownBuffer[lstrlen(UnknownBuffer)],
                                (SIZECHARS(UnknownBuffer) - lstrlen(UnknownBuffer)))) {
                    
                    SetDlgItemText(hwnd, IDC_VERIFY_IDENTITY, UnknownBuffer);
                }
            }

            if (Timestamp) {
                SetDlgItemText(hwnd, IDC_VERIFY_DATE_PUBLISHED, Timestamp);
            }

            //
            // Set the security alert icon.
            //
            hIcon = LoadIcon(MyDllModuleHandle, MAKEINTRESOURCE(IDI_SECURITY));
            SendDlgItemMessage(hwnd, IDC_VERIFY_ICON, STM_SETICON, (WPARAM)hIcon, 0L);

            //
            // Make sure this dialog is in the foreground (at least for this
            // process).
            //
            SetForegroundWindow(hwnd);

            //
            // Set the focus on the "No" button.
            //
            SetFocus(GetDlgItem(hwnd, IDC_VERIFY_WARN_NO));

            return FALSE;

        case WM_DESTROY:
            if (hIcon) {
                DestroyIcon(hIcon);
            }
            break;

        case WM_NOTIFY:
            switch (((NMHDR FAR *)lParam)->code) {
            case NM_RETURN:
            case NM_CLICK:
                switch (((LPNMHDR)lParam)->idFrom) {
                case IDC_VERIFY_TESTING_LINK:
                    //
                    // NTRAID#NTBUG9-707966-2002/09/24-jasonc
                    // We need to change the URL to point to the Authenticode
                    // topic.
                    //
                    ShellExecute(hwnd,
                             TEXT("open"),
                             TEXT("HELPCTR.EXE"),
                             TEXT("HELPCTR.EXE -url hcp://services/subsite?node=TopLevelBucket_4/Hardware&topic=MS-ITS%3A%25HELP_LOCATION%25%5Csysdm.chm%3A%3A/logo_testing.htm"),
                             NULL,
                             SW_SHOWNORMAL
                             );
                    break;

                case IDC_VERIFY_PUBLISHER_LINK:
                    ProviderData = WTHelperProvDataFromStateData(AuthenticodePrompt->hWVTStateData);
                    MYASSERT(ProviderData);

                    if(ProviderData) {
                        ProviderSigner = WTHelperGetProvSignerFromChain(ProviderData,
                                                                        0,
                                                                        FALSE,
                                                                        0);
                        MYASSERT(ProviderSigner);

                        if(ProviderSigner) {

                            ProviderCert = WTHelperGetProvCertFromChain(ProviderSigner, 
                                                                        0);
                            MYASSERT(ProviderCert);

                            if(ProviderCert) {

                                CRYPTUI_VIEWCERTIFICATE_STRUCT vcs;
                                BOOL bPropertiesChanged = FALSE;

                                ZeroMemory(&vcs, sizeof(vcs));
                                vcs.dwSize = sizeof(vcs);
                                vcs.hwndParent = hwnd;
                                vcs.pCryptProviderData = ProviderData;
                                vcs.fpCryptProviderDataTrustedUsage = TRUE;
                                vcs.pCertContext = ProviderCert->pCert;

                                CryptUIDlgViewCertificate(
                                             &vcs,
                                             &bPropertiesChanged);
                            }
                        }
                    }
                    break;
                }
                break;
            }
            break;

        case WM_COMMAND:
            switch(wParam) {

            case IDC_VERIFY_WARN_NO:
            case IDC_VERIFY_WARN_YES:
                EndDialog(hwnd, (int)wParam);
                break;

            case IDC_VERIFY_WARN_MORE_INFO:
                WinHelp(hwnd, TEXT("SECAUTH.HLP"), HELP_CONTEXT, IDH_SECAUTH_SIGNED);                
                break;

            default:
                break;
            }

            break;

        default:
            break;
    }

    return FALSE;
}


INT_PTR
CALLBACK
NoAuthenticodeCertifyDlgProc(
    IN HWND hwnd,
    IN UINT msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )

/*++

Routine Description:

    This is the dialog procedure for the Authenticode driver signing UI that is 
    presented to the user when a verification failure is encountered for a non-
    WHQL tested class.

--*/

{
    HICON hIcon = NULL;
    PAUTHENTICODE_CERT_PROMPT AuthenticodePrompt;
    PTSTR ErrorString;

    AuthenticodePrompt = (PAUTHENTICODE_CERT_PROMPT)GetWindowLongPtr(hwnd, DWLP_USER);

    switch(msg) {

        case WM_INITDIALOG:
            SetWindowLongPtr(hwnd, DWLP_USER, lParam);
            MessageBeep(MB_ICONASTERISK);
            AuthenticodePrompt = (PAUTHENTICODE_CERT_PROMPT)lParam;

            //
            // If lpszDescription is not NULL then this is the device verify
            // warning dialog, otherwise it is the software warning dialog.
            //
            if(AuthenticodePrompt->lpszDescription != NULL) {
                SetDlgItemText(hwnd, IDC_VERIFY_FILENAME, AuthenticodePrompt->lpszDescription);
            }

            ErrorString = GetCryptoErrorString(HRESULT_FROM_SETUPAPI(AuthenticodePrompt->Error));
            if (ErrorString) {
                SetDlgItemText(hwnd, IDC_VERIFY_AUTHENTICODE_PROBLEM, ErrorString);
            }

            //
            // Set the security alert icon.
            //
            hIcon = LoadIcon(NULL,
                            IDI_WARNING
                            );
            SendDlgItemMessage(hwnd, IDC_VERIFY_ICON, STM_SETICON, (WPARAM)hIcon, 0L);

            //
            // Make sure this dialog is in the foreground (at least for this
            // process).
            //
            SetForegroundWindow(hwnd);

            //
            // Set the focus on the "No" button.
            //
            SetFocus(GetDlgItem(hwnd, IDC_VERIFY_WARN_NO));

            return FALSE;

        case WM_DESTROY:
            if (hIcon) {
                DestroyIcon(hIcon);
            }
            break;

        case WM_NOTIFY:
            switch (((NMHDR FAR *)lParam)->code) {
            case NM_RETURN:
            case NM_CLICK:
                switch (((LPNMHDR)lParam)->idFrom) {
                case IDC_VERIFY_TESTING_LINK:
                    //
                    // NTRAID#NTBUG9-707966-2002/09/24-jasonc
                    // We need to change the URL to point to the Authenticode
                    // topic.
                    //
                    ShellExecute(hwnd,
                             TEXT("open"),
                             TEXT("HELPCTR.EXE"),
                             TEXT("HELPCTR.EXE -url hcp://services/subsite?node=TopLevelBucket_4/Hardware&topic=MS-ITS%3A%25HELP_LOCATION%25%5Csysdm.chm%3A%3A/logo_testing.htm"),
                             NULL,
                             SW_SHOWNORMAL
                             );
                    break;
                }
                break;
            }
            break;

        case WM_COMMAND:
            switch(wParam) {

            case IDC_VERIFY_WARN_NO:
            case IDC_VERIFY_WARN_YES:
                EndDialog(hwnd, (int)wParam);
                break;

            case IDC_VERIFY_WARN_MORE_INFO:
                WinHelp(hwnd, TEXT("SECAUTH.HLP"), HELP_CONTEXT, IDH_SECAUTH_UNSIGNED);                
                break;

            default:
                break;
            }

            break;

        default:
            break;
    }

    return FALSE;
}


INT_PTR
CALLBACK
DriverBlockDlgProc(
    IN HWND hwnd,
    IN UINT msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )

/*++

Routine Description:

    This is the dialog procedure for the driver blocking UI that is presented to
    the user when a a driver that is about to be installed is found in the bad
    driver database.

--*/

{
    HICON hIcon = NULL;
    LPTSTR pBuffer = NULL;
    ULONG BufferSize;
    static HAPPHELPINFOCONTEXT hAppHelpInfoContext = NULL;
    static SDBENTRYINFO SdbEntryInfo;

    PDRIVERBLOCK_PROMPT lpDriverBlockPrompt;

    lpDriverBlockPrompt = (PDRIVERBLOCK_PROMPT)GetWindowLongPtr(hwnd, DWLP_USER);

    switch(msg) {

        case WM_INITDIALOG:
            SetWindowLongPtr(hwnd, DWLP_USER, lParam);
            MessageBeep(MB_ICONASTERISK);
            lpDriverBlockPrompt = (PDRIVERBLOCK_PROMPT)lParam;

            hIcon = LoadIcon(MyDllModuleHandle,
                             MAKEINTRESOURCE(IDI_DRIVERBLOCK));

            SendDlgItemMessage(hwnd, IDC_DRIVERBLOCK_ICON, STM_SETICON, (WPARAM)hIcon, 0L);

            hAppHelpInfoContext = SdbOpenApphelpInformation(&lpDriverBlockPrompt->entryinfo.guidDB,
                                                            &lpDriverBlockPrompt->entryinfo.guidID);

            if ((hAppHelpInfoContext) &&
                ((BufferSize = SdbQueryApphelpInformation(hAppHelpInfoContext,
                                                         ApphelpAppName,
                                                         NULL,
                                                         0)) != 0) &&
                (pBuffer = MyMalloc(BufferSize)) &&
                ((BufferSize = SdbQueryApphelpInformation(hAppHelpInfoContext,
                                                         ApphelpAppName,
                                                         pBuffer,
                                                         BufferSize)) != 0)) {
                SetDlgItemText(hwnd, IDC_DRIVERBLOCK_APPNAME, pBuffer);
                MyFree(pBuffer);
            } else if (lpDriverBlockPrompt->lpszFile) {
                SetDlgItemText(hwnd, IDC_DRIVERBLOCK_APPNAME, pSetupGetFileTitle(lpDriverBlockPrompt->lpszFile));
            }

            if ((hAppHelpInfoContext) &&
                ((BufferSize = SdbQueryApphelpInformation(hAppHelpInfoContext,
                                                         ApphelpDetails,
                                                         NULL,
                                                         0)) != 0) &&
                (pBuffer = MyMalloc(BufferSize)) &&
                ((BufferSize = SdbQueryApphelpInformation(hAppHelpInfoContext,
                                                         ApphelpDetails,
                                                         pBuffer,
                                                         BufferSize)) != 0)) {

                SetDlgItemText(hwnd, IDC_DRIVERBLOCK_SUMMARY, pBuffer);
                MyFree(pBuffer);
            }

            //
            // Make sure this dialog is in the foreground (at least for this
            // process).
            //
            SetForegroundWindow(hwnd);
            return FALSE;

        case WM_DESTROY:
            if (hIcon) {
                DestroyIcon(hIcon);
            }
            if (hAppHelpInfoContext) {
                SdbCloseApphelpInformation(hAppHelpInfoContext);
            }
            break;

        case WM_COMMAND:
            switch(LOWORD(wParam)) {
            case IDCANCEL:
                EndDialog(hwnd, (int)wParam);
                break;

            case IDC_DRIVERBLOCK_DETAILS:
                if (hAppHelpInfoContext) {

                    BufferSize = SdbQueryApphelpInformation(hAppHelpInfoContext,
                                                                  ApphelpHelpCenterURL,
                                                                  NULL,
                                                                  0);

                    if (BufferSize && (pBuffer = MyMalloc(BufferSize + (lstrlen(TEXT("HELPCTR.EXE -url ")) * sizeof(TCHAR))))) {
                        lstrcpy(pBuffer, TEXT("HELPCTR.EXE -url "));

                        BufferSize = SdbQueryApphelpInformation(hAppHelpInfoContext,
                                                                ApphelpHelpCenterURL,
                                                                (PVOID)&pBuffer[lstrlen(TEXT("HELPCTR.EXE -url "))],
                                                                BufferSize);

                        if (BufferSize) {
                            ShellExecute(hwnd,
                                         TEXT("open"),
                                         TEXT("HELPCTR.EXE"),
                                         pBuffer,
                                         NULL,
                                         SW_SHOWNORMAL);
                        }

                        MyFree(pBuffer);
                    }
                }
                break;

            default:
                break;
            }

            break;

        default:
            break;
    }

    return FALSE;
}


DWORD
pGetInfOriginalNameAndCatalogFile(
    IN  PLOADED_INF             Inf,                     OPTIONAL
    IN  LPCTSTR                 CurrentName,             OPTIONAL
    OUT PBOOL                   DifferentName,           OPTIONAL
    OUT LPTSTR                  OriginalName,            OPTIONAL
    IN  DWORD                   OriginalNameSize,
    OUT LPTSTR                  OriginalCatalogName,     OPTIONAL
    IN  DWORD                   OriginalCatalogNameSize,
    IN  PSP_ALTPLATFORM_INFO_V2 AltPlatformInfo          OPTIONAL
    )

/*++

Routine Description:

    This routine determines whether a specified inf once had a different
    original name, such as in the case where the Di stuff copied and renamed a
    device inf.

    (Information about an INF's original name comes from the PNF.)

    This routine can also optionally return the original name of the catalog
    file for this INF.

Arguments:

    Inf - optionally, supplies a pointer to a LOADED_INF whose original name
        and catalog file are to be queried.  If this parameter isn't specified,
        then CurrentName must be specified.

    CurrentName - optionally, supplies the path to the INF whose original name
        is to be queried.  If Inf parameter is specified, this parameter is
        ignored.

    DifferentName - optionally, supplies the address of a boolean variable that,
        upon successful return, is set to TRUE if the INF's current name is
        different than its original name.

    OriginalName - if this routine returns successfully, and the DifferentName
        boolean was set to TRUE, then this optional buffer receives
        the INF's original name, which _will not_ be the same as the current
        name.

    OriginalNameSize - supplies size of buffer (bytes for ansi, chars for
        unicode) of OriginalName buffer, or zero if OriginalName is NULL.

    OriginalCatalogName - optionally, supplies a buffer that receives the
        original name of the catalog specified by this INF.  If the catalog
        doesn't specify a catalog file, this buffer will be set to an empty
        string.

    OriginalCatalogNameSize - supplies size, in characters, of
        OriginalCatalogName buffer (zero if buffer not supplied).

    AltPlatformInfo - optionally, supplies the address of a structure describing
        the platform parameters that should be used in formulating the decorated
        CatalogFile= entry to be used when searching for the INF's associated
        catalog file.

Return Value:

    If information is successfully retrieved from the INF, the return value is
    NO_ERROR.  Otherwise, it is a Win32 error code indicating the cause of
    failure.

--*/

{
    DWORD d;
    HINF hInf = INVALID_HANDLE_VALUE;

    MYASSERT((DifferentName && OriginalName && OriginalNameSize) ||
             !(DifferentName || OriginalName || OriginalNameSize));

    MYASSERT((OriginalCatalogName && OriginalCatalogNameSize) ||
             !(OriginalCatalogName || OriginalCatalogNameSize));

    MYASSERT(Inf || CurrentName);

    if(DifferentName) {
        *DifferentName = FALSE;
    }

    if(!Inf) {
        //
        // Open the INF.
        //
        hInf = SetupOpenInfFile(CurrentName,
                                NULL,
                                INF_STYLE_OLDNT | INF_STYLE_WIN4,
                                NULL
                               );

        if(hInf == INVALID_HANDLE_VALUE) {
            return GetLastError();
        }

        //
        // We don't need to lock the INF because it'll never be accessible
        // outside of this routine.
        //
        Inf = (PLOADED_INF)hInf;
    }

    //
    // Enclose in try/except in case we hit an inpage error while using this
    // memory-mapped image.
    //
    d = NO_ERROR;
    try {

        if(DifferentName) {
            if(Inf->OriginalInfName) {
                lstrcpyn(OriginalName, Inf->OriginalInfName, OriginalNameSize);
                *DifferentName = TRUE;
            }
        }

        if(OriginalCatalogName) {

            if(!pSetupGetCatalogFileValue(&(Inf->VersionBlock),
                                          OriginalCatalogName,
                                          OriginalCatalogNameSize,
                                          AltPlatformInfo)) {
                //
                // The INF didn't specify an associated catalog file
                //
                *OriginalCatalogName = TEXT('\0');
            }
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        //
        // If we hit an AV, then use invalid parameter error, otherwise, assume
        // an inpage error when dealing with a mapped-in file.
        //
        d = (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION) ? ERROR_INVALID_PARAMETER : ERROR_READ_FAULT;
    }

    if(hInf != INVALID_HANDLE_VALUE) {
        SetupCloseInfFile(hInf);
    }

    return d;
}

PSECURITY_DESCRIPTOR
pSetupConvertTextToSD(
    IN PCWSTR SDS,
    OUT PULONG SecDescSize
    )
/*++

Routine Description:

    Helper for cfgmgr.lib

    Obtains a binary security descriptor from an SDS
    Resulting buffer must be free'd using LocalFree (not MyFree)
    returns NULL if not supported and sets last error

Arguments:

    SDS - string to obtain security descriptor from

    SecDescSize - filled in with size of security descriptor

Return Value:

    returns security descriptor (use LocalFree to release)
    or NULL with GetLastError indicating error

--*/
{
    SCESTATUS status;
    PSECURITY_DESCRIPTOR pSD = NULL;
    ULONG ulSDSize;
    SECURITY_INFORMATION siSeInfo;

    //
    // If we're in "Disable SCE" mode on embedded, don't do security stuff...
    //
    if(GlobalSetupFlags & PSPGF_NO_SCE_EMBEDDED) {
        SetLastError(ERROR_SCE_DISABLED);
        return NULL;
    }

    try {
        status = SceSvcConvertTextToSD((PWSTR)SDS,&pSD,&ulSDSize,&siSeInfo);
        switch (status ) {
            case SCESTATUS_SUCCESS:
                MYASSERT(pSD);
                MYASSERT(ulSDSize);
                if (SecDescSize) {
                    *SecDescSize = ulSDSize;
                }
                SetLastError(NO_ERROR);
                break;

            case SCESTATUS_INVALID_PARAMETER:
                SetLastError(ERROR_INVALID_PARAMETER);
                pSD = NULL;
                break;

            case SCESTATUS_NOT_ENOUGH_RESOURCE:
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                pSD = NULL;
                break;

            case SCESTATUS_RECORD_NOT_FOUND:
            default:
                SetLastError(ERROR_INVALID_DATA);
                pSD = NULL;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        //
        // If we hit an AV, then use invalid parameter error, otherwise, assume
        // an inpage error when dealing with a mapped-in file.
        //
        SetLastError(ERROR_INVALID_DATA);
        pSD = NULL;
    }
    return pSD;
}

PWSTR
pSetupConvertSDToText(
    IN PSECURITY_DESCRIPTOR SD,
    OUT PULONG pSDSSize
    )
/*++

Routine Description:

    Helper for cfgmgr.lib

    Obtains an SDS from a binary security descriptor
    Resulting buffer must be free'd using LocalFree (not MyFree)
    returns NULL if not supported and sets last error

Arguments:

    SD - security descriptor to convert to a string

    pSDSSize - return size of string

Return Value:

    returns security descriptor string (use LocalFree to release)
    or NULL with GetLastError indicating error

--*/
{
    HINSTANCE Dll_Handle;
    FARPROC SceFileProc;
    SCESTATUS status;
    DWORD LoadStatus;
    SECURITY_INFORMATION securityInformation = 0;
    PSID sid;
    PACL acl;
    BOOLEAN tmp,present;
    LPWSTR SDS = NULL;
    ULONG ulSSDSize;
    SECURITY_INFORMATION siSeInfo;

    //
    // If we're in "Disable SCE" mode on embedded, don't do security stuff...
    //
    if(GlobalSetupFlags & PSPGF_NO_SCE_EMBEDDED) {
        //
        // Report an empty string
        //
        return LocalAlloc(LPTR, sizeof(WCHAR)); // LPTR zeroes out the char
    }

    try {
        //
        // find out what relevent information is in the descriptor
        // up a securityInformation block to go with it.
        //

        status = RtlGetOwnerSecurityDescriptor(SD, &sid, &tmp);

        if(NT_SUCCESS(status) && (sid != NULL)) {
            securityInformation |= OWNER_SECURITY_INFORMATION;
        }

        status = RtlGetGroupSecurityDescriptor(SD, &sid, &tmp);

        if(NT_SUCCESS(status) && (sid != NULL)) {
            securityInformation |= GROUP_SECURITY_INFORMATION;
        }

        status = RtlGetSaclSecurityDescriptor(SD,
                                              &present,
                                              &acl,
                                              &tmp);

        if(NT_SUCCESS(status) && (present)) {
            securityInformation |= SACL_SECURITY_INFORMATION;
        }

        status = RtlGetDaclSecurityDescriptor(SD,
                                              &present,
                                              &acl,
                                              &tmp);

        if(NT_SUCCESS(status) && (present)) {
            securityInformation |= DACL_SECURITY_INFORMATION;
        }

        //
        // now obtain an SDS
        //
        status = SceSvcConvertSDToText(SD,securityInformation,&SDS,&ulSSDSize);
        switch (status ) {
            case SCESTATUS_SUCCESS:
                MYASSERT(SDS);
                MYASSERT(ulSSDSize);
                if(pSDSSize != NULL) {
                    *pSDSSize = ulSSDSize;
                }
                SetLastError(NO_ERROR);
                break;

            case SCESTATUS_INVALID_PARAMETER:
                SetLastError(ERROR_INVALID_PARAMETER);
                SDS = NULL;
                break;

            case SCESTATUS_NOT_ENOUGH_RESOURCE:
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                SDS = NULL;
                break;

            case SCESTATUS_RECORD_NOT_FOUND:
            default:
                SetLastError(ERROR_INVALID_DATA);
                SDS = NULL;
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        if (SDS) {
            LocalFree(SDS);
        }
        SetLastError(ERROR_INVALID_DATA);
        SDS = NULL;
    }
    return SDS;
}

DWORD
pSetupCallSCE(
    IN DWORD Operation,
    IN PCWSTR FullName,
    IN PSP_FILE_QUEUE Queue,
    IN PCWSTR String1,
    IN DWORD Index1,
    IN PSECURITY_DESCRIPTOR SecDesc  OPTIONAL
    )
/*

    Operation ST_SCE_SET : - Sets security on a File in File Queue and informs SCE database
    FullName : - Filename (Needed)
    Queue    : - Pointer to FileQueue (Needed)
    Index    : - Index in String Table of Queue (Needed)

    Operation ST_SCE_RENAME : - Sets security on a File in File Queue and informs SCE database to
                                record it for the filename mentioned in String1
    FullName : - Filename (Needed)
    Queue    : - Pointer to FileQueue (Needed)
    String1  ; - Filename to record in Database (Needed)
    Index    : - Index in String Table of Queue (Optional - only if it needs to be set otherwise -1)

    Operation ST_SCE_DELETE : - Removes record of file in SCE database
    FullName : - Filename (Needed)

    Operation ST_SCE_UNWIND : - Used for Backup Unwinds when we reset the security on a dirty file
    FullName : - Filename (Needed)
    SecDesc  : - Pointer to Security Descriptor for the original file that we unwind (Needed)

    Operation ST_SCE_SERVICES : - Sets security on a Service and informs SCE database
    FullName : - Service Name (Needed)
    Index    : - Service Style (Needed)
    String1  ; - Security Descriptor string

    Operation ST_SCE_SDS_TO_BIN : - Sets security on a Service and informs SCE database
    FullName : - Service Name (Needed)
    Index    : - Service Style (Needed)
    String1  ; - Security Descriptor string

    In each case, return value is error or NO_ERROR
*/
{

    FARPROC SceFileProc;
    PCWSTR SecurityDescriptor;
    HINSTANCE Dll_Handle;
    DWORD ret, LoadStatus;

    //
    // If we're in "Disable SCE" mode on embedded, don't do security stuff...
    //
    if(GlobalSetupFlags & PSPGF_NO_SCE_EMBEDDED) {
        return NO_ERROR;
    }

    try {
        switch (Operation) {

            case ST_SCE_SET:

                //Get the Security descriptor from the String table of the node

                if( Index1 != -1 ){
                    SecurityDescriptor = pSetupStringTableStringFromId( Queue->StringTable, Index1 );

                    if(!SecurityDescriptor) {
                        ret= NO_ERROR;
                        break;
                    }
                }
                else {
                    ret = NO_ERROR;
                    break;
                }


                ret = SceSetupUpdateSecurityFile((PWSTR)FullName, 0, (PWSTR)SecurityDescriptor );
                break;

            case ST_SCE_RENAME:

                if( Index1 != -1 ) {
                    SecurityDescriptor = pSetupStringTableStringFromId( Queue->StringTable, Index1 );
                } else {
                    SecurityDescriptor = NULL;
                }

                ret = SceSetupMoveSecurityFile( (PWSTR)FullName, (PWSTR)String1, (PWSTR)SecurityDescriptor );
                break;



            case ST_SCE_DELETE:

                ret = SceSetupMoveSecurityFile( (PWSTR)FullName, NULL, NULL );
                break;


            case ST_SCE_UNWIND:

                ret = SceSetupUnwindSecurityFile( (PWSTR)FullName, SecDesc );
                break;

            case ST_SCE_SERVICES:

               if( String1 == NULL ){
                   ret = NO_ERROR;
               } else {
                   ret = SceSetupUpdateSecurityService( (PWSTR)FullName, Index1, (PWSTR)String1 );
               }
               break;

            default:
                MYASSERT(0);
                ret = ERROR_INVALID_DATA;
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        ret = ERROR_INVALID_DATA;
    }
    return ret;
}

VOID
RestoreBootReplacedFile(
    IN PSP_FILE_QUEUE      Queue,
    IN PSP_FILE_QUEUE_NODE QueueNode
    )
/*++

Routine Description:

    This routine restores a file that was renamed in preparation for a bootfile
    installation.

Arguments:

    Queue - queue that contains the bootfile copy operation

    QueueNode - bootfile copy operation being aborted

Return Value:

    None.

--*/
{
    DWORD rc;
    LONG TargetID;
    SP_TARGET_ENT TargetInfo;
    PCTSTR TargetFilename, RenamedFilename;
    BOOL UnPostSucceeded;

    //
    // First, we need to find the corresponding target info node so
    // we can find out what temporary name our file was renamed to.
    //
    rc = pSetupBackupGetTargetByPath((HSPFILEQ)Queue,
                                     NULL, // use Queue's string table
                                     NULL,
                                     QueueNode->TargetDirectory,
                                     -1,
                                     QueueNode->TargetFilename,
                                     &TargetID,
                                     &TargetInfo
                                    );

    if(rc == NO_ERROR) {
        //
        // Has the file previously been renamed (and not yet
        // restored)?
        //
        if((TargetInfo.InternalFlags & (SP_TEFLG_MOVED | SP_TEFLG_RESTORED)) == SP_TEFLG_MOVED) {

            TargetFilename = pSetupFormFullPath(
                                Queue->StringTable,
                                TargetInfo.TargetRoot,
                                TargetInfo.TargetSubDir,
                                TargetInfo.TargetFilename
                               );
            MYASSERT(TargetFilename);

            RenamedFilename = pSetupStringTableStringFromId(
                                Queue->StringTable,
                                TargetInfo.NewTargetFilename
                               );
            MYASSERT(RenamedFilename);

            //
            // Move the renamed file back to its original name.
            //
            RestoreRenamedOrBackedUpFile(TargetFilename,
                                         RenamedFilename,
                                         TRUE,
                                         Queue->LogContext
                                        );
            //
            // Set the flag indicating that this file has been
            // restored, and save this info.
            //
            TargetInfo.InternalFlags |= SP_TEFLG_RESTORED;
            pSetupBackupSetTargetByID((HSPFILEQ)Queue, TargetID, &TargetInfo);

            //
            // Finally, get rid of the delayed-move node that was to
            // delete the renamed file upon reboot.
            //
            UnPostSucceeded = UnPostDelayedMove(Queue,
                                                RenamedFilename,
                                                NULL
                                               );
            MYASSERT(UnPostSucceeded);
        }
    }
}


VOID
pSetupExemptFileFromProtection(
    IN  PCTSTR             FileName,
    IN  DWORD              FileChangeFlags,
    IN  PSETUP_LOG_CONTEXT LogContext,      OPTIONAL
    OUT PDWORD             QueueNodeFlags   OPTIONAL
    )
/*++

Routine Description:

    This routine checks to see if the specified file is a protected system
    file, and if so, it tells SFC to make a replacement exception for this file.

Arguments:

    FileName - Supplies the name of the file for which an exception is being
        requested.

    FileChangeFlags - Supplies the flags to be passed to SfcFileException, if
        this file is determined to be under the protection of SFP.

    LogContext - Optionally, supplies the log context to be used when logging
        information resulting from this request.

    QueueNodeFlags - Optionally, supplies the address of a variable that
        receives one or more of the following queue node flags indicating
        whether the specified file is a protected system file, and whether an
        exception was granted for its replacement:

        IQF_TARGET_PROTECTED - File is a protected system file.
        IQF_ALLOW_UNSIGNED   - An exception has been granted so that the file
                               may be replaced by an unsigned file.

Return Value:

    None.

--*/
{
    HANDLE hSfp;
    PSETUP_LOG_CONTEXT lc = NULL;
    DWORD Result = NO_ERROR;

    if(QueueNodeFlags) {
        *QueueNodeFlags = 0;
    }

    //
    // If the caller didn't supply us with a LogContext, then create our own.
    // We want to do this so that all log entries generated herein will end up
    // in the same section.
    //
    if(!LogContext) {
        if(CreateLogContext(NULL, TRUE, &lc) == NO_ERROR) {
            //
            // success
            //
            LogContext = lc;
        } else {
            lc = NULL;
        }
    }

    if(IsFileProtected(FileName, LogContext, &hSfp)) {

        if(QueueNodeFlags) {
            *QueueNodeFlags = IQF_TARGET_PROTECTED;
        }

        Result = SfcFileException(hSfp,
                                  (PWSTR)FileName,
                                  FileChangeFlags
                                 );

        if(Result == NO_ERROR) {

            WriteLogEntry(
                LogContext,
                SETUP_LOG_ERROR,
                MSG_LOG_SFC_EXEMPT_SUCCESS,
                NULL,
                FileName);

            if(QueueNodeFlags) {
                *QueueNodeFlags |= IQF_ALLOW_UNSIGNED;
            }

        } else {
            WriteLogEntry(
                LogContext,
                SETUP_LOG_ERROR|SETUP_LOG_BUFFER,
                MSG_LOG_SFC_EXEMPT_FAIL,
                NULL,
                FileName);
            WriteLogError(
                LogContext,
                SETUP_LOG_ERROR,
                Result);
        }

        SfcClose(hSfp);

        //
        // If we created our own local LogContext, we can free it now.
        //
        if(lc) {
            DeleteLogContext(lc);
        }
    }
}


BOOL
pSetupProtectedRenamesFlag(
    BOOL bSet
    )
{
    HKEY hKey;
    long rslt = ERROR_SUCCESS;

    if (OSVersionInfo.dwPlatformId != VER_PLATFORM_WIN32_NT) {
        return(TRUE);
    }

    rslt = RegOpenKeyEx(
                 HKEY_LOCAL_MACHINE,
                 TEXT("System\\CurrentControlSet\\Control\\Session Manager"),
                 0,
                 KEY_SET_VALUE,
                 &hKey);

    if (rslt == ERROR_SUCCESS) {
        DWORD Value = bSet ? 1 : 0;
        rslt = RegSetValueEx(
                 hKey,
                 TEXT("AllowProtectedRenames"),
                 0,
                 REG_DWORD,
                 (LPBYTE)&Value,
                 sizeof(DWORD));

        RegCloseKey(hKey);

        if (rslt != ERROR_SUCCESS) {
            DebugPrintEx( DPFLTR_ERROR_LEVEL, TEXT("couldn't RegSetValueEx, ec = %d\n"), rslt );
        }

    } else {
        DebugPrintEx( DPFLTR_ERROR_LEVEL, TEXT("couldn't RegOpenKeyEx, ec = %d\n"), rslt );
    }

    return(rslt == ERROR_SUCCESS);

}


VOID
pSetupUninstallNewCatalogNodes(
    IN PSP_FILE_QUEUE     Queue,
    IN PSETUP_LOG_CONTEXT LogContext OPTIONAL
    )
/*++

Routine Description:

    This routine uninstalls any newly-copied INFs/PNFs/CATs contained in the
    specified linked list of catalog nodes.

Arguments:

    Queue - Supplies a pointer to the file queue (potentially) containing
        newly-copied catalog nodes to be uninstalled.

Return Value:

    None.

--*/
{
    PSPQ_CATALOG_INFO CatalogNode;
    PTSTR InfToUninstall;
    BOOL Locked = FALSE;

    try {

        if(!_pSpUtilsStringTableLock(Queue->StringTable)) {
            leave;
        }

        Locked = TRUE;

        for(CatalogNode = Queue->CatalogList;
            CatalogNode;
            CatalogNode = CatalogNode->Next) {

            if(CatalogNode->Flags & CATINFO_FLAG_NEWLY_COPIED) {

                InfToUninstall = _pSpUtilsStringTableStringFromId(
                                     Queue->StringTable,
                                     CatalogNode->InfFinalPath
                                     );

                MYASSERT(InfToUninstall);

                if(InfToUninstall) {
                    pSetupUninstallOEMInf(InfToUninstall, LogContext, SUOI_FORCEDELETE, NULL);
                }
            }
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        //
        // Reference the following variable so the compiler will respect
        // statement ordering w.r.t. its assignment.
        //
        Locked = Locked;
    }

    if(Locked) {
        _pSpUtilsStringTableUnlock(Queue->StringTable);
    }
}


BOOL
WINAPI
SetupUninstallNewlyCopiedInfs(
    IN HSPFILEQ QueueHandle,
    IN DWORD Flags,
    IN PVOID Reserved
    )

/*++

Routine Description:

    This API uninstalls any INFs (and their associated PNFs and CATs) that
    were previously installed during committal of the specified file queue.

Arguments:

    QueueHandle - Supplies a handle to a committed file queue (potentially)
        containing newly-copied INFs to be uninstalled.

    Flags - Supplies flags that alter the behavior of this API.  Presently, no
        flags are defined.  This parameter must be zero.

    Reserved - Reserved for future use.  This parameter must be NULL.

Return Value:

    If all the parameters were valid, the return value is non-zero (TRUE). Note
    that this does _not_ necessarily mean that any newly-copied INFs were
    uninstalled.

    If there was a problem with the parameters passed in, the return value is
    FALSE, and GetLastError provides more information on the problem.

--*/

{
    PSP_FILE_QUEUE Queue;
    BOOL Success;
    PSETUP_LOG_CONTEXT LogContext;

    if(Flags) {
        SetLastError(ERROR_INVALID_FLAGS);
        return FALSE;
    }

    if(Reserved) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // Queue handle is actually a pointer to the queue structure.
    //
    Queue = (PSP_FILE_QUEUE)QueueHandle;

    //
    // do a quick handle validation before anything else
    //
    try {
        Success = ((Queue != NULL) && (Queue != INVALID_HANDLE_VALUE) && (Queue->Signature == SP_FILE_QUEUE_SIG));
        if(Success) {
            LogContext = Queue->LogContext;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        Success = FALSE;
    }

    if(!Success) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    pSetupUninstallNewCatalogNodes(Queue, LogContext);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\setupapi\fusion.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    fusion.c

Abstract:

    Wrappers and functions for fusionizing SetupAPI
    without effecting 3rd party DLL's
    and without dll-load overhead

Author:

    Jamie Hunter (JamieHun) 12/4/2000

Revision History:

    Jamie Hunter (JamieHun) Apr-28-2002
            Security code review

--*/

#include "precomp.h"
#pragma hdrstop

#undef CreateWindow
#undef CreateWindowEx
#undef CreateDialogParam
#undef CreateDialogIndirectParam
#undef DialogBoxParam
#undef DialogBoxIndirectParam
#undef MessageBox
#undef CreatePropertySheetPage
#undef DestroyPropertySheetPage
#undef PropertySheet
#undef ImageList_Create
#undef ImageList_Destroy
#undef ImageList_GetImageCount
#undef ImageList_SetImageCount
#undef ImageList_Add
#undef ImageList_ReplaceIcon
#undef ImageList_SetBkColor
#undef ImageList_GetBkColor
#undef ImageList_SetOverlayImage

#include <shfusion.h>

static CRITICAL_SECTION spFusionInitCritSec;
static BOOL spInitFusionCritSec = FALSE;
static BOOL spFusionDoneInit = FALSE;

BOOL spFusionInitialize()
/*++

Routine Description:

    Called on DllLoad
    do minimum possible


Arguments:

    none

Return Value:

    TRUE successful initialization

--*/
{
    try {
        InitializeCriticalSection(&spFusionInitCritSec);
        spInitFusionCritSec = TRUE;
    } except (EXCEPTION_EXECUTE_HANDLER) {
        //
        // spInitFusionCritSec remains FALSE
        //
    }
    return spInitFusionCritSec;
}


VOID
spFusionInitLong()
/*++

Routine Description:

    Called by internal stub to do real initialization


Arguments:

    none

Return Value:

    none

--*/
{
    BOOL locked = FALSE;
    BOOL success = FALSE;
    INITCOMMONCONTROLSEX CommCtrl;

    if(!spInitFusionCritSec) {
        //
        // critical section not initialized
        // probably out of memory
        // bail
        //
        MYASSERT(spInitFusionCritSec);
        spFusionDoneInit = TRUE;
        return;
    }
    try {
        EnterCriticalSection(&spFusionInitCritSec);
        locked = TRUE;
    } except(EXCEPTION_EXECUTE_HANDLER) {
    }
    if(!locked) {
        //
        // wasn't able to grab lock - probably out of memory
        // bail
        //
        spFusionDoneInit = TRUE;
        return;
    }

    if(spFusionDoneInit) {
        //
        // by the time we grabbed critical section
        // initialization was done
        // bail
        //
        LeaveCriticalSection(&spFusionInitCritSec);
        return;
    }

    //
    // call shell's fusion enabler
    //
    success = SHFusionInitializeFromModuleID(MyDllModuleHandle,IDR_MANIFEST);
    MYASSERT(success);
    ZeroMemory(&CommCtrl,sizeof(CommCtrl));
    CommCtrl.dwSize = sizeof(CommCtrl);
    CommCtrl.dwICC = ICC_WIN95_CLASSES | ICC_LINK_CLASS;
    success = InitCommonControlsEx(&CommCtrl);
    MYASSERT(success);

    //
    // at this point, it's now safe for anyone else to assume initialization is done
    // even if we haven't released critical section
    //
    spFusionDoneInit = TRUE;

    LeaveCriticalSection(&spFusionInitCritSec);
}

__inline
VOID
spFusionCheckInit()
/*++

Routine Description:

    Calls spFusionInitLong iff needed

Arguments:

    none

Return Value:

    none

--*/
{
    if(!spFusionDoneInit) {
        //
        // either not initialized, or currently going through initialization
        //
        spFusionInitLong();
    }
}

BOOL spFusionUninitialize(BOOL Full)
/*++

Routine Description:

    Called at DLL exit (if DLL being unloaded but not process Exit)

Arguments:

    none

Return Value:

    TRUE successful cleanup

--*/
{
    //
    // cleanup anything initialized at spFusionInitialize
    //
    if(spInitFusionCritSec) {
        DeleteCriticalSection(&spFusionInitCritSec);
        spInitFusionCritSec = FALSE;
    }
    if(Full && spFusionDoneInit) {
        SHFusionUninitialize();
    }
    return TRUE;
}

//
// generic functions for dealing with 3rd party DLL's
// that might be fusionized
//

HANDLE
spFusionContextFromModule(
    IN PCTSTR ModuleName
    )
/*++

Routine Description:

    Called to get a fusion context for specified module name
    given blah.dll look for
        1) blah.dll.manifest in same directory as blah.dll
        2) blah.dll with a fusion resource ID 123.
    If either of these provide a valid manifest, use it
    otherwise use app global manifest.

Arguments:

    fully qualified name of module that'll later be passed into LoadLibrary

Return Value:

    fusion context, or NULL to indicate app-global

--*/
{
    ACTCTX act = { 0 };
    HANDLE hContext;
    TCHAR ManifestName[MAX_PATH];
    PTSTR End;

    act.cbSize = sizeof(act);

    if(FAILED(StringCchCopy(ManifestName,MAX_PATH,ModuleName))) {
        goto deflt;
    }
    if(GetFileAttributes(ManifestName) == -1) {
        //
        // didn't find DLL?
        //
        goto deflt;
    }

    if(FAILED(StringCchCat(ManifestName,SIZECHARS(ManifestName),TEXT(".Manifest")))) {
        goto deflt;
    }
    if(GetFileAttributes(ManifestName) != -1) {
        //
        // found manifest
        //
        act.lpSource = ManifestName;
        act.dwFlags = 0;
        hContext = CreateActCtx(&act);
        if(hContext != INVALID_HANDLE_VALUE) {
            //
            // we created context based on manifest file
            //
            return hContext;
        }
    }

deflt:
    //
    // if the dll has a manifest resource
    // then use that
    //
    act.lpSource = ModuleName;
//    act.dwFlags = ACTCTX_FLAG_RESOURCE_NAME_VALID;
//    act.lpResourceName = MAKEINTRESOURCE(123);
    act.dwFlags = 0;

    hContext = CreateActCtx(&act);

    if(hContext != INVALID_HANDLE_VALUE) {
        //
        // we created context based on resource
        //
        return hContext;
    }
    //
    // if we couldn't find an alternative, use app-global
    //
    return NULL;
}

BOOL
spFusionKillContext(
    IN HANDLE hContext
    )
/*++

Routine Description:

    Release a context previously obtained by
    spFusionContextFromModule

Arguments:

    fusion context

Return Value:

    TRUE (always)

--*/
{
    if(hContext) {
        ReleaseActCtx(hContext);
    }
    return TRUE;
}

BOOL
spFusionEnterContext(
    IN  HANDLE hContext,
    OUT PSPFUSIONINSTANCE pInst
    )
/*++

Routine Description:

    Enter into a manifest context
    status of call is saved into pInst
    so that return value does not need
    to be checked

Arguments:

    hContext = fusion context
    pInst    = structure to save the "push" information

Return Value:

    TRUE if success, FALSE otherwise

--*/
{
    pInst->Acquired = ActivateActCtx(hContext,&pInst->Cookie);
    MYASSERT(pInst->Acquired);
    return pInst->Acquired;
}

BOOL
spFusionLeaveContext(
    IN PSPFUSIONINSTANCE pInst
    )
/*++

Routine Description:

    If pInst indicates that spFusionEnterContext
    succeeded, leave same context

Arguments:

    pInst = structure initialized by spFusionEnterContext

Return Value:

    TRUE if spFusionEnterContext succeeded, FALSE otherwise

--*/
{
    if(pInst->Acquired) {
        pInst->Acquired = FALSE;
        DeactivateActCtx(0,pInst->Cookie);
        return TRUE;
    } else {
        return FALSE;
    }
}

HWND spFusionCreateWindow(
            LPCTSTR lpClassName,  // registered class name
            LPCTSTR lpWindowName, // window name
            DWORD dwStyle,        // window style
            int x,                // horizontal position of window
            int y,                // vertical position of window
            int nWidth,           // window width
            int nHeight,          // window height
            HWND hWndParent,      // handle to parent or owner window
            HMENU hMenu,          // menu handle or child identifier
            HINSTANCE hInstance,  // handle to application instance
            LPVOID lpParam        // window-creation data
            )
{
    spFusionCheckInit();
    return SHFusionCreateWindow(lpClassName,
                                lpWindowName,
                                dwStyle,
                                x,
                                y,
                                nWidth,
                                nHeight,
                                hWndParent,
                                hMenu,
                                hInstance,
                                lpParam
                                );
}

HWND spFusionCreateWindowEx(
            DWORD dwExStyle,      // extended window style
            LPCTSTR lpClassName,  // registered class name
            LPCTSTR lpWindowName, // window name
            DWORD dwStyle,        // window style
            int x,                // horizontal position of window
            int y,                // vertical position of window
            int nWidth,           // window width
            int nHeight,          // window height
            HWND hWndParent,      // handle to parent or owner window
            HMENU hMenu,          // menu handle or child identifier
            HINSTANCE hInstance,  // handle to application instance
            LPVOID lpParam        // window-creation data
            )
{
    spFusionCheckInit();
    return SHFusionCreateWindowEx(dwExStyle,
                                  lpClassName,
                                  lpWindowName,
                                  dwStyle,
                                  x,
                                  y,
                                  nWidth,
                                  nHeight,
                                  hWndParent,
                                  hMenu,
                                  hInstance,
                                  lpParam
                                  );
}

HWND spFusionCreateDialogParam(
            HINSTANCE hInstance,     // handle to module
            LPCTSTR lpTemplateName,  // dialog box template
            HWND hWndParent,         // handle to owner window
            DLGPROC lpDialogFunc,    // dialog box procedure
            LPARAM dwInitParam       // initialization value
    )
{
    spFusionCheckInit();
    return SHFusionCreateDialogParam(
                            hInstance,
                            lpTemplateName,
                            hWndParent,
                            lpDialogFunc,
                            dwInitParam
                            );
}

HWND spFusionCreateDialogIndirectParam(
            HINSTANCE hInstance,        // handle to module
            LPCDLGTEMPLATE lpTemplate,  // dialog box template
            HWND hWndParent,            // handle to owner window
            DLGPROC lpDialogFunc,       // dialog box procedure
            LPARAM lParamInit           // initialization value
    )
{
    spFusionCheckInit();
    return SHFusionCreateDialogIndirectParam(
                            hInstance,
                            lpTemplate,
                            hWndParent,
                            lpDialogFunc,
                            lParamInit
                            );
}

INT_PTR spFusionDialogBoxParam(
            HINSTANCE hInstance,     // handle to module
            LPCTSTR lpTemplateName,  // dialog box template
            HWND hWndParent,         // handle to owner window
            DLGPROC lpDialogFunc,    // dialog box procedure
            LPARAM dwInitParam       // initialization value
    )
{
    spFusionCheckInit();
    return SHFusionDialogBoxParam(
                            hInstance,
                            lpTemplateName,
                            hWndParent,
                            lpDialogFunc,
                            dwInitParam
                            );
}

INT_PTR spFusionDialogBoxIndirectParam(
            HINSTANCE hInstance,             // handle to module
            LPCDLGTEMPLATE hDialogTemplate,  // dialog box template
            HWND hWndParent,                 // handle to owner window
            DLGPROC lpDialogFunc,            // dialog box procedure
            LPARAM dwInitParam               // initialization value
    )
{
    spFusionCheckInit();
    return SHFusionDialogBoxIndirectParam(
                            hInstance,
                            hDialogTemplate,
                            hWndParent,
                            lpDialogFunc,
                            dwInitParam
                            );
}

int spFusionMessageBox(
            IN HWND hWnd,
            IN LPCTSTR lpText,
            IN LPCTSTR lpCaption,
            IN UINT uType
            )
{
    ULONG_PTR dwCookie;
    BOOL act;
    int iRes = 0;
    spFusionCheckInit();
    act = SHActivateContext(&dwCookie);
    try {
        iRes = MessageBoxW(
                        hWnd,
                        lpText,
                        lpCaption,
                        uType
                        );
    } finally {
        if(act) {
            SHDeactivateContext(dwCookie);
        }
    }
    return iRes;
}

INT_PTR spFusionPropertySheet(
            LPCPROPSHEETHEADER pPropSheetHeader
    )
{
    spFusionCheckInit();
    return PropertySheetW(pPropSheetHeader);
}

HPROPSHEETPAGE spFusionCreatePropertySheetPage(
            LPPROPSHEETPAGE pPropSheetPage
    )
{
    spFusionCheckInit();
    MYASSERT(pPropSheetPage->dwFlags & PSP_USEFUSIONCONTEXT);
    MYASSERT(!pPropSheetPage->hActCtx);
    MYASSERT(pPropSheetPage->dwSize >= sizeof(PROPSHEETPAGE));

    return CreatePropertySheetPageW(pPropSheetPage);
}

BOOL spFusionDestroyPropertySheetPage(
            HPROPSHEETPAGE hPropSheetPage
            )
{
    spFusionCheckInit();
    return DestroyPropertySheetPage(
                            hPropSheetPage
                            );
}


HIMAGELIST spFusionImageList_Create(int cx, int cy, UINT flags, int cInitial, int cGrow)
{
    spFusionCheckInit();
    return ImageList_Create(
                            cx,
                            cy,
                            flags,
                            cInitial,
                            cGrow
                            );
}

BOOL spFusionImageList_Destroy(HIMAGELIST himl)
{
    spFusionCheckInit();
    return ImageList_Destroy(
                            himl
                            );
}

int spFusionImageList_Add(HIMAGELIST himl, HBITMAP hbmImage, HBITMAP hbmMask)
{
    spFusionCheckInit();
    return ImageList_Add(
                            himl,
                            hbmImage,
                            hbmMask
                            );

}

int spFusionImageList_ReplaceIcon(HIMAGELIST himl, int i, HICON hicon)
{
    spFusionCheckInit();
    return ImageList_ReplaceIcon(
                            himl,
                            i,
                            hicon
                            );
}

COLORREF spFusionImageList_SetBkColor(HIMAGELIST himl, COLORREF clrBk)
{
    spFusionCheckInit();
    return ImageList_SetBkColor(
                            himl,
                            clrBk
                            );
}

BOOL spFusionImageList_SetOverlayImage(HIMAGELIST himl, int iImage, int iOverlay)
{
    spFusionCheckInit();
    return ImageList_SetOverlayImage(
                            himl,
                            iImage,
                            iOverlay
                            );
}

BOOL spFusionGetOpenFileName(LPOPENFILENAME lpofn)
{
    spFusionCheckInit();
    return GetOpenFileNameW(lpofn);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\setupapi\fileutil.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    fileutil.c

Abstract:

    File-related functions for Windows NT Setup API dll.

Author:

    Ted Miller (tedm) 11-Jan-1995

Revision History:

--*/


#include "precomp.h"
#pragma hdrstop
#include <ntverp.h>

//
// This guid is used for file signing/verification.
//
GUID DriverVerifyGuid = DRIVER_ACTION_VERIFY;
GUID AuthenticodeVerifyGuid = WINTRUST_ACTION_GENERIC_VERIFY_V2;

//
// Instantiate exception class GUID.
//
#include <initguid.h>
DEFINE_GUID( GUID_DEVCLASS_WINDOWS_COMPONENT_PUBLISHER, 0xF5776D81L, 0xAE53, 0x4935, 0x8E, 0x84, 0xB0, 0xB2, 0x83, 0xD8, 0xBC, 0xEF );

// Bit 0 indicates policy for filters (0 = critical, 1 = non-critical)
#define DDB_DRIVER_POLICY_CRITICAL_BIT      (1 << 0)
// Bit 1 indicates policy for user-mode setup blocking (0 = block, 1 = no-block)
#define DDB_DRIVER_POLICY_SETUP_NO_BLOCK_BIT   (1 << 1)

#define MIN_HASH_LEN    16
#define MAX_HASH_LEN    20

//
// Global list of device setup classes subject to driver signing policy, along
// with validation platform overrides (where applicable).
//
DRVSIGN_POLICY_LIST GlobalDrvSignPolicyList;

//
// private function prototypes
//
BOOL
ClassGuidInDrvSignPolicyList(
    IN  PSETUP_LOG_CONTEXT       LogContext,           OPTIONAL
    IN  CONST GUID              *DeviceSetupClassGuid, OPTIONAL
    OUT PSP_ALTPLATFORM_INFO_V2 *ValidationPlatform    OPTIONAL
    );

DWORD
_VerifyCatalogFile(
    IN     PSETUP_LOG_CONTEXT      LogContext,
    IN     LPCTSTR                 CatalogFullPath,
    IN     PSP_ALTPLATFORM_INFO_V2 AltPlatformInfo,        OPTIONAL
    IN     BOOL                    UseAuthenticodePolicy,
    IN OUT HCERTSTORE             *hStoreTrustedPublisher, OPTIONAL
    OUT    HANDLE                 *hWVTStateData           OPTIONAL
    );

BOOL
pSetupIsAuthenticodePublisherTrusted(
    IN     PCCERT_CONTEXT  pcSignerCertContext,
    IN OUT HCERTSTORE     *hStoreTrustedPublisher OPTIONAL
    );

BOOL
IsAutoCertInstallAllowed(
    VOID
    );

DWORD
pSetupInstallCertificate(
    IN PCCERT_CONTEXT pcSignerCertContext
    );

//
// helper to determine log level to use
//
__inline
DWORD
GetCatLogLevel(
    IN DWORD Err,
    IN BOOL  DriverLevel
    )
{
    switch(Err) {
        case ERROR_FILE_NOT_FOUND:
        case ERROR_PATH_NOT_FOUND:
        case E_NOTIMPL:
            return (DriverLevel ? DRIVER_LOG_VVERBOSE : SETUP_LOG_VVERBOSE);

        default:
            return (DriverLevel ? DRIVER_LOG_INFO : SETUP_LOG_INFO);
    }
}

DWORD
ReadAsciiOrUnicodeTextFile(
    IN  HANDLE                FileHandle,
    OUT PTEXTFILE_READ_BUFFER Result,
    IN  PSETUP_LOG_CONTEXT    LogContext OPTIONAL
    )

/*++

Routine Description:

    Read in a text file that may be in either ascii or unicode format.
    If the file is ascii, it is assumed to be ANSI format and is converted
    to Unicode.

Arguments:

    FileHandle - Supplies the handle of the text file to be read.

    Result - supplies the address of a TEXTFILE_READ_BUFFER structure that
        receives information about the text file buffer read.  The structure
        is defined as follows:

            typedef struct _TEXTFILE_READ_BUFFER {
                PCTSTR  TextBuffer;
                DWORD   TextBufferSize;
                HANDLE  FileHandle;
                HANDLE  MappingHandle;
                PVOID   ViewAddress;
            } TEXTFILE_READ_BUFFER, *PTEXTFILE_READ_BUFFER;

            TextBuffer - pointer to the read-only character string containing
                the entire text of the file.
                (NOTE: If the file is a Unicode file with a Byte Order Mark
                prefix, this Unicode character is not included in the returned
                buffer.)
            TextBufferSize - size of the TextBuffer (in characters).
            FileHandle - If this is a valid handle (i.e., it's not equal to
                INVALID_HANDLE_VALUE), then the file was already the native
                character type, so the TextBuffer is simply the mapped-in image
                of the file.  This field is reserved for use by the
                DestroyTextFileReadBuffer routine, and should not be accessed.
            MappingHandle - If FileHandle is valid, then this contains the
                mapping handle for the file image mapping.
                This field is reserved for use by the DestroyTextFileReadBuffer
                routine, and should not be accessed.
            ViewAddress - If FileHandle is valid, then this contains the
                starting memory address where the file image was mapped in.
                This field is reserved for use by the DestroyTextFileReadBuffer
                routine, and should not be accessed.

    LogContext - for logging of errors/tracing

Return Value:

    Win32 error value indicating the outcome.

Remarks:

    Upon return from this routine, the caller MUST NOT attempt to close 
    FileHandle.  This routine with either close the handle itself (after it's 
    finished with it, or upon error), or it will store the handle away in the
    TEXTFILE_READ_BUFFER struct, to be later closed via 
    DestroyTextFileReadBuffer().

--*/

{
    DWORD rc;
    DWORD FileSize;
    HANDLE MappingHandle;
    PVOID ViewAddress, TextStartAddress;
    BOOL IsNativeChar;
    UINT SysCodePage = CP_ACP;

    //
    // Map the file for read access.
    //
    rc = pSetupMapFileForRead(
            FileHandle,
            &FileSize,
            &MappingHandle,
            &ViewAddress
            );

    if(rc != NO_ERROR) {
        //
        // We couldn't map the file--close the file handle now.
        //
        CloseHandle(FileHandle);

    } else {
        //
        // Determine whether the file is unicode.  Guard with try/except in
        // case we get an inpage error.
        //
        try {
            //
            // Check to see if the file starts with a Unicode Byte Order Mark
            // (BOM) character (0xFEFF).  If so, then we know that the file
            // is Unicode, and don't have to go through the slow process of
            // trying to figure it out.
            //
            TextStartAddress = ViewAddress;

            if((FileSize >= sizeof(WCHAR)) && (*(PWCHAR)TextStartAddress == 0xFEFF)) {
                //
                // The file has the BOM prefix.  Adjust the pointer to the
                // start of the text, so that we don't include the marker
                // in the text buffer we return.
                //
                IsNativeChar = TRUE;

                ((PWCHAR)TextStartAddress)++;
                FileSize -= sizeof(WCHAR);
            } else {

                IsNativeChar = IsTextUnicode(TextStartAddress,FileSize,NULL);

            }

        } except(pSetupExceptionFilter(GetExceptionCode())) {
            pSetupExceptionHandler(GetExceptionCode(), ERROR_READ_FAULT, &rc);
        }

        if(rc == NO_ERROR) {

            if(IsNativeChar) {
                //
                // No conversion is required--we'll just use the mapped-in
                // image in memory.
                //
                Result->TextBuffer = TextStartAddress;
                Result->TextBufferSize = FileSize / sizeof(TCHAR);
                Result->FileHandle = FileHandle;
                Result->MappingHandle = MappingHandle;
                Result->ViewAddress = ViewAddress;

            } else {

                DWORD NativeCharCount;
                PTCHAR Buffer;

                //
                // Need to convert the file to the native character type.
                // Allocate a buffer that is maximally sized.
                // The maximum size of the unicode text is
                // double the size of the oem text, and would occur
                // when each oem character is single-byte.
                //
                if(Buffer = MyMalloc(FileSize * sizeof(TCHAR))) {

                    try {
                        //
                        // FUTURE-1999/09/01-JamieHun -- Implement ANSI Inf Language=xxxx
                        // Need to come up with a better way of determining
                        // what code-page to interpret INF file under.
                        // Currently we use the install-base.
                        //
                        SysCodePage = CP_ACP;

                        rc = GLE_FN_CALL(0,
                                         NativeCharCount = MultiByteToWideChar(
                                                               SysCodePage,
                                                               MB_PRECOMPOSED,
                                                               TextStartAddress,
                                                               FileSize,
                                                               Buffer,
                                                               FileSize)
                                        );

                    } except(pSetupExceptionFilter(GetExceptionCode())) {
                        pSetupExceptionHandler(GetExceptionCode(), 
                                               ERROR_READ_FAULT, 
                                               &rc
                                              );
                    }

                } else {
                    rc = ERROR_NOT_ENOUGH_MEMORY;
                }

                if(rc == NO_ERROR) {
                    //
                    // If the converted buffer doesn't require the entire block
                    // we allocated, attempt to reallocate the buffer to its
                    // correct size.  We don't care if this fails, since the
                    // buffer we have is perfectly fine (just bigger than we
                    // need).
                    //
                    if(!(Result->TextBuffer = MyRealloc(Buffer, NativeCharCount * sizeof(TCHAR)))) {
                        Result->TextBuffer = Buffer;
                    }

                    Result->TextBufferSize = NativeCharCount;
                    Result->FileHandle = INVALID_HANDLE_VALUE;

                } else {
                    //
                    // Free the buffer, if it was previously allocated.
                    //
                    if(Buffer) {
                        MyFree(Buffer);
                    }
                }
            }
        }

        //
        // If the file was already in native character form and we didn't
        // enounter any errors, then we don't want to close it, because we
        // use the mapped-in view directly.
        //
        if((rc != NO_ERROR) || !IsNativeChar) {
            pSetupUnmapAndCloseFile(FileHandle, MappingHandle, ViewAddress);
        }
    }

    return rc;
}


BOOL
DestroyTextFileReadBuffer(
    IN PTEXTFILE_READ_BUFFER ReadBuffer
    )
/*++

Routine Description:

    Destroy a textfile read buffer created by ReadAsciiOrUnicodeTextFile.

Arguments:

    ReadBuffer - supplies the address of a TEXTFILE_READ_BUFFER structure
        for the buffer to be destroyed.

Return Value:

    BOOLean value indicating success or failure.

--*/
{
    //
    // If our ReadBuffer structure has a valid FileHandle, then we must
    // unmap and close the file, otherwise, we simply need to free the
    // allocated buffer.
    //
    if(ReadBuffer->FileHandle != INVALID_HANDLE_VALUE) {

        return pSetupUnmapAndCloseFile(ReadBuffer->FileHandle,
                                       ReadBuffer->MappingHandle,
                                       ReadBuffer->ViewAddress
                                      );
    } else {

        MyFree(ReadBuffer->TextBuffer);
        return TRUE;
    }
}


BOOL
GetVersionInfoFromImage(
    IN  PCTSTR      FileName,
    OUT PDWORDLONG  Version,
    OUT LANGID     *Language
    )

/*++

Routine Description:

    Retrieve file version and language info from a file.

    The version is specified in the dwFileVersionMS and dwFileVersionLS fields
    of a VS_FIXEDFILEINFO, as filled in by the win32 version APIs. For the
    language we look at the translation table in the version resources and 
    assume that the first langid/codepage pair specifies the language.

    If the file is not a coff image or does not have version resources,
    the function fails. The function does not fail if we are able to retrieve
    the version but not the language.

Arguments:

    FileName - supplies the full path of the file whose version data is desired.

    Version - receives the version stamp of the file. If the file is not a coff 
        image or does not contain the appropriate version resource data, the 
        function fails.

    Language - receives the language id of the file. If the file is not a coff 
        image or does not contain the appropriate version resource data, this 
        will be 0 and the function succeeds.

Return Value:

    TRUE if we were able to retreive at least the version stamp.
    FALSE otherwise.

--*/

{
    DWORD d;
    PVOID VersionBlock = NULL;
    VS_FIXEDFILEINFO *FixedVersionInfo;
    UINT DataLength;
    BOOL b;
    PWORD Translation;
    DWORD Ignored;

    //
    // Assume failure
    //
    b = FALSE;

    try {
        //
        // Get the size of version info block.
        //
        d = GetFileVersionInfoSize((PTSTR)FileName, &Ignored);
        if(!d) {
            leave;
        }

        //
        // Allocate memory block of sufficient size to hold version info block
        //
        VersionBlock = MyMalloc(d);
        if(!VersionBlock) {
            leave;
        }

        //
        // Get the version block from the file.
        //
        if(!GetFileVersionInfo((PTSTR)FileName, 0, d, VersionBlock)) {
            leave;
        }

        //
        // Get fixed version info.
        //
        if(VerQueryValue(VersionBlock,
                         TEXT("\\"),
                         &FixedVersionInfo,
                         &DataLength)) {
            //
            // If we get here, we declare success, even if there is no
            // language.
            //
            b = TRUE;

            //
            // Return version to caller.
            //
            *Version = (((DWORDLONG)FixedVersionInfo->dwFileVersionMS) << 32)
                     + FixedVersionInfo->dwFileVersionLS;

            //
            // Attempt to get language of file. We'll simply ask for the
            // translation table and use the first language id we find in there
            // as *the* language of the file.
            //
            // The translation table consists of LANGID/Codepage pairs.
            //
            if(VerQueryValue(VersionBlock,
                             TEXT("\\VarFileInfo\\Translation"),
                             &Translation,
                             &DataLength)
               && (DataLength >= (2*sizeof(WORD)))) {

                *Language = Translation[0];

            } else {
                //
                // No language
                //
                *Language = 0;
            }
        }

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_READ_FAULT, NULL);
        b = FALSE;
    }

    if(VersionBlock) {
        MyFree(VersionBlock);
    }

    return b;
}


BOOL
pSetupGetVersionInfoFromImage(
    IN  PCTSTR          FileName,
    OUT PULARGE_INTEGER Version,
    OUT LANGID         *Language
    )
/*++

Routine Description:

    See GetVersionInfoFromImage for description
    Semi-public version that uses the more friendly ULARGE_INTEGER

Arguments:

    FileName - supplies the full path of the file whose version data is 
        desired.

    Version - receives the version stamp of the file. If the file is not a coff 
        image or does not contain the appropriate version resource data, the 
        function fails.

    Language - receives the language id of the file. If the file is not a coff 
        image or does not contain the appropriate version resource data, this 
        will be 0 and the function succeeds.

Return Value:

    TRUE if we were able to retreive at least the version stamp.
    FALSE otherwise.

--*/
{
    DWORDLONG privateVersion=0;
    BOOL result;

    result = GetVersionInfoFromImage(FileName, &privateVersion, Language);
    if(result && Version) {
        Version->QuadPart = privateVersion;
    }
    return result;
}


BOOL
AddFileTimeSeconds(
    IN  const FILETIME *Base,
    OUT FILETIME *Target,
    IN  INT Seconds
    )
/*++

Routine Description:

    Bias the filetime by specified number of seconds

Arguments:

    Base    - original file time
    Target  - new file time
    Seconds - number of seconds to bias it by

Return Value:

    If successful, returns TRUE
    If out of bounds, returns FALSE and Target set to be same as Base

--*/
{
    ULARGE_INTEGER Fuddle;

    //
    // bias off FileTimeThen as it's the greater time
    //
    Fuddle.LowPart = Base->dwLowDateTime;
    Fuddle.HighPart = Base->dwHighDateTime;
    Fuddle.QuadPart += 10000000i64 * Seconds;
    if(Fuddle.HighPart < 0x80000000) {
        Target->dwHighDateTime = Fuddle.HighPart;
        Target->dwLowDateTime = Fuddle.LowPart;
        return TRUE;
    } else {
        *Target = *Base;
        return FALSE;
    }
}


DWORD
GetSetFileTimestamp(
    IN     PCTSTR    FileName,
    IN OUT FILETIME *CreateTime,   OPTIONAL
    OUT    FILETIME *AccessTime,   OPTIONAL
    OUT    FILETIME *WriteTime,    OPTIONAL
    IN     BOOL      Set
    )

/*++

Routine Description:

    Get or set a file's timestamp values.

Arguments:

    FileName - supplies full path of file to get or set timestamps

    CreateTime - if specified and the underlying filesystem supports it,
        receives the creation time of the file.

    AccessTime - if specified and the underlying filesystem supports it,
        receives the last access time of the file.

    WriteTime - if specified, receives the last write time of the file.
    
    Set - if TRUE, set the file's timestamp(s) to the caller-supplied value(s).
        Otherwise, simply retrieve the value(s).

Return Value:

    If successful, returns NO_ERROR, otherwise returns the Win32 error
    indicating the cause of failure.

--*/

{
    HANDLE h = INVALID_HANDLE_VALUE;
    DWORD d;

    try {

        d = GLE_FN_CALL(INVALID_HANDLE_VALUE,
                        h = CreateFile(FileName,
                                       Set ? GENERIC_WRITE : GENERIC_READ,
                                       FILE_SHARE_READ | FILE_SHARE_WRITE,
                                       NULL,
                                       OPEN_EXISTING,
                                       0,
                                       NULL)
                       );

        if(d != NO_ERROR) {
            leave;
        }

        if(Set) {

            d = GLE_FN_CALL(FALSE, 
                            SetFileTime(h, CreateTime, AccessTime, WriteTime)
                           );
        } else {
            
            d = GLE_FN_CALL(FALSE,
                            GetFileTime(h, CreateTime, AccessTime, WriteTime)
                           );
        }

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_READ_FAULT, &d);
    }

    if(h != INVALID_HANDLE_VALUE) {
        CloseHandle(h);
    }

    return d;
}


DWORD
RetreiveFileSecurity(
    IN  PCTSTR                FileName,
    OUT PSECURITY_DESCRIPTOR *SecurityDescriptor
    )

/*++

Routine Description:

    Retrieve security information from a file and place it into a buffer.

Arguments:

    FileName - supplies name of file whose security information is desired.

    SecurityDescriptor - If the function is successful, receives pointer
        to buffer containing security information for the file. The pointer
        may be NULL, indicating that there is no security information
        associated with the file or that the underlying filesystem does not
        support file security.

Return Value:

    Win32 error code indicating outcome. If NO_ERROR check the value returned
    in SecurityDescriptor.

    The caller can free the buffer with MyFree() when done with it.

--*/

{
    DWORD d;
    DWORD BytesRequired;
    PSECURITY_DESCRIPTOR p = NULL;

    try {

        BytesRequired = 1024;  // start out with a reasonably-sized buffer

        while(NULL != (p = MyMalloc(BytesRequired))) {

            //
            // Get the security.
            //
            d = GLE_FN_CALL(FALSE,
                            GetFileSecurity(
                                FileName,
                                OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION | DACL_SECURITY_INFORMATION,
                                p,
                                BytesRequired,
                                &BytesRequired)
                           );

            if(d == NO_ERROR) {
                *SecurityDescriptor = p;
                p = NULL; // so we won't try to free it later
                leave;
            }

            //
            // Return an error code, unless we just need a bigger buffer
            //
            MyFree(p);
            p = NULL;

            if(d != ERROR_INSUFFICIENT_BUFFER) {
                leave;
            }

            //
            // Otherwise, we'll try again with a bigger buffer
            //
        }

        //
        // If we get to here, then we failed due to insufficient memory.
        //
        d = ERROR_NOT_ENOUGH_MEMORY;

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_READ_FAULT, &d);
    }

    if(p) {
        MyFree(p);
    }

    return d;
}


DWORD
StampFileSecurity(
    IN PCTSTR               FileName,
    IN PSECURITY_DESCRIPTOR SecurityInfo
    )

/*++

Routine Description:

    Set security information on a file.

Arguments:

    FileName - supplies name of file whose security information is desired.

    SecurityDescriptor - supplies pointer to buffer containing security 
        information for the file. This buffer should have been returned by a 
        call to RetreiveFileSecurity.  If the underlying filesystem does not 
        support file security, the function fails.

Return Value:

    Win32 error code indicating outcome.

--*/

{
    return GLE_FN_CALL(FALSE,
                       SetFileSecurity(FileName,
                                       (OWNER_SECURITY_INFORMATION 
                                           | GROUP_SECURITY_INFORMATION
                                           | DACL_SECURITY_INFORMATION),
                                       SecurityInfo)
                      );
}


DWORD
TakeOwnershipOfFile(
    IN PCTSTR Filename
    )

/*++

Routine Description:

    Sets the owner of a given file to the default owner specified in
    the current process token.

Arguments:

    FileName - supplies fully-qualified path of the file of which to take 
        ownership.

Return Value:

    Win32 error code indicating outcome.

--*/

{
    SECURITY_DESCRIPTOR SecurityDescriptor;
    DWORD Err;
    HANDLE Token;
    DWORD BytesRequired;
    PTOKEN_OWNER OwnerInfo = NULL;

    //
    // Open the process token.
    //
    Err = GLE_FN_CALL(FALSE,
                      OpenProcessToken(GetCurrentProcess(), 
                                       TOKEN_QUERY, 
                                       &Token)
                     );

    if(Err != NO_ERROR) {
        return Err;
    }

    try {
        //
        // Get the current process's default owner sid.
        //
        Err = GLE_FN_CALL(FALSE,
                          GetTokenInformation(Token, 
                                              TokenOwner, 
                                              NULL, 
                                              0, 
                                              &BytesRequired)
                         );

        MYASSERT(Err != NO_ERROR);

        if(Err != ERROR_INSUFFICIENT_BUFFER) {
            leave;
        }

        OwnerInfo = MyMalloc(BytesRequired);
        if(!OwnerInfo) {
            Err = ERROR_NOT_ENOUGH_MEMORY;
            leave;
        }

        Err = GLE_FN_CALL(FALSE,
                          GetTokenInformation(Token,
                                              TokenOwner,
                                              OwnerInfo,
                                              BytesRequired,
                                              &BytesRequired)
                         );

        if(Err != NO_ERROR) {
            leave;
        }

        //
        // Initialize the security descriptor.
        //
        Err = GLE_FN_CALL(FALSE,
                          InitializeSecurityDescriptor(
                              &SecurityDescriptor,
                              SECURITY_DESCRIPTOR_REVISION)
                         );

        if(Err != NO_ERROR) {
            leave;
        }

        Err = GLE_FN_CALL(FALSE,
                          SetSecurityDescriptorOwner(&SecurityDescriptor,
                                                     OwnerInfo->Owner,
                                                     FALSE)
                         );

        if(Err != NO_ERROR) {
            leave;
        }

        //
        // Set file security.
        //
        Err = GLE_FN_CALL(FALSE,
                          SetFileSecurity(Filename,
                                          OWNER_SECURITY_INFORMATION,
                                          &SecurityDescriptor)
                         );

        //
        // Not all filesystems support this operation.
        //
        if(Err == ERROR_NOT_SUPPORTED) {
            Err = NO_ERROR;
        }

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_READ_FAULT, &Err);
    }

    if(OwnerInfo) {
        MyFree(OwnerInfo);
    }

    CloseHandle(Token);
    
    return Err;
}


DWORD
SearchForInfFile(
    IN  PCTSTR            InfName,
    OUT LPWIN32_FIND_DATA FindData,
    IN  DWORD             SearchControl,
    OUT PTSTR             FullInfPath,
    IN  UINT              FullInfPathSize,
    OUT PUINT             RequiredSize     OPTIONAL
    )
/*++

Routine Description:

    This routine searches for an INF file in the manner specified
    by the SearchControl parameter.  If the file is found, its
    full path is returned.

Arguments:

    InfName - Supplies name of INF to search for.  This name is simply
        appended to the two search directory paths, so if the name
        contains directories, the file will searched for in the
        subdirectory under the search directory.  I.e.:

            \foo\bar.inf

        will be searched for as %windir%\inf\foo\bar.inf and
        %windir%\system32\foo\bar.inf.

    FindData - Supplies the address of a Win32 Find Data structure that
        receives information about the file specified (if it is found).

    SearchControl - Specifies the order in which directories should
        be searched:

        INFINFO_DEFAULT_SEARCH : search %windir%\inf, then %windir%\system32

        INFINFO_REVERSE_DEFAULT_SEARCH : reverse of the above

        INFINFO_INF_PATH_LIST_SEARCH : search for the INF in each of the
            directories listed in the DevicePath value entry under:

            HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion.

    FullInfPath - If the file is found, receives the full path of the INF.

    FullInfPathSize - Supplies the size of the FullInfPath buffer (in
        characters).

    RequiredSize - Optionally, receives the number of characters (including
        terminating NULL) required to store the FullInfPath.

Return Value:

    Win32 error code indicating whether the function was successful.  Common
    return values are:

        NO_ERROR if the file was found, and the INF file path returned
            successfully.

        ERROR_INSUFFICIENT_BUFFER if the supplied buffer was not large enough
            to hold the full INF path (RequiredSize will indicated how large
            the buffer needs to be)

        ERROR_FILE_NOT_FOUND if the file was not found.

        ERROR_INVALID_PARAMETER if the SearchControl parameter is invalid.

--*/

{
    PCTSTR PathList;
    TCHAR CurInfPath[MAX_PATH];
    PCTSTR PathPtr, InfPathLocation;
    DWORD PathLength;
    BOOL b, FreePathList;
    DWORD d;

    //
    // Retrieve the path list.
    //
    if(SearchControl == INFINFO_INF_PATH_LIST_SEARCH) {
        //
        // Just use our global list of INF search paths.
        //
        PathList = InfSearchPaths;
        FreePathList = FALSE;
    } else {
        if(!(PathList = AllocAndReturnDriverSearchList(SearchControl))) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        FreePathList = TRUE;
    }

    d = NO_ERROR;
    InfPathLocation = NULL;

    try {
        //
        // Now look for the INF in each path in our MultiSz list.
        //
        for(PathPtr = PathList; *PathPtr; PathPtr += (lstrlen(PathPtr) + 1)) {
            //
            // Concatenate the INF file name with the current search path.
            //
            if(FAILED(StringCchCopy(CurInfPath, SIZECHARS(CurInfPath), PathPtr))) {
                //
                // not a valid path, don't bother trying to do FileExists
                //
                continue;
            }
            if(!pSetupConcatenatePaths(CurInfPath,
                                       InfName,
                                       SIZECHARS(CurInfPath),
                                       &PathLength)) {
                //
                // not a valid path, don't bother trying to do FileExists
                //
                continue;
            }

            d = GLE_FN_CALL(FALSE, FileExists(CurInfPath, FindData));

            if(d == NO_ERROR) {

                if(!(FindData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
                    InfPathLocation = CurInfPath;
                    break;
                }

            } else {
                //
                // See if we got a 'real' error
                //
                if((d != ERROR_NO_MORE_FILES) &&
                   (d != ERROR_FILE_NOT_FOUND) &&
                   (d != ERROR_PATH_NOT_FOUND)) {

                    //
                    // This is a 'real' error, abort the search.
                    //
                    break;
                }

                //
                // reset error to NO_ERROR and continue search
                //
                d = NO_ERROR;
            }
        }

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, &d);
    }

    //
    // Whatever the outcome, we're through with the PathList buffer.
    //
    if(FreePathList) {
        MyFree(PathList);
    }

    if(d != NO_ERROR) {
        return d;
    } else if(!InfPathLocation) {
        return ERROR_FILE_NOT_FOUND;
    }

    if(RequiredSize) {
        *RequiredSize = PathLength;
    }

    if(PathLength > FullInfPathSize) {
        return ERROR_INSUFFICIENT_BUFFER;
    }

    CopyMemory(FullInfPath,
               InfPathLocation,
               PathLength * sizeof(TCHAR)
              );

    return NO_ERROR;
}


DWORD
MultiSzFromSearchControl(
    IN  DWORD  SearchControl,
    OUT PTCHAR PathList,
    IN  DWORD  PathListSize,
    OUT PDWORD RequiredSize  OPTIONAL
    )
/*++

Routine Description:

    This routine takes a search control ordinal and builds a MultiSz list
    based on the search list it specifies.

Arguments:

    SearchControl - Specifies the directory list to be built.  May be one
        of the following values:

        INFINFO_DEFAULT_SEARCH : %windir%\inf, then %windir%\system32

        INFINFO_REVERSE_DEFAULT_SEARCH : reverse of the above

        INFINFO_INF_PATH_LIST_SEARCH : Each of the directories listed in
            the DevicePath value entry under:

            HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion.

    PathList - Supplies the address of a character buffer that will receive
        the MultiSz list.

    PathListSize - Supplies the size, in characters, of the PathList buffer.

    RequiredSize - Optionally, receives the number of characters required
        to store the MultiSz PathList.

        (NOTE:  The user-supplied buffer is used to retrieve the value entry
        from the registry.  Therefore, if the value is a REG_EXPAND_SZ entry,
        the RequiredSize parameter may be set too small on an
        ERROR_INSUFFICIENT_BUFFER error.  This will happen if the buffer was
        too small to retrieve the value entry, before expansion.  In this case,
        calling the API again with a buffer sized according to the RequiredSize
        output may fail with an ERROR_INSUFFICIENT_BUFFER yet again, since
        expansion may require an even larger buffer.)

Return Value:

    If successful, returns NO_ERROR.
    If failure, returns a Win32 error code indicating the cause of the failure.
    
--*/

{
    HKEY hk;
    PCTSTR Path1, Path2;
    PTSTR PathBuffer;
    DWORD RegDataType, PathLength, PathLength1, PathLength2;
    DWORD NumPaths, Err;
    BOOL UseDefaultDevicePath;

    if(PathList) {
        Err = NO_ERROR;  // assume success.
    } else {
        return ERROR_INVALID_PARAMETER;
    }

    UseDefaultDevicePath = FALSE;

    if(SearchControl == INFINFO_INF_PATH_LIST_SEARCH) {
        //
        // Retrieve the INF search path list from the registry.
        //
        if(RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                        pszPathSetup,
                        0,
                        KEY_READ,
                        &hk) != ERROR_SUCCESS) {
            //
            // Fall back to default (just the Inf directory).
            //
            UseDefaultDevicePath = TRUE;

        } else {

            PathBuffer = NULL;

            try {
                //
                // Get the DevicePath value entry.  Support REG_SZ or 
                // REG_EXPAND_SZ data.
                //
                PathLength = PathListSize * sizeof(TCHAR);
                Err = RegQueryValueEx(hk,
                                      pszDevicePath,
                                      NULL,
                                      &RegDataType,
                                      (LPBYTE)PathList,
                                      &PathLength
                                      );
                //
                // Need path length in characters from now on.
                //
                PathLength /= sizeof(TCHAR);

                if(Err == ERROR_SUCCESS) {

                    //
                    // Check if the caller's buffer has room for extra NULL 
                    // terminator.
                    //
                    if(PathLength >= PathListSize) {

                        PathLength++;
                        Err = ERROR_INSUFFICIENT_BUFFER;

                    } else if((RegDataType == REG_SZ) || (RegDataType == REG_EXPAND_SZ)) {
                        //
                        // Convert this semicolon-delimited list to a 
                        // REG_MULTI_SZ.
                        //
                        NumPaths = DelimStringToMultiSz(PathList,
                                                        PathLength,
                                                        TEXT(';')
                                                       );

                        //
                        // Allocate a temporary buffer large enough to hold the 
                        // number of paths in the MULTI_SZ list, each having 
                        // maximum length (plus an extra terminating NULL at 
                        // the end).
                        //
                        if(!(PathBuffer = MyMalloc((NumPaths * MAX_PATH * sizeof(TCHAR))
                                                   + sizeof(TCHAR)))) {

                            Err = ERROR_NOT_ENOUGH_MEMORY;
                            leave;
                        }

                        PathLength = 0;
                        for(Path1 = PathList;
                            *Path1;
                            Path1 += lstrlen(Path1) + 1) {

                            if(RegDataType == REG_EXPAND_SZ) {

                                DWORD SubPathLength;

                                SubPathLength = ExpandEnvironmentStrings(
                                                    Path1,
                                                    PathBuffer + PathLength,
                                                    MAX_PATH
                                                    );

                                if(SubPathLength <= MAX_PATH) {
                                    PathLength += lstrlen(PathBuffer+PathLength) + 1;
                                }

                            } else {

                                if(SUCCEEDED(StringCchCopy(PathBuffer + PathLength,
                                                           MAX_PATH, 
                                                           Path1))) {

                                    PathLength += lstrlen(PathBuffer+PathLength) + 1;
                                }
                            }
                            //
                            // If the last character in this path is a 
                            // backslash, then strip it off.
                            // PathLength at this point includes terminating 
                            // NULL char at PathBuffer[PathLength-1] is (or 
                            // should be) NULL char at PathBuffer[PathLength-2] 
                            // may be '\'
                            //

                            if(*CharPrev(PathBuffer, PathBuffer + PathLength - 1) == TEXT('\\')) {
                                *(PathBuffer + PathLength - 2) = TEXT('\0');
                                PathLength--;
                            }
                        }
                        //
                        // Add additional terminating NULL at the end.
                        //
                        *(PathBuffer + PathLength) = TEXT('\0');

                        if(++PathLength > PathListSize) {
                            Err = ERROR_INSUFFICIENT_BUFFER;
                        } else {
                            CopyMemory(PathList,
                                       PathBuffer,
                                       PathLength * sizeof(TCHAR)
                                      );
                        }

                        MyFree(PathBuffer);
                        PathBuffer = NULL;

                    } else {
                        //
                        // Bad data type--just use the Inf directory.
                        //
                        UseDefaultDevicePath = TRUE;
                    }

                } else if(Err == ERROR_MORE_DATA){
                    Err = ERROR_INSUFFICIENT_BUFFER;
                } else {
                    //
                    // Fall back to default (just the Inf directory).
                    //
                    UseDefaultDevicePath = TRUE;
                }

            } except(pSetupExceptionFilter(GetExceptionCode())) {

                pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, NULL);

                //
                // Fall back to default (just the Inf directory).
                //
                UseDefaultDevicePath = TRUE;

                if(PathBuffer) {
                    MyFree(PathBuffer);
                }
            }

            RegCloseKey(hk);
        }
    }

    if(UseDefaultDevicePath) {

        PathLength = lstrlen(InfDirectory) + 2;

        if(PathLength > PathListSize) {
            Err = ERROR_INSUFFICIENT_BUFFER;
        } else {
            Err = NO_ERROR;
            CopyMemory(PathList, InfDirectory, (PathLength - 1) * sizeof(TCHAR));
            //
            // Add extra NULL to terminate the list.
            //
            PathList[PathLength - 1] = TEXT('\0');
        }

    } else if((Err == NO_ERROR) && (SearchControl != INFINFO_INF_PATH_LIST_SEARCH)) {

        switch(SearchControl) {

            case INFINFO_DEFAULT_SEARCH :
                Path1 = InfDirectory;
                Path2 = SystemDirectory;
                break;

            case INFINFO_REVERSE_DEFAULT_SEARCH :
                Path1 = SystemDirectory;
                Path2 = InfDirectory;
                break;

            default :
                return ERROR_INVALID_PARAMETER;
        }

        PathLength1 = lstrlen(Path1) + 1;
        PathLength2 = lstrlen(Path2) + 1;
        PathLength = PathLength1 + PathLength2 + 1;

        if(PathLength > PathListSize) {
            Err = ERROR_INSUFFICIENT_BUFFER;
        } else {

            CopyMemory(PathList, Path1, PathLength1 * sizeof(TCHAR));
            CopyMemory(&(PathList[PathLength1]), Path2, PathLength2 * sizeof(TCHAR));
            //
            // Add additional terminating NULL at the end.
            //
            PathList[PathLength - 1] = TEXT('\0');
        }
    }

    if(((Err == NO_ERROR) || (Err == ERROR_INSUFFICIENT_BUFFER)) && RequiredSize) {
        *RequiredSize = PathLength;
    }

    return Err;
}


PTSTR
AllocAndReturnDriverSearchList(
    IN DWORD SearchControl
    )
/*++

Routine Description:

    This routine returns a buffer contains a multi-sz list of all directory 
    paths in our driver search path list.

    The buffer returned must be freed with MyFree().

Arguments:

    SearchControl - Specifies the directory list to be retrieved.  May be one
        of the following values:

        INFINFO_DEFAULT_SEARCH : %windir%\inf, then %windir%\system32

        INFINFO_REVERSE_DEFAULT_SEARCH : reverse of the above

        INFINFO_INF_PATH_LIST_SEARCH : Each of the directories listed in
            the DevicePath value entry under:

            HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion.

Returns:

    Pointer to the allocated buffer containing the list, or NULL if a failure
    was encountered (typically, due to out-of-memory).

--*/
{
    PTSTR PathListBuffer = NULL, TrimBuffer = NULL;
    DWORD BufferSize;
    DWORD Err;

    try {
        //
        // Start out with a buffer of MAX_PATH length, which should cover most cases.
        //
        BufferSize = MAX_PATH;

        //
        // Loop on a call to MultiSzFromSearchControl until we succeed or hit 
        // some error other than buffer-too-small.  There are two reasons for
        // this.  First, it is possible that someone could have added a new 
        // path to the registry list between calls, and second, since that
        // routine uses our buffer to retrieve the original (non-expanded)
        // list, it can only report the size it needs to retrieve the
        // unexpanded list.  After it is given enough space to retrieve it,
        // _then_ it can tell us how much space we really need.
        //
        // With all that said, we'll almost never see this call made more than 
        // once.
        //
        while(NULL != (PathListBuffer = MyMalloc((BufferSize+2) * sizeof(TCHAR)))) {

            if((Err = MultiSzFromSearchControl(SearchControl,
                                               PathListBuffer,
                                               BufferSize,
                                               &BufferSize)) == NO_ERROR) {
                //
                // We've successfully retrieved the path list.  If the list is 
                // larger than necessary (the normal case), then trim it down
                // before returning.  (If this fails it's no big deal--we'll 
                // just keep on using the original buffer.)
                //
                TrimBuffer = MyRealloc(PathListBuffer, 
                                       (BufferSize+2) * sizeof(TCHAR)
                                      );
                if(TrimBuffer) {
                    PathListBuffer = TrimBuffer;
                }

                //
                // We succeeded--break out of the loop.
                //
                break;

            } else {
                //
                // Free our current buffer before we find out what went wrong.
                //
                MyFree(PathListBuffer);
                PathListBuffer = NULL;

                if(Err != ERROR_INSUFFICIENT_BUFFER) {
                    //
                    // We failed.
                    //
                    leave;
                }
            }
        }

    } except(pSetupExceptionFilter(GetExceptionCode())) {

        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, NULL);

        if(TrimBuffer) {
            MyFree(TrimBuffer);
        } else if(PathListBuffer) {
            MyFree(PathListBuffer);
        }

        PathListBuffer = NULL;
    }

    return PathListBuffer;
}


BOOL
DoMove(
    IN PCTSTR CurrentName,
    IN PCTSTR NewName
    )
/*++

Routine Description:

    Wrapper for MoveFileEx on NT

Arguments:

    CurrentName - supplies the name of the file as it exists currently.

    NewName - supplies the new name

Returns:

    Boolean value indicating outcome. If failure, last error is set.

--*/
{
    return MoveFileEx(CurrentName, NewName, MOVEFILE_REPLACE_EXISTING);
}

BOOL
DelayedMove(
    IN PCTSTR CurrentName,
    IN PCTSTR NewName       OPTIONAL
    )

/*++

Routine Description:

    Queue a file for copy or delete on next reboot.

    On Windows NT this means using MoveFileEx().

Arguments:

    CurrentName - supplies the name of the file as it exists currently.

    NewName - if specified supplies the new name. If not specified
        then the file named by CurrentName is deleted on next reboot.

Returns:

    Boolean value indicating outcome. If failure, last error is set.

--*/

{
    return MoveFileEx(CurrentName,
                      NewName,
                      MOVEFILE_REPLACE_EXISTING | MOVEFILE_DELAY_UNTIL_REBOOT
                     );
}


typedef enum _OEM_FILE_TYPE {
    OemFiletypeInf,
    OemFiletypeCat
} OEM_FILE_TYPE, *POEM_FILE_TYPE;

BOOL
IsInstalledFileFromOem(
    IN PCTSTR        Filename,
    IN OEM_FILE_TYPE Filetype
    )

/*++

Routine Description:

    Determine whether a file has the proper format for an (installed) OEM INF
    or catalog.

Arguments:

    Filename - supplies filename (sans path) to be checked.
    
    Filetype - specifies the type of file indicating how validation should be
        performed for the caller-supplied Filename.  May be one of the 
        following values:
        
        OemFiletypeInf - file must be OEM INF filename format (i.e., OEM<n>.INF)
        
        OemFiletypeCat - file must be OEM CAT filename format (i.e., OEM<n>.CAT)

Return Value:

    If the file conforms to the format for an installed OEM file of the
    specified type, the return is non-zero.  Otherwise, it is FALSE.

--*/

{
    PTSTR p;
    BOOL b;

    //
    // Catalog filename must not contain path...
    //
    MYASSERT(pSetupGetFileTitle(Filename) == Filename);

    //
    // First check that the first 3 characters are OEM
    //
    if(_tcsnicmp(Filename, TEXT("oem"), 3)) {
        return FALSE;
    }

    //
    // Next verify that any characters after "oem" and before ".cat"
    // are digits.
    //
    p = (PTSTR)Filename;
    p = CharNext(p);
    p = CharNext(p);
    p = CharNext(p);

    while((*p != TEXT('\0')) && (*p != TEXT('.'))) {

        if((*p < TEXT('0')) || (*p > TEXT('9'))) {
            return FALSE;
        }

        p = CharNext(p);
    }

    //
    // Finally, verify that the last 4 characters are either ".inf" or ".cat",
    // depending on what type of file the caller specified.
    //
    switch(Filetype) {

        case OemFiletypeInf :
            b = !_tcsicmp(p, TEXT(".INF"));
            break;

        case OemFiletypeCat :
            b = !_tcsicmp(p, TEXT(".CAT"));
            break;

        default :
            MYASSERT(FALSE);
            return FALSE;
    }

    return b;
}


DWORD
pSetupInstallCatalog(
    IN  LPCTSTR CatalogFullPath,
    IN  LPCTSTR NewBaseName,
    OUT LPTSTR  NewCatalogFullPath  OPTIONAL
    )

/*++

Routine Description:

    This routine installs a catalog file. The file is copied by the system
    into a special directory, and is optionally renamed.

Arguments:

    CatalogFullPath - supplies the fully-qualified win32 path of the catalog
        to be installed on the system.

    NewBaseName - specifies the new base name to use when the catalog file is
        copied into the catalog store.

    NewCatalogFullPath - optionally receives the fully-qualified path of the
        catalog file within the catalog store. This buffer should be at least
        MAX_PATH bytes (ANSI version) or chars (Unicode version).

        ** NOTE: If we're running in "minimal embedded" mode, then we don't **
        ** actually call any of the Crypto APIs, and instead always simply  **
        ** report success.  In this case, the caller had better not have    **
        ** specified an OUT buffer for NewCatalogFullPath, because we won't **
        ** have a path to report.  If we run into this case, we'll instead  **
        ** report failure.  What this really says is that nobody other than **
        ** setupapi should ever be passing a non-NULL value for this arg.   **

Return Value:

    If successful, the return value is NO_ERROR.
    If failure, the return value is a Win32 error code indicating the cause of
    the failure.

--*/

{
    DWORD Err;
    HCATADMIN hCatAdmin;
    HCATINFO hCatInfo;
    CATALOG_INFO CatalogInfo;
    LPWSTR LocalCatalogFullPath;
    LPWSTR LocalNewBaseName;

    MYASSERT(NewBaseName);
    if(!NewBaseName) {
        return ERROR_INVALID_PARAMETER;
    }

    if(GlobalSetupFlags & PSPGF_MINIMAL_EMBEDDED) {
        //
        // If someone called us expecting the new catalog's full path to be
        // returned, they're outta luck...
        //
        MYASSERT(!NewCatalogFullPath);
        if(NewCatalogFullPath) {
            //
            // In minimal embedded mode, a non-NULL NewCatalogFullPath arg is
            // an invalid parameter...
            //
            return ERROR_INVALID_PARAMETER;

        } else {
            //
            // Simply report success.
            //
            return NO_ERROR;
        }
    }

    if(GlobalSetupFlags & PSPGF_AUTOFAIL_VERIFIES) {
        return TRUST_E_FAIL;
    }

    Err = NO_ERROR;
    LocalCatalogFullPath = NULL;
    LocalNewBaseName = NULL;
    hCatInfo = NULL;

    Err = GLE_FN_CALL(FALSE, CryptCATAdminAcquireContext(&hCatAdmin,
                                                         &DriverVerifyGuid,
                                                         0)
                     );

    if(Err != NO_ERROR) {
        return Err;
    }

    try {
        //
        // Duplicate our catalog pathname and basename since the
        // CryptCATAdminAddCatalog prototype doesn't specify these arguments as 
        // being const strings.
        //
        LocalCatalogFullPath = DuplicateString(CatalogFullPath);
        LocalNewBaseName = DuplicateString(NewBaseName);

        if(!LocalCatalogFullPath || !LocalNewBaseName) {
            Err = ERROR_NOT_ENOUGH_MEMORY;
            leave;
        }

        Err = GLE_FN_CALL(NULL,
                          hCatInfo = CryptCATAdminAddCatalog(
                                         hCatAdmin,
                                         LocalCatalogFullPath,
                                         LocalNewBaseName,
                                         0)
                         );

        if(Err != NO_ERROR) {
            //
            // If the error we received is ERROR_ALREADY_EXISTS, then that
            // indicates that the exact same catalog was already present
            // (and installed under the same name).  Treat this as a
            // success (assuming we can get the full pathname of the
            // existing catalog).
            //
            if(Err == ERROR_ALREADY_EXISTS) {

                if(NewCatalogFullPath) {
                    //
                    // Resolve the catalog base filename to a fully-
                    // qualified path.
                    //
                    CatalogInfo.cbStruct = sizeof(CATALOG_INFO);

                    Err = GLE_FN_CALL(FALSE,
                                      CryptCATAdminResolveCatalogPath(
                                          hCatAdmin,
                                          LocalNewBaseName,
                                          &CatalogInfo,
                                          0)
                                     );
                } else {
                    //
                    // Caller isn't interested in finding out what pathname
                    // the catalog was installed under...
                    //
                    Err = NO_ERROR;
                }
            }

        } else if(NewCatalogFullPath) {
            //
            // The caller wants to know the full path under which the catalog
            // got installed.
            //
            CatalogInfo.cbStruct = sizeof(CATALOG_INFO);

            Err = GLE_FN_CALL(FALSE,
                              CryptCATCatalogInfoFromContext(hCatInfo,
                                                             &CatalogInfo,
                                                             0)
                             );
        }

        //
        // If we succeeded in retrieving the installed catalog's full path
        // (and the caller requested it), fill in the caller's buffer now.
        //
        if((Err == NO_ERROR) && NewCatalogFullPath) {

            MYVERIFY(SUCCEEDED(StringCchCopy(NewCatalogFullPath, 
                                             MAX_PATH,
                                             CatalogInfo.wszCatalogFile)));
        }

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, &Err);
    }

    if(hCatInfo) {
        CryptCATAdminReleaseCatalogContext(hCatAdmin, hCatInfo, 0);
    }

    CryptCATAdminReleaseContext(hCatAdmin, 0);

    if(LocalCatalogFullPath) {
        MyFree(LocalCatalogFullPath);
    }
    if(LocalNewBaseName) {
        MyFree(LocalNewBaseName);
    }

    return Err;
}


DWORD
pSetupVerifyCatalogFile(
    IN LPCTSTR CatalogFullPath
    )

/*++

Routine Description:

    This routine verifies a single catalog file using standard OS codesigning
    (i.e., driver signing) policy.

Arguments:

    CatalogFullPath - supplies the fully-qualified Win32 path of
        the catalog file to be verified.

Return Value:

    If successful, the return value is ERROR_SUCCESS.
    If failure, the return value is the error returned from WinVerifyTrust.

--*/

{
    return _VerifyCatalogFile(NULL, CatalogFullPath, NULL, FALSE, NULL, NULL);
}


DWORD
_VerifyCatalogFile(
    IN     PSETUP_LOG_CONTEXT      LogContext,             OPTIONAL
    IN     LPCTSTR                 CatalogFullPath,
    IN     PSP_ALTPLATFORM_INFO_V2 AltPlatformInfo,        OPTIONAL
    IN     BOOL                    UseAuthenticodePolicy,
    IN OUT HCERTSTORE             *hStoreTrustedPublisher, OPTIONAL
    OUT    HANDLE                 *hWVTStateData           OPTIONAL
    )

/*++

Routine Description:

    This routine verifies a single catalog file using the specified policy.
    
Arguments:

    LogContext - optionally, supplies the context to be used when logging 
        information about the routine's activities.

    CatalogFullPath - supplies the fully-qualified Win32 path of the catalog
        file to be verified.
        
    AltPlatformInfo - optionally, supplies alternate platform information used
        to fill in a DRIVER_VER_INFO structure (defined in sdk\inc\softpub.h)
        that is passed to WinVerifyTrust.

        **  NOTE:  This structure _must_ have its cbSize field set to        **
        **  sizeof(SP_ALTPLATFORM_INFO_V2) -- validation on client-supplied  **
        **  buffer is the responsibility of the caller.                      **

    UseAuthenticodePolicy - if TRUE, verification is to be done using 
        Authenticode policy instead of standard driver signing policy.
    
    hStoreTrustedPublisher - optionally, supplies the address of a certificate
        store handle.  If the handle pointed to is NULL, a handle will be 
        acquired (if possible) via CertOpenStore and returned to the caller.  
        If the handle pointed to is non-NULL, then that handle will be used by 
        this routine.  If the pointer itself is NULL, then an HCERTSTORE will 
        be acquired for the duration of this call, and released before 
        returning.

        NOTE: it is the caller's responsibility to free the certificate store
        handle returned by this routine by calling CertCloseStore.  This handle
        may be opened in either success or failure cases, so the caller must
        check for non-NULL returned handle in both cases.    
    
    hWVTStateData - if supplied, this parameter points to a buffer that 
        receives a handle to WinVerifyTrust state data.  This handle will be
        returned only when validation was successfully performed using
        Authenticode policy.  This handle may be used, for example, to retrieve
        signer info when prompting the user about whether they trust the
        publisher.  (The status code returned will indicate whether or not this
        is necessary, see "Return Value" section below.)
        
        This parameter should only be supplied if UseAuthenticodePolicy is
        TRUE.  If the routine fails, then this handle will be set to NULL.
        
        It is the caller's responsibility to close this handle when they're
        finished with it by calling pSetupCloseWVTStateData().

Return Value:

    If the catalog was successfully validated via driver signing policy, then 
    the return value is NO_ERROR.
    
    If the catalog was successfully validated via Authenticode policy, and the
    publisher was in the TrustedPublisher store, then the return value is
    ERROR_AUTHENTICODE_TRUSTED_PUBLISHER.
    
    If the catalog was successfully validated via Authenticode policy, and the
    publisher was not in the TrustedPublisher store (hence we must prompt the
    user to establish their trust of the publisher), then the return value is
    ERROR_AUTHENTICODE_TRUST_NOT_ESTABLISHED

    If a failure occurred, the return value is a Win32 error code indicating
    the cause of the failure.

Remarks:

    If we're in initial system setup (i.e., GUI-mode setup or mini-setup), we
    automatically install the certificates for any Authenticode-signed packages
    we encounter.  This is done to make OEM and corporate deployment as
    painless as possible.  In order to avoid being spoofed into thinking we're
    in system setup when we're not, we check to see if we're in LocalSystem
    security context (which both GUI setup and mini-setup are), and that we're
    on an interactive windowstation (which umpnpmgr is not).
    
--*/

{
    WINTRUST_DATA WintrustData;
    WINTRUST_FILE_INFO WintrustFileInfo;
    DRIVER_VER_INFO VersionInfo;
    DWORD Err, CertAutoInstallErr;
    PCRYPT_PROVIDER_DATA ProviderData;
    PCRYPT_PROVIDER_SGNR ProviderSigner;
    PCRYPT_PROVIDER_CERT ProviderCert;
    TCHAR PublisherName[MAX_PATH];

    //
    // If the caller requested that we return WinVerifyTrust state data upon
    // successful Authenticode validation, then they'd better have actually
    // requested Authenticode validation!
    //
    MYASSERT(!hWVTStateData || UseAuthenticodePolicy);

    if(hWVTStateData) {
        *hWVTStateData = NULL;
    }

    if(GlobalSetupFlags & PSPGF_MINIMAL_EMBEDDED) {
        //
        // Not valid to call us requesting Authenticode validation!
        //
        MYASSERT(!UseAuthenticodePolicy);
        return ERROR_SUCCESS;
    }

    if(GlobalSetupFlags & PSPGF_AUTOFAIL_VERIFIES) {
        return TRUST_E_FAIL;
    }

    if (!FileExists(CatalogFullPath, NULL)) {
        return ERROR_NO_CATALOG_FOR_OEM_INF;
    }

    ZeroMemory(&WintrustData, sizeof(WINTRUST_DATA));
    WintrustData.cbStruct = sizeof(WINTRUST_DATA);
    WintrustData.dwUIChoice = WTD_UI_NONE;
    WintrustData.dwUnionChoice = WTD_CHOICE_FILE;
    WintrustData.pFile = &WintrustFileInfo;
    WintrustData.dwProvFlags =  WTD_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT |
                                WTD_CACHE_ONLY_URL_RETRIEVAL;

    ZeroMemory(&WintrustFileInfo, sizeof(WINTRUST_FILE_INFO));
    WintrustFileInfo.cbStruct = sizeof(WINTRUST_FILE_INFO);
    WintrustFileInfo.pcwszFilePath = CatalogFullPath;

    if(UseAuthenticodePolicy) {
        //
        // We want WinVerifyTrust to return a handle to its state data, so we
        // can retrieve the publisher's cert...
        //
        WintrustData.dwStateAction = WTD_STATEACTION_VERIFY;

    } else {
        //
        // Specify driver version info structure so that we can control the
        // range of OS versions against which this catalog should validate.
        //
        ZeroMemory(&VersionInfo, sizeof(DRIVER_VER_INFO));
        VersionInfo.cbStruct = sizeof(DRIVER_VER_INFO);
        
        if(AltPlatformInfo) {

            MYASSERT(AltPlatformInfo->cbSize == sizeof(SP_ALTPLATFORM_INFO_V2));

            //
            // Caller wants the file validated for an alternate platform, so we
            // must fill in a DRIVER_VER_INFO structure to be passed to the policy 
            // module.
            //
            VersionInfo.dwPlatform = AltPlatformInfo->Platform;
            VersionInfo.dwVersion  = AltPlatformInfo->MajorVersion;

            VersionInfo.sOSVersionLow.dwMajor  = AltPlatformInfo->FirstValidatedMajorVersion;
            VersionInfo.sOSVersionLow.dwMinor  = AltPlatformInfo->FirstValidatedMinorVersion;
            VersionInfo.sOSVersionHigh.dwMajor = AltPlatformInfo->MajorVersion;
            VersionInfo.sOSVersionHigh.dwMinor = AltPlatformInfo->MinorVersion;

        } else {
            //
            // If an AltPlatformInfo was not passed in then set the
            // WTD_USE_DEFAULT_OSVER_CHECK flag. This flag tells WinVerifyTrust to
            // use its default osversion checking, even though a DRIVER_VER_INFO
            // structure was passed in.
            //
            WintrustData.dwProvFlags |= WTD_USE_DEFAULT_OSVER_CHECK;
        }

        //
        // Specify a DRIVER_VER_INFO structure so we can get back signer
        // information about the catalog.
        //
        WintrustData.pPolicyCallbackData = (PVOID)&VersionInfo;
    }

    //
    // Our call to WinVerifyTrust may allocate a resource we need to free
    // (namely, the signer cert context).  Wrap the following in try/except
    // so we won't leak resources in case of exception.
    //
    try {

        Err = (DWORD)WinVerifyTrust(NULL,
                                    (UseAuthenticodePolicy 
                                        ? &AuthenticodeVerifyGuid
                                        : &DriverVerifyGuid),
                                    &WintrustData
                                   );

        if((Err != NO_ERROR) || !UseAuthenticodePolicy) {
            //
            // If we're using driver signing policy, and we failed because of 
            // an osattribute mismatch, then convert this error to a specific
            // error (with more sensible text).
            //
            if(!UseAuthenticodePolicy && (Err == ERROR_APP_WRONG_OS)) {
                Err = ERROR_SIGNATURE_OSATTRIBUTE_MISMATCH;
            }

            leave;
        }

        //
        // If we get to this point, we successfully validated the catalog via
        // Authenticode policy, and we have a handle to the WinVerifyTrust
        // state data we need in order to: (a) return the handle to the caller 
        // (if requested), and (b) get at the certificate we need to search for 
        // in the TrustedPublisher certificate store.
        //

        MYASSERT(WintrustData.hWVTStateData);
        if(!WintrustData.hWVTStateData) {
            Err = ERROR_UNIDENTIFIED_ERROR;
            leave;
        }

        //
        // Now we need to ascertain whether the publisher is already trusted,
        // or whether we must prompt the user.
        //
        ProviderData = WTHelperProvDataFromStateData(WintrustData.hWVTStateData);
        MYASSERT(ProviderData);
        if(!ProviderData) {
            Err = ERROR_UNIDENTIFIED_ERROR;
            leave;
        }

        ProviderSigner = WTHelperGetProvSignerFromChain(ProviderData,
                                                        0,
                                                        FALSE,
                                                        0
                                                       );
        MYASSERT(ProviderSigner);
        if(!ProviderSigner) {
            Err = ERROR_UNIDENTIFIED_ERROR;
            leave;
        }

        ProviderCert = WTHelperGetProvCertFromChain(ProviderSigner, 0);
        MYASSERT(ProviderCert);
        if(!ProviderCert) {
            Err = ERROR_UNIDENTIFIED_ERROR;
            leave;
        }

        if(pSetupIsAuthenticodePublisherTrusted(ProviderCert->pCert,
                                                hStoreTrustedPublisher)) {

            Err = ERROR_AUTHENTICODE_TRUSTED_PUBLISHER;

        } else {
            //
            // If we're running in a context where it's acceptable to auto-
            // install the cert, then do that now.  Otherwise, we report a
            // status code that informs the caller they must prompt the user
            // about whether this publisher is to be trusted.
            //
            if(IsAutoCertInstallAllowed()) {
                //
                // Retrieve the publisher's name, so we can include it when
                // logging either success or failure of the certificate
                // installation.
                //
                MYVERIFY(1 <= CertGetNameString(
                                  ProviderCert->pCert,
                                  CERT_NAME_SIMPLE_DISPLAY_TYPE,
                                  0,
                                  NULL,
                                  PublisherName,
                                  SIZECHARS(PublisherName))
                        );

                CertAutoInstallErr = pSetupInstallCertificate(ProviderCert->pCert);

                if(CertAutoInstallErr == NO_ERROR) {
                    //
                    // Log the fact that we auto-installed a certificate.
                    //
                    WriteLogEntry(LogContext,
                                  DRIVER_LOG_INFO,
                                  MSG_LOG_AUTHENTICODE_CERT_AUTOINSTALLED,
                                  NULL,
                                  PublisherName
                                 );

                    //
                    // Now publisher is trusted, so return status indicating
                    // that.
                    //
                    Err = ERROR_AUTHENTICODE_TRUSTED_PUBLISHER;

                } else {
                    //
                    // Log the fact that we couldn't install the certificate.
                    // Don't treat this as a fatal error, however.
                    //
                    WriteLogEntry(LogContext,
                                  DRIVER_LOG_WARNING | SETUP_LOG_BUFFER,
                                  MSG_LOG_AUTHENTICODE_CERT_AUTOINSTALL_FAILED,
                                  NULL,
                                  PublisherName
                                 );

                    WriteLogError(LogContext,
                                  DRIVER_LOG_WARNING,
                                  CertAutoInstallErr
                                 );
                    //
                    // Report status indicating that the user must be prompted
                    // to establish trust of this publisher.
                    //
                    Err = ERROR_AUTHENTICODE_TRUST_NOT_ESTABLISHED;
                }

            } else {
                Err = ERROR_AUTHENTICODE_TRUST_NOT_ESTABLISHED;
            }
        }

        //
        // If we get to here, then we've successfully verified the catalog, and
        // ascertained whether the certificate should be implicitly trusted.
        // If the caller requested that we return the WinVerifyTrust state data
        // to them, then we can store that in their output buffer now.
        //
        if(hWVTStateData) {

            *hWVTStateData = WintrustData.hWVTStateData;

            //
            // WinVerifyTrust state data handle successfully transferred to
            // caller's output buffer.  Clear it out of the WintrustData
            // structure so we won't end up trying to free it twice in case of
            // error.
            //
            WintrustData.hWVTStateData = NULL;
        }

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, &Err);
    }

    if(!UseAuthenticodePolicy && VersionInfo.pcSignerCertContext) {
        CertFreeCertificateContext(VersionInfo.pcSignerCertContext);
    }

    if((Err != ERROR_AUTHENTICODE_TRUSTED_PUBLISHER) &&
       (Err != ERROR_AUTHENTICODE_TRUST_NOT_ESTABLISHED)) {
        //
        // If our error is NO_ERROR, then we shouldn't have WinVerifyTrust
        // state data, because that indicates we validated using standard
        // driver signing policy, not Authenticode policy.
        //
        MYASSERT((Err != NO_ERROR) || !hWVTStateData || !*hWVTStateData);

        if(hWVTStateData && *hWVTStateData) {

            pSetupCloseWVTStateData(*hWVTStateData);
            *hWVTStateData = NULL;

            //
            // We'd better not also have a WinVerifyTrust state data handle in
            // the WintrustData structure...
            //
            MYASSERT(!WintrustData.hWVTStateData);
        }
    }

    if(WintrustData.hWVTStateData) {
        pSetupCloseWVTStateData(WintrustData.hWVTStateData);
    }

    return Err;
}


VOID
pSetupCloseWVTStateData(
    IN HANDLE hWVTStateData
    )

/*++

Routine Description:

    This routine closes the WinVerifyTrust state data handle returned from
    certain routines (e.g., _VerifyCatalogFile) for prompting the user to
    establish trust of an Authenticode publisher.

Arguments:

    hWVTStateData - supplies the WinVerifyTrust state data handle to be closed.

Return Value:

    None.

--*/

{
    WINTRUST_DATA WintrustData;

    ZeroMemory(&WintrustData, sizeof(WINTRUST_DATA));
    WintrustData.cbStruct = sizeof(WINTRUST_DATA);
    WintrustData.dwStateAction = WTD_STATEACTION_CLOSE;
    WintrustData.hWVTStateData = hWVTStateData;

    MYVERIFY(NO_ERROR == WinVerifyTrust(NULL,
                                        &AuthenticodeVerifyGuid,
                                        &WintrustData));
}


DWORD
pSetupUninstallCatalog(
    IN LPCTSTR CatalogFilename
    )

/*++

Routine Description:

    This routine uninstalls a catalog, so it can no longer be used to validate
    digital signatures.

Arguments:

    CatalogFilename - supplies the simple filename of the catalog to be
        uninstalled.

Return Value:

    If successful, the return value is NO_ERROR.
    If failure, the return value is a Win32 error code indicating the cause of
    the failure.

--*/

{
    DWORD Err;
    HCATADMIN hCatAdmin;

    if(GlobalSetupFlags & PSPGF_MINIMAL_EMBEDDED) {
        return NO_ERROR;
    }

    if(GlobalSetupFlags & PSPGF_AUTOFAIL_VERIFIES) {
        return TRUST_E_FAIL;
    }

    Err = GLE_FN_CALL(FALSE,
                      CryptCATAdminAcquireContext(&hCatAdmin, 
                                                  &DriverVerifyGuid, 
                                                  0)
                     );

    if(Err != NO_ERROR) {
        return Err;
    }

    try {

        Err = GLE_FN_CALL(FALSE,
                          CryptCATAdminRemoveCatalog(hCatAdmin, 
                                                     CatalogFilename, 
                                                     0)
                         );

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, &Err);
    }

    CryptCATAdminReleaseContext(hCatAdmin, 0);

    return Err;
}


BOOL
pAnyDeviceUsingInf(
    IN  LPCTSTR            InfFullPath,
    IN  PSETUP_LOG_CONTEXT LogContext   OPTIONAL
    )

/*++

Routine Description:

    This routine checks if any device, live or phantom, is using this INF file,
    and logs if they are.

Arguments:

    InfFullPath - supplies the full path of the INF.

    LogContext - optionally, supplies the log context to be used if a device
        using this INF is encountered.

Return Value:

    TRUE if this INF is being used by any device, or if an error occurred (if
    an error was encountered, we don't want to end up deleting the INF
    erroneously.
    
    FALSE if no devices are using this INF (and no errors were encountered).

--*/

{
    DWORD Err;
    HDEVINFO DeviceInfoSet;
    SP_DEVINFO_DATA DeviceInfoData;
    DWORD MemberIndex = 0;
    HKEY hkey = INVALID_HANDLE_VALUE;
    TCHAR CurrentDeviceInfFile[MAX_PATH];
    DWORD cbSize, dwType;
    PTSTR pInfFile;

    //
    // If we are passed a NULL InfFullPath or an enpty string then just return
    // FALSE since nobody is using this.
    //
    if(!InfFullPath || (InfFullPath[0] == TEXT('\0'))) {
        return FALSE;
    }

    pInfFile = (PTSTR)pSetupGetFileTitle(InfFullPath);

    DeviceInfoSet = SetupDiGetClassDevs(NULL, NULL, NULL, DIGCF_ALLCLASSES);

    if(DeviceInfoSet == INVALID_HANDLE_VALUE) {
        //
        // We can't retrieve a list of devices, hence we cannot make a
        // determination of whether this inf is in-use.  Safe thing to do is
        // assume it is in-use...
        //
        return TRUE;
    }

    Err = NO_ERROR; // assume we won't find any devices using this INF.

    try {

        DeviceInfoData.cbSize = sizeof(DeviceInfoData);

        while(SetupDiEnumDeviceInfo(DeviceInfoSet,
                                    MemberIndex++,
                                    &DeviceInfoData)) {

            //
            // Open the 'driver' key for this device.
            //
            hkey = SetupDiOpenDevRegKey(DeviceInfoSet,
                                        &DeviceInfoData,
                                        DICS_FLAG_GLOBAL,
                                        0,
                                        DIREG_DRV,
                                        KEY_READ);

            if(hkey != INVALID_HANDLE_VALUE) {

                cbSize = sizeof(CurrentDeviceInfFile);
                dwType = REG_SZ;

                if ((RegQueryValueEx(hkey,
                                     pszInfPath,
                                     NULL,
                                     &dwType,
                                     (LPBYTE)CurrentDeviceInfFile,
                                     &cbSize) == ERROR_SUCCESS) && 
                    !lstrcmpi(CurrentDeviceInfFile, pInfFile)) {

                    //
                    // This key is using this INF file so the INF can't be
                    // deleted.
                    //
                    Err = ERROR_SHARING_VIOLATION;  // any error will do

                    if(LogContext) {

                        TCHAR DeviceId[MAX_DEVICE_ID_LEN];

                        if(CM_Get_Device_ID(DeviceInfoData.DevInst,
                                            DeviceId,
                                            SIZECHARS(DeviceId),
                                            0
                                            ) != CR_SUCCESS) {

                            DeviceId[0] = TEXT('\0');
                        }

                        WriteLogEntry(LogContext,
                                      SETUP_LOG_WARNING,
                                      MSG_LOG_INF_IN_USE,
                                      NULL,
                                      pInfFile,
                                      DeviceId
                                     );
                    }
                }

                RegCloseKey(hkey);
                hkey = INVALID_HANDLE_VALUE;
            }
        }

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, &Err);
    }

    SetupDiDestroyDeviceInfoList(DeviceInfoSet);

    if(hkey != INVALID_HANDLE_VALUE) {
        RegCloseKey(hkey);
    }

    return (Err != NO_ERROR);
}


VOID
pSetupUninstallOEMInf(
    IN  LPCTSTR            InfFullPath,
    IN  PSETUP_LOG_CONTEXT LogContext,  OPTIONAL
    IN  DWORD              Flags,
    OUT PDWORD             InfDeleteErr OPTIONAL
    )

/*++

Routine Description:

    This routine uninstalls a 3rd-party INF, PNF, and CAT (if one exists).  It
    can also be used to uninstall an exception package INF, PNF, and CAT.

    By default this routine will first verify that there aren't any other
    device's, live and phantom, that are pointing their InfPath to this
    INF. This behavior can be overridden by the SUOI_FORCEDELETE flag.

Arguments:

    InfFullPath - supplies the full path of the INF to be uninstalled.

    LogContext - optionally, supplies the log context to be used if we
        encounter an error when attempting to delete the catalog.

    Flags - the following flags are supported:
    
        SUOI_FORCEDELETE - delete the INF even if other driver keys are
                           have their InfPath pointing to it.

    InfDeleteErr - optionally, supplies the address of a variable that receives
        the error (if any) encountered when attempting to delete the INF.
        Note that we delete the INF last (to avoid race conditions), so the
        corresponding CAT and PNF may have already been deleted at this point.

Return Value:

    None.

--*/

{
    DWORD Err;
    TCHAR FileNameBuffer[MAX_PATH+4]; // +4 in case filename is blahblah. not blahblah.inf
    BOOL FreeLogContext = FALSE;
    LPTSTR ExtPtr= NULL;
    HINF hInf = INVALID_HANDLE_VALUE;

    if(!LogContext) {

        if(NO_ERROR == CreateLogContext(NULL, TRUE, &LogContext)) {
            //
            // Remember that we created this log context locally, so we can
            // free it when we're done with this routine.
            //
            FreeLogContext = TRUE;

        } else {
            //
            // Ensure LogContext is still NULL so we won't try to use it.
            //
            LogContext = NULL;
        }
    }

    try {
        //
        // Make sure the specified INF is in %windir%\Inf, and that it's an OEM
        // INF (i.e, filename is OEM<n>.INF).
        //
        if(pSetupInfIsFromOemLocation(InfFullPath, TRUE)) {

            Err = ERROR_NOT_AN_INSTALLED_OEM_INF;
            goto LogAnyUninstallErrors;

        } else if(!IsInstalledFileFromOem(pSetupGetFileTitle(InfFullPath), OemFiletypeInf)) {

            BOOL IsExceptionInf = FALSE;
            GUID ClassGuid;

            //
            // The INF is in %windir%\Inf, but is not of the form oem<n>.inf.
            // It may still be OK to uninstall it, if it's an exception INF...
            //
            hInf = SetupOpenInfFile(InfFullPath, NULL, INF_STYLE_WIN4, NULL);

            if(hInf != INVALID_HANDLE_VALUE) {
                //
                // We don't need to lock the INF because it'll never be
                // accessible outside of this routine.
                //
                if(ClassGuidFromInfVersionNode(&(((PLOADED_INF)hInf)->VersionBlock), &ClassGuid)
                   && IsEqualGUID(&ClassGuid, &GUID_DEVCLASS_WINDOWS_COMPONENT_PUBLISHER)) {

                    IsExceptionInf = TRUE;
                }

                //
                // Close the INF handle now so we won't still have it open if
                // we end up deleting the INF.
                //
                SetupCloseInfFile(hInf);
                hInf = INVALID_HANDLE_VALUE; // no need to close if we hit an exception
            }

            if(!IsExceptionInf) {
                Err = ERROR_NOT_AN_INSTALLED_OEM_INF;
                goto LogAnyUninstallErrors;
            }
        }

        //
        // Unless the caller passed in the SUOI_FORCEDELETE flag first check
        // that no devices are using this INF file.
        //
        if(!(Flags & SUOI_FORCEDELETE) &&
           pAnyDeviceUsingInf(InfFullPath, LogContext)) {
            //
            // Some device is still using this INF so we can't delete it. 
            //
            Err = ERROR_INF_IN_USE_BY_DEVICES;
            goto LogAnyUninstallErrors;
        }

        //
        // Copy the caller-supplied INF name into a local buffer, so we can 
        // modify it when deleting the various files (INF, PNF, and CAT).
        //
        if(FAILED(StringCchCopy(FileNameBuffer, SIZECHARS(FileNameBuffer), InfFullPath))) {
            //
            // This error would be returned by DeleteFile if we let it go 
            // through.
            //
            Err = ERROR_PATH_NOT_FOUND;
            goto LogAnyUninstallErrors;
        }

        //
        // Uninstall the catalog (if any) first, because as soon as we delete
        // the INF, that slot is "open" for use by another INF, and we wouldn't
        // want to inadvertently delete someone else's catalog due to a race
        // condition.
        //
        ExtPtr = _tcsrchr(FileNameBuffer, TEXT('.'));

        MYASSERT(ExtPtr); // we already validated the filename's format

        if(FAILED(StringCchCopy(ExtPtr, 
                                SIZECHARS(FileNameBuffer)-(ExtPtr-FileNameBuffer),
                                pszCatSuffix))) {

            Err = ERROR_BUFFER_OVERFLOW;
        } else {
            Err = pSetupUninstallCatalog(pSetupGetFileTitle(FileNameBuffer));
        }

        if((Err != NO_ERROR) && LogContext) {
            //
            // It's kinda important that we were unable to delete the catalog, 
            // but not important enough to fail the routine.  Log this fact to
            // setupapi.log...
            //
            WriteLogEntry(LogContext,
                          DEL_ERR_LOG_LEVEL(Err) | SETUP_LOG_BUFFER,
                          MSG_LOG_OEM_CAT_UNINSTALL_FAILED,
                          NULL,
                          pSetupGetFileTitle(FileNameBuffer)
                         );

            WriteLogError(LogContext,
                          DEL_ERR_LOG_LEVEL(Err),
                          Err
                         );
        }

        //
        // Now delete the PNF (we don't care so much if this succeeds or 
        // fails)...
        //
        if(SUCCEEDED(StringCchCopy(ExtPtr, 
                                  SIZECHARS(FileNameBuffer)-(ExtPtr-FileNameBuffer), 
                                  pszPnfSuffix))) {

            SetFileAttributes(FileNameBuffer, FILE_ATTRIBUTE_NORMAL);
            DeleteFile(FileNameBuffer);
        }

        //
        // and finally the INF itself...
        //
        SetFileAttributes(InfFullPath, FILE_ATTRIBUTE_NORMAL);
        Err = GLE_FN_CALL(FALSE, DeleteFile(InfFullPath));

LogAnyUninstallErrors:

        if((Err != NO_ERROR) && LogContext) {

            WriteLogEntry(LogContext,
                          SETUP_LOG_ERROR | SETUP_LOG_BUFFER,
                          MSG_LOG_OEM_INF_UNINSTALL_FAILED,
                          NULL,
                          InfFullPath
                         );

            WriteLogError(LogContext,
                          SETUP_LOG_ERROR,
                          Err
                         );
        }

        if(InfDeleteErr) {
            *InfDeleteErr = Err;
        }

    } except(pSetupExceptionFilter(GetExceptionCode())) {

        pSetupExceptionHandler(GetExceptionCode(), 
                               ERROR_INVALID_PARAMETER, 
                               InfDeleteErr
                              );

        if(hInf != INVALID_HANDLE_VALUE) {
            SetupCloseInfFile(hInf);
        }
    }

    if(FreeLogContext) {
        DeleteLogContext(LogContext);
    }
}


DWORD
_VerifyFile(
    IN     PSETUP_LOG_CONTEXT      LogContext,
    IN OUT PVERIFY_CONTEXT         VerifyContext,          OPTIONAL
    IN     LPCTSTR                 Catalog,                OPTIONAL
    IN     PVOID                   CatalogBaseAddress,     OPTIONAL
    IN     DWORD                   CatalogImageSize,
    IN     LPCTSTR                 Key,
    IN     LPCTSTR                 FileFullPath,
    OUT    SetupapiVerifyProblem  *Problem,                OPTIONAL
    OUT    LPTSTR                  ProblemFile,            OPTIONAL
    IN     BOOL                    CatalogAlreadyVerified,
    IN     PSP_ALTPLATFORM_INFO_V2 AltPlatformInfo,        OPTIONAL
    IN     DWORD                   Flags,                  OPTIONAL
    OUT    LPTSTR                  CatalogFileUsed,        OPTIONAL
    OUT    PDWORD                  NumCatalogsConsidered,  OPTIONAL
    OUT    LPTSTR                  DigitalSigner,          OPTIONAL
    OUT    LPTSTR                  SignerVersion,          OPTIONAL
    OUT    HANDLE                 *hWVTStateData           OPTIONAL
    )

/*++

Routine Description:

    This routine verifies a single file against a particular catalog file, or
    against any installed catalog file.

Arguments:

    LogContext - supplies the context to be used when logging information about
        the routine's activities.
        
    VerifyContext - optionally, supplies the address of a structure that caches
        various verification context handles.  These handles may be NULL (if
        not previously acquired, and they may be filled in upon return (in
        either success or failure) if they were acquired during the processing
        of this verification request.  It is the caller's responsibility to
        free these various context handles when they are no longer needed by
        calling pSetupFreeVerifyContextMembers.

    Catalog - optionally, supplies the path of the catalog file to be used for
        the verification.  If this argument is not specified, then this routine
        will attempt to find a catalog that can verify it from among all
        catalogs installed in the system.

        If this path is a simple filename (no path components), then we'll look
        up that catalog file in the CatAdmin's list of installed catalogs, else
        we'll use the name as-is.

    CatalogBaseAddress - optionally, supplies the address of a buffer 
        containing the entire catalog image with which our enumerated catalog 
        must match before being considered a correct validation.  This is used 
        when copying OEM INFs, for example, when there may be multiple 
        installed catalogs that can validate an INF, but we want to make sure 
        that we pick _the_ catalog that matches the one we're contemplating 
        installing before we'll consider our INF/CAT files to be duplicates of 
        the previously-existing files.

        This parameter (and its partner, CatalogImageSize) are only used when
        Catalog doesn't specify a file path.

    CatalogImageSize - if CatalogBaseAddress is specified, this parameter give
        the size, in bytes, of that buffer.

    Key - supplies a value that "indexes" the catalog, telling the verify APIs
        which signature datum within the catalog it should use. Typically
        the key is the (original) filename of a file.

    FileFullPath - supplies the full path of the file to be verified.

    Problem - if supplied, this parameter points to a variable that will be
        filled in upon unsuccessful return with the cause of failure.  If this
        parameter is not supplied, then the ProblemFile parameter is ignored.

    ProblemFile - if supplied, this parameter points to a character buffer of 
        at least MAX_PATH characters that receives the name of the file for 
        which a verification error occurred (the contents of this buffer are 
        undefined if verification succeeds.

        If the Problem parameter is supplied, then the ProblemFile parameter
        must also be specified.

    CatalogAlreadyVerified - if TRUE, then verification won't be done on the
        catalog--we'll just use that catalog to validate the file of interest.
        If this is TRUE, then Catalog must be specified, must contain the path
        to the catalog file (i.e., it can't be a simple filename).
        
        ** This flag is ignored when validating via Authenticode policy--the **
        ** catalog is always verified.                                       **

    AltPlatformInfo - optionally, supplies alternate platform information used
        to fill in a DRIVER_VER_INFO structure (defined in sdk\inc\softpub.h)
        that is passed to WinVerifyTrust.

        **  NOTE:  This structure _must_ have its cbSize field set to        **
        **  sizeof(SP_ALTPLATFORM_INFO_V2) -- validation on client-supplied  **
        **  buffer is the responsibility of the caller.                      **

    Flags - supplies flags that alter that behavior of this routine.  May be a
        combination of the following values:

        VERIFY_FILE_IGNORE_SELFSIGNED - if this bit is set, then this routine
                                        will fail validation for self-signed
                                        binaries.

        VERIFY_FILE_USE_OEM_CATALOGS  - if this bit is set, then all catalogs
                                        installed in the system will be scanned
                                        to verify the given file.  Otherwise,
                                        OEM (3rd party) catalogs will NOT be
                                        scanned to verify the given file.  This
                                        is only applicable if a catalog is not
                                        specified.

        VERIFY_FILE_USE_AUTHENTICODE_CATALOG - Validate the file using a
                                               catalog signed with Authenticode
                                               policy.  If this flag is set,
                                               we'll _only_ check for
                                               Authenticode signatures, so if
                                               the caller wants to first try
                                               validating a file for OS code-
                                               signing usage, then falling back
                                               to Authenticode, they'll have to
                                               call this routine twice.
                                               
                                               If this flag is set, then the
                                               caller may also supply the
                                               hWVTStateData output parameter,
                                               which can be used to prompt user
                                               in order to establish that the
                                               publisher should be trusted.
                                               
                                               _VerifyFile will return one of
                                               two error codes upon successful
                                               validation via Authenticode
                                               policy.  Refer to the "Return
                                               Value" section for details.
        
        VERIFY_FILE_DRIVERBLOCKED_ONLY - Only check if the file is in the bad
                                         driver database, don't do any digital
                                         sigature validation.

        VERIFY_FILE_NO_DRIVERBLOCKED_CHECK - Don't check if the file is blocked
                                             via the Bad Driver Database.

    CatalogFileUsed - if supplied, this parameter points to a character buffer
        at least MAX_PATH characters big that receives the name of the catalog
        file used to verify the specified file.  This is only filled in upon
        successful return, or when the Problem is SetupapiVerifyFileProblem
        (i.e., the catalog verified, but the file did not).  If this buffer is
        set to the empty string upon a SetupapiVerifyFileProblem failure, then
        we didn't find any applicable catalogs to use for validation.

        Also, this buffer will contain an empty string upon successful return
        if the file was validated without using a catalog (i.e., the file
        contains its own signature).

    NumCatalogsConsidered - if supplied, this parameter receives a count of the
        number of catalogs against which verification was attempted.  Of course,
        if Catalog is specified, this number will always be either zero or one.

    DigitalSigner - if supplied, this parameter points to a character buffer of
        at least MAX_PATH characters that receives the name of who digitally
        signed the specified file. This value is only set if the Key is
        correctly signed (i.e. the function returns NO_ERROR).
        
        ** This parameter should not be supplied when validating using       **
        ** Authenticode policy.  Information about signer, date, etc., may   **
        ** be acquired from the hWVTStateData in that case.                  **

    SignerVersion - if supplied, this parameter points to a character buffer of
        at least MAX_PATH characters that receives the signer version as
        returned in the szwVerion field of the DRIVER_VER_INFO structure in our
        call to WinVerifyTrust.
        
        ** This parameter should not be supplied when validating using       **
        ** Authenticode policy.  Information about signer, date, etc., may   **
        ** be acquired from the hWVTStateData in that case.                  **
        
    hWVTStateData - if supplied, this parameter points to a buffer that 
        receives a handle to WinVerifyTrust state data.  This handle will be
        returned only when validation was successfully performed using
        Authenticode policy.  This handle may be used, for example, to retrieve
        signer info when prompting the user about whether they trust the
        publisher.  (The status code returned will indicate whether or not this
        is necessary, see "Return Value" section below.)
        
        This parameter should only be supplied if the 
        VERIFY_FILE_USE_AUTHENTICODE_CATALOG bit is set in the supplied Flags.
        If the routine fails, then this handle will be set to NULL.
        
        It is the caller's responsibility to close this handle when they're
        finished with it by calling pSetupCloseWVTStateData().

Return Value:

    If the file was successfully validated via driver signing policy (or we
    didn't perform digital signature verification and everything else 
    succeeded), then the return value is NO_ERROR.
    
    If the file was successfully validated via Authenticode policy, and the
    publisher was in the TrustedPublisher store, then the return value is
    ERROR_AUTHENTICODE_TRUSTED_PUBLISHER.
    
    If the file was successfully validated via Authenticode policy, and the
    publisher was not in the TrustedPublisher store (hence we must prompt the
    user to establish their trust of the publisher), then the return value is
    ERROR_AUTHENTICODE_TRUST_NOT_ESTABLISHED
    
    If a failure occurred, the return value is a Win32 error code indicating
    the cause of the failure.

--*/

{
    LPBYTE Hash;
    DWORD HashSize;
    CATALOG_INFO CatInfo;
    HANDLE hFile;
    HCATINFO hCatInfo;
    HCATINFO PrevCat;
    DWORD Err, AuthenticodeErr;
    WINTRUST_DATA WintrustData;
    WINTRUST_CATALOG_INFO WintrustCatalogInfo;
    WINTRUST_FILE_INFO WintrustFileInfo;
    DRIVER_VER_INFO VersionInfo;
    LPTSTR CatalogFullPath;
    WCHAR UnicodeKey[MAX_PATH];
    WIN32_FILE_ATTRIBUTE_DATA FileAttribData;
    BOOL FoundMatchingImage;
    DWORD CurCatFileSize;
    HANDLE CurCatFileHandle, CurCatMappingHandle;
    PVOID CurCatBaseAddress;
    BOOL LoggedWarning;
    BOOL TrySelfSign;
    DWORD AltPlatSlot;
    TAGREF tagref;
    HCATADMIN LocalhCatAdmin;
    HSDB LocalhSDBDrvMain;
    BOOL UseAuthenticodePolicy = Flags & VERIFY_FILE_USE_AUTHENTICODE_CATALOG;

    //
    // Initialize the CatalogFileUsed parameter to an empty string (i.e., no
    // applicable catalog at this point).
    //
    if(CatalogFileUsed) {
        *CatalogFileUsed = TEXT('\0');
    }

    //
    // Initialize the output counter indicating the number of catalog files we
    // processed during the attempted verification.
    //
    if(NumCatalogsConsidered) {
        *NumCatalogsConsidered = 0;
    }

    //
    // Initialize the output handle for WinVerifyTrust state data.
    //
    if(hWVTStateData) {
        *hWVTStateData = NULL;
    }

    //
    // If Authenticode validation is requested, then the caller shouldn't have
    // passed in the DigitalSigner and SignerVersion output parameters.
    //
    MYASSERT(!UseAuthenticodePolicy || (!DigitalSigner && !SignerVersion));

    if(GlobalSetupFlags & PSPGF_MINIMAL_EMBEDDED) {
        //
        // The old behavior of this API in the ANSI case where the crypto
        // APIs weren't available was to set the CatalogFileUsed OUT param to 
        // an empty string and report NO_ERROR.  We'll do the same thing here 
        // (but we'll also assert, because no external callers should care, and 
        // if they do, an empty string probably isn't going to make them very
        // happy).
        //
        MYASSERT(!CatalogFileUsed);
        MYASSERT(!NumCatalogsConsidered);

        //
        // We'd better not be called in minimal embedded scenarios where we're
        // asked to provide signer info...
        //
        MYASSERT(!DigitalSigner);
        MYASSERT(!SignerVersion);

        //
        // Likewise, we'd better not be called asking to validate using
        // Authenticode policy (and hence, to return WinVerifyTrust state data
        // regarding the signing certificate).
        //
        MYASSERT(!UseAuthenticodePolicy);

        return NO_ERROR;
    }

    //
    // If the caller requested that we return WinVerifyTrust state data upon
    // successful Authenticode validation, then they'd better have actually
    // requested Authenticode validation!
    //
    MYASSERT(!hWVTStateData || UseAuthenticodePolicy);

    //
    // Doesn't make sense to have both these flags set!
    //
    MYASSERT((Flags & (VERIFY_FILE_DRIVERBLOCKED_ONLY | VERIFY_FILE_NO_DRIVERBLOCKED_CHECK))
             != (VERIFY_FILE_DRIVERBLOCKED_ONLY | VERIFY_FILE_NO_DRIVERBLOCKED_CHECK)
            );

    //
    // If Problem is supplied, then ProblemFile must also be supplied.
    //
    MYASSERT(!Problem || ProblemFile);

    //
    // If the caller claims to have already verified the catalog file, make
    // sure they passed us the full path to one.
    //
    MYASSERT(!CatalogAlreadyVerified || (Catalog && (Catalog != pSetupGetFileTitle(Catalog))));

    //
    // If a catalog image is specified, we'd better have been given a size.
    //
    MYASSERT((CatalogBaseAddress && CatalogImageSize) ||
             !(CatalogBaseAddress || CatalogImageSize));

    //
    // If a catalog image was supplied for comparison, there shouldn't be a 
    // file path specified in the Catalog parameter.
    //
    MYASSERT(!CatalogBaseAddress || !(Catalog && (Catalog != pSetupGetFileTitle(Catalog))));

    //
    // OK, preliminary checking is over--prepare to enter try/except block...
    //
    hFile = INVALID_HANDLE_VALUE;
    Hash = NULL;
    LoggedWarning = FALSE;
    TrySelfSign = FALSE;
    AltPlatSlot = 0;
    tagref = TAGREF_NULL;
    LocalhCatAdmin = NULL;
    LocalhSDBDrvMain = NULL;
    hCatInfo = NULL;
    AuthenticodeErr = NO_ERROR;

    //
    // Go ahead and initialize the VersionInfo structure as well.
    // WinVerifyTrust will sometimes fill in the pcSignerCertContext field with
    // a cert context that must be freed, and we don't want to introduce the
    // possibility of leaking this if we hit an exception at an inopportune
    // moment.  (We don't need to do this for Authenticode verification,
    // because Authenticode pays no attention to the driver version info.)
    //
    if(!UseAuthenticodePolicy) {
        ZeroMemory(&VersionInfo, sizeof(DRIVER_VER_INFO));
        VersionInfo.cbStruct = sizeof(DRIVER_VER_INFO);
    }

    try {

        if(GlobalSetupFlags & PSPGF_AUTOFAIL_VERIFIES) {
            if(Problem) {
                *Problem = SetupapiVerifyAutoFailProblem;
                StringCchCopy(ProblemFile, MAX_PATH, FileFullPath);
            }
            Err = TRUST_E_FAIL;
            leave;
        }

        if(AltPlatformInfo) {

            AltPlatSlot = AllocLogInfoSlotOrLevel(LogContext,SETUP_LOG_VERBOSE,FALSE);
            WriteLogEntry(LogContext,
                          AltPlatSlot,
                          MSG_LOG_VERIFYFILE_ALTPLATFORM,
                          NULL,                        // text message
                          AltPlatformInfo->Platform,
                          AltPlatformInfo->MajorVersion,
                          AltPlatformInfo->MinorVersion,
                          AltPlatformInfo->FirstValidatedMajorVersion,
                          AltPlatformInfo->FirstValidatedMinorVersion
                         );
        }

        if(VerifyContext && VerifyContext->hCatAdmin) {
            LocalhCatAdmin = VerifyContext->hCatAdmin;
        } else {

            Err = GLE_FN_CALL(FALSE,
                              CryptCATAdminAcquireContext(&LocalhCatAdmin, 
                                                          &DriverVerifyGuid, 
                                                          0)
                             );

            if(Err != NO_ERROR) {
                //
                // Failure encountered--ensure local handle is still NULL.
                //
                LocalhCatAdmin = NULL;

                if(Problem) {
                    //
                    // We failed too early to blame the file as the problem, 
                    // but it's the only filename we currently have to return 
                    // as the problematic file.
                    //
                    *Problem = SetupapiVerifyFileProblem;
                    StringCchCopy(ProblemFile, MAX_PATH, FileFullPath);
                }

                leave;
            }

            //
            // If requested, store the handle to be returned to the caller.
            //
            if(VerifyContext) {
                VerifyContext->hCatAdmin = LocalhCatAdmin;
            }
        }

        //
        // Calculate the hash value for the inf.
        //
        Err = GLE_FN_CALL(INVALID_HANDLE_VALUE,
                          hFile = CreateFile(FileFullPath,
                                             GENERIC_READ,
                                             FILE_SHARE_READ,
                                             NULL,
                                             OPEN_EXISTING,
                                             0,
                                             NULL)
                         );

        if(Err != NO_ERROR) {
            if(Problem) {
                *Problem = SetupapiVerifyFileProblem;
                StringCchCopy(ProblemFile, MAX_PATH, FileFullPath);
            }
            leave;
        }

        //
        // Only check if the driver is in the defective driver database if we
        // are NOT in GUI setup, and the caller has NOT passed in the
        // VERIFY_FILE_NO_DRIVERBLOCKED_CHECK flag.
        //
        if(!GuiSetupInProgress &&
           !(Flags & VERIFY_FILE_NO_DRIVERBLOCKED_CHECK)) {
            //
            // Shim database APIs have been known to crash from time to time,
            // so guard ourselves against that because failure to do a lookup
            // in the bad driver database should not result in a verification
            // failure.
            //
            try {

                if(VerifyContext && VerifyContext->hSDBDrvMain) {
                    LocalhSDBDrvMain = VerifyContext->hSDBDrvMain;
                } else {

                    LocalhSDBDrvMain = SdbInitDatabaseEx(SDB_DATABASE_MAIN_DRIVERS, 
                                                         NULL,
                                                         DEFAULT_IMAGE
                                                        );

                    if(LocalhSDBDrvMain) {
                        //
                        // If requested, store the handle to be returned to the
                        // caller.
                        //
                        if(VerifyContext) {
                            VerifyContext->hSDBDrvMain = LocalhSDBDrvMain;
                        }

                    } else {
                        //
                        // Log a warning that we couldn't access the bad driver
                        // database to check if this is a blocked driver.
                        // (SdbInitDatabase doesn't set last error, so we don't
                        // know why this failed--only that it did.)
                        //
                        WriteLogEntry(LogContext,
                                      SETUP_LOG_WARNING,
                                      MSG_LOG_CANT_ACCESS_BDD,
                                      NULL,
                                      FileFullPath
                                     );
                    }
                }

                //
                // Check the bad driver database to see if this file is blocked.
                //
                if(LocalhSDBDrvMain) {

                    tagref = SdbGetDatabaseMatch(LocalhSDBDrvMain,
                                                 Key,
                                                 hFile,
                                                 NULL,
                                                 0);

                    if(tagref != TAGREF_NULL) {
                        //
                        // Read the driver policy to see if this should be
                        // blocked by usermode or not.
                        // If the 1st bit is set then this should NOT be blocked
                        // by usermode.
                        //
                        ULONG type, size, policy;

                        size = sizeof(policy);
                        policy = 0;
                        type = REG_DWORD;
                        if(SdbQueryDriverInformation(LocalhSDBDrvMain,
                                                     tagref,
                                                     TEXT("Policy"),
                                                     &type,
                                                     &policy,
                                                     &size) != ERROR_SUCCESS) {
                            //
                            // If we can't read the policy then default to 0.
                            // This means we will block in usermode!
                            //
                            policy = 0;
                        }

                        if(!(policy & DDB_DRIVER_POLICY_SETUP_NO_BLOCK_BIT)) {
                            //
                            // This driver is in the database and needs to be 
                            // blocked!
                            //
                            WriteLogEntry(LogContext,
                                          SETUP_LOG_VERBOSE,
                                          MSG_LOG_DRIVER_BLOCKED_ERROR,
                                          NULL,
                                          FileFullPath
                                         );

                            LoggedWarning = TRUE;

                            if(Problem) {
                                *Problem = SetupapiVerifyDriverBlocked;
                                StringCchCopy(ProblemFile, MAX_PATH, FileFullPath);
                            }

                            Err = ERROR_DRIVER_BLOCKED;
                            leave;
                        }
                    }
                } 

            } except(pSetupExceptionFilter(GetExceptionCode())) {

                pSetupExceptionHandler(GetExceptionCode(), 
                                       ERROR_INVALID_PARAMETER, 
                                       &Err
                                      );

                WriteLogEntry(LogContext,
                              SETUP_LOG_WARNING | SETUP_LOG_BUFFER,
                              MSG_LOG_CANT_ACCESS_BDD_EXCEPTION,
                              NULL,
                              FileFullPath
                             );

                WriteLogError(LogContext, SETUP_LOG_WARNING, Err);
            }
        }

        //
        // If the caller only wanted to check if the file was in the bad driver
        // database then we are done.
        //
        if(Flags & VERIFY_FILE_DRIVERBLOCKED_ONLY) {
            Err = NO_ERROR;
            leave;
        }

        //
        // Initialize some of the structures that will be used later on
        // in calls to WinVerifyTrust.  We don't know if we're verifying
        // against a catalog or against a file yet.
        //
        ZeroMemory(&WintrustData, sizeof(WINTRUST_DATA));
        WintrustData.cbStruct = sizeof(WINTRUST_DATA);
        WintrustData.dwUIChoice = WTD_UI_NONE;
        WintrustData.dwProvFlags =  WTD_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT |
                                    WTD_CACHE_ONLY_URL_RETRIEVAL;

        if(!UseAuthenticodePolicy) {
            //
            // We only supply a driver version info structure if we're doing
            // validation via driver signing policy.  Authenticode completely
            // ignores this...
            //
            if(AltPlatformInfo) {

                MYASSERT(AltPlatformInfo->cbSize == sizeof(SP_ALTPLATFORM_INFO_V2));

                //
                // Caller wants the file validated for an alternate
                // platform, so we must fill in a DRIVER_VER_INFO structure
                // to be passed to the policy module.
                //
                VersionInfo.dwPlatform = AltPlatformInfo->Platform;
                VersionInfo.dwVersion  = AltPlatformInfo->MajorVersion;

                VersionInfo.sOSVersionLow.dwMajor  = AltPlatformInfo->FirstValidatedMajorVersion;
                VersionInfo.sOSVersionLow.dwMinor  = AltPlatformInfo->FirstValidatedMinorVersion;
                VersionInfo.sOSVersionHigh.dwMajor = AltPlatformInfo->MajorVersion;
                VersionInfo.sOSVersionHigh.dwMinor = AltPlatformInfo->MinorVersion;

            } else {
                //
                // If an AltPlatformInfo was not passed in then set the
                // WTD_USE_DEFAULT_OSVER_CHECK flag. This flag tells
                // WinVerifyTrust to use its default osversion checking, even
                // though a DRIVER_VER_INFO structure was passed in.
                //
                WintrustData.dwProvFlags |= WTD_USE_DEFAULT_OSVER_CHECK;
            }

            //
            // Specify a DRIVER_VER_INFO structure so we can get back
            // who signed the file and the signer version information.
            // If we don't have an AltPlatformInfo then set the
            // WTD_USE_DEFAULT_OSVER_CHECK flag so that WinVerifyTrust will do
            // its default checking, just as if a DRIVER_VER_INFO structure
            // was not passed in.
            //
            WintrustData.pPolicyCallbackData = (PVOID)&VersionInfo;

            //
            // "auto-cache" feature only works for driver signing policy...
            //
            WintrustData.dwStateAction = WTD_STATEACTION_AUTO_CACHE;
        }

        //
        // Compute the cryptographic hash for the file.  If we fail to compute
        // this hash, we want to bail immediately.  We don't want to attempt to
        // fallback to self-signed binaries, because in the future the hash may
        // be used to revoke a signature, and we wouldn't want to automatically
        // trust a self-signed binary in that case.
        //

        HashSize = 100; // start out with a reasonable size for most requests.

        do {

            Hash = MyMalloc(HashSize);

            if(!Hash) {
                Err = ERROR_NOT_ENOUGH_MEMORY;
            } else {
                Err = GLE_FN_CALL(FALSE,
                                  CryptCATAdminCalcHashFromFileHandle(hFile, 
                                                                      &HashSize, 
                                                                      Hash, 
                                                                      0)
                                 );
            }

            if(Err != NO_ERROR) {

                if(Hash) {
                    MyFree(Hash);
                    Hash = NULL;
                }

                if(Err != ERROR_INSUFFICIENT_BUFFER) {
                    //
                    // We failed for some reason other than buffer-too-small.
                    //
                    WriteLogEntry(LogContext,
                                  SETUP_LOG_WARNING | SETUP_LOG_BUFFER,
                                  MSG_LOG_HASH_ERROR,
                                  NULL,
                                  FileFullPath,
                                  Catalog ? Catalog : TEXT(""),
                                  Key
                                 );

                    WriteLogError(LogContext, SETUP_LOG_WARNING, Err);

                    LoggedWarning = TRUE;

                    if(Problem) {
                        *Problem = SetupapiVerifyFileProblem;
                        StringCchCopy(ProblemFile, MAX_PATH, FileFullPath);
                    }

                    leave;
                }
            }

        } while(Err != NO_ERROR);

        //
        // Now we have the file's hash.  Initialize the structures that will be
        // used later on in calls to WinVerifyTrust.
        //
        WintrustData.dwUnionChoice = WTD_CHOICE_CATALOG;
        WintrustData.pCatalog = &WintrustCatalogInfo;

        ZeroMemory(&WintrustCatalogInfo, sizeof(WINTRUST_CATALOG_INFO));
        WintrustCatalogInfo.cbStruct = sizeof(WINTRUST_CATALOG_INFO);
        WintrustCatalogInfo.pbCalculatedFileHash = Hash;
        WintrustCatalogInfo.cbCalculatedFileHash = HashSize;

        //
        // WinVerifyTrust is case-sensitive, so ensure that the key being used
        // is all lower-case.  (We copy the key to a writable Unicode character 
        // buffer so we can lower-case it.)
        //
        StringCchCopy(UnicodeKey, SIZECHARS(UnicodeKey), Key);
        CharLower(UnicodeKey);
        WintrustCatalogInfo.pcwszMemberTag = UnicodeKey;

        if(Catalog && (Catalog != pSetupGetFileTitle(Catalog))) {
            //
            // We know in this case we're always going to examine exactly one 
            // catalog.
            //
            if(NumCatalogsConsidered) {
                *NumCatalogsConsidered = 1;
            }

            //
            // Fill in the catalog information since we know which catalog
            // we're going to be using...
            //
            WintrustCatalogInfo.pcwszCatalogFilePath = Catalog;
            //
            // The caller supplied the path to the catalog file to be used for
            // verification--we're ready to go!  First, verify the catalog
            // (unless the caller already did it), and if that succeeds, then
            // verify the file.
            //
            if(!CatalogAlreadyVerified || UseAuthenticodePolicy) {
                //
                // Before validating the catalog, we'll flush the crypto cache.
                // Otherwise, it can get fooled when validating against a
                // catalog at a specific location, because that catalog can
                // change "behind its back".
                //
                if(WintrustData.dwStateAction == WTD_STATEACTION_AUTO_CACHE) {

                    WintrustData.dwStateAction = WTD_STATEACTION_AUTO_CACHE_FLUSH;

                    Err = (DWORD)WinVerifyTrust(NULL,
                                                &DriverVerifyGuid,
                                                &WintrustData
                                               );
                    if(Err != NO_ERROR) {
                        //
                        // This shouldn't fail, but log a warning if it does...
                        //
                        WriteLogEntry(LogContext,
                                      SETUP_LOG_WARNING | SETUP_LOG_BUFFER,
                                      MSG_LOG_CRYPTO_CACHE_FLUSH_FAILURE,
                                      NULL,
                                      Catalog
                                     );

                        WriteLogError(LogContext,
                                      SETUP_LOG_WARNING,
                                      Err
                                     );
                        //
                        // treat this error as non-fatal
                        //
                    }

                    //
                    // When flushing the cache, crypto isn't supposed to be
                    // allocating a pcSignerCertContext...
                    //
                    MYASSERT(!VersionInfo.pcSignerCertContext);
                    if(VersionInfo.pcSignerCertContext) {
                        CertFreeCertificateContext(VersionInfo.pcSignerCertContext);
                        VersionInfo.pcSignerCertContext = NULL;
                    }

                    //
                    // Now back to our regularly-scheduled programming...
                    //
                    WintrustData.dwStateAction = WTD_STATEACTION_AUTO_CACHE;
                }

                //
                // NTRAID#NTBUG9-705286-2002/09/17-LonnyM superfluous validation of catalog
                // Apparently, WinVerifyTrust validates both the catalog, and
                // the file vouched thereby.  We should clean this up, although
                // the performance delta is probably insignificant.
                //
                Err = _VerifyCatalogFile(LogContext,
                                         Catalog,
                                         AltPlatformInfo,
                                         UseAuthenticodePolicy,
                                         (VerifyContext
                                             ? &(VerifyContext->hStoreTrustedPublisher)
                                             : NULL),
                                         hWVTStateData
                                        );
                //
                // If we got one of the two "successful" errors when validating
                // via Authenticode policy, then reset our error, and save the
                // Authenticode error for use later, if we don't subsequently
                // encounter some other failure.
                //
                if((Err == ERROR_AUTHENTICODE_TRUSTED_PUBLISHER) ||
                   (Err == ERROR_AUTHENTICODE_TRUST_NOT_ESTABLISHED)) {

                    MYASSERT(UseAuthenticodePolicy);
                    MYASSERT(!hWVTStateData || *hWVTStateData);

                    AuthenticodeErr = Err;
                    Err = NO_ERROR;
                }
            }

            if(Err != NO_ERROR) {

                MYASSERT(!hWVTStateData || !*hWVTStateData);

                WriteLogEntry(LogContext,
                              GetCatLogLevel(Err, UseAuthenticodePolicy) | SETUP_LOG_BUFFER,
                              (UseAuthenticodePolicy
                                  ? MSG_LOG_VERIFYCAT_VIA_AUTHENTICODE_ERROR
                                  : MSG_LOG_VERIFYCAT_ERROR),
                              NULL,
                              Catalog
                             );

                WriteLogError(LogContext, 
                              GetCatLogLevel(Err, UseAuthenticodePolicy), 
                              Err
                             );

                LoggedWarning = TRUE;

                if(Problem) {
                    *Problem = SetupapiVerifyCatalogProblem;
                    StringCchCopy(ProblemFile, MAX_PATH, Catalog);
                }

                leave;
            }

            //
            // Catalog was verified, now verify the file using that catalog.
            //
            if(CatalogFileUsed) {
                StringCchCopy(CatalogFileUsed, MAX_PATH, Catalog);
            }

            Err = (DWORD)WinVerifyTrust(NULL,
                                        (UseAuthenticodePolicy
                                            ? &AuthenticodeVerifyGuid
                                            : &DriverVerifyGuid),
                                        &WintrustData
                                       );

            //
            // Fill in the DigitalSigner and SignerVersion if they were passed 
            // in.
            //
            if(Err == NO_ERROR) {

                if(DigitalSigner) {
                    StringCchCopy(DigitalSigner, MAX_PATH, VersionInfo.wszSignedBy);
                }

                if(SignerVersion) {
                    StringCchCopy(SignerVersion, MAX_PATH, VersionInfo.wszVersion);
                }

            } else if(!UseAuthenticodePolicy && (Err == ERROR_APP_WRONG_OS)) {
                //
                // We failed validation via driver signing policy because of an
                // osattribute mismatch.  Translate this error into something
                // with more understandable text.
                //
                Err = ERROR_SIGNATURE_OSATTRIBUTE_MISMATCH;
            }

            if(Err != NO_ERROR) {

                WriteLogEntry(LogContext,
                              GetCatLogLevel(Err, UseAuthenticodePolicy) | SETUP_LOG_BUFFER,
                              (UseAuthenticodePolicy
                                  ? MSG_LOG_VERIFYFILE_AUTHENTICODE_AGAINST_FULLCATPATH_ERROR
                                  : MSG_LOG_VERIFYFILE_AGAINST_FULLCATPATH_ERROR),
                              NULL,
                              FileFullPath,
                              Catalog,
                              Key
                             );

                WriteLogError(LogContext, 
                              GetCatLogLevel(Err, UseAuthenticodePolicy), 
                              Err
                             );

                LoggedWarning = TRUE;

                if(Problem) {
                    *Problem = SetupapiVerifyFileProblem;
                    StringCchCopy(ProblemFile, MAX_PATH, FileFullPath);
                }

            } else {
                //
                // Log the successful validation against the caller-specified 
                // catalog.
                //
                if(UseAuthenticodePolicy) {

                    WriteLogEntry(LogContext,
                                  DRIVER_LOG_INFO | SETUP_LOG_BUFFER,
                                  MSG_LOG_VERIFYFILE_AUTHENTICODE_AGAINST_FULLCATPATH_OK,
                                  NULL,
                                  FileFullPath,
                                  Catalog,
                                  Key
                                 );

                    WriteLogError(LogContext, DRIVER_LOG_INFO, AuthenticodeErr);

                } else {

                    WriteLogEntry(LogContext,
                                  SETUP_LOG_VERBOSE,
                                  MSG_LOG_VERIFYFILE_AGAINST_FULLCATPATH_OK,
                                  NULL,
                                  FileFullPath,
                                  Catalog,
                                  Key
                                 );
                }
            }
        
            //
            // We don't attempt to fallback to self-contained signatures in
            // cases where the catalog is specifically specified.  Thus, we're
            // done, regardless of whether or not we were successful.
            //
            leave;
        }

        //
        // We'd better have a catalog name (i.e., not be doing global
        // validation) if we're supposed to be verifying via Authenticode
        // policy!
        //
        MYASSERT(!UseAuthenticodePolicy || Catalog);

        //
        // Search through installed catalogs looking for those that contain
        // data for a file with the hash we just calculated (aka, "global
        // validation").
        //
        PrevCat = NULL;

        Err = GLE_FN_CALL(NULL,
                          hCatInfo = CryptCATAdminEnumCatalogFromHash(
                                         LocalhCatAdmin,
                                         Hash,
                                         HashSize,
                                         0,
                                         &PrevCat)
                         );

        while(hCatInfo) {

            CatInfo.cbStruct = sizeof(CATALOG_INFO);
            if(CryptCATCatalogInfoFromContext(hCatInfo, &CatInfo, 0)) {

                CatalogFullPath = CatInfo.wszCatalogFile;

                //
                // If we have a catalog name we're looking for, see if the
                // current catalog matches.  If the caller didn't specify a
                // catalog, then just attempt to validate against each
                // catalog we enumerate.  Note that the catalog file info
                // we get back gives us a fully qualified path.
                //
                if(Catalog) {
                    FoundMatchingImage = !lstrcmpi(
                                            pSetupGetFileTitle(CatalogFullPath),
                                            Catalog
                                            );
                } else {

                    if((Flags & VERIFY_FILE_USE_OEM_CATALOGS) ||
                       !IsInstalledFileFromOem(pSetupGetFileTitle(CatalogFullPath),
                                               OemFiletypeCat)) {

                        FoundMatchingImage = TRUE;
                    } else {
                        FoundMatchingImage = FALSE;
                    }
                }

                if(FoundMatchingImage) {
                    //
                    // Increment our counter of how many catalogs we've 
                    // considered.
                    //
                    if(NumCatalogsConsidered) {
                        (*NumCatalogsConsidered)++;
                    }

                    //
                    // If the caller supplied a mapped-in image of the 
                    // catalog we're looking for, then check to see if this
                    // catalog matches by doing a binary compare.
                    //
                    if(CatalogBaseAddress) {

                        FoundMatchingImage = GetFileAttributesEx(
                                                    CatalogFullPath,
                                                    GetFileExInfoStandard,
                                                    &FileAttribData
                                                    );
                        //
                        // Check to see if the catalog we're looking
                        // at is the same size as the one we're
                        // verifying.
                        //
                        if(FoundMatchingImage &&
                           (FileAttribData.nFileSizeLow != CatalogImageSize)) {

                            FoundMatchingImage = FALSE;
                        }

                        if(FoundMatchingImage) {

                            if(NO_ERROR == pSetupOpenAndMapFileForRead(
                                               CatalogFullPath,
                                               &CurCatFileSize,
                                               &CurCatFileHandle,
                                               &CurCatMappingHandle,
                                               &CurCatBaseAddress)) {

                                MYASSERT(CurCatFileSize == CatalogImageSize);

                                //
                                // Wrap this binary compare in its own try/
                                // except block, because if we run across a
                                // catalog we can't read for some reason,
                                // we don't want this to abort our search.
                                //
                                try {

                                    FoundMatchingImage = 
                                        !memcmp(CatalogBaseAddress,
                                                CurCatBaseAddress,
                                                CatalogImageSize
                                               );

                                } except(pSetupExceptionFilter(GetExceptionCode())) {

                                    pSetupExceptionHandler(GetExceptionCode(), 
                                                           ERROR_READ_FAULT, 
                                                           NULL);

                                    FoundMatchingImage = FALSE;
                                }

                                pSetupUnmapAndCloseFile(CurCatFileHandle,
                                                        CurCatMappingHandle,
                                                        CurCatBaseAddress
                                                       );

                            } else {
                                FoundMatchingImage = FALSE;
                            }
                        }

                    } else {
                        //
                        // Since there was no catalog image supplied to
                        // match against, the catalog we're currently 
                        // looking at is considered a valid match 
                        // candidate.
                        //
                        FoundMatchingImage = TRUE;
                    }

                    if(FoundMatchingImage) {
                        //
                        // We found an applicable catalog, now validate the
                        // file against that catalog (this also validates the
                        // catalog itself).
                        //
                        WintrustCatalogInfo.pcwszCatalogFilePath = CatInfo.wszCatalogFile;

                        Err = (DWORD)WinVerifyTrust(NULL,
                                                    (UseAuthenticodePolicy
                                                        ? &AuthenticodeVerifyGuid
                                                        : &DriverVerifyGuid),
                                                    &WintrustData
                                                   );

                        //
                        // Fill in the DigitalSigner and SignerVersion if
                        // they were passed in.
                        //
                        if(Err == NO_ERROR) {
                            if(DigitalSigner) {
                                StringCchCopy(DigitalSigner, MAX_PATH, VersionInfo.wszSignedBy);
                            }

                            if(SignerVersion) {
                                StringCchCopy(SignerVersion, MAX_PATH, VersionInfo.wszVersion);
                            }

                        } else if(!UseAuthenticodePolicy && (Err == ERROR_APP_WRONG_OS)) {
                            //
                            // We failed validation via driver signing policy 
                            // because of an osattribute mismatch.  Translate 
                            // this error into something with more 
                            // understandable text.
                            //
                            // NOTE: Unfortunately, the crypto APIs report
                            // ERROR_APP_WRONG_OS in two quite different cases:
                            // 
                            //     1.  Valid driver signing catalog has an
                            //         osattribute mismatch.
                            //     2.  Authenticode catalog is being validated
                            //         using driver signing policy.
                            //
                            // We want to translate the error in the first case
                            // but not in the second.  The only way to 
                            // distinguish these two cases is to re-attempt
                            // verification against _all_ os versions.  Thus,
                            // any failure encountered must be due to #2.
                            //

                            //
                            // The DRIVER_VER_INFO structure was filled in
                            // during our previous call to WinVerifyTrust with
                            // a pointer that we must free!
                            //
                            if(VersionInfo.pcSignerCertContext) {
                                CertFreeCertificateContext(VersionInfo.pcSignerCertContext);
                            }

                            //
                            // Now reset the structure and clear the flag so
                            // that we'll validate against _any_ OS version
                            // (irrespective of the catalog's osattributes).
                            //
                            ZeroMemory(&VersionInfo, sizeof(DRIVER_VER_INFO));
                            VersionInfo.cbStruct = sizeof(DRIVER_VER_INFO);
                            WintrustData.dwProvFlags &= ~WTD_USE_DEFAULT_OSVER_CHECK;

                            if(NO_ERROR == WinVerifyTrust(NULL,
                                                          &DriverVerifyGuid,
                                                          &WintrustData)) {
                                //
                                // The catalog is a valid driver signing
                                // catalog (i.e., case #1 discussed above).
                                // Translate this into more specific/meaningful
                                // error.
                                //
                                Err = ERROR_SIGNATURE_OSATTRIBUTE_MISMATCH;
                            }
                        }

                        //
                        // If we successfully validated via Authenticode 
                        // policy, then we need to determine whether the 
                        // catalog's publisher is in the TrustedPublisher cert
                        // store.
                        //
                        if((Err == NO_ERROR) && UseAuthenticodePolicy) {

                            AuthenticodeErr = _VerifyCatalogFile(
                                                  LogContext,
                                                  WintrustCatalogInfo.pcwszCatalogFilePath,
                                                  NULL,
                                                  TRUE,
                                                  (VerifyContext
                                                      ? &(VerifyContext->hStoreTrustedPublisher)
                                                      : NULL),
                                                  hWVTStateData
                                                  );

                            MYASSERT((AuthenticodeErr == ERROR_AUTHENTICODE_TRUSTED_PUBLISHER) ||
                                     (AuthenticodeErr == ERROR_AUTHENTICODE_TRUST_NOT_ESTABLISHED));

                            if((AuthenticodeErr != ERROR_AUTHENTICODE_TRUSTED_PUBLISHER) &&
                               (AuthenticodeErr != ERROR_AUTHENTICODE_TRUST_NOT_ESTABLISHED)) {
                                //
                                // This shouldn't have failed, but since it
                                // did, we'll propagate this over to our error
                                // status so we treat it appropriately.
                                //
                                Err = AuthenticodeErr;
                            }
                        }

                        if(!UseAuthenticodePolicy) {
                            //
                            // The DRIVER_VER_INFO structure was filled in with
                            // a pointer that we must free!
                            //
                            if(VersionInfo.pcSignerCertContext) {
                                CertFreeCertificateContext(VersionInfo.pcSignerCertContext);
                                VersionInfo.pcSignerCertContext = NULL;
                            }
                        }

                        if(Err != NO_ERROR) {

                            WriteLogEntry(LogContext,
                                          GetCatLogLevel(Err, UseAuthenticodePolicy) | SETUP_LOG_BUFFER,
                                          (UseAuthenticodePolicy
                                              ? MSG_LOG_VERIFYFILE_AUTHENTICODE_GLOBAL_VALIDATION_ERROR
                                              : MSG_LOG_VERIFYFILE_GLOBAL_VALIDATION_ERROR),
                                          NULL,
                                          FileFullPath,
                                          CatInfo.wszCatalogFile,
                                          Key
                                         );

                            WriteLogError(LogContext, 
                                          GetCatLogLevel(Err, UseAuthenticodePolicy), 
                                          Err
                                         );

                            LoggedWarning = TRUE;

                        } else {

                            if(UseAuthenticodePolicy) {

                                WriteLogEntry(LogContext,
                                              DRIVER_LOG_INFO | SETUP_LOG_BUFFER,
                                              MSG_LOG_VERIFYFILE_AUTHENTICODE_GLOBAL_VALIDATION_OK,
                                              NULL,
                                              FileFullPath,
                                              CatInfo.wszCatalogFile,
                                              Key
                                             );

                                WriteLogError(LogContext, 
                                              DRIVER_LOG_INFO, 
                                              AuthenticodeErr
                                             );

                            } else {

                                WriteLogEntry(LogContext,
                                              SETUP_LOG_VERBOSE,
                                              MSG_LOG_VERIFYFILE_GLOBAL_VALIDATION_OK,
                                              NULL,
                                              FileFullPath,
                                              CatInfo.wszCatalogFile,
                                              Key
                                             );
                            }
                        }

                        if(Err == NO_ERROR) {
                            //
                            // We successfully verified the file--store the 
                            // name of the catalog used, if the caller
                            // requested it.
                            //
                            if(CatalogFileUsed) {
                                StringCchCopy(CatalogFileUsed, MAX_PATH, CatalogFullPath);
                            }

                        } else {

                            if(Catalog || CatalogBaseAddress) {
                                //
                                // We only want to return the catalog file used
                                // in cases where we believe the catalog to be
                                // valid.  In this situation, the only case we
                                // can tell for certain is when we encounter an
                                // osattribute mismatch.
                                //
                                if(CatalogFileUsed && (Err == ERROR_SIGNATURE_OSATTRIBUTE_MISMATCH)) {
                                    StringCchCopy(CatalogFileUsed, MAX_PATH, CatalogFullPath);
                                }

                                if(Problem) {
                                    *Problem = SetupapiVerifyFileProblem;
                                    StringCchCopy(ProblemFile, MAX_PATH, FileFullPath);
                                }
                            }
                        }

                        //
                        // If the result of the above validations is success,
                        // then we're done.  If not, and we're looking for a
                        // relevant catalog file (i.e., the INF didn't specify
                        // one), then we move on to the next catalog.
                        // Otherwise, we've failed.
                        //
                        if((Err == NO_ERROR) || Catalog || CatalogBaseAddress) {

                            CryptCATAdminReleaseCatalogContext(LocalhCatAdmin, hCatInfo, 0);
                            hCatInfo = NULL;
                            break;
                        }
                    }
                }
            }

            PrevCat = hCatInfo;

            Err = GLE_FN_CALL(NULL,
                              hCatInfo = CryptCATAdminEnumCatalogFromHash(
                                             LocalhCatAdmin, 
                                             Hash, 
                                             HashSize, 
                                             0, 
                                             &PrevCat)
                             );
        }

        if(Err == NO_ERROR) {
            //
            // We successfully validated the file--we're done!
            //
            leave;
        }

        //
        // report failure if we haven't already done so
        //
        if(!LoggedWarning) {

            WriteLogEntry(LogContext,
                          GetCatLogLevel(Err, UseAuthenticodePolicy) | SETUP_LOG_BUFFER,
                          (UseAuthenticodePolicy
                              ? MSG_LOG_VERIFYFILE_AUTHENTICODE_GLOBAL_VALIDATION_NO_CATS_FOUND
                              : MSG_LOG_VERIFYFILE_GLOBAL_VALIDATION_NO_CATS_FOUND),
                          NULL,
                          FileFullPath,
                          Catalog ? Catalog : TEXT(""),
                          Key
                         );

            WriteLogError(LogContext, 
                          GetCatLogLevel(Err, UseAuthenticodePolicy), 
                          Err
                         );

            LoggedWarning = TRUE;
        }

        if(!(Flags & (VERIFY_FILE_IGNORE_SELFSIGNED | VERIFY_FILE_USE_AUTHENTICODE_CATALOG))) {
            //
            // We've been instructed to allow self-signed files to be
            // considered valid, so check for self-contained signature now.
            //
            WintrustData.dwUnionChoice = WTD_CHOICE_FILE;
            WintrustData.pFile = &WintrustFileInfo;
            ZeroMemory(&WintrustFileInfo, sizeof(WINTRUST_FILE_INFO));
            WintrustFileInfo.cbStruct = sizeof(WINTRUST_FILE_INFO);
            WintrustFileInfo.pcwszFilePath = FileFullPath;

            Err = (DWORD)WinVerifyTrust(NULL,
                                        &DriverVerifyGuid,
                                        &WintrustData
                                       );

            //
            // Fill in the DigitalSigner and SignerVersion if
            // they were passed in.
            //
            if(Err == NO_ERROR) {
                if(DigitalSigner) {
                    StringCchCopy(DigitalSigner, MAX_PATH, VersionInfo.wszSignedBy);
                }

                if(SignerVersion) {
                    StringCchCopy(SignerVersion, MAX_PATH, VersionInfo.wszVersion);
                }
            }

            //
            // The DRIVER_VER_INFO structure was filled in with a pointer that
            // we must free!
            //
            if(VersionInfo.pcSignerCertContext) {
                CertFreeCertificateContext(VersionInfo.pcSignerCertContext);
                VersionInfo.pcSignerCertContext = NULL;
            }

            if(Err != NO_ERROR) {

                WriteLogEntry(LogContext,
                              SETUP_LOG_VERBOSE | SETUP_LOG_BUFFER,
                              MSG_LOG_SELFSIGN_ERROR,
                              NULL,
                              FileFullPath,
                              Key
                             );

                WriteLogError(LogContext, SETUP_LOG_VERBOSE, Err);

                LoggedWarning = TRUE;

            } else {

                WriteLogEntry(LogContext,
                              SETUP_LOG_VERBOSE,
                              MSG_LOG_SELFSIGN_OK,
                              NULL,
                              FileFullPath,
                              Key
                             );
            }
        }

        if(Err == NO_ERROR) {
            //
            // The file validated without a catalog.  Store an empty string
            // in the CatalogFileUsed buffer (if supplied).
            //
            if(CatalogFileUsed) {
                *CatalogFileUsed = TEXT('\0');
            }

        } else {
            //
            // report error prior to Self-Sign check
            //
            if(Problem) {
                *Problem = SetupapiVerifyFileProblem;
                StringCchCopy(ProblemFile, MAX_PATH, FileFullPath);
            }
        }

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, &Err);
    }

    if(Err == NO_ERROR) {
        //
        // If we successfully validated via Authenticode policy, then we should
        // have squirrelled away one of two "special" errors to be returned to
        // the caller...
        //
        MYASSERT((AuthenticodeErr == NO_ERROR) || UseAuthenticodePolicy);

        Err = AuthenticodeErr;

    } else {
        //
        // If we failed, and we haven't already logged a message indicating the
        // cause of the failure, log a generic message now.
        //
        if(!LoggedWarning) {

            WriteLogEntry(LogContext,
                          GetCatLogLevel(Err, UseAuthenticodePolicy) | SETUP_LOG_BUFFER,
                          (UseAuthenticodePolicy
                              ? MSG_LOG_VERIFYFILE_AUTHENTICODE_ERROR
                              : MSG_LOG_VERIFYFILE_ERROR),
                          NULL,
                          FileFullPath,
                          Catalog ? Catalog : TEXT(""),
                          Key
                         );

            WriteLogError(LogContext, 
                          GetCatLogLevel(Err, UseAuthenticodePolicy), 
                          Err
                         );
        }

        if(hWVTStateData && *hWVTStateData) {
            //
            // We must've hit an exception after retrieving the WinVerifyTrust
            // state data.  This is extremely unlikely, but if this happens,
            // we need to free this here and now.
            //
            pSetupCloseWVTStateData(*hWVTStateData);
            *hWVTStateData = NULL;
        }
    }

    if(!VerifyContext && LocalhSDBDrvMain) {
        //
        // Don't need to return our HSDB to the caller, so free it now.
        //
        SdbReleaseDatabase(LocalhSDBDrvMain);
    }

    if(hFile != INVALID_HANDLE_VALUE) {
        CloseHandle(hFile);
    }

    if(AltPlatSlot) {
        ReleaseLogInfoSlot(LogContext, AltPlatSlot);
    }

    if(Hash) {
        MyFree(Hash);
    }

    if(!UseAuthenticodePolicy && VersionInfo.pcSignerCertContext) {
        CertFreeCertificateContext(VersionInfo.pcSignerCertContext);
    }

    if(hCatInfo) {
        MYASSERT(LocalhCatAdmin);
        CryptCATAdminReleaseCatalogContext(LocalhCatAdmin, hCatInfo, 0);
    }

    if(!VerifyContext && LocalhCatAdmin) {
        CryptCATAdminReleaseContext(LocalhCatAdmin, 0);
    }

    return Err;
}


DWORD
pSetupVerifyFile(
    IN  PSETUP_LOG_CONTEXT      LogContext,
    IN  LPCTSTR                 Catalog,                OPTIONAL
    IN  PVOID                   CatalogBaseAddress,     OPTIONAL
    IN  DWORD                   CatalogImageSize,
    IN  LPCTSTR                 Key,
    IN  LPCTSTR                 FileFullPath,
    OUT SetupapiVerifyProblem  *Problem,                OPTIONAL
    OUT LPTSTR                  ProblemFile,            OPTIONAL
    IN  BOOL                    CatalogAlreadyVerified,
    IN  PSP_ALTPLATFORM_INFO_V2 AltPlatformInfo,        OPTIONAL
    OUT LPTSTR                  CatalogFileUsed,        OPTIONAL
    OUT PDWORD                  NumCatalogsConsidered   OPTIONAL
    )

/*++

Routine Description:

    See _VerifyFile

    Since this private API is exported for use by other system components
    (e.g., syssetup), we make a check to ensure that the AltPlatformInfo, if
    specified, is of the correct version.

--*/

{
    if(AltPlatformInfo) {
        if(AltPlatformInfo->cbSize != sizeof(SP_ALTPLATFORM_INFO_V2)) {
            return ERROR_INVALID_PARAMETER;
        }
        if(!(AltPlatformInfo->Flags & SP_ALTPLATFORM_FLAGS_VERSION_RANGE)) {
            //
            // this flag must be set to indicate the version range fields are
            // valid
            //
            return ERROR_INVALID_PARAMETER;
        }
    }

    return _VerifyFile(LogContext,
                       NULL,
                       Catalog,
                       CatalogBaseAddress,
                       CatalogImageSize,
                       Key,
                       FileFullPath,
                       Problem,
                       ProblemFile,
                       CatalogAlreadyVerified,
                       AltPlatformInfo,
                       0,
                       CatalogFileUsed,
                       NumCatalogsConsidered,
                       NULL,
                       NULL,
                       NULL
                      );
}


BOOL
IsInfForDeviceInstall(
    IN  PSETUP_LOG_CONTEXT       LogContext,           OPTIONAL
    IN  CONST GUID              *DeviceSetupClassGuid, OPTIONAL
    IN  PLOADED_INF              LoadedInf,            OPTIONAL
    OUT PTSTR                   *DeviceDesc,           OPTIONAL
    OUT PSP_ALTPLATFORM_INFO_V2 *ValidationPlatform,   OPTIONAL
    OUT PDWORD                   PolicyToUse,          OPTIONAL
    OUT PBOOL                    UseOriginalInfName,   OPTIONAL
    IN  BOOL                     ForceNonDrvSignPolicy
    )

/*++

Routine Description:

    This routine determines whether the specified INF is a device INF.  If so,
    it returns a generic string to use in identifying the device installation
    when there is no device description available (e.g., installing a printer).
    It can also return the appropriate platform parameters to be used in
    digital signature verification for this INF, as well as the codesigning
    policy to employ should a digital signature validation failure occur.
    Finally, this routine can indicate whether the INF should be installed
    under its original name (i.e., because it's an exception package INF).

Arguments:

    LogContext - Optionally, supplies the log context for any log entries that
        might be generated by this routine.

    DeviceSetupClassGuid - Optionally, supplies the address of a GUID that
        indicates which device setup class is to be used in determining
        information such as description, validation platform, and policy to
        use.  If this parameter is NULL, then the GUID is retrieved from the
        INF list supplied via the LoadedInf parameter.

    LoadedInf - Optionally, supplies the address of a loaded INF list we need
        to examine to see if any of the members therein are device INFs.  An
        INF is a device INF if it specifies a class association (via either
        Class= or ClassGUID= entries) in its [Version] section.  If the
        DeviceSetupClassGuid parameter is supplied (i.e., non-NULL), then this
        parameter is ignored.  If this parameter is also NULL, then it is
        assumed the installation is not device-related.

        The presence of a device INF anywhere in this list will cause us to
        consider this a device installation.  However, the _first_ INF we
        encounter having a class association is what will be used in 
        determining the device description (see below).

        ** NOTE:  The caller is responsible for locking the loaded INF **
        **        list prior to calling this routine!                  **

    DeviceDesc - Optionally, supplies the address of a string pointer that will
        be filled in upon return with a (newly-allocated) descriptive string to
        be used when referring to this installation (e.g., for doing driver
        signing failure popups).  We will first try to retrieve the friendly
        name for this INF's class (whose determination is described above).  If
        that's not possible (e.g., the class isn't yet installed), then we'll
        return the class name.  If that's not possible, then we'll return a
        (localized) generic string such as "Unknown driver software package".

        This output parameter (if supplied) will only ever be set to a non-NULL
        value when the routine returns TRUE.  The caller is responsible for
        freeing this character buffer.  If an out-of-memory failure is
        encountered when trying to allocate memory for this buffer, the
        DeviceDesc pointer will simply be set to NULL.  It will also be set to
        NULL if we're dealing with an exception package (since we don't want
        to treat this like a "hardware install" for purposes of codesigning
        blocking UI).

    ValidationPlatform - Optionally, supplies the address of a (version 2)
        altplatform info pointer that is filled in upon return with a newly-
        allocated structure specifying the appropriate parameters to be passed
        to WinVerifyTrust when validating this INF.  These parameters are
        retrieved from certclas.inf for the relevant device setup class GUID.
        If no special parameters are specified for this class (or if the INF
        has no class at all), then this pointer is returned as NULL, which
        causes us to use WinVerifyTrust's default validation.  Note that if
        we fail to allocate this structure due to low-memory, the pointer will
        be returned as NULL in that case as well.  This is OK, because this
        simply means we'll do default validation in that case.

        By this mechanism, we can easily deal with the different validation
        policies in effect for the various device classes we have in the 
        system.

        The caller is responsible for freeing the memory allocated for this
        structure.

    PolicyToUse - Optionally, supplies the address of a dword variable that is
        set upon return to indicate what codesigning policy (i.e., Ignore, 
        Warn, or Block) should be used for this INF.  This determination is 
        made based on whether any INF in the list is of a class that WHQL has a
        certification program for (as specified in %windir%\Inf\certclas.inf).

        Additionally, if any INF in the list is of the exception class, then
        the policy is automatically set to Block (i.e., it's not configurable
        via driver signing or non-driver-signing policy/preference settings).
        
        If it's appropriate to allow for a fallback to an Authenticode
        signature, then the high bit of the policy value will be set (i.e.,
        DRIVERSIGN_ALLOW_AUTHENTICODE).

    UseOriginalInfName - Optionally, supplies the address of a boolean variable
        that is set upon return to indicate whether the INF should be installed
        into %windir%\Inf under its original name.  This will only be true if
        the INF is an exception INF.

    ForceNonDrvSignPolicy - if TRUE, then we'll use non-driver signing policy,
        regardless of whether the INF has an associated device setup class
        GUID.  (Note: this override won't work if that class GUID is in the
        WHQL logo-able list contained in certclas.inf--in that case, we always
        want to use driver signing policy.)
        
        This override will also cause us to report that the INF is _not_ a
        device INF (assuming it's not a WHQL class, as described above).
                   
Return Value:

    If the INF is a device INF, the return value is TRUE.  Otherwise, it is
    FALSE.

--*/

{
    PLOADED_INF CurInf, NextInf;
    GUID ClassGuid;
    BOOL DeviceInfFound, ClassInDrvSignList;
    TCHAR ClassDescBuffer[LINE_LEN];
    PCTSTR ClassDesc;
    DWORD Err;
    BOOL IsExceptionInf = FALSE;

    if(DeviceDesc) {
        *DeviceDesc = NULL;
    }

    if(ValidationPlatform) {
        *ValidationPlatform = NULL;
    }

    if(UseOriginalInfName) {
        *UseOriginalInfName = FALSE;
    }

    if(!DeviceSetupClassGuid && !LoadedInf) {
        //
        // Not a whole lot to do here.  Assume non-driver-signing policy and
        // return.
        //
        if(PolicyToUse) {

            *PolicyToUse = pSetupGetCurrentDriverSigningPolicy(FALSE);

            //
            // Non-device installs are always candidates for Authenticode
            // signatures.
            //
            *PolicyToUse |= DRIVERSIGN_ALLOW_AUTHENTICODE;
        }

        return FALSE;
    }

    if(PolicyToUse) {
        *PolicyToUse = DRIVERSIGN_NONE;
    }

    //
    // If DeviceSetupClassGuid was specified, then retrieve information
    // pertaining to that class.  Otherwise, traverse the individual INFs in
    // the LOADED_INF list, examining each one to see if it's a device INF.
    //
    DeviceInfFound = FALSE;
    ClassInDrvSignList = FALSE;

    try {

        for(CurInf = LoadedInf; CurInf || DeviceSetupClassGuid; CurInf = NextInf) {
            //
            // Setup a "NextInf" pointer so we won't dereference NULL when we 
            // go back through the loop in the case where we have a
            // DeviceSetupClassGuid instead of a LoadedInf list.
            //
            NextInf = CurInf ? CurInf->Next : NULL;

            if(!DeviceSetupClassGuid) {
                if(ClassGuidFromInfVersionNode(&(CurInf->VersionBlock), &ClassGuid)) {
                    DeviceSetupClassGuid = &ClassGuid;
                } else {
                    //
                    // This INF doesn't have an associated device setup class 
                    // GUID, so skip it and continue on with our search for a 
                    // device INF.
                    //
                    continue;
                }
            }

            //
            // NOTE: From this point forward, you must reset the
            // DeviceSetupClasGuid pointer to NULL before making another pass
            // through the loop.  Otherwise, we'll enter an infinite loop, 
            // since we can enter the loop if that pointer is non-NULL.
            //

            if(IsEqualGUID(DeviceSetupClassGuid, &GUID_NULL)) {
                //
                // The INF specified a ClassGUID of GUID_NULL (e.g., like some 
                // of our non-device system INFs such as layout.inf do).  Skip 
                // it, and continue on with our search for a device INF.
                //
                DeviceSetupClassGuid = NULL;
                continue;
            }

            //
            // If we get to this point, we have a device setup class GUID.  If 
            // this is the first device INF we've encountered (or our first and 
            // only time through the loop when the caller passed us in a
            // DeviceSetupClassGuid), then do our best to retrieve a 
            // description for it (if we've been asked to do so).  We do not do
            // this for exception packages, because we don't want them to be 
            // referred to as "hardware installs" in the Block dialog if a 
            // signature verification failure occurs.
            //
            if(!DeviceInfFound) {

                DeviceInfFound = TRUE;

                if(DeviceDesc) {

                    if(!IsEqualGUID(DeviceSetupClassGuid, &GUID_DEVCLASS_WINDOWS_COMPONENT_PUBLISHER)) {
                        //
                        // First, try to retrieve the class's friendly name.
                        //
                        if(SetupDiGetClassDescription(DeviceSetupClassGuid,
                                                      ClassDescBuffer,
                                                      SIZECHARS(ClassDescBuffer),
                                                      NULL)) {

                            ClassDesc = ClassDescBuffer;

                        } else if(CurInf) {
                            //
                            // OK, so the class isn't installed yet.  Retrieve 
                            // the class name from the INF itself.
                            //
                            ClassDesc = pSetupGetVersionDatum(&(CurInf->VersionBlock),
                                                              pszClass
                                                             );
                        } else {
                            //
                            // The caller passed us in a device setup class 
                            // GUID instead of an INF.  The class hasn't been 
                            // installed  yet, so we have no idea what to call 
                            // it.
                            //
                            ClassDesc = NULL;
                        }

                        if(!ClassDesc) {
                            //
                            // We have a non-installed class, either with no 
                            // INF, or with an INF that specifies a ClassGUID= 
                            // entry, but no Class= entry in its [Version] 
                            // section.  If we tried to actually install a 
                            // device from such an INF, we'd get a failure in 
                            // SetupDiInstallClass because the class name is
                            // required when installing the class.  However,
                            // this INF might never be used in a device
                            // installation, but it definitely is a device INF.
                            // Therefore, we just give it a generic 
                            // description.
                            //
                            if(LoadString(MyDllModuleHandle,
                                          IDS_UNKNOWN_DRIVER,
                                          ClassDescBuffer,
                                          SIZECHARS(ClassDescBuffer))) {

                                ClassDesc = ClassDescBuffer;
                            } else {
                                ClassDesc = NULL;
                            }
                        }

                        //
                        // OK, we have a description for this device (unless we 
                        // hit some weird error).
                        //
                        if(ClassDesc) {
                            *DeviceDesc = DuplicateString(ClassDesc);
                        }
                    }
                }
            }

            //
            // If we get to this point, we know that:  (a) we have a device 
            // setup class GUID and (b) we've retrieved a device description, 
            // if necessary/possible.
            //
            // Now, check to see if this is an exception class--if it is, then
            // policy is Block, and we want to install the INF and CAT files
            // using their original names.
            //
            if(IsEqualGUID(DeviceSetupClassGuid, &GUID_DEVCLASS_WINDOWS_COMPONENT_PUBLISHER)) {

                if(PolicyToUse) {
                    *PolicyToUse = DRIVERSIGN_BLOCKING;
                }

                if(UseOriginalInfName) {
                    *UseOriginalInfName = TRUE;
                }

                IsExceptionInf = TRUE;
            }

            if(PolicyToUse || ValidationPlatform || ForceNonDrvSignPolicy) {

                //
                // Now check to see if this class is in our list of classes 
                // that WHQL has certification programs for (hence should be 
                // subject to driver signing policy).
                //
                // NOTE: We may also find the exception class GUID in this 
                // list.  This may be used as an override mechanism, in case we 
                // decide to allow 5.0-signed exception packages install on 
                // 5.1, for example.  This should never be the case, since an
                // exception package destined for multiple OS versions should
                // have an OS attribute explicitly calling out each OS version
                // for which it is applicable.  The fact that we check for the
                // exception package override in certclas.inf is simply an
                // "escape hatch" for such an unfortunate eventuality.
                //
                ClassInDrvSignList = ClassGuidInDrvSignPolicyList(
                                         LogContext,
                                         DeviceSetupClassGuid,
                                         ValidationPlatform
                                         );

                if(ClassInDrvSignList) {
                    //
                    // Once we encounter a device INF whose class is in our 
                    // driver signing policy list, we can stop looking...
                    //
                    break;
                }

            } else {
                //
                // The caller doesn't care about whether this class is subject 
                // to driver signing policy.  Since we've already retrieved the 
                // info they care about, we can get out of this loop.
                //
                break;
            }

            DeviceSetupClassGuid = NULL;  // break out in no-INF case
        }

        //
        // Unless we've already established that the policy to use is "Block"
        // (i.e., because we found an exception INF), we should retrieve the
        // applicable policy now...
        //
        if(PolicyToUse && (*PolicyToUse != DRIVERSIGN_BLOCKING)) {

            if(ForceNonDrvSignPolicy) {
                //
                // We want to use non-driver signing policy unless the INF's
                // class is in our WHQL-approved list.
                //
                if(ClassInDrvSignList) {
                    *PolicyToUse = pSetupGetCurrentDriverSigningPolicy(TRUE);
                } else {
                    *PolicyToUse = pSetupGetCurrentDriverSigningPolicy(FALSE)
                                       | DRIVERSIGN_ALLOW_AUTHENTICODE;
                }

            } else {
                //
                // If we have a device INF, we want to use driver signing 
                // policy.  Otherwise, we want "non-driver signing" policy.
                //
                *PolicyToUse = pSetupGetCurrentDriverSigningPolicy(DeviceInfFound);

                //
                // If we have a device setup class, and that class is in our 
                // WHQL-approved list, then we should not accept Authenticode
                // signatures.
                //
                if(!ClassInDrvSignList) {
                    *PolicyToUse |= DRIVERSIGN_ALLOW_AUTHENTICODE;
                }
            }
        }

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, NULL);
    }

    if(ForceNonDrvSignPolicy) {
        return (ClassInDrvSignList || IsExceptionInf);
    } else {
        return DeviceInfFound;
    }
}


DWORD
GetCodeSigningPolicyForInf(
    IN  PSETUP_LOG_CONTEXT       LogContext,         OPTIONAL
    IN  HINF                     InfHandle,
    OUT PSP_ALTPLATFORM_INFO_V2 *ValidationPlatform, OPTIONAL
    OUT PBOOL                    UseOriginalInfName  OPTIONAL
    )

/*++

Routine Description:

    This routine returns a value indicating the appropriate policy to be
    employed should a digital signature verification failure arise from some
    operation initiated by that INF.  It figures out whether the INF is subject
    to driver signing or non-driver signing policy (based on the INF's class
    affiliation), as well as whether or not Authenticode signatures should be
    allowed (based on the presence of an applicable WHQL program).  It also can
    return an altplatform info structure indicating how validation should be
    done (i.e., if certclas.inf indicates that a range of OSATTR versions 
    should be considered valid).

Arguments:

    LogContext - Optionally, supplies the log context for any log entries that
        might be generated by this routine.

    InfHandle - Supplies the handle of the INF for which policy is to be
        retrieved.

    ValidationPlatform - See preamble of IsInfForDeviceInstall routine for
        details.

    UseOriginalInfName - Optionally, supplies the address of a boolean variable
        that is set upon return to indicate whether the INF should be installed
        into %windir%\Inf under its original name.  This will only be true if
        the INF is an exception INF.

Return Value:

    DWORD indicating the policy to be used...
    
        DRIVERSIGN_NONE
        DRIVERSIGN_WARNING
        DRIVERSIGN_BLOCKING
        
    ...potentially OR'ed with the DRIVERSIGN_ALLOW_AUTHENTICODE flag, if it's
    acceptable to check for Authenticode signatures.

--*/

{
    DWORD Policy;

    if(UseOriginalInfName) {
        *UseOriginalInfName = FALSE;
    }

    if(ValidationPlatform) {
        *ValidationPlatform = NULL;
    }

    if(!LockInf((PLOADED_INF)InfHandle)) {
        //
        // This is an internal-only routine, and all callers should be passing
        // in valid INF handles.
        //
        MYASSERT(FALSE);
        //
        // If this does happen, just assume this isn't a device INF (but don't
        // allow Authenticode signatures).
        //
        return pSetupGetCurrentDriverSigningPolicy(FALSE);
    }

    try {

        IsInfForDeviceInstall(LogContext,
                              NULL,
                              (PLOADED_INF)InfHandle,
                              NULL,
                              ValidationPlatform,
                              &Policy,
                              UseOriginalInfName,
                              TRUE // use non-driver signing policy unless it's a WHQL class
                             );

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, NULL);

        //
        // We have to return a policy so we'll default to warn (w/o allowing
        // use of Authenticode signatures).
        //
        Policy = DRIVERSIGN_WARNING;
    }

    UnlockInf((PLOADED_INF)InfHandle);

    return Policy;
}


VOID
pSetupGetRealSystemTime(
    OUT LPSYSTEMTIME RealSystemTime
    );

DWORD
pSetupGetCurrentDriverSigningPolicy(
    IN BOOL IsDeviceInstallation
    )

/*++

Routine Description:

    (The following description describes the strategy behind the selection of
    policy.  The implementation, however, follows a few twists and turns in
    order to thwart unscupulous individuals who would subvert digital signature 
    UI in order to avoid having to get their packages signed...)

    This routine returns a value indicating what action should be taken when a
    digital signature verification failure is encountered.  Separate "policies"
    are maintained for "DriverSigning" (i.e., device installer activities) and
    "NonDriverSigning" (i.e., everything else).
    
    ** NOTE: presently, an INF that doesn't identify itself as a device INF  **
    ** (i.e., because it doesn't include a non-NULL ClassGuid entry in its   **
    ** [Version] section) will always fall under "non-driver signing"        **
    ** policy, even though it's possible the INF may be making driver-       **
    ** related changes (e.g., copying new driver files to                    **
    ** %windir%\system32\drivers, adding services via either AddReg or       **
    ** AddService, etc.).                                                    **

    For driver signing, there are actually 3 sources of policy:

        1.  HKLM\Software\Microsoft\Driver Signing : Policy : REG_BINARY (REG_DWORD also supported)
            This is a Windows 98-compatible value that specifies the default
            behavior which applies to all users of the machine.

        2.  HKCU\Software\Microsoft\Driver Signing : Policy : REG_DWORD
            This specifies the user's preference for what behavior to employ
            upon verification failure.

        3.  HKCU\Software\Policies\Microsoft\Windows NT\Driver Signing : BehaviorOnFailedVerify : REG_DWORD
            This specifies the administrator-mandated policy on what behavior
            to employ upon verification failure.  This policy, if specified,
            overrides the user's preference.

    The algorithm for deciding on the behavior to employ is as follows:

        if (3) is specified {
            policy = (3)
        } else {
            policy = (2)
        }
        policy = MAX(policy, (1))

    For non-driver signing, the algorithm is the same, except that values (1),
    (2), and (3) come from the following registry locations:

        1.  HKLM\Software\Microsoft\Non-Driver Signing : Policy : REG_BINARY (REG_DWORD also supported)

        2.  HKCU\Software\Microsoft\Non-Driver Signing : Policy : REG_DWORD

        3.  HKCU\Software\Policies\Microsoft\Windows NT\Non-Driver Signing : BehaviorOnFailedVerify : REG_DWORD

    NOTE:  If we're in non-interactive mode, policy is always Block, so we
           don't even bother trying to retrieve any of these registry settings.
           Another reason to avoid doing so is to keep from jumping to the
           wrong conclusion that someone has tampered with policy when in
           reality, we're in a service that loaded in GUI setup prior to the
           time when the policy values were fully initialized.

Arguments:

    IsDeviceInstallation - If non-zero, then driver signing policy should be
        retrieved.  Otherwise, non-driver signing policy should be used.

Return Value:

    Value indicating the policy in effect.  May be one of the following three
    values:

        DRIVERSIGN_NONE    -  silently succeed installation of unsigned/
                              incorrectly-signed files.  A PSS log entry will
                              be generated, however (as it will for all 3 
                              types)
                              
        DRIVERSIGN_WARNING -  warn the user, but let them choose whether or not
                              they still want to install the problematic file
                              
        DRIVERSIGN_BLOCKING - do not allow the file to be installed

    (If policy can't be retrieved from any of the sources described above, the
    default is DRIVERSIGN_NONE.)

--*/

{
    SYSTEMTIME RealSystemTime;
    DWORD PolicyFromReg, PolicyFromDS, RegDataType, RegDataSize;
    HKEY hKey;
    BOOL UserPolicyRetrieved = FALSE;
    WORD w;

    if(GlobalSetupFlags & PSPGF_NONINTERACTIVE) {
        return DRIVERSIGN_BLOCKING;
    }

    w = IsDeviceInstallation?1:0;
    RealSystemTime.wDayOfWeek = (LOWORD(&hKey)&~4)|(w<<2);
    pSetupGetRealSystemTime(&RealSystemTime);
    PolicyFromReg = (((RealSystemTime.wMilliseconds+2)&15)^8)/4;
    MYASSERT(PolicyFromReg <= DRIVERSIGN_BLOCKING);

    //
    // Retrieve the user policy.  If policy isn't set for this user, then
    // retrieve the user's preference, instead.
    //
    PolicyFromDS = DRIVERSIGN_NONE;
    hKey = INVALID_HANDLE_VALUE;

    try {

        if(ERROR_SUCCESS != RegOpenKeyEx(HKEY_CURRENT_USER,
                                         (IsDeviceInstallation ? pszDrvSignPolicyPath
                                                               : pszNonDrvSignPolicyPath),
                                         0,
                                         KEY_READ,
                                         &hKey)) {
            //
            // Ensure hKey is still invalid so we won't try to free it.
            //
            hKey = INVALID_HANDLE_VALUE;

        } else {

            RegDataSize = sizeof(PolicyFromDS);
            if(ERROR_SUCCESS == RegQueryValueEx(
                                    hKey,
                                    pszDrvSignBehaviorOnFailedVerifyDS,
                                    NULL,
                                    &RegDataType,
                                    (PBYTE)&PolicyFromDS,
                                    &RegDataSize)) {

                if((RegDataType == REG_DWORD) &&
                   (RegDataSize == sizeof(DWORD)) &&
                   ((PolicyFromDS == DRIVERSIGN_NONE) || (PolicyFromDS == DRIVERSIGN_WARNING) || (PolicyFromDS == DRIVERSIGN_BLOCKING)))
                {
                    //
                    // We successfully retrieved user policy, so we won't need 
                    // to retrieve user preference.
                    //
                    UserPolicyRetrieved = TRUE;
                }
            }

            RegCloseKey(hKey);
            hKey = INVALID_HANDLE_VALUE;
        }

        //
        // If we didn't find a user policy, then retrieve the user preference.
        //
        if(!UserPolicyRetrieved) {

            if(ERROR_SUCCESS != RegOpenKeyEx(HKEY_CURRENT_USER,
                                             (IsDeviceInstallation ? pszDrvSignPath
                                                                   : pszNonDrvSignPath),
                                             0,
                                             KEY_READ,
                                             &hKey)) {
                //
                // Ensure hKey is still invalid so we won't try to free it.
                //
                hKey = INVALID_HANDLE_VALUE;

            } else {

                RegDataSize = sizeof(PolicyFromDS);
                if(ERROR_SUCCESS == RegQueryValueEx(hKey,
                                                    pszDrvSignPolicyValue,
                                                    NULL,
                                                    &RegDataType,
                                                    (PBYTE)&PolicyFromDS,
                                                    &RegDataSize))
                {
                    if((RegDataType != REG_DWORD) ||
                       (RegDataSize != sizeof(DWORD)) ||
                       !((PolicyFromDS == DRIVERSIGN_NONE) || (PolicyFromDS == DRIVERSIGN_WARNING) || (PolicyFromDS == DRIVERSIGN_BLOCKING)))
                    {
                        //
                        // Bogus entry for user preference--ignore it.
                        //
                        PolicyFromDS = DRIVERSIGN_NONE;
                    }
                }

                //
                // No need to close the registry key handle--it'll get closed
                // after we exit the try/except block.
                //
            }
        }

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, NULL);
    }

    if(hKey != INVALID_HANDLE_VALUE) {
        RegCloseKey(hKey);
    }

    //
    // Now return the more restrictive of the two policies.
    //
    if(PolicyFromDS > PolicyFromReg) {
        return PolicyFromDS;
    } else {
        return PolicyFromReg;
    }
}


DWORD
VerifySourceFile(
    IN  PSETUP_LOG_CONTEXT      LogContext,
    IN  PSP_FILE_QUEUE          Queue,                      OPTIONAL
    IN  PSP_FILE_QUEUE_NODE     QueueNode,                  OPTIONAL
    IN  PCTSTR                  Key,
    IN  PCTSTR                  FileToVerifyFullPath,
    IN  PCTSTR                  OriginalSourceFileFullPath, OPTIONAL
    IN  PSP_ALTPLATFORM_INFO_V2 AltPlatformInfo,            OPTIONAL
    IN  DWORD                   Flags,
    OUT SetupapiVerifyProblem  *Problem,
    OUT LPTSTR                  ProblemFile,
    OUT LPTSTR                  CatalogFileUsed,            OPTIONAL
    OUT LPTSTR                  DigitalSigner,              OPTIONAL
    OUT LPTSTR                  SignerVersion,              OPTIONAL
    OUT HANDLE                 *hWVTStateData               OPTIONAL
    )

/*++

Routine Description:

    This routine verifies the digital signature of the specified file either
    globally (i.e., using all catalogs), or based on the catalog file specified
    in the supplied queue node.

Arguments:

    LogContext - Supplies a context for logging the verify

    Queue - Optionally, supplies pointer to the queue structure.  This contains 
        information about the default verification method to use when the file 
        isn't associated with a particular catalog.

    QueueNode - Optionally, supplies the queue node containing catalog
        information to be used when verifying the file's signature.  If not
        supplied, then the file will be verified using all applicable installed
        catalogs.  If this pointer is supplied, then so must the Queue
        parameter.

    Key - Supplies a value that "indexes" the catalog, telling the verify APIs
        which signature datum within the catalog it should use. Typically
        the key is the name of the destination file (sans path) that the source
        file is to be copied to.

    FileToVerifyFullPath - Supplies the full path of the file to be verified.

    OriginalSourceFileFullPath - Optionally, supplies the original source 
        file's name, to be returned in the ProblemFile buffer when an error 
        occurs.  If this parameter is not specified, then the source file's 
        original name is assumed to be the same as the filename we're 
        verifying, and the path supplied in FileToVerifyFullPath will be 
        returned in the ProblemFile buffer in case of error.

    AltPlatformInfo - optionally, supplies alternate platform information used
        to fill in a DRIVER_VER_INFO structure (defined in sdk\inc\softpub.h)
        that is passed to WinVerifyTrust.

        **  NOTE:  This structure _must_ have its cbSize field set to        **
        **  sizeof(SP_ALTPLATFORM_INFO_V2) -- validation on client-supplied  **
        **  buffer is the responsibility of the caller.                      **

    Flags - supplies flags that alter that behavior of this routine.  May be a
        combination of the following values:

        VERIFY_FILE_IGNORE_SELFSIGNED - if this bit is set, then this routine
                                        will fail validation for self-signed
                                        binaries.  NOTE: when validating via
                                        Authenticode policy, we always ignore
                                        self-signed binaries.

        VERIFY_FILE_USE_OEM_CATALOGS  - if this bit is set, then all catalogs
                                        installed in the system will be scanned
                                        to verify the given file.  Otherwise,
                                        OEM (3rd party) catalogs will NOT be
                                        scanned to verify the given file.  This
                                        is only applicable if a QueueNode
                                        specifying a specific catalog is not
                                        given.  NOTE: this flag should not be
                                        specified when requesting validation
                                        via Authenticode policy.
                                        
        VERIFY_FILE_USE_AUTHENTICODE_CATALOG - Validate the file using a
                                               catalog signed with Authenticode
                                               policy.  If this flag is set,
                                               we'll _only_ check for
                                               Authenticode signatures, so if
                                               the caller wants to first try
                                               validating a file for OS code-
                                               signing usage, then falling back
                                               to Authenticode, they'll have to
                                               call this routine twice.
                                               
                                               If this flag is set, then the
                                               caller may also supply the
                                               hWVTStateData output parameter,
                                               which can be used to prompt user
                                               in order to establish that the
                                               publisher should be trusted.
                                               
                                               VerifySourceFile will return one 
                                               of two error codes upon 
                                               successful validation via 
                                               Authenticode policy.  Refer to 
                                               the "Return Value" section for 
                                               details.

        VERIFY_FILE_DRIVERBLOCKED_ONLY - Only check if the file is in the bad
                                         driver database, don't do any digital
                                         sigature validation.  NOTE: this flag
                                         should not be specified when 
                                         requesting validation via Authenticode 
                                         policy.
                                         
        VERIFY_FILE_NO_DRIVERBLOCKED_CHECK - Don't check if the file is blocked
                                             via the Bad Driver Database.
                                             NOTE: this flag has no effect when
                                             validating via Authenticode policy
                                             because we never check the bad
                                             driver database in that case.

    Problem - Points to a variable that will be filled in upon unsuccessful
        return with the cause of failure.

    ProblemFile - Supplies the address of a character buffer that will be 
        filled in upon unsuccessful return to indicate the file that failed 
        verification.  This may be the name of the file we're verifying (or 
        it's original name, if supplied), or it may be the name of the catalog 
        used for verification, if the catalog itself isn't properly signed.  
        (The type of file can be ascertained from the value returned in the 
        Problem output parameter.)

    CatalogFileUsed - if supplied, this parameter points to a character buffer
        at least MAX_PATH characters big that receives the name of the catalog
        file used to verify the specified file.  This is only filled in upon
        successful return, or when the Problem is SetupapiVerifyFileProblem
        (i.e., the catalog verified, but the file did not).  If this buffer is
        set to the empty string upon a SetupapiVerifyFileProblem failure, then
        we didn't find any applicable catalogs to use for validation.

        Also, this buffer will contain an empty string upon successful return
        if the file was validated without using a catalog (i.e., the file
        contains its own signature).

    DigitalSigner - if supplied, this parameter points to a character buffer of
        at least MAX_PATH characters that receives the name of who digitally
        signed the specified file. This value is only set if the Key is
        correctly signed (i.e. the function returns NO_ERROR).

    SignerVersion - if supplied, this parameter points to a character buffer of
        at least MAX_PATH characters that receives the the signer version as
        returned in the szwVerion field of the DRIVER_VER_INFO structure in
        our call to WinVerifyTrust.
                
    hWVTStateData - if supplied, this parameter points to a buffer that 
        receives a handle to WinVerifyTrust state data.  This handle will be
        returned only when validation was successfully performed using
        Authenticode policy.  This handle may be used, for example, to retrieve
        signer info when prompting the user about whether they trust the
        publisher.  (The status code returned will indicate whether or not this
        is necessary, see "Return Value" section below.)
        
        This parameter should only be supplied if the 
        VERIFY_FILE_USE_AUTHENTICODE_CATALOG bit is set in the supplied Flags.
        If the routine fails, then this handle will be set to NULL.
        
        It is the caller's responsibility to close this handle when they're
        finished with it by calling pSetupCloseWVTStateData().

Return Value:

    If the file was successfully validated via driver signing policy (or we
    didn't perform digital signature verification and everything else 
    succeeded), then the return value is NO_ERROR.
    
    If the file was successfully validated via Authenticode policy, and the
    publisher was in the TrustedPublisher store, then the return value is
    ERROR_AUTHENTICODE_TRUSTED_PUBLISHER.
    
    If the file was successfully validated via Authenticode policy, and the
    publisher was not in the TrustedPublisher store (hence we must prompt the
    user to establish their trust of the publisher), then the return value is
    ERROR_AUTHENTICODE_TRUST_NOT_ESTABLISHED
    
    If a failure occurred, the return value is a Win32 error code indicating
    the cause of the failure.

--*/

{
    DWORD rc;
    PCTSTR AltCatalogFile;
    LPCTSTR InfFullPath;

    MYASSERT(!QueueNode || Queue);

    //
    // Initialize the output handle for WinVerifyTrust state data.
    //
    if(hWVTStateData) {
        *hWVTStateData = NULL;
    }

    //
    // If the caller requested that we return WinVerifyTrust state data upon
    // successful Authenticode validation, then they'd better have actually
    // requested Authenticode validation!
    //
    MYASSERT(!hWVTStateData || (Flags & VERIFY_FILE_USE_AUTHENTICODE_CATALOG));

    if(GlobalSetupFlags & PSPGF_MINIMAL_EMBEDDED) {
        //
        // Nobody had better be calling this expecting to get back any info
        // about a successful verification!
        //
        MYASSERT(!CatalogFileUsed);
        MYASSERT(!DigitalSigner);
        MYASSERT(!SignerVersion);

        //
        // Likewise, we'd better not be called asking to validate using
        // Authenticode policy (and hence, to return WinVerifyTrust state data
        // regarding the signing certificate).
        //
        MYASSERT(!(Flags & VERIFY_FILE_USE_AUTHENTICODE_CATALOG));

        return NO_ERROR;
    }

    //
    // We only support a subset of flags when validating via Authenticode
    // policy.  Make sure no illegal flags are set.
    //
    MYASSERT(!(Flags & VERIFY_FILE_USE_AUTHENTICODE_CATALOG) ||
             !(Flags & (VERIFY_FILE_USE_OEM_CATALOGS | VERIFY_FILE_DRIVERBLOCKED_ONLY)));

    //
    // If we know the file's destination (i.e., we have a QueueNode), and the
    // INF is headed for %windir%\Inf, we want to catch and disallow that right
    // up front.  We don't do this for exception packages, since it's assumed
    // (whether correctly or incorrectly) that they're "part of the OS", and as
    // such, they know what they're doing.
    //
    // We also unfortunately can't do this for Authenticode-signed packages,
    // because there are some IExpress packages out there that copy the INF to
    // the INF directory, and use an Authenticode signature.  If we treat this
    // as a signature failure, then this will cause us to bail out of queue
    // committal.  Since our Authenticode logic is meant to prevent spoofing/
    // tampering (and that's not the issue in this case), we just have to keep
    // quiet about this. :-(
    //
    if(!(Flags & VERIFY_FILE_USE_AUTHENTICODE_CATALOG) &&
       (QueueNode && !(Queue->Flags & FQF_KEEP_INF_AND_CAT_ORIGINAL_NAMES))) {

        TCHAR   TargetPath[MAX_PATH];
        LPCTSTR TargetFilename, p;

        //
        // Is the target file an INF?
        //
        TargetFilename = pSetupStringTableStringFromId(Queue->StringTable,
                                                       QueueNode->TargetFilename
                                                      );

        p = _tcsrchr(TargetFilename, TEXT('.'));

        if(p && !_tcsicmp(p, pszInfSuffix)) {
            //
            // It's an INF.  Construct the full target path to see where it's
            // going.
            //
            StringCchCopy(
                TargetPath,
                SIZECHARS(TargetPath),
                pSetupStringTableStringFromId(Queue->StringTable, QueueNode->TargetDirectory)
                );

            pSetupConcatenatePaths(TargetPath,
                                   TargetFilename,
                                   SIZECHARS(TargetPath),
                                   NULL
                                  );

            if(!pSetupInfIsFromOemLocation(TargetPath, TRUE)) {
                //
                // It is invalid to copy an INF into %windir%\Inf via a file
                // queue.  Report this file as unsigned...
                //
                *Problem = SetupapiVerifyIncorrectlyCopiedInf;
                StringCchCopy(ProblemFile, MAX_PATH, FileToVerifyFullPath);

                return ERROR_INCORRECTLY_COPIED_INF;
            }
        }
    }

    //
    // Check to see if the source file is signed.
    //
    if(QueueNode && QueueNode->CatalogInfo) {
        //
        // We should never have the IQF_FROM_BAD_OEM_INF internal flag set in
        // this case.
        //
        MYASSERT(!(QueueNode->InternalFlags & IQF_FROM_BAD_OEM_INF));

        if(*(QueueNode->CatalogInfo->CatalogFilenameOnSystem)) {
            //
            // The fact that our catalog info node has a filename filled in
            // means we successfully verified this catalog previously.  Now we
            // simply need to verify the temporary (source) file against the
            // catalog.
            //

            //
            // If our catalog is an Authenticode catalog, we don't want to use
            // WinVerifyTrust to validate using driver signing policy.  That's
            // because it will return the same error we get when we have an
            // osattribute mismatch, and this will confuse this routine's
            // callers.
            //
            if(!(Flags & VERIFY_FILE_USE_AUTHENTICODE_CATALOG) &&
               (QueueNode->CatalogInfo->Flags & 
                   (CATINFO_FLAG_AUTHENTICODE_SIGNED | CATINFO_FLAG_PROMPT_FOR_TRUST))) {

                *Problem = SetupapiVerifyFileProblem;
                StringCchCopy(ProblemFile, MAX_PATH, FileToVerifyFullPath);

                return ERROR_ONLY_VALIDATE_VIA_AUTHENTICODE;

            } else {
                //
                // The caller shouldn't have requested verification using
                // Authenticode policy unless they already knew the catalog was
                // Authenticode signed.  We'll do the right thing regardless, but
                // this is a sanity check.
                //
                MYASSERT(!(Flags & VERIFY_FILE_USE_AUTHENTICODE_CATALOG) ||
                         (QueueNode->CatalogInfo->Flags & 
                              (CATINFO_FLAG_AUTHENTICODE_SIGNED | CATINFO_FLAG_PROMPT_FOR_TRUST))
                        );

                rc = _VerifyFile(LogContext,
                                 &(Queue->VerifyContext),
                                 QueueNode->CatalogInfo->CatalogFilenameOnSystem,
                                 NULL,
                                 0,
                                 Key,
                                 FileToVerifyFullPath,
                                 Problem,
                                 ProblemFile,
                                 TRUE,
                                 AltPlatformInfo,
                                 Flags,
                                 CatalogFileUsed,
                                 NULL,
                                 DigitalSigner,
                                 SignerVersion,
                                 hWVTStateData
                                );
            }

        } else {
            //
            // The INF didn't specify a Catalog= entry.  This indicates we
            // should perform global validation, except when we're doing
            // Authenticode-based verification (which must be performed in
            // the context of a specific catalog explicitly identified by the
            // INF).
            //
            if(Flags & VERIFY_FILE_USE_AUTHENTICODE_CATALOG) {

                if(QueueNode->CatalogInfo->VerificationFailureError != NO_ERROR) {
                    rc = QueueNode->CatalogInfo->VerificationFailureError;
                } else {
                    rc = ERROR_NO_AUTHENTICODE_CATALOG;
                }

                if((rc == ERROR_NO_CATALOG_FOR_OEM_INF) ||
                   (rc == ERROR_NO_AUTHENTICODE_CATALOG)) {
                    //
                    // The failure is the INF's fault (it's an OEM INF that
                    // copies files without specifying a catalog).  Blame 
                    // the INF, not the file being copied.
                    //
                    *Problem = SetupapiVerifyInfProblem;
                    MYASSERT(QueueNode->CatalogInfo->InfFullPath != -1);
                    InfFullPath = pSetupStringTableStringFromId(
                                      Queue->StringTable,
                                      QueueNode->CatalogInfo->InfFullPath
                                      );
                    MYASSERT(InfFullPath);
                    StringCchCopy(ProblemFile, MAX_PATH, InfFullPath);

                } else {
                    //
                    // We previously failed to validate the catalog file
                    // associated with this queue node.
                    //
                    *Problem = SetupapiVerifyFileNotSigned;
                    //
                    // If the caller didn't supply us with an original 
                    // source filepath (which will be taken care of later), 
                    // go ahead and copy the path of the file that was to 
                    // be verified.
                    //
                    if(!OriginalSourceFileFullPath) {
                        StringCchCopy(ProblemFile, MAX_PATH, FileToVerifyFullPath);
                    }
                }

            } else {
                //
                // If there's no error associated with this catalog info node,
                // then we simply need to do global validation.  If there is an
                // error then we still need to check if the driver is in the 
                // bad driver database.
                //
                // If the queue has an alternate default catalog file 
                // associated with it, then retrieve that catalog's name for 
                // use later.
                //
                AltCatalogFile = (Queue->AltCatalogFile != -1)
                               ? pSetupStringTableStringFromId(Queue->StringTable, Queue->AltCatalogFile)
                               : NULL;

                rc = _VerifyFile(LogContext,
                                 &(Queue->VerifyContext),
                                 AltCatalogFile,
                                 NULL,
                                 0,
                                 Key,
                                 FileToVerifyFullPath,
                                 Problem,
                                 ProblemFile,
                                 FALSE,
                                 AltPlatformInfo,
                                 Flags |
                                 ((QueueNode->CatalogInfo->VerificationFailureError == NO_ERROR)
                                   ? 0
                                   : VERIFY_FILE_DRIVERBLOCKED_ONLY),
                                 CatalogFileUsed,
                                 NULL,
                                 DigitalSigner,
                                 SignerVersion,
                                 NULL
                                );

                if((rc == NO_ERROR) &&
                   (QueueNode->CatalogInfo->VerificationFailureError != NO_ERROR)) {
                    //
                    // If there is an error associated with this catalog info 
                    // node and the file was not in the bad driver database 
                    // then return the error.
                    //
                    rc = QueueNode->CatalogInfo->VerificationFailureError;

                    if(rc == ERROR_NO_CATALOG_FOR_OEM_INF) {
                        //
                        // The failure is the INF's fault (it's an OEM INF that
                        // copies files without specifying a catalog).  Blame 
                        // the INF, not the file being copied.
                        //
                        *Problem = SetupapiVerifyInfProblem;
                        MYASSERT(QueueNode->CatalogInfo->InfFullPath != -1);
                        InfFullPath = pSetupStringTableStringFromId(
                                          Queue->StringTable,
                                          QueueNode->CatalogInfo->InfFullPath
                                          );
                        StringCchCopy(ProblemFile, MAX_PATH, InfFullPath);

                    } else {
                        //
                        // We previously failed to validate the catalog file
                        // associated with this queue node.
                        //
                        *Problem = SetupapiVerifyFileNotSigned;
                        //
                        // If the caller didn't supply us with an original 
                        // source filepath (which will be taken care of later), 
                        // go ahead and copy the path of the file that was to 
                        // be verified.
                        //
                        if(!OriginalSourceFileFullPath) {
                            StringCchCopy(ProblemFile, MAX_PATH, FileToVerifyFullPath);
                        }
                    }
                }
            }
        }

    } else {
        //
        // We have no queue, or we couldn't associate this source file back
        // to a catalog info node that tells us exactly which catalog to use
        // for verification.  Thus, we'll have to settle for global validation.
        // (Except in the Authenticode case, where global validation isn't
        // allowed.)
        //
        if(Flags & VERIFY_FILE_USE_AUTHENTICODE_CATALOG) {

            rc = ERROR_NO_AUTHENTICODE_CATALOG;

            //
            // In this case, we have to blame the file, because we don't have
            // an INF to blame.
            //
            *Problem = SetupapiVerifyFileNotSigned;
            //
            // If the caller didn't supply us with an original source filepath
            // (which will be taken care of later), go ahead and copy the path
            // of the file that was to be verified.
            //
            if(!OriginalSourceFileFullPath) {
                StringCchCopy(ProblemFile, MAX_PATH, FileToVerifyFullPath);
            }

        } else {

            BOOL InfIsBad = FALSE;
            rc = NO_ERROR;

            if(Queue) {

                if(Queue->AltCatalogFile == -1) {

                    if(QueueNode && (QueueNode->InternalFlags & IQF_FROM_BAD_OEM_INF)) {
                        InfIsBad = TRUE;
                    }

                    AltCatalogFile = NULL;

                } else {
                    //
                    // We have an alternate catalog file to use instead of global
                    // validation.
                    //
                    AltCatalogFile = pSetupStringTableStringFromId(Queue->StringTable, Queue->AltCatalogFile);
                }

            } else {
                AltCatalogFile = NULL;
            }

            rc = _VerifyFile(LogContext,
                             Queue ? &(Queue->VerifyContext) : NULL,
                             AltCatalogFile,
                             NULL,
                             0,
                             Key,
                             FileToVerifyFullPath,
                             Problem,
                             ProblemFile,
                             FALSE,
                             AltPlatformInfo,
                             Flags |
                             (InfIsBad ? VERIFY_FILE_DRIVERBLOCKED_ONLY : 0),
                             CatalogFileUsed,
                             NULL,
                             DigitalSigner,
                             SignerVersion,
                             NULL
                            );

            if(rc == NO_ERROR) {
                if(InfIsBad) {
                    //
                    // The driver file was not blocked, but the INF was bad so 
                    // set the appropriate error and problem values.
                    //
                    rc = ERROR_NO_CATALOG_FOR_OEM_INF;
                    *Problem = SetupapiVerifyFileProblem;
                    StringCchCopy(ProblemFile, MAX_PATH, FileToVerifyFullPath);
                }
            }
        }
    }

    //
    // If the problem was with the file (as opposed to with the catalog), then
    // use the real source name, if supplied, as opposed to the temporary
    // filename we passed into _VerifyFile.
    //
    if((rc != NO_ERROR) &&
       (rc != ERROR_AUTHENTICODE_TRUSTED_PUBLISHER) &&
       (rc != ERROR_AUTHENTICODE_TRUST_NOT_ESTABLISHED)) {
           
        if(OriginalSourceFileFullPath &&
           ((*Problem == SetupapiVerifyFileNotSigned) || (*Problem == SetupapiVerifyFileProblem))) {

            StringCchCopy(ProblemFile, MAX_PATH, OriginalSourceFileFullPath);
        }
    }

    return rc;
}


DWORD
VerifyDeviceInfFile(
    IN     PSETUP_LOG_CONTEXT      LogContext,
    IN OUT PVERIFY_CONTEXT         VerifyContext,          OPTIONAL
    IN     LPCTSTR                 CurrentInfName,
    IN     PLOADED_INF             pInf,
    IN     PSP_ALTPLATFORM_INFO_V2 AltPlatformInfo,        OPTIONAL
    OUT    LPTSTR                  CatalogFileUsed,        OPTIONAL
    OUT    LPTSTR                  DigitalSigner,          OPTIONAL
    OUT    LPTSTR                  SignerVersion,          OPTIONAL
    IN     DWORD                   Flags,
    OUT    HANDLE                 *hWVTStateData           OPTIONAL
    )
/*++

Routine Description:

    This routine performs a digital signature verification on the specified
    INF file.

Arguments:

    LogContext - supplies the log context to be used in logging an error if
        we encounter an error.
        
    VerifyContext - optionally, supplies the address of a structure that caches
        various verification context handles.  These handles may be NULL (if
        not previously acquired, and they may be filled in upon return (in
        either success or failure) if they were acquired during the processing
        of this verification request.  It is the caller's responsibility to
        free these various context handles when they are no longer needed by
        calling pSetupFreeVerifyContextMembers.

    CurrentInfName - supplies the full path to the INF to be validated

    pInf - supplies a pointer to the LOADED_INF structure corresponding to this
        INF.

    AltPlatformInfo - optionally, supplies alternate platform information to
        be used when validating this INF.

    CatalogFileUsed - optionally, supplies a character buffer that must be at
        least MAX_PATH characters in size.  Upon successful return, this buffer
        will be filled in with the catalog file used to validate the INF.

    DigitalSigner - optionally, supplies a character buffer that must be at
        least MAX_PATH characters in size.  Upon successful return, this buffer
        will be filled in with the name of the signer.

    SignerVersion - optionally, supplies a character buffer that must be at
        least MAX_PATH characters in size.  Upon successful return, this buffer
        will be filled in with the signer version information.
        
    Flags - supplies flags that alter the behavior of this routine.  May be a
        combination of the following values:
        
        VERIFY_INF_USE_AUTHENTICODE_CATALOG - Validate the file using a
                                              catalog signed with Authenticode
                                              policy.  If this flag is set,
                                              we'll _only_ check for
                                              Authenticode signatures, so if
                                              the caller wants to first try
                                              validating a file for OS code-
                                              signing usage, then falling back
                                              to Authenticode, they'll have to
                                              call this routine twice.
                                              
                                              If this flag is set, then the
                                              caller may also supply the
                                              hWVTStateData output parameter,
                                              which can be used to prompt user
                                              in order to establish that the
                                              publisher should be trusted.
                                              
                                              VerifyDeviceInfFile will return
                                              one of two error codes upon 
                                              successful validation via 
                                              Authenticode policy.  Refer to 
                                              the "Return Value" section for 
                                              details.
                                               
    hWVTStateData - if supplied, this parameter points to a buffer that 
        receives a handle to WinVerifyTrust state data.  This handle will be
        returned only when validation was successfully performed using
        Authenticode policy.  This handle may be used, for example, to retrieve
        signer info when prompting the user about whether they trust the
        publisher.  (The status code returned will indicate whether or not this
        is necessary, see "Return Value" section below.)
        
        This parameter should only be supplied if the 
        VERIFY_INF_USE_AUTHENTICODE_CATALOG bit is set in the supplied Flags.
        If the routine fails, then this handle will be set to NULL.
        
        It is the caller's responsibility to close this handle when they're
        finished with it by calling pSetupCloseWVTStateData().
        
Return Value:

    If the INF was successfully validated via driver signing policy, then the
    return value is NO_ERROR.
    
    If the INF was successfully validated via Authenticode policy, and the
    publisher was in the TrustedPublisher store, then the return value is
    ERROR_AUTHENTICODE_TRUSTED_PUBLISHER.
    
    If the INF was successfully validated via Authenticode policy, and the
    publisher was not in the TrustedPublisher store (hence we must prompt the
    user to establish their trust of the publisher), then the return value is
    ERROR_AUTHENTICODE_TRUST_NOT_ESTABLISHED
    
    If a failure occurred, the return value is a Win32 error code indicating
    the cause of the failure.

--*/
{
    BOOL DifferentOriginalName;
    TCHAR OriginalCatalogName[MAX_PATH];
    TCHAR CatalogPath[MAX_PATH];
    TCHAR OriginalInfFileName[MAX_PATH];
    PTSTR p;
    DWORD Err;
    PSP_ALTPLATFORM_INFO_V2 ValidationPlatform;
    DWORD VerificationPolicyToUse;

    //
    // Initialize the output handle for WinVerifyTrust state data.
    //
    if(hWVTStateData) {
        *hWVTStateData = NULL;
    }

    if(GlobalSetupFlags & PSPGF_MINIMAL_EMBEDDED) {
        //
        // Nobody had better be calling this expecting to get back any info
        // about a successful verification!
        //
        MYASSERT(!CatalogFileUsed);
        MYASSERT(!DigitalSigner);
        MYASSERT(!SignerVersion);

        //
        // Likewise, we'd better not be called asking to validate using
        // Authenticode policy (and hence, to return WinVerifyTrust state data
        // regarding the signing certificate).
        //
        MYASSERT(!(Flags & VERIFY_INF_USE_AUTHENTICODE_CATALOG));

        return NO_ERROR;
    }

    //
    // If the caller requested that we return WinVerifyTrust state data upon
    // successful Authenticode validation, then they'd better have actually
    // requested Authenticode validation!
    //
    MYASSERT(!hWVTStateData || (Flags & VERIFY_INF_USE_AUTHENTICODE_CATALOG));

    if(GlobalSetupFlags & PSPGF_AUTOFAIL_VERIFIES) {
        return TRUST_E_FAIL;
    }

    CatalogPath[0] = TEXT('\0');

    Err = pGetInfOriginalNameAndCatalogFile(pInf,
                                            NULL,
                                            &DifferentOriginalName,
                                            OriginalInfFileName,
                                            SIZECHARS(OriginalInfFileName),
                                            OriginalCatalogName,
                                            SIZECHARS(OriginalCatalogName),
                                            AltPlatformInfo
                                           );

    if(Err != NO_ERROR) {
        return Err;
    }

    if(pSetupInfIsFromOemLocation(CurrentInfName, TRUE)) {
        //
        // INF isn't in %windir%\Inf (i.e., it's 3rd-party), so it had better
        // specify a catalog file...
        //
        if(!*OriginalCatalogName) {
            return ERROR_NO_CATALOG_FOR_OEM_INF;
        }

        //
        // ...and the CAT must reside in the same directory as the INF.
        //
        if(FAILED(StringCchCopy(CatalogPath, SIZECHARS(CatalogPath), CurrentInfName))) {
            return ERROR_PATH_NOT_FOUND;
        }
        p = (PTSTR)pSetupGetFileTitle(CatalogPath);
        if(FAILED(StringCchCopy(p, SIZECHARS(CatalogPath)-(p-CatalogPath), OriginalCatalogName))) {
            return ERROR_PATH_NOT_FOUND;
        }

    } else {
        //
        // The INF lives in %windir%\Inf.
        // If it is a 3rd party INF then we want to set the CatalogPath to
        // the current INF name with .CAT at the end instead of .INF (e.g
        // oem1.cat).  If this is not an OEM catalog then we won't set the
        // CatalogPath so we can search all of the catalogs in the system.
        //
        // We will assume that if the INF had a different original name.
        //
        if(DifferentOriginalName) {
            p = (PTSTR)pSetupGetFileTitle(CurrentInfName);
            if(FAILED(StringCchCopy(CatalogPath, SIZECHARS(CatalogPath), p))) {
                return ERROR_PATH_NOT_FOUND;
            }
            p = _tcsrchr(CatalogPath, TEXT('.'));
            if(!p) {
                p = CatalogPath+lstrlen(CatalogPath);
            }
            if(FAILED(StringCchCopy(p,SIZECHARS(CatalogPath)-(p-CatalogPath),pszCatSuffix))) {
                return ERROR_PATH_NOT_FOUND;
            }
        }
    }

    if(DifferentOriginalName) {
        MYASSERT(*OriginalInfFileName);
    } else {
        //
        // INF's current name is the same as its original name, so store the
        // simple filename (sans path) for use as the validation key in the
        // upcoming call to _VerifyFile.
        //
        StringCchCopy(OriginalInfFileName, SIZECHARS(OriginalInfFileName),pSetupGetFileTitle(CurrentInfName));
    }

    //
    // If the caller didn't supply alternate platform information, we need to
    // check and see whether a range of OSATTR versions should be considered
    // valid for this INF's class.
    //
    if(!AltPlatformInfo) {

        IsInfForDeviceInstall(LogContext,
                              NULL,
                              pInf,
                              NULL,
                              &ValidationPlatform,
                              &VerificationPolicyToUse,
                              NULL,
                              FALSE
                             );
    } else {

        ValidationPlatform = NULL;

        //
        // We still need to find out what verification policy is in effect, in
        // order to determine whether we can use Authenticode policy.
        //
        IsInfForDeviceInstall(LogContext,
                              NULL,
                              pInf,
                              NULL,
                              NULL,
                              &VerificationPolicyToUse,
                              NULL,
                              FALSE
                             );
    }

    try {

        if(Flags & VERIFY_INF_USE_AUTHENTICODE_CATALOG) {

            if(!(VerificationPolicyToUse & DRIVERSIGN_ALLOW_AUTHENTICODE)) {
                //
                // Authenticode policy can't be used for this INF!
                //
                Err = ERROR_AUTHENTICODE_DISALLOWED;
                leave;
            }

            if(!*CatalogPath) {
                //
                // Authenticode-signed INFs must expicitly reference a catalog.
                //
                Err = ERROR_NO_AUTHENTICODE_CATALOG;
                leave;
            }

            Err = _VerifyFile(LogContext,
                              VerifyContext,
                              CatalogPath,
                              NULL,
                              0,
                              OriginalInfFileName,
                              CurrentInfName,
                              NULL,
                              NULL,
                              FALSE,
                              (AltPlatformInfo ? AltPlatformInfo : ValidationPlatform),
                              (VERIFY_FILE_IGNORE_SELFSIGNED
                               | VERIFY_FILE_NO_DRIVERBLOCKED_CHECK
                               | VERIFY_FILE_USE_AUTHENTICODE_CATALOG),
                              CatalogFileUsed,
                              NULL,
                              DigitalSigner,
                              SignerVersion,
                              hWVTStateData
                             );

        } else {
            //
            // Perform standard drivers signing verification.
            //
            Err = _VerifyFile(LogContext,
                              VerifyContext,
                              (*CatalogPath ? CatalogPath : NULL),
                              NULL,
                              0,
                              OriginalInfFileName,
                              CurrentInfName,
                              NULL,
                              NULL,
                              FALSE,
                              (AltPlatformInfo ? AltPlatformInfo : ValidationPlatform),
                              (VERIFY_FILE_IGNORE_SELFSIGNED
                               | VERIFY_FILE_NO_DRIVERBLOCKED_CHECK),
                              CatalogFileUsed,
                              NULL,
                              DigitalSigner,
                              SignerVersion,
                              NULL
                             );
        }

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, &Err);
    }

    if(ValidationPlatform) {
        MyFree(ValidationPlatform);
    }

    return Err;
}


BOOL
IsFileProtected(
    IN  LPCTSTR            FileFullPath,
    IN  PSETUP_LOG_CONTEXT LogContext,   OPTIONAL
    OUT PHANDLE            phSfp         OPTIONAL
    )
/*++

Routine Description:

    This routine determines whether the specified file is a protected system
    file.

Arguments:

    FileFullPath - supplies the full path to the file of interest

    LogContext - supplies the log context to be used in logging an error if
        we're unable to open an SFC handle.

    phSfp - optionally, supplies the address of a handle variable that will be
        filled in with a handle to the SFC server.  This will only be supplied
        when the routine returns TRUE (i.e., the file is SFP-protected).

Return Value:

    If the file is protected, the return value is TRUE, otherwise it is FALSE.

--*/
{
    BOOL ret;

    HANDLE hSfp;

    hSfp = SfcConnectToServer(NULL);

    if(!hSfp) {
        //
        // This ain't good...
        //
        WriteLogEntry(LogContext,
                      SETUP_LOG_ERROR,
                      MSG_LOG_SFC_CONNECT_FAILED,
                      NULL
                     );

        return FALSE;
    }

    try {
        ret = SfcIsFileProtected(hSfp, FileFullPath);
    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, NULL);
        ret = FALSE;
    }

    //
    // If the file _is_ protected, and the caller wants the SFP handle (e.g.,
    // to subsequently exempt an unsigned replacement operation), then save
    // the handle in the caller-supplied buffer.  Otherwise, close the handle.
    //
    if(ret && phSfp) {
        *phSfp = hSfp;
    } else {
        SfcClose(hSfp);
    }

    return ret;
}


PSTR
GetAnsiMuiSafePathname(
    IN PCTSTR FilePath
    )
/*++

Routine Description:

    Remove filename portion of FilePath
    and convert rest of path to be MUI parse safe
    Note that the returned pathname is such that the FileName can be cat'd
    so for "E:\i386\myfile.dl_" FilePath = "E:\i386\" and 
    FileName = "myfile.dl_"

    *This is required* (it also happens to make this code easier)

Arguments:

    FilePath - path+filename to convert

Return Value:

    If successful, the return value is pointer to ANSI filepath (memory 
    allocated by pSetupMalloc)
    
    If unsuccessful, the return value is NULL and GetLastError returns error

--*/
{
    TCHAR Buffer[MAX_PATH];
    LPTSTR FilePart;
    DWORD actsz;

    actsz = GetFullPathName(FilePath,MAX_PATH,Buffer,&FilePart);
    if(actsz == 0) {
        //
        // GetLastError has error
        //
        return NULL;
    }
    if(actsz >= MAX_PATH) {
        //
        // can't do anything with this path
        //
        SetLastError(ERROR_INVALID_DATA);
        return NULL;
    }
    if(!FilePart) {
        //
        // Since GetFullPathName couldn't find the beginning of the filename,
        // assume this means we were handed a simple filename (sans path).
        //
        *Buffer = TEXT('\0');

    } else {
        //
        // Strip the filename from the path.
        //
        *FilePart = TEXT('\0');
    }
    return GetAnsiMuiSafeFilename(Buffer);
}


PSTR
GetAnsiMuiSafeFilename(
    IN PCTSTR FilePath
    )
/*++

Routine Description:

    Convert FilePath, which is a native file path to one that is safe to parse
    by ansi API's in an MUI environment.

    returned pointer is allocated and should be free'd

Arguments:

    FilePath - path to convert (may be an empty string)

Return Value:

    If successful, the return value is pointer to ANSI filepath (memory 
    allocated by pSetupMalloc)
    
    If unsuccessful, the return value is NULL and GetLastError returns error

--*/
{
    TCHAR Buffer[MAX_PATH];
    PTSTR p;
    PSTR ansiPath;
    DWORD actsz;
    DWORD err;

    //
    // NTRAID#NTBUG9-644041-2002/04/12-lonnym -- logic fails if short pathname support is turned off
    //

    actsz = GetShortPathName(FilePath,Buffer,MAX_PATH);
    if(actsz >= MAX_PATH) {
        //
        // file path too big
        //
        SetLastError(ERROR_INVALID_DATA);
        return NULL;
    }
    if(!actsz) {
        //
        // some other error - resort back the current path name
        //
        if(FAILED(StringCchCopy(Buffer,MAX_PATH,FilePath))) {
            SetLastError(ERROR_INVALID_DATA);
            return NULL;
        }
    }
    //
    // convert to ansi now we've (if we can) converted to short path name
    //
    ansiPath = pSetupUnicodeToAnsi(Buffer);
    if(!ansiPath) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return NULL;
    }
    return ansiPath;
}


BOOL
pSetupAppendPath(
    IN  PCTSTR  Path1,   OPTIONAL   
    IN  PCTSTR  Path2,   OPTIONAL
    OUT PTSTR  *Combined
    )
/*++

Routine Description:

    Call pSetupConcatenatePaths dynamically modifying memory/pointer

Arguments:

    Path1/Path2 - Optionally, supplies paths to concatenate
    
    Combined - resultant path (must be freed via MyFree)

Return Value:

    TRUE if we successfully concatenated the paths into a newly-allocated
    buffer.
    
    FALSE otherwise.
    
Notes:

    If both Path1 and Path2 are NULL, we will return a buffer containing a
    single NULL character (i.e., an empty string).    

--*/
{
    PTSTR FinalPath;
    UINT Len;
    BOOL b;

    if(!Path1 && !Path2) {
        *Combined = MyMalloc(sizeof(TCHAR));
        if(*Combined) {
            **Combined = TEXT('\0');
            return TRUE;
        } else {
            return FALSE;
        }
    }
    if(!Path1) {
        *Combined = DuplicateString(Path2);
        return *Combined ? TRUE : FALSE;
    }
    if(!Path2) {
        *Combined = DuplicateString(Path1);
        return *Combined ? TRUE : FALSE;
    }

    Len = lstrlen(Path1)+lstrlen(Path2)+2; // slash and null

    FinalPath = MyMalloc(Len*sizeof(TCHAR));
    if(!FinalPath) {
        *Combined = NULL;
        return FALSE;
    }

    try {

        StringCchCopy(FinalPath, Len, Path1);

        b = pSetupConcatenatePaths(FinalPath, Path2, Len, NULL);

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, NULL);
        b = FALSE;
    }

    if(!b) {
        MyFree(FinalPath);
        FinalPath = NULL;
    }

    *Combined = FinalPath;

    return b;
}


BOOL
pSetupApplyExtension(
    IN  PCTSTR  Original,
    IN  PCTSTR  Extension, OPTIONAL
    OUT PTSTR*  NewName
    )
/*++

Routine Description:

    Apply Extension onto Original to obtain NewName

Arguments:

    Original - original filename (may include path) with old extension
    
    Extension - new extension to apply (with or without dot), if NULL, deletes
    
    NewName - allocated buffer containing new filename (must be freed via
        MyFree)

Return Value:

    TRUE if modified filename was successfully returned in newly-allocated
    buffer.
    
    FALSE otherwise.

--*/
{
    PCTSTR End = Original+lstrlen(Original);
    PCTSTR OldExt = End;
    PTSTR NewString = NULL;
    TCHAR c;
    UINT len;
    UINT sublen;

    if(Extension && (*Extension == TEXT('.'))) {
        Extension++;
    }

    while(End != Original) {

        End = CharPrev(Original, End);
        if((*End == TEXT('/')) || (*End == TEXT('\\'))) {
            break;
        }
        if(*End == TEXT('.')) {
            OldExt = End;
            break;
        }
    }
    sublen = (UINT)(OldExt-Original);
    len = sublen + (Extension ? lstrlen(Extension) : 0) + 2;
    NewString = MyMalloc(len*sizeof(TCHAR));
    if(!NewString) {
        *NewName = NULL;
        return FALSE;
    }

    try {

        CopyMemory(NewString, Original, sublen * sizeof(TCHAR));

        NewString[sublen++] = Extension ? TEXT('.') : TEXT('\0');

        if(Extension) {
            MYVERIFY(SUCCEEDED(StringCchCopy(NewString + sublen,
                                             len - sublen,
                                             Extension))
                    );
        }

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, NULL);
        MyFree(NewString);
        NewString = NULL;
    }

    *NewName = NewString;

    return (NewString != NULL);
}


BOOL
ClassGuidInDrvSignPolicyList(
    IN  PSETUP_LOG_CONTEXT       OptLogContext,        OPTIONAL
    IN  CONST GUID              *DeviceSetupClassGuid,
    OUT PSP_ALTPLATFORM_INFO_V2 *ValidationPlatform    OPTIONAL
    )

/*++

Routine Description:

    This routine determines whether the specified device setup class is among
    the list of classes for which driver signing policy is applicable (i.e., as
    indicated by the class's inclusion in the [DriverSigningClasses] section of
    %windir%\Inf\certclas.inf).  Additionally, if an non-native signature
    validation lower-bound is applicable, a newly-allocated alternate platform
    info structure is returned to the caller (if requested) to be used in
    subsequent validation attempts associated with this class.

Arguments:

    LogContext - Optionally, supplies the log context for any log entries that
        might be generated by this routine.

    DeviceSetupClassGuid - Supplies the address of the GUID we're attempting to
        find in our driver signing policy list.

    ValidationPlatform - Optionally, supplies the address of a (version 2)
        altplatform info pointer (initialized to NULL) that is filled in upon
        return with a newly-allocated structure specifying the appropriate
        parameters to be passed to WinVerifyTrust when validating this INF.
        These parameters are retrieved from certclas.inf for the relevant
        device setup class GUID.  If no special parameters are specified for
        this class (or if the INF has no class at all), then this pointer is
        not modified (i.e., left as NULL) causing us to use WinVerifyTrust's
        default validation.  Note that if we fail to allocate this structure
        due to low-memory, the pointer will be left as NULL in that case as
        well.  This is OK, because this simply means we'll do default
        validation in that case.

        The caller is responsible for freeing the memory allocated for this
        structure.

Return Value:

    If the device setup class is in our driver signing policy list, the return
    value is non-zero (TRUE).  Otherwise, it is FALSE.

--*/

{
    DWORD Err;
    BOOL UseDrvSignPolicy;
    INT i;
    TCHAR CertClassInfPath[MAX_PATH];
    HINF hCertClassInf = INVALID_HANDLE_VALUE;
    INFCONTEXT InfContext;
    UINT ErrorLine;
    LONG LineCount;
    PCTSTR GuidString;
    PSETUP_LOG_CONTEXT LogContext = NULL;

    //
    // Default is to lump all device installs under driver signing policy
    //
    UseDrvSignPolicy = TRUE;

    //
    // If the caller supplied the ValidationPlatform parameter it must be
    // pointing to a NULL pointer...
    //
    MYASSERT(!ValidationPlatform || !*ValidationPlatform);

    if(!LockDrvSignPolicyList(&GlobalDrvSignPolicyList)) {
        return UseDrvSignPolicy;
    }

    try {

        InheritLogContext(OptLogContext, &LogContext); // want to group logging

        if(GlobalDrvSignPolicyList.NumMembers == -1) {
            //
            // We've not yet retrieved the list from certclas.inf.  First,
            // verify the INF to make sure no one has tampered with it...
            //
            LPTSTR strp = CertClassInfPath;
            size_t strl = SIZECHARS(CertClassInfPath);

            if(FAILED(StringCchCopyEx(strp,strl,InfDirectory,&strp,&strl,0)) ||
               FAILED(StringCchCopy(strp,strl,TEXT("\\certclas.inf")))) {
                Err = ERROR_PATH_NOT_FOUND;
            } else {
                Err = _VerifyFile(LogContext,
                                  NULL,
                                  NULL,
                                  NULL,
                                  0,
                                  pSetupGetFileTitle(CertClassInfPath),
                                  CertClassInfPath,
                                  NULL,
                                  NULL,
                                  FALSE,
                                  NULL,
                                  (VERIFY_FILE_IGNORE_SELFSIGNED | VERIFY_FILE_NO_DRIVERBLOCKED_CHECK),
                                  NULL,
                                  NULL,
                                  NULL,
                                  NULL,
                                  NULL
                                 );
            }
            if(Err == NO_ERROR) {
                //
                // Open up driver signing class list INF for use when examining
                // the individual INFs in the LOADED_INF list below.
                //
                Err = GLE_FN_CALL(INVALID_HANDLE_VALUE,
                                  hCertClassInf = SetupOpenInfFile(
                                                      CertClassInfPath,
                                                      NULL,
                                                      INF_STYLE_WIN4,
                                                      &ErrorLine)
                                 );

                if(Err != NO_ERROR) {
                    //
                    // This failure is highly unlikely to occur, since we just 
                    // got through validating the INF.
                    //
                    WriteLogEntry(LogContext,
                                  SETUP_LOG_WARNING | SETUP_LOG_BUFFER,
                                  MSG_LOG_CERTCLASS_LOAD_FAILED,
                                  NULL,
                                  CertClassInfPath,
                                  ErrorLine
                                 );
                }

            } else {

                WriteLogEntry(LogContext,
                              SETUP_LOG_WARNING | SETUP_LOG_BUFFER,
                              MSG_LOG_CERTCLASS_INVALID,
                              NULL,
                              CertClassInfPath
                             );
            }

            if(Err != NO_ERROR) {
                //
                // Somebody mucked with/deleted certclas.inf!  (Or, much less
                // likely, we encountered some other failure whilst trying to
                // load the INF.)  Since we don't know which classes are
                // subject to driver signing policy, we assume they all are.
                //
                WriteLogError(LogContext,
                              SETUP_LOG_WARNING | SETUP_LOG_BUFFER,
                              Err
                             );

                WriteLogEntry(LogContext,
                              SETUP_LOG_WARNING,
                              MSG_LOG_DRIVER_SIGNING_FOR_ALL_CLASSES,
                              NULL
                             );

                //
                // Set the NumMembers field to zero, so we'll know we
                // previously attempted (and failed) to retrieve the list.  We
                // do this so we don't keep re-trying to get this list.
                //
                GlobalDrvSignPolicyList.NumMembers = 0;

                leave;
            }

            //
            // Certclas.inf validated, and we successfully opened it.  Now
            // retrieve the list contained therein.
            //
            LineCount = SetupGetLineCount(hCertClassInf,
                                          pszDriverSigningClasses
                                         );

            MYASSERT(LineCount > 0);

            if((LineCount <= 0) ||
               (NULL == (GlobalDrvSignPolicyList.Members = MyMalloc(LineCount * sizeof(DRVSIGN_CLASS_LIST_NODE))))) {

                leave;
            }

            if(!SetupFindFirstLine(hCertClassInf,
                                   pszDriverSigningClasses,
                                   NULL,
                                   &InfContext)) {
                MYASSERT(FALSE);
                leave;
            }

            i = 0;

            do {

                MYASSERT(i < LineCount);

                //
                // The format of a line in the [DriverSigningClasses]
                // section is as follows:
                //
                // {GUID} [= FirstValidatedMajorVersion, FirstValidatedMinorVersion]
                //
                GuidString = pSetupGetField(&InfContext, 0);

                if(GuidString &&
                   (NO_ERROR == pSetupGuidFromString(GuidString, &(GlobalDrvSignPolicyList.Members[i].DeviceSetupClassGuid)))) {

                    if(SetupGetIntField(&InfContext, 1, &(GlobalDrvSignPolicyList.Members[i].MajorVerLB)) &&
                       SetupGetIntField(&InfContext, 2, &(GlobalDrvSignPolicyList.Members[i].MinorVerLB))) {
                        //
                        // We successfully retrieved major/minor
                        // version info for validation lower-bound.
                        // Do a sanity-check on these.
                        //
                        if(GlobalDrvSignPolicyList.Members[i].MajorVerLB <= 0) {

                            GlobalDrvSignPolicyList.Members[i].MajorVerLB = -1;
                            GlobalDrvSignPolicyList.Members[i].MinorVerLB = -1;
                        }

                    } else {
                        //
                        // Set major/minor version info to -1 to
                        // indicate there's no validation platform
                        // override.
                        //
                        GlobalDrvSignPolicyList.Members[i].MajorVerLB = -1;
                        GlobalDrvSignPolicyList.Members[i].MinorVerLB = -1;
                    }

                    i++;
                }

            } while(SetupFindNextLine(&InfContext, &InfContext));

            //
            // Update NumMembers field in our list to indicate the
            // number of class GUID entries we actually found.
            //
            GlobalDrvSignPolicyList.NumMembers = i;
        }

        //
        // We now have a list.  If the list is empty, this means we
        // encountered some problem retrieving the list, thus all device
        // classes should be subject to driver signing policy.  Otherwise,
        // try to find the caller-specified class in our list.
        //
        if(GlobalDrvSignPolicyList.NumMembers) {
            //
            // OK, we know we have a valid list--now default to non-driver
            // signing policy unless our list search proves fruitful.
            //
            UseDrvSignPolicy = FALSE;

            for(i = 0; i < GlobalDrvSignPolicyList.NumMembers; i++) {

                if(!memcmp(DeviceSetupClassGuid,
                           &(GlobalDrvSignPolicyList.Members[i].DeviceSetupClassGuid),
                           sizeof(GUID))) {
                    //
                    // We found a match!
                    //
                    UseDrvSignPolicy = TRUE;

                    //
                    // Now, check to see if we have any validation platform
                    // override info...
                    //
                    if(ValidationPlatform &&
                       (GlobalDrvSignPolicyList.Members[i].MajorVerLB != -1)) {

                        MYASSERT(GlobalDrvSignPolicyList.Members[i].MinorVerLB != -1);

                        *ValidationPlatform = MyMalloc(sizeof(SP_ALTPLATFORM_INFO_V2));

                        //
                        // If the memory allocation fails, we just won't report
                        // the altplatform info, so the validation will be done
                        // based on the current OS version (instead of widening
                        // it up to allow a range of valid versions).
                        //
                        if(*ValidationPlatform) {
                            ZeroMemory(*ValidationPlatform, sizeof(SP_ALTPLATFORM_INFO_V2));

                            (*ValidationPlatform)->cbSize = sizeof(SP_ALTPLATFORM_INFO_V2);
                            (*ValidationPlatform)->Platform = VER_PLATFORM_WIN32_NT;
                            (*ValidationPlatform)->Flags = SP_ALTPLATFORM_FLAGS_VERSION_RANGE;
                            (*ValidationPlatform)->MajorVersion = VER_PRODUCTMAJORVERSION;
                            (*ValidationPlatform)->MinorVersion = VER_PRODUCTMINORVERSION;

                            (*ValidationPlatform)->ProcessorArchitecture =
#if defined(_X86_)
                                PROCESSOR_ARCHITECTURE_INTEL;
#elif defined(_IA64_)
                                PROCESSOR_ARCHITECTURE_IA64;
#elif defined(_AMD64_)
                                PROCESSOR_ARCHITECTURE_AMD64;
#else
#error "no target architecture"
#endif

                            (*ValidationPlatform)->FirstValidatedMajorVersion
                                = (DWORD)(GlobalDrvSignPolicyList.Members[i].MajorVerLB);

                            (*ValidationPlatform)->FirstValidatedMinorVersion
                                = (DWORD)(GlobalDrvSignPolicyList.Members[i].MinorVerLB);
                        }
                    }

                    //
                    // Since we've found a match, we can break out of the loop.
                    //
                    break;
                }
            }
        }


    } except(pSetupExceptionFilter(GetExceptionCode())) {

        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, NULL);

        //
        // If we hit an exception, don't trust information in newly-allocated
        // validation platform buffer (if any)
        //
        if(ValidationPlatform && *ValidationPlatform) {
            MyFree(*ValidationPlatform);
            *ValidationPlatform = NULL;
        }
    }

    if(hCertClassInf != INVALID_HANDLE_VALUE) {
        SetupCloseInfFile(hCertClassInf);
    }

    if(LogContext) {
        DeleteLogContext(LogContext);
    }

    UnlockDrvSignPolicyList(&GlobalDrvSignPolicyList);

    return UseDrvSignPolicy;
}


BOOL
InitDrvSignPolicyList(
    VOID
    )
/*++

Routine Description:

    This routine initializes the global "Driver Signing Policy" list that is
    retrieved (on first use) from %windir%\Inf\certclas.inf.

Arguments:

    None

Return Value:

    If success, the return value is TRUE, otherwise, it is FALSE.

--*/
{
    ZeroMemory(&GlobalDrvSignPolicyList, sizeof(DRVSIGN_POLICY_LIST));
    GlobalDrvSignPolicyList.NumMembers = -1;
    return InitializeSynchronizedAccess(&GlobalDrvSignPolicyList.Lock);
}


VOID
DestroyDrvSignPolicyList(
    VOID
    )
/*++

Routine Description:

    This routine destroys the global "Driver Signing Policy" list that is
    retrieved (on first use) from %windir%\Inf\certclas.inf.

Arguments:

    None

Return Value:

    None

--*/
{
    if(LockDrvSignPolicyList(&GlobalDrvSignPolicyList)) {
        if(GlobalDrvSignPolicyList.Members) {
            MyFree(GlobalDrvSignPolicyList.Members);
        }
        DestroySynchronizedAccess(&GlobalDrvSignPolicyList.Lock);
    }
}


VOID
pSetupFreeVerifyContextMembers(
    IN PVERIFY_CONTEXT VerifyContext
    )
/*++

Routine Description:

    This routine frees the various context handles contained in the specified
    VerifyContext structure.

Arguments:

    VerifyContext - supplies a pointer to a verification context structure
        whose non-NULL members are to be freed.

Return Value:

    None

--*/
{
    //
    // Release the crypto context (if there is one)
    //
    if(VerifyContext->hCatAdmin) {
        CryptCATAdminReleaseContext(VerifyContext->hCatAdmin, 0);
    }

    //
    // Release the handle to the bad driver database (if there is one)
    //
    if(VerifyContext->hSDBDrvMain) {
        SdbReleaseDatabase(VerifyContext->hSDBDrvMain);
    }

    //
    // Release the handle to the trusted publisher cert store (if there is
    // one)
    //
    if(VerifyContext->hStoreTrustedPublisher) {
        CertCloseStore(VerifyContext->hStoreTrustedPublisher, 0);
    }
}


BOOL
pSetupIsAuthenticodePublisherTrusted(
    IN     PCCERT_CONTEXT  CertContext,
    IN OUT HCERTSTORE     *hStoreTrustedPublisher OPTIONAL
    )
/*++

Routine Description:

    This routine checks to see whether the specified certificate is in the
    "TrustedPublisher" certificate store.
    
Arguments:
    
    CertContext - supplies the certificate context to look for in the
        TrustedPublisher certificate store.
    
    hStoreTrustedPublisher - optionally, supplies the address of a certificate
        store handle.  If the handle pointed to is NULL, a handle will be 
        acquired (if possible) via CertOpenStore and returned to the caller.  
        If the handle pointed to is non-NULL, then that handle will be used by 
        this routine.  If the pointer itself is NULL, then an HCERTSTORE will 
        be acquired for the duration of this call, and released before 
        returning.

        NOTE: it is the caller's responsibility to free the certificate store
        handle returned by this routine by calling CertCloseStore.  This handle
        may be opened in either success or failure cases, so the caller must
        check for non-NULL returned handle in both cases.    

Return Value:

    If the certificate was located in the "TrustedPublisher" certificate store,
    the return value is non-zero (i.e., TRUE).
    
    Otherwise, the return value is FALSE.

--*/
{
    BYTE rgbHash[MAX_HASH_LEN];
    CRYPT_DATA_BLOB HashBlob;
    PCCERT_CONTEXT pFoundCert = NULL;
    BOOL IsPublisherTrusted = FALSE;
    HCERTSTORE LocalhStore = NULL;

    try {

        HashBlob.pbData = rgbHash;
        HashBlob.cbData = sizeof(rgbHash);
        if(!CertGetCertificateContextProperty(CertContext,
                                              CERT_SIGNATURE_HASH_PROP_ID,
                                              rgbHash,
                                              &HashBlob.cbData)
           || (MIN_HASH_LEN > HashBlob.cbData))
        {
            leave;
        }

        //
        // Check if trusted publisher
        //
        if(hStoreTrustedPublisher && *hStoreTrustedPublisher) {
            LocalhStore = *hStoreTrustedPublisher;
        } else {

            LocalhStore = CertOpenStore(
                              CERT_STORE_PROV_SYSTEM_W,
                              0,
                              (HCRYPTPROV)NULL,
                              (CERT_SYSTEM_STORE_CURRENT_USER |
                                  CERT_STORE_MAXIMUM_ALLOWED_FLAG |
                                  CERT_STORE_SHARE_CONTEXT_FLAG),
                              (const void *) L"TrustedPublisher"
                              );

            if(!LocalhStore) {
                leave;
            }

            //
            // Try to setup for auto-resync, but it's not a critical failure if
            // we can't do this...
            //
            CertControlStore(LocalhStore,
                             0,
                             CERT_STORE_CTRL_AUTO_RESYNC,
                             NULL
                            );

            if(hStoreTrustedPublisher) {
                *hStoreTrustedPublisher = LocalhStore;
            }
        }

        pFoundCert = CertFindCertificateInStore(LocalhStore,
                                                0,
                                                0,
                                                CERT_FIND_SIGNATURE_HASH,
                                                (const void *) &HashBlob,
                                                NULL
                                               );

        if(pFoundCert) {
            IsPublisherTrusted = TRUE;
        }

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, NULL);
    }

    if(pFoundCert) {
        CertFreeCertificateContext(pFoundCert);
    }

    if(!hStoreTrustedPublisher && LocalhStore) {
        CertCloseStore(LocalhStore, 0);
    }

    return IsPublisherTrusted;
}


BOOL
IsAutoCertInstallAllowed(
    VOID
    )
/*++

Routine Description:

    This routine indicates whether a certificate should automatically be
    installed.  The criteria it uses are:
    
    1.  Must be in GUI-mode setup or mini-setup.
        
    2.  Must be on an interactive windowstation
    
    3.  Must be in LocalSystem security context.
    
    (#2 & #3) are to prevent spoofing of registry values in #1.)

Arguments:

    None.

Return Value:

    If the certificate should be auto-installed, the return value is TRUE.
    Otherwise, it is FALSE.

--*/
{
    //
    // Only auto-install certificates if we're in GUI-mode setup (or
    // mini-setup)...
    //
    if(!GuiSetupInProgress) {
        return FALSE;
    }

    //
    // ...and if we're on an interactive windowstation...
    //
    if(!IsInteractiveWindowStation()) {
        return FALSE;
    }

    //
    // ...and if we're in LocalSystem security context.
    //
    if(!pSetupIsLocalSystem()) {
        return FALSE;
    }

    return TRUE;
}


DWORD
pSetupInstallCertificate(
    IN PCCERT_CONTEXT CertContext
    )
/*++

Routine Description:

    This routine will install the specified certificate into the 
    TrustedPublisher certificate store.

Arguments:

    CertContext - supplies the context for the certificate to be installed.

Return Value:

    If the certificate was successfully installed, the return value is
    NO_ERROR.
    
    Otherwise, it is a Win32 error indicating the cause of the failure.

--*/
{
    DWORD Err;
    HCERTSTORE hCertStore;

    Err = GLE_FN_CALL(NULL,
                      hCertStore = CertOpenStore(
                                       CERT_STORE_PROV_SYSTEM_W,
                                       0,
                                       (HCRYPTPROV)NULL,
                                       (CERT_SYSTEM_STORE_LOCAL_MACHINE 
                                        | CERT_STORE_OPEN_EXISTING_FLAG),
                                       (const void *) L"TrustedPublisher")
                     );

    if(Err != NO_ERROR) {
        return Err;
    }

    try {

        Err = GLE_FN_CALL(FALSE,
                          CertAddCertificateContextToStore(hCertStore,
                                                           CertContext,
                                                           CERT_STORE_ADD_USE_EXISTING,
                                                           NULL)
                         );

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, &Err);
    }

    if(hCertStore) {
        CertCloseStore(hCertStore, 0);
    }

    return Err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\setupapi\helpids.h ===
/*++

Copyright (c) 1995-1998 Microsoft Corporation

Module Name:

    helpids.h

Abstract:

    Private header file defining help id's for dialogs.

Author:

    Jamie Hunter (jamiehun) Aug 20 1998

Revision History:

--*/

#define IDH_NOHELP  ((DWORD) -1) // Disables Help for a control (for help compiles)

//
// Main property page on the Resources tab
// Created 5/11/98 by WGruber NTUA, JamieHun NTDEV
// also see DevResHelpIDs in DevRes.c
// dialog IDD_DEF_DEVRESOURCE_PROP
//

#define IDH_DEVMGR_RESOURCES_SETTINGS   2001100
#define IDH_DEVMGR_RESOURCES_BASEDON    2001110
#define IDH_DEVMGR_RESOURCES_CHANGE     2001120
#define IDH_DEVMGR_RESOURCES_AUTO       2001130
#define IDH_DEVMGR_RESOURCES_CONFLICTS  2001140
#define IDH_DEVMGR_RESOURCES_PARENT     2001150
#define IDH_DEVMGR_RESOURCES_SETMANUALLY 2001160

//
// Edit property page invoked from Resources tab
// Created 5/11/98 by WGruber NTUA, JamieHun NTDEV
// also see EditResHelpIDs in DevRes1.c
// dialog IDD_EDIT_RESOURCE
//

#define IDH_DEVMGR_RESOURCES_EDIT_VALUE 2100100
#define IDH_DEVMGR_RESOURCES_EDIT_INFO  2100110

//
// Select device dialog box.
// dialog DLG_DEINSTALL
//
#define IDH_DEVMGR_SELECTDEVICE_MANUFACTURER	    109010
#define IDH_DEVMGR_SELECTDEVICE_MODEL		        109020
#define IDH_DEVMGR_SELECTDEVICE_SHOWCOMPATIBLE	    109030
#define IDH_DEVMGR_SELECTDEVICE_SHOWALLHARDWARE	    109040
#define IDH_DEVMGR_SELECTDEVICE_SHOWSIMILARHARDWARE	109050
#define IDH_DEVMGR_SELECTDEVICE_WINDOWSUPDATE	    109060
#define IDH_DEVMGR_SELECTDEVICE_HAVEDISK            109070


#define IDH_SECAUTH_SIGNED                  52172 // Authenticode Signed
#define IDH_SECAUTH_UNSIGNED                52174 // Not Authenticode Signed
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\setupapi\inf.h ===
/*++

Copyright (c) 1993-2000 Microsoft Corporation

Module Name:

    infload.h

Abstract:

    Private header file for internal inf routines.

Author:

    Ted Miller (tedm) 19-Jan-1995

Revision History:

    Gabe Schaffer (t-gabes) 19-Jul-1998
        Added LogContext to LOADED_INF
--*/


//
// Define maximum string sizes allowed in INFs.
//
#define MAX_STRING_LENGTH 511 // this is the maximum size of an unsubstituted string
#define MAX_SECT_NAME_LEN 255
#if MAX_SECT_NAME_LEN > MAX_STRING_LENGTH
#error MAX_SECT_NAME_LEN is too large!
#endif

#define MAX_LOGCONFKEYSTR_LEN       15

#include "pshpack1.h"

//
// Make absolutely sure that these structures are DWORD aligned
// because we turn alignment off, to make sure sdtructures are
// packed as tightly as possible into memory blocks.
//

//
// Internal representation of a section in an inf file
//
typedef struct _INF_LINE {

    //
    // Number of values on the line
    // This includes the key if Flags has INF_LINE_HASKEY
    // (In that case the first two entries in the Values array
    // contain the key--the first one in case-insensitive form used
    // for lookup, and the second in case-sensitive form for display.
    // INF lines with a single value (no key) are treated the same way.)
    // Otherwise the first entry in the Values array is the first
    // value on the line
    //
    WORD ValueCount;
    WORD Flags;

    //
    // String IDs for the values on the line.
    // The values are stored in the value block,
    // one after another.
    //
    // The value is the offset within the value block as opposed to
    // an actual pointer. We do this because the value block gets
    // reallocated as the inf file is loaded.
    //
    UINT Values;

} INF_LINE, *PINF_LINE;

//
// INF_LINE.Flags
//
#define INF_LINE_HASKEY     0x0000001
#define INF_LINE_SEARCHABLE 0x0000002

#define HASKEY(Line)       ((Line)->Flags & INF_LINE_HASKEY)
#define ISSEARCHABLE(Line) ((Line)->Flags & INF_LINE_SEARCHABLE)

//
// INF section
// This guy is kept separate and has a pointer to the actual data
// to make sorting the sections a little easier
//
typedef struct _INF_SECTION {
    //
    // String Table ID of the name of the section
    //
    LONG  SectionName;

    //
    // Number of lines in this section
    //
    DWORD LineCount;

    //
    // The section's lines. The line structures are stored packed
    // in the line block, one after another.
    //
    // The value is the offset within the line block as opposed to
    // an actual pointer. We do it this way because the line block
    // gets reallocated as the inf file is loaded.
    //
    UINT Lines;

} INF_SECTION, *PINF_SECTION;

//
// Params for section enumeration
//

typedef struct {
    PTSTR       Buffer;
    UINT        Size;
    UINT        SizeNeeded;
    PTSTR       End;
} SECTION_ENUM_PARAMS, *PSECTION_ENUM_PARAMS;


#include "poppack.h"

//
// Define structures for user-defined DIRID storage.
//
typedef struct _USERDIRID {
    UINT Id;
    TCHAR Directory[MAX_PATH];
} USERDIRID, *PUSERDIRID;

typedef struct _USERDIRID_LIST {
    PUSERDIRID UserDirIds;  // may be NULL
    UINT UserDirIdCount;
} USERDIRID_LIST, *PUSERDIRID_LIST;

typedef struct _STRINGSUBST_NODE {
    UINT ValueOffset;
    LONG TemplateStringId;
    BOOL CaseSensitive;
} STRINGSUBST_NODE, *PSTRINGSUBST_NODE;

//
// Any system DIRID (i.e., >0x8000) that has bit 0x4000 set is a 'volatile'
// DIRID (these DIRIDs are volatile in the sense that, while they're not in the
// user-definable range, they're treated as if they were, and string replacement
// is done on-the-fly each time the PNF is loaded.  The shell special folders
// (CSIDL_* defines in sdk\inc\shlobj.h), for example, are in this range.  In
// the case of shell special folders, the actual CSIDL value (i.e., as is
// passed into SHGetSpecialFolderPath) can be obtained by simply masking out
// the volatile DIRID bit.
//
// Define the bitmask used to determine whether a system DIRID is volatile.
//
#define VOLATILE_DIRID_FLAG 0x4000

//
// Version block structure that is stored (packed) in the opaque
// VersionData buffer of a caller-supplied SP_INF_INFORMATION structure.
//
typedef struct _INF_VERSION_BLOCK {
    UINT NextOffset;
    FILETIME LastWriteTime;
    WORD DatumCount;
    WORD OffsetToData; // offset (in bytes) from beginning of Filename buffer.
    UINT DataSize;     // DataSize and TotalSize are both byte counts.
    UINT TotalSize;
    TCHAR Filename[ANYSIZE_ARRAY];
    //
    // Data follows Filename in the buffer
    //
} INF_VERSION_BLOCK, *PINF_VERSION_BLOCK;

//
// Internal version block node.
//
typedef struct _INF_VERSION_NODE {
    FILETIME LastWriteTime;
    UINT FilenameSize;
    CONST TCHAR *DataBlock;
    UINT DataSize;
    WORD DatumCount;
    TCHAR Filename[MAX_PATH];
} INF_VERSION_NODE, *PINF_VERSION_NODE;

//
// Internal representation of an inf file.
//
typedef struct _LOADED_INF {
    DWORD Signature;

    //
    // The following 3 fields are used for precompiled INFs (PNF).
    // If FileHandle is not INVALID_HANDLE_VALUE, then this is a PNF,
    // and the MappingHandle and ViewAddress fields are also valid.
    // Otherwise, this is a plain old in-memory INF.
    //
    HANDLE FileHandle;
    HANDLE MappingHandle;
    PVOID  ViewAddress;

    PVOID StringTable;
    DWORD SectionCount;
    PINF_SECTION SectionBlock;
    PINF_LINE LineBlock;
    PLONG ValueBlock;
    INF_VERSION_NODE VersionBlock;
    BOOL HasStrings;

    //
    // If this INF contains any DIRID references to the system partition, then
    // store the OsLoader path that was used when compiling this INF here.  (This
    // value will always be correct when the INF is loaded.  However, if drive letters
    // are subsequently reassigned, then it will be incorrect until the INF is unloaded
    // and re-loaded.)
    //
    PCTSTR OsLoaderPath;    // may be NULL

    //
    // Remember the location where this INF originally came from (may be a directory
    // path or a URL).
    //
    DWORD  InfSourceMediaType;  // SPOST_PATH or SPOST_URL
    PCTSTR InfSourcePath;       // may be NULL

    //
    // Remember the INF's original filename, before it was installed into
    // %windir%\Inf (i.e., automatically via device installation or explicitly
    // via SetupCopyOEMInf).
    //
    PCTSTR OriginalInfName;     // may be NULL

    //
    // Maintain a list of value offsets that require string substitution at
    // run-time.
    //
    PSTRINGSUBST_NODE SubstValueList;   // may be NULL
    WORD SubstValueCount;

    //
    // Place the style WORD here (immediately following another WORD field),
    // to fill a single DWORD.
    //
    WORD Style;                         // INF_STYLE_OLDNT, INF_STYLE_WIN4

    //
    // Sizes in bytes of various buffers
    //
    UINT SectionBlockSizeBytes;
    UINT LineBlockSizeBytes;
    UINT ValueBlockSizeBytes;

    //
    // Track what language was used when loading this INF.
    //
    DWORD LanguageId;

    //
    // Embedded structure containing information about the current user-defined
    // DIRID values.
    //
    USERDIRID_LIST UserDirIdList;

    //
    // Synchronization.
    //
    MYLOCK Lock;

    //
    // Log context for error logging
    //
    PSETUP_LOG_CONTEXT LogContext;

    //
    // Other flags
    //
    DWORD Flags;

    //
    // INFs are append-loaded via a doubly-linked list of LOADED_INFs.
    // (list is not circular--Prev of head is NULL, Next of tail is NULL)
    //
    struct _LOADED_INF *Prev;
    struct _LOADED_INF *Next;

} LOADED_INF, *PLOADED_INF;

#define LOADED_INF_SIG   0x24666e49      // Inf$

#define LockInf(Inf)    BeginSynchronizedAccess(&(Inf)->Lock)
#define UnlockInf(Inf)  EndSynchronizedAccess(&(Inf)->Lock)

//
// Define values for LOADED_INF.Flags field
//
//
// WARNING: The LIF_INF_DIGITALLY_SIGNED flag does not guarantee that the INF
// is currently digitally signed. When creating the PNF we verify that the INF
// is correctly digitally signed and then set this bit in the PNF. Currently we
// only use this flag to determine whether we should use the DriverVer date
// or not.
//
#define LIF_HAS_VOLATILE_DIRIDS     (0x00000001)
#define LIF_INF_DIGITALLY_SIGNED    (0x00000002)
#define LIF_OEM_F6_INF              (0x00000004)
#define LIF_INF_AUTHENTICODE_SIGNED (0x00000008)


//
// Helper define
//
#define INF_STYLE_ALL   (INF_STYLE_WIN4 | INF_STYLE_OLDNT)


//
// Define file header structure for precompiled INF (.PNF).
//
typedef struct _PNF_HEADER {

    WORD  Version;  // HiByte - Major Ver#, LoByte - Minor Ver#
    WORD  InfStyle;
    DWORD Flags;

    DWORD    InfSubstValueListOffset;
    WORD     InfSubstValueCount;

    WORD     InfVersionDatumCount;
    DWORD    InfVersionDataSize;
    DWORD    InfVersionDataOffset;
    FILETIME InfVersionLastWriteTime;

    DWORD StringTableBlockOffset;
    DWORD StringTableBlockSize;

    DWORD InfSectionCount;
    DWORD InfSectionBlockOffset;
    DWORD InfSectionBlockSize;
    DWORD InfLineBlockOffset;
    DWORD InfLineBlockSize;
    DWORD InfValueBlockOffset;
    DWORD InfValueBlockSize;

    DWORD WinDirPathOffset;
    DWORD OsLoaderPathOffset;

    WORD StringTableHashBucketCount;

    WORD LanguageId;

    DWORD InfSourcePathOffset;      // may be 0

    DWORD OriginalInfNameOffset;    // may be 0

} PNF_HEADER, *PPNF_HEADER;

//
// Define Major and Minor versions of the PNF format (currently 1.1)
//
#define PNF_MAJOR_VERSION (0x01)
#define PNF_MINOR_VERSION (0x01)

//
// Define flag values for the PNF header's Flags field.
//
// WARNING: The PNF_FLAG_INF_DIGITALLY_SIGNED flag does not guarantee that the INF
// is currently digitally signed. When creating the PNF we verify that the INF
// is correctly digitally signed and then set this bit in the PNF. Currently we
// only use this flag to determine whether we should use the DriverVer date
// or not.

#define PNF_FLAG_IS_UNICODE                 (0x00000001)
#define PNF_FLAG_HAS_STRINGS                (0x00000002)
#define PNF_FLAG_SRCPATH_IS_URL             (0x00000004)
#define PNF_FLAG_HAS_VOLATILE_DIRIDS        (0x00000008)
#define PNF_FLAG_RESERVED1                  (0x00000010) // was PNF_FLAG_INF_VERIFIED for Win2k
#define PNF_FLAG_INF_DIGITALLY_SIGNED       (0x00000020)
#define PNF_FLAG_OEM_F6_INF                 (0x00000040)
#define PNF_FLAG_16BIT_SUITE                (0x00000080) // if set, lower 16 bits of suite
                                                         // is in upper 16 bits of flags
#define PNF_FLAG_INF_VERIFIED               (0x00000100)
#define PNF_FLAG_INF_AUTHENTICODE_SIGNED    (0x00000200)



//
// Public inf functions in infload.c. All other routines are private to
// the inf handler package.
//
DWORD
DetermineInfStyle(
    IN PCTSTR            Filename,
    IN LPWIN32_FIND_DATA FindData
    );

//
// Flags for LoadInfFile.
//
#define LDINF_FLAG_MATCH_CLASS_GUID        (0x00000001)
#define LDINF_FLAG_ALWAYS_TRY_PNF          (0x00000002)
#define LDINF_FLAG_IGNORE_VOLATILE_DIRIDS  (0x00000004) // includes system partition
#define LDINF_FLAG_IGNORE_LANGUAGE         (0x00000008)
#define LDINF_FLAG_REGENERATE_PNF          (0x00000010)
#define LDINF_FLAG_SRCPATH_IS_URL          (0x00000020)
#define LDINF_FLAG_ALWAYS_GET_SRCPATH      (0x00000040) // used to work around TZ change in FAT
#define LDINF_FLAG_OEM_F6_INF              (0x00000080)
#define LDINF_FLAG_ALLOW_PNF_SHARING_LOCK  (0x00000100) // don't fail if PNF locked
#define LDINF_FLAG_ALWAYS_IGNORE_PNF       (0x00000200) // don't look at PNF

DWORD
LoadInfFile(
    IN  PCTSTR            Filename,
    IN  LPWIN32_FIND_DATA FileData,
    IN  DWORD             Style,
    IN  DWORD             Flags,
    IN  PCTSTR            ClassGuidString, OPTIONAL
    IN  PCTSTR            InfSourcePath,   OPTIONAL
    IN  PCTSTR            OriginalInfName, OPTIONAL
    IN  PLOADED_INF       AppendInf,       OPTIONAL
    IN  PSETUP_LOG_CONTEXT LogContext,     OPTIONAL
    OUT PLOADED_INF      *LoadedInf,
    OUT UINT             *ErrorLineNumber,
    OUT BOOL             *PnfWasUsed       OPTIONAL
    );

VOID
FreeInfFile(
    IN PLOADED_INF LoadedInf
    );


//
// Global strings used throughout the inf loaders/runtime stuff.  Sizes are
// included so that we can do sizeof() instead of lstrlen() to determine string
// length.
//
// The content of the following strings is defined in infstr.h:
//
extern CONST TCHAR pszSignature[SIZECHARS(INFSTR_KEY_SIGNATURE)],
                   pszVersion[SIZECHARS(INFSTR_SECT_VERSION)],
                   pszClass[SIZECHARS(INFSTR_KEY_HARDWARE_CLASS)],
                   pszClassGuid[SIZECHARS(INFSTR_KEY_HARDWARE_CLASSGUID)],
                   pszProvider[SIZECHARS(INFSTR_KEY_PROVIDER)],
                   pszStrings[SIZECHARS(SZ_KEY_STRINGS)],
                   pszLayoutFile[SIZECHARS(SZ_KEY_LAYOUT_FILE)],
                   pszManufacturer[SIZECHARS(INFSTR_SECT_MFG)],
                   pszControlFlags[SIZECHARS(INFSTR_CONTROLFLAGS_SECTION)],
                   pszSourceDisksNames[SIZECHARS(SZ_KEY_SRCDISKNAMES)],
                   pszSourceDisksFiles[SIZECHARS(SZ_KEY_SRCDISKFILES)],
                   pszDestinationDirs[SIZECHARS(SZ_KEY_DESTDIRS)],
                   pszDefaultDestDir[SIZECHARS(SZ_KEY_DEFDESTDIR)],
                   pszReboot[SIZECHARS(INFSTR_REBOOT)],
                   pszRestart[SIZECHARS(INFSTR_RESTART)],
                   pszClassInstall32[SIZECHARS(INFSTR_SECT_CLASS_INSTALL_32)],
                   pszAddInterface[SIZECHARS(SZ_KEY_ADDINTERFACE)],
                   pszInterfaceInstall32[SIZECHARS(INFSTR_SECT_INTERFACE_INSTALL_32)],
                   pszAddService[SIZECHARS(SZ_KEY_ADDSERVICE)],
                   pszDelService[SIZECHARS(SZ_KEY_DELSERVICE)],
                   pszCatalogFile[SIZECHARS(INFSTR_KEY_CATALOGFILE)],
                   pszMemConfig[SIZECHARS(INFSTR_KEY_MEMCONFIG)],
                   pszIOConfig[SIZECHARS(INFSTR_KEY_IOCONFIG)],
                   pszIRQConfig[SIZECHARS(INFSTR_KEY_IRQCONFIG)],
                   pszDMAConfig[SIZECHARS(INFSTR_KEY_DMACONFIG)],
                   pszPcCardConfig[SIZECHARS(INFSTR_KEY_PCCARDCONFIG)],
                   pszMfCardConfig[SIZECHARS(INFSTR_KEY_MFCARDCONFIG)],
                   pszConfigPriority[SIZECHARS(INFSTR_KEY_CONFIGPRIORITY)],
                   pszDriverVer[SIZECHARS(INFSTR_DRIVERVERSION_SECTION)];

//
// Other misc. global strings:
//
#define DISTR_INF_DRVDESCFMT               (TEXT("%s.") INFSTR_STRKEY_DRVDESC)
#define DISTR_INF_HWSECTIONFMT             (TEXT("%s.") INFSTR_SUBKEY_HW)
#define DISTR_INF_CHICAGOSIG               (TEXT("$Chicago$"))
#define DISTR_INF_WINNTSIG                 (TEXT("$Windows NT$"))
#define DISTR_INF_WIN95SIG                 (TEXT("$Windows 95$"))
#define DISTR_INF_WIN_SUFFIX               (TEXT(".") INFSTR_PLATFORM_WIN)
#define DISTR_INF_NT_SUFFIX                (TEXT(".") INFSTR_PLATFORM_NT)
#define DISTR_INF_PNF_SUFFIX               (TEXT(".PNF"))
#define DISTR_INF_INF_SUFFIX               (TEXT(".INF"))
#define DISTR_INF_CAT_SUFFIX               (TEXT(".CAT"))
#define DISTR_INF_SERVICES_SUFFIX          (TEXT(".") INFSTR_SUBKEY_SERVICES)
#define DISTR_INF_INTERFACES_SUFFIX        (TEXT(".") INFSTR_SUBKEY_INTERFACES)
#define DISTR_INF_COINSTALLERS_SUFFIX      (TEXT(".") INFSTR_SUBKEY_COINSTALLERS)
#define DISTR_INF_LOGCONFIGOVERRIDE_SUFFIX (TEXT(".") INFSTR_SUBKEY_LOGCONFIGOVERRIDE)
#define DISTR_INF_WMI_SUFFIX               (TEXT(".") INFSTR_SUBKEY_WMI)
//
// Define all platform-specific suffix strings for which we support non-native
// digital signature verification...
//
#define DISTR_INF_NTALPHA_SUFFIX           (TEXT(".") INFSTR_PLATFORM_NTALPHA)
#define DISTR_INF_NTX86_SUFFIX             (TEXT(".") INFSTR_PLATFORM_NTX86)
#define DISTR_INF_NTIA64_SUFFIX            (TEXT(".") INFSTR_PLATFORM_NTIA64)
#define DISTR_INF_NTAXP64_SUFFIX           (TEXT(".") INFSTR_PLATFORM_NTAXP64)
#define DISTR_INF_NTAMD64_SUFFIX           (TEXT(".") INFSTR_PLATFORM_NTAMD64)
//
// Define platform decoration strings for use on [SourceDisksNames] and
// [SourceDisksFiles] sections.
//
#define DISTR_INF_SRCDISK_SUFFIX_ALPHA  (TEXT("Alpha"))
#define DISTR_INF_SRCDISK_SUFFIX_X86    (TEXT("x86"))
#define DISTR_INF_SRCDISK_SUFFIX_IA64   (TEXT("ia64"))
#define DISTR_INF_SRCDISK_SUFFIX_AXP64  (TEXT("axp64"))
#define DISTR_INF_SRCDISK_SUFFIX_AMD64  (TEXT("amd64"))

//
// (Sizes are included for all strings that we define privately.  This
// is done so that we can do sizeof() instead of lstrlen() to determine
// string length.  Keep in sync with definitions in infload.c!)
//
extern CONST TCHAR pszDrvDescFormat[SIZECHARS(DISTR_INF_DRVDESCFMT)],
                   pszHwSectionFormat[SIZECHARS(DISTR_INF_HWSECTIONFMT)],
                   pszChicagoSig[SIZECHARS(DISTR_INF_CHICAGOSIG)],
                   pszWindowsNTSig[SIZECHARS(DISTR_INF_WINNTSIG)],
                   pszWindows95Sig[SIZECHARS(DISTR_INF_WIN95SIG)],
                   pszWinSuffix[SIZECHARS(DISTR_INF_WIN_SUFFIX)],
                   pszNtSuffix[SIZECHARS(DISTR_INF_NT_SUFFIX)],
                   pszNtAlphaSuffix[SIZECHARS(DISTR_INF_NTALPHA_SUFFIX)],
                   pszNtX86Suffix[SIZECHARS(DISTR_INF_NTX86_SUFFIX)],
                   pszNtIA64Suffix[SIZECHARS(DISTR_INF_NTIA64_SUFFIX)],
                   pszNtAXP64Suffix[SIZECHARS(DISTR_INF_NTAXP64_SUFFIX)],
                   pszNtAMD64Suffix[SIZECHARS(DISTR_INF_NTAMD64_SUFFIX)],
                   pszPnfSuffix[SIZECHARS(DISTR_INF_PNF_SUFFIX)],
                   pszInfSuffix[SIZECHARS(DISTR_INF_INF_SUFFIX)],
                   pszCatSuffix[SIZECHARS(DISTR_INF_CAT_SUFFIX)],
                   pszServicesSectionSuffix[SIZECHARS(DISTR_INF_SERVICES_SUFFIX)],
                   pszInterfacesSectionSuffix[SIZECHARS(DISTR_INF_INTERFACES_SUFFIX)],
                   pszCoInstallersSectionSuffix[SIZECHARS(DISTR_INF_COINSTALLERS_SUFFIX)],
                   pszLogConfigOverrideSectionSuffix[SIZECHARS(DISTR_INF_LOGCONFIGOVERRIDE_SUFFIX)],
                   pszWmiSectionSuffix[SIZECHARS(DISTR_INF_WMI_SUFFIX)],
                   pszAlphaSrcDiskSuffix[SIZECHARS(DISTR_INF_SRCDISK_SUFFIX_ALPHA)],
                   pszX86SrcDiskSuffix[SIZECHARS(DISTR_INF_SRCDISK_SUFFIX_X86)],
                   pszIa64SrcDiskSuffix[SIZECHARS(DISTR_INF_SRCDISK_SUFFIX_IA64)],
                   pszAxp64SrcDiskSuffix[SIZECHARS(DISTR_INF_SRCDISK_SUFFIX_AXP64)],
                   pszAmd64SrcDiskSuffix[SIZECHARS(DISTR_INF_SRCDISK_SUFFIX_AMD64)];

//
// Define constants that equate to native architecture suffixes...
//
#if defined(_ALPHA_)
#define pszNtPlatformSuffix       pszNtAlphaSuffix
#define pszPlatformSrcDiskSuffix  pszAlphaSrcDiskSuffix
#elif defined(_X86_)
#define pszNtPlatformSuffix       pszNtX86Suffix
#define pszPlatformSrcDiskSuffix  pszX86SrcDiskSuffix
#elif defined(_IA64_)
#define pszNtPlatformSuffix       pszNtIA64Suffix
#define pszPlatformSrcDiskSuffix  pszIa64SrcDiskSuffix
#elif defined(_AXP64_)
#define pszNtPlatformSuffix       pszNtAXP64Suffix
#define pszPlatformSrcDiskSuffix  pszAxp64SrcDiskSuffix
#elif defined(_AMD64_)
#define pszNtPlatformSuffix       pszNtAMD64Suffix
#define pszPlatformSrcDiskSuffix  pszAmd64SrcDiskSuffix
#else
#error Unknown processor type
#endif
//
// for now, platform name is same as pszPlatformSrcDiskSuffix (Alpha, x86, ia64, axp64, amd64)
//
#define pszPlatformName pszPlatformSrcDiskSuffix

//
// Define a (non-CONST) array of strings that specifies what lines to look for
// in an INF's [ControlFlags] section when determining whether a particular device
// ID should be excluded.  This is filled in during process attach for speed
// reasons.
//
// The max string length (including NULL) is 32, and there can be a maximum of 3
// such strings.  E.g.: ExcludeFromSelect, ExcludeFromSelect.NT, ExcludeFromSelect.NTAlpha
//
extern TCHAR pszExcludeFromSelectList[3][32];
extern DWORD ExcludeFromSelectListUb;  // contains the number of strings in the above list (2 or 3).


//
// Routine to determine whether a character is whitespace.
//
BOOL
IsWhitespace(
    IN PCTSTR pc
    );

//
// Routine to skip whitespace (but not newlines)
//
VOID
SkipWhitespace(
    IN OUT PCTSTR *Location,
    IN     PCTSTR  BufferEnd
    );

PINF_SECTION
InfLocateSection(
    IN  PLOADED_INF Inf,
    IN  PCTSTR      SectionName,
    OUT PUINT       SectionNumber   OPTIONAL
    );

BOOL
InfLocateLine(
    IN     PLOADED_INF   Inf,
    IN     PINF_SECTION  Section,
    IN     PCTSTR        Key,        OPTIONAL
    IN OUT PUINT         LineNumber,
    OUT    PINF_LINE    *Line
    );

PTSTR
InfGetKeyOrValue(
    IN  PLOADED_INF Inf,
    IN  PCTSTR      SectionName,
    IN  PCTSTR      LineKey,     OPTIONAL
    IN  UINT        LineNumber,  OPTIONAL
    IN  UINT        ValueNumber,
    OUT PLONG       StringId     OPTIONAL
    );

PTSTR
InfGetField(
    IN  PLOADED_INF Inf,
    IN  PINF_LINE   InfLine,
    IN  UINT        ValueNumber,
    OUT PLONG       StringId     OPTIONAL
    );

PINF_LINE
InfLineFromContext(
    IN PINFCONTEXT Context
    );


//
// Define a macro to retrieve the case-insensitive (i.e., searchable) string ID
// for an INF line's key, or -1 if there is no key.
// NOTE: INF lock must have been acquired before calling this macro!
//
// LONG
// pInfGetLineKeyId(
//     IN  PLOADED_INF Inf,
//     IN  PINF_LINE   InfLine
//     )
//
#define pInfGetLineKeyId(Inf,InfLine)  (ISSEARCHABLE(InfLine) ? (Inf)->ValueBlock[(InfLine)->Values] : -1)

//
// Routine to allocate and initialize a loaded inf descriptor.
//
PLOADED_INF
AllocateLoadedInfDescriptor(
    IN DWORD SectionBlockSize,
    IN DWORD LineBlockSize,
    IN DWORD ValueBlockSize,
    IN  PSETUP_LOG_CONTEXT LogContext OPTIONAL
    );

VOID
FreeInfOrPnfStructures(
    IN PLOADED_INF Inf
    );

//
// Define a macro to free all memory blocks associated with a loaded INF or PNF,
// and then free the memory for the loaded INF structure itself
//
// VOID
// FreeLoadedInfDescriptor(
//     IN PLOADED_INF Inf
//     );
//
#define FreeLoadedInfDescriptor(Inf) {  \
    FreeInfOrPnfStructures(Inf);        \
    MyTaggedFree(Inf,MEMTAG_INF);       \
}

BOOL
AddDatumToVersionBlock(
    IN OUT PINF_VERSION_NODE VersionNode,
    IN     PCTSTR            DatumName,
    IN     PCTSTR            DatumValue
    );

//
// Old inf manipulation routines, called by new inf loader
//
DWORD
ParseOldInf(
    IN  PCTSTR       FileImage,
    IN  DWORD        FileImageSize,
    IN  PSETUP_LOG_CONTEXT LogContext, OPTIONAL
    OUT PLOADED_INF *Inf,
    OUT UINT        *ErrorLineNumber
    );

DWORD
ProcessOldInfVersionBlock(
    IN PLOADED_INF Inf
    );

//
// Run-time helper routines.
//
PCTSTR
pSetupFilenameFromLine(
    IN PINFCONTEXT Context,
    IN BOOL        GetSourceName
    );


//
// Logical configuration stuff, inflogcf.c
//
DWORD
pSetupInstallLogConfig(
    IN HINF    Inf,
    IN PCTSTR  SectionName,
    IN DEVINST DevInst,
    IN DWORD   Flags,
    IN HMACHINE hMachine
    );

//
// INF Version information retrieval
//
PCTSTR
pSetupGetVersionDatum(
    IN PINF_VERSION_NODE VersionNode,
    IN PCTSTR            DatumName
    );

BOOL
pSetupGetCatalogFileValue(
    IN  PINF_VERSION_NODE       InfVersionNode,
    OUT LPTSTR                  Buffer,
    IN  DWORD                   BufferSize,
    IN  PSP_ALTPLATFORM_INFO_V2 AltPlatformInfo OPTIONAL
    );

VOID
pSetupGetPhysicalInfFilepath(
    IN  PINFCONTEXT LineContext,
    OUT LPTSTR      Buffer,
    IN  DWORD       BufferSize
    );

//
// Private installation routines.
//

//
// Private Flags & context for _SetupInstallFromInfSection.
// passed onto pSetupInstallRegistry
//

typedef struct _REGMOD_CONTEXT {
    DWORD               Flags;          // indicates what fields are filled in
    HKEY                UserRootKey;    // HKR
    LPGUID              ClassGuid;      // INF_PFLAG_CLASSPROP
    HMACHINE            hMachine;       // INF_PFLAG_CLASSPROP
    DWORD               DevInst;        // INF_PFLAG_DEVPROP
} REGMOD_CONTEXT, *PREGMOD_CONTEXT;

#define INF_PFLAG_CLASSPROP        (0x00000001)  // set if called for a ClassInstall32 section
#define INF_PFLAG_DEVPROP          (0x00000002)  // set if called for registry properties
#define INF_PFLAG_HKR              (0x00000004)  // indicates override _SetupInstallFromInfSection RelativeKeyRoot

BOOL
_SetupInstallFromInfSection(
    IN HWND             Owner,              OPTIONAL
    IN HINF             InfHandle,
    IN PCTSTR           SectionName,
    IN UINT             Flags,
    IN HKEY             RelativeKeyRoot,    OPTIONAL
    IN PCTSTR           SourceRootPath,     OPTIONAL
    IN UINT             CopyFlags,
    IN PVOID            MsgHandler,
    IN PVOID            Context,            OPTIONAL
    IN HDEVINFO         DeviceInfoSet,      OPTIONAL
    IN PSP_DEVINFO_DATA DeviceInfoData,     OPTIONAL
    IN BOOL             IsMsgHandlerNativeCharWidth,
    IN PREGMOD_CONTEXT  RegContext          OPTIONAL
    );

DWORD
pSetupInstallFiles(
    IN HINF              Inf,
    IN HINF              LayoutInf,         OPTIONAL
    IN PCTSTR            SectionName,
    IN PCTSTR            SourceRootPath,    OPTIONAL
    IN PSP_FILE_CALLBACK MsgHandler,        OPTIONAL
    IN PVOID             Context,           OPTIONAL
    IN UINT              CopyStyle,
    IN HWND              Owner,             OPTIONAL
    IN HSPFILEQ          UserFileQ,         OPTIONAL
    IN BOOL              IsMsgHandlerNativeCharWidth
    );

DWORD
pSetupInstallRegistry(
    IN HINF             Inf,
    IN PCTSTR           SectionName,
    IN PREGMOD_CONTEXT  RegContext          OPTIONAL
    );

DWORD
_AppendStringToMultiSz(
    IN PCTSTR           SubKeyName,         OPTIONAL
    IN PCTSTR           ValueName,          OPTIONAL
    IN PCTSTR           String,
    IN BOOL             AllowDuplicates,
    IN PREGMOD_CONTEXT  RegContext,         OPTIONAL
    IN UINT             Flags               OPTIONAL
    );

DWORD
_DeleteStringFromMultiSz(
    IN PCTSTR           SubKeyName,         OPTIONAL
    IN PCTSTR           ValueName,          OPTIONAL
    IN PCTSTR           String,
    IN UINT             Flags,
    IN PREGMOD_CONTEXT  RegContext          OPTIONAL
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\setupapi\infcache.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    infcache.c

Abstract:

    INF Cache management functions

Author:

    Jamie Hunter (jamiehun) Jan-27-2000

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#define BOUNDSCHECK(base,size,limit) ( \
                ((base)<=(limit)) && \
                ((size)<=(limit)) && \
                ((base+size)<=(limit)) && \
                ((base+size)>=(base)))

//
// Macros used to quadword-align Cache blocks.
//
#define CACHE_ALIGNMENT      ((DWORD)8)
#define CACHE_ALIGN_MASK     (~(DWORD)(CACHE_ALIGNMENT - 1))
#define CACHE_ALIGN_BLOCK(x) ((x & CACHE_ALIGN_MASK) + ((x & ~CACHE_ALIGN_MASK) ? CACHE_ALIGNMENT : 0))

BOOL
AlignForNextBlock(
    IN HANDLE hFile,
    IN DWORD  ByteCount
    );



#ifdef UNICODE

VOID InfCacheFreeCache(
    IN PINFCACHE pInfCache
    )
/*++

Routine Description:

    Delete/Release in-memory image of INF CACHE

Arguments:

    pInfCache - pointer to Run-Time data

Return Value:

    none

--*/
{
    if (pInfCache == NULL) {
        //
        // no cache
        //
        return;
    }
    if(pInfCache->bReadOnly && pInfCache->BaseAddress) {
        //
        // we're looking at memory mapped cache
        //
        pStringTableDestroy(pInfCache->pMatchTable);
        pStringTableDestroy(pInfCache->pInfTable);
        pSetupUnmapAndCloseFile(pInfCache->FileHandle, pInfCache->MappingHandle, pInfCache->BaseAddress);

    } else {
        //
        // if cache is writable, this data is transient
        //
        if(pInfCache->pHeader) {
            MyFree(pInfCache->pHeader);
        }
        if(pInfCache->pMatchTable) {
            pStringTableDestroy(pInfCache->pMatchTable);
        }
        if(pInfCache->pInfTable) {
            pStringTableDestroy(pInfCache->pInfTable);
        }
        if(pInfCache->pListTable) {
            MyFree(pInfCache->pListTable);
        }
    }
    //
    // transient information
    //
    if(pInfCache->pSearchTable) {
        pStringTableDestroy(pInfCache->pSearchTable);
    }
    MyFree(pInfCache);
}

#endif


#ifdef UNICODE

PINFCACHE InfCacheCreateNewCache(
    IN PSETUP_LOG_CONTEXT LogContext
    )
/*++

Routine Description:

    Create new empty cache

Arguments:

    LogContext - for logging

Return Value:

    pointer to Run-Time header if succeeded, NULL if out of memory.

--*/
{
    PINFCACHE pInfCache = (PINFCACHE)MyMalloc(sizeof(INFCACHE));
    if(pInfCache == NULL) {
        return NULL;
    }
    ZeroMemory(pInfCache,sizeof(INFCACHE));
    //
    // set initial state
    //
    pInfCache->BaseAddress = NULL;
    pInfCache->bReadOnly = FALSE;
    pInfCache->bDirty = TRUE;
    pInfCache->bNoWriteBack = FALSE;
    //
    // create transient data
    //
    pInfCache->pHeader = (PCACHEHEADER)MyMalloc(sizeof(CACHEHEADER));
    if(pInfCache->pHeader == NULL) {
        goto cleanup;
    }
    pInfCache->pMatchTable = pStringTableInitialize(sizeof(CACHEMATCHENTRY));
    if(pInfCache->pMatchTable == NULL) {
        goto cleanup;
    }
    pInfCache->pInfTable = pStringTableInitialize(sizeof(CACHEINFENTRY));
    if(pInfCache->pInfTable == NULL) {
        goto cleanup;
    }
    pInfCache->pHeader->Version = INFCACHE_VERSION;
    pInfCache->pHeader->Locale = GetThreadLocale();
    pInfCache->pHeader->Flags = 0;
    pInfCache->pHeader->FileSize = 0; // in memory image
    pInfCache->pHeader->MatchTableOffset = 0; // in memory image
    pInfCache->pHeader->MatchTableSize = 0; // in memory image
    pInfCache->pHeader->InfTableOffset = 0; // in memory image
    pInfCache->pHeader->InfTableSize = 0; // in memory image
    pInfCache->pHeader->ListDataOffset = 0; // in memory image
    pInfCache->pHeader->ListDataCount = 1; // initial size (count the free list node)
    pInfCache->ListDataAlloc = 32768; // initial size of allocation
    pInfCache->pListTable = (PCACHELISTENTRY)MyMalloc(sizeof(CACHELISTENTRY)*pInfCache->ListDataAlloc);
    if(pInfCache->pListTable == NULL) {
        goto cleanup;
    }
    //
    // initialize free-list to empty (even though we allocated enough space, we don't commit it until needed)
    //
    pInfCache->pListTable[0].Value = 0; // how many free entries
    pInfCache->pListTable[0].Next = 0;
    //
    // search table
    //
    pInfCache->pSearchTable = pStringTableInitialize(sizeof(CACHEHITENTRY));
    if(pInfCache->pSearchTable == NULL) {
        goto cleanup;
    }

    WriteLogEntry(LogContext,
                  DRIVER_LOG_VVERBOSE,
                  MSG_LOG_USING_NEW_INF_CACHE,
                  NULL
                  );
    return pInfCache;

cleanup:

    InfCacheFreeCache(pInfCache);
    return NULL;
}

#endif

#ifdef UNICODE

DWORD MarkForDelete(
    IN LPCTSTR FilePath
    )
/*++

Routine Description:

    Special delete operation that will open the file with required access
    mark it as needs deleting
    and then close it again

Arguments:

    FilePath - name of file to delete

Return Value:

    Success status

--*/
{
    TCHAR TmpFilePath[MAX_PATH*2];
    PTSTR FileName;
    HANDLE hFile;
    int c;

    hFile = CreateFile(FilePath,
                       0,
                       FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                       NULL,
                       OPEN_EXISTING,
                       FILE_ATTRIBUTE_NORMAL | FILE_FLAG_DELETE_ON_CLOSE,
                       NULL
                      );

    if(hFile == INVALID_HANDLE_VALUE) {
        //
        // this can fail for various reasons
        //
        if(GetLastError() == ERROR_FILE_NOT_FOUND) {
            return NO_ERROR;
        }
        return GetLastError();
    }
    //
    // rename file to a temporary one for period that file remains alive
    //
    lstrcpyn(TmpFilePath,FilePath,MAX_PATH);

    FileName = (PTSTR)pSetupGetFileTitle(TmpFilePath);
    for(c=0;c<1000;c++) {
        _stprintf(FileName,OLDCACHE_NAME_TEMPLATE,c);
        if (MoveFile(FilePath,TmpFilePath)) {
            break;
        }
        if (GetLastError() != ERROR_FILE_EXISTS) {
            MYASSERT(GetLastError() == ERROR_FILE_EXISTS);
            break;
        }
    }
    MYASSERT(c<1000);

    //
    // ok, done (file may go away as soon as we close handle)
    //
    CloseHandle(hFile);

    return NO_ERROR;
}

#endif

#ifdef UNICODE

DWORD InfCacheGetFileNames(
    IN LPCTSTR InfDirectory,
    OUT TCHAR InfPath[3][MAX_PATH]
    )
{
    TCHAR InfName[MAX_PATH];
    int c;

    for(c=0;c<3;c++) {
        lstrcpyn(InfPath[c],InfDirectory,MAX_PATH);
        _stprintf(InfName,INFCACHE_NAME_TEMPLATE,c);
        if(!pSetupConcatenatePaths(InfPath[c],InfName,MAX_PATH,NULL)) {
            //
            // filename too big, fall into default search mode (we'll never be able to save the cache)
            //
            return ERROR_BAD_PATHNAME;
        }
    }
    return NO_ERROR;
}

#endif

#ifdef UNICODE

PINFCACHE InfCacheLoadCache(
    IN LPCTSTR InfDirectory,
    IN PSETUP_LOG_CONTEXT LogContext
    )
/*++

Routine Description:

    Retrieves cache for INF directory, if any.
    We'll try
    1) INFCACHE.1 (if it's a bad file, we'll rename to OLDCACHE.xxx)
    2) INFCACHE.2 (ditto)
    if we can't open a either of them, we'll skip over. We'll only have
    both if something happened during write (such as reboot)
    the OLDCACHE.xxx will be deleted when last handle to it is closed

    we attempt to return (1) existing cache, (2) empty cache, (3) NULL

Arguments:

    InfDirectory - directory to find cache in
    LogContext   - for logging

Return Value:

    pointer to Run-Time header if succeeded, NULL if fatal error (go into default search mode)

--*/
{

    //
    // currently only support for unicode setupapi
    //

    TCHAR InfPath[3][MAX_PATH];
    int c;
    DWORD FileSize;
    HANDLE FileHandle = INVALID_HANDLE_VALUE;
    HANDLE MappingHandle = NULL;
    PVOID BaseAddress = NULL;
    PCACHEHEADER pHeader = NULL;
    PINFCACHE pInfCache = NULL;
    DWORD Err;

    MYASSERT(InfDirectory);

    if ((Err = InfCacheGetFileNames(InfDirectory,InfPath))!=NO_ERROR) {
        return NULL;
    }

    //
    // look at INFCACHE.1 (primary) INFCACHE.2 (backup)
    //
    for(c=1;c<3;c++) {
        //
        // try and map this file into memory
        //
        //
        FileHandle = CreateFile(
                        InfPath[c],
                        GENERIC_READ,
                        FILE_SHARE_READ | FILE_SHARE_DELETE, // need delete permission
                        NULL,
                        OPEN_EXISTING,
                        0,
                        NULL
                        );

        if(FileHandle == INVALID_HANDLE_VALUE) {

            continue; // this file is locked, or doesn't exist

        }
        if((Err = pSetupMapFileForRead(FileHandle,&FileSize,&MappingHandle,&BaseAddress)) != NO_ERROR) {
            //
            // shouldn't happen on a good file, so clean it up
            //
            MarkForDelete(InfPath[c]);
            continue;
        }

        if(FileSize >= sizeof(CACHEHEADER)) {
            pHeader = (PCACHEHEADER)BaseAddress;
            if(pHeader->Version == INFCACHE_VERSION &&
                pHeader->FileSize <= FileSize &&
                BOUNDSCHECK(pHeader->MatchTableOffset,pHeader->MatchTableSize,pHeader->FileSize) &&
                BOUNDSCHECK(pHeader->InfTableOffset,pHeader->InfTableSize,pHeader->FileSize) &&
                BOUNDSCHECK(pHeader->ListDataOffset,(pHeader->ListDataCount*sizeof(CACHELISTENTRY)),pHeader->FileSize) &&
                (pHeader->MatchTableOffset >= sizeof(CACHEHEADER)) &&
                (pHeader->InfTableOffset >= pHeader->MatchTableOffset+pHeader->MatchTableSize) &&
                (pHeader->ListDataOffset >= pHeader->InfTableOffset+pHeader->InfTableSize)) {
                //
                // we're reasonably happy this file is valid
                //
                break;
            }
        }
        //
        // bad file (we was able to open file for reading, so it wasn't locked for writing)
        //
        MarkForDelete(InfPath[c]);
        pSetupUnmapAndCloseFile(FileHandle, MappingHandle, BaseAddress);
    }

    switch(c) {
        case 0: // obtained primary file
        case 1: // obtained secondary file
        case 2: // obtained backup file, don't move as secondary may exist as locked
            WriteLogEntry(LogContext,
                          DRIVER_LOG_VVERBOSE,
                          MSG_LOG_USING_INF_CACHE,
                          NULL,
                          InfPath[c]);
            break;
        case 3: // obtained no file
            return InfCacheCreateNewCache(LogContext);
        default: // whoops?
            MYASSERT(FALSE);
            return InfCacheCreateNewCache(LogContext);
    }

    //
    // if we get here, we have a mapped file
    //
    MYASSERT(BaseAddress);
    pInfCache = (PINFCACHE)MyMalloc(sizeof(INFCACHE));
    if(pInfCache == NULL) {
        pSetupUnmapAndCloseFile(FileHandle, MappingHandle, BaseAddress);
        return NULL;
    }
    ZeroMemory(pInfCache,sizeof(INFCACHE));
    //
    // set initial state
    //
    pInfCache->FileHandle = FileHandle;
    pInfCache->MappingHandle = MappingHandle;
    pInfCache->BaseAddress = BaseAddress;
    pInfCache->bReadOnly = TRUE;
    pInfCache->bDirty = FALSE;
    pInfCache->bNoWriteBack = FALSE;
    //
    // make Runtime-Data point to relevent data structures
    //
    pInfCache->pHeader = pHeader;

    //
    // note that  InitializeStringTableFromMemoryMappedFile creates a header that must be
    // released by MyFree instead of pSetupStringTableDestroy
    //
    pInfCache->pMatchTable = InitializeStringTableFromMemoryMappedFile(
                                    (PBYTE)BaseAddress+pHeader->MatchTableOffset,
                                    pInfCache->pHeader->MatchTableSize,
                                    pInfCache->pHeader->Locale,
                                    sizeof(CACHEMATCHENTRY)
                                    );

    pInfCache->pInfTable = InitializeStringTableFromMemoryMappedFile(
                                    (PBYTE)BaseAddress+pHeader->InfTableOffset,
                                    pInfCache->pHeader->InfTableSize,
                                    pInfCache->pHeader->Locale,
                                    sizeof(CACHEINFENTRY)
                                    );

    pInfCache->pListTable = (PCACHELISTENTRY)((PBYTE)BaseAddress+pHeader->ListDataOffset);
    pInfCache->ListDataAlloc = 0; // initial size of allocation (0 since this is static)

    //
    // search table - transient and empty
    //
    pInfCache->pSearchTable = pStringTableInitialize(sizeof(CACHEHITENTRY));

    //
    // ok, now did all memory allocations succeed?
    //
    if(pInfCache->pMatchTable==NULL || pInfCache->pInfTable==NULL || pInfCache->pSearchTable==NULL) {
        InfCacheFreeCache(pInfCache);
        return NULL;
    }

    return pInfCache;

    //
    // for ANSI version, just use default search mode (for now)
    //
    return NULL;
}

#endif

#ifdef UNICODE

DWORD InfCacheMakeWritable(
    IN OUT PINFCACHE pInfCache
    )
/*++

Routine Description:

    Modifies InfCache in such a way that it can be written to
    This is expensive as all previously memory-mapped data must be copied into memory

Arguments:

    pInfCache - the cache we want to make writable

Return Value:

    status, typically NO_ERROR

--*/
{
    PCACHEHEADER pNewCacheHeader = NULL;
    PVOID pNewMatchTable = NULL;
    PVOID pNewInfTable = NULL;
    PCACHELISTENTRY pNewListTable = NULL;
    ULONG ListAllocSize = 0;

    if(pInfCache == NULL || !pInfCache->bReadOnly) {
        //
        // not a cache we can/need to modify
        //
        return NO_ERROR;
    }
    if (pInfCache->bNoWriteBack) {
        //
        // we've already attempted this once, cache now invalid
        //
        return ERROR_INVALID_DATA;
    }
    MYASSERT(pInfCache->BaseAddress);
    MYASSERT(!pInfCache->bDirty);
    //
    // allocatable data we need to duplicate is
    // CACHEHEADER
    // MatchStringTable
    // InfStringTable
    // DataList
    //
    pNewCacheHeader = (PCACHEHEADER)MyMalloc(sizeof(CACHEHEADER));
    if(pNewCacheHeader == NULL) {
        goto cleanup;
    }
    ZeroMemory(pNewCacheHeader,sizeof(CACHEHEADER));
    pNewCacheHeader->FileSize = 0;
    pNewCacheHeader->Flags = 0;
    pNewCacheHeader->InfTableOffset = 0;
    pNewCacheHeader->InfTableSize = 0;
    pNewCacheHeader->ListDataCount = pInfCache->pHeader->ListDataCount;
    pNewCacheHeader->Locale = pInfCache->pHeader->Locale;
    pNewCacheHeader->Version = INFCACHE_VERSION;

    pNewMatchTable = pStringTableDuplicate(pInfCache->pMatchTable);
    if(pNewMatchTable == NULL) {
        goto cleanup;
    }
    pNewInfTable = pStringTableDuplicate(pInfCache->pInfTable);
    if(pNewInfTable == NULL) {
        goto cleanup;
    }
    ListAllocSize = pNewCacheHeader->ListDataCount + 32768;
    pNewListTable = (PCACHELISTENTRY)MyMalloc(sizeof(CACHELISTENTRY)*ListAllocSize);
    if(pNewListTable == NULL) {
        goto cleanup;
    }
    //
    // copy the table
    //
    CopyMemory(pNewListTable,pInfCache->pListTable,pNewCacheHeader->ListDataCount*sizeof(CACHELISTENTRY));

    //
    // ok, now commit - delete & replace old data
    //
    pStringTableDestroy(pInfCache->pMatchTable);
    pStringTableDestroy(pInfCache->pInfTable);
    pSetupUnmapAndCloseFile(pInfCache->FileHandle, pInfCache->MappingHandle, pInfCache->BaseAddress);

    pInfCache->FileHandle = INVALID_HANDLE_VALUE;
    pInfCache->MappingHandle = NULL;
    pInfCache->BaseAddress = NULL;
    pInfCache->bReadOnly = FALSE;

    pInfCache->pHeader = pNewCacheHeader;
    pInfCache->pMatchTable = pNewMatchTable;
    pInfCache->pInfTable = pNewInfTable;
    pInfCache->pListTable = pNewListTable;
    pInfCache->ListDataAlloc = ListAllocSize;

    return NO_ERROR;

cleanup:

    //
    // we don't have enough memory to duplicate
    //
    if(pNewCacheHeader) {
        MyFree(pNewCacheHeader);
    }
    if(pNewMatchTable) {
        pStringTableDestroy(pNewMatchTable);
    }
    if(pNewInfTable) {
        pStringTableDestroy(pNewInfTable);
    }
    if(pNewListTable) {
        MyFree(pNewListTable);
    }
    return ERROR_NOT_ENOUGH_MEMORY;
}

#endif

#ifdef UNICODE

DWORD InfCacheWriteCache(
    IN LPCTSTR InfDirectory,
    IN OUT PINFCACHE pInfCache,
    IN PSETUP_LOG_CONTEXT LogContext
    )
/*++

Routine Description:

    Writes a cache file to the INF directory being searched
    Worst case scenario is we abandon the write, possibly leaving
    a file turd around (until next inf search)
    Typically,
    1) we'll write to INFCACHE.0
    2) we'll rename INFCACHE.2 to OLDCACHE.xxx (only if INFCACHE.1&2 exists)
    3) we'll rename INFCACHE.1 to INFCACHE.2
    4) we'll rename INFCACHE.0 to INFCACHE.1
    5) we'll rename INFCACHE.1 to OLDCACHE.xxx
    at stage 4, new callers may fail to open INFCACHE.1 and attempt INFCACHE.2
    OLDCACHE.xxx will be deleted when last handle to it is closed

Arguments:

    pInfCache - the cache we want to make writable

Return Value:

    status, typically NO_ERROR

--*/
{
    HANDLE hFile;
    HANDLE hFile2;
    TCHAR InfPath[3][MAX_PATH];
    DWORD Offset;
    DWORD BytesWritten;
    PVOID MatchTableBlock;
    PVOID InfTableBlock;
    DWORD Err;
    DWORD CacheIndex = 0;

    //
    // don't bother writing it if we don't have to
    //
    if(pInfCache->bNoWriteBack) {
        return ERROR_INVALID_DATA;
    }
    if(!pInfCache->bDirty || pInfCache->bReadOnly) {
        return NO_ERROR;
    }

    MYASSERT(InfDirectory);

    if ((Err = InfCacheGetFileNames(InfDirectory,InfPath))!=NO_ERROR) {
        return Err;
    }

    //
    // attempt to open the temporary file for writing
    //
    hFile = CreateFile(InfPath[0],
                       GENERIC_WRITE,
                       FILE_SHARE_DELETE, // exclusive, but can be deleted/renamed
                       NULL,
                       CREATE_ALWAYS,
                       FILE_ATTRIBUTE_NORMAL,
                       NULL
                      );

    if(hFile == INVALID_HANDLE_VALUE) {
        //
        // this will fail if we're non-admin, or we're already writing the cache
        //
        return GetLastError();
    }

    //
    // align past header
    //
    Offset = CACHE_ALIGN_BLOCK(sizeof(CACHEHEADER));
    MYASSERT(Offset>=sizeof(CACHEHEADER));

    //
    // get information about MatchTable
    //
    pInfCache->pHeader->MatchTableOffset = Offset;
    pInfCache->pHeader->MatchTableSize = pStringTableGetDataBlock(pInfCache->pMatchTable, &MatchTableBlock);
    Offset += CACHE_ALIGN_BLOCK(pInfCache->pHeader->MatchTableSize);
    MYASSERT(Offset>=pInfCache->pHeader->MatchTableOffset+pInfCache->pHeader->MatchTableSize);

    //
    // get information about InfTable
    //
    pInfCache->pHeader->InfTableOffset = Offset;
    pInfCache->pHeader->InfTableSize = pStringTableGetDataBlock(pInfCache->pInfTable, &InfTableBlock);
    Offset += CACHE_ALIGN_BLOCK(pInfCache->pHeader->InfTableSize);
    MYASSERT(Offset>=pInfCache->pHeader->InfTableOffset+pInfCache->pHeader->InfTableSize);

    //
    // get information about ListData
    //
    pInfCache->pHeader->ListDataOffset = Offset;
    Offset += CACHE_ALIGN_BLOCK((pInfCache->pHeader->ListDataCount*sizeof(CACHELISTENTRY)));
    MYASSERT(Offset>=pInfCache->pHeader->ListDataOffset+pInfCache->pHeader->ListDataCount*sizeof(CACHELISTENTRY));

    //
    // size of file now computed
    //
    pInfCache->pHeader->FileSize = Offset;

    //
    // write the file out
    //
    Offset = 0;

    //
    // cache header
    //
    if(!WriteFile(hFile, pInfCache->pHeader, sizeof(CACHEHEADER), &BytesWritten, NULL)) {
        Err = GetLastError();
        goto clean;
    }

    MYASSERT(BytesWritten == sizeof(CACHEHEADER));
    Offset += BytesWritten;

    //
    // MatchTable
    //
    if(AlignForNextBlock(hFile, pInfCache->pHeader->MatchTableOffset - Offset)) {
        Offset = pInfCache->pHeader->MatchTableOffset;
    } else {
        Err = GetLastError();
        goto clean;
    }

    if(!WriteFile(hFile, MatchTableBlock, pInfCache->pHeader->MatchTableSize, &BytesWritten, NULL)) {
        Err = GetLastError();
        goto clean;
    }

    MYASSERT(BytesWritten == pInfCache->pHeader->MatchTableSize);
    Offset += BytesWritten;

    //
    // InfTable
    //
    if(AlignForNextBlock(hFile, pInfCache->pHeader->InfTableOffset - Offset)) {
        Offset = pInfCache->pHeader->InfTableOffset;
    } else {
        Err = GetLastError();
        goto clean;
    }

    if(!WriteFile(hFile, InfTableBlock, pInfCache->pHeader->InfTableSize, &BytesWritten, NULL)) {
        Err = GetLastError();
        goto clean;
    }

    MYASSERT(BytesWritten == pInfCache->pHeader->InfTableSize);
    Offset += BytesWritten;

    //
    // ListData
    //

    if(AlignForNextBlock(hFile, pInfCache->pHeader->ListDataOffset - Offset)) {
        Offset = pInfCache->pHeader->ListDataOffset;
    } else {
        Err = GetLastError();
        goto clean;
    }

    if(!WriteFile(hFile, pInfCache->pListTable, pInfCache->pHeader->ListDataCount*sizeof(CACHELISTENTRY), &BytesWritten, NULL)) {
        Err = GetLastError();
        goto clean;
    }

    MYASSERT(BytesWritten == pInfCache->pHeader->ListDataCount*sizeof(CACHELISTENTRY));
    Offset += BytesWritten;

    //
    // final padding
    //

    if(AlignForNextBlock(hFile, pInfCache->pHeader->FileSize - Offset)) {
        Offset = pInfCache->pHeader->FileSize;
    } else {
        Err = GetLastError();
        goto clean;
    }

    FlushFileBuffers(hFile);

    //
    // new cache written, do we need to shuffle primary to backup?
    //
    hFile2 = CreateFile(InfPath[1],
                       GENERIC_READ,
                       FILE_SHARE_READ|FILE_SHARE_DELETE, // lock this file in place
                       NULL,
                       OPEN_EXISTING,
                       FILE_ATTRIBUTE_NORMAL,
                       NULL
                      );
    if(hFile2 != INVALID_HANDLE_VALUE) {
        //
        // ok, we have a primary, so back it up
        // delete the old backup first
        // once in place, any new opens will find it in backup position
        // until we move and release new cache
        //
        MarkForDelete(InfPath[2]);
        MoveFile(InfPath[1],InfPath[2]);
        CloseHandle(hFile2);
    }
    //
    // now attempt to move our cache
    //
    if(MoveFile(InfPath[0],InfPath[1])) {
        CacheIndex = 1;
    }
    CloseHandle(hFile);
    //
    // new cache committed & ready for reading
    // try not to leave turds around
    //
    MarkForDelete(InfPath[2]);
    MarkForDelete(InfPath[0]);

    pInfCache->bDirty = FALSE;

    WriteLogEntry(LogContext,
                  CacheIndex ? DRIVER_LOG_INFO : DRIVER_LOG_ERROR,
                  CacheIndex ? MSG_LOG_MODIFIED_INF_CACHE : MSG_LOG_FAILED_MODIFY_INF_CACHE,
                  NULL,
                  InfPath[CacheIndex]);

    return NO_ERROR;

clean:

    //
    // abandon the file
    // delete first, we can do this since we opened the file shared-delete
    // don't close before delete, otherwise we might delete a file someone else is writing
    //
    DeleteFile(InfPath[0]);
    CloseHandle(hFile);

    return Err;
}

#endif

#ifdef UNICODE

ULONG InfCacheAllocListEntry(
    IN OUT PINFCACHE pInfCache,
    IN LONG init
    )
/*++

Routine Description:

    Allocates a single list entry, initializing the datum to init

    Side effect: if pInfCache not writable, it will be made writable
    Side effect: if pInfCache not dirty, it will be marked dirty

Arguments:

    pInfCache - the cache we're going to modify
    init - initial value of datum

Return Value:

    index of datum, or 0 on failure. (GetLastError indicates error)

--*/
{
    DWORD status;
    ULONG entry;

    if(pInfCache->bReadOnly) {
        status = InfCacheMakeWritable(pInfCache);
        if(status != NO_ERROR) {
            pInfCache->bNoWriteBack = TRUE; // cache now invalid
            SetLastError(status);
            return 0;
        }
    }
    //
    // query free-list
    //
    entry = pInfCache->pListTable[0].Next;
    if(entry) {
        //
        // allocate from free list - reuse space
        //
        pInfCache->pListTable[0].Value--;
        pInfCache->pListTable[0].Next = pInfCache->pListTable[entry].Next;
        pInfCache->pListTable[entry].Value = init;
        pInfCache->pListTable[entry].Next = 0;
        pInfCache->bDirty = TRUE;
        return entry;
    }
    if(pInfCache->pHeader->ListDataCount >= pInfCache->ListDataAlloc) {
        //
        // allocate some extra space
        //
        ULONG CountNewSpace;
        PCACHELISTENTRY pNewSpace;

        MYASSERT(pInfCache->ListDataAlloc);
        CountNewSpace = pInfCache->ListDataAlloc*2;
        pNewSpace = (PCACHELISTENTRY)MyRealloc(pInfCache->pListTable,sizeof(CACHELISTENTRY)*CountNewSpace);
        if(pNewSpace == NULL) {
            //
            // ack!
            //
            pInfCache->bNoWriteBack = TRUE; // junk this cache at end
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return 0;
        }
        pInfCache->ListDataAlloc = CountNewSpace;
        pInfCache->pListTable = pNewSpace;
    }
    //
    // allocate from extra space
    //
    entry = pInfCache->pHeader->ListDataCount;
    pInfCache->pHeader->ListDataCount++;
    pInfCache->pListTable[entry].Value = init;
    pInfCache->pListTable[entry].Next = 0;
    pInfCache->bDirty = TRUE;
    return entry;
}

#endif

#ifdef UNICODE

DWORD InfCacheFreeListEntry(
    IN OUT PINFCACHE pInfCache,
    IN ULONG entry
    )
/*++

Routine Description:

    Releases a single list entry (no modifications to prev/next links made)

    Side effect: if pInfCache not writable, it will be made writable
    Side effect: if pInfCache not dirty, it will be marked dirty

Arguments:

    pInfCache - the cache we're going to modify
    entry - list entry to add to free list

Return Value:

    status, typically NO_ERROR

--*/
{
    DWORD status;

    if(entry == 0 || pInfCache == NULL || entry >= pInfCache->pHeader->ListDataCount) {
        return ERROR_INVALID_DATA;
    }
    if(pInfCache->bReadOnly) {
        status = InfCacheMakeWritable(pInfCache);
        if(status != NO_ERROR) {
            pInfCache->bNoWriteBack = TRUE; // cache now invalid
            return status;
        }
    }
    pInfCache->pListTable[entry].Value = -1;
    pInfCache->pListTable[entry].Next = pInfCache->pListTable[0].Next;
    pInfCache->pListTable[0].Next = entry;
    pInfCache->pListTable[0].Value++;
    pInfCache->bDirty = TRUE;
    return NO_ERROR;
}

#endif

#ifdef UNICODE

DWORD InfCacheRemoveMatchRefToInf(
    IN OUT PINFCACHE pInfCache,
    IN LONG MatchEntry,
    IN LONG InfEntry
    )
/*++

Routine Description:

    Removes details about a specific INF from specific HWID entry

    assumptions: pInfCache already writable

Arguments:

    pInfCache - the cache we're going to modify
    MatchEntry - the Match list we need to remove INF from
    InfEntry - the INF we need to remove from Match list

Return Value:

    status, typically NO_ERROR

--*/
{
    DWORD status;
    CACHEMATCHENTRY matchdata;
    ULONG parent_index;
    ULONG index;
    ULONG newindex;
    BOOL head;

    MYASSERT(pInfCache);
    MYASSERT(!pInfCache->bReadOnly);
    MYASSERT(MatchEntry);
    MYASSERT(InfEntry);

    if(!pStringTableGetExtraData(pInfCache->pMatchTable,MatchEntry,&matchdata,sizeof(matchdata))) {
        MYASSERT(FALSE); // should not fail
    }

    parent_index = 0;
    index = matchdata.InfList;
    head = FALSE;

    while (index) {

        newindex = pInfCache->pListTable[index].Next;

        if (pInfCache->pListTable[index].Value == InfEntry) {
            //
            // remove
            //
            pInfCache->bDirty = TRUE;
            if(parent_index) {
                pInfCache->pListTable[parent_index].Next = newindex;
            } else {
                matchdata.InfList = newindex;
                head = TRUE;
            }
            status = InfCacheFreeListEntry(pInfCache,index);
            if(status != NO_ERROR) {
                pInfCache->bNoWriteBack = TRUE; // cache now invalid
                return status;
            }
        } else {
            parent_index = index;
        }
        index = newindex;
    }

    if (head) {
        //
        // we modified the head item
        //
        if(!pStringTableSetExtraData(pInfCache->pMatchTable,MatchEntry,&matchdata,sizeof(matchdata))) {
            MYASSERT(FALSE); // should not fail
        }
    }

    return NO_ERROR;
}

#endif


#ifdef UNICODE

DWORD InfCacheRemoveInf(
    IN OUT PINFCACHE pInfCache,
    IN LONG nHitEntry,
    IN PCACHEINFENTRY inf_entry
    )
/*++

Routine Description:

    Removes details about a specific INF from cache

    Side effect: if pInfCache not writable, it will be made writable
    Side effect: if pInfCache not dirty, it will be marked dirty

Arguments:

    pInfCache - the cache we're going to modify
    nHitEntry - string id in Inf StringTable
    inf_entry - structure obtained from Inf StringTable

Return Value:

    status, typically NO_ERROR

--*/
{
    DWORD status;
    DWORD hwstatus;
    ULONG parent_index;
    CACHEINFENTRY dummy_entry;

    MYASSERT(inf_entry); // later we may make this optional
    MYASSERT(nHitEntry);

    if(inf_entry->MatchList == CIE_INF_INVALID) {
        //
        // already showing as deleted
        //
        return NO_ERROR;
    }

    if(pInfCache == NULL || pInfCache->bNoWriteBack) {
        return ERROR_INVALID_DATA;
    }

    if(pInfCache->bReadOnly) {
        status = InfCacheMakeWritable(pInfCache);
        if(status != NO_ERROR) {
            pInfCache->bNoWriteBack = TRUE; // cache now invalid
            return status;
        }
    }

    pInfCache->bDirty = TRUE;
    parent_index = inf_entry->MatchList;

    //
    // invalidate inf_entry
    //
    dummy_entry.MatchList = CIE_INF_INVALID;
    dummy_entry.FileTime.dwLowDateTime = 0;
    dummy_entry.FileTime.dwHighDateTime = 0;
    dummy_entry.MatchFlags = CIEF_INF_NOTINF;
    if(!pStringTableSetExtraData(pInfCache->pInfTable,nHitEntry,&dummy_entry,sizeof(dummy_entry))) {
        MYASSERT(FALSE); // should not fail
    }
    //
    // parse through and delete list of match ID's
    //
    hwstatus = NO_ERROR;

    while(parent_index>0 && parent_index<pInfCache->pHeader->ListDataCount) {
        LONG value = pInfCache->pListTable[parent_index].Value;
        ULONG next = pInfCache->pListTable[parent_index].Next;
        //
        // free the list entry for re-use
        //
        status = InfCacheFreeListEntry(pInfCache,parent_index);
        if(status != NO_ERROR) {
            pInfCache->bNoWriteBack = TRUE; // cache now invalid
            hwstatus = status;
        }
        parent_index = next;
        //
        // for each Match ID, delete all references to the INF
        //
        status = InfCacheRemoveMatchRefToInf(pInfCache,value,nHitEntry);
        if(hwstatus == NO_ERROR) {
            hwstatus = status;
        }
    }

    return hwstatus;
}

#endif

#ifdef UNICODE

LONG InfCacheLookupInf(
    IN OUT PINFCACHE pInfCache,
    IN LPWIN32_FIND_DATA FindFileData,
    OUT PCACHEINFENTRY inf_entry
    )
/*++

Routine Description:

    looks up the file as given by FindFileData to see if it's in the cache
    If it's in the cache marked valid, and the date-stamp in cache is same as date-stamp of INF
    then it's a 'HIT'
    If it's in the cache marked valid, but date-stamp is wrong, then it's deleted and considered
    a "MISS'
    All other cases, consider it a 'MISS'

Arguments:

    pInfCache - the cache we're using
    FindFileData - information about a specific file we're looking at
    inf_entry - structure obtained from Inf StringTable (if NULL, delete)

Return Value:

    -1 for a 'MISS'. StringID of INF for a 'HIT'
    inf_entry filled out with MatchList == CIE_INF_INVALID for a miss.

--*/
{
    LONG i;
    DWORD StringLength;

    MYASSERT(pInfCache);
    MYASSERT(FindFileData);
    MYASSERT(inf_entry);
    //
    // determine if the cache entry of pInfCache is considered valid
    //
    i = pStringTableLookUpString(pInfCache->pInfTable,
                                        FindFileData->cFileName,
                                        &StringLength,
                                        NULL, // hash value
                                        NULL, // find context
                                        STRTAB_CASE_INSENSITIVE,
                                        inf_entry,
                                        sizeof(CACHEINFENTRY));
    if(i>=0 && inf_entry->MatchList != CIE_INF_INVALID) {
        //
        // cache hit (and matchlist is valid)
        //
        if(CompareFileTime(&inf_entry->FileTime,&FindFileData->ftLastWriteTime)==0) {
            //
            // valid cache hit
            //
            return i;
        }
        //
        // cache out of date miss
        // although we'll rebuild it later, let's use this opportunity to delete the entry
        //
        InfCacheRemoveInf(pInfCache,i,inf_entry);
    }
    //
    // we're here because we have a miss, however fill in a new (empty) inf_entry
    // MatchList set to CIE_INF_INVALID to indicate list is invalid and inf must be searched
    //
    inf_entry->FileTime = FindFileData->ftLastWriteTime;
    inf_entry->MatchList = CIE_INF_INVALID;
    inf_entry->MatchFlags = CIEF_INF_NOTINF;

    return -1;
}

#endif

#ifdef UNICODE

ULONG InfCacheAddListTail(
    IN OUT PINFCACHE pInfCache,
    IN OUT PULONG head,
    IN OUT PULONG tail,
    IN LONG value
    )
/*++

Routine Description:

    Adds value to tail of a list where *tail is an entry in the list

Arguments:

    pInfCache - cache to modify
    head - head of list
    tail - DataList entry
    value - data to add

Return Value:

    new entry position, 0 on error (GetLastError() returns error)

--*/
{
    ULONG next;
    ULONG first;

    MYASSERT(pInfCache);
    MYASSERT(head == NULL || head != tail);
    if (tail) {
        first = *tail;
    } else if (head) {
        first = *head;
    } else {
        MYASSERT(head || tail);
    }
    if (!first) {
        next = InfCacheAllocListEntry(pInfCache,value);
        if (!next) {
            return 0;
        }
        if (head) {
            *head = next;
        }
    } else {
        //
        // move head to last item in list
        //
        while(pInfCache->pListTable[first].Next) {
            first = pInfCache->pListTable[first].Next;
        }
        next = InfCacheAllocListEntry(pInfCache,value);
        if(!next) {
            return 0;
        }
        pInfCache->pListTable[first].Next = next;
    }
    if(tail) {
        *tail = next;
    }
    return next;
}

#endif

#ifdef UNICODE

LONG InfCacheAddMatchItem(
    IN OUT PINFCACHE pInfCache,
    IN LPCTSTR key,
    IN LONG InfEntry
    )
/*++

Routine Description:

    Given an INF StringID (InfEntry) and match key,
    obtain (and return) Match StringID
    while also adding InfEntry to head of Match's INF list
    (if not already at head)
    Order is not particularly important, however adding to head is
    quicker to do, and easier to reduce number of times we add inf
    if match id is referenced multiple times

Arguments:

    pInfCache - cache to modify
    key - match string (buffer must be writable)
    InfEntry - StringID

Return Value:

    new entry in match table, -1 on error (GetLastError() returns error)

--*/
{
    LONG MatchIndex;
    CACHEMATCHENTRY matchentry;
    DWORD StringLength;

    MYASSERT(pInfCache);
    MYASSERT(key);
    MYASSERT(InfEntry>=0);

    //
    // if cache is invalid, we'll skip this as optimization
    //
    if(pInfCache->bNoWriteBack) {
        SetLastError(ERROR_INVALID_DATA);
        return -1;
    }

    MatchIndex = pStringTableLookUpString(pInfCache->pMatchTable,
                                                    (LPTSTR)key, // will not be modified
                                                    &StringLength,
                                                    NULL, // hash value
                                                    NULL, // find context
                                                    STRTAB_CASE_INSENSITIVE,
                                                    &matchentry,
                                                    sizeof(matchentry));

    if(MatchIndex < 0) {
        //
        // entirely new entry
        //
        matchentry.InfList = InfCacheAllocListEntry(pInfCache,InfEntry);
        if(matchentry.InfList == 0) {
            return -1;
        }
        MatchIndex = pStringTableAddString(pInfCache->pMatchTable,
                                                    (LPTSTR)key, // will not be modified
                                                    STRTAB_CASE_INSENSITIVE|STRTAB_NEW_EXTRADATA,
                                                    &matchentry,
                                                    sizeof(matchentry));
        if(MatchIndex<0) {
            pInfCache->bNoWriteBack = TRUE;
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return -1;
        }
    } else {
        MYASSERT(matchentry.InfList<pInfCache->pHeader->ListDataCount);
        //
        // if we came across this same match earlier for this inf,
        // the inf should still be at head of list
        // the world doesn't come to an end though if we end up adding
        // the inf twice - we check for this when deleting the inf
        //
        if (pInfCache->pListTable[matchentry.InfList].Value != InfEntry) {
            ULONG newentry = InfCacheAllocListEntry(pInfCache,InfEntry);
            if(newentry == 0) {
                return -1;
            }
            pInfCache->pListTable[newentry].Next = matchentry.InfList;
            matchentry.InfList = newentry;
            if(!pStringTableSetExtraData(pInfCache->pMatchTable,MatchIndex,&matchentry,sizeof(matchentry))) {
                MYASSERT(FALSE); // should not fail
            }
        }
    }
    return MatchIndex;
}

#endif

#ifdef UNICODE

LONG InfCacheAddInf(
    IN PSETUP_LOG_CONTEXT LogContext, OPTIONAL
    IN OUT PINFCACHE pInfCache,
    IN LPWIN32_FIND_DATA FindFileData,
    OUT PCACHEINFENTRY inf_entry,
    IN PLOADED_INF pInf
    )
/*++

Routine Description:

    Called to add a newly discovered INF to the cache
    If hINF is "bad", then we'll mark the INF as an exclusion
    so we don't waste time with it in future
    If we return with an error, caller knows that the INF
    must be searched if it can be searched

Arguments:

    LogContext - logging context for errors

    pInfCache - cache to modify

    FindFileData - contains name of INF and date-stamp

    inf_entry - returns list of match ID's associated with INF

    pINF - opened INF to add information about.  NOTE: Either this INF must
           be locked by the caller, or the INF cannot be accessed by any other
           thread.  THIS ROUTINE DOES NOT DO LOCKING ON THE INF.

Return Value:

    InfEntry - -1 if error (GetLastError returns status)

--*/
{
    //
    // FindFileData contains name & date-stamp of INF
    // we need to process all search information out of the INF
    //
    LONG nInfIndex = -1;
    LONG nMatchId = -1;
    ULONG last_list_entry = 0;
    ULONG head_list_entry = 0;
    DWORD Err = NO_ERROR;
    PCTSTR MatchString;
    GUID guid;
    PINF_SECTION MfgListSection;
    PINF_LINE MfgListLine;
    UINT MfgListLineIndex;
    PTSTR CurMfgSecName;
    TCHAR CurMfgSecWithExt[MAX_SECT_NAME_LEN];

    MYASSERT(pInfCache);
    MYASSERT(FindFileData);
    MYASSERT(inf_entry);

    if (pInfCache->bNoWriteBack) {
        //
        // cache is already bad, so don't waste time updating it
        // note though that the INF should be searched
        //
        return ERROR_INVALID_DATA;
    }
    if(pInfCache->bReadOnly) {
        Err = InfCacheMakeWritable(pInfCache);
        if(Err != NO_ERROR) {
            pInfCache->bNoWriteBack = TRUE; // cache now invalid
            return Err;
        }
        pInfCache->bDirty = TRUE;
    }

    //
    // this stuff should be set up earlier
    //
    MYASSERT(inf_entry->MatchList == CIE_INF_INVALID);
    MYASSERT(inf_entry->MatchFlags == CIEF_INF_NOTINF);
    MYASSERT(inf_entry->FileTime.dwHighDateTime = FindFileData->ftLastWriteTime.dwHighDateTime);
    MYASSERT(inf_entry->FileTime.dwLowDateTime = FindFileData->ftLastWriteTime.dwLowDateTime);
    MYASSERT(!pInfCache->bReadOnly);

    //
    // we need the InfIndex before we start (also mark this as file physically exist)
    //
    inf_entry->MatchList = 0;
    nInfIndex = pStringTableAddString(pInfCache->pInfTable,
                                        FindFileData->cFileName,
                                        STRTAB_CASE_INSENSITIVE|STRTAB_NEW_EXTRADATA,
                                        inf_entry,
                                        sizeof(CACHEINFENTRY));
    if (nInfIndex<0) {
        //
        // ack, out of memory
        //
        Err = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }

    if(pInf) {
        if(pInf->Style == INF_STYLE_WIN4) {

            inf_entry->MatchFlags |= CIEF_INF_WIN4;

            if(pInf->InfSourceMediaType == SPOST_URL) {
                inf_entry->MatchFlags |= CIEF_INF_URL;
            }

            //
            // for a Win4 style INF, we're going to add Class GUID & Class Name to the
            // pool of ID's we can match on
            // note that if one or the other is missing, we don't lookup here as registry
            // information could change
            // we do the cross-lookups at the time of the INF search
            //
            if((MatchString = pSetupGetVersionDatum(&pInf->VersionBlock, pszClassGuid))!=NULL) {
                //
                // we found a class GUID
                //
                inf_entry->MatchFlags |= CIEF_INF_CLASSGUID;

                nMatchId = InfCacheAddMatchItem(pInfCache,MatchString,nInfIndex);
                if (nMatchId<0) {
                    Err = GetLastError();
                    goto cleanup;
                }
                if (!InfCacheAddListTail(pInfCache,&head_list_entry,&last_list_entry,nMatchId)) {
                    Err = GetLastError();
                    goto cleanup;
                }

                //
                // check out a special case {0}
                //
                if(pSetupGuidFromString(MatchString, &guid) == NO_ERROR && pSetupIsGuidNull(&guid)) {
                    inf_entry->MatchFlags |= CIEF_INF_NULLGUID;
                }

            }
            if((MatchString = pSetupGetVersionDatum(&pInf->VersionBlock, pszClass))!=NULL) {
                //
                // we found a class name
                //
                inf_entry->MatchFlags |= CIEF_INF_CLASSNAME;

                nMatchId = InfCacheAddMatchItem(pInfCache,MatchString,nInfIndex);
                if (nMatchId<0) {
                    Err = GetLastError();
                    goto cleanup;
                }
                if (!InfCacheAddListTail(pInfCache,&head_list_entry,&last_list_entry,nMatchId)) {
                    Err = GetLastError();
                    goto cleanup;
                }
            }

            //
            // enumerate all manufacturers
            //
            if((MfgListSection = InfLocateSection(pInf, pszManufacturer, NULL)) &&
               MfgListSection->LineCount) {
                //
                // We have a [Manufacturer] section and there is at least one
                // line within it.
                //
                inf_entry->MatchFlags |= CIEF_INF_MANUFACTURER;

                for(MfgListLineIndex = 0;
                    InfLocateLine(pInf, MfgListSection, NULL, &MfgListLineIndex, &MfgListLine);
                    MfgListLineIndex++) {
                    //
                    // Make sure the current line is one of these valid forms:
                    //
                    // MfgDisplayNameAndModelsSection
                    // MfgDisplayName = MfgModelsSection [,TargetDecoration...]
                    //
                    if(!ISSEARCHABLE(MfgListLine)) {
                        //
                        // We have a line with multiple fields but no key--skip
                        // it.
                        //
                        continue;
                    }

                    if(CurMfgSecName = InfGetField(pInf, MfgListLine, 1, NULL)) {

                        INFCONTEXT device;

                        //
                        // Check to see if there is an applicable
                        // TargetDecoration entry for this manufacturer's
                        // models section (if so, the models section name will
                        // be appended with that decoration).
                        //
                        if(GetDecoratedModelsSection(LogContext,
                                                     pInf,
                                                     MfgListLine,
                                                     NULL,
                                                     CurMfgSecWithExt)) {
                            //
                            // From here on, use the decorated models section...
                            //
                            CurMfgSecName = CurMfgSecWithExt;
                        }

                        if(SetupFindFirstLine(pInf, CurMfgSecName, NULL, &device)) {
                            do {
                                TCHAR devname[LINE_LEN];
                                DWORD devindex;
                                DWORD fields = SetupGetFieldCount(&device);
                                //
                                // for a device line, field 1 = section, field 2+ = match keys
                                //
                                for(devindex=2;devindex<=fields;devindex++) {
                                    if(SetupGetStringField(&device,devindex,devname,LINE_LEN,NULL)) {
                                        //
                                        // finally, a hit key to add
                                        //
                                        nMatchId = InfCacheAddMatchItem(pInfCache,devname,nInfIndex);
                                        if(nMatchId<0) {
                                            Err = GetLastError();
                                            goto cleanup;
                                        }
                                        if (!InfCacheAddListTail(pInfCache,&head_list_entry,&last_list_entry,nMatchId)) {
                                            Err = GetLastError();
                                            goto cleanup;
                                        }
                                    }
                                }
                            } while(SetupFindNextLine(&device,&device));
                        }
                    }
                }
            }

        } else if (pInf->Style == INF_STYLE_OLDNT) {
            //
            // for an OLDNT style INF, we'll add Legacy class name to the pool of ID's
            // we can match on
            //
            inf_entry->MatchFlags |= CIEF_INF_OLDNT;

            if((MatchString = pSetupGetVersionDatum(&pInf->VersionBlock, pszClass))!=NULL) {
                //
                // we found a (legacy) class name
                //
                inf_entry->MatchFlags |= CIEF_INF_CLASSNAME;

                nMatchId = InfCacheAddMatchItem(pInfCache,MatchString,nInfIndex);
                if (nMatchId<0) {
                    Err = GetLastError();
                    goto cleanup;
                }
                if (!InfCacheAddListTail(pInfCache,&head_list_entry,&last_list_entry,nMatchId)) {
                    Err = GetLastError();
                    goto cleanup;
                }
            }

        } else {
            MYASSERT(FALSE);
        }
    }

    //
    // now re-write the inf data with new flags & match patterns
    //
    inf_entry->MatchList = head_list_entry;
    if(!pStringTableSetExtraData(pInfCache->pInfTable,nInfIndex,inf_entry,sizeof(CACHEINFENTRY))) {
        MYASSERT(FALSE); // should not fail
    }
    return nInfIndex;

cleanup:

    pInfCache->bNoWriteBack = TRUE;
    MYASSERT(Err);
    SetLastError(Err);
    return -1;
}

#endif

#ifdef UNICODE

LONG InfCacheSearchTableLookup(
    IN OUT PINFCACHE pInfCache,
    IN PCTSTR filename,
    IN OUT PCACHEHITENTRY hitstats)
/*++

Routine Description:

    Looks up filename in the search table, returning search information
    if filename was not already in search table, it's added

Arguments:

    pInfCache - cache to modify
    filename - file to obtain hit-entry information for
    hitstats - information obtained (such as if this files been processed etc)

Return Value:

    index in search table (-1 if error)

--*/
{
    LONG nHitIndex;
    DWORD StringLength;

    MYASSERT(pInfCache);
    MYASSERT(filename);
    MYASSERT(hitstats);

    nHitIndex = pStringTableLookUpString(pInfCache->pSearchTable,
                                                    (PTSTR)filename, // filename wont be changed
                                                    &StringLength,
                                                    NULL, // hash value
                                                    NULL, // find context
                                                    STRTAB_CASE_INSENSITIVE,
                                                    hitstats,
                                                    sizeof(CACHEHITENTRY));

    if(nHitIndex < 0) {
        //
        // entirely new entry (hitstats expected to have a value)
        //
        nHitIndex = pStringTableAddString(pInfCache->pSearchTable,
                                                    (PTSTR)filename, // filename wont be changed
                                                    STRTAB_CASE_INSENSITIVE|STRTAB_NEW_EXTRADATA,
                                                    hitstats,
                                                    sizeof(CACHEHITENTRY));
        if (nHitIndex<0) {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return -1;
        }
    }

    return nHitIndex;
}

#endif

#ifdef UNICODE

ULONG InfCacheSearchTableSetFlags(
    IN OUT PINFCACHE pInfCache,
    IN PCTSTR filename,
    IN ULONG setflags,
    IN ULONG clrflags
    )
/*++

Routine Description:

    Modifies flags associated with a filename

Arguments:

    pInfCache - cache to modify
    filename - file to obtain hit-entry information for
    setflags - flags to set
    clrflags - flags to clear

Return Value:

    combined flags, or (ULONG)(-1) on error.

--*/
{
    CACHEHITENTRY searchentry;
    LONG nHitIndex;
    ULONG flags;

    MYASSERT(pInfCache);
    MYASSERT(filename);

    searchentry.Flags = setflags; // prime in case of new entry
    nHitIndex = InfCacheSearchTableLookup(pInfCache,filename,&searchentry);
    if(nHitIndex<0) {
        return (ULONG)(-1);
    }
    flags = (searchentry.Flags&~clrflags) | setflags;
    if (flags != searchentry.Flags) {
        searchentry.Flags = flags;
        if(!pStringTableSetExtraData(pInfCache->pSearchTable,nHitIndex,&searchentry,sizeof(searchentry))) {
            MYASSERT(FALSE); // should not fail
        }
    }
    return searchentry.Flags;
}

#endif

#ifdef UNICODE

DWORD InfCacheMarkMatchInfs(
    IN OUT PINFCACHE pInfCache,
    IN PCTSTR MatchString,
    IN ULONG MatchFlag
    )
/*++

Routine Description:

    Called to iterate through the INF's associated with MatchString
    and flag them using MatchFlag

Arguments:

    pInfCache - cache to check (may modify search data)
    MatchString - match string to include
    MatchFlag - flag to set in all INF's associated with match string

Return Value:

    status - typically NO_ERROR

--*/
{
    LONG MatchIndex;
    DWORD StringLength;
    CACHEMATCHENTRY matchentry;
    ULONG entry;
    PTSTR InfName;
    ULONG SearchFlags;

    MYASSERT(pInfCache);
    MYASSERT(MatchString);
    MYASSERT(MatchFlag);

    //
    // find list of Inf's associated with match string
    //
    MatchIndex = pStringTableLookUpString(pInfCache->pMatchTable,
                                                    (PTSTR)MatchString, // it will not be modified
                                                    &StringLength,
                                                    NULL, // hash value
                                                    NULL, // find context
                                                    STRTAB_CASE_INSENSITIVE,
                                                    &matchentry,
                                                    sizeof(matchentry));
    if(MatchIndex < 0) {
        //
        // no match
        //
        return NO_ERROR;
    }
    for(entry = matchentry.InfList ; entry > 0 && entry < pInfCache->pHeader->ListDataCount ; entry = pInfCache->pListTable[entry].Next) {
        LONG InfEntry = pInfCache->pListTable[entry].Value;
        //
        // obtain name of Inf
        //
        InfName = pStringTableStringFromId(pInfCache->pInfTable,InfEntry);
        SearchFlags = InfCacheSearchTableSetFlags(pInfCache,InfName,MatchFlag,0);
        if(SearchFlags == (ULONG)(-1)) {
            //
            // failed - huh?
            // abort into fail-safe pass
            //
            MYASSERT(SearchFlags != (ULONG)(-1));
            return GetLastError();
        }
    }
    return NO_ERROR;
}

#endif

#ifdef UNICODE

BOOL
InfCacheSearchEnum(
    IN PVOID  StringTable,
    IN LONG   StringId,
    IN PCTSTR String,
    IN PVOID  ExtraData,
    IN UINT   ExtraDataSize,
    IN LPARAM lParam
    )
/*++

Routine Description:

    Callback for Phase-3 of InfCacheSearchDirectory

Arguments:

    StringTable - unused
    StringId - unused
    String - used to form INF name
    ExtraData - points to flags
    ExtraDataSize - unused
    lParam - points to InfCacheEnumData

Return Value:

    always TRUE unless out of memory condition

--*/
{
    PINFCACHE_ENUMDATA enum_data = (PINFCACHE_ENUMDATA)lParam;
    CACHEHITENTRY *hit_stats = (CACHEHITENTRY *)ExtraData;
    PTSTR InfFullPath = NULL;
    DWORD InfFullPathSize;
    BOOL b;
    WIN32_FIND_DATA FindData;
    PLOADED_INF pInf = NULL;
    UINT ErrorLineNumber;
    BOOL PnfWasUsed;
    BOOL cont = TRUE;

    MYASSERT(ExtraDataSize == sizeof(CACHEHITENTRY));
    MYASSERT(String);
    MYASSERT(enum_data);
    MYASSERT(hit_stats);
    MYASSERT(enum_data->Requirement);
    MYASSERT(enum_data->Callback);

    //
    // see if this is an INF of interest
    //
    if((hit_stats->Flags & enum_data->Requirement) == enum_data->Requirement) {
        //
        // this is a HIT
        // we need to open HINF
        //
        InfFullPathSize = lstrlen(enum_data->InfDir)+MAX_PATH+2;
        InfFullPath = MyMalloc(InfFullPathSize*sizeof(TCHAR));
        if (!InfFullPath) {
            return TRUE; // out of memory (does not abort search)
        }
        lstrcpy(InfFullPath,enum_data->InfDir);
        pSetupConcatenatePaths(InfFullPath,String,InfFullPathSize,NULL);

        if(b = FileExists(InfFullPath, &FindData)) {

            if(LoadInfFile(InfFullPath,
                           &FindData,
                           INF_STYLE_WIN4 | INF_STYLE_OLDNT, // we've filtered this ourselves
                           LDINF_FLAG_IGNORE_VOLATILE_DIRIDS | LDINF_FLAG_ALWAYS_TRY_PNF,
                           NULL,
                           NULL,
                           NULL,
                           NULL,
                           enum_data->LogContext,
                           &pInf,
                           &ErrorLineNumber,
                           &PnfWasUsed) != NO_ERROR) {
                pInf = NULL;
                WriteLogEntry(
                            enum_data->LogContext,
                            DRIVER_LOG_VVERBOSE,
                            MSG_LOG_COULD_NOT_LOAD_HIT_INF,
                            NULL,
                            InfFullPath);
            }
        } else {
            pInf = NULL;
        }

        if (pInf) {
            cont = enum_data->Callback(enum_data->LogContext,InfFullPath,pInf,PnfWasUsed,enum_data->Context);
            if(!cont) {
                enum_data->ExitStatus = GetLastError();
                MYASSERT(enum_data->ExitStatus);
            }
            FreeInfFile(pInf);
        }
    }
    if (InfFullPath) {
        MyFree(InfFullPath);
    }

    return cont;
}

#endif

DWORD InfCacheSearchDirectory(
    IN PSETUP_LOG_CONTEXT LogContext, OPTIONAL
    IN DWORD Action,
    IN PCTSTR InfDir,
    IN InfCacheCallback Callback, OPTIONAL
    IN PVOID Context, OPTIONAL
    IN PCTSTR ClassIdList, OPTIONAL
    IN PCTSTR HwIdList OPTIONAL
    )
/*++

Routine Description:

    Main workhorse of the InfCache
    Search a single specified directory
    calling Callback(hInf,Context) for each inf that has a likelyhood of matching

    note that Action flags, ClassId and HwIdList are hints, and Callback may get
    called for any/all INF's Callback must re-check for all search criteria.

    Searching is done in 3 phases

    Phase 1: Parse all INF's in directory. If an INF is not in cache, *almost always* call
    callback. If special inclusions (OLD INF's INF's with no Class GUID's) specified, then
    INF's that match the special criteria are processed here (since they can't be processed
    in Phase 2). All INF's that exist, haven't been processed and haven't been excluded get
    marked with CHE_FLAGS_PENDING ready for phase-2

    Phase 2: Process ClassId and HwIdList matching, setting CHE_FLAGS_GUIDMATCH and
    CHE_FLAGS_IDMATCH apropriately in matching INF's and search criteria flags. Search
    criteria will either be:
    CHE_FLAGS_PENDING - callback on all Win4 style INF's
    CHE_FLAGS_PENDING | CHE_FLAGS_GUIDMATCH - callback on all Win4 INF's that have matching class
    CHE_FLAGS_PENDING | CHE_FLAGS_IDMATCH - wildcard class, matching hardware ID's
    CHE_FLAGS_PENDING | CHE_FLAGS_GUIDMATCH | CHE_FLAGS_IDMATCH - most specific match

    Phase 3: enumerate through all INF's that we've marked with exact same flags as
    search criteria, and call callback on those INF's

    Using this search method, Win4 INF's that are in the cache are always processed last.

Arguments:

    LogContext - for logging
    InfDir - single directory to search
    Callback - function to call on a likely match
    Context - parameter to pass to function
    ClassIdList (optional) - multi-sz list of class id's (typically guid, name and legacy name)
    HwIdList (optional)- multi-sz list of hardware id's


Return Value:

    status, typically NO_ERROR

--*/
{
    PINFCACHE pInfCache = NULL;
    PTSTR InfPath = NULL;
    UINT PathSize;
    DWORD Err = NO_ERROR;
    WIN32_FIND_DATA FindFileData;
    HANDLE FindHandle = INVALID_HANDLE_VALUE;
    BOOL bNoWriteBack = FALSE;
    LONG InfId;
    LONG SearchId;
    ULONG SearchFlags;
    CACHEINFENTRY inf_entry;
    CACHEHITENTRY hit_stats;
    ULONG ReqFlags;
    INFCACHE_ENUMDATA enum_data;
    PSETUP_LOG_CONTEXT LocalLogContext = NULL;
    BOOL TryPnf = FALSE;
    BOOL TryCache = FALSE;
    FILETIME   FileTimeNow;
    FILETIME   FileTimeBefore;
    FILETIME   FileTimeAfter;

    MYASSERT(InfDir);

    //
    // obtain cache for directory of interest
    // we should be able to handle a NULL return
    // note that caller can either treat these two bits
    // as an operation (0-3) or as bitmaps
    // the result would be the same
    //

    if(!LogContext) {
        if(CreateLogContext(NULL,TRUE,&LocalLogContext)==NO_ERROR) {
            LogContext = LocalLogContext;
        } else {
            LocalLogContext = NULL;
            Err = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
    }

    WriteLogEntry(
                LogContext,
                DRIVER_LOG_VVERBOSE,
                MSG_LOG_ENUMERATING_FILES,
                NULL,
                InfDir);

    PathSize = lstrlen(InfDir)+10;
    InfPath = MyMalloc(PathSize*sizeof(TCHAR));
    if(!InfPath) {
        Err = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }
    lstrcpy(InfPath,InfDir);
    pSetupConcatenatePaths(InfPath,INFCACHE_INF_WILDCARD,PathSize,NULL);

#ifdef UNICODE
    if (pSetupInfIsFromOemLocation(InfPath,FALSE)) {
        if (Action & INFCACHE_FORCE_CACHE) {
            TryCache = TRUE;
        }
        if (Action & INFCACHE_FORCE_PNF) {
            TryPnf = TRUE;
        }
    } else {

        TryPnf = TRUE;

        //
        // Try using INF cache unless we're doing an INFCACHE_ENUMALL
        //
        if((Action & INFCACHE_ACTIONBITS) != INFCACHE_ENUMALL) {
            TryCache = TRUE;
        }
    }
    if (!TryCache) {
        //
        // directory is not in our default search path
        // treat as INFCACHE_ENUMALL
        //
        pInfCache = NULL;
    } else {
        switch(Action & INFCACHE_ACTIONBITS) {
            case INFCACHE_NOWRITE:
                pInfCache = InfCacheLoadCache(InfDir,LogContext);
                bNoWriteBack = TRUE;
                break;
            case INFCACHE_DEFAULT:
                pInfCache = InfCacheLoadCache(InfDir,LogContext);
                break;
            case INFCACHE_REBUILD:
                pInfCache = InfCacheCreateNewCache(LogContext);
                break;
            case INFCACHE_ENUMALL:
                pInfCache = NULL;
                break;
            default:
                MYASSERT(FALSE);
        }
    }
#else
    pInfCache = NULL;
#endif

    //
    // if an INF is changed, we will withhold writing back within 5 seconds
    // this ensures that a file stamped by InfCacheAwareCopyFile can get
    // modified again within the 2 second or so window where it may get
    // the same timestamp, but without us "freezing" any changes
    //
    GetSystemTimeAsFileTime(&FileTimeNow);
    AddFileTimeSeconds(&FileTimeNow,&FileTimeBefore,-5);
    AddFileTimeSeconds(&FileTimeNow,&FileTimeAfter,5);

    //
    // first phase - enumerate the INF directory
    //
    FindHandle = FindFirstFile(InfPath,&FindFileData);
    if(FindHandle != INVALID_HANDLE_VALUE) {
        do {
            BOOL NewInf = FALSE;
            BOOL bCallCallback = FALSE;
            PLOADED_INF pInf = NULL;
            UINT ErrorLineNumber;
            BOOL PnfWasUsed;

#ifdef UNICODE
            if(!pInfCache || pInfCache->bNoWriteBack) {
                //
                // fallen into failsafe mode
                //
                bCallCallback = TRUE;
            } else if((CompareFileTime(&FindFileData.ftLastWriteTime,&FileTimeBefore)>0)
                                     && (CompareFileTime(&FindFileData.ftLastWriteTime,&FileTimeAfter)<0)) {
                //
                // if actual file time falls close to now, then
                // we don't trust it
                // force it to be deleted out of the cache
                // and make sure we do a callback
                //
                // if there's an entry in the cache, we want to invalidate it
                // - this is particularly important if we're being called to
                // recreate the cache
                //
                InfId = InfCacheLookupInf(pInfCache,&FindFileData,&inf_entry);
                if(InfId>=0) {
                    //
                    // there was a match
                    //
                    InfCacheRemoveInf(pInfCache,InfId,&inf_entry);
                    InfId = -1;
                }
                bCallCallback = TRUE;
                NewInf = FALSE;
                WriteLogEntry(
                            LogContext,
                            DRIVER_LOG_VERBOSE,
                            MSG_LOG_CACHE_TIMEFRAME,
                            NULL,
                            FindFileData.cFileName);

            } else {


                //
                // mark this INF as existing
                //
                SearchFlags = InfCacheSearchTableSetFlags(pInfCache,
                                                    FindFileData.cFileName,
                                                        CHE_FLAGS_PENDING, // start off expecting this INF to be processed later
                                                    0);
                if(SearchFlags == (ULONG)(-1)) {
                    //
                    // failed - handle here
                    //
                    bCallCallback = TRUE;
                }
                InfId = InfCacheLookupInf(pInfCache,&FindFileData,&inf_entry);
                if (InfId<0) {
                    NewInf = TRUE;
                } else {
#if 0
                    //
                    // handle special inclusions (we can't handle these in Phase 2)
                    //
                    if (((Action&INFCACHE_INC_OLDINFS) && (inf_entry.MatchFlags&CIEF_INF_OLDINF)) ||
                        ((Action&INFCACHE_INC_NOCLASS) && (inf_entry.MatchFlags&CIEF_INF_NOCLASS))) {
                        bCallCallback = TRUE;
                    }
#endif
                    //
                    // handle exclusions (so that they will get excluded in Phase 2)
                    // exclusions are different for OLDNT and WIN4
                    //
                    if (inf_entry.MatchFlags & CIEF_INF_WIN4) {
                        //
                        // WIN4 INF
                        //
                        if(((Action & INFCACHE_EXC_URL) && (inf_entry.MatchFlags & CIEF_INF_URL)) ||
                           ((Action & INFCACHE_EXC_NULLCLASS) && (inf_entry.MatchFlags & CIEF_INF_NULLGUID)) ||
                           ((Action & INFCACHE_EXC_NOMANU) && !(inf_entry.MatchFlags & CIEF_INF_MANUFACTURER)) ||
                           ((Action & INFCACHE_EXC_NOCLASS) && !(inf_entry.MatchFlags & CIEF_INF_CLASSINFO))) {
                            //
                            // exclude this INF
                            //
                            InfCacheSearchTableSetFlags(pInfCache,
                                                        FindFileData.cFileName,
                                                        0,
                                                        CHE_FLAGS_PENDING);
                            WriteLogEntry(
                                        LogContext,
                                        DRIVER_LOG_VVERBOSE,
                                        MSG_LOG_EXCLUDE_WIN4_INF,
                                        NULL,
                                        FindFileData.cFileName);
                        }

                    } else if (inf_entry.MatchList & CIEF_INF_OLDNT) {

                        if((Action & INFCACHE_EXC_OLDINFS) ||
                           ((Action & INFCACHE_EXC_NOCLASS) && !(inf_entry.MatchList & CIEF_INF_CLASSINFO))) {
                            //
                            // exclude this INF
                            //
                            InfCacheSearchTableSetFlags(pInfCache,
                                                        FindFileData.cFileName,
                                                        0,
                                                        CHE_FLAGS_PENDING);
                            WriteLogEntry(
                                        LogContext,
                                        DRIVER_LOG_VVERBOSE,
                                        MSG_LOG_EXCLUDE_OLDNT_INF,
                                        NULL,
                                        FindFileData.cFileName);
                        } else {
                            //
                            // allow old INF's to match with any HwId's
                            // by considering it already matched
                            //
                            InfCacheSearchTableSetFlags(pInfCache,
                                                        FindFileData.cFileName,
                                                        CHE_FLAGS_IDMATCH,
                                                        0);
                        }
                    } else {
                        //
                        // always exclude non-inf's
                        //
                        InfCacheSearchTableSetFlags(pInfCache,
                                                    FindFileData.cFileName,
                                                    0,
                                                    CHE_FLAGS_PENDING);
                    }
                }
            }
#else
            bCallCallback = TRUE; // Win9x
#endif
            if (!Callback) {
                //
                // we were only called to re-build the cache
                //
                bCallCallback = FALSE;
            }
            if (NewInf || bCallCallback) {
                PTSTR InfFullPath = NULL;
                DWORD InfFullPathSize = lstrlen(InfDir)+MAX_PATH+2;

                //
                // we need to open HINF in either case
                //
                InfFullPath = MyMalloc(InfFullPathSize*sizeof(TCHAR));
                if(InfFullPath == NULL) {
                    //
                    // carry on with other files, even if out of memory
                    // not the best thing to do, but consistant with
                    // what we did before.
                    //
                    continue;
                }
                lstrcpy(InfFullPath,InfDir);
                pSetupConcatenatePaths(InfFullPath,FindFileData.cFileName,InfFullPathSize,NULL);

                if((Err=LoadInfFile(InfFullPath,
                               &FindFileData,
                               INF_STYLE_WIN4 | INF_STYLE_OLDNT, // we'll filter this ourselves
                               LDINF_FLAG_IGNORE_VOLATILE_DIRIDS | (TryPnf?LDINF_FLAG_ALWAYS_TRY_PNF:0),
                               NULL,
                               NULL,
                               NULL,
                               NULL,
                               LogContext,
                               &pInf,
                               &ErrorLineNumber,
                               &PnfWasUsed)) != NO_ERROR) {
                    pInf = NULL;
                    WriteLogEntry(
                                LogContext,
                                DRIVER_LOG_VVERBOSE,
                                MSG_LOG_COULD_NOT_LOAD_NEW_INF,
                                NULL,
                                InfFullPath);
                }

#ifdef UNICODE
                if(NewInf) {
                    //
                    // if opening the INF failed, we still want to record this fact
                    // in the cache so we don't try to re-open next time round
                    //
                    InfId = InfCacheAddInf(LogContext,pInfCache,&FindFileData,&inf_entry,pInf);

                    if(Callback) {
                        bCallCallback = TRUE;
                    }
                }
#endif
                if (pInf) {
                    if (bCallCallback && Callback) {
                        //
                        // we're processing the INF now
                        // clear pending flag (if we can) so we don't try and process INF a 2nd time
                        // the only time this can fail is if we haven't already added the INF
                        // so either way we wont callback twice
                        //
#ifdef UNICODE
                        if (pInfCache) {
                            //
                            // only set flags in the cache
                            // if we have a cache :-)
                            //
                            InfCacheSearchTableSetFlags(pInfCache,FindFileData.cFileName,0,CHE_FLAGS_PENDING);
                        }
#endif
                        if(!Callback(LogContext,InfFullPath,pInf,PnfWasUsed,Context)) {
                            Err = GetLastError();
                            MYASSERT(Err);
                            FreeInfFile(pInf);
                            MyFree(InfFullPath);
                            goto cleanup;
                        }
                    }
                    FreeInfFile(pInf);
                }
                MyFree(InfFullPath);
            }

        } while (FindNextFile(FindHandle,&FindFileData));
        FindClose(FindHandle);
    }

    if (!pInfCache) {
        //
        // we have processed all files already
        // skip cache search code, since we don't
        // have a cache to search
        //
        Err = NO_ERROR;
        goto cleanup;
    }

#ifdef UNICODE
    //
    // at this point we can commit cache
    //
    WriteLogEntry(
                LogContext,
                DRIVER_LOG_TIME,
                MSG_LOG_END_CACHE_1,
                NULL);

    if(pInfCache && !bNoWriteBack) {
        InfCacheWriteCache(InfDir,pInfCache,LogContext);
    }

    if (!Callback) {
        //
        // optimization: no callback
        // (we were only called, eg, to update cache)
        // leave early
        //
        Err = NO_ERROR;
        goto cleanup;
    }

    //
    // Phase 2 - determine all other INF's to process via Cache
    //
    // will want INFs that exist, haven't yet been processed
    // and haven't been excluded
    //

    ReqFlags = CHE_FLAGS_PENDING;

    if (ClassIdList && ClassIdList[0]) {

        PCTSTR ClassId;

        //
        // Primary list (typically Class GUID, Class Name and Legacy Class Name)
        //
        Err = NO_ERROR;
        for(ClassId = ClassIdList;*ClassId;ClassId += lstrlen(ClassId)+1) {
            Err = InfCacheMarkMatchInfs(pInfCache,ClassId,CHE_FLAGS_GUIDMATCH);
            if (Err != NO_ERROR) {
                break;
            }
        }
        if (Err == NO_ERROR) {
            //
            // succeeded, restrict requirement
            //
            ReqFlags |= CHE_FLAGS_GUIDMATCH;
        }
    }
    if (HwIdList && HwIdList[0]) {

        PCTSTR HwId;

        //
        // Secondary list
        // if a list of hardware Id's specified, we only want hits that include
        // any of the hardware Id's
        //
        Err = NO_ERROR;
        for(HwId = HwIdList;*HwId;HwId += lstrlen(HwId)+1) {
            Err = InfCacheMarkMatchInfs(pInfCache,HwId,CHE_FLAGS_IDMATCH);
            if(Err != NO_ERROR) {
                break;
            }
        }
        if (Err == NO_ERROR) {
            //
            // succeeded, restrict requirement
            //
            ReqFlags |= CHE_FLAGS_IDMATCH;
        }
    }

    //
    // Phase 3 - process all INF's that meet requirements
    // do this by simply enumerating the search string table
    //
    enum_data.LogContext = LogContext;
    enum_data.Callback = Callback;
    enum_data.Context = Context;
    enum_data.InfDir = InfDir;
    enum_data.Requirement = ReqFlags;
    enum_data.ExitStatus = NO_ERROR;

    Err = NO_ERROR;
    if(!pStringTableEnum(pInfCache->pSearchTable,
                        &hit_stats,
                        sizeof(hit_stats),
                        InfCacheSearchEnum,
                        (LPARAM)&enum_data)) {
        //
        // we'll only fail for error condition
        //

        Err = enum_data.ExitStatus;
    }

    WriteLogEntry(
                LogContext,
                DRIVER_LOG_TIME,
                MSG_LOG_END_CACHE_2,
                NULL);


#else

    Err = NO_ERROR;

#endif

cleanup:

#ifdef UNICODE
    if (pInfCache) {
        InfCacheFreeCache(pInfCache);
    }
#endif
    if (InfPath) {
        MyFree(InfPath);
    }
    if (LogContext && LocalLogContext) {
        DeleteLogContext(LocalLogContext);
    }

    return Err;
}


DWORD InfCacheSearchPath(
    IN PSETUP_LOG_CONTEXT LogContext, OPTIONAL
    IN DWORD Action,
    IN PCTSTR InfDirPath, OPTIONAL
    IN InfCacheCallback Callback, OPTIONAL
    IN PVOID Context, OPTIONAL
    IN PCTSTR ClassIdList, OPTIONAL
    IN PCTSTR HwIdList OPTIONAL
    )
/*++

Routine Description:

    Iterates InfDirPath calling InfCacheSearchDirectory for each entry

Arguments:

    LogContext - for logging
    InfDir - single directory to search - if not specified, uses driver path
    Callback - function to call on a likely match
    Context - parameter to pass to function
    ClassIdList (optional) - multi-sz list of class id's (typically guid, name and legacy name)
    HwIdList (optional)- multi-sz list of hardware id's


Return Value:

    status, typically NO_ERROR

--*/
{

    PSETUP_LOG_CONTEXT LocalLogContext = NULL;
    DWORD Err = NO_ERROR;
    PCTSTR InfDir;

    if (!InfDirPath) {
        InfDirPath = InfSearchPaths;
    }

    if(!LogContext) {
        if(CreateLogContext(NULL,TRUE,&LocalLogContext)==NO_ERROR) {
            LogContext = LocalLogContext;
        } else {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    for (InfDir = InfDirPath; *InfDir; InfDir+=lstrlen(InfDir)+1) {
        Err = InfCacheSearchDirectory(LogContext,Action,InfDir,Callback,Context,ClassIdList,HwIdList);
        if(Err != NO_ERROR) {
            break;
        }
    }

    if (LogContext && LocalLogContext) {
        DeleteLogContext(LocalLogContext);
    }

    return Err;
}

#ifdef UNICODE

BOOL WINAPI pSetupInfCacheBuild(
    IN DWORD Action
    )
/*++

Routine Description:

    Privately exported, called from (eg) syssetup to reset cache(s)

Arguments:

    Action - one of:
        INFCACHEBUILD_UPDATE
        INFCACHEBUILD_REBUILD

Return Value:

    TRUE if success, FALSE on Error (GetLastError indicates error)

--*/
{
    DWORD RealAction;
    DWORD Err;

    switch(Action) {
        case INFCACHEBUILD_UPDATE:
            RealAction = INFCACHE_DEFAULT;
            break;
        case INFCACHEBUILD_REBUILD:
            RealAction = INFCACHE_REBUILD;
            break;
        default:
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
    }
    RealAction |= INFCACHE_FORCE_CACHE|INFCACHE_FORCE_PNF;

    try {
        Err = InfCacheSearchPath(NULL,
                                    RealAction,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL
                                    );
    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_DATA;
    }
    SetLastError(Err);

    return Err==NO_ERROR;
}

#endif

BOOL
InfCacheAwareCopyFile(
    IN LPCTSTR Source,
    IN LPCTSTR Target
    )
{
#ifdef UNICODE
    FILETIME   FileTimeNow;

    //
    // we use the uniqueness of the timestamp on the INF to
    // know if an INF has been modified
    // it appears that some vendors decide to "touch" the timestamp
    // on related INF's that throws INFCACHE
    //
    // it's possible that InfCacheAwareCopyFile might get called for the same
    // filename (different file) multiple times over a 2 second interval
    // the InfCache code above will not trust a file to be stable until
    // 5 seconds has elapsed, in which case modifications will have new
    // timestamps
    //

    //
    // what's our current time?
    //
    if(!CopyFile(Source, Target, FALSE)) {
        return FALSE;
    }
    GetSystemTimeAsFileTime(&FileTimeNow);
    //
    // update time-stamp effectively invalidates the entry in INFCACHE
    // this file will not be 'comitted' to cache for at least another 5
    // seconds
    //
    GetSetFileTimestamp(Target,NULL,NULL,&FileTimeNow,TRUE);
    return TRUE;

#else
    return CopyFile(Source,Target,FALSE);
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\setupapi\infcache.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    infcache.h

Abstract:

    Private header for INFCACHE functions/structures
    (See also infcache.c)

Author:

    Jamie Hunter (jamiehun) Jan-27-2000

Revision History:

--*/

#define INFCACHE_VERSION (1)                // increment for every schema change
#define INFCACHE_NAME_TEMPLATE TEXT("INFCACHE.%d")   // name of cache file (number fills last 3 digits)
#define OLDCACHE_NAME_TEMPLATE TEXT("OLDCACHE.%03d")   // old cache file
#define INFCACHE_INF_WILDCARD  TEXT("*.inf")

//
// file layout is:
//
// CACHEHEADER
// <MatchTable>
// <InfTable>
// <ListData>
//
// file size = sizeof(CACHEHEADER) + MatchTableSize + InfTableSize + ListDataCount*sizeof(CACHELISTENTRY)
// first entry of <ListData> is reference to free-list
//

#include "pshpack1.h"

typedef struct tag_CACHEHEADER {
    ULONG Version;                          // indicates file schema
    LCID Locale;                            // locale (as written)
    DWORD Flags;                            // various flags
    ULONG FileSize;                         // size of file, including header
    ULONG MatchTableOffset;                 // offset of match table portion (allowing for alignment)
    ULONG MatchTableSize;                   // size of match table portion
    ULONG InfTableOffset;                   // offset of inf table portion (allowing for alignment)
    ULONG InfTableSize;                     // size of inf table portion
    ULONG ListDataOffset;                   // offset of list data portion (allowing for alignment)
    ULONG ListDataCount;                    // number of list data items
} CACHEHEADER, * PCACHEHEADER;

//
// MatchTable datum
//
typedef struct tag_CACHEMATCHENTRY {
    ULONG InfList;                          // index into ListTable of list of "hit" INFs
} CACHEMATCHENTRY, * PCACHEMATCHENTRY;

//
// InfTable datum
//
typedef struct tag_CACHEINFENTRY {
    FILETIME FileTime;                      // exactly same as FileTime saved in PNF
    ULONG MatchList;                        // into ListTable (first entry is GUID) cross-link of references to INF
    ULONG MatchFlags;                       // various flags to help expand/reduce search criteria
} CACHEINFENTRY, * PCACHEINFENTRY;
//
// special MatchList values
//
#define CIE_INF_INVALID         (ULONG)(-1) // indicates INF entry is outdated

#define CIEF_INF_NOTINF         0           // if flags is zero, this is not a valid INF
#define CIEF_INF_OLDNT          0x00000001  // indicates INF is old-style (Style == INF_STYLE_OLDNT)
#define CIEF_INF_WIN4           0x00000002  // indicates INF is Win4 style (Style == INF_STYLE_WIN4)
#define CIEF_INF_ISINF          (CIEF_INF_OLDNT|CIEF_INF_WIN4)
#define CIEF_INF_URL            0x00000004  // indicates INF InfSourceMediaType == SPOST_URL
#define CIEF_INF_CLASSNAME      0x00000008  // indicates INF has a Class Name (or Legacy name if OLDNT)
#define CIEF_INF_CLASSGUID      0x00000010  // indicates INF has a Class GUID
#define CIEF_INF_CLASSINFO      (CIEF_INF_CLASSNAME|CIEF_INF_CLASSGUID)
#define CIEF_INF_NULLGUID       0x00000020  // indicates INF has a Class GUID of {0}
#define CIEF_INF_MANUFACTURER   0x00000040  // indicates INF has at least one manufacturer

//
// CacheList datum
//
typedef struct tag_CACHELISTENTRY {
    LONG Value;                             // Typically StringID. For HWID/GUID, index into MatchTable. for INF, index into InfTable
    ULONG Next;                             // index to next entry
} CACHELISTENTRY, * PCACHELISTENTRY;

#include "poppack.h"

//
// Run-Time cache information
//

typedef struct tag_INFCACHE {
    HANDLE FileHandle;                      // information regarding the in-memory image of the cache file
    HANDLE MappingHandle;
    PVOID BaseAddress;

    PCACHEHEADER pHeader;                   // pointer to header in file image
    PVOID pMatchTable;                      // pointer to match table
    PVOID pInfTable;                        // pointer to inf table
    PCACHELISTENTRY pListTable;             // pointer to list table
    ULONG ListDataAlloc;                    // how much space is allocated, >= ListDataCount
    PVOID pSearchTable;                     // transient table to handle search state
    BOOL bReadOnly;                         // set if this is mapped, unset if allocated
    BOOL bDirty;                            // set if modified
    BOOL bNoWriteBack;                      // set if we shouldn't write cache (a failure occured so cache isn't good)
} INFCACHE, * PINFCACHE;

#define CHE_FLAGS_PENDING     0x00000001    // set if file is yet to be processed
#define CHE_FLAGS_GUIDMATCH   0x00000002    // set if during search pass we consider this a GUID MATCH
#define CHE_FLAGS_IDMATCH     0x00000004    // set if during search pass we got at least one ID MATCH

//
// SearchTable data
//
typedef struct tag_CACHEHITENTRY {
    ULONG Flags;                            // CHE_FLAGS_xxxx
} CACHEHITENTRY, * PCACHEHITENTRY;

//
// callback
//
typedef BOOL (CALLBACK * InfCacheCallback)(
    IN PSETUP_LOG_CONTEXT LogContext,
    IN PCTSTR InfPath,
    IN PLOADED_INF pInf,
    IN BOOL PnfWasUsed,
    IN PVOID Context
    );

//
// stringtable callback for INF enumeration
//
typedef struct tag_INFCACHE_ENUMDATA {
    PSETUP_LOG_CONTEXT LogContext;
    PCTSTR InfDir;
    InfCacheCallback Callback;
    PVOID Context;
    ULONG Requirement;
    DWORD ExitStatus;
} INFCACHE_ENUMDATA, *PINFCACHE_ENUMDATA;

//
// action flags
//
#define INFCACHE_DEFAULT     0x00000000      // default operation
#define INFCACHE_REBUILD     0x00000001      // ignore existing cache
#define INFCACHE_NOWRITE     0x00000002      // don't write back
#define INFCACHE_ENUMALL     0x00000003      // special combination, just enum all
#define INFCACHE_ACTIONBITS  0x000000FF      // primary action bits

#define INFCACHE_EXC_OLDINFS   0x00000100    // exclude INFs that are OLDNT
#define INFCACHE_EXC_URL       0x00000200    // exclude INFs that are marked SPOST_URL
#define INFCACHE_EXC_NOCLASS   0x00000400    // excludes INFs that has no class information
#define INFCACHE_EXC_NULLCLASS 0x00000800    // excludes INFs that has null class
#define INFCACHE_EXC_NOMANU    0x00001000    // excludes INFs that has no (or empty) [Manufacturers] - ignored for OLDNT

#define INFCACHE_FORCE_CACHE 0X00010000      // (try and) force cache creating even if "OEM dir"
#define INFCACHE_FORCE_PNF   0X00020000      // (try and) force PNF creating even if "OEM dir"


DWORD InfCacheSearchPath(
    IN PSETUP_LOG_CONTEXT LogContext, OPTIONAL
    IN DWORD Action,
    IN PCTSTR InfDirPath, OPTIONAL
    IN InfCacheCallback Callback, OPTIONAL
    IN PVOID Context, OPTIONAL
    IN PCTSTR ClassId, OPTIONAL
    IN PCTSTR HwIdList OPTIONAL
    );

BOOL
InfCacheAwareCopyFile(
    IN LPCTSTR Source,
    IN LPCTSTR Target
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\setupapi\infflist.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    infflist.c

Abstract:

    Externally exposed routines for manipulating file lists,
    disk descriptors, and directory descriptors in INF files.

Author:

    Ted Miller (tedm) 3-Feb-1995

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include <winspool.h>

//
// Locations of various fields on lines in a copy section.
// First field is 'target' filename.
// Second field is 'source' filename and is optional for copy sections
// and not used at all in delete sections.
#define COPYSECT_TARGET_FILENAME    1
#define COPYSECT_SOURCE_FILENAME    2

//
// Locations of various fields on lines in a file layout section.
//
#define LAYOUTSECT_FILENAME     0       // key
#define LAYOUTSECT_DISKID       1
#define LAYOUTSECT_SUBDIR       2
#define LAYOUTSECT_SIZE         3
#define LAYOUTSECT_CHECKSUM     4

//
// Locations of various fields on lines in a [DestinationDirs] section.
//
#define DIRSECT_DIRID           1
#define DIRSECT_SUBDIR          2


//
// Names of various sections in an INF.
// (string constants defined in infstr.h)
//
CONST TCHAR pszSourceDisksNames[] = SZ_KEY_SRCDISKNAMES,
            pszSourceDisksFiles[] = SZ_KEY_SRCDISKFILES,
            pszDestinationDirs[]  = SZ_KEY_DESTDIRS,
            pszDefaultDestDir[]   = SZ_KEY_DEFDESTDIR;


BOOL
_SetupGetSourceFileLocation(
    IN  HINF                    InfHandle,
    IN  PINFCONTEXT             InfContext,       OPTIONAL
    IN  PCTSTR                  FileName,         OPTIONAL
    IN  PSP_ALTPLATFORM_INFO_V2 AltPlatformInfo,  OPTIONAL
    OUT PUINT                   SourceId,         OPTIONAL
    OUT PTSTR                   ReturnBuffer,     OPTIONAL
    IN  DWORD                   ReturnBufferSize,
    OUT PDWORD                  RequiredSize,     OPTIONAL
    OUT PINFCONTEXT             LineContext       OPTIONAL
    )

/*++

Routine Description:

    Determine the location of a source file, as listed in an inf file.

Arguments:

    InfHandle - supplies the handle to a loaded inf file that contains
        file layout information, ie, has [SourceDisksNames] and
        [SourceDisksFiles] sections.

    InfContext - specifies a line in a copy section of an inf file
        for which the full source path is to be retreived. If this
        parameter is not specified, then FileName will be searched for
        in the [SourceDisksFiles] section of the INF specified by InfHandle.

    FileName - supplies the filename (no path) for which to return the
        full source location. Must be specified if InfContext is not.

    AltPlatformInfo - optionally, supplies alternate platform to be used
        when looking for decorated [SourceDisksFiles] section.

    SourceId - receives the source id of the source media where the
        file is located. This parameter may be NULL if this information
        is not desired.

    ReturnBuffer - receives the source path (relative to the source LDD).
        This path contains neither a drivespec nor the filename itself.
        The path never starts or ends with \, so the empty string
        means the root.

    ReturnBufferSize - specified the size in characters of the buffer
        pointed to by ReturnBuffer.

    RequiredSize - receives the number of characters required
        in ReturnBuffer. If the buffer is too small GetLastError
        returns ERROR_INSUFFICIENT_BUFFER.

Return Value:

    Boolean value indicating outcome.

--*/

{
    PCTSTR fileName, PlatformName;
    INFCONTEXT DecContext;
    INFCONTEXT UnDecContext;
    PINFCONTEXT lineContext;
    UINT Length;
    PCTSTR SubDir;
    TCHAR FileListSectionName[64];
    BOOL bDec = FALSE;
    BOOL bUnDec = FALSE;

    //
    // If caller gave a line context, the first field on the line
    // is the filename. Retreive it.
    //
    try {
        fileName = InfContext ? pSetupGetField(InfContext,COPYSECT_TARGET_FILENAME) : FileName;
    } except(EXCEPTION_EXECUTE_HANDLER) {
        //
        // InfContext must be a bad pointer
        //
        fileName = NULL;
    }

    if(!fileName) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    //
    // Now look for the filename's line in the [SourceDisksFiles] section.
    // Look in the platform-specific one first and the platform-independent
    // one if not found.
    //
    if(AltPlatformInfo) {

        switch(AltPlatformInfo->ProcessorArchitecture) {

            case PROCESSOR_ARCHITECTURE_INTEL :
                PlatformName = pszX86SrcDiskSuffix;
                break;

            case PROCESSOR_ARCHITECTURE_IA64 :
                PlatformName = pszIa64SrcDiskSuffix;
                break;

            case PROCESSOR_ARCHITECTURE_AMD64 :
                PlatformName = pszAmd64SrcDiskSuffix;
                break;

            default :
                //
                // unknown/unsupported processor architecture.
                //
                MYASSERT((AltPlatformInfo->ProcessorArchitecture == PROCESSOR_ARCHITECTURE_INTEL) ||
                         (AltPlatformInfo->ProcessorArchitecture == PROCESSOR_ARCHITECTURE_IA64)  ||
                         (AltPlatformInfo->ProcessorArchitecture == PROCESSOR_ARCHITECTURE_AMD64)
                        );

                SetLastError(ERROR_INVALID_PARAMETER);
                return(FALSE);
        }

    } else {
        PlatformName = pszPlatformSrcDiskSuffix;
    }

    wnsprintf(FileListSectionName,
               SIZECHARS(FileListSectionName),
               TEXT("%s.%s"),
               pszSourceDisksFiles,
               PlatformName
              );

    bDec = SetupFindFirstLine(InfHandle,FileListSectionName,fileName,&DecContext);
    if(bDec && (DecContext.CurrentInf == InfHandle)) {
        //
        // found Decorated section in same INF as source file
        //
        lineContext = &DecContext;
    } else {
        //
        // didn't find decorated section in expected INF, try undecorated in expected INF
        //
        bUnDec = SetupFindFirstLine(InfHandle,pszSourceDisksFiles,fileName,&UnDecContext);
        if(bUnDec  && (UnDecContext.CurrentInf == InfHandle)) {
            //
            // found in Undecorated section in same INF as source file
            //
            lineContext = &UnDecContext;
        } else if(bDec) {
            //
            // any decorated section (should only be one)
            //
            lineContext = &DecContext;
        } else if(bUnDec) {
            //
            // any undecorated section (should only be one)
            //
            lineContext = &UnDecContext;
        } else {
            //
            // none found
            //
            SetLastError(ERROR_LINE_NOT_FOUND);
            return(FALSE);
        }
    }

    //
    // Got the line. If the caller wants it, give it to him.
    // We don't guard this with try/except because this routine is internal
    // and any fault is a bug in the caller.
    //
    if(LineContext) {
        *LineContext = *lineContext;
    }

    //
    // Get the disk id.
    //
    if(SourceId) {
        if(!SetupGetIntField(lineContext,LAYOUTSECT_DISKID,SourceId)) {
            SetLastError(ERROR_INVALID_DATA);
            return(FALSE);
        }
    }

    //
    // If all the caller was interested in was the disk ID (i.e., they passed in ReturnBuffer
    // and RequiredSize both as NULL), then we can save the extra work and return now.
    //
    if(!(ReturnBuffer || RequiredSize)) {
        return TRUE;
    }

    //
    // Now get the path relative to the LDD.
    //
    SubDir = pSetupGetField(lineContext,LAYOUTSECT_SUBDIR);
    if(!SubDir) {
        SubDir = TEXT("");
    }

    Length = lstrlen(SubDir);

    //
    // Ignore leading path sep if present.
    //
    if(SubDir[0] == TEXT('\\')) {
        Length--;
        SubDir++;
    }

    //
    // See if there's a trailing path sep.
    //
    if(Length && *CharPrev(SubDir,SubDir+Length) == TEXT('\\')) {
        Length--;
    }

    //
    // Leave space for the nul
    //
    if(RequiredSize) {
        *RequiredSize = Length+1;
    }

    //
    // Place data in caller's buffer.
    // If caller didn't specify a buffer we're done.
    //
    if(ReturnBuffer) {
        if(ReturnBufferSize <= Length) {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            return(FALSE);
        }

        //
        // Don't use lstrcpy, because if we are stripping
        // a trailing path sep, lstrcpy could write the nul byte
        // past the end of the buffer.
        //
        CopyMemory(ReturnBuffer,SubDir,Length*sizeof(TCHAR));
        ReturnBuffer[Length] = 0;
    }

    return(TRUE);
}

#ifdef UNICODE
//
// ANSI version
//
BOOL
SetupGetSourceFileLocationA(
    IN  HINF        InfHandle,
    IN  PINFCONTEXT InfContext,       OPTIONAL
    IN  PCSTR       FileName,         OPTIONAL
    OUT PUINT       SourceId,
    OUT PSTR        ReturnBuffer,     OPTIONAL
    IN  DWORD       ReturnBufferSize,
    OUT PDWORD      RequiredSize      OPTIONAL
    )
{
    WCHAR returnbuffer[MAX_PATH];
    DWORD requiredsize;
    PCWSTR filename;
    UINT sourceid;
    DWORD rc;
    BOOL b;
    PCSTR ansireturn;

    rc = NO_ERROR;
    if(FileName) {
        rc = pSetupCaptureAndConvertAnsiArg(FileName,&filename);
        if(rc != NO_ERROR) {
            SetLastError(rc);
            return(FALSE);
        }
    } else {
        filename = NULL;
    }

    b = _SetupGetSourceFileLocation(
            InfHandle,
            InfContext,
            filename,
            NULL,
            &sourceid,
            returnbuffer,
            MAX_PATH,
            &requiredsize,
            NULL
            );

    rc = GetLastError();

    if(b) {
        rc = NO_ERROR;

        if(ansireturn = pSetupUnicodeToAnsi(returnbuffer)) {

            requiredsize = lstrlenA(ansireturn)+1;

            try {
                *SourceId = sourceid;
                if(RequiredSize) {
                    *RequiredSize = requiredsize;
                }
            } except(EXCEPTION_EXECUTE_HANDLER) {
                rc = ERROR_INVALID_PARAMETER;
                b = FALSE;
            }

            if(rc == NO_ERROR) {

                if(ReturnBuffer) {

                    if(requiredsize <= ReturnBufferSize) {

                        //
                        // lstrcpy won't generate an exception on NT even if
                        // ReturnBuffer is invalid, but will return NULL
                        //
                        try {
                            if(!lstrcpyA(ReturnBuffer,ansireturn)) {
                                b = FALSE;
                                rc = ERROR_INVALID_PARAMETER;
                            }
                        } except(EXCEPTION_EXECUTE_HANDLER) {
                            b = FALSE;
                            rc = ERROR_INVALID_PARAMETER;
                        }
                    } else {
                        b = FALSE;
                        rc = ERROR_INSUFFICIENT_BUFFER;
                    }
                }
            }

            MyFree(ansireturn);

        } else {
            b = FALSE;
            rc = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    if(filename) {
        MyFree(filename);
    }
    SetLastError(rc);
    return(b);
}
#else
//
// Unicode stub
//
BOOL
SetupGetSourceFileLocationW(
    IN  HINF        InfHandle,
    IN  PINFCONTEXT InfContext,       OPTIONAL
    IN  PCWSTR      FileName,         OPTIONAL
    OUT PUINT       SourceId,
    OUT PWSTR       ReturnBuffer,     OPTIONAL
    IN  DWORD       ReturnBufferSize,
    OUT PDWORD      RequiredSize      OPTIONAL
    )
{
    UNREFERENCED_PARAMETER(InfHandle);
    UNREFERENCED_PARAMETER(InfContext);
    UNREFERENCED_PARAMETER(FileName);
    UNREFERENCED_PARAMETER(SourceId);
    UNREFERENCED_PARAMETER(ReturnBuffer);
    UNREFERENCED_PARAMETER(ReturnBufferSize);
    UNREFERENCED_PARAMETER(RequiredSize);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif

BOOL
SetupGetSourceFileLocation(
    IN  HINF        InfHandle,
    IN  PINFCONTEXT InfContext,         OPTIONAL
    IN  PCTSTR      FileName,           OPTIONAL
    OUT PUINT       SourceId,
    OUT PTSTR       ReturnBuffer,       OPTIONAL
    IN  DWORD       ReturnBufferSize,
    OUT PDWORD      RequiredSize        OPTIONAL
    )
{
    TCHAR returnbuffer[MAX_PATH];
    DWORD requiredsize;
    PCTSTR filename;
    UINT sourceid;
    DWORD rc;
    BOOL b;

    rc = NO_ERROR;
    if(FileName) {
        rc = CaptureStringArg(FileName,&filename);
        if(rc != NO_ERROR) {
            SetLastError(rc);
            return(FALSE);
        }
    } else {
        filename = NULL;
    }

    b = _SetupGetSourceFileLocation(
            InfHandle,
            InfContext,
            filename,
            NULL,
            &sourceid,
            returnbuffer,
            MAX_PATH,
            &requiredsize,
            NULL
            );

    rc = GetLastError();

    if(b) {
        rc = NO_ERROR;

        try {
            *SourceId = sourceid;
            if(RequiredSize) {
                *RequiredSize = requiredsize;
            }
        } except(EXCEPTION_EXECUTE_HANDLER) {
            rc = ERROR_INVALID_PARAMETER;
            b = FALSE;
        }

        if(rc == NO_ERROR) {

            if(ReturnBuffer) {

                if(requiredsize <= ReturnBufferSize) {

                    //
                    // lstrcpy won't generate an exception on NT even if
                    // ReturnBuffer is invalid, but will return NULL
                    //
                    try {
                        if(!lstrcpy(ReturnBuffer,returnbuffer)) {
                            b = FALSE;
                            rc = ERROR_INVALID_PARAMETER;
                        }
                    } except(EXCEPTION_EXECUTE_HANDLER) {
                        b = FALSE;
                        rc = ERROR_INVALID_PARAMETER;
                    }
                } else {
                    b = FALSE;
                    rc = ERROR_INSUFFICIENT_BUFFER;
                }
            }
        }
    }

    if(filename) {
        MyFree(filename);
    }
    SetLastError(rc);
    return(b);
}


BOOL
_SetupGetSourceFileSize(
    IN  HINF                    InfHandle,
    IN  PINFCONTEXT             InfContext,      OPTIONAL
    IN  PCTSTR                  FileName,        OPTIONAL
    IN  PCTSTR                  Section,         OPTIONAL
    IN  PSP_ALTPLATFORM_INFO_V2 AltPlatformInfo, OPTIONAL
    OUT PDWORD                  FileSize,
    IN  UINT                    RoundingFactor   OPTIONAL
    )

/*++

Routine Description:

    Determine the (uncompressed) size of a source file,
    as listed in an inf file.

Arguments:

    InfHandle - supplies the handle to a loaded inf file that contains
        file layout information, ie, has [SourceDisksNames] and
        optionally [SourceDisksFiles] sections.

    InfContext - specifies a line in a the copy section of an inf file
        for which the size is to be retreived. If this parameter is
        not specified, the FileName parameter is checked next.

    FileName - supplies the filename (no path) for which to return the
        size. If this parameter is not specified the Section parameter
        is used (see below).

    Section - specifies the name of a section in the INF file specified
        by InfHandle. The total sizes of all files in the section is
        computed.

    AltPlatformInfo - optionally, supplies alternate platform information
        to be used in selecting a decorated [SourceDisksFiles] section.

    FileSize - receives the file size(s).

    RoundingFactor - If specified, supplies a value for rounding file sizes.
        All file sizes will be rounded up to be a multiple of this number
        before being added to the total size. This is useful for more
        exact determinations of the space a file will occupy on a given volume,
        because it allows the caller to have file sizes rounded up to be a
        multiple of the cluster size. If not specified no rounding takes place.

Return Value:

    Boolean value indicating outcome.

--*/

{
    PCTSTR fileName, PlatformName;
    INFCONTEXT LayoutSectionContext;
    INFCONTEXT CopySectionContext;
    BOOL b;
    UINT Size;
    LONG File,FileCount;
    TCHAR FileListSectionName[64];
    DWORD rc;

    //
    // If the rounding factor is not specified, set it to 1 so the math
    // below works without special cases.
    //
    if(!RoundingFactor) {
        RoundingFactor = 1;
    }

    // Establish an inf line context for the line in the copy list section,
    // unless the caller passed us an absolute filename.
    //
    fileName = NULL;
    FileCount = 1;
    if(InfContext) {

        //
        // Caller passed INF line context.
        // Remember the context in preparation for retreiving the filename
        // from the line later.
        //
        // fileName must be NULL so we look at the line
        // and get the correct source name
        //
        b = TRUE;
        try {
            CopySectionContext = *InfContext;
        } except(EXCEPTION_EXECUTE_HANDLER) {
            b = FALSE;
        }
        if(!b) {
            SetLastError(ERROR_INVALID_PARAMETER);
            return(FALSE);
        }

    } else {
        if(FileName) {
            //
            // Caller passed an absolute file name. Remember it.
            //
            fileName = FileName;

        } else {
            //
            // Caller must have passed a section, the contents of which lists
            // a set of files whose sizes are to be totalled. Determine the number
            // of lines in the section and establish a context.
            //
            if(Section) {

                FileCount = SetupGetLineCount(InfHandle,Section);

                if((FileCount == -1)
                || !SetupFindFirstLine(InfHandle,Section,NULL,&CopySectionContext)) {
                    rc = GetLastError();
                    pSetupLogSectionError(InfHandle,NULL,NULL,NULL,Section,MSG_LOG_NOSECTION_FILESIZE,rc,NULL);
                    SetLastError(ERROR_SECTION_NOT_FOUND); // ignoring rc for compatability with older versions of setupAPI
                    return(FALSE);
                }
            } else {
                SetLastError(ERROR_INVALID_PARAMETER);
                return(FALSE);
            }
        }
    }

    *FileSize = 0;
    for(File=0; File<FileCount; File++) {

        if(File) {
            //
            // This is not the first pass through the loop. We need
            // to locate the next line in the copy list section.
            //
            b = SetupFindNextLine(&CopySectionContext,&CopySectionContext);
            if(!b) {
                SetLastError(ERROR_INVALID_DATA);
                return(FALSE);
            }

            fileName = pSetupGetField(&CopySectionContext,COPYSECT_SOURCE_FILENAME);
            if(fileName == NULL || fileName[0] == 0) {
                fileName = pSetupGetField(&CopySectionContext,COPYSECT_TARGET_FILENAME);
            }
        } else {
            //
            // First pass through the loop. May need to get a filename.
            //
            if(!fileName) {
                fileName = pSetupGetField(&CopySectionContext,COPYSECT_SOURCE_FILENAME);
                if(fileName == NULL || fileName[0] == 0) {
                    fileName = pSetupGetField(&CopySectionContext,COPYSECT_TARGET_FILENAME);
                }
            }
        }

        //
        // If we don't have a filename by now, the inf is corrupt.
        //
        if(!fileName) {
            SetLastError(ERROR_INVALID_DATA);
            return(FALSE);
        }

        //
        // Locate the line in [SourceDisksFiles] that is for the filename
        // we are currently dealing with. Look in the platform-specific
        // section first.
        //
        if(AltPlatformInfo) {

            switch(AltPlatformInfo->ProcessorArchitecture) {

                case PROCESSOR_ARCHITECTURE_INTEL :
                    PlatformName = pszX86SrcDiskSuffix;
                    break;

                case PROCESSOR_ARCHITECTURE_IA64 :
                    PlatformName = pszIa64SrcDiskSuffix;
                    break;

                case PROCESSOR_ARCHITECTURE_AMD64 :
                    PlatformName = pszAmd64SrcDiskSuffix;
                    break;

                default :
                    //
                    // unknown/unsupported processor architecture.
                    //
                    MYASSERT((AltPlatformInfo->ProcessorArchitecture == PROCESSOR_ARCHITECTURE_INTEL) ||
                             (AltPlatformInfo->ProcessorArchitecture == PROCESSOR_ARCHITECTURE_IA64)  ||
                             (AltPlatformInfo->ProcessorArchitecture == PROCESSOR_ARCHITECTURE_AMD64)
                            );

                    SetLastError(ERROR_INVALID_PARAMETER);
                    return(FALSE);
            }

        } else {
            PlatformName = pszPlatformSrcDiskSuffix;
        }

        wnsprintf(
            FileListSectionName,
            sizeof(FileListSectionName)/sizeof(FileListSectionName[0]),
            TEXT("%s.%s"),
            pszSourceDisksFiles,
            PlatformName
            );
        b = SetupFindFirstLine(InfHandle,FileListSectionName,fileName,&LayoutSectionContext);
        if(!b) {
            b = SetupFindFirstLine(InfHandle,pszSourceDisksFiles,fileName,&LayoutSectionContext);
        }
        if(!b) {
            SetLastError(ERROR_LINE_NOT_FOUND);
            return(FALSE);
        }

        //
        // Get the size data for the file.
        //
        b = SetupGetIntField(&LayoutSectionContext,LAYOUTSECT_SIZE,&Size);
        if(!b) {
            SetLastError(ERROR_INVALID_DATA);
            return(FALSE);
        }

        //
        // Round size up to be an even multiple of the rounding factor
        //
        if(Size % RoundingFactor) {
            Size += RoundingFactor - (Size % RoundingFactor);
        }

        *FileSize += Size;
    }

    return(TRUE);
}

#ifdef UNICODE
//
// ANSI version
//
BOOL
SetupGetSourceFileSizeA(
    IN  HINF        InfHandle,
    IN  PINFCONTEXT InfContext,     OPTIONAL
    IN  PCSTR       FileName,       OPTIONAL
    IN  PCSTR       Section,        OPTIONAL
    OUT PDWORD      FileSize,
    IN  UINT        RoundingFactor  OPTIONAL
    )
{
    PCWSTR filename,section;
    BOOL b;
    DWORD rc;
    DWORD size;

    if(FileName) {
        rc = pSetupCaptureAndConvertAnsiArg(FileName,&filename);
        if(rc != NO_ERROR) {
            SetLastError(rc);
            return(FALSE);
        }
    } else {
        filename = NULL;
    }
    if(Section) {
        rc = pSetupCaptureAndConvertAnsiArg(Section,&section);
        if(rc != NO_ERROR) {
            if(filename) {
                MyFree(filename);
            }
            SetLastError(rc);
            return(FALSE);
        }
    } else {
        section = NULL;
    }

    b = _SetupGetSourceFileSize(InfHandle,
                                InfContext,
                                filename,
                                section,
                                NULL,
                                &size,
                                RoundingFactor
                               );
    rc = GetLastError();

    if (b) {
        try {
            *FileSize = size;
        } except(EXCEPTION_EXECUTE_HANDLER) {
            b = FALSE;
            rc = ERROR_INVALID_PARAMETER;
        }
    }

    if(filename) {
        MyFree(filename);
    }
    if(section) {
        MyFree(section);
    }

    SetLastError(rc);
    return(b);
}

#else
//
// Unicode stub
//
BOOL
SetupGetSourceFileSizeW(
    IN  HINF        InfHandle,
    IN  PINFCONTEXT InfContext,     OPTIONAL
    IN  PCWSTR      FileName,       OPTIONAL
    IN  PCWSTR      Section,        OPTIONAL
    OUT PDWORD      FileSize,
    IN  UINT        RoundingFactor  OPTIONAL
    )
{
    UNREFERENCED_PARAMETER(InfHandle);
    UNREFERENCED_PARAMETER(InfContext);
    UNREFERENCED_PARAMETER(FileName);
    UNREFERENCED_PARAMETER(Section);
    UNREFERENCED_PARAMETER(FileSize);
    UNREFERENCED_PARAMETER(RoundingFactor);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif

BOOL
SetupGetSourceFileSize(
    IN  HINF        InfHandle,
    IN  PINFCONTEXT InfContext,     OPTIONAL
    IN  PCTSTR      FileName,       OPTIONAL
    IN  PCTSTR      Section,        OPTIONAL
    OUT PDWORD      FileSize,
    IN  UINT        RoundingFactor  OPTIONAL
    )
{
    PCTSTR filename,section;
    BOOL b;
    DWORD rc;
    DWORD size;

    if(FileName) {
        rc = CaptureStringArg(FileName,&filename);
        if(rc != NO_ERROR) {
            SetLastError(rc);
            return(FALSE);
        }
    } else {
        filename = NULL;
    }
    if(Section) {
        rc = CaptureStringArg(Section,&section);
        if(rc != NO_ERROR) {
            if(filename) {
                MyFree(filename);
            }
            SetLastError(rc);
            return(FALSE);
        }
    } else {
        section = NULL;
    }

    b = _SetupGetSourceFileSize(InfHandle,
                                InfContext,
                                filename,
                                section,
                                NULL,
                                &size,
                                RoundingFactor
                               );
    rc = GetLastError();

    if (b) {
        try {
            *FileSize = size;
        } except(EXCEPTION_EXECUTE_HANDLER) {
            b = FALSE;
            rc = ERROR_INVALID_PARAMETER;
        }
    }

    if(filename) {
        MyFree(filename);
    }
    if(section) {
        MyFree(section);
    }

    SetLastError(rc);
    return(b);
}


BOOL
_SetupGetTargetPath(
    IN  HINF        InfHandle,
    IN  PINFCONTEXT InfContext,       OPTIONAL
    IN  PCTSTR      Section,          OPTIONAL
    OUT PTSTR       ReturnBuffer,     OPTIONAL
    IN  DWORD       ReturnBufferSize,
    OUT PDWORD      RequiredSize      OPTIONAL
    )

/*++

Routine Description:

    Determine the target directory for a given file list section.
    A file list section may be for copy, rename, or delete; in any case
    all the files in the section are in one directory and that directory
    is listed in the [DestinationDirs] section of the inf.

    Where InfContext is specified, we will look for [DestinationDirs]
    from the current inf in the context first. This will help the scenario
    where X.INF includes Y.INF includes LAYOUT.INF, both X&Y have entries
    but the section was found in Y. We want to find the section in X last.

Arguments:

    InfHandle - supplies the handle to a loaded inf file
        that contains a [DestinationDirs] section.

    InfContext - specifies a line in a the copy section of an inf file.
        The target directory for this section is retreived.

    Section - Supplies the section in InfHandle whose destination directory
        is to be retreived. Ignored if InfContext is specified.
        If neither InfContext nor Section are specified, this function retreives
        the default target path.

    ReturnBuffer - if specified, receives the full win32 path of the target.
        This value is guaranteed not to end with \.

    ReturnBufferSize - specifies the size in characters of the buffer pointed
        to by ReturnBuffer.

    RequiredSize - receives the size in characters of a buffer required to hold
        the output data.

Return Value:

    Boolean value indicating outcome. GetLastError() returns extended error info.
    ERROR_INSUFFICIENT_BUFFER is returned if the function fails because
    ReturnBuffer is too small.

--*/

{
    PINF_SECTION DestDirsSection = NULL;
    UINT LineNumber = 0;
    PINF_LINE Line = NULL;
    PCTSTR DirId = NULL;
    PCTSTR SubDir = NULL;
    PCTSTR ActualPath = NULL;
    UINT DirIdInt = 0;
    PLOADED_INF Inf = NULL;
    PLOADED_INF CurInf = NULL;
    PLOADED_INF DefaultDestDirInf = NULL;
    DWORD TmpRequiredSize = 0;
    BOOL DestDirFound = FALSE;
    BOOL DefaultDestDirFound = FALSE;
    DWORD Err = NO_ERROR;
    PINF_LINE DefaultDestDirLine = NULL;
    PCTSTR InfSourcePath = NULL;

    //
    // If an INF context was specified, use it to determine the name
    // the section the context describes. If inf context was not specified,
    // then a section name must have been.
    //
    Err = NO_ERROR;
    try {
        Inf = InfContext ? (PLOADED_INF)InfContext->Inf : (PLOADED_INF)InfHandle;

        if(!LockInf(Inf)) {
            Err = ERROR_INVALID_HANDLE;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;
    }
    if(Err != NO_ERROR) {
        SetLastError(Err);
        return(FALSE);
    }

    //
    // If we get here then InfContext is a good pointer if specified;
    // if not then Inf is a good pointer.
    //
    if(InfContext) {
        CurInf = (PLOADED_INF)InfContext->CurrentInf;
        InfSourcePath = CurInf->InfSourcePath;

        Section = pStringTableStringFromId(
                      CurInf->StringTable,
                      CurInf->SectionBlock[InfContext->Section].SectionName
                     );
    } else {
        InfSourcePath = Inf->InfSourcePath;

        if(!Section) {
            Section = pszDefaultDestDir;
        }
    }

    //
    // Traverse the linked list of INFs, looking for a [DestinationDirs] section
    // in each one.
    //
    DestDirFound = DefaultDestDirFound = FALSE;
    Err = NO_ERROR;

    if (InfContext) {
        //
        // first consider the CurrentInf as being Local scope
        //
        CurInf = InfContext->CurrentInf;

        if((DestDirsSection = InfLocateSection(CurInf, pszDestinationDirs, NULL))!=NULL) {
            //
            // Locate the line in [DestinationDirs] that gives the target path
            // for the section. The section name will be the key on the relevant line.
            // If that's not there, and we haven't already encountered a DefaultDestDir
            // entry, then look for that as well, and remember it if we find one.
            //
            LineNumber = 0;
            if(InfLocateLine(CurInf, DestDirsSection, Section, &LineNumber, &Line)) {
                //
                // Got the line in [DestinationDirs]. Pull out the directory. The subdir is optional.
                //
                DirId = InfGetField(CurInf, Line, DIRSECT_DIRID, NULL);
                if(!DirId) {
                    Err = ERROR_INVALID_DATA;
                    goto clean0;
                }

                SubDir = InfGetField(CurInf, Line, DIRSECT_SUBDIR, NULL);

                DestDirFound = TRUE;
            } else if(InfLocateLine(CurInf, DestDirsSection, pszDefaultDestDir, &LineNumber, &Line)) {
                DefaultDestDirInf = CurInf;
                DefaultDestDirLine = Line;
                DefaultDestDirFound = TRUE;
            }
        }
    }

    if(!DestDirFound && !DefaultDestDirFound) {
        //
        // search for any matches at all
        //
        for(CurInf = Inf; CurInf; CurInf = CurInf->Next) {

            if(!(DestDirsSection = InfLocateSection(CurInf, pszDestinationDirs, NULL))) {
                continue;
            }

            //
            // Locate the line in [DestinationDirs] that gives the target path
            // for the section. The section name will be the key on the relevant line.
            // If that's not there, and we haven't already encountered a DefaultDestDir
            // entry, then look for that as well, and remember it if we find one.
            //
            LineNumber = 0;
            if(InfLocateLine(CurInf, DestDirsSection, Section, &LineNumber, &Line)) {
                //
                // Got the line in [DestinationDirs]. Pull out the directory. The subdir is optional.
                //
                DirId = InfGetField(CurInf, Line, DIRSECT_DIRID, NULL);
                if(!DirId) {
                    Err = ERROR_INVALID_DATA;
                    goto clean0;
                }

                SubDir = InfGetField(CurInf, Line, DIRSECT_SUBDIR, NULL);

                DestDirFound = TRUE;
                break;
            }

            if(!DefaultDestDirFound &&
                    InfLocateLine(CurInf, DestDirsSection, pszDefaultDestDir, &LineNumber, &Line)) {
                DefaultDestDirInf = CurInf;
                DefaultDestDirLine = Line;
                DefaultDestDirFound = TRUE;
            }
        }
    }

    if(!DestDirFound) {
        //
        // If we found a DefaultDestDir, then use that, otherwise, use a default.
        //
        if(DefaultDestDirFound) {

            DirId = InfGetField(DefaultDestDirInf, DefaultDestDirLine, DIRSECT_DIRID, NULL);
            if(!DirId) {
                Err = ERROR_INVALID_DATA;
                goto clean0;
            }
            SubDir = InfGetField(DefaultDestDirInf, DefaultDestDirLine, DIRSECT_SUBDIR, NULL);
            CurInf = DefaultDestDirInf;
        } else {
            SubDir = NULL;
            DirId = NULL;
            DirIdInt = DIRID_DEFAULT;
            CurInf = NULL;
        }
    }

    //
    // Translate dirid/subdir to actual path.
    //
    ActualPath = pSetupDirectoryIdToPath(DirId,
                                         &DirIdInt,
                                         SubDir,
                                         InfSourcePath,
                                         (CurInf && CurInf->OsLoaderPath)
                                             ? &(CurInf->OsLoaderPath)
                                             : NULL
                                        );

    if(!ActualPath) {
        //
        // If the default DIRID lookup failed because DirId is in the
        // user-defined range, then GetLastError will return NO_ERROR.
        // Otherwise, we should bail now.
        //
        if((Err = GetLastError()) != NO_ERROR) {
            goto clean0;
        }

        //
        // Now see if we there's a user-defined DIRID for this.
        //
        if(!(ActualPath = pSetupVolatileDirIdToPath(NULL,
                                                DirIdInt,
                                                SubDir,
                                                Inf))) {
            Err = GetLastError();
            goto clean0;
        }
    }

    //
    // Put actual path in caller's buffer.
    //
    TmpRequiredSize = lstrlen(ActualPath) + 1;
    if(RequiredSize) {
        *RequiredSize = TmpRequiredSize;
    }

    if(ReturnBuffer) {
        if(TmpRequiredSize > ReturnBufferSize) {
            Err = ERROR_INSUFFICIENT_BUFFER;
        } else {
            lstrcpy(ReturnBuffer, ActualPath);
        }
    }

    MyFree(ActualPath);

clean0:
    UnlockInf(Inf);

    if(Err == NO_ERROR) {
        return TRUE;
    } else {
        SetLastError(Err);
        return FALSE;
    }
}

#ifdef UNICODE
//
// ANSI version
//
BOOL
SetupGetTargetPathA(
    IN  HINF        InfHandle,
    IN  PINFCONTEXT InfContext,       OPTIONAL
    IN  PCSTR       Section,          OPTIONAL
    OUT PSTR        ReturnBuffer,     OPTIONAL
    IN  DWORD       ReturnBufferSize,
    OUT PDWORD      RequiredSize      OPTIONAL
    )
{
    BOOL b;
    DWORD rc;
    WCHAR returnbuffer[MAX_PATH];
    DWORD requiredsize;
    PCWSTR section;
    PCSTR ansireturn;

    if(Section) {
        rc = pSetupCaptureAndConvertAnsiArg(Section,&section);
    } else {
        section = NULL;
        rc = NO_ERROR;
    }

    if(rc == NO_ERROR) {
        b = _SetupGetTargetPath(InfHandle,InfContext,section,returnbuffer,MAX_PATH,&requiredsize);
        rc = GetLastError();
    } else {
        b = FALSE;
    }

    if(b) {

        if(ansireturn = pSetupUnicodeToAnsi(returnbuffer)) {

            rc = NO_ERROR;

            requiredsize = lstrlenA(ansireturn) + 1;

            if(RequiredSize) {
                try {
                    *RequiredSize = requiredsize;
                } except(EXCEPTION_EXECUTE_HANDLER) {
                    rc = ERROR_INVALID_PARAMETER;
                    b = FALSE;
                }
            }

            if(rc == NO_ERROR) {

                if(ReturnBuffer) {
                    if(requiredsize <= ReturnBufferSize) {

                        //
                        // At least on NT lstrcpy won't fault if an arg is invalid
                        // but it will return false.
                        //
                        if(!lstrcpyA(ReturnBuffer,ansireturn)) {
                            rc = ERROR_INVALID_PARAMETER;
                            b = FALSE;
                        }

                    } else {
                        rc = ERROR_INSUFFICIENT_BUFFER;
                        b = FALSE;
                    }
                }
            }

            MyFree(ansireturn);
        } else {
            b = FALSE;
            rc = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    if(section) {
        MyFree(section);
    }
    SetLastError(rc);
    return(b);
}
#else
//
// Unicode stub
//
BOOL
SetupGetTargetPathW(
    IN  HINF        InfHandle,
    IN  PINFCONTEXT InfContext,       OPTIONAL
    IN  PCWSTR      Section,          OPTIONAL
    OUT PWSTR       ReturnBuffer,     OPTIONAL
    IN  DWORD       ReturnBufferSize,
    OUT PDWORD      RequiredSize      OPTIONAL
    )
{
    UNREFERENCED_PARAMETER(InfHandle);
    UNREFERENCED_PARAMETER(InfContext);
    UNREFERENCED_PARAMETER(Section);
    UNREFERENCED_PARAMETER(ReturnBuffer);
    UNREFERENCED_PARAMETER(ReturnBufferSize);
    UNREFERENCED_PARAMETER(RequiredSize);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif

BOOL
SetupGetTargetPath(
    IN  HINF        InfHandle,
    IN  PINFCONTEXT InfContext,       OPTIONAL
    IN  PCTSTR      Section,          OPTIONAL
    OUT PTSTR       ReturnBuffer,     OPTIONAL
    IN  DWORD       ReturnBufferSize,
    OUT PDWORD      RequiredSize      OPTIONAL
    )
{
    BOOL b;
    DWORD rc;
    TCHAR returnbuffer[MAX_PATH];
    DWORD requiredsize;
    PCTSTR section;

    if(Section) {
        rc = CaptureStringArg(Section,&section);
    } else {
        section = NULL;
        rc = NO_ERROR;
    }

    if(rc == NO_ERROR) {
        b = _SetupGetTargetPath(InfHandle,InfContext,section,returnbuffer,MAX_PATH,&requiredsize);
        rc = GetLastError();
    } else {
        b = FALSE;
    }

    if(b) {
        rc = NO_ERROR;

        if(RequiredSize) {
            try {
                *RequiredSize = requiredsize;
            } except(EXCEPTION_EXECUTE_HANDLER) {
                rc = ERROR_INVALID_PARAMETER;
                b = FALSE;
            }
        }

        if(rc == NO_ERROR) {

            if(ReturnBuffer) {
                if(requiredsize <= ReturnBufferSize) {

                    //
                    // At least on NT lstrcpy won't fault if an arg is invalid
                    // but it will return false.
                    //
                    if(!lstrcpy(ReturnBuffer,returnbuffer)) {
                        rc = ERROR_INVALID_PARAMETER;
                        b = FALSE;
                    }

                } else {
                    rc = ERROR_INSUFFICIENT_BUFFER;
                    b = FALSE;
                }
            }
        }
    }

    if(section) {
        MyFree(section);
    }
    SetLastError(rc);
    return(b);
}


PCTSTR
pSetupDirectoryIdToPath(
    IN     PCTSTR  DirectoryId,    OPTIONAL
    IN OUT PUINT   DirectoryIdInt, OPTIONAL
    IN     PCTSTR  SubDirectory,   OPTIONAL
    IN     PCTSTR  InfSourcePath,  OPTIONAL
    IN OUT PCTSTR *OsLoaderPath    OPTIONAL
    )
/*++

    (See pSetupDirectoryIdToPathEx for details.)

--*/
{
    return pSetupDirectoryIdToPathEx(DirectoryId,
                                     DirectoryIdInt,
                                     SubDirectory,
                                     InfSourcePath,
                                     OsLoaderPath,
                                     NULL
                                    );
}


PCTSTR
pSetupDirectoryIdToPathEx(
    IN     PCTSTR  DirectoryId,        OPTIONAL
    IN OUT PUINT   DirectoryIdInt,     OPTIONAL
    IN     PCTSTR  SubDirectory,       OPTIONAL
    IN     PCTSTR  InfSourcePath,      OPTIONAL
    IN OUT PCTSTR *OsLoaderPath,       OPTIONAL
    OUT    PBOOL   VolatileSystemDirId OPTIONAL
    )

/*++

Routine Description:

    Translate a directory id/subdirectory pair to an actual path.
    The directory ids are reserved string values that we share with Win9x (and
    then some).

    VOLATILE SYSTEM DIRID PATHS AND USER-DEFINED DIRID PATHS ARE NOT RETURNED
    BY THIS ROUTINE!!!

Arguments:

    DirectoryId - Optionally, supplies the (base-10) textual representation of
        the directory ID number to use.  If this parameter is not specified,
        then DirectoryIdInt must be specified.

    DirectoryIdInt - Optionally, supplies the address of an integer variable
        that specifies, on input, the DIRID to use.  This is only used if
        DirectoryID is not specified.  On output, if DirectoryId was used,
        then this variable receives the numeric value contained in the
        DirectoryId string.

    SubDirectory - Optionally, supplies a subdirectory string that will be
        appended with the DIRID path.

    InfSourcePath - Optionally, supplies the path to be used if the ID turns
        out to be DIRID_SRCPATH.  If this parameter is NULL, and the SourcePath
        DIRID is the one we are to use, then we use the global source path.

    OsLoaderPath - Optionally, supplies the address of a string pointer containing
        the OsLoader path.  If the address points to a NULL string pointer, it will
        be filled in with a newly-allocated character buffer containing the OsLoader
        path, as retrieved from the registry.  This will only be done if the DirectoryId
        being used is on the system partition.

    VolatileSystemDirId - Optionally, supplies the address of a boolean variable
        that, upon successful return, indicates whether or not the specified
        DIRID was a volatile system DIRID.

Return Value:

    If successful, the return value is a pointer to a newly-allocated buffer
    containing the directory path matching the specified DIRID.
    THE CALLER IS RESPONSIBLE FOR FREEING THIS BUFFER!

    If failure, the return value is NULL.  GetLastError() returns the reason
    for failure.  If the failure was because the DIRID was a user-defined one,
    then GetLastError() will return NO_ERROR.

--*/

{
    UINT Value;
    PTCHAR End;
    PCTSTR FirstPart;
    PTSTR Path;
    UINT Length;
    TCHAR Buffer[MAX_PATH];
    BOOL b;
    DWORD err;

    if(VolatileSystemDirId) {
        *VolatileSystemDirId = FALSE;
    }

    if(DirectoryId) {
        //
        // We only allow base-10 integer ids for now.
        // Only the terminating nul should cause the conversion to stop.
        // In any other case there were non-digits in the string.
        // Also disallow the empty string.
        //
        Value = _tcstoul(DirectoryId, &End, 10);

        if(*End || (End == DirectoryId)) {
            SetLastError(ERROR_INVALID_DATA);
            return(NULL);
        }

        if(DirectoryIdInt) {
            *DirectoryIdInt = Value;
        }

    } else {
        MYASSERT(DirectoryIdInt);
        Value = *DirectoryIdInt;
    }

    if(!SubDirectory) {
        SubDirectory = TEXT("");
    }

    Path = NULL;

    switch(Value) {

    case DIRID_NULL:
    case DIRID_ABSOLUTE:
    case DIRID_ABSOLUTE_16BIT:
        //
        // Absolute.
        //
        FirstPart = NULL;
        break;

    case DIRID_SRCPATH:
        //
        // If the caller supplied a path, then use it, otherwise, use our global default one.
        //
        if(InfSourcePath) {
            FirstPart = InfSourcePath;
        } else {
            FirstPart = SystemSourcePath;
        }
        break;

    case DIRID_BOOT:
    case DIRID_LOADER:
        //
        // System partition DIRIDS
        //
        if(OsLoaderPath && *OsLoaderPath) {
            lstrcpyn(Buffer, *OsLoaderPath, SIZECHARS(Buffer));
        } else {
            err = pSetupGetOsLoaderDriveAndPath(FALSE, Buffer, SIZECHARS(Buffer), &Length);
            if(err) {
                SetLastError(err);
                return NULL;
            }

            if(OsLoaderPath) {
                //
                // allocate a buffer to return the OsLoaderPath to the caller.
                //
                Length *= sizeof(TCHAR);    // need # bytes--not chars

                if(!(*OsLoaderPath = MyMalloc(Length))) {
                    SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                    return(NULL);
                }

                CopyMemory((PVOID)(*OsLoaderPath), Buffer, Length);
            }
        }
        if(Value == DIRID_BOOT) {
            if(Buffer[0] && Buffer[1] == TEXT(':') && Buffer[2] == TEXT('\\')) {
                //
                // got a simple directory to return
                //
                Buffer[3] = TEXT('\0'); // just want "<drive>:\" part.
            } else {
                //
                // use OsSystemPartitionRoot instead
                //
                lstrcpyn(Buffer,OsSystemPartitionRoot,MAX_PATH);
            }
        }
        FirstPart = Buffer;
        break;

    case DIRID_SHARED:
        //
        // On Win95 there is an installation mode that allows most of
        // the OS to exist on a server. If the system is installed in that mode
        // DIRID_SHARED is the location of the windows dir on the server.
        // Otherwise it just maps to the windows dir. For now just map to
        // sysroot.
        //
    case DIRID_WINDOWS:
        //
        // Windows directory
        //
        FirstPart = WindowsDirectory;
        break;

    case DIRID_SYSTEM:
        //
        // Windows system directory
        //
        FirstPart = SystemDirectory;
        break;

    case DIRID_DRIVERS:
        //
        // io subsys directory (drivers)
        //
        FirstPart = DriversDirectory;
        break;

    case DIRID_INF:
        //
        // inf directory
        //
        FirstPart = InfDirectory;
        break;

    case DIRID_HELP:
        //
        // Help directory
        //
        lstrcpyn(Buffer,WindowsDirectory,MAX_PATH);
        pSetupConcatenatePaths(Buffer,TEXT("help"),MAX_PATH,NULL);
        FirstPart = Buffer;
        break;

    case DIRID_FONTS:
        //
        // Fonts directory
        //
        lstrcpyn(Buffer,WindowsDirectory,MAX_PATH);
        pSetupConcatenatePaths(Buffer,TEXT("fonts"),MAX_PATH,NULL);
        FirstPart = Buffer;
        break;

    case DIRID_VIEWERS:
        //
        // Viewers directory
        //
        lstrcpyn(Buffer,SystemDirectory,MAX_PATH);
        pSetupConcatenatePaths(Buffer,TEXT("viewers"),MAX_PATH,NULL);
        FirstPart = Buffer;
        break;

    case DIRID_COLOR:
        //
        // ICM directory
        //
        lstrcpyn(Buffer, SystemDirectory, MAX_PATH);
        if(OSVersionInfo.dwPlatformId == VER_PLATFORM_WIN32_NT) {
            //
            // On NT, the path is system32\spool\drivers\color
            //
            pSetupConcatenatePaths(Buffer, TEXT("spool\\drivers\\color"), MAX_PATH, NULL);
        } else {
            //
            // On Win9x, the path is system\color
            //
            pSetupConcatenatePaths(Buffer, TEXT("color"), MAX_PATH, NULL);
        }
        FirstPart = Buffer;
        break;

    case DIRID_APPS:
        //
        // Application directory.
        //
        lstrcpyn(Buffer,WindowsDirectory,MAX_PATH);
        Buffer[2] = 0;
        FirstPart = Buffer;
        break;

    case DIRID_SYSTEM16:
        //
        // 16-bit system directory
        //
        FirstPart = System16Directory;
        break;

    case DIRID_SPOOL:
        //
        // spool directory
        //
        lstrcpyn(Buffer,SystemDirectory,MAX_PATH);
        pSetupConcatenatePaths(Buffer,TEXT("spool"),MAX_PATH,NULL);
        FirstPart = Buffer;
        break;

    case DIRID_SPOOLDRIVERS:

        b = GetPrinterDriverDirectory(
                NULL,                       // local machine
                NULL,                       // default platform
                1,                          // structure level
                (PVOID)Buffer,
                sizeof(Buffer),
                (PDWORD)&Length
                );

        if(!b) {
            return NULL;
        }
        FirstPart = Buffer;
        break;

    case DIRID_PRINTPROCESSOR:

        b = GetPrintProcessorDirectory(
                NULL,                       // local machine
                NULL,                       // default platform
                1,                          // structure level
                (PVOID)Buffer,
                sizeof(Buffer),
                (PDWORD)&Length
                );

        if(!b) {
            return NULL;
        }
        FirstPart = Buffer;
        break;

    case DIRID_USERPROFILE:

        b = GetEnvironmentVariable (
            TEXT("USERPROFILE"),
            Buffer,
            MAX_PATH
            );

        if(!b) {
            //
            // Can this happen?
            //
            return NULL;
        }

        FirstPart = Buffer;
        break;

    default:

        FirstPart = NULL;
        if((Value >= DIRID_USER) || (Value & VOLATILE_DIRID_FLAG)) {
            //
            // User-defined or volatile dirid--don't do anything with this here
            // except let the caller know if it's a volatile system DIRID (if
            // they requested this information).
            //
            if(Value < DIRID_USER && VolatileSystemDirId) {
                *VolatileSystemDirId = TRUE;
            }

            SetLastError(NO_ERROR);
            return NULL;
        }

        //
        // Default to system32\unknown
        //
        if(!FirstPart) {
            lstrcpyn(Buffer,SystemDirectory,MAX_PATH);
            pSetupConcatenatePaths(Buffer,TEXT("unknown"),MAX_PATH,NULL);
            FirstPart = Buffer;
        }
        break;
    }

    if(FirstPart) {

        pSetupConcatenatePaths((PTSTR)FirstPart,SubDirectory,0,&Length);

        Path = MyMalloc(Length * sizeof(TCHAR));
        if(!Path) {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return(NULL);
        }

        lstrcpy(Path,FirstPart);
        pSetupConcatenatePaths(Path,SubDirectory,Length,NULL);

    } else {
        //
        // Just use subdirectory.
        //
        Path = DuplicateString(SubDirectory);
    }

    //
    // Make sure the path doesn't end with a \. This could happen if
    // subdirectory is the empty string, etc.  Don't do this, however,
    // if it's a root path (e.g., 'A:\').
    //
    if (Path) {
        Length = lstrlen(Path);
        if(Length && *CharPrev(Path,Path+Length) == TEXT('\\')) {
            if((Length != 3) || (Path[1] != TEXT(':'))) {
                Path[Length-1] = 0;
            }
        }
    }
    return(Path);
}


PCTSTR
pGetPathFromDirId(
    IN     PCTSTR      DirectoryId,
    IN     PCTSTR      SubDirectory,   OPTIONAL
    IN     PLOADED_INF pLoadedInf
    )
/*
    Wrapper function that merges functionality of pSetupDirectoryIdToPathEx
    and pSetupVolatileDirIdToPath to return the DIRID that is needed, be it regular,
    volatile or user defined.

*/
{
    BOOL IsVolatileDirID=FALSE;
    PCTSTR ReturnPath;
    UINT Value = 0;

    MYASSERT(DirectoryId);
    MYASSERT(pLoadedInf);

    if( ReturnPath = pSetupDirectoryIdToPathEx(DirectoryId,
                                               &Value,
                                               SubDirectory,
                                               pLoadedInf->InfSourcePath,
                                               NULL,
                                               &IsVolatileDirID) ){

        return( ReturnPath );
    }

    if( IsVolatileDirID || (Value >= DIRID_USER) ){

        ReturnPath = pSetupVolatileDirIdToPath(DirectoryId,
                                               0,
                                               SubDirectory,
                                               pLoadedInf);

        return( ReturnPath );


    }

    // Should never happen

    return NULL;

}




PCTSTR
pSetupFilenameFromLine(
    IN PINFCONTEXT Context,
    IN BOOL        GetSourceName
    )
{
    return(pSetupGetField(Context,GetSourceName ? COPYSECT_SOURCE_FILENAME : COPYSECT_TARGET_FILENAME));
}


#ifdef UNICODE
//
// ANSI version
//
BOOL
SetupSetDirectoryIdExA(
    IN HINF  InfHandle,
    IN DWORD Id,        OPTIONAL
    IN PCSTR Directory, OPTIONAL
    IN DWORD Flags,
    IN DWORD Reserved1,
    IN PVOID Reserved2
    )
{
    BOOL b;
    DWORD rc;
    PCWSTR directory;

    if(Directory) {
        rc = pSetupCaptureAndConvertAnsiArg(Directory,&directory);
    } else {
        directory = NULL;
        rc = NO_ERROR;
    }

    if(rc == NO_ERROR) {
        b = SetupSetDirectoryIdExW(InfHandle,Id,directory,Flags,Reserved1,Reserved2);
        rc = GetLastError();
    } else {
        b = FALSE;
    }

    if(directory) {
        MyFree(directory);
    }

    SetLastError(rc);
    return(b);
}
#else
//
// Unicode stub
//
BOOL
SetupSetDirectoryIdExW(
    IN HINF   InfHandle,
    IN DWORD  Id,           OPTIONAL
    IN PCWSTR Directory,    OPTIONAL
    IN DWORD  Flags,
    IN DWORD  Reserved1,
    IN PVOID  Reserved2
    )
{
    UNREFERENCED_PARAMETER(InfHandle);
    UNREFERENCED_PARAMETER(Id);
    UNREFERENCED_PARAMETER(Directory);
    UNREFERENCED_PARAMETER(Flags);
    UNREFERENCED_PARAMETER(Reserved1);
    UNREFERENCED_PARAMETER(Reserved2);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif

BOOL
SetupSetDirectoryIdEx(
    IN HINF   InfHandle,
    IN DWORD  Id,           OPTIONAL
    IN PCTSTR Directory,    OPTIONAL
    IN DWORD  Flags,
    IN DWORD  Reserved1,
    IN PVOID  Reserved2
    )

/*++

Routine Description:

    Associate a directory id in the user directory id range with a particular
    directory. The caller can use this function prior to queueing files for
    copy, for getting files copied to a target location known only at runtime.

    After setting the directory ID, this routine traverses all loaded INFs in
    the InfHandle's linked list, and sees if any of them have unresolved string
    substitutions.  If so, it attempts to re-apply string substitution to them
    based on the new DIRID mapping.  Thus, some INF values may change after calling
    this routine.

Arguments:

    Id - supplies the directory id to use for the association. This value
        MUST be >= DIRID_USER or the function fails and GetLastError
        returns ERROR_INVALID_PARAMETER. If an association for this id
        already exists it is overwritten. If not specified (ie, 0), then
        Directory is ignored, and the entire current set of user-defined
        directory ids is deleted.

    Directory - if specified, supplies the directory path to associate with
        the given id. If not specified, any directory associated with Id
        is unassociated. No error results if Id is not currently associated
        with any directory.

    Flags - supplies a set of flags controlling operation.

        SETDIRID_NOT_FULL_PATH - indicates that the given Directory is not
            a full path specification but is one or more intermediate
            components in a path. Internally, the routine skips its usual
            call to GetFullPathName() if this flag is set.

Return Value:

    Boolean value indicating outcome. If FALSE, GetLastError() returns
    extended error information:

    ERROR_NOT_ENOUGH_MEMORY: a memory allocation failed

    ERROR_INVALID_PARAMETER: the Id parameter is not >= DIRID_USER, or
        Directory is not a valid string.

--*/

{
    PCTSTR directory;
    DWORD rc;
    PUSERDIRID UserDirId;
    UINT u;
    TCHAR Buffer[MAX_PATH];
    PTSTR p;
    PUSERDIRID_LIST UserDirIdList;
    DWORD RequiredSize;

    //
    // Validate Id parameter.
    // Also as a special case disallow the 16-bit -1 value.
    // Make sure reserved params are 0.
    //
    if((Id && ((Id < DIRID_USER) || (Id == DIRID_ABSOLUTE_16BIT))) || Reserved1 || Reserved2) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    //
    // Capture directory, if specified. Ignore if Id is not specified.
    //
    rc = NO_ERROR;
    if(Id && Directory) {
        try {
            directory = DuplicateString(Directory);
        } except(EXCEPTION_EXECUTE_HANDLER) {
            rc = ERROR_INVALID_PARAMETER;
        }
    } else {
        directory = NULL;
    }

    if(rc == NO_ERROR) {
        if(directory) {
            if(Flags & SETDIRID_NOT_FULL_PATH) {
                lstrcpyn(Buffer, directory, MAX_PATH);
                MyFree(directory);
            } else {

                RequiredSize = GetFullPathName(directory,
                                               SIZECHARS(Buffer),
                                               Buffer,
                                               &p
                                              );
                if(!RequiredSize) {
                    rc = GetLastError();
                } else if(RequiredSize >= SIZECHARS(Buffer)) {
                    MYASSERT(0);
                    rc = ERROR_BUFFER_OVERFLOW;
                }

                MyFree(directory);

                if(rc != NO_ERROR) {
                    SetLastError(rc);
                    return(FALSE);
                }
            }
            directory = Buffer;
        }

    } else {
        SetLastError(rc);
        return(FALSE);
    }

    try {
        if(!LockInf((PLOADED_INF)InfHandle)) {
            rc = ERROR_INVALID_HANDLE;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
      rc = ERROR_INVALID_HANDLE;
    }
    if (rc != NO_ERROR) {
        SetLastError(rc);
        return(FALSE);
    }

    UserDirIdList = &(((PLOADED_INF)InfHandle)->UserDirIdList);

    if(Id) {
        //
        // Got an id to use. Find any existing association for it.
        //
        UserDirId = NULL;
        for(u = 0; u < UserDirIdList->UserDirIdCount; u++) {
            if(UserDirIdList->UserDirIds[u].Id == Id) {
                UserDirId = &(UserDirIdList->UserDirIds[u]);
                break;
            }
        }

        if(directory) {

            if(UserDirId) {
                //
                // Overwrite existing association.
                //
                lstrcpy(UserDirId->Directory, directory);

            } else {
                //
                // Add a new association at the end of the list.
                //
                UserDirId = UserDirIdList->UserDirIds
                          ? MyRealloc(UserDirIdList->UserDirIds,
                                      (UserDirIdList->UserDirIdCount+1)*sizeof(USERDIRID))
                          : MyMalloc(sizeof(USERDIRID));

                if(UserDirId) {

                    UserDirIdList->UserDirIds = UserDirId;

                    lstrcpy(UserDirIdList->UserDirIds[UserDirIdList->UserDirIdCount].Directory, directory);
                    UserDirIdList->UserDirIds[UserDirIdList->UserDirIdCount].Id = Id;

                    UserDirIdList->UserDirIdCount++;

                } else {
                    rc = ERROR_NOT_ENOUGH_MEMORY;
                }
            }
        } else {
            //
            // Need to delete any existing association we found.
            //
            if(UserDirId) {
                //
                // Close up the hole in the array.
                // Note that when we get here u is the index of the
                // array slot where we found the match.
                //
                MoveMemory(
                    &(UserDirIdList->UserDirIds[u]),
                    &(UserDirIdList->UserDirIds[u+1]),
                    ((UserDirIdList->UserDirIdCount-u)-1) * sizeof(USERDIRID)
                    );

                //
                // Try to shrink the array -- this really should never fail
                // but we won't fail the call if it does fail for some reason.
                //
                if(UserDirId = MyRealloc(UserDirIdList->UserDirIds,
                                         (UserDirIdList->UserDirIdCount-1)*sizeof(USERDIRID))) {

                    UserDirIdList->UserDirIds = UserDirId;
                }
                UserDirIdList->UserDirIdCount--;
            }
        }

    } else {
        //
        // Id was not specified -- delete any set of associations.
        //
        if(UserDirIdList->UserDirIds) {
            MyFree(UserDirIdList->UserDirIds);
            UserDirIdList->UserDirIds = NULL;
            UserDirIdList->UserDirIdCount = 0;
        }
        MYASSERT(UserDirIdList->UserDirIdCount == 0);    // sanity check.
    }

    if(rc == NO_ERROR) {
        //
        // Now apply new DIRID mappings to all unresolved string substitutions
        // in the loaded INFs.
        //
        rc = ApplyNewVolatileDirIdsToInfs((PLOADED_INF)InfHandle, NULL);
    }

    UnlockInf((PLOADED_INF)InfHandle);

    SetLastError(rc);
    return(rc == NO_ERROR);
}


BOOL
SetupSetDirectoryIdA(
    IN HINF   InfHandle,
    IN DWORD  Id,           OPTIONAL
    IN PCSTR  Directory     OPTIONAL
    )
{
    return(SetupSetDirectoryIdExA(InfHandle,Id,Directory,0,0,0));
}

BOOL
SetupSetDirectoryIdW(
    IN HINF   InfHandle,
    IN DWORD  Id,           OPTIONAL
    IN PCWSTR Directory     OPTIONAL
    )
{
    return(SetupSetDirectoryIdExW(InfHandle,Id,Directory,0,0,0));
}


PCTSTR
pSetupVolatileDirIdToPath(
    IN PCTSTR      DirectoryId,    OPTIONAL
    IN UINT        DirectoryIdInt, OPTIONAL
    IN PCTSTR      SubDirectory,   OPTIONAL
    IN PLOADED_INF Inf
    )

/*++

Routine Description:

    Translate a volatile system DIRID or user-defined DIRID (along with an
    optional subdirectory) to an actual path.

    THIS ROUTINE DOES NOT DO INF LOCKING--CALLER MUST DO IT!

Arguments:

    DirectoryId - Optionally, supplies the directory id in string form.  If
        this parameter is not specified, then DirectoryIdInt is used directly.

    DirectoryIdInst - Supplies the DIRID to find the path for.  This parameter
        is ignored if DirectoryId is supplied.

    SubDirectory - Optionally, supplies a subdirectory to be appended to the
        path specified by the given DIRID.

    Inf - Supplies the address of the loaded INF structure containing the
        user-defined DIRID values to use.

Return Value:

    If success, a pointer to a path string is returned.  The caller is
    responsible for freeing this memory.
    If failure, the return value is NULL, and GetLastError() indicates the
    cause of failure.

--*/

{
    UINT Value;
    PTCHAR End;
    PCTSTR FirstPart;
    PTSTR Path;
    UINT Length;
    PUSERDIRID_LIST UserDirIdList;
    TCHAR SpecialFolderPath[MAX_PATH];

    if(DirectoryId) {
        //
        // We only allow base-10 integer ids for now.
        // Only the terminating nul should cause the conversion to stop.
        // In any other case there were non-digits in the string.
        // Also disallow the empty string.
        //
        Value = _tcstoul(DirectoryId, &End, 10);

        if(*End || (End == DirectoryId)) {
            SetLastError(ERROR_INVALID_DATA);
            return(NULL);
        }
    } else {
        Value = DirectoryIdInt;
    }

    if(!SubDirectory) {
        SubDirectory = TEXT("");
    }

    Path = NULL;
    FirstPart = NULL;

    if((Value < DIRID_USER) &&  (Value & VOLATILE_DIRID_FLAG)) {

#ifdef ANSI_SETUPAPI

        {
            HRESULT Result;
            LPITEMIDLIST ppidl;

            Result = SHGetSpecialFolderLocation (
                        NULL,
                        Value ^ VOLATILE_DIRID_FLAG,
                        &ppidl
                        );

            if (SUCCEEDED (Result)) {
                if (SHGetPathFromIDList (
                        ppidl,
                        SpecialFolderPath
                        )) {

                    FirstPart = SpecialFolderPath;
                }
            }
        }

#else

        //
        // This is a volatile system DIRID.  Presently, we only support DIRIDs
        // representing shell special folders, and we chose those DIRID values
        // to make it easy to convert to the CSIDL value necessary to hand into
        // SHGetSpecialFolderPath.
        //
        if(SHGetSpecialFolderPath(NULL,
                                  SpecialFolderPath,
                                  (Value ^ VOLATILE_DIRID_FLAG),
                                  TRUE // does this help?
                                 )) {

            FirstPart = SpecialFolderPath;
        }
#endif

    } else {
        //
        // This is a user-defined DIRID--look it up in our list of user DIRIDs
        // presently defined.
        //
        UserDirIdList = &(Inf->UserDirIdList);

        for(Length = 0; Length < UserDirIdList->UserDirIdCount; Length++) {

            if(UserDirIdList->UserDirIds[Length].Id == Value) {

                FirstPart = UserDirIdList->UserDirIds[Length].Directory;
                break;
            }
        }
    }

    if(FirstPart) {

        pSetupConcatenatePaths((PTSTR)FirstPart, SubDirectory, 0, &Length);

        Path = MyMalloc(Length * sizeof(TCHAR));
        if(!Path) {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return NULL;
        }

        lstrcpy(Path, FirstPart);
        pSetupConcatenatePaths(Path, SubDirectory, Length, NULL);

    } else {
        //
        // Just use subdirectory.
        //
        Path = DuplicateString(SubDirectory);
    }

    //
    // Make sure the path doesn't end with a \. This could happen if
    // subdirectory is the empty string, etc.
    //
    if (Path) {
        Length = lstrlen(Path);
        if(Length && (*CharPrev(Path,Path+Length) == TEXT('\\'))) {
            //
            // Special case when we have a path like "A:\"--we don't want
            // to strip the backslash in that scenario.
            //
            if((Length != 3) || (Path[1] != TEXT(':'))) {
                Path[Length-1] = 0;
            }
        }
    }

    return Path;
}


VOID
InfSourcePathFromFileName(
    IN  PCTSTR  InfFileName,
    OUT PTSTR  *SourcePath,  OPTIONAL
    OUT PBOOL   TryPnf
    )
/*++

Routine Description:

    This routine determines whether the specified INF path is in our INF search path list,
    or in %windir%, %windir%\INF, %windir%\system32, or %windir%\system.  If so, then it
    returns NULL.  If not, then it returns a copy of our flobal source path (which must be
    freed via MyFree).

Arguments:

    InfFileName - Supplies the fully-qualified path to the INF.

    SourcePath - Optionally, supplies the address of a variable that receives the address of
        a newly-allocated buffer containing the SourcePath to use, or NULL if the default
        should be used.

    TryPnf - Supplies the address of a variable that is set upon return to indicate whether
        or not this INF was in one of the directories in our INF search path list.

Return Value:

    None.

--*/
{
    TCHAR PathBuffer[MAX_PATH];
    INT TempLen;
    PTSTR s;

    if(SourcePath) {
        *SourcePath = NULL;
    }

    //
    // First, determine if this INF is located somewhere in our search path list.  If so,
    // then there's nothing more to do.
    //
    if(!pSetupInfIsFromOemLocation(InfFileName, FALSE)) {
        *TryPnf = TRUE;
        return;
    } else {
        *TryPnf = FALSE;
        if(!SourcePath) {
            //
            // If the caller doesn't care about the source path, then we're done.
            //
            return;
        }
    }

    //
    // We need to use the directory path where this INF came from as our SourcePath.
    //
    lstrcpy(PathBuffer, InfFileName);
    s = (PTSTR)pSetupGetFileTitle(PathBuffer);

    if(((s - PathBuffer) == 3) && (PathBuffer[1] == TEXT(':'))) {
        //
        // This path is a root path (e.g., 'A:\'), so don't strip the trailing backslash.
        //
        *s = TEXT('\0');
    } else {
        //
        // Strip the trailing backslash.
        //
        if((s > PathBuffer) && (*CharPrev(PathBuffer,s) == TEXT('\\'))) {
            s--;
        }
        *s = TEXT('\0');
    }

    //
    // Next, see if this file exists in any of the following locations:
    //
    // %windir%
    // %windir%\INF
    // %windir%\system32
    // %windir%\system
    //
    if (!lstrcmpi(PathBuffer, WindowsDirectory) ||
        !lstrcmpi(PathBuffer, InfDirectory) ||
        !lstrcmpi(PathBuffer, SystemDirectory) ||
        !lstrcmpi(PathBuffer, System16Directory)) {
        //
        // It is one of the above directories--no need to use any source path
        // other than the default.
        //
        return;
    }

    *SourcePath = DuplicateString(PathBuffer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\setupapi\infline.c ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    infline.c

Abstract:

    Externally exposed INF routines for INF line retreival and information.

Author:

    Ted Miller (tedm) 20-Jan-1995

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop


#ifdef UNICODE
//
// ANSI version
//
BOOL
SetupFindFirstLineA(
    IN  HINF        InfHandle,
    IN  PCSTR       Section,
    IN  PCSTR       Key,          OPTIONAL
    OUT PINFCONTEXT Context
    )
{
    PCTSTR section,key;
    BOOL b;
    DWORD d;

    if((d = pSetupCaptureAndConvertAnsiArg(Section,&section)) != NO_ERROR) {
        //
        // Invalid arg.
        //
        SetLastError(d);
        return(FALSE);
    }

    if(Key) {
        if((d = pSetupCaptureAndConvertAnsiArg(Key,&key)) != NO_ERROR) {
            //
            // Invalid arg.
            //
            MyFree(section);
            SetLastError(d);
            return(FALSE);
        }
    } else {
        key = NULL;
    }

    b = SetupFindFirstLine(InfHandle,section,key,Context);
    //
    // We're safe in calling this here regardless of success or failure, since
    // we are ensured that SetupFindFirstLine will always call SetLastError().
    //
    d = GetLastError();

    if(key) {
        MyFree(key);
    }
    MyFree(section);

    SetLastError(d);
    return(b);
}
#else
//
// Unicode stub
//
BOOL
SetupFindFirstLineW(
    IN  HINF        InfHandle,
    IN  PCWSTR      Section,
    IN  PCWSTR      Key,          OPTIONAL
    OUT PINFCONTEXT Context
    )
{
    UNREFERENCED_PARAMETER(InfHandle);
    UNREFERENCED_PARAMETER(Section);
    UNREFERENCED_PARAMETER(Key);
    UNREFERENCED_PARAMETER(Context);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif

BOOL
SetupFindFirstLine(
    IN  HINF        InfHandle,
    IN  PCTSTR      Section,
    IN  PCTSTR      Key,          OPTIONAL
    OUT PINFCONTEXT Context
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    PLOADED_INF CurInf;
    PINF_SECTION InfSection;
    PINF_LINE InfLine;
    UINT LineNumber;
    UINT SectionNumber;
    DWORD d;

    d = NO_ERROR;
    try {
        if(!LockInf((PLOADED_INF)InfHandle)) {
            d = ERROR_INVALID_HANDLE;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        //
        // Assume InfHandle was bad pointer
        //
        d = ERROR_INVALID_HANDLE;
    }
    if(d != NO_ERROR) {
        SetLastError(d);
        return(FALSE);
    }

    //
    // Traverse the linked list of loaded INFs, looking for the specified
    // section.
    //
    try {
        for(CurInf = (PLOADED_INF)InfHandle; CurInf; CurInf = CurInf->Next) {
            //
            // Locate the section.
            //
            if(!(InfSection = InfLocateSection(CurInf, Section, &SectionNumber))) {
                continue;
            }

            //
            // Attempt to locate the line within this section.
            //
            LineNumber = 0;
            if(InfLocateLine(CurInf, InfSection, Key, &LineNumber, &InfLine)) {
                break;
            }
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        d = ERROR_INVALID_PARAMETER;
    }

    UnlockInf((PLOADED_INF)InfHandle);

    if(d != NO_ERROR) {
        SetLastError(d);
        return(FALSE);
    }

    if(CurInf) {
        //
        // Then we found the specified line.
        //
        MYASSERT(Key || !LineNumber);
        try {
            Context->Inf = (PVOID)InfHandle;
            Context->CurrentInf = (PVOID)CurInf;
            Context->Section = SectionNumber;
            Context->Line = LineNumber;
        } except(EXCEPTION_EXECUTE_HANDLER) {
            d = ERROR_INVALID_PARAMETER;
        }
    } else {
        d = ERROR_LINE_NOT_FOUND;
    }

    SetLastError(d);
    return(d == NO_ERROR);
}


BOOL
SetupFindNextLine(
    IN  PINFCONTEXT ContextIn,
    OUT PINFCONTEXT ContextOut
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    return(SetupFindNextMatchLine(ContextIn,NULL,ContextOut));
}


#ifdef UNICODE
//
// ANSI version
//
BOOL
SetupFindNextMatchLineA(
    IN  PINFCONTEXT ContextIn,
    IN  PCSTR       Key,        OPTIONAL
    OUT PINFCONTEXT ContextOut
    )
{
    PWSTR key;
    BOOL b;
    DWORD d;

    if(!Key) {
        key = NULL;
        d = NO_ERROR;
    } else {
        d = pSetupCaptureAndConvertAnsiArg(Key,&key);
    }

    if (d == NO_ERROR) {


        b = SetupFindNextMatchLineW(ContextIn,key,ContextOut);
        d = GetLastError();

        if (key) {
            MyFree(key);
        }

    } else {
        b = FALSE;
    }

    SetLastError(d);
    return(b);
}
#else
//
// Unicode stub
//
BOOL
SetupFindNextMatchLineW(
    IN  PINFCONTEXT ContextIn,
    IN  PCWSTR      Key,        OPTIONAL
    OUT PINFCONTEXT ContextOut
    )
{
    UNREFERENCED_PARAMETER(ContextIn);
    UNREFERENCED_PARAMETER(Key);
    UNREFERENCED_PARAMETER(ContextOut);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif

BOOL
SetupFindNextMatchLine(
    IN  PINFCONTEXT ContextIn,
    IN  PCTSTR      Key,        OPTIONAL
    OUT PINFCONTEXT ContextOut
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    PLOADED_INF CurInf;
    UINT LineNumber;
    UINT SectionNumber;
    PINF_LINE Line;
    PINF_SECTION Section;
    PCTSTR SectionName;
    DWORD d;

    d = NO_ERROR;
    try {
        if(!LockInf((PLOADED_INF)ContextIn->Inf)) {
            d = ERROR_INVALID_HANDLE;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        //
        // ContextIn is a bad pointer
        //
        d = ERROR_INVALID_PARAMETER;
    }
    if(d != NO_ERROR) {
        SetLastError(d);
        return(FALSE);
    }

    //
    // Fetch values from context
    //
    try {
        CurInf = ContextIn->CurrentInf;
        SectionNumber = ContextIn->Section;
        Section = &CurInf->SectionBlock[SectionNumber];
        SectionName = pStringTableStringFromId(CurInf->StringTable, Section->SectionName);
        MYASSERT(SectionName);

        //
        // Either want next line, or to start searching for key on next line
        //
        LineNumber = ContextIn->Line+1;

        do {
            if(Section) {
                if(InfLocateLine(CurInf, Section, Key, &LineNumber, &Line)) {
                    break;
                }
            }
            if(CurInf = CurInf->Next) {
                Section = InfLocateSection(CurInf, SectionName, &SectionNumber);
                LineNumber = 0;
            }
        } while(CurInf);

    } except(EXCEPTION_EXECUTE_HANDLER) {
        d = ERROR_INVALID_PARAMETER;
    }

    UnlockInf((PLOADED_INF)ContextIn->Inf);

    if(d != NO_ERROR) {
        SetLastError(d);
        return(FALSE);
    }


    if(CurInf) {
        //
        // Then we found the next line.
        //
        try {
            ContextOut->Inf = ContextIn->Inf;
            ContextOut->CurrentInf = CurInf;
            ContextOut->Section = SectionNumber;
            ContextOut->Line = LineNumber;
        } except(EXCEPTION_EXECUTE_HANDLER) {
            d = ERROR_INVALID_PARAMETER;
        }
    } else {
        d = ERROR_LINE_NOT_FOUND;
    }

    SetLastError(d);
    return(d == NO_ERROR);
}


#ifdef UNICODE
//
// ANSI version
//
BOOL
SetupGetLineByIndexA(
    IN  HINF        InfHandle,
    IN  PCSTR       Section,
    IN  DWORD       Index,
    OUT PINFCONTEXT Context
    )
{
    PCWSTR section;
    DWORD d;
    BOOL b;

    if((d = pSetupCaptureAndConvertAnsiArg(Section,&section)) == NO_ERROR) {

        b = SetupGetLineByIndexW(InfHandle,section,Index,Context);
        d = GetLastError();

        MyFree(section);

    } else {
        b = FALSE;
    }

    SetLastError(d);
    return(b);
}
#else
//
// Unicode stub
//
BOOL
SetupGetLineByIndexW(
    IN  HINF        InfHandle,
    IN  PCWSTR      Section,
    IN  DWORD       Index,
    OUT PINFCONTEXT Context
    )
{
    UNREFERENCED_PARAMETER(InfHandle);
    UNREFERENCED_PARAMETER(Section);
    UNREFERENCED_PARAMETER(Index);
    UNREFERENCED_PARAMETER(Context);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif

BOOL
SetupGetLineByIndex(
    IN  HINF        InfHandle,
    IN  PCTSTR      Section,
    IN  DWORD       Index,
    OUT PINFCONTEXT Context
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    PLOADED_INF CurInf;
    PINF_SECTION InfSection;
    PINF_LINE InfLine;
    UINT LineNumber, CurLineNumberUB;
    UINT SectionNumber;
    DWORD d;

    d = NO_ERROR;
    try {
        if(!LockInf((PLOADED_INF)InfHandle)) {
            d =  ERROR_INVALID_HANDLE;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        d = ERROR_INVALID_HANDLE;
    }
    if(d != NO_ERROR) {
        SetLastError(d);
        return(FALSE);
    }

    try {
        //
        // Traverse the list of loaded INFs.  For each INF that contains
        // the specified section, we check to see if the line number we're
        // looking for lies within its (adjusted) range of line numbers.
        //
        CurLineNumberUB = 0;
        for(CurInf = (PLOADED_INF)InfHandle; CurInf; CurInf = CurInf->Next) {
            //
            // Locate the section.
            //
            if(!(InfSection = InfLocateSection(CurInf, Section, &SectionNumber))) {
                continue;
            }

            //
            // See if the line number lies in this INF section's range.
            //
            MYASSERT(Index >= CurLineNumberUB);
            LineNumber = Index - CurLineNumberUB;
            if(InfLocateLine(CurInf, InfSection, NULL, &LineNumber, &InfLine)) {
                break;
            } else {
                //
                // Subtract the number of lines this INF contributes to the section's
                // total line count, and continue with the next one.
                //
                CurLineNumberUB += InfSection->LineCount;
            }
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        d = ERROR_INVALID_PARAMETER;
    }

    UnlockInf((PLOADED_INF)InfHandle);

    if(d != NO_ERROR) {
        SetLastError(d);
        return(FALSE);
    }

    if(CurInf) {
        //
        // Then we found the specified line.
        //
        try {
            Context->Inf = (PVOID)InfHandle;
            Context->CurrentInf = (PVOID)CurInf;
            Context->Section = SectionNumber;
            Context->Line = LineNumber;
        } except(EXCEPTION_EXECUTE_HANDLER) {
            d = ERROR_INVALID_PARAMETER;
        }
    } else {
        d = ERROR_LINE_NOT_FOUND;
    }

    SetLastError(d);
    return(d == NO_ERROR);
}


#ifdef UNICODE
//
// ANSI version
//
LONG
SetupGetLineCountA(
    IN HINF  InfHandle,
    IN PCSTR Section
    )
{
    PCWSTR section;
    LONG l;
    DWORD d;

    if((d = pSetupCaptureAndConvertAnsiArg(Section,&section)) == NO_ERROR) {

        l = SetupGetLineCountW(InfHandle,section);
        d = GetLastError();

        MyFree(section);

    } else {

        l = -1;
    }

    SetLastError(d);
    return(l);
}
#else
//
// Unicode stub
//
LONG
SetupGetLineCountW(
    IN HINF   InfHandle,
    IN PCWSTR Section
    )
{
    UNREFERENCED_PARAMETER(InfHandle);
    UNREFERENCED_PARAMETER(Section);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(-1);
}
#endif

LONG
SetupGetLineCount(
    IN HINF   InfHandle,
    IN PCTSTR Section
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    PLOADED_INF CurInf;
    PINF_SECTION InfSection;
    LONG LineCount;
    DWORD d;

    d = NO_ERROR;
    try {
        if(!LockInf((PLOADED_INF)InfHandle)) {
            d = ERROR_INVALID_HANDLE;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        d = ERROR_INVALID_HANDLE;
    }
    if(d != NO_ERROR) {
        SetLastError(d);
        return(-1);
    }

    try {
        //
        // Traverse the linked list of loaded INFs, and sum up the section line
        // counts for each INF containing the specified section.
        //
        LineCount = -1;
        for(CurInf = (PLOADED_INF)InfHandle; CurInf; CurInf = CurInf->Next) {
            if(InfSection = InfLocateSection(CurInf, Section, NULL)) {
                if(LineCount == -1) {
                    LineCount = InfSection->LineCount;
                } else {
                    LineCount += InfSection->LineCount;
                }
            }
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        d = ERROR_INVALID_PARAMETER;
    }

    UnlockInf((PLOADED_INF)InfHandle);

    if(d != NO_ERROR) {
        SetLastError(d);
        return(-1);
    }

    if(LineCount == -1) {
        SetLastError(ERROR_SECTION_NOT_FOUND);
    } else {
        SetLastError(NO_ERROR);
    }

    return LineCount;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\setupapi\infinst.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    infinst.c

Abstract:

    High-level INF install section processing API.

Author:

    Ted Miller (tedm) 6-Mar-1995

Revision History:

    Jamie Hunter (JamieHun) Apr-29-2002
            Security code review

--*/

#include "precomp.h"
#pragma hdrstop


//
// Define invalid flags for SetupInstallServicesFromInfSection(Ex)
//
#define SPSVCINST_ILLEGAL_FLAGS (~( SPSVCINST_TAGTOFRONT               \
                                  | SPSVCINST_ASSOCSERVICE             \
                                  | SPSVCINST_DELETEEVENTLOGENTRY      \
                                  | SPSVCINST_NOCLOBBER_DISPLAYNAME    \
                                  | SPSVCINST_NOCLOBBER_STARTTYPE      \
                                  | SPSVCINST_NOCLOBBER_ERRORCONTROL   \
                                  | SPSVCINST_NOCLOBBER_LOADORDERGROUP \
                                  | SPSVCINST_NOCLOBBER_DEPENDENCIES   \
                                  | SPSVCINST_STOPSERVICE              ))

//
// Flags for UpdateInis in INFs
//
#define FLG_MATCH_KEY_AND_VALUE 1

//
// Flags for UpdateIniFields in INFs
//
#define FLG_INIFIELDS_WILDCARDS 1
#define FLG_INIFIELDS_USE_SEP2  2

#define TIME_SCALAR                   (1000)
#define REGISTER_WAIT_TIMEOUT_DEFAULT (60)
#define RUNONCE_TIMEOUT               (2*60*1000)
#define RUNONCE_THRESHOLD             (20) // * RUNONCE_TIMEOUT

#define DLLINSTALL      "DllInstall"
#define DLLREGISTER     "DllRegisterServer"
#define DLLUNREGISTER   "DllUnregisterServer"
#define EXEREGSVR       TEXT("/RegServer")
#define EXEUNREGSVR     TEXT("/UnRegServer")

typedef struct _INIFILESECTION {
    PTSTR IniFileName;
    PTSTR SectionName;
    PTSTR SectionData;
    int BufferSize;
    int BufferUsed;
    struct _INIFILESECTION *Next;
} INIFILESECTION, *PINIFILESECTION;

typedef struct _INISECTIONCACHE {
    //
    // Head of section list.
    //
    PINIFILESECTION Sections;
} INISECTIONCACHE, *PINISECTIONCACHE;

typedef struct _WOWSURRAGATE_IPC {
    GUID    MemoryRegionName;
    HANDLE  hFileMap;
    PVOID   MemoryRegion;
    GUID    SignalReadyToRegisterName;
    HANDLE  SignalReadyToRegister;
    GUID    SignalRegistrationCompleteName;
    HANDLE  SignalRegistrationComplete;
    HANDLE  hProcess;
} WOWSURRAGATE_IPC, *PWOWSURRAGATE_IPC;

typedef struct _REF_STATUS {
    DWORD RefCount;
    DWORD ExtendedStatus;
#if PRERELEASE
    unsigned ThreadId;
#endif
} REF_STATUS, *PREF_STATUS;


typedef struct _OLE_CONTROL_DATA {
    LPTSTR              FullPath;
    UINT                RegType;
    PSETUP_LOG_CONTEXT  LogContext;
    BOOL                Register; // or unregister
    LPCTSTR             Argument;
    PREF_STATUS         Status;
    PWOWSURRAGATE_IPC   WowIpcData;
} OLE_CONTROL_DATA, *POLE_CONTROL_DATA;



CONST TCHAR pszUpdateInis[]      = SZ_KEY_UPDATEINIS,
            pszUpdateIniFields[] = SZ_KEY_UPDATEINIFIELDS,
            pszIni2Reg[]         = SZ_KEY_INI2REG,
            pszAddReg[]          = SZ_KEY_ADDREG,
            pszDelReg[]          = SZ_KEY_DELREG,
            pszBitReg[]          = SZ_KEY_BITREG,
            pszRegSvr[]          = SZ_KEY_REGSVR,
            pszUnRegSvr[]        = SZ_KEY_UNREGSVR,
            pszProfileItems[]    = SZ_KEY_PROFILEITEMS;

//
// Separator chars in an ini field
//
TCHAR pszIniFieldSeparators[] = TEXT(" ,\t");

//
// Mapping between registry key specs in an inf file
// and predefined registry handles.
//

STRING_TO_DATA InfRegSpecTohKey[] = {
    TEXT("HKEY_LOCAL_MACHINE"), ((UINT_PTR)HKEY_LOCAL_MACHINE),
    TEXT("HKLM")              , ((UINT_PTR)HKEY_LOCAL_MACHINE),
    TEXT("HKEY_CLASSES_ROOT") , ((UINT_PTR)HKEY_CLASSES_ROOT),
    TEXT("HKCR")              , ((UINT_PTR)HKEY_CLASSES_ROOT),
    TEXT("HKR")               , ((UINT_PTR)NULL),
    TEXT("HKEY_CURRENT_USER") , ((UINT_PTR)HKEY_CURRENT_USER),
    TEXT("HKCU")              , ((UINT_PTR)HKEY_CURRENT_USER),
    TEXT("HKEY_USERS")        , ((UINT_PTR)HKEY_USERS),
    TEXT("HKU")               , ((UINT_PTR)HKEY_USERS),
    NULL                      , ((UINT_PTR)NULL)
};

//
// Mapping between registry value names and CM device registry property (CM_DRP) codes
//
// These values must be in the exact ordering of the SPDRP codes, as defined in setupapi.h.
// This allows us to easily map between SPDRP and CM_DRP property codes.
//
 STRING_TO_DATA InfRegValToDevRegProp[] = { pszDeviceDesc,               CM_DRP_DEVICEDESC,
                                            pszHardwareID,               CM_DRP_HARDWAREID,
                                            pszCompatibleIDs,            CM_DRP_COMPATIBLEIDS,
                                            TEXT(""),                    CM_DRP_UNUSED0,
                                            pszService,                  CM_DRP_SERVICE,
                                            TEXT(""),                    CM_DRP_UNUSED1,
                                            TEXT(""),                    CM_DRP_UNUSED2,
                                            pszClass,                    CM_DRP_CLASS,
                                            pszClassGuid,                CM_DRP_CLASSGUID,
                                            pszDriver,                   CM_DRP_DRIVER,
                                            pszConfigFlags,              CM_DRP_CONFIGFLAGS,
                                            pszMfg,                      CM_DRP_MFG,
                                            pszFriendlyName,             CM_DRP_FRIENDLYNAME,
                                            pszLocationInformation,      CM_DRP_LOCATION_INFORMATION,
                                            TEXT(""),                    CM_DRP_PHYSICAL_DEVICE_OBJECT_NAME,
                                            pszCapabilities,             CM_DRP_CAPABILITIES,
                                            pszUiNumber,                 CM_DRP_UI_NUMBER,
                                            pszUpperFilters,             CM_DRP_UPPERFILTERS,
                                            pszLowerFilters,             CM_DRP_LOWERFILTERS,
                                            TEXT(""),                    CM_DRP_BUSTYPEGUID,
                                            TEXT(""),                    CM_DRP_LEGACYBUSTYPE,
                                            TEXT(""),                    CM_DRP_BUSNUMBER,
                                            TEXT(""),                    CM_DRP_ENUMERATOR_NAME,
                                            TEXT(""),                    CM_DRP_SECURITY,
                                            pszDevSecurity,              CM_DRP_SECURITY_SDS,
                                            pszDevType,                  CM_DRP_DEVTYPE,
                                            pszExclusive,                CM_DRP_EXCLUSIVE,
                                            pszCharacteristics,          CM_DRP_CHARACTERISTICS,
                                            TEXT(""),                    CM_DRP_ADDRESS,
                                            pszUiNumberDescFormat,       CM_DRP_UI_NUMBER_DESC_FORMAT,
                                            TEXT(""),                    CM_DRP_DEVICE_POWER_DATA,
                                            TEXT(""),                    CM_DRP_REMOVAL_POLICY,
                                            TEXT(""),                    CM_DRP_REMOVAL_POLICY_HW_DEFAULT,
                                            pszRemovalPolicyOverride,    CM_DRP_REMOVAL_POLICY_OVERRIDE,
                                            TEXT(""),                    CM_DRP_INSTALL_STATE,
                                            TEXT(""),                    CM_DRP_LOCATION_PATHS,
                                            NULL,                        0
                                         };

//
// Mapping between registry value names and CM class registry property (CM_CRP) codes
//
// These values must be in the exact ordering of the SPCRP codes, as defined in setupapi.h.
// This allows us to easily map between SPCRP and CM_CRP property codes.
//
STRING_TO_DATA InfRegValToClassRegProp[] = { TEXT(""),                  0,
                                        TEXT(""),                       0,
                                        TEXT(""),                       0,
                                        TEXT(""),                       0,
                                        TEXT(""),                       0,
                                        TEXT(""),                       0,
                                        TEXT(""),                       0,
                                        TEXT(""),                       0,
                                        TEXT(""),                       0,
                                        TEXT(""),                       0,
                                        TEXT(""),                       0,
                                        TEXT(""),                       0,
                                        TEXT(""),                       0,
                                        TEXT(""),                       0,
                                        TEXT(""),                       0,
                                        TEXT(""),                       0,
                                        TEXT(""),                       0,
                                        TEXT(""),                       0,
                                        TEXT(""),                       0,
                                        TEXT(""),                       0,
                                        TEXT(""),                       0,
                                        TEXT(""),                       0,
                                        TEXT(""),                       0,
                                        TEXT(""),                       CM_CRP_SECURITY,
                                        pszDevSecurity,                 CM_CRP_SECURITY_SDS,
                                        pszDevType,                     CM_CRP_DEVTYPE,
                                        pszExclusive,                   CM_CRP_EXCLUSIVE,
                                        pszCharacteristics,             CM_CRP_CHARACTERISTICS,
                                        TEXT(""),                       0,
                                        NULL,                           0
                                     };

//
// Linked list of RunOnce entries encountered during INF processing while
// running in unattended mode.  The contents of this list are accessed by the
// caller via pSetupAccessRunOnceNodeList, and freed via
// pSetupDestroyRunOnceNodeList.
//
// ** NOTE -- THIS LIST IS NOT THREAD SAFE, AND IS FOR USE SOLELY BY THE **
// **         SINGLE THREAD IN UMPNPMGR THAT DOES DEVICE INSTALLATIONS.  **
//
PPSP_RUNONCE_NODE RunOnceListHead = NULL;



HKEY
pSetupInfRegSpecToKeyHandle(
    IN PCTSTR InfRegSpec,
    IN HKEY   UserRootKey,
    IN PBOOL  NeedToCloseKey
    );

DWORD
pSetupValidateDevRegProp(
    IN  ULONG   CmPropertyCode,
    IN  DWORD   ValueType,
    IN  PCVOID  Data,
    IN  DWORD   DataSize,
    OUT PVOID  *ConvertedBuffer,
    OUT PDWORD  ConvertedBufferSize
    );

DWORD
pSetupValidateClassRegProp(
    IN  ULONG   CmPropertyCode,
    IN  DWORD   ValueType,
    IN  PCVOID  Data,
    IN  DWORD   DataSize,
    OUT PVOID  *ConvertedBuffer,
    OUT PDWORD  ConvertedBufferSize
    );

//
// Internal ini file routines.
//
PINIFILESECTION
pSetupLoadIniFileSection(
    IN     PCTSTR           FileName,
    IN     PCTSTR           SectionName,
    IN OUT PINISECTIONCACHE SectionList
    );

DWORD
pSetupUnloadIniFileSections(
    IN PINISECTIONCACHE SectionList,
    IN BOOL             WriteToFile
    );

PTSTR
pSetupFindLineInSection(
    IN PINIFILESECTION Section,
    IN PCTSTR          KeyName,      OPTIONAL
    IN PCTSTR          RightHandSide OPTIONAL
    );

BOOL
pSetupReplaceOrAddLineInSection(
    IN PINIFILESECTION Section,
    IN PCTSTR          KeyName,         OPTIONAL
    IN PCTSTR          RightHandSide,   OPTIONAL
    IN BOOL            MatchRHS
    );

BOOL
pSetupAppendLineToSection(
    IN PINIFILESECTION Section,
    IN PCTSTR          KeyName,         OPTIONAL
    IN PCTSTR          RightHandSide    OPTIONAL
    );

BOOL
pSetupDeleteLineFromSection(
    IN PINIFILESECTION Section,
    IN PCTSTR          KeyName,         OPTIONAL
    IN PCTSTR          RightHandSide    OPTIONAL
    );

DWORD
pSetupSetSecurityForAddRegSection(
    IN HINF Inf,
    IN PCTSTR Section,
    IN PVOID  Context
    );

DWORD
LoadNtOnlyDll(
    IN  PCTSTR DllName,
    OUT HINSTANCE *Dll_Handle
    );

VOID
pSetupFreeOleControlData(
    IN POLE_CONTROL_DATA OleControlData);

DWORD
pSetupEnumInstallationSections(
    IN PVOID  Inf,
    IN PCTSTR Section,
    IN PCTSTR Key,
    IN ULONG_PTR  (*EnumCallbackFunc)(PVOID,PINFCONTEXT,PVOID),
    IN PVOID  Context
    )

/*++

Routine Description:

    Iterate all values on a line in a given section with a given key,
    treating each as the name of a section, and then pass each of the lines
    in the referenced sections to a callback function.

Arguments:

    Inf - supplies a handle to an open inf file.

    Section - supplies the name of the section in which the line whose
        values are to be iterated resides.

    Key - supplies the key of the line whose values are to be iterated.

    EnumCallbackFunc - supplies a pointer to the callback function.
        Each line in each referenced section is passed to this function.

    Context - supplies a context value to be passes through to the
        callback function.

Return Value:

    Win32 error code indicating outcome.

--*/

{
    BOOL b;
    INFCONTEXT LineContext;
    DWORD FieldCount;
    DWORD Field;
    DWORD d;
    PCTSTR SectionName;
    INFCONTEXT FirstLineContext;

    //
    // Find the relevent line in the given install section.
    // If not present then we're done -- report success.
    //
    b = SetupFindFirstLine(Inf,Section,Key,&LineContext);
    if(!b) {
        d = GetLastError();
        if ((d != NO_ERROR) && (d != ERROR_SECTION_NOT_FOUND) && (d != ERROR_LINE_NOT_FOUND)) {
            pSetupLogSectionError(Inf,NULL,NULL,NULL,Section,MSG_LOG_INSTALLSECT_ERROR,d,NULL);
        }
        return NO_ERROR; // for compatibility with older SetupAPI
    }

    do {
        //
        // Each value on the line in the given install section
        // is the name of another section.
        //
        FieldCount = SetupGetFieldCount(&LineContext);
        for(Field=1; Field<=FieldCount; Field++) {

            if((SectionName = pSetupGetField(&LineContext,Field))
            && SetupFindFirstLine(Inf,SectionName,NULL,&FirstLineContext)) {
                //
                // Call the callback routine for every line in the section.
                //
                do {
                    d = (DWORD)EnumCallbackFunc(Inf,&FirstLineContext,Context);
                    if(d != NO_ERROR) {
                        pSetupLogSectionError(Inf,NULL,NULL,NULL,SectionName,MSG_LOG_SECT_ERROR,d,Key);
                        return(d);
                    }
                } while(SetupFindNextLine(&FirstLineContext,&FirstLineContext));
            }
        }
    } while(SetupFindNextMatchLine(&LineContext,Key,&LineContext));

    SetLastError(NO_ERROR);
    return(NO_ERROR);
}

#ifdef UNICODE
DWORD
pSetupSetSecurityForAddRegSection(
    IN HINF Inf,
    IN PCTSTR Section,
    IN PVOID  Context
    )
/*

  This function takes an Addreg section and processes its corresponding .Security section
  if it exists

Arguments:


    Inf - supplies an INF handle so we can get a LogContext.

    Section - Name of the section to process

    Context - supplies the address of a registry modification context
        structure used in adding the registry value.  The structure is
        defined as:

            typedef struct _REGMOD_CONTEXT {

                DWORD               Flags;          // indicates what fields are filled in
                HKEY                UserRootKey;    // HKR
                PGUID               ClassGuid;      // INF_PFLAG_CLASSPROP
                HMACHINE            hMachine;       // INF_PFLAG_CLASSPROP
                DWORD               DevInst;        // INF_PFLAG_DEVPROP

            } REGMOD_CONTEXT, *PREGMOD_CONTEXT;

        where UserRootKey is a handle to the open inf key to be used as
        the root when HKR is specified as the root for the operation, and
        DevInst is the optional device instance handle that is supplied when
        the AddReg section is for a hardware key (i.e., under the Enum branch).
        If this handle is supplied, then the value is checked to see whether it
        is the name of a Plug&Play device registry property, and if so, the
        registry property is set via a CM API instead of via the registry API
        (which doesn't refer to the same location on Windows NT).
        Flags indicates if DevInst should be used, or if ClassGuid/hMachine pair should be used

Return Value:

    Win32 error code indicating outcome.

*/
{

    BOOL b;
    DWORD ret, LoadStatus;
    DWORD error = NO_ERROR;
    INFCONTEXT LineContext;
    DWORD FieldCount;
    DWORD Field;
    PCTSTR SectionName;
    INFCONTEXT FirstLineContext;
    PREGMOD_CONTEXT RegModContext;
    PCTSTR RootKeySpec;
    FARPROC SceRegUpdate;
    HKEY RootKey;
    HINSTANCE Sce_Dll;
    DWORD slot_regop = 0;
    BOOL CloseKey = FALSE;
    PCTSTR SubKeyName, SecDesc;
    BOOL SceFlags = 0;
#ifdef _WIN64
    BOOL CheckApplySceFlag = TRUE;    // always check
#else
    BOOL CheckApplySceFlag = IsWow64; // only check if on Wow64
#endif
    SecDesc = NULL;

    //
    // If we're in "Disable SCE" mode on embedded, then don't process security
    // stuff.
    //
    if(GlobalSetupFlags & PSPGF_NO_SCE_EMBEDDED) {
        return NO_ERROR;
    }

    //
    // Find the relevent line in the given install section.
    // If not present then we're done -- report success.
    //
    b = SetupFindFirstLine(Inf,Section,pszAddReg,&LineContext);
    if(!b) {
        return( NO_ERROR );
    }


    slot_regop = AllocLogInfoSlot(((PLOADED_INF) Inf)->LogContext,FALSE);

    do {
        //
        // Each value on the line in the given install section
        // is the name of another section.
        //
        FieldCount = SetupGetFieldCount(&LineContext);
        for(Field=1; Field<=FieldCount; Field++) {


            if( (SectionName = pSetupGetField(&LineContext,Field)) &&
                (SetupFindFirstLine(Inf,SectionName,NULL,&FirstLineContext)) ){

                //
                //If security section not present then don't bother and goto next section
                //
                if( !pSetupGetSecurityInfo( Inf, SectionName, &SecDesc )) {
                    continue;
                }

                //
                // Call the callback routine for every line in the section.
                //
                do {
                    RegModContext = (PREGMOD_CONTEXT)Context;
                    if(RootKeySpec = pSetupGetField(&FirstLineContext,1)) {
                        CloseKey = FALSE;
                        RootKey = pSetupInfRegSpecToKeyHandle(RootKeySpec, RegModContext->UserRootKey,&CloseKey);
                        if(!RootKey) {
                            if (slot_regop) {
                                ReleaseLogInfoSlot(((PLOADED_INF) Inf)->LogContext,slot_regop);
                            }

                            return( ERROR_BADKEY );
                        }

                        SubKeyName = pSetupGetField(&FirstLineContext,2);

                        SceFlags = 0;
                        if(CheckApplySceFlag) {
                            //
                            // if set, we're running on 64-bit OS
                            // either native (_WIN64 defined)
                            // or under WOW64 (Wow64 set)
                            // either case, we need to check AddReg etc flags
                            //
                            INT flags;
                            if(!SetupGetIntField(&FirstLineContext,4,&flags)) {
                                flags = 0;
                            }
#ifdef _WIN64
                            if((flags & FLG_ADDREG_32BITKEY)!=0) {
                                //
                                // if running on 64-bit
                                // set 32-bit flag *only if* special flag
                                // specified in AddReg etc
                                //
                                SceFlags |= SCE_SETUP_32KEY;
                            }
#else
                            if((flags & FLG_ADDREG_64BITKEY)!=0) {
                                //
                                // if running under Wow64
                                // set 32-bit flag *unless* special flag
                                // specified in AddReg etc
                                //
                                SceFlags |= SCE_SETUP_64KEY;
                            }
#endif
                        }

                        //
                        // log the fact that we're setting the security...
                        //
                        WriteLogEntry(
                            ((PLOADED_INF) Inf)->LogContext,
                            slot_regop,
                            MSG_LOG_SETTING_SECURITY_ON_SUBKEY,
                            NULL,
                            RootKeySpec,
                            (SubKeyName ? TEXT("\\") : TEXT("")),
                            (SubKeyName ? SubKeyName : TEXT("")),
                            SecDesc);

                        error = ERROR_INVALID_DATA;
                        try {
                            error = (DWORD)SceSetupUpdateSecurityKey(
                                                  RootKey,
                                                  (PWSTR)SubKeyName,
                                                  SceFlags,
                                                  (PWSTR)SecDesc);
                        } except(EXCEPTION_EXECUTE_HANDLER) {
                            error = ERROR_INVALID_DATA;
                        }
                        if(error) {
                            WriteLogError(
                                ((PLOADED_INF) Inf)->LogContext,
                                SETUP_LOG_ERROR,
                                error);

                            if (CloseKey) {
                                RegCloseKey( RootKey );
                            }

                            return( error );
                        }
                    } else {
                        if (slot_regop) {
                            ReleaseLogInfoSlot(((PLOADED_INF) Inf)->LogContext,slot_regop);
                        }

                        return( ERROR_INVALID_DATA );
                    }

                    if (CloseKey) {
                        RegCloseKey( RootKey );
                    }

                } while(SetupFindNextLine(&FirstLineContext,&FirstLineContext));

            }

        }
    }while(SetupFindNextMatchLine(&LineContext,pszAddReg,&LineContext));

    if (slot_regop) {
        ReleaseLogInfoSlot(((PLOADED_INF) Inf)->LogContext,slot_regop);
    }

    return( NO_ERROR );

}

#endif // UNICODE






DWORD_PTR
pSetupProcessUpdateInisLine(
    IN PVOID       Inf,
    IN PINFCONTEXT InfLineContext,
    IN PVOID       Context
    )

/*++

Routine Description:

    Process a line containing update-inis directives.

    The line is expected to be in the following format:

    <filename>,<section>,<old-entry>,<new-entry>,<flags>

    <filename> supplies the filename of the ini file.

    <section> supplies the section in the ini file.

    <old-entry> is optional and if specified supplies an entry to
        be removed from the section, in the form "key=val".

    <new-entry> is optional and if specified supplies an entry to
        be added to the section, in the form "key=val".

    <flags> are optional flags
        FLG_MATCH_KEY_AND_VALUE (1)

Arguments:

    Inf - supplies an INF handle so we can get a LogContext.

    InfLineContext - supplies context for current line in the section.

    Context - Supplies pointer to structure describing loaded ini file sections.

Return Value:

    Win32 error code indicating outcome.

--*/

{
    PCTSTR File;
    PCTSTR Section;
    PCTSTR OldLine;
    PCTSTR NewLine;
    BOOL b;
    DWORD d;
    PTCHAR Key,Value;
    PTCHAR p;
    UINT Flags;
    PINIFILESECTION SectData;
    PTSTR LineData;
    PINISECTIONCACHE IniSectionCache;

    IniSectionCache = Context;

    //
    // Get fields from the line.
    //
    File = pSetupGetField(InfLineContext,1);
    Section = pSetupGetField(InfLineContext,2);

    OldLine = pSetupGetField(InfLineContext,3);
    if(OldLine && (*OldLine == 0)) {
        OldLine = NULL;
    }

    NewLine = pSetupGetField(InfLineContext,4);
    if(NewLine && (*NewLine == 0)) {
        NewLine = NULL;
    }

    if(!SetupGetIntField(InfLineContext,5,&Flags)) {
        Flags = 0;
    }

    //
    // File and section must be specified.
    //
    if(!File || !Section) {
        return(ERROR_INVALID_DATA);
    }

    //
    // If oldline and newline are both not specified, we're done.
    //
    if(!OldLine && !NewLine) {
        return(NO_ERROR);
    }

    //
    // Open the file and section.
    //
    SectData = pSetupLoadIniFileSection(File,Section,IniSectionCache);
    if(!SectData) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    //
    // If there's an old entry specified, delete it.
    //
    if(OldLine) {

        Key = DuplicateString(OldLine);
        if(!Key) {
            return(ERROR_NOT_ENOUGH_MEMORY);
        }
        p = Key;

        if(Value = _tcschr(Key,TEXT('='))) {
            //
            // Delete by key.
            //
            *Value = 0;
            Value = NULL;
        } else {
            //
            // Delete by value.
            //
            Value = Key;
            Key = NULL;
        }

        pSetupDeleteLineFromSection(SectData,Key,Value);

        MyFree(p);
    }

    //
    // If there's a new entry specified, add it.
    //
    if(NewLine) {

        Key = DuplicateString(NewLine);
        if(!Key) {
            return(ERROR_NOT_ENOUGH_MEMORY);
        }
        p = Key;

        if(Value = _tcschr(Key,TEXT('='))) {
            //
            // There is a key. Depending on flags, we want to match
            // key only or key and value.
            //
            *Value++ = 0;
            b = ((Flags & FLG_MATCH_KEY_AND_VALUE) != 0);

        } else {
            //
            // No key. match whole line. This is the same as matching
            // the RHS only, since no line with a key can match.
            //
            Value = Key;
            Key = NULL;
            b = TRUE;
        }

        if(!pSetupReplaceOrAddLineInSection(SectData,Key,Value,b)) {
            d = ERROR_NOT_ENOUGH_MEMORY;
        }

        MyFree(p);

    }

    return(NO_ERROR);
}


BOOL
pSetupFieldPresentInIniFileLine(
    IN  PTCHAR  Line,
    IN  PCTSTR  Field,
    OUT PTCHAR *Start,
    OUT PTCHAR *End
    )
{
    TCHAR c;
    PTCHAR p,q;
    BOOL b;

    //
    // Skip the key if there is one (there should be one since we use
    // GetPrivateProfileString to query the value!)
    //
    if(p = _tcschr(Line,TEXT('='))) {
        Line = p+1;
    }

    //
    // Skip ini field separators.
    //
    Line += _tcsspn(Line,pszIniFieldSeparators);

    while(*Line) {
        //
        // Locate the end of the field.
        //
        p = Line;
        while(*p && !_tcschr(pszIniFieldSeparators,*p)) {
            if(*p == TEXT('\"')) {
                //
                // Find terminating quote. If none, ignore the quote.
                //
                if(q = _tcschr(p,TEXT('\"'))) {
                    p = q;
                }
            }
            p++;
        }

        //
        // p now points to first char past end of field.
        // Make sure the field is 0-terminated and see if we have
        // what we're looking for.
        c = *p;
        *p = 0;
        b = (lstrcmpi(Line,Field) == 0);
        *p = c;
        //
        // Skip separators so p points to first char in next field,
        // or to the terminating 0.
        //
        p += _tcsspn(p,pszIniFieldSeparators);

        if(b) {
            *Start = Line;
            *End = p;
            return(TRUE);
        }

        Line = p;
    }

    return(FALSE);
}


DWORD_PTR
pSetupProcessUpdateIniFieldsLine(
    IN PVOID       Inf,
    IN PINFCONTEXT InfLineContext,
    IN PVOID       Context
    )

/*++

Routine Description:

    Process a line containing update-ini-fields directives. Such directives
    allow individual values in ini files to be removed, added, or replaced.

    The line is expected to be in the following format:

    <filename>,<section>,<key>,<old-field>,<new-field>,<flags>

    <filename> supplies the filename of the ini file.

    <section> supplies the section in the ini file.

    <key> supplies the keyname of the line in the section in the ini file.

    <old-field> supplies the field to be deleted, if specified.

    <new-field> supplies the field to be added to the line, if specified.

    <flags> are optional flags

Arguments:

    InfLineContext - supplies context for current line in the section.

    Context - Supplies pointer to structure describing loaded ini file sections.

Return Value:

    Win32 error code indicating outcome.

--*/

{
    PCTSTR File;
    PCTSTR Section;
    PCTSTR Key;
    TCHAR Value[512];
    #define BUF_SIZE (sizeof(Value)/sizeof(TCHAR))
    TCHAR CONST *Old,*New;
    PTCHAR Start,End;
    BOOL b;
    DWORD d;
    DWORD Space;
    PCTSTR Separator;
    UINT Flags;
    PINISECTIONCACHE IniSectionCache;
    PINIFILESECTION SectData;
    PTSTR Line;

    IniSectionCache = Context;

    //
    // Get fields.
    //
    File = pSetupGetField(InfLineContext,1);
    Section = pSetupGetField(InfLineContext,2);
    Key = pSetupGetField(InfLineContext,3);

    Old = pSetupGetField(InfLineContext,4);
    if(Old && (*Old == 0)) {
        Old = NULL;
    }

    New = pSetupGetField(InfLineContext,5);
    if(New && (*New == 0)) {
        New = NULL;
    }

    if(!SetupGetIntField(InfLineContext,6,&Flags)) {
        Flags = 0;
    }

    //
    // Filename, section name, and key name are mandatory.
    //
    if(!File || !Section || !Key) {
        return(ERROR_INVALID_DATA);
    }

    //
    // If oldline and newline are both not specified, we're done.
    //
    if(!Old && !New) {
        return(NO_ERROR);
    }

    //
    // Open the file and section.
    //
    SectData = pSetupLoadIniFileSection(File,Section,IniSectionCache);
    if(!SectData) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    Separator = (Flags & FLG_INIFIELDS_USE_SEP2) ? TEXT(", ") : TEXT(" ");

    if(Line = pSetupFindLineInSection(SectData,Key,NULL)) {
        lstrcpyn(Value, Line, BUF_SIZE);
    } else {
        *Value = TEXT('\0');
    }

    //
    // Look for the old field if specified and remove it.
    //
    if(Old) {
        if(pSetupFieldPresentInIniFileLine(Value,Old,&Start,&End)) {
            MoveMemory(Start,End,(lstrlen(End)+1)*sizeof(TCHAR));
        }
    }

    //
    // If a replacement/new field is specified, put it in there.
    //
    if(New) {
        //
        // Calculate the number of chars that can fit in the buffer.
        //
        Space = BUF_SIZE - (lstrlen(Value) + 1);

        //
        // If there's space, stick the new field at the end of the line.
        //
        if(Space >= (DWORD)lstrlen(Separator)) {
            lstrcat(Value,Separator);
            Space -= lstrlen(Separator);
        }

        if(Space >= (DWORD)lstrlen(New)) {
            lstrcat(Value,New);
        }
    }

    //
    // Write the line back out.
    //
    b = pSetupReplaceOrAddLineInSection(SectData,Key,Value,FALSE);
    d = b ? NO_ERROR : ERROR_NOT_ENOUGH_MEMORY;

    return(d);
    #undef BUF_SIZE
}


DWORD_PTR
pSetupProcessDelRegLine(
    IN PVOID       Inf,
    IN PINFCONTEXT InfLineContext,
    IN PVOID       Context
    )

/*++

Routine Description:

    Process a line in the registry that contains delete-registry instructions.
    The line is expected to be in the following forms:

    <root-spec>,<subkey> - delete whole key
    <root-spec>,[<subkey>],[<value-name>][,[<flags>][,<string>]] - delete value

    <Root-spec> is one of HKR, HKLM, etc.

    <subkey> specifies the subkey relative to Root-spec.

    <value-name> is optional. If present if specifies a value entry to be deleted
        from the key. If not present the entire key is deleted. This routine
        cannot handle deleting subtrees; the key to be deleted must not have any
        subkeys or the routine will fail.

    <flags> indicate any special symantics on how to delete this value, and how to interpret the string

    <string> is optional. If flags = FLG_DELREG_MULTI_SZ_DELSTRING, all instances of this string will be removed

Arguments:

    Inf - supplies an INF handle so we can get a LogContext.

    InfLineContext - supplies inf line context for the line containing
        delete-registry instructions.

    Context - supplies the address of a registry modification context
        structure used in deleting the registry value.  The structure is
        defined as:

            typedef struct _REGMOD_CONTEXT {

                DWORD               Flags;          // indicates what fields are filled in
                HKEY                UserRootKey;    // HKR
                PGUID               ClassGuid;      // INF_PFLAG_CLASSPROP
                HMACHINE            hMachine;       // INF_PFLAG_CLASSPROP
                DWORD               DevInst;        // INF_PFLAG_DEVPROP

            } REGMOD_CONTEXT, *PREGMOD_CONTEXT;

        where UserRootKey is a handle to the open inf key to be used as
        the root when HKR is specified as the root for the operation, and
        DevInst is the optional device instance handle that is supplied when
        the DelReg section is for a hardware key (i.e., under the Enum branch).
        If this handle is supplied, then the value is checked to see whether it
        is the name of a Plug&Play device registry property, and if so, the
        registry property is deleted via a CM API _as well as_ via a registry API
        (the property is stored in a different location inaccessible to the registry
        APIs under Windows NT).

Return Value:

    Win32 error code indicating outcome.

--*/

{
    PCTSTR RootKeySpec,SubKeyName,ValueName,Data;
    HKEY RootKey,Key;
    DWORD d,rc;
    PREGMOD_CONTEXT RegModContext = (PREGMOD_CONTEXT)Context;
    UINT_PTR CmPropertyCode;
    DWORD slot_regop = 0;
    BOOL CloseKey;
    UINT DelFlags = 0;
    BOOL NonFatal = FALSE;
    CONFIGRET cr;

    //
    // We shouldn't be doing this against a remote machine.
    //
    MYASSERT(!(RegModContext->hMachine));

    //
    // Get root key spec, subkey name, and value name.
    //
    d = ERROR_INVALID_DATA;
    if((RootKeySpec = pSetupGetField(InfLineContext,1))
    && (SubKeyName = pSetupGetField(InfLineContext,2))) {

        ValueName = pSetupGetField(InfLineContext,3);
        if(!SetupGetIntField(InfLineContext,4,&DelFlags)){
            DelFlags = 0;
        }

        RootKey = pSetupInfRegSpecToKeyHandle(RootKeySpec, RegModContext->UserRootKey, &CloseKey);
        if(RootKey) {
            //
            // Make an information log entry saying we are deleting a key.
            // Note that we must allow for the fact that some parts of the
            // name may be missing.
            //
            if (slot_regop == 0) {
                slot_regop = AllocLogInfoSlot(((PLOADED_INF) Inf)->LogContext,FALSE);
            }
            WriteLogEntry(
                ((PLOADED_INF) Inf)->LogContext,
                slot_regop,
                (ValueName ? MSG_LOG_DELETING_REG_VALUE : MSG_LOG_DELETING_REG_KEY),
                NULL,
                RootKeySpec,
                SubKeyName,
                (*SubKeyName && ValueName ? TEXT("\\") : TEXT("")),
                (ValueName ? (*ValueName ? ValueName : TEXT("-")) : TEXT("")));
            if(ValueName && !(DelFlags & FLG_DELREG_KEYONLY_COMMON)) {

                //
                // at this point, we have been given root,subkey,value
                // we might have flags and other parameters
                //

                if(DelFlags & FLG_ADDREG_DELREG_BIT) {
                    //
                    // if we have a flag and that flag indicates
                    // that the entry must be interpreted as DELREG flags
                    // determine how to process flag
                    //
                    switch (DelFlags) {
                        case FLG_DELREG_32BITKEY | FLG_DELREG_MULTI_SZ_DELSTRING:
                        case FLG_DELREG_64BITKEY | FLG_DELREG_MULTI_SZ_DELSTRING:
                        case FLG_DELREG_MULTI_SZ_DELSTRING: {
                            Data = pSetupGetField(InfLineContext,5);
                            if (Data && *Data) {
                                //
                                // we have valid parameters for this flag
                                //
                                REGMOD_CONTEXT NewContext = *RegModContext;
                                if(NewContext.UserRootKey != RootKey) {
                                    NewContext.Flags = 0;               // if root is not HKR, clear context flags
                                    NewContext.UserRootKey = RootKey;
                                }

                                WriteLogEntry(
                                    ((PLOADED_INF) Inf)->LogContext,
                                    slot_regop,
                                    MSG_LOG_DELETING_REG_KEY_DELSTRING,
                                    NULL,
                                    RootKeySpec,
                                    SubKeyName,
                                    (*SubKeyName ? TEXT("\\") : TEXT("")),
                                    (*ValueName ? ValueName : TEXT("-")),
                                    Data);

                                //
                                // handling of all special cases done via this internal function
                                //
                                d = _DeleteStringFromMultiSz(
                                        SubKeyName,
                                        ValueName,
                                        Data,
                                        DelFlags,           // specify exact flag
                                        &NewContext
                                        );
                                if (d == ERROR_INVALID_DATA) {
                                    //
                                    // this error code is over-used :-( but get's returned if type mismatches
                                    // we don't consider type mismatch as fatal
                                    //
                                    NonFatal = TRUE;
                                }
                            } else {
                                WriteLogEntry(
                                    ((PLOADED_INF) Inf)->LogContext,
                                    slot_regop,
                                    MSG_LOG_DELETING_REG_KEY_FLAGS,
                                    NULL,
                                    RootKeySpec,
                                    SubKeyName,
                                    (*SubKeyName ? TEXT("\\") : TEXT("")),
                                    (*ValueName ? ValueName : TEXT("-")),
                                    DelFlags);

                                d = ERROR_INVALID_DATA;
                            }
                            goto clean0;
                        }

                        default:
                            WriteLogEntry(
                                ((PLOADED_INF) Inf)->LogContext,
                                slot_regop,
                                MSG_LOG_DELETING_REG_KEY_FLAGS,
                                NULL,
                                RootKeySpec,
                                SubKeyName,
                                (*SubKeyName ? TEXT("\\") : TEXT("")),
                                (*ValueName ? ValueName : TEXT("-")),
                                DelFlags);

                            d = ERROR_INVALID_DATA;
                            goto clean0;
                    }
                }


                if(*ValueName && !(*SubKeyName)) {
                    //
                    // If the key being used is HKR with no subkey specified, and if we
                    // are doing the DelReg for a hardware key (i.e., DevInst is non-NULL,
                    // then we need to check to see whether the value entry is the name of
                    // a device registry property.
                    //
                    if ((RegModContext->Flags & INF_PFLAG_CLASSPROP) != 0 &&
                        LookUpStringInTable(InfRegValToClassRegProp, ValueName, &CmPropertyCode)) {
                        //
                        // This value is a class registry property--we must delete the property
                        // by calling a CM API.
                        //
                        cr = CM_Set_Class_Registry_Property(RegModContext->ClassGuid,
                                                         (ULONG)CmPropertyCode,
                                                         NULL,
                                                         0,
                                                         0,
                                                         RegModContext->hMachine
                                                        );
                        switch (cr) {
                            case CR_SUCCESS:
                                rc = NO_ERROR;
                                break;

                            case CR_NO_SUCH_VALUE:
                                rc = ERROR_FILE_NOT_FOUND;
                                break;

                            case CR_INVALID_DEVINST:
                                rc = ERROR_NO_SUCH_DEVINST;
                                break;

                            default:
                                rc = ERROR_INVALID_DATA;
                                break;
                        }
                        if (rc != NO_ERROR && rc != ERROR_FILE_NOT_FOUND) {
                            //
                            // Log that an error occurred accessing CM value
                            //
                            WriteLogError(
                                ((PLOADED_INF) Inf)->LogContext,
                                SETUP_LOG_ERROR,
                                rc);
                        }
                        //
                        // fall through to delete normal registry value, if one exists
                        //
                    } else if ((RegModContext->Flags & INF_PFLAG_DEVPROP) != 0 &&
                       LookUpStringInTable(InfRegValToDevRegProp, ValueName, &CmPropertyCode)) {
                        //
                        // This value is a device registry property--we must delete the property
                        // by calling a CM API.
                        //
                        cr = CM_Set_DevInst_Registry_Property(RegModContext->DevInst,
                                                         (ULONG)CmPropertyCode,
                                                         NULL,
                                                         0,
                                                         0
                                                        );
                        switch (cr) {
                            case CR_SUCCESS:
                                rc = NO_ERROR;
                                break;

                            case CR_NO_SUCH_VALUE:
                                rc = ERROR_FILE_NOT_FOUND;
                                break;

                            case CR_INVALID_DEVINST:
                                rc = ERROR_NO_SUCH_DEVINST;
                                break;

                            default:
                                rc = ERROR_INVALID_DATA;
                                break;
                        }
                        if (rc != NO_ERROR && rc != ERROR_FILE_NOT_FOUND) {
                            //
                            // Log that an error occurred accessing CM value
                            //
                            WriteLogError(
                                ((PLOADED_INF) Inf)->LogContext,
                                SETUP_LOG_ERROR,
                                rc);
                        }
                        //
                        // fall through to delete normal registry value, if one exists
                        //
                    }
                }

                //
                // Open subkey for delete.
                //
                d = RegOpenKeyEx(
                        RootKey,
                        SubKeyName,
                        0,
#ifdef _WIN64
                        (( DelFlags & FLG_DELREG_32BITKEY ) ? KEY_WOW64_32KEY:0) |
#else
                        (( DelFlags & FLG_DELREG_64BITKEY ) ? KEY_WOW64_64KEY:0) |
#endif
                        KEY_SET_VALUE | KEY_QUERY_VALUE,
                        &Key
                        );

                if(d == NO_ERROR) {
                    d = RegDeleteValue(Key,ValueName);
                    RegCloseKey(Key);
                }

            } else {
                //
                // if we get here, we're only deleting the key
                //
                d = pSetupRegistryDelnodeEx(RootKey,SubKeyName,DelFlags);
            }

            if (CloseKey) {
                RegCloseKey( RootKey );
            }

        } else {
            d = ERROR_BADKEY;
        }
    } else {
        WriteLogEntry(
            ((PLOADED_INF) Inf)->LogContext,
            SETUP_LOG_ERROR,
            MSG_LOG_DELREG_PARAMS,
            NULL);
        return d;
    }

clean0:
    if (CloseKey) {
        RegCloseKey( RootKey );
    }

    if (d != NO_ERROR && d != ERROR_FILE_NOT_FOUND) {
        //
        // Log that an error occurred.
        //
        WriteLogError(
            ((PLOADED_INF) Inf)->LogContext,
            (NonFatal?SETUP_LOG_INFO:SETUP_LOG_ERROR),
            d);
        if (NonFatal) {
            d = NO_ERROR;
        }
    } else if (d != NO_ERROR) {
        //
        // verbose case, not full error, indicate what we did
        //
        WriteLogError(
            ((PLOADED_INF) Inf)->LogContext,
            SETUP_LOG_VERBOSE,
            d);
        d = NO_ERROR;

    } else {

        //
        // just flush the buffer
        //
        WriteLogEntry(
            ((PLOADED_INF) Inf)->LogContext,
            SETUP_LOG_VERBOSE,
            0,
            NULL);
    }

    if (slot_regop) {
        ReleaseLogInfoSlot(((PLOADED_INF) Inf)->LogContext,slot_regop);
    }
    return(d);
}

DWORD_PTR
pSetupProcessAddRegLine(
    IN PVOID       Inf,
    IN PINFCONTEXT InfLineContext,
    IN PVOID       Context
    )

/*++

Routine Description:

    Process a line in the INF that contains add-registry instructions.
    The line is expected to be in the following form:

    <root-spec>,<subkey>,<value-name>,<flags>,<value>...

    <Root-spec> is one of HKR, HKLM, etc.

    <subkey> specifies the subkey relative to Root-spec.

    <value-name> is optional. If not present the default value is set.

    <flags> is optional and supplies flags, such as to indicate the data type.
        These are the FLG_ADDREG_* flags defined in setupapi.h, and are a
        superset of those defined for Win95 in setupx.h.

    <value> is one or more values used as the data. The format depends
        on the value type. This value is optional. For REG_DWORD, the
        default is 0. For REG_SZ, REG_EXPAND_SZ, the default is the
        empty string. For REG_BINARY the default is a 0-length entry.
        For REG_MULTI_SZ the default is a single empty string.

    note that if <flags> has FLG_ADDREG_DELREG_BIT set, we ignore the line.

Arguments:

    Inf - supplies an INF handle so we can get a LogContext.

    InfLineContext - supplies inf line context for the line containing
        add-registry instructions.

    Context - supplies the address of a registry modification context
        structure used in adding the registry value.  The structure is
        defined as:

            typedef struct _REGMOD_CONTEXT {

                DWORD               Flags;          // indicates what fields are filled in
                HKEY                UserRootKey;    // HKR
                PGUID               ClassGuid;      // INF_PFLAG_CLASSPROP
                HMACHINE            hMachine;       // INF_PFLAG_CLASSPROP
                DWORD               DevInst;        // INF_PFLAG_DEVPROP

            } REGMOD_CONTEXT, *PREGMOD_CONTEXT;

        where UserRootKey is a handle to the open inf key to be used as
        the root when HKR is specified as the root for the operation, and
        DevInst is the optional device instance handle that is supplied when
        the AddReg section is for a hardware key (i.e., under the Enum branch).
        If this handle is supplied, then the value is checked to see whether it
        is the name of a Plug&Play device registry property, and if so, the
        registry property is set via a CM API instead of via the registry API
        (which doesn't refer to the same location on Windows NT).
        Flags indicates if DevInst should be used, or if ClassGuid/hMachine pair should be used

Return Value:

    Win32 error code indicating outcome.

--*/

{
    PCTSTR RootKeySpec,SubKeyName,ValueName;
    PCTSTR ValueTypeSpec;
    DWORD ValueType;
    HKEY RootKey,Key;
    DWORD d = NO_ERROR;
    BOOL b;
    INT IntVal;
    DWORD Size;
    DWORD ReqSize;
    PVOID Data;
    DWORD Disposition;
    UINT Flags = 0;
    PTSTR *Array;
    PREGMOD_CONTEXT RegModContext = (PREGMOD_CONTEXT)Context;
    UINT_PTR CmPropertyCode;
    PVOID ConvertedBuffer;
    DWORD ConvertedBufferSize;
    CONFIGRET cr;
    DWORD slot_regop = 0;
    BOOL CloseKey = FALSE;



    //
    // We shouldn't be doing this against a remote machine.
    //
    MYASSERT(!(RegModContext->hMachine));

    //
    // Get root key spec.  If we can't get the root key spec, we don't do anything and
    // return NO_ERROR.
    //
    if(RootKeySpec = pSetupGetField(InfLineContext,1)) {

        RootKey = pSetupInfRegSpecToKeyHandle(RootKeySpec, RegModContext->UserRootKey, &CloseKey);
        if(!RootKey) {
            WriteLogEntry(
                ((PLOADED_INF) Inf)->LogContext,
                SETUP_LOG_ERROR,
                MSG_LOG_ADDREG_NOROOT,
                NULL);
            return(ERROR_BADKEY);
        }

        //
        // SubKeyName is optional.
        //
        SubKeyName = pSetupGetField(InfLineContext,2);

        //
        // ValueName is optional. Either NULL or "" are acceptable
        // to pass to RegSetValueEx.
        //
        ValueName = pSetupGetField(InfLineContext,3);



        //
        // If we don't have a value name, the type is REG_SZ to force
        // the right behavior in RegSetValueEx. Otherwise get the data type.
        //

        ValueType = REG_SZ;
        if(ValueName) {
            if(!SetupGetIntField(InfLineContext,4,&Flags)) {
                Flags = 0;
            }


            if (Flags & FLG_ADDREG_DELREG_BIT) {
                d = NO_ERROR;
                //
                // Log that an error occurred
                //
                WriteLogEntry(
                    ((PLOADED_INF) Inf)->LogContext,
                    SETUP_LOG_VERBOSE,
                    MSG_LOG_SKIP_DELREG_KEY,
                    NULL,
                    RootKeySpec,
                    (SubKeyName ? SubKeyName : TEXT("")),
                    (SubKeyName && ValueName
                     && *SubKeyName && *ValueName ? TEXT("\\") : TEXT("")),
                    (ValueName ? ValueName : TEXT("")),
                    Flags);

                goto clean1;
            }
            switch(Flags & FLG_ADDREG_TYPE_MASK) {

                case FLG_ADDREG_TYPE_SZ :
                    ValueType = REG_SZ;
                    break;

                case FLG_ADDREG_TYPE_MULTI_SZ :
                    ValueType = REG_MULTI_SZ;
                    break;

                case FLG_ADDREG_TYPE_EXPAND_SZ :
                    ValueType = REG_EXPAND_SZ;
                    break;

                case FLG_ADDREG_TYPE_BINARY :
                    ValueType = REG_BINARY;
                    break;

                case FLG_ADDREG_TYPE_DWORD :
                    ValueType = REG_DWORD;
                    break;

                case FLG_ADDREG_TYPE_NONE :
                    ValueType = REG_NONE;
                    break;

                default :
                    //
                    // If the FLG_ADDREG_BINVALUETYPE is set, then the highword
                    // can contain just about any random reg data type ordinal value.
                    //
                    if(Flags & FLG_ADDREG_BINVALUETYPE) {
                        //
                        // Disallow the following reg data types:
                        //
                        //    REG_NONE, REG_SZ, REG_EXPAND_SZ, REG_MULTI_SZ
                        //
                        ValueType = (DWORD)HIWORD(Flags);

                        if((ValueType < REG_BINARY) || (ValueType == REG_MULTI_SZ)) {
                            d = ERROR_INVALID_DATA;
                            goto clean1;
                        }

                    } else {
                        d = ERROR_INVALID_DATA;
                        goto clean1;
                    }
            }
            //
            // Presently, the append behavior flag is only supported for
            // REG_MULTI_SZ values.
            //
            if((Flags & FLG_ADDREG_APPEND) && (ValueType != REG_MULTI_SZ)) {
                d = ERROR_INVALID_DATA;
                goto clean1;
            }
        }

        //
        // On Win9x setting the unnamed value to REG_EXPAND_SZ doesn't
        // work. So we convert to REG_SZ, assuming that anyone on Win9x trying
        // to do this has done the appropriate substitutions. This is a fix
        // for the IE guys, apparently advpack.dll does the right thing to
        // make the fix below viable.
        //
        if((OSVersionInfo.dwPlatformId != VER_PLATFORM_WIN32_NT)
        && (!ValueName || (*ValueName == 0))
        && (ValueType == REG_EXPAND_SZ)) {

            ValueType = REG_SZ;
        }

        //
        // Get the data based on type.
        //
        switch(ValueType) {

        case REG_MULTI_SZ:
            if(Flags & FLG_ADDREG_APPEND) {
                //
                // This is MULTI_SZ_APPEND, which means to append the string value to
                // an existing multi_sz if it's not already there.
                //
                if(SetupGetStringField(InfLineContext,5,NULL,0,&Size)) {
                    Data = MyMalloc(Size*sizeof(TCHAR));
                    if(!Data) {
                        d = ERROR_NOT_ENOUGH_MEMORY;
                        goto clean1;
                    }
                    if(SetupGetStringField(InfLineContext,5,Data,Size,NULL)) {
                        REGMOD_CONTEXT NewContext = *RegModContext;
                        if(NewContext.UserRootKey != RootKey) {
                            NewContext.Flags = 0;               // if new root, clear context flags
                            NewContext.UserRootKey = RootKey;
                        }

                        d = _AppendStringToMultiSz(
                                SubKeyName,
                                ValueName,
                                (PCTSTR)Data,
                                FALSE,           // don't allow duplicates.
                                &NewContext,
                                Flags
                                );
                    } else {
                        d = GetLastError();
                    }
                    MyFree(Data);
                } else {
                    d = ERROR_INVALID_DATA;
                }
                goto clean1;

            } else {

                if(SetupGetMultiSzField(InfLineContext, 5, NULL, 0, &Size)) {
                    Data = MyMalloc(Size*sizeof(TCHAR));
                    if(!Data) {
                        d = ERROR_NOT_ENOUGH_MEMORY;
                        goto clean1;
                    }
                    if(!SetupGetMultiSzField(InfLineContext, 5, Data, Size, NULL)) {
                        d = GetLastError();
                        MyFree(Data);
                        goto clean1;
                    }
                    Size *= sizeof(TCHAR);
                } else {
                    Size = sizeof(TCHAR);
                    Data = MyMalloc(Size);
                    if(!Data) {
                        d = ERROR_NOT_ENOUGH_MEMORY;
                        goto clean1;
                    }
                    *((PTCHAR)Data) = TEXT('\0');
                }
                break;
            }

        case REG_DWORD:
            //
            // Since the old SetupX APIs only allowed REG_BINARY, INFs had to specify REG_DWORD
            // by listing all 4 bytes separately.  Support the old format here, by checking to
            // see whether the line has 4 bytes, and if so, combine those to form the DWORD.
            //
            Size = sizeof(DWORD);
            Data = MyMalloc(sizeof(DWORD));
            if(!Data) {
                d = ERROR_NOT_ENOUGH_MEMORY;
                goto clean1;
            }

            if(SetupGetFieldCount(InfLineContext) == 8) {
                //
                // Then the DWORD is specified as a list of its constituent bytes.
                //
                if(!SetupGetBinaryField(InfLineContext,5,Data,Size,NULL)) {
                    d = GetLastError();
                    MyFree(Data);
                    goto clean1;
                }
            } else {
                if(!SetupGetIntField(InfLineContext,5,(PINT)Data)) {
                    *(PINT)Data = 0;
                }
            }
            break;

        case REG_SZ:
        case REG_EXPAND_SZ:
            if(SetupGetStringField(InfLineContext,5,NULL,0,&Size)) {
                Data = MyMalloc(Size*sizeof(TCHAR));
                if(!Data) {
                    d = ERROR_NOT_ENOUGH_MEMORY;
                    goto clean1;
                }
                if(!SetupGetStringField(InfLineContext,5,Data,Size,NULL)) {
                    d = GetLastError();
                    MyFree(Data);
                    goto clean1;
                }
                Size *= sizeof(TCHAR);
            } else {
                Size = sizeof(TCHAR);
                Data = DuplicateString(TEXT(""));
                if(!Data) {
                    d = ERROR_NOT_ENOUGH_MEMORY;
                    goto clean1;
                }
            }
            break;

        case REG_BINARY:
        default:
            //
            // All other values are specified in REG_BINARY form (i.e., one byte per field).
            //
            if(SetupGetBinaryField(InfLineContext, 5, NULL, 0, &Size)) {
                Data = MyMalloc(Size);
                if(!Data) {
                    d = ERROR_NOT_ENOUGH_MEMORY;
                    goto clean1;
                }
                if(!SetupGetBinaryField(InfLineContext, 5, Data, Size, NULL)) {
                    d = GetLastError();
                    MyFree(Data);
                    goto clean1;
                }
            } else {
                //
                // error occurred
                //
                d = GetLastError();
                goto clean1;
            }
            break;
        }

        //
        // Set this variable to TRUE only if this value should not be set later on in a call to
        // RegSetValueEx (e.g., if this value is a DevReg Property).
        //
        b = FALSE;

        //
        // Open/create the key.
        //
        if(SubKeyName && *SubKeyName) {
#ifdef UNICODE
            //
            // Warning--extreme hack ahead!!!
            //
            // If we're running in non-interactive mode, we cannot allow
            // RunOnce processing to happen in that context (typically, in TCB)
            // because we have no control over what stuff gets registered for
            // RunOnce.  Also, we can't kick off RunOnce in the context of a
            // logged-on user, because if it's a non-administrator, some of
            // the operations may fail, and be lost forever (SWENUM is a prime
            // example of this).
            //
            // Therefore, when we're in non-interactive mode, we "swallow" any
            // AddReg directives for RunOnce entries that use rundll32, and
            // squirrel them away in a global list.  The caller (i.e.,
            // umpnpmgr) can retrieve this list and do the job of rundll32
            // manually for these entries.  If we encounter any other kinds of
            // runonce entries, we bail.
            //
            if((GlobalSetupFlags & PSPGF_NONINTERACTIVE) &&
               (RootKey == HKEY_LOCAL_MACHINE) &&
               !lstrcmpi(SubKeyName, pszPathRunOnce) &&
               ((ValueType == REG_SZ) || (ValueType == REG_EXPAND_SZ))) {

                TCHAR szBuffer[MAX_PATH];
                PTSTR p, q, DontCare;
                DWORD DllPathSize;
                PTSTR DllFullPath, DllParams;
                PSTR  DllEntryPointName;
                PPSP_RUNONCE_NODE CurNode, NewNode;
                BOOL NodeAlreadyInList;
                PSP_ALTPLATFORM_INFO_V2 ValidationPlatform;

                //
                // We're looking at a RunOnce entry--see if it's rundll32-based.
                //
                p = _tcschr((PTSTR)Data, TEXT(' '));

                if(p) {

                    *p = TEXT('\0'); // separate 1st part of string for comparison

                    if(!lstrcmpi((PTSTR)Data, TEXT("rundll32.exe")) ||
                       !lstrcmpi((PTSTR)Data, TEXT("rundll32"))) {
                        //
                        // We have ourselves a rundll32 entry!  The next
                        // component (up until we hit a comma) is the name of
                        // the DLL we're supposed to load/run.
                        //
                        // NOTE--we don't deal with the (highly unlikely) case
                        // where the path has an embedded comma in it,
                        // surrounded by quotes.  Oh well.
                        //
                        p++;

                        q = _tcschr(p, TEXT(','));

                        if(q) {

                            *(q++) = TEXT('\0'); // separate 2nd part of string

                            if(ValueType == REG_EXPAND_SZ) {
                                ReqSize = ExpandEnvironmentStrings(p, szBuffer, SIZECHARS(szBuffer));
                                if(ReqSize == 0) {
                                    d = GetLastError();
                                    goto clean0;
                                } else if(ReqSize > SIZECHARS(szBuffer)) {
                                    d = ERROR_INSUFFICIENT_BUFFER;
                                    goto clean0;
                                }
                            } else {
                                lstrcpyn(szBuffer, p, (size_t)(q - p));
                            }

                            p = (PTSTR)pSetupGetFileTitle(szBuffer);
                            if(!_tcschr(p, TEXT('.'))) {
                                //
                                // The file doesn't have an extension--assume
                                // it's a DLL.
                                //
                                _tcscat(p, TEXT(".dll"));
                            }

                            p = DuplicateString(szBuffer);
                            if(!p) {
                                d = ERROR_NOT_ENOUGH_MEMORY;
                                goto clean0;
                            }

                            if(p == pSetupGetFileTitle(p)) {
                                //
                                // The filename is a simple filename--assume it
                                // exists in %windir%\system32.
                                //
                                lstrcpyn(szBuffer, SystemDirectory,SIZECHARS(szBuffer));
                                pSetupConcatenatePaths(szBuffer, p, SIZECHARS(szBuffer), NULL);

                            } else {
                                //
                                // The filename contains path information--get
                                // the fully-qualified path.
                                //
                                DllPathSize = GetFullPathName(
                                                  p,
                                                  SIZECHARS(szBuffer),
                                                  szBuffer,
                                                  &DontCare
                                                 );

                                if(!DllPathSize || (DllPathSize >= SIZECHARS(szBuffer))) {
                                    //
                                    // If we start failing because MAX_PATH
                                    // isn't big enough anymore, we wanna know
                                    // about it!
                                    //
                                    MYASSERT(DllPathSize < SIZECHARS(szBuffer));
                                    MyFree(p);
                                    d = GetLastError();
                                    goto clean0;
                                }
                            }

                            //
                            // No longer need temp string copy.
                            //
                            MyFree(p);

                            DllFullPath = DuplicateString(szBuffer);
                            if(!DllFullPath) {
                                d = ERROR_NOT_ENOUGH_MEMORY;
                                goto clean0;
                            }

                            //
                            // OK, now that we have the full path of the DLL,
                            // verify its digital signature.
                            //
                            IsInfForDeviceInstall(((PLOADED_INF)Inf)->LogContext,
                                                  NULL,
                                                  (PLOADED_INF)Inf,
                                                  NULL,
                                                  &ValidationPlatform,
                                                  NULL,
                                                  NULL,
                                                  FALSE
                                                 );

                            //
                            // We only verify using driver signing policy for
                            // server-side installations.  This is because we
                            // don't have the context to figure out what
                            // specific Authenticode-signed catalog to use.
                            //
                            d = _VerifyFile(((PLOADED_INF)Inf)->LogContext,
                                            NULL,
                                            NULL,
                                            NULL,
                                            0,
                                            pSetupGetFileTitle(DllFullPath),
                                            DllFullPath,
                                            NULL,
                                            NULL,
                                            FALSE,
                                            ValidationPlatform,
                                            (VERIFY_FILE_USE_OEM_CATALOGS | VERIFY_FILE_NO_DRIVERBLOCKED_CHECK),
                                            NULL,
                                            NULL,
                                            NULL,
                                            NULL,
                                            NULL
                                           );

                            //
                            // Free validation platform info struct, if we had
                            // one allocated above as a result of calling
                            // IsInfForDeviceInstall().
                            //
                            if(ValidationPlatform) {
                                MyFree(ValidationPlatform);
                            }

                            if(d != NO_ERROR) {
                                MyFree(DllFullPath);
                                goto clean0;
                            }

                            //
                            // The DLL seems acceptable to be loaded/run in the
                            // context of the caller.  Retrieve the entrypoint
                            // name (in ANSI), as well as the argument string
                            // to be passed to the DLL.
                            //
                            p = _tcschr(q, TEXT(' '));
                            if(p) {
                                *(p++) = TEXT('\0');
                                DllParams = DuplicateString(p);
                            } else {
                                DllParams = DuplicateString(TEXT(""));
                            }

                            if(!DllParams) {
                                d = ERROR_NOT_ENOUGH_MEMORY;
                                MyFree(DllFullPath);
                                goto clean0;
                            }

                            DllEntryPointName = pSetupUnicodeToAnsi(q);

                            if(!DllEntryPointName) {
                                d = ERROR_NOT_ENOUGH_MEMORY;
                                MyFree(DllFullPath);
                                MyFree(DllParams);
                                goto clean0;
                            }

                            //
                            // If we get to this point, we have the full DLL
                            // path, the DLL entrypoint (always in ANSI, since
                            // that's what GetProcAddress wants), and the DLL
                            // argument string.  Before we create a new node
                            // to add to our global list, scan the list to see
                            // if the node is already in there (if so, we don't
                            // need to add it again).
                            //
                            NodeAlreadyInList = FALSE;

                            if(RunOnceListHead) {

                                CurNode = NULL;

                                do {
                                    if(CurNode) {
                                        CurNode = CurNode->Next;
                                    } else {
                                        CurNode = RunOnceListHead;
                                    }

                                    if(!lstrcmpi(DllFullPath, CurNode->DllFullPath) &&
                                       !lstrcmpiA(DllEntryPointName, CurNode->DllEntryPointName) &&
                                       !lstrcmpi(DllParams, CurNode->DllParams)) {
                                        //
                                        // We have a duplicate--no need to do
                                        // the same RunOnce operation twice.
                                        //
                                        NodeAlreadyInList = TRUE;
                                        break;
                                    }

                                } while(CurNode->Next);
                            }

                            //
                            // Now create a new rundll32 node and stick it in
                            // our global list (unless it's already in there).
                            //
                            if(NodeAlreadyInList) {
                                NewNode = NULL;
                            } else {
                                NewNode = MyMalloc(sizeof(PSP_RUNONCE_NODE));
                                if(!NewNode) {
                                    d = ERROR_NOT_ENOUGH_MEMORY;
                                }
                            }

                            if(NewNode) {

                                NewNode->Next = NULL;
                                NewNode->DllFullPath = DllFullPath;
                                NewNode->DllEntryPointName = DllEntryPointName;
                                NewNode->DllParams = DllParams;

                                //
                                // Add our new node to the end of the list (we
                                // already found the end of the list above when
                                // doing our duplicate search.
                                //
                                if(RunOnceListHead) {
                                    CurNode->Next = NewNode;
                                } else {
                                    RunOnceListHead = NewNode;
                                }

                            } else {
                                //
                                // Either we couldn't allocate a new node entry
                                // (i.e., due to out-of-memory), or we didn't
                                // need to (because the node was already in the
                                // list.
                                //
                                MyFree(DllFullPath);
                                MyFree(DllEntryPointName);
                                MyFree(DllParams);
                            }

                            goto clean0;

                        } else {
                            //
                            // Improperly-formatted rundll32 entry.
                            //
                            d = ERROR_INVALID_DATA;
                            goto clean0;
                        }

                    } else {
                        //
                        // We don't know how to deal with anything else--abort!
                        //
                        d = ERROR_REQUIRES_INTERACTIVE_WINDOWSTATION;
                        goto clean0;
                    }

                } else {
                    //
                    // We don't know how to deal with anything else--abort!
                    //
                    d = ERROR_REQUIRES_INTERACTIVE_WINDOWSTATION;
                    goto clean0;
                }
            }
#endif // UNICODE

            if(Flags & FLG_ADDREG_OVERWRITEONLY) {

                d = RegOpenKeyEx(
                        RootKey,
                        SubKeyName,
                        0,
#ifdef _WIN64
                        (( Flags & FLG_ADDREG_32BITKEY ) ? KEY_WOW64_32KEY:0) |
#else
                        (( Flags & FLG_ADDREG_64BITKEY ) ? KEY_WOW64_64KEY:0) |
#endif
                        KEY_QUERY_VALUE | KEY_SET_VALUE,
                        &Key
                        );

                Disposition = REG_OPENED_EXISTING_KEY;

            } else {
                d = RegCreateKeyEx(
                        RootKey,
                        SubKeyName,
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
#ifdef _WIN64
                        (( Flags & FLG_ADDREG_32BITKEY ) ? KEY_WOW64_32KEY:0) |
#else
                        (( Flags & FLG_ADDREG_64BITKEY ) ? KEY_WOW64_64KEY:0) |
#endif
                        KEY_QUERY_VALUE | KEY_SET_VALUE,
                        NULL,
                        &Key,
                        &Disposition
                        );
            }

            if(d == NO_ERROR) {

                if(Disposition == REG_OPENED_EXISTING_KEY) {

                    //
                    // Work around hacked nonsense on Win95 where the unnamed value
                    // behaves differently.
                    //
                    if((Flags & FLG_ADDREG_NOCLOBBER)
                    && ((ValueName == NULL) || (*ValueName == 0))
                    && (OSVersionInfo.dwPlatformId != VER_PLATFORM_WIN32_NT)) {

                        d = 0;
                        if(RegQueryValueEx(Key,TEXT(""),NULL,NULL,(BYTE *)&Disposition,&d) == NO_ERROR) {
                            //
                            // The unnamed value entry is not set.
                            //
                            Flags &= ~FLG_ADDREG_NOCLOBBER;
                        }

                        d = NO_ERROR;
                    }

                    if(Flags & FLG_ADDREG_DELVAL) {
                        //
                        // Added for compatibility with Setupx (lonnym):
                        //     If this flag is present, then the data for this value is ignored, and
                        //     the value entry is deleted.
                        //
                        b = TRUE;
                        RegDeleteValue(Key, ValueName);
                    }
                } else {
                    //
                    // Win9x gets confused and thinks the nonamed value is there
                    // so we never overwrite if noclobber is set. Turn it off here.
                    //
                    Flags &= ~FLG_ADDREG_NOCLOBBER;
                }
            }

        } else {

            d = NO_ERROR;

            //
            // If the key being used is HKR with no subkey specified, and if we
            // are doing the AddReg for a hardware key or for a ClassInstall32
            // entry, then we need to check to see whether the value entry we
            // have is the name of a device or class registry property.
            //
            if((RegModContext->Flags & INF_PFLAG_CLASSPROP) != 0 && ValueName && *ValueName &&
                LookUpStringInTable(InfRegValToClassRegProp, ValueName, &CmPropertyCode)) {

                ULONG ExistingPropDataSize = 0;

                b = TRUE;   // we're handling this name here

                //
                // This value is a class registry property--if noclobber flag
                // is set, we must verify that the property doesn't currently
                // exist.
                //

                if((!(Flags & FLG_ADDREG_NOCLOBBER)) ||
                   (CM_Get_Class_Registry_Property(RegModContext->ClassGuid,
                                                     (ULONG)CmPropertyCode,
                                                     NULL,
                                                     NULL,
                                                     &ExistingPropDataSize,
                                                     0,
                                                      RegModContext->hMachine) == CR_NO_SUCH_VALUE)) {
                    //
                    // Next, make sure the data is valid (doing conversion if
                    // necessary and possible).
                    //
                    if((d = pSetupValidateClassRegProp((ULONG)CmPropertyCode,
                                                     ValueType,
                                                     Data,
                                                     Size,
                                                     &ConvertedBuffer,
                                                     &ConvertedBufferSize)) == NO_ERROR) {

                        if((cr = CM_Set_Class_Registry_Property(RegModContext->ClassGuid,
                                                                  (ULONG)CmPropertyCode,
                                                                  ConvertedBuffer ? ConvertedBuffer
                                                                                  : Data,
                                                                  ConvertedBuffer ? ConvertedBufferSize
                                                                                  : Size,
                                                                  0,
                                                                  RegModContext->hMachine)) != CR_SUCCESS) {

                            d = (cr == CR_INVALID_DEVINST) ? ERROR_NO_SUCH_DEVINST
                                                           : ERROR_INVALID_DATA;
                        }

                        if(ConvertedBuffer) {
                            MyFree(ConvertedBuffer);
                        }
                    }
                }

            } else if((RegModContext->Flags & INF_PFLAG_DEVPROP) != 0 && ValueName && *ValueName &&
               LookUpStringInTable(InfRegValToDevRegProp, ValueName, &CmPropertyCode)) {

                ULONG ExistingPropDataSize = 0;

                b = TRUE;   // we're handling this name here

                //
                // This value is a device registry property--if noclobber flag
                // is set, we must verify that the property doesn't currently
                // exist.
                //
                if((!(Flags & FLG_ADDREG_NOCLOBBER)) ||
                   (CM_Get_DevInst_Registry_Property(RegModContext->DevInst,
                                                     (ULONG)CmPropertyCode,
                                                     NULL,
                                                     NULL,
                                                     &ExistingPropDataSize,
                                                     0) == CR_NO_SUCH_VALUE)) {
                    //
                    // Next, make sure the data is valid (doing conversion if
                    // necessary and possible).
                    //
                    if((d = pSetupValidateDevRegProp((ULONG)CmPropertyCode,
                                                     ValueType,
                                                     Data,
                                                     Size,
                                                     &ConvertedBuffer,
                                                     &ConvertedBufferSize)) == NO_ERROR) {

                        if((cr = CM_Set_DevInst_Registry_Property(RegModContext->DevInst,
                                                                  (ULONG)CmPropertyCode,
                                                                  ConvertedBuffer ? ConvertedBuffer
                                                                                  : Data,
                                                                  ConvertedBuffer ? ConvertedBufferSize
                                                                                  : Size,
                                                                  0)) != CR_SUCCESS) {

                            d = (cr == CR_INVALID_DEVINST) ? ERROR_NO_SUCH_DEVINST
                                                           : ERROR_INVALID_DATA;
                        }

                        if(ConvertedBuffer) {
                            MyFree(ConvertedBuffer);
                        }
                    }
                }
            }

            //
            // Regardless of whether this value is a devinst registry property,
            // we need to set the Key equal to the RootKey (So we won't think
            // it's a newly-opened key and try to close it later.
            //
            Key = RootKey;
        }

        if(d == NO_ERROR) {

            if(!b) {
                //
                // If noclobber flag is set, then make sure that the value entry doesn't already exist.
                // Also respect the keyonly flag.
                //
                if(!(Flags & (FLG_ADDREG_KEYONLY | FLG_ADDREG_KEYONLY_COMMON))) {

                    if(Flags & FLG_ADDREG_NOCLOBBER) {
                        b = (RegQueryValueEx(Key,ValueName,NULL,NULL,NULL,NULL) != NO_ERROR);
                    } else {
                        if(Flags & FLG_ADDREG_OVERWRITEONLY) {
                            b = (RegQueryValueEx(Key,ValueName,NULL,NULL,NULL,NULL) == NO_ERROR);
                        } else {
                            b = TRUE;
                        }
                    }

                    //
                    // Set the value. Note that at this point d is NO_ERROR.
                    //
                    if(b) {
                        d = RegSetValueEx(Key,ValueName,0,ValueType,Data,Size);
                    }
                }
            }

            if(Key != RootKey) {
                RegCloseKey(Key);
            }
        } else {
            if(Flags & FLG_ADDREG_OVERWRITEONLY) {
                d = NO_ERROR;
            }
        }

#ifdef UNICODE

clean0:

#endif

        MyFree(Data);
    }

clean1:

    if(d != NO_ERROR) {
        //
        // Log that an error occurred
        //
        WriteLogEntry(
            ((PLOADED_INF) Inf)->LogContext,
            SETUP_LOG_ERROR,
            MSG_LOG_SETTING_REG_KEY,
            NULL,
            RootKeySpec,
            (SubKeyName ? SubKeyName : TEXT("")),
            (SubKeyName && ValueName
             && *SubKeyName && *ValueName ? TEXT("\\") : TEXT("")),
            (ValueName ? ValueName : TEXT("")));

        WriteLogError(
            ((PLOADED_INF) Inf)->LogContext,
            SETUP_LOG_ERROR,
            d);
    }

    if (CloseKey) {
        RegCloseKey( RootKey );
    }

    if (slot_regop) {
        ReleaseLogInfoSlot(((PLOADED_INF) Inf)->LogContext,slot_regop);
    }

    return d;
}

DWORD_PTR
pSetupProcessBitRegLine(
    IN PVOID       Inf,
    IN PINFCONTEXT InfLineContext,
    IN PVOID       Context
    )

/*++

Routine Description:

    Process a line in the registry that contains bit-registry instructions.
    The line is expected to be in the following form:

    <root-spec>,<subkey>,<value-name>,<flags>,<byte-mask>,<byte-to-modify>


    <Root-spec> is one of HKR, HKLM, etc.

    <subkey> specifies the subkey relative to Root-spec.

    <value-name> is optional. If not present the default value is set.

    <flags> is optional and supplies flags, such as whether to set bits or clear
        bits.  Value    Meaning
               0        (Default) Clear bits.   (FLG_BITREG_CLEARBITS)
               1        Set bits.                   (FLG_BITREG_SETBITS)

        These are the FLG_BITREG_* flags defined in setupapi.h, and are a
        superset of those defined for Win95 in setupx.h.

    <byte-mask> is a 1-byte hexadecimal value specifying which bits to operate on.

    <byte-to-modify> is the zero based index of the byte number to modify


Arguments:

    InfLineContext - supplies inf line context for the line containing
        add-registry instructions.

    Context - supplies the address of a registry modification context
        structure used in adding the registry value.  The structure is
        defined as:

            typedef struct _REGMOD_CONTEXT {

                HKEY UserRootKey;

                DEVINST DevInst;

            } REGMOD_CONTEXT, *PREGMOD_CONTEXT;

        where UserRootKey is a handle to the open inf key to be used as
        the root when HKR is specified as the root for the operation, and
        DevInst is the optional device instance handle that is supplied when
        the BitReg section is for a hardware key (i.e., under the Enum branch).
        If this handle is supplied, then the value is checked to see whether it
        is the name of a Plug&Play device registry property, and if so, the
        registry property is set via a CM API instead of via the registry API
        (which doesn't refer to the same location on Windows NT).

Return Value:

    Win32 error code indicating outcome.

--*/

{
    PCTSTR RootKeySpec,SubKeyName,ValueName;
    PCTSTR ValueTypeSpec;
    DWORD ValueType;
    HKEY RootKey,Key;
    DWORD d = NO_ERROR;
    DWORD cb;
    BOOL b;
    INT IntVal;
    DWORD Size;
    PBYTE Data = NULL;
    BYTE Mask;
    DWORD Disposition;
    UINT Flags = 0, BitMask = 0, ByteNumber = 0;
    PREGMOD_CONTEXT RegModContext = (PREGMOD_CONTEXT)Context;
    BOOL DevOrClassProp = FALSE;
    CONFIGRET cr;
    UINT_PTR CmPropertyCode;
    BOOL CloseKey;


    //
    // We shouldn't be doing this against a remote machine.
    //
    MYASSERT(!(RegModContext->hMachine));

    //
    // Get root key spec.  If we can't get the root key spec, we don't do anything and
    // return NO_ERROR.
    //
    if(RootKeySpec = pSetupGetField(InfLineContext,1)) {

        RootKey = pSetupInfRegSpecToKeyHandle(RootKeySpec, RegModContext->UserRootKey, &CloseKey);
        if(!RootKey) {
            return(ERROR_BADKEY);
        }

        //
        // SubKeyName is optional.
        //
        SubKeyName = pSetupGetField(InfLineContext,2);

        //
        // ValueName is optional. Either NULL or "" are acceptable
        // to pass to RegSetValueEx.
        //
        ValueName = pSetupGetField(InfLineContext,3);

        //
        // get the flags
        //
        SetupGetIntField(InfLineContext,4,&Flags);

        //
        // get the bitmask
        //
        SetupGetIntField(InfLineContext,5,&BitMask);
        if (BitMask > 0xFF) {
            d = ERROR_INVALID_DATA;
            goto exit;
        }

        //
        // get the byte number to modify
        //
        SetupGetIntField(InfLineContext,6,&ByteNumber);


        //
        // Open the key.
        //
        if(SubKeyName && *SubKeyName) {

            d = RegOpenKeyEx(
                        RootKey,
                        SubKeyName,
                        0,
#ifdef _WIN64
                        (( Flags & FLG_BITREG_32BITKEY ) ? KEY_WOW64_32KEY:0) |
#else
                        (( Flags & FLG_BITREG_64BITKEY ) ? KEY_WOW64_64KEY:0) |
#endif
                        KEY_QUERY_VALUE | KEY_SET_VALUE,
                        &Key
                        );


            if(d == NO_ERROR) {

                //
                // Work around hacked nonsense on Win95 where the unnamed value
                // behaves differently.
                //
                if( ((ValueName == NULL) || (*ValueName == 0))
                    && (OSVersionInfo.dwPlatformId != VER_PLATFORM_WIN32_NT)) {

                    d = 0;
                    if(RegQueryValueEx(Key,TEXT(""),NULL,&ValueType,(BYTE *)&Disposition,&d) == NO_ERROR) {
                        //
                        // The unnamed value entry is not set.
                        //
                        d = ERROR_INVALID_DATA;
                    }

                }

            }
        } else {
            //
            // If the key being used is HKR with no subkey specified, and if we
            // are doing the BitReg for a hardware key or for a ClassInstall32
            // entry, then we need to check to see whether the value entry we
            // have is the name of a device or class registry property.
            //
            if((RegModContext->Flags & INF_PFLAG_CLASSPROP) && ValueName && *ValueName &&
                LookUpStringInTable(InfRegValToClassRegProp, ValueName, &CmPropertyCode)) {
                //
                // Retrieve the existing class property.
                //
                cb = 0;
                cr = CM_Get_Class_Registry_Property(RegModContext->ClassGuid,
                                                    (ULONG)CmPropertyCode,
                                                    &ValueType,
                                                    NULL,
                                                    &cb,
                                                    0,
                                                    RegModContext->hMachine
                                                   );

                if((cr == CR_SUCCESS) || (cr == CR_BUFFER_SMALL)) {
                    //
                    // cb contains the required size for the buffer, in bytes.
                    //
                    if(cb) {
                        Data = (PBYTE)MyMalloc(cb) ;
                        if(!Data) {
                            d = ERROR_NOT_ENOUGH_MEMORY;
                        }

                        if(d == NO_ERROR) {

                            cr = CM_Get_Class_Registry_Property(RegModContext->ClassGuid,
                                                                (ULONG)CmPropertyCode,
                                                                &ValueType,
                                                                Data,
                                                                &cb,
                                                                0,
                                                                RegModContext->hMachine
                                                               );

                            if(cr == CR_SUCCESS) {
                                DevOrClassProp = TRUE;
                            } else {
                                d = MapCrToSpError(cr, ERROR_INVALID_DATA);
                                MyFree(Data);
                                Data = NULL;
                            }
                        }

                    } else {
                        d = ERROR_INVALID_DATA;
                    }

                } else {
                    //
                    // We can't access the property (probably because it doesn't
                    // exist.  We return ERROR_INVALID_DATA for consistency with
                    // the return code used by SetupDiGetDeviceRegistryProperty.
                    //
                    d = ERROR_INVALID_DATA;
                }

            } else if((RegModContext->Flags & INF_PFLAG_DEVPROP) && ValueName && *ValueName &&
               (b = LookUpStringInTable(InfRegValToDevRegProp, ValueName, &CmPropertyCode))) {
                //
                // Retrieve the existing device property.
                //
                cb = 0;
                cr = CM_Get_DevInst_Registry_Property(RegModContext->DevInst,
                                                      (ULONG)CmPropertyCode,
                                                      &ValueType,
                                                      NULL,
                                                      &cb,
                                                      0
                                                     );

                if(cr == CR_BUFFER_SMALL) {
                    //
                    // cb contains the required size for the buffer, in bytes.
                    //
                    MYASSERT(cb);

                    Data = (PBYTE)MyMalloc(cb) ;
                    if(!Data) {
                        d = ERROR_NOT_ENOUGH_MEMORY;
                    }

                    if(d == NO_ERROR) {

                        cr = CM_Get_DevInst_Registry_Property(RegModContext->DevInst,
                                                              (ULONG)CmPropertyCode,
                                                              &ValueType,
                                                              Data,
                                                              &cb,
                                                              0
                                                             );
                        if(cr == CR_SUCCESS) {
                            DevOrClassProp = TRUE;
                        } else {
                            d = MapCrToSpError(cr, ERROR_INVALID_DATA);
                            MyFree(Data);
                            Data = NULL;
                        }
                    }

                } else {
                    //
                    // We can't access the property (probably because it doesn't
                    // exist.  We return ERROR_INVALID_DATA for consistency with
                    // the return code used by SetupDiGetDeviceRegistryProperty.
                    //
                    d = ERROR_INVALID_DATA;
                }
            }

            //
            // Regardless of whether this value is a device or class registry
            // property, we need to set the Key equal to the RootKey (So we
            // won't think it's a newly-opened key and try to close it later.
            //
            Key = RootKey;
        }

        if(d == NO_ERROR) {

            if(!DevOrClassProp) {

                d = RegQueryValueEx(Key,ValueName,NULL,&ValueType,NULL,&cb);
                if (d == NO_ERROR) {
                    if (cb != 0 ) {
                        Data = (PBYTE) MyMalloc( cb ) ;
                        if (!Data) {
                            d  = ERROR_NOT_ENOUGH_MEMORY;
                        }

                        if (d == NO_ERROR) {
                            d = RegQueryValueEx(Key,ValueName,NULL,&ValueType,(PBYTE)Data,&cb);
                        }
                    } else {
                        d = ERROR_INVALID_DATA;
                    }
                }
            }

            //
            // byte number is zero-based where-as "cb" isn't
            //
            if(d == NO_ERROR) {
                switch (ValueType) {
                    case REG_BINARY:
                        if (ByteNumber > (cb-1)) {
                            d = ERROR_INVALID_DATA;
                        }
                        break;
                    case REG_DWORD:
                        if (ByteNumber > 3) {
                            d = ERROR_INVALID_DATA;
                        }
                        break;

                    default:
                        d = ERROR_INVALID_DATA;
                };
            }

            if (d == NO_ERROR) {
                //
                // set the target byte based on input flags
                //
                if (Flags == FLG_BITREG_SETBITS) {
                    Data[ByteNumber] |= BitMask;
                } else {
                    Data[ByteNumber] &= ~(BitMask);
                }

                if(DevOrClassProp) {

                    if(RegModContext->Flags & INF_PFLAG_CLASSPROP) {

                        cr = CM_Set_Class_Registry_Property(RegModContext->ClassGuid,
                                                            (ULONG)CmPropertyCode,
                                                            Data,
                                                            cb,
                                                            0,
                                                            RegModContext->hMachine
                                                           );
                        if(cr != CR_SUCCESS) {
                            d = MapCrToSpError(cr, ERROR_INVALID_DATA);
                        }

                    } else {

                        MYASSERT(RegModContext->Flags & INF_PFLAG_DEVPROP);

                        cr = CM_Set_DevInst_Registry_Property(RegModContext->DevInst,
                                                              (ULONG)CmPropertyCode,
                                                              Data,
                                                              cb,
                                                              0
                                                             );
                        if(cr != CR_SUCCESS) {
                            d = MapCrToSpError(cr, ERROR_INVALID_DATA);
                        }
                    }

                } else {
                    d = RegSetValueEx(Key,ValueName,0,ValueType,Data,cb);
                }
            }

            if (Data) {
                MyFree(Data);
            }
        }

        if(Key != RootKey) {
            RegCloseKey(Key);
        }
exit:
        if (CloseKey) {
            RegCloseKey(RootKey);
        }
    }

    return d;
}



DWORD_PTR
pSetupProcessIni2RegLine(
    IN PVOID       Inf,
    IN PINFCONTEXT InfLineContext,
    IN PVOID       Context
    )
{
    PCTSTR Filename,Section;
    PCTSTR Key,RegRootSpec,SubkeyPath;
    PTCHAR key,value;
    HKEY UserRootKey,RootKey,hKey;
    DWORD Disposition;
    PTCHAR Line;
    PTCHAR Buffer;
    DWORD d;
    TCHAR val[512];
    #define BUF_SIZE (sizeof(val)/sizeof(TCHAR))
    UINT Flags;
    DWORD slot_regop = 0;
    DWORD slot_subop = 0;
    BOOL CloseKey;


    UserRootKey = (HKEY)Context;

    //
    // Get filename and section name of ini file.
    //
    Filename = pSetupGetField(InfLineContext,1);
    Section = pSetupGetField(InfLineContext,2);
    if(!Filename || !Section) {
        return(ERROR_INVALID_DATA);
    }

    //
    // Get the ini file key. If not specified,
    // use the whole section.
    //
    Key = pSetupGetField(InfLineContext,3);

    //
    // Get the reg root spec and the subkey path.
    //
    RegRootSpec = pSetupGetField(InfLineContext,4);
    SubkeyPath = pSetupGetField(InfLineContext,5);
    if(SubkeyPath && (*SubkeyPath == 0)) {
        SubkeyPath = NULL;
    }

    //
    // Translate the root key spec into an hkey
    //
    RootKey = pSetupInfRegSpecToKeyHandle(RegRootSpec,UserRootKey, &CloseKey);
    if(!RootKey) {
        return(ERROR_BADKEY);
    }

    //
    // Get the flags value.
    //
    if(!SetupGetIntField(InfLineContext,6,&Flags)) {
        Flags = 0;
    }

    //
    // Get the relevent line or section in the ini file.
    //
    if(Key = pSetupGetField(InfLineContext,3)) {

        Buffer = MyMalloc(
                    (  lstrlen(Key)
                     + GetPrivateProfileString(Section,Key,TEXT(""),val,BUF_SIZE,Filename)
                     + 3)
                     * sizeof(TCHAR)
                    );

        if(!Buffer) {
            if (CloseKey) {
               RegCloseKey( RootKey );
            }
            return(ERROR_NOT_ENOUGH_MEMORY);
        }

        Buffer[wsprintf((PTSTR)Buffer,TEXT("%s=%s"),Key,val)+1] = 0;

    } else {
        Buffer = MyMalloc(32768);
        if(!Buffer) {
            if (CloseKey) {
               RegCloseKey( RootKey );
            }
            return(ERROR_NOT_ENOUGH_MEMORY);
        }
        if(!GetPrivateProfileSection(Section,Buffer,32768,Filename)) {
            *Buffer = 0;
        }
    }

    //
    // Open/create the relevent key.
    //
    d = NO_ERROR;
    //
    // Make an information log entry saying we are adding values.
    // Note that we must allow for the fact that the subkey
    // name may be missing.
    //
    if (slot_regop == 0) {
        slot_regop = AllocLogInfoSlot(((PLOADED_INF) Inf)->LogContext,FALSE);
    }
    WriteLogEntry(
        ((PLOADED_INF) Inf)->LogContext,
        slot_regop,
        MSG_LOG_SETTING_VALUES_IN_KEY,
        NULL,
        RegRootSpec,
        (SubkeyPath ? TEXT("\\") : TEXT("")),
        (SubkeyPath ? SubkeyPath : TEXT("")));

    if(SubkeyPath) {
        d = RegCreateKeyEx(
                RootKey,
                SubkeyPath,
                0,
                NULL,
                REG_OPTION_NON_VOLATILE,
#ifdef _WIN64
                (( Flags & FLG_INI2REG_32BITKEY ) ? KEY_WOW64_32KEY:0) |
#else
                (( Flags & FLG_INI2REG_64BITKEY ) ? KEY_WOW64_64KEY:0) |
#endif
                KEY_SET_VALUE,
                NULL,
                &hKey,
                &Disposition
                );
    } else {
        hKey = RootKey;
    }

    if (slot_subop == 0) {
        slot_subop = AllocLogInfoSlot(((PLOADED_INF) Inf)->LogContext,FALSE);
    }
    for(Line=Buffer; (d==NO_ERROR) && *Line; Line+=lstrlen(Line)+1) {

        //
        // Line points to the key=value pair.
        //
        key = Line;
        if(value = _tcschr(key,TEXT('='))) {
            *value++ = 0;
        } else {
            key = TEXT("");
            value = Line;
        }

        WriteLogEntry(
            ((PLOADED_INF) Inf)->LogContext,
            slot_subop,
            MSG_LOG_SETTING_REG_VALUE,
            NULL,
            key,
            value);

        //
        // Now key points to the value name and value to the value.
        //
        d = RegSetValueEx(
                hKey,
                key,
                0,
                REG_SZ,
                (CONST BYTE *)value,
                (lstrlen(value)+1)*sizeof(TCHAR)
                );
    }

    if (d != NO_ERROR) {
        //
        // Log that an error occurred, but I don't think that it
        // matters if it was from create or set.
        //
        WriteLogError(
            ((PLOADED_INF) Inf)->LogContext,
            SETUP_LOG_ERROR,
            d);
    }

    if(hKey != RootKey) {
        RegCloseKey(hKey);
    }

    MyFree(Buffer);

    if (slot_regop) {
        ReleaseLogInfoSlot(((PLOADED_INF) Inf)->LogContext,slot_regop);
    }
    if (slot_subop) {
        ReleaseLogInfoSlot(((PLOADED_INF) Inf)->LogContext,slot_subop);
    }

    if (CloseKey) {
        RegCloseKey( RootKey );
    }

    return(d);
    #undef BUF_SIZE
}


DWORD
pSetupInstallUpdateIniFiles(
    IN HINF   Inf,
    IN PCTSTR SectionName
    )

/*++

Routine Description:

    Locate the UpdateInis= and UpdateIniField= lines in an install section
    and process each section listed therein.

Arguments:

    Inf - supplies inf handle for inf containing the section indicated
        by SectionName.

    SectionName - supplies name of install section.

Return Value:

    Win32 error code indicating outcome.

--*/

{
    DWORD d,x;
    INISECTIONCACHE IniSectionCache;

    ZeroMemory(&IniSectionCache,sizeof(INISECTIONCACHE));

    d = pSetupEnumInstallationSections(
            Inf,
            SectionName,
            pszUpdateInis,
            pSetupProcessUpdateInisLine,
            &IniSectionCache
            );

    if(d == NO_ERROR) {

        d = pSetupEnumInstallationSections(
                Inf,
                SectionName,
                pszUpdateIniFields,
                pSetupProcessUpdateIniFieldsLine,
                &IniSectionCache
                );
    }

    x = pSetupUnloadIniFileSections(&IniSectionCache,(d == NO_ERROR));

    return((d == NO_ERROR) ? x : d);
}


DWORD
pSetupInstallRegistry(
    IN HINF            Inf,
    IN PCTSTR          SectionName,
    IN PREGMOD_CONTEXT RegContext
    )

/*++

Routine Description:

    Look for AddReg= and DelReg= directives within an inf section
    and parse them.

Arguments:

    Inf - supplies inf handle for inf containing the section indicated
        by SectionName.

    SectionName - supplies name of install section.

    RegContext - supplies context passed into AddReg and DelReg callbacks.

Return Value:

    Win32 error code indicating outcome.

--*/

{
    DWORD d;

    d = pSetupEnumInstallationSections(Inf,
                                       SectionName,
                                       pszDelReg,
                                       pSetupProcessDelRegLine,
                                       RegContext
                                      );

    if(d == NO_ERROR) {

        d = pSetupEnumInstallationSections(Inf,
                                           SectionName,
                                           pszAddReg,
                                           pSetupProcessAddRegLine,
                                           RegContext
                                          );

        //
        //Set Security on Keys that were created
        //Ignore errors as per security folks
        // pSetupSetSecurityForAddRegSection will log any security errors
        //
#ifdef UNICODE
        if(d == NO_ERROR) {
            pSetupSetSecurityForAddRegSection(Inf, SectionName, RegContext);
        }
#endif
    }

    return d;
}


DWORD
pSetupInstallBitReg(
    IN HINF            Inf,
    IN PCTSTR          SectionName,
    IN PREGMOD_CONTEXT RegContext
    )

/*++

Routine Description:

    Look for BitReg= directives within an inf section and parse them.

Arguments:

    Inf - supplies inf handle for inf containing the section indicated
        by SectionName.

    SectionName - supplies name of install section.

    RegContext - supplies context passed into AddReg and DelReg callbacks.

Return Value:

    Win32 error code indicating outcome.

--*/

{
    return pSetupEnumInstallationSections(Inf,
                                          SectionName,
                                          pszBitReg,
                                          pSetupProcessBitRegLine,
                                          RegContext
                                         );
}


DWORD
pSetupInstallIni2Reg(
    IN HINF   Inf,
    IN PCTSTR SectionName,
    IN HKEY   UserRootKey
    )

/*++

Routine Description:


Arguments:

    Inf - supplies inf handle for inf containing the section indicated
        by SectionName.

    SectionName - supplies name of install section.

Return Value:

    Win32 error code indicatinh outcome.

--*/

{
    DWORD d;

    d = pSetupEnumInstallationSections(
            Inf,
            SectionName,
            pszIni2Reg,
            pSetupProcessIni2RegLine,
            (PVOID)UserRootKey
            );

    return(d);
}

DWORD
pSetupRegisterDllInstall(
    IN POLE_CONTROL_DATA OleControlData,
    IN HMODULE ControlDll,
    IN PDWORD ExtendedStatus
    )
/*++

Routine Description:

    call the "DllInstall" entrypoint for the specified dll

Arguments:

    OleControlData - pointer to the OLE_CONTROL_DATA structure for the dll
                     to be registered

    ControlDll - module handle to the dll to be registered

    ExtendedStatus - receives updated SPREG_* flag indicating outcome


Return Value:

    Win32 error code indicating outcome.

--*/
{
    LPEXCEPTION_POINTERS ExceptionPointers = NULL;
    HRESULT (__stdcall *InstallRoutine) (BOOL bInstall, LPCTSTR pszCmdLine);
    HRESULT InstallStatus;

    DWORD d = NO_ERROR;

    //
    // parameter validation
    //
    if (!ControlDll) {
        *ExtendedStatus = SPREG_UNKNOWN;
        return ERROR_INVALID_PARAMETER;
    }

    //
    // get function pointer to "DllInstall" entrypoint
    //
    InstallRoutine = NULL; // shut up preFast
    try {
        (FARPROC)InstallRoutine = GetProcAddress(
            ControlDll, DLLINSTALL );
    } except (
        ExceptionPointers = GetExceptionInformation(),
        EXCEPTION_EXECUTE_HANDLER) {
    }
    if(ExceptionPointers) {
        //
        // something went wrong...record an error
        //
        d = ExceptionPointers->ExceptionRecord->ExceptionCode;

        WriteLogEntry(
            OleControlData->LogContext,
            SETUP_LOG_ERROR,
            MSG_LOG_OLE_CONTROL_INTERNAL_EXCEPTION,
            NULL,
            OleControlData->FullPath
            );

        DebugPrintEx(DPFLTR_TRACE_LEVEL, TEXT("SETUP: ...exception in GetProcAddress handled\n"));

        *ExtendedStatus = SPREG_GETPROCADDR;

    } else if(InstallRoutine) {
        //
        // now call the function
        //
        DebugPrintEx(DPFLTR_TRACE_LEVEL,TEXT("SETUP: installing...\n"));

        *ExtendedStatus = SPREG_DLLINSTALL;
        try {

            InstallStatus = InstallRoutine(OleControlData->Register, OleControlData->Argument);

            if(FAILED(InstallStatus)) {

                d = InstallStatus;

                WriteLogEntry(
                    OleControlData->LogContext,
                    SETUP_LOG_ERROR|SETUP_LOG_BUFFER,
                    MSG_LOG_OLE_CONTROL_API_FAILED,
                    NULL,
                    OleControlData->FullPath,
                    TEXT(DLLINSTALL)
                    );
                WriteLogError(OleControlData->LogContext,
                              SETUP_LOG_ERROR,
                              d);

            } else if(InstallStatus != S_OK) {
                WriteLogEntry(OleControlData->LogContext,
                                SETUP_LOG_WARNING,
                                MSG_LOG_OLE_CONTROL_API_WARN,
                                NULL,
                                OleControlData->FullPath,
                                TEXT(DLLINSTALL),
                                InstallStatus
                                );
            } else {
                WriteLogEntry(
                                OleControlData->LogContext,
                                SETUP_LOG_VERBOSE,
                                MSG_LOG_OLE_CONTROL_API_OK,
                                NULL,
                                OleControlData->FullPath,
                                TEXT(DLLINSTALL)
                                );
            }

        } except (
            ExceptionPointers = GetExceptionInformation(),
            EXCEPTION_EXECUTE_HANDLER) {

            d = ExceptionPointers->ExceptionRecord->ExceptionCode;

            WriteLogEntry(
                OleControlData->LogContext,
                SETUP_LOG_ERROR,
                MSG_LOG_OLE_CONTROL_API_EXCEPTION,
                NULL,
                OleControlData->FullPath,
                TEXT(DLLINSTALL)
                );

            DebugPrintEx(DPFLTR_TRACE_LEVEL,TEXT("SETUP: ...exception in DllInstall handled\n"));

        }

        DebugPrintEx(DPFLTR_TRACE_LEVEL,TEXT("SETUP: ...installed\n"));
    } else {
        *ExtendedStatus = SPREG_GETPROCADDR;
    }

    return d;

}

DWORD
pSetupRegisterDllRegister(
    IN POLE_CONTROL_DATA OleControlData,
    IN HMODULE ControlDll,
    IN PDWORD ExtendedStatus
    )
/*++

Routine Description:

    call the "DllRegisterServer" or "DllUnregisterServer" entrypoint for the
    specified dll

Arguments:

    OleControlData - pointer to the OLE_CONTROL_DATA structure for the dll
                     to be registered
    This is a copy of OleControlData from calling thread
    Inf specified is locked, but not native to this thread

    ControlDll - module handle to the dll to be registered

    ExtendedStatus - receives an extended status depending on the outcome of
                     this operation


Return Value:

    Win32 error code indicating outcome.

--*/
{
    LPEXCEPTION_POINTERS ExceptionPointers = NULL;
    HRESULT (__stdcall *RegisterRoutine) (VOID);
    HRESULT RegisterStatus;

    DWORD d = NO_ERROR;

    //
    // parameter validation
    //
    if (!ControlDll) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // get the function pointer to the actual routine we want to call
    //
    RegisterRoutine = NULL; // shut up preFast
    try {
        (FARPROC)RegisterRoutine = GetProcAddress(
            ControlDll, OleControlData->Register ? DLLREGISTER : DLLUNREGISTER);
    } except (
        ExceptionPointers = GetExceptionInformation(),
        EXCEPTION_EXECUTE_HANDLER) {
    }
    if(ExceptionPointers) {

        //
        // something went wrong, horribly wrong
        //
        d = ExceptionPointers->ExceptionRecord->ExceptionCode;

        WriteLogEntry(
            OleControlData->LogContext,
            SETUP_LOG_ERROR,
            MSG_LOG_OLE_CONTROL_INTERNAL_EXCEPTION,
            NULL,
            OleControlData->FullPath
            );

        DebugPrintEx(DPFLTR_TRACE_LEVEL,TEXT("SETUP: ...exception in GetProcAddress handled\n"));

        *ExtendedStatus = SPREG_GETPROCADDR;

    } else if(RegisterRoutine) {

        DebugPrintEx(DPFLTR_TRACE_LEVEL,TEXT("SETUP: registering...\n"));
        *ExtendedStatus = SPREG_REGSVR;
        try {

            RegisterStatus = RegisterRoutine();

            if(FAILED(RegisterStatus)) {

                d = RegisterStatus;

                WriteLogEntry(OleControlData->LogContext,
                              SETUP_LOG_ERROR | SETUP_LOG_BUFFER,
                              MSG_LOG_OLE_CONTROL_API_FAILED,
                              NULL,
                              OleControlData->FullPath,
                              OleControlData->Register ? TEXT(DLLREGISTER) : TEXT(DLLUNREGISTER)
                              );

                WriteLogError(OleControlData->LogContext,
                              SETUP_LOG_ERROR,
                              d);
            } else if(RegisterStatus != S_OK) {
                WriteLogEntry(OleControlData->LogContext,
                              SETUP_LOG_WARNING,
                              MSG_LOG_OLE_CONTROL_API_WARN,
                              NULL,
                              OleControlData->FullPath,
                              OleControlData->Register ? TEXT(DLLREGISTER) : TEXT(DLLUNREGISTER),
                              RegisterStatus
                              );
            } else {
                WriteLogEntry(OleControlData->LogContext,
                              SETUP_LOG_VERBOSE,
                              MSG_LOG_OLE_CONTROL_API_OK,
                              NULL,
                              OleControlData->FullPath,
                              OleControlData->Register ? TEXT(DLLREGISTER) : TEXT(DLLUNREGISTER)
                              );
            }

        } except (
            ExceptionPointers = GetExceptionInformation(),
            EXCEPTION_EXECUTE_HANDLER) {

            d = ExceptionPointers->ExceptionRecord->ExceptionCode;

            WriteLogEntry(
                OleControlData->LogContext,
                SETUP_LOG_ERROR,
                MSG_LOG_OLE_CONTROL_API_EXCEPTION,
                NULL,
                OleControlData->FullPath,
                OleControlData->Register ? TEXT(DLLREGISTER) : TEXT(DLLUNREGISTER)
                );

            DebugPrintEx(DPFLTR_TRACE_LEVEL,TEXT("SETUP: ...exception in DllRegisterServer handled\n"));

        }

        DebugPrintEx(DPFLTR_TRACE_LEVEL,TEXT("SETUP: ...registered\n"));

    } else {

        d = GetLastError();

        WriteLogEntry(OleControlData->LogContext,
                      SETUP_LOG_ERROR | SETUP_LOG_BUFFER,
                      MSG_LOG_OLE_CONTROL_NOT_REGISTERED_GETPROC_FAILED,
                      NULL,
                      OleControlData->FullPath,
                      OleControlData->Register ? TEXT(DLLREGISTER) : TEXT(DLLUNREGISTER)
                      );

        WriteLogError(OleControlData->LogContext,
                      SETUP_LOG_ERROR,
                      d);


        *ExtendedStatus = SPREG_GETPROCADDR;

    }

    return d;
}

DWORD
pSetupRegisterLoadDll(
    IN  POLE_CONTROL_DATA OleControlData,
    OUT HMODULE *ControlDll
    )
/*++

Routine Description:

    get the module handle to the specified dll

Arguments:

    OleControlData - pointer to the OLE_CONTROL_DATA structure for the dll
                     to be registered

    ControlDll - module handle for the dll


Return Value:

    Win32 error code indicating outcome.

--*/
{
    LPEXCEPTION_POINTERS ExceptionPointers = NULL;

    DWORD d = NO_ERROR;

    DebugPrintEx(DPFLTR_TRACE_LEVEL,TEXT("SETUP: loading dll...\n"));

    try {

        *ControlDll = LoadLibraryEx(OleControlData->FullPath,
                                    NULL,
                                    LOAD_WITH_ALTERED_SEARCH_PATH);

    } except (
        ExceptionPointers = GetExceptionInformation(),
        EXCEPTION_EXECUTE_HANDLER) {
    }
    if(ExceptionPointers) {

        WriteLogEntry(
            OleControlData->LogContext,
            SETUP_LOG_ERROR,
            MSG_LOG_OLE_CONTROL_LOADLIBRARY_EXCEPTION,
            NULL,
            OleControlData->FullPath
            );

        DebugPrintEx(DPFLTR_TRACE_LEVEL,TEXT("SETUP: ...exception in LoadLibrary handled\n"));
        d = ExceptionPointers->ExceptionRecord->ExceptionCode;

    } else if (!*ControlDll) {
        d = GetLastError();

        //
        // LoadLibrary failed.
        // File not found is not an error. We want to know about
        // other errors though.
        //

        d = GetLastError();

        DebugPrintEx(DPFLTR_TRACE_LEVEL,TEXT("SETUP: ...dll not loaded (%u)\n"),d);

        WriteLogEntry(
            OleControlData->LogContext,
            SETUP_LOG_ERROR|SETUP_LOG_BUFFER,
            MSG_LOG_OLE_CONTROL_LOADLIBRARY_FAILED,
            NULL,
            OleControlData->FullPath
            );
        WriteLogError(
            OleControlData->LogContext,
            SETUP_LOG_ERROR,
            d
            );

    } else {
        DebugPrintEx(DPFLTR_TRACE_LEVEL,TEXT("SETUP: ...dll loaded\n"));
    }

    return d;

}

HANDLE
pSetupRegisterExe(
    POLE_CONTROL_DATA OleControlData,
    PDWORD ExtendedStatus OPTIONAL
    )
/*++

Routine Description:

    register an exe by passing it the specified cmdline

Arguments:

    OleControlData - pointer to the OLE_CONTROL_DATA structure for the dll
                     to be registered
    ExtendedStatus - Win32 error code indicating outcome.

Return Value:

    if success, a handle for the process which the caller may wait on.
    if failure, return NULL;

--*/
{
    LPTSTR CmdLine = NULL;
    STARTUPINFO StartupInfo;
    PROCESS_INFORMATION ProcessInformation;
    BOOL HasQuote = FALSE;
    int CmdLen;

    DWORD d = NO_ERROR;

    //
    // parameter validation
    //
    if (!OleControlData) {
        if (ExtendedStatus) {
            *ExtendedStatus =  ERROR_INVALID_DATA;
        }
        return NULL;
    }

    //
    // no UI
    //
    GetStartupInfo(&StartupInfo);
    StartupInfo.dwFlags |= STARTF_USESHOWWINDOW;
    StartupInfo.wShowWindow = SW_HIDE;

    CmdLen = lstrlen(OleControlData->FullPath)+
                (OleControlData->Argument ? lstrlen(OleControlData->Argument)
                                : max(sizeof(EXEREGSVR),sizeof(EXEUNREGSVR))) +
                32; // worst case + some


    CmdLine = MyMalloc(CmdLen*sizeof(TCHAR));
    if(CmdLine == NULL) {
        d = GetLastError();
        goto final;
    }

    //
    // make sure full-path is quoted
    //
    HasQuote = wcschr(OleControlData->FullPath,TEXT('\"')) ? TRUE : FALSE;
    MYVERIFY(SUCCEEDED(StringCchPrintf(CmdLine,CmdLen,
                         HasQuote ? TEXT("%s %s") : TEXT("\"%s\" %s"),
                         OleControlData->FullPath,
                         OleControlData->Argument
                            ? OleControlData->Argument :
                                (OleControlData->Register ? EXEREGSVR : EXEUNREGSVR)
                         )));
    if (!CreateProcess(HasQuote? NULL : OleControlData->FullPath,
                        CmdLine,
                        NULL,
                        NULL,
                        FALSE,
                        DETACHED_PROCESS|NORMAL_PRIORITY_CLASS,
                        NULL,
                        NULL,
                        &StartupInfo,
                        &ProcessInformation)) {
        //
        // call failed
        //
        d = GetLastError();
    }

final:

    if(CmdLine) {
        MyFree(CmdLine);
    }
    if (d != NO_ERROR) {

        WriteLogEntry(
            OleControlData->LogContext,
            SETUP_LOG_ERROR|SETUP_LOG_BUFFER,
            MSG_LOG_OLE_CONTROL_CREATEPROCESS_FAILED,
            NULL,
            OleControlData->FullPath,
            (OleControlData->Argument
                ? OleControlData->Argument
                : (OleControlData->Register
                    ? EXEREGSVR
                    : EXEUNREGSVR))
            );
        WriteLogError(
            OleControlData->LogContext,
            SETUP_LOG_ERROR,
            d
            );

        ProcessInformation.hProcess = NULL;


    } else {

        CloseHandle( ProcessInformation.hThread );

        WriteLogEntry(
            OleControlData->LogContext,
            SETUP_LOG_VERBOSE,
            MSG_LOG_OLE_CONTROL_CREATEPROCESS_OK,
            NULL,
            OleControlData->FullPath,
            (OleControlData->Argument
                ? OleControlData->Argument
                : (OleControlData->Register
                    ? EXEREGSVR
                    : EXEUNREGSVR))
            );

    }

    if (*ExtendedStatus) {
        *ExtendedStatus = d;
    }

    return ProcessInformation.hProcess;

}



DWORD
__stdcall
pSetupRegisterUnregisterDll(
    VOID *Param
    )
/*++

Routine Description:

    main registration routine for registering exe's and dlls.

Arguments:

    Param - pointer to OLE_CONTROL_DATA structure indicating file to
            be processed

Return Value:

    Win32 error code indicating outcome.

--*/
{
    POLE_CONTROL_DATA OleControlData = (POLE_CONTROL_DATA) Param;
    LPEXCEPTION_POINTERS ExceptionPointers = NULL;
    HMODULE ControlDll = NULL;
    PTSTR Extension;
    DWORD d = NO_ERROR;
    DWORD Count;
    SPFUSIONINSTANCE spFusionInstance;

    if(!OleControlData) {
        return ERROR_INVALID_PARAMETER;
    }

    spFusionEnterContext(NULL,&spFusionInstance);

    d = (DWORD)OleInitialize(NULL);
    if (d!= NO_ERROR) {
        OleControlData->Status->ExtendedStatus = SPREG_UNKNOWN;
        goto clean0;
    }

    try {
        //
        // protect everything in TRY-EXCEPT, we're calling unknown code (DLL's)
        //
        d = pSetupRegisterLoadDll( OleControlData, &ControlDll );

        if (d == NO_ERROR) {

            //
            // We successfully loaded it.  Now call the appropriate routines.
            //
            //
            // On register, do DLLREGISTER, then DLLINSTALL
            // On unregister, do DLLINSTALL, then DLLREGISTER
            //
            if (OleControlData->Register) {

                if (OleControlData->RegType & FLG_REGSVR_DLLREGISTER && (d == NO_ERROR) ) {

                    d = pSetupRegisterDllRegister(
                                        OleControlData,
                                        ControlDll,
                                        &OleControlData->Status->ExtendedStatus );

                }

                if (OleControlData->RegType & FLG_REGSVR_DLLINSTALL && (d == NO_ERROR) ) {

                    d = pSetupRegisterDllInstall(
                                        OleControlData,
                                        ControlDll,
                                        &OleControlData->Status->ExtendedStatus );
                }

            } else {

                if (OleControlData->RegType & FLG_REGSVR_DLLINSTALL && (d == NO_ERROR) ) {

                    d = pSetupRegisterDllInstall(
                                        OleControlData,
                                        ControlDll,
                                        &OleControlData->Status->ExtendedStatus );
                }

                if (OleControlData->RegType & FLG_REGSVR_DLLREGISTER && (d == NO_ERROR) ) {

                    d = pSetupRegisterDllRegister(
                                        OleControlData,
                                        ControlDll,
                                        &OleControlData->Status->ExtendedStatus );

                }


            }

        } else {
            ControlDll = NULL;
            OleControlData->Status->ExtendedStatus = SPREG_LOADLIBRARY;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        //
        // If our exception was an AV, then use Win32 invalid param error, otherwise, assume it was
        // an inpage error dealing with a mapped-in file.
        //
        d = ERROR_INVALID_DATA;
        OleControlData->Status->ExtendedStatus = SPREG_UNKNOWN;
    }

    if (ControlDll) {
        FreeLibrary(ControlDll);
    }

//clean1:
    OleUninitialize();

clean0:

    spFusionLeaveContext(&spFusionInstance);

    if (d == NO_ERROR) {
        OleControlData->Status->ExtendedStatus = SPREG_SUCCESS;
    }

    //
    // we don't need OleControlData anymore so deallocate it here.
    //
    pSetupFreeOleControlData(OleControlData);

    return d;

}

#ifdef CHILDREGISTRATION
BOOL
IsThisANonNativeDll(
    PCTSTR FullPath
    )
/*++

Routine Description:

    determines if a dll is a supported non-native os dll (and must therefore be registered
    in a child process).  Uses the imagehlp APIs to figure this out

Arguments:

    FullPath - Fully qualified path to the dll to be processed


Return Value:

    TRUE indicates that the file is non-native and should therefore be
    registered in a different process.

--*/
{
    LOADED_IMAGE LoadedImage;
    BOOL RetVal = FALSE;
    PSTR FullPathCopy;
    BOOL locked = FALSE;

#ifndef _WIN64
    if(!IsWow64) {
        //
        // we don't support proxying on 32
        //
        return FALSE;
    }
#endif

    //
    // imagehlp takes an ANSI string, so convert it or make a non-const copy.
    //
    FullPathCopy = pSetupUnicodeToMultiByte(FullPath, CP_ACP);

    if (!FullPathCopy) {
        return(FALSE);
    }

    RtlZeroMemory(
        &LoadedImage,
        sizeof(LoadedImage) );

    //
    // get the image headers
    //
    try {
        EnterCriticalSection(&ImageHlpMutex);
        locked = TRUE;
    } except(EXCEPTION_EXECUTE_HANDLER) {
    }
    if(!locked) {
        MyFree(FullPathCopy);
        return FALSE;
    }
    try {
        if (MapAndLoad(
                FullPathCopy,
                NULL,
                &LoadedImage,
                TRUE, // assume it's a dll if there isn't any file extension
                TRUE /* read only */ )) {

            //
            // let's not bother to do alot of validation on the file, we'll just
            // see if it meets our search requirement of being a non-native dll.
            //
            if (LoadedImage.FileHeader->Signature == IMAGE_NT_SIGNATURE) {

    #if defined(_X86_)
                //
                // this will need to work better for AMD64
                //
                if ((LoadedImage.FileHeader->FileHeader.Machine == IMAGE_FILE_MACHINE_AMD64) ||
                    (LoadedImage.FileHeader->FileHeader.Machine == IMAGE_FILE_MACHINE_IA64)) {
                    RetVal = TRUE;
                }
    #elif defined(_IA64_) || defined(_AMD64_)
                if (LoadedImage.FileHeader->FileHeader.Machine == IMAGE_FILE_MACHINE_I386) {
                    RetVal = TRUE;
                }
    #else
    #error Unknown platform
    #endif
            }

            //
            // we do not support 16 bit images
            //
            if (LoadedImage.fDOSImage) {
                RetVal = FALSE;
            }

            UnMapAndLoad(&LoadedImage);
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        MYASSERT(FALSE && "exception in Map/Unmap");
    }
    LeaveCriticalSection(&ImageHlpMutex);

    MyFree(FullPathCopy);

    return(RetVal);
}

BOOL
BuildSecureSD(
    OUT PSECURITY_DESCRIPTOR *SDIn
    )
/*++

Routine Description:

    builds a secure security descriptor to be used in securing a globally
    named object. Our "secure" SD's DACL consists of the following permissions:

    Authenticated users get "generic read" access.
    Administrators get "generic all" access.

Arguments:

    SDIn    - pointer to the PSECURITY_DESCRIPTOR to be created.

Return Value:

    TRUE    - Success, the SECURITY_DESCRIPTOR was created successfully.
              The caller is responsible for freeing the SECURITY_DESCRIPTOR

--*/
{
    SID_IDENTIFIER_AUTHORITY NtAuthority         = SECURITY_NT_AUTHORITY;
    PSID                    AuthenticatedUsers;
    PSID                    BuiltInAdministrators;
    PSECURITY_DESCRIPTOR    Sd = NULL;
    ACL                     *Acl;
    ULONG                   AclSize;
    BOOL                    RetVal = TRUE;

    *SDIn = NULL;

    //
    // Allocate and initialize the required SIDs
    //
    if (!AllocateAndInitializeSid(
                &NtAuthority,
                2,
                SECURITY_BUILTIN_DOMAIN_RID,
                DOMAIN_ALIAS_RID_ADMINS,
                0,0,0,0,0,0,
                &BuiltInAdministrators)) {
        return(FALSE);
    }

    if (!AllocateAndInitializeSid(
            &NtAuthority,
            1,
            SECURITY_AUTHENTICATED_USER_RID,
            0,0,0,0,0,0,0,
            &AuthenticatedUsers)) {
        RetVal = FALSE;
        goto e0;
    }




    //
    // "- sizeof (ULONG)" represents the SidStart field of the
    // ACCESS_ALLOWED_ACE.  Since we're adding the entire length of the
    // SID, this field is counted twice.
    //

    AclSize = sizeof (ACL) +
        (2 * (sizeof (ACCESS_ALLOWED_ACE) - sizeof (ULONG))) +
        GetLengthSid(AuthenticatedUsers) +
        GetLengthSid(BuiltInAdministrators);

    Sd = MyMalloc(SECURITY_DESCRIPTOR_MIN_LENGTH + AclSize);

    if (!Sd) {

        RetVal = FALSE;
        goto e1;

    }



    Acl = (ACL *)((BYTE *)Sd + SECURITY_DESCRIPTOR_MIN_LENGTH);

    if (!InitializeAcl(Acl,
                       AclSize,
                       ACL_REVISION)) {
        RetVal = FALSE;
        goto e2;

    } else if (!AddAccessAllowedAce(Acl,
                                    ACL_REVISION,
                                    SYNCHRONIZE | GENERIC_READ,
                                    AuthenticatedUsers)) {

        // Failed to build the ACE granting "Authenticated users"
        // (SYNCHRONIZE | GENERIC_READ) access.
        RetVal = FALSE;
        goto e2;

    } else if (!AddAccessAllowedAce(Acl,
                                    ACL_REVISION,
                                    GENERIC_ALL,
                                    BuiltInAdministrators)) {

        // Failed to build the ACE granting "Built-in Administrators"
        // GENERIC_ALL access.
        RetVal = FALSE;
        goto e2;

    } else if (!InitializeSecurityDescriptor(Sd,
                                             SECURITY_DESCRIPTOR_REVISION)) {
        RetVal = FALSE;
        goto e2;

    } else if (!SetSecurityDescriptorDacl(Sd,
                                          TRUE,
                                          Acl,
                                          FALSE)) {

        // error
        RetVal = FALSE;
        goto e2;
    }

    if (!IsValidSecurityDescriptor(Sd)) {
        RetVal = FALSE;
        goto e2;
    }

    //
    // success
    //
    *SDIn = Sd;
    goto e1;

e2:
    MyFree(Sd);
e1:
    FreeSid(AuthenticatedUsers);
e0:
    FreeSid(BuiltInAdministrators);

    return(RetVal);
}

BOOL
pSetupCleanupWowIpcStream(
    IN OUT PWOWSURRAGATE_IPC WowIpcData
    )
/*++

Routine Description:

    This procedure will cleanup the structure that is used for creating
    a child process for registering components.

Arguments:

    WowIpcData - pointer to a WOWSURRAGATE_IPC structure which is cleaned up.

Return Value:

    Returns TRUE if the structure is successfully signalled.

--*/
{
    //
    // if any items are allocated, free them and zero things out
    //
    if (WowIpcData->MemoryRegion) {
        UnmapViewOfFile( WowIpcData->MemoryRegion );
    }

    if (WowIpcData->hFileMap) {
        CloseHandle(WowIpcData->hFileMap);
    }

    if (WowIpcData->SignalReadyToRegister) {
        CloseHandle(WowIpcData->SignalReadyToRegister);
    }

    if (WowIpcData->SignalRegistrationComplete) {
        CloseHandle(WowIpcData->SignalRegistrationComplete);
    }

    if (WowIpcData->hProcess) {
        CloseHandle(WowIpcData->hProcess);
    }

    RtlZeroMemory(WowIpcData,sizeof(WOWSURRAGATE_IPC));

    return(TRUE);

}

BOOL
InitializeWowIpcStream(
    OUT PWOWSURRAGATE_IPC WowIpcData
    )
/*++

Routine Description:

    This procedure will setup the structure that is used for creating
    a child process for registering components.

Arguments:

    WowIpcData - pointer to a WOWSURRAGATE_IPC structure which is filled in
                 with tbe information telling us what the process parameters
                 shall be and how to signal the process.

Return Value:

    Returns TRUE if the structure is successfully signalled.

--*/
{
    BOOL RetVal;
    SECURITY_ATTRIBUTES wowsa,signalreadysa,signalcompletesa;
    PSECURITY_DESCRIPTOR wowsd,signalreadysd,signalcompletesd;
    TCHAR MemoryRegionNameString[GUID_STRING_LEN];
    TCHAR SignalReadyToRegisterNameString[GUID_STRING_LEN];
    TCHAR SignalRegistrationCompleteNameString[GUID_STRING_LEN];


    //
    // clean this thing up just in case there's something left over
    //
    pSetupCleanupWowIpcStream(WowIpcData);

    //
    // create the names of our events and shared memory region
    //
    CoCreateGuid( &WowIpcData->MemoryRegionName );
    CoCreateGuid( &WowIpcData->SignalReadyToRegisterName );
    CoCreateGuid( &WowIpcData->SignalRegistrationCompleteName );

    pSetupStringFromGuid(&WowIpcData->MemoryRegionName,MemoryRegionNameString,GUID_STRING_LEN);
    pSetupStringFromGuid(&WowIpcData->SignalReadyToRegisterName,SignalReadyToRegisterNameString,GUID_STRING_LEN);
    pSetupStringFromGuid(&WowIpcData->SignalRegistrationCompleteName,SignalRegistrationCompleteNameString,GUID_STRING_LEN);

    //
    // now create the region and our named events
    //

    //
    // we need to created a named memory region, and this must be properly
    // secured, so we build a security descriptor
    //
    if (!BuildSecureSD(&wowsd)) {
        RetVal = FALSE;
        goto e0;
    }

    wowsa.nLength = sizeof(SECURITY_ATTRIBUTES);
    wowsa.bInheritHandle = TRUE;
    wowsa.lpSecurityDescriptor = wowsd;

    //
    // we need to created a named event, and this must be properly
    // secured, so we build a security descriptor
    //
    if (!BuildSecureSD(&signalreadysd)) {
        RetVal = FALSE;
        goto e1;
    }

    signalreadysa.nLength = sizeof(SECURITY_ATTRIBUTES);
    signalreadysa.bInheritHandle = TRUE;
    signalreadysa.lpSecurityDescriptor = signalreadysd;

    //
    // we need to created a named event, and this must be properly
    // secured, so we build a security descriptor
    //
    if (!BuildSecureSD(&signalcompletesd)) {
        RetVal = FALSE;
        goto e2;
    }

    signalcompletesa.nLength = sizeof(SECURITY_ATTRIBUTES);
    signalcompletesa.bInheritHandle = TRUE;
    signalcompletesa.lpSecurityDescriptor = signalcompletesd;

    WowIpcData->hFileMap = CreateFileMappingW(
                                INVALID_HANDLE_VALUE,
                                &wowsa,
                                PAGE_READWRITE | SEC_COMMIT,
                                0,
                                WOW_IPC_REGION_SIZE,
                                MemoryRegionNameString
                                );
    if (!WowIpcData->hFileMap) {
        RetVal = FALSE;
        goto e2;
        return(FALSE);
    }

    WowIpcData->MemoryRegion = MapViewOfFile(
                                        WowIpcData->hFileMap,
                                        FILE_MAP_WRITE,
                                        0,
                                        0,
                                        0
                                        );
    if (!WowIpcData->MemoryRegion) {
        RetVal = FALSE;
        goto e2;
    }

    WowIpcData->SignalReadyToRegister = CreateEventW(
                                                &signalreadysa,
                                                TRUE,
                                                FALSE,
                                                SignalReadyToRegisterNameString );

    WowIpcData->SignalRegistrationComplete = CreateEventW(
                                                    &signalcompletesa,
                                                    TRUE,
                                                    FALSE,
                                                    SignalRegistrationCompleteNameString );


    if (!WowIpcData->SignalReadyToRegister ||
        !WowIpcData->SignalRegistrationComplete) {
        RetVal = FALSE;
        goto e2;
    }

    RetVal = TRUE;

    //
    // pSetupCleanupWowIpcStream cleans up most of the resources allocated in this routine.
    //
e2:
    MyFree(signalcompletesd);
e1:
    MyFree(signalreadysd);
e0:
    MyFree(wowsd);

    if (!RetVal) {
        pSetupCleanupWowIpcStream(WowIpcData);
    }

    return(RetVal);
}


BOOL
SignalSurragateProcess(
    IN OUT PWOWSURRAGATE_IPC WowIpcData
    )
/*++

Routine Description:

    This procedure will signal our child process if it exists.
    If the process is not running, we will create a new process.

Arguments:

    WowIpcData - pointer to a WOWSURRAGATE_IPC structure which
                 tells us what the process parameters are and how
                 to signal the process

Return Value:

    Returns TRUE if the process is successfully signalled.

--*/
{
    BOOL RetVal;
    DWORD ReqSize;
    WCHAR CmdLine[MAX_PATH];
    WCHAR ProcessName[MAX_PATH];
    PROCESS_INFORMATION ProcessInformation;
    STARTUPINFO StartupInfo;
    TCHAR MemoryRegionNameString[GUID_STRING_LEN];
    TCHAR SignalReadyToRegisterNameString[GUID_STRING_LEN];
    TCHAR SignalRegistrationCompleteNameString[GUID_STRING_LEN];

    BOOL NeedToCreateProcess = FALSE;

    //
    // get the string version of our GUIDs, since we'll need these later
    // on.
    //
    pSetupStringFromGuid(&WowIpcData->MemoryRegionName,MemoryRegionNameString,GUID_STRING_LEN);
    pSetupStringFromGuid(&WowIpcData->SignalReadyToRegisterName,SignalReadyToRegisterNameString,GUID_STRING_LEN);
    pSetupStringFromGuid(&WowIpcData->SignalRegistrationCompleteName,SignalRegistrationCompleteNameString,GUID_STRING_LEN);

    //
    // put together the cmdline for the child process just in case we need
    // to launch it in a little bit.
    //
    ReqSize = ExpandEnvironmentStrings(
                        SURRAGATE_PROCESSNAME,
                        ProcessName,
                        SIZECHARS(ProcessName));
    if(!MYVERIFY((ReqSize>0) && (ReqSize<=SIZECHARS(ProcessName)))) {
        RetVal = FALSE;
        goto e0;
    }

    if(!MYVERIFY(SUCCEEDED(StringCchPrintf(CmdLine,SIZECHARS(CmdLine),
                                        TEXT("\"%s\" %s %s %s %s %s %s"),
                                        ProcessName,
                                        SURRAGATE_REGIONNAME_SWITCH,
                                        MemoryRegionNameString,
                                        SURRAGATE_SIGNALREADY_SWITCH,
                                        SignalReadyToRegisterNameString,
                                        SURRAGATE_SIGNALCOMPLETE_SWITCH,
                                        SignalRegistrationCompleteNameString )))) {
        RetVal = FALSE;
        goto e0;
    }

    //
    // no UI
    //
    GetStartupInfo(&StartupInfo);
    StartupInfo.dwFlags |= STARTF_USESHOWWINDOW;
    StartupInfo.wShowWindow = SW_HIDE;

    //
    // do we need to create a new process or is our process still running?
    //
    // note that there is a fine race condition here where the child
    // process could go away before we signal our event.
    //
    // I need to see how reachable that race condition is and if this needs
    // to be addressed
    //
    if (!WowIpcData->hProcess) {
        NeedToCreateProcess = TRUE;
    } else if (WaitForSingleObject(WowIpcData->hProcess, 0) == WAIT_OBJECT_0) {
        CloseHandle(WowIpcData->hProcess);
        WowIpcData->hProcess = NULL;
        NeedToCreateProcess = TRUE;
    }

    if (NeedToCreateProcess) {
        //
        // note that we just use the events we were already given, even
        // if we had a process and it's gone away.  Since we use GUIDs,
        // we don't have to worry about any process conflicting with our
        // named events, etc.
        //
#ifndef _WIN64
        if (IsWow64) {
            //
            // allow us to access 64-bit wowreg32 directly
            //
            Wow64DisableFilesystemRedirector(ProcessName);
        }
#endif
        if (! CreateProcessW(ProcessName,
                             CmdLine,
                             NULL,
                             NULL,
                             FALSE,
                             DETACHED_PROCESS|NORMAL_PRIORITY_CLASS,
                             NULL,
                             NULL,
                             &StartupInfo,
                             &ProcessInformation)) {
           RetVal = FALSE;
           goto e0;
        }
#ifndef _WIN64
        if (IsWow64) {
            //
            // re-enable redirection
            //
            Wow64EnableFilesystemRedirector();
        }
#endif

        //
        // keep ahold of the child process handle so we can wait on it later
        // on.
        //
        WowIpcData->hProcess = ProcessInformation.hProcess;
        CloseHandle(ProcessInformation.hThread);

    }

    //
    // we are completely initialized at this point, so fire off the surragate
    // process with the appropriate parameters.  It will wait until we signal
    // our event before proceeding with reading the shared memory region
    //
    SetEvent(WowIpcData->SignalReadyToRegister);

    RetVal = TRUE;

e0:

    //
    // if we failed to create the process, etc., then clean things up so that
    // things may work better the next time around.
    //
    if (!RetVal) {
        pSetupCleanupWowIpcStream(WowIpcData);
    }

    return(RetVal);

}


HANDLE
pSetupCallChildProcessForRegistration(
    IN POLE_CONTROL_DATA OleControlData,
    OUT PDWORD ExtendedStatus
    )
/*++

Routine Description:

    Procedure asks a child process to register the specified dll.  If the
    child process doesn't exist, it will be created.

Arguments:

    OleControlData - pointer to a OLE_CONTROL_DATA structure which specifes
                     how the file is to be registered.

    ExtendedStatus - receives a win32 error code with extended information
                      (if an error occurs)

Return Value:

    Returns a waitable handle on success which will be signalled when
    registration completes. If the registration cannot be started, the
    return value is NULL.

--*/
{
    PWOW_IPC_REGION_TOSURRAGATE IpcMemRegion;
    PWSTR p;
    //
    // if the ipc mechanism isn't already initialized, then initialze it.
    //
    if (!OleControlData->WowIpcData->MemoryRegion) {
        if (!InitializeWowIpcStream(OleControlData->WowIpcData)) {
            *ExtendedStatus = GetLastError();
            return NULL;
        }
    }

    MYASSERT( OleControlData->WowIpcData->SignalReadyToRegister != NULL );
    MYASSERT( OleControlData->WowIpcData->SignalRegistrationComplete != NULL );

    //
    // the region is initialized, so let's fill it in with the registration
    // data
    //
    IpcMemRegion = (PWOW_IPC_REGION_TOSURRAGATE)OleControlData->WowIpcData->MemoryRegion;

    wcscpy(IpcMemRegion->FullPath,OleControlData->FullPath);

    if (OleControlData->Argument) {
        wcscpy(IpcMemRegion->Argument,OleControlData->Argument);
    } else {
        IpcMemRegion->Argument[0] = UNICODE_NULL;
    }

    IpcMemRegion->RegType = OleControlData->RegType;
    IpcMemRegion->Register = OleControlData->Register;

    //
    // the region is filled in, so now signal the event to tell
    // the surragate to process the data
    //
    if (!SignalSurragateProcess(OleControlData->WowIpcData)) {
        *ExtendedStatus = GetLastError();
        return(NULL);
    }

    //
    // surragate will signal below event when it completes registration
    //
    return(OleControlData->WowIpcData->SignalRegistrationComplete);
}

#endif

VOID
pSetupFreeOleControlData(
    IN POLE_CONTROL_DATA OleControlData
    )
/*++

Routine Description:

    Frees the memory associated with OLE_CONTROL_DATA structure.

Arguments:

    OleControlData - pointer to the OLE_CONTROL_DATA to be deallocated.

Return Value:

    NONE.

--*/

{
    DWORD Count;

    MYASSERT(OleControlData != NULL);

    if (OleControlData->Argument) {
        MyFree(OleControlData->Argument);
    }

    if (OleControlData->FullPath) {
        MyFree(OleControlData->FullPath);
    }

    if (OleControlData->LogContext) {
        DeleteLogContext(OleControlData->LogContext);
    }

    //
    // watch out here.  this is ref-counted and we only free when the count
    // reaches zero
    //
    if (OleControlData->Status) {
        Count = InterlockedDecrement(&OleControlData->Status->RefCount);
        if (Count == 0) {
            MyFree(OleControlData->Status);
        }
    }

    MyFree(OleControlData);

}


HANDLE
pSetupSpawnRegistration(
    IN POLE_CONTROL_DATA OleControlData,
    OUT PDWORD pHowToGetStatusLaterOn,
    OUT PDWORD pExtendedStatus OPTIONAL
    )
/*++

Routine Description:

    This procedure determines what is the appropriate mechanism for the
    specified file and kicks off registration of that file.

Arguments:

    OleControlData - pointer to a OLE_CONTROL_DATA structure which specifes
                     how the file is to be registered.

    pHowToGetStatusLaterOn - receives a DWORD constant SP_GETSTATUS_* value
                             which indicates how the file was registered so
                             that the caller can get back the appropriate
                             status information later on.

    pExtendedStatus - receives a win32 error code with extended information
                      (if an error occurs)

Return Value:

    Returns a waitable handle on success which will be signalled when
    registration completes. If the registration cannot be started, the
    return value is NULL.

--*/
{
    intptr_t Thread;
    DWORD ThreadId;
    PCTSTR p;
    BOOL ItsAnEXE;
    HANDLE WaitableHandle;
    DWORD ExtendedStatus;
    PREF_STATUS RefStatus = OleControlData->Status;

    MYASSERT(OleControlData != NULL &&
             OleControlData->FullPath != NULL);


    WaitableHandle = NULL;
    ExtendedStatus = ERROR_SUCCESS;
    if (pExtendedStatus) {
        *pExtendedStatus = ERROR_SUCCESS;
    }

    //
    // we keep a refcount on this status, and we increment it
    // now to make sure that the data isn't freed prematurely
    //
    InterlockedIncrement(&OleControlData->Status->RefCount);

    p = _tcsrchr(OleControlData->FullPath, TEXT('.'));
    if (p) {
        p +=1;
    } else {
        ExtendedStatus = ERROR_INVALID_DATA;
        goto e0;
    }

    //
    // let's determine what type of file we're dealing with
    //
    if (0 == _tcsicmp(p,TEXT("exe"))) {
        ItsAnEXE = TRUE;
    } else {
        //
        // let's (gulp!) assume that this is a dll,ocx, or something
        // similar with some wierd extension. in any case, let's
        // just put all of these in the same bucket for now.  If
        // it's really something bogus, then the worst that should
        // happen is that the loadlibrary (in our other thread!) will
        // fall over
        //
        ItsAnEXE = FALSE;
    }

    //
    // if it's an exe, let's just create the process and wait on
    // that handle.
    //
    if (ItsAnEXE) {
        WaitableHandle = pSetupRegisterExe(
                                OleControlData,
                                &ExtendedStatus);

        //
        // we don't need OleControlData anymore, just free it here
        //
        pSetupFreeOleControlData(OleControlData);
        *pHowToGetStatusLaterOn = SP_GETSTATUS_FROMPROCESS;
    } else {
        //
        // we have a dll
        //

        //
        // if we're on 64 bits, then we need to look if this dll is a
        // 32 bit dll.  If it is, then we need use a child process
        // to register the dll.  otherwise we can just treat the dll
        // like "normal"
        //
#ifdef CHILDREGISTRATION
        if (IsThisANonNativeDll(OleControlData->FullPath)) {
            WaitableHandle = pSetupCallChildProcessForRegistration(
                                                OleControlData,
                                                &ExtendedStatus
                                                );
            //
            // we don't need OleControlData anymore, just free it here
            //
            pSetupFreeOleControlData(OleControlData);
            *pHowToGetStatusLaterOn = SP_GETSTATUS_FROMSURRAGATE;
        }
        else
#endif
        //
        // we have a native dll.
        // we handle these in another thread in case it hangs
        //
        {
            Thread = _beginthreadex(
                           NULL,
                           0,
                           pSetupRegisterUnregisterDll,
                           OleControlData,
                           0,
                           &ThreadId
                           );
            if (!Thread) {
                //
                // assume out of memory
                //
                ExtendedStatus = ERROR_NOT_ENOUGH_MEMORY;

                //
                // we don't need OleControlData anymore, just free it here
                //
                pSetupFreeOleControlData(OleControlData);
            } else {
#if PRERELEASE
                RefStatus->ThreadId = ThreadId;
#endif
            }

            WaitableHandle = (HANDLE) Thread;
            *pHowToGetStatusLaterOn = SP_GETSTATUS_FROMDLL;

        }

    }
e0:
    if (pExtendedStatus) {
        *pExtendedStatus = ExtendedStatus;
    }

    return WaitableHandle;

}


DWORD
pSetupProcessRegSvrSection(
    IN HINF   Inf,
    IN PCTSTR Section,
    IN BOOL   Register,
    IN HWND   hWndParent,
    IN PSP_FILE_CALLBACK MsgHandler,
    IN PVOID  Context,
    IN BOOL   IsMsgHandlerNativeCharWidth,
    IN BOOL   RegistrationCallbackAware
    )
/*++

Routine Description:

    process all of the registration directives in the specefied RegisterDlls
    section

    each line is expected to be in the following format:

    <dirid>,<subdir>,<filename>,<registration flags>,<optional timeout>,<arguments>

    <dirid> supplies the base directory id of the file.

    <subdir> if specified, specifies the subdir from the base directory
             where the file resides

    <filename> specifies the name of the file to be registered

    <registration flags> specifies the registration action to be taken

        FLG_REGSVR_DLLREGISTER      ( 0x00000001 )
        FLG_REGSVR_DLLINSTALL       ( 0x00000002 )

    <optional timeout> specifies how long to wait for the registration to
                       complete.  if not specified, use the default timeout

    <arguments>  if specified, contains the cmdline to pass to an executable
                 if we're not handling an EXE, this argument is ignored

Arguments:

    Inf        - Inf handle for the section to be processed
    Section    - name of the section to be processed
    Register   - if TRUE, we are registering items, if FALSE, we are
                 unregistering.  this allows the inf to share one section
                 for install and uninstall
    hWndParent - parent window handle we use for a messagebox
    MsgHandler - pointer to callback routine if we're dealing with a
                "registration aware" callback
    Context    - context pointer for callback routine
    IsMsgHandlerNativeCharWidth - indicates if message pieces need translation
    RegistrationCallbackAware - indicates if the callback routine is aware of
                                registration callbacks

Return Value:

    Win32 error code indicating outcome.

--*/
{
    DWORD dircount,d = NO_ERROR;
    DWORD FailureCode,Count;
    INFCONTEXT InfLine;
    PCTSTR DirId,Subdir,FileName, Args;
    UINT RegType, Timeout;
    PCTSTR FullPathTemp;
    TCHAR FullPath[MAX_PATH];
    TCHAR pwd[MAX_PATH];
    POLE_CONTROL_DATA pOleControlData;
    intptr_t Thread;
    unsigned ThreadId;
    DWORD WaitResult;
    HANDLE SignifyRegistration;
    PSETUP_LOG_CONTEXT LogContext = NULL;
    DWORD log_slot = 0;
    DWORD HowToGetStatus;
    UINT u;
    PREF_STATUS RefStatus;
    PLOADED_INF pLoadedInf = NULL;
#ifdef CHILDREGISTRATION
    WOWSURRAGATE_IPC WowIpcData;
#endif
#ifdef PRERELEASE
    BOOL LastTimeHadTimeout = FALSE;
    TCHAR LastTimeoutFileName[MAX_PATH];
    DWORD DebugTraceInfo = 0; // ISSUE-JamieHun-2001/01/29 attempt to catch a strange stress break
#endif

    //
    // save the current directory so we can restore it later on
    //
    dircount = GetCurrentDirectory(MAX_PATH,pwd);
    if(!dircount || (dircount >= MAX_PATH)) {
        pwd[0] = 0;
    }

#ifdef CHILDREGISTRATION
    ZeroMemory(&WowIpcData,sizeof(WowIpcData));
#endif

    try {
        if(Inf == NULL || Inf == (HINF)INVALID_HANDLE_VALUE || !LockInf((PLOADED_INF)Inf)) {
            d = ERROR_INVALID_PARAMETER;
            leave;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        d = ERROR_INVALID_PARAMETER;
    }
    if (d!=NO_ERROR) {
        MYASSERT(d==NO_ERROR);
        goto clean0;
    }
    pLoadedInf = (PLOADED_INF)Inf; // Inf is locked
    d = InheritLogContext(pLoadedInf->LogContext,&LogContext);
    if(d!=NO_ERROR) {
        goto clean0;
    }
    log_slot = AllocLogInfoSlot(LogContext,FALSE);

    //
    // retrieve the items from section and process them one at a time
    //

    if(SetupFindFirstLine(Inf,Section,NULL,&InfLine)) {

        do {
            //
            // retrieve pointers to the parameters for this file
            //

            DirId = pSetupGetField(&InfLine,1);
            Subdir = pSetupGetField(&InfLine,2);
            FileName = pSetupGetField(&InfLine,3);
            RegType = 0;
            SetupGetIntField(&InfLine,4,&RegType);
            Timeout = 0;
            SetupGetIntField(&InfLine,5,&Timeout);
            Args = pSetupGetField(&InfLine,6);

            pOleControlData = MyMalloc(sizeof(OLE_CONTROL_DATA));
            if (!pOleControlData) {
                d = ERROR_NOT_ENOUGH_MEMORY;
                goto clean0;
            }
            ZeroMemory(pOleControlData,sizeof(OLE_CONTROL_DATA));

            RefStatus = pOleControlData->Status = MyMalloc(sizeof(REF_STATUS));
            if (!pOleControlData->Status) {
                d = ERROR_NOT_ENOUGH_MEMORY;
                pSetupFreeOleControlData(pOleControlData);
                goto clean0;
            }


            ZeroMemory(pOleControlData->Status,sizeof(REF_STATUS));
            InterlockedIncrement(&pOleControlData->Status->RefCount);

            if (!Timeout) {
                Timeout = REGISTER_WAIT_TIMEOUT_DEFAULT;
            }

            //
            // timeout is specified in seconds, we need to convert to millseconds
            //
            Timeout = Timeout * TIME_SCALAR;

            if(DirId && FileName) {

                if(Subdir && (*Subdir == 0)) {
                    Subdir = NULL;
                }

                DebugPrintEx(DPFLTR_TRACE_LEVEL,TEXT("SETUP: filename for file to register is %ws\n"),FileName);

                WriteLogEntry(
                            LogContext,
                            log_slot,
                            (Args && Args[0]) ? MSG_LOG_REGISTER_PARAMS_ARGS : MSG_LOG_REGISTER_PARAMS,
                            NULL,
                            Section,
                            DirId,
                            Subdir ? Subdir : TEXT(""),
                            Subdir ? TEXT("\\") : TEXT(""),
                            FileName,
                            RegType,
                            Timeout/TIME_SCALAR,
                            Args);

                try {
#ifdef PRERELEASE
                    DebugTraceInfo |= 2; // ISSUE-JamieHun-2001/01/29 attempt to catch a strange stress break
#endif
                    //
                    // Get full path to the file
                    //
                    if(FullPathTemp = pGetPathFromDirId(DirId,Subdir,pLoadedInf)) {

#ifdef PRERELEASE
                        DebugTraceInfo |= 4; // ISSUE-JamieHun-2001/01/29 attempt to catch a strange stress break
#endif
                        lstrcpyn(FullPath,FullPathTemp,MAX_PATH);
                        SetCurrentDirectory(FullPath);
                        pSetupConcatenatePaths(FullPath,FileName,MAX_PATH,NULL);

#ifdef PRERELEASE
                        DebugTraceInfo |= 8; // ISSUE-JamieHun-2001/01/29 attempt to catch a strange stress break
#endif
                        //
                        // We key off the global "don't verify INFs" flag to
                        // indicate whether crypto support is available yet.  We
                        // don't want to complain about registering unsigned DLLs
                        // when those DLLs are the ones necessary to enable crypto
                        // (e.g., rsaenh.dll, rsaaes.dll, dssenh.dll, initpki.dll)
                        //
                        if(!(GlobalSetupFlags & PSPGF_NO_VERIFY_INF)) {

                            PSP_ALTPLATFORM_INFO_V2 ValidationPlatform = NULL;
                            PTSTR LocalDeviceDesc = NULL;

#ifdef PRERELEASE
                            DebugTraceInfo |= 8; // ISSUE-JamieHun-2001/01/29 attempt to catch a strange stress break
#endif
                            //
                            // Verify the digital signature for the file we're
                            // about to register/unregister.  We use a policy of
                            // "Ignore" so that unsigned files will silently be
                            // processed (with logging) except for the case when
                            // we're in non-interactive mode.
                            //
                            // (First, retrieve validation information relevant to
                            // this device setup class.)
                            //
                            IsInfForDeviceInstall(LogContext,
                                                  NULL,
                                                  pLoadedInf,
                                                  &LocalDeviceDesc,
                                                  &ValidationPlatform,
                                                  NULL,
                                                  NULL,
                                                  FALSE
                                                 );

                            //
                            // We can only validate using driver signing policy
                            // since we don't have the context to pinpoint a
                            // specific Authenticode-signed catalog that should
                            // be used.
                            //
                            d = _VerifyFile(LogContext,
                                            NULL,
                                            NULL,
                                            NULL,
                                            0,
                                            pSetupGetFileTitle(FullPath),
                                            FullPath,
                                            NULL,
                                            NULL,
                                            FALSE,
                                            ValidationPlatform,
                                            (VERIFY_FILE_USE_OEM_CATALOGS | VERIFY_FILE_NO_DRIVERBLOCKED_CHECK),
                                            NULL,
                                            NULL,
                                            NULL,
                                            NULL,
                                            NULL
                                           );

                            if(d != NO_ERROR) {

                                if(_HandleFailedVerification(
                                       hWndParent,
                                       SetupapiVerifyRegSvrFileProblem,
                                       FullPath,
                                       LocalDeviceDesc,
                                       DRIVERSIGN_NONE,
                                       TRUE,
                                       d,
                                       LogContext,
                                       NULL,
                                       NULL,
                                       NULL)) {
                                    //
                                    // We can continue on registering the file, even
                                    // though it's unsigned.
                                    //
                                    d = NO_ERROR;

                                }
                            }

#ifdef PRERELEASE
                            DebugTraceInfo |= 0x10; // ISSUE-JamieHun-2001/01/29 attempt to catch a strange stress break
#endif
                            //
                            // Free buffers we may have retrieved when calling
                            // IsInfForDeviceInstall().
                            //
                            if(LocalDeviceDesc) {
                                MyFree(LocalDeviceDesc);
                            }

                            if(ValidationPlatform) {
                                MyFree(ValidationPlatform);
                            }

                            if(d != NO_ERROR) {
                                //
                                // We need to abort the registration...
                                //
                                MyFree(FullPathTemp);
                                pSetupFreeOleControlData(pOleControlData);
                                leave;
                            }
#ifdef PRERELEASE
                            DebugTraceInfo |= 0x20; // ISSUE-JamieHun-2001/01/29 attempt to catch a strange stress break
#endif

                        } else {
                            //
                            // Our global flag indicates crypto support isn't
                            // available yet.  Log an entry indicating we skipped
                            // digital signature verification for this file.
                            //
                            WriteLogEntry(LogContext,
                                          SETUP_LOG_WARNING,
                                          (Register
                                            ? MSG_LOG_REGSVR_FILE_VERIFICATION_SKIPPED
                                            : MSG_LOG_UNREGSVR_FILE_VERIFICATION_SKIPPED),
                                          NULL,
                                          FullPath
                                         );
                        }

                        pOleControlData->Register = Register;
                        pOleControlData->FullPath = DuplicateString(FullPath);

#ifdef PRERELEASE
                        DebugTraceInfo |= 0x40; // ISSUE-JamieHun-2001/01/29 attempt to catch a strange stress break
#endif
                        if (!pOleControlData->FullPath) {
                            MyFree(FullPathTemp);
                            d = ERROR_NOT_ENOUGH_MEMORY;
                            pSetupFreeOleControlData(pOleControlData);
                            leave;
                        }
    #ifdef CHILDREGISTRATION
                        pOleControlData->WowIpcData = &WowIpcData;
    #endif
                        pOleControlData->RegType = RegType;
                        pOleControlData->Argument = Args
                                      ? DuplicateString(Args)
                                      : NULL;
                        if (Args && !pOleControlData->Argument) {
                            MyFree(FullPathTemp);
                            d = ERROR_NOT_ENOUGH_MEMORY;
                            pSetupFreeOleControlData(pOleControlData);
                            goto clean0;
                        }
                        InheritLogContext(LogContext,&pOleControlData->LogContext);

                        if (RegistrationCallbackAware && MsgHandler) {
                            //
                            // Inform the callback that we are about to start
                            // a registration operation, giving it the chance
                            // to abort if it wants to.
                            //
                            SP_REGISTER_CONTROL_STATUS ControlStatus;

                            ZeroMemory(
                                &ControlStatus,
                                sizeof(SP_REGISTER_CONTROL_STATUS));
                            ControlStatus.cbSize = sizeof(SP_REGISTER_CONTROL_STATUS);
                            ControlStatus.FileName = FullPath;

                            u = pSetupCallMsgHandler(
                                           LogContext,
                                           MsgHandler,
                                           IsMsgHandlerNativeCharWidth,
                                           Context,
                                           SPFILENOTIFY_STARTREGISTRATION,
                                           (UINT_PTR)&ControlStatus,
                                           Register
                                           );
                        } else {
                            //
                            // not registration aware, assume a default
                            //
#ifdef PRERELEASE
                            DebugTraceInfo |= 0x80; // ISSUE-JamieHun-2001/01/29 attempt to catch a strange stress break
#endif
                            u = FILEOP_DOIT;
                        }

                        if(u == FILEOP_ABORT) {
#ifdef PRERELEASE
                            DebugTraceInfo |= 0x100; // ISSUE-JamieHun-2001/01/29 attempt to catch a strange stress break
#endif
                            d = GetLastError();
                            if (d==NO_ERROR) {
                                d = ERROR_OPERATION_ABORTED;
                            }
                            WriteLogEntry(
                                        LogContext,
                                        SETUP_LOG_ERROR|SETUP_LOG_BUFFER,
                                        MSG_LOG_STARTREGISTRATION_ABORT,
                                        NULL);
                            WriteLogError(
                                        LogContext,
                                        SETUP_LOG_ERROR,
                                        d
                                        );

                            pSetupFreeOleControlData(pOleControlData);

                            MyFree(FullPathTemp);

                            goto clean0;
                        } else if (u == FILEOP_SKIP) {
#ifdef PRERELEASE
                            DebugTraceInfo |= 0x200; // ISSUE-JamieHun-2001/01/29 attempt to catch a strange stress break
#endif
                            WriteLogEntry(
                                        LogContext,
                                        SETUP_LOG_WARNING,
                                        MSG_LOG_STARTREGISTRATION_SKIP,
                                        NULL
                                        );
                            pSetupFreeOleControlData(pOleControlData);
                            //
                            // set to NULL so we don't try to free it later
                            //
                            RefStatus = NULL;
                        } else if(u == FILEOP_DOIT) {
                            //
                            // Attempt the registration and inform the callback,
                            //
                            DWORD ExtendedError;
#ifdef PRERELEASE
                            DebugTraceInfo |= 0x200; // ISSUE-JamieHun-2001/01/29 attempt to catch a strange stress break
#endif
#ifdef PRERELEASE
                            ASSERT_HEAP_IS_VALID();
#endif

                            SignifyRegistration = pSetupSpawnRegistration(
                                                            pOleControlData,
                                                            &HowToGetStatus,
                                                            &ExtendedError );


#ifdef PRERELEASE
                            DebugTraceInfo |= 0x1000; // ISSUE-JamieHun-2001/01/29 attempt to catch a strange stress break
#endif
                            if(SignifyRegistration) {

                                HANDLE hEvents[1];
                                int CurEvent = 0;

                                //
                                // wait until thread has done a minimal amount of work
                                // when this work is done, we can re-use or trash this structure
                                // and we know timeout for this thread
                                //

                                hEvents[0] = (HANDLE)SignifyRegistration;

                                do {
                                    WaitResult = MyMsgWaitForMultipleObjectsEx(
                                        1,
                                        &hEvents[0],
                                        Timeout,
                                        QS_ALLINPUT,
                                        MWMO_ALERTABLE | MWMO_INPUTAVAILABLE);
#ifdef PRERELEASE
                                    DebugTraceInfo |= 0x2000; // ISSUE-JamieHun-2001/01/29 attempt to catch a strange stress break
#endif
                                    if (WaitResult == WAIT_OBJECT_0 + 1) {
                                        MSG msg;

                                        while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {
                                            TranslateMessage(&msg);
                                            DispatchMessage(&msg);
                                        }
                                    }
                                } while(WaitResult != WAIT_TIMEOUT &&
                                        WaitResult != WAIT_OBJECT_0 &&
                                        WaitResult != WAIT_FAILED);

#ifdef PRERELEASE
                                DebugTraceInfo |= 0x4000; // ISSUE-JamieHun-2001/01/29 attempt to catch a strange stress break
#endif
                                if (WaitResult == WAIT_TIMEOUT) {
#ifdef PRERELEASE
                                    if (HowToGetStatus == SP_GETSTATUS_FROMDLL) {
                                        int __pass;

                                        for(__pass = 0;__pass < 2;__pass ++) {

                                            //
                                            // All stop so this can get debugged
                                            //
                                            DebugPrintEx(
                                                DPFLTR_ERROR_LEVEL,

                                                TEXT("Windows has detected that\n")
                                                TEXT("Registration of \"%s\" appears to have hung\n")
                                                TEXT("Contact owner of the hung DLL to diagnose\n")
                                                TEXT("Timeout for DLL was set to %u seconds\n")
                                                TEXT("ThreadID of hung DLL is %u (0x%x)\n%s"),
                                                FullPath,
                                                Timeout/TIME_SCALAR,
                                                RefStatus->ThreadId,RefStatus->ThreadId,
                                                ((__pass==0) ? TEXT("Hitting 'g' will display this again\n") : TEXT(""))
                                                );
                                                DebugBreak();
                                        }
                                    }
#endif
                                    //
                                    //  the ole registration is hung
                                    //  log an error
                                    //
                                    WriteLogEntry(
                                        LogContext,
                                        SETUP_LOG_ERROR,
                                        MSG_LOG_OLE_REGISTRATION_HUNG,
                                        NULL,
                                        FullPath
                                        );

                                    d = WAIT_TIMEOUT;
                                    FailureCode = SPREG_TIMEOUT;


#ifdef PRERELEASE
                                    //
                                    // This is to catch setup errors
                                    // and does not indicate an error
                                    // in SetupAPI
                                    //
                                    if (LastTimeHadTimeout) {
#ifdef CHILDREGISTRATION
                                            if (HowToGetStatus == SP_GETSTATUS_FROMSURRAGATE) {
                                                DebugPrintEx(
                                                    DPFLTR_ERROR_LEVEL,
#ifdef _WIN64
                                                    TEXT("Windows has detected that ")
                                                    TEXT("32-bit WOWREG32 has timed out while registering \"%s\". ")
                                                    TEXT("Prior to this, \"%s\" timed out. ")
                                                    TEXT("This may indicate a persistent error. ")
                                                    TEXT("To diagnose, try to ")
                                                    TEXT("register them by hand or contact ")
                                                    TEXT("the owners of these files ")
                                                    TEXT("to determine why they are timing out. ")
                                                    TEXT("also try running other 32-bit executables.\n"),
#else
                                                    TEXT("Windows has detected that ")
                                                    TEXT("64-bit WOWREG32 has timed out while registering \"%s\". ")
                                                    TEXT("Prior to this, \"%s\" timed out. ")
                                                    TEXT("This may indicate a persistent error. ")
                                                    TEXT("To diagnose, try to ")
                                                    TEXT("register them by hand or contact ")
                                                    TEXT("the owners of these files ")
                                                    TEXT("to determine why they are timing out. ")
                                                    TEXT("also try running other 64-bit executables.\n"),
#endif
                                                    FileName,
                                                    LastTimeoutFileName
                                                    );

                                            } else {
#endif
                                                DebugPrintEx(
                                                    DPFLTR_ERROR_LEVEL,
                                                    TEXT("Windows has detected that ")
                                                    TEXT("the registration of \"%s\" timed out. ")
                                                    TEXT("Prior to this, \"%s\" timed out. ")
                                                    TEXT("This may indicate a persistent error. ")
                                                    TEXT("To diagnose, try to ")
                                                    TEXT("register them by hand or contact ")
                                                    TEXT("the owners of these files ")
                                                    TEXT("to determine why they are timing out.\n"),
                                                    FileName,
                                                    LastTimeoutFileName
                                                    );
#ifdef CHILDREGISTRATION
                                            }
#endif
                                            DebugBreak();
                                    }
                                    LastTimeHadTimeout = TRUE;
                                    lstrcpyn(LastTimeoutFileName,FileName,MAX_PATH);
#endif

#ifdef CHILDREGISTRATION
                                    if (HowToGetStatus == SP_GETSTATUS_FROMSURRAGATE) {
                                        //
                                        // we have no choice but to abandon the process
                                        //
                                        pSetupCleanupWowIpcStream(&WowIpcData);

                                        //
                                        // set our handle to NULL so we don't
                                        // accidentally close it
                                        //
                                        SignifyRegistration = NULL;
                                    }
#endif

                                } else {

#ifdef PRERELEASE
                                    LastTimeHadTimeout = FALSE;
#endif

                                    switch(HowToGetStatus) {
                                        case SP_GETSTATUS_FROMDLL:
#ifdef PRERELEASE
                                            DebugTraceInfo |= 0x10000; // ISSUE-JamieHun-2001/01/29 attempt to catch a strange stress break
#endif
                                            GetExitCodeThread(SignifyRegistration,&d);
                                            FailureCode = RefStatus->ExtendedStatus;
                                            break;
#ifdef CHILDREGISTRATION
                                        case SP_GETSTATUS_FROMSURRAGATE:

#ifdef PRERELEASE
                                            DebugTraceInfo |= 0x20000; // ISSUE-JamieHun-2001/01/29 attempt to catch a strange stress break
#endif
                                            //
                                            // get the status code from the shared
                                            // memory region
                                            //
                                            MYASSERT(WowIpcData.MemoryRegion != NULL);
                                            d = ((PWOW_IPC_REGION_FROMSURRAGATE)WowIpcData.MemoryRegion)->Win32Error;
                                            FailureCode = ((PWOW_IPC_REGION_FROMSURRAGATE)WowIpcData.MemoryRegion)->FailureCode;
                                            //
                                            // reset the "it's complete" event so
                                            // we don't loop on it.
                                            //
                                            ResetEvent(WowIpcData.SignalRegistrationComplete);

                                            //
                                            // set the handle to NULL so we don't
                                            // accidentally close it
                                            //
                                            SignifyRegistration = NULL;
                                            break;
#endif
                                        case SP_GETSTATUS_FROMPROCESS:
#ifdef PRERELEASE
                                            DebugTraceInfo |= 0x40000; // ISSUE-JamieHun-2001/01/29 attempt to catch a strange stress break
#endif
                                            GetExitCodeProcess(SignifyRegistration,&d);
                                            FailureCode = SPREG_SUCCESS;
                                            d = NO_ERROR;

                                            break;
                                        default:
                                            MYASSERT(FALSE);
                                    }

                                }

#ifdef PRERELEASE
                                DebugTraceInfo |= 0x80000; // ISSUE-JamieHun-2001/01/29 attempt to catch a strange stress break
#endif
                                if (SignifyRegistration) {
                                    CloseHandle( SignifyRegistration );
                                }
#ifdef PRERELEASE
                                DebugTraceInfo |= 0x100000; // ISSUE-JamieHun-2001/01/29 attempt to catch a strange stress break
#endif

                            } else {
                                //
                                // the dll spawning failed.
                                // let's go onto the next one
                                //
                                d = ExtendedError;
                                FailureCode = SPREG_UNKNOWN;
                            }

#ifdef PRERELEASE
                            DebugTraceInfo |= 0x200000; // ISSUE-JamieHun-2001/01/29 attempt to catch a strange stress break
#endif
                            // make sure the dll, etc., didn't corrupt the heap
                            ASSERT_HEAP_IS_VALID();

                            if(d) {
                                WriteLogEntry(
                                            LogContext,
                                            SETUP_LOG_ERROR | SETUP_LOG_BUFFER,
                                            MSG_LOG_REGISTRATION_FAILED,
                                            NULL,
                                            FullPath
                                            );
                                WriteLogError(
                                            LogContext,
                                            SETUP_LOG_ERROR,
                                            d
                                            );
                            }

                            if (RegistrationCallbackAware && MsgHandler) {
                                SP_REGISTER_CONTROL_STATUS ControlStatus;

#ifdef PRERELEASE
                                DebugTraceInfo |= 0x400000; // ISSUE-JamieHun-2001/01/29 attempt to catch a strange stress break
#endif
                                ZeroMemory(
                                    &ControlStatus,
                                    sizeof(SP_REGISTER_CONTROL_STATUS));
                                ControlStatus.cbSize = sizeof(SP_REGISTER_CONTROL_STATUS);
                                ControlStatus.FileName = FullPath;
                                ControlStatus.Win32Error = d;
                                ControlStatus.FailureCode = FailureCode;

                                u = pSetupCallMsgHandler(
                                               LogContext,
                                               MsgHandler,
                                               IsMsgHandlerNativeCharWidth,
                                               Context,
                                               SPFILENOTIFY_ENDREGISTRATION,
                                               (UINT_PTR)&ControlStatus,
                                               Register );

#ifdef PRERELEASE
                                DebugTraceInfo |= 0x800000; // ISSUE-JamieHun-2001/01/29 attempt to catch a strange stress break
#endif
                                if (u == FILEOP_ABORT) {
                                    d = GetLastError();
                                    if (d==NO_ERROR) {
                                        d = ERROR_OPERATION_ABORTED;
                                    }
                                    WriteLogEntry(
                                                LogContext,
                                                SETUP_LOG_ERROR|SETUP_LOG_BUFFER,
                                                MSG_LOG_ENDREGISTRATION_ABORT,
                                                NULL);
                                    WriteLogError(
                                                LogContext,
                                                SETUP_LOG_ERROR,
                                                d
                                                );
                                    //
                                    // need a refcount on this cause we will free this if the
                                    // child thread has timed out (or if we never had a thread
                                    // this will just be deallocated).
                                    //
                                    Count = InterlockedDecrement(&RefStatus->RefCount);
                                    if (!Count) {
                                        MyFree(RefStatus);
                                    }

                                    MyFree(FullPathTemp);
                                    goto clean0;
                                } else {
                                    //
                                    // the callback indicated that it saw any error
                                    // which occurred and it wants to continue, so
                                    // reset the error code to "none" so that we
                                    // continue processing items in this section.
                                    //
                                    d = NO_ERROR;
                                }



                            }
                        } else {
#ifdef PRERELEASE
                            DebugTraceInfo |= 0x400; // ISSUE-JamieHun-2001/01/29 attempt to catch a strange stress break
#endif
                            pSetupFreeOleControlData(pOleControlData);
                            //
                            // set to NULL so we don't try to free it later
                            //
                            RefStatus = NULL;
                        }

                        //
                        // need a refcount on this cause we will free this if the
                        // child thread has timed out (or if we never had a thread
                        // this will just be deallocated).
                        //
                        if (RefStatus) {
                            Count = InterlockedDecrement(&RefStatus->RefCount);
                            if (!Count) {
                                MyFree(RefStatus);
                            }
                        }
                        MyFree(FullPathTemp);
                    }
#ifdef PRERELEASE
                    DebugTraceInfo = 1; // attempt to catch a strange stress break
#endif
                    d = NO_ERROR;
                } except(EXCEPTION_EXECUTE_HANDLER) {
                    MYASSERT(FALSE && "Exception taken during register/unregister");
                    d = ERROR_INVALID_DATA;
                }

            } else {
                DebugPrintEx(DPFLTR_TRACE_LEVEL,TEXT("SETUP: dll skipped, bad dirid\n"));
                WriteLogEntry(
                    LogContext,
                    SETUP_LOG_ERROR,
                    MSG_LOG_CANT_OLE_CONTROL_DIRID,
                    NULL,
                    FileName,
                    DirId
                    );

                d = ERROR_INVALID_DATA;

            }

        } while(SetupFindNextLine(&InfLine,&InfLine)  && d == NO_ERROR);
    } else {

        WriteLogEntry(
            LogContext,
            SETUP_LOG_ERROR,
            MSG_LOG_NOSECTION_MIN,
            NULL,
            Section,
            ((PLOADED_INF) Inf)->OriginalInfName
            );

        d = ERROR_INVALID_DATA;
    }

    //
    // cleanup
    //

clean0:
#ifdef CHILDREGISTRATION
    pSetupCleanupWowIpcStream(&WowIpcData);
#endif

    if(log_slot) {
        ReleaseLogInfoSlot(LogContext,log_slot);
    }
    if(LogContext) {
        DeleteLogContext(LogContext); // this is ref-counted
    }
    if(pLoadedInf) {
        UnlockInf(pLoadedInf);
    }

    //
    // put back the current working directory
    //
    if (pwd && pwd[0]) {
        SetCurrentDirectory(pwd);
    }

    return d;

}


DWORD
pSetupInstallRegisterUnregisterDlls(
    IN HINF   Inf,
    IN PCTSTR SectionName,
    IN BOOL   Register,
    IN HWND   hWndParent,
    IN PSP_FILE_CALLBACK Callback,
    IN PVOID  Context,
    IN BOOL   IsMsgHandlerNativeCharWidth,
    IN BOOL   RegistrationCallbackAware
    )

/*++

Routine Description:

    Locate the RegisterDlls= lines in an install section
    and process each section listed therein.

Arguments:

    Inf - supplies inf handle for inf containing the section indicated
        by SectionName.

    SectionName - supplies name of install section.

    Register - TRUE if register, FALSE if unregister

    hWndParent - parent window handle

    Callback - pointer to queue callback routine

    Context - context pointer for callback routine

    IsMsgHandlerNativeCharWidth - indicates if message pieces need translation

    RegistrationCallbackAware - indicates if callback routine wants to receive
                                registration callback notifications

Return Value:

    Win32 error code indicating outcome.

--*/

{
    DWORD d = NO_ERROR;
    INFCONTEXT LineContext;
    DWORD Field, FieldCount;
    PCTSTR SectionSpec;

    //
    // Find the RegisterDlls line in the given install section.
    // If not present then we're done with this operation.
    //


    if(!SetupFindFirstLine(  Inf
                           , SectionName
                           , Register? pszRegSvr : pszUnRegSvr
                           , &LineContext )) {

        DWORD rc = GetLastError();
        if((rc != NO_ERROR) && (rc != ERROR_SECTION_NOT_FOUND) && (rc != ERROR_LINE_NOT_FOUND)) {
            pSetupLogSectionError(Inf,NULL,NULL,NULL,SectionName,MSG_LOG_INSTALLSECT_ERROR,rc,NULL);
        }
        SetLastError(NO_ERROR); // for compatibility with older versions of SetupAPI
        return NO_ERROR;
    }

    do {
        //
        // Each value on the line in the given install section
        // is the name of another section.
        //
        FieldCount = SetupGetFieldCount(&LineContext);
        for(Field=1; d == NO_ERROR && (Field<=FieldCount); Field++) {

            if(SectionSpec = pSetupGetField(&LineContext,Field)) {

                if(SetupGetLineCount(Inf,SectionSpec) > 0) {
                    //
                    // The section exists and is not empty.
                    // So process it.
                    //
                    d = pSetupProcessRegSvrSection(
                                        Inf,
                                        SectionSpec,
                                        Register,
                                        hWndParent,
                                        Callback,
                                        Context,
                                        IsMsgHandlerNativeCharWidth,
                                        RegistrationCallbackAware);
                    if(d!=NO_ERROR) {
                        pSetupLogSectionError(Inf,NULL,NULL,NULL,SectionSpec,MSG_LOG_SECT_ERROR,d,Register? pszRegSvr : pszUnRegSvr);
                    }
                }

            }
        }
    } while(SetupFindNextMatchLine(  &LineContext
                                   , Register? pszRegSvr : pszUnRegSvr
                                   , &LineContext));

    SetLastError(d);

    return d;

}

#ifndef ANSI_SETUPAPI

BOOL
pSetupProcessProfileSection(
    IN HINF   Inf,
    IN PCTSTR Section
    )
/*

Routine Description :

    process all the directives specified in this single ProfileItems section . This section can have the following
    directives in the listed format

    [SectionX]
    Name = <Name> (as appears in Start Menu), <Flags>, <CSIDL>
    SubDir = <subdir>
    CmdLine = <dirid>,<subdirectory>,<filename>, <args>
    IconPath = <dirid>,<subdirectory>,<filename>
    IconIndex = <index>
    WorkingDir = <dirid>,<subdirectory>
    HotKey = <hotkey>
    InfoTip = <infotip>
    DisplayResource = <dllname>,<resid>

     Comments on the various parameters -

        By default all links are created under Start Menu\Programs. This can be over-ridden by using CSIDLs.

        Flags  - can be specified by ORing the necessary flags - OPTIONAL
                     FLG_PROFITEM_CURRENTUSER ( 0x00000001 ) - Operates on item in the current user's profile (Default is All User)
                     FLG_PROFITEM_DELETE      ( 0x00000002 ) - Operation is to delete the item (Default is to add)
                     FLG_PROFITEM_GROUP       ( 0x00000004 ) - Operation is on a group (Default is on a item)
                     FLG_PROFITEM_CSIDL       ( 0x00000008 ) - Don't default to Start Menu and use CSIDL specified - default CSIDL is 0

        CSIDL  - Used with FLG_PROFITEM_CSIDL and should be in decimal. OPTIONAL
                 Note: Will not work with FLG_PROFITEM_CURRENTUSER or FLG_PROFITEM_GROUP.
        subdir - Specify a subdirectory relative to the CSIDL group (default CSIDL group is Programs/StartMenu. OPTIONAL
        CmdLine - Required in the case of add operations but not for delete.
            dirid  - supplies the base directory id of the file. (Required if CmdLine exists)
            subdir - if specified, is the sub directory off the base directory where the file resides (Optional)
            filename - specifies the name of the binary that we are creating a link for. (Required if CmdLine exists)
            args     - If we need to specif a binary that contains spaces in its name then this can be used for args. (Optional)
        IconPath - Optional. If not specified will default to NULL
            dirid  - supplies the base directory id of the file that contains the icon. (Required if IconPath exists)
            subdir - if specified, is the sub directory off the base directory where the file resides (Optional)
            filename - specifies the name of the binary that contains the icon. (Required if IconPath exists)
        IconIndex - Optional, defaults to 0
            index - index of the icon in the executable.  Default is 0. (Optional)
        WorkingDir - Optional
            dirid  - supplies the base directory id of the working directory as needed by the shell. (Required if WorkingDir exists)
            subdir - if specified, is the sub directory off the base working directory (Optional)
        HotKey - Optional
            hotkey - hotkey code (optional)
        InfoTip - Optional
            infotip - String that contains description of the link
        DisplayResource - Optional
            filename - File, DLL/Executable where resource id resides
            resid - Identifier of resource, integer

*/
{
    PCTSTR Keys[9] = { TEXT("Name"), TEXT("SubDir"), TEXT("CmdLine"), TEXT("IconPath"), \
                        TEXT("IconIndex"), TEXT("WorkingDir"),TEXT("HotKey"), \
                        TEXT("InfoTip"), TEXT("DisplayResource") };
    INFCONTEXT InfLine;
    UINT Flags, Opt_csidl, i, j, Apply_csidl;
    TCHAR CmdLine[MAX_PATH+2], IconPath[MAX_PATH+2];
    PCTSTR Name = NULL, SubDir=NULL;
    PCTSTR WorkingDir=NULL, InfoTip=NULL, Temp_Args=NULL, BadInf;
    PCTSTR Temp_DirId = NULL, Temp_Subdir = NULL, Temp_Filename = NULL, FullPathTemp = NULL;
    UINT IconIndex = 0, t=0;
    DWORD HotKey = 0;
    DWORD DisplayResource = 0;
    BOOL ret, space;
    DWORD LineCount,Err;
    PTSTR ptr;
    PCTSTR OldFileName;
    PCTSTR DisplayResourceFile = NULL;
    PLOADED_INF pLoadedInf = NULL;

    CmdLine[0]=0;
    IconPath[0]=0;

    try {
        if(Inf == NULL || Inf == (HINF)INVALID_HANDLE_VALUE || !LockInf((PLOADED_INF)Inf)) {
            ret = FALSE;
            leave;
        }
        ret = TRUE;
    } except(EXCEPTION_EXECUTE_HANDLER) {
        ret = FALSE;
    }
    if (!ret) {
        Err = ERROR_INVALID_PARAMETER;
        MYASSERT(Err == NO_ERROR);
        goto clean0;
    }
    pLoadedInf = (PLOADED_INF)Inf; // Inf is locked

    //
    // Get the correct name of the inf to use while logging
    //
    BadInf = pLoadedInf->OriginalInfName ? pLoadedInf->OriginalInfName :
               pLoadedInf->VersionBlock.Filename;

    if(SetupFindFirstLine(Inf,Section,NULL,&InfLine)) {

        LineCount = SetupGetLineCount(Inf, Section);
        //
        // caller should make sure we have a non-empty section
        //
        MYASSERT( LineCount > 0 );

        ret = FALSE;

        for( i=0; LineCount && (i < 9 ); i++ ){

            if( !SetupFindFirstLine( Inf, Section, Keys[i], &InfLine ) )
                continue;

            switch( i ){
                                                                 // Name
                case 0:
                    Name = pSetupGetField( &InfLine, 1 );
                    Flags = 0x0;
                    SetupGetIntField( &InfLine, 2, &Flags );
                    Opt_csidl = 0x0;
                    if(Flags & FLG_PROFITEM_CSIDL)
                        SetupGetIntField( &InfLine, 3, &Opt_csidl );
                    break;

                case 1:                                         // SubDir
                    SubDir = pSetupGetField( &InfLine, 1 );
                    break;
                                                                // CmdLine
                case 2:
                    Temp_DirId = pSetupGetField( &InfLine, 1 );
                    Temp_Subdir = pSetupGetField( &InfLine, 2 );
                    Temp_Filename = pSetupGetField( &InfLine, 3 );
                    OldFileName = NULL;
                    Temp_Args = pSetupGetField( &InfLine, 4 );    //Not published - useful in the case of spaces in filename itself
                    if( Temp_DirId && Temp_Filename ){
                        if( Temp_Subdir && (*Temp_Subdir == 0))
                            Temp_Subdir = NULL;
                    }
                    else
                        break;

                    // Do the "quote or not to quote" to make shell happy in the different cases

                    FullPathTemp = pGetPathFromDirId(Temp_DirId,Temp_Subdir,pLoadedInf);


                    if( FullPathTemp && Temp_Filename ){
                        space = FALSE;
                        if(_tcschr(FullPathTemp, TEXT(' ')) || Temp_Args )    //Check for space in path or if args specified as seperate parameter
                           space = TRUE;

                        if( space ){
                            CmdLine[0] = TEXT('\"');
                            t = 1;
                        }
                        else
                            t = 0;
                        lstrcpyn(CmdLine+t, FullPathTemp, MAX_PATH);
                        if( space ){
                            if( Temp_Args )
                                ptr = (PTSTR)Temp_Args;
                            else{
                                ptr = NULL;
                                //
                                // Temp_Filename is a constant string.  we
                                // make a copy of it so we can manipulate it
                                //
                                //
                                OldFileName = Temp_Filename;
                                Temp_Filename = DuplicateString( OldFileName );
                                if( ptr = _tcschr(Temp_Filename, TEXT(' ')) ){   //in case of space in path look for the filename part (not argument)
                                    *ptr = 0;
                                    ptr++;
                                }
                            }
                        }
                        pSetupConcatenatePaths(CmdLine,Temp_Filename,MAX_PATH,NULL);

                        if( space ){
                            lstrcat( CmdLine, TEXT("\""));      //put the last quote
                            if( ptr ){                          //If there is an argument concatenate it
                                lstrcat( CmdLine, TEXT(" ") );
                                lstrcat( CmdLine, ptr );
                            }

                        }
                        MyFree( FullPathTemp );
                        if (OldFileName) {
                            MyFree( Temp_Filename );
                            Temp_Filename = OldFileName;
                        }
                    }
                    break;
                                                               //Icon Path
                case 3:
                    Temp_DirId = pSetupGetField( &InfLine, 1 );
                    Temp_Subdir = pSetupGetField( &InfLine, 2 );
                    Temp_Filename = pSetupGetField( &InfLine, 3 );
                    if( Temp_DirId && Temp_Filename ){
                        if( Temp_Subdir && (*Temp_Subdir == 0))
                            Temp_Subdir = NULL;
                    }
                    else
                        break;
                    FullPathTemp = pGetPathFromDirId(Temp_DirId,Temp_Subdir,pLoadedInf);
                    if( FullPathTemp && Temp_Filename ){
                        lstrcpyn(IconPath, FullPathTemp, MAX_PATH);
                        pSetupConcatenatePaths(IconPath,Temp_Filename,MAX_PATH,NULL);
                        MyFree( FullPathTemp );
                    }
                    break;


                case 4:                                        //Icon Index
                    SetupGetIntField( &InfLine, 1, &IconIndex );
                    break;

                case 5:                                        // Working Dir
                    Temp_DirId = pSetupGetField( &InfLine, 1 );
                    Temp_Subdir = pSetupGetField( &InfLine, 2 );
                    if( Temp_DirId ){
                        if( Temp_Subdir && (*Temp_Subdir == 0))
                            Temp_Subdir = NULL ;
                    }
                    else
                        break;
                    WorkingDir = pGetPathFromDirId(Temp_DirId,Temp_Subdir,pLoadedInf);
                    break;

                case 6:                                       // Hot Key
                    HotKey = 0;
                    SetupGetIntField( &InfLine, 1, &HotKey );
                    break;

                case 7:                                      // Info Tip
                    InfoTip = pSetupGetField( &InfLine, 1 );
                    break;

                case 8:                                     // Display Resource
                    DisplayResourceFile = pSetupGetField( &InfLine, 1);
                    DisplayResource = 0;
                    SetupGetIntField( &InfLine, 2, &DisplayResource );
                    break;

            }//switch

        }//for


        if( Name && (*Name != 0) ){

            if( Flags & FLG_PROFITEM_GROUP ){

                if( Flags & FLG_PROFITEM_DELETE ){
                    ret = DeleteGroup( Name, ((Flags & FLG_PROFITEM_CURRENTUSER) ? FALSE : TRUE) );
                    if( !ret && ( (GetLastError() == ERROR_FILE_NOT_FOUND) ||
                                  (GetLastError() == ERROR_PATH_NOT_FOUND) )){
                        ret = TRUE;
                        SetLastError( NO_ERROR );
                    }
                }else {
                    ret = CreateGroupEx( Name,
                                         ((Flags & FLG_PROFITEM_CURRENTUSER) ? FALSE : TRUE),
                                         (DisplayResourceFile && DisplayResourceFile[0]) ? DisplayResourceFile : NULL,
                                         (DisplayResourceFile && DisplayResourceFile[0]) ? DisplayResource : 0);
                }
            }
            else{

                if( Flags & FLG_PROFITEM_CSIDL )
                    Apply_csidl = Opt_csidl;
                else
                    Apply_csidl = (Flags & FLG_PROFITEM_CURRENTUSER) ? CSIDL_PROGRAMS : CSIDL_COMMON_PROGRAMS;



                if( SubDir && (*SubDir == 0 ))
                    SubDir = NULL;

                if( Flags & FLG_PROFITEM_DELETE ){

                    ret = DeleteLinkFile(
                            Apply_csidl,
                            SubDir,
                            Name,
                            TRUE
                            );

                    if( !ret && ( (GetLastError() == ERROR_FILE_NOT_FOUND) ||
                                  (GetLastError() == ERROR_PATH_NOT_FOUND) )){
                        ret = TRUE;
                        SetLastError( NO_ERROR );
                    }


                }
                else{

                     if( CmdLine && (*CmdLine != 0)){

                         ret = CreateLinkFileEx(
                                    Apply_csidl,
                                    SubDir,
                                    Name,
                                    CmdLine,
                                    IconPath,
                                    IconIndex,
                                    WorkingDir,
                                    (WORD)HotKey,
                                    SW_SHOWNORMAL,
                                    InfoTip,
                                    (DisplayResourceFile && DisplayResourceFile[0]) ? DisplayResourceFile : NULL,
                                    (DisplayResourceFile && DisplayResourceFile[0]) ? DisplayResource : 0
                                    );
                     }else{
                        WriteLogEntry(
                            ((PLOADED_INF) Inf)->LogContext,
                            SETUP_LOG_ERROR,
                            MSG_LOG_PROFILE_BAD_CMDLINE,
                            NULL,
                            Section,
                            BadInf
                            );


                        ret = FALSE;
                        SetLastError(ERROR_INVALID_DATA);


                     }
                }





            }

            if( !ret ){

                Err = GetLastError();
                WriteLogEntry(
                    ((PLOADED_INF) Inf)->LogContext,
                    SETUP_LOG_ERROR|SETUP_LOG_BUFFER,
                    MSG_LOG_PROFILE_OPERATION_ERROR,
                    NULL,
                    Section,
                    BadInf
                    );
                WriteLogError(
                    ((PLOADED_INF) Inf)->LogContext,
                    SETUP_LOG_ERROR,
                    Err);


            }



        }else{
            WriteLogEntry(
                ((PLOADED_INF) Inf)->LogContext,
                SETUP_LOG_ERROR,
                MSG_LOG_PROFILE_BAD_NAME,
                NULL,
                Section,
                BadInf
                );


            ret = FALSE;
            Err = ERROR_INVALID_DATA;
        }


    }else{
        ret = FALSE;
        Err = GetLastError();
        WriteLogEntry(
            ((PLOADED_INF) Inf)->LogContext,
            SETUP_LOG_ERROR,
            MSG_LOG_PROFILE_LINE_ERROR,
            NULL,
            Section,
            BadInf
            );


    }

clean0:
    if( WorkingDir ) {
        MyFree( WorkingDir );
    }

    if(pLoadedInf) {
        UnlockInf(pLoadedInf);
    }

    if(ret) {
        SetLastError( NO_ERROR );
    } else {
        SetLastError( Err );
    }

    return ret;
}


DWORD
pSetupInstallProfileItems(
    IN HINF   Inf,
    IN PCTSTR SectionName
    )

/*++

Routine Description:

    Locate the ProfileItems= lines in an install section
    and process each section listed therein. Each section specified here
    will point to a section that lists the needed directives for a single
    profile item.

Arguments:

    Inf - supplies inf handle for inf containing the section indicated
        by SectionName.

    SectionName - supplies name of install section.


Return Value:

    Win32 error code indicating outcome.

--*/

{
    DWORD d = NO_ERROR;
    INFCONTEXT LineContext;
    DWORD Field, FieldCount;
    PCTSTR SectionSpec;

    //
    // Find the ProfileItems line in the given install section.
    // If not present then we're done with this operation.
    //


    if(!SetupFindFirstLine(  Inf,
                             SectionName,
                             pszProfileItems,
                             &LineContext )) {
        DWORD rc = GetLastError();
        if((rc != NO_ERROR) && (rc != ERROR_SECTION_NOT_FOUND) && (rc != ERROR_LINE_NOT_FOUND)) {
            pSetupLogSectionError(Inf,NULL,NULL,NULL,SectionName,MSG_LOG_INSTALLSECT_ERROR,rc,NULL);
        }
        SetLastError(NO_ERROR); // for compatibility with older versions of SetupAPI
        return NO_ERROR;
    }

    do {
        //
        // Each value on the line in the given install section
        // is the name of another section.
        //
        FieldCount = SetupGetFieldCount(&LineContext);
        for(Field=1; d == NO_ERROR && (Field<=FieldCount); Field++) {

            if(SectionSpec = pSetupGetField(&LineContext,Field)) {

                if(SetupGetLineCount(Inf,SectionSpec) > 0) {
                    //
                    // The section exists and is not empty.
                    // So process it.
                    //
                    if(!pSetupProcessProfileSection(Inf,SectionSpec )) {
                        d = GetLastError();
                        pSetupLogSectionError(Inf,NULL,NULL,NULL,SectionSpec,MSG_LOG_SECT_ERROR,d,pszProfileItems);
                    }
                }

            }
        }
    } while(SetupFindNextMatchLine(  &LineContext,
                                     pszProfileItems,
                                     &LineContext));

    SetLastError( d );

    return d;

}
#endif

DWORD
pSetupInstallFiles(
    IN HINF              Inf,
    IN HINF              LayoutInf,         OPTIONAL
    IN PCTSTR            SectionName,
    IN PCTSTR            SourceRootPath,    OPTIONAL
    IN PSP_FILE_CALLBACK MsgHandler,        OPTIONAL
    IN PVOID             Context,           OPTIONAL
    IN UINT              CopyStyle,
    IN HWND              Owner,             OPTIONAL
    IN HSPFILEQ          UserFileQ,         OPTIONAL
    IN BOOL              IsMsgHandlerNativeCharWidth
    )

/*++

Routine Description:

    Look for file operation lines in an install section and process them.

Arguments:

    Inf - supplies inf handle for inf containing the section indicated
        by SectionName.

    LayoutInf - optionally, supplies a separate INF handle containing source
        media information about the files to be installed.  If this value is
        NULL or INVALID_HANDLE_VALUE, then it is assumed that this information
        is in the INF(s) whose handle was passed to us in the Inf parameter.

    SectionName - supplies name of install section.

    MsgHandler - supplies a callback to be used when the file queue is
        committed. Not used if UserFileQ is specified.

    Context - supplies context for callback function. Not used if UserFileQ
        is specified.

    Owner - supplies the window handle of a window to be the parent/owner
        of any dialogs that are created. Not used if UserFileQ is specified.

    UserFileQ - if specified, then this routine neither created nor commits the
        file queue. File operations are queued on this queue and it is up to the
        caller to flush the queue when it so desired. If this parameter is not
        specified then this routine creates a file queue and commits it
        before returning.

    IsMsgHandlerNativeCharWidth - indicates whether any message handler callback
        expects native char width args (or ansi ones, in the unicode build
        of this dll).

Return Value:

    Win32 error code indicating outcome.

--*/

{
    DWORD Field;
    unsigned i;
    PCTSTR Operations[3] = { TEXT("Copyfiles"),TEXT("Renfiles"),TEXT("Delfiles") };
    BOOL b;
    INFCONTEXT LineContext;
    DWORD FieldCount;
    PCTSTR SectionSpec;
    INFCONTEXT SectionLineContext;
    HSPFILEQ FileQueue;
    DWORD rc = NO_ERROR;
    BOOL FreeSourceRoot;
    DWORD InfSourceMediaType;

    //
    // see if install section exists for diagnostics (this will also check Inf)
    //
    if (!SetupFindFirstLine(Inf,SectionName,NULL,&LineContext)) {
        DWORD x = GetLastError();
        if((x != NO_ERROR) && (x != ERROR_SECTION_NOT_FOUND) && (x != ERROR_LINE_NOT_FOUND)) {
            pSetupLogSectionError(Inf,NULL,NULL,UserFileQ,SectionName,MSG_LOG_INSTALLSECT_ERROR,x,NULL);
            return x;
        }
    }

    if(!LayoutInf || (LayoutInf == INVALID_HANDLE_VALUE)) {
        LayoutInf = Inf;
    }

    //
    // Create a file queue.
    //
    if(UserFileQ) {
        FileQueue = UserFileQ;
    } else {
        FileQueue = SetupOpenFileQueue();
        if(FileQueue == INVALID_HANDLE_VALUE) {
            return(GetLastError());
        }
    }
    ShareLogContext(&((PLOADED_INF)LayoutInf)->LogContext,&((PSP_FILE_QUEUE)FileQueue)->LogContext);

    //
    // The following code is broken because it implies one default source root path per INF
    // file.  While this is correct for an OEM install, it's broken for os based installs
    //
    FreeSourceRoot = FALSE;
    if(!SourceRootPath) {
        if(SourceRootPath = pSetupGetDefaultSourcePath(Inf, 0, &InfSourceMediaType)) {
            //
            // For now, if the INF is from the internet, just use
            // the default OEM source path (A:\) instead.
            //
            if(InfSourceMediaType == SPOST_URL) {
                MyFree(SourceRootPath);
            //
            // Fall back to default OEM source path.
            //
            SourceRootPath = pszOemInfDefaultPath;
            } else {
                FreeSourceRoot = TRUE;
            }
        } else {
            //
            // lock this!
            //
            if (LockInf((PLOADED_INF)Inf)) {

                if (pSetupInfIsFromOemLocation(((PLOADED_INF)Inf)->VersionBlock.Filename, TRUE)) {
                    SourceRootPath = DuplicateString(((PLOADED_INF)Inf)->VersionBlock.Filename);
                    if (SourceRootPath) {
                        PTSTR p;
                        p = _tcsrchr( SourceRootPath, TEXT('\\') );
                        if (p) *p = TEXT('\0');
                        FreeSourceRoot = TRUE;
                    }
                }

                UnlockInf((PLOADED_INF)Inf);
            }

        }
    }

    b = TRUE;
    for(i=0; b && (i<3); i++) {

        //
        // Find the relevent line in the given install section.
        // If not present then we're done with this operation.
        //
        if(!SetupFindFirstLine(Inf,SectionName,Operations[i],&LineContext)) {
            continue;
        }

        do {
            //
            // Each value on the line in the given install section
            // is the name of another section.
            //
            FieldCount = SetupGetFieldCount(&LineContext);
            for(Field=1; b && (Field<=FieldCount); Field++) {

                if(SectionSpec = pSetupGetField(&LineContext,Field)) {

                    //
                    // Handle single-file copy specially.
                    //
                    if((i == 0) && (*SectionSpec == TEXT('@'))) {

                        b = SetupQueueDefaultCopy(
                                FileQueue,
                                LayoutInf,
                                SourceRootPath,
                                SectionSpec + 1,
                                SectionSpec + 1,
                                CopyStyle
                                );
                        if (!b) {
                            rc = GetLastError();
                            pSetupLogSectionError(Inf,NULL,NULL,FileQueue,SectionSpec+1,MSG_LOG_COPYSECT_ERROR,rc,Operations[i]);
                        }

                    } else if(SetupGetLineCount(Inf,SectionSpec) > 0) {
                        //
                        // The section exists and is not empty.
                        // Add it to the copy/delete/rename queue.
                        //
                        switch(i) {
                        case 0:
                            b = SetupQueueCopySection(
                                    FileQueue,
                                    SourceRootPath,
                                    LayoutInf,
                                    Inf,
                                    SectionSpec,
                                    CopyStyle
                                    );
                            break;

                        case 1:
                            b = SetupQueueRenameSection(FileQueue,Inf,NULL,SectionSpec);
                            break;

                        case 2:
                            b = SetupQueueDeleteSection(FileQueue,Inf,NULL,SectionSpec);
                            break;
                        }
                        if (!b) {
                            rc = GetLastError();
                            pSetupLogSectionError(Inf,NULL,NULL,FileQueue,SectionSpec,MSG_LOG_SECT_ERROR,rc,Operations[i]);
                        }
                    }
                }
            }
        } while(SetupFindNextMatchLine(&LineContext,Operations[i],&LineContext));
    }

    if(b && (FileQueue != UserFileQ)) {
        //
        // Perform the file operations.
        //
        b = _SetupCommitFileQueue(
                Owner,
                FileQueue,
                MsgHandler,
                Context,
                IsMsgHandlerNativeCharWidth
                );
        rc = b ? NO_ERROR : GetLastError();
    }

    if(FileQueue != UserFileQ) {
        SetupCloseFileQueue(FileQueue);
    }

    if(FreeSourceRoot) {
        MyFree(SourceRootPath);
    }

    return(rc);
}


BOOL
_SetupInstallFromInfSection(
    IN HWND             Owner,              OPTIONAL
    IN HINF             InfHandle,
    IN PCTSTR           SectionName,
    IN UINT             Flags,
    IN HKEY             RelativeKeyRoot,    OPTIONAL
    IN PCTSTR           SourceRootPath,     OPTIONAL
    IN UINT             CopyFlags,
    IN PVOID            MsgHandler,
    IN PVOID            Context,            OPTIONAL
    IN HDEVINFO         DeviceInfoSet,      OPTIONAL
    IN PSP_DEVINFO_DATA DeviceInfoData,     OPTIONAL
    IN BOOL             IsMsgHandlerNativeCharWidth,
    IN PREGMOD_CONTEXT  RegContext          OPTIONAL
    )
{
    PDEVICE_INFO_SET pDeviceInfoSet = NULL;
    PDEVINFO_ELEM DevInfoElem;
    DWORD d = NO_ERROR;
    BOOL CloseRelativeKeyRoot;
    REGMOD_CONTEXT DefRegContext;


    //
    // Validate the flags passed in.
    //
    if(Flags & ~(SPINST_ALL | SPINST_SINGLESECTION |
                 SPINST_LOGCONFIG_IS_FORCED | SPINST_LOGCONFIGS_ARE_OVERRIDES |
                 SPINST_REGISTERCALLBACKAWARE)) {
        d = ERROR_INVALID_FLAGS;
        goto clean1;
    }


    //
    // If the caller wants us to run a specific section, then they'd better
    // have told us what kind of section it is (i.e., one and only one of
    // the install action types must be specified).
    //
    // Presently, only LogConfig sections are allowed, since the other
    // flags flags encompass multiple actions (e.g., AddReg _and_ DelReg).
    //
    if((Flags & SPINST_SINGLESECTION) && ((Flags & SPINST_ALL) != SPINST_LOGCONFIG)) {
        d = ERROR_INVALID_FLAGS;
        goto clean1;
    }


    //
    // You can (optionally) specify SPINST_LOGCONFIG_IS_FORCED or SPINST_LOGCONFIGS_ARE_OVERRIDES,
    // but not both.
    //
    if((Flags & (SPINST_LOGCONFIG_IS_FORCED | SPINST_LOGCONFIGS_ARE_OVERRIDES)) ==
       (SPINST_LOGCONFIG_IS_FORCED | SPINST_LOGCONFIGS_ARE_OVERRIDES)) {

        d = ERROR_INVALID_FLAGS;
        goto clean1;
    }


    //
    // We only want to acquire the HDEVINFO lock if we're supposed to do some install
    // actions against a device instance.
    //
    if((Flags & (SPINST_REGISTRY | SPINST_BITREG | SPINST_INI2REG | SPINST_LOGCONFIG)) &&
       DeviceInfoSet && (DeviceInfoSet != INVALID_HANDLE_VALUE) && DeviceInfoData) {

        if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
            d = ERROR_INVALID_HANDLE;
            goto clean1;
        }

    } else {
        //This is ok in the remote case, since to call pSetupInstallLogConfig
        //We won't really get here (we'll take the if case)
        pDeviceInfoSet = NULL;
    }


    d = NO_ERROR;
    DevInfoElem = NULL;
    CloseRelativeKeyRoot = FALSE;

    try {
        //
        // Get a pointer to the element for the specified device
        // instance.
        //

        if(pDeviceInfoSet) {

            if(!(DevInfoElem = FindAssociatedDevInfoElem(pDeviceInfoSet,
                                                         DeviceInfoData,
                                                         NULL))) {
                d = ERROR_INVALID_PARAMETER;
                goto RegModsDone;
            }
        }

        if((Flags & (SPINST_REGISTRY | SPINST_BITREG | SPINST_INI2REG)) && DevInfoElem) {
            //
            // If the caller supplied a device information set and element, then this is
            // a device installation, and the registry modifications should be made to the
            // device instance's hardware registry key.
            //
            if((RelativeKeyRoot = SetupDiCreateDevRegKey(DeviceInfoSet,
                                                         DeviceInfoData,
                                                         DICS_FLAG_GLOBAL,
                                                         0,
                                                         DIREG_DEV,
                                                         NULL,
                                                         NULL)) == INVALID_HANDLE_VALUE) {
                d = GetLastError();
                goto RegModsDone;
            }

            CloseRelativeKeyRoot = TRUE;
        }

        if((Flags & SPINST_LOGCONFIG) && DevInfoElem) {

            d = pSetupInstallLogConfig(InfHandle,
                                       SectionName,
                                       DevInfoElem->DevInst,
                                       Flags,
                                       pDeviceInfoSet->hMachine);
            if(d != NO_ERROR) {
                goto RegModsDone;
            }
        }

        if(Flags & SPINST_INIFILES) {
            d = pSetupInstallUpdateIniFiles(InfHandle,SectionName);
            if(d != NO_ERROR) {
                goto RegModsDone;
            }
        }

        if(Flags & (SPINST_REGISTRY | SPINST_BITREG)) {

            if(!RegContext) {

                ZeroMemory(&DefRegContext, sizeof(DefRegContext));

                if(DevInfoElem) {
                    DefRegContext.Flags = INF_PFLAG_DEVPROP;
                    DefRegContext.DevInst = DevInfoElem->DevInst;
                }
                RegContext = &DefRegContext;
            }

            //
            // We check for the INF_PFLAG_HKR flag in case the caller supplied
            // us with a context that included a UserRootKey they wanted us to
            // use (i.e., instead of the RelativeKeyRoot)...
            //
            if(!(RegContext->Flags & INF_PFLAG_HKR)) {
                RegContext->UserRootKey = RelativeKeyRoot;
            }

            if(Flags & SPINST_REGISTRY) {
                d = pSetupInstallRegistry(InfHandle,
                                          SectionName,
                                          RegContext
                                         );
            }

            if((d == NO_ERROR) && (Flags & SPINST_BITREG)) {
                d = pSetupInstallBitReg(InfHandle,
                                        SectionName,
                                        RegContext
                                       );
            }

            if(d != NO_ERROR) {
                goto RegModsDone;
            }
        }

        if(Flags & SPINST_INI2REG) {
            d = pSetupInstallIni2Reg(InfHandle,SectionName,RelativeKeyRoot);
            if (d != NO_ERROR) {
                goto RegModsDone;
            }
        }

        if(Flags & SPINST_REGSVR) {
            d = pSetupInstallRegisterUnregisterDlls(
                                        InfHandle,
                                        SectionName,
                                        TRUE,
                                        Owner,
                                        MsgHandler,
                                        Context,
                                        IsMsgHandlerNativeCharWidth,
                                        (Flags & SPINST_REGISTERCALLBACKAWARE) != 0 );
            if (d != NO_ERROR) {
                goto RegModsDone;
            }
        }

        if(Flags & SPINST_UNREGSVR) {
            d = pSetupInstallRegisterUnregisterDlls(
                                        InfHandle,
                                        SectionName,
                                        FALSE,
                                        Owner,
                                        MsgHandler,
                                        Context,
                                        IsMsgHandlerNativeCharWidth,
                                        (Flags & SPINST_REGISTERCALLBACKAWARE) != 0 );
            if (d != NO_ERROR) {
                goto RegModsDone;
            }
        }

#ifndef ANSI_SETUPAPI

        if(Flags & SPINST_PROFILEITEMS) {
            d = pSetupInstallProfileItems(InfHandle,SectionName);
            if (d != NO_ERROR) {
                goto RegModsDone;
            }
        }
#endif

        if(Flags & SPINST_COPYINF) {
            d = pSetupCopyRelatedInfs(InfHandle,
                                      NULL,
                                      SectionName,
                                      SPOST_PATH,
                                      NULL);
            if (d != NO_ERROR) {
                goto RegModsDone;
            }
        }

RegModsDone:

        ;       // nothing to do.

    } except(EXCEPTION_EXECUTE_HANDLER) {
        d = ERROR_INVALID_PARAMETER;
        //
        // Access the following variable, so that the compiler will respect statement
        // ordering w.r.t. its assignment.
        //
        CloseRelativeKeyRoot = CloseRelativeKeyRoot;
    }


    if(CloseRelativeKeyRoot) {
        RegCloseKey(RelativeKeyRoot);
    }

    if(d == NO_ERROR) {

        if(Flags & SPINST_FILES) {

            d = pSetupInstallFiles(
                    InfHandle,
                    NULL,
                    SectionName,
                    SourceRootPath,
                    MsgHandler,
                    Context,
                    CopyFlags,
                    Owner,
                    NULL,
                    IsMsgHandlerNativeCharWidth
                    );
        }
    }

clean1:

    pSetupLogSectionError(InfHandle,DeviceInfoSet,DeviceInfoData,NULL,SectionName,MSG_LOG_INSTALLSECT_ERROR,d,NULL);

    if(pDeviceInfoSet) {
        UnlockDeviceInfoSet(pDeviceInfoSet);
    }

    SetLastError(d);
    return(d==NO_ERROR);
}

DWORD
pSetupLogSection(
    IN DWORD            SetupLogLevel,
    IN DWORD            DriverLogLevel,
    IN HINF             InfHandle,          OPTIONAL
    IN HDEVINFO         DeviceInfoSet,      OPTIONAL
    IN PSP_DEVINFO_DATA DeviceInfoData,     OPTIONAL
    IN PSP_FILE_QUEUE   Queue,              OPTIONAL
    IN PCTSTR           SectionName,
    IN DWORD            MsgID,
    IN DWORD            Err,
    IN PCTSTR           KeyName             OPTIONAL
)
/*++

Routine Description:

    Log error with section context
    error will be logged at SETUP_LOG_ERROR or DRIVER_LOG_ERROR depending if DeviceInfoSet/Data given
    error will contain inf name & section name used (%2 & %1 respectively)

Arguments:

    SetupLogLevel - log level apropriate for regular setup related log

    DriverLogLevel - log level apropriate for driver related log

    InfHandle - supplies inf handle for inf containing the section indicated
        by SectionName.

    DeviceInfoSet, DeviceInfoData - supplies driver install context

    SectionName - supplies name of install section.

    Queue - supplies file queue

    MsgID - supplies ID of message string to display

    Err - supplies error

    KeyName - passed as 3rd parameter

Return Value:

    Err.

--*/

{
    DWORD d = NO_ERROR;
    BOOL inf_locked = FALSE;
    DWORD level = SetupLogLevel;
    PDEVICE_INFO_SET pDeviceInfoSet = NULL;
    PDEVINFO_ELEM DevInfoElem = NULL;
    PSETUP_LOG_CONTEXT LogContext = NULL;
    PCTSTR szInfName = NULL;

    if (Err == NO_ERROR) {
        return Err;
    }

    //
    // determine LogContext/Level
    //
    try {

        //
        // first attempt to get the context from DeviceInfoSet/DeviceInfoData
        //
        if (DeviceInfoSet != NULL && DeviceInfoSet != INVALID_HANDLE_VALUE) {
            if((pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))!=NULL) {
                level = DriverLogLevel;
                LogContext = pDeviceInfoSet->InstallParamBlock.LogContext;
                if (DeviceInfoData) {
                    if((DevInfoElem = FindAssociatedDevInfoElem(pDeviceInfoSet,
                                                                 DeviceInfoData,
                                                                 NULL))!=NULL) {
                        LogContext = DevInfoElem->InstallParamBlock.LogContext;
                    }
                }
            }
        }
        //
        // if that fails, see if we can get it from a file queue
        //
        if(LogContext == NULL && Queue != NULL && Queue != INVALID_HANDLE_VALUE && Queue->Signature == SP_FILE_QUEUE_SIG) {
            LogContext = Queue->LogContext;
        }

        //
        // if no InfHandle was provided, we're done
        //
        if(InfHandle == NULL || InfHandle == INVALID_HANDLE_VALUE || !LockInf((PLOADED_INF)InfHandle)) {
            leave;
        }
        inf_locked = TRUE;
        //
        // if we still don't have logging context, use the inf's
        //
        if (LogContext == NULL) {
            LogContext = ((PLOADED_INF)InfHandle)->LogContext;
        }
        //
        // ideally we want the inf file name
        //
        szInfName = ((PLOADED_INF)InfHandle)->VersionBlock.Filename;

    } except(EXCEPTION_EXECUTE_HANDLER) {
    }

    if (LogContext) {
        //
        // indicate install failed, display error
        //
        WriteLogEntry(
            LogContext,
            level | SETUP_LOG_BUFFER,
            MsgID,
            NULL,
            SectionName?SectionName:TEXT("-"),
            szInfName?szInfName:TEXT("-"),
            KeyName
            );
        WriteLogError(
            LogContext,
            level,
            Err
            );
    }
    if (inf_locked) {
        UnlockInf((PLOADED_INF)InfHandle);
    }

    if(pDeviceInfoSet) {
        UnlockDeviceInfoSet(pDeviceInfoSet);
    }

    SetLastError(Err);
    return Err;
}

DWORD
pSetupLogSectionError(
    IN HINF             InfHandle,          OPTIONAL
    IN HDEVINFO         DeviceInfoSet,      OPTIONAL
    IN PSP_DEVINFO_DATA DeviceInfoData,     OPTIONAL
    IN PSP_FILE_QUEUE   Queue,              OPTIONAL
    IN PCTSTR           SectionName,
    IN DWORD            MsgID,
    IN DWORD            Err,
    IN PCTSTR           KeyName             OPTIONAL
)
/*++

Routine Description:

    See pSetupLogSection
    Log at ERROR level

Arguments:

    See pSetupLogSection

Return Value:

    Err.

--*/
{
    return pSetupLogSection(SETUP_LOG_ERROR,DRIVER_LOG_ERROR,
                            InfHandle,DeviceInfoSet,DeviceInfoData,
                            Queue,SectionName,MsgID,Err,KeyName);
}


DWORD
pSetupLogSectionWarning(
    IN HINF             InfHandle,          OPTIONAL
    IN HDEVINFO         DeviceInfoSet,      OPTIONAL
    IN PSP_DEVINFO_DATA DeviceInfoData,     OPTIONAL
    IN PSP_FILE_QUEUE   Queue,              OPTIONAL
    IN PCTSTR           SectionName,
    IN DWORD            MsgID,
    IN DWORD            Err,
    IN PCTSTR           KeyName             OPTIONAL
)
/*++

Routine Description:

    See pSetupLogSection
    Log at ERROR level

Arguments:

    See pSetupLogSection

Return Value:

    Err.

--*/
{
    return pSetupLogSection(SETUP_LOG_WARNING,DRIVER_LOG_WARNING,
                            InfHandle,DeviceInfoSet,DeviceInfoData,
                            Queue,SectionName,MsgID,Err,KeyName);
}

#ifdef UNICODE
//
// ANSI version
//
BOOL
SetupInstallFromInfSectionA(
    IN HWND                Owner,             OPTIONAL
    IN HINF                InfHandle,
    IN PCSTR               SectionName,
    IN UINT                Flags,
    IN HKEY                RelativeKeyRoot,   OPTIONAL
    IN PCSTR               SourceRootPath,    OPTIONAL
    IN UINT                CopyFlags,
    IN PSP_FILE_CALLBACK_A MsgHandler,
    IN PVOID               Context,           OPTIONAL
    IN HDEVINFO            DeviceInfoSet,     OPTIONAL
    IN PSP_DEVINFO_DATA    DeviceInfoData     OPTIONAL
    )
{
    PCWSTR sectionName;
    PCWSTR sourceRootPath;
    BOOL b;
    DWORD d;

    sectionName = NULL;
    sourceRootPath = NULL;
    d = NO_ERROR;

    if(SectionName) {
        d = pSetupCaptureAndConvertAnsiArg(SectionName,&sectionName);
    }
    if((d == NO_ERROR) && SourceRootPath) {
        d = pSetupCaptureAndConvertAnsiArg(SourceRootPath,&sourceRootPath);
    }

    if(d == NO_ERROR) {

        b = _SetupInstallFromInfSection(
                Owner,
                InfHandle,
                sectionName,
                Flags,
                RelativeKeyRoot,
                sourceRootPath,
                CopyFlags,
                MsgHandler,
                Context,
                DeviceInfoSet,
                DeviceInfoData,
                FALSE,
                NULL
                );

        d = GetLastError();
    } else {
        b = FALSE;
    }

    if(sectionName) {
        MyFree(sectionName);
    }
    if(sourceRootPath) {
        MyFree(sourceRootPath);
    }

    SetLastError(d);
    return(b);
}
#else
//
// Unicode stub
//
BOOL
SetupInstallFromInfSectionW(
    IN HWND                Owner,             OPTIONAL
    IN HINF                InfHandle,
    IN PCWSTR              SectionName,
    IN UINT                Flags,
    IN HKEY                RelativeKeyRoot,   OPTIONAL
    IN PCWSTR              SourceRootPath,    OPTIONAL
    IN UINT                CopyFlags,
    IN PSP_FILE_CALLBACK_W MsgHandler,
    IN PVOID               Context,           OPTIONAL
    IN HDEVINFO            DeviceInfoSet,     OPTIONAL
    IN PSP_DEVINFO_DATA    DeviceInfoData     OPTIONAL
    )
{
    UNREFERENCED_PARAMETER(Owner);
    UNREFERENCED_PARAMETER(InfHandle);
    UNREFERENCED_PARAMETER(SectionName);
    UNREFERENCED_PARAMETER(Flags);
    UNREFERENCED_PARAMETER(RelativeKeyRoot);
    UNREFERENCED_PARAMETER(SourceRootPath);
    UNREFERENCED_PARAMETER(CopyFlags);
    UNREFERENCED_PARAMETER(MsgHandler);
    UNREFERENCED_PARAMETER(Context);
    UNREFERENCED_PARAMETER(DeviceInfoSet);
    UNREFERENCED_PARAMETER(DeviceInfoData);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif

BOOL
SetupInstallFromInfSection(
    IN HWND              Owner,             OPTIONAL
    IN HINF              InfHandle,
    IN PCTSTR            SectionName,
    IN UINT              Flags,
    IN HKEY              RelativeKeyRoot,   OPTIONAL
    IN PCTSTR            SourceRootPath,    OPTIONAL
    IN UINT              CopyFlags,
    IN PSP_FILE_CALLBACK MsgHandler,
    IN PVOID             Context,           OPTIONAL
    IN HDEVINFO          DeviceInfoSet,     OPTIONAL
    IN PSP_DEVINFO_DATA  DeviceInfoData     OPTIONAL
    )
{
    BOOL b;

    b = _SetupInstallFromInfSection(
            Owner,
            InfHandle,
            SectionName,
            Flags,
            RelativeKeyRoot,
            SourceRootPath,
            CopyFlags,
            MsgHandler,
            Context,
            DeviceInfoSet,
            DeviceInfoData,
            TRUE,
            NULL
            );

    return(b);
}


#ifdef UNICODE
//
// ANSI version
//
BOOL
SetupInstallFilesFromInfSectionA(
    IN HINF              InfHandle,
    IN HINF              LayoutInfHandle,   OPTIONAL
    IN HSPFILEQ          FileQueue,
    IN PCSTR             SectionName,
    IN PCSTR             SourceRootPath,    OPTIONAL
    IN UINT              CopyFlags
    )
{
    PCWSTR sectionName;
    PCWSTR sourceRootPath;
    BOOL b;
    DWORD d;


    d = pSetupCaptureAndConvertAnsiArg(SectionName,&sectionName);
    if((d == NO_ERROR) && SourceRootPath) {
        d = pSetupCaptureAndConvertAnsiArg(SourceRootPath,&sourceRootPath);
    } else {
        sourceRootPath = NULL;
    }

    if(d == NO_ERROR) {

        b = SetupInstallFilesFromInfSectionW(
                InfHandle,
                LayoutInfHandle,
                FileQueue,
                sectionName,
                sourceRootPath,
                CopyFlags
                );

        d = GetLastError();

    } else {
        b = FALSE;
    }

    if(sectionName) {
        MyFree(sectionName);
    }
    if(sourceRootPath) {
        MyFree(sourceRootPath);
    }

    SetLastError(d);
    return(b);
}
#else
//
// Unicode stub
//
BOOL
SetupInstallFilesFromInfSectionW(
    IN HINF              InfHandle,
    IN HINF              LayoutInfHandle,   OPTIONAL
    IN HSPFILEQ          FileQueue,
    IN PCWSTR            SectionName,
    IN PCWSTR            SourceRootPath,    OPTIONAL
    IN UINT              CopyFlags
    )
{
    UNREFERENCED_PARAMETER(InfHandle);
    UNREFERENCED_PARAMETER(LayoutInfHandle);
    UNREFERENCED_PARAMETER(FileQueue);
    UNREFERENCED_PARAMETER(SectionName);
    UNREFERENCED_PARAMETER(SourceRootPath);
    UNREFERENCED_PARAMETER(CopyFlags);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif

BOOL
SetupInstallFilesFromInfSection(
    IN HINF     InfHandle,
    IN HINF     LayoutInfHandle,    OPTIONAL
    IN HSPFILEQ FileQueue,
    IN PCTSTR   SectionName,
    IN PCTSTR   SourceRootPath,     OPTIONAL
    IN UINT     CopyFlags
    )
{
    DWORD d;

    d = pSetupInstallFiles(
            InfHandle,
            LayoutInfHandle,
            SectionName,
            SourceRootPath,
            NULL,
            NULL,
            CopyFlags,
            NULL,
            FileQueue,
            TRUE        // not used by pSetupInstallFiles with this combo of args
            );

    SetLastError(d);
    return(d == NO_ERROR);
}


HKEY
pSetupInfRegSpecToKeyHandle(
    IN PCTSTR InfRegSpec,
    IN HKEY   UserRootKey,
    OUT PBOOL NeedToCloseKey
    )
{
    BOOL b;

    // make sure the whole handle is NULL as LookUpStringTable only
    // returns 32 bits

    UINT_PTR v;
    HKEY h = NULL;
    DWORD d;

    *NeedToCloseKey = FALSE;

    if (LookUpStringInTable(InfRegSpecTohKey, InfRegSpec, &v)) {
        if (v) {
            h = (HKEY)v;
        } else {
            h = UserRootKey;
        }
    } else {
        h = NULL;
    }

    return h;
}


//////////////////////////////////////////////////////////////////////////////
//
// Ini file support stuff.
//
// In Win95, the UpdateIni stuff is supported by a set of TpXXX routines.
// Those routines directly manipulate the ini file, which is bad news for us
// because inis can be mapped into the registry.
//
// Thus we want to use the profile APIs. However the profile APIs make it hard
// to manipulate lines without keys, so we have to manipulate whole sections
// at a time.
//
//      [Section]
//      a
//
// There is no way to get at the line "a" with the profile APIs. But the
// profile section APIs do let us get at it.
//
//////////////////////////////////////////////////////////////////////////////

PINIFILESECTION
pSetupLoadIniFileSection(
    IN     PCTSTR           FileName,
    IN     PCTSTR           SectionName,
    IN OUT PINISECTIONCACHE SectionList
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    DWORD d;
    PTSTR SectionData;
    PVOID p;
    DWORD BufferSize;
    PINIFILESECTION Desc;
    #define BUF_GROW 4096

    //
    // See if this section is already loaded.
    //
    for(Desc=SectionList->Sections; Desc; Desc=Desc->Next) {
        if(!lstrcmpi(Desc->IniFileName,FileName) && !lstrcmpi(Desc->SectionName,SectionName)) {
            return(Desc);
        }
    }

    BufferSize = 0;
    SectionData = NULL;

    //
    // Read the entire section. We don't know how big it is
    // so keep growing the buffer until we succeed.
    //
    do {
        BufferSize += BUF_GROW;
        if(SectionData) {
            p = MyRealloc(SectionData,BufferSize*sizeof(TCHAR));
        } else {
            p = MyMalloc(BufferSize*sizeof(TCHAR));
        }
        if(p) {
            SectionData = p;
        } else {
            if(SectionData) {
                MyFree(SectionData);
            }
            return(NULL);
        }

        //
        // Attempt to get the entire section.
        //
        d = GetPrivateProfileSection(SectionName,SectionData,BufferSize,FileName);

    } while(d == (BufferSize-2));

    if(Desc = MyMalloc(sizeof(INIFILESECTION))) {
        if(Desc->IniFileName = DuplicateString(FileName)) {
            if(Desc->SectionName = DuplicateString(SectionName)) {
                Desc->SectionData = SectionData;
                Desc->BufferSize = BufferSize;
                Desc->BufferUsed = d + 1;

                Desc->Next = SectionList->Sections;
                SectionList->Sections = Desc;
            } else {
                MyFree(SectionData);
                MyFree(Desc->IniFileName);
                MyFree(Desc);
                Desc = NULL;
            }
        } else {
            MyFree(SectionData);
            MyFree(Desc);
            Desc = NULL;
        }
    } else {
        MyFree(SectionData);
    }

    return(Desc);
}


PTSTR
pSetupFindLineInSection(
    IN PINIFILESECTION Section,
    IN PCTSTR          KeyName,      OPTIONAL
    IN PCTSTR          RightHandSide OPTIONAL
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    PTSTR p,q,r;
    BOOL b1,b2;

    if(!KeyName && !RightHandSide) {
        return(NULL);
    }

    for(p=Section->SectionData; *p; p+=lstrlen(p)+1) {

        //
        // Locate key separator if present.
        //
        q = _tcschr(p,TEXT('='));

        //
        // If we need to match by key, attempt that here.
        // If the line has no key then it can't match.
        //
        if(KeyName) {
            if(q) {
                *q = 0;
                b1 = (lstrcmpi(KeyName,p) == 0);
                *q = TEXT('=');
            } else {
                b1 = FALSE;
            }
        } else {
            b1 = TRUE;
        }

        //
        // If we need to match by right hand side, attempt
        // that here.
        //
        if(RightHandSide) {
            //
            // If we have a key, then the right hand side is everything
            // after. If we have no key, then the right hand side is
            // the entire line.
            //
            if(q) {
                r = q + 1;
            } else {
                r = p;
            }
            b2 = (lstrcmpi(r,RightHandSide) == 0);
        } else {
            b2 = TRUE;
        }

        if(b1 && b2) {
            //
            // Return pointer to beginning of line.
            //
            return(p);
        }
    }

    return(NULL);
}


BOOL
pSetupReplaceOrAddLineInSection(
    IN PINIFILESECTION Section,
    IN PCTSTR          KeyName,         OPTIONAL
    IN PCTSTR          RightHandSide,   OPTIONAL
    IN BOOL            MatchRHS
    )
{
    PTSTR LineInBuffer,NextLine;
    int CurrentCharsInBuffer;
    int ExistingLineLength,NewLineLength,BufferUsedDelta;
    PVOID p;

    //
    // Locate the line.
    //
    LineInBuffer = pSetupFindLineInSection(
                        Section,
                        KeyName,
                        MatchRHS ? RightHandSide : NULL
                        );

    if(LineInBuffer) {

        //
        // Line is in the section. Replace.
        //

        CurrentCharsInBuffer = Section->BufferUsed;

        ExistingLineLength = lstrlen(LineInBuffer)+1;

        NewLineLength = (KeyName ? (lstrlen(KeyName) + 1) : 0)         // key=
                      + (RightHandSide ? lstrlen(RightHandSide) : 0)   // RHS
                      + 1;                                             // terminating nul

        //
        // Empty lines not allowed but not error either.
        //
        if(NewLineLength == 1) {
            return(TRUE);
        }

        //
        // Figure out whether we need to grow the buffer.
        //
        BufferUsedDelta = NewLineLength - ExistingLineLength;
        if((BufferUsedDelta > 0) && ((Section->BufferSize - Section->BufferUsed) < BufferUsedDelta)) {

            p = MyRealloc(
                    Section->SectionData,
                    (Section->BufferUsed + BufferUsedDelta)*sizeof(TCHAR)
                    );

            if(p) {
                (PUCHAR)LineInBuffer += (PUCHAR)p - (PUCHAR)Section->SectionData;

                Section->SectionData = p;
                Section->BufferSize = Section->BufferUsed + BufferUsedDelta;
            } else {
                return(FALSE);
            }
        }

        NextLine = LineInBuffer + lstrlen(LineInBuffer) + 1;
        Section->BufferUsed += BufferUsedDelta;

        MoveMemory(

            //
            // Leave exactly enough space for the new line. Since the new line
            // will start at the same place the existing line is at now, the
            // target for the move is simply the first char past what will be
            // copied in later as the new line.
            //
            LineInBuffer + NewLineLength,

            //
            // The rest of the buffer past the line as it exists now must be
            // preserved. Thus the source for the move is the first char of
            // the next line as it is now.
            //
            NextLine,

            //
            // Subtract out the chars in the line as it exists now, since we're
            // going to overwrite it and are making room for the line in its
            // new form. Also subtract out the chars in the buffer that are
            // before the start of the line we're operating on.
            //
            ((CurrentCharsInBuffer - ExistingLineLength) - (LineInBuffer - Section->SectionData))*sizeof(TCHAR)

            );

        if(KeyName) {
            lstrcpy(LineInBuffer,KeyName);
            lstrcat(LineInBuffer,TEXT("="));
        }
        if(RightHandSide) {
            if(KeyName) {
                lstrcat(LineInBuffer,RightHandSide);
            } else {
                lstrcpy(LineInBuffer,RightHandSide);
            }
        }

        return(TRUE);

    } else {
        //
        // Line is not already in the section. Add it to the end.
        //
        return(pSetupAppendLineToSection(Section,KeyName,RightHandSide));
    }
}


BOOL
pSetupAppendLineToSection(
    IN PINIFILESECTION Section,
    IN PCTSTR          KeyName,         OPTIONAL
    IN PCTSTR          RightHandSide    OPTIONAL
    )
{
    int LineLength;
    PVOID p;
    int EndOffset;

    LineLength = (KeyName ? (lstrlen(KeyName) + 1) : 0)         // Key=
               + (RightHandSide ? lstrlen(RightHandSide) : 0)   // RHS
               + 1;                                             // terminating nul

    //
    // Empty lines not allowed but not error either.
    //
    if(LineLength == 1) {
        return(TRUE);
    }

    if((Section->BufferSize - Section->BufferUsed) < LineLength) {

        p = MyRealloc(
                Section->SectionData,
                (Section->BufferUsed + LineLength) * sizeof(WCHAR)
                );

        if(p) {
            Section->SectionData = p;
            Section->BufferSize = Section->BufferUsed + LineLength;
        } else {
            return(FALSE);
        }
    }

    //
    // Put new text at end of section, remembering that the section
    // is termianted with an extra nul character.
    //
    if(KeyName) {
        lstrcpy(Section->SectionData + Section->BufferUsed - 1,KeyName);
        lstrcat(Section->SectionData + Section->BufferUsed - 1,TEXT("="));
    }
    if(RightHandSide) {
        if(KeyName) {
            lstrcat(Section->SectionData + Section->BufferUsed - 1,RightHandSide);
        } else {
            lstrcpy(Section->SectionData + Section->BufferUsed - 1,RightHandSide);
        }
    }

    Section->BufferUsed += LineLength;
    Section->SectionData[Section->BufferUsed-1] = 0;

    return(TRUE);
}


BOOL
pSetupDeleteLineFromSection(
    IN PINIFILESECTION Section,
    IN PCTSTR          KeyName,         OPTIONAL
    IN PCTSTR          RightHandSide    OPTIONAL
    )
{
    int LineLength;
    PTSTR Line;

    if(!KeyName && !RightHandSide) {
        return(TRUE);
    }

    //
    // Locate the line.
    //
    if(Line = pSetupFindLineInSection(Section,KeyName,RightHandSide)) {

        LineLength = lstrlen(Line) + 1;

        MoveMemory(
            Line,
            Line + LineLength,
            ((Section->SectionData + Section->BufferUsed) - (Line + LineLength))*sizeof(TCHAR)
            );

        Section->BufferUsed -= LineLength;
    }

    return(TRUE);
}


DWORD
pSetupUnloadIniFileSections(
    IN PINISECTIONCACHE SectionList,
    IN BOOL             WriteToFile
    )
{
    DWORD d;
    BOOL b;
    PINIFILESECTION Section,Temp;

    d = NO_ERROR;
    for(Section=SectionList->Sections; Section; Section=Temp) {

        Temp = Section->Next;

        if(WriteToFile) {

            //
            // Delete the existing section first and then recreate it.
            //
            b = WritePrivateProfileString(
                    Section->SectionName,
                    NULL,
                    NULL,
                    Section->IniFileName
                    );

            if(b) {
                b = WritePrivateProfileSection(
                        Section->SectionName,
                        Section->SectionData,
                        Section->IniFileName
                        );
            }

            if(!b && (d == NO_ERROR)) {
                d = GetLastError();
                //
                // Allow invalid param because sometime we have problems
                // when ini files are mapped into the registry.
                //
                if(d == ERROR_INVALID_PARAMETER) {
                    d = NO_ERROR;
                }
            }
        }

        MyFree(Section->SectionData);
        MyFree(Section->SectionName);
        MyFree(Section->IniFileName);
        MyFree(Section);
    }

    return(d);
}


DWORD
pSetupValidateDevRegProp(
    IN  ULONG   CmPropertyCode,
    IN  DWORD   ValueType,
    IN  PCVOID  Data,
    IN  DWORD   DataSize,
    OUT PVOID  *ConvertedBuffer,
    OUT PDWORD  ConvertedBufferSize
    )
/*++

Routine Description:

    This routine validates the data buffer passed in with respect to the
    specified device registry property code.  If the code is not of the correct
    form, but can be converted (e.g., REG_EXPAND_SZ -> REG_SZ), then the
    conversion is done and placed into a new buffer, that is returned to the
    caller.

Arguments:

    CmPropertyCode - Specifies the CM_DRP code indentifying the device registry property
        with which this data buffer is associated.

    ValueType - Specifies the registry data type for the supplied buffer.

    Data - Supplies the address of the data buffer.

    DataSize - Supplies the size, in bytes, of the data buffer.

    ConvertedBuffer - Supplies the address of a variable that receives a newly-allocated
        buffer containing a converted form of the supplied data.  If the data needs no
        conversion, this parameter will be set to NULL on return.

    ConvertedBufferSize - Supplies the address of a variable that receives the size, in
        bytes, of the converted buffer, or 0 if no conversion was required.

Return Value:

    If successful, the return value is NO_ERROR, otherwise it is an ERROR_* code.

--*/
{
    //
    // Initialize ConvertedBuffer output params to indicate that no conversion was necessary.
    //
    *ConvertedBuffer = NULL;
    *ConvertedBufferSize = 0;

    //
    // Group all properties expecting the same data type together.
    //
    switch(CmPropertyCode) {
        //
        // REG_SZ properties. No other data type is supported.
        //
        case CM_DRP_DEVICEDESC :
        case CM_DRP_SERVICE :
        case CM_DRP_CLASS :
        case CM_DRP_CLASSGUID :
        case CM_DRP_DRIVER :
        case CM_DRP_MFG :
        case CM_DRP_FRIENDLYNAME :
        case CM_DRP_LOCATION_INFORMATION :
        case CM_DRP_SECURITY_SDS :
        case CM_DRP_UI_NUMBER_DESC_FORMAT:

            if(ValueType != REG_SZ) {
                return ERROR_INVALID_REG_PROPERTY;
            }

            break;

        //
        // REG_MULTI_SZ properties.  Allow REG_SZ as well, by simply double-terminating
        // the string (i.e., make it a REG_MULTI_SZ with only one string).
        //
        case CM_DRP_HARDWAREID :
        case CM_DRP_COMPATIBLEIDS :
        case CM_DRP_UPPERFILTERS:
        case CM_DRP_LOWERFILTERS:

            if(ValueType == REG_SZ) {

                if(*ConvertedBuffer = MyMalloc(*ConvertedBufferSize = DataSize + sizeof(TCHAR))) {
                    CopyMemory(*ConvertedBuffer, Data, DataSize);
                    *((PTSTR)((PBYTE)(*ConvertedBuffer) + DataSize)) = TEXT('\0');
                } else {
                    return ERROR_NOT_ENOUGH_MEMORY;
                }

            } else if(ValueType != REG_MULTI_SZ) {
                return ERROR_INVALID_REG_PROPERTY;
            }

            break;

        //
        // REG_DWORD properties.  Also allow REG_BINARY, as long as the size is right.
        //
        case CM_DRP_CONFIGFLAGS :
        case CM_DRP_CAPABILITIES :
        case CM_DRP_UI_NUMBER :
        case CM_DRP_DEVTYPE :
        case CM_DRP_EXCLUSIVE :
        case CM_DRP_CHARACTERISTICS :
        case CM_DRP_ADDRESS:
        case CM_DRP_REMOVAL_POLICY_OVERRIDE:

            if(((ValueType != REG_DWORD) && (ValueType != REG_BINARY)) || (DataSize != sizeof(DWORD))) {
                return ERROR_INVALID_REG_PROPERTY;
            }

            break;

        //
        // No other properties are supported.  Save the trouble of calling a CM API and
        // return failure now.
        //
        default :

            return ERROR_INVALID_REG_PROPERTY;
    }

    return NO_ERROR;
}

DWORD
pSetupValidateClassRegProp(
    IN  ULONG   CmPropertyCode,
    IN  DWORD   ValueType,
    IN  PCVOID  Data,
    IN  DWORD   DataSize,
    OUT PVOID  *ConvertedBuffer,
    OUT PDWORD  ConvertedBufferSize
    )
/*++

Routine Description:

    This routine validates the data buffer passed in with respect to the specified
    class registry property code.

Arguments:

    CmPropertyCode - Specifies the CM_CRP code indentifying the device registry property
        with which this data buffer is associated.

    ValueType - Specifies the registry data type for the supplied buffer.

    Data - Supplies the address of the data buffer.

    DataSize - Supplies the size, in bytes, of the data buffer.

    ConvertedBuffer - Supplies the address of a variable that receives a newly-allocated
        buffer containing a converted form of the supplied data.  If the data needs no
        conversion, this parameter will be set to NULL on return.

    ConvertedBufferSize - Supplies the address of a variable that receives the size, in
        bytes, of the converted buffer, or 0 if no conversion was required.

Return Value:

    If successful, the return value is NO_ERROR, otherwise it is an ERROR_* code.

--*/
{
    //
    // Initialize ConvertedBuffer output params to indicate that no conversion was necessary.
    //
    *ConvertedBuffer = NULL;
    *ConvertedBufferSize = 0;

    //
    // Group all properties expecting the same data type together.
    //
    switch(CmPropertyCode) {
        //
        // REG_SZ properties. No other data type is supported.
        //
        case CM_CRP_SECURITY_SDS :

            if(ValueType != REG_SZ) {
                return ERROR_INVALID_REG_PROPERTY;
            }

            break;

        //
        // REG_DWORD properties.  Also allow REG_BINARY, as long as the size is right.
        //
        case CM_CRP_DEVTYPE :
        case CM_CRP_EXCLUSIVE :
        case CM_CRP_CHARACTERISTICS :

            if(((ValueType != REG_DWORD) && (ValueType != REG_BINARY)) || (DataSize != sizeof(DWORD))) {
                return ERROR_INVALID_REG_PROPERTY;
            }

            break;

        //
        // No other properties are supported.  Save the trouble of calling a CM API and
        // return failure now.
        //
        default :

            return ERROR_INVALID_REG_PROPERTY;
    }

    return NO_ERROR;
}


#ifdef UNICODE
//
// ANSI version
//
BOOL
WINAPI
SetupInstallServicesFromInfSectionA(
    IN HINF   InfHandle,
    IN PCSTR  SectionName,
    IN DWORD  Flags
    )
{
    PCWSTR UnicodeSectionName;
    BOOL b;
    DWORD d;

    if((d = pSetupCaptureAndConvertAnsiArg(SectionName, &UnicodeSectionName)) == NO_ERROR) {

        b = SetupInstallServicesFromInfSectionExW(InfHandle,
                                                  UnicodeSectionName,
                                                  Flags,
                                                  INVALID_HANDLE_VALUE,
                                                  NULL,
                                                  NULL,
                                                  NULL
                                                 );

        d = GetLastError();

        MyFree(UnicodeSectionName);

    } else {
        b = FALSE;
    }

    SetLastError(d);
    return b;
}
#else
//
// Unicode stub
//
BOOL
WINAPI
SetupInstallServicesFromInfSectionW(
    IN HINF   InfHandle,
    IN PCWSTR SectionName,
    IN DWORD  Flags
    )
{
    UNREFERENCED_PARAMETER(InfHandle);
    UNREFERENCED_PARAMETER(SectionName);
    UNREFERENCED_PARAMETER(Flags);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}
#endif

BOOL
WINAPI
SetupInstallServicesFromInfSection(
    IN HINF   InfHandle,
    IN PCTSTR SectionName,
    IN DWORD  Flags
    )
/*++

Routine Description:

    This API performs service installation/deletion operations specified in a service
    install section.  Refer to devinstd.c!InstallNtService() for details on the format
    of this section.

Arguments:

    InfHandle - Supplies the handle of the INF containing the service install section

    SectionName - Supplies the name of the service install section to run.

    Flags - Supplies flags controlling the installation.  May be a combination of the
        following values:

        SPSVCINST_TAGTOFRONT - For every kernel or filesystem driver installed (that has
            an associated LoadOrderGroup), always move this service's tag to the front
            of the ordering list.

        SPSVCINST_DELETEEVENTLOGENTRY - For every service specified in a DelService entry,
            delete the associated event log entry (if there is one).

        SPSVCINST_NOCLOBBER_DISPLAYNAME - If this flag is specified, then we will
            not overwrite the service's display name, if it already exists.

        SPSVCINST_NOCLOBBER_STARTTYPE - If this flag is specified, then we will
            not overwrite the service's start type if the service already exists.

        SPSVCINST_NOCLOBBER_ERRORCONTROL - If this flag is specified, then we
            will not overwrite the service's error control value if the service
            already exists.

        SPSVCINST_NOCLOBBER_LOADORDERGROUP - If this flag is specified, then we
            will not overwrite the service's load order group if it already
            exists.

        SPSVCINST_NOCLOBBER_DEPENDENCIES - If this flag is specified, then we
            will not overwrite the service's dependencies list if it already
            exists.

Return Value:

    If the function succeeds, the return value is TRUE.

    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

--*/
{
    return SetupInstallServicesFromInfSectionEx(InfHandle,
                                                SectionName,
                                                Flags,
                                                INVALID_HANDLE_VALUE,
                                                NULL,
                                                NULL,
                                                NULL
                                               );
}


#ifdef UNICODE
//
// ANSI version
//
BOOL
WINAPI
SetupInstallServicesFromInfSectionExA(
    IN HINF             InfHandle,
    IN PCSTR            SectionName,
    IN DWORD            Flags,
    IN HDEVINFO         DeviceInfoSet,  OPTIONAL
    IN PSP_DEVINFO_DATA DeviceInfoData, OPTIONAL
    IN PVOID            Reserved1,
    IN PVOID            Reserved2
    )
{
    PCWSTR UnicodeSectionName;
    BOOL b;
    DWORD d;

    if((d = pSetupCaptureAndConvertAnsiArg(SectionName, &UnicodeSectionName)) == NO_ERROR) {

        b = SetupInstallServicesFromInfSectionExW(InfHandle,
                                                  UnicodeSectionName,
                                                  Flags,
                                                  DeviceInfoSet,
                                                  DeviceInfoData,
                                                  Reserved1,
                                                  Reserved2
                                                 );

        d = GetLastError();

        MyFree(UnicodeSectionName);

    } else {
        b = FALSE;
    }

    SetLastError(d);
    return b;
}
#else
//
// Unicode stub
//
BOOL
WINAPI
SetupInstallServicesFromInfSectionExW(
    IN HINF             InfHandle,
    IN PCWSTR           SectionName,
    IN DWORD            Flags,
    IN HDEVINFO         DeviceInfoSet,  OPTIONAL
    IN PSP_DEVINFO_DATA DeviceInfoData, OPTIONAL
    IN PVOID            Reserved1,
    IN PVOID            Reserved2
    )
{
    UNREFERENCED_PARAMETER(InfHandle);
    UNREFERENCED_PARAMETER(SectionName);
    UNREFERENCED_PARAMETER(Flags);
    UNREFERENCED_PARAMETER(DeviceInfoSet);
    UNREFERENCED_PARAMETER(DeviceInfoData);
    UNREFERENCED_PARAMETER(Reserved1);
    UNREFERENCED_PARAMETER(Reserved2);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}
#endif

BOOL
WINAPI
SetupInstallServicesFromInfSectionEx(
    IN HINF             InfHandle,
    IN PCTSTR           SectionName,
    IN DWORD            Flags,
    IN HDEVINFO         DeviceInfoSet,  OPTIONAL
    IN PSP_DEVINFO_DATA DeviceInfoData, OPTIONAL
    IN PVOID            Reserved1,
    IN PVOID            Reserved2
    )
/*++

Routine Description:

    This API performs service installation/deletion operations specified in a service
    install section.  Refer to devinstd.c!InstallNtService() for details on the format
    of this section.

Arguments:

    InfHandle - Supplies the handle of the INF containing the service install section

    SectionName - Supplies the name of the service install section to run.

    Flags - Supplies flags controlling the installation.  May be a combination of the
        following values:

        SPSVCINST_TAGTOFRONT - For every kernel or filesystem driver installed (that has
            an associated LoadOrderGroup), always move this service's tag to the front
            of the ordering list.

        SPSVCINST_ASSOCSERVICE - This flag may only be specified if a device information
            set and a device information element are specified.  If set, this flag
            specifies that the service being installed is the owning service (i.e.,
            function driver) for this device instance.  If the service install section
            contains more than AddService entry, then this flag is ignored (only 1
            service can be the function driver for a device instance).

        SPSVCINST_DELETEEVENTLOGENTRY - For every service specified in a DelService entry,
            delete the associated event log entry (if there is one).

        SPSVCINST_NOCLOBBER_DISPLAYNAME - If this flag is specified, then we will
            not overwrite the service's display name, if it already exists.

        SPSVCINST_NOCLOBBER_STARTTYPE - If this flag is specified, then we will
            not overwrite the service's start type if the service already exists.

        SPSVCINST_NOCLOBBER_ERRORCONTROL - If this flag is specified, then we
            will not overwrite the service's error control value if the service
            already exists.

        SPSVCINST_NOCLOBBER_LOADORDERGROUP - If this flag is specified, then we
            will not overwrite the service's load order group if it already
            exists.

        SPSVCINST_NOCLOBBER_DEPENDENCIES - If this flag is specified, then we
            will not overwrite the service's dependencies list if it already
            exists.

    DeviceInfoSet - Optionally, supplies a handle to the device information set containing
        an element that is to be associated with the service being installed.  If this
        parameter is not specified, then DeviceInfoData is ignored.

    DeviceInfoData - Optionally, specifies the device information element that is to be
        associated with the service being installed.  If DeviceInfoSet is specified, then
        this parameter must be specified.

    Reserved1, Reserved2 - Reserved for future use--must be NULL.

Return Value:

    If the function succeeds, the return value is TRUE.

    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

--*/
{
    PDEVICE_INFO_SET pDeviceInfoSet;
    PDEVINFO_ELEM DevInfoElem;
    INFCONTEXT InfContext;
    DWORD d;
    BOOL DontCare;
    BOOL NeedReboot = FALSE;

    //
    // Validate the flags passed in.
    //
    if(Flags & SPSVCINST_ILLEGAL_FLAGS) {
        SetLastError(ERROR_INVALID_FLAGS);
        return FALSE;
    }

    //
    // Make sure that a device information set and element were specified if the
    // SPSVCINST_ASSOCSERVICE flag is set.
    //
    if(Flags & SPSVCINST_ASSOCSERVICE) {

        if(!DeviceInfoSet ||
           (DeviceInfoSet == INVALID_HANDLE_VALUE) ||
           !DeviceInfoData) {

            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }
    }

    //
    // Make sure the caller didn't pass us anything in the Reserved parameters.
    //
    if(Reserved1 || Reserved2) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // Make sure we were given a section name.
    //
    if(!SectionName) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // Lock down the device information set for the duration of this call.
    //
    if(Flags & SPSVCINST_ASSOCSERVICE) {

        if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
            SetLastError(ERROR_INVALID_HANDLE);
            return FALSE;
        }

    } else {
        pDeviceInfoSet = NULL;
    }

    d = NO_ERROR;
    DevInfoElem = NULL;

    try {

        if(pDeviceInfoSet) {

            if(!(DevInfoElem = FindAssociatedDevInfoElem(pDeviceInfoSet,
                                                         DeviceInfoData,
                                                         NULL))) {
                d = ERROR_INVALID_PARAMETER;
                goto clean0;
            }
        }

        //
        // We don't do any validation that the section exists in the worker routine--make
        // sure that it does exist.
        //
        if(SetupFindFirstLine(InfHandle, SectionName, NULL, &InfContext)) {
            //
            // If SPSVCINST_ASSOCSERVICE is specified, then ensure that there is exactly
            // one AddService entry in this service install section.  If not, then clear
            // this flag.
            //
            if((Flags & SPSVCINST_ASSOCSERVICE) &&
               SetupFindFirstLine(InfHandle, SectionName, pszAddService, &InfContext) &&
               SetupFindNextMatchLine(&InfContext, pszAddService, &InfContext))
            {
                Flags &= ~SPSVCINST_ASSOCSERVICE;
            }

            d = InstallNtService(DevInfoElem,
                                 InfHandle,
                                 NULL,
                                 SectionName,
                                 NULL,
                                 Flags | SPSVCINST_NO_DEVINST_CHECK,
                                 &DontCare
                                );

            if ((d == NO_ERROR) && GetLastError() == ERROR_SUCCESS_REBOOT_REQUIRED) {
                NeedReboot = TRUE;
            }

        } else {
            d = GetLastError();
            pSetupLogSectionWarning(InfHandle,DeviceInfoSet,DeviceInfoData,NULL,SectionName,MSG_LOG_NOSECTION_SERVICE,d,NULL);
            //
            // some callers expect this specific error
            //
            d = ERROR_SECTION_NOT_FOUND;
        }

clean0: ;   // nothing to do.

    } except(EXCEPTION_EXECUTE_HANDLER) {
        d = ERROR_INVALID_PARAMETER;
    }

    if(pDeviceInfoSet) {
        UnlockDeviceInfoSet(pDeviceInfoSet);
    }

    if (!NeedReboot) {
        SetLastError(d);
    } else {
        MYASSERT( d == NO_ERROR );
    }
    return (d == NO_ERROR);
}


//
// Taken from Win95 sxgen.c. These are flags used when
// we are installing an inf such as when a user right-clicks
// on one and selects the 'install' action.
//
#define HOW_NEVER_REBOOT         0
#define HOW_ALWAYS_SILENT_REBOOT 1
#define HOW_ALWAYS_PROMPT_REBOOT 2
#define HOW_SILENT_REBOOT        3
#define HOW_PROMPT_REBOOT        4


#ifdef UNICODE
//
// ANSI version
//
VOID
WINAPI
InstallHinfSectionA(
    IN HWND      Window,
    IN HINSTANCE ModuleHandle,
    IN PCSTR     CommandLine,
    IN INT       ShowCommand
    )
#else
//
// Unicode version
//
VOID
WINAPI
InstallHinfSectionW(
    IN HWND      Window,
    IN HINSTANCE ModuleHandle,
    IN PCWSTR    CommandLine,
    IN INT       ShowCommand
    )
#endif
{
    UNREFERENCED_PARAMETER(Window);
    UNREFERENCED_PARAMETER(ModuleHandle);
    UNREFERENCED_PARAMETER(CommandLine);
    UNREFERENCED_PARAMETER(ShowCommand);
}

VOID
WINAPI
InstallHinfSection(
    IN HWND      Window,
    IN HINSTANCE ModuleHandle,
    IN PCTSTR    CommandLine,
    IN INT       ShowCommand
    )

/*++

Routine Description:

    This is the entry point that performs the INSTALL action when
    a user right-clicks an inf file. It is called by the shell via rundll32.

    The command line is expected to be of the following form:

        <section name> <flags> <file name>

    The section is expected to be a general format install section, and
    may also have an include= line and a needs= line. Infs listed on the
    include= line are append-loaded to the inf on the command line prior to
    any installation. Sections on the needs= line are installed after the
    section listed on the command line.

    After the specified section has been installed, a section of the form:

        [<section name>.Services]

    is used in a call to SetupInstallServicesFromInfSection.

Arguments:

    Flags - supplies flags for operation.

        1 - reboot the machine in all cases
        2 - ask the user if he wants to reboot
        3 - reboot the machine without asking the user, if we think it is necessary
        4 - if we think reboot is necessary, ask the user if he wants to reboot

        0x80 - set the default file source path for file installation to
               the path where the inf is located.  (NOTE: this is hardly ever
               necessary for the Setup APIs, since we intelligently determine what
               the source path should be.  The only case where this would still be
               useful is if there were a directory that contained INFs that was in
               our INF search path list, but that also contained the files to be
               copied by this INF install action.  In that case, this flag would
               still need to be set, or we would look for the files in the location
               from which the OS was installed.

Return Value:

    None.

--*/

{
    TCHAR SourcePathBuffer[MAX_PATH];
    PTSTR SourcePath;
    PTSTR szCmd = NULL;
    PTCHAR p;
    PTCHAR szHow;
    PTSTR szInfFile, szSectionName;
    INT   iHow, NeedRebootFlags;
    HINF  InfHandle;
    TCHAR InfSearchPath[MAX_PATH];
    HSPFILEQ FileQueue;
    PVOID QueueContext;
    BOOL b, Error;
    TCHAR ActualSection[MAX_SECT_NAME_LEN];
    DWORD ActualSectionLength;
    DWORD Win32ErrorCode;
    INFCONTEXT InfContext;
    BOOL DontCare;
    DWORD RequiredSize;
    DWORD slot_section = 0;
    BOOL NoProgressUI;
    BOOL reboot = FALSE;

    UNREFERENCED_PARAMETER(ModuleHandle);
    UNREFERENCED_PARAMETER(ShowCommand);

    //
    // Initialize variables that will later contain resource requiring clean-up.
    //
    InfHandle = INVALID_HANDLE_VALUE;
    FileQueue = INVALID_HANDLE_VALUE;
    QueueContext = NULL;

    Error = TRUE;   // assume failure.

    try {
        //
        // Take a copy of the command line then get pointers to the fields.
        //
        szCmd = DuplicateString(CommandLine);

        szSectionName = szCmd;
        szHow = _tcschr(szSectionName, TEXT(' '));
        if(!szHow) {
            goto c0;
        }
        *szHow++ = TEXT('\0');
        szInfFile = _tcschr(szHow, TEXT(' '));
        if(!szInfFile) {
            goto c0;
        }
        *szInfFile++ = TEXT('\0');

        iHow = _tcstol(szHow, NULL, 10);

        //
        // Get the full path to the INF, so that the path may be used as a
        // first-pass attempt at locating any associated INFs.
        //
        RequiredSize = GetFullPathName(szInfFile,
                                       SIZECHARS(InfSearchPath),
                                       InfSearchPath,
                                       &p
                                      );

        if(!RequiredSize || (RequiredSize >= SIZECHARS(InfSearchPath))) {
            //
            // If we start failing because MAX_PATH isn't big enough anymore, we
            // wanna know about it!
            //
            MYASSERT(RequiredSize < SIZECHARS(InfSearchPath));
            goto c0;
        }

        //
        // If flag is set (and INF filename includes a path), set up so DIRID_SRCPATH is
        // path where INF is located (i.e., override our default SourcePath determination).
        //
        if((iHow & 0x80) && (pSetupGetFileTitle(szInfFile) != szInfFile)) {
            TCHAR c = *p;
            *p = TEXT('\0');
            MYVERIFY(SUCCEEDED(StringCchCopy(SourcePathBuffer,SIZECHARS(SourcePathBuffer),InfSearchPath)));
            *p = c;
            SourcePath = SourcePathBuffer;
        } else {
            SourcePath = NULL;
        }

        iHow &= 0x7f;

        //
        // If we're non-interactive, then we don't want to allow any possibility
        // of a reboot prompt happening.
        //
        if(GlobalSetupFlags & (PSPGF_NONINTERACTIVE|PSPGF_UNATTENDED_SETUP)) {

            switch(iHow) {

                case HOW_NEVER_REBOOT:
                case HOW_ALWAYS_SILENT_REBOOT:
                case HOW_SILENT_REBOOT:
                    //
                    // These cases are OK--they're all silent.
                    //
                    break;

                default:
                    //
                    // Anything else is disallowed in non-interactive mode.
                    //
                    goto c0;
            }
        }

        //
        // Load the inf file that was passed on the command line.
        //
        InfHandle = SetupOpenInfFile(szInfFile, NULL, INF_STYLE_WIN4, NULL);
        if(InfHandle == INVALID_HANDLE_VALUE) {
            goto c0;
        }

        //
        // See if there is an nt-specific section
        //
        if(!SetupDiGetActualSectionToInstall(InfHandle,
                                             szSectionName,
                                             ActualSection,
                                             SIZECHARS(ActualSection),
                                             &ActualSectionLength,
                                             NULL
                                             )) {
            goto c0;
        }

        //
        // Check to see if the install section has a "Reboot" line.
        //
        if(SetupFindFirstLine(InfHandle, ActualSection, pszReboot, &InfContext)) {
            reboot = TRUE;
        }

        //
        // Assume there is only one layout file and load it.
        //
        SetupOpenAppendInfFile(NULL, InfHandle, NULL);

        //
        // Append-load any included INFs specified in an "include=" line in our
        // install section.
        //
        AppendLoadIncludedInfs(InfHandle, InfSearchPath, ActualSection, TRUE);

        //
        // Create a setup file queue and initialize the default queue callback.
        //
        FileQueue = SetupOpenFileQueue();
        if(FileQueue == INVALID_HANDLE_VALUE) {
            goto c1;
        }

        //
        // Replace the file queue's log context with the Inf's
        //
        ShareLogContext(&((PLOADED_INF)InfHandle)->LogContext,&((PSP_FILE_QUEUE)FileQueue)->LogContext);

        NoProgressUI = (GuiSetupInProgress || (GlobalSetupFlags & PSPGF_NONINTERACTIVE));

        QueueContext = SetupInitDefaultQueueCallbackEx(
                           Window,
                           (NoProgressUI ? INVALID_HANDLE_VALUE : NULL),
                           0,
                           0,
                           0
                          );

        if(!QueueContext) {
            goto c2;
        }

        if (slot_section == 0) {
            slot_section = AllocLogInfoSlot(((PSP_FILE_QUEUE) FileQueue)->LogContext,FALSE);
        }
        WriteLogEntry(((PSP_FILE_QUEUE) FileQueue)->LogContext,
            slot_section,
            MSG_LOG_INSTALLING_SECTION_FROM,
            NULL,
            ActualSection,
            szInfFile);

        b = (NO_ERROR == InstallFromInfSectionAndNeededSections(NULL,
                                                                InfHandle,
                                                                ActualSection,
                                                                SPINST_FILES,
                                                                NULL,
                                                                SourcePath,
                                                                SP_COPY_NEWER | SP_COPY_LANGUAGEAWARE,
                                                                NULL,
                                                                NULL,
                                                                INVALID_HANDLE_VALUE,
                                                                NULL,
                                                                FileQueue
                                                               ));

        //
        // Commit file queue.
        //
        if(!SetupCommitFileQueue(Window, FileQueue, SetupDefaultQueueCallback, QueueContext)) {
            goto c3;
        }

        //
        // Note, if the INF contains a (non-NULL) ClassGUID, then it will have
        // been installed into %windir%\Inf during the above queue committal.
        // We make no effort to subsequently uninstall it (and its associated
        // PNF and CAT) if something fails below.
        //

        //
        // Perform non-file operations for the section passed on the cmd line.
        //
        b = (NO_ERROR == InstallFromInfSectionAndNeededSections(Window,
                                                                InfHandle,
                                                                ActualSection,
                                                                SPINST_ALL ^ SPINST_FILES,
                                                                NULL,
                                                                NULL,
                                                                0,
                                                                NULL,
                                                                NULL,
                                                                INVALID_HANDLE_VALUE,
                                                                NULL,
                                                                NULL
                                                               ));

        //
        // Now run the corresponding ".Services" section (if there is one), and
        // then finish up the install.
        //
        ActualSectionLength--;
        if(SUCCEEDED(StringCchCopy(&(ActualSection[ActualSectionLength]),
                   SIZECHARS(ActualSection)-ActualSectionLength,
                   pszServicesSectionSuffix))) {

            //
            // We don't do any validation that the section exists in the worker
            // routine--make sure that it does exist.
            //
            if(SetupFindFirstLine(InfHandle, ActualSection, NULL, &InfContext)) {

                Win32ErrorCode = InstallNtService(NULL,
                                                  InfHandle,
                                                  InfSearchPath,
                                                  ActualSection,
                                                  NULL,
                                                  SPSVCINST_NO_DEVINST_CHECK,
                                                  &DontCare
                                                 );

                if(Win32ErrorCode != NO_ERROR) {
                    SetLastError(Win32ErrorCode);
                    goto c3;
                } else if(GetLastError()==ERROR_SUCCESS_REBOOT_REQUIRED) {
                    reboot = TRUE;
                }

            }
        }


        if(reboot) {
            //
            // we've been asked to reboot either by reboot keyword or because of boot-start service
            //
            if(iHow == HOW_SILENT_REBOOT) {
                //
                // We were supposed to only do a silent reboot if necessary.
                // Change this to _always_ do a silent reboot.
                //
                iHow = HOW_ALWAYS_SILENT_REBOOT;

            } else if(iHow != HOW_ALWAYS_SILENT_REBOOT) {

                if(GlobalSetupFlags & (PSPGF_NONINTERACTIVE|PSPGF_UNATTENDED_SETUP)) {
                    //
                    // In the non-interactive case, we have a problem.  The
                    // caller said to never reboot, but the INF wants us to ask
                    // the user.  We obviously cannot ask the user.
                    //
                    // In this case, we assert (we should never be running INFs
                    // non-interactively that require a reboot unless we've
                    // specified one of the silent reboot flags).  We then
                    // ignore the reboot flag, since the caller obviously
                    // doesn't want it/isn't prepared to deal with it.
                    //
                    MYASSERT(0);

                } else {
                    //
                    // In the interactive case, we want to force the (non-
                    // silent) reboot prompt (i.e., the INF flag overrides the
                    // caller).
                    //
                    iHow = HOW_ALWAYS_PROMPT_REBOOT;
                }
            }
        }

        if(NO_ERROR != (Win32ErrorCode = pSetupInstallStopEx(TRUE, 0, ((PSP_FILE_QUEUE)FileQueue)->LogContext))) {
            SetLastError(Win32ErrorCode);
            goto c3;
        }

        //
        // Refresh the desktop.
        //
        SHChangeNotify(SHCNE_ASSOCCHANGED,SHCNF_FLUSHNOWAIT,0,0);

        switch(iHow) {

        case HOW_NEVER_REBOOT:
            break;

        case HOW_ALWAYS_PROMPT_REBOOT:
            RestartDialogEx(Window, NULL, EWX_REBOOT,REASON_PLANNED_FLAG);
            break;

        case HOW_PROMPT_REBOOT:
            SetupPromptReboot(FileQueue, Window, FALSE);
            break;

        case HOW_SILENT_REBOOT:
            if(!(NeedRebootFlags = SetupPromptReboot(FileQueue, Window, TRUE))) {
                break;
            } else if(NeedRebootFlags == -1) {
                //
                // An error occurred--this should never happen.
                //
                goto c3;
            }
            //
            // Let fall through to same code that handles 'always silent reboot'
            // case.
            //

        case HOW_ALWAYS_SILENT_REBOOT:
            //
            // Assumption that user has reboot privs
            //
            if(pSetupEnablePrivilege(SE_SHUTDOWN_NAME, TRUE)) {
                ExitWindowsEx(EWX_REBOOT, 0);
            }
            break;
        }

        //
        // If we get to here, then this routine has been successful.
        //
        Error = FALSE;

c3:
        if(Error && (GetLastError() == ERROR_CANCELLED)) {
            //
            // If the error was because the user cancelled, then we don't want
            // to consider that as an error (i.e., we don't want to give an
            // error popup later).
            //
            Error = FALSE;
        }

        SetupTermDefaultQueueCallback(QueueContext);
        QueueContext = NULL;
c2:
        if (slot_section) {
            ReleaseLogInfoSlot(((PSP_FILE_QUEUE) FileQueue)->LogContext,slot_section);
            slot_section = 0;
        }
        SetupCloseFileQueue(FileQueue);
        FileQueue = INVALID_HANDLE_VALUE;
c1:
        SetupCloseInfFile(InfHandle);
        InfHandle = INVALID_HANDLE_VALUE;

c0:     ; // nothing to do.

    } except(EXCEPTION_EXECUTE_HANDLER) {
        if(QueueContext) {
            SetupTermDefaultQueueCallback(QueueContext);
        }
        if(FileQueue != INVALID_HANDLE_VALUE) {
            if (slot_section) {
                ReleaseLogInfoSlot(((PSP_FILE_QUEUE) FileQueue)->LogContext,slot_section);
                slot_section = 0;
            }
            SetupCloseFileQueue(FileQueue);
        }
        if(InfHandle != INVALID_HANDLE_VALUE) {
            SetupCloseInfFile(InfHandle);
        }
    }

    if(Error) {

        if(!(GlobalSetupFlags & (PSPGF_NONINTERACTIVE|PSPGF_UNATTENDED_SETUP))) {
             //
             // Re-use 'ActualSection' buffer to hold error dialog title.
             //
             if(!LoadString(MyDllModuleHandle,
                            IDS_ERROR,
                            ActualSection,
                            SIZECHARS(ActualSection))) {
                 *ActualSection = TEXT('\0');
             }

             FormatMessageBox(MyDllModuleHandle,
                              Window,
                              MSG_INF_FAILED,
                              ActualSection,
                              MB_OK | MB_ICONSTOP
                             );
        }
    }

    if(szCmd) {
        MyFree(szCmd);
    }
}


PTSTR
GetMultiSzFromInf(
    IN  HINF    InfHandle,
    IN  PCTSTR  SectionName,
    IN  PCTSTR  Key,
    OUT PBOOL   pSetupOutOfMemory
    )
/*++

Routine Description:

    This routine returns a newly-allocated buffer filled with the multi-sz list contained
    in the specified INF line.  The caller must free this buffer via MyFree().

Arguments:

    InfHandle - Supplies a handle to the INF containing the line

    SectionName - Specifies which section within the INF contains the line

    Key - Specifies the line whose fields are to be retrieved as a multi-sz list

    pSetupOutOfMemory - Supplies the address of a boolean variable that is set upon return
        to indicate whether or not a failure occurred because of an out-of-memory condition.
        (Failure for any other reason is assumed to be OK.)

Return Value:

    If successful, the return value is the address of a newly-allocated buffer containing
    the multi-sz list, otherwise, it is NULL.

--*/
{
    INFCONTEXT InfContext;
    PTSTR MultiSz;
    DWORD Size;

    //
    // Initialize out-of-memory indicator to FALSE.
    //
    *pSetupOutOfMemory = FALSE;

    if(!SetupFindFirstLine(InfHandle, SectionName, Key, &InfContext) ||
       !SetupGetMultiSzField(&InfContext, 1, NULL, 0, &Size) || (Size < 3)) {

        return NULL;
    }

    if(MultiSz = MyMalloc(Size * sizeof(TCHAR))) {
        if(SetupGetMultiSzField(&InfContext, 1, MultiSz, Size, &Size)) {
            return MultiSz;
        }
        MyFree(MultiSz);
    } else {
        *pSetupOutOfMemory = TRUE;
    }

    return NULL;
}


DWORD
pSetupInstallStopEx(
    IN BOOL DoRunOnce,
    IN DWORD Flags,
    IN PVOID Reserved OPTIONAL
    )
/*++

Routine Description:

    This routine sets up runonce/grpconv to run after a successful INF installation.

Arguments:

    DoRunOnce - If TRUE, then invoke (via WinExec) the runonce utility to perform the
        runonce actions.  If this flag is FALSE, then this routine simply sets the
        runonce registry values and returns.

        NOTE:  The return code from WinExec is not currently being checked, so the return
        value of InstallStop only reflects whether the registry values were set up
        successfully--_not_ whether 'runonce -r' was successfully run.

    Flags - Supplies flags that modify the behavior of this routine.  May be a
        combination of the following values:

        INSTALLSTOP_NO_UI       - Don't display any UI
        INSTALLSTOP_NO_GRPCONV  - Don't do GrpConv

    Reserved - Reserved for internal use--external callers must pass NULL.

Return Value:

    If successful, the return value is NO_ERROR, otherwise it is the Win32 error code
    indicating the error that was encountered.

--*/
{
    HKEY  hKey, hSetupKey;
    DWORD Error = NO_ERROR;
    LONG l;
    DWORD nValues = 0;
    PSETUP_LOG_CONTEXT lc = (PSETUP_LOG_CONTEXT)Reserved;

    //
    // If we're batching up RunOnce operations for server-side processing, then
    // return immediately without doing a thing.
    //
    if(GlobalSetupFlags & PSPGF_NONINTERACTIVE) {
        return NO_ERROR;
    }

    //
    // First, open the key "HKLM\Software\Microsoft\Windows\CurrentVersion\RunOnce"
    //
    if((l = RegOpenKeyEx(HKEY_LOCAL_MACHINE,pszPathRunOnce,0,KEY_WRITE|KEY_READ,&hKey)) != ERROR_SUCCESS) {
        return (DWORD)l;
    }

    if(!(Flags & INSTALLSTOP_NO_GRPCONV)) {
        //
        // If we need to run the runonce exe for the setup key...
        //
        MYASSERT(*pszKeySetup == TEXT('\\'));
        if(RegOpenKeyEx(hKey,
                        pszKeySetup + 1,    // skip the preceding '\'
                        0,
                        KEY_READ,
                        &hSetupKey) == ERROR_SUCCESS) {
            //
            // We don't need the key--we just needed to check its existence.
            //
            RegCloseKey(hSetupKey);

            //
            // Add the runonce value.
            //
            Error = (DWORD)RegSetValueEx(hKey,
                                         REGSTR_VAL_WRAPPER,
                                         0,
                                         REG_SZ,
                                         (PBYTE)pszRunOnceExe,
                                         sizeof(pszRunOnceExe)
                                        );
        } else {
            //
            // We're OK so far.
            //
            Error = NO_ERROR;
        }

        //
        // GroupConv is always run.
        //
        if(Flags & INSTALLSTOP_NO_UI) {
            l = RegSetValueEx(hKey,
                TEXT("GrpConv"),
                0,
                REG_SZ,
                (PBYTE)pszGrpConvNoUi,
                sizeof(pszGrpConvNoUi));
        } else {
            l = RegSetValueEx(hKey,
                TEXT("GrpConv"),
                0,
                REG_SZ,
                (PBYTE)pszGrpConv,
                sizeof(pszGrpConv));
        }
    }

    if( l != ERROR_SUCCESS ) {
        //
        // Since GrpConv is always run, consider it a more serious error than any error
        // encountered when setting 'runonce'.  (This decision is rather arbitrary, but
        // in practice, it should never make any difference.  Once we get the registry key
        // opened, there's no reason either of these calls to RegSetValueEx should fail.)
        //
        Error = (DWORD)l;
    }

    if (DoRunOnce && (GlobalSetupFlags & PSPGF_NO_RUNONCE)==0) {

        STARTUPINFO StartupInfo;
        PROCESS_INFORMATION ProcessInformation;
        BOOL started;
        TCHAR cmdline[MAX_PATH];
        TCHAR cmdpath[MAX_PATH];

        //
        // we want to know how many items we'll be executing in RunOnce to estimate a timeout
        //
        // This is black-art, we'll allow 5 mins + 1 min per item we
        // find in RunOnce key, but we don't know if there are any other (new) RunOnce keys
        //
        l = RegQueryInfoKey(hKey,NULL,NULL,NULL,
                                    NULL,NULL,NULL,
                                    &nValues,
                                    NULL, NULL, NULL, NULL);
        if ( l != ERROR_SUCCESS ) {
            nValues = 5;
        } else {
            nValues += 5;
        }

        RegCloseKey(hKey);

        ZeroMemory(&StartupInfo,sizeof(StartupInfo));
        ZeroMemory(&ProcessInformation,sizeof(ProcessInformation));

        if (lc) {
            //
            // log this information only if we have a context, else don't waste space
            //
            WriteLogEntry(lc,
                  SETUP_LOG_INFO,
                  MSG_LOG_RUNONCE_CALL,
                  NULL,
                  nValues
                 );
        }


        StartupInfo.cb = sizeof(StartupInfo);
        StartupInfo.dwFlags = STARTF_USESHOWWINDOW;
        StartupInfo.wShowWindow = SW_SHOWNORMAL; // runonce -r ignores this anyway
        MYVERIFY(SUCCEEDED(StringCchCopy(cmdpath,
                                         SIZECHARS(cmdpath),
                                         SystemDirectory)));
        if(pSetupConcatenatePaths(cmdpath,TEXT("\\runonce.exe"),SIZECHARS(cmdpath),NULL)
           && SUCCEEDED(StringCchPrintf(cmdline,
                                         SIZECHARS(cmdline),
                                         TEXT("\"%s\" -r"),
                                         cmdpath))) {

            started = CreateProcess(cmdpath,    // runonce command
                          cmdline,              // command-line to execute
                          NULL,                 // default process security
                          NULL,                 // default thread security
                          FALSE,                // don't inherit handles
                          0,                    // default flags
                          NULL,                 // inherit environment
                          NULL,                 // inherit current directory
                          &StartupInfo,
                          &ProcessInformation);

            if(started) {

                DWORD WaitProcStatus;
                DWORD Timeout;
                BOOL KeepWaiting = TRUE;


                if (nValues > RUNONCE_THRESHOLD) {
                    Timeout = RUNONCE_TIMEOUT * RUNONCE_THRESHOLD;
                } else if (nValues > 0) {
                    Timeout = RUNONCE_TIMEOUT * nValues;
                } else {
                    //
                    // assume something strange - shouldn't occur
                    //
                    Timeout = RUNONCE_TIMEOUT * RUNONCE_THRESHOLD;
                }

                while (KeepWaiting) {
                    WaitProcStatus = MsgWaitForMultipleObjectsEx(
                        1,
                        &ProcessInformation.hProcess,
                        Timeout,
                        QS_ALLINPUT,
                        MWMO_ALERTABLE | MWMO_INPUTAVAILABLE);
                    switch (WaitProcStatus) {
                    case WAIT_OBJECT_0 + 1: { // Process gui messages
                        MSG msg;

                        while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {
                            TranslateMessage(&msg);
                            DispatchMessage(&msg);
                        }

                        // fall through ...
                    }
                    case WAIT_IO_COMPLETION:
                        break;

                    case WAIT_OBJECT_0:
                    case WAIT_TIMEOUT:
                    default:
                        KeepWaiting = FALSE;
                        break;
                    }
                }

                if (WaitProcStatus == WAIT_TIMEOUT) {
                    //
                    // We won't consider this a critical failure--the runonce task
                    // will continue. We do want to log an error about this.
                    //
                    WriteLogEntry(lc,
                                  SETUP_LOG_ERROR,
                                  MSG_LOG_RUNONCE_TIMEOUT,
                                  NULL
                                 );
                }

                CloseHandle(ProcessInformation.hThread);
                CloseHandle(ProcessInformation.hProcess);
            }

        } else {
            started = FALSE;
        }

        if(!started) {

            DWORD CreateProcError;

            //
            // We won't consider this a critical failure--the runonce task
            // should get picked up later by someone else (e.g., at next
            // login).  We do want to log an error about this, however.
            //
            CreateProcError = GetLastError();

            WriteLogEntry(lc,
                          SETUP_LOG_ERROR | SETUP_LOG_BUFFER,
                          MSG_LOG_RUNONCE_FAILED,
                          NULL
                         );

            WriteLogError(lc,
                          SETUP_LOG_ERROR,
                          CreateProcError
                         );
        }
    } else {

        RegCloseKey(hKey);
    }

    return Error;
}

PPSP_RUNONCE_NODE
pSetupAccessRunOnceNodeList(
    VOID
    )
/*++

Routine Description:

    This routine returns a pointer to the head of the global RunOnce node list.
    The caller may traverse the list (via the Next pointer), but does not own
    the list, and may not modify it in any way.

    To cause the list to be freed, use pSetupDestroyRunOnceNodeList.

Arguments:

    None

Return Value:

    Pointer to the first item in the list, or NULL if the list is empty.

Remarks:

    THIS ROUTINE IS NOT THREAD SAFE, AND IS FOR USE SOLELY BY THE SINGLE THREAD
    IN UMPNPMGR THAT DOES DEVICE INSTALLATIONS.

--*/
{
    return RunOnceListHead;
}


VOID
pSetupDestroyRunOnceNodeList(
    VOID
    )
/*++

Routine Description:

    This routine frees the global list of RunOnce nodes, setting it back to an
    empty list.

Arguments:

    None

Return Value:

    None

Remarks:

    THIS ROUTINE IS NOT THREAD SAFE, AND IS FOR USE SOLELY BY THE SINGLE THREAD
    IN UMPNPMGR THAT DOES DEVICE INSTALLATIONS.

--*/
{
    PPSP_RUNONCE_NODE NextNode;

    while(RunOnceListHead) {
        NextNode = RunOnceListHead->Next;
        MyFree(RunOnceListHead->DllFullPath);
        MyFree(RunOnceListHead->DllEntryPointName);
        MyFree(RunOnceListHead->DllParams);
        MyFree(RunOnceListHead);
        RunOnceListHead = NextNode;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\setupapi\inflogcf.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    inflogcf.c

Abstract:

    Routines to parse logical configuration sections in
    win95-style INF files, and place the output in the registry.

Author:

    Ted Miller (tedm) 8-Mar-1995

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop


PCTSTR pszHexDigits = TEXT("0123456789ABCDEF");

#define INFCHAR_SIZE_SEP            TEXT('@')
#define INFCHAR_RANGE_SEP           TEXT('-')
#define INFCHAR_ALIGN_SEP           TEXT('%')
#define INFCHAR_ATTR_START          TEXT('(')
#define INFCHAR_ATTR_END            TEXT(')')
#define INFCHAR_MEMATTR_READ        TEXT('R')
#define INFCHAR_MEMATTR_WRITE       TEXT('W')
#define INFCHAR_MEMATTR_PREFETCH    TEXT('F')
#define INFCHAR_MEMATTR_COMBINEDWRITE TEXT('C')
#define INFCHAR_MEMATTR_CACHEABLE   TEXT('H')
#define INFCHAR_MEMATTR_DWORD       TEXT('D')
#define INFCHAR_MEMATTR_ATTRIBUTE   TEXT('A')
#define INFCHAR_DECODE_START        TEXT('(')
#define INFCHAR_DECODE_END          TEXT(')')
#define INFCHAR_DECODE_SEP          TEXT(':')
#define INFCHAR_IRQATTR_SEP         TEXT(':')
#define INFCHAR_IRQATTR_SHARE       TEXT('S')
#define INFCHAR_IRQATTR_LEVEL       TEXT('L')
#define INFCHAR_DMAWIDTH_NARROW     TEXT('N')   // i.e., 8-bit
#define INFCHAR_DMAWIDTH_WORD       TEXT('W')   // i.e., 16-bit
#define INFCHAR_DMAWIDTH_DWORD      TEXT('D')   // i.e., 32-bit
#define INFCHAR_DMA_BUSMASTER       TEXT('M')
#define INFCHAR_DMATYPE_A           TEXT('A')
#define INFCHAR_DMATYPE_B           TEXT('B')
#define INFCHAR_DMATYPE_F           TEXT('F')
#define INFCHAR_IOATTR_MEMORY       TEXT('M')
#define INFCHAR_PCCARD_IOATTR_WORD  TEXT('W')
#define INFCHAR_PCCARD_IOATTR_BYTE  TEXT('B')
#define INFCHAR_PCCARD_IOATTR_SRC   TEXT('S')
#define INFCHAR_PCCARD_IOATTR_Z8    TEXT('Z')
#define INFCHAR_PCCARD_ATTR_WAIT    TEXT('X')
#define INFCHAR_PCCARD_ATTR_WAITI   TEXT('I')
#define INFCHAR_PCCARD_ATTR_WAITM   TEXT('M')
#define INFCHAR_PCCARD_MEMATTR_WORD TEXT('M')
#define INFCHAR_PCCARD_MEM_ISATTR   TEXT('A')
#define INFCHAR_PCCARD_MEM_ISCOMMON TEXT('C')
#define INFCHAR_PCCARD_SEP          TEXT(':')
#define INFCHAR_PCCARD_ATTR_SEP     TEXT(' ')
#define INFCHAR_MFCARD_AUDIO_ATTR   TEXT('A')

#define INFLOGCONF_IOPORT_10BIT_DECODE    0x000003ff
#define INFLOGCONF_IOPORT_12BIT_DECODE    0x00000fff
#define INFLOGCONF_IOPORT_16BIT_DECODE    0x0000ffff
#define INFLOGCONF_IOPORT_POSITIVE_DECODE 0x00000000

#define DEFAULT_IOPORT_DECODE             INFLOGCONF_IOPORT_10BIT_DECODE

#define DEFAULT_MEMORY_ALIGNMENT    0xfffffffffffff000  // 4K-aligned (a'la Win9x)
#define DEFAULT_IOPORT_ALIGNMENT    0xffffffffffffffff  // byte-aligned
#define DEFAULT_IRQ_AFFINITY        0xffffffff          // use any processor


//
// Mapping between registry key specs in an inf file
// and predefined registry handles.
//
STRING_TO_DATA InfPrioritySpecToPriority[] = {  INFSTR_CFGPRI_HARDWIRED   , LCPRI_HARDWIRED,
                                                INFSTR_CFGPRI_DESIRED     , LCPRI_DESIRED,
                                                INFSTR_CFGPRI_NORMAL      , LCPRI_NORMAL,
                                                INFSTR_CFGPRI_SUBOPTIMAL  , LCPRI_SUBOPTIMAL,
                                                INFSTR_CFGPRI_DISABLED    , LCPRI_DISABLED,
                                                INFSTR_CFGPRI_RESTART     , LCPRI_RESTART,
                                                INFSTR_CFGPRI_REBOOT      , LCPRI_REBOOT,
                                                INFSTR_CFGPRI_POWEROFF    , LCPRI_POWEROFF,
                                                INFSTR_CFGPRI_HARDRECONFIG, LCPRI_HARDRECONFIG,
                                                INFSTR_CFGPRI_FORCECONFIG , LCPRI_FORCECONFIG,
                                                NULL                      , 0
                                             };


STRING_TO_DATA InfConfigSpecToConfig[] = {  INFSTR_CFGTYPE_BASIC   , BASIC_LOG_CONF,
                                            INFSTR_CFGTYPE_FORCED  , FORCED_LOG_CONF,
                                            INFSTR_CFGTYPE_OVERRIDE, OVERRIDE_LOG_CONF,
                                            NULL                   , 0
                                         };

//
// Declare strings used in processing INF LogConfigs.
//
// These strings are defined in infstr.h:
//
CONST TCHAR pszMemConfig[]      = INFSTR_KEY_MEMCONFIG,
            pszIOConfig[]       = INFSTR_KEY_IOCONFIG,
            pszIRQConfig[]      = INFSTR_KEY_IRQCONFIG,
            pszDMAConfig[]      = INFSTR_KEY_DMACONFIG,
            pszPcCardConfig[]   = INFSTR_KEY_PCCARDCONFIG,
            pszMfCardConfig[]   = INFSTR_KEY_MFCARDCONFIG,
            pszConfigPriority[] = INFSTR_KEY_CONFIGPRIORITY,
            pszDriverVer[]      = INFSTR_DRIVERVERSION_SECTION;


BOOL
pHexToScalar(
    IN  PCTSTR     FieldStart,
    IN  PCTSTR     FieldEnd,
    OUT PDWORDLONG Value,
    IN  BOOL       Want64Bits
    )
{
    UINT DigitCount;
    UINT i;
    DWORDLONG Accum;
    WORD Types[16];

    //
    // Make sure the number is in range by checking the number
    // of hex digits.
    //
    DigitCount = (UINT)(FieldEnd - FieldStart);
    if((DigitCount == 0)
    || (DigitCount > (UINT)(Want64Bits ? 16 : 8))
    || !GetStringTypeEx(LOCALE_SYSTEM_DEFAULT,CT_CTYPE1,FieldStart,DigitCount,Types)) {
        return(FALSE);
    }

    Accum = 0;
    for(i=0; i<DigitCount; i++) {
        if(!(Types[i] & C1_XDIGIT)) {
            return(FALSE);
        }
        Accum *= 16;
        Accum += _tcschr(pszHexDigits,(TCHAR)CharUpper((PTSTR)FieldStart[i])) - pszHexDigits;
    }

    *Value = Accum;
    return(TRUE);
}


BOOL
pHexToUlong(
    IN  PCTSTR FieldStart,
    IN  PCTSTR FieldEnd,
    OUT PDWORD Value
    )

/*++

Routine Description:

    Convert a sequence of unicode hex digits into an
    unsigned 32-bit number. Digits are validated.

Arguments:

    FieldStart - supplies pointer to unicode digit sequence.

    FieldEnd - supplies pointer to first character beyond the
        digit sequence.

    Value - receives 32-bit number

Return Value:

    TRUE if the number is in range and valid. FALSE otherwise.

--*/

{
    DWORDLONG x;
    BOOL b;

    if(b = pHexToScalar(FieldStart,FieldEnd,&x,FALSE)) {
        *Value = (DWORD)x;
    }
    return(b);
}


BOOL
pHexToUlonglong(
    IN  PCTSTR     FieldStart,
    IN  PCTSTR     FieldEnd,
    OUT PDWORDLONG Value
    )

/*++

Routine Description:

    Convert a sequence of unicode hex digits into an
    unsigned 64-bit number. Digits are validated.

Arguments:

    FieldStart - supplies pointer to unicode digit sequence.

    FieldEnd - supplies pointer to first character beyond the
        digit sequence.

    Value - receives 64-bit number

Return Value:

    TRUE if the number is in range and valid. FALSE otherwise.

--*/

{
    return(pHexToScalar(FieldStart,FieldEnd,Value,TRUE));
}


BOOL
pDecimalToUlong(
    IN  PCTSTR Field,
    OUT PDWORD Value
    )

/*++

Routine Description:

    Convert a nul-terminated sequence of unicode decimal digits into an
    unsigned 32-bit number. Digits are validated.

Arguments:

    Field - supplies pointer to unicode digit sequence.

    Value - receives DWORD number

Return Value:

    TRUE if the number is in range and valid. FALSE otherwise.

--*/

{
    UINT DigitCount;
    UINT i;
    DWORDLONG Accum;
    WORD Types[10];

    DigitCount = lstrlen(Field);
    if((DigitCount == 0) || (DigitCount > 10)
    || !GetStringTypeEx(LOCALE_SYSTEM_DEFAULT,CT_CTYPE1,Field,DigitCount,Types)) {
        return(FALSE);
    }

    Accum = 0;
    for(i=0; i<DigitCount; i++) {
        if(!(Types[i] & C1_DIGIT)) {
            return(FALSE);
        }
        Accum *= 10;
        Accum += _tcschr(pszHexDigits,(TCHAR)CharUpper((PTSTR)Field[i])) - pszHexDigits;

        //
        // Check overflow
        //
        if(Accum > 0xffffffff) {
            return(FALSE);
        }
    }

    *Value = (DWORD)Accum;
    return(TRUE);
}


DWORD
pSetupProcessMemConfig(
    IN LOG_CONF    LogConfig,
    IN PINFCONTEXT InfLine,
    IN HMACHINE        hMachine
    )

/*++

Routine Description:

    Process a MemConfig line in a Win95 INF. Such lines specify
    memory requirements for a device. Each line is expected to be
    in the form

    MemConfig = <start>-<end>[(<attr>)],<start>-<end>[(<attr>)],...

    <start> is the start of a memory range (64-bit hex)
    <end>   is the end of a memory range   (64-bit hex)
    <attr>  if present is a string of 0 or more chars from
            C - memory is combined-write
            D - memory is 32-bit, otherwise 24-bit.
            F - memory is prefetchable
            H - memory is cacheable
            R - memory is read-only
            W - memory is write-only
                (If R and W are specified or neither is specified the memory
                is read/write)

    or

    MemConfig = <size>@<min>-<max>[%align][(<attr>)],...

    <size>  is the size of a memory range (32-bit hex)
    <min>   is the minimum address where the memory range can be (64-bit hex)
    <max>   is the maximum address where the memory range can be (64-bit hex)
    <align> (if specified) is the alignment mask for the addresses (32-bit hex)
    <attr>  as above.

    ie, 8000@C0000-D7FFF%F0000 says the device needs a 32K memory window
    starting at any 64K-aligned address between C0000 and D7FFF.

    The default memory alignment is 4K (FFFFF000).

Arguments:

Return Value:

--*/

{
    UINT FieldCount,i;
    PCTSTR Field;
    DWORD d;
    PTCHAR p;
    INT u;
    UINT Attributes;
    DWORD RangeSize;
    ULARGE_INTEGER Align;
    DWORDLONG Start,End;
    PMEM_RESOURCE MemRes;
    PMEM_RANGE MemRange;
    RES_DES ResDes;
    PVOID q;
    BOOL bReadFlag = FALSE, bWriteFlag = FALSE;

    FieldCount = SetupGetFieldCount(InfLine);
    if (!FieldCount && GetLastError() != NO_ERROR) {
        return GetLastError();
    }

    if(MemRes = MyMalloc(offsetof(MEM_RESOURCE,MEM_Data))) {

        ZeroMemory(MemRes,offsetof(MEM_RESOURCE,MEM_Data));
        MemRes->MEM_Header.MD_Type = MType_Range;

        d = NO_ERROR;

    } else {
        d = ERROR_NOT_ENOUGH_MEMORY;
    }

    for(i=1; (d==NO_ERROR) && (i<=FieldCount); i++) {

        Field = pSetupGetField(InfLine,i);

        Attributes = 0;
        RangeSize = 0;
        Align.QuadPart = DEFAULT_MEMORY_ALIGNMENT;

        //
        // See if this is in the start-end or size@min-max format.
        // If we have a size, use it.
        //
        if(p = _tcschr(Field,INFCHAR_SIZE_SEP)) {
            if(pHexToUlong(Field,p,&RangeSize)) {
                Field = ++p;
            } else {
                d = ERROR_INVALID_INF_LOGCONFIG;
            }
        }

        //
        // We should now have a x-y which is either start/end or min/max.
        //
        if((d == NO_ERROR)                              // no err so far
        && (p = _tcschr(Field,INFCHAR_RANGE_SEP))       // Field: start of min; p: end of min
        && pHexToUlonglong(Field,p,&Start)              // get min
        && (Field = p+1)                                // Field: start of max
        && (   (p = _tcschr(Field,INFCHAR_ALIGN_SEP))
            || (p = _tcschr(Field,INFCHAR_ATTR_START))
            || (p = _tcschr(Field,0)))                  // p: end of max
        && pHexToUlonglong(Field,p,&End)) {             // get max
            //
            // If we get here Field is pointing either at the end of the field,
            // at the % that starts the alignment mask spec, or at the
            // ( that starts the attributes spec.
            //
            Field = p;
            if(*Field == INFCHAR_ALIGN_SEP) {
                Field++;
                p = _tcschr(Field,INFCHAR_ATTR_START);
                if(!p) {
                    p = _tcschr(Field,0);
                }
                if(pHexToUlonglong(Field, p, &(Align.QuadPart))) {
                    //
                    // NOTE:  Since these mask values are actually stored in a WDM
                    // resource list (i.e., IO_RESOURCE_REQUIREMENTS_LIST), there's
                    // no way to specify an alignment greater than 32 bits.  However,
                    // since the alignment value was implemented as a mask (for
                    // compatibility with Win9x), we must specify it as a 64-bit
                    // quantity, since it is applied to a 64-bit value.  We will check
                    // below to ensure that the most significant DWORD is all ones.
                    //
                    // Also, we must handle alignment values such as 000F0000, 00FF0000,
                    // 0FFF0000, and FFFF0000.  These all specify 64K alignment (depending
                    // on the min and max addresses, the INF writer might not need to
                    // specify all the 1 bits in the 32-bit value).
                    // Thus we perform an ersatz sign extension of sorts -- we
                    // find the highest 1 bit and replicate it into all the
                    // more significant bits in the value.
                    //
                    for(u=31; u>=0; u--) {
                        if(Align.HighPart & (1 << u)) {
                            break;
                        }
                        Align.HighPart |= (1 << u);
                    }
                    //
                    // Make sure that all the bits in the most-significant DWORD are set,
                    // because we can't express this alignment otherwise (as discussed
                    // above).  Also, make sure that if we encountered a '1' in the high
                    // dword, then the high bit of the low dword is '1' as well.
                    //
                    if((Align.HighPart ^ 0xffffffff) ||
                       ((u >= 0) && !(Align.LowPart & 0x80000000))) {

                        d = ERROR_INVALID_INF_LOGCONFIG;

                    } else {
                        //
                        // Do the sign extension for the low dword.
                        //
                        for(u=31; u>=0; u--) {
                            if(Align.LowPart & (1 << u)) {
                                break;
                            }
                            Align.LowPart |= (1 << u);
                        }
                    }

                } else {
                    d = ERROR_INVALID_INF_LOGCONFIG;
                }
            }

            //
            // See if we have attributes.
            //
            if((d == NO_ERROR) && (*p == INFCHAR_ATTR_START)) {
                Field = ++p;
                if(p = _tcschr(Field,INFCHAR_ATTR_END)) {
                    //
                    // C for combined-write
                    // D for 32-bit memory
                    // F for prefetchable
                    // H for cacheable
                    // R for readable
                    // W for writeable
                    // RW (or neither) means read/write
                    //
                    while((d == NO_ERROR) && (Field < p)) {

                        switch((TCHAR)CharUpper((PTSTR)(*Field))) {
                        case INFCHAR_MEMATTR_READ:
                            bReadFlag = TRUE;
                            break;
                        case INFCHAR_MEMATTR_WRITE:
                            bWriteFlag = TRUE;
                            break;
                        case INFCHAR_MEMATTR_PREFETCH:
                            Attributes |= fMD_PrefetchAllowed;
                            break;
                        case INFCHAR_MEMATTR_COMBINEDWRITE:
                            Attributes |= fMD_CombinedWriteAllowed;
                            break;
                        case INFCHAR_MEMATTR_DWORD:
                            Attributes |= fMD_32;
                            break;
                        case INFCHAR_MEMATTR_CACHEABLE:
                            Attributes |= fMD_Cacheable;
                            break;
                        default:
                            d = ERROR_INVALID_INF_LOGCONFIG;
                            break;
                        }

                        Field++;
                    }

                } else {
                    d = ERROR_INVALID_INF_LOGCONFIG;
                }
            }
        } else {
            d = ERROR_INVALID_INF_LOGCONFIG;
        }

        if(d == NO_ERROR) {
            //
            // If no range size was specified, then calculate it from
            // the given start and end addresses. Since this happens
            // when the memory requirement was an absolute start/end,
            // there is no alignment requirement.
            //
            if(RangeSize == 0) {
                RangeSize = (DWORD)(End-Start)+1;
                Align.QuadPart = DEFAULT_MEMORY_ALIGNMENT;
            }

            //
            // Slam values into the header part of the memory descriptor.
            // These will be ignored unless we're setting a forced config.
            // Note that the inf had better have specified forced mem configs
            // in a 'simple' form, since we throw away alignment, etc.
            //
            if (bWriteFlag && bReadFlag) {
                Attributes |=  fMD_ReadAllowed | fMD_RAM;       // read-write
            } else if (bWriteFlag && !bReadFlag) {
                Attributes |= fMD_ReadDisallowed | fMD_RAM;     // write only
            } else if (!bWriteFlag && bReadFlag) {
                Attributes |= fMD_ReadAllowed | fMD_ROM;        // read-only
            } else {
                Attributes |=  fMD_ReadAllowed | fMD_RAM;       // read-write
            }

            MemRes->MEM_Header.MD_Alloc_Base = Start;
            MemRes->MEM_Header.MD_Alloc_End = Start + RangeSize - 1;
            MemRes->MEM_Header.MD_Flags = Attributes;

            //
            // Add this guy into the descriptor we're building up.
            //
            q = MyRealloc(
                    MemRes,
                      offsetof(MEM_RESOURCE,MEM_Data)
                    + (sizeof(MEM_RANGE)*(MemRes->MEM_Header.MD_Count+1))
                    );

            if(q) {
                MemRes = q;
                MemRange = &MemRes->MEM_Data[MemRes->MEM_Header.MD_Count++];

                MemRange->MR_Align = Align.QuadPart;
                MemRange->MR_nBytes = RangeSize;
                MemRange->MR_Min = Start;
                MemRange->MR_Max = End;
                MemRange->MR_Flags = Attributes;
                MemRange->MR_Reserved = 0;

            } else {
                d = ERROR_NOT_ENOUGH_MEMORY;
            }
        }
    }

    if((d == NO_ERROR) && MemRes->MEM_Header.MD_Count) {

        d = CM_Add_Res_Des_Ex(
                &ResDes,
                LogConfig,
                ResType_Mem,
                MemRes,
                offsetof(MEM_RESOURCE,MEM_Data) + (sizeof(MEM_RANGE) * MemRes->MEM_Header.MD_Count),
                0,
                hMachine);

        d = MapCrToSpError(d, ERROR_INVALID_DATA);

        if(d == NO_ERROR) {
            CM_Free_Res_Des_Handle(ResDes);
        }
    }

    if(MemRes) {
        MyFree(MemRes);
    }

    return(d);
}


DWORD
pSetupProcessIoConfig(
    IN LOG_CONF    LogConfig,
    IN PINFCONTEXT InfLine,
    IN HMACHINE        hMachine
    )

/*++

Routine Description:

    Process an IOConfig line in a Win95 INF. Such lines specify
    IO port requirements for a device. Each line is expected to be
    in the form

    IOConfig = <start>-<end>[(<decodemask>:<aliasoffset>:<attr>)],...

    <start> is the start of a port range (64-bit hex)

    <end> is the end of a port range (64-bit hex)

    <decodemask> defines the alias type, and may be one of the following combinations:

        3ff    10-bit decode,   IOR_Alias is 0x04
        fff    12-bit decode,   IOR_Alias is 0x10
        ffff   16-bit decode,   IOR_Alias is 0x00
        0      positive decode, IOR_Alias is 0xFF

    <aliasoffset> is ignored.

    <attr> if 'M', specifies port is a memory address, otherwise port is an IO address.

    or

    IOConfig = <size>@<min>-<max>[%align][(<decodemask>:<aliasoffset>:<attr>)],...

    <size>  is the size of a port range (32-bit hex)
    <min>   is the minimum port where the memory range can be (64-bit hex)
    <max>   is the maximum port where the memory range can be (64-bit hex)
    <align> (if specified) is the alignment mask for the ports (32-bit hex)
    <decodemask>, <aliasoffset>,<attr> as above

    ie, IOConfig = 1F8-1FF(3FF::),2F8-2FF(3FF::),3F8-3FF(3FF::)
        IOConfig = 8@300-32F%FF8(3FF::)
        IOConfig = 2E8-2E8(3FF:8000:)

Arguments:

Return Value:

--*/

{
    UINT FieldCount,i;
    PCTSTR Field;
    DWORD d;
    PTCHAR p;
    INT u;
    DWORD RangeSize;
    ULARGE_INTEGER Align;
    DWORDLONG Decode;
    DWORDLONG Start,End;
    BOOL GotSize;
    PIO_RESOURCE IoRes;
    PIO_RANGE IoRange;
    RES_DES ResDes;
    PVOID q;
    UINT Attributes = 0;
    PTCHAR Attr;

    FieldCount = SetupGetFieldCount(InfLine);
    if (!FieldCount && GetLastError() != NO_ERROR) {
        return GetLastError();
    }

    if(IoRes = MyMalloc(offsetof(IO_RESOURCE,IO_Data))) {

        ZeroMemory(IoRes,offsetof(IO_RESOURCE,IO_Data));
        IoRes->IO_Header.IOD_Type = IOType_Range;

        d = NO_ERROR;

    } else {
        d = ERROR_NOT_ENOUGH_MEMORY;
    }

    for(i=1; (d==NO_ERROR) && (i<=FieldCount); i++) {

        Field = pSetupGetField(InfLine,i);

        Attributes = fIOD_IO;
        Decode = DEFAULT_IOPORT_DECODE;
        RangeSize = 0;
        Align.QuadPart = DEFAULT_IOPORT_ALIGNMENT;

        //
        // See if this is in the start-end or size@min-max format.
        // If we have a size, use it.
        //
        if(p = _tcschr(Field,INFCHAR_SIZE_SEP)) {
            if(pHexToUlong(Field,p,&RangeSize)) {
                Field = ++p;
            } else {
                d = ERROR_INVALID_INF_LOGCONFIG;
            }
        }

        //
        // We should now have a x-y which is either start/end or min/max.
        //
        if((d == NO_ERROR)                              // no err so far
        && (p = _tcschr(Field,INFCHAR_RANGE_SEP))       // Field: start of min; p: end of min
        && pHexToUlonglong(Field,p,&Start)              // get min
        && (Field = p+1)                                // Field: start of max
        && (   (p = _tcschr(Field,INFCHAR_ALIGN_SEP))
            || (p = _tcschr(Field,INFCHAR_DECODE_START))
            || (p = _tcschr(Field,0)))                  // p: end of max
        && pHexToUlonglong(Field,p,&End)) {             // get max
            //
            // If we get here Field is pointing either at the end of the field,
            // or at the % that starts the alignment mask spec,
            // or at the ( that starts the decode stuff.
            //
            Field = p;
            switch(*Field) {
            case INFCHAR_ALIGN_SEP:
                Field++;


                p = _tcschr(Field,INFCHAR_ATTR_START);
                if(!p) {
                    p = _tcschr(Field,0);
                }
                if(pHexToUlonglong(Field, p, &(Align.QuadPart))) {
                    //
                    // NOTE:  Since these mask values are actually stored in a WDM
                    // resource list (i.e., IO_RESOURCE_REQUIREMENTS_LIST), there's
                    // no way to specify an alignment greater than 32 bits.  However,
                    // since the alignment value was implemented as a mask (for
                    // compatibility with Win9x), we must specify it as a 64-bit
                    // quantity, since it is applied to a 64-bit value.  We will check
                    // below to ensure that the most significant DWORD is all ones.
                    //
                    // Also, we must handle alignment values such as 000F0000, 00FF0000,
                    // 0FFF0000, and FFFF0000.  These all specify 64K alignment (depending
                    // on the min and max addresses, the INF writer might not need to
                    // specify all the 1 bits in the 32-bit value).
                    // Thus we perform an ersatz sign extension of sorts -- we
                    // find the highest 1 bit and replicate it into all the
                    // more significant bits in the value.
                    //
                    for(u=31; u>=0; u--) {
                        if(Align.HighPart & (1 << u)) {
                            break;
                        }
                        Align.HighPart |= (1 << u);
                    }
                    //
                    // Make sure that all the bits in the most-significant DWORD are set,
                    // because we can't express this alignment otherwise (as discussed
                    // above).  Also, make sure that if we encountered a '1' in the high
                    // dword, then the high bit of the low dword is '1' as well.
                    //
                    if((Align.HighPart ^ 0xffffffff) ||
                       ((u >= 0) && !(Align.LowPart & 0x80000000))) {

                        d = ERROR_INVALID_INF_LOGCONFIG;

                    } else {
                        //
                        // Do the sign extension for the low dword.
                        //
                        for(u=31; u>=0; u--) {
                            if(Align.LowPart & (1 << u)) {
                                break;
                            }
                            Align.LowPart |= (1 << u);
                        }
                    }

                } else {
                    d = ERROR_INVALID_INF_LOGCONFIG;
                }
                break;

            case INFCHAR_DECODE_START:
                //
                // Get decode value (this determines the IOR_Alias that gets filled
                // in for the resdes.
                //
                Field++;
                p = _tcschr(Field,INFCHAR_DECODE_SEP);
                if (p) {
                    if (Field != p) {
                        pHexToUlonglong(Field,p,&Decode);     // got decode value
                    }
                    Field = p+1;
                    p = _tcschr(Field,INFCHAR_DECODE_SEP);
                    if (p) {
                        //
                        // Ignore alias field.
                        //
                        Field = p+1;
                        p = _tcschr(Field,INFCHAR_DECODE_END);
                        if (p) {
                            if (Field != p) {
                                if (*Field == INFCHAR_IOATTR_MEMORY) {
                                    Attributes = fIOD_Memory; // got attribute value
                                }
                            }
                        } else {
                            d = ERROR_INVALID_INF_LOGCONFIG;
                        }
                    } else {
                        d = ERROR_INVALID_INF_LOGCONFIG;
                    }
                } else {
                    d = ERROR_INVALID_INF_LOGCONFIG;
                }
                break;
            }
        } else {
            d = ERROR_INVALID_INF_LOGCONFIG;
        }

        if(d == NO_ERROR) {
            //
            // If no range size was specified, then calculate it from
            // the given start and end addresses. Since this happens
            // when the port requirement was an absolute start/end,
            // there is no alignment requirement (i.e., the default
            // byte-alignment should be specified).
            //
            if(RangeSize == 0) {
                RangeSize = (DWORD)(End-Start)+1;
                Align.QuadPart = DEFAULT_IOPORT_ALIGNMENT;
            }

            //
            // Create an alternate decode flag
            //
            switch(Decode) {

                case INFLOGCONF_IOPORT_10BIT_DECODE:
                    Attributes |= fIOD_10_BIT_DECODE;
                    break;

                case INFLOGCONF_IOPORT_12BIT_DECODE:
                    Attributes |= fIOD_12_BIT_DECODE;
                    break;

                case INFLOGCONF_IOPORT_16BIT_DECODE:
                    Attributes |= fIOD_16_BIT_DECODE;
                    break;

                case INFLOGCONF_IOPORT_POSITIVE_DECODE:
                    Attributes |= fIOD_POSITIVE_DECODE;
                    break;
            }
            //
            // Slam values into the header part of the i/o descriptor.
            // These will be ignored unless we're setting a forced config.
            // Note that the inf had better have specified forced i/o configs
            // in a 'simple' form, since we throw away alignment, etc.
            //
            IoRes->IO_Header.IOD_Alloc_Base = Start;
            IoRes->IO_Header.IOD_Alloc_End = Start + RangeSize - 1;
            IoRes->IO_Header.IOD_DesFlags = Attributes;

            //
            // Add this guy into the descriptor we're building up.
            //
            q = MyRealloc(
                    IoRes,
                      offsetof(IO_RESOURCE,IO_Data)
                    + (sizeof(IO_RANGE)*(IoRes->IO_Header.IOD_Count+1))
                    );

            if(q) {
                IoRes = q;
                IoRange = &IoRes->IO_Data[IoRes->IO_Header.IOD_Count++];

                IoRange->IOR_Align = Align.QuadPart;
                IoRange->IOR_nPorts = RangeSize;
                IoRange->IOR_Min = Start;
                IoRange->IOR_Max = End;
                IoRange->IOR_RangeFlags = Attributes;

                switch(Decode) {

                    case INFLOGCONF_IOPORT_10BIT_DECODE:
                        IoRange->IOR_Alias = IO_ALIAS_10_BIT_DECODE;
                        break;

                    case INFLOGCONF_IOPORT_12BIT_DECODE:
                        IoRange->IOR_Alias = IO_ALIAS_12_BIT_DECODE;
                        break;

                    case INFLOGCONF_IOPORT_16BIT_DECODE:
                        IoRange->IOR_Alias = IO_ALIAS_16_BIT_DECODE;
                        break;

                    case INFLOGCONF_IOPORT_POSITIVE_DECODE:
                        IoRange->IOR_Alias = IO_ALIAS_POSITIVE_DECODE;
                        break;

                    default:
                        d = ERROR_INVALID_INF_LOGCONFIG;
                        break;
                }

            } else {
                d = ERROR_NOT_ENOUGH_MEMORY;
            }
        }
    }

    if((d == NO_ERROR) && IoRes->IO_Header.IOD_Count) {

        d = CM_Add_Res_Des_Ex(
                &ResDes,
                LogConfig,
                ResType_IO,
                IoRes,
                offsetof(IO_RESOURCE,IO_Data) + (sizeof(IO_RANGE) * IoRes->IO_Header.IOD_Count),
                0,
                hMachine);

        d = MapCrToSpError(d, ERROR_INVALID_DATA);

        if(d == NO_ERROR) {
            CM_Free_Res_Des_Handle(ResDes);
        }
    }

    if(IoRes) {
        MyFree(IoRes);
    }

    return(d);
}


DWORD
pSetupProcessIrqConfig(
    IN LOG_CONF    LogConfig,
    IN PINFCONTEXT InfLine,
    IN HMACHINE    hMachine
    )

/*++

Routine Description:

    Process an IRQConfig line in a Win95 INF. Such lines specify
    IRQ requirements for a device. Each line is expected to be
    in the form

    IRQConfig = [[S][L]:]<IRQNum>,...

    S: if present indicates that the interrupt is shareable
    L: if present indicates that the interrupt is Level sensitive,
       otherwise it is assumed to be edge sensitive.
    IRQNum is the IRQ number in decimal.

Arguments:

Return Value:

--*/

{
    UINT FieldCount,i;
    PCTSTR Field;
    DWORD d;
    BOOL Shareable;
    BOOL Level;
    DWORD Irq;
    PIRQ_RESOURCE IrqRes;
    PIRQ_RANGE IrqRange;
    RES_DES ResDes;
    PVOID q;

    FieldCount = SetupGetFieldCount(InfLine);
    if (!FieldCount && GetLastError() != NO_ERROR) {
        return GetLastError();
    }

    if(IrqRes = MyMalloc(offsetof(IRQ_RESOURCE,IRQ_Data))) {

        ZeroMemory(IrqRes,offsetof(IRQ_RESOURCE,IRQ_Data));
        IrqRes->IRQ_Header.IRQD_Type = IRQType_Range;

        d = NO_ERROR;

    } else {
        d = ERROR_NOT_ENOUGH_MEMORY;
    }

    Shareable = FALSE;
    Level = FALSE;
    for(i=1; (d==NO_ERROR) && (i<=FieldCount); i++) {

        Field = pSetupGetField(InfLine,i);

        //
        // For first field, see if we have S: by itself...
        //
        if((i == 1)
        &&((TCHAR)CharUpper((PTSTR)Field[0]) == INFCHAR_IRQATTR_SHARE)
        && (Field[1] == INFCHAR_IRQATTR_SEP)) {

            Shareable = TRUE;
            Field+=2;
        }

        //
        // ... see if we have an L: by itself...
        //
        if((i == 1)
        &&((TCHAR)CharUpper((PTSTR)Field[0]) == INFCHAR_IRQATTR_LEVEL)
        && (Field[1] == INFCHAR_IRQATTR_SEP)) {

            Level = TRUE;
            Field+=2;
        }

        //
        // ... see if we have both attributes.
        //
        if((i == 1)
        && (Field[2] == INFCHAR_IRQATTR_SEP)) {

            if (((TCHAR)CharUpper((PTSTR)Field[0]) == INFCHAR_IRQATTR_SHARE)
            ||   (TCHAR)CharUpper((PTSTR)Field[1]) == INFCHAR_IRQATTR_SHARE) {

                Shareable = TRUE;
            }

            if (((TCHAR)CharUpper((PTSTR)Field[0]) == INFCHAR_IRQATTR_LEVEL)
            ||   (TCHAR)CharUpper((PTSTR)Field[1]) == INFCHAR_IRQATTR_LEVEL) {

                Level = TRUE;
            }
            Field+=3;
        }

        if(pDecimalToUlong(Field,&Irq)) {

            //
            // Slam values into the header part of the irq descriptor.
            // These will be ignored unless we're setting a forced config.
            //
            IrqRes->IRQ_Header.IRQD_Flags = Shareable ? fIRQD_Share : fIRQD_Exclusive;
            IrqRes->IRQ_Header.IRQD_Flags |= Level ? fIRQD_Level : fIRQD_Edge;
            IrqRes->IRQ_Header.IRQD_Alloc_Num = Irq;
            IrqRes->IRQ_Header.IRQD_Affinity = DEFAULT_IRQ_AFFINITY;

            //
            // Add this guy into the descriptor we're building up.
            //
            q = MyRealloc(
                    IrqRes,
                      offsetof(IRQ_RESOURCE,IRQ_Data)
                    + (sizeof(IRQ_RANGE)*(IrqRes->IRQ_Header.IRQD_Count+1))
                    );

            if(q) {
                IrqRes = q;
                IrqRange = &IrqRes->IRQ_Data[IrqRes->IRQ_Header.IRQD_Count++];

                IrqRange->IRQR_Min = Irq;
                IrqRange->IRQR_Max = Irq;
                IrqRange->IRQR_Flags = Shareable ? fIRQD_Share : fIRQD_Exclusive;
                IrqRange->IRQR_Flags |= Level ? fIRQD_Level : fIRQD_Edge;

            } else {
                d = ERROR_NOT_ENOUGH_MEMORY;
            }
        } else {
            d = ERROR_INVALID_INF_LOGCONFIG;
        }
    }

    if((d == NO_ERROR) && IrqRes->IRQ_Header.IRQD_Count) {

        d = CM_Add_Res_Des_Ex(
                &ResDes,
                LogConfig,
                ResType_IRQ,
                IrqRes,
                offsetof(IRQ_RESOURCE,IRQ_Data) + (sizeof(IRQ_RANGE) * IrqRes->IRQ_Header.IRQD_Count),
                0,
                hMachine);

        d = MapCrToSpError(d, ERROR_INVALID_DATA);

        if(d == NO_ERROR) {
            CM_Free_Res_Des_Handle(ResDes);
        }
    }

    if(IrqRes) {
        MyFree(IrqRes);
    }

    return(d);
}


DWORD
pSetupProcessDmaConfig(
    IN LOG_CONF    LogConfig,
    IN PINFCONTEXT InfLine,
    IN HMACHINE    hMachine
    )

/*++

Routine Description:

    Process a DMAConfig line in a Win95 INF. Such lines specify
    DMA requirements for a device. Each line is expected to be
    in the form

    DMAConfig = [<attrs>:]<DMANum>,...

    if <attrs> is present it can be
        D - 32-bit DMA channel
        W - 16-bit DMA channel
        N - 8-bit DMA channel (default).  Specify both W and N if 8- and 16-bit DMA is supported.
        M - Bus Mastering
        A - Type-A DMA channel
        B - Type-B DMA channel
        F - Type-F DMA channel
        (If none of A, B, or F are specified, then standard DMA is assumed)

    DMANum is the DMA channel number in decimal.

Arguments:

Return Value:

--*/

{
    UINT FieldCount,i;
    PCTSTR Field;
    DWORD d;
    DWORD Dma;
    INT ChannelSize;       // fDD_ xxx flags for channel width
    INT DmaType;           // fDD_ xxx flags for DMA type
    PDMA_RESOURCE DmaRes;
    PDMA_RANGE DmaRange;
    RES_DES ResDes;
    PVOID q;
    PTCHAR p;
    BOOL BusMaster;
    ULONG DmaFlags;

    ChannelSize = -1;
    BusMaster = FALSE;
    DmaType = -1;

    FieldCount = SetupGetFieldCount(InfLine);
    if (!FieldCount && GetLastError() != NO_ERROR) {
        return GetLastError();
    }

    if(DmaRes = MyMalloc(offsetof(DMA_RESOURCE,DMA_Data))) {

        ZeroMemory(DmaRes,offsetof(DMA_RESOURCE,DMA_Data));
        DmaRes->DMA_Header.DD_Type = DType_Range;

        d = NO_ERROR;

    } else {
        d = ERROR_NOT_ENOUGH_MEMORY;
    }

    for(i=1; (d==NO_ERROR) && (i<=FieldCount); i++) {

        Field = pSetupGetField(InfLine,i);

        //
        // For first field, see if we have attribute spec.
        //
        if(i == 1) {

            if(p = _tcschr(Field, INFCHAR_IRQATTR_SEP)) {

                for( ;((d == NO_ERROR) && (Field < p)); Field++) {

                    switch((TCHAR)CharUpper((PTSTR)(*Field))) {

                        //
                        // Channel size can be both 8 and 16 (i.e., both 'W' and 'N'), but
                        // you can't mix these with 'D'.
                        //
                        case INFCHAR_DMAWIDTH_WORD:
                            if(ChannelSize == fDD_DWORD) {
                                d = ERROR_INVALID_INF_LOGCONFIG;
                            } else if(ChannelSize == fDD_BYTE) {
                                ChannelSize = fDD_BYTE_AND_WORD;
                            } else {
                                ChannelSize = fDD_WORD;
                            }
                            break;

                        case INFCHAR_DMAWIDTH_DWORD:
                            if((ChannelSize != -1) && (ChannelSize != fDD_DWORD)) {
                                d = ERROR_INVALID_INF_LOGCONFIG;
                            } else {
                                ChannelSize = fDD_DWORD;
                            }
                            break;

                        case INFCHAR_DMAWIDTH_NARROW:
                            if(ChannelSize == fDD_DWORD) {
                                d = ERROR_INVALID_INF_LOGCONFIG;
                            } else if(ChannelSize == fDD_WORD) {
                                ChannelSize = fDD_BYTE_AND_WORD;
                            } else {
                                ChannelSize = fDD_BYTE;
                            }
                            break;

                        case INFCHAR_DMA_BUSMASTER:
                            BusMaster = TRUE;
                            break;

                        //
                        // The DMA types are mutually exclusive...
                        //
                        case INFCHAR_DMATYPE_A:
                            if((DmaType != -1) && (DmaType != fDD_TypeA)) {
                                d = ERROR_INVALID_INF_LOGCONFIG;
                            } else {
                                DmaType = fDD_TypeA;
                            }
                            break;

                        case INFCHAR_DMATYPE_B:
                            if((DmaType != -1) && (DmaType != fDD_TypeB)) {
                                d = ERROR_INVALID_INF_LOGCONFIG;
                            } else {
                                DmaType = fDD_TypeB;
                            }
                            break;

                        case INFCHAR_DMATYPE_F:
                            if((DmaType != -1) && (DmaType != fDD_TypeF)) {
                                d = ERROR_INVALID_INF_LOGCONFIG;
                            } else {
                                DmaType = fDD_TypeF;
                            }
                            break;

                        default:
                            d = ERROR_INVALID_INF_LOGCONFIG;
                            break;
                    }
                }

                Field++;    // skip over separator character
            }

            if(ChannelSize == -1) {
                DmaFlags = fDD_BYTE; // default is 8-bit DMA
            } else {
                DmaFlags = (ULONG)ChannelSize;
            }

            if(BusMaster) {
                DmaFlags |= fDD_BusMaster;
            }

            if(DmaType != -1) {
                DmaFlags |= DmaType;
            }
        }

        if(d == NO_ERROR) {
            if(pDecimalToUlong(Field,&Dma)) {

                //
                // Slam values into the header part of the dma descriptor.
                // These will be ignored unless we're setting a forced config.
                //
                DmaRes->DMA_Header.DD_Flags = DmaFlags;
                DmaRes->DMA_Header.DD_Alloc_Chan = Dma;

                //
                // Add this guy into the descriptor we're building up.
                //
                q = MyRealloc(
                        DmaRes,
                          offsetof(DMA_RESOURCE,DMA_Data)
                        + (sizeof(DMA_RANGE)*(DmaRes->DMA_Header.DD_Count+1))
                        );

                if(q) {
                    DmaRes = q;
                    DmaRange = &DmaRes->DMA_Data[DmaRes->DMA_Header.DD_Count++];

                    DmaRange->DR_Min = Dma;
                    DmaRange->DR_Max = Dma;
                    DmaRange->DR_Flags = DmaFlags;

                } else {
                    d = ERROR_NOT_ENOUGH_MEMORY;
                }
            } else {
                d = ERROR_INVALID_INF_LOGCONFIG;
            }
        }
    }

    if((d == NO_ERROR) && DmaRes->DMA_Header.DD_Count) {

        d = CM_Add_Res_Des_Ex(
                &ResDes,
                LogConfig,
                ResType_DMA,
                DmaRes,
                offsetof(DMA_RESOURCE,DMA_Data) + (sizeof(DMA_RANGE) * DmaRes->DMA_Header.DD_Count),
                0,
                hMachine);

        d = MapCrToSpError(d, ERROR_INVALID_DATA);

        if(d == NO_ERROR) {
            CM_Free_Res_Des_Handle(ResDes);
        }
    }

    if(DmaRes) {
        MyFree(DmaRes);
    }

    return(d);
}


DWORD
pSetupProcessPcCardConfig(
    IN LOG_CONF    LogConfig,
    IN PINFCONTEXT InfLine,
    IN HMACHINE    hMachine
    )

/*++

Routine Description:

    Process a PcCardConfig line in a Win95 INF.  Such lines specify
    PC Card (PCMCIA) configuration information necessary for a device.
    Each line is expected to be in the form

    PcCardConfig = <ConfigIndex>[:[<MemoryCardBase1>][:<MemoryCardBase2>]][(<attrs>)]

    where

        <ConfigIndex> is the 8-bit PCMCIA configuration index

        <MemoryCardBase1> is the (optional) 32-bit 1st memory base address

        <MemoryCardBase2> is the (optional) 32-bit 2nd memory base address

        <attrs> is a combination of attribute specifiers optionally separated by
                spaces. The attribute string is processed from left to right,
                and an invalid attribute specifier aborts the entire PcCardConfig
                directive. Attributes may be specified in any order except for the
                positional attributes 'A' and 'C', which are described below.

                Accepted attribute specifiers are as follows:

                W   - 16-bit I/O data path (default: 16-bit)
                B   - 8-bit I/O data path (default: 16-bit)

                Sn  - ~IOCS16 source. If n is zero, ~IOCS16 is based on the value of
                      the datasize bit. If n is one, ~IOCS16 is based on the ~IOIS16
                      signal from the device. (default: 1)

                Zn  - I/O 8-bit zero wait state. If n is one, 8-bit I/O accesses occur
                      with zero additional wait states. If n is zero, access will
                      occur with additional wait states. This flag has no meaning for
                      16-bit I/O. (default: 0)

                XIn - I/O wait states. If n is one, 16-bit system accesses occur with
                      1 additional wait state. (default: 1)

                M   - 16-bit Memory (default: 8-bit)
                M8  - 8-bit Memory (default: 8-bit)

                XMn - Memory wait states, where n can be 0, 1, 2 or 3. This value
                      determines the number of additional wait states for 16-bit
                      accesses to a memory window. (default: 3)

                    NOTE: The following two attributes relate positionally to memory
                    windows resources. That is, the first 'A' or 'C' specified in the
                    attribute string (reading from left to right) corresponds to the
                    first memory resource in the device's resource list. The next
                    'A' or 'C' corresponds to the second memory resource. Subsequent
                    attribute/common memory specifiers are ignored.

                A - Memory range to be mapped as Attribute memory
                C - Memory range to be mapped as Common Memory (default)

                Example:
                (W CA M XM1 XI0) translates to:
                    I/O 16bit
                    1st memory window is common
                    2nd memory window is attribute
                    Memory 16 bit
                    one wait state on memory windows
                    zero wait states on i/o windows

    All numeric values are assumed to be in hexadecimal format.

Arguments:

Return Value:

--*/

{
    PCCARD_RESOURCE PcCardResource;
    PCTSTR Field, p;
    DWORD ConfigIndex, i, d;

    DWORD MemoryCardBase[PCD_MAX_MEMORY] = {0};
    DWORD Flags;

    UINT memAttrIndex = 0, memWaitIndex = 0, memWidthIndex = 0;
    UINT ioSourceIndex = 0, ioZeroWait8Index = 0, ioWaitState16Index = 0, ioWidthIndex = 0;
    UINT index;
    RES_DES ResDes;

    //
    // Assume failure
    //
    d = ERROR_INVALID_INF_LOGCONFIG;

    //
    // We should have one field (not counting the line's key)
    //
    if(SetupGetFieldCount(InfLine) != 1) {
        goto clean0;
    } else {
        Field = pSetupGetField(InfLine, 1);
    }

    //
    // Retrieve the ConfigIndex.  It may be terminated by either a colon ':',
    // an open paren '(', or eol.
    //
    if(!(p = _tcschr(Field, INFCHAR_PCCARD_SEP)) && !(p = _tcschr(Field, INFCHAR_ATTR_START))) {
        p = Field + lstrlen(Field);
    }

    if(!pHexToUlong(Field, p, &ConfigIndex) || (ConfigIndex > 255)) {
        goto clean0;
    }

    //
    // Process the (optional) memory card base addresses
    //
    for(i = 0; i < PCD_MAX_MEMORY; i++) {

        if(*p == INFCHAR_PCCARD_SEP) {

            Field = p + 1;
            if(!(p = _tcschr(Field, INFCHAR_PCCARD_SEP)) && !(p = _tcschr(Field, INFCHAR_ATTR_START))) {
                p = Field + lstrlen(Field);
            }

            //
            // Allow an empty field.
            //
            if(Field == p) {
                MemoryCardBase[i] = 0;
            } else if(!pHexToUlong(Field, p, &(MemoryCardBase[i]))) {
                goto clean0;
            }

        } else {
            MemoryCardBase[i] = 0;
        }
    }

    //
    // Initialize the flags
    //

    Flags = fPCD_ATTRIBUTES_PER_WINDOW |
            fPCD_MEM1_WS_THREE | fPCD_MEM2_WS_THREE |
            fPCD_IO1_SRC_16 | fPCD_IO2_SRC_16 |
            fPCD_IO1_WS_16 | fPCD_IO2_WS_16;

    if(*p && (*p == INFCHAR_ATTR_START)) {

        //
        // Read the attributes.
        //  W   - 16-bit I/O data path
        //  B   - 8-bit I/O data path
        //  Sn  - ~IOCS16 source.
        //  Zn  - I/O 8-bit zero wait state.
        //  XIn - I/O wait states.
        //  M   - 16-bit Memory
        //  M8  - 8-bit Memory
        //  XMn - Memory wait states
        //  A   - Attribute Memory
        //  C   - Common Memory
        //

        Field = ++p;
        if(!(p = _tcschr(Field,INFCHAR_ATTR_END))) {
            goto clean0;
        }

        while(Field < p) {

            switch((TCHAR)CharUpper((PTSTR)(*Field))) {

            case INFCHAR_PCCARD_IOATTR_WORD:
                if (ioWidthIndex >= PCD_MAX_IO) {
                    goto clean0;
                }
                Flags |= (ioWidthIndex++ ? fPCD_IO2_16
                                         : (fPCD_IO1_16 | fPCD_IO2_16));
                break;

            case INFCHAR_PCCARD_IOATTR_BYTE:
                if (ioWidthIndex >= PCD_MAX_IO) {
                    goto clean0;
                }
                Flags &= (ioWidthIndex++ ? ~fPCD_IO2_16
                                         : ~(fPCD_IO1_16 | fPCD_IO2_16));
                break;

            case INFCHAR_PCCARD_MEMATTR_WORD:
                if (memWidthIndex >= PCD_MAX_MEMORY) {
                    goto clean0;
                }
                if (++Field < p) {
                    if (*Field == TEXT('8')) {
                        Flags &= (memWidthIndex++ ? ~fPCD_MEM2_16
                                                  : ~(fPCD_MEM1_16 | fPCD_MEM2_16));
                        break;
                    }
                    // not an 8, back up 1
                    --Field;
                }
                Flags |= (memWidthIndex++ ? fPCD_MEM2_16
                                          : (fPCD_MEM1_16 | fPCD_MEM2_16));
                break;

            case INFCHAR_PCCARD_MEM_ISATTR:
                if (memAttrIndex >= PCD_MAX_MEMORY) {
                    goto clean0;
                }
                Flags |= (memAttrIndex++ ? fPCD_MEM2_A
                                         : (fPCD_MEM1_A | fPCD_MEM2_A));
                break;

            case INFCHAR_PCCARD_MEM_ISCOMMON:
                if (memAttrIndex >= PCD_MAX_MEMORY) {
                    goto clean0;
                }
                Flags &= (memAttrIndex++ ? ~fPCD_MEM2_A
                                         : ~(fPCD_MEM1_A | fPCD_MEM2_A));
                break;

            case INFCHAR_PCCARD_IOATTR_SRC:
                if (ioSourceIndex >= PCD_MAX_IO) {
                    goto clean0;
                }
                if (++Field < p) {
                    if (*Field == TEXT('0')) {
                        Flags &= (ioSourceIndex++ ? ~fPCD_IO2_SRC_16
                                                  : ~(fPCD_IO1_SRC_16 | fPCD_IO2_SRC_16));
                    } else if (*Field == TEXT('1')) {
                        Flags |= (ioSourceIndex++ ? fPCD_IO2_SRC_16
                                                  : (fPCD_IO1_SRC_16 | fPCD_IO2_SRC_16));
                    } else {
                        goto clean0;
                    }
                }
                break;

            case INFCHAR_PCCARD_IOATTR_Z8:
                if (ioZeroWait8Index >= PCD_MAX_IO) {
                    goto clean0;
                }
                if (++Field < p) {
                    if (*Field == TEXT('0')) {
                        Flags &= (ioZeroWait8Index++ ? ~fPCD_IO2_ZW_8
                                                     : ~(fPCD_IO1_ZW_8 | fPCD_IO2_ZW_8));
                    } else if (*Field == TEXT('1')) {
                        Flags |= (ioZeroWait8Index++ ? fPCD_IO2_ZW_8
                                                     : (fPCD_IO1_ZW_8 | fPCD_IO2_ZW_8));
                    } else {
                        goto clean0;
                    }
                }
                break;

            case INFCHAR_PCCARD_ATTR_WAIT:
                if (++Field < p) {

                    switch((TCHAR)CharUpper((PTSTR)(*Field))) {

                    case INFCHAR_PCCARD_ATTR_WAITI:
                        if (ioWaitState16Index >= PCD_MAX_IO) {
                            goto clean0;
                        }
                        if (++Field < p) {
                            if (*Field == TEXT('0')) {
                                Flags &= (ioWaitState16Index++ ? ~fPCD_IO2_WS_16
                                                               : ~(fPCD_IO1_WS_16 | fPCD_IO2_WS_16));
                            } else if (*Field == TEXT('1')) {
                                Flags |= (ioWaitState16Index++ ? fPCD_IO2_WS_16
                                                               : (fPCD_IO1_WS_16 | fPCD_IO2_WS_16));
                            } else {
                                goto clean0;
                            }
                        }
                        break;

                    case INFCHAR_PCCARD_ATTR_WAITM:
                        if (memWaitIndex >= PCD_MAX_MEMORY) {
                            goto clean0;
                        }
                        if (++Field < p) {

                            Flags &= (memWaitIndex ? ~mPCD_MEM2_WS
                                                   : ~(mPCD_MEM1_WS | mPCD_MEM2_WS));

                            if (*Field == TEXT('0')) {
                                memWaitIndex++;
                            } else if (*Field == TEXT('1')) {
                                Flags |= (memWaitIndex++ ? fPCD_MEM2_WS_ONE
                                                         : (fPCD_MEM1_WS_ONE | fPCD_MEM2_WS_ONE));
                            } else if (*Field == TEXT('2')) {
                                Flags |= (memWaitIndex++ ? fPCD_MEM2_WS_TWO
                                                         : (fPCD_MEM1_WS_TWO | fPCD_MEM2_WS_TWO));
                            } else if (*Field == TEXT('3')) {
                                Flags |= (memWaitIndex++ ? fPCD_MEM2_WS_THREE
                                                         : (fPCD_MEM1_WS_THREE | fPCD_MEM2_WS_THREE));
                            } else {
                                goto clean0;
                            }

                        }
                        break;

                    default:
                        goto clean0;
                    }
                }
                break;

            case INFCHAR_PCCARD_ATTR_SEP:
                break;

            default:
                // unknown character
                goto clean0;
            }
            if (Field < p) {
                Field++;
            }
        }
    }

    //
    // If we get to here, then we've successfully retrieved all the necessary information
    // needed to initialize the PC Card configuration resource descriptor.
    //
    ZeroMemory(&PcCardResource, sizeof(PcCardResource));

    PcCardResource.PcCard_Header.PCD_Count = 1;
    PcCardResource.PcCard_Header.PCD_Flags = Flags;
    PcCardResource.PcCard_Header.PCD_ConfigIndex = (BYTE)ConfigIndex;
    PcCardResource.PcCard_Header.PCD_MemoryCardBase1 = MemoryCardBase[0];
    PcCardResource.PcCard_Header.PCD_MemoryCardBase2 = MemoryCardBase[1];

    d = CM_Add_Res_Des_Ex(
            &ResDes,
            LogConfig,
            ResType_PcCardConfig,
            &PcCardResource,
            sizeof(PcCardResource),
            0,
            hMachine);

    d = MapCrToSpError(d, ERROR_INVALID_DATA);

    if(d == NO_ERROR) {
        CM_Free_Res_Des_Handle(ResDes);
    }

clean0:
    return d;
}


DWORD
pSetupProcessMfCardConfig(
    IN LOG_CONF    LogConfig,
    IN PINFCONTEXT InfLine,
    IN HMACHINE    hMachine
    )

/*++

Routine Description:

    Process a MfCardConfig line in a Win95 INF.  Such lines specify
    PCMCIA Multifunction card configuration information necessary for a device.
    There should normally be one MfCardConfig line per function. Each line is expected
    to be in the form:

    MfCardConfig = <ConfigRegBase>:<ConfigOptions>[:<IoResourceIndex>][(<attrs>)]

    where

        <ConfigRegBase> is the attribute offset of this function's
                        configuration registers

        <ConfigOptions> is the 8-bit PCMCIA configuration option register

        <IoResourceIndex> is the (optional) index to the Port Io resource descriptor
                          which will be used to program the configuration I/O base
                          and limit registers

        <attrs> is the optional set of attribute flags which can consist of:

                A - Audio enable should be set on in the configuration and status register

    All numeric values are assumed to be in hexadecimal format.

Arguments:

Return Value:

--*/

{
    MFCARD_RESOURCE MfCardResource;
    PCTSTR Field, p;
    DWORD ConfigOptions, i;
    DWORD ConfigRegisterBase, IoResourceIndex;
    DWORD Flags = 0;
    DWORD d = NO_ERROR;
    RES_DES ResDes;


    //
    // We should have one field (not counting the line's key)
    //
    if(SetupGetFieldCount(InfLine) != 1) {
        d = ERROR_INVALID_INF_LOGCONFIG;
    }

    if (d == NO_ERROR) {
        //
        // Retrieve the ConfigRegisterBase. It must be terminated by a colon.
        //
        Field = pSetupGetField(InfLine, 1);

        p = _tcschr(Field, INFCHAR_PCCARD_SEP);

        if(!p || !pHexToUlong(Field, p, &ConfigRegisterBase)) {
            d = ERROR_INVALID_INF_LOGCONFIG;
        }
    }

    if (d == NO_ERROR) {
        //
        // Retrieve the ConfigOptions.  It may be terminated by either a colon ':',
        // an open paren '(', or eol.
        //
        Field = p + 1;

        if(!(p = _tcschr(Field, INFCHAR_PCCARD_SEP)) && !(p = _tcschr(Field, INFCHAR_ATTR_START))) {
            p = Field + lstrlen(Field);
        }

        if(!pHexToUlong(Field, p, &ConfigOptions) || (ConfigOptions > 255)) {
            d = ERROR_INVALID_INF_LOGCONFIG;
        }
    }

    if ((d == NO_ERROR) && (*p == INFCHAR_PCCARD_SEP)) {
        //
        // Retrieve the IoResourceIndex. It may be terminated by either
        // an open paren '(', or eol.
        //

        Field = p + 1;
        if(!(p = _tcschr(Field, INFCHAR_ATTR_START))) {
            p = Field + lstrlen(Field);
        }
        if(!pHexToUlong(Field, p, &IoResourceIndex) || (IoResourceIndex > 255)) {
            d = ERROR_INVALID_INF_LOGCONFIG;
        }
    }


    if ((d == NO_ERROR) && (*p == INFCHAR_ATTR_START)) {
        //
        // Retrieve the attributes.
        //
        while (TRUE) {
            p++;

            if (!*p) {
                // Didn't find a close paren
                d = ERROR_INVALID_INF_LOGCONFIG;
                break;
            }

            if (*p == INFCHAR_ATTR_END) {
                if (*(p+1)) {
                    // found garbage after the close paren
                    d = ERROR_INVALID_INF_LOGCONFIG;
                }
                break;
            }

            if ((TCHAR)CharUpper((PTSTR)*p) == INFCHAR_MFCARD_AUDIO_ATTR) {
                Flags |= fPMF_AUDIO_ENABLE;
            } else {
                // bad flag
                d = ERROR_INVALID_INF_LOGCONFIG;
                break;
            }
        }
    }

    if(d == NO_ERROR) {
        //
        // If we get to here, then we've successfully retrieved all the necessary information
        // needed to initialize the multifunction PC Card configuration resource descriptor.
        //
        ZeroMemory(&MfCardResource, sizeof(MfCardResource));

        MfCardResource.MfCard_Header.PMF_Count = 1;
        MfCardResource.MfCard_Header.PMF_Flags = Flags;
        MfCardResource.MfCard_Header.PMF_ConfigOptions = (BYTE)ConfigOptions;
        MfCardResource.MfCard_Header.PMF_IoResourceIndex = (BYTE)IoResourceIndex;
        MfCardResource.MfCard_Header.PMF_ConfigRegisterBase = ConfigRegisterBase;

        d = CM_Add_Res_Des_Ex(
                &ResDes,
                LogConfig,
                ResType_MfCardConfig,
                &MfCardResource,
                sizeof(MfCardResource),
                0,
                hMachine);

        d = MapCrToSpError(d, ERROR_INVALID_DATA);

        if(d == NO_ERROR) {
            CM_Free_Res_Des_Handle(ResDes);
        }
    }
    return d;
}

#if 0
DWORD
pSetupProcessLogConfigLines(
    IN PVOID    Inf,
    IN PCTSTR   SectionName,
    IN PCTSTR   KeyName,
    IN DWORD    (*CallbackFunc)(LOG_CONFIG,PINFCONTEXT,HMACHINE),
    IN LOG_CONF LogConfig,
    IN HMACHINE hMachine
    )
{
    BOOL b;
    DWORD d;
    INFCONTEXT InfLine;

    b = SetupFindFirstLine(Inf,SectionName,KeyName,&InfLine);
    d = NO_ERROR;
    //
    // Process each line with a key that matches.
    //
    while(b && (d == NO_ERROR)) {

        d = CallbackFunc(LogConfig,&InfLine, hMachine);

        if(d == NO_ERROR) {
            b = SetupFindNextMatchLine(&InfLine,KeyName,&InfLine);
        }
    }

    return(d);
}

#endif

DWORD
pSetupProcessConfigPriority(
    IN  PVOID     Inf,
    IN  PCTSTR    SectionName,
    IN  LOG_CONF  LogConfig,
    OUT PRIORITY *PriorityValue,
    OUT DWORD    *ConfigType,
    IN  DWORD     Flags
    )
{
    INFCONTEXT InfLine;
    PCTSTR PrioritySpec;
    PCTSTR ConfigSpec;
    DWORD d = NO_ERROR;
    INT_PTR v;

    //
    // We only need to fetch one of these lines and look at the
    // first value on it.
    //
    if(SetupFindFirstLine(Inf,SectionName,pszConfigPriority,&InfLine)
       && (PrioritySpec = pSetupGetField(&InfLine,1))) {

        if(!LookUpStringInTable(InfPrioritySpecToPriority,PrioritySpec,&v)) {
            d = ERROR_INVALID_INF_LOGCONFIG;
        } else {
            *PriorityValue = (PRIORITY)v;
            //
            // The second value is optional and specifies whether the config is forced,
            // standard (i.e., basic), or override. If the value isn't specified then
            // assume basic, unless the Flags tell us otherwise.
            //
            ConfigSpec = pSetupGetField(&InfLine,2);
            if(!ConfigSpec || !*ConfigSpec) {

                if(Flags & SPINST_LOGCONFIG_IS_FORCED) {
                    *ConfigType = FORCED_LOG_CONF;
                } else if(Flags & SPINST_LOGCONFIGS_ARE_OVERRIDES) {
                    *ConfigType = OVERRIDE_LOG_CONF;
                } else {
                    *ConfigType = BASIC_LOG_CONF;
                }

            } else {

                if(LookUpStringInTable(InfConfigSpecToConfig, ConfigSpec, &v)) {
                    *ConfigType = (DWORD)v;
                    //
                    // A valid ConfigType was specified.  Let's make sure it doesn't disagree
                    // with any flags that were passed in to this routine.
                    //
                    if(Flags & SPINST_LOGCONFIG_IS_FORCED) {
                        if(*ConfigType != FORCED_LOG_CONF) {
                            d = ERROR_INVALID_INF_LOGCONFIG;
                        }
                    } else if(Flags & SPINST_LOGCONFIGS_ARE_OVERRIDES) {
                        if(*ConfigType != OVERRIDE_LOG_CONF) {
                            d = ERROR_INVALID_INF_LOGCONFIG;
                        }
                    }

                } else {
                    d = ERROR_INVALID_INF_LOGCONFIG;
                }
            }
        }

        //
        // If we successfully determined the LogConfig type as FORCED_LOG_CONF, then
        // set the priority to LCPRI_FORCECONFIG.
        //
        if((d == NO_ERROR) && (*ConfigType == FORCED_LOG_CONF)) {
            *PriorityValue = LCPRI_FORCECONFIG;
        }


    } else {

        *PriorityValue = (Flags & SPINST_LOGCONFIG_IS_FORCED) ? LCPRI_FORCECONFIG : LCPRI_NORMAL;

        if(Flags & SPINST_LOGCONFIG_IS_FORCED) {
            *ConfigType = FORCED_LOG_CONF;
        } else if(Flags & SPINST_LOGCONFIGS_ARE_OVERRIDES) {
            *ConfigType = OVERRIDE_LOG_CONF;
        } else {
            *ConfigType = BASIC_LOG_CONF;
        }
    }

    return d;
}


DWORD
pSetupProcessLogConfigSection(
    IN PVOID   Inf,
    IN PCTSTR  SectionName,
    IN DEVINST DevInst,
    IN DWORD   Flags,
    IN HMACHINE hMachine
    )
{
    DWORD d;
    LOG_CONF LogConfig;
    PRIORITY Priority;
    DWORD ConfigType;
    CONFIGRET cr;

    DWORD LineIndex = 0;
    INFCONTEXT InfLine;
    TCHAR Key[MAX_LOGCONFKEYSTR_LEN];

    //
    // Process config priority values.
    //

    //
    // LogConfig is used before initialized in following call.
    // It doesn't matter to function being called, but 6.0 compiler
    // doesn't like it, so init to 0.
    //

    LogConfig = 0;

    d = pSetupProcessConfigPriority(Inf,SectionName,LogConfig,&Priority,&ConfigType,Flags);
    if(d != NO_ERROR) {
        goto c0;
    }

    //
    // Now that we know the priority we can create an empty log config.
    //
    d = MapCrToSpError(CM_Add_Empty_Log_Conf_Ex(&LogConfig,DevInst,Priority,ConfigType,hMachine),
                       ERROR_INVALID_DATA
                      );

    if(d != NO_ERROR) {
        goto c0;
    }

    //
    // Iterate over the lines in the section adding entries to the log config in
    // the same order as they are found.
    //

    if (SetupFindFirstLine(Inf,SectionName,NULL,&InfLine)) {

        do {

            //
            // Get the key.
            //

            if (!SetupGetStringField(&InfLine,
                                     0, // Index 0 is the key field
                                     Key,
                                     MAX_LOGCONFKEYSTR_LEN,
                                     NULL
                                     )) {
                //
                // Either we didn't have a key or its longer than the longest
                // valid key - either way its invalid
                //

                d = ERROR_INVALID_INF_LOGCONFIG;
                goto c1;
            }

            if (!_tcsicmp(Key, pszMemConfig)) {

                //
                // Process MemConfig lines
                //

                d = pSetupProcessMemConfig(LogConfig, &InfLine, hMachine);

            } else if (!_tcsicmp(Key, pszIOConfig)) {

                //
                // Process IoConfig lines
                //

                d = pSetupProcessIoConfig(LogConfig, &InfLine, hMachine);

            } else if (!_tcsicmp(Key, pszIRQConfig)) {

                //
                // Process IRQConfig lines
                //

                d = pSetupProcessIrqConfig(LogConfig, &InfLine, hMachine);

            } else if (!_tcsicmp(Key, pszDMAConfig)) {

                //
                // Process DMAConfig lines
                //

                d = pSetupProcessDmaConfig(LogConfig, &InfLine, hMachine);

            } else if (!_tcsicmp(Key, pszPcCardConfig)) {

                //
                // Process PcCardConfig lines
                //

                d = pSetupProcessPcCardConfig(LogConfig, &InfLine, hMachine);

            } else if (!_tcsicmp(Key, pszMfCardConfig)) {

                //
                // Process MfCardConfig lines
                //

                d = pSetupProcessMfCardConfig(LogConfig, &InfLine, hMachine);

            } else {

                //
                // If we don't understand the line skip it
                //

                d = NO_ERROR;
            }

        } while (d == NO_ERROR && SetupFindNextMatchLine(&InfLine,NULL,&InfLine));
    }

#if 0
    //
    // Process MemConfig lines
    //
    d = pSetupProcessLogConfigLines(
            Inf,
            SectionName,
            pszMemConfig,
            pSetupProcessMemConfig,
            LogConfig,
            hMachine
            );

    if(d != NO_ERROR) {
        goto c1;
    }

    //
    // Process IOConfig lines
    //
    d = pSetupProcessLogConfigLines(
            Inf,
            SectionName,
            pszIOConfig,
            pSetupProcessIoConfig,
            LogConfig,
            hMachine
            );

    if(d != NO_ERROR) {
        goto c1;
    }

    //
    // Process IRQConfig lines
    //
    d = pSetupProcessLogConfigLines(
            Inf,
            SectionName,
            pszIRQConfig,
            pSetupProcessIrqConfig,
            LogConfig,
            hMachine
            );

    if(d != NO_ERROR) {
        goto c1;
    }

    //
    // Process DMAConfig lines
    //
    d = pSetupProcessLogConfigLines(
            Inf,
            SectionName,
            pszDMAConfig,
            pSetupProcessDmaConfig,
            LogConfig,
            hMachine
            );

    if(d != NO_ERROR) {
        goto c1;
    }

    //
    // Process PcCardConfig lines
    //
    d = pSetupProcessLogConfigLines(
            Inf,
            SectionName,
            pszPcCardConfig,
            pSetupProcessPcCardConfig,
            LogConfig,
            hMachine
            );
#endif

c1:
    if(d != NO_ERROR) {
        CM_Free_Log_Conf(LogConfig,0);
    }
    CM_Free_Log_Conf_Handle(LogConfig);
c0:
    return(d);
}


DWORD
pSetupInstallLogConfig(
    IN HINF    Inf,
    IN PCTSTR  SectionName,
    IN DEVINST DevInst,
    IN DWORD   Flags,
    IN HMACHINE hMachine
    )

/*++

Routine Description:

    Look for logical configuration directives within an inf section
    and parse them. Each value on the LogConf= line is taken to be
    the name of a logical config section.

Arguments:

    Inf - supplies inf handle for inf containing the section indicated
        by SectionName.

    SectionName - supplies name of install section.

    DevInst - device instance handle for log configs.

    Flags - supplies flags that modify the behavior of this routine.  The
        following flags are payed attention to, everything else is ignored:

        SPINST_SINGLESECTION - if this bit is set, then the specified section
                               is a LogConf section, instead of an install
                               section containing LogConf entries.

        SPINST_LOGCONFIG_IS_FORCED - if this bit is set, then the LogConfigs
                                     to be written out are forced configs.
                                     If the ConfigType field of the ConfigPriority
                                     entry is present, and specifies something
                                     other than FORCED, this routine will fail
                                     with ERROR_INVALID_INF_LOGCONFIG.

        SPINST_LOGCONFIGS_ARE_OVERRIDES - if this bit is set, then the LogConfigs
                                          to be written out are override configs.
                                          If the ConfigType field of the ConfigPriority
                                          entry is present, and specifies something
                                          other than OVERRIDE, this routine will fail
                                          with ERROR_INVALID_INF_LOGCONFIG.

Return Value:

    Win32 error code indicating outcome.

--*/

{
    INFCONTEXT LineContext;
    DWORD rc = NO_ERROR;
    DWORD FieldCount;
    DWORD Field;
    PCTSTR SectionSpec;

    if(Flags & SPINST_SINGLESECTION) {
        //
        // Process the specific LogConf section the caller specified.
        //
        if(SetupGetLineCount(Inf, SectionName) == -1) {
            rc = ERROR_SECTION_NOT_FOUND;
        } else {
            rc = pSetupProcessLogConfigSection(Inf, SectionName, DevInst, Flags,hMachine);
        }
    } else {
        //
        // Find the relevant line in the given install section.
        // If not present then we're done with this operation.
        //
        if(SetupFindFirstLine(Inf,SectionName,SZ_KEY_LOGCONFIG,&LineContext)) {

            do {
                //
                // Each value on the line in the given install section
                // is the name of a logical config section.
                //
                FieldCount = SetupGetFieldCount(&LineContext);
                for(Field=1; (rc==NO_ERROR) && (Field<=FieldCount); Field++) {

                    if((SectionSpec = pSetupGetField(&LineContext,Field))
                    && (SetupGetLineCount(Inf,SectionSpec) > 0)) {

                        rc = pSetupProcessLogConfigSection(Inf,SectionSpec,DevInst,Flags,hMachine);
                    } else {
                        rc = ERROR_SECTION_NOT_FOUND;
                    }
                    if (rc != NO_ERROR) {
                        pSetupLogSectionError(Inf,NULL,NULL,NULL,SectionSpec,MSG_LOG_SECT_ERROR,rc,SZ_KEY_LOGCONFIG);
                    }
                }

            } while((rc == NO_ERROR) && SetupFindNextMatchLine(&LineContext,SZ_KEY_LOGCONFIG,&LineContext));
        }
    }

    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\setupapi\infsdisk.c ===
/*++

Copyright (c) 1995-2000 Microsoft Corporation

Module Name:

    infsdisk.c

Abstract:

    Externally exposed INF routines for source disk descriptor manipulation.

Author:

    Ted Miller (tedm) 9-Feb-1995

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//
// Locations of various fields in the [SourceDisksNames] section
// of an inf
//
#define DISKNAMESECT_DESCRIPTION    1
#define DISKNAMESECT_TAGFILE        2       // cabinet name in win95
#define DISKNAMESECT_OEM            3       // unused, indicates oem disk in win95
#define DISKNAMESECT_PATH           4
#define DISKNAMESECT_FLAGS          5       // indicates extra tags
#define DISKNAMESECT_TAGFILE2       6       // real tagfile if DISKNAMESECT_TAGFILE is really a cabfile

#ifdef UNICODE
//
// ANSI version
//
BOOL
SetupGetSourceInfoA(
    IN  HINF   InfHandle,
    IN  UINT   SourceId,
    IN  UINT   InfoDesired,
    OUT PSTR   ReturnBuffer,     OPTIONAL
    IN  DWORD  ReturnBufferSize,
    OUT PDWORD RequiredSize      OPTIONAL
    )
{
    DWORD rc;
    BOOL b;
    PWCHAR buffer;
    DWORD requiredsize;
    PCSTR ansi;

    buffer = MyMalloc(MAX_INF_STRING_LENGTH);
    if (buffer) {

        b = pSetupGetSourceInfo(
                InfHandle,
                NULL,
                SourceId,
                NULL,
                InfoDesired,
                buffer,
                MAX_INF_STRING_LENGTH,
                &requiredsize
                );

        rc = GetLastError();

        if(b) {

            rc = NO_ERROR;

            if(ansi = pSetupUnicodeToAnsi(buffer)) {

                requiredsize = lstrlenA(ansi)+1;

                if(RequiredSize) {
                    try {
                        *RequiredSize = requiredsize;
                    } except(EXCEPTION_EXECUTE_HANDLER) {
                        rc = ERROR_INVALID_PARAMETER;
                        b = FALSE;
                    }
                }

                if((rc == NO_ERROR) && ReturnBuffer) {

                    if(!lstrcpynA(ReturnBuffer,ansi,ReturnBufferSize)) {
                        //
                        // ReturnBuffer invalid
                        //
                        rc = ERROR_INVALID_PARAMETER;
                        b = FALSE;
                    }
                }

                MyFree(ansi);
            } else {
                rc = ERROR_NOT_ENOUGH_MEMORY;
                b = FALSE;
            }
        }

        MyFree(buffer);
    } else {
        rc = ERROR_NOT_ENOUGH_MEMORY;
        b = FALSE;
    }

    SetLastError(rc);
    return(b);
}
#else
//
// Unicode stub
//
BOOL
SetupGetSourceInfoW(
    IN  HINF   InfHandle,
    IN  UINT   SourceId,
    IN  UINT   InfoDesired,
    OUT PWSTR  ReturnBuffer,     OPTIONAL
    IN  DWORD  ReturnBufferSize,
    OUT PDWORD RequiredSize      OPTIONAL
    )
{
    UNREFERENCED_PARAMETER(InfHandle);
    UNREFERENCED_PARAMETER(SourceId);
    UNREFERENCED_PARAMETER(InfoDesired);
    UNREFERENCED_PARAMETER(ReturnBuffer);
    UNREFERENCED_PARAMETER(ReturnBufferSize);
    UNREFERENCED_PARAMETER(RequiredSize);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif

BOOL
SetupGetSourceInfo(
    IN  HINF   InfHandle,
    IN  UINT   SourceId,
    IN  UINT   InfoDesired,
    OUT PTSTR  ReturnBuffer,     OPTIONAL
    IN  DWORD  ReturnBufferSize,
    OUT PDWORD RequiredSize      OPTIONAL
    )
//
// Native version
//
{
    return pSetupGetSourceInfo(InfHandle,
                               NULL,
                               SourceId,
                               NULL,
                               InfoDesired,
                               ReturnBuffer,
                               ReturnBufferSize,
                               RequiredSize
                              );
}

BOOL
pSetupGetSourceInfo(
    IN  HINF                    InfHandle,         OPTIONAL
    IN  PINFCONTEXT             LayoutLineContext, OPTIONAL
    IN  UINT                    SourceId,
    IN  PSP_ALTPLATFORM_INFO_V2 AltPlatformInfo,   OPTIONAL
    IN  UINT                    InfoDesired,
    OUT PTSTR                   ReturnBuffer,      OPTIONAL
    IN  DWORD                   ReturnBufferSize,
    OUT PDWORD                  RequiredSize       OPTIONAL
    )
/*++

Routine Description:

    Get information from SourceDisksNames

    If InfHandle specified instead of LayoutLineContext
    and the ID is specified in more than one INF
    then the wrong information *MAY* be returned.
    This effects callers of SetupGetSourceInfo
    we need a SetupGetSourceInfoEx post 5.0

Arguments:

    InfHandle - required if LayoutLineContext is not provided, else specifies a layout inf

    SourceId  - numerical source ID, used as search key in SourceDisksNames section

    AltPlatformInfo - optionally, supplies alternate platform information used
        in decorating the [SourceDisksNames] section.

    InfoDesired -
        SRCINFO_PATH
        SRCINFO_TAGFILE
        SRCINFO_DESCRIPTION
        SRCINFO_FLAGS

    ReturnBuffer - buffer for returned string
    ReturnBufferSize - size of buffer
    RequiredSize - size buffer needs to be if ReturnBufferSize too small
    LayoutLineContext - if specified, used to determine correct INF to use if SourceID's conflict

Return Value:

    Boolean value indicating outcome. If FALSE, GetLastError() returns
    extended error information.
    ReturnBuffer filled out with string
    RequiredSize filled out with required size of buffer to hold string

--*/
{
    PCTSTR PlatformName;
    UINT ValueIndex;
    BOOL Mandatory;
    BOOL IsPath;
    INFCONTEXT InfContext;
    INFCONTEXT SelectedInfContext;
    int SelectedRank;
    TCHAR SourceIdString[24];
    PCTSTR Value;
    BOOL b;
    UINT Length;
    TCHAR MediaListSectionName[64];
    HINF hInfPreferred = (HINF)(-1);

    try {
        if ((LayoutLineContext != NULL) && (LayoutLineContext != (PINFCONTEXT)(-1))) {
            hInfPreferred = (HINF)LayoutLineContext->CurrentInf;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        hInfPreferred = (HINF)(-1);
    }

    //
    // Determine the index of the value that gives the caller the info he wants.
    //
    switch(InfoDesired) {

    case SRCINFO_PATH:
        ValueIndex = DISKNAMESECT_PATH;
        Mandatory = FALSE;
        IsPath = TRUE;
        break;

    case SRCINFO_TAGFILE:
        ValueIndex = DISKNAMESECT_TAGFILE;
        Mandatory = FALSE;
        IsPath = TRUE;
        break;

    case SRCINFO_DESCRIPTION:
        ValueIndex = DISKNAMESECT_DESCRIPTION;
        Mandatory = TRUE;
        IsPath = FALSE;
        break;

    case SRCINFO_FLAGS:
        ValueIndex = DISKNAMESECT_FLAGS;
        Mandatory = FALSE;
        IsPath = FALSE;
        break;

    case SRCINFO_TAGFILE2:
        ValueIndex = DISKNAMESECT_TAGFILE2;
        Mandatory = FALSE;
        IsPath = TRUE;
        break;

    default:
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    wsprintf(SourceIdString,TEXT("%d"),SourceId);

    if(AltPlatformInfo) {

        switch(AltPlatformInfo->ProcessorArchitecture) {

            case PROCESSOR_ARCHITECTURE_INTEL :
                PlatformName = pszX86SrcDiskSuffix;
                break;

            case PROCESSOR_ARCHITECTURE_IA64 :
                PlatformName = pszIa64SrcDiskSuffix;
                break;

            case PROCESSOR_ARCHITECTURE_AMD64 :
                PlatformName = pszAmd64SrcDiskSuffix;
                break;

            default :
                //
                // unknown/unsupported processor architecture.
                //
                MYASSERT((AltPlatformInfo->ProcessorArchitecture == PROCESSOR_ARCHITECTURE_INTEL) ||
                         (AltPlatformInfo->ProcessorArchitecture == PROCESSOR_ARCHITECTURE_IA64)  ||
                         (AltPlatformInfo->ProcessorArchitecture == PROCESSOR_ARCHITECTURE_AMD64)
                        );

                SetLastError(ERROR_INVALID_PARAMETER);
                return(FALSE);
        }

    } else {
        PlatformName = pszPlatformSrcDiskSuffix;
    }

    wnsprintf(
        MediaListSectionName,
        sizeof(MediaListSectionName)/sizeof(MediaListSectionName[0]),
        TEXT("%s.%s"),
        pszSourceDisksNames,
        PlatformName
        );

    //
    // we will prefer
    // (1) an entry in hInfPreferred           (Rank 11/12 decorated over undecorated)
    // (2) an entry linked to hInfPreferred    (Rank 21/22 decorated over undecorated)
    // (3) an entry in hInfHandle              (Rank 31/32 decorated over undecorated)
    // (4) an entry linked to InfHandle        (Rank 41/42 decorated over undecorated)
    //

    SelectedRank = 100;       // 11-42 as above

    if ((hInfPreferred != NULL) && (hInfPreferred != (HINF)(-1))) {
        //
        // see if we can find the SourceIdString in the INF that we found the section in
        //
        // rank 11 or 21 (decorated) - always try
        //
        if(SetupFindFirstLine(hInfPreferred,MediaListSectionName,SourceIdString,&InfContext)) {
            if (InfContext.Inf == InfContext.CurrentInf) {
                SelectedRank = 11;
                SelectedInfContext = InfContext;
            } else {
                SelectedRank = 21;
                SelectedInfContext = InfContext;
            }
        }
        if (SelectedRank > 12) {
            //
            // rank 12 or 22 (undecorated) only try if we haven't got anything better than 12
            //
            if(SetupFindFirstLine(hInfPreferred,pszSourceDisksNames,SourceIdString,&InfContext)) {
                if (InfContext.Inf == InfContext.CurrentInf) {
                    SelectedRank = 12;
                    SelectedInfContext = InfContext;
                } else if (SelectedRank > 22) {
                    SelectedRank = 22;
                    SelectedInfContext = InfContext;
                }
            }
        }
    }
    if ((InfHandle != NULL) && (InfHandle != (HINF)(-1)) && (SelectedRank > 31)) {
        //
        // see if we can find the SourceIdString in the supplied INF
        //
        // rank 31 or 41 (decorated) - only try if we haven't got anything better than 31
        //
        if(SetupFindFirstLine(InfHandle,MediaListSectionName,SourceIdString,&InfContext)) {
            if (InfContext.Inf == InfContext.CurrentInf) {
                SelectedRank = 31;
                SelectedInfContext = InfContext;
            } else if (SelectedRank > 41) {
                SelectedRank = 41;
                SelectedInfContext = InfContext;
            }
        }
        if (SelectedRank > 32) {
            //
            // rank 32 or 42 (undecorated) - only try if we haven't got anything better than 32
            //
            if(SetupFindFirstLine(InfHandle,pszSourceDisksNames,SourceIdString,&InfContext)) {
                if (InfContext.Inf == InfContext.CurrentInf) {
                    SelectedRank = 32;
                    SelectedInfContext = InfContext;
                } else if (SelectedRank > 42) {
                    SelectedRank = 42;
                    SelectedInfContext = InfContext;
                }
            }
        }
    }
    if(SelectedRank == 100 || (Value = pSetupGetField(&InfContext,ValueIndex))==NULL) {
        if(Mandatory) {
            SetLastError(ERROR_LINE_NOT_FOUND);
            return(FALSE);
        } else {
            Value = TEXT("");
        }
    }

    //
    // Figure out how many characters are in the output.
    // If the value is a path type value we want to remove
    // the trailing backslash if there is one.
    //
    Length = lstrlen(Value);
    if(IsPath && Length && (*CharPrev(Value,Value+Length) == TEXT('\\'))) {
        Length--;
    }

    //
    // Need to leave space for the trailing nul.
    //
    Length++;
    if(RequiredSize) {
        b = TRUE;
        try {
            *RequiredSize = Length;
        } except(EXCEPTION_EXECUTE_HANDLER) {
            b = FALSE;
        }
        if(!b) {
            SetLastError(ERROR_INVALID_PARAMETER);
            return(FALSE);
        }
    }

    b = TRUE;
    if(ReturnBuffer) {
        if(Length <= ReturnBufferSize) {
            //
            // lstrcpyn is a strange API but the below is correct --
            // the size parameter is actually the capacity of the
            // target buffer. So to get it to put the nul in the
            // right place we pass one larger than the number of chars
            // we want copied.
            //
            if(!lstrcpyn(ReturnBuffer,Value,Length)) {
                //
                // ReturnBuffer invalid
                //
                b = FALSE;
                SetLastError(ERROR_INVALID_PARAMETER);
            }
        } else {
            b = FALSE;
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
        }
    }

    return(b);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\setupapi\infold.c ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    infold.c

Abstract:

    Routines to load an old-style inf file.
    Based on prsinf\spinf.c

Author:

    Ted Miller (tedm) 19-Jan-1995

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop


//
// Internal temporary representation of the inf file.
// The win95 representation is built from these structures
// which are then throw away.
//
typedef struct _X_VALUE {
    struct _X_VALUE *Next;
    PTCHAR Name;
} X_VALUE, *PX_VALUE;

typedef struct _X_LINE {
    struct _X_LINE *Next;
    PTCHAR Name;
    PX_VALUE Value;
    UINT ValueCount;
} X_LINE, *PX_LINE;

typedef struct _X_SECTION {
    struct _X_SECTION *Next;
    PTCHAR Name;
    PX_LINE Line;
    UINT LineCount;
} X_SECTION, *PX_SECTION;

typedef struct _X_INF {
    PX_SECTION Section;
    UINT SectionCount;
    UINT TotalLineCount;
    UINT TotalValueCount;
} X_INF, *PX_INF;


//
// Global parse context.
//
typedef struct _PARSE_CONTEXT {
    PX_INF Inf;
    PX_SECTION Section;
    PX_LINE Line;
    PX_VALUE Value;
} PARSE_CONTEXT, *PPARSE_CONTEXT;

//
// Token parser values.
//
typedef enum _X_TOKENTYPE {
    TOK_EOF,
    TOK_EOL,
    TOK_LBRACE,
    TOK_RBRACE,
    TOK_STRING,
    TOK_EQUAL,
    TOK_COMMA,
    TOK_ERRPARSE,
    TOK_ERRNOMEM
} X_TOKENTYPE, *PX_TOKENTTYPE;

//
// Token parser data type
//
typedef struct _X_TOKEN {
    X_TOKENTYPE Type;
    PTCHAR pValue;
} X_TOKEN, *PX_TOKEN;


//
// string terminators are the whitespace characters (isspace: space, tab,
// linefeed, formfeed, vertical tab, carriage return) or the chars given below
//
// quoted string terminators allow some of the regular terminators to
// appear as characters
//
PTCHAR szStrTerms    = TEXT("[]=,\" \t\n\f\v\r");
PTCHAR szBrcStrTerms = TEXT("[]=,\"\t\n\f\v\r");
PTCHAR szQStrTerms   = TEXT("\"\n\f\v\r");
PTCHAR szCBrStrTerms = TEXT("}\n\f\v\r");

#define IsStringTerminator(terminators,ch)   (_tcschr((terminators),(ch)) != NULL)


VOID
SpFreeTemporaryParseStructures(
   IN PX_INF Inf
   )

/*++

Routine Description:

    Free the structures built by the old-style-inf parser.

Arguments:

    Inf - supplies pointer to inf descriptor structure.

Return Value:

    None.

--*/

{
    PX_SECTION Section,NextSection;
    PX_LINE Line,NextLine;
    PX_VALUE Value,NextValue;

    for(Section=Inf->Section; Section; Section=NextSection) {

        for(Line=Section->Line; Line; Line=NextLine) {

            for(Value=Line->Value; Value; Value=NextValue) {

                NextValue = Value->Next;
                if(Value->Name) {
                    MyFree(Value->Name);
                }
                MyFree(Value);
            }

            NextLine = Line->Next;
            if(Line->Name) {
                MyFree(Line->Name);
            }
            MyFree(Line);
        }

        NextSection = Section->Next;
        MyFree(Section->Name);
        MyFree(Section);
    }

    MyFree(Inf);
}


BOOL
SpAppendSection(
    IN PPARSE_CONTEXT Context,
    IN PTCHAR         SectionName
    )

/*++

Routine Description:

    This appends a new section to the section list in the current INF.
    All further lines and values pertain to this new section, so it resets
    the line list and value lists too.

Arguments:

    Context - supplies the parse context

    SectionName - Name of the new section. ( [SectionName] )

Return Value:

    BOOL - FALSE if failure (out of memory)

--*/

{
    PX_SECTION NewSection;

    MYASSERT(Context->Inf);

    //
    // Allocate memory for the new section
    //
    if((NewSection = MyMalloc(sizeof(X_SECTION))) == NULL) {
        return(FALSE);
    }

    //
    // initialize the new section
    //
    ZeroMemory(NewSection,sizeof(X_SECTION));
    NewSection->Name = SectionName;

    //
    // Link it in
    //
    if(Context->Section) {
        Context->Section->Next = NewSection;
    } else {
        Context->Inf->Section = NewSection;
    }

    Context->Section = NewSection;

    //
    // reset the current line record and current value record field
    //
    Context->Line = NULL;
    Context->Value = NULL;

    Context->Inf->SectionCount++;

    return(TRUE);
}


BOOL
SpAppendLine(
    IN PPARSE_CONTEXT Context,
    IN PTCHAR         LineKey
    )

/*++

Routine Description:

    This appends a new line to the line list in the current section.
    All further values pertain to this new line, so it resets
    the value list too.

Arguments:

    Context - supplies the parse context.

    LineKey - Key to be used for the current line, this could be NULL.

Return Value:

    BOOL - FALSE if failure (out of memory)

--*/


{
    PX_LINE NewLine;

    MYASSERT(Context->Section);

    //
    // Allocate memory for the new Line
    //
    if((NewLine = MyMalloc(sizeof(X_LINE))) == NULL) {
        return(FALSE);
    }

    ZeroMemory(NewLine,sizeof(X_LINE));

    NewLine->Name = LineKey;

    //
    // Link it in
    //
    if(Context->Line) {
        Context->Line->Next = NewLine;
    } else {
        Context->Section->Line = NewLine;
    }

    Context->Line = NewLine;

    //
    // Reset the current value record
    //
    Context->Value = NULL;

    //
    // Adjust counts.
    //
    Context->Inf->TotalLineCount++;
    Context->Section->LineCount++;
    if(LineKey) {
        Context->Inf->TotalValueCount++;
        NewLine->ValueCount = 1;
    }

    return(TRUE);
}


BOOL
SpAppendValue(
    IN PPARSE_CONTEXT Context,
    IN PTCHAR         ValueString
    )

/*++

Routine Description:

    This appends a new value to the value list in the current line.

Arguments:

    Context - supplies the parse context.

    ValueString - The value string to be added.

Return Value:

    BOOL - FALSE if failure (out of memory)

--*/

{
    PX_VALUE NewValue;

    MYASSERT(Context->Line);

    //
    // Allocate memory for the new value record
    //
    if((NewValue = MyMalloc(sizeof(X_VALUE))) == NULL) {
        return(FALSE);
    }

    ZeroMemory(NewValue,sizeof(X_VALUE));

    NewValue->Name = ValueString;

    //
    // Link it in.
    //
    if(Context->Value) {
        Context->Value->Next = NewValue;
    } else {
        Context->Line->Value = NewValue;
    }

    //
    // Adjust counts
    //
    Context->Value = NewValue;
    Context->Inf->TotalValueCount++;
    Context->Line->ValueCount++;

    return(TRUE);
}



X_TOKEN
SpGetToken(
    IN OUT PCTSTR *Stream,
    IN     PCTSTR  StreamEnd,
    IN     PTCHAR  pszStrTerms,
    IN     PTCHAR  pszQStrTerms,
    IN     PTCHAR  pszCBrStrTerms
    )

/*++

Routine Description:

    This function returns the Next token from the configuration stream.

Arguments:

    Stream - Supplies the address of the configuration stream.  Returns
        the address of where to start looking for tokens within the
        stream.

    StreamEnd - Supplies the memory address immediately following the
        character stream.

Return Value:

    The next token

--*/

{

    PCTSTR pch, pchStart;
    PTCHAR pchNew;
    DWORD Length, i;
    X_TOKEN Token;

    //
    // Skip whitespace (except for eol)
    //
    pch = *Stream;

    while(pch < StreamEnd) {

        SkipWhitespace(&pch, StreamEnd);

        if((pch < StreamEnd) && !(*pch)) {
            //
            // We hit a NULL char--skip it
            // and keep looking for a token.
            //
            pch++;

        } else {
            break;
        }
    }

    //
    // Check for comments and remove them
    //
    if((pch < StreamEnd) &&
       ((*pch == TEXT(';')) || (*pch == TEXT('#')) ||
        ((*pch == TEXT('/')) && (*(pch+1) == TEXT('/')))))
    {
        do {
            pch++;
        } while((pch < StreamEnd) && (*pch != TEXT('\n')));
    }

    if(pch == StreamEnd) {
        *Stream = pch;
        Token.Type = TOK_EOF;
        Token.pValue = NULL;
        return(Token);
    }

    switch (*pch) {

    case TEXT('['):
        pch++;
        Token.Type = TOK_LBRACE;
        Token.pValue = NULL;
        break;

    case TEXT(']'):
        pch++;
        Token.Type = TOK_RBRACE;
        Token.pValue = NULL;
        break;

    case TEXT('='):
        pch++;
        Token.Type = TOK_EQUAL;
        Token.pValue = NULL;
        break;

    case TEXT(','):
        pch++;
        Token.Type = TOK_COMMA;
        Token.pValue = NULL;
        break;

    case TEXT('\n'):
        pch++;
        Token.Type = TOK_EOL;
        Token.pValue = NULL;
        break;

    case TEXT('\"'):
        pch++;
        //
        // determine quoted string
        //
        pchStart = pch;
        while((pch < StreamEnd) && !IsStringTerminator(pszQStrTerms,*pch)) {
            pch++;
        }

        //
        //
        // Only valid terminator is double quote
        //
        if((pch == StreamEnd) || (*pch != TEXT('\"'))) {
            Token.Type = TOK_ERRPARSE;
            Token.pValue = NULL;
        } else {

            //
            // Got a valid string. Allocate space for it and save.
            //
            Length = (DWORD)(pch - pchStart);
            if((pchNew = MyMalloc((Length+1)*sizeof(TCHAR))) == NULL) {
                Token.Type = TOK_ERRNOMEM;
                Token.pValue = NULL;
            } else {
                //
                // We can't use string copy here, since there may be
                // NULL chars in the string (which we convert to
                // spaces during the copy).
                //
                // lstrcpyn(pchNew,pchStart,Length+1);
                //
                for(i = 0; i < Length; i++) {
                    if(!(pchNew[i] = pchStart[i])) {
                        pchNew[i] = TEXT(' ');
                    }
                }
                pchNew[Length] = 0;
                Token.Type = TOK_STRING;
                Token.pValue = pchNew;
            }
            pch++;   // advance past the quote
        }
        break;

    case TEXT('{'):
        //
        // determine quoted string
        //
        pchStart = pch;
        while((pch < StreamEnd) && !IsStringTerminator(pszCBrStrTerms,*pch)) {
            pch++;
        }

        //
        // Only valid terminator is curly brace
        if((pch == StreamEnd) || (*pch != TEXT('}'))) {
            Token.Type = TOK_ERRPARSE;
            Token.pValue = NULL;
        } else {

            //
            // Got a valid string. Allocate space for it and save.
            //
            Length = (DWORD)(pch - pchStart) + 1;
            if((pchNew = MyMalloc((Length+1)*sizeof(TCHAR))) == NULL) {
                Token.Type = TOK_ERRNOMEM;
                Token.pValue = NULL;
            } else {
                //
                // We can't use string copy here, since there may be
                // NULL chars in the string (which we convert to
                // spaces during the copy).
                //
                // lstrcpyn(pchNew,pchStart,Length+1);
                //
                for(i = 0; i < Length; i++) {
                    if(!(pchNew[i] = pchStart[i])) {
                        pchNew[i] = TEXT(' ');
                    }
                }
                pchNew[Length] = TEXT('\0');
                Token.Type = TOK_STRING;
                Token.pValue = pchNew;
            }
            pch++;   // advance past the brace
        }
        break;

    default:
        //
        // determine regular string
        //
        pchStart = pch;
        while((pch < StreamEnd) && !IsStringTerminator(pszStrTerms,*pch)) {
            pch++;
        }

        //
        // Disallow empty strings here
        //
        if(pch == pchStart) {
            pch++;
            Token.Type = TOK_ERRPARSE;
            Token.pValue = NULL;
        } else {

            Length = (DWORD)(pch - pchStart);
            if((pchNew = MyMalloc((Length+1)*sizeof(TCHAR))) == NULL) {
                Token.Type = TOK_ERRNOMEM;
                Token.pValue = NULL;
            } else {
                //
                // We can't use string copy here, since there may be
                // NULL chars in the string (which we convert to
                // spaces during the copy).
                //
                // lstrcpyn(pchNew,pchStart,Length+1);
                //
                for(i = 0; i < Length; i++) {
                    if(!(pchNew[i] = pchStart[i])) {
                        pchNew[i] = TEXT(' ');
                    }
                }
                pchNew[Length] = 0;
                Token.Type = TOK_STRING;
                Token.pValue = pchNew;
            }
        }
        break;
    }

    *Stream = pch;
    return(Token);
}


DWORD
ParseInfBuffer(
    IN  PCTSTR  Buffer,
    IN  DWORD   BufferSize,
    OUT PX_INF *Inf,
    OUT UINT   *ErrorLineNumber
    )

/*++

Routine Description:

    Given a character buffer containing the INF file, this routine parses
    the INF into an internal form with Section records, Line records and
    Value records.

Arguments:

    Buffer - contains to ptr to a buffer containing the INF file

    BufferSize - contains the size of Buffer, in characters.

    Inf - if the return value is NO_ERROR, receives a pointer to the
        inf descriptor for the parsed inf.

    ErrorLineNumber - receives the line number where a syntax/oom error
        was encountered, if the return value is not NO_ERROR.

Return Value:

    Win32 error code (with inf extensions) indicating outcome.

    If NO_ERROR, Inf is filled in.
    If not NO_ERROR, ErrorLineNumber is filled in.

--*/

{
    PCTSTR Stream, StreamEnd;
    PTCHAR pchSectionName, pchValue, pchEmptyString;
    DWORD State, InfLine;
    DWORD LastState;
    X_TOKEN Token;
    BOOL Done;
    PTCHAR pszStrTermsCur    = szStrTerms;
    PTCHAR pszQStrTermsCur   = szQStrTerms;
    PTCHAR pszCBrStrTermsCur = szCBrStrTerms;
    DWORD ErrorCode;
    PARSE_CONTEXT Context;

    //
    // Initialize the globals and create an inf record structure.
    //
    ZeroMemory(&Context,sizeof(PARSE_CONTEXT));
    if((Context.Inf = MyMalloc(sizeof(X_INF))) == NULL) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }
    ZeroMemory(Context.Inf,sizeof(X_INF));

    //
    // Set initial state
    //
    State     = 1;
    LastState = State;
    InfLine   = 1;
    StreamEnd = (Stream = Buffer) + BufferSize;
    Done      = FALSE;
    ErrorCode = NO_ERROR;

    //
    // Initialize the token type, so we'll know not to free any
    // memory for it if we hit an exception right off the bat.
    //
    Token.Type = TOK_ERRPARSE;

    pchSectionName = NULL;
    pchValue       = NULL;
    pchEmptyString = NULL;

    //
    // Guard token processing loop with try/except in case we
    // get an inpage error.
    //
    try {

        while(!Done) {

            Token = SpGetToken(&Stream,
                               StreamEnd,
                               pszStrTermsCur,
                               pszQStrTermsCur,
                               pszCBrStrTermsCur
                              );

            //
            // If you need to debug the parser, uncomment the following:
#if 0
             DebugPrintEx(DPFLTR_ERROR_LEVEL, TEXT("STATE: %u TOKEN: %u (%s) LAST: %u\r\n"),
                        State, Token.Type,
                        Token.pValue ? Token.pValue : TEXT("NULL"),
                        LastState);
#endif

            if(Token.Type == TOK_ERRNOMEM) {
                 Done = TRUE;
                 ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
            } else {

                switch (State) {
                //
                // STATE1: Start of file, this state remains till first
                //         section is found
                // Valid Tokens: TOK_EOL, TOK_EOF, TOK_LBRACE
                //
                case 1:
                    switch (Token.Type) {

                    case TOK_EOL:
                        break;

                    case TOK_EOF:
                        Done = TRUE;
                        break;

                    case TOK_LBRACE:
                        pszStrTermsCur = szBrcStrTerms;
                        State = 2;
                        break;

                    default:
                        Done = TRUE;
                        ErrorCode = ERROR_EXPECTED_SECTION_NAME;
                        break;
                    }
                    break;

                //
                // STATE 2: Section LBRACE has been received, expecting STRING
                //
                // Valid Tokens: TOK_STRING
                //
                case 2:
                    //
                    // allow spaces in section names
                    //
                    switch (Token.Type) {

                    case TOK_STRING:
                        State = 3;
                        //
                        // restore term. string with space
                        //
                        pszStrTermsCur = szStrTerms;
                        pchSectionName = Token.pValue;
                        break;

                    default:
                        Done = TRUE;
                        ErrorCode = ERROR_BAD_SECTION_NAME_LINE;
                        break;
                    }
                    break;

                //
                // STATE 3: Section Name received, expecting RBRACE
                //
                // Valid Tokens: TOK_RBRACE
                //
                case 3:
                    switch (Token.Type) {

                    case TOK_RBRACE:
                        State = 4;
                        break;

                    default:
                        Done = TRUE;
                        ErrorCode = ERROR_BAD_SECTION_NAME_LINE;
                        break;
                    }
                    break;

                //
                // STATE 4: Section Definition Complete, expecting EOL
                //
                // Valid Tokens: TOK_EOL, TOK_EOF
                //
                case 4:
                    switch (Token.Type) {

                    case TOK_EOL:
                        if(SpAppendSection(&Context,pchSectionName)) {
                            pchSectionName = NULL;
                            State = 5;
                        } else {
                            ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
                            Done = TRUE;
                        }
                        break;

                    case TOK_EOF:
                        if(SpAppendSection(&Context,pchSectionName)) {
                            pchSectionName = NULL;
                        } else {
                            ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
                        }
                        Done = TRUE;
                        break;

                    default:
                        ErrorCode = ERROR_BAD_SECTION_NAME_LINE;
                        Done = TRUE;
                        break;
                    }
                    break;

                //
                // STATE 5: Expecting Section Lines
                //
                // Valid Tokens: TOK_EOL, TOK_EOF, TOK_STRING, TOK_LBRACE
                //
                case 5:
                    switch (Token.Type) {

                    case TOK_EOL:
                        break;

                    case TOK_EOF:
                        Done = TRUE;
                        break;

                    case TOK_STRING:
                        pchValue = Token.pValue;
                        //
                        // Set token's pValue pointer to NULL, so we won't
                        // try to free the same memory twice if we hit an
                        // exception
                        //
                        Token.pValue = NULL;
                        State = 6;
                        break;

                    case TOK_LBRACE:
                        pszStrTermsCur = szBrcStrTerms;
                        State = 2;
                        break;

                    default:
                        // Done = TRUE;
                        // ErrorCode = ERROR_GENERAL_SYNTAX;
                        State = 20;
                        LastState = 5;
                        break;
                    }
                    break;

                //
                // STATE 6: String returned, not sure whether it is key or value
                //
                // Valid Tokens: TOK_EOL, TOK_EOF, TOK_COMMA, TOK_EQUAL
                //
                case 6:
                    switch (Token.Type) {

                    case TOK_EOL:
                        if(SpAppendLine(&Context,NULL) && SpAppendValue(&Context,pchValue)) {
                            pchValue = NULL;
                            State = 5;
                        } else {
                            ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
                            Done = TRUE;
                        }
                        break;

                    case TOK_EOF:
                        if(SpAppendLine(&Context,NULL) && SpAppendValue(&Context,pchValue)) {
                            pchValue = NULL;
                        } else {
                            ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
                        }
                        Done = TRUE;
                        break;

                    case TOK_COMMA:
                        if(SpAppendLine(&Context,NULL) && SpAppendValue(&Context,pchValue)) {
                            pchValue = NULL;
                            State = 7;
                        } else {
                            Done = TRUE;
                            ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
                        }
                        break;

                    case TOK_EQUAL:
                        if(SpAppendLine(&Context,pchValue)) {
                            pchValue = NULL;
                            State = 8;
                        } else {
                            ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
                            Done = TRUE;
                        }
                        break;

                    case TOK_STRING:
                        MyFree(Token.pValue);
                        Token.pValue = NULL;
                        // fall through

                    default:
                        // Done = TRUE;
                        // ErrorCode = ERROR_GENERAL_SYNTAX;
                        //
                        if(pchValue) {
                            MyFree(pchValue);
                            pchValue = NULL;
                        }
                        State = 20;
                        LastState = 5;
                        break;
                    }
                    break;

                //
                // STATE 7: Comma received, Expecting another string
                //
                // Valid Tokens: TOK_STRING, TOK_EOL, TOK_EOF, TOK_COMMA
                //
                case 7:
                    switch (Token.Type) {

                    case TOK_STRING:
                        if(SpAppendValue(&Context,Token.pValue)) {
                            State = 9;
                        } else {
                            Done = TRUE;
                            ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
                        }
                        break;

                    case TOK_COMMA:
                    case TOK_EOL:
                    case TOK_EOF:
                        //
                        // If we hit end-of-line or end-of-file, then add an
                        // empty-string value.
                        //
                        if(pchEmptyString = MyMalloc(sizeof(TCHAR))) {
                            *pchEmptyString = TEXT('\0');
                            if(SpAppendValue(&Context, pchEmptyString)) {
                                if(Token.Type == TOK_EOL) {
                                    State = 5;
                                } else if (Token.Type == TOK_COMMA) {
                                    State = 7;
                                } else {
                                    Done = TRUE;
                                }
                            } else {
                                MyFree(pchEmptyString);
                                pchEmptyString = NULL;
                                Done = TRUE;
                                ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
                            }
                        } else {
                            Done = TRUE;
                            ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
                        }
                        pchEmptyString = NULL;
                        break;

                    default:
                        // Done = TRUE;
                        // ErrorCode = ERROR_GENERAL_SYNTAX;
                        State = 20;
                        LastState = 7;
                        break;
                    }
                    break;

                //
                // STATE 8: Equal received, Expecting another string
                //
                // Valid Tokens: TOK_STRING, TOK_EOL, TOK_EOF, TOK_COMMA
                //
                case 8:
                    switch (Token.Type) {

                    case TOK_STRING:
                        if(SpAppendValue(&Context,Token.pValue)) {
                            State = 9;
                        } else {
                            Done = TRUE;
                            ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
                        }
                        break;

                    case TOK_COMMA:
                    case TOK_EOL:
                    case TOK_EOF:
                        //
                        // If we hit end-of-line or end-of-file, then add an
                        // empty-string value.
                        //
                        if(pchEmptyString = MyMalloc(sizeof(TCHAR))) {
                            *pchEmptyString = TEXT('\0');
                            if(SpAppendValue(&Context, pchEmptyString)) {
                                if(Token.Type == TOK_EOL) {
                                    State = 5;
                                } else if (Token.Type == TOK_COMMA) {
                                    State = 7;
                                } else {
                                    Done = TRUE;
                                }
                            } else {
                                MyFree(pchEmptyString);
                                pchEmptyString = NULL;
                                Done = TRUE;
                                ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
                            }
                        } else {
                            Done = TRUE;
                            ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
                        }
                        pchEmptyString = NULL;
                        break;

                    default:
                        // Done = TRUE;
                        // ErrorCode = ERROR_GENERAL_SYNTAX;
                        State = 20;
                        LastState = 8;
                        break;
                    }
                    break;

                //
                // STATE 9: String received after equal, value string
                //
                // Valid Tokens: TOK_EOL, TOK_EOF, TOK_COMMA
                //
                case 9:
                    switch (Token.Type) {

                    case TOK_EOL:
                        State = 5;
                        break;

                    case TOK_EOF:
                        Done = TRUE;
                        break;

                    case TOK_COMMA:
                        State = 7;
                        break;

                    case TOK_STRING:
                        MyFree(Token.pValue);
                        Token.pValue = NULL;
                        // fall through

                    default:
                        // Done = TRUE;
                        // ErrorCode = ERROR_GENERAL_SYNTAX;
                        State = 20;
                        LastState = 5;
                        break;
                    }
                    break;

                //
                // STATE 10: Value string definitely received
                //
                // Valid Tokens: TOK_EOL, TOK_EOF, TOK_COMMA
                //
                case 10:
                    switch (Token.Type) {

                    case TOK_EOL:
                      State =5;
                      break;

                    case TOK_EOF:
                        Done = TRUE;
                        break;

                    case TOK_COMMA:
                        State = 7;
                        break;

                    case TOK_STRING:
                        MyFree(Token.pValue);
                        Token.pValue = NULL;
                        // fall through

                    default:
                        // Done = TRUE;
                        // ErrorCode = ERROR_GENERAL_SYNTAX;
                        State = 20;
                        LastState = 10;
                        break;
                    }
                    break;

                //
                // STATE 20: Eat a line of INF
                //
                // Valid Tokens: TOK_EOL, TOK_EOF
                //
                case 20:
                    switch (Token.Type) {

                    case TOK_EOL:
                        State = LastState;
                        break;

                    case TOK_EOF:
                        Done = TRUE;
                        break;

                    case TOK_STRING:
                        MyFree(Token.pValue);
                        Token.pValue = NULL;
                        // fall through

                    default:
                        break;
                    }
                    break;

                default:

                    Done = TRUE;
                    ErrorCode = ERROR_GENERAL_SYNTAX;
                    break;

                } // end switch(State)

            } // end else

            if(ErrorCode == NO_ERROR) {

                //
                // Keep track of line numbers
                //
                if(Token.Type == TOK_EOL) {
                    InfLine++;
                }

            }

        } // End while

    } except(EXCEPTION_EXECUTE_HANDLER) {

        ErrorCode = ERROR_READ_FAULT;

        //
        // Reference the following string pointers here in the except clause so that
        // the compiler won't re-order the code in such a way that we don't know whether
        // or not to free the corresponding buffers.
        //
        Token.pValue   = Token.pValue;
        pchEmptyString = pchEmptyString;
        pchSectionName = pchSectionName;
        pchValue       = pchValue;
    }

    if(ErrorCode != NO_ERROR) {

        if((Token.Type == TOK_STRING) && Token.pValue) {
             MyFree(Token.pValue);
        }

        if(pchEmptyString) {
            MyFree(pchEmptyString);
        }

        if(pchSectionName) {
            MyFree(pchSectionName);
        }

        if(pchValue) {
            MyFree(pchValue);
        }

        SpFreeTemporaryParseStructures(Context.Inf);
        Context.Inf = NULL;

        *ErrorLineNumber = InfLine;
    }

    *Inf = Context.Inf;
    return(ErrorCode);
}


DWORD
ParseOldInf(
    IN  PCTSTR       FileImage,
    IN  DWORD        FileImageSize,
    IN  PSETUP_LOG_CONTEXT LogContext, OPTIONAL
    OUT PLOADED_INF *Inf,
    OUT UINT        *ErrorLineNumber
    )

/*++

Routine Description:

    Top-level routine to parse an old-style inf file.

    The file is first parsed using the old parser, into data structures
    understood by that parser. Following that those structures are converted
    into the universal internal inf format.

Arguments:

    FileImage - supplies a pointer to the in-memory image of the file.
        The image is assumed to be terminated by a nul character.

    FileImageSize - supplies the number of wide chars in the FileImage.

    LogContext - supplies optional logging context

    Inf - receives a pointer to the inf descriptor for the file.

    ErrorLineNumber - receives the line number of a syntx error if one is
        detected in the inf file.

Return Value:

    Win32 error code (with inf extensions) indicating outcome.

    If NO_ERROR, Inf is filled in.
    If not NO_ERROR, ErrorLineNumber is filled in.

--*/

{
    PLOADED_INF inf;
    PX_INF X_Inf;
    DWORD rc;
    PX_SECTION X_Section;
    PX_LINE X_Line;
    PX_VALUE X_Value;
    LONG StringId, StringId2;
    BOOL b;
    UINT LineNumber;
    UINT ValueNumber;
    PLONG TempValueBlock;
    PTSTR SearchString;

    //
    // First go off and parse the file into the temporary (old-style)
    // inf structures.
    //
    rc = ParseInfBuffer(FileImage,FileImageSize,&X_Inf,ErrorLineNumber);
    if(rc != NO_ERROR) {
        return(rc);
    }

    //
    // Allocate a new-style inf descriptor.  (Note that we allocate an additional
    // <TotalLineCount> number of values, since each line may have a key, which
    // requires two values each.  We'll trim this down later on.)
    //
    inf = AllocateLoadedInfDescriptor(X_Inf->SectionCount,
                                      X_Inf->TotalLineCount,
                                      X_Inf->TotalValueCount + X_Inf->TotalLineCount,
                                      LogContext
                                     );

    if(!inf) {
        SpFreeTemporaryParseStructures(X_Inf);
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    inf->Style = INF_STYLE_OLDNT;

    //
    // Now, parse the old-style inf structures into new-style inf structures.
    //
    b = TRUE;
    LineNumber = 0;
    ValueNumber = 0;
    for(X_Section=X_Inf->Section; b && X_Section; X_Section=X_Section->Next) {

        //
        // Add the section to the section block.
        //
        StringId = pStringTableAddString(inf->StringTable,
                                         X_Section->Name,
                                         STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE,
                                         NULL,0
                                        );
        if(StringId == -1) {
            b = FALSE;
        } else {
            inf->SectionBlock[inf->SectionCount].SectionName = StringId;
            inf->SectionBlock[inf->SectionCount].LineCount = X_Section->LineCount;
            inf->SectionBlock[inf->SectionCount].Lines = LineNumber;

            inf->SectionCount++;
        }

        for(X_Line=X_Section->Line; b && X_Line; X_Line=X_Line->Next) {

            //
            // Add the line to the line block.
            //
            inf->LineBlock[LineNumber].ValueCount = (WORD)X_Line->ValueCount;

            if(X_Line->Name) {
                inf->LineBlock[LineNumber].Flags = INF_LINE_HASKEY | INF_LINE_SEARCHABLE;
                inf->LineBlock[LineNumber].ValueCount++;
            } else if(X_Line->ValueCount == 1) {
                //
                // If the line only has a single value, then it's searchable, even if it
                // doesn't have a key.
                //
                inf->LineBlock[LineNumber].Flags = INF_LINE_SEARCHABLE;
                inf->LineBlock[LineNumber].ValueCount++;
            } else {
                inf->LineBlock[LineNumber].Flags = 0;
            }

            if(b) {

                inf->LineBlock[LineNumber].Values = ValueNumber;
                X_Value = X_Line->Value;

                //
                // If the line is searchable (i.e., has a key xor a single value), then add the
                // search value twice--once case insensitively and once case-sensitively.
                //
                if(ISSEARCHABLE(&(inf->LineBlock[LineNumber]))) {

                    if(X_Line->Name) {
                        SearchString = X_Line->Name;
                    } else {
                        SearchString = X_Value->Name;
                        X_Value = X_Value->Next;
                    }

                    //
                    // First get the case-sensitive string id...
                    //
                    StringId = pStringTableAddString(
                                    inf->StringTable,
                                    SearchString,
                                    STRTAB_CASE_SENSITIVE,
                                    NULL,0
                                    );
                    //
                    // And now get the case-insensitive string id...
                    //
                    StringId2 = pStringTableAddString(inf->StringTable,
                                                      SearchString,
                                                      STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE,
                                                      NULL,0
                                                     );

                    if((StringId == -1) || (StringId2 == -1)) {
                        b = FALSE;
                    } else {
                        inf->ValueBlock[ValueNumber++] = StringId2;  // Add the searchable string...
                        inf->ValueBlock[ValueNumber++] = StringId;   // and then the displayable one.
                    }
                }

                for( ; b && X_Value; X_Value=X_Value->Next) {

                    //
                    // Add the value to the value block.
                    //
                    StringId = pStringTableAddString(inf->StringTable,
                                                     X_Value->Name,
                                                     STRTAB_CASE_SENSITIVE,
                                                     NULL,0
                                                    );
                    if(StringId == -1) {
                        b = FALSE;
                    } else {
                        inf->ValueBlock[ValueNumber++] = StringId;
                    }
                }

                LineNumber++;
            }
        }
    }

    //
    // Record the sizes of the INF data blocks.
    //
    inf->SectionBlockSizeBytes = X_Inf->SectionCount * sizeof(INF_SECTION);
    inf->LineBlockSizeBytes    = X_Inf->TotalLineCount * sizeof(INF_LINE);

    //
    // We don't need the temporary inf descriptors any more.
    //
    SpFreeTemporaryParseStructures(X_Inf);

    //
    // Attempt to trim the value block down to exact size necessary.  Since this buffer is
    // either shrinking or staying the same, the realloc shouldn't fail, but if it does, we'll
    // just continue to use the original block.
    //
    inf->ValueBlockSizeBytes = ValueNumber * sizeof(LONG);
    if(TempValueBlock = MyRealloc(inf->ValueBlock, ValueNumber * sizeof(LONG))) {
        inf->ValueBlock = TempValueBlock;
    }

    //
    // If an error has occured, free the inf descriptor we've
    // been building. Otherwise we want to pass that descriptor
    // back to the caller.
    //
    if(b) {
        *Inf = inf;
    } else {
        *ErrorLineNumber = 0;
        FreeLoadedInfDescriptor(inf);
    }

    return(b ? NO_ERROR : ERROR_NOT_ENOUGH_MEMORY);
}


DWORD
ProcessOldInfVersionBlock(
    IN PLOADED_INF Inf
    )

/*++

Routine Description:

    Set up a version node for an old-style inf file. The version node is
    simulated in that there is no [Version] section; we look for other stuff
    in the file to simulate version information.

    Class is determined from [Identification].OptionType.
    Signature is determined from [Signature].FileType.
    If the signature is MICROSOFT_FILE then we set the Provider to the localized
    version of "Microsoft."

Arguments:

    Inf - supplies a pointer to the inf descriptor for the file.

Return Value:

    Win32 error code (with inf extensions) indicating outcome.

--*/

{
    TCHAR StrBuf[128];
    PTSTR String;

    //
    // Class
    //
    if(String = InfGetKeyOrValue(Inf, TEXT("Identification"), TEXT("OptionType"), 0, 1, NULL)) {
        if(!AddDatumToVersionBlock(&(Inf->VersionBlock), pszClass, String)) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    //
    // Signature
    //
    if(String = InfGetKeyOrValue(Inf, pszSignature, TEXT("FileType"), 0, 1, NULL)) {
        if(!AddDatumToVersionBlock(&(Inf->VersionBlock), pszSignature, String)) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    //
    // Provider
    //
    if(String && !_tcsicmp(String, TEXT("MICROSOFT_FILE"))) {

        LoadString(MyDllModuleHandle, IDS_MICROSOFT, StrBuf, sizeof(StrBuf)/sizeof(TCHAR));

        if(!AddDatumToVersionBlock(&(Inf->VersionBlock), pszProvider, StrBuf)) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\setupapi\infopenv.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    infopenv.c

Abstract:

    Externally exposed INF routines for INF opening, closing,
    and versioning.

Author:

    Ted Miller (tedm) 20-Jan-1995

Revision History:

    Jamie Hunter (JamieHun) May-2-2002
            Security code review

--*/

#include "precomp.h"
#pragma hdrstop


BOOL
pSetupVersionNodeFromInfInformation(
    IN  PSP_INF_INFORMATION InfInformation,
    IN  UINT                InfIndex,
    OUT PINF_VERSION_NODE   VersionNode,
    OUT PTSTR               OriginalFilename OPTIONAL
    );


#ifdef UNICODE
//
// ANSI version
//
BOOL
SetupGetInfInformationA(
    IN  LPCVOID             InfSpec,
    IN  DWORD               SearchControl,
    OUT PSP_INF_INFORMATION ReturnBuffer,     OPTIONAL
    IN  DWORD               ReturnBufferSize,
    OUT PDWORD              RequiredSize      OPTIONAL
    )
{
    PCWSTR infspec;
    BOOL b;
    DWORD rc;

    //
    // For this API, the return buffer does not have to be translated
    // from Unicode to ANSI. This makes things much easier since the
    // required size is the same for the ANSI and Unicode versions.
    //
    if((SearchControl == INFINFO_INF_NAME_IS_ABSOLUTE)
    || (SearchControl == INFINFO_DEFAULT_SEARCH)
    || (SearchControl == INFINFO_REVERSE_DEFAULT_SEARCH)
    || (SearchControl == INFINFO_INF_PATH_LIST_SEARCH)) {

        rc = pSetupCaptureAndConvertAnsiArg(InfSpec,&infspec);
        if(rc != NO_ERROR) {
            SetLastError(rc);
            return(FALSE);
        }

    } else {
        //
        // Not a pointer to a string, just pass it on.
        //
        infspec = InfSpec;
    }

    //
    // Note that the data returned from this API is in an
    // internal format, and thus we don't need any less space
    // for the ANSI API, and can just use the buffer and sizes
    // passed in by the caller.
    //
    b = SetupGetInfInformationW(
            infspec,
            SearchControl,
            ReturnBuffer,
            ReturnBufferSize,
            RequiredSize
            );

    rc = GetLastError();

    if(infspec != InfSpec) {
        MyFree(infspec);
    }

    SetLastError(rc);
    return(b);
}
#else
//
// Unicode stub
//
BOOL
SetupGetInfInformationW(
    IN  LPCVOID             InfSpec,
    IN  DWORD               SearchControl,
    OUT PSP_INF_INFORMATION ReturnBuffer,     OPTIONAL
    IN  DWORD               ReturnBufferSize,
    OUT PDWORD              RequiredSize      OPTIONAL
    )
{
    UNREFERENCED_PARAMETER(InfSpec);
    UNREFERENCED_PARAMETER(SearchControl);
    UNREFERENCED_PARAMETER(ReturnBuffer);
    UNREFERENCED_PARAMETER(ReturnBufferSize);
    UNREFERENCED_PARAMETER(RequiredSize);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif

BOOL
SetupGetInfInformation(
    IN  LPCVOID             InfSpec,
    IN  DWORD               SearchControl,
    OUT PSP_INF_INFORMATION ReturnBuffer,     OPTIONAL
    IN  DWORD               ReturnBufferSize,
    OUT PDWORD              RequiredSize      OPTIONAL
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    BOOL UnloadInf;
    PLOADED_INF Inf, CurInf;
    UINT InfCount;
    PUCHAR Out;
    DWORD TotalSpaceRequired;
    DWORD d;
    DWORD ErrorLineNumber;
    TCHAR Path[MAX_PATH];
    PINF_VERSION_NODE VersionNode;
    INF_VERSION_BLOCK UNALIGNED *Prev;
    BOOL TryPnf;
    WIN32_FIND_DATA FindData;
    PTSTR DontCare;
    UINT OriginalFilenameSize;

    //
    // Set up some state based on the SearchSpec parameter.
    //
    Inf = NULL;
    switch(SearchControl) {

    case INFINFO_INF_SPEC_IS_HINF:

        Inf = (PLOADED_INF)InfSpec;
        d = NO_ERROR;
        try {
            if (!LockInf(Inf)) {
                d = ERROR_INVALID_HANDLE;
            }
        } except(EXCEPTION_EXECUTE_HANDLER) {
            d = ERROR_INVALID_HANDLE;
        }
        if (d != NO_ERROR) {
            SetLastError(d);
            return FALSE;
        }
        break;

    case INFINFO_INF_NAME_IS_ABSOLUTE:
        //
        // Make sure we have a fully-qualified path.
        //
        d = GetFullPathName((PCTSTR)InfSpec,
                            SIZECHARS(Path),
                            Path,
                            &DontCare
                           );
        if(!d) {
            //
            // LastError has already been set
            // (unless InfSpec was NULL or "")
            //
            if (GetLastError()==NO_ERROR) {
                SetLastError(ERROR_FILE_NOT_FOUND);
            }
            return FALSE;
        } else if(d >= SIZECHARS(Path)) {
            MYASSERT(0);
            SetLastError(ERROR_BUFFER_OVERFLOW);
            return FALSE;
        }

        if(FileExists(Path, &FindData)) {
            InfSourcePathFromFileName(Path, NULL, &TryPnf);
            break;
        } else {
            //
            // LastError has already been set.
            //
            return FALSE;
        }

    case INFINFO_DEFAULT_SEARCH:
    case INFINFO_REVERSE_DEFAULT_SEARCH:
    case INFINFO_INF_PATH_LIST_SEARCH:

        try {
            d = SearchForInfFile((PCTSTR)InfSpec,
                                 &FindData,
                                 SearchControl,
                                 Path,
                                 SIZECHARS(Path),
                                 NULL
                                );
        } except(EXCEPTION_EXECUTE_HANDLER) {
            d = ERROR_INVALID_PARAMETER;
        }
        if(d == NO_ERROR) {
            TryPnf = TRUE;
            break;
        } else {
            SetLastError(d);
            return FALSE;
        }

    default:
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    //
    // Load the inf if necessary.
    //
    if(Inf) {
        UnloadInf = FALSE;
    } else {

        d = LoadInfFile(Path,
                        &FindData,
                        INF_STYLE_ALL,
                        TryPnf ? LDINF_FLAG_ALWAYS_TRY_PNF : 0,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        NULL, // LogContext
                        &Inf,
                        &ErrorLineNumber,
                        NULL
                       );

        if(d != NO_ERROR) {
            SetLastError(d);
            return(FALSE);
        }

        UnloadInf = TRUE;
    }

    //
    // Determine the number of infs associated with this handle,
    // and calculate the amount of space that will be needed to
    // store version information about them.
    //
    // For each inf we will need space for the version block,
    // as well as an offset in the SP_INF_INFORMATION structure
    // to indicate where that inf's version block is located
    // in the output buffer.
    //
    TotalSpaceRequired = offsetof(SP_INF_INFORMATION, VersionData);
    for(InfCount = 0, CurInf = Inf;
        CurInf;
        InfCount++, CurInf = CurInf->Next)
    {
        OriginalFilenameSize = CurInf->OriginalInfName
                             ? (lstrlen(CurInf->OriginalInfName) + 1) * sizeof(TCHAR)
                             : 0;

        TotalSpaceRequired += (offsetof(INF_VERSION_BLOCK, Filename) +
                               CurInf->VersionBlock.FilenameSize +
                               CurInf->VersionBlock.DataSize +
                               OriginalFilenameSize
                              );
    }

    if(RequiredSize) {
        *RequiredSize = TotalSpaceRequired;
    }

    //
    // See if we have a large enough output buffer.
    // If we have a large enough buffer then set up some
    // initial values in it.
    //
    if(ReturnBufferSize < TotalSpaceRequired) {
        if(UnloadInf) {
            FreeInfFile(Inf);
        } else {
            UnlockInf(Inf);
        }
        if(ReturnBuffer) {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            return FALSE;
        } else {
            return TRUE;
        }
    }

    d = NO_ERROR;

    try {
        ReturnBuffer->InfStyle = Inf->Style;
        ReturnBuffer->InfCount = InfCount;
    } except(EXCEPTION_EXECUTE_HANDLER) {
        if(UnloadInf) {
            FreeInfFile(Inf);
        } else {
            UnlockInf(Inf);
        }
        SetLastError(d = ERROR_INVALID_PARAMETER);
    }

    if(d != NO_ERROR) {
        return FALSE;
    }

    Out = (PUCHAR)ReturnBuffer + offsetof(SP_INF_INFORMATION, VersionData);

    //
    // Traverse all infs associated with this inf handle and copy
    // version data into the caller's buffer. Guard with SEH to ensure
    // that the caller passed a valid buffer.
    //
    try {
        Prev = NULL;
        for(CurInf = Inf; CurInf; CurInf = CurInf->Next) {
            //
            // Store offset into
            //
            if(Prev) {
                Prev->NextOffset = (UINT)((UINT_PTR)Out - (UINT_PTR)ReturnBuffer);
            }
            Prev = (PVOID)Out;

            OriginalFilenameSize = CurInf->OriginalInfName
                                 ? (lstrlen(CurInf->OriginalInfName) + 1) * sizeof(TCHAR)
                                 : 0;

            Prev->LastWriteTime = CurInf->VersionBlock.LastWriteTime;
            Prev->DatumCount    = CurInf->VersionBlock.DatumCount;
            Prev->OffsetToData  = CurInf->VersionBlock.FilenameSize + OriginalFilenameSize;
            Prev->DataSize      = CurInf->VersionBlock.DataSize;
            Prev->TotalSize     = offsetof(INF_VERSION_BLOCK, Filename) +
                                      CurInf->VersionBlock.FilenameSize +
                                      OriginalFilenameSize +
                                      CurInf->VersionBlock.DataSize;

            Out += offsetof(INF_VERSION_BLOCK, Filename);

            //
            // Now copy the filename, (optionally) original filename, and
            // version data into the output buffer.
            //
            CopyMemory(Out, CurInf->VersionBlock.Filename, CurInf->VersionBlock.FilenameSize);
            Out += CurInf->VersionBlock.FilenameSize;

            if(CurInf->OriginalInfName) {
                CopyMemory(Out, CurInf->OriginalInfName, OriginalFilenameSize);
                Out += OriginalFilenameSize;
            }

            CopyMemory(Out, CurInf->VersionBlock.DataBlock, CurInf->VersionBlock.DataSize);
            Out += CurInf->VersionBlock.DataSize;
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        if(UnloadInf) {
            FreeInfFile(Inf);
        } else {
            UnlockInf(Inf);
        }
        SetLastError(d = ERROR_INVALID_PARAMETER);
    }

    if(d != NO_ERROR) {
        return FALSE;
    }

    Prev->NextOffset = 0;

    //
    // Unload the inf if necessary
    //
    if(UnloadInf) {
        FreeInfFile(Inf);
    } else {
        UnlockInf(Inf);
    }

    return TRUE;
}


#ifdef UNICODE
//
// ANSI version
//
BOOL
SetupQueryInfFileInformationA(
    IN  PSP_INF_INFORMATION InfInformation,
    IN  UINT                InfIndex,
    OUT PSTR                ReturnBuffer,     OPTIONAL
    IN  DWORD               ReturnBufferSize,
    OUT PDWORD              RequiredSize      OPTIONAL
    )
{
    WCHAR returnbuffer[MAX_PATH];
    DWORD requiredsize;
    DWORD rc;
    PSTR ansi;
    BOOL b;

    b = SetupQueryInfFileInformationW(
            InfInformation,
            InfIndex,
            returnbuffer,
            MAX_PATH,
            &requiredsize
            );

    rc = GetLastError();

    if(b) {
        if(ansi = pSetupUnicodeToAnsi(returnbuffer)) {

            rc = NO_ERROR;
            requiredsize = lstrlenA(ansi)+1;

            if(RequiredSize) {
                try {
                    *RequiredSize = requiredsize;
                } except(EXCEPTION_EXECUTE_HANDLER) {
                    rc = ERROR_INVALID_PARAMETER;
                    b = FALSE;
                }
            }

            if(b) {
                if(ReturnBuffer) {
                    if(ReturnBufferSize >= requiredsize) {
                        //
                        // lstrcpy returns NULL if it faults
                        //
                        if(!lstrcpyA(ReturnBuffer,ansi)) {
                            rc = ERROR_INVALID_PARAMETER;
                            b = FALSE;
                        }
                    } else {
                        b = FALSE;
                        rc = ERROR_INSUFFICIENT_BUFFER;
                    }
                }
            }

            MyFree(ansi);
        } else {
            rc = ERROR_NOT_ENOUGH_MEMORY;
            b = FALSE;
        }
    }

    SetLastError(rc);
    return(b);
}
#else
//
// Unicode stub
//
BOOL
SetupQueryInfFileInformationW(
    IN  PSP_INF_INFORMATION InfInformation,
    IN  UINT                InfIndex,
    OUT PWSTR               ReturnBuffer,     OPTIONAL
    IN  DWORD               ReturnBufferSize,
    OUT PDWORD              RequiredSize      OPTIONAL
    )
{
    UNREFERENCED_PARAMETER(InfInformation);
    UNREFERENCED_PARAMETER(InfIndex);
    UNREFERENCED_PARAMETER(ReturnBuffer);
    UNREFERENCED_PARAMETER(ReturnBufferSize);
    UNREFERENCED_PARAMETER(RequiredSize);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif

BOOL
SetupQueryInfFileInformation(
    IN  PSP_INF_INFORMATION InfInformation,
    IN  UINT                InfIndex,
    OUT PTSTR               ReturnBuffer,     OPTIONAL
    IN  DWORD               ReturnBufferSize,
    OUT PDWORD              RequiredSize      OPTIONAL
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    UINT FilenameLength;
    INF_VERSION_NODE VersionNode;
    DWORD rc;

    //
    // See whether the index is in range and
    // retrieve the version descriptor for this inf.
    //
    rc = NO_ERROR;
    try {
        if(!pSetupVersionNodeFromInfInformation(InfInformation,InfIndex,&VersionNode,NULL)) {
            rc = ERROR_INVALID_PARAMETER;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        rc = ERROR_INVALID_PARAMETER;
    }
    if(rc != NO_ERROR) {
        SetLastError(rc);
        return(FALSE);
    }

    FilenameLength = VersionNode.FilenameSize / sizeof(TCHAR);

    if(RequiredSize) {
        try {
            *RequiredSize = FilenameLength;
        } except(EXCEPTION_EXECUTE_HANDLER) {
            rc = ERROR_INVALID_PARAMETER;
        }
        if(rc != NO_ERROR) {
            SetLastError(rc);
            return(FALSE);
        }
    }

    //
    // Check length of user's buffer.
    //
    if(FilenameLength > ReturnBufferSize) {
        if(ReturnBuffer) {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            return FALSE;
        } else {
            return TRUE;
        }
    }

    //
    // Copy the data into user's buffer.
    //
    try {
        CopyMemory(ReturnBuffer,VersionNode.Filename,VersionNode.FilenameSize);
    } except(EXCEPTION_EXECUTE_HANDLER) {
        rc = ERROR_INVALID_PARAMETER;
    }

    if(rc != NO_ERROR) {
        SetLastError(rc);
        return(FALSE);
    }

    return TRUE;
}


#ifdef UNICODE
//
// ANSI version
//
BOOL
WINAPI
SetupQueryInfOriginalFileInformationA(
    IN  PSP_INF_INFORMATION      InfInformation,
    IN  UINT                     InfIndex,
    IN  PSP_ALTPLATFORM_INFO_V2  AlternatePlatformInfo, OPTIONAL
    OUT PSP_ORIGINAL_FILE_INFO_A OriginalFileInfo
    )
{
    SP_ORIGINAL_FILE_INFO_W UnicodeOriginalFileInfo;
    DWORD rc;
    int i;
    BOOL b;

    rc = NO_ERROR;

    //
    // Do an initial check on user-supplied output buffer to see if it seems
    // to be valid.
    //
    try {
        if(OriginalFileInfo->cbSize != sizeof(SP_ORIGINAL_FILE_INFO_A)) {
            rc = ERROR_INVALID_USER_BUFFER;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        rc = ERROR_INVALID_PARAMETER;
    }

    if(rc != NO_ERROR) {
        SetLastError(rc);
        return FALSE;
    }

    UnicodeOriginalFileInfo.cbSize = sizeof(SP_ORIGINAL_FILE_INFO_W);

    b = SetupQueryInfOriginalFileInformationW(
            InfInformation,
            InfIndex,
            AlternatePlatformInfo,
            &UnicodeOriginalFileInfo
           );

    rc = GetLastError();

    if(b) {
        //
        // Convert the Unicode fields of the original file info structure into
        // ANSI, and store the information in the caller-supplied ANSI
        // structure.
        //
        try {
            //
            // First, translate/store the original INF name...
            //
            i = WideCharToMultiByte(
                    CP_ACP,
                    0,
                    UnicodeOriginalFileInfo.OriginalInfName,
                    -1,
                    OriginalFileInfo->OriginalInfName,
                    SIZECHARS(OriginalFileInfo->OriginalInfName),
                    NULL,
                    NULL
                    );

            //
            // ...and if that succeeded, then translate/store the original
            // catalog filename.
            //
            if(i) {
                //
                // Note that the original catalog filename may be the empty
                // string (i.e., the INF didn't specify an associated catalog
                // file).  We don't need to special-case this, since
                // WideCharToMultiByte can handle empty strings just fine.
                //
                i = WideCharToMultiByte(
                        CP_ACP,
                        0,
                        UnicodeOriginalFileInfo.OriginalCatalogName,
                        -1,
                        OriginalFileInfo->OriginalCatalogName,
                        SIZECHARS(OriginalFileInfo->OriginalCatalogName),
                        NULL,
                        NULL
                        );
            }

            if(!i) {
                b = FALSE;
                rc = GetLastError();
                //
                // If we start seeing cases where our Unicode->ANSI expansion
                // blows our buffersize, we need to know about it...
                //
                MYASSERT((rc != NO_ERROR) && (rc != ERROR_INSUFFICIENT_BUFFER));
            }
        } except(EXCEPTION_EXECUTE_HANDLER) {
            rc = ERROR_INVALID_PARAMETER;
            b = FALSE;
        }
    }

    SetLastError(rc);

    return b;
}
#else
//
// Unicode stub
//
BOOL
WINAPI
SetupQueryInfOriginalFileInformationW(
    IN  PSP_INF_INFORMATION      InfInformation,
    IN  UINT                     InfIndex,
    IN  PSP_ALTPLATFORM_INFO_V2  AlternatePlatformInfo, OPTIONAL
    OUT PSP_ORIGINAL_FILE_INFO_W OriginalFileInfo
    )
{
    UNREFERENCED_PARAMETER(InfInformation);
    UNREFERENCED_PARAMETER(InfIndex);
    UNREFERENCED_PARAMETER(AlternatePlatformInfo);
    UNREFERENCED_PARAMETER(OriginalFileInfo);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif

BOOL
WINAPI
SetupQueryInfOriginalFileInformation(
    IN  PSP_INF_INFORMATION      InfInformation,
    IN  UINT                     InfIndex,
    IN  PSP_ALTPLATFORM_INFO_V2  AlternatePlatformInfo, OPTIONAL
    OUT PSP_ORIGINAL_FILE_INFO   OriginalFileInfo
    )

/*++

Routine Description:

    This routine returns an INF's original name (which will be different from
    its current name if the INF was installed into %windir%\Inf, for example).
    If the INF's original name is the same as its current name, the current
    name is returned.

    It also returns the original filename of the catalog file specified by the
    INF via a (potentially decorated) CatalogFile= entry in the INF's [version]
    section.  The OS/architecture-specific decoration may be overridden from
    the default (i.e., current platform) by passing in an optional alternate
    platform information structure.  If the INF doesn't specify any catalog
    file, then this field in the output OriginalFileInfo structure will be set
    to an empty string.

    Both filenames returned in the OriginalFileInfo are simple filenames, i.e.,
    there is no path information included.

Arguments:

    InfInformation - supplies context from which we retrieve information about
        the INF whose index is specified by InfIndex.

    InfIndex - supplies the zero-based index of the INF within the
        InfInformation context buffer that we're retrieving original file
        information for.

    AlternatePlatformInfo - optionally, supplies alternate platform information
        used when searching for the appropriately decorated CatalogFile= entry
        within the INF's [version] section.

        (NOTE: caller may actually pass in a V1 struct instead--we detect this
        case and convert the V1 struct into a V2 one.)

    OriginalFileInfo - supplies the address of an original file information
        buffer that upon success receives information about the original
        (simple) filenames of files associated with this INF.  This structure
        must have its cbSize field set to sizeof(SP_ORIGINAL_FILE_INFO) upon
        entry to this routine or the call will fail with GetLastError()
        returning ERROR_INVALID_USER_BUFFER.

        The fields of this structure are set upon successful return as follows:

        OriginalInfName - receives the INF's original filename, which may be
            different than its current filename in the case where the INF was
            an OEM in that was installed into the %windir%\Inf directory (e.g.,
            via SetupCopyOEMInf).

        OriginalCatalogName - receives the platform-appropriate CatalogFile=
            entry in the INF's [version] section (where the platform is the
            default native one unless AlternatePlatformInfo is supplied).  If
            there is no applicable CatalogFile= entry, this field will be set
            to the empty string.

Return Value:

    If successful, the return value is non-zero.
    If unsuccessful, the return value is FALSE, and GetLastError() may be
    called to determine the cause of failure.

--*/

{
    INF_VERSION_NODE VersionNode;
    DWORD rc;
    SP_ALTPLATFORM_INFO_V2 AltPlatformInfoV2;

    rc = NO_ERROR;
    //
    // See whether the index is in range and retrieve the version descriptor
    // and original filename for this inf.
    //
    try {
        //
        // Do an initial check on user-supplied output buffer to see if it
        // seems to be valid.
        //
        if(OriginalFileInfo->cbSize != sizeof(SP_ORIGINAL_FILE_INFO)) {
            rc = ERROR_INVALID_USER_BUFFER;
            goto clean0;
        }

        //
        // Now validate the AlternatePlatformInfo parameter.
        //
        if(AlternatePlatformInfo) {

            if(AlternatePlatformInfo->cbSize != sizeof(SP_ALTPLATFORM_INFO_V2)) {
                //
                // The caller may have passed us in a Version 1 struct, or they
                // may have passed us in bad data...
                //
                if(AlternatePlatformInfo->cbSize == sizeof(SP_ALTPLATFORM_INFO_V1)) {
                    //
                    // Flags/Reserved field is reserved in V1
                    //
                    if(AlternatePlatformInfo->Reserved) {
                        rc = ERROR_INVALID_PARAMETER;
                        goto clean0;
                    }
                    //
                    // Convert the caller-supplied data into Version 2 format.
                    //
                    ZeroMemory(&AltPlatformInfoV2, sizeof(AltPlatformInfoV2));

                    AltPlatformInfoV2.cbSize                = sizeof(SP_ALTPLATFORM_INFO_V2);
                    AltPlatformInfoV2.Platform              = ((PSP_ALTPLATFORM_INFO_V1)AlternatePlatformInfo)->Platform;
                    AltPlatformInfoV2.MajorVersion          = ((PSP_ALTPLATFORM_INFO_V1)AlternatePlatformInfo)->MajorVersion;
                    AltPlatformInfoV2.MinorVersion          = ((PSP_ALTPLATFORM_INFO_V1)AlternatePlatformInfo)->MinorVersion;
                    AltPlatformInfoV2.ProcessorArchitecture = ((PSP_ALTPLATFORM_INFO_V1)AlternatePlatformInfo)->ProcessorArchitecture;
                    AltPlatformInfoV2.Flags                 = 0;
                    AlternatePlatformInfo = &AltPlatformInfoV2;

                } else {
                    rc = ERROR_INVALID_USER_BUFFER;
                    goto clean0;
                }
            }

            //
            // Gotta be either Windows or Windows NT
            //
            if((AlternatePlatformInfo->Platform != VER_PLATFORM_WIN32_WINDOWS) &&
               (AlternatePlatformInfo->Platform != VER_PLATFORM_WIN32_NT)) {

                rc = ERROR_INVALID_PARAMETER;
                goto clean0;
            }

            //
            // Processor had better be either i386, amd64, or ia64
            //
            if((AlternatePlatformInfo->ProcessorArchitecture != PROCESSOR_ARCHITECTURE_INTEL) &&
               (AlternatePlatformInfo->ProcessorArchitecture != PROCESSOR_ARCHITECTURE_IA64) &&
               (AlternatePlatformInfo->ProcessorArchitecture != PROCESSOR_ARCHITECTURE_AMD64)) {

                rc = ERROR_INVALID_PARAMETER;
                goto clean0;
            }

            //
            // MajorVersion field must be non-zero (MinorVersion field can be
            // anything)
            //
            if(!AlternatePlatformInfo->MajorVersion) {
                rc = ERROR_INVALID_PARAMETER;
                goto clean0;
            }
            //
            // Validate structure parameter flags (bits indicating what
            // parts of the structure are valid).
            //
            if((AlternatePlatformInfo->Flags & ~ (SP_ALTPLATFORM_FLAGS_VERSION_RANGE)) != 0) {
                rc = ERROR_INVALID_PARAMETER;
                goto clean0;
            }
            //
            // fill in version validation range if none supplied by caller
            //
            if((AlternatePlatformInfo->Flags & SP_ALTPLATFORM_FLAGS_VERSION_RANGE) == 0) {
                //
                // If caller does not know about FirstValidate*Version,
                // version upper and lower bounds are equal.
                //
                AlternatePlatformInfo->FirstValidatedMajorVersion = AlternatePlatformInfo->MajorVersion;
                AlternatePlatformInfo->FirstValidatedMinorVersion = AlternatePlatformInfo->MinorVersion;
                AlternatePlatformInfo->Flags |= SP_ALTPLATFORM_FLAGS_VERSION_RANGE;
            }


        }

        //
        // OK, now retrieve the INF's original filename...
        //
        if(!pSetupVersionNodeFromInfInformation(InfInformation,
                                                InfIndex,
                                                &VersionNode,
                                                OriginalFileInfo->OriginalInfName)) {
            rc = ERROR_INVALID_PARAMETER;
            goto clean0;
        }

        //
        // ...and retrieve the (platform-appropriate) catalog file associated
        // with this INF (if there is one).
        //
        if(!pSetupGetCatalogFileValue(&VersionNode,
                                      OriginalFileInfo->OriginalCatalogName,
                                      SIZECHARS(OriginalFileInfo->OriginalCatalogName),
                                      AlternatePlatformInfo)) {
            //
            // No applicable CatalogFile= entry found--set field to empty
            // string.
            //
            *(OriginalFileInfo->OriginalCatalogName) = TEXT('\0');
        }

clean0: ;   // nothing to do

    } except(EXCEPTION_EXECUTE_HANDLER) {
        rc = ERROR_INVALID_PARAMETER;
    }

    SetLastError(rc);
    return (rc == NO_ERROR);
}


#ifdef UNICODE
//
// ANSI version
//
BOOL
SetupQueryInfVersionInformationA(
    IN  PSP_INF_INFORMATION InfInformation,
    IN  UINT                InfIndex,
    IN  PCSTR               Key,              OPTIONAL
    OUT PSTR                ReturnBuffer,     OPTIONAL
    IN  DWORD               ReturnBufferSize,
    OUT PDWORD              RequiredSize      OPTIONAL
    )
{
    INF_VERSION_NODE VersionNode;
    PCWSTR Data;
    DWORD rc;
    PSTR ansidata;
    UINT ansilength;
    PCWSTR key;

    //
    // See whether the index is in range and
    // get pointer to version descriptor for this inf.
    //
    try {
        if(pSetupVersionNodeFromInfInformation(InfInformation,InfIndex,&VersionNode,NULL)) {
            //
            // See whether we want a specific value.
            //
            if(Key) {

                rc = pSetupCaptureAndConvertAnsiArg(Key,&key);
                if(rc == NO_ERROR) {

                    if(Data = pSetupGetVersionDatum(&VersionNode,key)) {

                        if(ansidata = pSetupUnicodeToAnsi(Data)) {

                            ansilength = lstrlenA(ansidata) + 1;
                            if(RequiredSize) {
                                *RequiredSize = ansilength;
                            }

                            if(ReturnBuffer) {
                                if(ReturnBufferSize >= ansilength) {
                                    CopyMemory(ReturnBuffer,ansidata,ansilength);
                                    rc = NO_ERROR;
                                } else {
                                    rc = ERROR_INSUFFICIENT_BUFFER;
                                }
                            } else {
                                rc = NO_ERROR;
                            }

                            MyFree(ansidata);
                        } else {
                            rc = ERROR_NOT_ENOUGH_MEMORY;
                        }
                    } else {
                        rc = ERROR_INVALID_DATA;
                    }

                    MyFree(key);
                }
            } else {
                //
                // Caller wants all values. Copy whole data block to caller's buffer,
                // plus a terminating NUL character.
                //
                // Maximum size the data could be in ansi is the exact same
                // size it is in unicode, if every char is a double-byte char.
                //
                if(ansidata = MyMalloc(VersionNode.DataSize)) {

                    ansilength = WideCharToMultiByte(
                                    CP_ACP,
                                    0,
                                    (PWSTR)VersionNode.DataBlock,
                                    VersionNode.DataSize / sizeof(WCHAR),
                                    ansidata,
                                    VersionNode.DataSize,
                                    NULL,
                                    NULL
                                    );

                    if(RequiredSize) {
                        //
                        // account for terminating nul
                        //
                        *RequiredSize = ansilength+1;
                    }

                    if(ReturnBuffer) {
                        if(ReturnBufferSize >= *RequiredSize) {
                            CopyMemory(ReturnBuffer,ansidata,ansilength);
                            ReturnBuffer[ansilength] = 0;
                            rc = NO_ERROR;
                        } else {
                            rc = ERROR_INSUFFICIENT_BUFFER;
                        }
                    } else {
                        rc = NO_ERROR;
                    }

                    MyFree(ansidata);
                } else {
                    rc = ERROR_NOT_ENOUGH_MEMORY;
                }
            }
        } else {
            rc = ERROR_INVALID_PARAMETER;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        rc = ERROR_INVALID_PARAMETER;
    }

    SetLastError(rc);
    return(rc == NO_ERROR);
}
#else
//
// Unicode stub
//
BOOL
SetupQueryInfVersionInformationW(
    IN  PSP_INF_INFORMATION InfInformation,
    IN  UINT                InfIndex,
    IN  PCWSTR              Key,              OPTIONAL
    OUT PWSTR               ReturnBuffer,     OPTIONAL
    IN  DWORD               ReturnBufferSize,
    OUT PDWORD              RequiredSize      OPTIONAL
    )
{
    UNREFERENCED_PARAMETER(InfInformation);
    UNREFERENCED_PARAMETER(InfIndex);
    UNREFERENCED_PARAMETER(Key);
    UNREFERENCED_PARAMETER(ReturnBuffer);
    UNREFERENCED_PARAMETER(ReturnBufferSize);
    UNREFERENCED_PARAMETER(RequiredSize);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif

BOOL
SetupQueryInfVersionInformation(
    IN  PSP_INF_INFORMATION InfInformation,
    IN  UINT                InfIndex,
    IN  PCTSTR              Key,              OPTIONAL
    OUT PTSTR               ReturnBuffer,     OPTIONAL
    IN  DWORD               ReturnBufferSize,
    OUT PDWORD              RequiredSize      OPTIONAL
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    INF_VERSION_NODE VersionNode;
    PCTSTR Data;
    UINT DataLength;
    DWORD rc;

    //
    // See whether the index is in range and
    // get pointer to version descriptor for this inf.
    //
    try {
        if(pSetupVersionNodeFromInfInformation(InfInformation,InfIndex,&VersionNode,NULL)) {
            //
            // See whether we want a specific value.
            //
            if(Key) {
                if(Data = pSetupGetVersionDatum(&VersionNode,Key)) {

                    DataLength = lstrlen(Data) + 1;
                    if(RequiredSize) {
                        *RequiredSize = DataLength;
                    }

                    if(ReturnBuffer) {
                        if(ReturnBufferSize >= DataLength) {
                            CopyMemory(ReturnBuffer,Data,DataLength * sizeof(TCHAR));
                            rc = NO_ERROR;
                        } else {
                            rc = ERROR_INSUFFICIENT_BUFFER;
                        }
                    } else {
                        rc = NO_ERROR;
                    }
                } else {
                    rc = ERROR_INVALID_DATA;
                }
            } else {
                //
                // Caller wants all values. Copy whole data block to caller's buffer,
                // plus a terminating NUL character.
                //
                DataLength = (VersionNode.DataSize / sizeof(TCHAR)) + 1;
                if(RequiredSize) {
                    *RequiredSize = DataLength;
                }

                if(ReturnBuffer) {
                    if(ReturnBufferSize >= DataLength) {
                        CopyMemory(ReturnBuffer,VersionNode.DataBlock,VersionNode.DataSize);
                        ReturnBuffer[VersionNode.DataSize/sizeof(TCHAR)] = 0;
                        rc = NO_ERROR;
                    } else {
                        rc = ERROR_INSUFFICIENT_BUFFER;
                    }
                } else {
                    rc = NO_ERROR;
                }
            }
        } else {
            rc = ERROR_INVALID_PARAMETER;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        rc = ERROR_INVALID_PARAMETER;
    }

    SetLastError(rc);
    return(rc == NO_ERROR);
}



BOOL
_SetupGetInfFileList(
    IN  PCTSTR DirectoryPath,    OPTIONAL
    IN  DWORD  InfStyle,
    OUT PVOID  ReturnBuffer,     OPTIONAL
    IN  DWORD  ReturnBufferSize,
    OUT PDWORD RequiredSize      OPTIONAL
#ifdef UNICODE
    IN ,BOOL   ConvertToAnsi
#endif
    )
{
    TCHAR SearchSpec[MAX_PATH];
    PTCHAR FilenameStart;
    WIN32_FIND_DATA FindData;
    HANDLE FindHandle;
    DWORD Style;
    UINT FileNameLength;
    DWORD RemainingSpaceInBuffer;
    DWORD CurrentOffsetInBuffer;
    DWORD TotalSpaceNeededInBuffer;
    BOOL InsufficientBuffer;
    DWORD d;
    PTSTR DontCare;
#ifdef UNICODE
    CHAR ansi[MAX_PATH];
#endif

    //
    // Set up the search directory
    //
    if(DirectoryPath) {
        //
        // Make sure this directory path is fully-qualified.
        //
        d = GetFullPathName(DirectoryPath,
                            SIZECHARS(SearchSpec),
                            SearchSpec,
                            &DontCare
                           );

        if(!d) {
            //
            // LastError has already been set.
            //
            return FALSE;
        } else if(d >= SIZECHARS(SearchSpec)) {
            MYASSERT(0);
            SetLastError(ERROR_BUFFER_OVERFLOW);
            return FALSE;
        }

    } else {
        lstrcpyn(SearchSpec, InfDirectory,SIZECHARS(SearchSpec));
    }

    pSetupConcatenatePaths(SearchSpec, pszInfWildcard, SIZECHARS(SearchSpec), NULL);
    FilenameStart = (PTSTR)pSetupGetFileTitle(SearchSpec);

    FindHandle = FindFirstFile(SearchSpec,&FindData);
    if(FindHandle == INVALID_HANDLE_VALUE) {
        d = GetLastError();
        if((d == ERROR_NO_MORE_FILES) || (d == ERROR_FILE_NOT_FOUND) || (d == ERROR_PATH_NOT_FOUND)) {
            if(RequiredSize) {
                d = NO_ERROR;
                try {
                    *RequiredSize = 1;
                } except(EXCEPTION_EXECUTE_HANDLER) {
                    d = ERROR_INVALID_PARAMETER;
                }
                if(d != NO_ERROR) {
                    SetLastError(d);
                    return(FALSE);
                }
            }
            if(ReturnBuffer) {
                if(ReturnBufferSize) {
                    d = NO_ERROR;
                    try {
#ifdef UNICODE
                        if(ConvertToAnsi) {
                            *(PCHAR)ReturnBuffer = 0;
                        } else
#endif
                        *(PTCHAR)ReturnBuffer = 0;
                    } except(EXCEPTION_EXECUTE_HANDLER) {
                        d = ERROR_INVALID_PARAMETER;
                    }
                    SetLastError(d);
                    return(d == NO_ERROR);
                } else {
                    SetLastError(ERROR_INSUFFICIENT_BUFFER);
                    return FALSE;
                }
            } else {
                return TRUE;
            }
        }
        SetLastError(d);
        return(FALSE);
    }

    //
    // Leave space for the extra terminating nul char.
    //
    RemainingSpaceInBuffer = ReturnBufferSize;
    if(RemainingSpaceInBuffer) {
        RemainingSpaceInBuffer--;
    }

    TotalSpaceNeededInBuffer = 1;
    CurrentOffsetInBuffer = 0;

    InsufficientBuffer = FALSE;
    d = NO_ERROR;

    do {
        //
        // Skip directories
        //
        if(FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
            continue;
        }

        //
        // Form full pathname of file in SearchSpec.
        //
        lstrcpy(FilenameStart,FindData.cFileName);

        //
        // Determine the inf type and see whether the caller
        // wants to know about infs of this type.
        //
        Style = DetermineInfStyle(SearchSpec, &FindData);
        if((Style == INF_STYLE_NONE) || !(Style & InfStyle)) {
            continue;
        }

        //
        // Got a legit inf file.
        //
#ifdef UNICODE
        if(ConvertToAnsi) {
            //
            // The nul is included because it's converted
            // so no need to add 1
            //
            FileNameLength = WideCharToMultiByte(
                                CP_ACP,
                                0,
                                FindData.cFileName,
                                -1,
                                ansi,
                                MAX_PATH,
                                NULL,
                                NULL
                                );
        } else
#endif
        FileNameLength = lstrlen(FindData.cFileName) + 1;

        TotalSpaceNeededInBuffer += FileNameLength;

        if(ReturnBuffer) {

            if(RemainingSpaceInBuffer >= FileNameLength ) {

                RemainingSpaceInBuffer -= FileNameLength;

                //
                // lstrcpy will return NULL if it faults
                //
#ifdef UNICODE
                if(ConvertToAnsi) {
                    DontCare = (PVOID)lstrcpyA((PCHAR)ReturnBuffer+CurrentOffsetInBuffer,ansi);
                } else
#endif
                DontCare = lstrcpy((PTCHAR)ReturnBuffer+CurrentOffsetInBuffer,FindData.cFileName);

                if(!DontCare) {

                    d = ERROR_INVALID_PARAMETER;

                } else {

                    CurrentOffsetInBuffer += FileNameLength;

                    try {
#ifdef UNICODE
                        if(ConvertToAnsi) {
                            ((PCHAR)ReturnBuffer)[CurrentOffsetInBuffer] = 0;
                        } else
#endif
                        ((PTCHAR)ReturnBuffer)[CurrentOffsetInBuffer] = 0;
                    } except(EXCEPTION_EXECUTE_HANDLER) {
                        d = ERROR_INVALID_PARAMETER;
                    }
                }
            } else {
                InsufficientBuffer = TRUE;
            }
        }

    } while((d == NO_ERROR) && FindNextFile(FindHandle,&FindData));

    FindClose(FindHandle);

    if(d != NO_ERROR) {
        SetLastError(d);
    }

    if(GetLastError() == ERROR_NO_MORE_FILES) {

        d = NO_ERROR;

        try {
            if(RequiredSize) {
                *RequiredSize = TotalSpaceNeededInBuffer;
            }
        } except(EXCEPTION_EXECUTE_HANDLER) {
            d = ERROR_INVALID_PARAMETER;
        }

        if(d == NO_ERROR) {
            if(InsufficientBuffer) {
                SetLastError(ERROR_INSUFFICIENT_BUFFER);
                return FALSE;
            }
            return(TRUE);
        } else {
            SetLastError(d);
        }
    }

    //
    // Last error already set
    //
    return(FALSE);
}

#ifdef UNICODE
//
// ANSI version
//
BOOL
SetupGetInfFileListA(
    IN  PCSTR  DirectoryPath,    OPTIONAL
    IN  DWORD  InfStyle,
    OUT PSTR   ReturnBuffer,     OPTIONAL
    IN  DWORD  ReturnBufferSize,
    OUT PDWORD RequiredSize      OPTIONAL
    )
{
    PWSTR dirpath;
    DWORD rc;
    BOOL b;

    if(DirectoryPath) {
        rc = pSetupCaptureAndConvertAnsiArg(DirectoryPath,&dirpath);
        if(rc != NO_ERROR) {
            SetLastError(rc);
            return(FALSE);
        }
    } else {
        dirpath = NULL;
    }


    b = _SetupGetInfFileList(dirpath,InfStyle,ReturnBuffer,ReturnBufferSize,RequiredSize,TRUE);
    rc = GetLastError();

    if(dirpath) {
        MyFree(dirpath);
    }

    SetLastError(rc);
    return(b);
}
#else
//
// Unicode stub
//
BOOL
SetupGetInfFileListW(
    IN  PCWSTR DirectoryPath,    OPTIONAL
    IN  DWORD  InfStyle,
    OUT PWSTR  ReturnBuffer,     OPTIONAL
    IN  DWORD  ReturnBufferSize,
    OUT PDWORD RequiredSize      OPTIONAL
    )
{
    UNREFERENCED_PARAMETER(DirectoryPath);
    UNREFERENCED_PARAMETER(InfStyle);
    UNREFERENCED_PARAMETER(ReturnBuffer);
    UNREFERENCED_PARAMETER(ReturnBufferSize);
    UNREFERENCED_PARAMETER(RequiredSize);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif

BOOL
SetupGetInfFileList(
    IN  PCTSTR DirectoryPath,    OPTIONAL
    IN  DWORD  InfStyle,
    OUT PTSTR  ReturnBuffer,     OPTIONAL
    IN  DWORD  ReturnBufferSize,
    OUT PDWORD RequiredSize      OPTIONAL
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    PTSTR dirpath;
    DWORD rc;
    BOOL b;

    if(DirectoryPath) {
        rc = CaptureStringArg(DirectoryPath,&dirpath);
        if(rc != NO_ERROR) {
            SetLastError(rc);
            return(FALSE);
        }
    } else {
        dirpath = NULL;
    }


    b = _SetupGetInfFileList(
            dirpath,
            InfStyle,
            ReturnBuffer,
            ReturnBufferSize,
            RequiredSize
#ifdef UNICODE
           ,FALSE
#endif
            );

    rc = GetLastError();

    if(dirpath) {
        MyFree(dirpath);
    }

    SetLastError(rc);
    return(b);
}


#ifdef UNICODE
//
// ANSI version
//
HINF
SetupOpenInfFileA(
    IN  PCSTR FileName,
    IN  PCSTR InfType,     OPTIONAL
    IN  DWORD InfStyle,
    OUT PUINT ErrorLine    OPTIONAL
    )
{
    PCTSTR fileName,infType;
    DWORD err;
    HINF h;

    err = NO_ERROR;
    fileName = NULL;
    infType = NULL;

    //
    // Set error line to 0 since ansi arg conversion could fail
    // and we need to indicate that there's no error in the inf itself.
    //
    if(ErrorLine) {
        try {
            *ErrorLine = 0;
        } except(EXCEPTION_EXECUTE_HANDLER) {
            err = ERROR_INVALID_PARAMETER;
        }
    }

    if(err == NO_ERROR) {
        err = pSetupCaptureAndConvertAnsiArg(FileName,&fileName);
        if((err == NO_ERROR) && InfType) {
            err = pSetupCaptureAndConvertAnsiArg(InfType,&infType);
        }
    }

    if(err == NO_ERROR) {
        h = SetupOpenInfFileW(fileName,infType,InfStyle,ErrorLine);
        err = GetLastError();
    } else {
        h = INVALID_HANDLE_VALUE;
    }

    if(fileName) {
        MyFree(fileName);
    }
    if(infType) {
        MyFree(infType);
    }

    SetLastError(err);
    return(h);
}
#else
//
// Unicode stub
//
HINF
SetupOpenInfFileW(
    IN  PCWSTR FileName,
    IN  PCWSTR InfType,    OPTIONAL
    IN  DWORD  InfStyle,
    OUT PUINT  ErrorLine   OPTIONAL
    )
{
    UNREFERENCED_PARAMETER(FileName);
    UNREFERENCED_PARAMETER(InfType);
    UNREFERENCED_PARAMETER(InfStyle);
    UNREFERENCED_PARAMETER(ErrorLine);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(INVALID_HANDLE_VALUE);
}
#endif


HINF
SetupOpenInfFile(
    IN  PCTSTR FileName,
    IN  PCTSTR InfClass,    OPTIONAL
    IN  DWORD  InfStyle,
    OUT PUINT  ErrorLine    OPTIONAL
    )

/*++

Routine Description:

    This routine opens an INF file and returns a handle to it.

Arguments:

    FileName - Supplies the address of a NULL-terminated string containing
        the name (and optionally, the path) of the INF file to be opened.  If
        the filename contains no path separator characters, it is searched for
        first in the %windir%\inf directory, and then in the %windir%\system32
        directory.  Otherwise, the name is assumed to be a full path
        specification, and no is opened as-is.

    InfClass - Optionally, supplies the address of a NULL-terminated string
        containing the class of the INF file desired.  For old-style (i.e.,
        Windows NT 3.x script-base) INF files, this string must match the type
        specified in the OptionType value of the [Identification] section of the
        INF (e.g., OptionType=NetAdapter).  For Windows 95-compatibile INF
        files, this string must match the class of the specified INF.  If the
        INF has a Class value in its [version] section, then this value is used
        for the comparison.  If no Class value is present, but a ClassGUID value
        is present in the [version] section, then the corresponding class name
        for that GUID is retrieved, and comparison is done based on that name.

    InfStyle - Specifies the style of the INF to open.  May be a combination of
        the following flags:

            INF_STYLE_OLDNT - Windows NT 3.x script-based INF files.

            INF_STYLE_WIN4 - Windows 95-compatible INF files.

            INF_STYLE_CACHE_ENABLE - always cache INF, even outside of
                %windir%\Inf.

            INF_STYLE_CACHE_DISABLE - delete INF from cache, if outside of
                %windir%\Inf.

            INF_STYLE_CACHE_IGNORE - access INF only, do not touch or look
                at other files.

    ErrorLine - If an error occurs loading the file, this parameter receives the
        (1-based) line number where the error occurred.  This value is generally
        reliable only if GetLastError does not return ERROR_NOT_ENOUGH_MEMORY.
        If out-of-memory does occur, the ErrorLine may be 0.

Return Value:

    If the function succeeds, the return value is a handle to the opened INF
    file.

    If the function fails, the return value is INVALID_HANDLE_VALUE.  To get
    extended error information, call GetLastError.

Remarks:

    If the load fails because the INF class does not match InfClass, the
    function returns FALSE, and GetLastError returns ERROR_CLASS_MISMATCH.

    The SetupCloseInfFile function is used to close a handle returned by
    SetupOpenInfFile.

    If multiple INF styles are specified, the style of the INF file opened may
    be ascertained by calling SetupGetInfInformation.

    Since there may be multiple class GUIDs all having the same class name,
    callers interested in only INFs of a particular class (i.e., a particular
    class GUID) should retrieve the ClassGuid value from the INF to verify that
    the class matches exactly.

    If both the INF_STYLE_CACHE_ENABLE and INF_STYLE_CACHE_DISABLE InfStyle
    flags are specified, then the existing cached information that is maintained
    about the INF (e.g., original source location) is discarded, and the INF is
    re-added to the cache without this old information.

    (Internal:  Presently, the INF_STYLE_CACHE_ENABLE and
    INF_STYLE_CACHE_DISABLE flags cause us to create or delete PNFs outside of
    %windir%\Inf.  Their rather vague-sounding names were chosen to reflect the
    possibility of modifying the caching/indexing scheme in the future.)

--*/

{
    UINT errorLine;
    DWORD d;
    PLOADED_INF Inf;
    PCTSTR Class;
    TCHAR TempString[MAX_PATH];
    GUID ClassGuid;
    HRESULT hr;
    BOOL TryPnf = FALSE;
    BOOL IgnorePnf = FALSE;
    WIN32_FIND_DATA FindData;
    PTSTR DontCare;
    PTSTR TempCharPtr = NULL;

    //
    // Determine whether just the filename (no path) was specified.  If so,
    // look for it in the DevicePath directory search path.  Otherwise,
    // use the path as-is.
    //
    try {
        if(FileName == pSetupGetFileTitle(FileName)) {
            //
            // The specified INF name is a simple filename.  Search for it in
            // the INF directories using the default search order.
            //
            d = SearchForInfFile(
                    FileName,
                    &FindData,
                    INFINFO_DEFAULT_SEARCH,
                    TempString,
                    SIZECHARS(TempString),
                    NULL
                    );

            if(d == NO_ERROR) {
                TryPnf = TRUE;
            }
        } else {
            //
            // The specified INF filename contains more than just a filename.
            // Assume it's an absolute path.  (We need to make sure it's
            // fully-qualified, because that's what LoadInfFile expects.)
            //
            d = GetFullPathName(FileName,
                                SIZECHARS(TempString),
                                TempString,
                                &DontCare
                               );
            if(!d) {
                d = GetLastError();
            } else if(d >= SIZECHARS(TempString)) {
                MYASSERT(0);
                d = ERROR_BUFFER_OVERFLOW;
            } else {
                //
                // We successfully retrieved the full pathname, now see if the
                // file exists.
                //
                if(FileExists(TempString, &FindData)) {
                    //
                    // We have everything we need to load this INF.
                    //
                    InfSourcePathFromFileName(TempString, &TempCharPtr, &TryPnf);
                    d = NO_ERROR;
                } else {
                    d = GetLastError();
                }
            }
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        //
        // Assume FileName was invalid and thus pSetupGetFileTitle fell over.
        //
        d = ERROR_INVALID_PARAMETER;
        TempCharPtr = TempCharPtr;
    }

    if(d != NO_ERROR) {
        goto PrepareForReturn;
    }

    if(InfStyle & INF_STYLE_CACHE_DISABLE) {
        //
        // Delete the existing PNF for this INF (if any).
        //
        TCHAR PnfFullPath[MAX_PATH];
        PTSTR PnfFileName, PnfFileExt;

        lstrcpy(PnfFullPath, TempString);

        //
        // Find the start of the filename component of the path, and then find
        // the last period (if one exists) in that filename.
        //
        PnfFileName = (PTSTR)pSetupGetFileTitle(PnfFullPath);
        if(!(PnfFileExt = _tcsrchr(PnfFileName, TEXT('.')))) {
            PnfFileExt = PnfFullPath + lstrlen(PnfFullPath);
        }

        //
        // Now create a corresponding filename with the extension '.PNF'
        //
        lstrcpyn(PnfFileExt, pszPnfSuffix, SIZECHARS(PnfFullPath) - (int)(PnfFileExt - PnfFullPath));

        SetFileAttributes(PnfFullPath, FILE_ATTRIBUTE_NORMAL);
        DeleteFile(PnfFullPath);
    }

    if(InfStyle & INF_STYLE_CACHE_ENABLE) {
        //
        // The caller has requested that this INF be cached (even though it may
        // be outside of our INF search path).
        //
        TryPnf = TRUE;
    }
    if(InfStyle & INF_STYLE_CACHE_IGNORE) {
        //
        // The caller has requested that we don't trust the PNF
        // overrides TryPnf
        //
        TryPnf = FALSE;
        IgnorePnf = TRUE;
    }

    try {
        d = LoadInfFile(
                TempString,
                &FindData,
                InfStyle,
                (TryPnf ? LDINF_FLAG_ALWAYS_TRY_PNF : 0)
                | (IgnorePnf ? LDINF_FLAG_ALWAYS_IGNORE_PNF : 0),
                NULL,
                TempCharPtr,
                NULL,
                NULL,
                NULL, // LogContext
                &Inf,
                &errorLine,
                NULL
                );
    } except(EXCEPTION_EXECUTE_HANDLER) {
        d = ERROR_INVALID_PARAMETER;
    }

    if(d == NO_ERROR) {

        if(InfClass) {

            d = ERROR_CLASS_MISMATCH;   // assume mismatch

            //
            // Match based on class of inf. The following check works for
            // both new and old style infs, because old-style infs use
            // [Identification].OptionType as the class (see oldinf.c
            // function ProcessOldInfVersionBlock()).
            //
            if(Class = pSetupGetVersionDatum(&(Inf->VersionBlock), pszClass)) {
                try {
                    if(!lstrcmpi(Class,InfClass)) {
                        d = NO_ERROR;
                    }
                } except(EXCEPTION_EXECUTE_HANDLER) {
                    d = ERROR_INVALID_PARAMETER;
                }
            } else {
                //
                // No Class entry--check for ClassGUID entry.
                //
                if(Class = pSetupGetVersionDatum(&(Inf->VersionBlock), pszClassGuid)) {
                    //
                    // Get the class name associated with this GUID, and see if it
                    // matches the caller-supplied class name.
                    //
                    // (We have to cast away the CONST-ness of the Class string, because
                    // the prototype for CLSIDFromString doesn't specify this parameter
                    // as constant.)
                    //
                    if((hr = pSetupGuidFromString((PTSTR)Class, &ClassGuid)) == S_OK) {

                        if(SetupDiClassNameFromGuid(&ClassGuid,
                                                    TempString,
                                                    SIZECHARS(TempString),
                                                    NULL)) {

                            try {
                                if(!lstrcmpi(TempString,InfClass)) {
                                    d = NO_ERROR;
                                }
                            } except(EXCEPTION_EXECUTE_HANDLER) {
                                d = ERROR_INVALID_PARAMETER;
                            }
                        }
                    } else {
                        if(hr == E_OUTOFMEMORY) {
                            d = ERROR_NOT_ENOUGH_MEMORY;
                        }
                    }
                }
            }

            if(d != NO_ERROR) {
                FreeInfFile(Inf);
            }
        }

    } else {
        if(ErrorLine) {
            try {
                *ErrorLine = errorLine;
            } except(EXCEPTION_EXECUTE_HANDLER) {
                d = ERROR_INVALID_PARAMETER;
            }
        }
    }

PrepareForReturn:

    if(TempCharPtr) {
        MyFree(TempCharPtr);
    }

    SetLastError(d);

    return((d == NO_ERROR) ? (HINF)Inf : (HINF)INVALID_HANDLE_VALUE);
}


HINF
SetupOpenMasterInf(
    VOID
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    TCHAR FileName[MAX_PATH];

    lstrcpyn(FileName,InfDirectory,SIZECHARS(FileName)-11);
    lstrcat(FileName,TEXT("\\LAYOUT.INF"));

    return(SetupOpenInfFile(FileName,NULL,INF_STYLE_WIN4,NULL));
}


#ifdef UNICODE
//
// ANSI version
//
BOOL
SetupOpenAppendInfFileA(
    IN  PCSTR  FileName,    OPTIONAL
    IN  HINF   InfHandle,
    OUT PUINT  ErrorLine    OPTIONAL
    )
{
    PCWSTR fileName = NULL;
    DWORD d;
    BOOL b;

    //
    // Set error line to 0 since ansi arg conversion could fail
    // and we need to indicate that there's no error in the inf itself.
    //
    d = NO_ERROR;
    if(ErrorLine) {
        try {
            *ErrorLine = 0;
        } except(EXCEPTION_EXECUTE_HANDLER) {
            d = ERROR_INVALID_PARAMETER;
        }
    }

    if(d == NO_ERROR) {
        if(FileName) {
            d = pSetupCaptureAndConvertAnsiArg(FileName,&fileName);
        } else {
            fileName = NULL;
        }
    }

    if(d == NO_ERROR) {
        b = SetupOpenAppendInfFileW(fileName,InfHandle,ErrorLine);
        d = GetLastError();
    } else {
        b = FALSE;
    }

    if(fileName) {
        MyFree(fileName);
    }

    SetLastError(d);
    return(b);
}
#else
//
// Unicode stub
//
BOOL
SetupOpenAppendInfFileW(
    IN  PCWSTR FileName,    OPTIONAL
    IN  HINF   InfHandle,
    OUT PUINT  ErrorLine    OPTIONAL
    )
{
    UNREFERENCED_PARAMETER(FileName);
    UNREFERENCED_PARAMETER(InfHandle);
    UNREFERENCED_PARAMETER(ErrorLine);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif

BOOL
SetupOpenAppendInfFile(
    IN  PCTSTR FileName,    OPTIONAL
    IN  HINF   InfHandle,
    OUT PUINT  ErrorLine    OPTIONAL
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    PLOADED_INF ExistingInf = NULL, CurInf = NULL;
    DWORD d = NO_ERROR;
    TCHAR Filename[2][MAX_PATH];
    UINT FilenameCount, i, Field;
    UINT errorLine = 0;
    BOOL LookInInfDirAlso;
    BOOL TryPnf;
    WIN32_FIND_DATA FindData;
    PTSTR TempCharPtr = NULL;
    PTSTR DontCare;
    PINF_SECTION InfSection;
    UINT LineNumber;
    PINF_LINE InfLine = NULL;

    try {

        if(LockInf((PLOADED_INF)InfHandle)) {
            ExistingInf = (PLOADED_INF)InfHandle;
        } else {
            d = ERROR_INVALID_HANDLE;
            goto clean0;
        }

        //
        // Check INF Signature field as a further validation on the InfHandle.
        //
        if(ExistingInf->Signature != LOADED_INF_SIG) {
            d = ERROR_INVALID_HANDLE;
            goto clean0;
        }

        //
        // Only allow this for win95-style infs.
        //
        if(ExistingInf->Style != INF_STYLE_WIN4) {
            d = ERROR_INVALID_PARAMETER;
            goto clean0;
        }

        //
        // If there is no filename, search through the list of existing INFs, looking
        // for a layout entry in their version blocks.  We begin at the end of the list,
        // and search backward, using the first layout file we encounter.  This allows
        // for the possibility of append-loading several INFs together (e.g., as done by the
        // optional components dialog), and calling SetupOpenAppendInfFile with no filename
        // for each.  Each INF could specify its own layout file, and everything works great.
        // (NOTE: In the above example, if all the INFs specified the same layout file, it
        // would only get loaded once, as expected.)
        //
        // We also can now handle 'LayoutFile' entries that specify multiple layout files.  E.g.,
        //
        //     LayoutFile = pluslay.inf, layout.inf
        //
        // In the above example, we would append-load 'pluslay.inf', followed by 'layout.inf'.
        // Because of the way we store INFs, any duplicate entries in both INFs would resolve in
        // favor of pluslay.inf, since it was loaded first (unless, of course, layout.inf was
        // already in our list of loaded INFs).
        //
        if(!FileName) {
            //
            // First, find the end of the list.
            //
            for(CurInf = ExistingInf; CurInf->Next; CurInf = CurInf->Next);

            //
            // Now, search the list, back-to-front, looking for a layout file in each INF's
            // [version] section.
            //
            for(; CurInf; CurInf = CurInf->Prev) {
                //
                // Locate the [Version] section.
                //
                if(InfSection = InfLocateSection(CurInf, pszVersion, NULL)) {
                    //
                    // Now look for a LayoutFile line.
                    //
                    LineNumber = 0;
                    if(InfLocateLine(CurInf, InfSection, pszLayoutFile, &LineNumber, &InfLine)) {
                        //
                        // We've found the line containing the INFs to be append-
                        // loaded.  Get the first field on the line to start off
                        // our loop below.
                        //
                        FileName = InfGetField(CurInf, InfLine, 1, NULL);
                        break;
                    } else {
                        //
                        // Make sure InfLine is still NULL, so we won't try to use it.
                        //
                        InfLine = NULL;
                    }
                }
            }

            if(!FileName) {
                //
                // Then we didn't find any INFs that specify a layout file.
                //
                d = ERROR_INVALID_DATA;
                goto clean0;
            }
        }

        //
        // Now append-load the INF (or the possibly multiple INFs, if we're
        // using a LayoutFile line).
        //
        for(Field = 1;
            FileName;
            FileName = InfLine ? InfGetField(CurInf, InfLine, ++Field, NULL) : NULL) {

            FilenameCount = 0;
            LookInInfDirAlso = TRUE;
            TryPnf = FALSE;

            //
            // Determine whether just the filename (no path) was specified.
            //
            if(FileName == pSetupGetFileTitle(FileName)) {
                //
                // If we retrieved this filename from an INF's [version] section,
                // then we first attempt to open up the layout file from the
                // directory where we found the INF.  If we don't find it in that
                // directory, and that directory wasn't the Inf directory, then
                // we try to open it up in %windir%\Inf as well.
                //
                if(CurInf) {
                    //
                    // Copy the path without the ending backslash character,
                    // because that's how the 'InfDirectory' string is formatted.
                    //
                    lstrcpyn(Filename[0],
                             CurInf->VersionBlock.Filename,
                             (int)(pSetupGetFileTitle(CurInf->VersionBlock.Filename) - CurInf->VersionBlock.Filename)
                            );

                    //
                    // Compare this path against the InfDirectory path, to see
                    // if they're the same.
                    //
                    if(!lstrcmpi(Filename[0], InfDirectory)) {
                        TryPnf = TRUE;
                        LookInInfDirAlso = FALSE;
                    }

                    //
                    // Now concatenate the layout filename onto the path.
                    //
                    pSetupConcatenatePaths(Filename[0], FileName, MAX_PATH, NULL);
                    FilenameCount = 1;

                    //
                    // If 'TryPnf' is still FALSE, then that means that the INF
                    // wasn't in the INF directory.  Now find out if it's in a
                    // location that requires a non-NULL SourcePath (i.e.,
                    // something other than the default).
                    //
                    if(!TryPnf) {
                        InfSourcePathFromFileName(Filename[0], &TempCharPtr, &TryPnf);
                    }
                }

                if(LookInInfDirAlso) {
                    lstrcpy(Filename[FilenameCount], InfDirectory);
                    pSetupConcatenatePaths(Filename[FilenameCount], FileName, MAX_PATH, NULL);

                    if(!FilenameCount) {
                        TryPnf = TRUE;
                    }

                    FilenameCount++;
                }

            } else {
                //
                // The INF filename contains more than just a filename.  Assume
                // it's an absolute path.  (We need to make sure it's fully-
                // qualified, because that's what LoadInfFile expects.)
                //
                d = GetFullPathName(FileName,
                                    SIZECHARS(Filename[0]),
                                    Filename[0],
                                    &DontCare
                                   );
                if(!d) {
                    d = GetLastError();
                    goto clean0;
                } else if(d >= SIZECHARS(Filename[0])) {
                    MYASSERT(0);
                    d = ERROR_BUFFER_OVERFLOW;
                    goto clean0;
                }

                InfSourcePathFromFileName(Filename[0], &TempCharPtr, &TryPnf);
                FilenameCount = 1;
                //
                // (Since we're setting FilenameCount to 1, we know we'll go
                // through the loop below at least once, thus d will get set to
                // the proper error, so we don't have to re-initialize it to
                // NO_ERROR here.)
                //
            }

            for(i = 0; i < FilenameCount; i++) {
                //
                // Load the inf
                //
                if(FileExists(Filename[i], &FindData)) {

                    if((d = LoadInfFile(Filename[i],
                                        &FindData,
                                        INF_STYLE_WIN4,
                                        (i | TryPnf) ? LDINF_FLAG_ALWAYS_TRY_PNF : 0,
                                        NULL,
                                        (i | TryPnf) ? NULL : TempCharPtr,
                                        NULL,
                                        ExistingInf,
                                        ExistingInf->LogContext,
                                        &ExistingInf,
                                        &errorLine,
                                        NULL)) == NO_ERROR) {
                        break;
                    }
                } else {
                    d = GetLastError();
                }
            }

            //
            // We no longer need the INF source path--free it if necessary.
            //
            if(TempCharPtr) {
                MyFree(TempCharPtr);
                TempCharPtr = NULL;
            }

            if(d != NO_ERROR) {
                break;
            }
        }

clean0:
        //
        // If the caller requested it, give them the line number at which any error occurred.
        // (This may be zero on non-parse errors.)
        //
        if(ErrorLine) {
            *ErrorLine = errorLine;
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        //
        // If we hit an AV, then use invalid parameter error, otherwise, assume an inpage error when dealing
        // with a mapped-in file.
        //
        d = (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION) ? ERROR_INVALID_PARAMETER : ERROR_READ_FAULT;

        if(TempCharPtr) {
            MyFree(TempCharPtr);
        }

        //
        // Access the 'ExistingInf' variable, so that the compiler will respect our statement
        // ordering w.r.t. this variable.  Otherwise, we may not always know whether or not
        // we should be unlocking this INF.
        //
        ExistingInf = ExistingInf;
    }

    if(ExistingInf) {
        UnlockInf(ExistingInf);
    }

    SetLastError(d);

    return(d == NO_ERROR);
}


VOID
SetupCloseInfFile(
    IN HINF InfHandle
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    PLOADED_INF CurInf, NextInf;

    try {
        //
        // Make sure we can lock the head of the INF list before
        // we start deleting!
        //
        if(LockInf((PLOADED_INF)InfHandle)) {
            //
            // Also check INF Signature field as a further validation.
            //
            if(((PLOADED_INF)InfHandle)->Signature == LOADED_INF_SIG) {

                CurInf = ((PLOADED_INF)InfHandle)->Next;

                DestroySynchronizedAccess(&(((PLOADED_INF)InfHandle)->Lock));
                FreeLoadedInfDescriptor((PLOADED_INF)InfHandle);

                for(; CurInf; CurInf = NextInf) {
                    NextInf = CurInf->Next;
                    FreeInfFile(CurInf);
                }

            } else {
                UnlockInf((PLOADED_INF)InfHandle);
            }
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        ;
    }
}

//
// ANSI version
//
BOOL
WINAPI
SetupVerifyInfFileA(
    IN  PCSTR                   InfName,
    IN  PSP_ALTPLATFORM_INFO_V2 AltPlatformInfo,                OPTIONAL
    OUT PSP_INF_SIGNER_INFO_A   InfSignerInfo
    )
{
    DWORD Err = NO_ERROR;
    SP_INF_SIGNER_INFO_W InfSignerInfoW;
    int i;
    PWSTR InfNameUnicode = NULL;

    try {

        if (!InfName) {
            SetLastError(ERROR_INVALID_PARAMETER);
            leave;
        }

        if (!InfSignerInfo || (InfSignerInfo->cbSize != sizeof(SP_INF_SIGNER_INFO_A))) {
            SetLastError(ERROR_INVALID_PARAMETER);
            leave;      // exit try block
        }


        Err = pSetupCaptureAndConvertAnsiArg(InfName, &InfNameUnicode);

        if (Err != NO_ERROR) {
            leave;      // exit try block
        }

        InfSignerInfoW.cbSize = sizeof(InfSignerInfoW);

        Err = GLE_FN_CALL(FALSE,
                          SetupVerifyInfFile(InfNameUnicode,
                                             AltPlatformInfo,
                                             &InfSignerInfoW)
                         );

        if((Err == NO_ERROR) ||
           (Err == ERROR_AUTHENTICODE_TRUSTED_PUBLISHER) ||
           (Err == ERROR_AUTHENTICODE_TRUST_NOT_ESTABLISHED)) {

            i = WideCharToMultiByte(
                    CP_ACP,
                    0,
                    InfSignerInfoW.CatalogFile,
                    -1,
                    InfSignerInfo->CatalogFile,
                    SIZECHARS(InfSignerInfo->CatalogFile),
                    NULL,
                    NULL
                    );
            if (i==0) {
                //
                // error occurred (LastError set to error)
                //
                Err = GetLastError();
                leave;              // exit try block
            }

            i = WideCharToMultiByte(
                    CP_ACP,
                    0,
                    InfSignerInfoW.DigitalSigner,
                    -1,
                    InfSignerInfo->DigitalSigner,
                    SIZECHARS(InfSignerInfo->DigitalSigner),
                    NULL,
                    NULL
                    );
            if (i==0) {
                //
                // error occurred (LastError set to error)
                //
                Err = GetLastError();
                leave;              // exit try block
            }

            i = WideCharToMultiByte(
                    CP_ACP,
                    0,
                    InfSignerInfoW.DigitalSignerVersion,
                    -1,
                    InfSignerInfo->DigitalSignerVersion,
                    SIZECHARS(InfSignerInfo->DigitalSignerVersion),
                    NULL,
                    NULL
                    );
            if (i==0) {
                //
                // error occurred (LastError set to error)
                //
                Err = GetLastError();
                leave;              // exit try block
            }
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;
    }

    if (InfNameUnicode) {
        MyFree(InfNameUnicode);
    }

    SetLastError(Err);
    return (Err == NO_ERROR);
}

BOOL
WINAPI
SetupVerifyInfFile(
    IN  LPCTSTR                 InfName,
    IN  PSP_ALTPLATFORM_INFO_V2 AltPlatformInfo,                OPTIONAL
    OUT PSP_INF_SIGNER_INFO     InfSignerInfo
    )
/*++

Routine Description:

    This routine verifies the digital signature of the specified INF,
    using its corresponding catalog.  The verification can optionally
    be performed against a non-native platform.

Arguments:

    InfName - Supplies the name of the INF file to be verified.
        This name may include a path.

    AltPlatformInfo - optionally, supplies the address of a structure
        containing information regarding the alternate platform that is
        to be used when validating the INF file.

    InfSignerInfo - Supplies the address of a structure that receives information
        about the INF's digital signature (if it is signed).

Return Value:

    If the INF was successfully validated using driver signing policy, the
    return value is TRUE.

    If the INF was successfully validated using Authenticode policy, and the
    publisher was in the TrustedPublisher store, the return value is FALSE and
    GetLastError returns ERROR_AUTHENTICODE_TRUSTED_PUBLISHER.

    If the INF was successfully validated using Authenticode policy, and the
    publisher was *not* in the TrustedPublisher store, the return value is
    FALSE and GetLastError returns ERROR_AUTHENTICODE_TRUST_NOT_ESTABLISHED.

    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

--*/

{
    DWORD Err = NO_ERROR;
    DWORD AuthenticodeError;
    TCHAR PathBuffer[MAX_PATH];
    PLOADED_INF Inf = NULL;
    BOOL PnfWasUsed;
    UINT ErrorLineNumber;
    BOOL TryPnf;
    WIN32_FIND_DATA FindData;
    DWORD TempRequiredSize;
    PTSTR DontCare;
    HANDLE hWVTStateData;
    PCRYPT_PROVIDER_DATA ProviderData;
    PCRYPT_PROVIDER_SGNR ProviderSigner;
    PCRYPT_PROVIDER_CERT ProviderCert;

    try {

        if (!InfName) {
            Err = ERROR_INVALID_PARAMETER;
            leave;
        }

        if (!InfSignerInfo || (InfSignerInfo->cbSize != sizeof(SP_INF_SIGNER_INFO))) {
            Err = ERROR_INVALID_PARAMETER;
            leave;
        }

        if(InfName == pSetupGetFileTitle(InfName)) {
            //
            // The specified INF name is a simple filename.  Search for it in
            // the DevicePath search path list.
            //
            Err = SearchForInfFile(InfName,
                                   &FindData,
                                   INFINFO_INF_PATH_LIST_SEARCH,
                                   PathBuffer,
                                   SIZECHARS(PathBuffer),
                                   NULL
                                  );
            if(Err == NO_ERROR) {
                TryPnf = TRUE;
            } else {
                leave;
            }

        } else {
            //
            // The specified INF filename contains more than just a filename.
            // Assume it's an absolute path.  (We need to make sure it's
            // fully-qualified, because that's what LoadInfFile expects.)
            //
            TempRequiredSize = GetFullPathName(InfName,
                                               SIZECHARS(PathBuffer),
                                               PathBuffer,
                                               &DontCare
                                              );
            if(!TempRequiredSize) {
                Err = GetLastError();
                leave;
            } else if(TempRequiredSize >= SIZECHARS(PathBuffer)) {
                MYASSERT(0);
                Err = ERROR_BUFFER_OVERFLOW;
                leave;
            }

            if(FileExists(PathBuffer, &FindData)) {
                //
                // We have a valid file path, and we're ready to load this INF.
                //
                InfSourcePathFromFileName(PathBuffer, NULL, &TryPnf);
            } else {
                Err = GetLastError();
                leave;
            }
        }

        //
        // Load the INF.
        //
        Err = LoadInfFile(PathBuffer,
                          &FindData,
                          INF_STYLE_WIN4,
                          LDINF_FLAG_IGNORE_VOLATILE_DIRIDS | (TryPnf ? LDINF_FLAG_ALWAYS_TRY_PNF : 0),
                          NULL,
                          NULL,
                          NULL,
                          NULL,
                          NULL, // LogContext
                          &Inf,
                          &ErrorLineNumber,
                          NULL
                         );
        if(Err != NO_ERROR) {
            leave;
        }

        InfSignerInfo->CatalogFile[0] = TEXT('\0');
        InfSignerInfo->DigitalSigner[0] = TEXT('\0');
        InfSignerInfo->DigitalSignerVersion[0] = TEXT('\0');

        if(GlobalSetupFlags & PSPGF_MINIMAL_EMBEDDED) {
            //
            // We can't call the VerifyDeviceInfFile internal routine, because
            // it doesn't expect to be asked for the signer info (it doesn't
            // make any sense to talk about the signer info, because we have
            // no idea who signed the INF, or even if it was signed).
            //
            Err = NO_ERROR;

        } else {

            Err = VerifyDeviceInfFile(NULL,
                                      NULL,
                                      PathBuffer,
                                      Inf,
                                      AltPlatformInfo,
                                      InfSignerInfo->CatalogFile,
                                      InfSignerInfo->DigitalSigner,
                                      InfSignerInfo->DigitalSignerVersion,
                                      0,
                                      NULL
                                     );

            if((Err != NO_ERROR) && (Err != ERROR_SIGNATURE_OSATTRIBUTE_MISMATCH)) {
                //
                // We failed to verify via driver signing policy (and it wasn't
                // simply because a valid driver signing catalog didn't have an
                // applicable osattribute).  Fall back to validating via
                // Authenticode policy.  NOTE: we don't have to worry about
                // whether Authenticode verification is acceptable for this
                // class--the VerifyDeviceInfFile routine will check for that.
                //
                // NTRAID#NTBUG9-719853-2002/10/11-LonnyM We may be using Authenticode policy when we shouldn't!
                // It's possible that we have a valid catalog (per driver
                // signing policy), and the failure was due to the INF having
                // been tampered with.  In that case, we really shouldn't be
                // doing Authenticode validation.  However, we know that
                // WinVerifyTrust should fail in either case, and Authenticode
                // policy actually gives us a better error (TRUST_E_NOSIGNATURE
                // instead of ERROR_INVALID_PARAMETER).
                //
                AuthenticodeError = VerifyDeviceInfFile(
                                        NULL,
                                        NULL,
                                        PathBuffer,
                                        Inf,
                                        AltPlatformInfo,
                                        InfSignerInfo->CatalogFile,
                                        NULL,
                                        NULL,
                                        VERIFY_INF_USE_AUTHENTICODE_CATALOG,
                                        &hWVTStateData
                                        );

                if((AuthenticodeError == ERROR_AUTHENTICODE_TRUSTED_PUBLISHER) ||
                   (AuthenticodeError == ERROR_AUTHENTICODE_TRUST_NOT_ESTABLISHED)) {
                    //
                    // Update error to indicate that the INF was Authenticode
                    // signed.
                    //
                    Err = AuthenticodeError;

                    ProviderData = WTHelperProvDataFromStateData(hWVTStateData);
                    MYASSERT(ProviderData);
                    if (ProviderData) {
                        ProviderSigner = WTHelperGetProvSignerFromChain(ProviderData,
                                                                        0,
                                                                        FALSE,
                                                                        0);
                        MYASSERT(ProviderSigner);
                        if (ProviderSigner) {
                            ProviderCert = WTHelperGetProvCertFromChain(ProviderSigner,
                                                                        0);
                            MYASSERT(ProviderCert);
                            if (ProviderCert) {
                                //
                                // Get the publisher and add this
                                // as the DigitalSigner.
                                //
                                CertGetNameString(ProviderCert->pCert,
                                                  CERT_NAME_SIMPLE_DISPLAY_TYPE,
                                                  0,
                                                  NULL,
                                                  InfSignerInfo->DigitalSigner,
                                                  SIZECHARS(InfSignerInfo->DigitalSigner));
                            }
                        }
                    }

                    if(hWVTStateData) {
                        pSetupCloseWVTStateData(hWVTStateData);
                    }

                } else if(AuthenticodeError != ERROR_AUTHENTICODE_DISALLOWED) {
                    //
                    // It was acceptable to validate using Authenticode
                    // policy (it just didn't work).  Use this error,
                    // instead of the one generated based on driver signing
                    // verification policy.
                    //
                    Err = AuthenticodeError;
                }
            }
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_DATA;
    }

    if (Inf) {
        FreeInfFile(Inf);
        Inf = NULL;
    }

    SetLastError(Err);
    return (Err == NO_ERROR);
}



/////////////////////////////////////////////////////////////////
//
// Internal routines
//
/////////////////////////////////////////////////////////////////

BOOL
pSetupVersionNodeFromInfInformation(
    IN  PSP_INF_INFORMATION InfInformation,
    IN  UINT                InfIndex,
    OUT PINF_VERSION_NODE   VersionNode,
    OUT PTSTR               OriginalFilename OPTIONAL
    )

/*++

Routine Description:

    Fills in a caller-supplied INF_VERSION_NODE buffer for an INF file
    from the SP_INF_INFORMATION structure.

Arguments:

    InfInformation - supplies the inf information descriptor

    InfIndex - supplies the 0-based index of the inf whose version block
        is requested. If this value is not inrange an error is returned.

    VersionNode - supplies the address of a buffer that receives the version
        node structure.

    OriginalFilename - optionally, supplies the address of a character buffer
        (that must be at least MAX_PATH characters large) that receives the
        INF's original filename (which may be the same as its current filename
        if the INF isn't an OEM INF.

Return Value:

    If successful, the return value is TRUE, otherwise, it is FALSE.

--*/

{
    PINF_VERSION_BLOCK First;
    INF_VERSION_BLOCK UNALIGNED *Ver;
    PUCHAR Base;
    UINT ord;
    INF_VERSION_BLOCK TempVersionBlock;
    UINT FilenameSize;

    //
    // Get pointer to first version block.
    //
    Base = (PUCHAR)InfInformation;
    First = (PINF_VERSION_BLOCK)(Base+offsetof(SP_INF_INFORMATION,VersionData));

    //
    // Find relevant version block
    //
    ord = 0;
    for(Ver=First; Ver; Ver=(INF_VERSION_BLOCK UNALIGNED *)(Base+Ver->NextOffset)) {

        if(ord++ == InfIndex) {
            break;
        }
    }

    if(!Ver) {
        SetLastError(ERROR_NO_MORE_ITEMS);
        return FALSE;
    }

    //
    // Now fill in the version node based on the information contained in the version block.
    //
    VersionNode->LastWriteTime = Ver->LastWriteTime;
    VersionNode->DataBlock     = (CONST TCHAR *)((PBYTE)(Ver->Filename) + Ver->OffsetToData);
    VersionNode->DataSize      = Ver->DataSize;
    VersionNode->DatumCount    = Ver->DatumCount;

    //
    // The 'filename' character buffer may actually contain two strings--the
    // first being the INF's current filename (with path), and the second being
    // the INF's original filename (this won't be present if the INF's name
    // hasn't changed from its original name).
    //
    // Copy the first MAX_PATH characters of this buffer (or the entire buffer,
    // whichever is smaller) into the VersionNode's Filename buffer, then after
    // we've computed the string length of that string, we can ascertain whether
    // or not there's another string following it containing the INF's original
    // name.
    //
    FilenameSize = (Ver->OffsetToData < SIZECHARS(VersionNode->Filename))
                 ? Ver->OffsetToData : SIZECHARS(VersionNode->Filename);

    CopyMemory(VersionNode->Filename, Ver->Filename, FilenameSize);
    VersionNode->FilenameSize = (lstrlen(VersionNode->Filename) + 1) * sizeof(TCHAR);

    MYASSERT(Ver->OffsetToData >= VersionNode->FilenameSize);

    if(OriginalFilename) {

        if(Ver->OffsetToData > VersionNode->FilenameSize) {
            //
            // Then there's more data in the Filename buffer, namely the INF's
            // original name--fill this filename into the caller-supplied buffer.
            //
            FilenameSize = Ver->OffsetToData - VersionNode->FilenameSize;
            MYASSERT(((UINT)(FilenameSize / sizeof(TCHAR)) * sizeof(TCHAR)) == FilenameSize);
            MYASSERT(FilenameSize > sizeof(TCHAR));

            CopyMemory(OriginalFilename,
                       (PBYTE)Ver->Filename + VersionNode->FilenameSize,
                       FilenameSize
                      );

            MYASSERT(((lstrlen(OriginalFilename) + 1) * sizeof(TCHAR)) == FilenameSize);

        } else {
            //
            // No original name info stored--must be same as current name.
            //
            if(FAILED(StringCchCopy(OriginalFilename,MAX_PATH, pSetupGetFileTitle(VersionNode->Filename)))) {
                SetLastError(ERROR_BUFFER_OVERFLOW);
                return FALSE;
            }
        }
    }

    return TRUE;
}


PCTSTR
pSetupGetVersionDatum(
    IN PINF_VERSION_NODE VersionNode,
    IN PCTSTR            DatumName
    )

/*++

Routine Description:

    Look up a piece of version data in an version data node.

Arguments:

    VersionNode - supplies a pointer to the version node to
        be searched for the datum.

    DatumName - supplies the name of the datum to be retreived.

Return Value:

    NULL if the datum does not exist in the data block.
    Otherwise a pointer to the datum value is returned. The caller
        must not free or write into this memory.

--*/

{
    WORD Datum;
    UINT StringLength;
    PCTSTR Data = VersionNode->DataBlock;

    for(Datum=0; Datum < VersionNode->DatumCount; Datum++) {

        StringLength = lstrlen(Data) + 1;

        //
        // Go through the version block looking for a matching datum name.
        //
        if(lstrcmpi(Data, DatumName)) {

            //
            // Point to the next one.
            //
            Data += StringLength;
            Data += lstrlen(Data) + 1;

        } else {

            //
            // Found it. Return datum value to caller.
            //
            return (Data + StringLength);
        }
    }

    return(NULL);
}


BOOL
pSetupGetCatalogFileValue(
    IN  PINF_VERSION_NODE       InfVersionNode,
    OUT LPTSTR                  Buffer,
    IN  DWORD                   BufferSize,
    IN  PSP_ALTPLATFORM_INFO_V2 AltPlatformInfo OPTIONAL
    )

/*++

Routine Description:

    This routine fetches the (potentially decorated) CatalogFile= value from the
    specified inf version section.

Arguments:

    InfVersionNode - points to the INF version node from which we're attempting
        to retrieve the associated catalog file.

    Buffer - if the routine returns TRUE, receives the value for CatalogFile=
        in the [Version] section of the inf.

    BufferSize - supplies the size in bytes (ansi) or chars (unicode) of
        the buffer pointed to by Buffer.

    AltPlatformInfo - optionally, supplies the address of a structure describing
        the platform parameters that should be used in formulating the decorated
        CatalogFile= entry to be used when searching for the INF's associated
        catalog file.

Return Value:

    Boolean value indicating whether a value was found and copied to the
    caller-supplied Buffer.

--*/

{
    TCHAR CatFileWithExt[64];
    LPCTSTR p, NtPlatformSuffixToUse;
    DWORD PlatformId;

    MYASSERT(BufferSize >= MAX_PATH);

    p = NULL;

    CopyMemory(CatFileWithExt, pszCatalogFile, sizeof(pszCatalogFile) - sizeof(TCHAR));

    //
    // Set up some variables based on the native platform or upon the non-native
    // platform specified in the AltPlatformInfo parameter.
    //
    if(AltPlatformInfo) {
        PlatformId = AltPlatformInfo->Platform;
        switch(AltPlatformInfo->ProcessorArchitecture) {

            case PROCESSOR_ARCHITECTURE_INTEL:
                NtPlatformSuffixToUse = pszNtX86Suffix;
                break;

            case PROCESSOR_ARCHITECTURE_IA64:
                NtPlatformSuffixToUse = pszNtIA64Suffix;
                break;

            case PROCESSOR_ARCHITECTURE_AMD64:
                NtPlatformSuffixToUse = pszNtAMD64Suffix;
                break;

            default:
                return FALSE;
        }
    } else {
        PlatformId = OSVersionInfo.dwPlatformId;
        NtPlatformSuffixToUse = pszNtPlatformSuffix;
    }

    if(PlatformId == VER_PLATFORM_WIN32_NT) {
        //
        // We're running on NT, so first try the NT architecture-specific
        // extension, then the generic NT extension.
        //
        lstrcpyn((PTSTR)((PBYTE)CatFileWithExt + (sizeof(pszCatalogFile) - sizeof(TCHAR))),
                 NtPlatformSuffixToUse,
                 SIZECHARS(CatFileWithExt) - (sizeof(pszCatalogFile) - sizeof(TCHAR))
                );

        p = pSetupGetVersionDatum(InfVersionNode, CatFileWithExt);

        if(!p) {
            //
            // We didn't find an NT architecture-specific CatalogFile= entry, so
            // fall back to looking for just an NT-specific one.
            //
            CopyMemory((PBYTE)CatFileWithExt + (sizeof(pszCatalogFile) - sizeof(TCHAR)),
                       pszNtSuffix,
                       sizeof(pszNtSuffix)
                      );

            p = pSetupGetVersionDatum(InfVersionNode, CatFileWithExt);
        }

    } else {
        //
        // We're running on Windows 95, so try the Windows-specific extension
        //
        CopyMemory((PBYTE)CatFileWithExt + (sizeof(pszCatalogFile) - sizeof(TCHAR)),
                   pszWinSuffix,
                   sizeof(pszWinSuffix)
                  );

        p = pSetupGetVersionDatum(InfVersionNode, CatFileWithExt);
    }

    //
    // If we didn't find an OS/architecture-specific CatalogFile= entry above,
    // then look for an undecorated entry.
    //
    if(!p) {
        p = pSetupGetVersionDatum(InfVersionNode, pszCatalogFile);
    }

    //
    // If we got back an empty string, then treat this as if there was no
    // CatalogFile= entry (this might be used, for example, so that a system-
    // supplied INF that supports both NT and Win98 could specify an undecorated
    // CatalogFile= entry for Win98, yet supply an NT-specific CatalogFile=
    // entry that's an empty string, so that we'd do global verification on NT).
    //
    if(p && lstrlen(p)) {
        lstrcpyn(Buffer, p, BufferSize);
        return TRUE;
    } else {
        return FALSE;
    }
}


VOID
pSetupGetPhysicalInfFilepath(
    IN  PINFCONTEXT LineContext,
    OUT LPTSTR      Buffer,
    IN  DWORD       BufferSize
    )
{
    lstrcpyn(
        Buffer,
        ((PLOADED_INF)LineContext->CurrentInf)->VersionBlock.Filename,
        BufferSize
        );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\setupapi\infvalue.c ===
/*++

Copyright (c) 1993-2000 Microsoft Corporation

Module Name:

    infvalue.c

Abstract:

    Externally exposed INF routines for INF value retreival and manipulation.

Author:

    Ted Miller (tedm) 20-Jan-1995

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop


BOOL
pAToI(
    IN  PCTSTR      Field,
    OUT PINT        IntegerValue
    )

/*++

Routine Description:

Arguments:

Return Value:

Remarks:

    Hexadecimal numbers are also supported.  They must be prefixed by '0x' or '0X', with no
    space allowed between the prefix and the number.

--*/

{
    INT Value;
    UINT c;
    BOOL Neg;
    UINT Base;
    UINT NextDigitValue;
    INT OverflowCheck;
    BOOL b;

    if(!Field) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    if(*Field == TEXT('-')) {
        Neg = TRUE;
        Field++;
    } else {
        Neg = FALSE;
        if(*Field == TEXT('+')) {
            Field++;
        }
    }

    if((*Field == TEXT('0')) &&
       ((*(Field+1) == TEXT('x')) || (*(Field+1) == TEXT('X')))) {
        //
        // The number is in hexadecimal.
        //
        Base = 16;
        Field += 2;
    } else {
        //
        // The number is in decimal.
        //
        Base = 10;
    }

    for(OverflowCheck = Value = 0; *Field; Field++) {

        c = (UINT)*Field;

        if((c >= (UINT)'0') && (c <= (UINT)'9')) {
            NextDigitValue = c - (UINT)'0';
        } else if(Base == 16) {
            if((c >= (UINT)'a') && (c <= (UINT)'f')) {
                NextDigitValue = (c - (UINT)'a') + 10;
            } else if ((c >= (UINT)'A') && (c <= (UINT)'F')) {
                NextDigitValue = (c - (UINT)'A') + 10;
            } else {
                break;
            }
        } else {
            break;
        }

        Value *= Base;
        Value += NextDigitValue;

        //
        // Check for overflow.  For decimal numbers, we check to see whether the
        // new value has overflowed into the sign bit (i.e., is less than the
        // previous value.  For hexadecimal numbers, we check to make sure we
        // haven't gotten more digits than will fit in a DWORD.
        //
        if(Base == 16) {
            if(++OverflowCheck > (sizeof(INT) * 2)) {
                break;
            }
        } else {
            if(Value < OverflowCheck) {
                break;
            } else {
                OverflowCheck = Value;
            }
        }
    }

    if(*Field) {
        SetLastError(ERROR_INVALID_DATA);
        return(FALSE);
    }

    if(Neg) {
        Value = 0-Value;
    }
    b = TRUE;
    try {
        *IntegerValue = Value;
    } except(EXCEPTION_EXECUTE_HANDLER) {
        b = FALSE;
    }
    if(!b) {
        SetLastError(ERROR_INVALID_PARAMETER);
    }
    return(b);
}


DWORD
SetupGetFieldCount(
    IN PINFCONTEXT Context
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    PINF_LINE Line = NULL;
    DWORD rc = NO_ERROR;
    DWORD res = 0;

    try {
        if(!LockInf((PLOADED_INF)Context->Inf)) {
            rc = ERROR_INVALID_PARAMETER;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        rc = ERROR_INVALID_PARAMETER;
    }

    if(rc) {
        SetLastError(rc);
        return(0);
    }

    try {
        Line = InfLineFromContext(Context);
        if(!Line) {
            rc = ERROR_INVALID_PARAMETER;
            leave;
        }

        if(HASKEY(Line)) {
            res = Line->ValueCount - 2;
        } else {
            res = ISSEARCHABLE(Line) ? 1 : Line->ValueCount;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        rc = ERROR_INVALID_PARAMETER;
        res = 0;
    }

    try {
        UnlockInf((PLOADED_INF)Context->Inf);
    } except(EXCEPTION_EXECUTE_HANDLER) {
    }

    SetLastError(rc);
    return res;
}

#ifdef UNICODE
//
// ANSI version
//
BOOL
SetupGetStringFieldA(
    IN  PINFCONTEXT Context,
    IN  DWORD       FieldIndex,
    OUT PSTR        ReturnBuffer,     OPTIONAL
    IN  DWORD       ReturnBufferSize,
    OUT LPDWORD     RequiredSize      OPTIONAL
    )
{
    PCWSTR Field;
    PCSTR field;
    UINT Len;
    DWORD rc, TmpRequiredSize;

    //
    // Context could be a bogus pointer -- guard access to it.
    //
    try {
        Field = pSetupGetField(Context, FieldIndex);
    } except(EXCEPTION_EXECUTE_HANDLER) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if(Field) {
        field = pSetupUnicodeToAnsi(Field);
        if(!field) {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return FALSE;
        }
    } else {
        //
        // (last error already set by pSetupGetField)
        //
        return FALSE;
    }

    Len = lstrlenA(field) + 1;

    //
    // RequiredSize and ReturnBuffer could be bogus pointers;
    // guard access to them.
    //
    rc = NO_ERROR;
    try {
        if(RequiredSize) {
            *RequiredSize = Len;
        }
        if(ReturnBuffer) {
            if(ReturnBufferSize >= Len) {
                lstrcpyA(ReturnBuffer, field);
            } else {
                rc = ERROR_INSUFFICIENT_BUFFER;
            }
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        rc = ERROR_INVALID_PARAMETER;
    }

    MyFree(field);
    SetLastError(rc);
    return(rc == NO_ERROR);
}
#else
//
// Unicode stub
//
BOOL
SetupGetStringFieldW(
    IN  PINFCONTEXT Context,
    IN  DWORD       FieldIndex,
    OUT PWSTR       ReturnBuffer,     OPTIONAL
    IN  DWORD       ReturnBufferSize,
    OUT LPDWORD     RequiredSize      OPTIONAL
    )
{
    UNREFERENCED_PARAMETER(Context);
    UNREFERENCED_PARAMETER(FieldIndex);
    UNREFERENCED_PARAMETER(ReturnBuffer);
    UNREFERENCED_PARAMETER(ReturnBufferSize);
    UNREFERENCED_PARAMETER(RequiredSize);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif

BOOL
SetupGetStringField(
    IN  PINFCONTEXT Context,
    IN  DWORD       FieldIndex,
    OUT PTSTR       ReturnBuffer,     OPTIONAL
    IN  DWORD       ReturnBufferSize,
    OUT LPDWORD     RequiredSize      OPTIONAL
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    PCTSTR Field;
    UINT Len;
    DWORD rc;

    //
    // Context could be a bogus pointer -- guard access to it.
    //
    try {
        Field = pSetupGetField(Context, FieldIndex);
    } except(EXCEPTION_EXECUTE_HANDLER) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if(!Field) {
        //
        // (last error already set by pSetupGetField)
        //
        return FALSE;
    }

    Len = lstrlen(Field) + 1;

    //
    // RequiredSize and ReturnBuffer could be bogus pointers;
    // guard access to them.
    //
    rc = NO_ERROR;
    try {
        if(RequiredSize) {
            *RequiredSize = Len;
        }
        if(ReturnBuffer) {
            if(ReturnBufferSize >= Len) {
                lstrcpy(ReturnBuffer, Field);
            } else {
                rc = ERROR_INSUFFICIENT_BUFFER;
            }
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        rc = ERROR_INVALID_PARAMETER;
    }

    SetLastError(rc);
    return(rc == NO_ERROR);
}


BOOL
SetupGetIntField(
    IN  PINFCONTEXT Context,
    IN  DWORD       FieldIndex,
    OUT PINT        IntegerValue
    )

/*++

Routine Description:

Arguments:

Return Value:

Remarks:

    Hexadecimal numbers are also supported.  They must be prefixed by '0x' or '0X', with no
    space allowed between the prefix and the number.

--*/

{
    PCTSTR Field;

    try {
        Field = pSetupGetField(Context,FieldIndex);
    } except(EXCEPTION_EXECUTE_HANDLER) {
        Field = NULL;
    }

    return (pAToI(Field, IntegerValue));
}


#ifdef UNICODE
//
// ANSI version
//
BOOL
SetupGetLineTextA(
    IN  PINFCONTEXT Context,          OPTIONAL
    IN  HINF        InfHandle,        OPTIONAL
    IN  PCSTR       Section,          OPTIONAL
    IN  PCSTR       Key,              OPTIONAL
    OUT PSTR        ReturnBuffer,     OPTIONAL
    IN  DWORD       ReturnBufferSize,
    OUT PDWORD      RequiredSize      OPTIONAL
    )
{
    INFCONTEXT context;
    BOOL b;
    UINT FieldCount;
    UINT u;
    BOOL InsufficientBuffer;
    DWORD OldSize, TmpRequiredSize;
    PCWSTR Field;
    PCSTR field;
    PCWSTR section,key;

    //
    // Set up inf context.
    //
    if(Context) {
        u = NO_ERROR;
        try {
            context = *Context;
        } except(EXCEPTION_EXECUTE_HANDLER) {
            u = ERROR_INVALID_PARAMETER;
        }
        if(u != NO_ERROR) {
            SetLastError(u);
            return(FALSE);
        }
    } else {
        if(!InfHandle || !Section || !Key) {
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }

        if(Section) {
            u = pSetupCaptureAndConvertAnsiArg(Section,&section);
            if(u != NO_ERROR) {
                SetLastError(u);
                return(FALSE);
            }
        } else {
            section = NULL;
        }

        if(Key) {
            u = pSetupCaptureAndConvertAnsiArg(Key,&key);
            if(u != NO_ERROR) {
                if(section) {
                    MyFree(section);
                }
                SetLastError(u);
                return(FALSE);
            }
        } else {
            key = NULL;
        }

        b = SetupFindFirstLine(InfHandle,section,key,&context);
        u = GetLastError();

        if(section) {
            MyFree(section);
        }
        if(key) {
            MyFree(key);
        }

        if(!b) {
            SetLastError(u);
            return FALSE;
        }
    }

    //
    // Figure out how many fields are involved.
    //
    InsufficientBuffer = FALSE;
    if(FieldCount = SetupGetFieldCount(&context)) {
        TmpRequiredSize = 0;

        for(u=0; u<FieldCount; u++) {

            Field = pSetupGetField(&context, u+1);
            MYASSERT(Field);

            field = pSetupUnicodeToAnsi(Field);
            if(!field) {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                return(FALSE);
            }

            OldSize = TmpRequiredSize;
            TmpRequiredSize += lstrlenA(field)+1;

            if(ReturnBuffer) {
                if(TmpRequiredSize > ReturnBufferSize) {
                    InsufficientBuffer = TRUE;
                } else {
                    //
                    // lstrcpy is safe even with bad pointers
                    // (at least on NT)
                    //
                    lstrcpyA(ReturnBuffer+OldSize,field);
                    ReturnBuffer[TmpRequiredSize - 1] = ',';
                }
            }

            MyFree(field);
        }

        //
        // 0-terminate the buffer by overwriting the final comma.
        //
        if(ReturnBuffer && !InsufficientBuffer) {
            ReturnBuffer[TmpRequiredSize - 1] = 0;
        }
    } else {
        //
        // Special case when no values -- need 1 byte for nul.
        //
        if (GetLastError() != NO_ERROR) {
            //
            // actually, something went wrong reading the data from our context...
            // bail out
            //
            return(FALSE);
        }
        TmpRequiredSize = 1;
        if(ReturnBuffer) {
            if(ReturnBufferSize) {
                *ReturnBuffer = 0;
            } else {
                InsufficientBuffer = TRUE;
            }
        }
    }

    if(RequiredSize) {
        u = NO_ERROR;
        try {
            *RequiredSize = TmpRequiredSize;
        } except(EXCEPTION_EXECUTE_HANDLER) {
            u = ERROR_INVALID_PARAMETER;
        }
        if(u != NO_ERROR) {
            SetLastError(u);
            return(FALSE);
        }
    }

    if(InsufficientBuffer) {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    }

    return TRUE;
}
#else
//
// Unicode stub
//
BOOL
SetupGetLineTextW(
    IN  PINFCONTEXT Context,          OPTIONAL
    IN  HINF        InfHandle,        OPTIONAL
    IN  PCWSTR      Section,          OPTIONAL
    IN  PCWSTR      Key,              OPTIONAL
    OUT PWSTR       ReturnBuffer,     OPTIONAL
    IN  DWORD       ReturnBufferSize,
    OUT PDWORD      RequiredSize      OPTIONAL
    )
{
    UNREFERENCED_PARAMETER(Context);
    UNREFERENCED_PARAMETER(InfHandle);
    UNREFERENCED_PARAMETER(Section);
    UNREFERENCED_PARAMETER(Key);
    UNREFERENCED_PARAMETER(ReturnBuffer);
    UNREFERENCED_PARAMETER(ReturnBufferSize);
    UNREFERENCED_PARAMETER(RequiredSize);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif

BOOL
SetupGetLineText(
    IN  PINFCONTEXT Context,          OPTIONAL
    IN  HINF        InfHandle,        OPTIONAL
    IN  PCTSTR      Section,          OPTIONAL
    IN  PCTSTR      Key,              OPTIONAL
    OUT PTSTR       ReturnBuffer,     OPTIONAL
    IN  DWORD       ReturnBufferSize,
    OUT PDWORD      RequiredSize      OPTIONAL
    )

/*++

Routine Description:

    This function returns the contents of a line in a compact format.
    All extraneous whitespace is removed, and multi-line values are converted
    into a single contiguous string.

    For example, consider the following extract from an INF:

    HKLM, , Foo, 1, \
    ; This is a comment
    01, 02, 03

    would be returned as:
    HKLM,,Foo,1,01,02,03

Arguments:

    Context - Supplies context for an inf line whose text is to be retreived.
        If not specified, then InfHandle, Section, and Key must be.

    InfHandle - Supplies handle of the INF file to query.
        Only used if Context is NULL.

    Section - points to a null-terminated string that specifies the section
        containing the key nameof the line whose text is to be retreived.
        (Only used if InfLineHandle is NULL.)

    Key - Points to the null-terminated string containing the key name
        whose associated string is to be retrieved. (Only used if InfLineHandle is NULL.)

    ReturnBuffer - Points to the buffer that receives the retrieved string.

    ReturnBufferSize - Specifies the size, in characters, of the buffer pointed to
        by the ReturnBuffer parameter.

    RequiredSize - Receives the actual number of characters needed for the buffer
        pointed to by the ReturnBuffer parameter. If this value is larger than the
        value specified in the ReturnBufferSize parameter, the function fails and
        the function stores no data in the buffer.

Return Value:

    If the function succeeds, the return value is TRUE.
    If the function fails, the return value is FALSE. To get extended error information,
        call GetLastError.

--*/

{
    INFCONTEXT context;
    BOOL b;
    UINT FieldCount;
    UINT u;
    BOOL InsufficientBuffer;
    DWORD OldSize, TmpRequiredSize;
    PCTSTR Field;

    //
    // Set up inf context.
    //
    if(Context) {
        u = NO_ERROR;
        try {
            context = *Context;
        } except(EXCEPTION_EXECUTE_HANDLER) {
            u = ERROR_INVALID_PARAMETER;
        }
        if(u != NO_ERROR) {
            SetLastError(u);
            return(FALSE);
        }
    } else {
        if(!InfHandle || !Section || !Key) {
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }
        if(!SetupFindFirstLine(InfHandle, Section, Key, &context)) {
            return FALSE;
        }
    }

    //
    // Figure out how many fields are involved.
    //
    InsufficientBuffer = FALSE;
    if(FieldCount = SetupGetFieldCount(&context)) {
        TmpRequiredSize = 0;

        for(u=0; u<FieldCount; u++) {

            Field = pSetupGetField(&context, u+1);
            MYASSERT(Field);

            OldSize = TmpRequiredSize;
            TmpRequiredSize += lstrlen(Field)+1;

            if(ReturnBuffer) {
                if(TmpRequiredSize > ReturnBufferSize) {
                    InsufficientBuffer = TRUE;
                } else {
                    //
                    // lstrcpy is safe even with bad pointers
                    // (at least on NT)
                    //
                    lstrcpy(ReturnBuffer+OldSize, Field);
                    ReturnBuffer[TmpRequiredSize - 1] = TEXT(',');
                }
            }
        }

        //
        // 0-terminate the buffer by overwriting the final comma.
        //
        if(ReturnBuffer && !InsufficientBuffer) {
            ReturnBuffer[TmpRequiredSize - 1] = TEXT('\0');
        }
    } else {
        //
        // Special case when no values -- need 1 byte for nul.
        //
        if (GetLastError() != NO_ERROR) {
            //
            // actually, something went wrong reading the data from our context...
            // bail out
            //
            return(FALSE);
        }
        TmpRequiredSize = 1;
        if(ReturnBuffer) {
            if(ReturnBufferSize) {
                *ReturnBuffer = TEXT('\0');
            } else {
                InsufficientBuffer = TRUE;
            }
        }
    }

    if(RequiredSize) {
        u = NO_ERROR;
        try {
            *RequiredSize = TmpRequiredSize;
        } except(EXCEPTION_EXECUTE_HANDLER) {
            u = ERROR_INVALID_PARAMETER;
        }
        if(u != NO_ERROR) {
            SetLastError(u);
            return(FALSE);
        }
    }

    if(InsufficientBuffer) {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    }

    return TRUE;
}


#ifdef UNICODE
//
// ANSI version
//
BOOL
SetupGetMultiSzFieldA(
    IN  PINFCONTEXT Context,
    IN  DWORD       FieldIndex,
    OUT PSTR        ReturnBuffer,     OPTIONAL
    IN  DWORD       ReturnBufferSize,
    OUT LPDWORD     RequiredSize      OPTIONAL
    )
{
    PCTSTR Field;
    UINT FieldCount;
    UINT u;
    UINT Len;
    BOOL InsufficientBuffer;
    DWORD OldSize, TmpRequiredSize;
    DWORD rc;
    PCSTR field;

    rc = NO_ERROR;

    //
    // Disallow keys
    //
    if(FieldIndex == 0) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // Figure out how many fields are involved.
    //
    FieldCount = SetupGetFieldCount(Context);
    if (FieldCount == 0 && GetLastError() != NO_ERROR) {
        return FALSE;
    }
    if(FieldCount > (FieldIndex-1)) {
        FieldCount -= FieldIndex - 1;
    } else {
        FieldCount = 0;
    }

    //
    // Need at least one byte for the terminating nul.
    //
    TmpRequiredSize = 1;
    InsufficientBuffer = FALSE;

    if(ReturnBuffer) {
        if(ReturnBufferSize) {
            try {
                *ReturnBuffer = 0;
            } except(EXCEPTION_EXECUTE_HANDLER) {
                rc = ERROR_INVALID_PARAMETER;
            }
            if(rc != NO_ERROR) {
                SetLastError(rc);
                return(FALSE);
            }
        } else {
            InsufficientBuffer = TRUE;
        }
    }

    for(u=0; u<FieldCount; u++) {

        try {
            Field = pSetupGetField(Context, u+FieldIndex);
        } except(EXCEPTION_EXECUTE_HANDLER) {
            rc = ERROR_INVALID_PARAMETER;
        }
        if(rc != NO_ERROR) {
            SetLastError(rc);
            return(FALSE);
        }

        MYASSERT(Field);

        field = pSetupUnicodeToAnsi(Field);
        if(!field) {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return(FALSE);
        }

        if((Len = lstrlenA(field)+1) == 1) {
            //
            // Then we've encountered an empty field.  Since multi-sz lists can't contain
            // an empty string, this terminates our list.
            //
            MyFree(field);
            goto clean0;
        }

        OldSize = TmpRequiredSize;
        TmpRequiredSize += Len;

        if(ReturnBuffer) {
            if(TmpRequiredSize > ReturnBufferSize) {
                InsufficientBuffer = TRUE;
            } else {
                //
                // lstrcpy is safe with bad pointers (at least on NT)
                //
                lstrcpyA(ReturnBuffer+OldSize-1,field);
                ReturnBuffer[TmpRequiredSize - 1] = 0;
            }
        }

        MyFree(field);
    }

clean0:
    if(RequiredSize) {
        try {
            *RequiredSize = TmpRequiredSize;
        } except(EXCEPTION_EXECUTE_HANDLER) {
            rc = ERROR_INVALID_PARAMETER;
        }
        if(rc != NO_ERROR) {
            SetLastError(rc);
            return(FALSE);
        }
    }

    if(InsufficientBuffer) {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    }

    return TRUE;
}
#else
//
// Unicode stub
//
BOOL
SetupGetMultiSzFieldW(
    IN  PINFCONTEXT Context,
    IN  DWORD       FieldIndex,
    OUT PWSTR       ReturnBuffer,     OPTIONAL
    IN  DWORD       ReturnBufferSize,
    OUT LPDWORD     RequiredSize      OPTIONAL
    )
{
    UNREFERENCED_PARAMETER(Context);
    UNREFERENCED_PARAMETER(FieldIndex);
    UNREFERENCED_PARAMETER(ReturnBuffer);
    UNREFERENCED_PARAMETER(ReturnBufferSize);
    UNREFERENCED_PARAMETER(RequiredSize);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif

BOOL
SetupGetMultiSzField(
    IN  PINFCONTEXT Context,
    IN  DWORD       FieldIndex,
    OUT PTSTR       ReturnBuffer,     OPTIONAL
    IN  DWORD       ReturnBufferSize,
    OUT LPDWORD     RequiredSize      OPTIONAL
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    PCTSTR Field;
    UINT FieldCount;
    UINT u;
    UINT Len;
    BOOL InsufficientBuffer;
    DWORD OldSize, TmpRequiredSize;
    DWORD rc;

    rc = NO_ERROR;

    //
    // Disallow keys
    //
    if(FieldIndex == 0) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // Figure out how many fields are involved.
    //
    FieldCount = SetupGetFieldCount(Context);
    if (FieldCount == 0 && GetLastError() != NO_ERROR) {
        return FALSE;
    }
    if(FieldCount > (FieldIndex-1)) {
        FieldCount -= FieldIndex - 1;
    } else {
        FieldCount = 0;
    }

    //
    // Need at least one byte for the terminating nul.
    //
    TmpRequiredSize = 1;
    InsufficientBuffer = FALSE;

    if(ReturnBuffer) {
        if(ReturnBufferSize) {
            try {
                *ReturnBuffer = 0;
            } except(EXCEPTION_EXECUTE_HANDLER) {
                rc = ERROR_INVALID_PARAMETER;
            }
            if(rc != NO_ERROR) {
                SetLastError(rc);
                return(FALSE);
            }
        } else {
            InsufficientBuffer = TRUE;
        }
    }

    for(u=0; u<FieldCount; u++) {

        try {
            Field = pSetupGetField(Context, u+FieldIndex);
        } except(EXCEPTION_EXECUTE_HANDLER) {
            rc = ERROR_INVALID_PARAMETER;
        }
        if(rc != NO_ERROR) {
            SetLastError(rc);
            return(FALSE);
        }

        MYASSERT(Field);

        if((Len = lstrlen(Field)+1) == 1) {
            //
            // Then we've encountered an empty field.  Since multi-sz lists can't contain
            // an empty string, this terminates our list.
            //
            goto clean0;
        }

        OldSize = TmpRequiredSize;
        TmpRequiredSize += Len;

        if(ReturnBuffer) {
            if(TmpRequiredSize > ReturnBufferSize) {
                InsufficientBuffer = TRUE;
            } else {
                //
                // lstrcpy is safe with bad pointers (at least on NT)
                //
                lstrcpy(ReturnBuffer+OldSize-1, Field);
                ReturnBuffer[TmpRequiredSize - 1] = 0;
            }
        }
    }

clean0:
    if(RequiredSize) {
        try {
            *RequiredSize = TmpRequiredSize;
        } except(EXCEPTION_EXECUTE_HANDLER) {
            rc = ERROR_INVALID_PARAMETER;
        }
        if(rc != NO_ERROR) {
            SetLastError(rc);
            return(FALSE);
        }
    }

    if(InsufficientBuffer) {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    }

    return TRUE;
}


BOOL
SetupGetBinaryField(
    IN  PINFCONTEXT Context,
    IN  DWORD       FieldIndex,
    OUT PBYTE       ReturnBuffer,     OPTIONAL
    IN  DWORD       ReturnBufferSize,
    OUT LPDWORD     RequiredSize      OPTIONAL
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    PCTSTR Field;
    UINT FieldCount;
    UINT u;
    ULONG Value;
    BOOL Store;
    PTCHAR End;
    DWORD TmpRequiredSize;
    DWORD rc;

    rc = NO_ERROR;

    //
    // Disallow keys
    //
    if(FieldIndex == 0) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // Figure out how many fields are involved.
    //
    FieldCount = SetupGetFieldCount(Context);
    if (FieldCount == 0 && GetLastError() != NO_ERROR) {
        return FALSE;
    }
    if(FieldCount > (FieldIndex-1)) {
        FieldCount -= FieldIndex - 1;
    } else {
        FieldCount = 0;
    }

    TmpRequiredSize = FieldCount;

    Store = (ReturnBuffer && (TmpRequiredSize <= ReturnBufferSize));

    //
    // Even though we know the required size,
    // go through the loop anyway to validate the data.
    //
    for(u=0; u<FieldCount; u++) {

        try {
            if(!(Field = pSetupGetField(Context,u+FieldIndex))) {
                rc = ERROR_INVALID_HANDLE;
            }
        } except(EXCEPTION_EXECUTE_HANDLER) {
            rc = ERROR_INVALID_PARAMETER;
        }
        if(rc != NO_ERROR) {
            SetLastError(rc);
            return(FALSE);
        }

        Value = _tcstoul(Field, &End, 16);

        //
        // Only the terminating nul should have caused the conversion
        // to stop. In any other case there were non-hex digits in the string.
        // Also disallow the empty string.
        //
        if((End == Field) || *End || (Value > 255)) {
            SetLastError(ERROR_INVALID_DATA);
            return FALSE;
        }

        if(Store) {
            try {
                *ReturnBuffer++ = (UCHAR)Value;
            } except(EXCEPTION_EXECUTE_HANDLER) {
                rc = ERROR_INVALID_PARAMETER;
            }
            if(rc != NO_ERROR) {
                SetLastError(rc);
                return(FALSE);
            }
        }
    }

    if(RequiredSize) {
        try {
            *RequiredSize = TmpRequiredSize;
        } except(EXCEPTION_EXECUTE_HANDLER) {
            rc = ERROR_INVALID_PARAMETER;
        }
        if(rc != NO_ERROR) {
            SetLastError(rc);
            return(FALSE);
        }
    }

    if(ReturnBuffer && (TmpRequiredSize > ReturnBufferSize)) {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    }

    return TRUE;
}


PINF_LINE
InfLineFromContext(
    IN PINFCONTEXT Context
    )

/*++

Routine Description:

    Given an INF context, return a pointer to the inf line structure.

Arguments:

    Context - supplies a pointer to the context structure that was filled
        in by one of the line-related INF APIs.
        No validation is performed on any value in the context structure.

Return Value:

    Pointer to the relevent inf line structure.

--*/

{
    PLOADED_INF Inf;
    PINF_SECTION Section;
    PINF_LINE Line;

    Inf = (PLOADED_INF)Context->CurrentInf;

    if(!LockInf((PLOADED_INF)Context->Inf)) {
        return(NULL);
    }

    Section = &Inf->SectionBlock[Context->Section];
    Line = &Inf->LineBlock[Section->Lines + Context->Line];

    UnlockInf((PLOADED_INF)Context->Inf);
    return(Line);
}

/////////////////////////////////////////////////////////////////
//
// Internal routines
//
/////////////////////////////////////////////////////////////////




BOOL
pSetupGetSecurityInfo(
    IN HINF Inf,
    IN PCTSTR SectionName,
    OUT PCTSTR *SecDesc )
{

    BOOL b;
    PTSTR SecuritySectionName;
    INFCONTEXT LineContext;
    DWORD rc;


    SecuritySectionName = (PTSTR)MyMalloc( ((lstrlen(SectionName) + lstrlen((PCTSTR)L".Security"))*sizeof(TCHAR)) + 3l );
    if( !SecuritySectionName ){
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return( FALSE );
    }

    lstrcpy( SecuritySectionName, SectionName );
    lstrcat( SecuritySectionName, (PCTSTR)(L".Security") );
    b = SetupFindFirstLine(Inf,(PCTSTR)SecuritySectionName,NULL,&LineContext);
    MyFree( SecuritySectionName );
    if(!b)
        return( FALSE );    // Section did not exist or other error


    if( !(*SecDesc = pSetupGetField( &LineContext, 1 )) )
        return( FALSE );            // Error code is present by checking GetLastError() if needed
    else
        return( TRUE );


}




PCTSTR
pSetupGetField(
    IN PINFCONTEXT Context,
    IN DWORD       FieldIndex
    )

/*++

Routine Description:

    Retreive a field from a line.

Arguments:

    Context - supplies inf context. No validation is performed
        on the values contained in this structure.

    FieldIndex - supplies 1-based index of field to retreive.
        An index of 0 retreives the key, if it exists.

Return Value:

    Pointer to string. The caller must not write into this buffer.

    If the field index is not valid, the return value is NULL,
    and SetLastError() will have been called.

--*/

{
    PINF_LINE Line;
    PTSTR p = NULL;
    DWORD Err = NO_ERROR;

    //
    // InfLineFromContext does it's own INF locking, but the later call
    // to InfGetField doesn't, so go ahead and grab the lock up front.
    //
    if(LockInf((PLOADED_INF)Context->Inf)) {

        if(Line = InfLineFromContext(Context)) {

            if((p = InfGetField(Context->CurrentInf,Line,FieldIndex,NULL)) == NULL) {
                Err = ERROR_INVALID_PARAMETER;
            }

        } else {
            Err = ERROR_INVALID_PARAMETER;
        }

        UnlockInf((PLOADED_INF)Context->Inf);

    } else {
        Err = ERROR_INVALID_HANDLE;
    }

    SetLastError(Err);
    return p;
}

BOOL
pSetupGetDriverDate(
    IN  HINF        InfHandle,
    IN  PCTSTR      Section,
    IN OUT PFILETIME  pFileTime
    )

/*++

Routine Description:

    Retreive the date from a specified Section.

    The Date specified in an INF section has the following format:

    DriverVer=xx/yy/zzzz

        or

    DriverVer=xx-yy-zzzz

    where xx is the month, yy is the day, and zzzz is the for digit year.
    Note that the year MUST be 4 digits.  A year of 98 will be considered
    0098 and not 1998!

    This date should be the date of the Drivers and not for the INF itself.
    So a single INF can have multiple driver install Sections and each can
    have different dates depending on when the driver was last updated.

Arguments:

    InfHandle - Supplies handle of the INF file to query.

    Section - points to a null-terminated string that specifies the section
        of the driver to get the FILETIME infomation.

    pFileTime - points to a FILETIME structure that will receive the Date,
        if it exists.

Return Value:

    BOOL. TRUE if a valid date existed in the specified Section and FALSE otherwise.

--*/

{
    DWORD rc;
    SYSTEMTIME SystemTime;
    INFCONTEXT InfContext;
    TCHAR DriverDate[20];
    PTSTR Convert, Temp;
    DWORD Value;

    rc = NO_ERROR;

    try {

        *DriverDate = 0;
        ZeroMemory(&SystemTime, sizeof(SYSTEMTIME));
        pFileTime->dwLowDateTime = 0;
        pFileTime->dwHighDateTime = 0;

        if(SetupFindFirstLine(InfHandle, Section, pszDriverVer, &InfContext)) {

            if ((SetupGetStringField(&InfContext,
                                1,
                                DriverDate,
                                SIZECHARS(DriverDate),
                                NULL)) &&
                 (*DriverDate)) {

                Convert = DriverDate;

                if (*Convert) {

                    Temp = DriverDate;
                    while (*Temp && (*Temp != TEXT('-')) && (*Temp != TEXT('/')))
                        Temp++;

                    if (*Temp == TEXT('\0')) {
                        //
                        // There is no day or year in this date, so just exit.
                        //
                        leave;
                    }

                    *Temp = 0;

                    //
                    //Convert the month
                    //
                    pAToI(Convert, (PINT)&Value);
                    SystemTime.wMonth = LOWORD(Value);

                    Convert = Temp+1;

                    if (*Convert) {

                        Temp = Convert;
                        while (*Temp && (*Temp != TEXT('-')) && (*Temp != TEXT('/')))
                            Temp++;

                        if (*Temp == TEXT('\0')) {
                            //
                            // There is no day or year in this date, so just exit.
                            //
                            leave;
                        }
                        
                        *Temp = 0;

                        //
                        //Convert the day
                        //
                        pAToI(Convert, (PINT)&Value);
                        SystemTime.wDay = LOWORD(Value);

                        Convert = Temp+1;

                        if (*Convert) {

                            //
                            //Convert the year
                            //
                            pAToI(Convert, (PINT)&Value);
                            SystemTime.wYear = LOWORD(Value);

                            //
                            //Convert SYSTEMTIME into FILETIME
                            //
                            SystemTimeToFileTime(&SystemTime, pFileTime);
                        }
                    }
                }
            }

        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        rc = ERROR_INVALID_PARAMETER;
        SetLastError(rc);
        return FALSE;
    }

    SetLastError(NO_ERROR);
    return((pFileTime->dwLowDateTime != 0) || (pFileTime->dwHighDateTime != 0));
}



BOOL
pSetupGetDriverVersion(
    IN  HINF        InfHandle,
    IN  PCTSTR      Section,
    OUT DWORDLONG   *Version
    )

/*++

Routine Description:

    Retreive the driver version from a specified Section.

    The driver version specified in an INF section has the following format:

    DriverVer=xx/yy/zzzz, a.b.c.d

        or

    DriverVer=xx-yy-zzzz, a.b.c.d

    a.b.c.d is the version of the driver, where a, b, c, and d are all WORD
    decimal values.

    The version is in the second field in the DriverVer INF value, the driver date
    is in the first field.

Arguments:

    InfHandle - Supplies handle of the INF file to query.

    Section - points to a null-terminated string that specifies the section
        of the driver to get the FILETIME infomation.

    Version - points to a DWORDLONG value that will receive the version,
        if it exists.

Return Value:

    BOOL. TRUE if a valid driver version existed in the specified Section and FALSE otherwise.

--*/

{
    DWORD rc;
    INFCONTEXT InfContext;
    TCHAR DriverVersion[LINE_LEN];
    BOOL bEnd = FALSE;
    INT MajorHiWord, MajorLoWord, MinorHiWord, MinorLoWord;
    PTSTR Convert, Temp;

    rc = NO_ERROR;

    try {

        *DriverVersion = 0;
        *Version = 0;
        MajorHiWord = MajorLoWord = MinorHiWord = MinorLoWord = 0;

        if(SetupFindFirstLine(InfHandle, Section, pszDriverVer, &InfContext)) {

            if ((SetupGetStringField(&InfContext,
                                2,
                                DriverVersion,
                                SIZECHARS(DriverVersion),
                                NULL)) &&
                 (*DriverVersion)) {

                Convert = DriverVersion;

                if (*Convert) {

                    Temp = DriverVersion;
                    while (*Temp && (*Temp != TEXT('.'))) {

                        Temp++;
                    }

                    if (!*Temp) {

                       bEnd = TRUE;
                    }

                    *Temp = 0;

                    //
                    //Convert the HIWORD of the major version
                    //
                    if (pAToI(Convert, (PINT)&MajorHiWord)) {

                        Convert = Temp+1;

                        if (!bEnd && *Convert) {

                            Temp = Convert;
                            while (*Temp && (*Temp != TEXT('.'))) {

                                Temp++;
                            }

                            if (!*Temp) {

                                bEnd = TRUE;
                            }

                            *Temp = 0;

                            //
                            //Convert the LOWORD of the major version
                            //
                            if (pAToI(Convert, (PINT)&MajorLoWord)) {

                                Convert = Temp+1;

                                if (!bEnd && *Convert) {

                                    Temp = Convert;
                                    while (*Temp && (*Temp != TEXT('.'))) {

                                        Temp++;
                                    }

                                    if (!*Temp) {

                                        bEnd = TRUE;
                                    }

                                    *Temp = 0;

                                    //
                                    //Convert the HIWORD of the minor version
                                    //
                                    if (pAToI(Convert, (PINT)&MinorHiWord)) {

                                        Convert = Temp+1;

                                        if (!bEnd && *Convert) {

                                            Temp = Convert;
                                            while (*Temp && (*Temp != TEXT('.'))) {

                                                Temp++;
                                            }

                                            *Temp = 0;

                                            //
                                            //Convert the LOWORD of the minor version
                                            //
                                            pAToI(Convert, (PINT)&MinorLoWord);
                                        }
                                    }
                                }
                            }
                        }
                    }


                    *Version = (((DWORDLONG)MajorHiWord << 48) +
                                 ((DWORDLONG)MajorLoWord << 32) +
                                 ((DWORDLONG)MinorHiWord << 16) +
                                  (DWORDLONG)MinorLoWord);
                }
            }

        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        rc = ERROR_INVALID_PARAMETER;
        *Version = 0;
        SetLastError(rc);
        return FALSE;
    }

    SetLastError(NO_ERROR);
    return(*Version != 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\setupapi\infload.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    infload.c

Abstract:

    Routines to load and parse INF files, and manipulate data in them.

Author:

    Ted Miller (tedm) 13-Jan-1995

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include <ntverp.h>

//
// Values used when initializing and growing the section, line, and value blocks.
//
#define INITIAL_SECTION_BLOCK_SIZE  50
#define INITIAL_LINE_BLOCK_SIZE     350
#define INITIAL_VALUE_BLOCK_SIZE    1000

#define SECTION_BLOCK_GROWTH    10
#define LINE_BLOCK_GROWTH       100
#define VALUE_BLOCK_GROWTH      500

//
// Define unresolved substitution values for return by ParseValueString and
// ProcessForSubstitutions
//
#define UNRESOLVED_SUBST_NONE                  (0)
#define UNRESOLVED_SUBST_USER_DIRID            (1)
#define UNRESOLVED_SUBST_SYSTEM_VOLATILE_DIRID (2)


//
// Macros used to quadword-align PNF blocks.
//
#define PNF_ALIGNMENT      ((DWORD)8)
#define PNF_ALIGN_MASK     (~(DWORD)(PNF_ALIGNMENT - 1))

#define PNF_ALIGN_BLOCK(x) ((x & PNF_ALIGN_MASK) + ((x & ~PNF_ALIGN_MASK) ? PNF_ALIGNMENT : 0))

//
// Structure containing parameters relating to a [strings] section of an INF
// file (used during parsing).
//
typedef struct _STRINGSEC_PARAMS {
    PCTSTR Start;
    PCTSTR End;
    UINT   StartLineNumber;
    UINT   EndLineNumber;
} STRINGSEC_PARAMS, *PSTRINGSEC_PARAMS;


//
// Parse context, used by inf load/parse routines to pass
// state around.
//
typedef struct _PARSE_CONTEXT {

    //
    // Pointer to the end of the buffer.
    //
    PCTSTR BufferEnd;

    //
    // Current line number in the file
    //
    UINT CurrentLineNumber;

    //
    // section, line, and value block buffer sizes and current locations.
    //
    UINT LineBlockUseCount;
    UINT ValueBlockUseCount;
    UINT SectionBlockSize;
    UINT LineBlockSize;
    UINT ValueBlockSize;

    //
    // Value indicating whether we are within a section.
    // We always within a section unless the first non-comment line
    // of the inf is not section line, and that is an error case.
    //
    BOOL GotOneSection;

    //
    // Pointer to the actual inf descriptor
    //
    PLOADED_INF Inf;

    //
    // The following field is used solely for the purposes of calling
    // ProcessForSubstitutions() after an INF has already been loaded.  This is
    // necessary when applying user-defined or volatile system DIRIDs to
    // unresolved string substitutions.  If this flag is TRUE, then the
    // aforementioned routine will call pSetupVolatileDirIdToPath for %<x>%
    // substrings, instead of its normal (i.e., load-time) processing.
    //
    BOOL DoVolatileDirIds;

    //
    // Specifies the directory where this INF is located (if it's an OEM location).
    //
    PCTSTR InfSourcePath;   // may be NULL.

    //
    // Specifies the drive/directory where the OsLoader is located.
    //
    PCTSTR OsLoaderPath;

    //
    // Buffer used during parsing.
    //
    TCHAR TemporaryString[MAX_INF_STRING_LENGTH+1];

} PARSE_CONTEXT, *PPARSE_CONTEXT;

//
// Declare global string variables used throughout the inf loaders.
//
// These strings are defined in infstr.h:
//
CONST TCHAR pszSignature[]          = INFSTR_KEY_SIGNATURE,
            pszVersion[]            = INFSTR_SECT_VERSION,
            pszClass[]              = INFSTR_KEY_HARDWARE_CLASS,
            pszClassGuid[]          = INFSTR_KEY_HARDWARE_CLASSGUID,
            pszProvider[]           = INFSTR_KEY_PROVIDER,
            pszStrings[]            = SZ_KEY_STRINGS,
            pszLayoutFile[]         = SZ_KEY_LAYOUT_FILE,
            pszManufacturer[]       = INFSTR_SECT_MFG,
            pszControlFlags[]       = INFSTR_CONTROLFLAGS_SECTION,
            pszReboot[]             = INFSTR_REBOOT,
            pszRestart[]            = INFSTR_RESTART,
            pszClassInstall32[]     = INFSTR_SECT_CLASS_INSTALL_32,
            pszAddInterface[]       = SZ_KEY_ADDINTERFACE,
            pszInterfaceInstall32[] = INFSTR_SECT_INTERFACE_INSTALL_32,
            pszAddService[]         = SZ_KEY_ADDSERVICE,
            pszDelService[]         = SZ_KEY_DELSERVICE,
            pszCatalogFile[]        = INFSTR_KEY_CATALOGFILE;


//
// Other misc. global strings:
//
// Be sure to keep these strings in sync with the strings used
// in inf.h to compute the array size.  This is done so that
// we can determine string length by doing a sizeof() instead
// of having to do lstrlen().
//
CONST TCHAR pszDrvDescFormat[]                  = DISTR_INF_DRVDESCFMT,
            pszHwSectionFormat[]                = DISTR_INF_HWSECTIONFMT,
            pszChicagoSig[]                     = DISTR_INF_CHICAGOSIG,
            pszWindowsNTSig[]                   = DISTR_INF_WINNTSIG,
            pszWindows95Sig[]                   = DISTR_INF_WIN95SIG,
            pszWinSuffix[]                      = DISTR_INF_WIN_SUFFIX,
            pszNtSuffix[]                       = DISTR_INF_NT_SUFFIX,
            pszNtX86Suffix[]                    = DISTR_INF_NTX86_SUFFIX,
            pszNtIA64Suffix[]                   = DISTR_INF_NTIA64_SUFFIX,
            pszNtAMD64Suffix[]                  = DISTR_INF_NTAMD64_SUFFIX,
            pszPnfSuffix[]                      = DISTR_INF_PNF_SUFFIX,
            pszInfSuffix[]                      = DISTR_INF_INF_SUFFIX,
            pszCatSuffix[]                      = DISTR_INF_CAT_SUFFIX,
            pszServicesSectionSuffix[]          = DISTR_INF_SERVICES_SUFFIX,
            pszWmiSectionSuffix[]               = DISTR_INF_WMI_SUFFIX,
            pszInterfacesSectionSuffix[]        = DISTR_INF_INTERFACES_SUFFIX,
            pszCoInstallersSectionSuffix[]      = DISTR_INF_COINSTALLERS_SUFFIX,
            pszLogConfigOverrideSectionSuffix[] = DISTR_INF_LOGCONFIGOVERRIDE_SUFFIX,
            pszX86SrcDiskSuffix[]               = DISTR_INF_SRCDISK_SUFFIX_X86,
            pszIa64SrcDiskSuffix[]              = DISTR_INF_SRCDISK_SUFFIX_IA64,
            pszAmd64SrcDiskSuffix[]             = DISTR_INF_SRCDISK_SUFFIX_AMD64;


DWORD
CreateInfVersionNode(
    IN PLOADED_INF Inf,
    IN PCTSTR      Filename,
    IN PFILETIME   LastWriteTime
    );

BOOL
LoadPrecompiledInf(
    IN  PCTSTR       Filename,
    IN  PFILETIME    LastWriteTime,
    IN  PCTSTR       OsLoaderPath,                    OPTIONAL
    IN  DWORD        LanguageId,
    IN  DWORD        Flags,
    IN  PSETUP_LOG_CONTEXT LogContext,                OPTIONAL
    OUT PLOADED_INF *Inf,
    OUT PTSTR       *InfSourcePathToMigrate,          OPTIONAL
    OUT PDWORD       InfSourcePathToMigrateMediaType, OPTIONAL
    OUT PTSTR       *InfOriginalNameToMigrate         OPTIONAL
    );

DWORD
SavePnf(
    IN PCTSTR      Filename,
    IN PLOADED_INF Inf
    );

PLOADED_INF
DuplicateLoadedInfDescriptor(
    IN PLOADED_INF Inf
    );

BOOL
AddUnresolvedSubstToList(
    IN PLOADED_INF Inf,
    IN UINT        ValueOffset,
    IN BOOL        CaseSensitive
    );

BOOL
AlignForNextBlock(
    IN HANDLE hFile,
    IN DWORD  ByteCount
    );


BOOL
IsWhitespace(
    IN PCTSTR pc
    )

/*++

Routine Description:

    Determine whether a character is whitespace. Whitespace refers to the ctype
    definition.

Arguments:

    pc - points to character to be examined.

Return Value:

    TRUE if the character is whitespace. FALSE if not.

    Note that the nul chracter is not whitespace.

--*/

{
    WORD Type;

    return(GetStringTypeEx(LOCALE_SYSTEM_DEFAULT,CT_CTYPE1,pc,1,&Type) && (Type & C1_SPACE));
}


VOID
SkipWhitespace(
    IN OUT PCTSTR *Location,
    IN     PCTSTR  BufferEnd
    )

/*++

Routine Description:

    Skip whitespace characters in the input stream. For the purposes of this
    routine, newline characters are NOT considered whitespace.

    Note that the end-of-stream marker ('\0') IS considered whitespace.

Arguments:

    Location - on input, supplies the current location in the input stream.
        On output, receives the location in the input stream of the first
        non-whitespace character. Note that this may be equal to BufferEnd,
        if no whitespace was found, in which case the pointer may be
        invalid.

    BufferEnd - specifies the address of the end of the buffer (i.e., the
        memory address immediately following the buffer's memory range).

Return Value:

    None.

--*/

{
    while((*Location < BufferEnd) &&
          (**Location != TEXT('\n')) &&
          (!(**Location) || IsWhitespace(*Location))) {

        (*Location)++;
    }
}


VOID
SkipLine(
    IN OUT PPARSE_CONTEXT  Context,
    IN OUT PCTSTR         *Location
    )

/*++

Routine Description:

    Skip all remaining characters in the current line, and positions the
    input pointer to the first character on the next line.

    No whitespace is skipped automatically -- the input pointer may
    very well point to whitespace or the end-of-stream marker on exit.

Arguments:

    Context - supplies the parse context

    Location - on input, supplies the current location in the input stream.
        On output, receives the location in the input stream of the first
        character on the next line.

Return Value:

    None.

--*/

{
    PCTSTR BufferEnd = Context->BufferEnd;

    while((*Location < BufferEnd) && (**Location != TEXT('\n'))) {
        (*Location)++;
    }

    //
    // *Location points at either the newline or end-of-buffer.
    // Skip the newline if necessary.
    //
    if(*Location < BufferEnd) {
        Context->CurrentLineNumber++;
        (*Location)++;
    }
}


BOOL
MergeDuplicateSection(
    IN PPARSE_CONTEXT Context
    )
{
    PLOADED_INF Inf;
    PINF_SECTION NewestSection;
    PINF_SECTION Section;
    UINT Size;
    UINT MoveSize;
    PVOID TempBuffer;

    Inf = Context->Inf;

    //
    // Nothing to merge if only one section
    //
    if(Inf->SectionCount < 2) {
        return(TRUE);
    }

    NewestSection = Inf->SectionBlock + Inf->SectionCount - 1;

    //
    // See whether the final section duplicates any existing sections.
    //
    for(Section=Inf->SectionBlock; Section<NewestSection; Section++) {
        if(Section->SectionName == NewestSection->SectionName) {
            break;
        }
    }

    if(Section == NewestSection) {
        //
        // No duplication; return success
        //
        return(TRUE);
    }

    //
    // Got a duplicate.
    //

    //
    // We need to move the new section's lines (at the end of the line block)
    // to be just after the existing section's lines.
    //
    // First, we'll save off the new section's lines in a temporary buffer.
    //
    Size = NewestSection->LineCount * sizeof(INF_LINE);
    TempBuffer = MyMalloc(Size);
    if(!TempBuffer) {
        return(FALSE);
    }
    CopyMemory(TempBuffer,&Inf->LineBlock[NewestSection->Lines],Size);

    //
    // Next, we'll move up the affected existing lines, to make room for
    // the section's new lines
    //
    MoveSize = Context->LineBlockUseCount - (Section->Lines + Section->LineCount);
    MoveSize *= sizeof(INF_LINE);
    MoveSize -= Size;

    MoveMemory(
        &Inf->LineBlock[Section->Lines + Section->LineCount + NewestSection->LineCount],
        &Inf->LineBlock[Section->Lines + Section->LineCount],
        MoveSize
        );

    //
    // Now put the new lines in the hole we just opened up
    //
    CopyMemory(
        &Inf->LineBlock[Section->Lines + Section->LineCount],
        TempBuffer,
        Size
        );

    MyFree(TempBuffer);

    //
    // Adjust the existing section's limits to account for the new lines.
    //
    Section->LineCount += NewestSection->LineCount;

    //
    // Adjust all subsequent sections' starting line value
    //
    for(Section=Section+1; Section<NewestSection; Section++) {
        Section->Lines += NewestSection->LineCount;
    }

    //
    // Remove the newest section.
    //
    Inf->SectionCount--;

    return(TRUE);
}


PTCHAR
LocateStringSubstitute(
    IN  PPARSE_CONTEXT Context,
    IN  PTSTR          String
    )
/*++

Routine Description:

    This routine attempts to find a string substitution in an INF's
    [strings] section for the specified key.

    THIS ROUTINE OPERATES UNDER THE ASSUMPTION THAT IT IS ONLY INVOKED FROM
    WITHIN LOADINF.  IT DOESN'T HANDLE MULTIPLE INFS, NOR DOES IT DO ANY
    INF LOCKING.

Arguments:

    Context - current INF parse context

    String - string to be substituted

Return Value:

    If substitution is a success, the function returns a pointer to the string,
    either in the string table or in the workspace.  If failure, NULL is returned.

--*/
{
    UINT Zero = 0;
    PINF_LINE Line;

    MYASSERT(Context->Inf->SectionCount > 1);
    MYASSERT(Context->Inf->HasStrings);

    //
    // The strings section is always first to be parsed.
    // (See PreprocessInf()).
    //
    // Look for a line in [strings] with key of String.
    //
    if(InfLocateLine(Context->Inf,
                     Context->Inf->SectionBlock,
                     String,
                     &Zero,
                     &Line)) {
        //
        // Get and return value #1.
        //
        return(InfGetField(Context->Inf,Line,1,NULL));
    }

    //
    // No valid substitution exists.
    //
    return NULL;
}


VOID
ProcessForSubstitutions(
    IN OUT PPARSE_CONTEXT Context,
    IN     PCTSTR         String,
    OUT    PDWORD         UnresolvedSubst
    )
{
    PCTSTR In, q;
    PTCHAR Out, p;
    TCHAR Str[MAX_STRING_LENGTH];
    ULONG Len, i;
    PTCHAR End;
    TCHAR DirId[MAX_PATH];
    BOOL HasStrings = Context->Inf->HasStrings;
    UINT DirIdUsed;
    BOOL HasVolatileSysDirId;

    In = String;
    Out = Context->TemporaryString;
    End = Out + SIZECHARS(Context->TemporaryString);

    *UnresolvedSubst = UNRESOLVED_SUBST_NONE;

    while(*In) {

        if(*In == TEXT('%')) {
            //
            // Double % in input ==> single % in output
            //
            if(*(++In) == TEXT('%')) {
                if(Out < End) {
                    *Out++ = TEXT('%');
                }
                In++;
            } else {
                //
                // Look for terminating %.
                //
                if(p = _tcschr(In,TEXT('%'))) {

                    HasVolatileSysDirId = FALSE;

                    //
                    // Get value to substitute. If we can't find the value,
                    // put the whole string like %abc% in there.
                    //
                    Len = (ULONG)(p - In);
                    if(Len > CSTRLEN(Str)) {
                        //
                        // We can't handle substitutions for tokens this long.
                        // We'll just bail in this case, and copy over the token as-is.
                        //
                        q = NULL;
                    } else {
                        lstrcpyn(Str,In,Len+1);
                        if(Context->DoVolatileDirIds) {
                            if(q = pSetupVolatileDirIdToPath(Str, 0, NULL, Context->Inf)) {

                                lstrcpyn(DirId, q, SIZECHARS(DirId));
                                MyFree(q);
                                q = DirId;

                                //
                                // If the next character following this string substitution
                                // is a backslash, then we need to make sure that the path we
                                // just retrieved doesn't have a backslash (i.e., we want to
                                // make sure we have a well-formed path).
                                //
                                if(*(p + 1) == TEXT('\\')) {
                                    i = lstrlen(DirId);
                                    if(i > 0 && (*CharPrev(DirId,DirId+i) == TEXT('\\'))) {
                                        DirId[i-1] = TEXT('\0');
                                    }
                                }
                            }
                        } else {
                            if(HasStrings) {
                                q = LocateStringSubstitute(Context, Str);
                            } else {
                                q = NULL;
                            }
                            if(!q) {
                                //
                                // Maybe we have a standard DIRID here...
                                //
                                if(q = pSetupDirectoryIdToPathEx(Str,
                                                                 &DirIdUsed,
                                                                 NULL,
                                                                 Context->InfSourcePath,
                                                                 &(Context->OsLoaderPath),
                                                                 &HasVolatileSysDirId)) {

                                    lstrcpyn(DirId, q, SIZECHARS(DirId));
                                    MyFree(q);
                                    q = DirId;

                                    //
                                    // If the next character following this string substitution
                                    // is a backslash, then we need to make sure that the path we
                                    // just retrieved doesn't have a backslash (i.e., we want to
                                    // make sure we have a well-formed path).
                                    //
                                    if(*(p + 1) == TEXT('\\')) {
                                        i = lstrlen(DirId);
                                        if(i > 0 && (*CharPrev(DirId,DirId+i) == TEXT('\\'))) {
                                            DirId[i-1] = TEXT('\0');
                                        }
                                    }

                                    if((DirIdUsed == DIRID_BOOT) || (DirIdUsed == DIRID_LOADER)) {
                                        //
                                        // Then this INF contains string substititutions that
                                        // reference system partition DIRIDs.  Store the OsLoaderPath
                                        // contained in the parse context structure in the INF itself.
                                        //
                                        Context->Inf->OsLoaderPath = Context->OsLoaderPath;
                                    }
                                }
                            }
                        }
                    }
                    if(q) {
                        Len = lstrlen(q);
                        for(i=0; i<Len; i++) {
                            if(Out < End) {
                                *Out++ = q[i];
                            }
                        }
                        In = p+1;
                    } else {
                        //
                        // Len is the length of the internal part (the abc in %abc%).
                        //
                        if(Out < End) {
                            *Out++ = TEXT('%');
                        }
                        for(i=0; i<=Len; i++, In++) {
                            if(Out < End) {
                                *Out++ = *In;
                            }
                        }

                        //
                        // When we encounter a substitution for which there is
                        // no corresponding string, we set the UnresolvedSubst
                        // output parameter so that the caller knows to track
                        // this value for later resolution (e.g., for volatile
                        // and user-defined DIRIDs).
                        //
                        // (NOTE: Don't set this if we bailed because the token
                        // was too long!)
                        //
                        if(Len <= CSTRLEN(Str)) {

                            *UnresolvedSubst = HasVolatileSysDirId
                                             ? UNRESOLVED_SUBST_SYSTEM_VOLATILE_DIRID
                                             : UNRESOLVED_SUBST_USER_DIRID;
                        }
                    }

                } else {
                    //
                    // No terminating %. So we have something like %abc.
                    // Want to put %abc in the output. Put the % in here
                    // manually and then just let subsequent passes
                    // through the loop copy the rest of the chars.
                    //
                    if(Out < End) {
                        *Out++ = TEXT('%');
                    }
                }
            }
        } else {
            //
            // Plain char.
            //
            if(Out < End) {
                *Out++ = *In;
            }
            In++;
        }
    }

    *Out = 0;
}


VOID
ParseValueString(
    IN OUT PPARSE_CONTEXT  Context,
    IN OUT PCTSTR         *Location,
    IN     BOOL            ForKey,
    OUT    PDWORD          UnresolvedSubst
    )

/*++

Routine Description:

    Extract a string starting at the current location in the input stream.
    The string starts at the current location, and is terminated by
    comma, newline, comment, or end-of-buffer. If the string is potentially
    a line key, it may also terminate with an =.

    The string may also be continued across multiple lines by using a
    continuation character "\".  The pieces are appended together to form
    a single string that is returned to the caller.  E.g.,

    "this is a "\
    "string used to" \
    " test line continuation"

    becomes:

    "this is a string used to test line continuation"

Arguments:

    Context - supplies parse context.

    Location - on input, supplies a pointer to the current location in the
        input stream. On outut, recevies a pointer to the location in the
        input stream of the character that terminated the string (may be
        a pointer to the end of the buffer, in which case the pointer must
        not be dereferenced!)

    ForKey - indicates whether = is a valid string terminator. If this value
        is FALSE, = is just another character with no special semantics.

    UnresolvedSubst - receives a value indicating whether or not this value
        contained any unresolved string substitutions (and as such, should be
        tracked for user-defined DIRID replacement, etc.).  May be one of the
        following 3 values:

            UNRESOLVED_SUBST_NONE                  (0)
            UNRESOLVED_SUBST_USER_DIRID            (1)
            UNRESOLVED_SUBST_SYSTEM_VOLATILE_DIRID (2)

Return Value:

    None.

--*/

{
    DWORD Count;
    PTCHAR Out;
    BOOL InQuotes;
    BOOL Done;
    PCTSTR location = *Location;
    PCTSTR BufferEnd = Context->BufferEnd;
    TCHAR TempString[MAX_STRING_LENGTH+1];
    PTSTR LastBackslashChar, LastNonWhitespaceChar;

    //
    // Prepare to get the string
    //
    Count = 0;
    Out = TempString;
    Done = FALSE;
    InQuotes = FALSE;
    LastBackslashChar = NULL;
    //
    // Set the last non-whitespace pointer to be the character immediately preceding
    // the output buffer.  We always reference the value of this pointer + 1, so there's
    // no danger of a bad memory reference.
    //
    LastNonWhitespaceChar = Out - 1;

    //
    // The first string can terminate with an =
    // as well as the usual comma, newline, comment, or end-of-input.
    //
    while(!Done && (location < BufferEnd)) {

        switch(*location) {

        case TEXT('\r'):
            //
            // Ignore these.
            //
            location++;
            break;

        case TEXT('\\'):
            //
            // If we're not inside quotes, this could be a continuation character.
            //
            if(!InQuotes) {
                LastBackslashChar = Out;
            }

            //
            // We always store this character, we just may have to remove it later if
            // it turns out to be the continuation character.
            //
            goto store;

        case TEXT('\"'):

            location++;

            if(InQuotes) {

                if((location < BufferEnd) && *location == TEXT('\"')) {
                    goto store;
                } else {
                    InQuotes = FALSE;
                }
            } else {
                InQuotes = TRUE;
            }
            break;

        case TEXT(','):

            if(InQuotes) {
                goto store;
            } else {
                Done = TRUE;
                break;
            }

        case TEXT(';'):

            if(InQuotes) {
                goto store;
            }
            //
            // This character terminates the value, so let fall through to processing
            // of end-of-line.  (We treat ';' and '\n' differently than ',' because the
            // former chars can possibly require a line continuation.)
            //

        case TEXT('\n'):
            //
            // OK, we've hit the end of the data on the line.  If we found a backslash
            // character, and its value is greater than that of the last non-whitespace
            // character we encountered, then that means that we need to continue this
            // value on the next line.
            //
            if(LastBackslashChar && (LastBackslashChar > LastNonWhitespaceChar)) {
                //
                // Trim any trailing whitespace from our current string (this includes
                // getting rid of the backslash character itself).
                //
                Out = LastNonWhitespaceChar + 1;

                //
                // Skip to the beginning of the next line.
                //
                SkipLine(Context, &location);

                //
                // Skip any preceding whitespace on this new line.
                //
                SkipWhitespace(&location, BufferEnd);

                //
                // Clear the last-backslash pointer--we're on a new line now.
                //
                LastBackslashChar = NULL;

                break;
            }

            Done = TRUE;
            break;

        case TEXT('='):

            if(InQuotes) {
                goto store;
            }

            if(ForKey) {
                //
                // We've got a key.
                //
                Done = TRUE;
                break;
            }

            //
            // Else just fall through for default handling.
            //

        default:
        store:

            //
            // Strings longer then the maximum length are silently truncated.
            // NULL characters are converted to spaces.
            //
            if(Count < CSTRLEN(TempString)) {
                *Out = *location ? *location : TEXT(' ');

                if(InQuotes || ((*Out != TEXT('\\')) && !IsWhitespace(Out))) {
                    //
                    // Update our pointer that keeps track of the last non-whitespace
                    // character we've encountered.
                    //
                    LastNonWhitespaceChar = Out;
                }

                Out++;
                Count++;
            }
            location++;
            break;
        }
    }

    //
    // Terminate the string in the buffer after the last non-whitespace character encountered.
    //
    *(LastNonWhitespaceChar + 1) = TEXT('\0');

    //
    // Store the new current buffer location in the caller's variable.
    //
    *Location = location;

    //
    // Substitute localized strings from the strings section.
    // The strings section (if it exists) is always first
    // (see PreprocessInf()).
    //
    // (tedm) Ignore whether or not the value was in quotes.
    // Win95 infs do stuff like "%Description%\foo" and expect the
    // substitution to work.
    //
    // (lonnym) We have to do this regardless of whether the INF has
    // a [strings] section, since this routine tells us whether we have
    // unresolved substitutions (e.g., for later replacement by user-defined
    // DIRIDs).
    //
    if((Context->Inf->SectionCount > 1) || !(Context->Inf->HasStrings)) {
        ProcessForSubstitutions(Context, TempString, UnresolvedSubst);
    } else {
        //
        // Don't process values in the [strings] section for substitution!
        //
        lstrcpy(Context->TemporaryString, TempString);
        *UnresolvedSubst = UNRESOLVED_SUBST_NONE;
    }
}


DWORD
ParseValuesLine(
    IN OUT PPARSE_CONTEXT  Context,
    IN OUT PCTSTR         *Location
    )

/*++

Routine Description:

    Parse a line of input that is not a section name and not a line
    with only a comment on it.

    Such lines are in the format

    [<key> = ] <value>,<value>,<value>,...

    The key is optional. Unquoted whitespace between non-whitespace characters
    within a value is significant and considered part of the value.

    Thus

        a,  b cd  ef ,ghi

    is the 3 values "a" "b cd  ef" and "ghi"

    Unquoted commas separate values. Two double quotes in a row within a quoted
    string result in a single double quote character in the resulting string.

    A logical line may be extended across several physical lines by use of the line
    continuation character "\".  E.g.,

        a = b, c, \
        d, e

        becomes "a = b, c, d, e"

    If it is desired to have a string that ends with a backslash at the end of a line,
    the string must be enclosed in quotes. E.g.,

        a = "C:\"

Arguments:

    Context - supplies the parse context

    Location - on input, supplies the current location in the input stream.
        This must point to the left bracket.
        On output, receives the location in the input stream of the first
        character on the next line. This may be the end of input marker.

Return Value:

    Result indicating outcome.

--*/

{
    BOOL HaveKey = FALSE, RepeatSingleVal = FALSE;
    BOOL Done;
    DWORD Size;
    PVOID p;
    LONG StringId;
    PCTSTR BufferEnd = Context->BufferEnd;
    PWORD pValueCount;
    DWORD UnresolvedSubst;
    BOOL CaseSensitive;

    //
    // Parse out the first string.
    // The first string can terminate with an = or whitespace
    // as well as the usual comma, newline, comment, or end-of-buffer
    // (or line continuation character "\").
    //
    ParseValueString(Context, Location, TRUE, &UnresolvedSubst);

    //
    // If it terminated with an = then it's a key.
    //
    if(*Location < BufferEnd) {
        HaveKey = (**Location == TEXT('='));
    }

    //
    // Set up the current line
    //
    MYASSERT(Context->Inf->SectionCount);
    Context->Inf->SectionBlock[Context->Inf->SectionCount-1].LineCount++;

    if(Context->LineBlockUseCount == Context->LineBlockSize) {

        Size = (Context->LineBlockSize + LINE_BLOCK_GROWTH) * sizeof(INF_LINE);

        p = MyRealloc(Context->Inf->LineBlock,Size);
        if(p) {
            Context->Inf->LineBlock = p;
            Context->LineBlockSize += LINE_BLOCK_GROWTH;
        } else {
            return(ERROR_NOT_ENOUGH_MEMORY);
        }
    }

    Context->Inf->LineBlock[Context->LineBlockUseCount].Values = Context->ValueBlockUseCount;
    *(pValueCount = &(Context->Inf->LineBlock[Context->LineBlockUseCount].ValueCount)) = 0;
    Context->Inf->LineBlock[Context->LineBlockUseCount].Flags = HaveKey
                                                                ? (INF_LINE_HASKEY | INF_LINE_SEARCHABLE)
                                                                : 0;

    for(Done=FALSE; !Done; ) {
        //
        // Save away the value in the value block. If it's a key, then
        // store it twice--once case-insensitively for lookup, and a second
        // time case-sensitively for display.  Store everything else
        // case-sensitively.
        //
        // We also want to treat a single value with no key as if it were a key (i.e., store
        // it twice).  This is for Win95 compatibility.
        //
        do {

            do {
                //
                // To keep from having to allocate a buffer for the case-insensitive key addition (which
                // must be value 0), we do the case-sensitive addition first, then insert the case-
                // insensitive version in front of it on the second pass of this inner loop.
                //
                CaseSensitive = ((*pValueCount != 1) || !HaveKey);
                StringId = pStringTableAddString(Context->Inf->StringTable,
                                                 Context->TemporaryString,
                                                 STRTAB_BUFFER_WRITEABLE | (CaseSensitive ? STRTAB_CASE_SENSITIVE
                                                                                          : STRTAB_CASE_INSENSITIVE),
                                                 NULL,0
                                                );

                if(StringId == -1) {
                    return(ERROR_NOT_ENOUGH_MEMORY);
                }

                if(Context->ValueBlockUseCount == Context->ValueBlockSize) {

                    Size = (Context->ValueBlockSize + VALUE_BLOCK_GROWTH) * sizeof(LONG);

                    p = MyRealloc(Context->Inf->ValueBlock,Size);
                    if(p) {
                        Context->Inf->ValueBlock = p;
                        Context->ValueBlockSize += VALUE_BLOCK_GROWTH;
                    } else {
                        return(ERROR_NOT_ENOUGH_MEMORY);
                    }
                }

                if((*pValueCount == 1) && HaveKey) {
                    //
                    // Shift over the case-sensitive version, and insert the case-insensitive one.
                    //
                    Context->Inf->ValueBlock[Context->ValueBlockUseCount] =
                        Context->Inf->ValueBlock[Context->ValueBlockUseCount - 1];

                    Context->Inf->ValueBlock[Context->ValueBlockUseCount - 1] = StringId;

                    if(UnresolvedSubst) {

                        if(!AddUnresolvedSubstToList(Context->Inf,
                                                     Context->ValueBlockUseCount - 1,
                                                     CaseSensitive)) {

                            return ERROR_NOT_ENOUGH_MEMORY;
                        }

                        if(UnresolvedSubst == UNRESOLVED_SUBST_SYSTEM_VOLATILE_DIRID) {
                            Context->Inf->Flags |= LIF_HAS_VOLATILE_DIRIDS;
                        }
                    }

                    //
                    // Reset the 'RepeatSingleVal' flag, in case we were faking the key behavior.
                    //
                    RepeatSingleVal = FALSE;

                } else {
                    Context->Inf->ValueBlock[Context->ValueBlockUseCount] = StringId;

                    if(UnresolvedSubst) {

                        if(!AddUnresolvedSubstToList(Context->Inf,
                                                     Context->ValueBlockUseCount,
                                                     CaseSensitive)) {

                            return ERROR_NOT_ENOUGH_MEMORY;
                        }

                        if(UnresolvedSubst == UNRESOLVED_SUBST_SYSTEM_VOLATILE_DIRID) {
                            Context->Inf->Flags |= LIF_HAS_VOLATILE_DIRIDS;
                        }
                    }
                }

                Context->ValueBlockUseCount++;
                (*pValueCount)++;

            } while(HaveKey && (*pValueCount < 2));

            //
            // Check to see if this was the last value on the line.
            //
            if((*Location == BufferEnd) ||
               (**Location == TEXT('\n')) ||
               (**Location == TEXT(';'))) {

                Done = TRUE;
                //
                // If this was the _only_ value on the line (i.e., no key), then treat this value
                // as a key, and add it in again, case-insensitively.
                //
                if(*pValueCount == 1) {

                    MYASSERT(!HaveKey);

                    HaveKey = TRUE;
                    Context->Inf->LineBlock[Context->LineBlockUseCount].Flags = INF_LINE_SEARCHABLE;
                    RepeatSingleVal = TRUE;
                }
            }

        } while (RepeatSingleVal);

        if(!Done) {
            //
            // Skip terminator and whitespace.
            //
            (*Location)++;
            SkipWhitespace(Location, BufferEnd);

            //
            // Get the next string.
            //
            ParseValueString(Context, Location, FALSE, &UnresolvedSubst);
        }
    }

    Context->LineBlockUseCount++;

    //
    // Skip to next line
    //
    SkipLine(Context,Location);

    return(NO_ERROR);
}


DWORD
ParseSectionLine(
    IN OUT PPARSE_CONTEXT  Context,
    IN OUT PCTSTR         *Location
    )

/*++

Routine Description:

    Parse a line of input that is known to be a section name line.
    Such lines are in the format

    '[' <arbitrary chars> ']'

    All charcters between the brackets are considered part of the section
    name, with no special casing of quotes, whitespace, etc. The remainder
    of the line is ignored.

Arguments:

    Context - supplies the parse context

    Location - on input, supplies the current location in the input stream.
        This must point to the left bracket.
        On output, receives the location in the input stream of the first
        character on the next line. This may be the end of input marker.

Return Value:

    Result indicating outcome.

--*/

{
    DWORD Count;
    PTCHAR Out;
    BOOL Done;
    DWORD Result;
    PVOID p;
    DWORD Size;
    DWORD Index;
    LONG SectionNameId;
    PCTSTR BufferEnd = Context->BufferEnd;

    //
    // Skip the left bracket.
    //
    MYASSERT(**Location == TEXT('['));
    (*Location)++;

    //
    // Prepare for section name
    //
    Out = Context->TemporaryString;
    Count = 0;

    //
    // This is implemeted according to the win95 code in setup\setupx\inf2.c.
    // All characters between the 2 brackets are considered part of the
    // section name with no further processing (like for double quotes, etc).
    //
    // Win95 also seems to allow [] as a section name.
    //

    for(Done=FALSE,Result=NO_ERROR; !Done; (*Location)++) {

        if((*Location == BufferEnd) || (**Location == TEXT('\n'))) {
            //
            // Syntax error
            //
            Result = ERROR_BAD_SECTION_NAME_LINE;
            Done = TRUE;

        } else {

            switch(**Location) {

            case TEXT(']'):
                Done = TRUE;
                *Out = 0;
                break;

            default:
                if(Count < MAX_SECT_NAME_LEN) {
                    //
                    // Convert NULL characters to spaces.
                    //
                    *Out++ = **Location ? **Location : TEXT(' ');
                    Count++;
                } else {
                    Result = ERROR_SECTION_NAME_TOO_LONG;
                    Done = TRUE;
                }
                break;
            }
        }
    }

    Index = Context->Inf->SectionCount;

    if(Result == NO_ERROR) {

        //
        // Ignore the rest of the line
        //
        SkipLine(Context,Location);

        //
        // See if we have enough room in the section block
        // for this section. If not, grow the block.
        //
        if(Index == Context->SectionBlockSize) {

            //
            // Calculate the new section block size.
            //
            Size = (Index + SECTION_BLOCK_GROWTH) * sizeof(INF_SECTION);

            if(p = MyRealloc(Context->Inf->SectionBlock,Size)) {
                Context->SectionBlockSize += SECTION_BLOCK_GROWTH;
                Context->Inf->SectionBlock = p;
            } else {
                Result = ERROR_NOT_ENOUGH_MEMORY;
            }
        }
    }

    if(Result == NO_ERROR) {

        Context->Inf->SectionBlock[Index].LineCount = 0;
        Context->Inf->SectionBlock[Index].Lines = Context->LineBlockUseCount;

        SectionNameId = pStringTableAddString(Context->Inf->StringTable,
                                              Context->TemporaryString,
                                              STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE,
                                              NULL,0
                                             );

        if(SectionNameId == -1) {
            Result = ERROR_NOT_ENOUGH_MEMORY;
        } else {
            Context->Inf->SectionBlock[Index].SectionName = SectionNameId;
            Context->Inf->SectionCount++;
            Context->GotOneSection = TRUE;
        }
    }

    return(Result);
}


DWORD
ParseGenericLine(
    IN OUT PPARSE_CONTEXT  Context,
    IN OUT PCTSTR         *Location,
    OUT    PBOOL           Done
    )

/*++

Routine Description:

    Parse a single line of input. The line may be a comment line, a section name,
    or a values line.

    Handling is passed off to line-specific parsing routines depending on the
    line type.

Arguments:

    Context - supplies the parse context

    Location - on input, supplies the current location in the input stream.
        On output, receives the location in the input stream of the first
        character on the next line.

    Done - receives boolean value indicating whether we are done
        parsing the buffer. If this is TRUE on output the caller can stop
        calling this routine.

Return Value:

    Result indicating outcome.

--*/

{
    DWORD ParseResult;

    *Done = FALSE;

    //
    // Skip over leading whitespace on the line.
    //
    SkipWhitespace(Location, Context->BufferEnd);

    //
    // Further processing depends on the first important character on the line.
    //
    if(*Location == Context->BufferEnd) {
        //
        // End of input, empty line. Terminate current section.
        //
        *Done = TRUE;
        ParseResult = MergeDuplicateSection(Context) ? NO_ERROR : ERROR_NOT_ENOUGH_MEMORY;

    } else {

        switch(**Location) {

        case TEXT('\n'):

            //
            // Empty line.
            //
            SkipLine(Context,Location);
            ParseResult = NO_ERROR;
            break;

        case TEXT('['):

            //
            // Potentially got a new section.
            // First terminate the current section.
            //
            if(MergeDuplicateSection(Context)) {
                ParseResult = ParseSectionLine(Context,Location);
            } else {
                ParseResult = ERROR_NOT_ENOUGH_MEMORY;
            }
            break;

        case TEXT(';'):

            //
            // Comment line; ignore it.
            //
            SkipLine(Context,Location);
            ParseResult = NO_ERROR;
            break;

        default:

            //
            // Ordinary values line. Disallow unless we are within a section.
            //
            ParseResult = Context->GotOneSection
                        ? ParseValuesLine(Context,Location)
                        : ERROR_EXPECTED_SECTION_NAME;
            break;
        }
    }

    return(ParseResult);
}


PLOADED_INF
AllocateLoadedInfDescriptor(
    IN DWORD SectionBlockSize,
    IN DWORD LineBlockSize,
    IN DWORD ValueBlockSize,
    IN  PSETUP_LOG_CONTEXT LogContext OPTIONAL
    )
{
    PLOADED_INF p;

    if(p = MyTaggedMalloc(sizeof(LOADED_INF),MEMTAG_INF)) {

        ZeroMemory(p,sizeof(LOADED_INF));

        if(p->SectionBlock = MyMalloc(SectionBlockSize*sizeof(INF_SECTION))) {

            if(p->LineBlock = MyMalloc(LineBlockSize*sizeof(INF_LINE))) {

                if(p->ValueBlock = MyMalloc(ValueBlockSize*sizeof(LONG))) {

                    if(p->StringTable = pStringTableInitialize(0)) {
                        p->LogContext = NULL;
                        if(InheritLogContext(LogContext, &p->LogContext) == NO_ERROR) {
                            //
                            // success
                            //
                            if(InitializeSynchronizedAccess(&p->Lock)) {

                                p->Signature = LOADED_INF_SIG;
                                p->FileHandle = p->MappingHandle = INVALID_HANDLE_VALUE;
                                return(p);
                            }
                            DeleteLogContext(p->LogContext);
                        }
                        pStringTableDestroy(p->StringTable);
                    }
                    MyFree(p->ValueBlock);
                }
                MyFree(p->LineBlock);
            }
            MyFree(p->SectionBlock);
        }
        MyTaggedFree(p,MEMTAG_INF);
    }

    return(NULL);
}


PLOADED_INF
DuplicateLoadedInfDescriptor(
    IN PLOADED_INF Inf
    )
/*++

Routine Description:

    This routine duplicates an existing INF descriptor.  The duplicate returned
    is a totally independent copy, except that it has the lock handles (MYLOCK
    array) and Prev and Next pointers of the original.  This is useful for
    transferring a memory-mapped PNF into read-write memory if modification is
    required.

    THIS ROUTINE DOESN'T DO LOCKING OF ANY FORM ON THE INF--THE CALLER MUST
    HANDLE IT.

Arguments:

    Inf - supplies the address of the INF descriptor to be duplicated.  This
        pointer refers to a single LOADED_INF structure, so any additional INFs
        linked up via the 'Next' pointer are ignored.

Return Value:

    If successful, the return value is the address of the newly-created duplicate.
    If out-of-memory or inpage error, the return value is NULL.

--*/
{
    PLOADED_INF NewInf;
    BOOL Success;

    if(NewInf = MyTaggedMalloc(sizeof(LOADED_INF),MEMTAG_INF)) {
        CopyMemory(NewInf, Inf, sizeof(LOADED_INF));
        NewInf->Signature = 0;
        NewInf->SectionBlock = NULL;
        NewInf->LineBlock = NULL;
        NewInf->ValueBlock = NULL;
        NewInf->StringTable = NULL;
        NewInf->VersionBlock.DataBlock = NULL;
        NewInf->UserDirIdList.UserDirIds = NULL;
        NewInf->SubstValueList = NULL;
        NewInf->OsLoaderPath = NULL;
        NewInf->InfSourcePath = NULL;
        NewInf->OriginalInfName = NULL;
    } else {
        return NULL;
    }

    Success = FALSE;

    try {

        NewInf->SectionBlock = MyMalloc(Inf->SectionBlockSizeBytes);
        if(NewInf->SectionBlock) {

            CopyMemory(NewInf->SectionBlock, Inf->SectionBlock, Inf->SectionBlockSizeBytes);

            NewInf->LineBlock = MyMalloc(Inf->LineBlockSizeBytes);
            if(NewInf->LineBlock) {

                CopyMemory(NewInf->LineBlock, Inf->LineBlock, Inf->LineBlockSizeBytes);

                NewInf->ValueBlock = MyMalloc(Inf->ValueBlockSizeBytes);
                if(NewInf->ValueBlock) {

                    CopyMemory(NewInf->ValueBlock, Inf->ValueBlock, Inf->ValueBlockSizeBytes);

                    NewInf->StringTable = pStringTableDuplicate(Inf->StringTable);
                    if(NewInf->StringTable) {

                        NewInf->VersionBlock.DataBlock = MyTaggedMalloc(Inf->VersionBlock.DataSize,MEMTAG_VBDATA);
                        if(NewInf->VersionBlock.DataBlock) {

                            CopyMemory((PVOID)(NewInf->VersionBlock.DataBlock),
                                       Inf->VersionBlock.DataBlock,
                                       Inf->VersionBlock.DataSize
                                      );

                            if(Inf->SubstValueCount) {
                                NewInf->SubstValueList =
                                    MyMalloc(Inf->SubstValueCount * sizeof(STRINGSUBST_NODE));
                                if(!(NewInf->SubstValueList)) {
                                    goto clean0;
                                }
                                CopyMemory((PVOID)NewInf->SubstValueList,
                                           Inf->SubstValueList,
                                           Inf->SubstValueCount * sizeof(STRINGSUBST_NODE)
                                          );
                            }

                            if(Inf->UserDirIdList.UserDirIdCount) {
                                NewInf->UserDirIdList.UserDirIds =
                                    MyMalloc(Inf->UserDirIdList.UserDirIdCount * sizeof(USERDIRID));
                                if(!(NewInf->UserDirIdList.UserDirIds)) {
                                    goto clean0;
                                }
                                CopyMemory((PVOID)NewInf->UserDirIdList.UserDirIds,
                                           Inf->UserDirIdList.UserDirIds,
                                           Inf->UserDirIdList.UserDirIdCount * sizeof(USERDIRID)
                                          );
                            }

                            if(Inf->OsLoaderPath) {

                                NewInf->OsLoaderPath = DuplicateString(Inf->OsLoaderPath);

                                if(!NewInf->OsLoaderPath) {
                                    goto clean0;
                                }
                            }

                            if(Inf->InfSourcePath) {

                                NewInf->InfSourcePath = DuplicateString(Inf->InfSourcePath);

                                if(!NewInf->InfSourcePath) {
                                    goto clean0;
                                }
                            }

                            if(Inf->OriginalInfName) {

                                NewInf->OriginalInfName = DuplicateString(Inf->OriginalInfName);

                                if(!NewInf->OriginalInfName) {
                                    goto clean0;
                                }
                            }

                            //
                            // Reset the PNF fields because this backed-up INF is completely
                            // in-memory.
                            //
                            NewInf->FileHandle = NewInf->MappingHandle = INVALID_HANDLE_VALUE;
                            NewInf->ViewAddress = NULL;

                            NewInf->Signature = LOADED_INF_SIG;

                            Success = TRUE;
                        }
                    }
                }
            }
        }

clean0: ; // nothing to do

    } except(EXCEPTION_EXECUTE_HANDLER) {
        //
        // Access the following variables here in the except clause, so that the compiler will respect
        // our statement ordering w.r.t. these variables.
        //
        Success = FALSE;
        NewInf->OriginalInfName = NewInf->OriginalInfName;
        NewInf->InfSourcePath = NewInf->InfSourcePath;
        NewInf->OsLoaderPath = NewInf->OsLoaderPath;
        NewInf->SubstValueList = NewInf->SubstValueList;
        NewInf->UserDirIdList.UserDirIds = NewInf->UserDirIdList.UserDirIds;
        NewInf->VersionBlock.DataBlock = NewInf->VersionBlock.DataBlock;
        NewInf->StringTable = NewInf->StringTable;
        NewInf->ValueBlock = NewInf->ValueBlock;
        NewInf->LineBlock = NewInf->LineBlock;
        NewInf->SectionBlock = NewInf->SectionBlock;
    }

    if(!Success) {
        //
        // Either we ran out of memory, or we got an inpage error trying to copy data
        // from a memory-mapped PNF image.  Free any memory we allocated above.
        //
        if(NewInf->OriginalInfName) {
            MyFree(NewInf->OriginalInfName);
        }

        if(NewInf->InfSourcePath) {
            MyFree(NewInf->InfSourcePath);
        }

        if(NewInf->OsLoaderPath) {
            MyFree(NewInf->OsLoaderPath);
        }

        if(NewInf->SubstValueList) {
            MyFree(NewInf->SubstValueList);
        }

        if(NewInf->UserDirIdList.UserDirIds) {
            MyFree(NewInf->UserDirIdList.UserDirIds);
        }

        if(NewInf->VersionBlock.DataBlock) {
            MyTaggedFree(NewInf->VersionBlock.DataBlock,MEMTAG_VBDATA);
        }

        if(NewInf->StringTable) {
            pStringTableDestroy(NewInf->StringTable);
        }

        if(NewInf->ValueBlock) {
            MyFree(NewInf->ValueBlock);
        }

        if(NewInf->LineBlock) {
            MyFree(NewInf->LineBlock);
        }

        if(NewInf->SectionBlock) {
            MyFree(NewInf->SectionBlock);
        }

        MyTaggedFree(NewInf,MEMTAG_INF);
        NewInf = NULL;
    } else {
        //
        // The copy was successful, but it made a copy of the pointer to the
        // log context, so we must addref if
        //
        RefLogContext(NewInf->LogContext);
    }

    return NewInf;
}


VOID
ReplaceLoadedInfDescriptor(
    IN PLOADED_INF InfToReplace,
    IN PLOADED_INF NewInf
    )

/*++

Routine Description:

    Replace the specified INF with a new INF descriptor.
    Note that this routine also frees the NewInf descriptor, when done.

Arguments:

    InfToReplace - supplies a pointer to the inf descriptor to be replaced.

    NewInf - supplies a pointer to the new INF descriptor that is to replace
        the existing one.

Return Value:

    None.

--*/

{
    FreeInfOrPnfStructures(InfToReplace);

    //
    // Copy backup to inf
    //
    CopyMemory(InfToReplace, NewInf, sizeof(LOADED_INF));

    //
    // Just free the NewInf descriptor itself.
    //
    MyTaggedFree(NewInf,MEMTAG_INF);
}


VOID
FreeInfOrPnfStructures(
    IN PLOADED_INF Inf
    )
/*++

Routine Description:

    If the specified INF was loaded from a textfile (non-PNF), then this routine
    frees the memory associated with the various blocks it contains.  If, instead,
    the Inf is a PNF, then the PNF file is unmapped from memory and the handle is
    closed.

    THIS ROUTINE DOES NOT FREE THE LOADED_INF STRUCTURE ITSELF!

Arguments:

    Inf - supplies a pointer to the inf descriptor for the loaded inf file.

Return Value:

    None.

--*/
{
    //
    // If this INF has a vald FileHandle, then we must unmap and close its PNF,
    // otherwise, we simply need to free the associated memory blocks.
    //
    if(Inf->FileHandle != INVALID_HANDLE_VALUE) {

        pSetupUnmapAndCloseFile(Inf->FileHandle, Inf->MappingHandle, Inf->ViewAddress);

        pStringTableDestroy(Inf->StringTable);

    } else {

        MyFree(Inf->ValueBlock);
        MyFree(Inf->LineBlock);
        MyFree(Inf->SectionBlock);

        pStringTableDestroy(Inf->StringTable);

        if(Inf->VersionBlock.DataBlock) {
            MyTaggedFree(Inf->VersionBlock.DataBlock,MEMTAG_VBDATA);
        }

        if(Inf->SubstValueList) {
            MyFree(Inf->SubstValueList);
            Inf->SubstValueList = NULL;
        }

        if(Inf->OsLoaderPath) {
            MyFree(Inf->OsLoaderPath);
        }

        if(Inf->InfSourcePath) {
            MyFree(Inf->InfSourcePath);
        }

        if(Inf->OriginalInfName) {
            MyFree(Inf->OriginalInfName);
        }
    }

    //
    // For both INFs and PNFs, we must free the user-defined DIRID list (if there is one).
    //
    if(Inf->UserDirIdList.UserDirIds) {
        MyFree(Inf->UserDirIdList.UserDirIds);
    }

    //
    // Delete the log context if there is one
    //
    DeleteLogContext(Inf->LogContext);
    Inf->LogContext = NULL;

    //
    // Finally, mark the INF as no longer valid.
    //
    Inf->Signature = 0;
}


DWORD
ParseNewInf(
    IN  PCTSTR             FileImage,
    IN  DWORD              FileImageSize,
    IN  PCTSTR             InfSourcePath,       OPTIONAL
    IN  PCTSTR             OsLoaderPath,        OPTIONAL
    IN  PSETUP_LOG_CONTEXT LogContext,          OPTIONAL
    OUT PLOADED_INF       *Inf,
    OUT UINT              *ErrorLineNumber,
    IN  PSTRINGSEC_PARAMS  StringsSectionParams
    )

/*++

Routine Description:

    Parse an inf file from an in-memory image.

Arguments:

    FileImage - supplies a pointer to the unicode in-memory image
        of the file.

    FileImageSize - supplies the size of the in memory image.

    InfSourcePath - optionally, supplies the directory path from which
        the Inf is being loaded.

    OsLoaderPath - optionally, supplies the full path to the OsLoader
        (e.g., "C:\os\winnt40").  If it is discovered that this INF
        references system partition DIRIDs, then a copy of this string
        will be stored in the LOADED_INF structure.  If this parameter
        is not specified, then it will be retrieved from the registry,
        if needed.

    LogContext - optionally supplies the log context we should inherit from

    Inf - receives a pointer to the descriptor for the inf we loaded.

    ErrorLineNumber - receives the line number of a syntax error,
        if parsing was not successful for other than an out of memory
        condition.

    StringsSectionParams - Supplies information about the location of a
        [strings] section (if there is one) in this INF.

Return Value:

    Result indicating outcome. If the result is not ERROR_ERROR,
    ErrorLineNumber is filled in.

--*/

{
    PPARSE_CONTEXT ParseContext;
    PCTSTR Location;
    DWORD Result, OsLoaderPathLength;
    PVOID p;
    BOOL Done;
    PINF_SECTION DestDirsSection;
    PINF_LINE DestDirsLine;
    PCTSTR DirId;
    PTCHAR End;
    PCTSTR FileImageEnd;
    UINT NumPieces, i, DirIdInt;
    PCTSTR PieceList[3][2];    // 3 pieces, each with a start & end address
    UINT   StartLineNumber[3]; // keep track of the starting line number for
                               // each piece.

    *ErrorLineNumber = 0;
    ParseContext = MyMalloc(sizeof(PARSE_CONTEXT));
    if(!ParseContext) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    ZeroMemory(ParseContext,sizeof(PARSE_CONTEXT));

    ParseContext->Inf = AllocateLoadedInfDescriptor(
                            INITIAL_SECTION_BLOCK_SIZE,
                            INITIAL_LINE_BLOCK_SIZE,
                            INITIAL_VALUE_BLOCK_SIZE,
                            LogContext
                            );

    if(ParseContext->Inf) {
        ParseContext->SectionBlockSize = INITIAL_SECTION_BLOCK_SIZE;
        ParseContext->LineBlockSize = INITIAL_LINE_BLOCK_SIZE;
        ParseContext->ValueBlockSize = INITIAL_VALUE_BLOCK_SIZE;
        ParseContext->Inf->HasStrings = (StringsSectionParams->Start != NULL);
        ParseContext->InfSourcePath = InfSourcePath;
        if(OsLoaderPath) {
            if(!(ParseContext->OsLoaderPath = DuplicateString(OsLoaderPath))) {
                FreeLoadedInfDescriptor(ParseContext->Inf);
                ParseContext->Inf = NULL;
            }
        }
    }

    if(ParseContext->Inf) {

        ParseContext->Inf->Style = INF_STYLE_WIN4;

        //
        // We want to process the [strings] section first, if present,
        // so we split the file up into (up to) 3 pieces--string section,
        // what comes before it, and what comes after it.
        //
        FileImageEnd = FileImage + FileImageSize;

        if(StringsSectionParams->Start) {
            //
            // Figure out whether we have 1, 2, or 3 pieces.
            //
            PieceList[0][0] = StringsSectionParams->Start;
            PieceList[0][1] = StringsSectionParams->End;
            StartLineNumber[0] = StringsSectionParams->StartLineNumber;
            NumPieces = 1;

            if(StringsSectionParams->Start > FileImage) {
                PieceList[1][0] = FileImage;
                PieceList[1][1] = StringsSectionParams->Start;
                StartLineNumber[1] = 1;
                NumPieces++;
            }

            if(StringsSectionParams->End < FileImageEnd) {
                PieceList[NumPieces][0] = StringsSectionParams->End;
                PieceList[NumPieces][1] = FileImageEnd;
                StartLineNumber[NumPieces] = StringsSectionParams->EndLineNumber;
                NumPieces++;
            }

        } else {
            //
            // No [strings] section, just one big piece.
            //
            PieceList[0][0] = FileImage;
            PieceList[0][1] = FileImageEnd;
            StartLineNumber[0] = 1;
            NumPieces = 1;
        }

        //
        // Surround the parsing loop with try/except in case we get an inpage error.
        //
        Result = NO_ERROR;
        try {

            for(i = 0; ((Result == NO_ERROR) && (i < NumPieces)); i++) {
                //
                // Parse every line in this piece.
                //
                Location = PieceList[i][0];
                ParseContext->BufferEnd = PieceList[i][1];
                ParseContext->CurrentLineNumber = StartLineNumber[i];

                do {
                    Result = ParseGenericLine(ParseContext,&Location,&Done);
                    if(Result != NO_ERROR) {
                        break;
                    }
                } while(!Done);
            }

        } except(EXCEPTION_EXECUTE_HANDLER) {
            Result = ERROR_READ_FAULT;
        }

        if(Result != NO_ERROR) {
            *ErrorLineNumber = ParseContext->CurrentLineNumber;
            FreeLoadedInfDescriptor(ParseContext->Inf);
            MyFree(ParseContext);
            return(Result);
        }

        //
        // We've successfully loaded the file. Trim down the section,
        // line, and value blocks. Since these guys are shrinking or
        // staying the same size the reallocs really ought not to fail.
        // If a realloc fails we'll just continue to use the original block.
        //
        ParseContext->Inf->SectionBlockSizeBytes = ParseContext->Inf->SectionCount * sizeof(INF_SECTION);
        p = MyRealloc(
                ParseContext->Inf->SectionBlock,
                ParseContext->Inf->SectionBlockSizeBytes
                );
        if(p) {
            ParseContext->Inf->SectionBlock = p;
        }

        ParseContext->Inf->LineBlockSizeBytes = ParseContext->LineBlockUseCount * sizeof(INF_LINE);
        p = MyRealloc(
                ParseContext->Inf->LineBlock,
                ParseContext->LineBlockUseCount * sizeof(INF_LINE)
                );
        if(p) {
            ParseContext->Inf->LineBlock = p;
        }

        ParseContext->Inf->ValueBlockSizeBytes = ParseContext->ValueBlockUseCount * sizeof(LONG);
        p = MyRealloc(
                ParseContext->Inf->ValueBlock,
                ParseContext->ValueBlockUseCount * sizeof(LONG)
                );
        if(p) {
            ParseContext->Inf->ValueBlock = p;
        }

        pStringTableTrim(ParseContext->Inf->StringTable);

        //
        // Even if we didn't find any string substitutions referencing system partition DIRIDs,
        // we still might have a reference in a [DestinationDirs] section--check for that now.
        // this will allow us to have these values ready for if/when they are referenced
        //
        if(!ParseContext->Inf->OsLoaderPath &&
           (DestDirsSection = InfLocateSection(ParseContext->Inf, pszDestinationDirs, NULL))) {

            for(i = 0;
                InfLocateLine(ParseContext->Inf, DestDirsSection, NULL, &i, &DestDirsLine);
                i++) {

                if(DirId = InfGetField(ParseContext->Inf, DestDirsLine, 1, NULL)) {

                    DirIdInt = _tcstoul(DirId, &End, 10);

                    if((DirIdInt == DIRID_BOOT) || (DirIdInt == DIRID_LOADER)) {
                        //
                        // We've found a reference to a system partition DIRID.  Store a copy
                        // of the system partition path we're using into the INF, and abort the
                        // search.
                        //
                        if(!ParseContext->OsLoaderPath) {
                            //
                            // We haven't yet retrieved the OsLoaderPath--do so now.
                            // (Re-use the parse context's TemporaryString buffer to get this.)
                            //
                            Result = pSetupGetOsLoaderDriveAndPath(FALSE,
                                                                   ParseContext->TemporaryString,
                                                                   SIZECHARS(ParseContext->TemporaryString),
                                                                   &OsLoaderPathLength
                                                                   );
                            if(Result) {
                                FreeLoadedInfDescriptor(ParseContext->Inf);
                                MyFree(ParseContext);
                                return Result;
                            }

                            OsLoaderPathLength *= sizeof(TCHAR); // want # bytes--not chars

                            if(!(ParseContext->OsLoaderPath = MyMalloc(OsLoaderPathLength))) {
                                FreeLoadedInfDescriptor(ParseContext->Inf);
                                MyFree(ParseContext);
                                return ERROR_NOT_ENOUGH_MEMORY;
                            }

                            CopyMemory((PVOID)ParseContext->OsLoaderPath,
                                       ParseContext->TemporaryString,
                                       OsLoaderPathLength
                                      );
                        }
                        ParseContext->Inf->OsLoaderPath = ParseContext->OsLoaderPath;
                        break;
                    }
                }
            }
        }

        //
        // If there is no OsLoaderPath stored in the INF, then that means that it contains no
        // references to system partition DIRIDs.  We can free the OsLoaderPath character buffer
        // contained in the parse context structure.
        //
        if(!ParseContext->Inf->OsLoaderPath && ParseContext->OsLoaderPath) {
            MyFree(ParseContext->OsLoaderPath);
        }

        *Inf = ParseContext->Inf;

        MyFree(ParseContext);
        return(NO_ERROR);
    }

    MyFree(ParseContext);
    return(ERROR_NOT_ENOUGH_MEMORY);
}


DWORD
PreprocessInf(
    IN     PCTSTR            FileImage,
    IN OUT PDWORD            FileImageSize,
    IN     BOOL              MatchClassGuid,
    IN     PCTSTR            ClassGuidString,     OPTIONAL
    IN     DWORD             LanguageId,          OPTIONAL
    IN     PSETUP_LOG_CONTEXT LogContext,         OPTIONAL
    IN     PCTSTR            FileName,            OPTIONAL
    OUT    PBOOL             Win95Inf,
    OUT    PSTRINGSEC_PARAMS StringsSectionParams OPTIONAL
    )
{
    PCTSTR FileImageEnd;
    PCTSTR VerAndStringsCheckUB, DecoratedStringsCheckUB, SigAndClassGuidCheckUB;
    PCTSTR p;
    PTSTR endp;
    UINT CurLineNumber, InStringsSection;
    PCTSTR StrSecStart[5], StrSecEnd[5];          // 1-based, 0th entry unused.
    UINT   StrSecStartLine[5], StrSecEndLine[5];  // ""
    BOOL InVersionSection;
    BOOL IsWin95Inf;
    DWORD rc = NO_ERROR;
    DWORD StrSecLangId, PrimaryLanguageId, NearLanguageId;
    BOOL LocalizedInf = FALSE;

    //
    // We make some assumptions about the relative lengths of certain
    // strings during the preprocessing phase for optimization reasons.
    // The following asserts verify that our assumptions remain correct.
    //
    MYASSERT(CSTRLEN(pszVersion) == CSTRLEN(pszStrings));
    MYASSERT(CSTRLEN(pszClassGuid) == CSTRLEN(pszSignature));
    MYASSERT(CSTRLEN(pszChicagoSig) <= CSTRLEN(pszWindowsNTSig));
    MYASSERT(CSTRLEN(pszWindowsNTSig) == CSTRLEN(pszWindows95Sig));

    FileImageEnd = FileImage + *FileImageSize;
    SigAndClassGuidCheckUB = FileImageEnd;

    //
    // I have to cast these two arrays to silence a bogus compiler warning about
    // different 'const' qualifiers.
    //
    ZeroMemory((PVOID)StrSecStart, sizeof(StrSecStart));
    ZeroMemory((PVOID)StrSecEnd, sizeof(StrSecEnd));
    InStringsSection = 0;

    PrimaryLanguageId = (DWORD)PRIMARYLANGID(LanguageId);
    NearLanguageId = 0;

    InVersionSection = IsWin95Inf = FALSE;
    CurLineNumber = 1;

    //
    // Pre-compute upper-bound for section name string comparison that we
    // make multiple times, so that we don't have to compute it each
    // time.
    //
    VerAndStringsCheckUB = FileImageEnd - CSTRLEN(pszVersion);
    DecoratedStringsCheckUB = VerAndStringsCheckUB - 5;         // "strings" + ".xxxx"

    //
    // Define a macro that lets us know we're at the end of the file
    // if either:
    // (a) we reach the end of the image, or
    // (b) we hit a CTL-Z
    //
    #define AT_EOF ((p >= FileImageEnd) || (*p == (TCHAR)26))

    //
    // Guard the pre-processing pass through the file with a try/except, in
    // case we get an inpage error.
    //
    try {

        for(p=FileImage; !AT_EOF; ) {

            //
            // Skip whitespace and newlines.
            //
            while(TRUE) {
                if(*p == TEXT('\n')) {
                    CurLineNumber++;
                } else if(!IsWhitespace(p)) {
                    break;
                }
                p++;
                if(AT_EOF) {
                    break;
                }
            }

            if(AT_EOF) {
                //
                // We're through processing the buffer.
                //
                break;
            }

            //
            // See if it's a section title.
            //
            if(*p == TEXT('[')) {

                //
                // If the section we were just in was a [Strings] section, then
                // remember where the strings section ended.
                //
                if(InStringsSection) {
                    StrSecEnd[InStringsSection] = p;
                    StrSecEndLine[InStringsSection] = CurLineNumber;
                    InStringsSection = 0;
                }

                p++;
                InVersionSection = FALSE;

                //
                // See if it's one of the ones we care about.
                //
                // (Be careful here--we check the closing bracket position
                // _before_ the string compare as an optimization.  It just
                // so happens that both strings are the same length, so this
                // acts as a quick filter to eliminate string compares.)
                //
                if((p < VerAndStringsCheckUB) &&
                   (*(p + CSTRLEN(pszVersion)) == TEXT(']'))) {
                    //
                    // Then we may have either a [Version] or a [Strings] section.
                    // Check for these in turn.
                    //
                    if(!_tcsnicmp(p, pszVersion, CSTRLEN(pszVersion))) {
                        InVersionSection = TRUE;
                        p += (CSTRLEN(pszVersion) + 1);
                        //
                        // Pre-compute an upper bound to speed up string comparisons
                        // when checking for signature and class GUID entries.
                        //
                        SigAndClassGuidCheckUB = FileImageEnd - CSTRLEN(pszSignature);

                    } else {
                        if(!StrSecStart[4] && !_tcsnicmp(p, pszStrings, CSTRLEN(pszStrings))) {
                            //
                            // We matched on the undecorated string section--this is the lowest
                            // priority match.
                            //
                            InStringsSection = 4;
                            StrSecStart[4] = p-1;
                            StrSecStartLine[4] = CurLineNumber;
                            p += (CSTRLEN(pszStrings) + 1);
                        }
                    }

                } else if(LanguageId && !StrSecStart[1]) {
                    //
                    // We don't have a [strings] nor a [version] section.  However, we need to
                    // check to see if we have a language-specific strings section, for example,
                    //
                    //     [strings.0409]
                    //
                    if((p < DecoratedStringsCheckUB) &&
                       (*(p + CSTRLEN(pszVersion) + 5) == TEXT(']'))) {
                        //
                        // The section name is of the right length.  Now verify that the name
                        // begins with "strings."
                        //
                        if((*(p + CSTRLEN(pszVersion)) == TEXT('.')) &&
                           !_tcsnicmp(p, pszStrings, CSTRLEN(pszStrings))) {
                            //
                            // OK, we've found a language-specific strings section--retrieve
                            // the 4-digit (hex) language ID.
                            //
                            StrSecLangId = _tcstoul((p + CSTRLEN(pszVersion) + 1), &endp, 16);

                            if(endp == (p + CSTRLEN(pszVersion) + 5)) {
                                //
                                // The language ID was of the proper form - this
                                // is a localized INF
                                //
                                LocalizedInf = TRUE;
                                //
                                // now see if it matches the language we're
                                // supposed to be using when loading this INF.
                                //
                                if(StrSecLangId == LanguageId) {
                                    //
                                    // we have an exact match
                                    //
                                    InStringsSection = 1;
                                    NearLanguageId = LanguageId;

                                } else if(StrSecLangId == PrimaryLanguageId) {
                                    //
                                    // we have a match on primary language (sublanguage is not
                                    // included in the strings section's name--thus permitting
                                    // a 'wildcard' match).
                                    //
                                    if(!StrSecStart[2]) {
                                        InStringsSection = 2;
                                    }
                                    if(!StrSecStart[1]) {
                                        NearLanguageId = PrimaryLanguageId;
                                    }

                                } else if((DWORD)PRIMARYLANGID(StrSecLangId) == PrimaryLanguageId) {
                                    //
                                    // we have a match on primary language (sublanguage is a
                                    // mismatch, but it's better than falling back to the default).
                                    //
                                    if(!StrSecStart[3]) {
                                        InStringsSection = 3;
                                        if(!StrSecStart[1] && !StrSecStart[2]) {
                                            NearLanguageId = StrSecLangId;
                                        }
                                    }
                                }

                                if(InStringsSection) {
                                    StrSecStart[InStringsSection] = p-1;
                                    StrSecStartLine[InStringsSection] = CurLineNumber;
                                }
                                p += (CSTRLEN(pszStrings) + 6);
                            }
                        }
                    }
                }

            } else {

                if(InVersionSection && (p < SigAndClassGuidCheckUB)) {
                    //
                    // See if this is the signature line indicating a Win95-style
                    // Device INF. (signature=$Chicago$ or "$Windows NT$")
                    //
                    if(!IsWin95Inf && !_tcsnicmp(p, pszSignature, CSTRLEN(pszSignature))) {

                        PCTSTR ChicagoCheckUB = FileImageEnd - CSTRLEN(pszChicagoSig);

                        //
                        // Skip over Signature, and look for "$Chicago$" or
                        // "$Windows NT$" anywhere on the rest of the line
                        //
                        p += CSTRLEN(pszSignature);

                        while((p <= ChicagoCheckUB) &&
                              (*p != (TCHAR)26) && (*p != TEXT('\n'))) {

                            if(*(p++) == TEXT('$')) {
                                //
                                // Check for signatures (check in order of
                                // increasing signature length, so that we can
                                // eliminate checks if we happen to be near the
                                // end of the file).
                                //
                                // Check for "$Chicago$"
                                //
                                if(!_tcsnicmp(p,
                                              pszChicagoSig + 1,
                                              CSTRLEN(pszChicagoSig) - 1)) {

                                    IsWin95Inf = TRUE;
                                    p += (CSTRLEN(pszChicagoSig) - 1);

                                } else if((p + (CSTRLEN(pszWindowsNTSig) - 1)) <= FileImageEnd) {
                                    //
                                    // Check for "Windows NT$" and "Windows 95$" (we already checked
                                    // for the preceding '$').
                                    //
                                    if(!_tcsnicmp(p, pszWindowsNTSig + 1, CSTRLEN(pszWindowsNTSig) - 1) ||
                                       !_tcsnicmp(p, pszWindows95Sig + 1, CSTRLEN(pszWindows95Sig) - 1)) {

                                        IsWin95Inf = TRUE;
                                        p += (CSTRLEN(pszWindowsNTSig) - 1);
                                    }
                                }
                                break;
                            }
                        }

                    } else if(MatchClassGuid && !_tcsnicmp(p, pszClassGuid, CSTRLEN(pszClassGuid))) {

                        PCTSTR GuidStringCheckUB = FileImageEnd - (GUID_STRING_LEN - 1);

                        //
                        // We have found a ClassGUID line--see if it matches the
                        // class GUID specified by the caller.
                        //
                        p += CSTRLEN(pszClassGuid);

                        //
                        // If a class GUID string wasn't specified, then use GUID_NULL.
                        //
                        if(!ClassGuidString) {
                            ClassGuidString = pszGuidNull;
                        }

                        while((p <= GuidStringCheckUB) &&
                              (*p != (TCHAR)26) && (*p != TEXT('\n'))) {

                            if(*(p++) == TEXT('{')) {

                                if((*(p + (GUID_STRING_LEN - 3)) != TEXT('}')) ||
                                   _tcsnicmp(p, ClassGuidString + 1, GUID_STRING_LEN - 3)) {
                                    //
                                    // The GUIDs don't match.  If ClassGuid was NULL, then
                                    // this means we should continue, because we were matching
                                    // against GUID_NULL, which we want to disallow.
                                    //
                                    if(ClassGuidString == pszGuidNull) {
                                        //
                                        // We don't need to keep looking for ClassGUIDs.
                                        //
                                        MatchClassGuid = FALSE;
                                    }
                                } else {
                                    //
                                    // The GUIDs match.  If ClassGuid was not NULL, then this
                                    // means that we should continue.
                                    //
                                    if(ClassGuidString != pszGuidNull) {
                                        //
                                        // We don't need to keep looking for ClassGUIDs.
                                        //
                                        MatchClassGuid = FALSE;
                                    }
                                }
                                //
                                // Skip over the GUID string.
                                //
                                p += (GUID_STRING_LEN - 2);

                                break;
                            }
                        }

                        //
                        // If we get here, and MatchClassGuid hasn't been reset,
                        // then we know that this ClassGUID entry didn't match.
                        //
                        if(MatchClassGuid) {
                            rc = ERROR_CLASS_MISMATCH;
                            goto clean0;
                        }
                    }
                }
            }

            //
            // Skip to the newline or end of file.
            //
            while(!AT_EOF && (*p != TEXT('\n'))) {
                p++;
            }
        }

clean0: ; // Nothing to do.

    } except(EXCEPTION_EXECUTE_HANDLER) {
        rc = ERROR_READ_FAULT;
    }

    if(rc == NO_ERROR) {

        MYASSERT(p <= FileImageEnd);

        if(p < FileImageEnd) {
            //
            // Then we hit a CTL-Z during processing, so update the
            // FileImageSize output parameter with the new size.
            //
            *FileImageSize = (DWORD)(p - FileImage);
        }

        if(StringsSectionParams) {
            //
            // If a strings section happens to be the last section in the INF,
            // then we need to remember the end of the INF as being the end of
            // the string section also.
            //
            if(InStringsSection) {
                StrSecEnd[InStringsSection] = p;
                StrSecEndLine[InStringsSection] = CurLineNumber;
            }

            //
            // Now search through our array of strings sections (highest priority to lowest),
            // looking for the best match.
            //
            for(InStringsSection = 1; InStringsSection < 5; InStringsSection++) {
                if(StrSecStart[InStringsSection]) {
                    break;
                }
            }
            //
            // if the INF appears to be partially localized, and we didn't
            // pick an apropriate localized string section
            // log it
            //
            if(LogContext && IsWin95Inf) {
                if(InStringsSection >= 5) {
                    //
                    // it's quite valid to have an INF with no strings section
                    // so log it verbose here, we'll catch it later
                    //
                    WriteLogEntry(LogContext,
                                  SETUP_LOG_VERBOSE,
                                  MSG_LOG_NO_STRINGS,
                                  NULL,
                                  LanguageId,
                                  PrimaryLanguageId,
                                  NearLanguageId,
                                  FileName
                                  );
                } else if(LocalizedInf && InStringsSection > 2) {
                    //
                    // INF has localized string sections
                    // but none were reasonable match for locale
                    //
                    WriteLogEntry(LogContext,
                                  SETUP_LOG_WARNING,
                                  (InStringsSection> 3 ? MSG_LOG_DEF_STRINGS :
                                                         MSG_LOG_NEAR_STRINGS),
                                  NULL,
                                  LanguageId,
                                  PrimaryLanguageId,
                                  NearLanguageId,
                                  FileName
                                  );
                }
            }

            if(IsWin95Inf && (InStringsSection < 5)) {
                //
                // If we found a [strings] section in a Win95-style INF,
                // then store the beginning and ending positions, and the
                // beginning and ending line numbers, in the output parameter
                // structure
                //
                StringsSectionParams->Start = StrSecStart[InStringsSection];
                StringsSectionParams->End = StrSecEnd[InStringsSection];
                StringsSectionParams->StartLineNumber = StrSecStartLine[InStringsSection];
                StringsSectionParams->EndLineNumber = StrSecEndLine[InStringsSection];

            } else {
                ZeroMemory(StringsSectionParams, sizeof(STRINGSEC_PARAMS));
            }
        }

        *Win95Inf = IsWin95Inf;
    }

    return rc;
}


DWORD
DetermineInfStyle(
    IN PCTSTR            Filename,
    IN LPWIN32_FIND_DATA FindData
    )

/*++

Routine Description:

    Open an inf file, determine its style, and close the file, without
    keeping it around.

Arguments:

    Filename - supplies the fully-qualified pathname of the inf file to be checked

Return Value:

    INF_STYLE_NONE - style could not be determined
    INF_STYLE_WIN4 - win95-style inf file
    INF_STYLE_OLDNT - winnt3.5-style inf file

--*/

{
    HANDLE TextFileHandle;
    TEXTFILE_READ_BUFFER ReadBuffer;
    DWORD Style;
    BOOL Win95Inf;
    PLOADED_INF Pnf;

    //
    // First, determine whether a precompiled form of this INF exists, and if so, then
    // use it to determine the INF's style.
    //
    if(LoadPrecompiledInf(Filename,
                          &(FindData->ftLastWriteTime),
                          NULL,
                          0,
                          LDINF_FLAG_IGNORE_VOLATILE_DIRIDS | LDINF_FLAG_IGNORE_LANGUAGE,
                          NULL,
                          &Pnf,
                          NULL,
                          NULL,
                          NULL)) {
        //
        // Now we can simply access the Style field of the INF.
        //
        try {
            Style = (DWORD)Pnf->Style;
        } except(EXCEPTION_EXECUTE_HANDLER) {
            Style = INF_STYLE_NONE;
        }

        //
        // Now close the PNF.
        //
        FreeInfFile(Pnf);

    } else {
        //
        // No PNF--Open and preprocess the text version of the INF to find out its style.
        //
        if((TextFileHandle = CreateFile(Filename,
                                        GENERIC_READ,
                                        FILE_SHARE_READ,
                                        NULL,
                                        OPEN_EXISTING,
                                        0,
                                        NULL)) == INVALID_HANDLE_VALUE) {
            return INF_STYLE_NONE;

        } else {
            //
            // We're ready to make the determination--initially assume 'no-style'
            //
            Style = INF_STYLE_NONE;
        }

        if(ReadAsciiOrUnicodeTextFile(TextFileHandle, &ReadBuffer,NULL) == NO_ERROR) {

            if(PreprocessInf(ReadBuffer.TextBuffer,
                             &(ReadBuffer.TextBufferSize),
                             FALSE,
                             NULL,
                             0,
                             NULL,
                             NULL,
                             &Win95Inf,
                             NULL) == NO_ERROR) {

                Style = Win95Inf ? INF_STYLE_WIN4 : INF_STYLE_OLDNT;
            }
            DestroyTextFileReadBuffer(&ReadBuffer);
        }
        //
        // No need to close the textfile handle--it's taken care of in the above routines.
        //
    }

    return Style;
}


DWORD
LoadInfFile(
    IN  PCTSTR            Filename,
    IN  LPWIN32_FIND_DATA FileData,
    IN  DWORD             Style,
    IN  DWORD             Flags,
    IN  PCTSTR            ClassGuidString, OPTIONAL
    IN  PCTSTR            InfSourcePath,   OPTIONAL
    IN  PCTSTR            OriginalInfName, OPTIONAL
    IN  PLOADED_INF       AppendInf,       OPTIONAL
    IN  PSETUP_LOG_CONTEXT pLogContext,     OPTIONAL
    OUT PLOADED_INF      *LoadedInf,
    OUT UINT             *ErrorLineNumber,
    OUT BOOL             *PnfWasUsed       OPTIONAL
    )

/*++

Routine Description:

    Top level routine to load an inf file. Both win95-style and winnt3.x-style
    device infs are supported.

Arguments:


    Filename - supplies the fully-qualified pathname of the inf file to be loaded

    FileData - supplies data returned from FindFirstFile/FindNextFile for this INF.

    Style - supplies a type of inf file to be loaded. May be a combination of

        INF_STYLE_WIN4 - fail to load the given inf file if it is not a win95
            inf file.

        INF_STYLE_OLDNT - fail to load the given inf file if it is not an old
            style inf file.

        If a load fails because of the type, the return code is
        ERROR_WRONG_INF_STYLE.

    Flags - Specifies certain behaviors to use when loading the INF.  May be a
        combination of the following values:

        LDINF_FLAG_MATCH_CLASS_GUID - Check the INF to make sure it matches the GUID
            specified by the ClassGuid parameter (see discussion below).

        LDINF_FLAG_ALWAYS_TRY_PNF - If specified, then we will always attempt to
            generate a PNF file, if a valid one does not exist.

        LDINF_FLAG_ALWAYS_IGNORE_PNF - If specified, then we will not even look
            at or attempt to generate PNF file.

        LDINF_FLAG_IGNORE_VOLATILE_DIRIDS - If specified, then no validation
            will be done on the stored OsLoaderPath present in the PNF.  Since
            dynamically retrieving the current path is time consuming, this
            flag should be specified as an optimization if it is known that the
            relevant DIRIDs are not going to be needed (e.g., driver searching).

            This flag also suppresses substitution of volatile system DIRIDs.

            (Note: this flag should not be specified when append-loading an INF)

        LDINF_FLAG_REGENERATE_PNF - If specified, then the existing PNF (if
            present) is considered invalid, and is not even checked for.  This
            flag causes us to always generate a new PNF, and if we're unable to
            do so, the routine will fail.  This flag must always be specified in
            conjunction with LDINF_FLAG_ALWAYS_TRY_PNF.

        LDINF_FLAG_SRCPATH_IS_URL - If specified, then the InfSourcePath passed in is
            not a file path, but rather a URL.  If this flag is specified, InfSourcePath
            may still be NULL, which indicates that the origin of this INF was the default
            Code Download Manager site.

    ClassGuidString - Optionally, supplies the address of a class GUID string that
        the INF should match in order to be opened.  If the LDINF_FLAG_MATCH_CLASS_GUID
        bit is set in the Flags parameter, this GUID is matched against the ClassGUID
        entry in the [version] section of the INF.  If the two GUIDs are different, the
        load will fail with ERROR_CLASS_MISMATCH.  If the INF has no ClassGUID entry,
        then this check is not made, and the file is always opened.  If ClassGUID matching
        is requested, but ClassGuidString is NULL, then the INF load will succeed for all
        INFs except those with a ClassGUID of GUID_NULL.

    InfSourcePath - Optionally, supplies a path to be used as the INF's source path.  If
        LDINF_FLAG_SRCPATH_IS_URL is specified, this is a URL (see above), otherwise, this
        is a directory path.  This information is stored in the PNF file if this INF gets
        precompiled.

        If LDINF_FLAG_SRCPATH_IS_URL is specified, then "A:\" is used as the directory string
        substitution for DIRID_SRCPATH.

    OriginalInfName - Optionally, supplies the original name of the INF (no path)
        to be stored in the PNF, if generated.  If this parameter is not supplied,
        then the INF's present name is assumed to be its original name.

    AppendInf - if supplied, specifies an already-loaded inf to which
        the inf is to be load-appended.  THIS INF MUST HAVE BEEN ALREADY LOCKED BY THE
        CALLER!!!

    pLogContext - if supplied, specifies a LogContext that should be inherited
        as opposed to creating one

    LoadedInf - If AppendInf is not specified, receives a pointer to
        the descriptor for the inf. If AppendInf is specified, receives AppendInf.

    ErrorLineNumber - receives the line number of the error if there is
        a syntax error in the file (see below)

    PnfWasUsed - optionally, receives a boolean value upon successful return
        indicating whether or not a precompiled INF was used/generated in
        loading this INF.  NOTE, this flag should not be specified if an
        append-load is requested.

Return Value:

    Win32 error code (with inf extensions) for result.
    If result is not NO_ERROR, ErrorLineNumber is filled in.

--*/

{
    TEXTFILE_READ_BUFFER ReadBuffer;
    DWORD rc;
    PLOADED_INF Inf, InfListTail;
    BOOL Win95Inf;
    STRINGSEC_PARAMS StringsSectionParams;
    HANDLE TextFileHandle;
    PCTSTR OsLoaderPath = NULL;
    DWORD LanguageId;
    PTSTR InfSourcePathToMigrate, InfOriginalNameToMigrate;
    DWORD InfSourcePathToMigrateMediaType = SPOST_NONE;
    BOOL PnfUsed = FALSE;   // this allows us to log the flag if PnfWasUsed=NULL
    BOOL PnfSaved = FALSE;  // allows us to log the fact that we saved PNF
    PSETUP_LOG_CONTEXT LogContext = NULL;

    MYASSERT(!(AppendInf && PnfWasUsed));

    MYASSERT(!(AppendInf && (Flags & LDINF_FLAG_IGNORE_VOLATILE_DIRIDS)));

    *ErrorLineNumber = 0;

    if(PnfWasUsed) {
        *PnfWasUsed = FALSE;
    }

    //
    // Since we're now storing zero-length INF files in %windir%\Inf as
    // placeholders for the corresponding catalog files, add a quick check to
    // make sure we haven't been handed a zero-length INF.  If so, we can return
    // immediately and short ciruit some code.  (While we're at it, also make
    // sure that the high DWORD doesn't have any bits set, as we can't handle
    // files greater than 2^32).
    //
    if(FileData->nFileSizeHigh || !FileData->nFileSizeLow) {
        return ERROR_GENERAL_SYNTAX;
    }

    //
    // If append-loading, then traverse the existing list of loaded INFs, to see
    // if we've already loaded this one.
    //
    if(AppendInf) {
        //
        // Only allow appending with win95 infs
        //
        if(AppendInf->Style & INF_STYLE_OLDNT) {
            return ERROR_WRONG_INF_STYLE;
        }

        for(Inf = AppendInf; Inf; Inf = Inf->Next) {
            if(!lstrcmpi(Inf->VersionBlock.Filename, Filename)) {
                //
                // We've already loaded this INF--we can return success.
                //
                *LoadedInf = AppendInf;
                return NO_ERROR;
            }

            //
            // Check to see if the INF we're currently examining references the
            // system partition/OsLoader path.  If so, then remember this path
            // so that we will use the same one later when append-loading our
            // new INF.
            //
            if(Inf->OsLoaderPath) {
                if(OsLoaderPath) {
                    //
                    // We'd better be using the same value for OsLoadPath for
                    // all our append-loaded INFs!
                    //
                    MYASSERT(!lstrcmpi(Inf->OsLoaderPath, OsLoaderPath));
                } else {
                    OsLoaderPath = Inf->OsLoaderPath;
                }
            }

            //
            // Remember this node, in case it's the tail.  We do this so we don't
            // have to hunt for the tail again later.
            //
            InfListTail = Inf;
        }

        //
        // We want to append-load the INF based on the locale of the already-
        // loaded INF(s)
        //
        LanguageId = AppendInf->LanguageId;

    } else {
        //
        // We want to load the INF based on the current locale set for this thread.
        //
        LanguageId = (DWORD)LANGIDFROMLCID(GetThreadLocale());
    }

    InheritLogContext(pLogContext,&LogContext);

    //
    // Now determine whether a precompiled form of this INF exists, and if so,
    // then use it instead.
    //
    if((Flags & (LDINF_FLAG_REGENERATE_PNF|LDINF_FLAG_ALWAYS_IGNORE_PNF))==0) {
        if (!InfSourcePath && !(Flags & LDINF_FLAG_SRCPATH_IS_URL)) {
            //
            // if no source information provided, then always use that provided in the PNF
            // even if it might be wrong
            // typically when we're replacing such an INF, we'll explicitly say
            // not to load existing PNF
            //
            Flags |= LDINF_FLAG_ALWAYS_GET_SRCPATH;
        }
        if (LoadPrecompiledInf(Filename,
                          &(FileData->ftLastWriteTime),
                          OsLoaderPath,
                          LanguageId,
                          Flags,
                          LogContext,
                          &Inf,
                          &InfSourcePathToMigrate,
                          &InfSourcePathToMigrateMediaType,
                          &InfOriginalNameToMigrate)) {
            //
            // Make sure that the PNF is of the specified style.
            //
            if(!(Style & (DWORD)Inf->Style)) {
                FreeInfFile(Inf);
                DeleteLogContext(LogContext);
                return ERROR_WRONG_INF_STYLE;
            }

            if(AppendInf) {
                Inf->Prev = InfListTail;
                InfListTail->Next = Inf;
            }

            PnfUsed = TRUE;
            if(PnfWasUsed) {
                *PnfWasUsed = TRUE;
            }

            rc = NO_ERROR;
            goto clean0;
        }
    }

    //
    // If we tried to load the PNF and it failed, then check to see if we were
    // returned any INF source path information to migrate to the new PNF.  If
    // so, then this overrides the InfSourcePath information passed into this
    // routine.
    //
    if(InfSourcePathToMigrateMediaType != SPOST_NONE) {
        //
        // Discard the arguments the caller passed in and use what we retrieved
        // from the old PNF instead.
        //
        InfSourcePath = InfSourcePathToMigrate;
        if(InfSourcePathToMigrateMediaType == SPOST_PATH) {
            //
            // Make sure the "sourcepath is URL" bit is not set.
            //
            Flags &= ~LDINF_FLAG_SRCPATH_IS_URL;
        } else {
            //
            // This is a URL path--make sure the "sourcepath is URL" bit is set.
            //
            Flags |= LDINF_FLAG_SRCPATH_IS_URL;
        }

        //
        // If we're migrating source path information from the PNF, then we need
        // to use the PNF-specified original INF name, as well, instead of what
        // the caller may have specified.
        //
        OriginalInfName = InfOriginalNameToMigrate;
    }

    //
    // We can't use a precompiled INF, so resort to reading in the textfile INF.
    //
    if((TextFileHandle = CreateFile(Filename,
                                    GENERIC_READ,
                                    FILE_SHARE_READ,
                                    NULL,
                                    OPEN_EXISTING,
                                    0,
                                    NULL)) == INVALID_HANDLE_VALUE) {

        if(InfSourcePathToMigrateMediaType != SPOST_NONE) {
            if(InfSourcePathToMigrate) {
                MyFree(InfSourcePathToMigrate);
            }
            if(InfOriginalNameToMigrate) {
                MyFree(InfOriginalNameToMigrate);
            }
        }
        DeleteLogContext(LogContext);
        return GetLastError();
    }

    //
    // Note: We don't have to worry about closing TextFileHandle from this point
    // on, because the following routine will either close it for us, or copy it
    // into the ReadBuffer structure, to be later closed via DestroyTextFileReadBuffer().
    //
    if((rc = ReadAsciiOrUnicodeTextFile(TextFileHandle, &ReadBuffer,LogContext)) == NO_ERROR) {
        //
        // Make sure the style (and class) matched what the caller is asking
        // for and go parse the inf file in a style-specific manner.
        //
        Inf = NULL;
        if((rc = PreprocessInf(ReadBuffer.TextBuffer,
                               &(ReadBuffer.TextBufferSize),
                               (Flags & LDINF_FLAG_MATCH_CLASS_GUID),
                               ClassGuidString,
                               LanguageId,
                               LogContext,
                               Filename,
                               &Win95Inf,
                               &StringsSectionParams)) == NO_ERROR) {

            rc = ERROR_WRONG_INF_STYLE;
            if(Win95Inf) {
                if(Style & INF_STYLE_WIN4) {
                    //
                    // If we're dealing with a URL, then we don't have a real
                    // directory that we can do substitions on for DIRID_SRCPATH.
                    // "A:\" is about the best we can do.
                    //
                    rc = ParseNewInf(ReadBuffer.TextBuffer,
                                     ReadBuffer.TextBufferSize,
                                     (Flags & LDINF_FLAG_SRCPATH_IS_URL) ? pszOemInfDefaultPath
                                                                         : InfSourcePath,
                                     OsLoaderPath,
                                     LogContext,
                                     &Inf,
                                     ErrorLineNumber,
                                     &StringsSectionParams
                                    );
                }
            } else {
                //
                // Can't append old-style file.
                //
                if(!AppendInf && (Style & INF_STYLE_OLDNT)) {
                    rc = ParseOldInf(ReadBuffer.TextBuffer,
                                     ReadBuffer.TextBufferSize,
                                     LogContext,
                                     &Inf,
                                     ErrorLineNumber
                                    );
                }
            }
        }

        //
        // Free the in-memory image of the file.
        //
        DestroyTextFileReadBuffer(&ReadBuffer);

        if(rc == NO_ERROR) {
            //
            // If we get here then we've parsed the file successfully.
            // Set up version block for this file.
            //
            *ErrorLineNumber = 0;
            rc = CreateInfVersionNode(Inf, Filename, &(FileData->ftLastWriteTime));

            if(rc == NO_ERROR) {

                Inf->InfSourceMediaType = (Flags & LDINF_FLAG_SRCPATH_IS_URL) ? SPOST_URL
                                                                              : SPOST_PATH;

                if(InfSourcePath) {
                    //
                    // If the caller specified a source path (or we're migrating
                    // one from a previously-existing PNF), then duplicate the
                    // string, and store a pointer to it in our INF structure.
                    //
                    if(!(Inf->InfSourcePath = DuplicateString(InfSourcePath))) {
                        rc = ERROR_NOT_ENOUGH_MEMORY;
                    }
                }

                if((rc == NO_ERROR) && OriginalInfName) {
                    //
                    // If the caller specified the INF's original filename (or
                    // we're migrating one from a previously-existing PNF), then
                    // duplicate the string, and store a pointer to it in our
                    // INF structure.
                    //
                    // We shouldn't be storing this name if it's the same as the
                    // INF's present name.
                    //
                    MYASSERT(lstrcmpi(OriginalInfName, pSetupGetFileTitle(Filename)));

                    if(!(Inf->OriginalInfName = DuplicateString(OriginalInfName))) {
                        rc = ERROR_NOT_ENOUGH_MEMORY;
                    }
                }
            }

            if(rc == NO_ERROR) {
                //
                // Store the language ID used to load this INF into the LOADED_INF structure.
                //
                Inf->LanguageId = LanguageId;

                if (Flags & LDINF_FLAG_OEM_F6_INF) {
                    Inf->Flags = LIF_OEM_F6_INF;
                }

                //
                // If we get here then we've parsed the file successfully and
                // successfully created the version block.  If we're allowed
                // to write out a PNF file for this loaded INF, then do that
                // now.
                //
                if(Flags & LDINF_FLAG_ALWAYS_TRY_PNF) {

                    rc = SavePnf(Filename, Inf);

                    if(rc == NO_ERROR) {
                        PnfSaved = TRUE;
                        if(PnfWasUsed) {
                            *PnfWasUsed = TRUE;
                        }
                    } else if(((rc == ERROR_SHARING_VIOLATION)
                               || ((rc == ERROR_LOCK_VIOLATION)))
                              && (Flags & LDINF_FLAG_ALLOW_PNF_SHARING_LOCK)) {
                        //
                        // A sharing-type error occurred
                        // so a PNF exists and is in USE
                        // and we are flagged to indicate that it's non-fatal.
                        //
                        rc = NO_ERROR;
                    } else if(!(Flags & LDINF_FLAG_REGENERATE_PNF)) {
                        //
                        // We weren't explicitly asked to generate a PNF, thus
                        // our failure to do so shouldn't be considered fatal.
                        //
                        rc = NO_ERROR;
                    }
                }
            }

            if(rc == NO_ERROR) {
                if(AppendInf) {
                    Inf->Prev = InfListTail;
                    InfListTail->Next = Inf;
                }
            } else {
                FreeInfFile(Inf);
            }
        }
    }

clean0:

    if(AppendInf) {
        //
        // If the newly-loaded INF has any volatile system DIRIDs, or if the
        // INF we're appending to has any user-defined DIRIDs, then apply those
        // to the newly-appended INF now.
        //
        if((rc == NO_ERROR) &&
           (AppendInf->UserDirIdList.UserDirIdCount || Inf->Flags & LIF_HAS_VOLATILE_DIRIDS)) {

            if((rc = ApplyNewVolatileDirIdsToInfs(AppendInf, Inf)) != NO_ERROR) {
                //
                // So near, and yet, so far!  Yank the new INF out of the linked
                // list, and free it.
                //
                MYASSERT(Inf->Prev);
                Inf->Prev->Next = Inf->Next;
                FreeInfFile(Inf);
            }
        }
        if(rc == NO_ERROR) {
            *LoadedInf = AppendInf;
        }
    } else if(rc == NO_ERROR) {
        //
        // We're not append-loading the INF, thus there's no user-defined
        // DIRID substitutions to worry about.  However, if the INF has volatile
        // system DIRIDs, then we still need to apply paths to those DIRIDs now
        // (unless the caller said to skip it).
        //
        if((Inf->Flags & LIF_HAS_VOLATILE_DIRIDS) &&
           !(Flags & LDINF_FLAG_IGNORE_VOLATILE_DIRIDS)) {

            rc = ApplyNewVolatileDirIdsToInfs(Inf, NULL);
        }
        if(rc == NO_ERROR) {
            *LoadedInf = Inf;
        } else {
            FreeInfFile(Inf);
        }
    }

    if (rc == NO_ERROR) {
        //
        // log that the INF was loaded
        //
        WriteLogEntry(
            LogContext,
            SETUP_LOG_VVERBOSE,
            (PnfUsed ? MSG_LOG_OPENED_PNF
                     : (PnfSaved ? MSG_LOG_SAVED_PNF : MSG_LOG_OPENED_INF)),
            NULL,
            Filename,
            LanguageId);
    }

    if(InfSourcePathToMigrateMediaType != SPOST_NONE) {
        if(InfSourcePathToMigrate) {
            MyFree(InfSourcePathToMigrate);
        }
        if(InfOriginalNameToMigrate) {
            MyFree(InfOriginalNameToMigrate);
        }
    }
    DeleteLogContext(LogContext);

    return rc;
}


VOID
FreeInfFile(
    IN PLOADED_INF LoadedInf
    )

/*++

Routine Description:

    Unload an inf file, freeing all resources used by its internal
    representation.

Arguments:

    Inf - supplies a pointer to the inf descriptor for the loaded inf file.

Return Value:

    None.

--*/

{
    if(LockInf(LoadedInf)) {
        DestroySynchronizedAccess(&LoadedInf->Lock);
        FreeLoadedInfDescriptor(LoadedInf);
    }
}


BOOL
AddDatumToVersionBlock(
    IN OUT PINF_VERSION_NODE VersionNode,
    IN     PCTSTR            DatumName,
    IN     PCTSTR            DatumValue
    )

/*++

Routine Description:

    Append an inf version datum to the version node.

Arguments:

    VersionNode - supplies pointer to the version node.

    DatumName - supplies name of the datum.

    DatumValue - supplies datum's value.

Return Value:

    FALSE if OOM.
    TRUE if datum added successfully. Various fields in the VersionNode
        will have been updated.

--*/

{
    UINT RequiredSpace;
    UINT NameLength, ValueLength;
    PTSTR NewDataBlock;

    NameLength = lstrlen(DatumName) + 1;
    ValueLength = lstrlen(DatumValue) + 1;

    //
    // The space needed to store the datum is the existing space plus
    // the length of the 2 strings and their nul bytes.
    //
    RequiredSpace = VersionNode->DataSize + ((NameLength + ValueLength) * sizeof(TCHAR));

    if(VersionNode->DataBlock) {
        NewDataBlock = MyTaggedRealloc((PVOID)(VersionNode->DataBlock), RequiredSpace, MEMTAG_VBDATA);
    } else {
        NewDataBlock = MyTaggedMalloc(RequiredSpace, MEMTAG_VBDATA);
    }

    if(!NewDataBlock) {
        return FALSE;
    }

    //
    // Place the datum name in the version block.
    //
    lstrcpy((PTSTR)((PUCHAR)NewDataBlock + VersionNode->DataSize), DatumName);
    VersionNode->DataSize += NameLength * sizeof(TCHAR);

    //
    // Place the datum value in the version block.
    //
    lstrcpy((PTSTR)((PUCHAR)NewDataBlock + VersionNode->DataSize), DatumValue);
    VersionNode->DataSize += ValueLength * sizeof(TCHAR);

    VersionNode->DatumCount++;

    VersionNode->DataBlock = NewDataBlock;

    return TRUE;
}


DWORD
ProcessNewInfVersionBlock(
    IN PLOADED_INF Inf
    )

/*++

Routine Description:

    Set up a version node for a new-style inf file. The version node is
    simply a mirror of the [Version] section in the file.

    Since this routine is only called at INF load time, no locking is done.
    Also, since we are guaranteed that this will operate on a single INF
    only, we don't have to worry about traversing a linked list of INFs.

Arguments:

    Inf - supplies a pointer to the inf descriptor for the file.

Return Value:

    Win32 error code (with inf extensions) indicating outcome.

--*/

{
    PINF_SECTION Section;
    PINF_LINE Line;
    UINT u;
    BOOL b;

    //
    // Locate the [Version] section.
    //
    if(Section = InfLocateSection(Inf, pszVersion, NULL)) {
        //
        // Iterate each line in the section. If the line has a key and at least one
        // other value, then it counts as a version datum. Otherwise ignore it.
        //
        for(u = 0, Line = &Inf->LineBlock[Section->Lines];
            u < Section->LineCount;
            u++, Line++)
        {
            if(HASKEY(Line)) {

                MYASSERT(Line->ValueCount > 2);

                //
                // Use the case-sensitive key name.
                //
                b = AddDatumToVersionBlock(
                        &(Inf->VersionBlock),
                        pStringTableStringFromId(Inf->StringTable, Inf->ValueBlock[Line->Values+1]),
                        pStringTableStringFromId(Inf->StringTable, Inf->ValueBlock[Line->Values+2])
                        );

                if(!b) {
                    return ERROR_NOT_ENOUGH_MEMORY;
                }
            }
        }
    }
    return NO_ERROR;
}


DWORD
CreateInfVersionNode(
    IN PLOADED_INF Inf,
    IN PCTSTR      Filename,
    IN PFILETIME   LastWriteTime
    )

/*++

Routine Description:

    Set up a version node for an inf file, and link it into the list of INFs for
    the specified LOADED_INF structure.
    THIS ROUTINE ASSUMES THAT THE VERSION BLOCK STRUCTURE IN THE INF HAS BEEN
    ZEROED OUT.

Arguments:

    Inf - supplies pointer to descriptor for loaded inf file.

    Filename - supplies (fully-qualified) filename used to load inf file.

    LastWriteTime - supplies a pointer to a FILETIME structure specifying
        the time that the INF was last written to.

Return Value:

    Win32 error code (with inf extensions) indicating outcome.

--*/

{
    MYASSERT(!(Inf->VersionBlock.DataBlock));
    MYASSERT(!(Inf->VersionBlock.DataSize));
    MYASSERT(!(Inf->VersionBlock.DatumCount));

    //
    // Fill in the filename and other fields in the version descriptor.
    //
    Inf->VersionBlock.LastWriteTime = *LastWriteTime;

    Inf->VersionBlock.FilenameSize = (lstrlen(Filename) + 1) * sizeof(TCHAR);

    CopyMemory(Inf->VersionBlock.Filename, Filename, Inf->VersionBlock.FilenameSize);

    //
    // Style-specific processing.
    //
    return((Inf->Style == INF_STYLE_WIN4) ? ProcessNewInfVersionBlock(Inf)
                                          : ProcessOldInfVersionBlock(Inf));
}


/////////////////////////////////////////////
//
// Inf data access functions
//
/////////////////////////////////////////////

#ifdef UNICODE

BOOL
WINAPI
SetupEnumInfSectionsA (
    IN  HINF        InfHandle,
    IN  UINT        Index,
    OUT PSTR        Buffer,         OPTIONAL
    IN  UINT        Size,           OPTIONAL
    OUT UINT        *SizeNeeded     OPTIONAL
    )
/*++

Routine Description:
    See SetupEnumInfSections
    Ansi Wrapper

--*/
{
    UINT UniSize;
    UINT AnsiSize;
    BOOL f;
    PWSTR UniBuffer;
    PSTR AnsiBuffer;
    DWORD rc;

    f = SetupEnumInfSectionsW(InfHandle,Index,NULL,0,&UniSize);
    if(!f) {
        return FALSE;
    }
    UniBuffer = (PWSTR)MyMalloc(UniSize*sizeof(WCHAR));
    if(!UniBuffer) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }
    f = SetupEnumInfSectionsW(InfHandle,Index,UniBuffer,UniSize,NULL);
    if(!f) {
        rc = GetLastError();
        MYASSERT(f);
        MyFree(UniBuffer);
        SetLastError(rc);
        return FALSE;
    }
    AnsiBuffer = pSetupUnicodeToAnsi(UniBuffer);
    MyFree(UniBuffer);
    if(!AnsiBuffer) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }
    AnsiSize = strlen(AnsiBuffer)+1;
    try {
        if(SizeNeeded) {
            *SizeNeeded = AnsiSize;
        }
        if (Buffer) {
            if(Size<AnsiSize) {
                rc = ERROR_INSUFFICIENT_BUFFER;
            } else {
                strcpy(Buffer,AnsiBuffer);
                rc = NO_ERROR;
            }
        } else if(Size) {
            rc = ERROR_INVALID_USER_BUFFER;
        } else {
            rc = NO_ERROR;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        //
        // Assume InfHandle was bad pointer
        //
        rc = ERROR_INVALID_DATA;
    }
    MyFree(AnsiBuffer);
    SetLastError(rc);
    return (rc == NO_ERROR);
}

#else

BOOL
WINAPI
SetupEnumInfSectionsW (
    IN  HINF        InfHandle,
    IN  UINT        Index,
    OUT PWSTR       Buffer,         OPTIONAL
    IN  UINT        Size,           OPTIONAL
    OUT UINT        *SizeNeeded     OPTIONAL
    )
/*++

Routine Description:
    See SetupEnumInfSections
    Unicode Stub for ANSI SetupAPI

--*/
{
    UNREFERENCED_PARAMETER(InfHandle);
    UNREFERENCED_PARAMETER(Buffer);
    UNREFERENCED_PARAMETER(Size);
    UNREFERENCED_PARAMETER(SizeNeeded);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}

#endif

BOOL
WINAPI
SetupEnumInfSections (
    IN  HINF        InfHandle,
    IN  UINT        Index,
    OUT PTSTR       Buffer,         OPTIONAL
    IN  UINT        Size,           OPTIONAL
    OUT UINT        *SizeNeeded     OPTIONAL
    )
/*++

Routine Description:

    Enumerate Sections of a single INF (ignoring any attached INF's)
    Start with Index==0 and keep incrementing Index until ERROR_NO_MORE_ITEMS
    is returned.

    section name is copied into Buffer.

Arguments:

    InfHandle - Specifies the handle to an open INF file

    Index - enumeration index, not related to order sections are in INF

    Buffer - Receives a single section name

    Size - Specifies the size of Buffer, in characters

    SizeNeeded - Receives the size of Buffer needed, in characters

Return Value:

    TRUE if the function succeeds, or FALSE if not.

--*/
{
    DWORD rc = NO_ERROR;
    LPTSTR section;
    UINT actsz;
    PLOADED_INF pInf = (PLOADED_INF)InfHandle;

    try {
        if(!LockInf(pInf)) {
            rc = ERROR_INVALID_HANDLE;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        //
        // Assume InfHandle was bad pointer
        //
        rc = ERROR_INVALID_HANDLE;
    }

    if (rc != NO_ERROR) {
        SetLastError (rc);
        return FALSE;
    }

    try {
        if(Index >= pInf->SectionCount) {
            rc = ERROR_NO_MORE_ITEMS;
            leave;
        }
        section = pStringTableStringFromId(pInf->StringTable, pInf->SectionBlock[Index].SectionName);
        if(section == NULL) {
            MYASSERT(section);
            rc = ERROR_INVALID_DATA;
            leave;
        }
        actsz = lstrlen(section)+1;
        if(SizeNeeded) {
            *SizeNeeded = actsz;
        }
        if (Buffer) {
            if(Size<actsz) {
                rc = ERROR_INSUFFICIENT_BUFFER;
            } else {
                _tcscpy(Buffer,section);
                rc = NO_ERROR;
            }
        } else if(Size) {
            rc = ERROR_INVALID_USER_BUFFER;
        } else {
            rc = NO_ERROR;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        //
        // Assume InfHandle was bad pointer
        //
        rc = ERROR_INVALID_DATA;
    }
    UnlockInf(pInf);
    SetLastError(rc);
    return (rc == NO_ERROR);
}


//
// NTRAID#207847-JamieHun-2000/10/19 Fix users of (p)SetupGetInfSections
//
// pSectionEnumWorker and pSetupGetInfSections are busted implementations
// of obtaining a list of INF sections
//
// we have to leave them in until all internal tools get updated
//
VOID
pSectionEnumWorker (
    IN      PCTSTR String,
    IN OUT  PSECTION_ENUM_PARAMS Params
    )

/*++

Routine Description:

    Callback that receives each section name.  It copies the string
    to a supplied buffer (if available), and also keeps track of the
    total size regardless if a buffer was supplied.

Arguments:

    String - Specifies the section name

    Params - Specifies a pointer to a SECTION_ENUM_PARAMS structure.
             Receives the section appended to the supplied buffer (if
             necessary) and an updated total buffer size.

Return Value:

    Always TRUE.

--*/

{
    UINT Size;

    if (!String) {
        MYASSERT(FALSE);
        return;
    }

    Size = (UINT)((PBYTE) _tcschr (String, 0) - (PBYTE) String) + sizeof(TCHAR);

    Params->SizeNeeded += Size;
    if (Params->Size > Params->SizeNeeded) {
        if (Params->Buffer) {
            _tcscpy (Params->End, String);
            Params->End = _tcschr (Params->End, 0);
            Params->End++;
        }
    }
}

BOOL
pSetupGetInfSections (
    IN  HINF        InfHandle,
    OUT PTSTR       Buffer,         OPTIONAL
    IN  UINT        Size,           OPTIONAL
    OUT UINT        *SizeNeeded     OPTIONAL
    )

/*++

Routine Description:

    Make a multi-sz list of section names by enumerating the section
    string table and copying them into a caller-supplied buffer.
    Caller can also request the size needed without supplying a
    buffer.

    This function was implemented for the Win9x upgrade and is NOT
    exposed as a public API nor an ANSI version.

Arguments:

    Inf - Specifies the handle to an open INF file

    Buffer - Receives a multi-sz list of section names

    Size - Specifies the size of Buffer, in bytes

    SizeNeeded - Receives the size of Buffer needed, in bytes

Return Value:

    TRUE if the function succeeds, or FALSE if not.

--*/

{
    PLOADED_INF Inf;
    DWORD rc = NO_ERROR;
    SECTION_ENUM_PARAMS Params;
    PBYTE p;
    PINF_SECTION Section;
    UINT u;

    //
    // Init the enum worker params
    //

    Params.Buffer = Buffer;
    Params.Size = Buffer ? Size : 0;
    Params.SizeNeeded = 0;
    Params.End = Buffer;

    //
    // Validate buffer arg
    //

    try {
        if (Buffer) {
            p = (PBYTE) Buffer;
            p[0] = 0;
            p[Size - 1] = 0;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        rc = ERROR_INVALID_PARAMETER;
    }

    if (rc != NO_ERROR) {
        SetLastError (rc);
        return FALSE;
    }

    //
    // Lock the INF
    //

    try {
        if(!LockInf((PLOADED_INF)InfHandle)) {
            rc = ERROR_INVALID_HANDLE;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        //
        // Assume InfHandle was bad pointer
        //
        rc = ERROR_INVALID_HANDLE;
    }

    if (rc != NO_ERROR) {
        SetLastError (rc);
        return FALSE;
    }

    //
    // Traverse the linked list of loaded INFs, enumerating each INF's
    // sections.
    //
    try {
        for(Inf = (PLOADED_INF)InfHandle; Inf; Inf = Inf->Next) {
            //
            // Enumerate the sections
            //

            for(u=0,Section=Inf->SectionBlock; u<Inf->SectionCount; u++,Section++) {
                pSectionEnumWorker (
                    pStringTableStringFromId (Inf->StringTable, Section->SectionName),
                    &Params
                    );
            }
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        rc = ERROR_INVALID_PARAMETER;
    }

    //
    // Update the structure and OUT params for the last time
    //

    try {
        if (rc == NO_ERROR) {
            Params.SizeNeeded += sizeof(TCHAR);

            if (SizeNeeded) {
                *SizeNeeded = Params.SizeNeeded;
            }

            if (Params.Buffer && Params.Size >= Params.SizeNeeded) {
                *Params.End = 0;
            } else if (Params.Buffer) {
                rc = ERROR_INSUFFICIENT_BUFFER;
            }
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
        rc = ERROR_INVALID_PARAMETER;
    }

    //
    // Unlock the INF
    //

    UnlockInf((PLOADED_INF)InfHandle);

    return rc == NO_ERROR;
}


PINF_SECTION
InfLocateSection(
    IN  PLOADED_INF Inf,
    IN  PCTSTR      SectionName,
    OUT PUINT       SectionNumber   OPTIONAL
    )

/*++

Routine Description:

    Locate a section within an inf file.  This routine DOES NOT traverse a
    linked list of INFs, looking for the section in each.

    THIS ROUTINE DOES NOT LOCK THE INF--THE CALLER MUST HANDLE IT!!!

Arguments:

    Inf - supplies a pointer to the inf descriptor for the loaded inf file.

    SectionName - Supplies the name of the section to be located.

    SectionNumber - if specified, receives the ordinal number of
        the section.

Return Value:

    Pointer to the section descriptor, or NULL if the section
    does not exist.

--*/

{
    LONG StringId;
    PINF_SECTION Section;
    UINT u;
    DWORD StringLength;
    TCHAR TempString[MAX_SECT_NAME_LEN];

    //
    // Make a copy of the SectionName into a modifiable buffer to speed
    // the lookup.
    //
    lstrcpyn(TempString, SectionName, SIZECHARS(TempString));

    //
    // Start from the beginning.
    //
    StringId = pStringTableLookUpString(Inf->StringTable,
                                        TempString,
                                        &StringLength,
                                        NULL,
                                        NULL,
                                        STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE,
                                        NULL,0
                                       );
    if(StringId == -1) {
        return(NULL);
    }

    for(u=0,Section=Inf->SectionBlock; u<Inf->SectionCount; u++,Section++) {
        if(Section->SectionName == StringId) {
            if(SectionNumber) {
                *SectionNumber = u;
            }
            return(Section);
        }
    }

    return(NULL);
}


BOOL
InfLocateLine(
    IN     PLOADED_INF   Inf,
    IN     PINF_SECTION  Section,
    IN     PCTSTR        Key,        OPTIONAL
    IN OUT PUINT         LineNumber,
    OUT    PINF_LINE    *Line
    )

/*++

Routine Description:

    Locate a line within a section.  This routine DOES NOT traverse a
    linked list of INFs, looking for the section in each.

    THIS ROUTINE DOES NOT LOCK THE INF--THE CALLER MUST HANDLE IT!!!

Arguments:

    Inf - supplies a pointer to the inf descriptor for the loaded inf file.

    SectionName - Supplies a pointer to the section descriptor for the section
        to be searched.

    Key - if specified, supplies the key of the line to look for.

    LineNumber - on input, supplies the line number of the line where the
        search is to begin. On output, receives the line number of the
        line where the match was found

    Line - receives a pointer to the line descriptor for the line
        where the match was found.

Return Value:

    TRUE if line is found, FALSE otherwise.

--*/

{
    PINF_LINE line;
    UINT u;
    LONG StringId;
    DWORD StringLength;
    TCHAR TempString[MAX_STRING_LENGTH];

    if(Key) {
        //
        // Copy the key name into a modifiable buffer to speed up the string table API.
        //
        lstrcpyn(TempString, Key, SIZECHARS(TempString));
        StringId = pStringTableLookUpString(Inf->StringTable,
                                            TempString,
                                            &StringLength,
                                            NULL,
                                            NULL,
                                            STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE,
                                            NULL,0
                                           );
        if(StringId == -1) {
            return FALSE;
        }

        for(u = *LineNumber, line = &Inf->LineBlock[Section->Lines + (*LineNumber)];
            u < Section->LineCount;
            u++, line++)
        {
            if(ISSEARCHABLE(line) && (Inf->ValueBlock[line->Values] == StringId)) {
                *Line = line;
                *LineNumber = u;
                return TRUE;
            }
        }
    } else {
        if(*LineNumber < Section->LineCount) {
            *Line = &Inf->LineBlock[Section->Lines + (*LineNumber)];
            return TRUE;
        }
    }

    return FALSE;
}


PTSTR
InfGetField(
    IN  PLOADED_INF Inf,
    IN  PINF_LINE   InfLine,
    IN  UINT        ValueNumber,
    OUT PLONG       StringId     OPTIONAL
    )

/*++

Routine Description:

    Retrieve the key or a value from a specified line in an inf file.

    THIS ROUTINE DOES NOT DO LOCKING!!!

Arguments:

    Inf - supplies a pointer to the inf descriptor for the loaded inf file.

    InfLine - supplies a pointer to the line descriptor for the line
        from which the value is to be fetched.  THIS LINE MUST BE CONTAINED
        WITHIN THE SPECIFIED INF!!

    ValueNumber - supplies the index for the value to retreive. If a line has a key,
        the key is value #0 and other values start at 1. If a line does not have a
        key, values start at 1.  For Win95 INF compatibility, if there's only a single
        value on the line (i.e., no '=' to denote it as a key), we'll consider it to
        be both a key and the first value (either 0 or 1 will work).

    StringId - if specified, receives the string table id of the value.

Return Value:

    Pointer to the value, or NULL if not found. The caller must not write into
    or otherwise alter this string.

--*/

{
    LONG stringId;
    PTSTR ret = NULL;

    //
    // Adjust the value number.
    //
    if(HASKEY(InfLine)) {
        //
        // All field references are shifted up by one, to account for the two
        // copies of the key (first is case insensative)
        //
        ValueNumber++;
        if(ValueNumber==0) {
            //
            // wrap
            //
            return NULL;
        }

    } else {

        if(ISSEARCHABLE(InfLine)) {
            //
            // lines that consist of one value "VaLue" are treated like "value=VaLue"
            // this is such a line, and is recognized because HASKEY is FALSE but
            // ISSEARCHABLE is TRUE
            //
            // We want to return the second of the two, since it's the one that was
            // stored case-sensitively.
            //
            if(ValueNumber > 1) {
                return NULL;
            } else {
                ValueNumber = 1;
            }

        } else {
            //
            // This line is not searchable, so asking for value #0 is an error.
            //
            if(ValueNumber) {
                ValueNumber--;
            } else {
                return NULL;
            }
        }
    }

    //
    // Get the value.
    //
    if(ValueNumber < InfLine->ValueCount) {

        stringId = Inf->ValueBlock[InfLine->Values+ValueNumber];

        if(StringId) {
            *StringId = stringId;
        }

        return pStringTableStringFromId(Inf->StringTable, stringId);
    }

    return NULL;
}


PTSTR
InfGetKeyOrValue(
    IN  PLOADED_INF Inf,
    IN  PCTSTR      SectionName,
    IN  PCTSTR      LineKey,     OPTIONAL
    IN  UINT        LineNumber,  OPTIONAL
    IN  UINT        ValueNumber,
    OUT PLONG       StringId     OPTIONAL
    )

/*++

Routine Description:

    Retrieve the key or a value from a specified line in an inf file.

Arguments:

    Inf - supplies a pointer to the inf descriptor for the loaded inf file.

    SectionName - supplies the name of the section where the value is located.

    LineKey - if specified, supplies the key name for the line where the
        value is located. If not specified, LineNumber is used instead.

    LineNumber - if LineKey is not specified, supplies the 0-based line number
        within the section where the value is located.

    ValueNumber - supplies the index for the value to retreive. If a line has a key,
        the key is value #0 and other values start at 1. If a line does not have a
        key, values start at 1.

    StringId - if specified, receives the string table id of the value.

Return Value:

    Pointer to the value, or NULL if not found. The caller must not write into
    or otherwise alter this string.

--*/

{
    INFCONTEXT InfContext;
    PINF_LINE Line;
    PTSTR String;

    if(LineKey) {
        if(!SetupFindFirstLine((HINF)Inf, SectionName, LineKey, &InfContext)) {
            return NULL;
        }
    } else {
        if(!SetupGetLineByIndex((HINF)Inf, SectionName, LineNumber, &InfContext)) {
            return NULL;
        }
    }

    Line = InfLineFromContext(&InfContext);

    //
    // The above routines do their own locking.  The following routine, however, does
    // not, so we must lock the INF before preceding.
    //
    if(LockInf(Inf)) {
        String = InfGetField(Inf, Line, ValueNumber, StringId);
        UnlockInf(Inf);
    } else {
        String = NULL;
    }

    return String;
}

PVOID
InitializeStringTableFromPNF(
    IN PPNF_HEADER PnfHeader,
    IN LCID        Locale
    )
{
    PVOID StringTable = NULL;

    try {

        StringTable = InitializeStringTableFromMemoryMappedFile(
                            (PUCHAR)PnfHeader + PnfHeader->StringTableBlockOffset,
                            PnfHeader->StringTableBlockSize,
                            Locale,
                            0
                            );

    } except(EXCEPTION_EXECUTE_HANDLER) {
    }

    return StringTable;
}

BOOL
LoadPrecompiledInf(
    IN  PCTSTR       Filename,
    IN  PFILETIME    LastWriteTime,
    IN  PCTSTR       OsLoaderPath,                    OPTIONAL
    IN  DWORD        LanguageId,
    IN  DWORD        Flags,
    IN  PSETUP_LOG_CONTEXT LogContext,                OPTIONAL
    OUT PLOADED_INF *Inf,
    OUT PTSTR       *InfSourcePathToMigrate,          OPTIONAL
    OUT PDWORD       InfSourcePathToMigrateMediaType, OPTIONAL
    OUT PTSTR       *InfOriginalNameToMigrate         OPTIONAL
    )
/*++

Routine Description:

    This routine attempts to find a .PNF (Precompiled iNF) file corresponding to
    the specified .INF name.  If located, the .PNF is mapped into memory as a
    LOADED_INF.  To ensure that the INF hasn't changed since being compiled, the
    INF's LastWriteTime, as stored in the .PNF's version block, is checked against
    the LastWriteTime passed into this routine.  If the two are different, then the
    .PNF is out-of-sync, and is discarded from memory and deleted from the disk.

Arguments:

    Filename - supplies the name of the INF file whose precompiled form is to be loaded.
        This should be a fully qualified path (i.e., as returned by GetFullPathName).

    LastWriteTime - supplies the last-write time for the INF.

    OsLoaderPath - optionally, supplies path of the current OsLoader directory
        (e.g., "C:\os\winnt40").  If the specified PNF contains references to
        the system partition, then its stored OsLoaderPath must match this path
        in order for the PNF to be valid.  If this parameter is not specified,
        the OsLoader path is dynamically retrieved for comparison (unless the
        LDINF_FLAG_IGNORE_VOLATILE_DIRIDS flag is specified).

    LanguageId - supplies the language ID that must match the language ID stored in the
        PNF in order for the PNF to be used (ignored if LDINF_FLAG_IGNORE_LANGUAGE is
        specified).

    Flags - supplies flags that modify the behavior of this routine.  The following
        flags are currently recognized:

        LDINF_FLAG_IGNORE_VOLATILE_DIRIDS - If specified, then no validation
            will be done on the stored OsLoaderPath present in the PNF.  Since
            dynamically retrieving the current path is time consuming, this
            flag should be specified as an optimization if it is known that the
            relevant DIRIDs are not going to be needed.

        LDINF_FLAG_IGNORE_LANGUAGE - If specified, then no validation will be done on
            the language ID stored in the PNF.  This flag should only be used if no data
            is to be retrieved from the INF (e.g., if we're just interested in finding
            out if this is an old- or new-style INF).

    LogContext - if supplied, is a log context to be inherited

    Inf - supplies the address of the variable that receives the LOADED_INF pointer,
        if a valid .PNF is located.

    InfSourcePathToMigrate - Optionally, supplies the address of a string pointer
        that receives the address of a newly-allocated string buffer containing
        the source path associated with the INF's PNF that, while valid, was
        discarded because of a change in one of the stored system parameters
        (e.g., OS loader path, windir path, language ID).  This parameter will
        only be filled in upon unsuccessful return.  The type of path returned
        is dependent upon the value received by the InfSourcePathToMigrateMediaType
        argument, described below.  ** THE CALLER MUST FREE THIS STRING **

    InfSourcePathToMigrateMediaType - Optionally, supplies the address of a
        variable that will be set whenever InfSourcePathToMigrate is returned.
        This value indicates the type of source path we're talking about.  It
        can be one of the following values:

        SPOST_PATH - InfSourcePathToMigrate is a pointer to a standard file path

        SPOST_URL - If InfSourcePathToMigrate is NULL, then this INF came from
            the Windows Update (aka, Code Download Manager) website.  Otherwise,
            InfSourcePathToMigrate indicates the URL where the INF came from.

    InfOriginalNameToMigrate - Optionally, supplies the address of a string pointer
        that receives the address of a newly-allocated string buffer containing
        the original name of the associated INF (sans path).  Like  the
        InfSourcePathToMigrate and InfSourcePathToMigrateMediaType arguments
        described above, this argument is only filled in upon unsuccessful return
        for a PNF that, while structurally sound, was invalid because of a system
        parameter mismatch.  ** THE CALLER MUST FREE THIS STRING **

Return Value:

    If the PNF was successfully loaded, the return value is TRUE, otherwise, it
    is FALSE.

--*/
{
    TCHAR CharBuffer[MAX_PATH];
    PTSTR PnfFileName, PnfFileExt;
    DWORD FileSize;
    HANDLE FileHandle, MappingHandle;
    PVOID BaseAddress;
    BOOL IsPnfFile = FALSE;
    BOOL TimeDateMatch = FALSE;
    PPNF_HEADER PnfHeader;
    PLOADED_INF NewInf;
    BOOL NeedToDestroyLock, MinorVer1FieldsAvailable;
    PBYTE PnfImageEnd;
    DWORD TempStringLen;
    DWORD err;

    //
    // Either InfSourcePathToMigrate, InfSourcePathToMigrateMediaType, and
    // InfOriginalNameToMigrate must all be specified, or none of them may be
    // specified.
    //
    MYASSERT((InfSourcePathToMigrate && InfSourcePathToMigrateMediaType && InfOriginalNameToMigrate) ||
             !(InfSourcePathToMigrate || InfSourcePathToMigrateMediaType || InfOriginalNameToMigrate));

    if(InfSourcePathToMigrate) {
        *InfSourcePathToMigrate = NULL;
        *InfSourcePathToMigrateMediaType = SPOST_NONE;
        *InfOriginalNameToMigrate = NULL;
    }

    lstrcpyn(CharBuffer, Filename, SIZECHARS(CharBuffer));

    //
    // Find the start of the filename component of the path, and then find the last
    // period (if one exists) in that filename.
    //
    PnfFileName = (PTSTR)pSetupGetFileTitle(CharBuffer);
    if(!(PnfFileExt = _tcsrchr(PnfFileName, TEXT('.')))) {
        PnfFileExt = CharBuffer + lstrlen(CharBuffer);
    }

    //
    // Now create a corresponding filename with the extension '.PNF'
    //
    lstrcpyn(PnfFileExt, pszPnfSuffix, SIZECHARS(CharBuffer) - (int)(PnfFileExt - CharBuffer));

    //
    // Attempt to open and map the file into memory.
    //
    if(pSetupOpenAndMapFileForRead(CharBuffer,
                             &FileSize,
                             &FileHandle,
                             &MappingHandle,
                             &BaseAddress) != NO_ERROR) {
        //
        // Couldn't open a .PNF file--bail now.
        //
        return FALSE;
    }

    NewInf = NULL;
    NeedToDestroyLock = FALSE;
    MinorVer1FieldsAvailable = TRUE;
    PnfImageEnd = (PBYTE)BaseAddress + FileSize;

    try {
        //
        // Now verify that this really is a precompiled INF (and that it's one we can use).
        // Then see if the LastWriteTime field in its version block agrees with the filetime
        // we were passed in.
        //
        PnfHeader = (PPNF_HEADER)BaseAddress;

        //
        // If we ever rev the major version, the logic below will need to change,
        // as we'll need to migrate the INF source path information over, thus
        // we can't bail so quickly.
        //
        MYASSERT(PNF_MAJOR_VERSION == 1);

        if(HIBYTE(PnfHeader->Version) != PNF_MAJOR_VERSION) {
            //
            // A major version mismatch means the PNF is unusable (see note above
            // about the need to migrate INF source path info in the future).
            //
            if(LogContext) {
                WriteLogEntry(LogContext,
                              SETUP_LOG_WARNING,
                              MSG_LOG_PNF_VERSION_MAJOR_MISMATCH,
                              NULL,
                              PnfFileName,
                              PNF_MAJOR_VERSION,
                              HIBYTE(PnfHeader->Version)
                              );
            }
            goto clean0;
        }

        if(LOBYTE(PnfHeader->Version) != PNF_MINOR_VERSION) {

            if(LogContext) {
                WriteLogEntry(LogContext,
                              SETUP_LOG_WARNING,
                              MSG_LOG_PNF_VERSION_MINOR_MISMATCH,
                              NULL,
                              PnfFileName,
                              PNF_MINOR_VERSION,
                              LOBYTE(PnfHeader->Version)
                              );
            }
            if(LOBYTE(PnfHeader->Version) < PNF_MINOR_VERSION) {
                //
                // We're currently at minor version 1.  PNFs having a minor
                // version of 1 differ from those having a minor version of 0
                // in the following ways:
                //
                // 1.  Minor version 1 PNFs store the LanguageId in which the
                //     INF was precompiled.  For Minor version 0 INFs, this field
                //     was initialized to zero.  This will cause our check for
                //     LanguageId match to fail, thus we'll consider the PNF
                //     invalid.
                //
                // 2.  Minor version 1 PNFs contain additional fields for
                //     InfSourcePathOffset and OriginalInfNameOffset.  This means
                //     that the PNF_HEADER struct got longer, thus we can only
                //     use these fields for minor version 1 or greater PNFs.
                //
                MinorVer1FieldsAvailable = FALSE;
            }

            //
            // (If the minor version of the PNF we're looking at is _greater_ than
            // the version we currently support, then we should attempt to use
            // this PNF, since all the fields that we care about should be right
            // where we expect them to be.)
            //
        }

        //
        // The version information checks out--now check the last-write times.
        // note that if we add any other consistancy checks to determine that this PNF
        // is associated with the INF
        // we must also modify simular tests for INF cache
        //
        TimeDateMatch = CompareFileTime(LastWriteTime, &(PnfHeader->InfVersionLastWriteTime))?FALSE:TRUE;

        if (!TimeDateMatch && !(Flags&LDINF_FLAG_ALWAYS_GET_SRCPATH)) {
            //
            // Time&Date don't match, and we're not interested in always getting source path
            //
            WriteLogEntry(LogContext,
                          SETUP_LOG_WARNING,
                          MSG_LOG_PNF_TIMEDATE_MISMATCH,
                          NULL,
                          PnfFileName
                          );
            goto clean0;
        }

#ifdef UNICODE
        if(!(PnfHeader->Flags & PNF_FLAG_IS_UNICODE))
#else
        if(PnfHeader->Flags & PNF_FLAG_IS_UNICODE)
#endif
        {
            WriteLogEntry(LogContext,
                          SETUP_LOG_WARNING,
                          MSG_LOG_PNF_REBUILD_NATIVE,
                          NULL,
                          PnfFileName
                          );
            //
            // The APIs are Unicode while the PNF is ANSI, or vice versa.  We
            // still want to migrate the source path and original filename
            // information, if present, so that we preserve this information
            // across an upgrade from Win9x to NT, for example.
            //
            if(MinorVer1FieldsAvailable && InfSourcePathToMigrate) {
                //
                // First, retrieve the original INF name
                //
                if(PnfHeader->OriginalInfNameOffset) {
                    //
                    // Use strlen/wcslen so if an exception occurs it won't get
                    // swallowed...
                    //
#ifdef UNICODE
                    TempStringLen = strlen((PCSTR)((PBYTE)BaseAddress + PnfHeader->OriginalInfNameOffset)) + 1;
                    TempStringLen *= sizeof(CHAR);
#else
                    TempStringLen = wcslen((PCWSTR)((PBYTE)BaseAddress + PnfHeader->OriginalInfNameOffset)) + 1;
                    TempStringLen *= sizeof(WCHAR);
#endif
                    if(PnfImageEnd <
                           ((PBYTE)BaseAddress + PnfHeader->OriginalInfNameOffset + TempStringLen))
                    {
                        goto clean0;
                    }

                    //
                    // Looks like we have a good original INF name string.  Now
                    // convert it to the native character width.
                    //
#ifdef UNICODE
                    *InfOriginalNameToMigrate =
                        pSetupMultiByteToUnicode((PCSTR)((PBYTE)BaseAddress + PnfHeader->OriginalInfNameOffset),
                                           CP_ACP
                                          );
#else
                    *InfOriginalNameToMigrate =
                        pSetupUnicodeToMultiByte((PCWSTR)((PBYTE)BaseAddress + PnfHeader->OriginalInfNameOffset),
                                           CP_ACP
                                          );
#endif
                    if(!*InfOriginalNameToMigrate) {
                        goto clean0;
                    }
                }

                //
                // Next, retrieve the source path information
                //
                if(PnfHeader->InfSourcePathOffset) {
#ifdef UNICODE
                    TempStringLen = strlen((PCSTR)((PBYTE)BaseAddress + PnfHeader->InfSourcePathOffset)) + 1;
                    TempStringLen *= sizeof(CHAR);
#else
                    TempStringLen = wcslen((PCWSTR)((PBYTE)BaseAddress + PnfHeader->InfSourcePathOffset)) + 1;
                    TempStringLen *= sizeof(WCHAR);
#endif
                    if(PnfImageEnd <
                           ((PBYTE)BaseAddress + PnfHeader->InfSourcePathOffset + TempStringLen))
                    {
                        goto clean0;
                    }

                    //
                    // Looks like we have a good source path string.  Now convert
                    // it to the native character width.
                    //
#ifdef UNICODE
                    *InfSourcePathToMigrate =
                        pSetupMultiByteToUnicode((PCSTR)((PBYTE)BaseAddress + PnfHeader->InfSourcePathOffset),
                                           CP_ACP
                                          );
#else
                    *InfSourcePathToMigrate =
                        pSetupUnicodeToMultiByte((PCWSTR)((PBYTE)BaseAddress + PnfHeader->InfSourcePathOffset),
                                           CP_ACP
                                          );
#endif
                    if(!*InfSourcePathToMigrate) {
                        goto clean0;
                    }

                    if(PnfHeader->Flags & PNF_FLAG_SRCPATH_IS_URL) {
                        *InfSourcePathToMigrateMediaType = SPOST_URL;
                    } else {
                        *InfSourcePathToMigrateMediaType = SPOST_PATH;
                    }

                } else if(PnfHeader->Flags & PNF_FLAG_SRCPATH_IS_URL) {
                    //
                    // No source path stored in the PNF, but the flag says it's
                    // a URL, thus it came from Windows Update.
                    //
                    *InfSourcePathToMigrateMediaType = SPOST_URL;
                }
            }

            goto clean0;
        }

        //
        // Make sure that the last data block is still within the file.  This
        // prevents us from opening up a corrupted (truncated) PNF, and thinking
        // it's valid until later when we actually try to access data at an
        // offset that's past the end of the file's mapped image.
        //
        if(PnfHeader->InfSubstValueCount) {

            if(PnfImageEnd <
                   ((PBYTE)BaseAddress + PnfHeader->InfSubstValueListOffset + (PnfHeader->InfSubstValueCount * sizeof(STRINGSUBST_NODE))))
            {
                WriteLogEntry(LogContext,
                              SETUP_LOG_ERROR,
                              MSG_LOG_PNF_CORRUPTED,
                              NULL,
                              PnfFileName
                              );
                goto clean0;
            }

        } else if(MinorVer1FieldsAvailable && (PnfHeader->OriginalInfNameOffset)) {
            //
            // Use _tcslen so if an exception occurs it won't get swallowed...
            //
            TempStringLen = _tcslen((PCTSTR)((PBYTE)BaseAddress + PnfHeader->OriginalInfNameOffset)) + 1;

            if(PnfImageEnd <
                   ((PBYTE)BaseAddress + PnfHeader->OriginalInfNameOffset + (TempStringLen * sizeof(TCHAR))))
            {
                WriteLogEntry(LogContext,
                              SETUP_LOG_ERROR,
                              MSG_LOG_PNF_CORRUPTED,
                              NULL,
                              PnfFileName
                              );
                goto clean0;
            }

        } else if(MinorVer1FieldsAvailable && (PnfHeader->InfSourcePathOffset)) {
            //
            // Use _tcslen so if an exception occurs it won't get swallowed...
            //
            TempStringLen = _tcslen((PCTSTR)((PBYTE)BaseAddress + PnfHeader->InfSourcePathOffset)) + 1;

            if(PnfImageEnd <
                   ((PBYTE)BaseAddress + PnfHeader->InfSourcePathOffset + (TempStringLen * sizeof(TCHAR))))
            {
                WriteLogEntry(LogContext,
                              SETUP_LOG_ERROR,
                              MSG_LOG_PNF_CORRUPTED,
                              NULL,
                              PnfFileName
                              );
                goto clean0;
            }

        } else {
            //
            // Well, we didn't have a substitution block or a source path block,
            // so the last block in the PNF is the value block.
            //
            if(PnfImageEnd <
                ((PBYTE)BaseAddress + PnfHeader->InfValueBlockOffset + PnfHeader->InfValueBlockSize))
            {
                WriteLogEntry(LogContext,
                              SETUP_LOG_ERROR,
                              MSG_LOG_PNF_CORRUPTED,
                              NULL,
                              PnfFileName
                              );
                goto clean0;
            }
        }

        //
        // From this point forward, we appear to have a structurally sound PNF
        // of the appropriate version and character width.  Any failures
        // encountered should cause us to return the INF source path information
        // to the caller (if requested).
        //

        if (!TimeDateMatch) {
            MYASSERT(Flags&LDINF_FLAG_ALWAYS_GET_SRCPATH);
            //
            // Time&Date don't match, but we've recovered old media
            // we have to do this since on FAT/FAT32 the UT reported for a file
            // will change every time system TZ is changed.
            //
            WriteLogEntry(LogContext,
                          SETUP_LOG_INFO,
                          MSG_LOG_PNF_REBUILD_TIMEDATE_MISMATCH,
                          NULL,
                          PnfFileName
                          );
            goto clean1;
        }

        //
        // Make sure that the language ID that this PNF was compiled for matches
        // that of the current thread.
        //
        if(!(Flags & LDINF_FLAG_IGNORE_LANGUAGE) && ((DWORD)(PnfHeader->LanguageId) != LanguageId)) {
            WriteLogEntry(LogContext,
                          SETUP_LOG_WARNING,
                          MSG_LOG_PNF_REBUILD_LANGUAGE_MISMATCH,
                          NULL,
                          PnfFileName,
                          LanguageId,
                          PnfHeader->LanguageId
                          );
            goto clean1;
        }

        //
        // Now verify that the Windows (and, optionally, OsLoader) directories
        // for this PNF match the current state of the world.
        //
        if(lstrcmpi((PCTSTR)((PBYTE)BaseAddress + PnfHeader->WinDirPathOffset), WindowsDirectory)) {
            //
            // This PNF doesn't match the current WindowsDirectory path, so don't
            // use it.
            //
            WriteLogEntry(LogContext,
                          SETUP_LOG_WARNING,
                          MSG_LOG_PNF_REBUILD_WINDIR_MISMATCH,
                          NULL,
                          PnfFileName,
                          WindowsDirectory,
                          (PCTSTR)((PBYTE)BaseAddress + PnfHeader->WinDirPathOffset)
                          );
            goto clean1;
        }
        if((PnfHeader->OsLoaderPathOffset) && !(Flags & LDINF_FLAG_IGNORE_VOLATILE_DIRIDS)) {
            //
            // This INF contains references to the system partition.  Verify that the path
            // used during precompilation is the one we're currently using.
            //
            if(!OsLoaderPath) {
                //
                // The caller didn't specify an OsLoaderPath, so we must dynamically retrieve this
                // value from the registry.
                //
                err = pSetupGetOsLoaderDriveAndPath(FALSE, CharBuffer, SIZECHARS(CharBuffer), NULL);
                if(err) {
                    WriteLogEntry(LogContext,
                                  SETUP_LOG_WARNING,
                                  MSG_LOG_PNF_REBUILD_OSLOADER_MISMATCH,
                                  NULL,
                                  PnfFileName,
                                  TEXT("?"),
                                  (PCTSTR)((PBYTE)BaseAddress + PnfHeader->OsLoaderPathOffset)
                                  );
                    goto clean1;
                }
                OsLoaderPath = CharBuffer;
            }

            if(lstrcmpi((PCTSTR)((PBYTE)BaseAddress + PnfHeader->OsLoaderPathOffset), OsLoaderPath)) {
                WriteLogEntry(LogContext,
                              SETUP_LOG_WARNING,
                              MSG_LOG_PNF_REBUILD_OSLOADER_MISMATCH,
                              NULL,
                              PnfFileName,
                              OsLoaderPath,
                              (PCTSTR)((PBYTE)BaseAddress + PnfHeader->OsLoaderPathOffset)
                              );
                goto clean1;
            }
        }

        //
        // Make sure that we have verified whether this INF is digitally signed or not
        //
        if (!(PnfHeader->Flags & PNF_FLAG_INF_VERIFIED)) {
            WriteLogEntry(LogContext,
                          SETUP_LOG_INFO,
                          MSG_LOG_PNF_REBUILD_UNVERIFIED,
                          NULL,
                          PnfFileName
                          );
            goto clean1;
        }
        //
        // Verify that the product suite flags match
        // this causes us to refresh the PNF's if there's any change in product
        // suite
        // if on NT, PNF_FLAG_16BIT_SUITE must be set and upper 16 bits contains
        // product suite
        // if not on NT, PNF_FLAG_16BIT_SUITE must NOT be set.
        //
        if(((OSVersionInfo.dwPlatformId != VER_PLATFORM_WIN32_NT) &&
                    (PnfHeader->Flags & PNF_FLAG_16BIT_SUITE)) ||
                   ((OSVersionInfo.dwPlatformId == VER_PLATFORM_WIN32_NT) &&
                    (((PnfHeader->Flags & PNF_FLAG_16BIT_SUITE) == 0) ||
                    ((((PnfHeader->Flags >> 16) & 0xffff)^OSVersionInfo.wSuiteMask) &
                        ~(VER_SUITE_TERMINAL|VER_SUITE_SINGLEUSERTS))))) {
            WriteLogEntry(LogContext,
                          SETUP_LOG_INFO,
                          MSG_LOG_PNF_REBUILD_SUITE,
                          NULL,
                          PnfFileName,
                          ((PnfHeader->Flags >> 16) & 0xffff),
                          OSVersionInfo.wSuiteMask
                          );
            goto clean1;
        }

        //
        // One final check--make sure that the number of hash buckets used when precompiling
        // this INF matches what we expect.  (This wasn't rolled into the version check, since
        // this is something that is subject to lots of modification, and we didn't want to
        // rev the major version number each time.)
        //
        if(PnfHeader->StringTableHashBucketCount != HASH_BUCKET_COUNT) {
            WriteLogEntry(LogContext,
                          SETUP_LOG_WARNING,
                          MSG_LOG_PNF_REBUILD_HASH_MISMATCH,
                          NULL,
                          PnfFileName,
                          HASH_BUCKET_COUNT,
                          PnfHeader->StringTableHashBucketCount
                          );
            goto clean1;
        }

        //
        // We can use the file--now set up our top level structures.
        //
        if(NewInf = MyTaggedMalloc(sizeof(LOADED_INF),MEMTAG_INF)) {

            ZeroMemory(NewInf, sizeof(LOADED_INF));

            if(NewInf->StringTable = InitializeStringTableFromPNF(PnfHeader, (LCID)LanguageId)) {
                NewInf->LogContext = NULL;

                if(InheritLogContext(LogContext, &(NewInf->LogContext)) == NO_ERROR) {

                    if(InitializeSynchronizedAccess(&(NewInf->Lock))) {

                        NeedToDestroyLock = TRUE;

                        //
                        // All necessary resources were successfully allocated--now
                        // fill in the LOADED_INF fields
                        //
                        NewInf->Signature = LOADED_INF_SIG;

                        NewInf->FileHandle = FileHandle;
                        NewInf->MappingHandle = MappingHandle;
                        NewInf->ViewAddress = BaseAddress;

                        NewInf->SectionCount = PnfHeader->InfSectionCount;

                        NewInf->SectionBlockSizeBytes = PnfHeader->InfSectionBlockSize;
                        NewInf->SectionBlock = (PINF_SECTION)((PBYTE)BaseAddress +
                                                              PnfHeader->InfSectionBlockOffset);

                        NewInf->LineBlockSizeBytes = PnfHeader->InfLineBlockSize;
                        NewInf->LineBlock = (PINF_LINE)((PBYTE)BaseAddress +
                                                        PnfHeader->InfLineBlockOffset);

                        NewInf->ValueBlockSizeBytes = PnfHeader->InfValueBlockSize;
                        NewInf->ValueBlock = (PLONG)((PBYTE)BaseAddress +
                                                     PnfHeader->InfValueBlockOffset);

                        NewInf->Style = PnfHeader->InfStyle;

                        NewInf->HasStrings = (PnfHeader->Flags & PNF_FLAG_HAS_STRINGS);

                        if(PnfHeader->Flags & PNF_FLAG_HAS_VOLATILE_DIRIDS) {
                            NewInf->Flags |= LIF_HAS_VOLATILE_DIRIDS;
                        }

                        if (PnfHeader->Flags & PNF_FLAG_INF_DIGITALLY_SIGNED) {
                            NewInf->Flags |= LIF_INF_DIGITALLY_SIGNED;
                        }

                        if (PnfHeader->Flags & PNF_FLAG_OEM_F6_INF) {
                            NewInf->Flags |= LIF_OEM_F6_INF;
                        }

                        if (PnfHeader->Flags & PNF_FLAG_INF_AUTHENTICODE_SIGNED) {
                            NewInf->Flags |= LIF_INF_AUTHENTICODE_SIGNED;
                        }

                        NewInf->LanguageId = (DWORD)(PnfHeader->LanguageId);

                        //
                        // Next, fill in the VersionBlock fields.
                        //
                        NewInf->VersionBlock.LastWriteTime = *LastWriteTime;
                        NewInf->VersionBlock.DatumCount = PnfHeader->InfVersionDatumCount;
                        NewInf->VersionBlock.DataSize = PnfHeader->InfVersionDataSize;
                        NewInf->VersionBlock.DataBlock = (PCTSTR)((PBYTE)BaseAddress +
                                                                  PnfHeader->InfVersionDataOffset);

                        NewInf->VersionBlock.FilenameSize = (lstrlen(Filename) + 1) * sizeof(TCHAR);
                        CopyMemory(NewInf->VersionBlock.Filename,
                                   Filename,
                                   NewInf->VersionBlock.FilenameSize
                                  );

                        //
                        // Fill in the OsLoaderPath field, if present in the PNF.
                        //
                        if(PnfHeader->OsLoaderPathOffset) {
                            NewInf->OsLoaderPath = (PCTSTR)((PBYTE)BaseAddress +
                                                             PnfHeader->OsLoaderPathOffset);
                        }

                        //
                        // If the INF's SourcePath is available, then use it (default
                        // to assuming local (i.e., non-internet) source location).
                        //
                        // At this point, we should only be dealing with minor version
                        // 1 or later PNFs.
                        //
                        MYASSERT(MinorVer1FieldsAvailable);

                        NewInf->InfSourceMediaType = SPOST_PATH;

                        if(PnfHeader->InfSourcePathOffset) {
                            NewInf->InfSourcePath = (PCTSTR)((PBYTE)BaseAddress +
                                                             PnfHeader->InfSourcePathOffset);
                        }

                        if(PnfHeader->Flags & PNF_FLAG_SRCPATH_IS_URL) {
                            NewInf->InfSourceMediaType = SPOST_URL;
                        }

                        //
                        // Now retrieve the INF's original filename, if present.  If
                        // this field isn't present, then the INF's current filename
                        // is assumed to be the same as its original filename (e.g.,
                        // a system-supplied INF).
                        //
                        if(PnfHeader->OriginalInfNameOffset) {
                            NewInf->OriginalInfName = (PCTSTR)((PBYTE)BaseAddress +
                                                             PnfHeader->OriginalInfNameOffset);
                        }

                        //
                        // Finally, fill in the string substitution list (if there is one).
                        //
                        if(PnfHeader->InfSubstValueCount) {
                            NewInf->SubstValueCount = PnfHeader->InfSubstValueCount;
                            NewInf->SubstValueList  = (PSTRINGSUBST_NODE)((PBYTE)BaseAddress +
                                                                PnfHeader->InfSubstValueListOffset);
                        }

                        //
                        // We have successfully loaded the PNF.
                        //
                        IsPnfFile = TRUE;
                    }
                }
            }
        }

clean1:
        if(!IsPnfFile && InfSourcePathToMigrate && MinorVer1FieldsAvailable) {
            //
            // Actually, this is a good PNF, just one that we can't use.  The
            // caller has requested that we return the original INF source path
            // location and original INF filename, so that this information can
            // be migrated to the new PNF  that will be built to replace this
            // one.
            //
#ifndef ANSI_SETUPAPI
#ifdef _X86_
            MYASSERT(OSVersionInfo.dwPlatformId == VER_PLATFORM_WIN32_NT);
            if((Flags&LDINF_FLAG_ALWAYS_GET_SRCPATH) &&
               ((PnfHeader->Flags & PNF_FLAG_16BIT_SUITE) == 0) &&
               (PnfHeader->OriginalInfNameOffset == 0) &&
               (PnfHeader->InfSourcePathOffset == 0) &&
               !pSetupInfIsFromOemLocation(Filename,TRUE)) {
                PCTSTR title;
                PCTSTR p;
                PTSTR catname = NULL;
                PSP_ALTPLATFORM_INFO_V2 pPlatform = NULL;
                DWORD FixErr;
                //
                // if we're here
                // we may need to work around a Win2k-Gold bug
                //
                // the bug is that if the timezone is changed
                // Win2k looses OriginalInfNameOffset/InfSourcePathOffset
                // which causes the INF to appear as unsigned
                // when it's really signed
                //

                //
                // get file title, of form:
                // xxxx.INF
                //
                title = pSetupGetFileTitle(Filename);

                //
                // see if it's of form OEMxxxx.INF
                //
                p = title;
                if(_wcsnicmp(p,TEXT("OEM"),3)!=0) {
                    goto clean0;
                }
                p+=3;
                if(p[0] == TEXT('.')) {
                    //
                    // OEM.xxx (we're expecting a number before '.')
                    //
                    goto clean0;
                }
                while(p[0]>=TEXT('0')&&p[0]<=TEXT('9')) {
                    p++;
                }
                if((p-title) > 7) {
                    //
                    // we're expecting no more than 4 digits
                    //
                    goto clean0;
                }
                if(_wcsicmp(p,pszInfSuffix)!=0) {
                    //
                    // not OEMnnnn.INF
                    //
                    goto clean0;
                }
                //
                // see if there's a catalog that shadows this INF
                //
                WriteLogEntry(LogContext,
                              SETUP_LOG_INFO,
                              MSG_LOG_PNF_WIN2KBUG,
                              NULL,
                              PnfFileName
                              );

                //
                // see if the INF has a catalog that validates it
                //
                if(!pSetupApplyExtension(title,pszCatSuffix,&catname)) {
                    //
                    // validate against any catalog
                    // this is safe since the INF will get checked
                    // again when saving as PNF
                    //
                    catname = NULL;
                }
                pPlatform = MyMalloc(sizeof(SP_ALTPLATFORM_INFO_V2));
                //
                // if pPlatform is NULL, we'll probably fail the other bits
                // too so bail.
                //
                if(!pPlatform) {
                    goto clean0;
                }
                ZeroMemory(pPlatform, sizeof(SP_ALTPLATFORM_INFO_V2));
                pPlatform->cbSize = sizeof(SP_ALTPLATFORM_INFO_V2);
                pPlatform->Platform = VER_PLATFORM_WIN32_NT;
                pPlatform->Flags = SP_ALTPLATFORM_FLAGS_VERSION_RANGE;
                pPlatform->MajorVersion = VER_PRODUCTMAJORVERSION;
                pPlatform->MinorVersion = VER_PRODUCTMINORVERSION;
                pPlatform->ProcessorArchitecture = PROCESSOR_ARCHITECTURE_INTEL;
                pPlatform->FirstValidatedMajorVersion = 0;
                pPlatform->FirstValidatedMinorVersion = 0;
                FixErr = _VerifyFile(
                             LogContext,
                             NULL,           // no VerifyContext to pass in
                             catname,        // eg "OEMx.CAT"
                             NULL,0,         // we're not verifying against another catalog image
                             title,          // eg "mydisk.inf"
                             Filename,       // eg "....\OEMx.INF"
                             NULL,           // return: problem info
                             NULL,           // return: problem file
                             FALSE,          // has to be FALSE because we don't have full path
                             pPlatform,      // alt platform info
                             (VERIFY_FILE_IGNORE_SELFSIGNED
                              | VERIFY_FILE_NO_DRIVERBLOCKED_CHECK),
                             NULL,           // return: catalog file, full path
                             NULL,           // return: number of catalogs considered
                             NULL,           // return: digital signer
                             NULL,           // return: signer version
                             NULL            // return: WinVerifyTrust state data
                            );
                if(catname) {
                    MyFree(catname);
                }
                if(pPlatform) {
                    MyFree(pPlatform);
                }
                if(FixErr != NO_ERROR) {
                    //
                    // failed, don't fake any information
                    //
                    goto clean0;
                }

                //
                // at this point, pretend original name was "OEM.INF"
                // and that files are located in A:\
                // we'll see at the time the inf is parsed
                // if it's signed or not
                //
                *InfSourcePathToMigrate = DuplicateString(TEXT("A:\\"));
                if(!*InfSourcePathToMigrate) {
                    goto clean0;
                }
                *InfOriginalNameToMigrate = DuplicateString(TEXT("OEM.INF"));
                if(!*InfOriginalNameToMigrate) {
                    MyFree(*InfSourcePathToMigrate);
                    *InfSourcePathToMigrate = NULL;
                    goto clean0;
                }
                *InfSourcePathToMigrateMediaType = SPOST_PATH;
                WriteLogEntry(LogContext,
                              SETUP_LOG_WARNING,
                              MSG_LOG_PNF_WIN2KBUGFIX,
                              NULL,
                              PnfFileName
                              );

                goto clean0;
            }
#endif
#endif
            if(PnfHeader->OriginalInfNameOffset) {
                *InfOriginalNameToMigrate =
                    DuplicateString((PCTSTR)((PBYTE)BaseAddress + PnfHeader->OriginalInfNameOffset));

                if(!*InfOriginalNameToMigrate) {
                    goto clean0;
                }
            }

            if(PnfHeader->InfSourcePathOffset) {

                *InfSourcePathToMigrate =
                    DuplicateString((PCTSTR)((PBYTE)BaseAddress + PnfHeader->InfSourcePathOffset));

                if(!*InfSourcePathToMigrate) {
                    goto clean0;
                }

                if(PnfHeader->Flags & PNF_FLAG_SRCPATH_IS_URL) {
                    *InfSourcePathToMigrateMediaType = SPOST_URL;
                } else {
                    *InfSourcePathToMigrateMediaType = SPOST_PATH;
                }

            } else if(PnfHeader->Flags & PNF_FLAG_SRCPATH_IS_URL) {
                //
                // No source path stored in the PNF, but the flag says it's
                // a URL, thus it came from Windows Update.
                //
                *InfSourcePathToMigrateMediaType = SPOST_URL;
            }
        }

clean0: ;   // nothing to do

    } except(EXCEPTION_EXECUTE_HANDLER) {
        //
        // Reference the NeedToDestroyLock flag here in the except clause, so that the
        // compiler won't try to re-order the code in such a way that the flag is unreliable.
        //
        NeedToDestroyLock = NeedToDestroyLock;
    }

    if(IsPnfFile) {
        *Inf = NewInf;
    } else {

        if(NewInf) {

            if(NeedToDestroyLock && LockInf(NewInf)) {
                DestroySynchronizedAccess(&(NewInf->Lock));
            }

            if(NewInf->StringTable) {
                pStringTableDestroy(NewInf->StringTable);
            }
            if(NewInf->LogContext) {
                DeleteLogContext(NewInf->LogContext);
            }

            MyTaggedFree(NewInf,MEMTAG_INF);
        }

        pSetupUnmapAndCloseFile(FileHandle, MappingHandle, BaseAddress);
    }

    return IsPnfFile;
}


DWORD
SavePnf(
    IN PCTSTR      Filename,
    IN PLOADED_INF Inf
    )
/*++

Routine Description:

    This routine attempts to write to disk a precompiled form (.PNF file) of the
    specified loaded INF descriptor (from a .INF file).

Arguments:

    Filename - specifies the fully-qualified path to the .INF textfile from which
        this INF descriptor was loaded.  A corresponding file with a .PNF extension
        will be created to store the precompiled INF into.

    Inf - supplies the address of the loaded INF descriptor to be written to disk
        as a precompiled INF file.

Return Value:

    If successful, the return value is NO_ERROR.
    If failure, the return value is a Win32 error code indicating the reason for
    failure.

--*/
{
    TCHAR PnfFilePath[MAX_PATH];
    PTSTR PnfFileName, PnfFileExt;
    HANDLE hFile;
    PNF_HEADER PnfHeader;
    DWORD Offset, BytesWritten, WinDirPathLen, SourcePathLen, OsLoaderPathLen;
    DWORD OriginalInfNameLen;
    PVOID StringTableDataBlock;
    DWORD Err;
    PSP_ALTPLATFORM_INFO_V2 ValidationPlatform;
    DWORD VerificationPolicyToUse;
    DWORD InfSigErr;

    if(GlobalSetupFlags & PSPGF_MINIMAL_EMBEDDED) {
        //
        // To minimize our footprint in certain embedded scenarios, we refrain
        // from generating PNFs.  We also assume the INF is valid...
        //
        Inf->Flags |= LIF_INF_DIGITALLY_SIGNED;

        return NO_ERROR;
    }

    lstrcpyn(PnfFilePath, Filename,SIZECHARS(PnfFilePath));

    //
    // Find the start of the filename component of the path, and then find the last
    // period (if one exists) in that filename.
    //
    PnfFileName = (PTSTR)pSetupGetFileTitle(PnfFilePath);
    if(!(PnfFileExt = _tcsrchr(PnfFileName, TEXT('.')))) {
        PnfFileExt = PnfFilePath + lstrlen(PnfFilePath);
    }

    //
    // Now create a corresponding filename with the extension '.PNF'
    //
    lstrcpyn(PnfFileExt, pszPnfSuffix, SIZECHARS(PnfFilePath) - (int)(PnfFileExt - PnfFilePath));

    //
    // NOTE: If there's already a PNF for this INF, we're going to blow it away.
    // If we encounter a failure after successfully creating the file, we're going
    // to delete the partial PNF, and there'll be no rollback to restore the old
    // PNF.  This is OK because if CreateFile succeeds, then we know we're going
    // to be able to write out the PNF barring out-of-disk-space problems.  For
    // out-of-disk-space problems, there could be one of two causes:
    //
    // 1.  The INF associated with the old PNF has gotten bigger, hence the PNF
    //     has gotten bigger.  In this case, it's desirable that we blow away
    //     the old PNF because it's invalid for the INF anyway.
    //
    // 2.  The INF is the same, but something else has changed that caused us to
    //     need to regenerate the PNF (e.g., code page changed).  Given the
    //     present information stored in PNFs, such a change would not result in
    //     a significant size difference between the old and new PNFs.  Thus, if
    //     the old PNF fit in the available disk space, then so would the new
    //     one.  If this changes in the future (e.g., storing out a new PNF can
    //     result in substantially increasing its size), then we'll need to be
    //     careful about backing up the old PNF before attempting to write out
    //     the new one, in case we need to rollback.
    //

    hFile = CreateFile(PnfFilePath,
                       GENERIC_WRITE,
                       0,
                       NULL,
                       CREATE_ALWAYS,
                       FILE_ATTRIBUTE_NORMAL,
                       NULL
                      );

    if(hFile == INVALID_HANDLE_VALUE) {
        return GetLastError();
    }

    //
    // Enclose the rest of the function in try/except, in case we hit an error while
    // writing to the file.
    //
    Err = NO_ERROR;
    ValidationPlatform = NULL;

    try {
        //
        // Initialize a PNF header structure to be written to the beginning of the file.
        //
        ZeroMemory(&PnfHeader, sizeof(PNF_HEADER));

        PnfHeader.InfStyle = Inf->Style;

#ifdef UNICODE
        PnfHeader.Flags = PNF_FLAG_IS_UNICODE;
#else
        PnfHeader.Flags = 0;
#endif
        if(Inf->HasStrings) {
            PnfHeader.Flags |= PNF_FLAG_HAS_STRINGS;
        }

        if(Inf->InfSourceMediaType == SPOST_URL) {
            PnfHeader.Flags |= PNF_FLAG_SRCPATH_IS_URL;
        }

        if(Inf->Flags & LIF_HAS_VOLATILE_DIRIDS) {
            PnfHeader.Flags |= PNF_FLAG_HAS_VOLATILE_DIRIDS;
        }

        if (Inf->Flags & LIF_OEM_F6_INF) {
            PnfHeader.Flags |= PNF_FLAG_OEM_F6_INF;
        }

        //
        // if this is NT, save product suite
        // this helps us, eg, catch migration from PER to PRO
        // so that we can refresh PNF's
        //
        if(OSVersionInfo.dwPlatformId == VER_PLATFORM_WIN32_NT) {
            PnfHeader.Flags |= (((DWORD)OSVersionInfo.wSuiteMask)<<16) | PNF_FLAG_16BIT_SUITE;
        }

        //
        // We can only verify the digital signature of an INF file
        // after the crypto DLLs have been registered.
        //
        if(!(GlobalSetupFlags & PSPGF_NO_VERIFY_INF)) {

            TCHAR CatalogName[MAX_PATH];
            TCHAR FullCatalogPath[MAX_PATH];
            PTSTR p;

            FullCatalogPath[0] = TEXT('\0');

            //
            // If this INF does not live in %windir%\inf, or specifies a
            // CatalogFile= entry, then we don't want to do global validataion.
            // In these cases, we want to validate against the CatalogFile=
            // catalog.
            //
            // Note that if there is no CatalogFile= then FullCatalogPath[0]
            // will still be set to TEXT('\0') which will cause us to do global
            // validataion.
            //
            if(pSetupGetCatalogFileValue(&(Inf->VersionBlock),
                                         CatalogName,
                                         SIZECHARS(CatalogName),
                                         NULL) &&
               (CatalogName[0] != TEXT('\0'))) {

                //
                // The INF specified a CatalogFile= entry.  If the INF is in
                // a 3rd-party location (i.e., not in %windir%\Inf, then we'll
                // use the full path to the catalog (it must be located in the
                // same directory as the INF).  If the INF is in %windir%\Inf,
                // then we will look for an installed catalog having the same
                // primary filename as the INF, with an extension of ".CAT".
                //
                if(pSetupInfIsFromOemLocation(Filename, TRUE)) {
                    //
                    // Construct full path to the catalog based on the location
                    // of the INF.
                    //
                    lstrcpyn(FullCatalogPath, Filename, SIZECHARS(FullCatalogPath));

                    p = (PTSTR)pSetupGetFileTitle(FullCatalogPath);

                    lstrcpyn(p,
                             CatalogName,
                             (int)(SIZECHARS(FullCatalogPath) - (p - FullCatalogPath))
                            );

                } else {
                    //
                    // Construct simple filename of catalog based on INF's name
                    // (with .CAT extension)
                    //
                    lstrcpyn(FullCatalogPath,
                             pSetupGetFileTitle(Filename),
                             SIZECHARS(FullCatalogPath)
                            );

                    p = _tcsrchr(FullCatalogPath, TEXT('.'));
                    if(!p) {
                        //
                        // Should never happen, but if our INF file has no
                        // extension, simply append ".CAT".
                        //
                        p = FullCatalogPath + lstrlen(FullCatalogPath);
                    }

                    lstrcpyn(p,
                             pszCatSuffix,
                             (int)(SIZECHARS(FullCatalogPath) - (p - FullCatalogPath))
                            );
                }
            }

            //
            // Check if the INF digitally signed
            //
            IsInfForDeviceInstall(NULL,
                                  NULL,
                                  Inf,
                                  NULL,
                                  &ValidationPlatform,
                                  &VerificationPolicyToUse,
                                  NULL,
                                  FALSE
                                 );

            InfSigErr = _VerifyFile(NULL,
                                    NULL,
                                    (*FullCatalogPath ? FullCatalogPath : NULL),
                                    NULL,
                                    0,
                                    (Inf->OriginalInfName
                                        ? Inf->OriginalInfName
                                        : pSetupGetFileTitle(Filename)),
                                    Filename,
                                    NULL,
                                    NULL,
                                    FALSE,
                                    ValidationPlatform,
                                    (VERIFY_FILE_IGNORE_SELFSIGNED
                                     | VERIFY_FILE_NO_DRIVERBLOCKED_CHECK),
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL
                                   );

            if(InfSigErr == NO_ERROR) {

                PnfHeader.Flags |= PNF_FLAG_INF_DIGITALLY_SIGNED;
                Inf->Flags |= LIF_INF_DIGITALLY_SIGNED;

            } else if((InfSigErr != ERROR_SIGNATURE_OSATTRIBUTE_MISMATCH) &&
                      *FullCatalogPath &&
                      (VerificationPolicyToUse & DRIVERSIGN_ALLOW_AUTHENTICODE)) {
                //
                // We failed to verify using standard driver signing policy
                // (and the failure wasn't due to an invalid osattribute).  We
                // can fallback to Authenticode signatures for this INF, so
                // check for that now...
                //
                InfSigErr = _VerifyFile(NULL,
                                        NULL,
                                        FullCatalogPath,
                                        NULL,
                                        0,
                                        (Inf->OriginalInfName
                                            ? Inf->OriginalInfName
                                            : pSetupGetFileTitle(Filename)),
                                        Filename,
                                        NULL,
                                        NULL,
                                        FALSE,
                                        ValidationPlatform,
                                        (VERIFY_FILE_IGNORE_SELFSIGNED
                                         | VERIFY_FILE_NO_DRIVERBLOCKED_CHECK
                                         | VERIFY_FILE_USE_AUTHENTICODE_CATALOG),
                                        NULL,
                                        NULL,
                                        NULL,
                                        NULL,
                                        NULL
                                       );

                if((InfSigErr == ERROR_AUTHENTICODE_TRUSTED_PUBLISHER) ||
                   (InfSigErr == ERROR_AUTHENTICODE_TRUST_NOT_ESTABLISHED)) {
                    //
                    // For the purposes of setting the "INF is signed" flag in
                    // the PNF, we don't care whether or not we've established
                    // that the user trusts the publisher.  That will be taken
                    // care of later, if the user ever attempts to perform a
                    // device install using this INF.
                    //
                    PnfHeader.Flags |= (PNF_FLAG_INF_DIGITALLY_SIGNED |
                                        PNF_FLAG_INF_AUTHENTICODE_SIGNED);
                    Inf->Flags |= (LIF_INF_DIGITALLY_SIGNED |
                                   LIF_INF_AUTHENTICODE_SIGNED);
                }
            }

            PnfHeader.Flags |= PNF_FLAG_INF_VERIFIED;
        }

        PnfHeader.Version = MAKEWORD(PNF_MINOR_VERSION, PNF_MAJOR_VERSION);

        PnfHeader.StringTableHashBucketCount = HASH_BUCKET_COUNT;

        PnfHeader.LanguageId = (WORD)(Inf->LanguageId);

        //
        // The Windows directory path is the first data block after the header.
        //
        Offset = PNF_ALIGN_BLOCK(sizeof(PNF_HEADER));
        PnfHeader.WinDirPathOffset = Offset;
        WinDirPathLen = (lstrlen(WindowsDirectory) + 1) * sizeof(TCHAR);

        //
        // The (optional) OsLoader directory path is the second data block.
        //
        Offset += PNF_ALIGN_BLOCK(WinDirPathLen);
        if(Inf->OsLoaderPath) {
            PnfHeader.OsLoaderPathOffset = Offset;
            OsLoaderPathLen = (lstrlen(Inf->OsLoaderPath) + 1) * sizeof(TCHAR);
        } else {
            OsLoaderPathLen = 0;
        }

        //
        // The string table is the third data block...
        //
        Offset += PNF_ALIGN_BLOCK(OsLoaderPathLen);
        PnfHeader.StringTableBlockOffset = Offset;
        PnfHeader.StringTableBlockSize   = pStringTableGetDataBlock(Inf->StringTable, &StringTableDataBlock);

        //
        // Next comes the version block...
        //
        Offset += PNF_ALIGN_BLOCK(PnfHeader.StringTableBlockSize);
        PnfHeader.InfVersionDataOffset    = Offset;
        PnfHeader.InfVersionDatumCount    = Inf->VersionBlock.DatumCount;
        PnfHeader.InfVersionDataSize      = Inf->VersionBlock.DataSize;
        PnfHeader.InfVersionLastWriteTime = Inf->VersionBlock.LastWriteTime;

        //
        // then, the section block...
        //
        Offset += PNF_ALIGN_BLOCK(PnfHeader.InfVersionDataSize);
        PnfHeader.InfSectionBlockOffset = Offset;
        PnfHeader.InfSectionCount = Inf->SectionCount;
        PnfHeader.InfSectionBlockSize = Inf->SectionBlockSizeBytes;

        //
        // followed by the line block...
        //
        Offset += PNF_ALIGN_BLOCK(PnfHeader.InfSectionBlockSize);
        PnfHeader.InfLineBlockOffset = Offset;
        PnfHeader.InfLineBlockSize = Inf->LineBlockSizeBytes;

        //
        // and the value block...
        //
        Offset += PNF_ALIGN_BLOCK(PnfHeader.InfLineBlockSize);
        PnfHeader.InfValueBlockOffset = Offset;
        PnfHeader.InfValueBlockSize = Inf->ValueBlockSizeBytes;

        //
        // then the INF source path (if there is one)...
        //
        Offset += PNF_ALIGN_BLOCK(PnfHeader.InfValueBlockSize);
        if(Inf->InfSourcePath) {
            PnfHeader.InfSourcePathOffset = Offset;
            SourcePathLen = (lstrlen(Inf->InfSourcePath) + 1) * sizeof(TCHAR);
            Offset += PNF_ALIGN_BLOCK(SourcePathLen);
        } else {
            PnfHeader.InfSourcePathOffset = 0;
        }

        //
        // followed by the original INF's filename (if supplied, this indicates
        // the INF originally had a different name prior to being copied into
        // the current location)...
        //
        if(Inf->OriginalInfName) {
            PnfHeader.OriginalInfNameOffset = Offset;
            OriginalInfNameLen = (lstrlen(Inf->OriginalInfName) + 1) * sizeof(TCHAR);
            Offset += PNF_ALIGN_BLOCK(OriginalInfNameLen);
        } else {
            PnfHeader.OriginalInfNameOffset = 0;
        }

        //
        // and finally, the string substitution block (if there is one).
        //
        if(PnfHeader.InfSubstValueCount = Inf->SubstValueCount) {
            PnfHeader.InfSubstValueListOffset = Offset;
        } else {
            PnfHeader.InfSubstValueListOffset = 0;
        }

        //
        // Now write out all the blocks.
        //
        Offset = 0;

        if(!WriteFile(hFile, &PnfHeader, sizeof(PnfHeader), &BytesWritten, NULL)) {
            Err = GetLastError();
            goto clean0;
        }

        MYASSERT(BytesWritten == sizeof(PnfHeader));
        Offset += BytesWritten;

        if(AlignForNextBlock(hFile, PnfHeader.WinDirPathOffset - Offset)) {
            Offset = PnfHeader.WinDirPathOffset;
        } else {
            Err = GetLastError();
            goto clean0;
        }

        if(!WriteFile(hFile, WindowsDirectory, WinDirPathLen, &BytesWritten, NULL)) {
            Err = GetLastError();
            goto clean0;
        }

        MYASSERT(BytesWritten == WinDirPathLen);
        Offset += BytesWritten;

        if(Inf->OsLoaderPath) {

            if(AlignForNextBlock(hFile, PnfHeader.OsLoaderPathOffset - Offset)) {
                Offset = PnfHeader.OsLoaderPathOffset;
            } else {
                Err = GetLastError();
                goto clean0;
            }

            if(!WriteFile(hFile, Inf->OsLoaderPath, OsLoaderPathLen, &BytesWritten, NULL)) {
                Err = GetLastError();
                goto clean0;
            }

            MYASSERT(BytesWritten == OsLoaderPathLen);
            Offset += BytesWritten;
        }

        if(AlignForNextBlock(hFile, PnfHeader.StringTableBlockOffset - Offset)) {
            Offset = PnfHeader.StringTableBlockOffset;
        } else {
            Err = GetLastError();
            goto clean0;
        }

        if(!WriteFile(hFile, StringTableDataBlock, PnfHeader.StringTableBlockSize, &BytesWritten, NULL)) {
            Err = GetLastError();
            goto clean0;
        }

        MYASSERT(BytesWritten == PnfHeader.StringTableBlockSize);
        Offset += BytesWritten;

        if(AlignForNextBlock(hFile, PnfHeader.InfVersionDataOffset - Offset)) {
            Offset = PnfHeader.InfVersionDataOffset;
        } else {
            Err = GetLastError();
            goto clean0;
        }

        if(!WriteFile(hFile, Inf->VersionBlock.DataBlock, PnfHeader.InfVersionDataSize, &BytesWritten, NULL)) {
            Err = GetLastError();
            goto clean0;
        }

        MYASSERT(BytesWritten == PnfHeader.InfVersionDataSize);
        Offset += BytesWritten;

        if(AlignForNextBlock(hFile, PnfHeader.InfSectionBlockOffset - Offset)) {
            Offset = PnfHeader.InfSectionBlockOffset;
        } else {
            Err = GetLastError();
            goto clean0;
        }

        if(!WriteFile(hFile, Inf->SectionBlock, PnfHeader.InfSectionBlockSize, &BytesWritten, NULL)) {
            Err = GetLastError();
            goto clean0;
        }

        MYASSERT(BytesWritten == PnfHeader.InfSectionBlockSize);
        Offset += BytesWritten;

        if(AlignForNextBlock(hFile, PnfHeader.InfLineBlockOffset - Offset)) {
            Offset = PnfHeader.InfLineBlockOffset;
        } else {
            Err = GetLastError();
            goto clean0;
        }

        if(!WriteFile(hFile, Inf->LineBlock, PnfHeader.InfLineBlockSize, &BytesWritten, NULL)) {
            Err = GetLastError();
            goto clean0;
        }

        MYASSERT(BytesWritten == PnfHeader.InfLineBlockSize);
        Offset += BytesWritten;

        if(AlignForNextBlock(hFile, PnfHeader.InfValueBlockOffset - Offset)) {
            Offset = PnfHeader.InfValueBlockOffset;
        } else {
            Err = GetLastError();
            goto clean0;
        }

        if(!WriteFile(hFile, Inf->ValueBlock, PnfHeader.InfValueBlockSize, &BytesWritten, NULL)) {
            Err = GetLastError();
            goto clean0;
        }

        MYASSERT(BytesWritten == PnfHeader.InfValueBlockSize);
        Offset += BytesWritten;

        if(Inf->InfSourcePath) {

            if(AlignForNextBlock(hFile, PnfHeader.InfSourcePathOffset - Offset)) {
                Offset = PnfHeader.InfSourcePathOffset;
            } else {
                Err = GetLastError();
                goto clean0;
            }

            if(!WriteFile(hFile, Inf->InfSourcePath, SourcePathLen, &BytesWritten, NULL)) {
                Err = GetLastError();
                goto clean0;
            }

            MYASSERT(BytesWritten == SourcePathLen);
            Offset += BytesWritten;
        }

        if(Inf->OriginalInfName) {

            if(AlignForNextBlock(hFile, PnfHeader.OriginalInfNameOffset - Offset)) {
                Offset = PnfHeader.OriginalInfNameOffset;
            } else {
                Err = GetLastError();
                goto clean0;
            }

            if(!WriteFile(hFile, Inf->OriginalInfName, OriginalInfNameLen, &BytesWritten, NULL)) {
                Err = GetLastError();
                goto clean0;
            }

            MYASSERT(BytesWritten == OriginalInfNameLen);
            Offset += BytesWritten;
        }

        if(PnfHeader.InfSubstValueCount) {

            if(!AlignForNextBlock(hFile, PnfHeader.InfSubstValueListOffset - Offset)) {
                Err = GetLastError();
                goto clean0;
            }

            if(!WriteFile(hFile,
                          Inf->SubstValueList,
                          PnfHeader.InfSubstValueCount * sizeof(STRINGSUBST_NODE),
                          &BytesWritten,
                          NULL)) {

                Err = GetLastError();
                goto clean0;
            }

            MYASSERT(BytesWritten == PnfHeader.InfSubstValueCount * sizeof(STRINGSUBST_NODE));
        }

clean0: ; // nothing to do

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_DATA;
    }

    CloseHandle(hFile);

    if(ValidationPlatform) {
        MyFree(ValidationPlatform);
    }

    if(Err != NO_ERROR) {
        //
        // Something went wrong--get rid of the file.
        //
        DeleteFile(PnfFilePath);
    }

    return Err;
}


BOOL
AddUnresolvedSubstToList(
    IN PLOADED_INF Inf,
    IN UINT        ValueOffset,
    IN BOOL        CaseSensitive
    )
/*++

Routine Description:

    This routine adds a new STRINGSUBST_NODE to the array stored in the specified INF.
    The entries in this array are used later to quickly locate all values that have
    unresolved string substitutions in them (i.e., for subsequent user-defined DIRID
    replacement).

Arguments:

    Inf - Specifies the INF containing the string value to be added to the unresolved
        substitutions list.

    ValueOffset - Specifies the offset within the INF's value block of the unresolved
        string value.

Return Value:

    If the new element was successfully added to the array, the return value is TRUE.
    If the routine failed (due to an out-of-memory error), the return value is FALSE.

--*/
{
    PSTRINGSUBST_NODE p;

    //
    // Grow the array to accommodate the new element.
    //
    if(Inf->SubstValueList) {
        p = MyRealloc(Inf->SubstValueList, (Inf->SubstValueCount + 1) * sizeof(STRINGSUBST_NODE));
    } else {
        MYASSERT(!(Inf->SubstValueCount));
        p = MyMalloc(sizeof(STRINGSUBST_NODE));
    }

    if(!p) {
        return FALSE;
    }

    //
    // Now, we must check to see if the ValueOffset currently being inserted is the same
    // as the entry on the end of the list.  This will be the case if we're dealing with
    // a line key, or a single-value line, since we first add the value case-sensitively,
    // then add the value again case-insensitively for look-up, and insert it in front
    // of the case-sensitive form.
    //
    if(Inf->SubstValueCount &&
       (ValueOffset == p[Inf->SubstValueCount - 1].ValueOffset)) {
        //
        // The value offsets are the same.  Increment the value offset for the value
        // currently at the end of the list, before adding the new value.
        //
        p[Inf->SubstValueCount - 1].ValueOffset++;
    }

    p[Inf->SubstValueCount].ValueOffset = ValueOffset;
    p[Inf->SubstValueCount].TemplateStringId = Inf->ValueBlock[ValueOffset];
    p[Inf->SubstValueCount].CaseSensitive = CaseSensitive;

    //
    // Store the new array size and pointer back in the INF, and return success.
    //
    Inf->SubstValueList = p;
    Inf->SubstValueCount++;

    return TRUE;
}


DWORD
ApplyNewVolatileDirIdsToInfs(
    IN PLOADED_INF MasterInf,
    IN PLOADED_INF Inf        OPTIONAL
    )
/*++

Routine Description:

    This routine processes either a single INF, or each loaded INF in the
    linked list, applying volatile system or user-defined DIRID mappings to each
    value containing unresolved string substitutions.

    THIS ROUTINE DOES NOT DO INF LOCKING--CALLER MUST DO IT!

Arguments:

    MasterInf - Supplies a pointer to the head of a linked list of loaded inf
        structures.  This 'master' node contains the user-defined DIRID
        mappings for this set of INFs.  If the 'Inf' parameter is not specified,
        then each INF in this linked list is processed.

    Inf - Optionally, supplies a pointer to a single INF within the MasterInf list
        to be processed.  If this parameter is not specified, then all INFs in
        the list are processed.

Return Value:

    If success, the return value is NO_ERROR.
    If failure, the return value is a Win32 error code.

--*/
{
    PLOADED_INF CurInf, WriteableInf;
    UINT UserDirIdCount;
    PUSERDIRID UserDirIds;
    DWORD i;
    PCTSTR TemplateString;
    PPARSE_CONTEXT ParseContext = NULL;
    DWORD UnresolvedSubst;
    LONG NewStringId;

    UserDirIdCount = MasterInf->UserDirIdList.UserDirIdCount;
    UserDirIds     = MasterInf->UserDirIdList.UserDirIds;

    for(CurInf = Inf ? Inf : MasterInf;
        CurInf;
        CurInf = Inf ? NULL : CurInf->Next) {
        //
        // Nothing to do if there are no unresolved string substitutions.
        //
        if(!(CurInf->SubstValueCount)) {
            continue;
        }

        //
        // If this is a PNF, then we must move it into writeable memory before
        // we do the string substitutions.
        //
        if(CurInf->FileHandle != INVALID_HANDLE_VALUE) {

            if(!(WriteableInf = DuplicateLoadedInfDescriptor(CurInf))) {
                if(ParseContext) {
                    MyFree(ParseContext);
                }
                return ERROR_NOT_ENOUGH_MEMORY;
            }

            //
            // Replace the contents of the PNF in the linked list with that of our
            // new writeable INF.
            //
            ReplaceLoadedInfDescriptor(CurInf, WriteableInf);
        }

        //
        // There are one or more unresolved string substitutions in this INF.
        // Process each one.
        //
        for(i = 0; i < CurInf->SubstValueCount; i++) {
            //
            // Retrieve the original (template) string for this value.
            //
            TemplateString = pStringTableStringFromId(CurInf->StringTable,
                                                      CurInf->SubstValueList[i].TemplateStringId
                                                     );
            MYASSERT(TemplateString);

            //
            // Build a partial parse context structure to pass into ProcessForSubstitutions().
            //
            if(!ParseContext) {
                ParseContext = MyMalloc(sizeof(PARSE_CONTEXT));
                if(!ParseContext) {
                    return ERROR_NOT_ENOUGH_MEMORY;
                }
                ZeroMemory(ParseContext,sizeof(PARSE_CONTEXT));
            }

            ParseContext->DoVolatileDirIds = TRUE;
            ParseContext->Inf = MasterInf;
            //
            // None of the other fields are used in this case--don't bother initializing them.
            //
            ProcessForSubstitutions(ParseContext, TemplateString, &UnresolvedSubst);

            NewStringId = pStringTableAddString(CurInf->StringTable,
                                                ParseContext->TemporaryString,
                                                STRTAB_BUFFER_WRITEABLE | (CurInf->SubstValueList[i].CaseSensitive
                                                                                ? STRTAB_CASE_SENSITIVE
                                                                                : STRTAB_CASE_INSENSITIVE),
                                                NULL,0
                                               );
            if(NewStringId == -1) {
                //
                // We failed because of an out-of-memory condition.  Aborting now means that the
                // INF may have some of its unresolved strings fixed up, while others haven't yet
                // been processed.  Oh well...
                //
                MyFree(ParseContext);
                return ERROR_NOT_ENOUGH_MEMORY;
            }

            //
            // Replace the string ID at the value offset with the new one we just computed.
            //
            CurInf->ValueBlock[CurInf->SubstValueList[i].ValueOffset] = NewStringId;
        }
    }
    if(ParseContext) {
        MyFree(ParseContext);
    }

    return NO_ERROR;
}


BOOL
AlignForNextBlock(
    IN HANDLE hFile,
    IN DWORD  ByteCount
    )
/*++

Routine Description:

    This routine writes out the requested number of zero bytes into the specified
    file.

Arguments:

    hFile - Supplies a handle to the file where the zero-valued bytes are to be
        written.

    ByteCount - Specifies the number of zero-valued bytes to write to the file.

Return Value:

    If success, the return value is TRUE.
    If failure, the return value is FALSE.  Call GetLastError() to retrieve a
    Win32 error code indicating the cause of the failure.

--*/
{
    DWORD i, BytesWritten;
    BYTE byte = 0;

    MYASSERT(ByteCount < PNF_ALIGNMENT);

    for(i = 0; i < ByteCount; i++) {
        if(!WriteFile(hFile, &byte, sizeof(byte), &BytesWritten, NULL)) {
            //
            // LastError already set.
            //
            return FALSE;
        }
        MYASSERT(BytesWritten == sizeof(byte));
    }

    return TRUE;
}


DWORD
pSetupGetOsLoaderDriveAndPath(
    IN  BOOL   RootOnly,
    OUT PTSTR  CallerBuffer,
    IN  DWORD  CallerBufferSize,
    OUT PDWORD RequiredSize      OPTIONAL
    )
/*++

Routine Description:

    This routine retrieves the current path for the system partition root/OsLoader directory
    (from the registry).

Arguments:

    RootOnly - if TRUE, then only the system partition root is returned (e.g., "C:\")

    CallerBuffer - supplies a character buffer that receives the requested path

    CallerBufferSize - supplies the size, in characters of the CallerBuffer

    RequiredSize - optionally, supplies the address of a variable that receives the
        number of characters required to store the requested path string (including
        terminating NULL).

Return Value:

    If success, the return value is NO_ERROR.
    If failure, the return value is ERROR_INSUFFICIENT_BUFFER.

--*/
{
    HKEY hKey;
    TCHAR CharBuffer[MAX_PATH];
    PTSTR Buffer = NULL;
    DWORD DataLen;
    DWORD Type;
    LONG Err;


    CopyMemory(CharBuffer,
               pszPathSetup,
               sizeof(pszPathSetup) - sizeof(TCHAR)
              );
    CopyMemory((PBYTE)CharBuffer + (sizeof(pszPathSetup) - sizeof(TCHAR)),
               pszKeySetup,
               sizeof(pszKeySetup)
              );

    if((Err = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                           CharBuffer,
                           0,
                           KEY_READ,
                           &hKey)) == ERROR_SUCCESS) {
        Err = QueryRegistryValue(hKey,pszBootDir,&Buffer,&Type,&DataLen);
        if(Err == NO_ERROR) {
            lstrcpyn(CharBuffer,Buffer,SIZECHARS(CharBuffer));
            MyFree(Buffer);
        }
        RegCloseKey(hKey);
    }

    if(Err != ERROR_SUCCESS) {
#ifdef UNICODE
        //
        // If we couldn't retrieve the 'BootDir' value, resort to using the
        // OsSystemPartitionRoot
        //
        // root path is \\?\GLOBALROOT\<SystemPartition> not <BootDir>
        // can't make assumption about BootDir
        // so fail if we don't have that information
        //
        if(!OsSystemPartitionRoot) {
            //
            // if this is NULL at this point, we can't support this call
            // most likely due to out of memory condition, so report as such
            //
            return ERROR_OUTOFMEMORY;
        }
        lstrcpyn(CharBuffer,OsSystemPartitionRoot,SIZECHARS(CharBuffer));
#else
        //
        // If we couldn't retrieve the 'BootDir' value, drop back to default of "C:\".
        //
        lstrcpyn(CharBuffer,pszDefaultSystemPartition,SIZECHARS(CharBuffer));
#endif
        Err = NO_ERROR;
    }

    //
    // If there is an OsLoader relative path, then concatenate it to our root path.
    //
    if(!RootOnly && OsLoaderRelativePath) {
        pSetupConcatenatePaths(CharBuffer, OsLoaderRelativePath, SIZECHARS(CharBuffer), &DataLen);
    } else {
        DataLen = lstrlen(CharBuffer)+1;
    }

    if(RequiredSize) {
        *RequiredSize = DataLen;
    }

    if(CallerBufferSize < DataLen) {
        return ERROR_INSUFFICIENT_BUFFER;
    }

    CopyMemory(CallerBuffer, CharBuffer, DataLen * sizeof(TCHAR));

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\setupapi\logapi.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    logapi.c

Abstract:

    Public exposure of an error logging API, based on windows\setup\setuplog.

Author:

    Jim Schmidt (jimschm) 28-Apr-1997

Revision History:

    jimschm     16-Dec-1998     Added UseCountCs (duh!!)

--*/

#include "precomp.h"

#include <setuplog.h>

SETUPLOG_CONTEXT LogContext;
INT UseCount;

#define MAX_STRING_RESOURCE   0x08000



//
// NOTE: Watch the case.  We expose an API named SetupLogError, which is different than
//       the lib-based SetuplogError function.
//


LPSTR
pUnicodeToAnsiForDisplay (
    PCWSTR UnicodeStr
    )
{
    INT Len;
    LPSTR AnsiBuffer;
    CHAR CodePage[32];
    DWORD rc;

    //
    // Allocate buffer to be freed by caller
    //

    Len = (lstrlenW (UnicodeStr) + 1) * sizeof (WCHAR);

    AnsiBuffer = (LPSTR) MyMalloc (Len);
    if (!AnsiBuffer) {
        SetLastError (ERROR_NOT_ENOUGH_MEMORY);
        return NULL;
    }

    //
    // Convert to UNICODE based on thread's Locale; convert assuming string
    // is for display purposes
    //

    if (!GetLocaleInfoA (GetThreadLocale(), LOCALE_IDEFAULTANSICODEPAGE, CodePage, 32)) {
        MyFree (AnsiBuffer);
        return NULL;
    }

    rc = WideCharToMultiByte (
            atoi (CodePage),
            WC_COMPOSITECHECK|WC_DISCARDNS,
            UnicodeStr,
            -1,
            AnsiBuffer,
            Len,
            NULL,
            NULL
            );

    if (rc == 0) {
        MyFree (AnsiBuffer);
        return NULL;
    }

    return AnsiBuffer;
}


PWSTR
pAnsiToUnicodeForDisplay (
    LPCSTR AnsiStr
    )
{
    INT Len;
    LPWSTR UnicodeBuffer;
    CHAR CodePage[32];
    DWORD rc;

    //
    // Allocate buffer to be freed by caller
    //

    Len = (lstrlenA (AnsiStr) + 1) * sizeof (WCHAR);

    UnicodeBuffer = (LPWSTR) MyMalloc (Len);
    if (!UnicodeBuffer) {
        SetLastError (ERROR_NOT_ENOUGH_MEMORY);
        return NULL;
    }

    //
    // Convert to UNICODE based on thread's Locale
    //

    if (!GetLocaleInfoA (GetThreadLocale(), LOCALE_IDEFAULTANSICODEPAGE, CodePage, 32)) {
        MyFree (UnicodeBuffer);
        return NULL;
    }

    rc = MultiByteToWideChar (
            atoi (CodePage),
            MB_USEGLYPHCHARS,
            AnsiStr,
            -1,
            UnicodeBuffer,
            Len
            );

    if (rc == 0) {
        MyFree (UnicodeBuffer);
        return NULL;
    }

    return UnicodeBuffer;
}


PVOID
pOpenFileCallback (
    IN  LPCTSTR  Filename,
    IN  BOOL     WipeLogFile
    )

/*++

Routine Description:

    Opens the log and optionally overwrites an existing copy.

Arguments:

    FileName    - Specifies the name of the file to open or create

    WipeLogFile - TRUE if an existing log should be overwritten, FALSE if
                  it should be appended

Return Value:

    Pointer to the file handle.

--*/


{
    TCHAR   CompleteFilename[MAX_PATH];
    HANDLE  hFile;

    //
    // Form the pathname of the logfile. (uses real Windows directory)
    //
    lstrcpyn(CompleteFilename,WindowsDirectory,SIZECHARS(CompleteFilename));
    if (!pSetupConcatenatePaths (CompleteFilename, Filename, SIZECHARS(CompleteFilename), NULL)) {
        return NULL;
    }

    //
    // If we're wiping the logfile clean, attempt to delete
    // what's there.
    //
    if(WipeLogFile) {
        SetFileAttributes (CompleteFilename, FILE_ATTRIBUTE_NORMAL);
        DeleteFile (CompleteFilename);
    }

    //
    // Open existing file or create a new one.
    //
    hFile = CreateFile (
        CompleteFilename,
        GENERIC_READ | GENERIC_WRITE,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        NULL,
        OPEN_ALWAYS,
        FILE_ATTRIBUTE_NORMAL,
        NULL
        );

    return (PVOID)hFile;
}


static
BOOL
pWriteFile (
    IN  PVOID   LogFile,
    IN  LPCTSTR Buffer
    )

/*++

Routine Description:

    Writes an entry to the Setup Error Log by converting string to ANSI and
    calling WriteFile.  The message is appended to the log.

Arguments:

    LogFile  - The handle to an open log file
    Buffer   - The UNICODE message to write

Return Value:

    Boolean indicating whether the operation was successful.  Error code is set
    to a Win32 error code if the return value is FALSE.

--*/


{
    PCSTR   AnsiBuffer;
    BOOL    Status;
    DWORD   DontCare;

    if (0xffffffff == SetFilePointer (LogFile, 0, NULL, FILE_END)) {
        return FALSE;
    }

#ifdef UNICODE

    //
    // Convert to ANSI for file output
    //

    if (AnsiBuffer = pUnicodeToAnsiForDisplay (Buffer)) {
        Status = WriteFile (
                    LogFile,
                    AnsiBuffer,
                    lstrlenA (AnsiBuffer),
                    &DontCare,
                    NULL
                    );
        MyFree (AnsiBuffer);
    } else {
        Status = FALSE;
    }

#else

    Status = WriteFile (
                LogFile,
                Buffer,
                lstrlen (Buffer),
                &DontCare,
                NULL
                );

#endif

    if (Status) {
        FlushFileBuffers (LogFile);
    }

    return Status;

}


static
LPTSTR
pFormatLogMessage (
    IN LPCTSTR   MessageString,
    IN UINT      MessageId,      OPTIONAL
    IN va_list * ArgumentList
    )

/*++

Routine Description:

    Format a message string using a message string and caller-supplied
    arguments.

    This routine supports only MessageIds that are Win32 error codes.  It
    does not support messages for string resources.

Arguments:

    MessageString - Supplies the message text.  For logapi.c, this should
                    always be non-NULL.

    MessageId - Supplies a Win32 error code, or 0 if MessageString is to be
                used.

    ArgumentList - supplies arguments to be inserted in the message text.

Return Value:

    Pointer to buffer containing formatted message. If the message was not found
    or some error occurred retrieving it, this buffer will bne empty.

    Caller can free the buffer with MyFree().

    If NULL is returned, out of memory.

--*/

{
    DWORD d;
    LPTSTR Buffer;
    LPTSTR Message;
    TCHAR  ModuleName[MAX_PATH];
    TCHAR  ErrorNumber[24];
    LPTSTR Args[2];

    if (MessageString > (LPCTSTR) SETUPLOG_USE_MESSAGEID) {
        d = FormatMessage (
                FORMAT_MESSAGE_ALLOCATE_BUFFER|FORMAT_MESSAGE_FROM_STRING,
                MessageString,
                0,
                0,
                (LPTSTR) &Buffer,
                0,
                ArgumentList
                );
    } else {
        d = FormatMessage (
                FORMAT_MESSAGE_ALLOCATE_BUFFER |
                    ((MessageId < MSG_FIRST) ? FORMAT_MESSAGE_FROM_SYSTEM : FORMAT_MESSAGE_FROM_HMODULE),
                (PVOID) GetModuleHandle (NULL),
                MessageId,
                MAKELANGID (LANG_NEUTRAL,SUBLANG_NEUTRAL),
                (LPTSTR) &Buffer,
                0,
                ArgumentList
                );
    }


    if(!d) {
        //
        // Give up.
        //
        return NULL;
    }

    //
    // Make duplicate using our memory system so user can free with MyFree().
    //
    Message = DuplicateString (Buffer);

    LocalFree ((HLOCAL) Buffer);

    return Message;
}


static
BOOL
pAcquireMutex (
    IN  PVOID   Mutex
    )

/*++

Routine Description:

    Waits on the log mutex for a max of 1 second, and returns TRUE if the mutex
    was claimed, or FALSE if the claim timed out.

Arguments:

    Mutex - specifies which mutex to acquire.

Return Value:

    TRUE if the mutex was claimed, or FALSE if the claim timed out.

--*/


{
    DWORD rc;

    if (!Mutex) {
        SetLastError (ERROR_INVALID_HANDLE);
        return FALSE;
    }

    // Wait a max of 1 second for the mutex
    rc = WaitForSingleObject (Mutex, 1000);
    if (rc != WAIT_OBJECT_0) {
        SetLastError (ERROR_EXCL_SEM_ALREADY_OWNED);
        return FALSE;
    }

    return TRUE;
}



BOOL
WINAPI
SetupOpenLog (
    BOOL Erase
    )

/*++

Routine Description:

    Opens the log for processing.  Must be called before SetupLogError is called.
    A use count is maintained so a single process can call SetupOpenLog and
    SetupCloseLog from multiple threads.

Arguments:

    Erase - TRUE to erase an existing log, or FALSE to append to an existing log

Return Value:

    Boolean indicating whether the operation was successful.  Error code is set
    to a Win32 error code if the return value is FALSE.

--*/

{
    BOOL b = TRUE;
    INT i;
    DWORD rc;
    BOOL locked = FALSE;


    __try {
        EnterCriticalSection (&LogUseCountCs);
        locked = TRUE;
        //
        // Perform initialization of log APIs
        //

        if (!UseCount) {
            LogContext.OpenFile  = (PSPLOG_OPENFILE_ROUTINE) pOpenFileCallback;
            LogContext.CloseFile = CloseHandle;
            LogContext.AllocMem  = pSetupMalloc;
            LogContext.FreeMem   = pSetupFree;
            LogContext.Format    = (PSPLOG_FORMAT_ROUTINE) pFormatLogMessage;
            LogContext.Write     = (PSPLOG_WRITE_ROUTINE) pWriteFile;
            LogContext.Lock      = pAcquireMutex;
            LogContext.Unlock    = ReleaseMutex;

            LogContext.Mutex = CreateMutexW(NULL,FALSE,L"SetuplogMutex");

            for (i = 0 ; i < LogSevMaximum ; i++) {
                LogContext.SeverityDescriptions[i] = MyLoadString (IDS_LOGSEVINFORMATION + i);
            }

            //
            // We don't want to allow anyone to erase the existing log, so we just
            // ignore the value of Erase and always append to the log.
            //
            b = SetuplogInitialize (&LogContext, FALSE);
            rc = GetLastError();

        } else {
            rc = ERROR_ALREADY_INITIALIZED;
        }

        UseCount++;
    }
    __finally {
        //
        // Clean up and exit
        //

        if (!b) {
            SetupCloseLog();
        }

        SetLastError (rc);
        if(locked) {
            LeaveCriticalSection (&LogUseCountCs);
        }
    }

    return b;
}


VOID
WINAPI
SetupCloseLog (
    VOID
    )

/*++

Routine Description:

    Cleans up all resources associated with the log

Arguments:

    none

Return Value:

    none

--*/


{
    INT i;
    BOOL locked=FALSE;


    __try {
        EnterCriticalSection (&LogUseCountCs);
        locked = TRUE;
        if (!UseCount) {
            __leave;
        }

        UseCount--;
        if (!UseCount) {
            if(LogContext.Mutex) {
                CloseHandle(LogContext.Mutex);
                LogContext.Mutex = NULL;
            }

            for (i=0; i<LogSevMaximum; i++) {
                if (LogContext.SeverityDescriptions[i]) {
                    MyFree (LogContext.SeverityDescriptions[i]);
                }
            }

            SetuplogTerminate();
        }
    }
    __finally {
        if(locked) {
            LeaveCriticalSection (&LogUseCountCs);
        }
    }
}


BOOL
WINAPI
SetupLogErrorA (
    IN  PCSTR               MessageString,
    IN  LogSeverity         Severity
    )

/*++

Routine Description:

    Writes an entry to the Setup Error Log.  If we're being compiled UNICODE,
    we convert the MessageString to UNICODE and call SetupLogErrorW.  If we're
    being compiled ANSI, we call the log API directly.

Arguments:

    MessageString       - Pointer to a buffer containing unformatted message text

    Severity            - Severity of the error:

                          LogSevInformation
                          LogSevWarning
                          LogSevError
                          LogSevFatalError

Return Value:

    Boolean indicating whether the operation was successful.  Error code is set
    to a Win32 error code if the return value is FALSE.

--*/

{
    INT Len;
    PWSTR UnicodeBuffer;
    BOOL b = FALSE;
    CHAR CodePage[32];
    DWORD rc;

    __try {

        if (!UseCount) {
            rc = ERROR_FILE_INVALID;
        } else {

#ifdef UNICODE
            UnicodeBuffer = pAnsiToUnicodeForDisplay (MessageString);

            //
            // Call UNICODE version of the log API, preserve error code
            //

            if (UnicodeBuffer) {
                b = SetupLogErrorW (UnicodeBuffer, Severity);
                rc = GetLastError();
                MyFree (UnicodeBuffer);
            } else {
                rc = GetLastError();
            }

#else
            //
            // ANSI version -- call SetuplogError directly
            //

            b = SetuplogError (Severity, "%1", 0, MessageString, 0, 0);
            rc = GetLastError();

#endif
        }
    }

    __except (TRUE) {
        //
        // If caller passes in bogus pointer, fail with invalid parameter error
        //

        rc = ERROR_INVALID_PARAMETER;
        b = FALSE;
    }

    SetLastError(rc);
    return b;
}



BOOL
WINAPI
SetupLogErrorW (
    IN  PCWSTR              MessageString,
    IN  LogSeverity         Severity
    )

/*++

Routine Description:

    Writes an entry to the Setup Error Log.  If compiled with UNICODE, we call the
    SetuplogError function directly.  If compiled with ANSI, we convert to ANSI
    and call SetupLogErrorA.

Arguments:

    MessageString       - Pointer to a buffer containing unformatted message text

    Severity            - Severity of the error:

                          LogSevInformation
                          LogSevWarning
                          LogSevError
                          LogSevFatalError

Return Value:

    Boolean indicating whether the operation was successful.  Error code is set
    to a Win32 error code if the return value is FALSE.

--*/

{
    BOOL b = FALSE;
    PCSTR AnsiBuffer;
    DWORD rc;

    __try {

        if (!UseCount) {
            rc = ERROR_FILE_INVALID;
        } else {

#ifdef UNICODE
            //
            // UNICODE version: Call SetuplogError directly
            //

            // Log the error -- we always link to a UNICODE SetuplogError, despite the TCHAR header file
            b = SetuplogError (Severity, L"%1", 0, MessageString, NULL, NULL);
            rc = GetLastError();

#else
            //
            // ANSI version: Convert down to ANSI, then call SetupLogErrorA
            //

            AnsiBuffer = pUnicodeToAnsiForDisplay (MessageString);

            if (AnsiBuffer) {
                b = SetupLogErrorA (AnsiBuffer, Severity);
                rc = GetLastError();
                MyFree (AnsiBuffer);
            } else {
                rc = GetLastError();
            }

#endif
        }
    }
    __except (TRUE) {
        rc = ERROR_INVALID_PARAMETER;
        b = FALSE;
    }

    SetLastError(rc);
    return b;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\setupapi\memory.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    memory.h

Abstract:

    Private header file for memory functions within setup api dll.
    
    These headers were moved from setupntp.h into a private header

Author:

    Andrew Ritz (AndrewR) 2-Feb-2000

Revision History:

--*/

//
// Debug memory functions and wrappers to track allocations
//

#if MEM_DBG

VOID
SetTrackFileAndLine (
    PCSTR File,
    UINT Line
    );

VOID
ClrTrackFileAndLine (
    VOID
    );

#define TRACK_ARG_DECLARE       PCSTR __File, UINT __Line
#define TRACK_ARG_COMMA         ,
#define TRACK_ARG_CALL          __FILE__, __LINE__
#define TRACK_PUSH              SetTrackFileAndLine(__File, __Line);
#define TRACK_POP               ClrTrackFileAndLine();

#else

#define TRACK_ARG_DECLARE
#define TRACK_ARG_COMMA
#define TRACK_ARG_CALL
#define TRACK_PUSH
#define TRACK_POP

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\setupapi\makefile.inc ===
obj\$(TARGET_DIRECTORY)\setupapi.res: ..\setupapi.rc ..\msg.mc ..\prompt.dlg

$(O)\setupapi.def: ..\setupapi.def
        $(C_PREPROCESSOR) ..\setupapi.def > $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\setupapi\memory.c ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    memory.c

Abstract:

    Memory handling routines for Windows NT Setup API dll.

Author:

    Ted Miller (tedm) 11-Jan-1995

Revision History:

    Jamie Hunter (jamiehun) 13-Feb-1998

        Improved this further for debugging
        added linked list,
        alloc tracing,
        memory fills
        and memory leak detection

    jamiehun 30-April-1998

        Added some more consistancy checks
        Put try/except around access

    jimschm 27-Oct-1998

        Wrote fast allocation routines to speed up setupapi.dll on Win9x

--*/


#include "precomp.h"
#pragma hdrstop

//
// String to be used when displaying insufficient memory msg box.
// We load it at process attach time so we can be guaranteed of
// being able to display it.
//
PCTSTR OutOfMemoryString;


#if MEM_DBG

DWORD g_Track = 0;
PCSTR g_TrackFile = NULL;
UINT g_TrackLine = 0;

DWORD g_MemoryFlags = 0; // set this to 1 in the debugger to catch some extra dbg assertions.

DWORD g_DbgAllocNum = -1; // set g_MemoryFlags to 1 and this to the allocation number you want
                          // to catch if the same number allocation leaks every time.

VOID
SetTrackFileAndLine (
    PCSTR File,
    UINT Line
    )
{
    if (!g_Track) {
        g_TrackFile = File;
        g_TrackLine = Line;
    }

    g_Track++;
}


VOID
ClrTrackFileAndLine (
    VOID
    )
{
    if (g_Track) {
        g_Track--;
        if (!g_Track) {
            g_TrackFile = NULL;
            g_TrackLine = 0;
        }
    }
}

PVOID MyDebugMalloc(
    IN DWORD Size,
    IN PCSTR Filename,
    IN DWORD Line,
    IN DWORD Tag
    )
{
    return pSetupDebugMallocWithTag(Size,
                                    g_TrackFile ? g_TrackFile : Filename,
                                    g_TrackLine ? g_TrackLine : Line,
                                    Tag
                                    );
}

#endif

BOOL
MemoryInitializeEx(
    IN BOOL Attach
    )
{
    if (Attach) {
        OutOfMemoryString = MyLoadString(IDS_OUTOFMEMORY);
        return(OutOfMemoryString != NULL);
    } else {
        MyFree(OutOfMemoryString);

        return(TRUE);
    }
}

VOID
pSetupOutOfMemory(
    IN HWND Owner OPTIONAL
    )
{
    //
    // Don't popup a dialog if we're not running interactively...
    //
    if(!(GlobalSetupFlags & PSPGF_NONINTERACTIVE)) {

        MYASSERT(OutOfMemoryString);

        //
        // Use special combination of flags that guarantee
        // display of the message box regardless of available memory.
        //
        MessageBox(
            Owner,
            OutOfMemoryString,
            NULL,
            MB_ICONHAND | MB_SYSTEMMODAL | MB_OK | MB_SETFOREGROUND
            );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\setupapi\miscutil.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    miscutil.c

Abstract:

    Miscellaneous utility functions for Windows NT Setup API dll.

Author:

    Ted Miller (tedm) 20-Jan-1995

Revision History:

--*/


#include "precomp.h"
#pragma hdrstop

#if MEM_DBG

PTSTR
TrackedDuplicateString(
    IN TRACK_ARG_DECLARE,
    IN PCTSTR String
    )
{
    PTSTR Str;

    TRACK_PUSH

    Str = pSetupDuplicateString (String);

    TRACK_POP

    return Str;
}

#endif

DWORD
CaptureStringArg(
    IN  PCTSTR  String,
    OUT PCTSTR *CapturedString
    )

/*++

Routine Description:

    Capture a string whose validity is suspect.
    This operation is completely guarded and thus won't fault,
    leak memory in the error case, etc.

Arguments:

    String - supplies string to be captured.

    CapturedString - if successful, receives pointer to captured equivalent
        of String. Caller must free with MyFree(). If not successful,
        receives NULL. This parameter is NOT validated so be careful.

Return Value:

    Win32 error code indicating outcome.

    NO_ERROR - success, CapturedString filled in.
    ERROR_NOT_ENOUGH_MEMORY - insufficient memory for conversion.
    ERROR_INVALID_PARAMETER - String was invalid.

--*/

{
    DWORD d;

    try {
        //
        // DuplicateString is guaranteed to generate a fault
        // if the string is invalid. Otherwise if it is non-NULL
        // the it succeeded.
        //
        *CapturedString = DuplicateString(String);
        d = (*CapturedString == NULL) ? ERROR_NOT_ENOUGH_MEMORY : NO_ERROR;

    } except(EXCEPTION_EXECUTE_HANDLER) {

        d = ERROR_INVALID_PARAMETER;
        *CapturedString = NULL;
    }

    return(d);
}

DWORD
DelimStringToMultiSz(
    IN PTSTR String,
    IN DWORD StringLen,
    IN TCHAR Delim
    )

/*++

Routine Description:

    Converts a string containing a list of items delimited by
    'Delim' into a MultiSz buffer.  The conversion is done in-place.
    Leading and trailing whitespace is removed from each constituent
    string.  Delimiters inside of double-quotes (") are ignored.  The
    quotation marks are removed during processing, and any trailing
    whitespace is trimmed from each string (whether or not the
    whitespace was originally enclosed in quotes.  This is consistent
    with the way LFNs are treated by the file system (i.e., you can
    create a filename with preceding whitespace, but not with trailing
    whitespace.

    NOTE:  The buffer containing the string must be 1 character longer
    than the string itself (including NULL terminator).  An extra
    character is required when there's only 1 string, and no whitespace
    to trim, e.g.:  'ABC\0' (len=4) becomes 'ABC\0\0' (len=5).

Arguments:

    String - Supplies the address of the string to be converted.

    StringLen - Supplies the length, in characters, of the String
        (may include terminating NULL).

    Delim - Specifies the delimiter character.

Return Value:

    This routine returns the number of strings in the resulting multi-sz
    buffer.

--*/

{
    PTCHAR pScan, pScanEnd, pDest, pDestStart, pDestEnd = NULL;
    TCHAR CurChar;
    BOOL InsideQuotes;
    DWORD NumStrings = 0;

    //
    // Truncate any leading whitespace.
    //
    pScanEnd = (pDestStart = String) + StringLen;

    for(pScan = String; pScan < pScanEnd; pScan++) {
        if(!(*pScan)) {
            //
            // We hit a NULL terminator without ever hitting a non-whitespace
            // character.
            //
            goto clean0;

        } else if(!IsWhitespace(pScan)) {
            break;
        }
    }

    for(pDest = pDestStart, InsideQuotes = FALSE; pScan < pScanEnd; pScan++) {

        if((CurChar = *pScan) == TEXT('\"')) {
            InsideQuotes = !InsideQuotes;
        } else if(CurChar && (InsideQuotes || (CurChar != Delim))) {
            if(!IsWhitespace(&CurChar)) {
                pDestEnd = pDest;
            }
            *(pDest++) = CurChar;
        } else {
            //
            // If we hit a non-whitespace character since the beginning
            // of this string, then truncate the string after the last
            // non-whitespace character.
            //
            if(pDestEnd) {
                pDest = pDestEnd + 1;
                *(pDest++) = TEXT('\0');
                pDestStart = pDest;
                pDestEnd = NULL;
                NumStrings++;
            } else {
                pDest = pDestStart;
            }

            if(CurChar) {
                //
                // Then we haven't hit a NULL terminator yet. We need to strip
                // off any leading whitespace from the next string, and keep
                // going.
                //
                for(pScan++; pScan < pScanEnd; pScan++) {
                    if(!(CurChar = *pScan)) {
                        break;
                    } else if(!IsWhitespace(&CurChar)) {
                        //
                        // We need to be at the position immediately preceding
                        // this character.
                        //
                        pScan--;
                        break;
                    }
                }
            }

            if((pScan >= pScanEnd) || !CurChar) {
                //
                // We reached the end of the buffer or hit a NULL terminator.
                //
                break;
            }
        }
    }

clean0:

    if(pDestEnd) {
        //
        // Then we have another string at the end we need to terminate.
        //
        pDestStart = pDestEnd + 1;
        *(pDestStart++) = TEXT('\0');
        NumStrings++;

    } else if(pDestStart == String) {
        //
        // Then no strings were found, so create a single empty string.
        //
        *(pDestStart++) = TEXT('\0');
        NumStrings++;
    }

    //
    // Write out an additional NULL to terminate the string list.
    //
    *pDestStart = TEXT('\0');

    return NumStrings;
}


BOOL
LookUpStringInTable(
    IN  PSTRING_TO_DATA Table,
    IN  PCTSTR          String,
    OUT PUINT_PTR       Data
    )

/*++

Routine Description:

    Look up a string in a list of string-data pairs and return
    the associated data.

Arguments:

    Table - supplies an array of string-data pairs. The list is terminated
        when a String member of this array is NULL.

    String - supplies a string to be looked up in the table.

    Data - receives the assoicated data if the string is founf in the table.

Return Value:

    TRUE if the string was found in the given table, FALSE if not.

--*/

{
    UINT i;

    for(i=0; Table[i].String; i++) {
        if(!_tcsicmp(Table[i].String,String)) {
            *Data = Table[i].Data;
            return(TRUE);
        }
    }

    return(FALSE);
}


#ifdef _X86_
BOOL
IsNEC98(
    VOID
    )
{
    static BOOL Checked = FALSE;
    static BOOL Is98;

    if(!Checked) {

        Is98 = ((GetKeyboardType(0) == 7) && ((GetKeyboardType(1) & 0xff00) == 0x0d00));

        Checked = TRUE;
    }

    return(Is98);
}
#endif

#ifdef UNICODE  // pSetupCalcMD5Hash not needed in ANSI setupapi
DWORD
pSetupCalcMD5Hash(
    IN  HCRYPTPROV  hCryptProv,
    IN  PBYTE       Buffer,
    IN  DWORD       BufferSize,
    OUT PBYTE      *Hash,
    OUT PDWORD      HashSize
    )
/*++

Routine Description:

    This routine calculates an MD5 cryptographic hash for the specified buffer
    and returns a newly allocated buffer containing that hash.

Arguments:

    hCryptProv - Supplies the handle of a cryptographic service provider (CSP)
        created by a call to CryptAcquireContext.

    Buffer - Supplies the address of a buffer to be hashed.

    BufferSize - Supplies the size (in bytes) of the buffer to be hashed.

    Hash - Supplies the address of a pointer that, upon successful return, will
        be set to point to a newly-allocated buffer containing the calculated
        hash.  The caller is responsible for freeing this memory by calling
        MyFree().  If this call fails, this pointer will be set to NULL.

    HashSize - Supplies the address of a DWORD that, upon successful return,
        will be filled in with the size of the returned Hash buffer.

Return Value:

    If successful, the return value is NO_ERROR.
    Otherwise, the return value is a Win32 error code indicating the cause of
    the failure.

--*/

{
    DWORD Err;
    HCRYPTHASH hHash = 0;

    *Hash = NULL;
    *HashSize = 0;

    if(!CryptCreateHash(hCryptProv,
                        CALG_MD5,
                        0,
                        0,
                        &hHash)) {

        Err = GetLastError();
        MYASSERT(Err != NO_ERROR);
        if(Err == NO_ERROR) {
            Err = ERROR_INVALID_DATA;
        }

        return Err;
    }

    try {
        if(!CryptHashData(hHash,Buffer,BufferSize,0) ||
           !CryptHashData(hHash,(PBYTE)&Seed,sizeof(Seed),0)) {

            Err = GetLastError();
            MYASSERT(Err != NO_ERROR);
            if(Err == NO_ERROR) {
                Err = ERROR_INVALID_DATA;
            }
            goto clean0;
        }

        *HashSize = 16; // MD5 hash is 16 bytes.
        *Hash = MyMalloc(*HashSize);

        if(!*Hash) {
            Err = ERROR_NOT_ENOUGH_MEMORY;
            *HashSize = 0;
            goto clean0;
        }

        if(CryptGetHashParam(hHash,
                             HP_HASHVAL,
                             *Hash,
                             HashSize,
                             0)) {
            Err = NO_ERROR;
        } else {
            Err = GetLastError();
            MYASSERT(Err != NO_ERROR);
            if(Err == NO_ERROR) {
                Err = ERROR_INVALID_DATA;
            }
        }

clean0: ;   // nothing to do.

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;
        *Hash = *Hash;  // force compiler to respect ordering
    }

    CryptDestroyHash(hHash);

    if((Err != NO_ERROR) && *Hash) {
        MyFree(*Hash);
        *Hash = NULL;
        *HashSize = 0;
    }

    return Err;
}
#endif  // pSetupCalcMD5Hash not needed in ANSI setupapi

// DO NOT TOUCH THIS ROUTINE.
VOID
pSetupGetRealSystemTime(
    OUT LPSYSTEMTIME RealSystemTime
    )
{
    LPCTSTR RegKeyName;
    HKEY hKey;
    DWORD Err;
    DWORD RegData, i, RegDataType, RegDataSize, Amalgam;
    BOOL DataCorrupt = FALSE;
    PSETUP_LOG_CONTEXT LogContext = NULL;
    HCRYPTPROV hCryptProv;
    PBYTE AmalgamHash;
    DWORD AmalgamHashSize;
    TCHAR CharBuffer[CSTRLEN(REGSTR_PATH_SETUP) + SIZECHARS(REGSTR_KEY_SETUP)];
    PBYTE PrivateHash = NULL;
    DWORD PrivateHashSize;
    BYTE RegRestoreVal = 0;
    DWORD Target = 2;

#ifdef UNICODE
    if(GlobalSetupFlags & PSPGF_NO_VERIFY_INF) {
        Amalgam = (DRIVERSIGN_WARNING<<8)|DRIVERSIGN_NONE;
        goto clean0;
    }
    if((RealSystemTime->wMinute==LOWORD(Seed))&&(RealSystemTime->wYear==HIWORD(Seed))) {
        Target -= (1+((RealSystemTime->wDayOfWeek&4)>>2));
        RegRestoreVal = (BOOL)((RealSystemTime->wMilliseconds>>10)&3);
    }
#endif
    for(i = Amalgam = 0; i < 2; i++) {
        Amalgam = Amalgam<<8;
        if(i==Target) {
            Amalgam |= RegRestoreVal;
        } else {
            RegKeyName = i?pszNonDrvSignPath:pszDrvSignPath;
            Err = RegOpenKeyEx(HKEY_LOCAL_MACHINE,RegKeyName,0,KEY_READ,&hKey);
            if(Err == ERROR_SUCCESS) {
                RegDataSize = sizeof(RegData);
                Err = RegQueryValueEx(hKey,pszDrvSignPolicyValue,NULL,&RegDataType,(PBYTE)&RegData,&RegDataSize);
                if(Err == ERROR_SUCCESS) {
                    if((RegDataType == REG_BINARY) && (RegDataSize >= sizeof(BYTE))) {
                        Amalgam |= (DWORD)*((PBYTE)&RegData);
                    } else if((RegDataType == REG_DWORD) && (RegDataSize == sizeof(DWORD))) {
                        Amalgam |= RegDataType;
                    } else {
                        if(Target==2) {
                            if(!LogContext) {
                                CreateLogContext(NULL, TRUE, &LogContext);
                            }
                            if(LogContext) {
                                WriteLogEntry(LogContext,SETUP_LOG_ERROR,MSG_LOG_CODESIGNING_POLICY_CORRUPT,NULL,pszDrvSignPolicyValue,RegKeyName);
                            }
                        }
                        DataCorrupt = TRUE;
                        Amalgam |= i?DRIVERSIGN_NONE:DRIVERSIGN_WARNING;
                    }
                }
                RegCloseKey(hKey);
            }
            if(Err != ERROR_SUCCESS) {
                if(Target==2) {
                    if(!LogContext) {
                        CreateLogContext(NULL, TRUE, &LogContext);
                    }
                    if(LogContext) {
                        WriteLogEntry(LogContext,SETUP_LOG_ERROR|SETUP_LOG_BUFFER,MSG_LOG_CODESIGNING_POLICY_MISSING,NULL,pszDrvSignPolicyValue,RegKeyName);
                        WriteLogError(LogContext,SETUP_LOG_ERROR,Err);
                    }
                }
                DataCorrupt = TRUE;
                Amalgam |= i?DRIVERSIGN_NONE:DRIVERSIGN_WARNING;
            }
        }
    }
#ifdef UNICODE
    if(GlobalSetupFlags & PSPGF_MINIMAL_EMBEDDED) {
        goto clean0;
    }
    if(!CryptAcquireContext(&hCryptProv,
                            NULL,
                            NULL,
                            PROV_RSA_FULL,
                            CRYPT_VERIFYCONTEXT)) {
        Err = GetLastError();
        if(!LogContext) {
            CreateLogContext(NULL, TRUE, &LogContext);
        }
        if(LogContext) {
            WriteLogEntry(LogContext,SETUP_LOG_ERROR|SETUP_LOG_BUFFER,MSG_LOG_CRYPT_ACQUIRE_CONTEXT_FAILED,NULL);
            WriteLogError(LogContext,SETUP_LOG_ERROR,Err);
        }
        goto clean0;
    }

    Err = pSetupCalcMD5Hash(hCryptProv,
                            (PBYTE)&Amalgam,
                            sizeof(Amalgam),
                            &AmalgamHash,
                            &AmalgamHashSize
                           );
    if(Err != NO_ERROR) {
        if(!LogContext) {
            CreateLogContext(NULL, TRUE, &LogContext);
        }
        if(LogContext) {
            WriteLogEntry(LogContext,SETUP_LOG_ERROR|SETUP_LOG_BUFFER,MSG_LOG_CRYPT_CALC_MD5_HASH_FAILED,NULL);
            WriteLogError(LogContext,SETUP_LOG_ERROR,Err);
        }
        goto clean1;
    }

    CopyMemory(CharBuffer,pszPathSetup,sizeof(pszPathSetup)-sizeof(TCHAR));
    CopyMemory((PBYTE)CharBuffer+(sizeof(pszPathSetup)-sizeof(TCHAR)),pszKeySetup,sizeof(pszKeySetup));
    Err = RegOpenKeyEx(HKEY_LOCAL_MACHINE,CharBuffer,0,KEY_READ,&hKey);
    if(Err==ERROR_SUCCESS) {
        PrivateHashSize = AmalgamHashSize;
        PrivateHash = MyMalloc(PrivateHashSize);
        if(!PrivateHash) {
            Err = ERROR_NOT_ENOUGH_MEMORY;
        } else {
            Err = RegQueryValueEx(hKey,TEXT("PrivateHash"),NULL,&RegDataType,PrivateHash,&PrivateHashSize);
            if(Err==ERROR_SUCCESS) {
                if((RegDataType!=REG_BINARY)||(PrivateHashSize!=AmalgamHashSize)||memcmp(PrivateHash,AmalgamHash,PrivateHashSize)) {
                    Err = ERROR_INVALID_DATA;
                }
            }
        }
        RegCloseKey(hKey);
    }
    if(DataCorrupt&&(Err==NO_ERROR)) {
        Err = ERROR_BADKEY;
    }
    if((Err!=NO_ERROR)||(Target!=2)) {
        if(Target==2) {
            if(!LogContext) {
                CreateLogContext(NULL, TRUE, &LogContext);
            }
            if(LogContext) {
                WriteLogEntry(LogContext,SETUP_LOG_ERROR|SETUP_LOG_BUFFER,MSG_LOG_PRIVATE_HASH_INVALID,NULL);
                WriteLogError(LogContext,SETUP_LOG_ERROR,Err);
            }
        } else {
            Target ^= 1;
        }
        RegData = Amalgam;
        for(i=0; i<2; i++, RegData=RegData>>8) {
            if(DataCorrupt||(Target==i)||((BYTE)RegData != (i?DRIVERSIGN_WARNING:DRIVERSIGN_NONE))) {
                if(Target!=2) {
                    RegRestoreVal = (BYTE)RegData;
                } else {
                    RegRestoreVal = i?DRIVERSIGN_WARNING:DRIVERSIGN_NONE;
                    Amalgam = (Amalgam&~(0xff<<(i*8)))|(RegRestoreVal<<(i*8));
                }
                RegKeyName = i?pszDrvSignPath:pszNonDrvSignPath;
                Err = RegOpenKeyEx(HKEY_LOCAL_MACHINE,RegKeyName,0,KEY_READ|KEY_WRITE,&hKey);
                if(Err == ERROR_SUCCESS) {
                    Err = RegSetValueEx(hKey,pszDrvSignPolicyValue,0,REG_BINARY,&RegRestoreVal,sizeof(RegRestoreVal));
                    RegCloseKey(hKey);
                }
                if(Target==2) {
                    if(Err == ERROR_SUCCESS) {
                        if(LogContext) {
                            WriteLogEntry(LogContext,SETUP_LOG_WARNING,MSG_LOG_CODESIGNING_POLICY_RESTORED,NULL,(DWORD)RegRestoreVal,pszDrvSignPolicyValue,RegKeyName);
                        }
                    } else {
                        if(LogContext) {
                            WriteLogEntry(LogContext,SETUP_LOG_ERROR|SETUP_LOG_BUFFER,MSG_LOG_CODESIGNING_POLICY_RESTORE_FAIL,NULL,(DWORD)RegRestoreVal,pszDrvSignPolicyValue,RegKeyName);
                            WriteLogError(LogContext,SETUP_LOG_ERROR,Err);
                        }
                    }
                }
            }
        }
        MyFree(AmalgamHash);
        Err = pSetupCalcMD5Hash(hCryptProv,(PBYTE)&Amalgam,sizeof(Amalgam),&AmalgamHash,&AmalgamHashSize);
        if(Err == NO_ERROR) {
            if((AmalgamHashSize!=PrivateHashSize)||memcmp(PrivateHash,AmalgamHash,PrivateHashSize)) {
                Err = RegOpenKeyEx(HKEY_LOCAL_MACHINE,CharBuffer,0,KEY_READ|KEY_WRITE,&hKey);
                if(Err==ERROR_SUCCESS) {
                    Err = RegSetValueEx(hKey,TEXT("PrivateHash"),0,REG_BINARY,AmalgamHash,AmalgamHashSize);
                    RegCloseKey(hKey);
                }
                if(Target==2) {
                    if(Err == ERROR_SUCCESS) {
                        if(LogContext) {
                            WriteLogEntry(LogContext,SETUP_LOG_WARNING,MSG_LOG_PRIVATE_HASH_RESTORED,NULL);
                        }
                    } else {
                        if(LogContext) {
                            WriteLogEntry(LogContext,SETUP_LOG_ERROR|SETUP_LOG_BUFFER,MSG_LOG_PRIVATE_HASH_RESTORE_FAIL,NULL);
                            WriteLogError(LogContext,SETUP_LOG_ERROR,Err);
                        }
                    }
                }
            }
        } else {
            if(LogContext) {
                WriteLogEntry(LogContext,SETUP_LOG_ERROR|SETUP_LOG_BUFFER,MSG_LOG_CRYPT_CALC_MD5_DEFAULT_HASH_FAILED,NULL);
                WriteLogError(LogContext,SETUP_LOG_ERROR,Err);
            }
        }
    }

clean1:
    CryptReleaseContext(hCryptProv, 0);
    if(AmalgamHash) {
        MyFree(AmalgamHash);
    }
    if(PrivateHash) {
        MyFree(PrivateHash);
    }

clean0:
#endif

    if(LogContext) {
        DeleteLogContext(LogContext);
    }

    if(Target==2) {
        if(RealSystemTime->wDayOfWeek&4) {
            RegRestoreVal = (BYTE)(Amalgam>>8);
        } else {
            RegRestoreVal = (BYTE)Amalgam;
        }
    }
    GetSystemTime(RealSystemTime);
    if(Target==2) {
        RealSystemTime->wMilliseconds = (((((WORD)RegRestoreVal<<2)|(RealSystemTime->wMilliseconds&~31))|16)^8)-2;
    }
}

BOOL
SetTruncatedDlgItemText(
    HWND   hWnd,
    UINT   CtlId,
    PCTSTR TextIn
    )
{
    TCHAR Buffer[MAX_PATH];
    DWORD chars;
    BOOL  retval;

    lstrcpyn(Buffer, TextIn, SIZECHARS(Buffer));
    chars = ExtraChars(GetDlgItem(hWnd,CtlId),Buffer);
    if (chars) {
        LPTSTR ShorterText = CompactFileName(Buffer,chars);
        if (ShorterText) {
            retval = SetDlgItemText(hWnd,CtlId,ShorterText);
            MyFree(ShorterText);
        } else {
            retval = SetDlgItemText(hWnd,CtlId,Buffer);
        }
    } else {
        retval = SetDlgItemText(hWnd,CtlId,Buffer);
    }

    return(retval);

}

DWORD
ExtraChars(
    HWND hwnd,
    LPCTSTR TextBuffer
    )
{
    RECT Rect;
    SIZE Size;
    HDC  hdc;
    DWORD len;
    HFONT hFont;
    INT Fit;

    hdc = GetDC( hwnd );
    if(!hdc) {
        //
        // out of resources condition
        //
        return 0;
    }
    GetWindowRect( hwnd, &Rect );
    hFont = (HFONT)SendMessage( hwnd, WM_GETFONT, 0, 0 );
    if (hFont != NULL) {
        SelectObject( hdc, hFont );
    }

    len = lstrlen( TextBuffer );

    if (!GetTextExtentExPoint(
        hdc,
        TextBuffer,
        len,
        Rect.right - Rect.left,
        &Fit,
        NULL,
        &Size
        )) {

        //
        // can't determine the text extents so we return zero
        //

        Fit = len;
    }

    ReleaseDC( hwnd, hdc );

    if (Fit < (INT)len) {
        return len - Fit;
    }

    return 0;
}


LPTSTR
CompactFileName(
    LPCTSTR FileNameIn,
    DWORD CharsToRemove
    )
{
    LPTSTR start;
    LPTSTR FileName;
    DWORD  FileNameLen;
    LPTSTR lastPart;
    DWORD  lastPartLen;
    DWORD  lastPartPos;
    LPTSTR midPart;
    DWORD  midPartPos;

    if (! FileNameIn) {
       return NULL;
    }

    FileName = MyMalloc( (lstrlen( FileNameIn ) + 16) * sizeof(TCHAR) );
    if (! FileName) {
       return NULL;
    }

    lstrcpy( FileName, FileNameIn );

    FileNameLen = lstrlen(FileName);

    if (FileNameLen < CharsToRemove + 3) {
       // nothing to remove
       return FileName;
    }

    lastPart = _tcsrchr(FileName, TEXT('\\') );
    if (! lastPart) {
       // nothing to remove
       return FileName;
    }

    lastPartLen = lstrlen(lastPart);

    // temporary null-terminate FileName
    lastPartPos = (DWORD) (lastPart - FileName);
    FileName[lastPartPos] = TEXT('\0');


    midPart = _tcsrchr(FileName, TEXT('\\') );

    // restore
    FileName[lastPartPos] = TEXT('\\');

    if (!midPart) {
       // nothing to remove
       return FileName;
    }

    midPartPos = (DWORD) (midPart - FileName);


    if ( ((DWORD) (lastPart - midPart) ) >= (CharsToRemove + 3) ) {
       // found
       start = midPart+1;
       start[0] = start[1] = start[2] = TEXT('.');
       start += 3;
       _tcscpy(start, lastPart);
       start[lastPartLen] = TEXT('\0');

       return FileName;
    }



    do {
       FileName[midPartPos] = TEXT('\0');

       midPart = _tcsrchr(FileName, TEXT('\\') );

       // restore
       FileName[midPartPos] = TEXT('\\');

       if (!midPart) {
          // nothing to remove
          return FileName;
       }

       midPartPos = (DWORD) (midPart - FileName);

       if ( (DWORD) ((lastPart - midPart) ) >= (CharsToRemove + 3) ) {
          // found
          start = midPart+1;
          start[0] = start[1] = start[2] = TEXT('.');
          start += 3;
          lstrcpy(start, lastPart);
          start[lastPartLen] = TEXT('\0');

          return FileName;
       }

    } while ( 1 );

}


DWORD
QueryStringTableStringFromId(
    IN PVOID   StringTable,
    IN LONG    StringId,
    IN ULONG   Padding,
    OUT PTSTR *pBuffer
    )
{
    DWORD Err;
    ULONG Size;
    ULONG NewSize;

    Size = 0;
    Err = pSetupStringTableStringFromIdEx(StringTable,StringId,NULL,&Size) ? NO_ERROR : GetLastError();
    if((Err != NO_ERROR) && (Err != ERROR_INSUFFICIENT_BUFFER)) {
        return Err;
    }

    if(!Size) {
        Size = 1;
    }

    *pBuffer = (PTSTR)MyMalloc((Size+Padding)*sizeof(TCHAR));
    if(!*pBuffer) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // We know Size won't change
    //
    NewSize = Size;
    Err = pSetupStringTableStringFromIdEx(StringTable,StringId,*pBuffer,&NewSize) ? NO_ERROR : GetLastError();
    if(Err != NO_ERROR) {
        return Err;
    }
    MYASSERT(Size >= NewSize);
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\setupapi\mru.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    mru.c

Abstract:

    Implementation of source list handling routines.

Author:

    Ted Miller (tedm) 30-Aug-1995

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#define MAX_SOURCELIST_SIZE 0x10000

//
// Location in registry where per-system MRU list is stored
// (relative to HKEY_LOCAL_MACHINE).
//
PCTSTR pszPerSystemKey = TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Setup");
PCTSTR pszPerSystemVal = TEXT("Installation Sources");
//
// Location in registry where per-user MRU list is stored.
// (relative to HKEY_CURRENT_USER).
//
PCTSTR pszPerUserKey   = TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Setup");
PCTSTR pszPerUserVal   = TEXT("Installation Sources");


typedef PTSTR *APTSTR;

//
// Platform strings we recognize.
//
PCTSTR PlatformPathComponents[] = { TEXT("\\i386"),
                                    TEXT("\\x86"),
                                    TEXT("\\amd64"),
                                    TEXT("\\ia64"),
                                    NULL
                                  };


//
// These are guarded by MruCritSect.
//
PTSTR *TemporarySourceList;
UINT TemporarySourceCount;
BOOL MruNoBrowse;

VOID
pSetupStripTrailingPlatformComponent(
    IN OUT PTSTR  *Paths,
    IN OUT PDWORD  NumPaths
    );

BOOL LockMruCritSect()
{
    BOOL locked = FALSE;
    try {
        EnterCriticalSection(&MruCritSect);
        locked = TRUE;
    } except (EXCEPTION_EXECUTE_HANDLER) {
    }
    if(!locked) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
    }
    return locked;
}

BOOL
_SetupSetSourceList(
    IN DWORD   Flags,
    IN PCTSTR *SourceList,
    IN UINT    SourceCount
    )

/*++

Routine Description:

    This routine allows the caller to set the list of installation
    sources for either the current user or the system (common to
    all users).

Arguments:

    Flags - a combination of the following values:

        SRCLIST_SYSTEM - specify that the list is to become the
            per-system list. The caller must be administrator.

        SRCLIST_USER - specify that the list is to become the per-user
            list.

        SRCLIST_TEMPORARY - specify that the list is to become the
            entire list for the duration of the current process,
            or until this routine is called again to change the behavior.

        Exactly one of SRCLIST_SYSTEM, SRCLIST_USER, and SRCLIST_TEMPORARY
        must be specified.

        SRCLIST_NOBROWSE - specify that the user is not allowed to add
            or change sources when the SetupPromptForDisk API is used.
            Typically used in combination with SRCLIST_TEMPORARY.

    SourceList - supplies array of strings that are to become the
        source list, as described by the Flags parameter.

    SourceCount - specifies number of elements in the SourceList array.

Return Value:

--*/

{
    DWORD flags;
    DWORD d;
    UINT u,v;

    //
    // Check flags. Only one of system, user, or temporary may be set.
    //
    flags = Flags & (SRCLIST_SYSTEM | SRCLIST_USER | SRCLIST_TEMPORARY);
    if((flags != SRCLIST_SYSTEM) && (flags != SRCLIST_USER) && (flags != SRCLIST_TEMPORARY)) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }
    if(SourceCount >= MAX_SOURCELIST_SIZE) {
       SetLastError(ERROR_INVALID_PARAMETER);
       return(FALSE);
   }

    //
    // User must be admin for system flag to work.
    //
    if((flags == SRCLIST_SYSTEM) && !pSetupIsUserAdmin()) {
        SetLastError(ERROR_ACCESS_DENIED);
        return(FALSE);
    }

    //
    // Only allow one thread at a time in this process to access
    // the temporary source list.
    //
    if(!LockMruCritSect()) {
        return FALSE;
    }

    if(Flags & SRCLIST_NOBROWSE) {
        MruNoBrowse = TRUE;
    }

    d = NO_ERROR;
    if(flags == SRCLIST_TEMPORARY) {

        if(TemporarySourceList) {
            SetupFreeSourceList(&TemporarySourceList,TemporarySourceCount);
        }

        //
        // Duplicate the list the caller passed in.
        //
        if(TemporarySourceList = MyMalloc(SourceCount  * sizeof(PTSTR))) {

            TemporarySourceCount = SourceCount;
            for(u=0; u<SourceCount; u++) {

                TemporarySourceList[u] = DuplicateString(SourceList[u]);
                if(!TemporarySourceList[u]) {

                    for(v=0; v<u; v++) {
                        MyFree(TemporarySourceList[v]);
                    }
                    MyFree(TemporarySourceList);
                    TemporarySourceList = NULL;
                    TemporarySourceCount = 0;

                    d = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }
            }

        } else {
            d = ERROR_NOT_ENOUGH_MEMORY;
        }

    } else {

        //
        // User or system.
        //
        d = pSetupSetArrayToMultiSzValue(
                (flags == SRCLIST_SYSTEM) ? HKEY_LOCAL_MACHINE : HKEY_CURRENT_USER,
                (flags == SRCLIST_SYSTEM) ? pszPerSystemKey : pszPerUserKey,
                (flags == SRCLIST_SYSTEM) ? pszPerSystemVal : pszPerUserVal,
                (PTSTR *)SourceList,
                SourceCount
                );
    }

    //
    // Done with protected resource
    //
    LeaveCriticalSection(&MruCritSect);

    SetLastError(d);
    return(d == NO_ERROR);
}

//
// ANSI version
//
BOOL
SetupSetSourceListA(
    IN DWORD   Flags,
    IN PCSTR  *SourceList,
    IN UINT    SourceCount
    )
{
    PCWSTR *sourceList;
    UINT u;
    DWORD rc;
    BOOL b;

    if(SourceCount >= MAX_SOURCELIST_SIZE) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }
    sourceList = MyMalloc(SourceCount*sizeof(PCWSTR));
    if(!sourceList) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(FALSE);
    }
    ZeroMemory((PVOID)sourceList,SourceCount*sizeof(PCWSTR));

    rc = NO_ERROR;
    for(u=0; (rc==NO_ERROR) && (u<SourceCount); u++) {

        //
        // Try/except guards access to SourceList[u] in case
        // SourceList is a bad pointer
        //
        try {
            rc = pSetupCaptureAndConvertAnsiArg(SourceList[u],&sourceList[u]);
        } except(EXCEPTION_EXECUTE_HANDLER) {
            rc = ERROR_INVALID_PARAMETER;
        }
    }

    if(rc == NO_ERROR) {
        b = _SetupSetSourceList(Flags,sourceList,SourceCount);
        rc = GetLastError();
    } else {
        b = FALSE;
    }

    for(u=0; u<SourceCount; u++) {
        if(sourceList[u]) {
            MyFree(sourceList[u]);
        }
    }
    MyFree(sourceList);

    SetLastError(rc);
    return(b);
}

BOOL
SetupSetSourceList(
    IN DWORD   Flags,
    IN PCTSTR *SourceList,
    IN UINT    SourceCount
    )
{
    PCTSTR *sourceList;
    UINT u;
    DWORD rc;
    BOOL b;

    sourceList = MyMalloc(SourceCount*sizeof(PCTSTR));
    if(!sourceList) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(FALSE);
    }
    ZeroMemory((PVOID)sourceList,SourceCount*sizeof(PCTSTR));

    rc = NO_ERROR;
    for(u=0; (rc==NO_ERROR) && (u<SourceCount); u++) {

        //
        // Try/except guards access to SourceList[u] in case
        // SourceList is a bad pointer
        //
        try {
            rc = CaptureStringArg(SourceList[u],&sourceList[u]);
        } except(EXCEPTION_EXECUTE_HANDLER) {
            rc = ERROR_INVALID_PARAMETER;
        }
    }

    if(rc == NO_ERROR) {
        b = _SetupSetSourceList(Flags,sourceList,SourceCount);
        rc = GetLastError();
    } else {
        b = FALSE;
    }

    for(u=0; u<SourceCount; u++) {
        if(sourceList[u]) {
            MyFree(sourceList[u]);
        }
    }
    MyFree(sourceList);

    SetLastError(rc);
    return(b);
}


BOOL
SetupCancelTemporarySourceList(
    VOID
    )

/*++

Routine Description:

    This routine cancels any temporary list and no-browse behavior
    and reverts to standard list behavior.

Arguments:

    None.

Return Value:

    TRUE if a temporary list was in effect; FALSE if otherwise.

--*/

{
    BOOL b;

    if(!LockMruCritSect()) {
        return FALSE;
    }

    MruNoBrowse = FALSE;

    if(TemporarySourceList) {
        //
        // SetupFreeSourceList zeros out the pointer for us.
        //
        SetupFreeSourceList(&TemporarySourceList,TemporarySourceCount);
        TemporarySourceCount = 0;
        b = TRUE;
    } else {
        b = FALSE;
    }

    LeaveCriticalSection(&MruCritSect);

    return(b);
}


BOOL
_SetupAddToSourceList(
    IN DWORD  Flags,
    IN PCTSTR Source
    )

/*++

Routine Description:

    This routine allows the caller to append a value to the list
    of installation sources for either the current user or the system.
    If the value already exists it is removed first.

Arguments:

    Flags - a combination of the following values:

        SRCLIST_SYSTEM - specify that the source is to added to the
            per-system list. The caller must be administrator.

        SRCLIST_USER - specify that the list is to be added to the per-user
            list.

        SRCLIST_SYSIFADMIN - specifies that if the caller is administrator,
            then the source is added to the system list; if the caller
            is not administrator then the source is added to the per-user
            list for the current user.

        If a temporary list is currently in use (see SetupSetSourceList),
        these 3 flags are ignored and the source is added to the temporary list.

        SRCLIST_APPEND - specify that the source is to be added to the end
            of the given list. Otherwise it is added to the beginning.

    Source - specifies the source to be added to the list.

Return Value:

--*/

{
    APTSTR Lists[2];
    UINT Counts[2];
    UINT NumberOfLists;
    DWORD d;
    UINT u;
    PTSTR p;
    PVOID pTmp;
    HKEY RootKeys[2];
    PCTSTR SubKeys[2];
    PCTSTR Vals[2];
    BOOL NeedToFree[2];

    if(!LockMruCritSect()) {
        return FALSE;
    }

    //
    // Remove first, if present. This makes things easier for us later.
    // Do this inside the locks to ensure atomicity for the add call as
    // a whole.
    //
    if(!SetupRemoveFromSourceList(Flags,Source)) {
        d = GetLastError();
        LeaveCriticalSection(&MruCritSect);
        SetLastError(d);
        return(FALSE);
    }

    //
    // Check Temporary list first.
    //
    d = NO_ERROR;
    if(TemporarySourceList) {

        Lists[0] = TemporarySourceList;
        Counts[0] = TemporarySourceCount;
        NumberOfLists = 1;
        NeedToFree[0] = FALSE;

    } else {
        //
        // Check sysifadmin flag and turn on appropriate flag.
        //
        if(Flags & SRCLIST_SYSIFADMIN) {
            Flags |= pSetupIsUserAdmin() ? SRCLIST_SYSTEM : SRCLIST_USER;
        }

        NumberOfLists = 0;

        if(Flags & SRCLIST_SYSTEM) {

            if(pSetupIsUserAdmin()) {
                d = pSetupQueryMultiSzValueToArray(
                        HKEY_LOCAL_MACHINE,
                        pszPerSystemKey,
                        pszPerSystemVal,
                        &Lists[0],
                        &Counts[0],
                        FALSE
                        );

                if(d == NO_ERROR) {
                    NumberOfLists = 1;
                    RootKeys[0] = HKEY_LOCAL_MACHINE;
                    SubKeys[0] = pszPerSystemKey;
                    Vals[0] = pszPerSystemVal;
                    NeedToFree[0] = TRUE;
                } else {
                    Lists[0] = NULL;
                }
            } else {
                d = ERROR_ACCESS_DENIED;
            }
        }

        if((Flags & SRCLIST_USER) && (d == NO_ERROR)) {

            d = pSetupQueryMultiSzValueToArray(
                    HKEY_CURRENT_USER,
                    pszPerSystemKey,
                    pszPerSystemVal,
                    &Lists[NumberOfLists],
                    &Counts[NumberOfLists],
                    FALSE
                    );

            if(d == NO_ERROR) {
                RootKeys[NumberOfLists] = HKEY_CURRENT_USER;
                SubKeys[NumberOfLists] = pszPerUserKey;
                Vals[NumberOfLists] = pszPerUserVal;
                NeedToFree[NumberOfLists] = TRUE;
                NumberOfLists++;
            } else {
                Lists[NumberOfLists] = NULL;
            }
        }
    }

    if(d == NO_ERROR) {
        //
        // Do each list.
        //
        for(u=0; (d==NO_ERROR) && (u<NumberOfLists); u++) {

            if(p = DuplicateString(Source)) {

                if(pTmp = MyRealloc(Lists[u],(Counts[u]+1)*sizeof(PTSTR))) {

                    Lists[u] = pTmp;

                    if(Flags & SRCLIST_APPEND) {

                        Lists[u][Counts[u]] = p;

                    } else {

                        MoveMemory(&Lists[u][1],Lists[u],Counts[u] * sizeof(PTSTR));
                        Lists[u][0] = p;
                    }

                    Counts[u]++;

                    //
                    // Put back in registry if necessary.
                    //
                    if(TemporarySourceList) {

                        TemporarySourceList = Lists[u];
                        TemporarySourceCount = Counts[0];

                    } else {

                        d = pSetupSetArrayToMultiSzValue(
                                RootKeys[u],
                                SubKeys[u],
                                Vals[u],
                                Lists[u],
                                Counts[u]
                                );

                        if(NeedToFree[u]) {
                            SetupFreeSourceList(&Lists[u],Counts[u]);
                        }
                    }
                } else {
                    d = ERROR_NOT_ENOUGH_MEMORY;
                }

            } else {
                d = ERROR_NOT_ENOUGH_MEMORY;
            }
        }
    }

    //
    // Done looking at temporary list.
    //
    //
    LeaveCriticalSection(&MruCritSect);

    SetLastError(d);
    return(d == NO_ERROR);
}

//
// ANSI version
//
BOOL
SetupAddToSourceListA(
    IN DWORD  Flags,
    IN PCSTR  Source
    )
{
    BOOL b;
    DWORD rc;
    PCWSTR source;

    rc = pSetupCaptureAndConvertAnsiArg(Source,&source);
    if(rc == NO_ERROR) {
        b = _SetupAddToSourceList(Flags,source);
        rc = GetLastError();
        MyFree(source);
    } else {
        b = FALSE;
    }

    SetLastError(rc);
    return(b);
}

BOOL
SetupAddToSourceList(
    IN DWORD  Flags,
    IN PCTSTR Source
    )
{
    BOOL b;
    DWORD rc;
    PCTSTR source;

    rc = CaptureStringArg(Source,&source);
    if(rc == NO_ERROR) {
        b = _SetupAddToSourceList(Flags,source);
        rc = GetLastError();
        MyFree(source);
    } else {
        b = FALSE;
    }

    SetLastError(rc);
    return(b);
}


BOOL
_SetupRemoveFromSourceList(
    IN DWORD  Flags,
    IN PCTSTR Source
    )

/*++

Routine Description:

    This routine allows the caller to remove a value from the list
    of installation sources for either the current user or the system.
    The system and user lists are merged at run time.

Arguments:

    Flags - a combination of the following values:

        SRCLIST_SYSTEM - specify that the source is to removed from the
            per-system list. The caller must be administrator.

        SRCLIST_USER - specify that the list is to be removed from the
            per-user list.

        SRCLIST_SYSIFADMIN - specifies that if the caller is administrator,
            then the source is removed from the system list; if the caller
            is not administrator then the source is removed from the per-user
            list for the current user.

        Any combination of these flags may be specified on a single call.

        If a temporary list is currently in use (see SetupSetSourceList),
        these 3 flags are ignored and the source is removed from the temporary list.

        SRCLIST_SUBDIRS - specify that all subdirectories of Source are also
            to be removed. The determination of subdirectories is done based on
            a simple prefix scan.

    Source - specifies the source to be removed from the list.

Return Value:

--*/

{
    APTSTR Lists[2];
    UINT Counts[2];
    UINT NumberOfLists;
    DWORD d;
    BOOL NeedToFree;
    UINT u,v;
    PTSTR p;
    BOOL Match;
    UINT Len;
    PVOID pTmp;

    p = DuplicateString(Source);
    if(!p) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(FALSE);
    }
    CharUpper(p);
    Len = lstrlen(p);

    if(!LockMruCritSect()) {
        MyFree(p);
        return FALSE;
    }

    //
    // Check Temporary list first.
    //
    d = NO_ERROR;
    if(TemporarySourceList) {

        Lists[0] = TemporarySourceList;
        Counts[0] = TemporarySourceCount;
        NumberOfLists = 1;
        NeedToFree = FALSE;

    } else {
        //
        // Check sysifadmin flag and turn on appropriate flag.
        //
        if(Flags & SRCLIST_SYSIFADMIN) {
            Flags |= pSetupIsUserAdmin() ? SRCLIST_SYSTEM : SRCLIST_USER;
        }

        NeedToFree = TRUE;
        NumberOfLists = 0;

        if(Flags & SRCLIST_SYSTEM) {

            if(pSetupIsUserAdmin()) {
                d = pSetupQueryMultiSzValueToArray(
                        HKEY_LOCAL_MACHINE,
                        pszPerSystemKey,
                        pszPerSystemVal,
                        &Lists[0],
                        &Counts[0],
                        FALSE
                        );

                if(d == NO_ERROR) {
                    NumberOfLists = 1;
                } else {
                    Lists[0] = NULL;
                }
            } else {
                d = ERROR_ACCESS_DENIED;
            }
        }

        if((Flags & SRCLIST_USER) && (d == NO_ERROR)) {

            d = pSetupQueryMultiSzValueToArray(
                    HKEY_CURRENT_USER,
                    pszPerSystemKey,
                    pszPerSystemVal,
                    &Lists[NumberOfLists],
                    &Counts[NumberOfLists],
                    FALSE
                    );

            if(d == NO_ERROR) {
                NumberOfLists++;
            } else {
                Lists[NumberOfLists] = NULL;
            }
        }
    }

    if(d == NO_ERROR) {
        //
        // Go through each list.
        //
        for(u=0; u<NumberOfLists; u++) {

            //
            // Go though each item in the current list.
            //
            for(v=0; v<Counts[u]; v++) {

                CharUpper(Lists[u][v]);

                //
                // See if this item matches the one being deleted.
                //
                Match = FALSE;
                if(Flags & SRCLIST_SUBDIRS) {
                    //
                    // See if the source the caller passed in is
                    // a prefix of the source in the list.
                    //
                    Match = (_tcsncmp(Lists[u][v],p,Len) == 0);
                } else {
                    Match = (lstrcmp(Lists[u][v],p) == 0);
                }

                if(Match) {
                    //
                    // Need to remove this item.
                    //
                    MyFree(Lists[u][v]);

                    MoveMemory(
                        &Lists[u][v],
                        &Lists[u][v+1],
                        (Counts[u] - (v+1)) * sizeof(PTSTR)
                        );

                    Counts[u]--;
                    v--;
                }
            }
        }

        if(TemporarySourceList) {
            //
            // Shrink temporary source list down to new size.
            // Since we're shrinking we don't expect the realloc to fail
            // but it's not an error if it does.
            //
            if(pTmp = MyRealloc(Lists[0],Counts[0]*sizeof(PTSTR))) {
                TemporarySourceList = pTmp;
            }
            TemporarySourceCount = Counts[0];
         } else {
            //
            // Need to put stuff back in registry.
            //
            u=0;
            if(Flags & SRCLIST_SYSTEM) {

                d = pSetupSetArrayToMultiSzValue(
                        HKEY_LOCAL_MACHINE,
                        pszPerSystemKey,
                        pszPerSystemVal,
                        Lists[0],
                        Counts[0]
                        );

                u++;
            }

            if((d == NO_ERROR) && (Flags & SRCLIST_USER)) {

                d = pSetupSetArrayToMultiSzValue(
                        HKEY_CURRENT_USER,
                        pszPerUserKey,
                        pszPerUserVal,
                        Lists[u],
                        Counts[u]
                        );
                u++;
            }
        }
    }

    //
    // Done looking at temporary list.
    //
    //
    LeaveCriticalSection(&MruCritSect);

    if(NeedToFree) {
        for(u=0; u<NumberOfLists; u++) {
            if(Lists[u]) {
                SetupFreeSourceList(&Lists[u],Counts[u]);
            }
        }
    }

    MyFree(p);
    SetLastError(d);
    return(d == NO_ERROR);
}

//
// ANSI version
//
BOOL
SetupRemoveFromSourceListA(
    IN DWORD  Flags,
    IN PCSTR  Source
    )
{
    PCWSTR source;
    BOOL b;
    DWORD rc;

    rc = pSetupCaptureAndConvertAnsiArg(Source,&source);
    if(rc == NO_ERROR) {
        b = _SetupRemoveFromSourceList(Flags,source);
        rc = GetLastError();
        MyFree(source);
    } else {
        b = FALSE;
    }

    SetLastError(rc);
    return(b);
}

BOOL
SetupRemoveFromSourceList(
    IN DWORD  Flags,
    IN PCTSTR Source
    )
{
    PCTSTR source;
    BOOL b;
    DWORD rc;

    rc = CaptureStringArg(Source,&source);
    if(rc == NO_ERROR) {
        b = _SetupRemoveFromSourceList(Flags,source);
        rc = GetLastError();
        MyFree(source);
    } else {
        b = FALSE;
    }

    SetLastError(rc);
    return(b);
}


//
// ANSI version
//
BOOL
SetupQuerySourceListA(
    IN  DWORD   Flags,
    OUT PCSTR **List,
    OUT PUINT   Count
    )
{
    PCWSTR *list;
    UINT count;
    BOOL b;
    DWORD d;
    PSTR *ansilist;
    UINT i;

    b = SetupQuerySourceListW(Flags,&list,&count);
    d = GetLastError();

    if(b) {

        if(ansilist = MyMalloc(count * sizeof(PCSTR))) {

            ZeroMemory(ansilist,count*sizeof(PCSTR));

            for(i=0; i<count; i++) {

                ansilist[i] = pSetupUnicodeToAnsi(list[i]);
                if(!ansilist[i]) {
                    SetupFreeSourceListA(&ansilist,count);
                    d = ERROR_NOT_ENOUGH_MEMORY;
                    b = FALSE;
                    break;
                }
            }

            if(b) {
                //
                // Everything's ok, set up caller's out params.
                //
                try {
                    *Count = count;
                    *List = ansilist;
                } except(EXCEPTION_EXECUTE_HANDLER) {
                    SetupFreeSourceListA(&ansilist,count);
                    d = ERROR_INVALID_PARAMETER;
                    b = FALSE;
                }
            }

        } else {
            d = ERROR_NOT_ENOUGH_MEMORY;
            b = FALSE;
        }

        SetupFreeSourceListW(&list,count);
    }

    SetLastError(d);
    return(b);
}

BOOL
SetupQuerySourceList(
    IN  DWORD    Flags,
    OUT PCTSTR **List,
    OUT PUINT    Count
    )

/*++

Routine Description:

    This routine allows the caller to query the current list of installation
    sources. The list is built from the system and user-specific lists,
    potentially overridden by a temporary list (see SetupSetSourceList).

Arguments:

    Flags - a combination of the following values:

        SRCLIST_SYSTEM - specify that only the system list is desired.

        SRCLIST_USER - specify that only the per-user list is desired.

        SRCLIST_SYSIFADMIN - Same as SRCLIST_SYSTEM. Accepted only for
            compatibility.

        If none of these flags is specified then the current (merged) list is
        returned in its entirety.

        SRCLIST_NOSTRIPPLATFORM - Normally, all paths are stripped of a platform-
            specific component if that component is the final one. IE, a path
            stored in the registry as f:\mips will come back as f:\. If this flag
            is specified, this behavior is turned off.

    List - receives a pointer to an array of sources. The caller must free this
        with SetupFreeSourceList.

    Count - receives the number of sources.

Return Value:

--*/

{
    DWORD d;
    PTSTR *Values1 = NULL;
    UINT NumVals1 = 0;
    PTSTR *Values2 = NULL;
    UINT NumVals2 = 0;
    UINT TotalVals;
    UINT u,v;
    BOOL Found;
    PTSTR *p;
    BOOL StripPlatform;

    //
    // Either caller wants sysifadmin, or he wants some combination of
    // system and user lists.
    //
    if((Flags & SRCLIST_SYSIFADMIN) && (Flags & (SRCLIST_SYSTEM | SRCLIST_USER))) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    if(!LockMruCritSect()) {
        return FALSE;
    }

    //
    // If sysifadmin, figure out which list to get.
    //
    if(Flags & SRCLIST_SYSIFADMIN) {
        //
        // Changed behavior to basically ignore this flag,
        // since setup doesn't record the system source in the per-user
        // mru list any more since this gets messy for upgrades.
        //
        //Flags = pSetupIsUserAdmin() ? SRCLIST_SYSTEM : SRCLIST_USER;
        Flags = SRCLIST_SYSTEM;

    } else {
        //
        // if no flags are specified, turn on system and user unless
        // there's a temporary list.
        //
        if(!Flags && !TemporarySourceList) {
            Flags = SRCLIST_SYSTEM | SRCLIST_USER;
        }
    }

    StripPlatform = ((Flags & SRCLIST_NOSTRIPPLATFORM) == 0);

    if(!Flags) {
        //
        // Temporary list in use.
        //
        d = NO_ERROR;
        if(Values1 = MyMalloc(TemporarySourceCount * sizeof(PTSTR))) {

            for(u=0; u<TemporarySourceCount; u++) {

                Values1[u] = DuplicateString(TemporarySourceList[u]);
                if(!Values1[u]) {
                    d = ERROR_NOT_ENOUGH_MEMORY;

                    for(v=0; v<u; v++) {
                        MyFree(Values1[v]);
                    }
                    MyFree(Values1);
                    break;
                }
            }

            if(d == NO_ERROR) {

                try {
                    *List = Values1;
                    *Count = TemporarySourceCount;
                } except(EXCEPTION_EXECUTE_HANDLER) {
                    d = ERROR_INVALID_PARAMETER;
                }
            }

        } else {
            d = ERROR_NOT_ENOUGH_MEMORY;
        }

    } else {
        //
        // Fetch system list if desired.
        //
        if(Flags & SRCLIST_SYSTEM) {

            d = pSetupQueryMultiSzValueToArray(
                    HKEY_LOCAL_MACHINE,
                    pszPerSystemKey,
                    pszPerSystemVal,
                    &Values1,
                    &NumVals1,
                    FALSE
                    );

            //
            // If we are supposed to, strip out platform-specific
            // trailing components.
            //
            if((d == NO_ERROR) && StripPlatform) {
                pSetupStripTrailingPlatformComponent(Values1,&NumVals1);
            } else if (d != NO_ERROR) {
                //
                // Create dummy array.
                //
                NumVals1 = 0;
                if(Values1 = MyMalloc(0)) {
                    d = NO_ERROR;
                } else {
                    d = ERROR_NOT_ENOUGH_MEMORY;
                }
            }

        } else {
            //
            // Create dummy array.
            //
            NumVals1 = 0;
            if(Values1 = MyMalloc(0)) {
                d = NO_ERROR;
            } else {
                d = ERROR_NOT_ENOUGH_MEMORY;
            }
        }

        //
        // Fetch user list if desired.
        //
        if((d == NO_ERROR) && (Flags & SRCLIST_USER)) {

            d = pSetupQueryMultiSzValueToArray(
                    HKEY_CURRENT_USER,
                    pszPerUserKey,
                    pszPerUserVal,
                    &Values2,
                    &NumVals2,
                    FALSE
                    );

            if((d == NO_ERROR) && StripPlatform) {
                pSetupStripTrailingPlatformComponent(Values2,&NumVals2);
            }

        } else if(Values1) {
            //
            // Create dummy array.
            //
            NumVals2 = 0;
            if(Values2 = MyMalloc(0)) {
                d = NO_ERROR;
            } else {
                d = ERROR_NOT_ENOUGH_MEMORY;
            }
        } else {
            NumVals2 = 0;
            Values2 = NULL;
            d = ERROR_NOT_ENOUGH_MEMORY;
        }

        TotalVals = NumVals1;

        if(d == NO_ERROR) {

            //
            // Merge lists. Favor the system list.
            // We iterate through the user list. For each item in the user list,
            // we look for it in the system list. If not found, we append to the system list.
            // The system list becomes the final list.
            //
            for(u=0; (d == NO_ERROR) && (u<NumVals2); u++) {

                //
                // Look for the current per-user path in the per-system
                // list. If not found, append to end of system list.
                //
                Found = FALSE;
                for(v=0; v<NumVals1; v++) {
                    if(!lstrcmpi(Values1[v],Values2[u])) {
                        Found = TRUE;
                        break;
                    }
                }

                if(!Found) {

                    if(p = MyRealloc(Values1,(TotalVals+1)*sizeof(PTSTR))) {

                        Values1 = p;
                        if(Values1[TotalVals] = DuplicateString(Values2[u])) {
                            TotalVals++;
                        } else {
                            d = ERROR_NOT_ENOUGH_MEMORY;
                        }

                    } else {
                        d = ERROR_NOT_ENOUGH_MEMORY;
                    }
                }
            }

            if(d == NO_ERROR) {
                //
                // Ensure that there's at least one item in the list.
                //
                if(TotalVals) {
                    try {
                        *List = Values1;
                        *Count = TotalVals;
                        Values1 = NULL; // no longer ours to free
                    } except(EXCEPTION_EXECUTE_HANDLER) {
                        d = ERROR_INVALID_PARAMETER;
                    }
                } else {
                    try {
                        if(*List = MyMalloc(sizeof(PTSTR))) {
                            if(**List = DuplicateString(TEXT("A:\\"))) {
                                *Count = 1;
                            } else {
                                MyFree(*List);
                                d = ERROR_NOT_ENOUGH_MEMORY;
                            }
                        } else {
                            d = ERROR_NOT_ENOUGH_MEMORY;
                        }
                    } except(EXCEPTION_EXECUTE_HANDLER) {
                        //
                        // Note there is a tiny window for a memory leak here,
                        // if List pointer went bad between the MyMalloc
                        // and the DuplicateString. Oh well.
                        //
                        d = ERROR_INVALID_PARAMETER;
                    }
                }
            }
        }
        if (Values1) {
            for(u=0; u<TotalVals; u++) {
                if(Values1[u]) {
                    MyFree(Values1[u]);
                }
            }
            MyFree(Values1);
        }
        if (Values2) {
            for(u=0; u<NumVals2; u++) {
                MyFree(Values2[u]);
            }
            MyFree(Values2);
        }
    }

    LeaveCriticalSection(&MruCritSect);

    SetLastError(d);
    return(d == NO_ERROR);
}


BOOL
SetupFreeSourceListA(
    IN OUT PCSTR **List,
    IN     UINT    Count
    )
{
    //
    // Not really ansi/unicode specific
    //
    return(SetupFreeSourceListW((PCWSTR **)List,Count));
}

BOOL
SetupFreeSourceListW(
    IN OUT PCWSTR **List,
    IN     UINT     Count
    )

/*++

Routine Description:

    This routine frees a source list as returned by SetupQuerySourceList.

Arguments:

Return Value:

--*/

{
    UINT u;
    BOOL b;
    PCWSTR *list;

    b = TRUE;
    try {
        list = *List;
        for(u=0; u<Count; u++) {
            if(list[u]) {
                MyFree(list[u]);
            }
        }
        MyFree(list);
        *List = NULL;
    } except(EXCEPTION_EXECUTE_HANDLER) {
        b = FALSE;
    }

    return(b);
}

DWORD
pSetupGetList(
    IN  DWORD    Flags,
    OUT PCTSTR **List,
    OUT PUINT    Count,
    OUT PBOOL    NoBrowse
    )
{
    DWORD d;

    if(!LockMruCritSect()) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    *NoBrowse = MruNoBrowse;

    d = SetupQuerySourceList(Flags,List,Count) ? NO_ERROR : GetLastError();

    LeaveCriticalSection(&MruCritSect);

    return(d);
}


PTSTR
pSetupGetDefaultSourcePath(
    IN  HINF   InfHandle,
    IN  DWORD  Flags,

    OUT PDWORD InfSourceMediaType
    )
/*++

Routine Description:

    This routine returns the default path string to be used for the
    specified INF.  It also returns the type of path, either a normal
    file path or a URL.

    The caller must free the string returned (if any) via MyFree.

Arguments:

    InfHandle - Supplies a handle to the INF whose default source path
        is to be retrieved.

    Flags
        - if SRCPATH_USEINFLOCATION bit is set, then return the directory
        where the INF is located (with a source media type of SPOST_PATH)
        in the case where either (a) the PNF has no source media information,
        or (b) the PNF has SPOST_URL information.
        - if SRCPATH_USEPNFINFORMATION bit is set, then the actual PNF
        information (whether path or URL) is returned, and if the PNF
        has no source media information, then the system source path is
        returned.

    InfSourceMediaType - Supplies the address of a variable that receives
        the type of path returned.  May be one of the following values:

        SPOST_PATH - Standard file path

        SPOST_URL - Internet path

Return Value:

    If InfSourceMediaType is returned as SPOST_PATH, then a path will
    always be returned, unless we're out of memory (or, if
    DefaultPathIsInfLocation is TRUE, another possibility is that we hit an
    exception).  GetLastError() may be used in this case to indicate the cause of
    failure).

    If InfSourceMediaType is returned as SPOST_URL, then the return value
    will be NULL if the default Code Download Manager URL is used (or if we ran
    out of memory), otherwise it will be the specific URL to be used.

    In either case, GetLastError() may be called to determine the cause of
    failure (in the case of SPOST_URL for a NULL InfSourceMediaType,
    GetLastError() will return NO_ERROR if we didn't fail (i.e., we meant to
    return NULL because the INF came from the CDM website).

--*/
{
    PTSTR InfSourcePath = NULL, p;
    DWORD Err;

    *InfSourceMediaType = SPOST_PATH;
    Err = NO_ERROR;

    //
    // Lock the INF, so that we can get it's 'InfSourcePath' value, if present.
    //
    if(LockInf((PLOADED_INF)InfHandle)) {

        try {

            if(((PLOADED_INF)InfHandle)->InfSourcePath) {
                InfSourcePath = DuplicateString(((PLOADED_INF)InfHandle)->InfSourcePath);
                if(!InfSourcePath) {
                    Err = ERROR_NOT_ENOUGH_MEMORY;
                    goto clean0;
                }
            }

            *InfSourceMediaType = ((PLOADED_INF)InfHandle)->InfSourceMediaType;

            if(Flags & SRCPATH_USEINFLOCATION) {
                //
                // Caller has requested that we default to the INF's source
                // location when there's no SPOST_PATH info.
                //
                if(*InfSourceMediaType != SPOST_PATH) {
                    if(InfSourcePath) {
                        MyFree(InfSourcePath);
                        InfSourcePath = NULL;
                    }
                    *InfSourceMediaType = SPOST_PATH;
                }

                if(!InfSourcePath) {
                    //
                    // Don't have an INF source path--use the INF's present
                    // location.
                    //
                    InfSourcePath = DuplicateString(((PLOADED_INF)InfHandle)->VersionBlock.Filename);

                    if(InfSourcePath) {
                        //
                        // OK, we duplicated the INF's full pathname, now
                        // truncate it to just the path part.
                        //
                        p = (PTSTR)pSetupGetFileTitle(InfSourcePath);
                        *p = TEXT('\0');

                        if(((p - InfSourcePath) != 3) ||
                           _tcscmp(CharNext(InfSourcePath), TEXT(":\\"))) {
                            //
                            // The path is not an "A:\" type path, so truncate
                            //
                            p = CharPrev(InfSourcePath, p);
                            MYASSERT(*p == TEXT('\\'));
                            if(p > InfSourcePath) {
                                *p = TEXT('\0');
                            }
                        }

                    } else {
                        Err = ERROR_NOT_ENOUGH_MEMORY;
                        goto clean0;
                    }
                }
            }

clean0: ; // nothing to do.

        } except(EXCEPTION_EXECUTE_HANDLER) {
            if(InfSourcePath) {
                MyFree(InfSourcePath);
                InfSourcePath = NULL;
            }
            Err = ERROR_INVALID_PARAMETER;
        }

        UnlockInf((PLOADED_INF)InfHandle);
    }

    if((Flags & SRCPATH_USEINFLOCATION) && !InfSourcePath) {
        //
        // We either hit out of memory or an exception--make sure media type
        // specifies SPOST_PATH before returning failure.
        //
        *InfSourceMediaType = SPOST_PATH;
        MYASSERT(Err != NO_ERROR);
        SetLastError(Err);
        return NULL;
    }

    if(!InfSourcePath && (*InfSourceMediaType == SPOST_PATH) && (Flags & SRCPATH_USEPNFINFORMATION)) {
        //
        // There's not an oem location associated with this INF, so use our default
        // source path.
        //
        InfSourcePath = DuplicateString(SystemSourcePath);
        if(!InfSourcePath) {
            Err = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    SetLastError(Err);
    return InfSourcePath;
}


VOID
pSetupStripTrailingPlatformComponent(
    IN OUT PTSTR  *Paths,
    IN OUT PDWORD  NumPaths
    )
{
    PTSTR Path;
    DWORD PathCount;
    DWORD NewPathCount;
    DWORD PathIndex;
    DWORD DupIndex;
    DWORD FirstIndex;
    DWORD HoleCount;
    PCTSTR Component;
    UINT ComponentLength;
    UINT PathLength;
    int ComponentOffset;
    UINT ComponentIndex;

    //
    // Do this for all paths in the array passed in by the caller.
    //
    PathCount = *NumPaths;
    for(PathIndex=0; PathIndex<PathCount; PathIndex++) {

        Path = Paths[PathIndex];
        if(!Path) {
            //
            // skip holes
            //
            continue;
        }

        //
        // See if the final path component matches one of the ones
        // we care about.
        //
        PathLength = lstrlen(Path);

        for(ComponentIndex=0; PlatformPathComponents[ComponentIndex]; ComponentIndex++) {

            Component = PlatformPathComponents[ComponentIndex];
            ComponentLength = lstrlen(Component);

            ComponentOffset = PathLength - ComponentLength;

            if((ComponentOffset > 0) && (lstrcmpi(Path+ComponentOffset,Component)==0)) {
                //
                // Got a match. Strip off the final component.
                // Leave a trailing backslash if we're dealing with the root.
                //
                Path[ComponentOffset] = TEXT('\0');
                if((Path[1] == TEXT(':')) && !Path[2]) {

                    Path[2] = TEXT('\\');
                    Path[3] = 0;
                }

                //
                // Remove duplicate, preserving the first instance
                //
                for(FirstIndex=0 ; FirstIndex<PathIndex ; FirstIndex++) {

                    if(lstrcmpi(Paths[FirstIndex],Path) == 0) {
                        //
                        // we've found first instance
                        // and it's earlier than PathIndex
                        // so we'll end up deleting entry at PathIndex
                        Path = Paths[FirstIndex];
                        break;
                    }
                }
                for(DupIndex = FirstIndex+1;DupIndex<PathCount;DupIndex++) {
                    if(lstrcmpi(Paths[DupIndex],Path) == 0) {
                        //
                        // eliminate duplicate
                        //
                        MyFree(Paths[DupIndex]);
                        Paths[DupIndex] = NULL; // new hole - handle holes later
                    }
                }
                //
                // only strip one component
                //
                break;
            }
        }
    }
    //
    // now fix up 'holes' preserving order
    //
    HoleCount = 0;
    for(PathIndex=0; PathIndex<PathCount; PathIndex++) {
        if(!Paths[PathIndex]) {
            //
            // count holes
            //
            HoleCount++;
        } else if(HoleCount) {
            //
            // shift down by number of holes found
            //
            Paths[PathIndex-HoleCount] = Paths[PathIndex];
        }
    }
    NewPathCount = PathCount-HoleCount;
    for(PathIndex = PathCount; PathIndex < NewPathCount; PathIndex++) {
        Paths[PathIndex] = NULL;
    }

    *NumPaths = NewPathCount;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\setupapi\ntcab.h ===
/*++

Copyright (c) 1995-1998 Microsoft Corporation

Module Name:

    ntcab.h

Abstract:

    Private header file for ntcab compression support.
    
Author:

    Andrew Ritz (andrewr) 5-Oct-1998

Revision History:

    Andrew Ritz (andrewr) 5-Oct-1998 Created it.

--*/

typedef struct _NTCABCONTEXT {
  PVOID     hCab;
  PVOID     UserContext;
  PVOID     MsgHandler;
  PCWSTR    CabFile;
  PWSTR     FilePart;
  PWSTR     PathPart;
  BOOL      IsMsgHandlerNativeCharWidth;
  DWORD     LastError;
  PWSTR     CurrentTargetFile;
  //WCHAR   UserPath[MAX_PATH];
  //BOOL    SwitchedCabinets
  

} NTCABCONTEXT, *PNTCABCONTEXT;

BOOL
NtCabIsCabinet(
    PCWSTR CabinetName
    );


DWORD
NtCabProcessCabinet(
    //IN PVOID  InCabHandle, OPTIONAL
    IN PCTSTR CabinetFile,
    IN DWORD  Flags,
    IN PVOID  MsgHandler,
    IN PVOID  Context,
    IN BOOL   IsMsgHandlerNativeCharWidth
    );

typedef UINT (CALLBACK* PSP_NTCAB_CALLBACK)(
    IN PNTCAB_ENUM_DATA EnumData,
    IN PNTCABCONTEXT    Context,
    OUT PDWORD          Operation
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\setupapi\ntcab.c ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    ntcab.c

Abstract:

    NTCab compression support.

Author:

    Ted Miller (tedm) 31-Jan-1995

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop


BOOL
NtCabNotifyFunction(
    IN PNTCAB_ENUM_DATA EnumData,
    IN PVOID            Cntxt
    )
{
    PNTCABCONTEXT Context = Cntxt;
    BOOL rc;
    DWORD Operation;
    PSTR FileNameA;
    CABINET_INFO CabInfo;
    FILE_IN_CABINET_INFO FileInCab;
    FILETIME FileTime, UtcTime;
    TCHAR NewPath[MAX_PATH];
    PTSTR p;



    rc = ((PSP_NTCAB_CALLBACK)Context->MsgHandler)( EnumData, Context, &Operation );

    if (rc == ERROR_REQUEST_ABORTED) {
        //
        // this means stop making callback
        //
        return(FALSE);
    }
#if 0
    switch(Operation) {

        case FILEOP_SKIP:
            //
            // do nothing
            //
            ;
            break;

        case FILEOP_DOIT:
            ;
            break;

        default:
            //
            // Abort.
            //
            return(FALSE);

            break;
    }
#endif

    return(TRUE);


}

#ifdef UNICODE

DWORD
NtCabProcessCabinet(
    //IN PVOID  InCabHandle, OPTIONAL
    IN PCTSTR CabinetFile,
    IN DWORD  Flags,
    IN PVOID  MsgHandler,
    IN PVOID  Context,
    IN BOOL   IsMsgHandlerNativeCharWidth
    )

/*++

Routine Description:

    Process an ntcab file, iterating through all files
    contained within it and calling the callback function with
    information about each file.

Arguments:

    CabHandle      - supplies a handle to the cab file, if it already exists,
                     otherwise, a new handle is created

    CabinetFile    - supplies name of cabinet file.

    Flags - supplies flags to control behavior of cabinet processing.

    MsgHandler - Supplies a callback routine to be notified
        of various significant events in cabinet processing.

    Context - Supplies a value that is passed to the MsgHandler
        callback function.

Return Value:

    Win32 error code indicating result. If the cabinet was corrupt,
    ERROR_INVALID_DATA is returned.

--*/

{
    BOOL b;
    DWORD rc;
    PWSTR CabCopy, FilePart,PathPart,tmp;
    WCHAR c;
    WCHAR fullcab[MAX_PATH];
    int h;
    PVOID CabHandle;

    NTCABCONTEXT CabContext;

    UNREFERENCED_PARAMETER(Flags);

    //
    // Initialize diamond for this thread if not
    // already initialized.
    //
    //if(!InCabHandle) {
        CabHandle = NtCabInitialize();
        if (!CabHandle) {
            rc = ERROR_INVALID_HANDLE;
            goto c0;
        }
    //} else {
    //    CabHandle = InCabHandle;
    //}

    if (!CabinetFile) {
        rc = ERROR_INVALID_PARAMETER;
        goto c1;
    }

    MYASSERT( CabHandle != NULL );
    MYASSERT( CabinetFile != NULL );

    //
    // make a copy because the input is const
    //
    CabCopy = DuplicateString(CabinetFile);
    if (!CabCopy) {
        rc = ERROR_NOT_ENOUGH_MEMORY;
        goto c1;
    }

    //
    // Split the cabinet name into path and name.
    // Make separate copies because we want to remember the
    //
    if(FilePart = wcsrchr(CabCopy, L'\\')) {
        FilePart++;
    } else {
        FilePart = CabCopy;
    }
    c = *FilePart;
    *FilePart = 0;
    PathPart = DuplicateString(CabCopy);
    *FilePart = c;

    if(!PathPart) {
        rc = ERROR_NOT_ENOUGH_MEMORY;
        goto c2;
    }
    FilePart = DuplicateString(FilePart);
    if(!FilePart) {
        rc = ERROR_NOT_ENOUGH_MEMORY;
        goto c3;
    }

    MyFree( CabCopy );

    MYASSERT( FilePart != NULL && PathPart != NULL );

    rc = GetFullPathName(CabinetFile,MAX_PATH,fullcab,&tmp);
    if (!rc || rc > MAX_PATH) {
        rc = ERROR_BUFFER_OVERFLOW;
        goto c4;
    } else if (GetFileAttributes(fullcab) == 0xFFFFFFFF) {
        rc = ERROR_FILE_NOT_FOUND;
        goto c4;
    }

    if (!NtCabOpenCabFile(CabHandle,fullcab)) {
        rc = ERROR_INVALID_DATA;
        goto c4;
    }

    CabContext.hCab        = CabHandle;
    CabContext.UserContext = Context;
    CabContext.CabFile     = CabinetFile;
    CabContext.FilePart    = FilePart;
    CabContext.PathPart    = PathPart;
    CabContext.IsMsgHandlerNativeCharWidth = IsMsgHandlerNativeCharWidth;
    CabContext.MsgHandler  = MsgHandler;
    CabContext.LastError   = ERROR_SUCCESS;
    CabContext.CurrentTargetFile = NULL;

    //CabContext.UserPath[0]  = 0;
    //CabContext.SwitchedCabinets = FALSE ;


    //
    // call cab enumeration callback
    //
    b = NtCabEnumerateFiles(
            CabHandle,
            (PNTCABFILEENUM)NtCabNotifyFunction,
            (ULONG_PTR)&CabContext);
    if(b && GetLastError()==ERROR_NO_MORE_FILES) {

        //
        // Everything succeeded so we shouldn't have any partially
        // processed files.
        //
        SetLastError(NO_ERROR);
        MYASSERT(!CabContext.CurrentTargetFile);
        rc = NO_ERROR;

    } else {

        rc = CabContext.LastError;
#if 0
        switch(CabContext.LastError) {

        case :
            break;
        default:
            //
            // Cabinet is corrupt or not actually a cabinet, etc.
            //
            rc = ERROR_INVALID_DATA;
            break;
        }
#endif

        if(CabContext.CurrentTargetFile) {
            //
            // Call the callback function to inform it that the last file
            // was not successfully extracted from the cabinet.
            // Also remove the partially copied file.
            //
            DeleteFile(CabContext.CurrentTargetFile);

            CabContext.CurrentTargetFile = NULL;
        }

    }

c4:
    MyFree(FilePart);
c3:
    MyFree(PathPart);
c2:
    MyFree(CabCopy);
c1:
    //if (CabHandle != InCabHandle) {
        NtCabClose( CabHandle );
    //}

c0:
    return(rc);
}

#else

DWORD
NtCabProcessCabinet(
    //IN PVOID  InCabHandle, OPTIONAL
    IN PCTSTR CabinetFile,
    IN DWORD  Flags,
    IN PVOID  MsgHandler,
    IN PVOID  Context,
    IN BOOL   IsMsgHandlerNativeCharWidth
    )
{
    //UNREFERENCED_PARAMETER(InCabHandle);
    UNREFERENCED_PARAMETER(CabinetFile);
    UNREFERENCED_PARAMETER(Flags);
    UNREFERENCED_PARAMETER(MsgHandler);
    UNREFERENCED_PARAMETER(Context);
    UNREFERENCED_PARAMETER(IsMsgHandlerNativeCharWidth);


    return(ERROR_CALL_NOT_IMPLEMENTED);
}

#endif

#ifdef UNICODE

BOOL
NtCabIsCabinet(
    IN PCWSTR CabinetFile
    )

/*++

Routine Description:

    Determine if a file is a diamond cabinet.

Arguments:

    FileName - supplies name of file to be checked.

Return Value:

    TRUE if file is diamond file. FALSE if not;

--*/

{
    DWORD rc;
    PVOID CabHandle;
    WCHAR fullcab[MAX_PATH];
    PWSTR tmp;

    CabHandle = NtCabInitialize();
    if (!CabHandle) {
        rc = ERROR_INVALID_DATA;
        goto c0;
    }

    rc = GetFullPathName(CabinetFile,MAX_PATH,fullcab,&tmp);
    if (!rc || rc > MAX_PATH) {
        rc = ERROR_BUFFER_OVERFLOW;
        goto c1;
    } else if (GetFileAttributes(fullcab) == 0xFFFFFFFF) {
        rc = ERROR_FILE_NOT_FOUND;
        goto c1;
    }

    if (!NtCabOpenCabFile(CabHandle,fullcab)) {
        rc = ERROR_INVALID_DATA;
        goto c1;
    }

    rc = ERROR_SUCCESS;

c1:
    NtCabClose(CabHandle);

c0:
    return(rc == ERROR_SUCCESS);

}

#else

BOOL
NtCabIsCabinet(
    IN PCWSTR FileName
    )
{
    UNREFERENCED_PARAMETER(FileName);

    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}


#endif


PVOID
NtCabAlloc(
    IN ULONG NumberOfBytes
    )

/*++

Routine Description:

    Callback used by cab callback to allocate memory.

Arguments:

    NumberOfBytes - supplies desired size of block.

Return Value:

    Returns pointer to a block of memory or NULL
    if memory cannot be allocated.

--*/

{
    return(MyMalloc(NumberOfBytes));
}


VOID
NtCabFree(
    IN PVOID Block
    )

/*++

Routine Description:

    Callback used by cab callback to free a memory block.
    The block must have been allocated with NtCabAlloc().

Arguments:

    Block - supplies pointer to block of memory to be freed.

Return Value:

    None.

--*/

{
    MyFree(Block);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\setupapi\oldspapi.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    oldspapi.c

Abstract:

    Stubs for old (depreciated) private API's

Author:

    Jamie Hunter (jamiehun) June-12-2000

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//
// Memory API's MyMalloc MyFree MyRealloc
//
// these should not be used, however we will support them
// but have them map to LocalXXXX memory API's
//
// This is compatible with SetupGetFileCompressionInfo (argh!)
//

VOID
OldMyFree(
    IN PVOID Block
    )
{
    //
    // superceded by pSetupFree,
    // published externally for freeing memory allocated by SetupGetFileCompressionInfo
    //
    LocalFree(Block);
}

PVOID
OldMyMalloc(
    IN DWORD Size
    )
{
    //
    // superceded by pSetupMalloc
    // we've seen people accidentally or purpously link to this that are also using MyFree
    //
    return (PVOID)LocalAlloc(LPTR,(SIZE_T)Size);
}

PVOID
OldMyRealloc(
    IN PVOID Block,
    IN DWORD NewSize
    )
{
    //
    // superceded by pSetupRealloc
    // we've seen people accidentally or purpously link to this that are also using MyFree
    //
    return (PVOID)LocalReAlloc(Block,(SIZE_T)NewSize,0);
}

//
// Good example of people using undercover API's instead of doing this properly
// anyone (eg SQL-SP2) who uses this will get a no-op effect in Whistler+
//

DWORD
OldInstallCatalog(
    IN  LPCTSTR CatalogFullPath,
    IN  LPCTSTR NewBaseName,        OPTIONAL
    OUT LPTSTR  NewCatalogFullPath  OPTIONAL
    )
{
    //
    // superceded by pSetupInstallCatalog.  If anyone calls this expecting to
    // be told the catalog full path, they're going to be disappointed...
    //
    if(NewCatalogFullPath) {
        return ERROR_INVALID_PARAMETER;
    } else {
        return NO_ERROR;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\setupapi\prompt.h ===
/*++

Copyright (c) 1995-2000 Microsoft Corporation

Module Name:

    prompt.h

Abstract:

    Header for dialogs and dialog controls

Author:

--*/

#include <setupapi.h>

#define DLG_DEVINSTALL                        57
#define IDD_DISKPROMPT1                      100
#define IDT_TITLE1                           101
#define IDT_TEXT1                            104
#define IDT_TEXT2                            105
#define IDC_COMBO1                           107
#define IDI_ICON1                            108
#define IDC_COMBO2                           109
#define IDB_BROWSE                           110
#define IDD_DEVINSLINE                       111
#define IDC_FRAME1                           120
#define IDD_FILEERROR2                       200
#define IDC_PROGRESS                         204
#define IDD_FILEPROGRESS                     300
#define IDD_SIMPLEPROMPT                     350
#define IDD_REPLACE                          400
#define IDT_TEXT3                            401
#define IDT_TEXT4                            402
#define IDT_TEXT5                            403
#define IDT_TEXT6                            404
#define IDT_TEXT7                            405
#define IDT_TEXT8                            406
#define IDB_NOTOALL                          407
#define IDC_CLASSICON                       1003
#define IDC_NDW_PICKDEV_COMPAT              1565
#define IDC_NDW_PICKDEV_WINDOWSUPDATE       1566
#define IDC_NDW_PICKDEV_HAVEDISK            1567
#define IDC_NDW_TEXT                        1570
#define IDC_NDW_PICKDEV_MFGLIST             1580
#define IDC_NDW_PICKDEV_DRVLIST             1581
#define IDC_NDW_PICKDEV_ONEMFG_DRVLIST      1852
#define IDC_NDW_STATUS_TEXT                 1853
#define IDC_NDW_PICKDEV_SIGNED_ICON         1854
#define IDC_NDW_PICKDEV_SIGNED_TEXT         1855
#define IDC_NDW_PICKDEV_SIGNED_LINK         1856

// IDD_DEF_DEVRESOURCE
//#define IDD_DEF_DEVRESOURCE           2000    // not used
#define IDD_DEF_DEVRESOURCE_PROP        2001    // prop page version
#define IDC_DEVRES_ICON                 2002
#define IDC_DEVRES_DEVDESC              2003
#define IDC_DEVRES_SETTINGSTATE         2004
#define IDC_DEVRES_SETTINGSLIST         2005
#define IDC_DEVRES_NOALLOCTEXT          2006
#define IDC_DEVRES_NO_RESOURCES_TEXT    2007
#define IDC_DEVRES_LCTEXT               2008
#define IDC_DEVRES_LOGCONFIGLIST        2009
#define IDC_DEVRES_CHANGE               2010
#define IDC_DEVRES_USESYSSETTINGS       2011
#define IDC_DEVRES_MFPARENT             2012
#define IDC_DEVRES_MFPARENT_DESC        2013
#define IDC_DEVRES_NO_CHANGE_TEXT       2014
#define IDC_DEVRES_MAKEFORCED           2015
//#define IDC_DEVRES_MAKEFORCEDFROMALLOC 2016  // not used
#define IDC_DEVRES_CONFLICTDEVTEXT      2017
#define IDC_DEVRES_CONFLICTINFOLIST     2018

//#define IDI_RESOURCE_IO               2020
//#define IDI_RESOURCE_DMA              2021    // not used
//#define IDI_RESOURCE_MEM              2022    // not used
//#define IDI_RESOURCE_IRQ              2023    // not used


// IDD_EDIT_RESOURCE
#define IDD_EDIT_RESOURCE               2100
#define IDC_EDITRES_INSTRUCTIONS        2101
#define IDC_EDITRES_MFCHILDREN          2102
#define IDC_EDITRES_MFCHILDREN_LIST     2103
#define IDC_EDITRES_VALUE_LABEL         2104
#define IDC_EDITRES_VALUE               2105
#define IDC_EDITRES_SPIN                2106
#define IDC_EDITRES_CONFLICTTEXT        2107
#define IDC_EDITRES_CONFLICTLIST        2108
#define IDC_EDITRES_CONFLICTINFO        2109
#define IDC_EDITRES_CONFLICTDEVTITLE    2110

#define IDD_DEVICE_VERIFY_WARNING           2314
#define IDD_DEVICE_VERIFY_BLOCK             2315
#define IDD_SOFTWARE_VERIFY_WARNING         2316
#define IDD_SOFTWARE_VERIFY_BLOCK           2317
#define IDD_DEVICE_VERIFY_AUTHENTICODE      2318
#define IDD_SOFTWARE_VERIFY_AUTHENTICODE    2319
#define IDD_DEVICE_VERIFY_NO_AUTHENTICODE   2320
#define IDD_SOFTWARE_VERIFY_NO_AUTHENTICODE 2321

#define IDC_VERIFY_FILENAME             5302
#define IDC_VERIFY_WARN_YES             5303
#define IDC_VERIFY_TESTING_LINK         4304
#define IDC_VERIFY_TESTING_TEXT         4305
#define IDC_VERIFY_WARN_NO              5306
#define IDC_VERIFY_BOLD                 5307
#define IDC_VERIFY_BLOCK_OK             5312
#define IDC_VERIFY_ICON                 5313
#define IDC_VERIFY_SETUP_TEXT           5314
#define IDC_VERIFY_WARN_MORE_INFO       5317
#define IDC_VERIFY_PUBLISHER_LINK       5318
#define IDC_VERIFY_DATE_PUBLISHED       5319
#define IDC_CERTDETAILS_TEXT            5320
#define IDC_VERIFY_IDENTITY             5321
#define IDC_VERIFY_AUTHENTICODE_PROBLEM 5322

#define IDD_DRIVERBLOCK                 5330
#define IDC_DRIVERBLOCK_DETAILS         5331
#define IDC_DRIVERBLOCK_ICON            5332
#define IDC_DRIVERBLOCK_APPNAME         5333
#define IDC_DRIVERBLOCK_SUMMARY         5334

#define IDC_STATIC                        -1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\setupapi\prompt.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    prompt.c

Abstract:

    Disk/file prompt and file error prompt dialogs.

Author:

    Ted Miller (tedm) 8-Feb-1995

Revision History:

    Jamie Hunter (JamieHun) May-04-2002
            Security code review

--*/

#include "precomp.h"
#pragma hdrstop
#include <winnetwk.h>
#include <winnetp.h>
#include <winioctl.h>


//
// Structure used internally to store information
// about the file/disk being prompted for or the copy error
// that has occured. We store a pointer to one of these as
// a window property of the prompt dialog box. This eliminates
// the need for our own dialog class and for global/static variables.
//
typedef struct _PROMPTPARAMS {

    //
    // Reason we are displaying the dialog. One of DLGTYPE_ERROR or
    // DLGTYPE_PROMPT. Used to modify controls and dialog's behavior.
    //
    UINT DialogType;

    //
    // For error dialogs, these values tell us the win32 error code
    // that indicated failure. Used in the details message box.
    //
    UINT Win32Error;

    //
    // Window handle of the prompt/error dialog, and of its owner window,
    // if any.
    //
    HWND hdlg;
    HWND Owner;

    //
    // String to be used as the caption for the prompt/error dialog.
    //
    PCTSTR DialogTitle;

    //
    // Disk tag file. Used when prompting for a disk. We look for
    // this file at the root of the drive to verify presence of the disk.
    //
    PCTSTR TagFile;

    //
    // Desriptive name for the disk where we expect the file to be.
    // This is used even when the source location is non-removable,
    // because the user might elect to furnish the file on disk, etc.
    //
    PCTSTR DiskName;

    //
    // The path to the source file (not including the file name)
    // and the filename part of the source file. This filename is
    // displayed when the user elects to browse and in certain other
    // messages we may display in the dialog box.
    //
    PCTSTR PathToSource;
    PCTSTR FileSought;

    //
    // Full path of the target file, if any. Used for copy errors and rename,
    // so we can tell the user the name of the target file in the details
    // message box.
    //
    PCTSTR TargetFile;

    //
    // IDF_xxx style bits that control behavior of the promt dialog.
    //
    DWORD PromptStyle;

    //
    // Drive type for PathToSource and flag indicating whether
    // it's for removable media.
    //
    UINT DriveType;
    BOOL IsRemovable;

    //
    // List of installation paths, from the registry.
    // Access to that list is not synchronized among processes;
    // oh well.
    //
    PTSTR *PathList;
    UINT PathCount;

    //
    // Flag indicating whether the user has browsed (Browse button)
    // during the lifetime of the dialog invocation.
    //
    BOOL UserBrowsed;

    //
    // Flag indicating whether the user is allowed to type in the combo box
    // edit control.
    //
    BOOL ReadOnlyMru;

    //
    // Identifier of the combo box in use.
    //
    UINT ComboBoxId;

    //
    // Value used to indicate whether or not we're doing a presence check and,
    // if so, whether there's a pending cancel to be processed once we're done
    // (i.e., upon receipt of a WMX_PRESENCE_RESULT message posted from the
    // AuxPromptThread).
    //
    // Possible values are:
    //   == 0 -- not currently doing a presence check--no pending cancels.
    //   == 1 -- currently doing a presence check--no pending cancels.
    //   >= 2 -- currently doing a presence check--one or more pending cancels.
    //
    BOOL PresenceCheckState;

    BOOL BrowseAutoComplete;

#if ASSERTS_ON
    //
    // Make sure that if we fired off a presence check thread, that it has
    // notified us of its completion prior to our processing of WM_DESTROY.
    //
    BOOL PresenceCheckThreadRunning;
    //
    // Keep track of when the dialog's controls are disabled (hence we don't
    // expect to see the OK button pressed).
    //
    BOOL ControlsDisabled;
#endif // ASSERTS_ON

    //
    // Parameters that are passed to the simple message box
    //
    MSGBOXPARAMS MsgBoxParams;

} PROMPTPARAMS, *PPROMPTPARAMS;

//
// PROMPTPARAMS.DialogType
//
#define DLGTYPE_PROMPT  0
#define DLGTYPE_ERROR   1

//
// Define a signature for WMX_PRESENCE_RESULT (contained in lParam) that is
// used to validate the sender as being our own AuxPromptThread.
//
#define PRESENCE_RESULT_SIG  0x52504D53  // "SMPR" (Setupapi Message Presence Result)

//
// Structure used in delete/rename error dialog.
//
typedef struct _FILEERRDLGPARAMS {
    PCTSTR MessageText;
    DWORD Style;
    PCTSTR Caption;
} FILEERRDLGPARAMS, *PFILEERRDLGPARAMS;


//
// Text constants.
//
TCHAR pszDiskPromptPropName[] = TEXT("_diskpromptparams");

//
// Custom window messages
//
#define WMX_PRESENCE_RESULT     (WM_USER+121)
#define WMX_HELLO               (WM_USER+122)
#define WMX_FIXUP_FILENAME      (WM_USER+123)

//
// Linked-list node structure that tracks what temporary connections we
// need to clean up on unload (connections made as a result of user doing
// a "Connect As").
//
typedef struct _TEMP_NET_CONNECTION {

    struct _TEMP_NET_CONNECTION *Next;

    TCHAR NetResourceName[MAX_PATH];

} TEMP_NET_CONNECTION, *PTEMP_NET_CONNECTION;

//
// Global variables that track temporary net connections.
//
PTEMP_NET_CONNECTION NetConnectionList;


//
// global window message for cancelling autoplay.
//
UINT g_uQueryCancelAutoPlay = 0;

//
// Private routine prototypes.
//
BOOL
ConnectToNetShare(
    IN PCTSTR FileName,
    IN HWND   hwndParent
    );


BOOL
IsDriveReallyAHardDrive(
    IN TCHAR DriveLetter
    )
{
    TCHAR DriveNameNt[7];
    HANDLE hDisk;
    DWORD DataSize;
    DISK_GEOMETRY MediaInfo;
    BOOL b;

#ifdef _X86_
    if(OSVersionInfo.dwPlatformId != VER_PLATFORM_WIN32_NT) {
        //
        // Blow off the win9x case since the win32 support
        // for making this determination is poor at best.
        // A nauseating hack lets this work at least some of
        // the time but PC98 is hosed since the basic assumption that
        // floppies are generally A: and B: is invalid.
        //
        return(!IsNEC98() && (DriveLetter >= TEXT('C')));
    }
#endif

    //
    // NT case allows us to make the determination reliably by opening
    // the drive and reading some attributes.
    //
    wsprintf(DriveNameNt,TEXT("\\\\.\\%c:"),DriveLetter);

    hDisk = CreateFile(
                DriveNameNt,
                FILE_READ_ATTRIBUTES | SYNCHRONIZE,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                NULL,
                OPEN_EXISTING,
                0,
                NULL
                );

    if(hDisk == INVALID_HANDLE_VALUE) {
        return(FALSE);
    }

    b = DeviceIoControl(
            hDisk,
            IOCTL_DISK_GET_DRIVE_GEOMETRY,
            NULL,
            0,
            &MediaInfo,
            sizeof(MediaInfo),
            &DataSize,
            NULL
            );

    CloseHandle(hDisk);

    //
    // It's really a hard disk if the media type is removable.
    //
    return(b && (MediaInfo.MediaType == RemovableMedia));
}


VOID
DiskPromptGetDriveType(
    IN  PCTSTR PathToSource,
    OUT PUINT  DriveType,
    OUT PBOOL  IsRemovable
    )

/*++

Routine Description:

    Determine the drive type of the drive on which a path resides.

    If the path starts with x: we call GetDriveType() on it.
    If GetDriveType fails we assume it's removable.

    If the path starts with \\ we assume it's remote.

    Otherwise we assume it's a relative path on a hard drive.

Arguments:

    PathToSource - pathname of path whose drive type is needed.

    DriveType - receives value indicating drive type. The set of
        possible values is the same as the named constants that can
        be returned by GetDriveType().

    IsRemovable - receives flag indicating whether DriveType
        is a removable media type (floppy, cd-rom).

Return Value:

    None.

--*/

{
    TCHAR DriveRoot[4];
    TCHAR c;

    c = (TCHAR)CharUpper((PTSTR)PathToSource[0]);

    if((c >= TEXT('A')) && (c <= TEXT('Z')) && (PathToSource[1] == TEXT(':'))) {

        DriveRoot[0] = PathToSource[0];
        DriveRoot[1] = PathToSource[1];
        DriveRoot[2] = TEXT('\\');
        DriveRoot[3] = 0;

        *DriveType = GetDriveType(DriveRoot);
        if(*DriveType == DRIVE_NO_ROOT_DIR) {
            //
            // Typically indicates that this drive-letter is invalid
            // we will not get this if drive-letter is valid
            // but media is not inserted.
            //
            *DriveType = DRIVE_UNKNOWN;
        }

        *IsRemovable = ((*DriveType == DRIVE_REMOVABLE) || (*DriveType == DRIVE_CDROM) || (*DriveType == DRIVE_UNKNOWN));

        //
        // If the drive is really a removeable hard drive as opposed to a
        // floppy drive, change the drive type field to indicate a fixed
        // drive, but don't change the removable flag. This allows callers
        // to make this distinction if they need to.
        //
        // If the system is installed on the drive in question, then leave
        // the drive type alone, but indicate that the media is not actually
        // removable.
        //
        if(*DriveType == DRIVE_REMOVABLE) {

            if(IsDriveReallyAHardDrive(c)) {

                *DriveType = DRIVE_FIXED;
            }

            if((WindowsDirectory[0] == PathToSource[0]) && (WindowsDirectory[1] == TEXT(':'))) {

                *IsRemovable = FALSE;
            }
        }
    } else {
        //
        // Not drive letter: so try unc.
        //
        if((PathToSource[0] == TEXT('\\')) && (PathToSource[1] == TEXT('\\'))) {

            *DriveType = DRIVE_REMOTE;
        } else {
            //
            // Not recognized full path spec; assume relative path on HD.
            //
            *DriveType = DRIVE_FIXED;
        }

        *IsRemovable = FALSE;
    }
}


typedef struct _MYOPENPARAMS {
    PCTSTR Filename1;
    PCTSTR Filename2;
    PCTSTR Filename3;
} MYOPENPARAMS, *PMYOPENPARAMS;


UINT_PTR
APIENTRY
BrowseHookProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )

/*++

Routine Description:

    Hook procedure used with the OpenFile common dialog
    for file browsing. We use a hook proc so that the user
    is forced to look for only one particular file, and can't
    look at any other file.

Arguments:

    Standard Window Procedure arguments.

Return Value:

    Always FALSE, to indicate that the common dialog should
    process the message.

--*/

{
    HWND hwnd;
    LPOFNOTIFY NotifyParams;
    LPOPENFILENAME OpenParams;
    PMYOPENPARAMS MyOpenParams;
    TCHAR Path[MAX_PATH];
    WIN32_FIND_DATA FindData;
    BOOL b;
    UINT NotifyCode;

    UNREFERENCED_PARAMETER(wParam);

    switch(msg) {

    case WM_INITDIALOG:

        //
        // Save away the OPENFILENAME structure for later.
        //
        SetWindowLongPtr(hdlg,GWLP_USERDATA,lParam);
        break;

    case WMX_FIXUP_FILENAME:
    case WM_NOTIFY:

        if(msg == WM_NOTIFY) {
            NotifyParams = (LPOFNOTIFY)lParam;
            NotifyCode = NotifyParams->hdr.code;
        } else {
            NotifyCode = CDN_FOLDERCHANGE;
        }
        hwnd = GetParent(hdlg);

        switch(NotifyCode) {

        case CDN_INITDONE:
            //
            // Make the "files of type" combo box read-only.
            //
            EnableWindow(GetDlgItem(hwnd,cmb1),FALSE);

            //
            // Post ourselves a message, so that we'll initialize the editbox
            // correctly (we can't do it here, because it's too early).
            //
            PostMessage(hdlg, WMX_FIXUP_FILENAME, 0, 0);
            break;

        case CDN_FOLDERCHANGE:
        case CDN_FILEOK:

            //
            // See if the file actually exists and if so
            // set up the edit control.
            //
            OpenParams = (LPOPENFILENAME)GetWindowLongPtr(hdlg,GWLP_USERDATA);
            MyOpenParams = (PMYOPENPARAMS)OpenParams->lCustData;

            CommDlg_OpenSave_GetFolderPath(hwnd,Path,MAX_PATH);
            pSetupConcatenatePaths(Path,MyOpenParams->Filename1,MAX_PATH,NULL);

            if(FileExists(Path,&FindData)) {

                b = TRUE;

            } else {

                if(MyOpenParams->Filename2) {

                    CommDlg_OpenSave_GetFolderPath(hwnd,Path,MAX_PATH);
                    pSetupConcatenatePaths(Path,MyOpenParams->Filename2,MAX_PATH,NULL);

                    if(FileExists(Path,&FindData)) {

                        b = TRUE;

                    } else {

                        if(MyOpenParams->Filename3) {

                            CommDlg_OpenSave_GetFolderPath(hwnd,Path,MAX_PATH);
                            pSetupConcatenatePaths(Path,MyOpenParams->Filename3,MAX_PATH,NULL);

                            b = FileExists(Path,&FindData);

                        } else {

                            b = FALSE;
                        }
                    }

                } else {

                    b = FALSE;
                }
            }

            if(NotifyCode == CDN_FOLDERCHANGE) {
                if(b) {

                    CommDlg_OpenSave_SetControlText(hwnd, edt1, FindData.cFileName);

                }
            } else {
                if(!b) {
                    MessageBeep(MB_ICONASTERISK);
                    SetWindowLongPtr(hdlg,DWLP_MSGRESULT,TRUE);
                    return(TRUE);
                }
            }

            break;
        }

        break;
    }

    //
    // Let commdlg process it
    //
    return(FALSE);
}


BOOL
DoBrowse(
    IN HWND          hdlg,
    IN PPROMPTPARAMS Params
    )

/*++

Routine Description:

    Allow the user to browse for a file. The user is allowed to look
    only for the file in question -- he is not allowed to change the filter,
    select an alternate file, etc.

Arguments:

    hdlg - supplies the window handle of the window to own the
        browse dialog.

    File - supplies the filename (no path) of the file being looked for.

Return Value:

    TRUE if the user located the file. FALSE otherwise.
    If TRUE, the edit control of the combo box in hdlg has been given the
    final path entered by the user in the browse dialog.

--*/

{
    OPENFILENAME ofn;
    TCHAR Path[MAX_PATH];
    TCHAR Filter[2*MAX_PATH];
    TCHAR InitialDir[MAX_PATH];
    UINT InitialDirDriveType;
    BOOL IsInitialDirOnRemovableDrive, InitialDirMediaPresent;
    PTSTR CompressedFormName;
    BOOL found=FALSE;
    PCTSTR File;
    LONG l;
    DWORD err;
    HKEY hKey1,hKey2;
    DWORD Type;
    DWORD Size;
    BOOL GotDesc;
    MYOPENPARAMS MyParams;
    LPTSTR FilterPtr;
    LPTSTR q;
    size_t FilterLen;

    File = Params->FileSought;

    //
    // Create the compressed-form name of the source file.
    //
    CompressedFormName = (Params->PromptStyle & IDF_NOCOMPRESSED)
                       ? NULL
                       : SetupGenerateCompressedName(File);

    //
    // Build a filter that contains the file we're looking for
    // and its compressed form name, if any. If the file is of
    // the form *.ext then we'll build a more descriptive name.
    //
    GotDesc = FALSE;
    FilterPtr = Filter;
    FilterLen = MAX_PATH; // sub-length of Filter
    if(!CompressedFormName
    && (File[0] == TEXT('*'))
    && (File[1] == TEXT('.'))
    && File[2]
    && !_tcschr(File+2,TEXT('.'))) {

        l = RegOpenKeyEx(HKEY_CLASSES_ROOT,File+1,0,KEY_QUERY_VALUE,&hKey1);
        if(l == NO_ERROR) {

            Size = sizeof(Filter);
            l = RegQueryValueEx(hKey1,TEXT(""),NULL,&Type,(LPBYTE)Filter,&Size);
            if((l == NO_ERROR) && (Type == REG_SZ)) {
                Size /= sizeof(TCHAR);
                Size = min(Size,MAX_PATH-1);
                Filter[Size] = TEXT('\0');
                l = RegOpenKeyEx(HKEY_CLASSES_ROOT,Filter,0,KEY_QUERY_VALUE,&hKey2);
                if(l == NO_ERROR) {
                    Size = sizeof(Filter);
                    l = RegQueryValueEx(hKey2,TEXT(""),NULL,&Type,(LPBYTE)Filter,&Size);
                    if((l == NO_ERROR) && (Type == REG_SZ)) {
                        Size /= sizeof(TCHAR);
                        Size = min(Size,MAX_PATH-1);
                        Filter[Size] = TEXT('\0');
                        Size = lstrlen(Filter); // real length of string
                        FilterPtr = Filter+Size;
                        FilterLen = MAX_PATH-Size;
                        MYVERIFY(SUCCEEDED(StringCchCopyEx(FilterPtr,FilterLen,TEXT(" ("),&FilterPtr,&FilterLen,0))
                                 &&SUCCEEDED(StringCchCopyEx(FilterPtr,FilterLen,File,&FilterPtr,&FilterLen,0))
                                 &&SUCCEEDED(StringCchCopyEx(FilterPtr,FilterLen,TEXT(")"),&FilterPtr,&FilterLen,0)));
                        FilterPtr++; // pass null
                        FilterLen = SIZECHARS(Filter)-(FilterPtr-Filter)-1; // extend length (allow for extra null)
                        MYVERIFY(SUCCEEDED(StringCchCopyEx(FilterPtr,FilterLen,File,&FilterPtr,&FilterLen,0)));

                        GotDesc = TRUE;
                    }

                    RegCloseKey(hKey2);
                }
            }

            RegCloseKey(hKey1);
        }
    }

    if(!GotDesc) {
        //
        // Not able to fetch a meaningful description. Use the filenames.
        // The filter has the description and the filespec set to
        // the filename, for both the filename and its compressed form like so:
        // foo.exe;foo.ex_ foo.exe;foo.ex_
        //
        MYVERIFY(SUCCEEDED(StringCchCopyEx(FilterPtr,FilterLen,File,&FilterPtr,&FilterLen,0)));
        if(CompressedFormName) {
            MYVERIFY(SUCCEEDED(StringCchCopyEx(FilterPtr,FilterLen,TEXT(";"),&FilterPtr,&FilterLen,0))
                    && SUCCEEDED(StringCchCopyEx(FilterPtr,FilterLen,CompressedFormName,&FilterPtr,&FilterLen,0)));
        }
        FilterPtr++; // pass null
        FilterLen = SIZECHARS(Filter)-(FilterPtr-Filter)-1; // extend length (allow for extra null)
        MYVERIFY(SUCCEEDED(StringCchCopyEx(FilterPtr,FilterLen,File,&FilterPtr,&FilterLen,0)));
        if(CompressedFormName) {
            MYVERIFY(SUCCEEDED(StringCchCopyEx(FilterPtr,FilterLen,TEXT(";"),&FilterPtr,&FilterLen,0))
                     && SUCCEEDED(StringCchCopyEx(FilterPtr,FilterLen,CompressedFormName,&FilterPtr,&FilterLen,0)));
        }
    }

    //
    // Stick the cabinet name in there if we think there is one.
    // We do a dirty hackola to tell the difference between a tag file
    // and a cabinet, namely we look for a .cab extension.
    //
    // Note that at this point p points at the terminating nul
    // of the last filename placed into Filter.
    //
    if(Params->TagFile) {
        q = (PTSTR)pSetupGetFileTitle(Params->TagFile);
        l = lstrlen(q);

        if((l > 4) && !lstrcmpi((q+l)-4,TEXT(".cab"))) {
            MYVERIFY(SUCCEEDED(StringCchCopyEx(FilterPtr,FilterLen,TEXT(";"),&FilterPtr,&FilterLen,0))
                     && SUCCEEDED(StringCchCopyEx(FilterPtr,FilterLen,q,&FilterPtr,&FilterLen,0)));
        } else {
            q = NULL;
        }
    } else {
        q = NULL;
    }
    FilterPtr++; // skip null
    MYASSERT((FilterPtr-Filter)<SIZECHARS(Filter));
    *FilterPtr = TEXT('\0'); // final null

    MyParams.Filename1 = File;
    MyParams.Filename2 = CompressedFormName;
    MyParams.Filename3 = q;

    MYVERIFY(SUCCEEDED(StringCchCopy(Path,SIZECHARS(Path),File)));

    InitialDir[0] = TEXT('\0');
    GetDlgItemText(hdlg,Params->ComboBoxId,InitialDir,MAX_PATH);
    InitialDir[MAX_PATH-1] = TEXT('\0');

    //
    // If the initial directory is on removable media, make sure that the media
    // is present prior to firing off the common dialog.  Otherwise, the user
    // will a popup that the media isn't accessible.
    //
    DiskPromptGetDriveType(InitialDir,
                           &InitialDirDriveType,
                           &IsInitialDirOnRemovableDrive
                          );

    if(IsInitialDirOnRemovableDrive) {
        //
        // We have a removable drive--make sure the media is present.
        // if it's not, we'll probably get ERROR_INVALID_DRIVE
        // if it is, we'll either succeed or get ERROR_FILE_NOT_FOUND
        //
        InitialDirMediaPresent = (FileExists(InitialDir, NULL) ||
                                    GetLastError() == ERROR_FILE_NOT_FOUND);
    } else {
        InitialDirMediaPresent = TRUE;
    }
    ofn.lStructSize = GuiSetupInProgress ?
                            OPENFILENAME_SIZE_VERSION_400 : sizeof(OPENFILENAME);

    ofn.hwndOwner = hdlg;
    ofn.hInstance = NULL;
    ofn.lpstrFilter = Filter;
    ofn.lpstrCustomFilter = NULL;
    ofn.nMaxCustFilter = 0;
    ofn.nFilterIndex = 1;
    ofn.lpstrFile = Path;
    ofn.nMaxFile = MAX_PATH;
    ofn.lpstrFileTitle = NULL;
    ofn.nMaxFileTitle = 0;
    ofn.lpstrInitialDir = InitialDirMediaPresent ? InitialDir : NULL;
    ofn.lpstrTitle = MyLoadString(IDS_LOCATEFILE);

    ofn.Flags = OFN_HIDEREADONLY | OFN_ENABLEHOOK | OFN_NOCHANGEDIR | OFN_ENABLESIZING
              | OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST | OFN_EXPLORER | OFN_FORCESHOWHIDDEN;

    ofn.nFileOffset = 0;
    ofn.nFileExtension = 0;
    ofn.lpstrDefExt = NULL;
    ofn.lCustData = (LPARAM)&MyParams;
    ofn.lpfnHook = BrowseHookProc;
    ofn.lpTemplateName  = NULL;

    found = GetOpenFileName(&ofn);

    if(ofn.lpstrTitle) {
        MyFree(ofn.lpstrTitle);
    }

    if(CompressedFormName) {
        MyFree(CompressedFormName);
    }

    UpdateWindow(hdlg);

    if(found) {
        //
        // Remove file part, put the resulting directory in the path field
        // This does not cause the string to be added to the combo box list.
        //
        if(ofn.nFileOffset<MAX_PATH) {
            Path[ofn.nFileOffset - 1] = TEXT('\0');
        } else {
            Path[MAX_PATH-1] = TEXT('\0');
        }
        SetDlgItemText(hdlg,Params->ComboBoxId,Path);
        return(TRUE);
    }

    return(FALSE);
}


PTSTR
GetErrorDetails(
    IN PPROMPTPARAMS Params
    )

/*++

Routine Description:

    Display a message box with details about a file copy error.

Arguments:

    Params - supplies file error dialog parameters.

Return Value:

    None.

--*/

{
    PTSTR Message;
    TCHAR FullPath[MAX_PATH];
    PTSTR ErrorName;
    PTCHAR p;
    DWORD chars;
    PTSTR ShorterText = NULL;
    TCHAR TargetPath[MAX_PATH];

    //
    // Form full path name.
    //
    lstrcpyn(FullPath,Params->PathToSource,SIZECHARS(FullPath));
    pSetupConcatenatePaths(FullPath,Params->FileSought,MAX_PATH,NULL);

    //
    // try to make the path fit in our dialog
    //
    chars = ExtraChars(GetDlgItem(Params->hdlg,IDT_TEXT2),FullPath);
    if (chars) {
        ShorterText = CompactFileName(FullPath,chars);
        if (ShorterText) {
            lstrcpyn(FullPath, ShorterText,SIZECHARS(FullPath));
            MyFree(ShorterText);
            ShorterText = NULL;
        }
    }

    lstrcpyn(TargetPath, Params->TargetFile,SIZECHARS(TargetPath));
    chars = ExtraChars(GetDlgItem(Params->hdlg,IDT_TEXT2),Params->TargetFile);
    if (chars) {
        ShorterText = CompactFileName(Params->TargetFile,chars);
        if (ShorterText) {
            lstrcpyn(TargetPath, ShorterText,SIZECHARS(TargetPath));
            MyFree(ShorterText);
            ShorterText = NULL;
        }
    }

    //
    // Fetch error description. Remove trailing cr/lf if present.
    //
    ErrorName = RetreiveAndFormatMessage(Params->Win32Error);
    if(ErrorName) {
        p = ErrorName + lstrlen(ErrorName) - 1;
        while((p > ErrorName) && (*p <= TEXT(' '))) {
            *p-- = 0;
        }
    } else {
        return NULL;
    }

    Message = RetreiveAndFormatMessage(
                    MSG_FILEERROR_DETAILS1,
                    ErrorName,
                    Params->Win32Error,
                    FullPath,
                    TargetPath
                    );

    MyFree(ErrorName);

    return Message;

}


BOOL
DoPresenceCheck(
    IN PPROMPTPARAMS Params,
    IN BOOL          AllowConnectAs
    )

/*++

Routine Description:

    Check for the presence of a source file or source disk.

    If the source path is on removable media and a tag file is
    specified, we attempt to locate the tag file on the root of
    the drive specified by the source path.

    If the source path is not on removable media or a tag file
    is not specified, we look for the file (including compressed-form
    names) in the given path.

Arguments:

    Params - supplies pointer to disk prompt dialog parameters.

    AllowConnectAs - supplies a boolean indicating whether or not this
        routine should give the user a "Connect as:" dialog if they've
        typed in a UNC path that they currently don't have access to.

Return Value:

    TRUE if the disk/file is present and accessible. FALSE if not.

--*/

{
    BOOL b;
    TCHAR FileName[MAX_PATH];
    DWORD d;
    WIN32_FIND_DATA FindData;
    PTSTR p;

    //
    // If there's a tagfile then look for the tag file.
    // Otherwise look for the file in the target path -- note that the
    // file's name could be in compressed form.
    //
    if(Params->TagFile && !Params->UserBrowsed) {

        if(Params->IsRemovable) {
            //
            // Removable media. Look for tag at root.
            // If tag not found at root, look in actual directory.
            //
            MYASSERT(Params->PathToSource[0]);
            MYASSERT(Params->PathToSource[1] == TEXT(':'));

            lstrcpyn(FileName,Params->PathToSource,3);
            pSetupConcatenatePaths(FileName,Params->TagFile,MAX_PATH,NULL);

            b = FileExists(FileName,NULL);

            //
            // If we couldn't find the tagfile at the root and the path
            // is not for the root, look for the file in the path also.
            //
            // If we get here, we already know that PathToSource starts
            // with x:. We could have a path of the form x:\foo\bar
            // or x:foo\bar.
            //
            if(!b
            && Params->PathToSource[2]
            && !((Params->PathToSource[2] == TEXT('\\')) && !Params->PathToSource[3])) {

                lstrcpy(FileName,Params->PathToSource);
                pSetupConcatenatePaths(FileName,Params->TagFile,MAX_PATH,NULL);
                b = FileExists(FileName,NULL);
            }

            //
            // Additional check for removeable hard drives to allow winnt32
            // to work, because in that case there's no tagfiles!
            //
            if(Params->DriveType == DRIVE_FIXED) {
                goto check1;
            }

        } else {
            //
            // Fixed media. Look for tag in the path where the file
            // is being sought. If it's not found there, look for
            // the file itself. This logic makes cabinets work right.
            //
            lstrcpy(FileName,Params->PathToSource);
            pSetupConcatenatePaths(FileName,Params->TagFile,MAX_PATH,NULL);
            b = FileExists(FileName,NULL);

            if(!b && (Params->DriveType == DRIVE_REMOTE)) {

                d = GetLastError();

                if((d == ERROR_ACCESS_DENIED)    || (d == ERROR_WRONG_PASSWORD) ||
                   (d == ERROR_LOGON_FAILURE)    || (d == ERROR_NOT_AUTHENTICATED) ||
                   (d == ERROR_INVALID_PASSWORD) || (d == ERROR_BAD_NETPATH)) {
                    //
                    // If this is a network path, and we got 'access denied'-type of error,
                    // then give the user "Connect As" dialog (if caller specified it's OK).
                    //
                    if(AllowConnectAs && ConnectToNetShare(FileName, Params->hdlg)) {
                        //
                        // We successfully connected to the network share--now try our
                        // file existence check again.
                        //
                        b = FileExists(FileName,NULL);
                    }
                }
            }

            check1:
            if(!b && lstrcmpi(Params->TagFile,Params->FileSought)) {
                //
                // We couldn't find the tagfile and the file we're seeking is
                // not the tagfile. So now we look for the file itself
                // in the path given to us. Note that the name of the file
                // could be the compressed form.
                //
                lstrcpy(FileName,Params->PathToSource);
                pSetupConcatenatePaths(FileName,Params->FileSought,MAX_PATH,NULL);

                d = SetupDetermineSourceFileName(FileName,&b,&p,&FindData);

                if(d == NO_ERROR) {
                    MyFree(p);
                    b = TRUE;
                } else {
                    b = FALSE;
                }
            }
        }

    } else {

        lstrcpy(FileName,Params->PathToSource);
        pSetupConcatenatePaths(FileName,Params->FileSought,MAX_PATH,NULL);

        d = SetupDetermineSourceFileName(FileName,&b,&p,&FindData);

        if(Params->DriveType == DRIVE_REMOTE) {
            //
            // This is a network path.  If we got an 'access denied'-type of error, then
            // give the user "Connect As" dialog (if caller specified it's OK).
            //
            if((d == ERROR_ACCESS_DENIED)    || (d == ERROR_WRONG_PASSWORD) ||
               (d == ERROR_LOGON_FAILURE)    || (d == ERROR_NOT_AUTHENTICATED) ||
               (d == ERROR_INVALID_PASSWORD) || (d == ERROR_BAD_NETPATH)) {

                if(AllowConnectAs && ConnectToNetShare(FileName, Params->hdlg)) {
                    //
                    // We successfully connected to the network share--now try to find
                    // the source file again.
                    //
                    d = SetupDetermineSourceFileName(FileName,&b,&p,&FindData);
                }
            }
        }

        if(d == NO_ERROR) {
            MyFree(p);
            b = TRUE;
        } else {
            //
            // Make cabinet-based browse work by also looking for the tag file.
            // Note sleazy hack that matches a similar sleazy hack in DoBrowse(),
            // namely looking at extension to see if it's .cab.
            //
            b = FALSE;
            if(Params->TagFile) {
                d = lstrlen(Params->TagFile);
                if((d > 4) && !lstrcmpi((Params->TagFile+d)-4,TEXT(".cab"))) {

                    lstrcpy(FileName,Params->PathToSource);
                    pSetupConcatenatePaths(FileName,Params->TagFile,MAX_PATH,NULL);

                    d = SetupDetermineSourceFileName(FileName,&b,&p,&FindData);
                    if(b = (d == NO_ERROR)) {
                        MyFree(p);
                    }
                }
            }
        }
    }

    return(b);
}


void
__cdecl
AuxPromptThread(
    IN void *args
    )

/*++

Routine Description:

    Thread entry point to wrap DoPresenceCheck.
    Calls DoPresenceCheck and then posts a message to the prompt
    dialog indicating the outcome.

Arguments:

    args - supplies file error dialog parameters.

Return Value:

    None.

--*/

{
    PPROMPTPARAMS Params;
    BOOL b;
    HWND hwnd;

    Params = args;

#if ASSERTS_ON
    //
    // Set a flag to indicate that our presence check thread is up and running.
    //
    MYASSERT(!Params->PresenceCheckThreadRunning);
    Params->PresenceCheckThreadRunning = TRUE;
#endif // ASSERTS_ON

    hwnd = Params->hdlg;

    b = DoPresenceCheck(Params, TRUE);

#if ASSERTS_ON
    //
    // The window had better not have gone away!
    //
    MYASSERT(IsWindow(hwnd));
    //
    // Now reset the flag to indicate that our presence check thread is
    // finished.
    //
    Params->PresenceCheckThreadRunning = FALSE;
#endif // ASSERTS_ON

    //
    // Tell the dialog what we found.
    //
    PostMessage(hwnd, WMX_PRESENCE_RESULT, b, PRESENCE_RESULT_SIG);
}


VOID
PresenceCheckSetControls(
    IN PPROMPTPARAMS Params,
    IN BOOL          Starting
    )

/*++

Routine Description:

    Disable or re-enable various controls in the error/prompt dialog
    in preparation for or upon return from a file presence check.
    We do this because the presence check occurs in another thread,
    so the main dialog remains responsive. We don't want the user
    to click OK again while we're checking, etc.

Arguments:

    Params - supplies file error/disk prompt dialog parameters.

    Starting - indicates whether we are preparing for a presence check
        (TRUE) or returning from one (FALSE).

Return Value:

    None.

--*/

{
#if ASSERTS_ON
    if(!Starting) {
        Params->ControlsDisabled = FALSE;
    }
#endif // ASSERTS_ON

    EnableWindow(GetDlgItem(Params->hdlg,IDOK),!Starting);
    EnableWindow(GetDlgItem(Params->hdlg,IDCANCEL),!Starting);
    EnableWindow(GetDlgItem(Params->hdlg,Params->ComboBoxId),!Starting);

    EnableWindow(
        GetDlgItem(Params->hdlg,IDB_BROWSE),
        Starting ? FALSE : !(Params->PromptStyle & IDF_NOBROWSE)
        );

#if ASSERTS_ON
    if(Starting) {
        Params->ControlsDisabled = TRUE;
    }
#endif // ASSERTS_ON
}


BOOL
StartPresenceCheck(
    IN PPROMPTPARAMS Params
    )

/*++

Routine Description:

    Perform a presence check, doing the real work asynchronously
    in another thread. See AuxPromptThread().

Arguments:

    Params - supplies file error/disk prompt dialog parameters.

Return Value:

    Boolean value indicating whether the check could be started.
    If FALSE, assume out of memory.

--*/

{
    //
    // need to disable controls so user can't do anything
    // while we're off performing the file presence check.
    //
    PresenceCheckSetControls(Params,TRUE);

    //
    // Make sure we don't already have a presence check going on...
    //
    MYASSERT(Params->PresenceCheckState == 0);

    //
    // Set flag in prompt params to indicate we're doing a presence check.
    //
    Params->PresenceCheckState = 1;

    return(_beginthread(AuxPromptThread,0,Params) != -1);
}


BOOL
InitDiskPromptDialog(
    IN OUT PPROMPTPARAMS Params
    )

/*++

Routine Description:

    Initialize the disk prompt dialog. This involves hiding buttons
    and other control, and setting up static text controls, based on the
    prompt style specified by the caller.

Arguments:

    Params - supplies parameters for the disk prompting

Return Value:

    TRUE if success; FALSE if out of memory.

--*/

{
    int i;
    PTCHAR p,q;
    BOOL b;
    UINT IconId;
    HICON hIcon;
    HWND ComboBox;
    UINT ComboBoxId;
    HWND OtherComboBox;

    //
    // Remember parameter list
    //
    if(!SetProp(Params->hdlg,pszDiskPromptPropName,(HANDLE)Params)) {
        return(FALSE);
    }

    if(!SetWindowText(Params->hdlg,Params->DialogTitle)) {
        return(FALSE);
    }

    //
    // Figure out which combo box to use. This depends on whether
    // we're supposed to have an editable mru.
    //
    ComboBoxId = Params->ReadOnlyMru ? IDC_COMBO2 : IDC_COMBO1;
    ComboBox = GetDlgItem(Params->hdlg,ComboBoxId);
    OtherComboBox = GetDlgItem(Params->hdlg,Params->ReadOnlyMru ? IDC_COMBO1 : IDC_COMBO2);
    Params->ComboBoxId = ComboBoxId;

    ShowWindow(OtherComboBox,SW_HIDE);
    EnableWindow(OtherComboBox,FALSE);

    //
    // Set up combo box title.
    //
    p = MyLoadString((Params->PromptStyle & IDF_OEMDISK) ? IDS_COPYFROMOEM : IDS_COPYFROM);
    if(!p) {
        return(FALSE);
    }
    b = SetDlgItemText(Params->hdlg,IDT_TITLE1,p);
    MyFree(p);
    if(!b) {
        return(FALSE);
    }

    //
    // Set up the combo box.
    //
    for(i=0; i<(int)Params->PathCount; i++) {
        if(SendMessage(ComboBox,CB_ADDSTRING,0,(LPARAM)Params->PathList[i]) < 0) {
            return(FALSE);
        }
    }

    SendMessage(ComboBox,CB_LIMITTEXT,MAX_PATH,0);

    if(Params->ReadOnlyMru) {
        //
        // Select the first string in the list.
        //
        SendMessage(ComboBox,CB_SETCURSEL,0,0);
    } else {
        //
        // Set text of combo box to the path we're searching along.
        // This does not cause the string to be added to the combo box list.
        //
        if(!SetDlgItemText(Params->hdlg,ComboBoxId,Params->PathToSource)) {
            return(FALSE);
        }

#ifdef UNICODE

        if(Params->BrowseAutoComplete) {
            SHAutoComplete(GetWindow(ComboBox, GW_CHILD), SHACF_FILESYS_DIRS);
        }
#endif

    }

    //
    // Hide buttons if necessary.
    //
    if(Params->PromptStyle & IDF_NOBROWSE) {
        ShowWindow(GetDlgItem(Params->hdlg,IDB_BROWSE),SW_HIDE);
        EnableWindow(GetDlgItem(Params->hdlg,IDB_BROWSE),FALSE);
    }

    //
    // Set icon.
    //
    if(Params->DialogType == DLGTYPE_ERROR) {
        hIcon = LoadIcon(NULL,IDI_HAND);
    } else {
        switch(Params->DriveType) {

        case DRIVE_REMOTE:
            IconId = ICON_NETWORK;
            break;

        case DRIVE_CDROM:
            IconId = ICON_CD;
            break;

        case DRIVE_FIXED:
            IconId = ICON_HARD;
            break;

        case DRIVE_REMOVABLE:
        default:
            IconId = ICON_FLOPPY;
            break;
        }

        hIcon = LoadIcon(MyDllModuleHandle,MAKEINTRESOURCE(IconId));
    }

    if(hIcon) {
        SendDlgItemMessage(Params->hdlg,IDI_ICON1,STM_SETICON,(WPARAM)hIcon,0);
    }

    return(TRUE);
}


BOOL
SetDiskPromptDialogText(
    IN OUT PPROMPTPARAMS Params
    )

/*++

Routine Description:

    Set up static text fields that explain to the user what is requested
    and what he has to do to continue. These fields depend on whether we're
    prompting for an oem disk, whether the file is on removable media, and
    whether a tag file has been specified.

Arguments:

    Params - supplies parameters for the disk prompting

Return Value:

    TRUE if success; FALSE if out of memory.

--*/

{
    BOOL b;
    PTSTR p;

    if(Params->DialogType == DLGTYPE_PROMPT) {
        //
        // There are 2 text fields - the explanation and action.
        // What the text looks like depends on the prompt style flags,
        // whether the file is on removable media, etc.
        //
        // First handle the explanation text.
        //
        if (Params->PromptStyle & IDF_USEDISKNAMEASPROMPT) {
            b = SetDlgItemText(Params->hdlg,IDT_TEXT1,Params->DiskName);
        } else {
            if(Params->PromptStyle & IDF_OEMDISK) {
                p = MyLoadString(IDS_DISKPROMPTOEM);
            } else {
                if(Params->IsRemovable && Params->TagFile) {
                    p = FormatStringMessage(IDS_DISKPROMPT1,Params->DiskName);
                } else {
                    p = FormatStringMessage(IDS_DISKPROMPT2,Params->FileSought,Params->DiskName);
                }
            }

            if(!p) {
                return(FALSE);
            }

            b = SetDlgItemText(Params->hdlg,IDT_TEXT1,p);

            MyFree(p);
        }


        if(!b) {
            return(FALSE);
        }

        //
        // Now handle the explanation text. This is hidden for oem disks.
        //
        if(Params->PromptStyle & IDF_OEMDISK) {

            ShowWindow(GetDlgItem(Params->hdlg,IDT_TEXT2),SW_HIDE);
            EnableWindow(GetDlgItem(Params->hdlg,IDT_TEXT2),FALSE);

        } else {
            if(Params->IsRemovable && Params->TagFile) {
                p = FormatStringMessage(IDS_PROMPTACTION1,Params->DiskName);
            } else {
                p = MyLoadString(IDS_PROMPTACTION2);
            }

            if(!p) {
                return(FALSE);
            }

            b = SetDlgItemText(Params->hdlg,IDT_TEXT2,p);

            MyFree(p);
            if(!b) {
                return(FALSE);
            }
        }
    } else {
        if(Params->DialogType != DLGTYPE_ERROR) {
            return(FALSE);
        }

        p = MyLoadString(IDS_RETRY);
        if (!p) {
            return(FALSE);
        }

        b = SetDlgItemText(Params->hdlg,IDOK,p);
        MyFree(p);
        if (!b) {
            return(FALSE);
        }

        //
        // Explanation text -- "An error occurred copying a file" etc.
        //
        p = FormatStringMessage(IDS_FILEERRCOPY,Params->FileSought);
        if(!p) {
            return(FALSE);
        }
        b = SetDlgItemText(Params->hdlg,IDT_TEXT1,p);

        MyFree(p);
        if(!b) {
            return(FALSE);
        }

        //
        // Action text.
        //

        if (Params->Win32Error != ERROR_DIRECTORY &&
            Params->Win32Error != ERROR_DISK_FULL) {
            if(Params->PromptStyle & IDF_OEMDISK) {
                p = MyLoadString(IDS_COPYERROROEM);
            } else {
                if(Params->IsRemovable) {
                    p = FormatStringMessage(IDS_COPYERROR1,Params->DiskName);
                } else {
                    p = FormatStringMessage(IDS_COPYERROR2,Params->DiskName);
                }
            }
        } else {
            p = GetErrorDetails(Params);
        }


        if(!p) {
            return(FALSE);
        }

        b = SetDlgItemText(Params->hdlg,IDT_TEXT2,p);

        MyFree(p);
        if(!b) {
            return(FALSE);
        }
    }

    return(TRUE);
}


BOOL
WarnSkip(
    IN HWND hwnd,
    IN BOOL Skip
    )

/*++

Routine Description:

    Warn the user that skipping the file or cancelling
    can tank the system.

Arguments:

    hwnd - supplies window handle for window to own the message box
        this routine will display.

    Skip - if TRUE, user is trying to skip the file; FALSE means
        he is trying to cancel.

Return Value:

    TRUE if user wants to skip file/cancel; false otherwise.

--*/

{
    PCTSTR Caption;
    PCTSTR Message;
    BOOL b;

    b = TRUE;
    if(Caption = MyLoadString(IDS_WARNING)) {

        if(Message = MyLoadString(Skip ? IDS_SURESKIP : IDS_SURECANCEL)) {

            b = (MessageBox(hwnd,Message,Caption,MB_YESNO|MB_ICONWARNING|MB_DEFBUTTON2) == IDYES);

            MyFree(Message);
        }

        MyFree(Caption);
    }

    return(b);
}


BOOL
CancelAllCopies(
    IN HWND hwnd
    )

/*++

Routine Description:

    ask the user if they want to cancel copying one file or all files

Arguments:

    hwnd - supplies window handle for window to own the message box
        this routine will display.

Return Value:


    TRUE if user wants to cancel just this copy (really the same as skipping a file)
    FALSE if user wants to cancel all copies;

--*/

{
    PCTSTR Caption;
    PCTSTR Message;
    BOOL b;

    b = TRUE;
    if(Caption = MyLoadString(IDS_COPYERROR)) {

        if(Message = MyLoadString(IDS_CANCELALL)) {

            b = (MessageBox(hwnd,Message,Caption,MB_YESNO|MB_ICONWARNING|MB_DEFBUTTON2) == IDYES);

            MyFree(Message);
        }

        MyFree(Caption);
    }

    return(b);
}

INT_PTR
DlgProcSimplePrompt(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )

/*++

Routine Description:

    Dialog procedure for disk prompting dialog.

    The return value for the dialog is

    DPROMPT_CANCEL  - user cancelled
    DPROMPT_SKIPFILE    - user elected to skip file
    DPROMPT_SUCCESS - disk is in the drive/we found the file we're looking for
    DPROMPT_OUTOFMEMORY     - out of memory

Arguments:

    Standard dialog routine parameters.

Return Value:

    TRUE if message processed; FALSE if not.

--*/

{
    BOOL b = FALSE;
    TCHAR Text[MAX_PATH];
    PPROMPTPARAMS PromptParams;
    BOOL WarnIfSkip;
    BOOL ReallyCancel;
    HICON hIcon;
    static DWORD UnitMask = 0xFFFFFFFF;

    switch(msg) {

    case WM_INITDIALOG:

        PromptParams = (PPROMPTPARAMS)lParam;
        MYASSERT(PromptParams != NULL);

        if(!SetProp(hdlg,pszDiskPromptPropName,(HANDLE)&(PromptParams->MsgBoxParams))) {
            EndDialog(hdlg,DPROMPT_OUTOFMEMORY);
            break;
        }

        if(!SetWindowText(hdlg,PromptParams->MsgBoxParams.lpszCaption)) {
            EndDialog(hdlg,DPROMPT_OUTOFMEMORY);
            break;
        }

        if(!SetWindowText(hdlg,PromptParams->MsgBoxParams.lpszCaption)) {
            EndDialog(hdlg,DPROMPT_OUTOFMEMORY);
            break;
        }

        if (!SetDlgItemText(hdlg,IDT_TEXT1,PromptParams->MsgBoxParams.lpszText)) {
            EndDialog(hdlg,DPROMPT_OUTOFMEMORY);
            break;
        }

        hIcon = LoadIcon(MyDllModuleHandle,PromptParams->MsgBoxParams.lpszIcon);

        if(hIcon) {
            SendDlgItemMessage(hdlg,IDI_ICON1,STM_SETICON,(WPARAM)hIcon,0);
        }

        pSetupCenterWindowRelativeToParent(hdlg);

        if ((PromptParams->PathToSource[0] != TEXT('\0')) &&
             _istalpha(PromptParams->PathToSource[0])) {
            UnitMask = (1 << (_totupper(PromptParams->PathToSource[0]) - TEXT('A')));
        }

        b = FALSE;
        break;

    case WM_DEVICECHANGE:
        if ((wParam == DBT_DEVICEARRIVAL) &&
            (((PDEV_BROADCAST_VOLUME)lParam)->dbcv_devicetype == DBT_DEVTYP_VOLUME) &&
            (((PDEV_BROADCAST_VOLUME)lParam)->dbcv_flags & DBTF_MEDIA) &&
            (((PDEV_BROADCAST_VOLUME)lParam)->dbcv_unitmask == UnitMask)) {
            //
            // The user inserted a CD or removable media into the source drive,
            // so do an automatic OK so we can check this new media.
            //
            PostMessage(hdlg, WM_COMMAND, MAKELPARAM(IDOK, BN_CLICKED), 0L);
        }
        break;

    case WM_COMMAND:

        if(HIWORD(wParam) == BN_CLICKED) {
            b = TRUE;
            EndDialog(hdlg,LOWORD(wParam));
            break;

        } else {
            b = FALSE;
        }
        break;

    case WM_DESTROY:

        //
        // Nothing to do about this if it fails.
        // Note: the return value is typically a pointer to stack data
        //
        RemoveProp(hdlg,pszDiskPromptPropName);
        //
        // Let default processing take place by indicating that
        // we didn't process this message
        //
        b = FALSE;
        break;

    default:
        if (!g_uQueryCancelAutoPlay) {
            g_uQueryCancelAutoPlay = RegisterWindowMessage(TEXT("QueryCancelAutoPlay"));
        }

        if (msg == g_uQueryCancelAutoPlay) {
            SetWindowLongPtr( hdlg, DWLP_MSGRESULT, 1 );
            return 1;       // cancel auto-play
        }


        b = FALSE;
        break;
    }

    return(b);
}



INT_PTR
DlgProcDiskPrompt1(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )

/*++

Routine Description:

    Dialog procedure for disk prompting dialog.

    The return value for the dialog is

    DPROMPT_CANCEL  - user cancelled
    DPROMPT_SKIPFILE    - user elected to skip file
    DPROMPT_SUCCESS - disk is in the drive/we found the file we're looking for
    DPROMPT_OUTOFMEMORY     - out of memory

Arguments:

    Standard dialog routine parameters.

Return Value:

    TRUE if message processed; FALSE if not.

--*/

{
    BOOL b = FALSE;
    PPROMPTPARAMS PromptParams;
    TCHAR Text[MAX_PATH];
    BOOL WarnIfSkip;
    BOOL ReallyCancel;
    static DWORD UnitMask = 0xFFFFFFFF;

    switch(msg) {

    case WM_INITDIALOG:

        PromptParams = (PPROMPTPARAMS)lParam;
        MYASSERT( PromptParams != NULL );
        PromptParams->hdlg = hdlg;

        //
        // Initialize the dialog.
        //
        if(InitDiskPromptDialog(PromptParams) && SetDiskPromptDialogText(PromptParams)) {
            //
            // Set focus to directory combobox and continue.
            //
            SetFocus(GetDlgItem(hdlg, PromptParams->ReadOnlyMru ? IDC_COMBO2 : IDC_COMBO1));
        } else {
            //
            // Out of memory.
            //
            b = TRUE;
            EndDialog(hdlg,DPROMPT_OUTOFMEMORY);
            break;
        }

        //
        // Indicate to windows that we set the focus.
        //
        b = FALSE;

        if(!(PromptParams->PromptStyle & IDF_NOBEEP)) {
            MessageBeep(MB_ICONASTERISK);
        }

        if ((PromptParams->PathToSource[0] != TEXT('\0')) &&
            _istalpha(PromptParams->PathToSource[0])) {
            UnitMask = (1 << (_totupper(PromptParams->PathToSource[0]) - TEXT('A')));
        }

        pSetupCenterWindowRelativeToParent(hdlg);

        PostMessage(hdlg,WMX_HELLO,0,0);
        break;

    case WMX_HELLO:

        b = TRUE;
        PromptParams = (PPROMPTPARAMS)GetProp(hdlg,pszDiskPromptPropName);
        MYASSERT(PromptParams != NULL);

        if(PromptParams && !(PromptParams->PromptStyle & IDF_NOFOREGROUND)) {
            SetForegroundWindow(hdlg);
        }
        break;

    case WM_DEVICECHANGE:
        if ((wParam == DBT_DEVICEARRIVAL) &&
            (((PDEV_BROADCAST_VOLUME)lParam)->dbcv_devicetype == DBT_DEVTYP_VOLUME) &&
            (((PDEV_BROADCAST_VOLUME)lParam)->dbcv_flags & DBTF_MEDIA) &&
            (((PDEV_BROADCAST_VOLUME)lParam)->dbcv_unitmask == UnitMask)) {
            //
            // The user inserted a CD or removable media into the source drive,
            // so do an automatic OK so we can check this new media.
            //
            PostMessage(hdlg, WM_COMMAND, MAKELPARAM(IDOK, BN_CLICKED), 0L);
        }
        break;

    case WM_COMMAND:

        if(HIWORD(wParam) == BN_CLICKED) {

            PromptParams = (PPROMPTPARAMS)GetProp(hdlg,pszDiskPromptPropName);
            MYASSERT(PromptParams != NULL);

            WarnIfSkip = (PromptParams && (PromptParams->PromptStyle & IDF_WARNIFSKIP));

            b = TRUE;
            switch(LOWORD(wParam)) {

            case IDOK:
                //
                // We'd better not get here if controls are disabled!
                //
                MYASSERT(!PromptParams->ControlsDisabled);

                //
                // User might have changed the source path.
                // Get the current path from the combo's edit control
                //
                Text[0] = TEXT('\0'); // default value
                GetDlgItemText(hdlg,PromptParams->ComboBoxId,Text,SIZECHARS(Text));
                Text[SIZECHARS(Text)-1] = TEXT('\0'); // make sure it's terminated.
                MyFree(PromptParams->PathToSource);
                PromptParams->PathToSource = DuplicateString(Text);
                DiskPromptGetDriveType(Text,&PromptParams->DriveType,&PromptParams->IsRemovable);

                //
                // See whether we can get at the file.
                //
                if(!PromptParams->PathToSource || !StartPresenceCheck(PromptParams)) {
                    EndDialog(hdlg,DPROMPT_OUTOFMEMORY);
                }
                break;

            case IDCANCEL:
                //
                // We'd better not get here if controls are disabled!
                //
                MYASSERT(!PromptParams->ControlsDisabled);

                //
                // ask if they want to cancel all copies or just cancel one copy
                //
                if (PromptParams->DialogType != DLGTYPE_ERROR) {
                    ReallyCancel = TRUE;
                } else {
                    if (PromptParams->PromptStyle & IDF_NOSKIP) {
                        ReallyCancel = TRUE;
                    } else {
                        ReallyCancel = !CancelAllCopies(hdlg);
                    }
                }


                if(WarnIfSkip ? WarnSkip(hdlg,!ReallyCancel) : TRUE) {
                    //
                    // If we're currently doing a file presence check, then
                    // just increment our PresenceCheckState value, and defer
                    // the EndDialog until receipt of WMX_PRESENCE_RESULT.
                    //
                    if (ReallyCancel) {
                        if(PromptParams->PresenceCheckState == 0) {
                            EndDialog(hdlg,DPROMPT_CANCEL);
                        } else {
                            (PromptParams->PresenceCheckState)++;
                        }
                    } else {
                        EndDialog(hdlg,DPROMPT_SKIPFILE);
                    }
                }
                break;

            case IDB_BROWSE:
                //
                // We'd better not get here if controls are disabled!
                //
                MYASSERT(!PromptParams->ControlsDisabled);

                if(DoBrowse(hdlg,PromptParams)) {
                    PromptParams->UserBrowsed = TRUE;
                }
                break;

            default:
                b = FALSE;
                break;
            }

        } else {
            b = FALSE;
        }
        break;

    case WM_DESTROY:

#if ASSERTS_ON
        //
        // We'd better not have an outstanding presence check thread running!
        //
        PromptParams = (PPROMPTPARAMS)GetProp(hdlg, pszDiskPromptPropName);
        MYASSERT(PromptParams != NULL);

        if(PromptParams) {
            MYASSERT(!PromptParams->PresenceCheckThreadRunning);
        }

#endif // ASSERTS_ON

        //
        // Nothing to do about this if it fails.
        //
        RemoveProp(hdlg,pszDiskPromptPropName);
        //
        // Let default processing take place by indicating that
        // we didn't process this message
        //
        b = FALSE;
        break;

    case WMX_PRESENCE_RESULT:
        //
        // Make sure this message came from AuxPromptThread--we've seen weird
        // stress failures indicating that someone else was sending us this
        // message from time to time.
        //
        MYASSERT(lParam == PRESENCE_RESULT_SIG);

        //
        // In case the above does happen, just ignore this message...
        //
        if(lParam != PRESENCE_RESULT_SIG) {
            b = FALSE;
            break;
        }

        b = TRUE;
        PromptParams = (PPROMPTPARAMS)GetProp(hdlg,pszDiskPromptPropName);

        //
        // Also, we don't expect to get this message unless we actually had a
        // presence check thread running.
        //
        MYASSERT(PromptParams != NULL);
        MYASSERT(PromptParams->PresenceCheckState);

        //
        // If the user pressed cancel while we were off doing our presence
        // check, then honor that request now.
        //
        if(PromptParams->PresenceCheckState > 1) {
            EndDialog(hdlg, DPROMPT_CANCEL);
        }

        //
        // Aux thread is telling us that it knows whether the file is present.
        // wParam has the boolean.
        // PromptParams->PathToSource is already set.
        //
        if(wParam) {
            EndDialog(hdlg,DPROMPT_SUCCESS);
        } else {

            //
            // File/disk is not accessible. Don't end the dialog.
            //
            if(!(PromptParams->PromptStyle & IDF_NOFOREGROUND)) {
                SetForegroundWindow(hdlg);
            }

            //
            // If we're searching for a directory containing INFs (e.g.,
            // SetupDiSelectOEMDrv), then we want to popup a message informing
            // the user that the location they've specified doesn't contain
            // information about their hardware.  Otherwise, we want to maintain
            // the file prompt behavior of just beeping.
            //
            if(lstrcmpi(PromptParams->FileSought, pszInfWildcard)) {
                if(!(PromptParams->PromptStyle & IDF_NOBEEP)) {
                    MessageBeep(MB_ICONASTERISK);
                }
            } else {
                if(!LoadString(MyDllModuleHandle,
                               IDS_SELECT_DEVICE,
                               Text,
                               SIZECHARS(Text))) {
                    *Text = TEXT('\0');
                }

                FormatMessageBox(MyDllModuleHandle,
                                 NULL,
                                 MSG_NO_DEVICEINFO_ERROR,
                                 Text,
                                 MB_OK | MB_TASKMODAL
                                );
            }

            //
            // Reset value indicating we're no longer doing a presence check.
            //
            PromptParams->PresenceCheckState = 0;

            //
            // Restore controls that were disabled when we started the presence check.
            //
            PresenceCheckSetControls(PromptParams,FALSE);

            SetFocus(GetDlgItem(hdlg,PromptParams->ComboBoxId));
        }
        break;

    default:
        if (!g_uQueryCancelAutoPlay) {
            g_uQueryCancelAutoPlay = RegisterWindowMessage(TEXT("QueryCancelAutoPlay"));
        }

        if (msg == g_uQueryCancelAutoPlay) {
            SetWindowLongPtr( hdlg, DWLP_MSGRESULT, 1 );
            return 1;       // cancel auto-play
        }


        b = FALSE;
        break;
    }

    return(b);
}


VOID
ModifyPathList(
    IN PPROMPTPARAMS Params
    )

/*++

Routine Description:

    Modifies a list of installation paths kept in the registry.
    The existing list is scanned for the path the user accepted in the disk
    prompt dialog. That path is added if not already in the list.

Arguments:

    Params - supplies disk prompt dialog parameters.

Return Value:

    None. If any part of the operation, the list simply doesn't get updated
    in the registry.

--*/

{
    //
    // Params->PathToSource will be the final path entered by the user
    // in the combo box. Add to list. If this fails, oh well.
    //
    SetupAddToSourceList(SRCLIST_SYSIFADMIN,Params->PathToSource);
}


UINT
_SetupPromptForDisk(
    IN  HWND   hwndParent,
    IN  PCTSTR DialogTitle,      OPTIONAL
    IN  PCTSTR DiskName,         OPTIONAL
    IN  PCTSTR PathToSource,     OPTIONAL
    IN  PCTSTR FileSought,
    IN  PCTSTR TagFile,          OPTIONAL
    IN  DWORD  DiskPromptStyle,
    OUT PTSTR  PathBuffer,
    IN  DWORD  PathBufferSize,
    OUT PDWORD PathRequiredSize  OPTIONAL
    )
{
    PROMPTPARAMS Params;
    INT_PTR i;
    TCHAR Buffer[256];
    DWORD d;
    DWORD ResultPathLen;
    PTSTR Message;
    HANDLE hDialogEvent = NULL;
    BOOL PromptUser = FALSE;

    //
    // If we're running non-interactive, bail now.  Unless, that is, we've been
    // instructed to check for the presence of the source file _before_ doing
    // any UI, in which case we can hang around until we do our presence check
    // down below.
    //
    if((GlobalSetupFlags & (PSPGF_NONINTERACTIVE|PSPGF_UNATTENDED_SETUP)) &&
       !(DiskPromptStyle & IDF_CHECKFIRST)) {

        SetLastError(ERROR_REQUIRES_INTERACTIVE_WINDOWSTATION);
        return DPROMPT_CANCEL;
    }

    //
    // It is illegal to specify both the IDF_USEDISKNAMEASPROMPT and the
    // IDF_OEMDISK flag.  This is due to the fact that they both cause
    // a different style of UI text to be displayed that would conflict
    // with itself.
    //
    if ((DiskPromptStyle & IDF_USEDISKNAMEASPROMPT) &&
        (DiskPromptStyle & IDF_OEMDISK)) {

        SetLastError(ERROR_INVALID_PARAMETER);
        return DPROMPT_CANCEL;
    }

    ZeroMemory(&Params,sizeof(PROMPTPARAMS));

    //
    // Determine the path to the source. Start by fetching the entire
    // installation locations list for the current user.
    //
    d = pSetupGetList(0,&Params.PathList,&Params.PathCount,&Params.ReadOnlyMru);
    if(d != NO_ERROR) {
        i = DPROMPT_OUTOFMEMORY;
        goto c0;
    }

    if(PathToSource) {
        //
        // Code in dialog box relies on being able to free this
        // so duplicate it here.
        //
        Params.PathToSource = DuplicateString(PathToSource);
    } else {
        if(Params.PathCount) {
            Params.PathToSource = DuplicateString(Params.PathList[0]);
        } else {
            //
            // Nothing in system path lists. Use a reasonable default.
            //
            Params.PathToSource = DuplicateString(pszOemInfDefaultPath);
        }
    }
    if(!Params.PathToSource) {
        i = DPROMPT_OUTOFMEMORY;
        d = ERROR_NOT_ENOUGH_MEMORY;
        goto c1;
    }

    //
    // Determine the drive type of the source path.
    //
    DiskPromptGetDriveType(Params.PathToSource,&Params.DriveType,&Params.IsRemovable);

    //
    // If the disk name wasn't specified, fetch a default.
    //
    if(DiskName) {
        Params.DiskName = DiskName;
    } else {
        Params.DiskName = MyLoadString(IDS_UNKNOWN_PARENS);
        if(!Params.DiskName) {
            i = DPROMPT_OUTOFMEMORY;
            d = ERROR_NOT_ENOUGH_MEMORY;
            goto c2;
        }
    }

    //
    // If a dialog title wasn't specified, try to get text from parent window.
    //
    if(DialogTitle) {
        Params.DialogTitle = DialogTitle;
    } else {

        if(Params.Owner
        && (i = GetWindowTextLength(Params.Owner))
        && GetWindowText(Params.Owner,Buffer,sizeof(Buffer)/sizeof(TCHAR))) {

            Params.DialogTitle = FormatStringMessage(IDS_FILESNEEDED2,Buffer);
        } else {
            Params.DialogTitle = MyLoadString(IDS_FILESNEEDED);
        }

        if(!Params.DialogTitle) {
            i = DPROMPT_OUTOFMEMORY;
            d = ERROR_NOT_ENOUGH_MEMORY;
            goto c3;
        }
    }

    Params.TagFile = TagFile;

    //
    // Validate parent window.
    //
    Params.Owner = IsWindow(hwndParent) ? hwndParent : NULL;

    //
    // Fill in other fields.
    //
    if((Params.FileSought = FileSought) == NULL) {
        i = DPROMPT_CANCEL;
        d = ERROR_INVALID_PARAMETER;
        goto c4;
    }
    Params.Owner = hwndParent;
    Params.PromptStyle = DiskPromptStyle | IDF_NODETAILS;
    Params.hdlg = NULL;
    Params.UserBrowsed = FALSE;
    Params.DialogType = DLGTYPE_PROMPT;
    Params.TargetFile = NULL;

    if(Params.ReadOnlyMru) {
        Params.PromptStyle |= IDF_NOBROWSE;
    }

    if (GuiSetupInProgress) {
        hDialogEvent = CreateEvent(NULL,TRUE,FALSE,SETUP_HAS_OPEN_DIALOG_EVENT);
    }

    //
    // If we're supposed to, check for the disk/file first.
    //
    if((DiskPromptStyle & IDF_CHECKFIRST) && DoPresenceCheck(&Params, FALSE)) {

        i = DPROMPT_SUCCESS;
        d = NO_ERROR;

    } else if(GlobalSetupFlags & (PSPGF_NONINTERACTIVE|PSPGF_UNATTENDED_SETUP)) {

        i = DPROMPT_CANCEL;
        d = ERROR_REQUIRES_INTERACTIVE_WINDOWSTATION;

    } else {
        //
        // Before invoking the dialog, we will prompt the user with a simple
        // message box in some cases to avoid the user ever actually seeing
        // a path in the more complicated prompt dialog.
        //
        if(DiskName &&
           !(DiskPromptStyle & IDF_NOREMOVABLEMEDIAPROMPT) &&
           ((Params.DriveType == DRIVE_REMOVABLE) || (Params.DriveType == DRIVE_CDROM))) {

            Message = RetreiveAndFormatMessage(
                        (Params.DriveType == DRIVE_CDROM)
                          ? ( GuiSetupInProgress ? MSG_CDPROMPT_NONETWORK :  MSG_CDPROMPT )
                          : ( GuiSetupInProgress ? MSG_FLOPPYPROMPT_NONETWORK :  MSG_FLOPPYPROMPT ),
                        DiskName,
                        (TCHAR)CharUpper((PTSTR)Params.PathToSource[0])
                        );

            if(Message) {

                LoadString(MyDllModuleHandle,IDS_PROMPTTITLE,Buffer,sizeof(Buffer)/sizeof(TCHAR));
                if(!(DiskPromptStyle & IDF_NOBEEP)) {
                    MessageBeep(MB_ICONASTERISK);
                }

                reprompt:
                Params.MsgBoxParams.cbSize = sizeof(MSGBOXPARAMS);
                Params.MsgBoxParams.hwndOwner = hwndParent;
                Params.MsgBoxParams.hInstance = MyDllModuleHandle;
                Params.MsgBoxParams.lpszText = Message;
                Params.MsgBoxParams.lpszCaption = Buffer;
                Params.MsgBoxParams.dwStyle = MB_USERICON | MB_OKCANCEL;

                Params.MsgBoxParams.lpszIcon = (Params.DriveType == DRIVE_CDROM)
                                      ? MAKEINTRESOURCE(ICON_CD)
                                      : MAKEINTRESOURCE(ICON_FLOPPY);

                Params.MsgBoxParams.lpfnMsgBoxCallback = NULL;
                Params.MsgBoxParams.dwLanguageId = LANG_NEUTRAL;


                if (hDialogEvent) {
                    SetEvent(hDialogEvent);
                }

                switch(DialogBoxParam(
                            MyDllModuleHandle,
                            MAKEINTRESOURCE(IDD_SIMPLEPROMPT),
                            hwndParent,
                            DlgProcSimplePrompt,
                            (LPARAM)&Params
                            )) {

                case DPROMPT_OUTOFMEMORY:
                    i = DPROMPT_OUTOFMEMORY;
                    d = ERROR_NOT_ENOUGH_MEMORY;
                    break;

                case IDOK:
                    if(DoPresenceCheck(&Params, FALSE)) {
                        i = DPROMPT_SUCCESS;
                        d = NO_ERROR;
                    } else {
                        i = DPROMPT_SKIPFILE;
                    }
                    break;

                case IDCANCEL:
                    d = ERROR_CANCELLED;
                    i = DPROMPT_CANCEL;
                    if((DiskPromptStyle & IDF_WARNIFSKIP) && !WarnSkip(hwndParent,FALSE)) {
                        goto reprompt;
                    }
                    break;
                default:
                    MYASSERT( FALSE );
                }

                if (hDialogEvent) {
                    ResetEvent(hDialogEvent);
                }

                MyFree(Message);
            } else {
                i = DPROMPT_OUTOFMEMORY;
                d = ERROR_NOT_ENOUGH_MEMORY;
                goto c4;
            }
        } else {
            i = DPROMPT_SKIPFILE;
        }

        if(i == DPROMPT_SKIPFILE) {

            if (hDialogEvent) {
                SetEvent(hDialogEvent);
            }

            Params.BrowseAutoComplete = FALSE;
            if(!GuiSetupInProgress) {
                d = OleInitialize(NULL);
                if(SUCCEEDED(d)) {
                    Params.BrowseAutoComplete = TRUE;
                }
            }
            i = DialogBoxParam(
                    MyDllModuleHandle,
                    MAKEINTRESOURCE(IDD_DISKPROMPT1),
                    hwndParent,
                    DlgProcDiskPrompt1,
                    (LPARAM)&Params
                    );
            if(!GuiSetupInProgress && (d==NO_ERROR)) {
                OleUninitialize();
            }

            if (hDialogEvent) {
                ResetEvent(hDialogEvent);
            }

            switch(i) {

            case DPROMPT_SUCCESS:
                PromptUser = TRUE;
                d = NO_ERROR;
                break;

            case DPROMPT_SKIPFILE:
                d = NO_ERROR;
                break;

            case DPROMPT_CANCEL:
                d = ERROR_CANCELLED;
                break;

            case DPROMPT_BUFFERTOOSMALL:
                d = ERROR_INSUFFICIENT_BUFFER;
                break;

            default:
                i = DPROMPT_OUTOFMEMORY;
                d = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }
        }
    }

    //
    // If success, we want to add the path string to the list of path strings
    // if it's not already in there.
    //
    if(i == DPROMPT_SUCCESS) {

        //
        // Only add the file to the MRU list if we prompted the user and
        // they entered a valid path.
        //
        if (PromptUser) {

            ModifyPathList(&Params);
        }

        //
        // Now determine what to return to the user depending on the
        // buffer and sizes passed in.
        //
        ResultPathLen = lstrlen(Params.PathToSource)+1;
        if(PathRequiredSize) {
            *PathRequiredSize = ResultPathLen;
        }
        if(PathBuffer) {
            if(ResultPathLen > PathBufferSize) {
                i = DPROMPT_BUFFERTOOSMALL;
            } else {
                lstrcpy(PathBuffer,Params.PathToSource);
            }
        }
    }

c4:
    if (hDialogEvent) {
        CloseHandle(hDialogEvent);
    }

    if(!DialogTitle) {
        MyFree(Params.DialogTitle);
    }
c3:
    if(!DiskName) {
        MyFree(Params.DiskName);
    }
c2:
    MyFree(Params.PathToSource);
c1:
    SetupFreeSourceList(&Params.PathList,Params.PathCount);
c0:
    SetLastError(d);
    return((UINT)i);
}

#ifdef UNICODE
//
// ANSI version
//
UINT
SetupPromptForDiskA(
    IN  HWND   hwndParent,
    IN  PCSTR  DialogTitle,      OPTIONAL
    IN  PCSTR  DiskName,         OPTIONAL
    IN  PCSTR  PathToSource,     OPTIONAL
    IN  PCSTR  FileSought,
    IN  PCSTR  TagFile,          OPTIONAL
    IN  DWORD  DiskPromptStyle,
    OUT PSTR   PathBuffer,
    IN  DWORD  PathBufferSize,
    OUT PDWORD PathRequiredSize  OPTIONAL
    )
{
    PCWSTR dialogTitle;
    PCWSTR diskName;
    PCWSTR pathToSource;
    PCWSTR fileSought;
    PCWSTR tagFile;
    WCHAR pathBuffer[MAX_PATH];
    CHAR ansiBuffer[MAX_PATH];
    DWORD rc;
    UINT u;
    DWORD Size;

    dialogTitle = NULL;
    diskName = NULL;
    pathToSource = NULL;
    fileSought = NULL;
    tagFile = NULL;
    rc = NO_ERROR;

    if(DialogTitle) {
        rc = pSetupCaptureAndConvertAnsiArg(DialogTitle,&dialogTitle);
    }
    if((rc == NO_ERROR) && DiskName) {
        rc = pSetupCaptureAndConvertAnsiArg(DiskName,&diskName);
    }
    if((rc == NO_ERROR) && PathToSource) {
        rc = pSetupCaptureAndConvertAnsiArg(PathToSource,&pathToSource);
    }
    if((rc == NO_ERROR) && FileSought) {
        rc = pSetupCaptureAndConvertAnsiArg(FileSought,&fileSought);
    }
    if((rc == NO_ERROR) && TagFile) {
        rc = pSetupCaptureAndConvertAnsiArg(TagFile,&tagFile);
    }

    if(rc == NO_ERROR) {

        u = _SetupPromptForDisk(
                hwndParent,
                dialogTitle,
                diskName,
                pathToSource,
                fileSought,
                tagFile,
                DiskPromptStyle,
                pathBuffer,
                MAX_PATH,
                &Size
                );

        rc = GetLastError();

        if(u == DPROMPT_SUCCESS) {

            Size = (DWORD)WideCharToMultiByte(
                            CP_ACP,
                            0,
                            pathBuffer,
                            (int)Size,
                            ansiBuffer,
                            MAX_PATH,
                            NULL,
                            NULL
                            );

            if(PathRequiredSize) {
                *PathRequiredSize = Size;
            }

            if(PathBuffer) {
                if(Size > PathBufferSize) {
                    u = DPROMPT_BUFFERTOOSMALL;
                } else {
                    lstrcpynA(PathBuffer,ansiBuffer,Size);
                }
            }
        }
    } else {
        u = (rc == ERROR_NOT_ENOUGH_MEMORY) ? DPROMPT_OUTOFMEMORY : DPROMPT_CANCEL;
    }

    if(dialogTitle) {
        MyFree(dialogTitle);
    }
    if(diskName) {
        MyFree(diskName);
    }
    if(pathToSource) {
        MyFree(pathToSource);
    }
    if(fileSought) {
        MyFree(fileSought);
    }
    if(tagFile) {
        MyFree(tagFile);
    }

    SetLastError(rc);
    return(u);
}
#else
//
// Unicode stub
//
UINT
SetupPromptForDiskW(
    IN  HWND   hwndParent,
    IN  PCWSTR DialogTitle,      OPTIONAL
    IN  PCWSTR DiskName,         OPTIONAL
    IN  PCWSTR PathToSource,     OPTIONAL
    IN  PCWSTR FileSought,
    IN  PCWSTR TagFile,          OPTIONAL
    IN  DWORD  DiskPromptStyle,
    OUT PWSTR  PathBuffer,
    IN  DWORD  PathBufferSize,
    OUT PDWORD PathRequiredSize  OPTIONAL
    )
{
    UNREFERENCED_PARAMETER(hwndParent);
    UNREFERENCED_PARAMETER(DialogTitle);
    UNREFERENCED_PARAMETER(DiskName);
    UNREFERENCED_PARAMETER(PathToSource);
    UNREFERENCED_PARAMETER(FileSought);
    UNREFERENCED_PARAMETER(TagFile);
    UNREFERENCED_PARAMETER(DiskPromptStyle);
    UNREFERENCED_PARAMETER(PathBuffer);
    UNREFERENCED_PARAMETER(PathBufferSize);
    UNREFERENCED_PARAMETER(PathRequiredSize);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(DPROMPT_CANCEL);
}
#endif

UINT
SetupPromptForDisk(
    IN  HWND   hwndParent,
    IN  PCTSTR DialogTitle,      OPTIONAL
    IN  PCTSTR DiskName,         OPTIONAL
    IN  PCTSTR PathToSource,     OPTIONAL
    IN  PCTSTR FileSought,
    IN  PCTSTR TagFile,          OPTIONAL
    IN  DWORD  DiskPromptStyle,
    OUT PTSTR  PathBuffer,
    IN  DWORD  PathBufferSize,
    OUT PDWORD PathRequiredSize  OPTIONAL
    )
{
    PCTSTR dialogTitle;
    PCTSTR diskName;
    PCTSTR pathToSource;
    PCTSTR fileSought;
    PCTSTR tagFile;
    TCHAR pathBuffer[MAX_PATH];
    DWORD rc;
    UINT u;
    DWORD Size;

    dialogTitle = NULL;
    diskName = NULL;
    pathToSource = NULL;
    fileSought = NULL;
    tagFile = NULL;
    rc = NO_ERROR;

    if(DialogTitle) {
        rc = CaptureStringArg(DialogTitle,&dialogTitle);
    }
    if((rc == NO_ERROR) && DiskName) {
        rc = CaptureStringArg(DiskName,&diskName);
    }
    if((rc == NO_ERROR) && PathToSource) {
        rc = CaptureStringArg(PathToSource,&pathToSource);
    }
    if((rc == NO_ERROR) && FileSought) {
        rc = CaptureStringArg(FileSought,&fileSought);
    }
    if((rc == NO_ERROR) && TagFile) {
        rc = CaptureStringArg(TagFile,&tagFile);
    }

    if(rc == NO_ERROR) {

        u = _SetupPromptForDisk(
                hwndParent,
                dialogTitle,
                diskName,
                pathToSource,
                fileSought,
                tagFile,
                DiskPromptStyle,
                pathBuffer,
                MAX_PATH,
                &Size
                );

        rc = GetLastError();

        if(u == DPROMPT_SUCCESS) {

            if(PathRequiredSize) {
                *PathRequiredSize = Size;
            }

            if(PathBuffer) {
                if(Size > PathBufferSize) {
                    u = DPROMPT_BUFFERTOOSMALL;
                } else {
                    lstrcpyn(PathBuffer,pathBuffer,Size);
                }
            }
        }
    } else {
        u = (rc == ERROR_NOT_ENOUGH_MEMORY) ? DPROMPT_OUTOFMEMORY : DPROMPT_CANCEL;
    }

    if(dialogTitle) {
        MyFree(dialogTitle);
    }
    if(diskName) {
        MyFree(diskName);
    }
    if(pathToSource) {
        MyFree(pathToSource);
    }
    if(fileSought) {
        MyFree(fileSought);
    }
    if(tagFile) {
        MyFree(tagFile);
    }

    SetLastError(rc);
    return(u);
}

INT_PTR
DlgProcFileError(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )

/*++

Routine Description:

    Dialog procedure for delete/rename error dialog.

    The return value for the dialog is

    DPROMPT_CANCEL  - user cancelled
    DPROMPT_SKIPFILE    - user elected to skip file
    DPROMPT_SUCCESS - user said retry
    DPROMPT_OUTOFMEMORY     - out of memory

Arguments:

    Standard dialog routine parameters.

Return Value:

    TRUE if message processed; FALSE if not.

--*/

{
    static PFILEERRDLGPARAMS Params = NULL;
    BOOL b;

    switch(msg) {

    case WM_INITDIALOG:

        Params = (PFILEERRDLGPARAMS)lParam;

        SetDlgItemText(hdlg,IDT_TEXT1,Params->MessageText);
        SetWindowText(hdlg,Params->Caption);

        SendDlgItemMessage(
            hdlg,
            IDI_ICON1,
            STM_SETICON,
            (WPARAM)LoadIcon(NULL,IDI_HAND),
            0
            );

        if(!(Params->Style & IDF_NOBEEP)) {
            MessageBeep(MB_ICONASTERISK);
        }

        if(!(Params->Style & IDF_NOFOREGROUND)) {
            PostMessage(hdlg,WMX_HELLO,0,0);
        }

        pSetupCenterWindowRelativeToParent(hdlg);

        //
        // Set focus to retry button and continue.
        //
        SetFocus(GetDlgItem(hdlg,IDOK));
        b = FALSE;
        break;

    case WMX_HELLO:

        SetForegroundWindow(hdlg);
        b = TRUE;
        break;

    case WM_COMMAND:

        if(HIWORD(wParam) == BN_CLICKED) {

            b = TRUE;
            switch(LOWORD(wParam)) {

            case IDOK:
                EndDialog(hdlg,DPROMPT_SUCCESS);
                break;

            case IDCANCEL:
                if ( (Params->Style & IDF_NOSKIP) || !CancelAllCopies(hdlg)) {
                    EndDialog(hdlg,DPROMPT_CANCEL);
                } else {
                    EndDialog(hdlg,DPROMPT_SKIPFILE);
                }
                break;

            default:
                b = FALSE;
                break;
            }

        } else {
            b = FALSE;
        }
        break;

    default:
        if (!g_uQueryCancelAutoPlay) {
            g_uQueryCancelAutoPlay = RegisterWindowMessage(TEXT("QueryCancelAutoPlay"));
        }

        if (msg == g_uQueryCancelAutoPlay) {
            SetWindowLongPtr( hdlg, DWLP_MSGRESULT, 1 );
            return 1;       // cancel auto-play
        }

        b = FALSE;
        break;
    }

    return(b);
}


#ifdef UNICODE
//
// ANSI version
//
UINT
SetupCopyErrorA(
    IN  HWND   hwndParent,
    IN  PCSTR  DialogTitle,     OPTIONAL
    IN  PCSTR  DiskName,        OPTIONAL
    IN  PCSTR  PathToSource,
    IN  PCSTR  SourceFile,
    IN  PCSTR  TargetPathFile,  OPTIONAL
    IN  UINT   Win32ErrorCode,
    IN  DWORD  Style,
    OUT PSTR   PathBuffer,      OPTIONAL
    IN  DWORD  PathBufferSize,
    OUT PDWORD PathRequiredSize OPTIONAL
    )
{
    PCWSTR dialogTitle;
    PCWSTR diskName;
    PCWSTR pathToSource;
    PCWSTR sourceFile;
    PCWSTR targetPathFile;
    WCHAR pathBuffer[MAX_PATH];
    CHAR ansiBuffer[MAX_PATH];
    DWORD rc;
    UINT u;
    DWORD Size;

    dialogTitle = NULL;
    diskName = NULL;
    pathToSource = NULL;
    sourceFile = NULL;
    targetPathFile = NULL;
    rc = NO_ERROR;

    if(DialogTitle) {
        rc = pSetupCaptureAndConvertAnsiArg(DialogTitle,&dialogTitle);
    }
    if((rc == NO_ERROR) && DiskName) {
        rc = pSetupCaptureAndConvertAnsiArg(DiskName,&diskName);
    }
    if((rc == NO_ERROR) && PathToSource) {
        rc = pSetupCaptureAndConvertAnsiArg(PathToSource,&pathToSource);
    }
    if((rc == NO_ERROR) && SourceFile) {
        rc = pSetupCaptureAndConvertAnsiArg(SourceFile,&sourceFile);
    }
    if((rc == NO_ERROR) && TargetPathFile) {
        rc = pSetupCaptureAndConvertAnsiArg(TargetPathFile,&targetPathFile);
    }

    if(rc == NO_ERROR) {

        u = SetupCopyErrorW(
                hwndParent,
                dialogTitle,
                diskName,
                pathToSource,
                sourceFile,
                targetPathFile,
                Win32ErrorCode,
                Style,
                pathBuffer,
                MAX_PATH,
                &Size
                );

        rc = GetLastError();

        if(u == DPROMPT_SUCCESS) {

            Size = (DWORD)WideCharToMultiByte(
                            CP_ACP,
                            0,
                            pathBuffer,
                            (int)Size,
                            ansiBuffer,
                            MAX_PATH,
                            NULL,
                            NULL
                            );

            if(PathRequiredSize) {
                *PathRequiredSize = Size;
            }

            if(PathBuffer) {
                if(Size > PathBufferSize) {
                    u = DPROMPT_BUFFERTOOSMALL;
                } else {
                    lstrcpynA(PathBuffer,ansiBuffer,Size);
                }
            }
        }
    } else {
        u = (rc == ERROR_NOT_ENOUGH_MEMORY) ? DPROMPT_OUTOFMEMORY : DPROMPT_CANCEL;
    }

    if(dialogTitle) {
        MyFree(dialogTitle);
    }
    if(diskName) {
        MyFree(diskName);
    }
    if(pathToSource) {
        MyFree(pathToSource);
    }
    if(sourceFile) {
        MyFree(sourceFile);
    }
    if(targetPathFile) {
        MyFree(targetPathFile);
    }

    SetLastError(rc);
    return(u);
}
#else
//
// Unicode stub
//
UINT
SetupCopyErrorW(
    IN  HWND   hwndParent,
    IN  PCWSTR DialogTitle,     OPTIONAL
    IN  PCWSTR DiskName,        OPTIONAL
    IN  PCWSTR PathToSource,
    IN  PCWSTR SourceFile,
    IN  PCWSTR TargetPathFile,  OPTIONAL
    IN  UINT   Win32ErrorCode,
    IN  DWORD  Style,
    OUT PWSTR  PathBuffer,      OPTIONAL
    IN  DWORD  PathBufferSize,
    OUT PDWORD PathRequiredSize OPTIONAL
    )
{
    UNREFERENCED_PARAMETER(hwndParent);
    UNREFERENCED_PARAMETER(DialogTitle);
    UNREFERENCED_PARAMETER(DiskName);
    UNREFERENCED_PARAMETER(PathToSource);
    UNREFERENCED_PARAMETER(SourceFile);
    UNREFERENCED_PARAMETER(TargetPathFile);
    UNREFERENCED_PARAMETER(Win32ErrorCode);
    UNREFERENCED_PARAMETER(Style);
    UNREFERENCED_PARAMETER(PathBuffer);
    UNREFERENCED_PARAMETER(PathBufferSize);
    UNREFERENCED_PARAMETER(PathRequiredSize);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(DPROMPT_CANCEL);
}
#endif

UINT
SetupCopyError(
    IN  HWND   hwndParent,
    IN  PCTSTR DialogTitle,     OPTIONAL
    IN  PCTSTR DiskName,        OPTIONAL
    IN  PCTSTR PathToSource,
    IN  PCTSTR SourceFile,
    IN  PCTSTR TargetPathFile,  OPTIONAL
    IN  UINT   Win32ErrorCode,
    IN  DWORD  Style,
    OUT PTSTR  PathBuffer,      OPTIONAL
    IN  DWORD  PathBufferSize,
    OUT PDWORD PathRequiredSize OPTIONAL
    )

/*++

Routine Description:

    Inform the user about a file copy error.

Arguments:

    hwndParent - supplies window handle of window/dialog to own the error dialog
        displayed by this routine.

    DialogTitle - if specified, supplies title for error dialog. If not specified
        a default of "Copy Error" will be supplied.

    DiskName - if specified, supplies name of the disk from which a source file
        was expected. If not specified a default of "(Unknown)" will be supplied.

    PathToSource - supplies full path part of source file name.

    SourceFile - supplies filename part of the source file name.

    TargetPathFile - if specified supplies the full pathname of the target.

    Win32ErrorCode - supplies win32 error code of failure.

    Style - supplies flags to control the behavior of the dialog.

Return Value:

    DPROMPT_xxx indicating outcome.

--*/

{
    INT_PTR i;
    DWORD d = NO_ERROR;
    DWORD TmpRequiredSize;
    HANDLE hDialogEvent = NULL;
    PCTSTR dialogTitle = NULL;
    PCTSTR diskName = NULL;
    PCTSTR pathToSource = NULL;
    PCTSTR sourceFile = NULL;
    PCTSTR targetPathFile = NULL;
    PTSTR  ErrorText = NULL;
    PTSTR  Message = NULL;
    PTSTR p;

    //
    // If we're running non-interactive, bail now...
    //
    if(GlobalSetupFlags & (PSPGF_NONINTERACTIVE|PSPGF_UNATTENDED_SETUP)) {
        SetLastError(ERROR_REQUIRES_INTERACTIVE_WINDOWSTATION);
        return DPROMPT_CANCEL;
    }

    //
    // verify & snap all parameters
    //
    if(DialogTitle) {
        d = CaptureStringArg(DialogTitle,&dialogTitle);
    } else {
        dialogTitle = MyLoadString(IDS_COPYERROR);
        if(!dialogTitle) {
            d = ERROR_NOT_ENOUGH_MEMORY;
        }
    }
    if(d == NO_ERROR) {
        if(DiskName) {
            d = CaptureStringArg(DiskName,&diskName);
        } else {
            diskName = MyLoadString(IDS_UNKNOWN_PARENS);
            if(!diskName) {
                d = ERROR_NOT_ENOUGH_MEMORY;
            }
        }
    }
    if(d == NO_ERROR) {
        if(PathToSource) {
            d = CaptureStringArg(PathToSource,&pathToSource);
        } else {
            d = ERROR_INVALID_PARAMETER;
        }
    }
    if(d == NO_ERROR) {
        if(SourceFile) {
            d = CaptureStringArg(SourceFile,&sourceFile);
        } else {
            d = ERROR_INVALID_PARAMETER;
        }
    }
    if((d == NO_ERROR) && TargetPathFile) {
        d = CaptureStringArg(TargetPathFile,&targetPathFile);
    }
    if(d) {
        if(d == ERROR_NOT_ENOUGH_MEMORY) {
            i = DPROMPT_OUTOFMEMORY;
        } else {
            i = DPROMPT_CANCEL;
        }
        goto clean;
    }

    if(Win32ErrorCode == ERROR_INVALID_TARGET) {
        FILEERRDLGPARAMS FileErrorDlgParams;
        //
        // Fatal copy error not fixed by changing source location
        //
        ErrorText = MyLoadString(IDS_COPY_INVALID_TARGET);
        if(!ErrorText) {
            i = DPROMPT_OUTOFMEMORY;
            goto clean;
        }

        //
        // don't display the error-code in this case
        // just the error text
        //
        Message = RetreiveAndFormatMessage(
                        MSG_FILEERROR_COPY,
                        sourceFile,
                        ErrorText
                        );

        if(!Message) {
            i = DPROMPT_OUTOFMEMORY;
            goto clean;
        }

        FileErrorDlgParams.MessageText = Message;
        FileErrorDlgParams.Style = Style;
        FileErrorDlgParams.Caption = dialogTitle;
        if(!FileErrorDlgParams.Caption) {
            i = DPROMPT_OUTOFMEMORY;
            goto clean;
        }

        if (GuiSetupInProgress) {
            hDialogEvent = CreateEvent(NULL,TRUE,FALSE,SETUP_HAS_OPEN_DIALOG_EVENT);
        }

        if ( hDialogEvent ) {
            SetEvent( hDialogEvent );
        }

        d = NO_ERROR;
        i = DialogBoxParam(
                MyDllModuleHandle,
                MAKEINTRESOURCE(IDD_FILEERROR2),
                hwndParent,
                DlgProcFileError,
                (LPARAM)&FileErrorDlgParams
                );

        if ( hDialogEvent ) {
            ResetEvent( hDialogEvent );
            CloseHandle( hDialogEvent );
        }
        if(i == -1) {
            i = DPROMPT_OUTOFMEMORY;
        }

    } else {
        PROMPTPARAMS Params;

        ZeroMemory(&Params,sizeof(PROMPTPARAMS));

        //
        // If the dialog title is not specified fetch a default.
        //
        Params.DialogTitle = dialogTitle;
        Params.DiskName = diskName;
        Params.FileSought = sourceFile;
        Params.PathToSource = pathToSource;
        Params.TargetFile = targetPathFile;
        //
        // assume dialog proc may change any of these
        //
        dialogTitle = NULL;
        diskName = NULL;
        sourceFile = NULL;
        pathToSource = NULL;
        targetPathFile = NULL;
        //
        // There is no tag file usage in the error dialog.
        //
        Params.TagFile = NULL;

        //
        // Determine drive type of source path
        //
        DiskPromptGetDriveType(Params.PathToSource,&Params.DriveType,&Params.IsRemovable);

        //
        // Fetch the installation path list.
        //
        d = pSetupGetList(
                0,
                &Params.PathList,
                &Params.PathCount,
                &Params.ReadOnlyMru
                );

        if(d != NO_ERROR) {
            i = (d == ERROR_NOT_ENOUGH_MEMORY) ? DPROMPT_OUTOFMEMORY : DPROMPT_CANCEL;
            goto clean;
        }

        //
        // Other fields
        //
        Params.Owner = hwndParent;
        Params.PromptStyle = Style;
        Params.UserBrowsed = FALSE;
        Params.DialogType = DLGTYPE_ERROR;
        Params.Win32Error = Win32ErrorCode;

        if(Params.ReadOnlyMru) {
            Params.PromptStyle |= IDF_NOBROWSE;
        }

        if (GuiSetupInProgress) {
            hDialogEvent = CreateEvent(NULL,TRUE,FALSE,SETUP_HAS_OPEN_DIALOG_EVENT);
        }

        if ( hDialogEvent ) {
            SetEvent( hDialogEvent );
        }

        Params.BrowseAutoComplete = FALSE;
        if(!GuiSetupInProgress) {
            d = OleInitialize(NULL);
            if(SUCCEEDED(d)) {
                Params.BrowseAutoComplete = TRUE;
            }
        }
        i = DialogBoxParam(
                MyDllModuleHandle,
                MAKEINTRESOURCE(IDD_DISKPROMPT1),
                hwndParent,
                DlgProcDiskPrompt1,
                (LPARAM)&Params
                );
        if(!GuiSetupInProgress && (d==NO_ERROR)) {
            OleUninitialize();
        }


        if ( hDialogEvent ) {
            ResetEvent( hDialogEvent );
            CloseHandle( hDialogEvent );
        }

        d = GetLastError();
        if(i == DPROMPT_SUCCESS) {
            ModifyPathList(&Params);

            //
            // Now determine what to return to the user depending on the
            // buffer and sizes passed in.
            //
            TmpRequiredSize = lstrlen(Params.PathToSource)+1;
            if(PathRequiredSize) {
                *PathRequiredSize = TmpRequiredSize;
            }

            if(PathBuffer) {
                if(TmpRequiredSize > PathBufferSize) {
                    i = DPROMPT_BUFFERTOOSMALL;
                } else {
                    lstrcpy(PathBuffer,Params.PathToSource);
                }
            }
        }

        SetupFreeSourceList(&Params.PathList,Params.PathCount);
        //
        // release params (either we, or DlgProcDiskPrompt1 allocated the data)
        //
        if (Params.DialogTitle) {
            MyFree(Params.DialogTitle);
        }
        if (Params.DiskName) {
            MyFree(Params.DiskName);
        }
        if (Params.FileSought) {
            MyFree(Params.FileSought);
        }
        if (Params.PathToSource) {
            MyFree(Params.PathToSource);
        }
        if (Params.TargetFile) {
            MyFree(Params.TargetFile);
        }

    }

clean:

    if(dialogTitle) {
        MyFree(dialogTitle);
    }
    if(diskName) {
        MyFree(diskName);
    }
    if(pathToSource) {
        MyFree(pathToSource);
    }
    if(sourceFile) {
        MyFree(sourceFile);
    }
    if(targetPathFile) {
        MyFree(targetPathFile);
    }
    if(ErrorText) {
        MyFree(ErrorText);
    }
    if(Message) {
        MyFree(Message);
    }

    SetLastError(d);
    return((UINT)i);
}



#ifdef UNICODE
//
// ANSI version
//
UINT
SetupRenameErrorA(
    IN  HWND   hwndParent,
    IN  PCSTR  DialogTitle,      OPTIONAL
    IN  PCSTR  SourceFile,
    IN  PCSTR  TargetFile,
    IN  UINT   Win32ErrorCode,
    IN  DWORD  Style
    )
{
    PCWSTR dialogTitle,sourceFile,targetFile;
    DWORD rc;
    UINT u;

    dialogTitle = NULL;
    sourceFile = NULL;
    targetFile = NULL;
    rc = NO_ERROR;

    if(DialogTitle) {
        rc = pSetupCaptureAndConvertAnsiArg(DialogTitle,&dialogTitle);
    }
    if((rc == NO_ERROR) && SourceFile) {
        rc = pSetupCaptureAndConvertAnsiArg(SourceFile,&sourceFile);
    }
    if((rc == NO_ERROR) && TargetFile) {
        rc = pSetupCaptureAndConvertAnsiArg(TargetFile,&targetFile);
    }

    if(rc == NO_ERROR) {
        u = SetupRenameErrorW(
                hwndParent,
                dialogTitle,
                sourceFile,
                targetFile,
                Win32ErrorCode,
                Style
                );
        rc = GetLastError();

    } else {
        u = (rc == ERROR_NOT_ENOUGH_MEMORY) ? DPROMPT_OUTOFMEMORY : DPROMPT_CANCEL;
    }

    if(dialogTitle) {
        MyFree(dialogTitle);
    }
    if(sourceFile) {
        MyFree(sourceFile);
    }
    if(targetFile) {
        MyFree(targetFile);
    }
    SetLastError(rc);
    return(u);
}
#else
//
// Unicode stub
//
UINT
SetupRenameErrorW(
    IN  HWND   hwndParent,
    IN  PCWSTR DialogTitle,      OPTIONAL
    IN  PCWSTR SourceFile,
    IN  PCWSTR TargetFile,
    IN  UINT   Win32ErrorCode,
    IN  DWORD  Style
    )
{
    UNREFERENCED_PARAMETER(hwndParent);
    UNREFERENCED_PARAMETER(DialogTitle);
    UNREFERENCED_PARAMETER(SourceFile);
    UNREFERENCED_PARAMETER(TargetFile);
    UNREFERENCED_PARAMETER(Win32ErrorCode);
    UNREFERENCED_PARAMETER(Style);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(DPROMPT_CANCEL);
}
#endif

UINT
SetupRenameError(
    IN  HWND   hwndParent,
    IN  PCTSTR DialogTitle,     OPTIONAL
    IN  PCTSTR SourceFile,
    IN  PCTSTR TargetFile,
    IN  UINT   Win32ErrorCode,
    IN  DWORD  Style
    )

/*++

Routine Description:

    Inform the user about a rename error.

Arguments:

    hwndParent - supplies window handle of window/dialog to own the error dialog
        displayed by this routine.

    DialogTitle - if specified, supplies title for error dialog. If not specified
        a default of "Rename Error" will be supplied.

    SourceFile - supplies full path and filename of source.

    TargetFile - supplies full path and filename of target.

    Win32ErrorCode - supplies win32 error code of failure.

    Style - supplies flags to control the behavior of the dialog.

Return Value:

    DPROMPT_xxx indicating outcome.

--*/

{
    PTSTR ErrorText;
    PTSTR Message;
    PTCHAR p;
    INT_PTR i;
    FILEERRDLGPARAMS FileErrorDlgParams;

    //
    // If we're running non-interactive, bail now...
    //
    if(GlobalSetupFlags & (PSPGF_NONINTERACTIVE|PSPGF_UNATTENDED_SETUP)) {
        SetLastError(ERROR_REQUIRES_INTERACTIVE_WINDOWSTATION);
        return DPROMPT_CANCEL;
    }

    ErrorText = RetreiveAndFormatMessage(Win32ErrorCode);
    if(ErrorText) {
        p = ErrorText + lstrlen(ErrorText) - 1;
        while((p > ErrorText) && (*p <= TEXT(' '))) {
            *p-- = 0;
        }
    } else {
        return(DPROMPT_OUTOFMEMORY);
    }

    Message = RetreiveAndFormatMessage(
                    MSG_FILEERROR_RENAME,
                    ErrorText,
                    Win32ErrorCode,
                    SourceFile,
                    TargetFile
                    );

    if(!Message) {
        MyFree(ErrorText);
        return(DPROMPT_OUTOFMEMORY);
    }

    FileErrorDlgParams.MessageText = Message;
    FileErrorDlgParams.Style = Style;
    FileErrorDlgParams.Caption = DialogTitle ? DialogTitle : MyLoadString(IDS_RENAMEERROR);
    if(!FileErrorDlgParams.Caption) {
        MyFree(ErrorText);
        MyFree(Message);
        SetLastError(NO_ERROR);
        return(DPROMPT_OUTOFMEMORY);
    }

    i = DialogBoxParam(
            MyDllModuleHandle,
            MAKEINTRESOURCE(IDD_FILEERROR2),
            hwndParent,
            DlgProcFileError,
            (LPARAM)&FileErrorDlgParams
            );

    MyFree(ErrorText);
    MyFree(Message);
    if(!DialogTitle) {
        MyFree(FileErrorDlgParams.Caption);
    }

    if(i == -1) {
        i = DPROMPT_OUTOFMEMORY;
    }

    SetLastError(NO_ERROR);
    return((UINT)i);
}


#ifdef UNICODE
//
// ANSI version
//
UINT
SetupDeleteErrorA(
    IN  HWND   hwndParent,
    IN  PCSTR  DialogTitle,      OPTIONAL
    IN  PCSTR  File,
    IN  UINT   Win32ErrorCode,
    IN  DWORD  Style
    )
{
    PCWSTR dialogTitle,file;
    DWORD rc;
    UINT u;

    dialogTitle = NULL;
    file = NULL;
    rc = NO_ERROR;

    if(DialogTitle) {
        rc = pSetupCaptureAndConvertAnsiArg(DialogTitle,&dialogTitle);
    }
    if((rc ==NO_ERROR) && File) {
        rc = pSetupCaptureAndConvertAnsiArg(File,&file);
    }

    if(rc == NO_ERROR) {
        u = SetupDeleteErrorW(hwndParent,dialogTitle,file,Win32ErrorCode,Style);
        rc = GetLastError();
    } else {
        u = (rc == ERROR_NOT_ENOUGH_MEMORY) ? DPROMPT_OUTOFMEMORY : DPROMPT_CANCEL;
    }

    if(dialogTitle) {
        MyFree(dialogTitle);
    }
    if(file) {
        MyFree(file);
    }
    SetLastError(rc);
    return(u);
}
#else
//
// Unicode stub
//
UINT
SetupDeleteErrorW(
    IN  HWND   hwndParent,
    IN  PCWSTR DialogTitle,      OPTIONAL
    IN  PCWSTR File,
    IN  UINT   Win32ErrorCode,
    IN  DWORD  Style
    )
{
    UNREFERENCED_PARAMETER(hwndParent);
    UNREFERENCED_PARAMETER(DialogTitle);
    UNREFERENCED_PARAMETER(File);
    UNREFERENCED_PARAMETER(Win32ErrorCode);
    UNREFERENCED_PARAMETER(Style);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(DPROMPT_CANCEL);
}
#endif

UINT
SetupDeleteError(
    IN  HWND   hwndParent,
    IN  PCTSTR DialogTitle,     OPTIONAL
    IN  PCTSTR File,
    IN  UINT   Win32ErrorCode,
    IN  DWORD  Style
    )

/*++

Routine Description:

    Inform the user about a rename error.

Arguments:

    hwndParent - supplies window handle of window/dialog to own the error dialog
        displayed by this routine.

    DialogTitle - if specified, supplies title for error dialog. If not specified
        a default of "Delete Error" will be supplied.

    File - supplies full path and filename of file being deleted.

    Win32ErrorCode - supplies win32 error code of failure.

    Style - supplies flags to control the behavior of the dialog.

Return Value:

    DPROMPT_xxx indicating outcome.

--*/

{
    PTSTR ErrorText;
    PTSTR Message;
    PTCHAR p;
    INT_PTR i;
    FILEERRDLGPARAMS FileErrorDlgParams;

    //
    // If we're running non-interactive, bail now...
    //
    if(GlobalSetupFlags & (PSPGF_NONINTERACTIVE|PSPGF_UNATTENDED_SETUP)) {
        SetLastError(ERROR_REQUIRES_INTERACTIVE_WINDOWSTATION);
        return DPROMPT_CANCEL;
    }

    ErrorText = RetreiveAndFormatMessage(Win32ErrorCode);
    if(ErrorText) {
        p = ErrorText + lstrlen(ErrorText) - 1;
        while((p > ErrorText) && (*p <= TEXT(' '))) {
            *p-- = 0;
        }
    } else {
        return(DPROMPT_OUTOFMEMORY);
    }

    Message = RetreiveAndFormatMessage(
                    MSG_FILEERROR_DELETE,
                    File,
                    ErrorText,
                    Win32ErrorCode
                    );

    if(!Message) {
        MyFree(ErrorText);
        return(DPROMPT_OUTOFMEMORY);
    }

    FileErrorDlgParams.MessageText = Message;
    FileErrorDlgParams.Style = Style;
    FileErrorDlgParams.Caption = DialogTitle ? DialogTitle : MyLoadString(IDS_DELETEERROR);
    if(!FileErrorDlgParams.Caption) {
        MyFree(ErrorText);
        MyFree(Message);
        return(DPROMPT_OUTOFMEMORY);
    }

    i = DialogBoxParam(
            MyDllModuleHandle,
            MAKEINTRESOURCE(IDD_FILEERROR2),
            hwndParent,
            DlgProcFileError,
            (LPARAM)&FileErrorDlgParams
            );

    MyFree(ErrorText);
    MyFree(Message);
    if(!DialogTitle) {
        MyFree(FileErrorDlgParams.Caption);
    }

    if(i == -1) {
        i = DPROMPT_OUTOFMEMORY;
    }

    return((UINT)i);
}

#ifdef UNICODE
//
// ANSI version
//
UINT
SetupBackupErrorA(
    IN  HWND   hwndParent,
    IN  PCSTR  DialogTitle,      OPTIONAL
    IN  PCSTR  SourceFile,
    IN  PCSTR  TargetFile,       OPTIONAL
    IN  UINT   Win32ErrorCode,
    IN  DWORD  Style
    )
{
    PCWSTR dialogTitle,sourceFile,targetFile;
    DWORD rc;
    UINT u;

    dialogTitle = NULL;
    sourceFile = NULL;
    targetFile = NULL;
    rc = NO_ERROR;

    if(DialogTitle) {
        rc = pSetupCaptureAndConvertAnsiArg(DialogTitle,&dialogTitle);
    }
    if((rc == NO_ERROR) && SourceFile) {
        rc = pSetupCaptureAndConvertAnsiArg(SourceFile,&sourceFile);
    }
    if((rc == NO_ERROR) && TargetFile) {
        rc = pSetupCaptureAndConvertAnsiArg(TargetFile,&targetFile);
    }

    if(rc == NO_ERROR) {
        u = SetupBackupErrorW(
                hwndParent,
                dialogTitle,
                sourceFile,
                targetFile,
                Win32ErrorCode,
                Style
                );
        rc = GetLastError();

    } else {
        u = (rc == ERROR_NOT_ENOUGH_MEMORY) ? DPROMPT_OUTOFMEMORY : DPROMPT_CANCEL;
    }

    if(dialogTitle) {
        MyFree(dialogTitle);
    }
    if(sourceFile) {
        MyFree(sourceFile);
    }
    if(targetFile) {
        MyFree(targetFile);
    }
    SetLastError(rc);
    return(u);
}
#else
//
// Unicode stub
//
UINT
SetupBackupErrorW(
    IN  HWND   hwndParent,
    IN  PCWSTR DialogTitle,      OPTIONAL
    IN  PCWSTR SourceFile,
    IN  PCWSTR TargetFile,       OPTIONAL
    IN  UINT   Win32ErrorCode,
    IN  DWORD  Style
    )
{
    UNREFERENCED_PARAMETER(hwndParent);
    UNREFERENCED_PARAMETER(DialogTitle);
    UNREFERENCED_PARAMETER(SourceFile);
    UNREFERENCED_PARAMETER(TargetFile);
    UNREFERENCED_PARAMETER(Win32ErrorCode);
    UNREFERENCED_PARAMETER(Style);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(DPROMPT_CANCEL);
}
#endif

UINT
SetupBackupError(
    IN  HWND   hwndParent,
    IN  PCTSTR DialogTitle,     OPTIONAL
    IN  PCTSTR SourceFile,
    IN  PCTSTR TargetFile,      OPTIONAL
    IN  UINT   Win32ErrorCode,
    IN  DWORD  Style
    )

/*++

Routine Description:

    Inform the user about a backup error.

Arguments:

    hwndParent - supplies window handle of window/dialog to own the error dialog
        displayed by this routine.

    DialogTitle - if specified, supplies title for error dialog. If not specified
        a default of "Rename Error" will be supplied.

    SourceFile - supplies full path and filename of file to be backed up

    TargetFile - supplies full path and filename of final name, if known

    Win32ErrorCode - supplies win32 error code of failure.

    Style - supplies flags to control the behavior of the dialog.

Return Value:

    DPROMPT_xxx indicating outcome.

--*/

{
    PTSTR ErrorText;
    PTSTR Message;
    PTCHAR p;
    INT_PTR i;
    FILEERRDLGPARAMS FileErrorDlgParams;

    //
    // If we're running non-interactive, bail now...
    //
    if(GlobalSetupFlags & (PSPGF_NONINTERACTIVE|PSPGF_UNATTENDED_SETUP)) {
        SetLastError(ERROR_REQUIRES_INTERACTIVE_WINDOWSTATION);
        return DPROMPT_CANCEL;
    }

    ErrorText = RetreiveAndFormatMessage(Win32ErrorCode);
    if(ErrorText) {
        p = ErrorText + lstrlen(ErrorText) - 1;
        while((p > ErrorText) && (*p <= TEXT(' '))) {
            *p-- = 0;
        }
    } else {
        return(DPROMPT_OUTOFMEMORY);
    }

    Message = RetreiveAndFormatMessage(
                    MSG_FILEERROR_BACKUP,
                    SourceFile,
                    ErrorText,
                    Win32ErrorCode
                    );

    if(!Message) {
        MyFree(ErrorText);
        return(DPROMPT_OUTOFMEMORY);
    }

    FileErrorDlgParams.MessageText = Message;
    FileErrorDlgParams.Style = Style;
    FileErrorDlgParams.Caption = DialogTitle ? DialogTitle : MyLoadString(IDS_BACKUPERROR);
    if(!FileErrorDlgParams.Caption) {
        MyFree(ErrorText);
        MyFree(Message);
        return(DPROMPT_OUTOFMEMORY);
    }

    i = DialogBoxParam(
            MyDllModuleHandle,
            MAKEINTRESOURCE(IDD_FILEERROR2),
            hwndParent,
            DlgProcFileError,
            (LPARAM)&FileErrorDlgParams
            );

    MyFree(ErrorText);
    MyFree(Message);
    if(!DialogTitle) {
        MyFree(FileErrorDlgParams.Caption);
    }

    if(i == -1) {
        i = DPROMPT_OUTOFMEMORY;
    }

    return((UINT)i);
}


BOOL
ConnectToNetShare(
    IN PCTSTR FileName,
    IN HWND   hwndParent
    )
/*++

Routine Description:

    This routine determines the network share component of the specified file path,
    and give the user a "Connect As" dialog so that they can connect to this share.

Arguments:

    FileName - supplies the path of a file contained in the network share to be
        connected to.

    hwndParent - supplies a handle to the window that should be the parent of the
        "Connect As" dialog.

Return Value:

    If the network share is successfully connected to, the return value is TRUE, otherwise,
    it is FALSE.

--*/
{
    TCHAR TempFileName[MAX_PATH];
    NETRESOURCE NetResourceIn;
    LPNETRESOURCE NetResourceOut = NULL;
    PTSTR TempString;
    DWORD BufferSize, d;
    BOOL Success = FALSE;
    BOOL locked = FALSE;
    PTEMP_NET_CONNECTION NewConnectionNode;


    //
    // Surround this code in try/except, in case we get an exception going out to
    // the network.
    //
    try {
        //
        // Copy the filename into a local (writable) buffer, because the WNet structure
        // doesn't specify its string pointers as CONST, and we don't want to take any chances.
        //
        lstrcpyn(TempFileName, FileName, SIZECHARS(TempFileName));

        ZeroMemory(&NetResourceIn, sizeof(NetResourceIn));

        NetResourceIn.lpRemoteName = TempFileName;
        NetResourceIn.dwType = RESOURCETYPE_DISK;

        //
        // Use a reasonable default buffer size in hopes of avoiding multiple calls to
        // WNetGetResourceInformation.
        //
        BufferSize = sizeof(NETRESOURCE) + (MAX_PATH * sizeof(TCHAR));
        while(TRUE) {

            if(!(NetResourceOut = MyMalloc(BufferSize))) {
                goto clean0;
            }

            d = WNetGetResourceInformation(&NetResourceIn, NetResourceOut, &BufferSize, &TempString);

            if(d == WN_SUCCESS) {
                break;
            } else {
                //
                // Free the buffer currently allocated for the net resource information.
                //
                MyFree(NetResourceOut);
                NetResourceOut = NULL;

                if(d != WN_MORE_DATA) {
                    //
                    // The call failed for some reason other than too small a buffer, so we just
                    // need to bail.
                    //
                    goto clean0;
                }
            }
        }

        //
        // If we get to this point, then we've successfully retrieved network resource information
        // for the caller-supplied path.  Now give the user a chance to connect to that network
        // location.
        //
        if(WNetAddConnection3(hwndParent,
                              NetResourceOut,
                              NULL,
                              NULL,
                              CONNECT_INTERACTIVE | CONNECT_PROMPT) == NO_ERROR) {
            Success = TRUE;

            //
            // Now, add a new node for this connection into our temporary network
            // connections list, so that we can disconnect during DLL unload.
            //
            if(NewConnectionNode = MyMalloc(sizeof(TEMP_NET_CONNECTION))) {
                lstrcpy(NewConnectionNode->NetResourceName, NetResourceOut->lpRemoteName);

                try {
                    EnterCriticalSection(&NetConnectionListCritSect);
                    locked = TRUE;
                    NewConnectionNode->Next = NetConnectionList;
                    NetConnectionList = NewConnectionNode;

                } except(EXCEPTION_EXECUTE_HANDLER) {
                }
                if(locked) {
                    LeaveCriticalSection(&NetConnectionListCritSect);
                }
            }
        }

clean0: ;   // nothing to do.

    } except(EXCEPTION_EXECUTE_HANDLER) {
        //
        // Reference the following variable so the compiler will respect our statement
        // ordering for it.
        //
        NetResourceOut = NetResourceOut;
    }

    if(NetResourceOut) {
        MyFree(NetResourceOut);
    }

    return Success;
}


VOID
pSetupInitNetConnectionList(
    IN BOOL Init
    )
/*++

Routine Description:

    This routine initializes/tears down the temporary network connection linked list that is
    used to track what UNC connections the user has made (via "Connect As" dialog) that need
    to be cleaned up on DLL unload.  As the list is being torn down, the network connection
    for each node is deleted.

Arguments:

    Init - specifies whether we're initializing or tearing down this list.

Return Value:

    None.

--*/
{
    PTEMP_NET_CONNECTION CurNode, NextNode;

    if(Init) {
        NetConnectionList = NULL;
    } else {

        for(CurNode = NetConnectionList; CurNode; CurNode = NextNode) {
            //
            // First, attempt to disconnect from this network resource.
            //
            WNetCancelConnection2(CurNode->NetResourceName, 0, FALSE);

            NextNode = CurNode->Next;
            MyFree(CurNode);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\setupapi\rc_ids.h ===
/*++

Copyright (c) 1995-2000 Microsoft Corporation

Module Name:

    rc_ids.h

Abstract:

    Header for resources, see also dialog.h

Author:

--*/

#define     IDS_MICROSOFT         1
#define     IDS_UNKNOWN_PARENS    2
#define     IDS_LOCATEFILE        3
#define     IDS_OUTOFMEMORY       4
#define     IDS_ADDITIONALMODELS  5

//
// Standard class icons
//
#define     ICON_DISPLAY          1
#define     ICON_MOUSE            2
#define     ICON_KEYBOARD         3
#define     ICON_PRINTER          4

#define     ICON_NET              5
#define     ICON_NETTRANS         6
#define     ICON_NETCLIENT        7
#define     ICON_NETSERVICE       8

#define     ICON_CONTROLLER       9

#define     ICON_SCSI            10
#define     ICON_PCCARD          11

#define     ICON_UNKNOWN         18
#define     ICON_DEFAULT         19

#define     ICON_USB             20
#define     ICON_1394            21
#define     ICON_GPS             22
#define     ICON_PORT            23
#define     ICON_HID             24
#define     ICON_SMARTCARDREADER 25
#define     ICON_MULTIPORTSERIAL 26
#define     ICON_SYSTEM          27
#define     ICON_PROCESSOR       28
#define     ICON_MEDIACHANGER    29
#define     ICON_BIOMETRIC       30

//
// Other icons
//
#define     IDI_SIGNED          40
#define     IDI_BLANK           41
#define     IDI_WARN            42
#define     IDI_DRIVERBLOCK     43
#define     IDI_SECURITY        44
#define     IDI_CERT            45

//
// Icons for various dialogs.
//
#define     ICON_FLOPPY        50
#define     ICON_CD            51
#define     ICON_NETWORK       52
#define     ICON_HARD          53
#define     ICON_SETUP         54
#define     ICON_EBD          105

//
// AVIs
//
#define     IDA_FILECOPY       60
#define     IDA_FILEDEL        61
#define     IDA_ANIMATION      62

//
// Bitmaps.
//
#define     BMP_DRIVERTYPES  1201

//
// Files needed strings in disk prompt/file error dialog
//
#define     IDS_FILESNEEDED     100
#define     IDS_FILESNEEDED2    101
#define     IDS_COPYFROM        102
#define     IDS_COPYFROMOEM     103
#define     IDS_DISKPROMPT1     104
#define     IDS_DISKPROMPT2     105
#define     IDS_DISKPROMPTOEM   106
#define     IDS_PROMPTACTION1   107
#define     IDS_PROMPTACTION2   108
#define     IDS_PROMPTTITLE     109

#define     IDS_COPYERROR       110
#define     IDS_FILEERRCOPY     111

#define     IDS_SURESKIP        112
#define     IDS_SURECANCEL      113

#define     IDS_COPYERROROEM    114
#define     IDS_COPYERROR1      115
#define     IDS_COPYERROR2      116

#define     IDS_WARNING         117

#define     IDS_ERRORDETAILS    120
#define     IDS_ERROR           121

#define     IDS_RENAMEERROR     122
#define     IDS_DELETEERROR     123
#define     IDS_BACKUPERROR     124

#define     IDS_CANCELALL       125
#define     IDS_RETRY           126

#define     IDS_LANG_NEUTRAL    127
#define     IDS_LANG_UNKNOWN    128

//
// Strings used in progress dialog.
//
#define     IDS_FILEOP_BACKUP   142
#define     IDS_FILEOP_FROM     143
#define     IDS_FILEOP_TO       144
#define     IDS_FILEOP_FILE     145

#define     IDS_COPY_CAPTION1   146
#define     IDS_COPY_CAPTION2   147
#define     IDS_RENAME_CAPTION1 148
#define     IDS_RENAME_CAPTION2 149
#define     IDS_DELETE_CAPTION1 150
#define     IDS_DELETE_CAPTION2 151
#define     IDS_BACKUP_CAPTION1 152
#define     IDS_BACKUP_CAPTION2 153
#define     IDS_COPY_INVALID_TARGET 154
#define     IDS_CANCELFILEOPS   155

//
// Strings used in Add New Device Wizard
//
#define IDS_OEMTITLE            309
#define IDS_NDW_PICKDEV1        430
#define IDS_SELECT_DEVICE       704
#define IDS_NDWSEL_MODELSLABEL 2011
#define IDS_NDWSEL_MFGLABEL    2012
#define IDS_DRIVER_IS_SIGNED   2013
#define IDS_DRIVER_NOT_SIGNED  2014
#define IDS_DRIVER_AUTHENTICODE_SIGNED 2015

//
// Strings used in Select Device dialog
// (setupx ID + 100 to avoid overlap)
//
#define IDS_INSTALLSTR0             200
#define IDS_INSTALLSTR1             201
#define IDS_INSTALLCLASS            205
#define IDS_INSTALLOEM              206
#define IDS_INSTALLOEM1             212

//
// Other device installer strings
//
#define IDS_DEVICEINSTALLER    4206

//
// Strings for resource selection dialogs
//
#define IDS_RESOURCETYPE                 1000
#define IDS_RESOURCESETTING              1001
#define IDS_DEVRES_NO_CHANGE_MF          1002
#define IDS_BASICCONFIG                  1003
#define IDS_RESTYPE_FULL                 1004
#define IDS_MEMORY_FULL                  1005
#define IDS_IO_FULL                      1006
#define IDS_DMA_FULL                     1007
#define IDS_IRQ_FULL                     1008
#define IDS_IRQ_FULL_LC                  1009
#define IDS_DMA_FULL_LC                  1010
#define IDS_MEMORY_FULL_LC               1011
#define IDS_IO_FULL_LC                   1012

#define IDS_OVERRIDECONFIG               1014
#define IDS_RESOURCE_BASE                1100
#define IDS_MEMORY                       1101
#define IDS_IO                           1102
#define IDS_DMA                          1103
#define IDS_IRQ                          1104

#define IDS_UNKNOWN                      1107

#define IDS_FORCEDCONFIG_PARTIAL         1020

#define IDS_DEVRES_NOALLOC_DISABLED      1022
#define IDS_DEVRES_NOALLOC_PROBLEM       1023
#define IDS_DEVRES_NORMAL_CONFLICT       1024
#define IDS_DEVRES_NOMATCHINGLC          1025
#define IDS_DEVRES_NOMODIFYTITLE         1026
#define IDS_EDITRES_RANGEINSTR1          1027
#define IDS_EDITRES_RANGEINSTR2          1028
#define IDS_EDITRES_ENTRYERROR           1029
#define IDS_EDITRES_VALIDATEERROR1       1030
#define IDS_EDITRES_VALIDATEERROR2       1031
#define IDS_EDITRES_VALIDATEERROR3       1032
#define IDS_ERROR_BADMEMTEXT             1033
#define IDS_ERROR_BADIOTEXT              1034
#define IDS_ERROR_BADDMATEXT             1035
#define IDS_ERROR_BADIRQTEXT             1036
#define IDS_EDITRES_CONFLICTWARNMSG      1037
#define IDS_EDITRES_CONFLICTWARNTITLE    1038
#define IDS_DEVRES_NOCONFLICTINFO        1049
#define IDS_DEVRES_NOMODIFYALL           1050
#define IDS_DEVRES_NOMODIFYSINGLE        1051
#define IDS_EDITRES_SINGLEINSTR1         1052
#define IDS_EDITRES_SINGLEINSTR2         1053
#define IDS_EDITRES_TITLE                1054
#define IDS_EDITRES_UNKNOWNCONFLICT      1055
#define IDS_EDITRES_UNKNOWNCONFLICTINGDEVS 1056
#define IDS_EDITRES_NOCONFLICT           1057
#define IDS_EDITRES_NOCONFLICTINGDEVS    1058

#define IDS_MAKE_FORCED_TITLE            1060
#define IDS_FORCEDCONFIG_WARN1           1061
#define IDS_FORCEDCONFIG_WARN2           1062
#define IDS_FORCEDCONFIG_WARN3           1063
#define IDS_FORCEDCONFIG_WARN4           1064
#define IDS_EDITRES_DEVCONFLICT          1065
#define IDS_CONFLICT_FMT                 1066
#define IDS_DEVRES_NOCONFLICTDEVS        1067
#define IDS_DEVRES_NO_RESOURCES          1068
#define IDS_DEVRES_NOMODIFYSELECT        1069

#define IDS_CONFLICT_UNAVAILABLE         1071
#define IDS_CONFLICT_GENERALERROR        1072
#define IDS_DEVNAME_UNK                  1073
#define IDS_GENERIC_DEVNAME              1074
#define IDS_EDITRES_RESERVED             1075
#define IDS_EDITRES_RESERVEDRANGE        1076
#define IDS_CURRENTCONFIG                1077

#define IDS_LOGSEVINFORMATION            3001
#define IDS_LOGSEVWARNING                3002
#define IDS_LOGSEVERROR                  3003
#define IDS_LOGSEVFATALERROR             3004

#define IDS_UNKNOWN_DRIVER               5320

#define IDS_DRIVER_UPDATE_TITLE          5330
#define IDS_DRIVER_NOMATCH1              5331

#define IDS_DRIVERCACHE_DESC             5332

#define IDS_NDW_NO_DRIVERS               5333
#define IDS_NDW_RETRIEVING_LIST          5334
#define IDS_NDW_NODRIVERS_WARNING        5335

#define IDS_DRIVER_NOMATCH2              5336
#define IDS_DRIVER_NOMATCH3              5337

#define IDS_NDW_SELECTDEVICE             5340

#define IDS_VERSION                      5342

#define IDS_YES                          5343
#define IDS_NO                           5344
#define IDS_DEVICE_VERIFY_MSG1           5345
#define IDS_DEVICE_VERIFY_MSG2           5346
#define IDS_SOFTWARE_VERIFY_MSG1         5347
#define IDS_SOFTWARE_VERIFY_MSG2         5348
#define IDS_UNKNOWNPUBLISHER             5349
#define IDS_UNKNOWNPUBLISHERCERTISSUER   5350
#define IDS_FILE_NOT_FOUND                  5400
#define IDS_SPC_PROVIDER                    5401
#define IDS_SPC_SUBJECT                     5402
#define IDS_SPC_NO_SIGNATURE                5403
#define IDS_SPC_BAD_SIGNATURE               5404
#define IDS_SPC_BAD_FILE_DIGEST             5405
#define IDS_SPC_NO_VALID_SIGNER             5406
#define IDS_SPC_SIGNER_CERT                 5407
#define IDS_SPC_VALID_COUNTERSIGNER         5408
#define IDS_SPC_CERT_EXPIRED                5409
#define IDS_SPC_CERT_SIGNATURE              5410
#define IDS_SPC_CHAINING                    5411
#define IDS_SPC_UNTRUSTED_ROOT              5412
#define IDS_SPC_UNTRUSTED_TEST_ROOT         5413
#define IDS_SPC_INVALID_CERT_NESTING        5414
#define IDS_SPC_INVALID_PURPOSE             5415
#define IDS_SPC_INVALID_BASIC_CONSTRAINTS   5416
#define IDS_SPC_INVALID_FINANCIAL           5417
#define IDS_SPC_TIMESTAMP                   5418
#define IDS_SPC_CERT_REVOKED                5419
#define IDS_SPC_REVOCATION_ERROR            5420
#define IDS_SPC_SECURITY_SETTINGS           5421
#define IDS_SPC_INVALID_EXTENSION           5422
#define IDS_WRONG_USAGE                     5423
#define IDS_ELEMENT_NOT_FOUND               5424
#define IDS_SPC_OSS_ERROR                   5425
#define IDS_SPC_UNKNOWN                     5426
#define IDS_AUTHENTICITY                    5427



//
// strings with well-known ID's
//
#define IDS_SHELL_INF_DESCRIPTION        2000  // "Setup Information" for INF extension
#define IDS_SHELL_PNF_DESCRIPTION        2001  // "Precompiled Setup Information" for PNF extension

//
// Include dialogs header files also
//
#include "prompt.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\setupapi\resource.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    resource.c

Abstract:

    Routines that manipulate resources (strings, messages, etc).

Author:

    Ted Miller (tedm) 6-Feb-1995

Revision History:

    Jamie Hunter (JamieHun) Apr-28-2002
            Security code review

--*/

#include "precomp.h"
#pragma hdrstop


VOID
SetDlgText(
    IN HWND hwndDlg,
    IN INT  iControl,
    IN UINT nStartString,
    IN UINT nEndString
    )
/*++

Routine Description:

    This routine concatenates a number of string resources and does a
    SetWindowText() for a dialog text control.

Arguments:

    hwndDlg - Handle to dialog window

    iControl - Dialog control ID to receive text

    nStartString - ID of first string resource to concatenate

    nEndString - ID of last string resource to concatenate

Return Value:

    None.

Remarks:

    String IDs must be consecutive.

--*/
{
    TCHAR StringBuffer[SDT_MAX_TEXT];
    UINT i;
    INT  Len = 0;

    for(i = nStartString;
        ((i <= nEndString) && (Len < (SDT_MAX_TEXT - 1)));
        i++)
    {
        Len += LoadString(MyDllModuleHandle,
                          i,
                          StringBuffer + Len,
                          SDT_MAX_TEXT - Len
                         );
    }

    if(!Len) {
        StringBuffer[0] = TEXT('\0');
    }

    SetDlgItemText(hwndDlg, iControl, StringBuffer);
}


PTSTR
MyLoadString(
    IN UINT StringId
    )

/*++

Routine Description:

    Retreive a string from the string resources of this module.

Arguments:

    StringId - supplies string table identifier for the string.

Return Value:

    Pointer to buffer containing string. If the string was not found
    or some error occurred retreiving it, this buffer will be empty.

    Caller can free the buffer with MyFree().

    If NULL is returned, out of memory.

--*/

{
    PTSTR Buffer, p;
    int Length, RequiredLength;

    //
    // Start out with a reasonably-sized buffer so that we'll rarely need to
    // grow the buffer and retry (Length is in terms of characters, not bytes).
    //
    Length = LINE_LEN;

    while(TRUE) {

        Buffer = MyMalloc(Length * sizeof(TCHAR));
        if(!Buffer) {
            return NULL;
        }

        RequiredLength = LoadString(MyDllModuleHandle,
                                    StringId,
                                    Buffer,
                                    Length
                                   );
        if(!RequiredLength) {
            *Buffer = TEXT('\0');
            Length = 1;
            break;
        }

        //
        // Because of the way LoadString works, there's no way to
        // tell for sure whether your buffer was big enough in the case where
        // the length returned just fits in the buffer you supplied (the API
        // silently truncates in this case).  Thus, if RequiredLength is exactly
        // the size of our supplied buffer (minus terminating null, which
        // LoadString doesn't count), we increase the buffer size by LINE_LEN
        // characters and try again, to make sure we get the whole string.
        //
        if(RequiredLength < (Length - 1)) {
            //
            // Looks like we got the whole string.  Set the length to be the
            // required length + 1 character, to accommodate the terminating
            // null character.
            //
            Length = RequiredLength + 1;
            break;
        } else {
            MyFree(Buffer);
            Length += LINE_LEN;
        }
    }

    //
    // Resize the buffer to its correct size.  If this fails (which it shouldn't)
    // it's no big deal, it just means we're using a larger buffer for this string
    // than we need to.
    //
    if(p = MyRealloc(Buffer, Length * sizeof(TCHAR))) {
        Buffer = p;
    }

    return Buffer;
}


PTSTR
FormatStringMessageV(
    IN UINT     FormatStringId,
    IN va_list *ArgumentList
    )

/*++

Routine Description:

    Retreive a string from the string resources of this module and
    format it using FormatMessage.

Arguments:

    StringId - supplies string table identifier for the string.

    ArgumentList - supplies list of strings to be substituted in the
        format string.

Return Value:

    Pointer to buffer containing formatted message. If the string was not found
    or some error occurred retreiving it, this buffer will be NULL

    Caller can free the buffer with MyFree().

    If NULL is returned, out of memory.

--*/

{
    PTSTR FormatString;
    va_list arglist;
    PTSTR Message;
    PTSTR Return;
    DWORD d;

    //
    // First, load the format string.
    //
    FormatString = MyLoadString(FormatStringId);
    if(!FormatString) {
        return(NULL);
    }

    //
    // Now format the message using the arguements the caller passed.
    //
    d = FormatMessage(
            FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
            FormatString,
            0,
            0,
            (PTSTR)&Message,
            0,
            ArgumentList
            );

    MyFree(FormatString);

    if(!d) {
        return(NULL);
    }

    //
    // Make duplicate using our memory system so user can free with MyFree().
    //
    Return = DuplicateString(Message);
    LocalFree((HLOCAL)Message);
    return(Return);
}


PTSTR
FormatStringMessage(
    IN UINT FormatStringId,
    ...
    )

/*++

Routine Description:

    Retreive a string from the string resources of this module and
    format it using FormatMessage.

Arguments:

    StringId - supplies string table identifier for the string.

Return Value:

    Pointer to buffer containing formatted message. If the string was not found
    or some error occurred retreiving it, this buffer will be empty.

    Caller can free the buffer with MyFree().

    If NULL is returned, out of memory.

--*/

{
    va_list arglist;
    PTSTR p;

    va_start(arglist,FormatStringId);
    p = FormatStringMessageV(FormatStringId,&arglist);
    va_end(arglist);

    return(p);
}


PTSTR
FormatStringMessageFromStringV(
    IN PTSTR    FormatString,
    IN va_list *ArgumentList
    )

/*++

Routine Description:

    Format the input string using FormatMessage.

Arguments:

    FormatString - supplies the format string.

    ArgumentList - supplies list of strings to be substituted in the
        format string.

Return Value:

    Pointer to buffer containing formatted message. If some error occurred
    formatting the string, this buffer will be NULL.

    Caller can free the buffer with MyFree().

    If NULL is returned, out of memory/other error

--*/

{
    va_list arglist;
    PTSTR Message;
    PTSTR Return;
    DWORD d;

    //
    // Format the message using the arguements the caller passed.
    //
    d = FormatMessage(
            FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
            FormatString,
            0,
            0,
            (PTSTR)&Message,
            0,
            ArgumentList
            );

    if(!d) {
        return(NULL);
    }

    //
    // Make duplicate using our memory system so user can free with MyFree().
    //
    Return = DuplicateString(Message);
    LocalFree((HLOCAL)Message);
    return(Return);
}


PTSTR
FormatStringMessageFromString(
    IN PTSTR FormatString,
    ...
    )

/*++

Routine Description:

    Format the input string using FormatMessage.

Arguments:

    FormatString - supplies the format string.

Return Value:

    Pointer to buffer containing formatted message. If some error occurred
    formatting the string, this buffer will be empty.

    Caller can free the buffer with MyFree().

    If NULL is returned, out of memory.

--*/

{
    va_list arglist;
    PTSTR p;

    va_start(arglist,FormatString);
    p = FormatStringMessageFromStringV(FormatString,&arglist);
    va_end(arglist);

    return(p);
}


INT
FormatMessageBox(
    IN HANDLE hinst,
    IN HWND   hwndParent,
    IN UINT   TextMessageId,
    IN PCTSTR Title,
    IN UINT   Style,
    ...
    )
/*++

Routine Description:

    This routine formats two message strings--one containing messagebox text,
    and the other containing a messagebox caption.  The message box is then
    displayed.

    The message ids can be either a message in this dll's message table
    resources or a win32 error code, in which case a description of
    that error is retreived from the system.

Arguments:

    hinst - Supplies the handle of the module containing string resources to
        be used.

    hwndParent - Supplies the handle of window to be the parent of the message box.

    TextMessageId - Supplies message-table identifier or win32 error code
        for the messagebox text.

    TitleMessageId - Supplies message-table identifier or win32 error code
        for the messagebox caption.

    Style - Supplies style flags for the message box.

    ... - Supplies arguments to be inserted in the message text.

Return Value:

    The return value is zero if there is not enough memory to create the message box, or
    if a failure occurred while creating the message box.

    If the function succeeds, the return value is one of the following menu-item values
    returned by the dialog box:

        IDABORT   Abort button was selected.
        IDCANCEL  Cancel button was selected.
        IDIGNORE  Ignore button was selected.
        IDNO      No button was selected.
        IDOK      OK button was selected.
        IDRETRY   Retry button was selected.
        IDYES     Yes button was selected.

    If a message box has a Cancel button, the function returns the IDCANCEL value if
    either the ESC key is pressed or the Cancel button is selected. If the message box
    has no Cancel button, pressing ESC has no effect.

--*/
{
    va_list arglist;
    PTSTR Text = NULL;
    INT ret;

    //
    // We should never be called if we're not interactive.
    //
    MYASSERT(!(GlobalSetupFlags & (PSPGF_NONINTERACTIVE|PSPGF_UNATTENDED_SETUP)));

    if(GlobalSetupFlags & (PSPGF_NONINTERACTIVE|PSPGF_UNATTENDED_SETUP)) {
        return 0;
    }

    try {

        va_start(arglist, Style);
        Text  = RetreiveAndFormatMessageV(TextMessageId, &arglist);
        va_end(arglist);

        if(Text) {
            //
            // We always beep when we display the message
            //
            MessageBeep(Style & (MB_ICONHAND|MB_ICONEXCLAMATION|MB_ICONQUESTION|MB_ICONASTERISK));
            ret = MessageBox(hwndParent, Text, Title, Style);
        } else {
            ret = 0;
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        ret = 0;
    }

    if(Text) {
        MyFree(Text);
    }

    return ret;
}


PTSTR
RetreiveAndFormatMessageV(
    IN UINT     MessageId,
    IN va_list *ArgumentList
    )

/*++

Routine Description:

    Format a message string using a message string and caller-supplied
    arguments.

    The message id can be either a message in this dll's message table
    resources or a win32 error code, in which case a description of
    that error is retreived from the system.

Arguments:

    MessageId - supplies message-table identifier or win32 error code
        for the message.

    ArgumentList - supplies arguments to be inserted in the message text.

Return Value:

    Pointer to buffer containing formatted message. If the message was not found
    or some error occurred retreiving it, this buffer will be empty.

    Caller can free the buffer with MyFree().

    If NULL is returned, out of memory.

--*/

{
    DWORD d;
    PTSTR Buffer;
    PTSTR Message;
    TCHAR ModuleName[MAX_PATH];
    TCHAR ErrorNumber[24];
    PTCHAR p;
    PTSTR Args[2];

    d = FormatMessage(
            FORMAT_MESSAGE_ALLOCATE_BUFFER
          | ((MessageId < MSG_FIRST) ?
                (FORMAT_MESSAGE_FROM_SYSTEM|FORMAT_MESSAGE_IGNORE_INSERTS)
                : FORMAT_MESSAGE_FROM_HMODULE),
            (PVOID)MyDllModuleHandle,
            MessageId,
            MAKELANGID(LANG_NEUTRAL,SUBLANG_NEUTRAL),
            (PTSTR)&Buffer,
            0,
            ArgumentList
            );

    if(!d) {
        if(GetLastError() == ERROR_NOT_ENOUGH_MEMORY) {
            return(NULL);
        }

        MYVERIFY(SUCCEEDED(StringCchPrintf(ErrorNumber,
                                            SIZECHARS(ErrorNumber),
                                            TEXT("%x"),
                                            MessageId)));
        Args[0] = ErrorNumber;

        Args[1] = ModuleName;

        if(GetModuleFileName(MyDllModuleHandle,ModuleName,SIZECHARS(ModuleName))) {
            if(p = _tcsrchr(ModuleName,TEXT('\\'))) {
                Args[1] = p+1;
            }
        } else {
            ModuleName[0] = 0;
        }

        d = FormatMessage(
                FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                NULL,
                ERROR_MR_MID_NOT_FOUND,
                MAKELANGID(LANG_NEUTRAL,SUBLANG_NEUTRAL),
                (PTSTR)&Buffer,
                0,
                (va_list *)Args
                );

        if(!d) {
            //
            // Give up.
            //
            return(NULL);
        }
    }

    //
    // Make duplicate using our memory system so user can free with MyFree().
    //
    Message = DuplicateString(Buffer);

    LocalFree((HLOCAL)Buffer);

    return(Message);
}


PTSTR
RetreiveAndFormatMessage(
    IN UINT MessageId,
    ...
    )

/*++

Routine Description:

    Format a message string using a message string and caller-supplied
    arguments.

    The message id can be either a message in this dll's message table
    resources or a win32 error code, in which case a description of
    that error is retreived from the system.

Arguments:

    MessageId - supplies message-table identifier or win32 error code
        for the message.

    ... - supplies arguments to be inserted in the message text.

Return Value:

    Pointer to buffer containing formatted message. If the message was not found
    or some error occurred retreiving it, this buffer will be empty.

    Caller can free the buffer with MyFree().

    If NULL is returned, out of memory.

--*/

{
    va_list arglist;
    PTSTR p;

    va_start(arglist,MessageId);
    p = RetreiveAndFormatMessageV(MessageId,&arglist);
    va_end(arglist);

    return(p);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\setupapi\registry.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    registry.c

Abstract:

    Registry interface routines for Windows NT Setup API Dll.

Author:

    Ted Miller (tedm) 6-Feb-1995

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop


//
// Private function prototypes.
//
DWORD
QueryMultiSzDevRegPropToArray(
    IN  DEVINST  DevInst,
    IN  ULONG    CmPropertyCode,
    OUT PTSTR  **StringArray,
    OUT PUINT    StringCount
    );

DWORD
SetArrayToMultiSzDevRegProp(
    IN DEVINST  DevInst,
    IN ULONG    CmPropertyCode,
    IN PTSTR   *StringArray,
    IN UINT     StringCount
    );


#if MEM_DBG

DWORD
TrackedQueryRegistryValue(
    IN          TRACK_ARG_DECLARE TRACK_ARG_COMMA
    IN  HKEY    KeyHandle,
    IN  PCTSTR  ValueName,
    OUT PTSTR  *Value,
    OUT PDWORD  DataType,
    OUT PDWORD  DataSizeBytes
    )
{
    DWORD d;

    TRACK_PUSH

// defined again below
#undef QueryRegistryValue

    d = QueryRegistryValue (
            KeyHandle,
            ValueName,
            Value,
            DataType,
            DataSizeBytes
            );

    TRACK_POP

    return d;
}

#endif


DWORD
QueryRegistryValue(
    IN  HKEY    KeyHandle,
    IN  PCTSTR  ValueName,
    OUT PTSTR  *Value,
    OUT PDWORD  DataType,
    OUT PDWORD  DataSizeBytes
    )
/*++

Routine Description:

    Return an allocated buffer holding a copy of what's in registry
    buffer is padded with two extra NULL's so that caller never has
    to worry about unterminated strings.
    Caller does have to worry about size of fixed-size data

Arguments:

    KeyHandle - Key to query value in
    ValueName - name of value to query
    Value     - returned pointer containing value, release with MyFree
    DataType  - type of returned data
    DataSizeBytes - size of returned data in bytes (not TCHAR's!!!)

Return Value:

    NO_ERROR iff success

--*/
{
    LONG l;
    DWORD sz;

    sz = 0;
    l = RegQueryValueEx(KeyHandle,ValueName,NULL,DataType,NULL,&sz);
    *DataSizeBytes = sz;
    if(l != NO_ERROR) {
        return((DWORD)l);
    }

    //
    // If the size of the value entry is 0 bytes, then return success, but with
    // Value set to NULL.
    //
    if(!sz) {
        *Value = NULL;
        return NO_ERROR;
    }

    sz += sizeof(TCHAR)*2; // always pad the buffer with extra zero's

    *Value = MyMalloc(sz);
    if(*Value == NULL) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    l = RegQueryValueEx(KeyHandle,ValueName,NULL,DataType,(PVOID)*Value,DataSizeBytes);

    if(l != NO_ERROR) {
        MyFree(*Value);
    } else {
        //
        // write 2 NULL chars to end of buffer
        //
        ZeroMemory(((LPBYTE)*Value)+*DataSizeBytes,sizeof(TCHAR)*2);
    }

    return((DWORD)l);
}

#if MEM_DBG

#define QueryRegistryValue(a,b,c,d,e)   TrackedQueryRegistryValue(TRACK_ARG_CALL,a,b,c,d,e)

#endif

DWORD
QueryRegistryDwordValue(
    IN  HKEY    KeyHandle,
    IN  PCTSTR  ValueName,
    OUT PDWORD  Value
    )
/*++

Routine Description:

    Return a DWORD value
    If registry is DWORD, return as IS
    otherwise convert if data type indicates that's possible

Arguments:

    KeyHandle - Key to query value in
    ValueName - name of value to query
    Value     - caller allocated, filled with returned DWORD value

Return Value:

    NO_ERROR iff success

--*/
{
    DWORD Err;
    DWORD DataType;
    DWORD DataSize;
    PTSTR Data;
    Err = QueryRegistryValue(KeyHandle,ValueName,&Data,&DataType,&DataSize);
    if(Err != NO_ERROR) {
        *Value = 0;
        return Err;
    }
    switch (DataType) {
        case REG_DWORD:
            if(DataSize != sizeof(DWORD)) {
                MyFree(Data);
                *Value = 0;
                return ERROR_INVALID_DATA;
            }
            *Value = *(PDWORD)Data;
            break;

        case REG_SZ:
        case REG_EXPAND_SZ:
        case REG_MULTI_SZ:
            *Value = (DWORD)_tcstoul(Data,NULL,0);
            break;

        default:
            *Value = 0;
            break;
    }
    MyFree(Data);
    return NO_ERROR;
}

#if MEM_DBG

DWORD
TrackedQueryDeviceRegistryProperty(
    IN                   TRACK_ARG_DECLARE TRACK_ARG_COMMA
    IN  HDEVINFO         DeviceInfoSet,
    IN  PSP_DEVINFO_DATA DeviceInfoData,
    IN  DWORD            Property,
    OUT PTSTR           *Value,
    OUT PDWORD           DataType,
    OUT PDWORD           DataSizeBytes
    )
{
    DWORD d;

    TRACK_PUSH

// defined again below
#undef QueryDeviceRegistryProperty

    d = QueryDeviceRegistryProperty (
            DeviceInfoSet,
            DeviceInfoData,
            Property,
            Value,
            DataType,
            DataSizeBytes
            );

    TRACK_POP

    return d;
}

#endif




DWORD
QueryDeviceRegistryProperty(
    IN  HDEVINFO         DeviceInfoSet,
    IN  PSP_DEVINFO_DATA DeviceInfoData,
    IN  DWORD            Property,
    OUT PTSTR           *Value,
    OUT PDWORD           DataType,
    OUT PDWORD           DataSizeBytes
    )
/*++

Routine Description:

    Return an allocated buffer holding a copy of device registry property
    Buffer is padded with two extra NULL's so that caller never has
    to worry about unterminated strings.
    Caller does have to worry about size of fixed-size data

Arguments:

    DeviceInfoSet/DeviceInfoData/Property passed to SetupDiGetDeviceRegistryProperty
    Value     - returned pointer containing value, release with MyFree
    DataType  - type of returned data
    DataSizeBytes - size of returned data in bytes (not TCHAR's!!!)

Return Value:

    NO_ERROR iff success

--*/
{
    DWORD Err;
    DWORD sz;

    sz = 0;
    Err = SetupDiGetDeviceRegistryProperty(DeviceInfoSet,
                                           DeviceInfoData,
                                           Property,
                                           DataType,
                                           NULL,
                                           0,
                                           &sz)
                                           ? NO_ERROR : GetLastError();

    *DataSizeBytes = sz;
    if((Err != NO_ERROR) && (Err != ERROR_INSUFFICIENT_BUFFER)) {
        return Err;
    }

    //
    // If the size of the value entry is 0 bytes, then return success, but with
    // Value set to NULL.
    //
    if(!sz) {
        *Value = NULL;
        return NO_ERROR;
    }

    sz += sizeof(TCHAR)*2; // always pad the buffer with extra zero's

    *Value = MyMalloc(sz);
    if(*Value == NULL) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    Err = SetupDiGetDeviceRegistryProperty(DeviceInfoSet,
                                           DeviceInfoData,
                                           Property,
                                           DataType,
                                           (PVOID)*Value,
                                           *DataSizeBytes,
                                           DataSizeBytes)
                                           ? NO_ERROR : GetLastError();

    if(Err != NO_ERROR) {
        MyFree(*Value);
    } else {
        //
        // write 2 NULL chars to end of buffer
        //
        ZeroMemory(((LPBYTE)*Value)+*DataSizeBytes,sizeof(TCHAR)*2);
    }

    return Err;
}

#if MEM_DBG

#define QueryDeviceRegistryProperty(a,b,c,d,e,f)   TrackedQueryDeviceRegistryProperty(TRACK_ARG_CALL,a,b,c,d,e,f)

#endif



DWORD
pSetupQueryMultiSzValueToArray(
    IN  HKEY     Root,
    IN  PCTSTR   Subkey,
    IN  PCTSTR   ValueName,
    OUT PTSTR  **Array,
    OUT PUINT    StringCount,
    IN  BOOL     FailIfDoesntExist
    )
{
    DWORD d;
    HKEY hKey;
    DWORD DataType;
    DWORD DataSizeBytes;
    PTSTR Value;
    DWORD DataSizeChars;
    INT Count,i;
    PTSTR *array;
    PTSTR p;

    //
    // Open the subkey
    //
    d = RegOpenKeyEx(Root,Subkey,0,KEY_READ,&hKey);
    if((d != NO_ERROR) && FailIfDoesntExist) {
        return(d);
    }

    if(d != NO_ERROR) {
        Value = MyMalloc(sizeof(TCHAR));
        if(!Value) {
            return(ERROR_NOT_ENOUGH_MEMORY);
        }
        *Value = 0;

        DataSizeChars = 1;
        Count = 0;

    } else {

        //
        // Query the value and close the subkey.
        // If the data is not multisz type, we don't know what to
        // do with it here.
        // note that QueryRegistryValue ensures that the string is
        // always correctly double-NULL terminated
        //
        d = QueryRegistryValue(hKey,ValueName,&Value,&DataType,&DataSizeBytes);

        RegCloseKey(hKey);

        if(d != NO_ERROR) {
            if(FailIfDoesntExist) {
                return(d);
            }
        } else if(!DataSizeBytes) {
            //
            // Value entry was zero bytes in length--that's OK as long as the
            // datatype is right.
            //
            if(DataType != REG_MULTI_SZ) {
                return(ERROR_INVALID_DATA);
            }
        }

        if((d != NO_ERROR) || !DataSizeBytes) {
            Value = MyMalloc(sizeof(TCHAR));
            if(!Value) {
                return(ERROR_NOT_ENOUGH_MEMORY);
            }
            *Value = 0;

            DataSizeChars = 1;
            Count = 0;
        } else {

            if(DataType != REG_MULTI_SZ) {
                MyFree(Value);
                return(ERROR_INVALID_DATA);
            }
            DataSizeChars = DataSizeBytes/sizeof(TCHAR);

            for(i=0,p=Value; p[0]; i++,p+=lstrlen(p)+1) {
                //
                // this will always be ok as QueryRegistryValue
                // appends two NULLS onto end of string
                //
                MYASSERT((DWORD)(p-Value) < DataSizeChars);
            }
            Count = i;
        }
    }

    //
    // Allocate an array to hold the pointers (never allocate a zero-length array!)
    //
    if(!(array = MyMalloc(Count ? (Count * sizeof(PTSTR)) : sizeof(PTSTR)))) {
        MyFree(Value);
        return(ERROR_INVALID_DATA);
    }

    //
    // Walk through the multi sz and build the string array.
    //
    for(i=0,p=Value; p[0]; i++,p+=lstrlen(p)+1) {
        MYASSERT(i<Count);

        array[i] = DuplicateString(p);
        if(array[i] == NULL) {
            for(Count=0; Count<i; Count++) {
                MyFree(array[Count]);
            }
            MyFree(array);
            MyFree(Value);
            return(ERROR_NOT_ENOUGH_MEMORY);
        }
    }

    MyFree(Value);
    *Array = array;
    *StringCount = Count;

    return(NO_ERROR);
}


DWORD
pSetupSetArrayToMultiSzValue(
    IN HKEY     Root,
    IN PCTSTR   Subkey,
    IN PCTSTR   ValueName,
    IN PTSTR   *Array,
    IN UINT     StringCount
    )
{
    UINT i;
    UINT Length;
    UINT BufferSize;
    PTCHAR Buffer;
    PTCHAR p;
    DWORD d;
    HKEY hKey;
    DWORD ActionTaken;

    //
    // Calculate the length of the buffer needed to hold the
    // multi sz value. Note that empty strings are not allowed.
    //
    BufferSize = sizeof(TCHAR);
    for(i=0; i<StringCount; i++) {

        if(Length = lstrlen(Array[i])) {
            BufferSize += (Length + 1) * sizeof(TCHAR);
        } else {
            return(ERROR_INVALID_DATA);
        }
    }

    //
    // Allocate a buffer to hold the data.
    //
    Buffer = MyMalloc(BufferSize);
    if(Buffer == NULL) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    //
    // Copy the string data into the buffer, forming a multi sz.
    //
    for(p=Buffer,i=0; i<StringCount; i++,p+=Length+1) {

        Length = lstrlen(Array[i]);

        lstrcpy(p,Array[i]);
    }
    *p = 0;

    //
    // Open/create the subkey.
    //
    if(Subkey && *Subkey) {
        d = RegCreateKeyEx(
                Root,
                Subkey,
                0,
                NULL,
                REG_OPTION_NON_VOLATILE,
                KEY_SET_VALUE,
                NULL,
                &hKey,
                &ActionTaken
                );
    } else {
        hKey = Root;
        d = NO_ERROR;
    }
    if(d == NO_ERROR) {
        d = RegSetValueEx(
                hKey,
                ValueName,
                0,
                REG_MULTI_SZ,
                (PVOID)Buffer,
                BufferSize
                );

        if(hKey != Root) {
            RegCloseKey(hKey);
        }
    }

    MyFree(Buffer);
    return(d);
}

DWORD
pSetupAppendStringToMultiSz(
    IN HKEY   Key,
    IN PCTSTR SubKeyName,       OPTIONAL
    IN DWORD  DevInst,          OPTIONAL
    IN PCTSTR ValueName,        OPTIONAL
    IN PCTSTR String,
    IN BOOL   AllowDuplicates
    )
/*++

Routine Description:

    "Old" Exported version of pSetupAppendStringToMultiSz
    This doesn't seem to be used anywhere

--*/

{
    REGMOD_CONTEXT RegContext;

    RegContext.Flags = DevInst ? INF_PFLAG_DEVPROP : 0;
    RegContext.UserRootKey = Key;
    RegContext.DevInst = DevInst;
    return _AppendStringToMultiSz(SubKeyName,ValueName,String,AllowDuplicates,&RegContext,0);
}

DWORD
_AppendStringToMultiSz(
    IN PCTSTR           SubKeyName,         OPTIONAL
    IN PCTSTR           ValueName,          OPTIONAL
    IN PCTSTR           String,
    IN BOOL             AllowDuplicates,
    IN PREGMOD_CONTEXT  RegContext,         OPTIONAL
    IN UINT             Flags               OPTIONAL
    )

/*++

Routine Description:

    Append a string value to a multi_sz.

Arguments:

    RegContext->UserRootKey - supplies handle to open registry key. The key must have
        KEY_SET_VALUE access.

    SubKeyName - if specified, supplies the name of a subkey of Key
        where the value is to be stored. If not specified or if ""
        then the value is stored in Key.  If supplied and the key
        doesn't exist, the key is created.

    RegContext->DevInst - Optionally, supplies a DEVINST handle for the device
        instance corresponding to the hardware storage key specified
        by 'Key'.  If this handle is specified, and if SubKeyName is
        not specified, then the value name being appended will be
        checked to see whether it is the name of a device registry
        property.  If so, then CM APIs will be used to modify the
        the corresponding registry property, since the Key handle
        represents a separate location under Windows NT.

    ValueName - supplies the value entry name of the multi_sz.
        If not specified or "" then the unnamed entry is used.
        If the value entry does not exist it is created.

    String - supplies the string to be added in to the multi_sz.
        Must not be an empty string.

    AllowDuplicates - if TRUE, then the string is simply appended
        to the multi_sz. Otherwise the string is only appended if
        no instance of it currently exists in the multi_sz.

    RegContext - Passed in from _SetupInstallFromInfSection

    Flags      - Flags that may have been got from the INF and passed to us

Return Value:

    Handle to setup file queue. INVALID_HANDLE_VALUE if insufficient
    memory to create the queue.

--*/

{
    DWORD d;
    DWORD Disposition;
    HKEY hKey;
    PTSTR *Array;
    PVOID p;
    BOOL Append;
    UINT StringCount;
    UINT i;
    BOOL IsDevRegProp = FALSE;
    BOOL IsClassRegProp = FALSE;
    UINT_PTR CmPropertyCode;

    MYASSERT(RegContext);
    //
    // Empty strings really mess up a multi_sz.
    //
    if(!String || !(*String)) {
        return(ERROR_INVALID_PARAMETER);
    }

    //
    // Open/create the key.
    //
    if(SubKeyName && *SubKeyName) {
        d = RegCreateKeyEx(
                RegContext->UserRootKey,
                SubKeyName,
                0,
                NULL,
                REG_OPTION_NON_VOLATILE,
#ifdef _WIN64
                (( Flags & FLG_ADDREG_32BITKEY ) ? KEY_WOW64_32KEY:0) |
#else
                (( Flags & FLG_ADDREG_64BITKEY ) ? KEY_WOW64_64KEY:0) |
#endif
                KEY_SET_VALUE,
                NULL,
                &hKey,
                &Disposition
                );
        if(d != NO_ERROR) {
            return(d);
        }
    } else {
        //
        // If DevInst was specified, then determine whether the specified value is a Plug&Play
        // device registry property.
        //
        if (ValueName && *ValueName) {
            if((RegContext->Flags & INF_PFLAG_CLASSPROP) &&
               (IsClassRegProp = LookUpStringInTable(InfRegValToClassRegProp, ValueName, &CmPropertyCode))) {
                //
                // This value is a class registry property.  Retrieve the current property's data, and
                // format it into the same string array as returned by the pSetupQueryMultiSzValueToArray call
                // below.
                //
                //d = QueryMultiSzClassRegPropToArray(RegModContext->ClassGuid, CmPropertyCode, &Array, &StringCount);
                //
                // No class properties have MultiSz characteristics, so not implemented
                //
                d = ERROR_INVALID_DATA;

            } else if((RegContext->Flags & INF_PFLAG_DEVPROP) &&
               (IsDevRegProp = LookUpStringInTable(InfRegValToDevRegProp, ValueName, &CmPropertyCode))) {
                //
                // This value is a device registry property.  Retrieve the current property's data, and
                // format it into the same string array as returned by the pSetupQueryMultiSzValueToArray call
                // below.
                //
                d = QueryMultiSzDevRegPropToArray(RegContext->DevInst, (ULONG)CmPropertyCode, &Array, &StringCount);
            }
        }

        hKey = RegContext->UserRootKey;
    }

    if(!IsDevRegProp && !IsClassRegProp) {
        //
        // Query the existing registry value.
        //
        d = pSetupQueryMultiSzValueToArray(hKey,NULL,ValueName,&Array,&StringCount,FALSE);
    }

    if(d == NO_ERROR) {
        //
        // Determine whether to append or replace.
        // If replacing, we don't need to do anything!
        //
        Append = TRUE;
        if(!AllowDuplicates) {
            for(i=0; i<StringCount; i++) {
                if(!lstrcmpi(Array[i],String)) {
                    Append = FALSE;
                    break;
                }
            }
        }

        if(Append) {
            //
            // Stick the string on the end.
            //
            if(p = MyRealloc(Array, (StringCount+1)*sizeof(PTSTR))) {
                Array = p;
                p = DuplicateString(String);
                if(p) {
                    Array[StringCount++] = p;
                } else {
                    d = ERROR_NOT_ENOUGH_MEMORY;
                }
            } else {
                d = ERROR_NOT_ENOUGH_MEMORY;
            }

            if(IsDevRegProp) {
                d = SetArrayToMultiSzDevRegProp(RegContext->DevInst, (ULONG)CmPropertyCode, Array, StringCount);
            } else if(IsClassRegProp) {
                //
                // not implemented yet, and should return an error before getting here
                //
                MYASSERT(IsClassRegProp == FALSE);

            } else {
                d = pSetupSetArrayToMultiSzValue(hKey,NULL,ValueName,Array,StringCount);
            }
        }

        pSetupFreeStringArray(Array,StringCount);
    }

    if(hKey != RegContext->UserRootKey) {
        RegCloseKey(hKey);
    }

    return(d);
}

DWORD
_DeleteStringFromMultiSz(
    IN PCTSTR           SubKeyName,         OPTIONAL
    IN PCTSTR           ValueName,          OPTIONAL
    IN PCTSTR           String,
    IN UINT             Flags,
    IN PREGMOD_CONTEXT  RegContext          OPTIONAL
    )

/*++

Routine Description:

    Delete a string value from a multi_sz.

Arguments:

    RegContext->UserRootKey - supplies handle to open registry key. The key must have
        KEY_SET_VALUE access.

    SubKeyName - if specified, supplies the name of a subkey of Key
        where the value is to be stored. If not specified or if ""
        then the value is stored in Key.

    RegContext->DevInst - Optionally, supplies a DEVINST handle for the device
        instance corresponding to the hardware storage key specified
        by 'Key'.  If this handle is specified, and if SubKeyName is
        not specified, then the value name being appended will be
        checked to see whether it is the name of a device registry
        property.  If so, then CM APIs will be used to modify the
        the corresponding registry property, since the Key handle
        represents a separate location under Windows NT.

    ValueName - supplies the value entry name of the multi_sz.
        If not specified or "" then the unnamed entry is used.

    String - supplies the string to be added in to the multi_sz.
        Must not be an empty string.

    Flags - indicates what kind of delete operation
            FLG_DELREG_MULTI_SZ_DELSTRING - delete all occurances of string

    RegContext - Passed in from _SetupInstallFromInfSection

Return Value:

    Handle to setup file queue. INVALID_HANDLE_VALUE if insufficient
    memory to create the queue.

--*/

{
    DWORD d;
    DWORD Disposition;
    HKEY hKey;
    PTSTR *Array;
    PVOID p;
    UINT StringCount;
    UINT i;
    BOOL IsDevRegProp = FALSE;
    BOOL IsClassRegProp = FALSE;
    BOOL Modified = FALSE;
    UINT_PTR CmPropertyCode;

    MYASSERT(RegContext);
    //
    // Can't delete an empty string from multi-sz
    //
    if(!String || !(*String)) {
        return(ERROR_INVALID_PARAMETER);
    }

    //
    // Open the key.
    //
    if(SubKeyName && *SubKeyName) {
        d = RegOpenKeyEx(
                RegContext->UserRootKey,
                SubKeyName,
                0,
#ifdef _WIN64
                ((Flags & FLG_DELREG_32BITKEY) ? KEY_WOW64_32KEY:0) |
#else
                ((Flags & FLG_DELREG_64BITKEY) ? KEY_WOW64_64KEY:0) |
#endif
                KEY_SET_VALUE | KEY_QUERY_VALUE,
                &hKey
                );
        if(d != NO_ERROR) {
            return(d);
        }
    } else {
        if (ValueName && *ValueName) {
            //
            // If DevInst was specified, then determine whether the specified value is a Plug&Play
            // device registry property.
            //
            if((RegContext->Flags & INF_PFLAG_CLASSPROP) &&
               (IsClassRegProp = LookUpStringInTable(InfRegValToClassRegProp, ValueName, &CmPropertyCode))) {
                //
                // This value is a class registry property.  Retrieve the current property's data, and
                // format it into the same string array as returned by the pSetupQueryMultiSzValueToArray call
                // below.
                //
                //d = QueryMultiSzClassRegPropToArray(RegModContext->ClassGuid, CmPropertyCode, &Array, &StringCount);
                //
                // No class properties have MultiSz characteristics, so not implemented
                //
                d = ERROR_INVALID_DATA;

            } else if((RegContext->Flags & INF_PFLAG_DEVPROP) &&
               (IsDevRegProp = LookUpStringInTable(InfRegValToDevRegProp, ValueName, &CmPropertyCode))) {
                //
                // This value is a device registry property.  Retrieve the current property's data, and
                // format it into the same string array as returned by the pSetupQueryMultiSzValueToArray call
                // below.
                // fails if not multi-sz
                //
                d = QueryMultiSzDevRegPropToArray(RegContext->DevInst, (ULONG)CmPropertyCode, &Array, &StringCount);
            }
        }

        hKey = RegContext->UserRootKey;
    }

    if(!IsDevRegProp && !IsClassRegProp) {
        //
        // Query the existing registry value.
        // fails if not multi-sz
        //
        d = pSetupQueryMultiSzValueToArray(hKey,NULL,ValueName,&Array,&StringCount,FALSE);
    }

    if(d == NO_ERROR) {

        switch (Flags) {
            case FLG_DELREG_32BITKEY | FLG_DELREG_MULTI_SZ_DELSTRING:
            case FLG_DELREG_64BITKEY | FLG_DELREG_MULTI_SZ_DELSTRING:
            case FLG_DELREG_MULTI_SZ_DELSTRING:
                for(i=0; i<StringCount; i++) {
                    if(lstrcmpi(Array[i],String)==0) {
                        //
                        // Need to remove this item.
                        // and re-adjust the list
                        //
                        MyFree(Array[i]);
                        StringCount--;
                        if (i<StringCount) {
                            MoveMemory(
                                &Array[i],
                                &Array[i+1],
                                (StringCount - i) * sizeof(PTSTR)
                                );
                        }
                        i--;

                        Modified = TRUE;
                    }
                }
                break;

            default:
                MYASSERT(FALSE);
                break;
        }

        if (Modified) {

            if(IsDevRegProp) {
                d = SetArrayToMultiSzDevRegProp(RegContext->DevInst, (ULONG)CmPropertyCode, Array, StringCount);
            } else if(IsClassRegProp) {
                //
                // not implemented yet, and should return an error before getting here
                //
                MYASSERT(IsClassRegProp == FALSE);

            } else {
                d = pSetupSetArrayToMultiSzValue(hKey,NULL,ValueName,Array,StringCount);
            }
        }

        pSetupFreeStringArray(Array,StringCount);
    }

    if(hKey != RegContext->UserRootKey) {
        RegCloseKey(hKey);
    }

    return(d);
}

VOID
pSetupFreeStringArray(
    IN PTSTR *Array,
    IN UINT   StringCount
    )
{
    UINT i;

    for(i=0; i<StringCount; i++) {
        MyFree(Array[i]);
    }

    MyFree(Array);
}

DWORD
QueryMultiSzDevRegPropToArray(
    IN  DEVINST  DevInst,
    IN  ULONG    CmPropertyCode,
    OUT PTSTR  **StringArray,
    OUT PUINT    StringCount
    )
/*++

Routine Description:

    This routine retrieves a multi-sz device registry property, and
    formats it into an array of strings.  The caller must free this
    string array by calling pSetupFreeStringArray().

Arguments:

    DevInst - supplies the handle to the device instance for which the
        registry property is to be retrieved.

    CmPropertyCode - specifies the property to be retrieved.  This is
        a CM_DRP value.

    StringArray - supplies the address of a variable that will be set to
        point to the newly-allocated array of strings.

    StringCount - supplies the address of a variable that will receive
        the number of strings in the string array.

Return Value:

    If successful, the return value is NO_ERROR, otherwise, it is an
    ERROR_* code.

--*/
{
    DWORD Err = NO_ERROR;
    CONFIGRET cr;
    ULONG PropDataType, BufferSize = 0;
    PTSTR Buffer = NULL;
    PTSTR *Array = NULL;
    UINT  Count, i;
    PTSTR CurString;

    try {
        //
        // Retrieve the device registry property.
        //
        do {

            if((cr = CM_Get_DevInst_Registry_Property(DevInst,
                                                      CmPropertyCode,
                                                      &PropDataType,
                                                      Buffer,
                                                      &BufferSize,
                                                      0)) != CR_SUCCESS) {
                switch(cr) {

                    case CR_BUFFER_SMALL :
                        //
                        // Allocate a larger buffer.
                        //
                        if(Buffer) {
                            MyFree(Buffer);
                            Buffer = NULL;
                        }
                        if(!(Buffer = MyMalloc(BufferSize))) {
                            Err = ERROR_NOT_ENOUGH_MEMORY;
                            goto clean0;
                        }
                        break;

                    case CR_NO_SUCH_VALUE :
                        //
                        // The specified property doesn't currently exist.  That's
                        // OK--we'll just return an empty string array.
                        //
                        break;

                    case CR_INVALID_DEVINST :
                        Err = ERROR_NO_SUCH_DEVINST;
                        goto clean0;

                    default :
                        Err = ERROR_INVALID_DATA;
                        goto clean0;
                }
            }

        } while(cr == CR_BUFFER_SMALL);

        //
        // By this point, we've either retrieved the property data (CR_SUCCESS), or we've
        // discovered that it doesn't presently exist (CR_NO_SUCH_VALUE).  Allocate space
        // for the array (at least one element, even if there are no strings).
        //
        Count = 0;
        if(cr == CR_SUCCESS) {

            if(PropDataType != REG_MULTI_SZ) {
                Err = ERROR_INVALID_DATA;
                goto clean0;
            }

            if (Buffer) {
                for(CurString = Buffer;
                    *CurString;
                    CurString += (lstrlen(CurString) + 1)) {

                    Count++;
                }
            }
        }

        i = 0;

        if(!(Array = MyMalloc(Count ? (Count * sizeof(PTSTR)) : sizeof(PTSTR)))) {
            Err = ERROR_NOT_ENOUGH_MEMORY;
            goto clean0;
        }

        if(cr == CR_SUCCESS) {

            if (Buffer) {
                for(CurString = Buffer;
                    *CurString;
                    CurString += (lstrlen(CurString) + 1)) {

                    if(Array[i] = DuplicateString(CurString)) {
                        i++;
                    } else {
                        Err = ERROR_NOT_ENOUGH_MEMORY;
                        goto clean0;
                    }
                }
            }
        }

        *StringArray = Array;
        *StringCount = Count;

clean0: ;   // nothing to do

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;
        //
        // Access the following variables here so that the compiler will respect our statement
        // ordering w.r.t. these values.  Otherwise, we can't be sure that the values are accurate
        // at the point where the exception occurred.
        //
        Buffer = Buffer;
        Array = Array;
        i = i;
    }

    if(Buffer) {
        MyFree(Buffer);
    }

    if((Err != NO_ERROR) && Array) {
        pSetupFreeStringArray(Array, i);
    }

    return Err;
}


DWORD
SetArrayToMultiSzDevRegProp(
    IN DEVINST  DevInst,
    IN ULONG    CmPropertyCode,
    IN PTSTR   *StringArray,
    IN UINT     StringCount
    )
/*++

Routine Description:

    This routine converts a string array into a multi-sz buffer, and
    sets the specified device registry property to its contents.

Arguments:

    DevInst - supplies the handle to the device instance for which the
        registry property is to be set.

    CmPropertyCode - specifies the property to be set.  This is a
        CM_DRP value.

    StringArray - supplies the string array to use in creating the
        multi-sz buffer.

    StringCount - supplies the number of strings in the array.

Return Value:

    If successful, the return value is NO_ERROR, otherwise, it is an
    ERROR_* code.

--*/
{
    UINT i;
    UINT Length;
    UINT BufferSize;
    PTCHAR Buffer;
    PTCHAR p;
    DWORD d;
    CONFIGRET cr;

    //
    // Calculate the length of the buffer needed to hold the
    // multi sz value. Note that empty strings are not allowed.
    //
    BufferSize = StringCount ? sizeof(TCHAR) : (2 * sizeof(TCHAR));
    for(i=0; i<StringCount; i++) {

        if(Length = lstrlen(StringArray[i])) {
            BufferSize += (Length + 1) * sizeof(TCHAR);
        } else {
            return(ERROR_INVALID_DATA);
        }
    }

    d = NO_ERROR;

    //
    // Allocate a buffer to hold the data.
    //
    if(!(Buffer = MyMalloc(BufferSize))) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    try {
        //
        // Copy the string data into the buffer, forming a multi sz.
        //
        p = Buffer;
        if(StringCount) {
            for(i=0; i<StringCount; i++, p+=Length+1) {

                Length = lstrlen(StringArray[i]);

                lstrcpy(p, StringArray[i]);
            }
        } else {
            *(p++) = TEXT('\0');
        }
        *p = TEXT('\0');

        if((cr = CM_Set_DevInst_Registry_Property(DevInst,
                                                  CmPropertyCode,
                                                  Buffer,
                                                  BufferSize,
                                                  0)) != CR_SUCCESS) {

            d = (cr == CR_INVALID_DEVINST) ? ERROR_NO_SUCH_DEVINST
                                           : ERROR_INVALID_DATA;
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        d = ERROR_INVALID_PARAMETER;
    }

    MyFree(Buffer);
    return(d);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\setupapi\sources.inc ===
MAJORCOMP=setup

TARGETPATH=obj
TARGETTYPE=DYNLINK

DLLDEF=$(O)\setupapi.def
DLLENTRY=_DllMainCRTStartup

!include $(PROJECT_ROOT)\prerelease.inc

!if $(PRERELEASE)
# C_DEFINES=$(C_DEFINES) -DMEM_DBG=1 -DASSERTS_ON=1
#C_DEFINES=$(C_DEFINES) -DMEM_DBG=1
#C_DEFINES=$(C_DEFINES) -DDBGHEAP_CHECK
!endif

INCLUDES=\
    ..;                  \
    $(DS_INC_PATH);      \
    $(SHELL_INC_PATH);   \
    $(ADMIN_INC_PATH);   \
    $(WINDOWS_INC_PATH); \
    $(ENDUSER_INC_PATH); \
    $(NET_INC_PATH); \
    $(PROJECT_ROOT)\win32\lz32\winlza;


#
# setupapi can be run over the net; this flag forces the file to be copied
# to the local pagefile and protects against inpage i/o errors
#
LINKER_FLAGS=/SWAPRUN:CD /SWAPRUN:NET

SOURCES=\
    ..\backup.c    \
    ..\cntxtlog.c  \
    ..\copy.c      \
    ..\debug.c     \
    ..\decomp.c    \
    ..\devclass.c  \
    ..\devdrv.c    \
    ..\devicon.c   \
    ..\devinfo.c   \
    ..\devinst.c   \
    ..\devinstd.c  \
    ..\devoem.c    \
    ..\devprop.c   \
    ..\devreg.c    \
    ..\devres.c    \
    ..\devres1.c   \
    ..\devres2.c   \
    ..\devwiz.c    \
    ..\devwmi.c    \
    ..\diamond.c   \
    ..\diansicv.c  \
    ..\diskspac.c  \
    ..\diutil.c    \
    ..\dll.c       \
    ..\filelog.c   \
    ..\fileq1.c    \
    ..\fileq2.c    \
    ..\fileq3.c    \
    ..\fileq4.c    \
    ..\fileq5.c    \
    ..\fileq6.c    \
    ..\fileqcb.c   \
    ..\fileutil.c  \
    ..\fusion.c    \
    ..\infcache.c  \
    ..\infflist.c  \
    ..\infinst.c   \
    ..\infline.c   \
    ..\infload.c   \
    ..\inflogcf.c  \
    ..\infold.c    \
    ..\infopenv.c  \
    ..\infsdisk.c  \
    ..\infvalue.c  \
    ..\logapi.c    \
    ..\memory.c    \
    ..\miscutil.c  \
    ..\mru.c       \
    ..\oldspapi.c  \
    ..\prompt.c    \
    ..\registry.c  \
    ..\resource.c  \
    ..\setupapi.rc \
    ..\stub.c

UMRES=$(O)\setupapi.res
UMTYPE=windows
UMENTRY=winmain

NTTARGETFILE0=msg.h msg.rc

PRECOMPILED_INCLUDE=precomp.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\setupapi\spfusion.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    spfusion.h

Abstract:

    Wrappers and functions for fusionizing SetupAPI
    without effecting 3rd party DLL's
    and without dll-load overhead

Author:

    Jamie Hunter (JamieHun) 12/4/2000

Revision History:

--*/

//
// redirect these API's to our internal implementation
// that initializes fusion if needed
//

#ifdef FUSIONAWARE

#undef CreateWindow
#undef CreateWindowEx
#undef CreateDialogParam
#undef CreateDialogIndirectParam
#undef DialogBoxParam
#undef DialogBoxIndirectParam
#undef MessageBox
#undef PropertySheet
#undef CreatePropertySheetPage
#undef DestroyPropertySheetPage
#undef ImageList_Create
#undef ImageList_Destroy
#undef ImageList_GetImageCount
#undef ImageList_SetImageCount
#undef ImageList_Add
#undef ImageList_ReplaceIcon
#undef ImageList_SetBkColor
#undef ImageList_GetBkColor
#undef ImageList_SetOverlayImage
#undef GetOpenFileName
#undef GetSaveFileName
#undef ChooseColor
#undef ChooseFont
#undef CommDlgExtendedError
#undef FindText
#undef GetFileTitle
#undef PageSetupDlg
#undef PrintDlg
#undef PrintDlgEx
#undef ReplaceText

#define CreateWindow                   spFusionCreateWindow
#define CreateWindowEx                 spFusionCreateWindowEx
#define CreateDialogParam              spFusionCreateDialogParam
#define CreateDialogIndirectParam      spFusionCreateDialogIndirectParam
#define DialogBoxParam                 spFusionDialogBoxParam
#define DialogBoxIndirectParam         spFusionDialogBoxIndirectParam
#define MessageBox                     spFusionMessageBox
#define PropertySheet                  spFusionPropertySheet
#define CreatePropertySheetPage        spFusionCreatePropertySheetPage
#define DestroyPropertySheetPage       spFusionDestroyPropertySheetPage
#define ImageList_Create               spFusionImageList_Create
#define ImageList_Destroy              spFusionImageList_Destroy
#define ImageList_GetImageCount        spFusionImageList_GetImageCount
#define ImageList_SetImageCount        spFusionImageList_SetImageCount
#define ImageList_Add                  spFusionImageList_Add
#define ImageList_ReplaceIcon          spFusionImageList_ReplaceIcon
#define ImageList_SetBkColor           spFusionImageList_SetBkColor
#define ImageList_GetBkColor           spFusionImageList_GetBkColor
#define ImageList_SetOverlayImage      spFusionImageList_SetOverlayImage
#define GetOpenFileName                spFusionGetOpenFileName


BOOL spFusionInitialize();
BOOL spFusionUninitialize(BOOL Full);

HWND spFusionCreateWindow(
            LPCTSTR lpClassName,  // registered class name
            LPCTSTR lpWindowName, // window name
            DWORD dwStyle,        // window style
            int x,                // horizontal position of window
            int y,                // vertical position of window
            int nWidth,           // window width
            int nHeight,          // window height
            HWND hWndParent,      // handle to parent or owner window
            HMENU hMenu,          // menu handle or child identifier
            HINSTANCE hInstance,  // handle to application instance
            LPVOID lpParam        // window-creation data
            );

HWND spFusionCreateWindowEx(
            DWORD dwExStyle,      // extended window style
            LPCTSTR lpClassName,  // registered class name
            LPCTSTR lpWindowName, // window name
            DWORD dwStyle,        // window style
            int x,                // horizontal position of window
            int y,                // vertical position of window
            int nWidth,           // window width
            int nHeight,          // window height
            HWND hWndParent,      // handle to parent or owner window
            HMENU hMenu,          // menu handle or child identifier
            HINSTANCE hInstance,  // handle to application instance
            LPVOID lpParam        // window-creation data
            );

HWND spFusionCreateDialogParam(
            HINSTANCE hInstance,     // handle to module
            LPCTSTR lpTemplateName,  // dialog box template
            HWND hWndParent,         // handle to owner window
            DLGPROC lpDialogFunc,    // dialog box procedure
            LPARAM dwInitParam       // initialization value
            );

HWND spFusionCreateDialogIndirectParam(
            HINSTANCE hInstance,        // handle to module
            LPCDLGTEMPLATE lpTemplate,  // dialog box template
            HWND hWndParent,            // handle to owner window
            DLGPROC lpDialogFunc,       // dialog box procedure
            LPARAM lParamInit           // initialization value
            );

INT_PTR spFusionDialogBoxParam(
            HINSTANCE hInstance,     // handle to module
            LPCTSTR lpTemplateName,  // dialog box template
            HWND hWndParent,         // handle to owner window
            DLGPROC lpDialogFunc,    // dialog box procedure
            LPARAM dwInitParam       // initialization value
            );

INT_PTR spFusionDialogBoxIndirectParam(
            HINSTANCE hInstance,             // handle to module
            LPCDLGTEMPLATE hDialogTemplate,  // dialog box template
            HWND hWndParent,                 // handle to owner window
            DLGPROC lpDialogFunc,            // dialog box procedure
            LPARAM dwInitParam               // initialization value
            );

int spFusionMessageBox(
            IN HWND hWnd,
            IN LPCTSTR lpText,
            IN LPCTSTR lpCaption,
            IN UINT uType
            );

int spNonFusionMessageBox(
            IN HWND hWnd,
            IN LPCTSTR lpText,
            IN LPCTSTR lpCaption,
            IN UINT uType
            );

INT_PTR spFusionPropertySheet(
            LPCPROPSHEETHEADER pPropSheetHeader
            );

HPROPSHEETPAGE spFusionCreatePropertySheetPage(
            LPPROPSHEETPAGE pPropSheetPage
            );

BOOL spFusionDestroyPropertySheetPage(
            HPROPSHEETPAGE hPropSheetPage
            );

//
// from commctrl.h
//
HIMAGELIST spFusionImageList_Create(int cx, int cy, UINT flags, int cInitial, int cGrow);
BOOL       spFusionImageList_Destroy(HIMAGELIST himl);
int        spFusionImageList_GetImageCount(HIMAGELIST himl);
BOOL       spFusionImageList_SetImageCount(HIMAGELIST himl, UINT uNewCount);
int        spFusionImageList_Add(HIMAGELIST himl, HBITMAP hbmImage, HBITMAP hbmMask);
int        spFusionImageList_ReplaceIcon(HIMAGELIST himl, int i, HICON hicon);
COLORREF   spFusionImageList_SetBkColor(HIMAGELIST himl, COLORREF clrBk);
COLORREF   spFusionImageList_GetBkColor(HIMAGELIST himl);
BOOL       spFusionImageList_SetOverlayImage(HIMAGELIST himl, int iImage, int iOverlay);

//
// from commdlg.h
//
BOOL spFusionGetOpenFileName(LPOPENFILENAME lpofn);


//
// private stuff
//

typedef struct _SPFUSIONINSTANCE {
    BOOL      Acquired;
    ULONG_PTR Cookie;
} SPFUSIONINSTANCE, *PSPFUSIONINSTANCE;

HANDLE
spFusionContextFromModule(
    IN PCTSTR ModuleName
    );

BOOL
spFusionKillContext(
    IN HANDLE hContext
    );

BOOL
spFusionEnterContext(
    IN  HANDLE hContext,
    OUT PSPFUSIONINSTANCE pInst
    );

BOOL
spFusionLeaveContext(
    IN PSPFUSIONINSTANCE pInst
    );

#else

//
// dummy structure/API's that do nothing
//

typedef struct _SPFUSIONINSTANCE {
    BOOL      Acquired;
} SPFUSIONINSTANCE, *PSPFUSIONINSTANCE;

__inline
HANDLE
spFusionContextFromModule(
    IN PCTSTR ModuleName
    )
{
    ModuleName = ModuleName;
    return NULL;
}

__inline
BOOL
spFusionKillContext(
    IN HANDLE hContext
    )
{
    hContext = hContext;
    return TRUE;
}

__inline
BOOL
spFusionEnterContext(
    IN  HANDLE hContext,
    OUT PSPFUSIONINSTANCE pInst
    )
{
    hContext = hContext;
    pInst->Acquired = TRUE;
    return TRUE;
}

__inline
BOOL
spFusionLeaveContext(
    IN PSPFUSIONINSTANCE pInst
    )
{
    pInst->Acquired = FALSE;
    return TRUE;
}

#endif // FUSIONAWARE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\setupapi\setupntp.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    setupntp.h

Abstract:

    Private top-level header file for Windows NT Setup
    services Dll.

Author:

    Ted Miller (tedm) 11-Jan-1995

Revision History:

    Jamie Hunter (jamiehun) 27-Jan-2000 Added infcache.h
    Jim Schmidt (jimschm)   16-Dec-1998 Log api init
    Jim Schmidt (jimschm)   28-Apr-1997 Added stub.h
    Jamie Hunter (jamiehun) 13-Jan-1997 Added backup.h

--*/


#if !defined(UNICODE) || !defined(_UNICODE) || defined(ANSI_SETUPAPI)
#error "Ansi SetupAPI no longer supported"
#endif

//
// System header files
//

#if DBG
#ifndef MEM_DBG
#define MEM_DBG 1
#endif
#else
#ifndef MEM_DBG
#define MEM_DBG 0
#endif
#endif

//
// NT Header Files
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>


//
// Make sure we always use version 2 of SP_ALTPLATFORM_INFO structure...
//
#define USE_SP_ALTPLATFORM_INFO_V1 0

//
// CRT header files
//
#include <process.h>
#include <malloc.h>
#include <wchar.h>
#include <stddef.h>
#include <stdio.h>
#include <fcntl.h>
#include <tchar.h>
#include <mbstring.h>
//
// Windows header files
//
#include <windows.h>
#include <windowsx.h>
#include <commctrl.h>
#include <commdlg.h>
#include <prsht.h>
#include <spfusion.h>

#include <imagehlp.h>
#include <diamondd.h>
#include <lzexpand.h>
#include <dlgs.h>
#include <regstr.h>
#include <infstr.h>
#include <objbase.h>
#include <wincrypt.h>
#include <mscat.h>
#include <softpub.h>
#include <wintrust.h>
#include <cryptui.h>
#include <shlobj.h>
#include <shlwapi.h>
#include <shellapi.h>
#include <userenv.h>
#include <userenvp.h>
#include <secedit.h>
#include <scesetup.h>
#include <sfcapip.h>
#include <wow64reg.h>
#include <dbt.h>
#include <shimdb.h>
#include <setupapi.h>

#include <cfgmgr32.h>
#include <spapip.h>
#include <devguid.h>
#include <cdm.h>

//
// safe strings
//
#define STRSAFE_NO_DEPRECATE // we're using both safe and 'unsafe' routines right now
#include <strsafe.h>

//
// these definitions may be used by private header files
//
#ifndef ARRAYSIZE
#define ARRAYSIZE(x)    (sizeof((x))/sizeof((x)[0]))
#endif
#define SIZECHARS(x)    ARRAYSIZE(x)
#define CSTRLEN(x)      (SIZECHARS(x)-1)

typedef struct _STRING_TO_DATA {
    PCTSTR     String;
    UINT_PTR   Data;
} STRING_TO_DATA, *PSTRING_TO_DATA;

//
// Define structure to house various verification context handles (cached on a
// per-file-queue basis for performance).
//
typedef struct _VERIFY_CONTEXT {
    //
    // crypto context handle acquired during digital signature verification
    // (starts out as NULL, if non-NULL when freeing queue, must release via
    // CryptCATAdminReleaseContext)
    //
    HCATADMIN hCatAdmin;

    //
    // handle to bad driver database acquired during check for blocked driver
    // (starts out as NULL, if non-NULL when freeing queue, must release via
    // SdbReleaseDatabase)
    //
    HSDB hSDBDrvMain;

    //
    // handle to trusted publisher certificate store.  Used when checking to
    // see if the publisher of an Authenticode-signed catalog should be
    // implicitly trusted (i.e., without prompting the user).  (starts out as
    // NULL, if non-NULL when freing queue, must release via CertCloseStore)
    //
    HCERTSTORE hStoreTrustedPublisher;

} VERIFY_CONTEXT, *PVERIFY_CONTEXT;


//
// Private header files
//
#include "sputils/locking.h"
#include "sputils/strtab.h"
#include "memory.h"
#include "cntxtlog.h"
#include "inf.h"
#include "infcache.h"
#include "backup.h"
#include "fileq.h"
#include "debug.h"
#include "devinst.h"
#include "devres.h"
#include "rc_ids.h"
#include "msg.h"
#include "stub.h"
#include "helpids.h"

#ifdef CHILDREGISTRATION
#include "childreg.h"
#ifndef _WIN64
#include <wow64t.h>
#endif // _WIN64
#endif // CHILDREGISTRATION

//
// NTRAID#489682-2001/11/02-JamieHun These need to move into public headers
//
#define SP_COPY_ALREADYDECOMP       0x0400000   // similar to SP_COPY_NODECOMP

//
// Private DNF_ flags (start at 0x10000000)
//
#define PDNF_MASK                   0xF0000000  // Mask for private PDNF_xxx flags
#define PDNF_CLEANUP_SOURCE_PATH    0x10000000  // Delete the source path when we destroy the driver node
                                                // used when drivers are downloaded from the Internet
//
// Thread Local Storage Index
//
extern DWORD TlsIndex;

//
// Module handle for this DLL. Filled in at process attach.
//
extern HANDLE MyDllModuleHandle;

//
// Module handle for security DLL. Initialized to NULL in at process attach. Filled in when SCE APIs have to be called
//
extern HINSTANCE SecurityDllHandle;

//
// OS Version Information structure filled in at process attach.
//
extern OSVERSIONINFOEX OSVersionInfo;

//
// Static strings we retreive once, at process attach.
//
extern PCTSTR WindowsDirectory,InfDirectory,SystemDirectory,ConfigDirectory,DriversDirectory,System16Directory;
extern PCTSTR SystemSourcePath,ServicePackSourcePath,DriverCacheSourcePath,ServicePackCachePath;
extern PCTSTR OsLoaderRelativePath;     // may be NULL
extern PCTSTR OsSystemPartitionRoot;    // \\?\GLOBALROOT\Device\Volume
extern PCTSTR WindowsBackupDirectory;   // Directory to write uninstall backups to
extern PCTSTR ProcessFileName;          // Filename of app calling setupapi
extern PCTSTR LastGoodDirectory;        // %windir%\LastGood

//
// are we inside gui setup? determined at process attach
//
extern BOOL GuiSetupInProgress;

//
// various other global flags
//
extern DWORD GlobalSetupFlags;

//
// global window message for cancelling autoplay.
//
extern UINT g_uQueryCancelAutoPlay;

//
// Static multi-sz list of directories to be searched for INFs.
//
extern PCTSTR InfSearchPaths;

//
// Determine at runtime if we're running under WOW64
//
#ifndef _WIN64
extern BOOL IsWow64;
#endif

#ifdef UNICODE
extern DWORD Seed;
#endif

//
// ImageHlp isn't multi-thread safe, so needs a mutex
//
extern CRITICAL_SECTION InitMutex;             // for one-time initializations
extern CRITICAL_SECTION ImageHlpMutex;         // for dealing with IMAGEHLP library
extern CRITICAL_SECTION PlatformPathOverrideCritSect;
extern CRITICAL_SECTION LogUseCountCs;
extern CRITICAL_SECTION MruCritSect;
extern CRITICAL_SECTION NetConnectionListCritSect;


//
// Debug memory functions and wrappers to track allocations
//

DWORD
QueryRegistryValue(
    IN  HKEY    KeyHandle,
    IN  PCTSTR  ValueName,
    OUT PTSTR  *Value,
    OUT PDWORD  DataType,
    OUT PDWORD  DataSizeBytes
    );

DWORD
QueryDeviceRegistryProperty(
    IN  HDEVINFO         DeviceInfoSet,
    IN  PSP_DEVINFO_DATA DeviceInfoData,
    IN  DWORD            Property,
    OUT PTSTR           *Value,
    OUT PDWORD           DataType,
    OUT PDWORD           DataSizeBytes
    );

DWORD
QueryRegistryDwordValue(
    IN  HKEY    KeyHandle,
    IN  PCTSTR  ValueName,
    OUT PDWORD  Value
    );

BOOL
MemoryInitializeEx(
    IN BOOL Attach
    );

#if MEM_DBG

//
// Macros and wrappers are needed for externally exposed functions
//
PVOID MyDebugMalloc(
    IN DWORD Size,
    IN PCSTR Filename,
    IN DWORD Line,
    IN DWORD Tag
    );

#define MyMalloc(sz)                    MyDebugMalloc(sz,__FILE__,__LINE__,0)
#define MyTaggedMalloc(sz,tag)          MyDebugMalloc(sz,__FILE__,__LINE__,tag)
#define MyTaggedRealloc(ptr,sz,tag)     pSetupReallocWithTag(ptr,sz,tag)
#define MyTaggedFree(ptr,tag)           pSetupFreeWithTag(ptr,tag)

DWORD
TrackedQueryRegistryValue(
    IN          TRACK_ARG_DECLARE,
    IN  HKEY    KeyHandle,
    IN  PCTSTR  ValueName,
    OUT PTSTR  *Value,
    OUT PDWORD  DataType,
    OUT PDWORD  DataSizeBytes
    );

#define QueryRegistryValue(a,b,c,d,e)   TrackedQueryRegistryValue(TRACK_ARG_CALL,a,b,c,d,e)

DWORD
TrackedQueryDeviceRegistryProperty(
    IN                   TRACK_ARG_DECLARE TRACK_ARG_COMMA
    IN  HDEVINFO         DeviceInfoSet,
    IN  PSP_DEVINFO_DATA DeviceInfoData,
    IN  DWORD            Property,
    OUT PTSTR           *Value,
    OUT PDWORD           DataType,
    OUT PDWORD           DataSizeBytes
    );

#define QueryDeviceRegistryProperty(a,b,c,d,e,f)   TrackedQueryDeviceRegistryProperty(TRACK_ARG_CALL,a,b,c,d,e,f)

PTSTR
TrackedDuplicateString(
    IN TRACK_ARG_DECLARE,
    IN PCTSTR String
    );

#define DuplicateString(x)              TrackedDuplicateString(TRACK_ARG_CALL,x)

#else

#define DuplicateString                 pSetupDuplicateString
#define MyMalloc(sz)                    pSetupMalloc(sz)
#define MyTaggedMalloc(sz,tag)          pSetupMalloc(sz)
#define MyTaggedRealloc(ptr,sz,tag)     pSetupRealloc(ptr,sz)
#define MyTaggedFree(ptr,tag)           pSetupFree(ptr)

#endif

#define MyFree(ptr)                     pSetupFree(ptr)
#define MyRealloc(ptr,sz)               pSetupRealloc(ptr,sz)

//
// memory tags grouped here for easy reference
// see also common.h in sputils
//
//
// Log Context tags
//
#define MEMTAG_LOGCONTEXT               (0x636c434c) // LClc - context structure
#define MEMTAG_LCSECTION                (0x7378434c) // LCxs - section string
#define MEMTAG_LCBUFFER                 (0x6278434c) // LCxb - other strings
#define MEMTAG_LCINFO                   (0x6269434c) // LCib - info (array of buffers)
#define MEMTAG_LCINDEXES                (0x6969434c) // LCii - index
//
// Loaded_Inf tags
//
#define MEMTAG_INF                      (0x666e694c) // Linf - LOADED_INF
#define MEMTAG_VBDATA                   (0x6462764c) // Lvbd - version block data


//
// File functions in fileutil.c
//

typedef struct _TEXTFILE_READ_BUFFER {
    PCTSTR TextBuffer;
    DWORD  TextBufferSize;
    HANDLE FileHandle;
    HANDLE MappingHandle;
    PVOID  ViewAddress;
} TEXTFILE_READ_BUFFER, *PTEXTFILE_READ_BUFFER;

DWORD
ReadAsciiOrUnicodeTextFile(
    IN  HANDLE                FileHandle,
    OUT PTEXTFILE_READ_BUFFER Result,
    IN  PSETUP_LOG_CONTEXT    LogContext OPTIONAL
    );

BOOL
DestroyTextFileReadBuffer(
    IN PTEXTFILE_READ_BUFFER ReadBuffer
    );

BOOL
AddFileTimeSeconds(
    IN  const FILETIME *Base,
    OUT FILETIME *Target,
    IN  INT Seconds
    );

DWORD
GetSetFileTimestamp(
    IN  PCTSTR    FileName,
    OUT FILETIME *CreateTime,   OPTIONAL
    OUT FILETIME *AccessTime,   OPTIONAL
    OUT FILETIME *WriteTime,    OPTIONAL
    IN  BOOL      Set
    );

DWORD
RetreiveFileSecurity(
    IN  PCTSTR                FileName,
    OUT PSECURITY_DESCRIPTOR *SecurityDescriptor
    );

DWORD
StampFileSecurity(
    IN PCTSTR               FileName,
    IN PSECURITY_DESCRIPTOR SecurityInfo
    );

DWORD
TakeOwnershipOfFile(
    IN PCTSTR Filename
    );

DWORD
SearchForInfFile(
    IN  PCTSTR                      InfName,
    OUT LPWIN32_FIND_DATA           FindData,
    IN  DWORD                       SearchControl,
    OUT PTSTR                       FullInfPath,
    IN  UINT                        FullInfPathSize,
    OUT PUINT                       RequiredSize     OPTIONAL
    );

DWORD
MultiSzFromSearchControl(
    IN  DWORD  SearchControl,
    OUT PTCHAR PathList,
    IN  DWORD  PathListSize,
    OUT PDWORD RequiredSize  OPTIONAL
    );

PSTR
GetAnsiMuiSafePathname(
    IN  PCTSTR      FilePath
    );

PSTR
GetAnsiMuiSafeFilename(
    IN  PCTSTR      FilePath
    );

BOOL
pSetupAppendPath(
    IN  PCTSTR  Path1,
    IN  PCTSTR  Path2,
    OUT PTSTR*  Combined
    );

BOOL
pSetupApplyExtension(
    IN  PCTSTR  Original,
    IN  PCTSTR  Extension,
    OUT PTSTR*  NewName
    );

//
// Resource/string retrieval routines in resource.c
//

VOID
SetDlgText(
    IN HWND hwndDlg,
    IN INT  iControl,
    IN UINT nStartString,
    IN UINT nEndString
    );

#define SDT_MAX_TEXT    1000        // Max SetDlgText() combined text size

PTSTR
MyLoadString(
    IN UINT StringId
    );

PTSTR
FormatStringMessage(
    IN UINT FormatStringId,
    ...
    );

PTSTR
FormatStringMessageV(
    IN UINT     FormatStringId,
    IN va_list *ArgumentList
    );

PTSTR
FormatStringMessageFromString(
    IN PTSTR FormatString,
    ...
    );

PTSTR
FormatStringMessageFromStringV(
    IN PTSTR    FormatString,
    IN va_list *ArgumentList
    );

PTSTR
RetreiveAndFormatMessage(
    IN UINT MessageId,
    ...
    );

PTSTR
RetreiveAndFormatMessageV(
    IN UINT     MessageId,
    IN va_list *ArgumentList
    );

INT
FormatMessageBox(
    IN HANDLE hinst,
    IN HWND   hwndParent,
    IN UINT   TextMessageId,
    IN PCTSTR Title,
    IN UINT   Style,
    ...
    );

//
// This is in shell32.dll and in windows\inc16\shlsemip.h but
// that file cannot be #include'd here as it has macros that clash
// with our own, etc.
//
#ifdef ANSI_SETUPAPI
//
// Win9x - does not have RestartDialogEx
//
#define RestartDialogEx(hwnd,Prompt,Return,ReasonCode) RestartDialog(hwnd,Prompt,Return)
#endif
//
// Decompression/filename manupilation routines in decomp.c.
//
PTSTR
SetupGenerateCompressedName(
    IN PCTSTR Filename
    );

DWORD
SetupInternalGetFileCompressionInfo(
    IN  PCTSTR                       SourceFileName,
    OUT PTSTR                       *ActualSourceFileName,
    OUT PWIN32_FIND_DATA             SourceFindData,
    OUT PDWORD                       TargetFileSize,
    OUT PUINT                        CompressionType
    );

DWORD
SetupDetermineSourceFileName(
    IN  PCTSTR                       FileName,
    OUT PBOOL                        UsedCompressedName,
    OUT PTSTR                       *FileNameLocated,
    OUT PWIN32_FIND_DATA             FindData
    );

BOOL
pSetupDoesFileMatch(
    IN  PCTSTR            InputName,
    IN  PCTSTR            CompareName,
    OUT PBOOL             UsedCompressedName,
    OUT PTSTR            *FileNameLocated
    );

//
// Diamond functions. The Process and Thread Attach routines are called
// by the DLL entry point routine and should not be called by anyone else.
//
BOOL
DiamondProcessAttach(
    IN BOOL Attach
    );

BOOL
DiamondTlsInit(
    IN BOOL Init
    );

BOOL
DiamondIsCabinet(
    IN PCTSTR FileName
    );

DWORD
DiamondProcessCabinet(
    IN PCTSTR CabinetFile,
    IN DWORD  Flags,
    IN PVOID  MsgHandler,
    IN PVOID  Context,
    IN BOOL   IsUnicodeMsgHandler
    );

//
// Misc routines
//
BOOL
IsInteractiveWindowStation(
    VOID
    );

VOID
DiskPromptGetDriveType(
    IN  PCTSTR PathToSource,
    OUT PUINT  DriveType,
    OUT PBOOL  IsRemovable
    );

BOOL
SetTruncatedDlgItemText(
    HWND hdlg,
    UINT CtlId,
    PCTSTR TextIn
    );

LPTSTR
CompactFileName(
    LPCTSTR FileNameIn,
    DWORD CharsToRemove
    );

DWORD
ExtraChars(
    HWND hwnd,
    LPCTSTR TextBuffer
    );

VOID
pSetupInitPlatformPathOverrideSupport(
    IN BOOL Init
    );

VOID
pSetupInitSourceListSupport(
    IN BOOL Init
    );

DWORD
pSetupDecompressOrCopyFile(
    IN  PCTSTR SourceFileName,
    IN  PCTSTR TargetFileName,
    IN  PUINT  CompressionType, OPTIONAL
    IN  BOOL   AllowMove,
    OUT PBOOL  Moved            OPTIONAL
    );

BOOL
_SetupInstallFileEx(
    IN  PSP_FILE_QUEUE      Queue,             OPTIONAL
    IN  PSP_FILE_QUEUE_NODE QueueNode,         OPTIONAL
    IN  HINF                InfHandle,         OPTIONAL
    IN  PINFCONTEXT         InfContext,        OPTIONAL
    IN  PCTSTR              SourceFile,        OPTIONAL
    IN  PCTSTR              SourcePathRoot,    OPTIONAL
    IN  PCTSTR              DestinationName,   OPTIONAL
    IN  DWORD               CopyStyle,
    IN  PVOID               CopyMsgHandler,    OPTIONAL
    IN  PVOID               Context,           OPTIONAL
    OUT PBOOL               FileWasInUse,
    IN  BOOL                IsMsgHandlerNativeCharWidth,
    OUT PBOOL               SignatureVerifyFailed
    );

VOID
pSetupFreeVerifyContextMembers(
    IN PVERIFY_CONTEXT VerifyContext
    );


//
// Define flags for _SetupCopyOEMInf
//
#define SCOI_NO_UI_ON_SIGFAIL                 0x00000001
#define SCOI_NO_ERRLOG_ON_MISSING_CATALOG     0x00000002
#define SCOI_NO_ERRLOG_IF_INF_ALREADY_PRESENT 0x00000004
#define SCOI_KEEP_INF_AND_CAT_ORIGINAL_NAMES  0x00000008 // for exception INFs
#define SCOI_ABORT_IF_UNSIGNED                0x00000010
#define SCOI_TRY_UPDATE_PNF                   0x00000020 // not fatal if PNF
                                                         // present and in use

BOOL
_SetupCopyOEMInf(
    IN     PCTSTR                  SourceInfFileName,
    IN     PCTSTR                  OEMSourceMediaLocation,          OPTIONAL
    IN     DWORD                   OEMSourceMediaType,
    IN     DWORD                   CopyStyle,
    OUT    PTSTR                   DestinationInfFileName,          OPTIONAL
    IN     DWORD                   DestinationInfFileNameSize,
    OUT    PDWORD                  RequiredSize,                    OPTIONAL
    OUT    PTSTR                  *DestinationInfFileNameComponent, OPTIONAL
    IN     PCTSTR                  SourceInfOriginalName,
    IN     PCTSTR                  SourceInfCatalogName,            OPTIONAL
    IN     HWND                    Owner,
    IN     PCTSTR                  DeviceDesc,                      OPTIONAL
    IN     DWORD                   DriverSigningPolicy,
    IN     DWORD                   Flags,
    IN     PCTSTR                  AltCatalogFile,                  OPTIONAL
    IN     PSP_ALTPLATFORM_INFO_V2 AltPlatformInfo,                 OPTIONAL
    OUT    PDWORD                  DriverSigningError,              OPTIONAL
    OUT    PTSTR                   CatalogFilenameOnSystem,
    IN     PSETUP_LOG_CONTEXT      LogContext,
    IN OUT PVERIFY_CONTEXT         VerifyContext,                   OPTIONAL
    OUT    HANDLE                 *hWVTStateData                    OPTIONAL
    );

DWORD
pSetupUninstallCatalog(
    IN LPCTSTR CatalogFilename
    );

VOID
pSetupUninstallOEMInf(
    IN  LPCTSTR            InfFullPath,
    IN  PSETUP_LOG_CONTEXT LogContext,  OPTIONAL
    IN  DWORD              Flags,
    OUT PDWORD             InfDeleteErr OPTIONAL
    );

PTSTR
AllocAndReturnDriverSearchList(
    IN DWORD SearchControl
    );

pSetupGetSecurityInfo(
    IN HINF Inf,
    IN PCTSTR SectionName,
    OUT PCTSTR *SecDesc );

BOOL
pSetupGetDriverDate(
    IN  HINF        InfHandle,
    IN  PCTSTR      Section,
    IN OUT PFILETIME   pFileTime
    );

BOOL
pSetupGetDriverVersion(
    IN  HINF        InfHandle,
    IN  PCTSTR      Section,
    OUT DWORDLONG   *Version
    );

PTSTR
GetMultiSzFromInf(
    IN  HINF    InfHandle,
    IN  PCTSTR  SectionName,
    IN  PCTSTR  Key,
    OUT PBOOL   pSetupOutOfMemory
    );

VOID
pSetupInitNetConnectionList(
    IN BOOL Init
    );

BOOL
_SetupGetSourceFileSize(
    IN  HINF                    InfHandle,
    IN  PINFCONTEXT             InfContext,      OPTIONAL
    IN  PCTSTR                  FileName,        OPTIONAL
    IN  PCTSTR                  Section,         OPTIONAL
    IN  PSP_ALTPLATFORM_INFO_V2 AltPlatformInfo, OPTIONAL
    OUT PDWORD                  FileSize,
    IN  UINT                    RoundingFactor   OPTIONAL
    );

BOOL
_SetupGetSourceFileLocation(
    IN  HINF                    InfHandle,
    IN  PINFCONTEXT             InfContext,       OPTIONAL
    IN  PCTSTR                  FileName,         OPTIONAL
    IN  PSP_ALTPLATFORM_INFO_V2 AltPlatformInfo,  OPTIONAL
    OUT PUINT                   SourceId,         OPTIONAL
    OUT PTSTR                   ReturnBuffer,     OPTIONAL
    IN  DWORD                   ReturnBufferSize,
    OUT PDWORD                  RequiredSize,     OPTIONAL
    OUT PINFCONTEXT             LineContext       OPTIONAL
    );

DWORD
pSetupLogSectionError(
    IN HINF             InfHandle,          OPTIONAL
    IN HDEVINFO         DeviceInfoSet,      OPTIONAL
    IN PSP_DEVINFO_DATA DeviceInfoData,     OPTIONAL
    IN PSP_FILE_QUEUE   Queue,              OPTIONAL
    IN PCTSTR           SectionName,
    IN DWORD            MsgID,
    IN DWORD            Err,
    IN PCTSTR           KeyName             OPTIONAL
);

DWORD
pSetupLogSectionWarning(
    IN HINF             InfHandle,          OPTIONAL
    IN HDEVINFO         DeviceInfoSet,      OPTIONAL
    IN PSP_DEVINFO_DATA DeviceInfoData,     OPTIONAL
    IN PSP_FILE_QUEUE   Queue,              OPTIONAL
    IN PCTSTR           SectionName,
    IN DWORD            MsgID,
    IN DWORD            Err,
    IN PCTSTR           KeyName             OPTIONAL
);

DWORD
pSetupCopyRelatedInfs(
    IN HINF   hDeviceInf,
    IN PCTSTR InfFileName,                  OPTIONAL
    IN PCTSTR InfSectionName,
    IN DWORD  OEMSourceMediaType,
    IN PSETUP_LOG_CONTEXT LogContext        OPTIONAL
    );

BOOL
pCompareFilesExact(
    IN PCTSTR File1,
    IN PCTSTR File2
    );


//
// Routine to call out to a PSP_FILE_CALLBACK, handles
// Unicode<-->ANSI issues
//
UINT
pSetupCallMsgHandler(
    IN PSETUP_LOG_CONTEXT LogContext,
    IN PVOID MsgHandler,
    IN BOOL  MsgHandlerIsNativeCharWidth,
    IN PVOID Context,
    IN UINT  Notification,
    IN UINT_PTR Param1,
    IN UINT_PTR Param2
    );

UINT
pSetupCallDefaultMsgHandler(
    IN PVOID Context,
    IN UINT  Notification,
    IN UINT_PTR Param1,
    IN UINT_PTR Param2
    );

//
// Internal routine to get MRU list.
//
DWORD
pSetupGetList(
    IN  DWORD    Flags,
    OUT PCTSTR **List,
    OUT PUINT    Count,
    OUT PBOOL    NoBrowse
    );

#define  SRCPATH_USEPNFINFORMATION  0x00000001
#define  SRCPATH_USEINFLOCATION     0x00000002

#define SRC_FLAGS_SVCPACK_SOURCE     (0x0001)


#define PSP_COPY_USE_DRIVERCACHE     0x80000000
#define PSP_COPY_CHK_DRIVERCACHE     0x40000000
//#define PSP_COPY_USE_SPCACHE         0x20000000 - moved to spapip.w

PTSTR
pSetupGetDefaultSourcePath(
    IN  HINF   InfHandle,
    IN  DWORD  Flags,
    OUT PDWORD InfSourceMediaType
    );

VOID
InfSourcePathFromFileName(
    IN  PCTSTR  InfFileName,
    OUT PTSTR  *SourcePath,  OPTIONAL
    OUT PBOOL   TryPnf
    );

BOOL
pSetupGetSourceInfo(
    IN  HINF                    InfHandle,         OPTIONAL
    IN  PINFCONTEXT             LayoutLineContext, OPTIONAL
    IN  UINT                    SourceId,
    IN  PSP_ALTPLATFORM_INFO_V2 AltPlatformInfo,   OPTIONAL
    IN  UINT                    InfoDesired,
    OUT PTSTR                   ReturnBuffer,      OPTIONAL
    IN  DWORD                   ReturnBufferSize,
    OUT PDWORD                  RequiredSize       OPTIONAL
    );

//
// function to get the apropriate return value for ReturnStatus, for specific callback Notification
//
UINT
pGetCallbackErrorReturn(
    IN UINT Notification,
    IN DWORD ReturnStatus
    );
//
// Routines for creating/destroying global mini-icon list.
//
BOOL
CreateMiniIcons(
    VOID
    );

VOID
DestroyMiniIcons(
    VOID
    );


//
// Global log init/terminate
//

VOID
InitLogApi (
    VOID
    );

VOID
TerminateLogApi (
    VOID
    );



//
// DIRID mapping routines.
//
PCTSTR
pSetupVolatileDirIdToPath(
    IN PCTSTR      DirectoryId,    OPTIONAL
    IN UINT        DirectoryIdInt, OPTIONAL
    IN PCTSTR      SubDirectory,   OPTIONAL
    IN PLOADED_INF Inf
    );

DWORD
ApplyNewVolatileDirIdsToInfs(
    IN PLOADED_INF MasterInf,
    IN PLOADED_INF Inf        OPTIONAL
    );

PCTSTR
pSetupDirectoryIdToPathEx(
    IN     PCTSTR  DirectoryId,        OPTIONAL
    IN OUT PUINT   DirectoryIdInt,     OPTIONAL
    IN     PCTSTR  SubDirectory,       OPTIONAL
    IN     PCTSTR  InfSourcePath,      OPTIONAL
    IN OUT PCTSTR *OsLoaderPath,       OPTIONAL
    OUT    PBOOL   VolatileSystemDirId OPTIONAL
    );

PCTSTR
pGetPathFromDirId(
    IN     PCTSTR      DirectoryId,
    IN     PCTSTR      SubDirectory,   OPTIONAL
    IN     PLOADED_INF pLoadedInf
    );

//
// routines for inter-thread communication
//

#ifndef UNICODE
#define MyMsgWaitForMultipleObjectsEx(nc,ph,dwms,dwwm,dwfl) MsgWaitForMultipleObjects(nc,ph,FALSE,dwms,dwwm)
#else
#define MyMsgWaitForMultipleObjectsEx MsgWaitForMultipleObjectsEx
#endif

//
// Macro to make ansi vs unicode string handling
// a little easier
//
#ifdef UNICODE
#define NewAnsiString(x)        pSetupUnicodeToAnsi(x)
#define NewPortableString(x)    pSetupAnsiToUnicode(x)
#else
#define NewAnsiString(x)        DuplicateString(x)
#define NewPortableString(x)    DuplicateString(x)
#endif

//
// Internal file-handling routines in fileutil.c
//
DWORD
MapFileForRead(
    IN  HANDLE   FileHandle,
    OUT PDWORD   FileSize,
    OUT PHANDLE  MappingHandle,
    OUT PVOID   *BaseAddress
    );

BOOL
DoMove(
    IN PCTSTR CurrentName,
    IN PCTSTR NewName
    );

BOOL
DelayedMove(
    IN PCTSTR CurrentName,
    IN PCTSTR NewName       OPTIONAL
    );

extern GUID DriverVerifyGuid;

//
// Flags for VerifySourceFile and _VerifyFile
//
#define VERIFY_FILE_IGNORE_SELFSIGNED         0x00000001
#define VERIFY_FILE_USE_OEM_CATALOGS          0x00000002
#define VERIFY_FILE_USE_AUTHENTICODE_CATALOG  0x00000004
#define VERIFY_FILE_DRIVERBLOCKED_ONLY        0x00000008
#define VERIFY_FILE_NO_DRIVERBLOCKED_CHECK    0x00000010

DWORD
_VerifyFile(
    IN     PSETUP_LOG_CONTEXT      LogContext,
    IN OUT PVERIFY_CONTEXT         VerifyContext,          OPTIONAL
    IN     LPCTSTR                 Catalog,                OPTIONAL
    IN     PVOID                   CatalogBaseAddress,     OPTIONAL
    IN     DWORD                   CatalogImageSize,
    IN     LPCTSTR                 Key,
    IN     LPCTSTR                 FileFullPath,
    OUT    SetupapiVerifyProblem  *Problem,                OPTIONAL
    OUT    LPTSTR                  ProblemFile,            OPTIONAL
    IN     BOOL                    CatalogAlreadyVerified,
    IN     PSP_ALTPLATFORM_INFO_V2 AltPlatformInfo,        OPTIONAL
    IN     DWORD                   Flags,                  OPTIONAL
    OUT    LPTSTR                  CatalogFileUsed,        OPTIONAL
    OUT    PDWORD                  NumCatalogsConsidered,  OPTIONAL
    OUT    LPTSTR                  DigitalSigner,          OPTIONAL
    OUT    LPTSTR                  SignerVersion,          OPTIONAL
    OUT    HANDLE                 *hWVTStateData           OPTIONAL
    );

DWORD
VerifySourceFile(
    IN  PSETUP_LOG_CONTEXT      LogContext,
    IN  PSP_FILE_QUEUE          Queue,                      OPTIONAL
    IN  PSP_FILE_QUEUE_NODE     QueueNode,                  OPTIONAL
    IN  PCTSTR                  Key,
    IN  PCTSTR                  FileToVerifyFullPath,
    IN  PCTSTR                  OriginalSourceFileFullPath, OPTIONAL
    IN  PSP_ALTPLATFORM_INFO_V2 AltPlatformInfo,            OPTIONAL
    IN  DWORD                   Flags,
    OUT SetupapiVerifyProblem  *Problem,
    OUT LPTSTR                  ProblemFile,
    OUT LPTSTR                  CatalogFileUsed,            OPTIONAL
    OUT LPTSTR                  DigitalSigner,              OPTIONAL
    OUT LPTSTR                  SignerVersion,              OPTIONAL
    OUT HANDLE                 *hWVTStateData               OPTIONAL
    );

//
// Flags for VerifyDeviceInfFile
//
#define VERIFY_INF_USE_AUTHENTICODE_CATALOG  0x00000004 // same as for _VerifyFile

DWORD
VerifyDeviceInfFile(
    IN     PSETUP_LOG_CONTEXT      LogContext,
    IN OUT PVERIFY_CONTEXT         VerifyContext,          OPTIONAL
    IN     LPCTSTR                 CurrentInfName,
    IN     PLOADED_INF             pInf,
    IN     PSP_ALTPLATFORM_INFO_V2 AltPlatformInfo,        OPTIONAL
    OUT    LPTSTR                  CatalogFileUsed,        OPTIONAL
    OUT    LPTSTR                  DigitalSigner,          OPTIONAL
    OUT    LPTSTR                  SignerVersion,          OPTIONAL
    IN     DWORD                   Flags,
    OUT    HANDLE                 *hWVTStateData           OPTIONAL
    );

BOOL
_HandleFailedVerification(
    IN HWND                  Owner,
    IN SetupapiVerifyProblem Problem,
    IN LPCTSTR               ProblemFile,
    IN LPCTSTR               DeviceDesc,          OPTIONAL
    IN DWORD                 DriverSigningPolicy,
    IN BOOL                  NoUI,
    IN DWORD                 Error,
    IN PVOID                 LogContext,          OPTIONAL
    OUT PDWORD               Flags,               OPTIONAL
    IN LPCTSTR               TargetFile,          OPTIONAL
    IN HANDLE                hWUTStateData        OPTIONAL
    );

VOID
pSetupCloseWVTStateData(
    IN HANDLE hWVTStateData
    );

BOOL
IsInfForDeviceInstall(
    IN  PSETUP_LOG_CONTEXT       LogContext,           OPTIONAL
    IN  CONST GUID              *DeviceSetupClassGuid, OPTIONAL
    IN  PLOADED_INF              LoadedInf,            OPTIONAL
    OUT PTSTR                   *DeviceDesc,           OPTIONAL
    OUT PSP_ALTPLATFORM_INFO_V2 *ValidationPlatform,   OPTIONAL
    OUT PDWORD                   PolicyToUse,          OPTIONAL
    OUT PBOOL                    UseOriginalInfName,   OPTIONAL
    IN  BOOL                     ForceNonDrvSignPolicy
    );

DWORD
GetCodeSigningPolicyForInf(
    IN  PSETUP_LOG_CONTEXT       LogContext,         OPTIONAL
    IN  HINF                     InfHandle,
    OUT PSP_ALTPLATFORM_INFO_V2 *ValidationPlatform, OPTIONAL
    OUT PBOOL                    UseOriginalInfName  OPTIONAL
    );

typedef struct _DRVSIGN_CLASS_LIST_NODE {
    GUID DeviceSetupClassGuid;  // class subject to driver signing policy
    INT MajorVerLB;             // -1 if no validation platform override info
    INT MinorVerLB;             // -1 if no validation platform override info
}  DRVSIGN_CLASS_LIST_NODE, *PDRVSIGN_CLASS_LIST_NODE;

typedef struct _DRVSIGN_POLICY_LIST {
    //
    // Array of device setup class GUIDs for which driver signing policy is
    // applicable, along with validation platform override information (if
    // appropriate).
    //
    PDRVSIGN_CLASS_LIST_NODE Members;

    //
    // Number of elements in above array (initialized to -1).
    //
    INT NumMembers;

    //
    // Synchronization
    //
    MYLOCK Lock;

} DRVSIGN_POLICY_LIST, *PDRVSIGN_POLICY_LIST;

#define LockDrvSignPolicyList(d)   BeginSynchronizedAccess(&((d)->Lock))
#define UnlockDrvSignPolicyList(d) EndSynchronizedAccess(&((d)->Lock))

//
// Global "Driver Search In-Progress" list.
//
extern DRVSIGN_POLICY_LIST GlobalDrvSignPolicyList;

BOOL
InitDrvSignPolicyList(
    VOID
    );

VOID
DestroyDrvSignPolicyList(
    VOID
    );

//
// Bit that may be OR'ed in with driver signing policy to indicate that
// Authenticode signatures may be accepted.
//
#define DRIVERSIGN_ALLOW_AUTHENTICODE 0x80000000

BOOL
IsFileProtected(
    IN  LPCTSTR            FileFullPath,
    IN  PSETUP_LOG_CONTEXT LogContext,   OPTIONAL
    OUT PHANDLE            phSfp         OPTIONAL
    );

#define FileExists pSetupFileExists

BOOL
GetVersionInfoFromImage(
    IN  PCTSTR      FileName,
    OUT PDWORDLONG  Version,
    OUT LANGID     *Language
    );

//
// Utils
//

PCTSTR
GetSystemSourcePath(
    TRACK_ARG_DECLARE
    );

PCTSTR
GetServicePackSourcePath(
    TRACK_ARG_DECLARE
    );

PCTSTR
GetServicePackCachePath(
    TRACK_ARG_DECLARE
    );

DWORD
RegistryDelnode(
    IN  HKEY   RootKey,
    IN  PCTSTR SubKeyName,
    IN  DWORD  ExtraFlags
    );

DWORD
CaptureStringArg(
    IN  PCTSTR  String,
    OUT PCTSTR *CapturedString
    );

DWORD
DelimStringToMultiSz(
    IN PTSTR String,
    IN DWORD StringLen,
    IN TCHAR Delim
    );

BOOL
pAToI(
    IN  PCTSTR Field,
    OUT PINT   IntegerValue
    );

DWORD
pAcquireSCMLock(
    IN  SC_HANDLE  SCMHandle,
    OUT SC_LOCK   *pSCMLock,
    IN  PSETUP_LOG_CONTEXT LogContext
    );

//
// wrapper around pSetupStringTableStringFromIdEx to allocate buffer on fly
//
DWORD
QueryStringTableStringFromId(
    IN PVOID   StringTable,
    IN LONG    StringId,
    IN ULONG   Padding,
    OUT PTSTR *pBuffer
    );

VOID
pSetupExceptionHandler(
    IN  DWORD  ExceptionCode,
    IN  DWORD  AccessViolationError,
    OUT PDWORD Win32ErrorCode        OPTIONAL
    );

LONG
pSetupExceptionFilter(
    DWORD ExceptionCode
    );

//
// Define flags for DoInstallActionWithParams
//
#define INSTALLACTION_CALL_CI    0x00000001
#define INSTALLACTION_NO_DEFAULT 0x00000002

DWORD
DoInstallActionWithParams(
    IN DI_FUNCTION             InstallFunction,
    IN HDEVINFO                DeviceInfoSet,
    IN PSP_DEVINFO_DATA        DeviceInfoData,         OPTIONAL
    IN PSP_CLASSINSTALL_HEADER ClassInstallParams,     OPTIONAL
    IN DWORD                   ClassInstallParamsSize,
    IN DWORD                   Flags
    );

BOOL
LookUpStringInTable(
    IN  PSTRING_TO_DATA Table,
    IN  PCTSTR          String,
    OUT PUINT_PTR       Data
    );

//
// Diagnostic/debug functions in debug.c
//

#define DebugPrintEx  pSetupDebugPrintEx

#if DBG

#define MYTRACE(x)  DebugPrintEx x /*(...)*/

#else

#define MYTRACE(x)

#endif

//
// Allow assertion checking to be turned on independently
// of DBG, like by specifying C_DEFINES=-DASSERTS_ON=1 in sources file.
//
#ifndef ASSERTS_ON
#if DBG
#define ASSERTS_ON 1
#else
#define ASSERTS_ON 0
#endif
#endif

#ifdef _X86_
BOOL
IsNEC98(
    VOID
    );

#endif

//
// Stubs to allow ANSI build to run on Win9x
//

#ifdef DBGHEAP_CHECK

    #ifdef ANSI_SETUPAPI

        #define ASSERT_HEAP_IS_VALID()

    #else

        #define ASSERT_HEAP_IS_VALID()   RtlValidateHeap(pSetupGetHeap(),0,NULL)

    #endif // ANSI_SETUPAPI

#else

    #define ASSERT_HEAP_IS_VALID()

#endif // DBGHEAP_CHECK


//
// TLS data/macro's
//

//
// Diamond TLS data.
//
typedef struct _DIAMOND_THREAD_DATA {

    //
    // Boolean value indicating whether the current thread
    // is inside diamond. Diamond doesn't really providee
    // a full context environment so we declare it non-reentrant.
    //
    BOOL InDiamond;

    //
    // Diamond context data
    //
    HFDI FdiContext;
    ERF FdiError;

    //
    // Last encountered error
    //
    DWORD LastError;

    //
    // Name of cabinet as passed to DiamondProcessCabinet,
    //
    PCTSTR CabinetFile;

    //
    // Notification callback and context parameter
    //
    PVOID MsgHandler;
    PVOID Context;
    BOOL IsMsgHandlerNativeCharWidth;

    //
    // Full path of the current target file being extracted.
    //
    PTSTR CurrentTargetFile;

    //
    // Flag indicating whether diamond asked us to switch cabinets.
    // If we do switch, then we stop copying when the current file
    // is done. This prevents diamond from happily doing each file
    // in the new cabinet, which would ruin the queue commit routine's
    // ability to allow some files to exist outside the cabinet, etc.
    //
    BOOL SwitchedCabinets;

    //
    // If the source path changes as the result of a prompt for a
    // new cabinet (when a file continues across multiple cabinets),
    // we remember the path the user gave us here.
    //
    TCHAR UserPath[MAX_PATH];

} DIAMOND_THREAD_DATA, *PDIAMOND_THREAD_DATA;

typedef struct _SETUP_TLS {
    struct _SETUP_TLS      *Prev;
    struct _SETUP_TLS      *Next;
    //
    // all TLS data used by SetupAPI
    //
    DIAMOND_THREAD_DATA     Diamond;
    SETUP_LOG_TLS           SetupLog;
    DWORD                   PerThreadDoneComponent;
    DWORD                   PerThreadFailedComponent;

} SETUP_TLS, *PSETUP_TLS;

PSETUP_TLS
SetupGetTlsData(
    );


//
// Registration flags.
//
#define SP_GETSTATUS_FROMDLL                0x00000001  // in proc dll registration
#define SP_GETSTATUS_FROMPROCESS            0x00000002  // executable registration
#define SP_GETSTATUS_FROMSURRAGATE          0x00000004  // surragate process dll registration


#if MEM_DBG

//
// these have to be at the bottom to compile
//

#define GetSystemSourcePath()           GetSystemSourcePath(TRACK_ARG_CALL)
#define GetServicePackSourcePath()      GetServicePackSourcePath(TRACK_ARG_CALL)
#define GetServicePackCachePath()       GetServicePackCachePath(TRACK_ARG_CALL)
#define InheritLogContext(a,b)          InheritLogContext(TRACK_ARG_CALL,a,b)

#endif

BOOL
InitComponents(
    DWORD Components
    );

VOID
ComponentCleanup(
    DWORD Components
    );

//#define COMPONENT_OLE                       0x00000001  // need to use OLE
//#define COMPONENT_FUSION                    0x00000002  // need to use Fusion

//
// RetrieveAllDriversForDevice flags
//
#define RADFD_FLAG_FUNCTION_DRIVER          0x00000001
#define RADFD_FLAG_DEVICE_UPPER_FILTERS     0x00000002
#define RADFD_FLAG_DEVICE_LOWER_FILTERS     0x00000004
#define RADFD_FLAG_CLASS_UPPER_FILTERS      0x00000008
#define RADFD_FLAG_CLASS_LOWER_FILTERS      0x00000010

#define RADFD_FLAG_DEVICE_FILTERS           RADFD_FLAG_DEVICE_UPPER_FILTERS | RADFD_FLAG_DEVICE_LOWER_FILTERS
#define RADFD_FLAG_CLASS_FILTERS            RADFD_FLAG_CLASS_UPPER_FILTERS | RADFD_FLAG_CLASS_LOWER_FILTERS
#define RADFD_FLAG_ALL_FILTERS              RADFD_FLAG_DEVICE_FILTERS | RADFD_FLAG_CLASS_FILTERS

BOOL
RetrieveAllDriversForDevice(
    IN  PDEVINFO_ELEM  DevInfoElem,
    OUT PTSTR          *FilterDrivers,
    IN  DWORD          Flags,
    IN  HMACHINE       hMachine
    );

VOID
pGetVersionText(
   OUT PTSTR VersionText,
   IN DWORDLONG Version
   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\setupapi\stub.h ===
//
// Prototype and function pointer types
//

typedef BOOL (GETFILEATTRIBUTESEXA_PROTOTYPE)(LPCSTR, GET_FILEEX_INFO_LEVELS, LPVOID);
typedef GETFILEATTRIBUTESEXA_PROTOTYPE * GETFILEATTRIBUTESEXA_PROC;

typedef UINT (GETSYSTEMWINDOWSDIRECTORYA_PROTOTYPE)(LPSTR, UINT);
typedef GETSYSTEMWINDOWSDIRECTORYA_PROTOTYPE * GETSYSTEMWINDOWSDIRECTORYA_PROC;

typedef BOOL (VERIFYVERSIONINFOA_PROTOTYPE)(LPOSVERSIONINFOEXA, DWORD, DWORDLONG);
typedef VERIFYVERSIONINFOA_PROTOTYPE * VERIFYVERSIONINFOA_PROC;

typedef ULONGLONG (VERSETCONDITIONMASK_PROTOTYPE)(ULONGLONG, DWORD, BYTE);
typedef VERSETCONDITIONMASK_PROTOTYPE * VERSETCONDITIONMASK_PROC;

typedef HANDLE (WINAPI SFCONNECTTOSERVER_PROTOTYPE)(LPCWSTR ServerName);
typedef VOID (SFCCLOSE_PROTOTYPE)(IN HANDLE RpcHandle);
typedef DWORD (WINAPI SFCFILEEXCEPTION_PROTOTYPE)(HANDLE RpcHandle,PCWSTR FileName,DWORD ExpectedChangeType);
typedef BOOL (WINAPI SFCISFILEPROTECTED_PROTOTYPE)(HANDLE RpcHandle,LPCWSTR ProtFileName);
typedef SFCONNECTTOSERVER_PROTOTYPE * SFCONNECTTOSERVER_PROC;
typedef SFCCLOSE_PROTOTYPE * SFCCLOSE_PROC;
typedef SFCFILEEXCEPTION_PROTOTYPE * SFCFILEEXCEPTION_PROC;
typedef SFCISFILEPROTECTED_PROTOTYPE * SFCISFILEPROTECTED_PROC;

#ifdef ANSI_SETUPAPI

typedef CONFIGRET (WINAPI *CM_GET_CLASS_REGISTRY_PROPERTYA)(
    IN  LPGUID      ClassGUID,
    IN  ULONG       ulProperty,
    OUT PULONG      pulRegDataType,    OPTIONAL
    OUT PVOID       Buffer,            OPTIONAL
    IN  OUT PULONG  pulLength,
    IN  ULONG       ulFlags,
    IN  HMACHINE    hMachine
    );

typedef CONFIGRET (WINAPI *CM_SET_CLASS_REGISTRY_PROPERTYA)(
    IN LPGUID      ClassGUID,
    IN ULONG       ulProperty,
    IN PCVOID      Buffer,       OPTIONAL
    IN ULONG       ulLength,
    IN ULONG       ulFlags,
    IN HMACHINE    hMachine
    );

typedef CONFIGRET (WINAPI *CM_GET_DEVICE_INTERFACE_ALIAS_EXA)(
            IN     LPCSTR   pszDeviceInterface,
            IN     LPGUID   AliasInterfaceGuid,
            OUT    LPSTR    pszAliasDeviceInterface,
            IN OUT PULONG   pulLength,
            IN     ULONG    ulFlags,
            IN     HMACHINE hMachine
            );

typedef CONFIGRET (WINAPI *CM_GET_DEVICE_INTERFACE_LIST_EXA)(
            IN  LPGUID      InterfaceClassGuid,
            IN  DEVINSTID_A pDeviceID,      OPTIONAL
            OUT PCHAR       Buffer,
            IN  ULONG       BufferLen,
            IN  ULONG       ulFlags,
            IN  HMACHINE    hMachine
            );

typedef CONFIGRET (WINAPI *CM_GET_DEVICE_INTERFACE_LIST_SIZE_EXA)(
            IN  PULONG      pulLen,
            IN  LPGUID      InterfaceClassGuid,
            IN  DEVINSTID_A pDeviceID,      OPTIONAL
            IN  ULONG       ulFlags,
            IN  HMACHINE    hMachine
            );

typedef CONFIGRET (WINAPI *CM_GET_LOG_CONF_PRIORITY_EX)(
            IN  LOG_CONF  lcLogConf,
            OUT PPRIORITY pPriority,
            IN  ULONG     ulFlags,
            IN  HMACHINE  hMachine
            );

typedef CONFIGRET (WINAPI *CM_QUERY_AND_REMOVE_SUBTREE_EXA)(
            IN  DEVINST        dnAncestor,
            OUT PPNP_VETO_TYPE pVetoType,
            OUT LPSTR          pszVetoName,
            IN  ULONG          ulNameLength,
            IN  ULONG          ulFlags,
            IN  HMACHINE       hMachine
            );

typedef CONFIGRET (WINAPI *CM_REGISTER_DEVICE_INTERFACE_EXA)(
            IN  DEVINST   dnDevInst,
            IN  LPGUID    InterfaceClassGuid,
            IN  LPCSTR    pszReference,         OPTIONAL
            OUT LPSTR     pszDeviceInterface,
            IN OUT PULONG pulLength,
            IN  ULONG     ulFlags,
            IN  HMACHINE  hMachine
            );

typedef CONFIGRET (WINAPI *CM_SET_DEVNODE_PROBLEM_EX)(
            IN DEVINST   dnDevInst,
            IN ULONG     ulProblem,
            IN  ULONG    ulFlags,
            IN  HMACHINE hMachine
            );

typedef CONFIGRET (WINAPI *CM_UNREGISTER_DEVICE_INTERFACE_EXA)(
            IN LPCSTR   pszDeviceInterface,
            IN ULONG    ulFlags,
            IN HMACHINE hMachine
            );

typedef BOOL (WINAPI *CRYPTCATADMINACQUIRECONTEXT)(
            OUT HCATADMIN *phCatAdmin,
            IN const GUID *pgSubsystem,
            IN DWORD dwFlags
            );

typedef BOOL (WINAPI *CRYPTCATADMINRELEASECONTEXT)(
            IN HCATADMIN hCatAdmin,
            IN DWORD dwFlags
            );

typedef BOOL (WINAPI *CRYPTCATADMINRELEASECATALOGCONTEXT)(
            IN HCATADMIN hCatAdmin,
            IN HCATINFO hCatInfo,
            IN DWORD dwFlags
            );

typedef HCATINFO (WINAPI *CRYPTCATADMINADDCATALOG)(
            IN HCATADMIN hCatAdmin,
            IN WCHAR *pwszCatalogFile,
            IN OPTIONAL WCHAR *pwszSelectBaseName,
            IN DWORD dwFlags
            );

typedef BOOL (WINAPI *CRYPTCATCATALOGINFOFROMCONTEXT)(
            IN HCATINFO hCatInfo,
            IN OUT CATALOG_INFO *psCatInfo,
            IN DWORD dwFlags
            );

typedef BOOL (WINAPI *CRYPTCATADMINCALCHASHFROMFILEHANDLE)(
            IN HANDLE hFile,
            IN OUT DWORD *pcbHash,
            OUT OPTIONAL BYTE *pbHash,
            IN DWORD dwFlags
            );

typedef HCATINFO (WINAPI *CRYPTCATADMINENUMCATALOGFROMHASH)(
            IN HCATADMIN hCatAdmin,
            IN BYTE *pbHash,
            IN DWORD cbHash,
            IN DWORD dwFlags,
            IN OUT HCATINFO *phPrevCatInfo
            );

typedef BOOL (WINAPI *CRYPTCATADMINREMOVECATALOG)(
            IN HCATADMIN hCatAdmin,
            IN WCHAR *pwszCatalogFile,
            IN DWORD dwFlags
            );

typedef BOOL (WINAPI *CRYPTCATADMINRESOLVECATALOGPATH)(
            IN HCATADMIN hCatAdmin,
            IN WCHAR *pwszCatalogFile,
            IN OUT CATALOG_INFO *psCatInfo,
            IN DWORD dwFlags
            );

typedef BOOL (WINAPI *CERTFREECERTIFICATECONTEXT)(
            IN PCCERT_CONTEXT pCertContext
            );

typedef LONG (WINAPI *WINVERIFYTRUST)(
            HWND hwnd,
            GUID *pgActionID,
            LPVOID pWVTData
            );

typedef CONFIGRET (WINAPI *CM_QUERY_RESOURCE_CONFLICT_LIST)(
             OUT PCONFLICT_LIST pclConflictList,
             IN  DEVINST        dnDevInst,
             IN  RESOURCEID     ResourceID,
             IN  PCVOID         ResourceData,
             IN  ULONG          ResourceLen,
             IN  ULONG          ulFlags,
             IN  HMACHINE       hMachine
             );

typedef CONFIGRET (WINAPI *CM_FREE_RESOURCE_CONFLICT_HANDLE)(
             IN CONFLICT_LIST   clConflictList
             );

typedef CONFIGRET (WINAPI *CM_GET_RESOURCE_CONFLICT_COUNT)(
             IN CONFLICT_LIST   clConflictList,
             OUT PULONG         pulCount
             );

typedef CONFIGRET (WINAPI *CM_GET_RESOURCE_CONFLICT_DETAILSA)(
             IN CONFLICT_LIST         clConflictList,
             IN ULONG                 ulIndex,
             IN OUT PCONFLICT_DETAILS_A pConflictDetails
             );

#endif

//
// Pointers declared in stub.c and initialized in InitializeStubFnPtrs
//

extern GETFILEATTRIBUTESEXA_PROC  Dyn_GetFileAttributesExA;
extern GETSYSTEMWINDOWSDIRECTORYA_PROC Dyn_GetSystemWindowsDirectoryA;
extern VERIFYVERSIONINFOA_PROC    Dyn_VerifyVersionInfoA;
extern VERSETCONDITIONMASK_PROC   Dyn_VerSetConditionMask;
extern SFCONNECTTOSERVER_PROC     Dyn_SfcConnectToServer;
extern SFCCLOSE_PROC              Dyn_SfcClose;
extern SFCFILEEXCEPTION_PROC      Dyn_SfcFileException;
extern SFCISFILEPROTECTED_PROC    Dyn_SfcIsFileProtected;

#ifdef ANSI_SETUPAPI

extern CM_QUERY_RESOURCE_CONFLICT_LIST Dyn_CM_Query_Resource_Conflict_List;
extern CM_FREE_RESOURCE_CONFLICT_HANDLE Dyn_CM_Free_Resource_Conflict_Handle;
extern CM_GET_RESOURCE_CONFLICT_COUNT Dyn_CM_Get_Resource_Conflict_Count;
extern CM_GET_RESOURCE_CONFLICT_DETAILSA Dyn_CM_Get_Resource_Conflict_DetailsA;
extern CM_GET_CLASS_REGISTRY_PROPERTYA Dyn_CM_Get_Class_Registry_PropertyA;
extern CM_SET_CLASS_REGISTRY_PROPERTYA Dyn_CM_Set_Class_Registry_PropertyA;
extern CM_GET_DEVICE_INTERFACE_ALIAS_EXA Dyn_CM_Get_Device_Interface_Alias_ExA;
extern CM_GET_DEVICE_INTERFACE_LIST_EXA Dyn_CM_Get_Device_Interface_List_ExA;
extern CM_GET_DEVICE_INTERFACE_LIST_SIZE_EXA Dyn_CM_Get_Device_Interface_List_Size_ExA;
extern CM_GET_LOG_CONF_PRIORITY_EX Dyn_CM_Get_Log_Conf_Priority_Ex;
extern CM_QUERY_AND_REMOVE_SUBTREE_EXA Dyn_CM_Query_And_Remove_SubTree_ExA;
extern CM_REGISTER_DEVICE_INTERFACE_EXA Dyn_CM_Register_Device_Interface_ExA;
extern CM_SET_DEVNODE_PROBLEM_EX Dyn_CM_Set_DevNode_Problem_Ex;
extern CM_UNREGISTER_DEVICE_INTERFACE_EXA Dyn_CM_Unregister_Device_Interface_ExA;

extern CRYPTCATADMINACQUIRECONTEXT Dyn_CryptCATAdminAcquireContext;
extern CRYPTCATADMINRELEASECONTEXT Dyn_CryptCATAdminReleaseContext;
extern CRYPTCATADMINRELEASECATALOGCONTEXT Dyn_CryptCATAdminReleaseCatalogContext;
extern CRYPTCATADMINADDCATALOG Dyn_CryptCATAdminAddCatalog;
extern CRYPTCATCATALOGINFOFROMCONTEXT Dyn_CryptCATCatalogInfoFromContext;
extern CRYPTCATADMINCALCHASHFROMFILEHANDLE Dyn_CryptCATAdminCalcHashFromFileHandle;
extern CRYPTCATADMINENUMCATALOGFROMHASH Dyn_CryptCATAdminEnumCatalogFromHash;
extern CRYPTCATADMINREMOVECATALOG Dyn_CryptCATAdminRemoveCatalog;
extern CRYPTCATADMINRESOLVECATALOGPATH Dyn_CryptCATAdminResolveCatalogPath;

extern CERTFREECERTIFICATECONTEXT Dyn_CertFreeCertificateContext;

extern WINVERIFYTRUST Dyn_WinVerifyTrust;

#endif

//
// "Not Implemented" Stubs
//

BOOL
WINAPI
Stub_VerifyVersionInfoA(
    IN LPOSVERSIONINFOEXA lpVersionInformation,
    IN DWORD dwTypeMask,
    IN DWORDLONG dwlConditionMask
    );

BOOL
WINAPI
Stub_VerifyVersionInfoW(
    IN LPOSVERSIONINFOEXW lpVersionInformation,
    IN DWORD dwTypeMask,
    IN DWORDLONG dwlConditionMask
    );

ULONGLONG
NTAPI
Stub_VerSetConditionMask(
    IN ULONGLONG ConditionMask,
    IN DWORD TypeMask,
    IN BYTE Condition
    );

HANDLE
WINAPI
Stub_SfcConnectToServer(
    IN LPCWSTR ServerName
    );

VOID
Stub_SfcClose(
    IN HANDLE RpcHandle
    );

DWORD
WINAPI
Stub_SfcFileException(
    IN HANDLE RpcHandle,
    IN PCWSTR FileName,
    IN DWORD ExpectedChangeType
    );

BOOL
WINAPI
Stub_SfcIsFileProtected(
    IN HANDLE RpcHandle,
    IN LPCWSTR ProtFileName
    );

HANDLE
WINAPI
FirstLoad_SfcConnectToServer(
    IN LPCWSTR ServerName
    );

VOID
FirstLoad_SfcClose(
    IN HANDLE RpcHandle
    );

DWORD
WINAPI
FirstLoad_SfcFileException(
    IN HANDLE RpcHandle,
    IN PCWSTR FileName,
    IN DWORD ExpectedChangeType
    );

BOOL
WINAPI
FirstLoad_SfcIsFileProtected(
    IN HANDLE RpcHandle,
    IN LPCWSTR ProtFileName
    );

#ifdef ANSI_SETUPAPI

CONFIGRET
WINAPI
Stub_CM_Get_Class_Registry_PropertyA(
    IN  LPGUID      ClassGUID,
    IN  ULONG       ulProperty,
    OUT PULONG      pulRegDataType,    OPTIONAL
    OUT PVOID       Buffer,            OPTIONAL
    IN  OUT PULONG  pulLength,
    IN  ULONG       ulFlags,
    IN  HMACHINE    hMachine
    );

CONFIGRET
WINAPI
Stub_CM_Set_Class_Registry_PropertyA(
    IN LPGUID      ClassGUID,
    IN ULONG       ulProperty,
    IN PCVOID      Buffer,       OPTIONAL
    IN ULONG       ulLength,
    IN ULONG       ulFlags,
    IN HMACHINE    hMachine
    );

CONFIGRET
WINAPI
Stub_CM_Get_Device_Interface_Alias_ExA (
    IN     LPCSTR   pszDeviceInterface,
    IN     LPGUID   AliasInterfaceGuid,
    OUT    LPSTR    pszAliasDeviceInterface,
    IN OUT PULONG   pulLength,
    IN     ULONG    ulFlags,
    IN     HMACHINE hMachine
    );

CONFIGRET
WINAPI
Stub_CM_Get_Device_Interface_List_ExA(
    IN  LPGUID      InterfaceClassGuid,
    IN  DEVINSTID_A pDeviceID,      OPTIONAL
    OUT PCHAR       Buffer,
    IN  ULONG       BufferLen,
    IN  ULONG       ulFlags,
    IN  HMACHINE    hMachine
    );

CONFIGRET
WINAPI
Stub_CM_Get_Device_Interface_List_Size_ExA(
    IN  PULONG      pulLen,
    IN  LPGUID      InterfaceClassGuid,
    IN  DEVINSTID_A pDeviceID,      OPTIONAL
    IN  ULONG       ulFlags,
    IN  HMACHINE    hMachine
    );

CONFIGRET
WINAPI
Stub_CM_Get_Log_Conf_Priority_Ex(
    IN  LOG_CONF  lcLogConf,
    OUT PPRIORITY pPriority,
    IN  ULONG     ulFlags,
    IN  HMACHINE  hMachine
    );

CONFIGRET
WINAPI
Stub_CM_Query_And_Remove_SubTree_ExA(
    IN  DEVINST        dnAncestor,
    OUT PPNP_VETO_TYPE pVetoType,
    OUT LPSTR          pszVetoName,
    IN  ULONG          ulNameLength,
    IN  ULONG          ulFlags,
    IN  HMACHINE       hMachine
    );

CONFIGRET
WINAPI
Stub_CM_Register_Device_Interface_ExA(
    IN  DEVINST   dnDevInst,
    IN  LPGUID    InterfaceClassGuid,
    IN  LPCSTR    pszReference,         OPTIONAL
    OUT LPSTR     pszDeviceInterface,
    IN OUT PULONG pulLength,
    IN  ULONG     ulFlags,
    IN  HMACHINE  hMachine
    );

CONFIGRET
WINAPI
Stub_CM_Set_DevNode_Problem_Ex(
    IN DEVINST   dnDevInst,
    IN ULONG     ulProblem,
    IN  ULONG    ulFlags,
    IN  HMACHINE hMachine
    );

CONFIGRET
WINAPI
Stub_CM_Unregister_Device_Interface_ExA(
    IN LPCSTR   pszDeviceInterface,
    IN ULONG    ulFlags,
    IN HMACHINE hMachine
    );

CONFIGRET
WINAPI
Stub_CM_Query_Resource_Conflict_List(
             OUT PCONFLICT_LIST pclConflictList,
             IN  DEVINST        dnDevInst,
             IN  RESOURCEID     ResourceID,
             IN  PCVOID         ResourceData,
             IN  ULONG          ResourceLen,
             IN  ULONG          ulFlags,
             IN  HMACHINE       hMachine
             );

CONFIGRET
WINAPI
Stub_CM_Free_Resource_Conflict_Handle(
             IN CONFLICT_LIST   clConflictList
             );

CONFIGRET
WINAPI
Stub_CM_Get_Resource_Conflict_Count(
             IN CONFLICT_LIST   clConflictList,
             OUT PULONG         pulCount
             );

CONFIGRET
WINAPI
Stub_CM_Get_Resource_Conflict_DetailsA(
             IN CONFLICT_LIST         clConflictList,
             IN ULONG                 ulIndex,
             IN OUT PCONFLICT_DETAILS_A pConflictDetails
             );


BOOL
WINAPI
Stub_CryptCATAdminAcquireContext (
    OUT HCATADMIN *phCatAdmin,
    IN const GUID *pgSubsystem,
    IN DWORD dwFlags
    );

BOOL
WINAPI
Stub_CryptCATAdminReleaseContext (
    IN HCATADMIN hCatAdmin,
    IN DWORD dwFlags
    );

BOOL
WINAPI
Stub_CryptCATAdminReleaseCatalogContext (
    IN HCATADMIN hCatAdmin,
    IN HCATINFO hCatInfo,
    IN DWORD dwFlags
    );

HCATINFO
WINAPI
Stub_CryptCATAdminAddCatalog (
    IN HCATADMIN hCatAdmin,
    IN WCHAR *pwszCatalogFile,
    IN OPTIONAL WCHAR *pwszSelectBaseName,
    IN DWORD dwFlags
    );

BOOL
WINAPI
Stub_CryptCATCatalogInfoFromContext (
    IN HCATINFO hCatInfo,
    IN OUT CATALOG_INFO *psCatInfo,
    IN DWORD dwFlags
    );

BOOL
WINAPI
Stub_CryptCATAdminCalcHashFromFileHandle (
    IN HANDLE hFile,
    IN OUT DWORD *pcbHash,
    OUT OPTIONAL BYTE *pbHash,
    IN DWORD dwFlags
    );

HCATINFO
WINAPI
Stub_CryptCATAdminEnumCatalogFromHash(
    IN HCATADMIN hCatAdmin,
    IN BYTE *pbHash,
    IN DWORD cbHash,
    IN DWORD dwFlags,
    IN OUT HCATINFO *phPrevCatInfo
    );

BOOL
WINAPI
Stub_CryptCATAdminRemoveCatalog(
    IN HCATADMIN hCatAdmin,
    IN WCHAR *pwszCatalogFile,
    IN DWORD dwFlags
    );

BOOL
WINAPI
Stub_CryptCATAdminResolveCatalogPath(
    IN HCATADMIN hCatAdmin,
    IN WCHAR *pwszCatalogFile,
    IN OUT CATALOG_INFO *psCatInfo,
    IN DWORD dwFlags
    );

BOOL
WINAPI
Stub_CertFreeCertificateContext(
    IN PCCERT_CONTEXT pCertContext
    );

LONG
WINAPI
Stub_WinVerifyTrust(
    HWND hwnd,
    GUID *pgActionID,
    LPVOID pWVTData
    );


int
Stub_wnsprintf(
    LPTSTR lpOut,
    int cchLimitIn,
    LPCTSTR pszFmt,
    ...
    );


#endif


//
// Macro repairs
//

#define SfcConnectToServer Dyn_SfcConnectToServer
#define SfcClose           Dyn_SfcClose
#define SfcFileException   Dyn_SfcFileException
#define SfcIsFileProtected Dyn_SfcIsFileProtected

#ifdef ANSI_SETUPAPI

#undef VerifyVersionInfo
#undef VerSetConditionMask
#undef GetFileAttributesEx
#undef GetSystemWindowsDirectory
#undef CM_Get_Class_Registry_Property
#undef CM_Set_Class_Registry_Property
#undef CM_Get_Device_Interface_Alias_Ex
#undef CM_Get_Device_Interface_List_Ex
#undef CM_Get_Device_Interface_List_Size_Ex
#undef CM_Query_And_Remove_SubTree_Ex
#undef CM_Register_Device_Interface_Ex
#undef CM_Unregister_Device_Interface_Ex
#undef CM_Get_Resource_Conflict_Details

#define VerifyVersionInfo  Dyn_VerifyVersionInfoA
#define VerSetConditionMask Dyn_VerSetConditionMask
#define CM_Get_Class_Registry_Property Dyn_CM_Get_Class_Registry_PropertyA
#define CM_Set_Class_Registry_Property Dyn_CM_Set_Class_Registry_PropertyA
#define CM_Get_Device_Interface_Alias_Ex Dyn_CM_Get_Device_Interface_Alias_ExA
#define CM_Get_Device_Interface_List_Ex Dyn_CM_Get_Device_Interface_List_ExA
#define CM_Get_Device_Interface_List_Size_Ex Dyn_CM_Get_Device_Interface_List_Size_ExA
#define CM_Get_Log_Conf_Priority_Ex Dyn_CM_Get_Log_Conf_Priority_Ex
#define CM_Query_And_Remove_SubTree_Ex Dyn_CM_Query_And_Remove_SubTree_ExA
#define CM_Register_Device_Interface_Ex Dyn_CM_Register_Device_Interface_ExA
#define CM_Set_DevNode_Problem_Ex Dyn_CM_Set_DevNode_Problem_Ex
#define CM_Unregister_Device_Interface_Ex Dyn_CM_Unregister_Device_Interface_ExA
#define CM_Query_Resource_Conflict_List Dyn_CM_Query_Resource_Conflict_List
#define CM_Free_Resource_Conflict_Handle Dyn_CM_Free_Resource_Conflict_Handle
#define CM_Get_Resource_Conflict_Count Dyn_CM_Get_Resource_Conflict_Count
#define CM_Get_Resource_Conflict_Details Dyn_CM_Get_Resource_Conflict_DetailsA

#define CryptCATAdminAcquireContext Dyn_CryptCATAdminAcquireContext
#define CryptCATAdminReleaseContext Dyn_CryptCATAdminReleaseContext
#define CryptCATAdminReleaseCatalogContext Dyn_CryptCATAdminReleaseCatalogContext
#define CryptCATAdminAddCatalog Dyn_CryptCATAdminAddCatalog
#define CryptCATCatalogInfoFromContext Dyn_CryptCATCatalogInfoFromContext
#define CryptCATAdminCalcHashFromFileHandle Dyn_CryptCATAdminCalcHashFromFileHandle
#define CryptCATAdminEnumCatalogFromHash Dyn_CryptCATAdminEnumCatalogFromHash
#define CryptCATAdminRemoveCatalog Dyn_CryptCATAdminRemoveCatalog
#define CryptCATAdminResolveCatalogPath Dyn_CryptCATAdminResolveCatalogPath
#define CertFreeCertificateContext Dyn_CertFreeCertificateContext

#define WinVerifyTrust Dyn_WinVerifyTrust

#define GetFileAttributesEx Dyn_GetFileAttributesExA
#define GetSystemWindowsDirectory Dyn_GetSystemWindowsDirectoryA

#endif

//
// ANSI specific emulation of API's (we don't want to dynamic check)
//

#ifdef ANSI_SETUPAPI
#undef wnsprintf
#define wnsprintf Stub_wnsprintf
#endif

//
// Functions called from DllMain
//

VOID
InitializeStubFnPtrs (
    VOID
    );

VOID
CleanUpStubFns (
    VOID
    );

FARPROC
ObtainFnPtr (
    PCSTR DllName,
    PCSTR FnName,
    FARPROC Default
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\setupapi\stub.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    stub.c

Abstract:

    Dynamic loading of routines that are implemented differently on Win9x and NT.

Author:

    Jim Schmidt (jimschm) 29-Apr-1997

Revision History:

    jimschm 26-Oct-1998     Added cfgmgr32, crypt32, mscat and wintrust APIs
    lonnym  01-Apr-2000     Added VerifyVersionInfo and VerSetConditionMask

--*/

#include "precomp.h"


//
// Stub & emulation prototypes -- implemented below
//

GETFILEATTRIBUTESEXA_PROTOTYPE EmulatedGetFileAttributesExA;

//
// Function ptr declarations.  When adding, prefix the function ptr with
// Dyn_ to indicate a dynamically loaded version of an API.
//

GETFILEATTRIBUTESEXA_PROC Dyn_GetFileAttributesExA;
GETSYSTEMWINDOWSDIRECTORYA_PROC Dyn_GetSystemWindowsDirectoryA;
VERIFYVERSIONINFOA_PROC Dyn_VerifyVersionInfoA;
VERSETCONDITIONMASK_PROC Dyn_VerSetConditionMask;
//
// these functions are a little more involved, since we don't want to
// pull in SFC until we have to (delay-load)
//
SFCONNECTTOSERVER_PROC     Dyn_SfcConnectToServer = FirstLoad_SfcConnectToServer;
SFCCLOSE_PROC              Dyn_SfcClose           = FirstLoad_SfcClose;
SFCFILEEXCEPTION_PROC      Dyn_SfcFileException   = FirstLoad_SfcFileException;
SFCISFILEPROTECTED_PROC    Dyn_SfcIsFileProtected = FirstLoad_SfcIsFileProtected;

#ifdef ANSI_SETUPAPI

CM_QUERY_RESOURCE_CONFLICT_LIST Dyn_CM_Query_Resource_Conflict_List;
CM_FREE_RESOURCE_CONFLICT_HANDLE Dyn_CM_Free_Resource_Conflict_Handle;
CM_GET_RESOURCE_CONFLICT_COUNT Dyn_CM_Get_Resource_Conflict_Count;
CM_GET_RESOURCE_CONFLICT_DETAILSA Dyn_CM_Get_Resource_Conflict_DetailsA;
CM_GET_CLASS_REGISTRY_PROPERTYA Dyn_CM_Get_Class_Registry_PropertyA;
CM_SET_CLASS_REGISTRY_PROPERTYA Dyn_CM_Set_Class_Registry_PropertyA;
CM_GET_DEVICE_INTERFACE_ALIAS_EXA Dyn_CM_Get_Device_Interface_Alias_ExA;
CM_GET_DEVICE_INTERFACE_LIST_EXA Dyn_CM_Get_Device_Interface_List_ExA;
CM_GET_DEVICE_INTERFACE_LIST_SIZE_EXA Dyn_CM_Get_Device_Interface_List_Size_ExA;
CM_GET_LOG_CONF_PRIORITY_EX Dyn_CM_Get_Log_Conf_Priority_Ex;
CM_QUERY_AND_REMOVE_SUBTREE_EXA Dyn_CM_Query_And_Remove_SubTree_ExA;
CM_REGISTER_DEVICE_INTERFACE_EXA Dyn_CM_Register_Device_Interface_ExA;
CM_SET_DEVNODE_PROBLEM_EX Dyn_CM_Set_DevNode_Problem_Ex;
CM_UNREGISTER_DEVICE_INTERFACE_EXA Dyn_CM_Unregister_Device_Interface_ExA;

CRYPTCATADMINACQUIRECONTEXT Dyn_CryptCATAdminAcquireContext;
CRYPTCATADMINRELEASECONTEXT Dyn_CryptCATAdminReleaseContext;
CRYPTCATADMINRELEASECATALOGCONTEXT Dyn_CryptCATAdminReleaseCatalogContext;
CRYPTCATADMINADDCATALOG Dyn_CryptCATAdminAddCatalog;
CRYPTCATCATALOGINFOFROMCONTEXT Dyn_CryptCATCatalogInfoFromContext;
CRYPTCATADMINCALCHASHFROMFILEHANDLE Dyn_CryptCATAdminCalcHashFromFileHandle;
CRYPTCATADMINENUMCATALOGFROMHASH Dyn_CryptCATAdminEnumCatalogFromHash;
CRYPTCATADMINREMOVECATALOG Dyn_CryptCATAdminRemoveCatalog;
CRYPTCATADMINRESOLVECATALOGPATH Dyn_CryptCATAdminResolveCatalogPath;

CERTFREECERTIFICATECONTEXT CertFreeCertificateContext;

WINVERIFYTRUST WinVerifyTrust;

#endif


VOID
InitializeStubFnPtrs (
    VOID
    )

/*++

Routine Description:

    This routine tries to load the function ptr of OS-provided APIs, and if
    they aren't available, stub versions are used instead.  We do this
    for APIs that are unimplemented on a platform that setupapi will
    run on.

Arguments:

    none

Return Value:

    none

--*/

{
    //
    // no dynamic loading should be done here for WinXP etc
    // it's only done for ANSI version of setupapi.dll
    // who's sole purpose is for setup of WinXP
    // from Win9x (ie, used in context of winnt32.exe)
    //

#ifdef ANSI_SETUPAPI

    //
    // Kernel32 API's - try loading from the OS dll, and if the API
    // doesn't exist, use an emulation version
    //

    (FARPROC) Dyn_GetFileAttributesExA = ObtainFnPtr (
                                                "kernel32.dll",
                                                "GetFileAttributesExA",
                                                (FARPROC) EmulatedGetFileAttributesExA
                                                );

    (FARPROC) Dyn_GetSystemWindowsDirectoryA = ObtainFnPtr (
                                                "kernel32.dll",
                                                "GetSystemWindowsDirectoryA",
                                                (FARPROC) GetWindowsDirectoryA
                                                );

    //
    // use Win9x config manager APIs if they exist, otherwise return ERROR_CALL_NOT_IMPLEMENTED
    //
    (FARPROC) Dyn_CM_Get_Class_Registry_PropertyA = ObtainFnPtr (
                                                        "cfgmgr32.dll",
                                                        "CM_Get_Class_Registry_PropertyA",
                                                        (FARPROC) Stub_CM_Get_Class_Registry_PropertyA
                                                        );

    (FARPROC) Dyn_CM_Set_Class_Registry_PropertyA = ObtainFnPtr (
                                                        "cfgmgr32.dll",
                                                        "CM_Set_Class_Registry_PropertyA",
                                                        (FARPROC) Stub_CM_Set_Class_Registry_PropertyA
                                                        );

    (FARPROC) Dyn_CM_Get_Device_Interface_Alias_ExA = ObtainFnPtr (
                                                        "cfgmgr32.dll",
                                                        "CM_Get_Device_Interface_Alias_ExA",
                                                        (FARPROC) Stub_CM_Get_Device_Interface_Alias_ExA
                                                        );

    (FARPROC) Dyn_CM_Get_Device_Interface_List_ExA = ObtainFnPtr (
                                                        "cfgmgr32.dll",
                                                        "CM_Get_Device_Interface_List_ExA",
                                                        (FARPROC) Stub_CM_Get_Device_Interface_List_ExA
                                                        );

    (FARPROC) Dyn_CM_Get_Device_Interface_List_Size_ExA = ObtainFnPtr (
                                                        "cfgmgr32.dll",
                                                        "CM_Get_Device_Interface_List_Size_ExA",
                                                        (FARPROC) Stub_CM_Get_Device_Interface_List_Size_ExA
                                                        );

    (FARPROC) Dyn_CM_Get_Log_Conf_Priority_Ex = ObtainFnPtr (
                                                        "cfgmgr32.dll",
                                                        "CM_Get_Log_Conf_Priority_Ex",
                                                        (FARPROC) Stub_CM_Get_Log_Conf_Priority_Ex
                                                        );

    (FARPROC) Dyn_CM_Query_And_Remove_SubTree_ExA = ObtainFnPtr (
                                                        "cfgmgr32.dll",
                                                        "CM_Query_And_Remove_SubTree_ExA",
                                                        (FARPROC) Stub_CM_Query_And_Remove_SubTree_ExA
                                                        );

    (FARPROC) Dyn_CM_Register_Device_Interface_ExA = ObtainFnPtr (
                                                        "cfgmgr32.dll",
                                                        "CM_Register_Device_Interface_ExA",
                                                        (FARPROC) Stub_CM_Register_Device_Interface_ExA
                                                        );

    (FARPROC) Dyn_CM_Set_DevNode_Problem_Ex = ObtainFnPtr (
                                                        "cfgmgr32.dll",
                                                        "CM_Set_DevNode_Problem_Ex",
                                                        (FARPROC) Stub_CM_Set_DevNode_Problem_Ex
                                                        );

    (FARPROC) Dyn_CM_Unregister_Device_Interface_ExA = ObtainFnPtr (
                                                        "cfgmgr32.dll",
                                                        "CM_Unregister_Device_Interface_ExA",
                                                        (FARPROC) Stub_CM_Unregister_Device_Interface_ExA
                                                        );

    (FARPROC)Dyn_CM_Query_Resource_Conflict_List = ObtainFnPtr (
                                                        "cfgmgr32.dll",
                                                        "CM_Query_Resource_Conflict_List",
                                                        (FARPROC) Stub_CM_Query_Resource_Conflict_List
                                                        );

    (FARPROC)Dyn_CM_Free_Resource_Conflict_Handle = ObtainFnPtr (
                                                        "cfgmgr32.dll",
                                                        "CM_Free_Resource_Conflict_Handle",
                                                        (FARPROC) Stub_CM_Free_Resource_Conflict_Handle
                                                        );

    (FARPROC)Dyn_CM_Get_Resource_Conflict_Count = ObtainFnPtr (
                                                        "cfgmgr32.dll",
                                                        "CM_Get_Resource_Conflict_Count",
                                                        (FARPROC) Stub_CM_Get_Resource_Conflict_Count
                                                        );

    (FARPROC)Dyn_CM_Get_Resource_Conflict_DetailsA = ObtainFnPtr (
                                                        "cfgmgr32.dll",
                                                        "CM_Get_Resource_Conflict_DetailsA",
                                                        (FARPROC) Stub_CM_Get_Resource_Conflict_DetailsA
                                                        );

    //
    // use Win9x crypto APIs if they exist, otherwise fail with ERROR_CALL_NOT_IMPLEMENTED
    //

    (FARPROC) Dyn_CryptCATAdminAcquireContext = ObtainFnPtr (
                                                        "wintrust.dll",
                                                        "CryptCATAdminAcquireContext",
                                                        (FARPROC) Stub_CryptCATAdminAcquireContext
                                                        );

    (FARPROC) Dyn_CryptCATAdminReleaseContext = ObtainFnPtr (
                                                        "wintrust.dll",
                                                        "CryptCATAdminReleaseContext",
                                                        (FARPROC) Stub_CryptCATAdminReleaseContext
                                                        );

    (FARPROC) Dyn_CryptCATAdminReleaseCatalogContext = ObtainFnPtr (
                                                        "wintrust.dll",
                                                        "CryptCATAdminReleaseCatalogContext",
                                                        (FARPROC) Stub_CryptCATAdminReleaseCatalogContext
                                                        );

    (FARPROC) Dyn_CryptCATAdminAddCatalog = ObtainFnPtr (
                                                        "wintrust.dll",
                                                        "CryptCATAdminAddCatalog",
                                                        (FARPROC) Stub_CryptCATAdminAddCatalog
                                                        );

    (FARPROC) Dyn_CryptCATCatalogInfoFromContext = ObtainFnPtr (
                                                        "wintrust.dll",
                                                        "CryptCATCatalogInfoFromContext",
                                                        (FARPROC) Stub_CryptCATCatalogInfoFromContext
                                                        );

    (FARPROC) Dyn_CryptCATAdminCalcHashFromFileHandle = ObtainFnPtr (
                                                        "wintrust.dll",
                                                        "CryptCATAdminCalcHashFromFileHandle",
                                                        (FARPROC) Stub_CryptCATAdminCalcHashFromFileHandle
                                                        );

    (FARPROC) Dyn_CryptCATAdminEnumCatalogFromHash = ObtainFnPtr (
                                                        "wintrust.dll",
                                                        "CryptCATAdminEnumCatalogFromHash",
                                                        (FARPROC) Stub_CryptCATAdminEnumCatalogFromHash
                                                        );

    (FARPROC) Dyn_CryptCATAdminRemoveCatalog = ObtainFnPtr (
                                                        "wintrust.dll",
                                                        "CryptCATAdminRemoveCatalog",
                                                        (FARPROC) Stub_CryptCATAdminRemoveCatalog
                                                        );

    (FARPROC) Dyn_CryptCATAdminResolveCatalogPath = ObtainFnPtr (
                                                        "wintrust.dll",
                                                        "CryptCATAdminResolveCatalogPath",
                                                        (FARPROC) Stub_CryptCATAdminResolveCatalogPath
                                                        );

    (FARPROC) Dyn_CertFreeCertificateContext = ObtainFnPtr (
                                                        "crypt32.dll",
                                                        "CertFreeCertificateContext",
                                                        (FARPROC) Stub_CertFreeCertificateContext
                                                        );

    //
    // use Win9x WinVerifyTrust if it exists, otherwise return ERROR_SUCCESS
    //

    (FARPROC) Dyn_WinVerifyTrust = ObtainFnPtr (
                                        "wintrust.dll",
                                        "WinVerifyTrust",
                                        (FARPROC) Stub_WinVerifyTrust
                                        );


    //
    // Use VerifyVersionInfo and VerSetConditionMask APIs,
    // if available, otherwise fail with ERROR_CALL_NOT_IMPLEMENTED.
    //
    (FARPROC) Dyn_VerifyVersionInfoA = ObtainFnPtr(
                                           "kernel32.dll",
                                           "VerifyVersionInfoA",
                                           (FARPROC) Stub_VerifyVersionInfoA
                                          );

    (FARPROC) Dyn_VerSetConditionMask = ObtainFnPtr(
                                           "ntdll.dll",
                                           "VerSetConditionMask",
                                           (FARPROC) Stub_VerSetConditionMask
                                          );

    //
    // ***Add other dynamic loading here***
    //
#endif

}


BOOL
EmulatedGetFileAttributesExA (
    IN      PCSTR FileName,
    IN      GET_FILEEX_INFO_LEVELS InfoLevelId,
    OUT     LPVOID FileInformation
    )

/*++

Routine Description:

    Implements an emulation of the NT-specific function GetFileAttributesEx.
    Basic exception handling is implemented, but parameters are not otherwise
    validated.

Arguments:

    FileName - Specifies file to get attributes for

    InfoLevelId - Must be GetFileExInfoStandard

    FileInformation - Must be a valid pointer to WIN32_FILE_ATTRIBUTE_DATA struct

Return Value:

    TRUE for success, FALSE for failure.  GetLastError provided error code.

--*/


{
    //
    // GetFileAttributesEx does not exist on Win95, and ANSI version of setupapi.dll
    // is required for Win9x to NT 5 upgrade
    //

    HANDLE FileEnum;
    WIN32_FIND_DATAA fd;
    PCSTR p,pChar;
    TCHAR  CurChar;
    WIN32_FILE_ATTRIBUTE_DATA *FileAttribData = (WIN32_FILE_ATTRIBUTE_DATA *) FileInformation;

    __try {
        //
        // We only support GetFileExInfoStandard
        //

        if (InfoLevelId != GetFileExInfoStandard) {
            SetLastError (ERROR_INVALID_PARAMETER);
            return FALSE;
        }

        //
        // Locate file title
        // note that this is an ANSI implementation of pSetupGetFileTitle
        //

        p = pChar = FileName;
        while(CurChar = *pChar) {
            pChar = CharNextA(pChar);
            if((CurChar == '\\') || (CurChar == '/') || (CurChar == ':')) {
                p = pChar;
            }
        }

        ZeroMemory (FileAttribData, sizeof (WIN32_FILE_ATTRIBUTE_DATA));

        FileEnum = FindFirstFileA (FileName, &fd);

        //
        // Prohibit caller-supplied pattern
        //

        if (FileEnum!=INVALID_HANDLE_VALUE && lstrcmpiA (p, fd.cFileName)) {
            FindClose (FileEnum);
            FileEnum = INVALID_HANDLE_VALUE;
            SetLastError (ERROR_INVALID_PARAMETER);
        }

        //
        // If exact match found, fill in the attributes
        //

        if (FileEnum) {
            FileAttribData->dwFileAttributes = fd.dwFileAttributes;
            FileAttribData->nFileSizeHigh = fd.nFileSizeHigh;
            FileAttribData->nFileSizeLow  = fd.nFileSizeLow;

            CopyMemory (&FileAttribData->ftCreationTime, &fd.ftCreationTime, sizeof (FILETIME));
            CopyMemory (&FileAttribData->ftLastAccessTime, &fd.ftLastAccessTime, sizeof (FILETIME));
            CopyMemory (&FileAttribData->ftLastWriteTime, &fd.ftLastWriteTime, sizeof (FILETIME));

            FindClose (FileEnum);
        }

        return FileEnum != INVALID_HANDLE_VALUE;
    }

    __except (TRUE) {
        //
        // If bogus FileInformation pointer is passed, an exception is thrown.
        //

        SetLastError (ERROR_INVALID_PARAMETER);
        return FALSE;
    }
}


//
// DLL array structures
//

#define MAX_DLL_ARRAY   16

typedef struct {
    PCSTR DllName;
    HINSTANCE DllInst;
} DLLTABLE, *PDLLTABLE;

static INT g_ArraySize = 0;
static DLLTABLE g_DllArray[MAX_DLL_ARRAY];


//
// Attempt to get library out of System32 directory first
//

HMODULE DelayLoadLibrary(
    IN LPCSTR LibName
    )
/*++

    internal

Routine Description:

    Given an ANSI library name, prepend system32 directory and load it
    (ie, enforce our own search path)
    Don't assume anything is initialized

Arguments:

    LibName - name passed to us by pDelayLoadHook

Result:

    HMODULE from LoadLibrary, or NULL for default processing

--*/
{
    CHAR path[MAX_PATH];
    UINT swdLen;
    UINT libLen;
    HMODULE result;

    libLen = strlen(LibName);
    if(strrchr(LibName,'\\') || strrchr(LibName,'/')) {
        MYASSERT(FALSE);
        return NULL;
    }
    swdLen = GetSystemDirectoryA(path,MAX_PATH);
    if((swdLen == 0) || ((swdLen+libLen+1)>=MAX_PATH)) {
        return NULL;
    }
    if(*CharPrevA(path,path+swdLen)!=TEXT('\\')) {
        path[swdLen++] = TEXT('\\');
    }
    strcpy(path+swdLen,LibName);
    result = LoadLibraryA(path);
    if(result) {
        MYTRACE((DPFLTR_TRACE_LEVEL, TEXT("SetupAPI: delay-loaded %hs.\n"), path));
    } else {
        MYTRACE((DPFLTR_ERROR_LEVEL, TEXT("SetupAPI: Could not delay-load %hs.\n"), path));
    }
    return result;
}


FARPROC
ObtainFnPtr (
    IN      PCSTR DllName,
    IN      PCSTR ProcName,
    IN      FARPROC Default
    )

/*++

Routine Description:

    This routine manages an array of DLL instance handles and returns the
    proc address of the caller-specified routine.  The DLL is loaded
    and remains loaded until the DLL terminates.  This array is not
    synchronized.

Arguments:

    DllName - The ANSI DLL name to load

    ProcName - The ANSI procedure name to locate

    Default - The default procedure, if the export was not found

Return Value:

    The address of the requested function, or NULL if the DLL could not
    be loaded, or the function is not implemented in the loaded DLL.

--*/

{
    INT i;
    PSTR DupBuf;
    FARPROC Address = NULL;

    //
    // Search for loaded DLL
    //

    for (i = 0 ; i < g_ArraySize ; i++) {
        if (!lstrcmpiA (DllName, g_DllArray[i].DllName)) {
            break;
        }
    }

    do {
        //
        // If necessary, load the DLL
        //

        if (i == g_ArraySize) {
            if (g_ArraySize == MAX_DLL_ARRAY) {
                // Constant limit needs to be raised
                MYASSERT (FALSE);
                break;
            }

            g_DllArray[i].DllInst = DelayLoadLibrary (DllName);
            if (!g_DllArray[i].DllInst) {
                break;
            }

            DupBuf = (PSTR) MyMalloc (lstrlenA (DllName) + 1);
            if (!DupBuf) {
                break;
            }
            lstrcpyA (DupBuf, DllName);
            g_DllArray[i].DllName = DupBuf;

            g_ArraySize++;
        }

        //
        // Now that DLL is loaded, return the proc address if it exists
        //

        Address = GetProcAddress (g_DllArray[i].DllInst, ProcName);

    } while (FALSE);

    if (!Address) {
        return Default;
    }

    return Address;
}


VOID
pCleanUpDllArray (
    VOID
    )

/*++

Routine Description:

    Cleans up the DLL array resources.

Arguments:

    none

Return Value:

    none

--*/

{
    INT i;

    for (i = 0 ; i < g_ArraySize ; i++) {
        FreeLibrary (g_DllArray[i].DllInst);
        MyFree (g_DllArray[i].DllName);
    }

    g_ArraySize = 0;
}


VOID
CleanUpStubFns (
    VOID
    )

/*++

Routine Description:

    Cleans up all resources used by emulation routines and function pointer list.

Arguments:

    none

Return Value:

    none

--*/

{
    pCleanUpDllArray();
}


BOOL
WINAPI
Stub_VerifyVersionInfoA(
    IN LPOSVERSIONINFOEXA lpVersionInformation,
    IN DWORD dwTypeMask,
    IN DWORDLONG dwlConditionMask
    )
{
    UNREFERENCED_PARAMETER(lpVersionInformation);
    UNREFERENCED_PARAMETER(dwTypeMask);
    UNREFERENCED_PARAMETER(dwlConditionMask);

    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}

ULONGLONG
NTAPI
Stub_VerSetConditionMask(
    IN ULONGLONG ConditionMask,
    IN DWORD TypeMask,
    IN BYTE Condition
    )
{
    UNREFERENCED_PARAMETER(TypeMask);
    UNREFERENCED_PARAMETER(Condition);

    //
    // Simply return ConditionMask unaltered.  (If this API doesn't exist, we
    // don't expect VerifyVersionInfo to exist either, so that should fail.)
    //
    return ConditionMask;
}

HANDLE
WINAPI
Stub_SfcConnectToServer(
    IN LPCWSTR ServerName
    )
{
    SetLastError (ERROR_CALL_NOT_IMPLEMENTED);
    return NULL;
}

VOID
Stub_SfcClose(
    IN HANDLE RpcHandle
    )
{
    return;
}

DWORD
WINAPI
Stub_SfcFileException(
    IN HANDLE RpcHandle,
    IN PCWSTR FileName,
    IN DWORD ExpectedChangeType
    )
{
    return ERROR_CALL_NOT_IMPLEMENTED;
}

BOOL
WINAPI
Stub_SfcIsFileProtected(
    IN HANDLE RpcHandle,
    IN LPCWSTR ProtFileName
    )
{
    SetLastError (ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}


HANDLE
WINAPI
FirstLoad_SfcConnectToServer(
    IN LPCWSTR ServerName
    )
{
    BOOL ok = FALSE;
    try {
        EnterCriticalSection(&InitMutex);
        if(Dyn_SfcConnectToServer == FirstLoad_SfcConnectToServer) {
            (FARPROC) Dyn_SfcConnectToServer         = ObtainFnPtr (
                                                        "sfc_os.dll",
                                                        (LPCSTR)3,
                                                        (FARPROC) Stub_SfcConnectToServer
                                                        );
        }
        LeaveCriticalSection(&InitMutex);
        ok = TRUE;
    } except(EXCEPTION_EXECUTE_HANDLER) {
    }
    if(ok) {
        return Dyn_SfcConnectToServer(ServerName);
    } else {
        return Stub_SfcConnectToServer(ServerName);
    }
}

VOID
FirstLoad_SfcClose(
    IN HANDLE RpcHandle
    )
{
    BOOL ok = FALSE;
    try {
        EnterCriticalSection(&InitMutex);
        if(Dyn_SfcClose == FirstLoad_SfcClose) {
            (FARPROC) Dyn_SfcClose                   = ObtainFnPtr (
                                                        "sfc_os.dll",
                                                        (LPCSTR)4,
                                                        (FARPROC) Stub_SfcClose
                                                        );
        }
        LeaveCriticalSection(&InitMutex);
        ok = TRUE;
    } except(EXCEPTION_EXECUTE_HANDLER) {
    }

    if(ok) {
        Dyn_SfcClose(RpcHandle);
    }
    return;
}

DWORD
WINAPI
FirstLoad_SfcFileException(
    IN HANDLE RpcHandle,
    IN PCWSTR FileName,
    IN DWORD ExpectedChangeType
    )
{
    BOOL ok = FALSE;
    try {
        EnterCriticalSection(&InitMutex);
        if(Dyn_SfcFileException == FirstLoad_SfcFileException) {
            (FARPROC) Dyn_SfcFileException           = ObtainFnPtr (
                                                        "sfc_os.dll",
                                                        (LPCSTR)5,
                                                        (FARPROC) Stub_SfcFileException
                                                        );
        }
        LeaveCriticalSection(&InitMutex);
        ok = TRUE;
    } except(EXCEPTION_EXECUTE_HANDLER) {
    }

    if(ok) {
        return Dyn_SfcFileException(RpcHandle,FileName,ExpectedChangeType);
    } else {
        return Stub_SfcFileException(RpcHandle,FileName,ExpectedChangeType);
    }
}

BOOL
WINAPI
FirstLoad_SfcIsFileProtected(
    IN HANDLE RpcHandle,
    IN LPCWSTR ProtFileName
    )
{
    BOOL ok = FALSE;
    try {
        EnterCriticalSection(&InitMutex);
        if(Dyn_SfcIsFileProtected == FirstLoad_SfcIsFileProtected) {
            (FARPROC) Dyn_SfcIsFileProtected         = ObtainFnPtr (
                                                        "sfc_os.dll",
                                                        "SfcIsFileProtected",
                                                        (FARPROC) Stub_SfcIsFileProtected
                                                        );
        }
        LeaveCriticalSection(&InitMutex);
        ok = TRUE;
    } except(EXCEPTION_EXECUTE_HANDLER) {
    }

    if(ok) {
        return Dyn_SfcIsFileProtected(RpcHandle,ProtFileName);
    } else {
        return Stub_SfcIsFileProtected(RpcHandle,ProtFileName);
    }
}

#ifdef ANSI_SETUPAPI

CONFIGRET
WINAPI
Stub_CM_Query_Resource_Conflict_List(
             OUT PCONFLICT_LIST pclConflictList,
             IN  DEVINST        dnDevInst,
             IN  RESOURCEID     ResourceID,
             IN  PCVOID         ResourceData,
             IN  ULONG          ResourceLen,
             IN  ULONG          ulFlags,
             IN  HMACHINE       hMachine
             )
{
    return CR_CALL_NOT_IMPLEMENTED;
}

CONFIGRET
WINAPI
Stub_CM_Free_Resource_Conflict_Handle(
             IN CONFLICT_LIST   clConflictList
             )
{
    return CR_CALL_NOT_IMPLEMENTED;
}

CONFIGRET
WINAPI
Stub_CM_Get_Resource_Conflict_Count(
             IN CONFLICT_LIST   clConflictList,
             OUT PULONG         pulCount
             )
{
    return CR_CALL_NOT_IMPLEMENTED;
}

CONFIGRET
WINAPI
Stub_CM_Get_Resource_Conflict_DetailsA(
             IN CONFLICT_LIST         clConflictList,
             IN ULONG                 ulIndex,
             IN OUT PCONFLICT_DETAILS_A pConflictDetails
             )
{
    return CR_CALL_NOT_IMPLEMENTED;
}

CONFIGRET
WINAPI
Stub_CM_Get_Class_Registry_PropertyA(
    IN  LPGUID      ClassGUID,
    IN  ULONG       ulProperty,
    OUT PULONG      pulRegDataType,    OPTIONAL
    OUT PVOID       Buffer,            OPTIONAL
    IN  OUT PULONG  pulLength,
    IN  ULONG       ulFlags,
    IN  HMACHINE    hMachine
    )
{
    return CR_CALL_NOT_IMPLEMENTED;
}

CONFIGRET
WINAPI
Stub_CM_Set_Class_Registry_PropertyA(
    IN LPGUID      ClassGUID,
    IN ULONG       ulProperty,
    IN PCVOID      Buffer,       OPTIONAL
    IN ULONG       ulLength,
    IN ULONG       ulFlags,
    IN HMACHINE    hMachine
    )
{
    return CR_CALL_NOT_IMPLEMENTED;
}

CONFIGRET
WINAPI
Stub_CM_Get_Device_Interface_Alias_ExA(
    IN     PCSTR   pszDeviceInterface,
    IN     LPGUID   AliasInterfaceGuid,
    OUT    PSTR    pszAliasDeviceInterface,
    IN OUT PULONG   pulLength,
    IN     ULONG    ulFlags,
    IN     HMACHINE hMachine
    )
{
    return CR_CALL_NOT_IMPLEMENTED;
}


CONFIGRET
WINAPI
Stub_CM_Get_Device_Interface_List_ExA(
    IN  LPGUID      InterfaceClassGuid,
    IN  DEVINSTID_A pDeviceID,      OPTIONAL
    OUT PCHAR       Buffer,
    IN  ULONG       BufferLen,
    IN  ULONG       ulFlags,
    IN  HMACHINE    hMachine
    )
{
    return CR_CALL_NOT_IMPLEMENTED;
}


CONFIGRET
WINAPI
Stub_CM_Get_Device_Interface_List_Size_ExA(
    IN  PULONG      pulLen,
    IN  LPGUID      InterfaceClassGuid,
    IN  DEVINSTID_A pDeviceID,      OPTIONAL
    IN  ULONG       ulFlags,
    IN  HMACHINE    hMachine
    )
{
    return CR_CALL_NOT_IMPLEMENTED;
}


CONFIGRET
WINAPI
Stub_CM_Get_Log_Conf_Priority_Ex(
    IN  LOG_CONF  lcLogConf,
    OUT PPRIORITY pPriority,
    IN  ULONG     ulFlags,
    IN  HMACHINE  hMachine
    )
{
    return CR_CALL_NOT_IMPLEMENTED;
}


CONFIGRET
WINAPI
Stub_CM_Query_And_Remove_SubTree_ExA(
    IN  DEVINST        dnAncestor,
    OUT PPNP_VETO_TYPE pVetoType,
    OUT PSTR          pszVetoName,
    IN  ULONG          ulNameLength,
    IN  ULONG          ulFlags,
    IN  HMACHINE       hMachine
    )
{
    return CR_CALL_NOT_IMPLEMENTED;
}


CONFIGRET
WINAPI
Stub_CM_Register_Device_Interface_ExA(
    IN  DEVINST   dnDevInst,
    IN  LPGUID    InterfaceClassGuid,
    IN  PCSTR    pszReference,         OPTIONAL
    OUT PSTR     pszDeviceInterface,
    IN OUT PULONG pulLength,
    IN  ULONG     ulFlags,
    IN  HMACHINE  hMachine
    )
{
    return CR_CALL_NOT_IMPLEMENTED;
}


CONFIGRET
WINAPI
Stub_CM_Set_DevNode_Problem_Ex(
    IN DEVINST   dnDevInst,
    IN ULONG     ulProblem,
    IN  ULONG    ulFlags,
    IN  HMACHINE hMachine
    )
{
    return CR_CALL_NOT_IMPLEMENTED;
}


CONFIGRET
WINAPI
Stub_CM_Unregister_Device_Interface_ExA(
    IN PCSTR   pszDeviceInterface,
    IN ULONG    ulFlags,
    IN HMACHINE hMachine
    )
{
    return CR_CALL_NOT_IMPLEMENTED;
}


BOOL
WINAPI
Stub_CryptCATAdminAcquireContext (
    OUT HCATADMIN *phCatAdmin,
    IN const GUID *pgSubsystem,
    IN DWORD dwFlags
    )
{
    SetLastError (ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}


BOOL
WINAPI
Stub_CryptCATAdminReleaseContext (
    IN HCATADMIN hCatAdmin,
    IN DWORD dwFlags
    )
{
    SetLastError (ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}


BOOL
WINAPI
Stub_CryptCATAdminReleaseCatalogContext (
    IN HCATADMIN hCatAdmin,
    IN HCATINFO hCatInfo,
    IN DWORD dwFlags
    )
{
    SetLastError (ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}


HCATINFO
WINAPI
Stub_CryptCATAdminAddCatalog (
    IN HCATADMIN hCatAdmin,
    IN WCHAR *pwszCatalogFile,
    IN OPTIONAL WCHAR *pwszSelectBaseName,
    IN DWORD dwFlags
    )
{
    SetLastError (ERROR_CALL_NOT_IMPLEMENTED);
    return NULL;
}


BOOL
WINAPI
Stub_CryptCATCatalogInfoFromContext (
    IN HCATINFO hCatInfo,
    IN OUT CATALOG_INFO *psCatInfo,
    IN DWORD dwFlags
    )
{
    SetLastError (ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}


BOOL
WINAPI
Stub_CryptCATAdminCalcHashFromFileHandle (
    IN HANDLE hFile,
    IN OUT DWORD *pcbHash,
    OUT OPTIONAL BYTE *pbHash,
    IN DWORD dwFlags
    )
{
    SetLastError (ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}


HCATINFO
WINAPI
Stub_CryptCATAdminEnumCatalogFromHash(
    IN HCATADMIN hCatAdmin,
    IN BYTE *pbHash,
    IN DWORD cbHash,
    IN DWORD dwFlags,
    IN OUT HCATINFO *phPrevCatInfo
    )
{
    SetLastError (ERROR_CALL_NOT_IMPLEMENTED);
    return NULL;
}


BOOL
WINAPI
Stub_CryptCATAdminRemoveCatalog(
    IN HCATADMIN hCatAdmin,
    IN WCHAR *pwszCatalogFile,
    IN DWORD dwFlags
    )
{
    SetLastError (ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}


BOOL
WINAPI
Stub_CryptCATAdminResolveCatalogPath(
    IN HCATADMIN hCatAdmin,
    IN WCHAR *pwszCatalogFile,
    IN OUT CATALOG_INFO *psCatInfo,
    IN DWORD dwFlags
    )
{
    SetLastError (ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}


BOOL
WINAPI
Stub_CertFreeCertificateContext(
    IN PCCERT_CONTEXT pCertContext
    )
{
    SetLastError (ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}


LONG
WINAPI
Stub_WinVerifyTrust(
    HWND hwnd,
    GUID *pgActionID,
    LPVOID pWVTData
    )
{
    return ERROR_SUCCESS;
}

int
Stub_wnsprintf(
    LPTSTR lpOut,
    int cchLimitIn,
    LPCTSTR pszFmt,
    ...
    )
{
    //
    // Win95 doesn't have wnsprintf
    // in ANSI version of SetupAPI, use CRT instead
    //
    va_list argptr;
    int sz;

    if(cchLimitIn<=0) {
        return 0;
    }

    va_start(argptr,pszFmt);
    sz = _vsntprintf(lpOut,cchLimitIn,pszFmt,argptr);
    if(sz == cchLimitIn) {
        //
        // backup
        //
        sz = CharPrev(lpOut,lpOut+sz)-lpOut;
        lpOut[sz] = TEXT('\0');
    }
    return sz;
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\setupapi\ansi\precomp.h ===
#include "setupntp.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\setupapi\ansi\makefile.inc ===
!include ..\makefile.inc

msg.h msg00001.bin msg.rc: ..\msg.mc
        mc -a -v ..\msg.mc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\setupapi\sputils\fileutil.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    fileutil.c

Abstract:

    File-related functions for SPUTILS

Author:

    Ted Miller (tedm) 11-Jan-1995

Revision History:

    Jamie Hunter (JamieHun) Jun-27-2000
            Moved various functions out of setupapi

    Jamie Hunter (JamieHun) Feb-22-2002
            Security code review

--*/


#include "precomp.h"
#pragma hdrstop

DWORD
pSetupOpenAndMapFileForRead(
    IN  PCTSTR   FileName,
    OUT PDWORD   FileSize,
    OUT PHANDLE  FileHandle,
    OUT PHANDLE  MappingHandle,
    OUT PVOID   *BaseAddress
    )

/*++

Routine Description:

    Open and map an existing file for read access.

Arguments:

    FileName - supplies pathname to file to be mapped.

    FileSize - receives the size in bytes of the file.

    FileHandle - receives the win32 file handle for the open file.
        The file will be opened for generic read access.

    MappingHandle - receives the win32 handle for the file mapping
        object.  This object will be for read access.

    BaseAddress - receives the address where the file is mapped.

Return Value:

    NO_ERROR if the file was opened and mapped successfully.
        The caller must unmap the file with pSetupUnmapAndCloseFile when
        access to the file is no longer desired.

    Win32 error code if the file was not successfully mapped.

--*/

{
    DWORD rc;

    //
    // Open the file -- fail if it does not exist.
    //
    *FileHandle = CreateFile(
                    FileName,
                    GENERIC_READ,
                    FILE_SHARE_READ,
                    NULL,
                    OPEN_EXISTING,
                    0,
                    NULL
                    );

    if(*FileHandle == INVALID_HANDLE_VALUE) {

        rc = GetLastError();

    } else if((rc = pSetupMapFileForRead(*FileHandle,
                                   FileSize,
                                   MappingHandle,
                                   BaseAddress)) != NO_ERROR) {
        CloseHandle(*FileHandle);
    }

    return(rc);
}

#ifndef SPUTILSW

DWORD
pSetupMapFileForRead(
    IN  HANDLE   FileHandle,
    OUT PDWORD   FileSize,
    OUT PHANDLE  MappingHandle,
    OUT PVOID   *BaseAddress
    )

/*++

Routine Description:

    Map an opened file for read access.

Arguments:

    FileHandle - supplies the handle of the opened file to be mapped.
        This handle must have been opened with at least read access.

    FileSize - receives the size in bytes of the file.

    MappingHandle - receives the win32 handle for the file mapping
        object.  This object will be for read access.

    BaseAddress - receives the address where the file is mapped.

Return Value:

    NO_ERROR if the file was mapped successfully.  The caller must
        unmap the file with pSetupUnmapAndCloseFile when access to the file
        is no longer desired.

    Win32 error code if the file was not successfully mapped.

--*/

{
    DWORD rc;

    //
    // Get the size of the file.
    //
    *FileSize = GetFileSize(FileHandle, NULL);
    if(*FileSize != (DWORD)(-1)) {

        //
        // Create file mapping for the whole file.
        //
        *MappingHandle = CreateFileMapping(
                            FileHandle,
                            NULL,
                            PAGE_READONLY,
                            0,
                            *FileSize,
                            NULL
                            );

        if(*MappingHandle) {

            //
            // Map the whole file.
            //
            *BaseAddress = MapViewOfFile(
                                *MappingHandle,
                                FILE_MAP_READ,
                                0,
                                0,
                                *FileSize
                                );

            if(*BaseAddress) {
                return(NO_ERROR);
            }

            rc = GetLastError();
            CloseHandle(*MappingHandle);
        } else {
            rc = GetLastError();
        }
    } else {
        rc = GetLastError();
    }

    return(rc);
}

BOOL
pSetupUnmapAndCloseFile(
    IN HANDLE FileHandle,
    IN HANDLE MappingHandle,
    IN PVOID  BaseAddress
    )

/*++

Routine Description:

    Unmap and close a file.

Arguments:

    FileHandle - supplies win32 handle to open file.

    MappingHandle - supplies the win32 handle for the open file mapping
        object.

    BaseAddress - supplies the address where the file is mapped.

Return Value:

    BOOLean value indicating success or failure.

--*/

{
    BOOL b;

    b = UnmapViewOfFile(BaseAddress);

    b = b && CloseHandle(MappingHandle);

    b = b && CloseHandle(FileHandle);

    return(b);
}

#endif //!SPUTILSW


BOOL
pSetupFileExists(
    IN  PCTSTR           FileName,
    OUT PWIN32_FIND_DATA FindData   OPTIONAL
    )

/*++

Routine Description:

    Determine if a file exists and is accessible.
    Errormode is set (and then restored) so the user will not see
    any pop-ups.

Arguments:

    FileName - supplies full path of file to check for existance.

    FindData - if specified, receives find data for the file.

Return Value:

    TRUE if the file exists and is accessible.
    FALSE if not. GetLastError() returns extended error info.

--*/

{
    WIN32_FIND_DATA findData;
    HANDLE FindHandle;
    UINT OldMode;
    DWORD Error;

    OldMode = SetErrorMode(SEM_FAILCRITICALERRORS);

    FindHandle = FindFirstFile(FileName,&findData);
    if(FindHandle == INVALID_HANDLE_VALUE) {
        Error = GetLastError();
    } else {
        FindClose(FindHandle);
        if(FindData) {
            *FindData = findData;
        }
        Error = NO_ERROR;
    }

    SetErrorMode(OldMode);

    SetLastError(Error);
    return (Error == NO_ERROR);
}

DWORD
pSetupMakeSurePathExists(
    IN PCTSTR FullFilespec
    )

/*++

Routine Description:

    This routine ensures that a multi-level path exists by creating individual
    levels one at a time. It is assumed that the caller will pass in a *filename*
    whose path needs to exist. Some examples:

    c:\x                        - C:\ is assumes to always exist.

    c:\x\y\z                    - Ensure that c:\x\y exists.

    \x\y\z                      - \x\y on current drive

    x\y                         - x in current directory

    d:x\y                       - d:x

    \\server\share\p\file       - \\server\share\p

    \\?\GLOBALROOT\a\b\c        - other more weird scenarios
    \\?\C:\a\b\c

Arguments:

    FullFilespec - supplies the *filename* of a file that the caller wants to
        create. This routine creates the *path* to that file, in other words,
        the final component is assumed to be a filename, and is not a
        directory name. (This routine doesn't actually create this file.)
        If this is invalid, then the results are undefined (for example,
        passing \\server\share, C:\, or C:).

Return Value:

    Win32 error code indicating outcome. If FullFilespec is invalid,
    *may* return ERROR_INVALID_NAME.

--*/

{
    TCHAR Buffer[MAX_PATH+2];
    TCHAR c;
    PTSTR filename;
    PTSTR root;
    PTSTR last;
    PTSTR backtrack;
    DWORD len;
    DWORD attrib;

    //
    // normalize path
    //
    len = GetFullPathName(FullFilespec,MAX_PATH,Buffer,&filename);
    if(len >= MAX_PATH) {
        //
        // directory name is longer than we can handle
        //
        return ERROR_INVALID_NAME;
    }
    if(!len) {
        //
        // other error
        //
        return GetLastError();
    }
    if(filename == NULL || filename == Buffer) {
        //
        // looks like no path specified
        //
        return ERROR_INVALID_NAME;
    }
    //
    // chop off filename part
    //
    filename[0] = TEXT('\0');

    //
    // now do some other sanity checks
    // to determine 'root' - a point we wont try to create
    //
    if((_totupper(Buffer[0])>=TEXT('A')) &&
       (_totupper(Buffer[0])<=TEXT('Z')) &&
       (Buffer[1] == TEXT(':'))) {
        //
        // looks like "d:" format
        //
        if(Buffer[2] != TEXT('\\')) {
            return ERROR_INVALID_NAME;
        }
        root = Buffer+2;
    }

    if(Buffer[0] == TEXT('\\') &&
        Buffer[1] == TEXT('\\')) {
        //
        // UNC style (\\machine\share\path \\?\d\path \\?\GLOBALROOT\path \\.\GLOBALROOT\path etc)
        // root is 2nd slash after \\
        //
        root = _tcschr(Buffer+2,TEXT('\\')); // find first slash
        if(root) {
            root = _tcschr(root+1,TEXT('\\')); // find 2nd slash
        }
        if(!root) {
            return ERROR_INVALID_NAME;
        }
    }

    //
    // see if the directory specified exists
    // include the slash, since that helps scenarios like \\?\GLOBALROOT\Device\HarddiskVolume1\
    // and works for all the other scenarios
    // can't use findfirst/findnext though
    //
    attrib = GetFileAttributes(Buffer);
    if(attrib != (DWORD)(-1)) {
        if(attrib & FILE_ATTRIBUTE_DIRECTORY) {
            //
            // requested directory already exists
            //
            return NO_ERROR;
        }
        //
        // directory was expected
        //
        return ERROR_DIRECTORY;
    }

    //
    // now we have to step backwards until we find an existing directory
    // change all '\' to nulls as we do so
    // this will give us something like (c esc form) c:\\a\\b\\c\0d\0e\0f\0\0
    // we know the last \0 is there from when we chopped filename
    // first directory to be created is c:\\a\\b\\c
    //
    last = CharPrev(Buffer,filename); // to last slash
    if(last == root) {
        return ERROR_INVALID_NAME;
    }
    if(*last != TEXT('\\')) {
        //
        // should never be the case
        //
        return ERROR_INVALID_NAME;
    }
    while(last > root) {
        *last = TEXT('\0');
        backtrack = _tcsrchr(Buffer,TEXT('\\'));
        if(!backtrack) {
            return ERROR_INVALID_NAME;
        }
        c = backtrack[1];
        backtrack[1] = TEXT('\0');
        attrib = GetFileAttributes(Buffer); // does this part exist?
        backtrack[1] = c;                   // but character back
        if(attrib != (DWORD)(-1)) {
            if(attrib & FILE_ATTRIBUTE_DIRECTORY) {
                //
                // requested directory already exists
                // 'last' points to first NULL to replace to slash
                // Buffer contains first directory to create
                //
                break;
            }
            //
            // directory was expected
            //
            return ERROR_DIRECTORY;
        }
        //
        // keep going
        //
        last = backtrack;
    }
    if(last <= root) {
        return ERROR_INVALID_NAME;
    }

    //
    // now begin create loop
    //
    while(CreateDirectory(Buffer,NULL)) {
        if(!last[1]) {
            //
            // path created
            //
            return NO_ERROR;
        }
        last[0] = TEXT('\\');
        last += lstrlen(last);
    }
    //
    // failed for some other reason
    //
    return GetLastError();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\setupapi\sputils\memory.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    memory.c

Abstract:

    Memory handling routines for Windows NT Setup API dll.

Author:

    Ted Miller (tedm) 11-Jan-1995

Revision History:

    Jamie Hunter (jamiehun) 13-Feb-1998

        Improved this further for debugging
        added linked list,
        alloc tracing,
        memory fills
        and memory leak detection

    jamiehun 30-April-1998

        Added some more consistancy checks
        Put try/except around access

    jimschm 27-Oct-1998

        Wrote fast allocation routines to speed up setupapi.dll on Win9x

    JamieHun Jun-26-2000

        Moved to sputils
        Changed to use a private heap

--*/


#include "precomp.h"
#pragma hdrstop

static BOOL Initialized = FALSE;
static HANDLE _pSpUtilsHeap = NULL;

#define ALLOC(x)        HeapAlloc(_pSpUtilsHeap,0,x)
#define FREE(x)         HeapFree(_pSpUtilsHeap,0,x)
#define REALLOC(x,y)    HeapReAlloc(_pSpUtilsHeap,0,x,y)
#define MEMSIZE(x)      HeapSize(_pSpUtilsHeap,0,x)
#define INITIALHEAPSIZE (0x100000)

//
// Internal debugging features
//

#if MEM_DBG

#define MEMERROR(x) _pSpUtilsAssertFail(__FILE__,__LINE__,#x)

DWORD _pSpUtilsDbgAllocNum = 0;
DWORD _pSpUtilsMemoryFlags = 0;

struct _MemHeader {
    struct _MemHeader * PrevAlloc;  // previous on chain
    struct _MemHeader * NextAlloc;  // next on chain
    DWORD MemoryTag;                // tag - to pair off Malloc/Free
    DWORD BlockSize;                // bytes of "real" data
    DWORD AllocNum;                 // number of this allocation, ie AllocCount at the time this was allocated
    PCSTR AllocFile;                // name of file that did allocation, if set
    DWORD AllocLine;                // line of this allocation
    DWORD HeadMemSig;               // head-check, stop writing before actual data
    BYTE Data[sizeof(DWORD)];       // size allows for tail-check at end of actual data
};

struct _MemStats {
    struct _MemHeader * FirstAlloc; // will be NULL if no allocations, else earliest malloc/realloc in chain
    struct _MemHeader * LastAlloc;  // last alloc/realloc goes to end of chain
    DWORD MemoryAllocated;          // bytes, excluding headers
    DWORD AllocCount;               // incremented for every alloc
    DWORD ReallocCount;             // incremented for every realloc
    DWORD FreeCount;                // incremented for every free
    BOOL DoneInitDebugMutex;
    CRITICAL_SECTION DebugMutex;    // We need a mutex to manage memstats, setupapi is MT
} _pSpUtilsMemStats = {
    NULL, NULL, 0, 0, 0, 0, FALSE, 0
};

//
// Checked builds have a block head/tail check
// and extra statistics
//
#define HEAD_MEMSIG 0x4d444554  // = MDET (MSB to LSB) or TEDM (LSB to MSB)
#define TAIL_MEMSIG 0x5445444d  // = TEDM (MSB to LSB) or MDET (LSB to MSB)
#define MEM_ALLOCCHAR 0xdd      // makes sure we fill with non-null
#define MEM_FREECHAR 0xee       // if we see this, memory has been de-allocated
#define MEM_DEADSIG 0xdeaddead
#define MEM_TOOBIG 0x80000000   // use this to pick up big allocs

#define MemMutexLock()          EnterCriticalSection(&_pSpUtilsMemStats.DebugMutex)
#define MemMutexUnlock()        LeaveCriticalSection(&_pSpUtilsMemStats.DebugMutex)

static
BOOL MemBlockCheck(
    struct _MemHeader * Mem
    )
/*++

Routine Description:

    Verify a block header is valid

Arguments:
    Mem = Header to verify

Returns:
    TRUE if valid
    FALSE if not valid

++*/
{
    if (Mem == NULL) {
        return TRUE;
    }
    if (Mem->HeadMemSig != HEAD_MEMSIG) {
        MEMERROR("Internal heap error - HeadMemSig invalid");
        return FALSE;
    }
    if (Mem->BlockSize >= MEM_TOOBIG) {
        MEMERROR("Internal heap error - BlockSize too big");
        return FALSE;
    }
    if((Mem->PrevAlloc == Mem) || (Mem->NextAlloc == Mem)) {
        //
        // we should have failed the MEMSIG, but it's ok as an extra check
        //
        MEMERROR("Internal heap error - self link");
        return FALSE;
    }
    if ((*(DWORD UNALIGNED *)(Mem->Data+Mem->BlockSize)) != TAIL_MEMSIG) {
        MEMERROR("Internal heap error - TailMemSig invalid");
        return FALSE;
    }
    return TRUE;
}

static
struct _MemHeader *
MemBlockGet(
    IN PVOID Block
    )
/*++

Routine Description:

    Verify a block is valid, and return real memory pointer

Arguments:
    Block - address the application uses

++*/
{
    struct _MemHeader * Mem;

    if((DWORD_PTR)Block < offsetof(struct _MemHeader,Data[0])) {
        MEMERROR("Internal heap error - Block address is invalid");
        return NULL;
    }

    Mem = (struct _MemHeader *)(((PBYTE)Block) - offsetof(struct _MemHeader,Data[0]));

    if (MemBlockCheck(Mem)==FALSE) {
        //
        // block fails test
        //
        return NULL;
    }

    if(Mem->PrevAlloc != NULL) {
        if(MemBlockCheck(Mem->PrevAlloc)==FALSE) {
            //
            // back link is invalid
            //
            return NULL;
        }
    } else if (_pSpUtilsMemStats.FirstAlloc != Mem) {
        //
        // _pSpUtilsMemStats.FirstAlloc is invalid wrt Mem
        //
        MEMERROR("Internal heap error - FirstAlloc invalid");
        return NULL;
    }
    if(Mem->NextAlloc != NULL) {
        if(MemBlockCheck(Mem->NextAlloc)==FALSE) {
            //
            // forward link is invalid
            //
            return NULL;
        }
    } else if (_pSpUtilsMemStats.LastAlloc != Mem) {
        //
        // _pSpUtilsMemStats.LastAlloc is invalid wrt Mem
        //
        MEMERROR("Internal heap error - LastAlloc invalid");
        return NULL;
    }

    //
    // seems pretty good
    //

    return Mem;
}

static
PVOID
MemBlockLink(
    struct _MemHeader * Mem
    )

{
    if (Mem == NULL) {
        return NULL;
    }

    Mem->PrevAlloc = _pSpUtilsMemStats.LastAlloc;
    Mem->NextAlloc = NULL;
    _pSpUtilsMemStats.LastAlloc = Mem;
    if (Mem->PrevAlloc == NULL) {
        _pSpUtilsMemStats.FirstAlloc = Mem;
    } else {
        if (MemBlockCheck(Mem->PrevAlloc)) {
            Mem->PrevAlloc->NextAlloc = Mem;
        }
    }

    Mem->HeadMemSig = HEAD_MEMSIG;
    *(DWORD UNALIGNED *)(Mem->Data+Mem->BlockSize) = TAIL_MEMSIG;

    return (PVOID)(Mem->Data);
}

static
PVOID
MemBlockUnLink(
    struct _MemHeader * Mem
    )

{
    if (Mem == NULL) {
        return NULL;
    }
    if((Mem->PrevAlloc == Mem) || (Mem->NextAlloc == Mem) || (Mem->HeadMemSig == MEM_DEADSIG)) {
        MEMERROR("Internal heap error - MemBlockUnLink");
    }

    if (Mem->PrevAlloc == NULL) {
        _pSpUtilsMemStats.FirstAlloc = Mem->NextAlloc;
    } else {
        Mem->PrevAlloc->NextAlloc = Mem->NextAlloc;
    }
    if (Mem->NextAlloc == NULL) {
        _pSpUtilsMemStats.LastAlloc = Mem->PrevAlloc;
    } else {
        Mem->NextAlloc->PrevAlloc = Mem->PrevAlloc;
    }
    Mem->PrevAlloc = Mem;  // make pointers harmless and also adds as an exta debug check
    Mem->NextAlloc = Mem;  // make pointers harmless and also adds as an exta debug check
    Mem->HeadMemSig = MEM_DEADSIG;
    *(DWORD UNALIGNED *)(Mem->Data+Mem->BlockSize) = MEM_DEADSIG;

    return Mem->Data;
}

static
BOOL
MemDebugInitialize(
    VOID
    )
{
    try {
        InitializeCriticalSection(&_pSpUtilsMemStats.DebugMutex);
        _pSpUtilsMemStats.DoneInitDebugMutex = TRUE;
    } except(EXCEPTION_EXECUTE_HANDLER) {
    }
    return _pSpUtilsMemStats.DoneInitDebugMutex;
}

static
BOOL
MemDebugUninitialize(
    VOID
    )
{
    struct _MemHeader *Mem;
    TCHAR Msg[1024];
    TCHAR Process[MAX_PATH];

    //
    // Dump the leaks
    //

    Mem = _pSpUtilsMemStats.FirstAlloc;

    GetModuleFileName( GetModuleHandle(NULL),Process, sizeof(Process)/sizeof(TCHAR));


    while (Mem) {
        wsprintf (Msg, TEXT("SPUTILS: Leak (%d bytes) at %hs line %u (allocation #%d) in process %s \r\n"), Mem->BlockSize, Mem->AllocFile, Mem->AllocLine, Mem->AllocNum, Process );
        pSetupDebugPrintEx(DPFLTR_WARNING_LEVEL, Msg);
        if (_pSpUtilsMemoryFlags != 0) {
            if (Mem->BlockSize > 1024) {
                pSetupDebugPrintEx(DPFLTR_ERROR_LEVEL, TEXT("Leak of > 1K. Calling DebugBreak.\n"));
                DebugBreak();
            }
        }

        Mem = Mem->NextAlloc;
    }

    //
    // Clean up
    //

    if(_pSpUtilsMemStats.DoneInitDebugMutex) {
        DeleteCriticalSection(&_pSpUtilsMemStats.DebugMutex);
    }

    //
    // any last minute checks
    //

    return TRUE;
}

#endif // MEM_DBG


//
// published functions
//

PVOID
pSetupDebugMallocWithTag(
    IN DWORD Size,
    IN PCSTR Filename,
    IN DWORD Line,
    IN DWORD Tag
    )
/*++

Routine Description:

    Debug version of Malloc
    Resulting allocated block has prefix/suffix and is filled with MEM_ALLOCCHAR

Arguments:

    Size - size in bytes of block to be allocated. The size may be 0.
    Filename/Line - debugging information

    Tag    - match malloc with free/realloc's

Return Value:

    Pointer to block of memory, or NULL if a block could not be allocated.

--*/
{
#if MEM_DBG

    struct _MemHeader *Mem;
    PVOID Ptr = NULL;
    BOOL locked = FALSE;
    LPEXCEPTION_POINTERS ExceptionPointers = NULL;

    MYASSERT(Initialized);


    try {
        MemMutexLock();
        locked = TRUE;
        _pSpUtilsMemStats.AllocCount++;

        if (Size >= MEM_TOOBIG) {
            MEMERROR("pSetupDebugMalloc - requested size too big (negative?)");
            leave;
        }

        if((Mem = (struct _MemHeader*) ALLOC(Size+sizeof(struct _MemHeader))) == NULL) {
            leave;  // it failed ALLOC, but prob not due to a bug
        }

        Mem->MemoryTag = Tag;
        Mem->BlockSize = Size;
        Mem->AllocNum = _pSpUtilsMemStats.AllocCount;
        Mem->AllocFile = Filename;
        Mem->AllocLine = Line;

        // init memory we have allocated (to make sure we don't accidently get zero's)
        FillMemory(Mem->Data,Size,MEM_ALLOCCHAR);

        _pSpUtilsMemStats.MemoryAllocated += Size;

        Ptr = MemBlockLink(Mem);

        if (_pSpUtilsMemoryFlags && (_pSpUtilsDbgAllocNum == Mem->AllocNum)) {
            MEMERROR("_pSpUtilsDbgAllocNum hit");
        }

    } except(ExceptionPointers = GetExceptionInformation(),
             EXCEPTION_EXECUTE_HANDLER) {
        MEMERROR("pSetupDebugMalloc - Exception");
        Ptr = NULL;
    }

    if(locked) {
        MemMutexUnlock();
    }

    return Ptr;

#else

    return ALLOC(Size);

#endif
}

PVOID
pSetupDebugMalloc(
    IN DWORD Size,
    IN PCSTR Filename,
    IN DWORD Line
    )
/*++

Routine Description:

    Allocate a chunk of memory. The memory is not zero-initialized.

Arguments:

    Size - size in bytes of block to be allocated. The size may be 0.

Return Value:

    Pointer to block of memory, or NULL if a block could not be allocated.

--*/

{
    MYASSERT(Initialized);

#if MEM_DBG

    return pSetupDebugMallocWithTag(Size, Filename , Line, 0);

#else

    return ALLOC(Size);

#endif
}

PVOID
pSetupMalloc(
    IN DWORD Size
    )

/*++

Routine Description:

    Allocate a chunk of memory. The memory is not zero-initialized.

Arguments:

    Size - size in bytes of block to be allocated. The size may be 0.

Return Value:

    Pointer to block of memory, or NULL if a block could not be allocated.

--*/

{
    MYASSERT(Initialized);

#if MEM_DBG

    return pSetupDebugMallocWithTag(Size, NULL , 0, 0);

#else

    return ALLOC(Size);

#endif
}

PVOID
pSetupReallocWithTag(
    IN PVOID Block,
    IN DWORD NewSize,
    IN DWORD Tag
    )

/*++

Routine Description:

    Realloc routine Debug/Non-Debug versions

    Note that a general assumption here, is that if NewSize <= OriginalSize
    the reallocation *should* not fail

Arguments:

    Block - pointer to block to be reallocated.

    NewSize - new size in bytes of block. If the size is 0, this function
        works like pSetupFree, and the return value is NULL.

    Tag    - match realloc with malloc

Return Value:

    Pointer to block of memory, or NULL if a block could not be allocated.
    In that case the original block remains unchanged.

--*/

{
#if MEM_DBG

    PVOID p;
    DWORD OldSize;
    struct _MemHeader *Mem;
    PVOID Ptr = NULL;
    BOOL locked = FALSE;
    LPEXCEPTION_POINTERS ExceptionPointers = NULL;

    MYASSERT(Initialized);

    try {
        MemMutexLock();
        locked = TRUE;
        _pSpUtilsMemStats.ReallocCount++;

        if (Block == NULL) {
            leave;
        }

        if (NewSize >= MEM_TOOBIG) {
            MEMERROR("pSetupRealloc - requested size too big (negative?)");
            leave;
        }

        Mem = MemBlockGet(Block);
        if (Mem == NULL) {
            leave;
        }

        if (Mem->MemoryTag != Tag) {
            MEMERROR("pSetupRealloc - Tag mismatch");
            leave;
        }

        OldSize = Mem->BlockSize;
        MemBlockUnLink(Mem);

        if (NewSize < OldSize) {
            // trash memory we're about to free
            FillMemory(Mem->Data+NewSize,OldSize-NewSize+sizeof(DWORD),MEM_FREECHAR);
        }

        if((p = REALLOC(Mem, NewSize+sizeof(struct _MemHeader))) == NULL) {
            //
            // failed to re-alloc
            //
            MemBlockLink(Mem);
            leave;
        }
        Mem = (struct _MemHeader*)p;
        Mem->BlockSize = NewSize;

        if (NewSize > OldSize) {
            // init extra memory we have allocated
            FillMemory(Mem->Data+OldSize,NewSize-OldSize,MEM_ALLOCCHAR);
        }
        _pSpUtilsMemStats.MemoryAllocated -= OldSize;
        _pSpUtilsMemStats.MemoryAllocated += NewSize;

        Ptr = MemBlockLink(Mem);

    } except(ExceptionPointers = GetExceptionInformation(),
             EXCEPTION_EXECUTE_HANDLER) {
        MEMERROR("pSetupRealloc - Exception");
        Ptr = NULL;
    }

    if(locked) {
        MemMutexUnlock();
    }

    return Ptr;

#else

    return REALLOC(Block, NewSize);

#endif
}

PVOID
pSetupRealloc(
    IN PVOID Block,
    IN DWORD NewSize
    )

/*++

Routine Description:

    Realloc routine Debug/Non-Debug versions

    Note that a general assumption here, is that if NewSize <= OriginalSize
    the reallocation *should* not fail

Arguments:

    Block - pointer to block to be reallocated.

    NewSize - new size in bytes of block. If the size is 0, this function
        works like pSetupFree, and the return value is NULL.

Return Value:

    Pointer to block of memory, or NULL if a block could not be allocated.
    In that case the original block remains unchanged.

--*/

{
#if MEM_DBG

    return pSetupReallocWithTag(Block,NewSize,0);

#else

    return REALLOC(Block, NewSize);

#endif
}

VOID
pSetupFreeWithTag(
    IN CONST VOID *Block,
    IN DWORD Tag
    )

/*++

Routine Description:

    Free (debug/non-debug versions)

Arguments:

    Buffer - pointer to block to be freed.
    Tag    - match free with malloc

Return Value:

    None.

--*/

{
#if MEM_DBG

    DWORD OldSize;
    struct _MemHeader *Mem;
    BOOL locked = FALSE;
    LPEXCEPTION_POINTERS ExceptionPointers = NULL;

    MYASSERT(Initialized);

    try {
        MemMutexLock();
        locked = TRUE;
        _pSpUtilsMemStats.FreeCount++;

        if (Block == NULL) {
            leave;
        }

        Mem = MemBlockGet((PVOID)Block);
        if (Mem == NULL) {
            leave;
        }
        if (Mem->MemoryTag != Tag) {
            MEMERROR("pSetupFree - Tag mismatch");
            leave;
        }
        OldSize = Mem->BlockSize;
        MemBlockUnLink(Mem);
        _pSpUtilsMemStats.MemoryAllocated -= OldSize;

        //
        // trash memory we're about to free, so we can immediately see it has been free'd!!!!
        // we keep head/tail stuff to have more info available when debugging
        //
        FillMemory((PVOID)Block,OldSize,MEM_FREECHAR);
        Mem->MemoryTag = (DWORD)(-1);
        FREE(Mem);
    } except(ExceptionPointers = GetExceptionInformation(),
             EXCEPTION_EXECUTE_HANDLER) {
          MEMERROR("pSetupFree - Exception");
    }

    if(locked) {
        MemMutexUnlock();
    }

#else

    FREE ((void *)Block);

#endif
}

VOID
pSetupFree(
    IN CONST VOID *Block
    )

/*++

Routine Description:

    Free (debug/non-debug versions)

Arguments:

    Buffer - pointer to block to be freed.

Return Value:

    None.

--*/
{
#if MEM_DBG

    pSetupFreeWithTag(Block,0);

#else

    FREE ((void *)Block);

#endif

}

HANDLE
pSetupGetHeap(
    VOID
    )
{
    MYASSERT(Initialized);
    return _pSpUtilsHeap;
}

//
// initialization functions
//

BOOL
_pSpUtilsMemoryInitialize(
    VOID
    )
{
#if MEM_DBG
    _pSpUtilsHeap = HeapCreate(0,INITIALHEAPSIZE,0);
    if(_pSpUtilsHeap == NULL) {
        return FALSE;
    }
    MemDebugInitialize();
#else
    _pSpUtilsHeap = GetProcessHeap();
#endif

#if MEM_DBG
#endif
    Initialized = TRUE;
    return TRUE;
}

BOOL
_pSpUtilsMemoryUninitialize(
    VOID
    )
{
    if(Initialized) {
#if MEM_DBG
        MemDebugUninitialize();

        if(_pSpUtilsHeap) {
            HeapDestroy(_pSpUtilsHeap);
            _pSpUtilsHeap = NULL;
        }
#endif
        Initialized = FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\setupapi\sputils\sources.inc ===
MAJORCOMP=setup

TARGETPATH=obj
TARGETTYPE=LIBRARY

!include $(PROJECT_ROOT)\prerelease.inc

!if $(PRERELEASE)
#C_DEFINES=$(C_DEFINES) -DMEM_DBG=1 -DASSERTS_ON=1
# C_DEFINES=$(C_DEFINES) -DMEM_DBG=1
!endif

USE_NOLIBS=1

INCLUDES=\
    ..;                  \
    $(ADMIN_INC_PATH);   \
    $(WINDOWS_INC_PATH)

C_DEFINES=$(C_DEFINES)

SOURCES=\
    ..\fileutil.c  \
    ..\memory.c    \
    ..\miscutil.c  \
    ..\registry.c  \
    ..\security.c  \
    ..\sputils.c   \
    ..\strtab.c

!if $(IA64)
# Emit LTCG codegen
LTCG_WKS=1
!endif

# PRECOMPILED_INCLUDE=precomp.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\setupapi\sputils\locking.h ===
/*++

Copyright (c) 1995-2000 Microsoft Corporation

Module Name:

    locking.h

Abstract:

    Private header file for locking/synchronization functions
    within SPUTILS

Author:

    Ted Miller (tedm) 31-Mar-1995

Revision History:

    Jamie Hunter (JamieHun) Jun-27-2000
                Moved out of SetupAPI

--*/


//
// Locking functions. These functions are used to make various parts of
// the DLL multithread-safe. The basic idea is to have a mutex and an event.
// The mutex is used to synchronize access to the structure being guarded.
// The event is only signalled when the structure being guarded is destroyed.
// To gain access to the guarded structure, a routine waits on both the mutex
// and the event. If the event gets signalled, then the structure was destroyed.
// If the mutex gets signalled, then the thread has access to the structure.
//
typedef struct _MYLOCK {
    HANDLE Handles[2];
} MYLOCK, *PMYLOCK;

//
// Indices into Locks array in string table structure.
//
#define TABLE_DESTROYED_EVENT 0
#define TABLE_ACCESS_MUTEX    1

BOOL
__inline
BeginSynchronizedAccess(
    IN PMYLOCK Lock
    )
{
    DWORD d = WaitForMultipleObjects(2,Lock->Handles,FALSE,INFINITE);
    //
    // Success if the mutex object satisfied the wait;
    // Failure if the table destroyed event satisified the wait, or
    // the mutex was abandoned, etc.
    //
    return((d - WAIT_OBJECT_0) == TABLE_ACCESS_MUTEX);
}

VOID
__inline
EndSynchronizedAccess(
    IN PMYLOCK Lock
    )
{
    ReleaseMutex(Lock->Handles[TABLE_ACCESS_MUTEX]);
}

BOOL
_pSpUtilsInitializeSynchronizedAccess(
    OUT PMYLOCK Lock
    );

VOID
_pSpUtilsDestroySynchronizedAccess(
    IN OUT PMYLOCK Lock
    );

#define InitializeSynchronizedAccess    _pSpUtilsInitializeSynchronizedAccess
#define DestroySynchronizedAccess       _pSpUtilsDestroySynchronizedAccess
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\setupapi\sputils\miscutil.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    miscutil.c

Abstract:

    Miscellaneous utility functions for SPUTILS

Author:

    Ted Miller (tedm) 20-Jan-1995

Revision History:

    Jamie Hunter (JamieHun) Jun-27-2000
            Moved various functions out of setupapi into sputils

    Jamie Hunter (JamieHun) Mar-05-2002
            Security code review

--*/


#include "precomp.h"
#pragma hdrstop

PTSTR
pSetupDuplicateString(
    IN PCTSTR String
    )

/*++

Routine Description:

    Create a duplicate copy of a nul-terminated string.
    If the string pointer is not valid an exception is generated.

Arguments:

    String - supplies string to be duplicated.

Return Value:

    NULL if out of memory.
    Caller can free buffer with pSetupFree().

--*/

{
    PTSTR p;

    //
    // The win32 lstrlen and lstrcpy functions are guarded with
    // try/except (at least on NT). So if we use them and the string
    // is invalid, we may end up 'laundering' it into a valid 0-length
    // string. We don't want that -- we actually want to fault
    // in that case. So use the CRT functions, which we know are
    // unguarded and will generate exceptions with invalid args.
    //
    // Also handle the case where the string is valid when we are
    // taking its length, but becomes invalid before or while we
    // are copying it. If we're not careful this could be a memory
    // leak. A try/finally does exactly what we want -- allowing us
    // to clean up and still 'pass on' the exception.
    //
    if(p = pSetupCheckedMalloc((_tcslen(String)+1)*sizeof(TCHAR))) {
        try {
            //
            // If String is or becomes invalid, this will generate
            // an exception, but before execution leaves this routine
            // we'll hit the termination handler.
            //
            _tcscpy(p,String);
        } finally {
            //
            // If a fault occurred during the copy, free the copy.
            // Execution will then pass to whatever exception handler
            // might exist in the caller, etc.
            //
            if(AbnormalTermination()) {
                pSetupFree(p);
                p = NULL;
            }
        }
    }

    return(p);
}

#ifndef SPUTILSW

PSTR
pSetupUnicodeToMultiByte(
    IN PCWSTR UnicodeString,
    IN UINT   Codepage
    )

/*++

Routine Description:

    Convert a string from unicode to ansi.

Arguments:

    UnicodeString - supplies string to be converted.

    Codepage - supplies codepage to be used for the conversion.

Return Value:

    NULL if out of memory or invalid codepage.
    Caller can free buffer with pSetupFree().

--*/

{
    UINT WideCharCount;
    PSTR String;
    UINT StringBufferSize;
    UINT BytesInString;
    PSTR p;

    WideCharCount = lstrlenW(UnicodeString) + 1;

    //
    // Allocate maximally sized buffer.
    // If every unicode character is a double-byte
    // character, then the buffer needs to be the same size
    // as the unicode string. Otherwise it might be smaller,
    // as some unicode characters will translate to
    // single-byte characters.
    //
    StringBufferSize = WideCharCount * 2;
    String = pSetupCheckedMalloc(StringBufferSize);
    if(String == NULL) {
        return(NULL);
    }

    //
    // Perform the conversion.
    //
    BytesInString = WideCharToMultiByte(
                        Codepage,
                        0,                      // default composite char behavior
                        UnicodeString,
                        WideCharCount,
                        String,
                        StringBufferSize,
                        NULL,
                        NULL
                        );

    if(BytesInString == 0) {
        pSetupFree(String);
        return(NULL);
    }

    //
    // Resize the string's buffer to its correct size.
    // If the realloc fails for some reason the original
    // buffer is not freed.
    //
    if(p = pSetupRealloc(String,BytesInString)) {
        String = p;
    }

    return(String);
}


PWSTR
pSetupMultiByteToUnicode(
    IN PCSTR String,
    IN UINT  Codepage
    )

/*++

Routine Description:

    Convert a string to unicode.

Arguments:

    String - supplies string to be converted.

    Codepage - supplies codepage to be used for the conversion.

Return Value:

    NULL if string could not be converted (out of memory or invalid cp)
    Caller can free buffer with pSetupFree().

--*/

{
    UINT BytesIn8BitString;
    UINT CharsInUnicodeString;
    PWSTR UnicodeString;
    PWSTR p;

    BytesIn8BitString = lstrlenA(String) + 1;

    //
    // Allocate maximally sized buffer.
    // If every character is a single-byte character,
    // then the buffer needs to be twice the size
    // as the 8bit string. Otherwise it might be smaller,
    // as some characters are 2 bytes in their unicode and
    // 8bit representations.
    //
    UnicodeString = pSetupCheckedMalloc(BytesIn8BitString * sizeof(WCHAR));
    if(UnicodeString == NULL) {
        return(NULL);
    }

    //
    // Perform the conversion.
    //
    CharsInUnicodeString = MultiByteToWideChar(
                                Codepage,
                                MB_PRECOMPOSED,
                                String,
                                BytesIn8BitString,
                                UnicodeString,
                                BytesIn8BitString
                                );

    if(CharsInUnicodeString == 0) {
        pSetupFree(UnicodeString);
        return(NULL);
    }

    //
    // Resize the unicode string's buffer to its correct size.
    // If the realloc fails for some reason the original
    // buffer is not freed.
    //
    if(p = pSetupRealloc(UnicodeString,CharsInUnicodeString*sizeof(WCHAR))) {
        UnicodeString = p;
    }

    return(UnicodeString);
}

#endif // ! SPUTILSW

#ifdef UNICODE

DWORD
pSetupCaptureAndConvertAnsiArg(
    IN  PCSTR   AnsiString,
    OUT PCWSTR *UnicodeString
    )

/*++

Routine Description:

    Capture an ANSI string whose validity is suspect and convert it
    into a Unicode string. The conversion is completely guarded and thus
    won't fault, leak memory in the error case, etc.

Arguments:

    AnsiString - supplies string to be converted.

    UnicodeString - if successful, receives pointer to unicode equivalent
        of AnsiString. Caller must free with pSetupFree(). If not successful,
        receives NULL. This parameter is NOT validated so be careful.

Return Value:

    Win32 error code indicating outcome.

    NO_ERROR - success, UnicodeString filled in.
    ERROR_NOT_ENOUGH_MEMORY - insufficient memory for conversion.
    ERROR_INVALID_PARAMETER - AnsiString was invalid.

--*/

{
    PSTR ansiString;
    DWORD d;

    //
    // Capture the string first. We do this because pSetupMultiByteToUnicode
    // won't fault if AnsiString were to become invalid, meaning we could
    // 'launder' a bogus argument into a valid one. Be careful not to
    // leak memory in the error case, etc (see comments in DuplicateString()).
    // Do NOT use Win32 string functions here; we rely on faults occuring
    // when pointers are invalid!
    //
    *UnicodeString = NULL;
    d = NO_ERROR;
    try {
        ansiString = pSetupCheckedMalloc(strlen(AnsiString)+1);
        if(!ansiString) {
            d = ERROR_NOT_ENOUGH_MEMORY;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        //
        // If we get here, strlen faulted and ansiString
        // was not allocated.
        //
        d = ERROR_INVALID_PARAMETER;
    }

    if(d == NO_ERROR) {
        try {
            strcpy(ansiString,AnsiString);
        } except(EXCEPTION_EXECUTE_HANDLER) {
            d = ERROR_INVALID_PARAMETER;
            pSetupFree(ansiString);
        }
    }

    if(d == NO_ERROR) {
        //
        // Now we have a local copy of the string; don't worry
        // about faults any more.
        //
        *UnicodeString = pSetupMultiByteToUnicode(ansiString,CP_ACP);
        if(*UnicodeString == NULL) {
            d = ERROR_NOT_ENOUGH_MEMORY;
        }

        pSetupFree(ansiString);
    }

    return(d);
}

#else

DWORD
pSetupCaptureAndConvertAnsiArg(
    IN  PCSTR   AnsiString,
    OUT PCWSTR *UnicodeString
    )
{
    //
    // Stub so the dll will link.
    //
    UNREFERENCED_PARAMETER(AnsiString);
    UNREFERENCED_PARAMETER(UnicodeString);
    return(ERROR_CALL_NOT_IMPLEMENTED);
}

#endif


BOOL
pSetupConcatenatePaths(
    IN OUT PTSTR  Target,
    IN     PCTSTR Path,
    IN     UINT   TargetBufferSize,
    OUT    PUINT  RequiredSize          OPTIONAL
    )

/*++

Routine Description:

    Concatenate 2 paths, ensuring that one, and only one,
    path separator character is introduced at the junction point.

Arguments:

    Target - supplies first part of path. Path is appended to this.
        (Target should be a buffer under program control)

    Path - supplies path to be concatenated to Target.
        (Path should be a buffer under program control)

    TargetBufferSize - supplies the size of the Target buffer,
        in characters.

    RequiredSize - if specified, receives the number of characters
        required to hold the fully concatenated path, including
        the terminating nul.

Return Value:

    TRUE if the full path fit in Target buffer. Otherwise the path
    will have been truncated.

--*/

{
    UINT TargetLength,PathLength;
    BOOL TrailingBackslash,LeadingBackslash;
    UINT EndingLength;
    PCTSTR CharTest;

    TargetLength = lstrlen(Target);
    PathLength = lstrlen(Path);

    //
    // See whether the target has a trailing backslash.
    // (allow forward slash here which is symantically equivalent)
    //

    if(TargetLength &&
        ((*(CharTest = CharPrev(Target,Target+TargetLength)) == TEXT('\\'))
         || (*CharTest == TEXT('/')))) {
        TrailingBackslash = TRUE;
        TargetLength--;
    } else {
        TrailingBackslash = FALSE;
    }

    //
    // See whether the path has a leading backshash.
    // (allow forward slash here which is symantically equivalent)
    //
    if((Path[0] == TEXT('\\')) || (Path[0] == TEXT('/'))) {
        LeadingBackslash = TRUE;
        PathLength--;
    } else {
        LeadingBackslash = FALSE;
    }

    //
    // Calculate the ending length, which is equal to the sum of
    // the length of the two strings modulo leading/trailing
    // backslashes, plus one path separator, plus a nul.
    //
    EndingLength = TargetLength + PathLength + 2;
    if(RequiredSize) {
        *RequiredSize = EndingLength;
    }

    if(!LeadingBackslash && (TargetLength < TargetBufferSize)) {
        Target[TargetLength++] = TEXT('\\');
    }

    if(TargetBufferSize > TargetLength) {
        lstrcpyn(Target+TargetLength,Path,TargetBufferSize-TargetLength);
    }

    //
    // Make sure the buffer is nul terminated in all cases.
    //
    if (TargetBufferSize) {
        Target[TargetBufferSize-1] = 0;
    }

    return(EndingLength <= TargetBufferSize);
}

PCTSTR
pSetupGetFileTitle(
    IN PCTSTR FilePath
    )

/*++

Routine Description:

    This routine returns a pointer to the first character in the
    filename part of the supplied path.  If only a filename was given,
    then this will be a pointer to the first character in the string
    (i.e., the same as what was passed in).

    To find the filename part, the routine returns the last component of
    the string, beginning with the character immediately following the
    last '\', '/' (Windows treats '/' as equivalent to '\' ) or initial
    'd:' specification.

Arguments:

    FilePath - Supplies the file path from which to retrieve the filename
        portion.

Return Value:

    A pointer to the beginning of the filename portion of the path.

--*/

{
    PCTSTR LastComponent;
    TCHAR  CurChar;

    if((_totupper(FilePath[0])>=TEXT('A')) &&
       (_totupper(FilePath[0])<=TEXT('Z')) &&
       (FilePath[1] == TEXT(':'))) {
        //
        // x: (drive letter - colon) is skipped, this
        // is the only time we don't treat ':' as part of path name
        //
        FilePath+=2;
    }

    LastComponent = FilePath;

    while(CurChar = *FilePath) {
        FilePath = CharNext(FilePath);
        if((CurChar == TEXT('\\')) || (CurChar == TEXT('/'))) {
            LastComponent = FilePath;
        }
    }

    return LastComponent;
}

#ifndef SPUTILSW

BOOL
_pSpUtilsInitializeSynchronizedAccess(
    OUT PMYLOCK Lock
    )

/*++

Routine Description:

    Initialize a lock structure to be used with Synchronization routines.

Arguments:

    Lock - supplies structure to be initialized. This routine creates
        the locking event and mutex and places handles in this structure.

Return Value:

    TRUE if the lock structure was successfully initialized. FALSE if not.

--*/

{
    if(Lock->Handles[TABLE_DESTROYED_EVENT] = CreateEvent(NULL,TRUE,FALSE,NULL)) {
        if(Lock->Handles[TABLE_ACCESS_MUTEX] = CreateMutex(NULL,FALSE,NULL)) {
            return(TRUE);
        }
        CloseHandle(Lock->Handles[TABLE_DESTROYED_EVENT]);
    }
    return(FALSE);
}


VOID
_pSpUtilsDestroySynchronizedAccess(
    IN OUT PMYLOCK Lock
    )

/*++

Routine Description:

    Tears down a lock structure created by InitializeSynchronizedAccess.
    ASSUMES THAT THE CALLING ROUTINE HAS ALREADY ACQUIRED THE LOCK!

Arguments:

    Lock - supplies structure to be torn down. The structure itself
        is not freed.

Return Value:

    None.

--*/

{
    HANDLE h1,h2;

    h1 = Lock->Handles[TABLE_DESTROYED_EVENT];
    h2 = Lock->Handles[TABLE_ACCESS_MUTEX];

    Lock->Handles[TABLE_DESTROYED_EVENT] = NULL;
    Lock->Handles[TABLE_ACCESS_MUTEX] = NULL;

    CloseHandle(h2);

    SetEvent(h1);
    CloseHandle(h1);
}

VOID
pSetupCenterWindowRelativeToParent(
    HWND hwnd
    )

/*++

Routine Description:

    Centers a dialog relative to its owner, taking into account
    the 'work area' of the desktop.

Arguments:

    hwnd - window handle of dialog to center

Return Value:

    None.

--*/

{
    RECT  rcFrame,
          rcWindow;
    LONG  x,
          y,
          w,
          h;
    POINT point;
    HWND Parent;

    Parent = GetWindow(hwnd,GW_OWNER);
    if(Parent == NULL) {
        return;
    }

    point.x = point.y = 0;
    ClientToScreen(Parent,&point);
    GetWindowRect(hwnd,&rcWindow);
    GetClientRect(Parent,&rcFrame);

    w = rcWindow.right  - rcWindow.left + 1;
    h = rcWindow.bottom - rcWindow.top  + 1;
    x = point.x + ((rcFrame.right  - rcFrame.left + 1 - w) / 2);
    y = point.y + ((rcFrame.bottom - rcFrame.top  + 1 - h) / 2);

    //
    // Get the work area for the current desktop (i.e., the area that
    // the tray doesn't occupy).
    //
    if(!SystemParametersInfo(SPI_GETWORKAREA, 0, (PVOID)&rcFrame, 0)) {
        //
        // For some reason SPI failed, so use the full screen.
        //
        rcFrame.top = rcFrame.left = 0;
        rcFrame.right = GetSystemMetrics(SM_CXSCREEN);
        rcFrame.bottom = GetSystemMetrics(SM_CYSCREEN);
    }

    if(x + w > rcFrame.right) {
        x = rcFrame.right - w;
    } else if(x < rcFrame.left) {
        x = rcFrame.left;
    }
    if(y + h > rcFrame.bottom) {
        y = rcFrame.bottom - h;
    } else if(y < rcFrame.top) {
        y = rcFrame.top;
    }

    MoveWindow(hwnd,x,y,w,h,FALSE);
}

#endif // !SPUTILSW
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\setupapi\sputils\registry.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    registry.c

Abstract:

    Registry interface routines for Windows NT Setup API Dll.

Author:

    Ted Miller (tedm) 6-Feb-1995

Revision History:

    Jamie Hunter (JamieHun) Mar-05-2002
            Security code review

--*/

#include "precomp.h"
#pragma hdrstop

static
BOOL
_RegistryDelnodeWorker(
    IN  HKEY   ParentKeyHandle,
    IN  PCTSTR KeyName,
    IN  DWORD Flags,
    OUT PDWORD ErrorCode
    )

/*++

Routine Description:

    Delete all subkeys of a key whose name and parent's handle was passed as
    parameter.
    The algorithm used in this function guarantees that the maximum number  of
    descendent keys will be deleted.

Arguments:


    ParentKeyHandle - Handle to the parent of the key that is currently being
        examined.

    KeyName - Name of the key that is currently being examined. This name can
        be an empty string (but not a NULL pointer), and in this case
        ParentKeyHandle refers to the key that is being examined.

    ErrorCode - Pointer to a variable that will contain an Win32 error code if
        the function fails.

Return Value:

    BOOL - Returns TRUE if the opearation succeeds.


--*/

{
    HKEY     CurrentKeyTraverseAccess;
    DWORD    iSubKey;
    TCHAR    SubKeyName[MAX_PATH+1];
    DWORD    SubKeyNameLength;
    FILETIME ftLastWriteTime;
    LONG     Status;
    LONG     StatusEnum;
    LONG     SavedStatus;


    //
    // NOTICE-2002/03/11-JamieHun Recursive delete of registry requires special care
    // particularly if running under raised security permissions
    // we have to watch out for symbolic links, and if found, delete the
    // link not what the link refers to
    //

    //
    //  Do not accept NULL pointer for ErrorCode
    //
    if(ErrorCode == NULL) {
        return(FALSE);
    }
    //
    //  Do not accept NULL pointer for KeyName.
    //
    if(KeyName == NULL) {
        *ErrorCode = ERROR_INVALID_PARAMETER;
        return(FALSE);
    }

    //
    // Open a handle to the key whose subkeys are to be deleted.
    // Since we need to delete its subkeys, the handle must have
    // KEY_ENUMERATE_SUB_KEYS access.
    //
    Status = RegOpenKeyEx(
                ParentKeyHandle,
                KeyName,
                REG_OPTION_OPEN_LINK, // don't follow links, delete them
#ifdef _WIN64
                (( Flags & FLG_DELREG_32BITKEY ) ? KEY_WOW64_32KEY:0) |
#else
                (( Flags & FLG_DELREG_64BITKEY ) ? KEY_WOW64_64KEY:0) |
#endif
                KEY_ENUMERATE_SUB_KEYS | DELETE,
                &CurrentKeyTraverseAccess
                );

    if(Status != ERROR_SUCCESS) {
        //
        //  If unable to enumerate the subkeys, return error.
        //
        *ErrorCode = Status;
        return(FALSE);
    }

    //
    //  Traverse the key
    //
    iSubKey = 0;
    SavedStatus = ERROR_SUCCESS;
    do {
        //
        // Get the name of a subkey
        //
        SubKeyNameLength = SIZECHARS(SubKeyName);
        StatusEnum = RegEnumKeyEx(
                        CurrentKeyTraverseAccess,
                        iSubKey,
                        SubKeyName,
                        &SubKeyNameLength,
                        NULL,
                        NULL,
                        NULL,
                        &ftLastWriteTime
                        );

        if(StatusEnum == ERROR_SUCCESS) {
            //
            // Delete all children of the subkey.
            // Just assume that the children will be deleted, and don't check
            // for failure.
            //
            _RegistryDelnodeWorker(CurrentKeyTraverseAccess,SubKeyName,0,&Status);
            //
            // Now delete the subkey, and check for failure.
            //
            Status = RegDeleteKey(CurrentKeyTraverseAccess,SubKeyName);
            //
            // If unable to delete the subkey, then save the error code.
            // Note that the subkey index is incremented only if the subkey
            // was not deleted.
            //
            if(Status != ERROR_SUCCESS) {
                iSubKey++;
                SavedStatus = Status;
            }
        } else {
            //
            // If unable to get a subkey name due to ERROR_NO_MORE_ITEMS,
            // then the key doesn't have subkeys, or all subkeys were already
            // enumerated. Otherwise, an error has occurred, so just save
            // the error code.
            //
            if(StatusEnum != ERROR_NO_MORE_ITEMS) {
                SavedStatus = StatusEnum;
            }
        }
        //if((StatusEnum != ERROR_SUCCESS ) && (StatusEnum != ERROR_NO_MORE_ITEMS)) {
        //    printf( "RegEnumKeyEx() failed, Key Name = %ls, Status = %d, iSubKey = %d \n",KeyName,StatusEnum,iSubKey);
        //}
    } while(StatusEnum == ERROR_SUCCESS);

    //
    // Close the handle to the key whose subkeys were deleted, and return
    // the result of the operation.
    //
    RegCloseKey(CurrentKeyTraverseAccess);

    if(SavedStatus != ERROR_SUCCESS) {
        *ErrorCode = SavedStatus;
        return(FALSE);
    }
    return(TRUE);
}

DWORD
pSetupRegistryDelnodeEx(
    IN  HKEY   RootKey,
    IN  PCTSTR SubKeyName,
    IN  DWORD  ExtraFlags
    )
/*++

Routine Description:

    This routine deletes a registry key and gets rid of everything under it recursively.

Arguments:

    RootKey - Supplies handle to open registry key..ex. HKLM etc.

    SubKeyName - Name of the SubKey that we wish to recursively delete.

    ExtraFlags - Flags that are specified in the DelReg section of the INF.

Return Value:

    If successful, the return value is NO_ERROR, otherwise, it is an error code.

--*/
{
    DWORD d,err,Status;
    HKEY hKey;
    PTSTR p;
    PTSTR TempKey = NULL;


    d = _RegistryDelnodeWorker(RootKey,SubKeyName,ExtraFlags,&err) ? NO_ERROR : err;

    if((d == ERROR_FILE_NOT_FOUND) || (d == ERROR_PATH_NOT_FOUND)) {
        d = NO_ERROR;
    }

    if(d == NO_ERROR) {
        //
        // Delete top-level key
        //


#ifdef _WIN64
        if( ExtraFlags & FLG_DELREG_32BITKEY ) {
#else
        if( ExtraFlags & FLG_DELREG_64BITKEY ) {
#endif

            //
            // For handling the WOW64 case:
            // deleting RootKey\SubKeyName by itself won't work
            // split subkeyname into parent\final
            // open parent for 32-bit access, and delete final
            //
            TempKey = pSetupDuplicateString(SubKeyName);
            if(TempKey) {

                p = _tcsrchr(TempKey, TEXT('\\'));
                if(p){
                    *p++ = TEXT('\0');

                    d = RegOpenKeyEx(
                            RootKey,
                            TempKey,
                            0,
#ifdef _WIN64
                            KEY_WOW64_32KEY |
#else
                            KEY_WOW64_64KEY |
#endif
                            DELETE,
                            &hKey
                            );

                    d = RegDeleteKey(hKey, p);

                }else{

                   d = NO_ERROR;

                }
                pSetupFree( TempKey );

            }else{
                d = ERROR_NOT_ENOUGH_MEMORY;
            }
        }else{
            //
            // native case
            //
            d = RegDeleteKey(RootKey, SubKeyName);
        }

        if((d == ERROR_FILE_NOT_FOUND) || (d == ERROR_PATH_NOT_FOUND)) {
            //
            // FUTURE-2002/03/13-JamieHun Logging
            //   At a verbose level, log that this key wasn't found
            //
            d = NO_ERROR;
        }
    }

    return(d);
}

DWORD
pSetupRegistryDelnode(
    IN  HKEY   RootKey,
    IN  PCTSTR SubKeyName
    )
{
    // Calls into Ex Function

    return pSetupRegistryDelnodeEx( RootKey, SubKeyName, 0);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\setupapi\sputils\security.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    security.c

Abstract:

    Routines to deal with security-related stuff.

    Externally exposed routines:

        pSetupIsUserAdmin
        pSetupDoesUserHavePrivilege
        pSetupEnablePrivilege

Author:

    Ted Miller (tedm) 14-Jun-1995

Revision History:

    Jamie Hunter (jamiehun) Jun-27-2000
                Moved functions to sputils

    Jamie Hunter (JamieHun) Mar-18-2002
            Security code review

--*/

#include "precomp.h"
#include <lmaccess.h>
#pragma hdrstop


#ifndef SPUTILSW

BOOL
pSetupIsUserAdmin(
    VOID
    )

/*++

Routine Description:

    This routine returns TRUE if the caller's process is a member of the
    administrator group

    Caller MAY be impersonating someone.

Arguments:

    None.

Return Value:

    TRUE - Caller is effectively an Administrator

    FALSE - Caller is not an Administrator

--*/

{
    BOOL b;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
    PSID AdministratorsGroup;

    b = AllocateAndInitializeSid(&NtAuthority,
                                 2,
                                 SECURITY_BUILTIN_DOMAIN_RID,
                                 DOMAIN_ALIAS_RID_ADMINS,
                                 0,
                                 0,
                                 0,
                                 0,
                                 0,
                                 0,
                                 &AdministratorsGroup
                                );

    if (b) {

        if (!CheckTokenMembership(NULL,
                                  AdministratorsGroup,
                                  &b
                                 )) {
            b = FALSE;
        }

        FreeSid(AdministratorsGroup);
    }

    return(b);
}

#endif // !SPUTILSW

BOOL
pSetupDoesUserHavePrivilege(
    PCTSTR PrivilegeName
    )

/*++

Routine Description:

    This routine returns TRUE if the thread (which may be impersonating) has
    the specified privilege.  The privilege does not have
    to be currently enabled.  This routine is used to indicate
    whether the caller has the potential to enable the privilege.

    Caller MAY be impersonating someone and IS
    expected to be able to open their own thread and thread
    token.

Arguments:

    Privilege - the name form of privilege ID (such as
        SE_SECURITY_NAME).

Return Value:

    TRUE - Caller has the specified privilege.

    FALSE - Caller does not have the specified privilege.

--*/

{
    HANDLE Token;
    ULONG BytesRequired;
    PTOKEN_PRIVILEGES Privileges;
    BOOL b;
    DWORD i;
    LUID Luid;

    //
    // Open the thread token.
    //
    if(!OpenThreadToken(GetCurrentThread(),TOKEN_QUERY,FALSE,&Token)) {
        if(GetLastError() != ERROR_NO_TOKEN) {
            return FALSE;
        }
        if(!OpenProcessToken(GetCurrentProcess(),TOKEN_QUERY,&Token)) {
            return FALSE;
        }
    }

    b = FALSE;
    Privileges = NULL;

    //
    // Get privilege information.
    //
    if(!GetTokenInformation(Token,TokenPrivileges,NULL,0,&BytesRequired)
    && (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
    && (Privileges = pSetupCheckedMalloc(BytesRequired))
    && GetTokenInformation(Token,TokenPrivileges,Privileges,BytesRequired,&BytesRequired)
    && LookupPrivilegeValue(NULL,PrivilegeName,&Luid)) {

        //
        // See if we have the requested privilege
        //
        for(i=0; i<Privileges->PrivilegeCount; i++) {

            if((Luid.LowPart  == Privileges->Privileges[i].Luid.LowPart)
            && (Luid.HighPart == Privileges->Privileges[i].Luid.HighPart)) {

                b = TRUE;
                break;
            }
        }
    }

    //
    // Clean up and return.
    //

    if(Privileges) {
        pSetupFree(Privileges);
    }

    CloseHandle(Token);

    return(b);
}


BOOL
pSetupEnablePrivilege(
    IN PCTSTR PrivilegeName,
    IN BOOL   Enable
    )

/*++

Routine Description:

    Enable or disable a given named privilege for current ****PROCESS****
    Any code that requires to change privilege per thread should not use this
    routine.
    It remains here for compatability only and will be depreciated as soon
    as dependents change (it's used by a few setup routines where it's fine
    to enable process priv's)

Arguments:

    PrivilegeName - supplies the name of a system privilege.

    Enable - flag indicating whether to enable or disable the privilege.

Return Value:

    Boolean value indicating whether the operation was successful.

--*/

{
    HANDLE Token;
    BOOL b;
    TOKEN_PRIVILEGES NewPrivileges;
    LUID Luid;

    if(!OpenProcessToken(GetCurrentProcess(),TOKEN_ADJUST_PRIVILEGES,&Token)) {
        return(FALSE);
    }

    if(!LookupPrivilegeValue(NULL,PrivilegeName,&Luid)) {
        CloseHandle(Token);
        return(FALSE);
    }

    NewPrivileges.PrivilegeCount = 1;
    NewPrivileges.Privileges[0].Luid = Luid;
    NewPrivileges.Privileges[0].Attributes = Enable ? SE_PRIVILEGE_ENABLED : 0;

    b = AdjustTokenPrivileges(
            Token,
            FALSE,
            &NewPrivileges,
            0,
            NULL,
            NULL
            );

    CloseHandle(Token);

    return(b);
}


static
PSID
_GetUserSid(
    IN  HANDLE  hUserToken
    )

/*++

Routine Description:

    Retrieves the corresponding user SID for the specified user access token.

Arguments:

    hUserToken - Specifies a handle to a user access token.

Return Value:

    If successful, returns a pointer to an allocated buffer containing the SID
    for the specified user access token.  Otherwise, returns NULL.
    GetLastError can be called to retrieve information pertaining to the error
    encountered.

Notes:

    If successful, it is responsibility of the caller to free the the returned
    buffer with pSetupFree.

--*/

{
    DWORD cbBuffer, cbRequired;
    PTOKEN_USER pUserInfo = NULL;
    PSID pUserSid = NULL;
    DWORD Err;

    try {
        //
        // Determine the size of buffer we need to store the TOKEN_USER information
        // for the supplied user access token.  The TOKEN_USER structure contains
        // the SID_AND_ATTRIBUTES information for the User.
        //
        cbBuffer = 0;

        Err = GLE_FN_CALL(FALSE,
                          GetTokenInformation(hUserToken,
                                              TokenUser,
                                              NULL,
                                              cbBuffer,
                                              &cbRequired)
                         );

        //
        // We'd better not succeed, since we supplied no buffer!
        //
        ASSERT(Err != NO_ERROR);

        if(Err == NO_ERROR) {
            Err = ERROR_INVALID_DATA;
        }

        if(Err != ERROR_INSUFFICIENT_BUFFER) {
            leave;
        }

        ASSERT(cbRequired > 0);

        //
        // Allocate a buffer for the TOKEN_USER data.
        //
        cbBuffer = cbRequired;

        pUserInfo = (PTOKEN_USER)pSetupCheckedMalloc(cbBuffer);

        if(!pUserInfo) {
            Err = ERROR_NOT_ENOUGH_MEMORY;
            leave;
        }

        //
        // Retrieve the TOKEN_USER data.
        //
        Err = GLE_FN_CALL(FALSE,
                          GetTokenInformation(hUserToken,
                                              TokenUser,
                                              pUserInfo,
                                              cbBuffer,
                                              &cbRequired)
                         );

        if(Err != NO_ERROR) {
            leave;
        }

        MYASSERT(pUserInfo->User.Sid != NULL);

        //
        // Check that the returned SID is valid.
        // Note - calling GetLastError is not valid for IsValidSid!
        //
        MYASSERT(IsValidSid(pUserInfo->User.Sid));

        if(!IsValidSid(pUserInfo->User.Sid)) {
            Err = ERROR_INVALID_DATA;
            leave;
        }

        //
        // Make a copy of the User SID_AND_ATTRIBUTES.
        //
        cbBuffer = GetLengthSid(pUserInfo->User.Sid);

        MYASSERT(cbBuffer > 0);

        pUserSid = (PSID)pSetupCheckedMalloc(cbBuffer);

        if(!pUserSid) {
            Err = ERROR_NOT_ENOUGH_MEMORY;
            leave;
        }

        Err = GLE_FN_CALL(FALSE, CopySid(cbBuffer, pUserSid, pUserInfo->User.Sid));

        if(Err != NO_ERROR) {
            leave;
        }

        //
        // Check that the returned SID is valid.
        // Note - calling GetLastError is not valid for IsValidSid!
        //
        MYASSERT(IsValidSid(pUserSid));

        if(!IsValidSid(pUserSid)) {
            Err = ERROR_INVALID_DATA;
            leave;
        }

    } except(_pSpUtilsExceptionFilter(GetExceptionCode())) {
        _pSpUtilsExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, &Err);
    }

    if(pUserInfo) {
        pSetupFree(pUserInfo);
    }

    if(Err == NO_ERROR) {
        MYASSERT(pUserSid);
    } else if(pUserSid) {
        pSetupFree(pUserSid);
        pUserSid = NULL;
    }

    SetLastError(Err);
    return pUserSid;

} // _GetUserSid


BOOL
pSetupIsLocalSystem(
    VOID
    )

/*++

Routine Description:

    This function detects whether the process is running in LocalSystem
    security context.

Arguments:

    none.

Return Value:

    If this process is running in LocalSystem, the return value is non-zero
    (i.e., TRUE).  Otherwise, the return value is FALSE.  If FALSE is returned,
    GetLastError returns more information about the reason.  If the function
    encountered no problem when retrieving/comparing the SIDs, GetLastError()
    will return ERROR_FUNCTION_FAILED.  Otherwise, it will return another
    Win32 error code indicating the cause of failure.

--*/

{
    DWORD  Err;
    HANDLE hToken = NULL;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
    PSID   pUserSid = NULL, pLocalSystemSid = NULL;

    try {
        //
        // Attempt to open the thread token, to see if we are impersonating.
        //
        Err = GLE_FN_CALL(FALSE,
                          OpenThreadToken(GetCurrentThread(),
                                          MAXIMUM_ALLOWED, 
                                          TRUE, 
                                          &hToken)
                         );

        if(Err == ERROR_NO_TOKEN) {
            //
            // Not impersonating, attempt to open the process token.
            //
            Err = GLE_FN_CALL(FALSE,
                              OpenProcessToken(GetCurrentProcess(),
                                               MAXIMUM_ALLOWED, 
                                               &hToken)
                             );
        }

        if(Err != NO_ERROR) {
            //
            // Ensure hToken is still NULL so we won't try and free it later.
            //
            hToken = NULL;
            leave;
        }

        MYASSERT(hToken);

        //
        // Retrieve the user SID.
        //
        Err = GLE_FN_CALL(NULL, pUserSid = _GetUserSid(hToken));

        if(Err != NO_ERROR) {
            leave;
        }

        //
        // Create the LocalSystem SID
        //
        Err = GLE_FN_CALL(FALSE,
                          AllocateAndInitializeSid(&NtAuthority, 
                                                   1,
                                                   SECURITY_LOCAL_SYSTEM_RID,
                                                   0, 
                                                   0, 
                                                   0, 
                                                   0, 
                                                   0, 
                                                   0, 
                                                   0, 
                                                   &pLocalSystemSid)
                         );

        if(Err != NO_ERROR) {
            leave;
        }

        MYASSERT(pLocalSystemSid);

        //
        // Check that the returned SID is valid.  We must check this ourselves
        // because if either SID supplied to IsEquialSid is not valid, the 
        // return value is undefined.
        //
        MYASSERT(IsValidSid(pLocalSystemSid));

        //
        // Note - calling GetLastError is not valid for IsValidSid!
        //
        if(!IsValidSid(pLocalSystemSid)) {
            Err = ERROR_INVALID_DATA;
            leave;
        }

        //
        // Check if the two SIDs are equal.
        //
        if(!EqualSid(pUserSid, pLocalSystemSid)) {
            //
            // EqualSid doesn't set last error when SIDs are valid but 
            // different, so we need to set an unsuccessful error here 
            // ourselves.
            //
            Err = ERROR_FUNCTION_FAILED;
            leave;
        }

        //
        // Our SID equals LocalSystem SID, so we know we're running in 
        // LocalSystem!  (Err is already set to NO_ERROR, which is our signal
        // to return TRUE from this routine)
        //

    } except(_pSpUtilsExceptionFilter(GetExceptionCode())) {
        _pSpUtilsExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, &Err);
    }

    if(pLocalSystemSid) {
        FreeSid(pLocalSystemSid);
    }

    if(pUserSid) {
        pSetupFree(pUserSid);
    }

    if(hToken) {
        CloseHandle(hToken);
    }

    SetLastError(Err);
    return(Err == NO_ERROR);

} // pSetupIsLocalSystem
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\setupapi\sputils\common.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    common.h

Abstract:

    Private header file for sputils

Author:

    Jamie Hunter (JamieHun) Jun-27-2000

Revision History:

--*/

//
// internally we may use some definitions from these files
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <windowsx.h>
#include <stddef.h>
#include <regstr.h>
#include <tchar.h>
#include <malloc.h>   // for _resetstkoflw
#include <setupapi.h>
#include <spapip.h>
#include "strtab.h"
#include "locking.h"


//
// if a function is private to this library, we don't want to collide with functions
// in other libraries etc
// since C doesn't have namespaces, either make "static" or prefix _pSpUtils
//

#ifndef ASSERTS_ON
#if DBG
#define ASSERTS_ON 1
#else
#define ASSERTS_ON 0
#endif
#endif

#if DBG
#ifndef MEM_DBG
#define MEM_DBG 1
#endif
#else
#ifndef MEM_DBG
#define MEM_DBG 0
#endif
#endif

VOID
_pSpUtilsAssertFail(
    IN PCSTR FileName,
    IN UINT LineNumber,
    IN PCSTR Condition
    );

#if ASSERTS_ON

#define MYASSERT(x)     if(!(x)) { _pSpUtilsAssertFail(__FILE__,__LINE__,#x); }
#define MYVERIFY(x)     ((x)? TRUE : _pSpUtilsAssertFail(__FILE__,__LINE__,#x), FALSE)

#else

#define MYASSERT(x)
#define MYVERIFY(x)     ((x)? TRUE : FALSE)

#e