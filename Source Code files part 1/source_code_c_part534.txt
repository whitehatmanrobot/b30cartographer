}

    //
    //  Is this a DBCS locale?
    //

    WORD wPrimaryLangID = PRIMARYLANGID( GetSystemDefaultLangID() );

    m_fIsDBCS =  ((wPrimaryLangID == LANG_JAPANESE) ||
                  (wPrimaryLangID == LANG_CHINESE)  ||
                  (wPrimaryLangID == LANG_KOREAN) );


    if ( !m_EventLog.Success() ) {

        DBGPRINTF(( DBG_CONTEXT,
                    " Eventlog not initialized\n"));

        if ( GetLastError() != ERROR_ACCESS_DENIED )
        {
            DBG_ASSERT( m_state != BlockStateActive);
            errInit = GetLastError();

            //
            //  Skip anything else that might fail since we don't have an
            //  event log object
            //

            goto Exit;
        }
    }

    //
    //  If we failed to open the service path in the metabase above, bail
    //  out of the initialization
    //

    if ( errInit )
    {
        const CHAR * apsz[1];
        apsz[0] = QueryMDPath();

        LogEvent( INET_SVC_INVALID_MB_PATH,
                  1,
                  (const CHAR **) apsz,
                  errInit );

        goto Exit;
    }

    //
    // Get module name
    //

    m_hModule = GetModuleHandle( pszModuleName);
    if ( m_hModule == NULL ) {

        CHAR * apsz[1];

        errInit = GetLastError();

        apsz[0] = (PCHAR)pszModuleName;
        m_EventLog.LogEvent( INET_SVC_GET_MODULE_FAILED,
                           1,
                           (const CHAR**)apsz,
                           errInit );
        DBG_ASSERT( m_state != BlockStateActive);

        goto Exit;
    }

    //
    // Init others
    //

    if ( MultipleInstanceSupport ) {
        m_strServiceComment.Copy(DEF_MULTI_SERVER_COMMENT_A);
    }

    //
    // Create pending shutdown event
    //

    m_hPendingShutdownEvent = CreateEvent( NULL,
                                           FALSE,
                                           FALSE,
                                           NULL );
    if ( m_hPendingShutdownEvent == NULL )
    {
        errInit = GetLastError();
        goto Exit;
    }

Exit:
    //
    // Add ourself to the list - Note we must always get on this list as the
    // destructor assumes this.
    //

    AcquireGlobalLock( );

    InsertHeadList( & sm_ServiceInfoListHead, &m_ServiceListEntry );

    if ( errInit == NO_ERROR )
    {
        //
        // put service information into metabase
        //

        AdvertiseServiceInformationInMB( );

        //
        // we're on. now set the state to be active!
        //

        m_state = BlockStateActive;
    }

    ReleaseGlobalLock( );

    //
    //  Initialize the service status structure.
    //

    m_svcStatus.dwServiceType             = SERVICE_WIN32_SHARE_PROCESS;
    m_svcStatus.dwCurrentState            = SERVICE_STOPPED;
    m_svcStatus.dwControlsAccepted        = SERVICE_ACCEPT_STOP
                                              | SERVICE_ACCEPT_PAUSE_CONTINUE
                                              | SERVICE_ACCEPT_SHUTDOWN;
    m_svcStatus.dwWin32ExitCode           = errInit;
    m_svcStatus.dwServiceSpecificExitCode = errInit;
    m_svcStatus.dwCheckPoint              = 0;
    m_svcStatus.dwWaitHint                = 0;

    return;

} // IIS_SERVICE::IIS_SERVICE()



IIS_SERVICE::~IIS_SERVICE( VOID)
/*++

    Description:

        Cleanup the TsvcInfo object. If the service is not already
         terminated, it terminates the service before cleanup.

    Arguments:
        None

    Returns:
        None


--*/
{

    IF_DEBUG(INSTANCE) {
        DBGPRINTF((DBG_CONTEXT,"~IIS_SERVICE: nRef %d nInstances %d\n",
            m_reference, m_nInstance));
    }

    DBG_ASSERT( m_reference == 0 );
    DBG_ASSERT( IsListEmpty(&m_InstanceListHead) );
    DBG_ASSERT( IsListEmpty(&m_EndpointListHead) );
    DBG_ASSERT( m_dwShutdownScheduleId == 0);

    if ( m_hShutdownEvent != NULL ) {
        DBG_REQUIRE(CloseHandle(m_hShutdownEvent));
        m_hShutdownEvent = NULL;
    }

    if ( m_hPendingShutdownEvent != NULL )
    {
        DBG_REQUIRE( CloseHandle( m_hPendingShutdownEvent ) );
        m_hPendingShutdownEvent = NULL;
    }

    //
    // remove from global list
    //

    AcquireGlobalLock( );
    RemoveEntryList( &m_ServiceListEntry );
    ReleaseGlobalLock( );

#if SERVICE_REF_TRACKING
    DestroyRefTraceLog( m_pDbgRefTraceLog );
#endif // SERVICE_REF_TRACKING

    DeleteCriticalSection( &m_lock );
} // IIS_SERVICE::~IIS_SERVICE()



DWORD
IIS_SERVICE::StartServiceOperation(
    IN  PFN_SERVICE_CTRL_HANDLER         pfnCtrlHandler,
    IN  PFN_SERVICE_SPECIFIC_INITIALIZE  pfnInitialize,
    IN  PFN_SERVICE_SPECIFIC_CLEANUP     pfnCleanup
    )
/*++
    Description:

        Starts the operation of service instantiated in the given
           Service Info Object.


    Arguments:

        pfnCtrlHandler
            pointer to a callback function for handling dispatch of
            service controller requests. A separate function is required
            since Service Controller call back function does not send
            context information.

        pfnInitialize
            pointer to a callback function implemented by the service DLL;
            the callback is responsible for all ServiceSpecific initializations

        pfnCleanup
            pointer to a callback function implemented by the service DLL;
            the callback is responsible for all ServiceSpecific Cleanups

    Returns:

        NO_ERROR on success and Win32 error code if any failure.
--*/
{

    DWORD err;
    DWORD cbBuffer;
    BOOL  fInitCalled = FALSE;

    DBG_ASSERT((pfnInitialize != NULL) && (pfnCleanup != NULL));

    if ( !IsActive()) {

        //
        // Not successfully initialized.
        //

        DBGPRINTF((DBG_CONTEXT,
            "Service not ready. Failing StartServiceOperation\n"));
        return ( ERROR_NOT_READY );
    }

    //
    //  Create shutdown event.
    //

    DBG_ASSERT(m_hShutdownEvent == NULL);
    m_hShutdownEvent = CreateEvent( NULL,           //  lpsaSecurity
                                    TRUE,           //  fManualReset
                                    FALSE,          //  fInitialState
                                    NULL
                                    );

    if( m_hShutdownEvent == NULL ) {

        err = GetLastError();

        DBGPRINTF(( DBG_CONTEXT,
                    "InitializeService(): Cannot create shutdown event,"
                     " error %lu\n", err ));

        goto Cleanup;
    }

    m_hsvcStatus = RegisterServiceCtrlHandler(
                        QueryServiceName(),
                        pfnCtrlHandler
                        );

    //
    //  Register the Control Handler routine.
    //

    if( m_hsvcStatus == NULL_SERVICE_STATUS_HANDLE ) {

        err = GetLastError();

        DBGPRINTF( ( DBG_CONTEXT,
                    "cannot connect to register ctrl handler, error %lu\n",
                     err )
                 );


        goto Cleanup;
    }

    //
    //  Indicate to the service that we are starting up,
    //  Update the service status.
    //

    err = UpdateServiceStatus( SERVICE_START_PENDING,
                               NO_ERROR,
                               1,
                               IIS_SERVICE_START_WAIT_HINT
                               );

    if( err != NO_ERROR ) {

        DBGPRINTF( ( DBG_CONTEXT,
                    "StartServiceOperation(): cannot update service status,"
                    " error %lu\n",
                    err )
                  );

        goto Cleanup;
    }

    //
    //  Initialize the various service specific components.
    //

    m_dwNextSCMUpdateTime = GetCurrentTimeInSeconds() + IIS_SERVICE_START_WAIT_HINT_SECONDS / 2;
    m_dwStartUpIndicatorCalls = 0;
    m_dwClientStartActivityIndicator = 1;

    if ( pfnInitialize != NULL ) {

        err = ( *pfnInitialize)( this);
        fInitCalled = TRUE;

        if( err != NO_ERROR ) {

            DBGPRINTF( ( DBG_CONTEXT,
                       " Initialization of service failed with %d\n",
                        err));

            goto Cleanup;
        }
    }

    //
    //  We are done with all initializatios, Update the service status.
    //


    err = UpdateServiceStatus( SERVICE_RUNNING,
                               NO_ERROR,
                               0,
                               0 );

    if( err != NO_ERROR ) {
        DBGPRINTF( ( DBG_CONTEXT, "cannot update service status, error %lu\n",
                     err )
                );

        goto Cleanup;
    }

    //
    //  Wait for the shutdown event.
    //

    DBGPRINTF( ( DBG_CONTEXT,
                 "IIS_SERVICE(%08p) %s - Waiting for ShutDown Event ...\n",
                 this, QueryServiceName()
                 ));

#if 0
    err = WaitForSingleObject( m_hShutdownEvent,
                               INFINITE );

    if ( err != WAIT_OBJECT_0) {

        //
        // Error. Unable to wait for single object.
        //

        DBGPRINTF( ( DBG_CONTEXT,
                    "Wait for single object failed with Error %lu\n",
                    err )
                 );
    }
#else

    while ( TRUE ) {

        MSG msg;

        //
        // Need to do MsgWait instead of WaitForSingleObject
        // to process windows msgs.  We now have a window
        // because of COM.
        //

        err = MsgWaitForMultipleObjects( 1,
                                         &m_hShutdownEvent,
                                         FALSE,
                                         INFINITE,
                                         QS_ALLINPUT );

        if ( err == WAIT_OBJECT_0 ) {
            break;
        }

        while ( PeekMessage( &msg,
                             NULL,
                             0,
                             0,
                             PM_REMOVE ))
        {
            DispatchMessage( &msg );
        }
    }

#endif

    err = NO_ERROR;

    //
    //  Stop time.  Tell the Service Controller that we're stopping,
    //  then terminate the various service components.
    //

    UpdateServiceStatus( SERVICE_STOP_PENDING,
                         0,
                         1,
                         SERVICE_STOP_WAIT_HINT );

Cleanup:

    if ( fInitCalled && (pfnCleanup != NULL) ) {

        //
        // 1. Register a scheduled work item for periodic update to the
        //    Service Controller while shutdown is happening in this thread
        //    (Reason: Shutdown takes far longer time
        //          than SERVICE_STOP_WAIT_HINT)
        //

        m_nShutdownIndicatorCalls = 0;

        DBG_ASSERT( m_dwShutdownScheduleId == 0);
        m_dwShutdownScheduleId =
            ScheduleWorkItem( ServiceShutdownIndicator,
                              this,
                              MS_SERVICE_SHUTDOWN_INDICATOR_TIME_INTERVAL,
                              TRUE );     // Periodic

        if ( m_dwShutdownScheduleId == 0) {
            DBGPRINTF(( DBG_CONTEXT,
                        "ScheduleShutdown for Service(%s) failed."
                        " Error = %d\n",
                        QueryServiceName(),
                        GetLastError()
                        ));
        }

        //
        // 2. Stop all endpoints for the service
        //

        IF_DEBUG( INSTANCE ) {
            DBGPRINTF(( DBG_CONTEXT,
                        "IIS_SERVICE(%08p) Stopping all endpoints for %s\n",
                        this, QueryServiceName()
                        ));
        }

        DBG_REQUIRE( EnumServiceInstances( NULL, NULL,
                                           I_StopInstanceEndpoint)
                     );

        //
        // 3. Cleanup partially initialized modules
        //

        DWORD err1 = ( *pfnCleanup)( this);


        // calls MB.Save so that next MB.Save will be fast
        // and will not cause delay during shutdown
        {
            DBGPRINTF(( DBG_CONTEXT,"[IIS_SERVICE::StartServiceOperation] Pre-Saving Metabase\n" ));

            MB     mb( (IMDCOM*) IIS_SERVICE::QueryMDObject() );
            mb.Save();
        }

        DBGPRINTF((DBG_CONTEXT,"Cleanup done\n"));

        if ( err1 != NO_ERROR )
        {
            if ( err1 != ERROR_IO_PENDING )
            {
                //
                // Compound errors possible
                //

                if ( err != NO_ERROR) {

                    DBGPRINTF( ( DBG_CONTEXT,
                               " Error %d occured during cleanup of service %s\n",
                               err1, QueryServiceName()));
                }
            }
        }

        if ( err1 == ERROR_IO_PENDING )
        {
            //
            // Shutdown is not complete yet.  Wait for it to complete
            //

            WaitForSingleObject( m_hPendingShutdownEvent, INFINITE );
        }

        //
        // 4. If present, remove the scheduled work item
        //
        if ( m_dwShutdownScheduleId != 0) {
            RemoveWorkItem( m_dwShutdownScheduleId);
            m_dwShutdownScheduleId = 0;
        }
    }

    //
    //  If we managed to actually connect to the Service Controller,
    //  then tell it that we're stopped.
    //

    if( m_hsvcStatus != NULL_SERVICE_STATUS_HANDLE ) {
        UpdateServiceStatus( SERVICE_STOPPED,
                             err,
                             0,
                             0 );
    }

    return ( err);

} // IIS_SERVICE::StartServiceOperation()

VOID
IIS_SERVICE::IndicateShutdownComplete(
    VOID
)
/*++

Routine Description:

    Used by services which return ERROR_IO_PENDING in their TerminateService
    routines.  In this case, they should use this method to indicate
    that shutdown is complete.

Arguments:

    None

Return Value:

    None

--*/
{
    if ( m_hPendingShutdownEvent )
    {
        SetEvent( m_hPendingShutdownEvent );
    }
}


DWORD
IIS_SERVICE::UpdateServiceStatus(
        IN DWORD dwState,
        IN DWORD dwWin32ExitCode,
        IN DWORD dwCheckPoint,
        IN DWORD dwWaitHint
        )
/*++
    Description:

        Updates the local copy status of service controller status
         and reports it to the service controller.

    Arguments:

        dwState - New service state.

        dwWin32ExitCode - Service exit code.

        dwCheckPoint - Check point for lengthy state transitions.

        dwWaitHint - Wait hint for lengthy state transitions.

    Returns:

        NO_ERROR on success and returns Win32 error if failure.
        On success the status is reported to service controller.

--*/
{
    m_svcStatus.dwCurrentState  = dwState;
    m_svcStatus.dwWin32ExitCode = dwWin32ExitCode;
    m_svcStatus.dwCheckPoint    = dwCheckPoint;
    m_svcStatus.dwWaitHint      = dwWaitHint;

    return ReportServiceStatus();

} // IIS_SERVICE::UpdateServiceStatus()



DWORD
IIS_SERVICE::ReportServiceStatus( VOID)
/*++
    Description:

        Wraps the call to SetServiceStatus() function.
        Prints the service status data if need be

    Arguments:

        None

    Returns:

        NO_ERROR if successful. other Win32 error code on failure.
        If successfull the new status has been reported to the service
         controller.
--*/
{
    DWORD err = NO_ERROR;

    IF_DEBUG( DLL_SERVICE_INFO)   {

          DBGPRINTF(( DBG_CONTEXT, "dwServiceType             = %08lX\n",
                     m_svcStatus.dwServiceType ));

          DBGPRINTF(( DBG_CONTEXT, "dwCurrentState            = %08lX\n",
                     m_svcStatus.dwCurrentState ));

          DBGPRINTF(( DBG_CONTEXT, "dwControlsAccepted        = %08lX\n",
                     m_svcStatus.dwControlsAccepted ));

          DBGPRINTF(( DBG_CONTEXT, "dwWin32ExitCode           = %08lX\n",
                     m_svcStatus.dwWin32ExitCode ));

          DBGPRINTF(( DBG_CONTEXT, "dwServiceSpecificExitCode = %08lX\n",
                     m_svcStatus.dwServiceSpecificExitCode ));

          DBGPRINTF(( DBG_CONTEXT, "dwCheckPoint              = %08lX\n",
                     m_svcStatus.dwCheckPoint ));

          DBGPRINTF(( DBG_CONTEXT, "dwWaitHint                = %08lX\n",
                     m_svcStatus.dwWaitHint ));
    }

    IF_DEBUG(DLL_SERVICE_INFO) {
        DBGPRINTF(( DBG_CONTEXT,
               " Setting Service Status for %s to %d\n",
               QueryServiceName(), m_svcStatus.dwCurrentState)
              );
    }

    if( !SetServiceStatus( m_hsvcStatus, &m_svcStatus ) ) {

        err = GetLastError();
    }

    return err;
}   // IIS_SERVICE::ReportServiceStatus()



VOID
IIS_SERVICE::ServiceCtrlHandler (
                    IN DWORD dwOpCode
                    )
/*++
    Description:

        This function received control requests from the service controller.
        It runs in the context of service controller's dispatcher thread and
        performs the requested function.
        ( Note: Avoid time consuming operations in this function.)

    Arguments:

        dwOpCode
            indicates the requested operation. This should be
            one of the SERVICE_CONTROL_* manifests.


    Returns:
        None. If successful, then the state of the service might be changed.

    Note:
        if an operation ( especially SERVICE_CONTROL_STOP) is very lengthy,
         then this routine should report a STOP_PENDING status and create
         a worker thread to do the dirty work. The worker thread would then
         perform the necessary work and for reporting timely wait hints and
         final SERVICE_STOPPED status.

    History:
        KeithMo     07-March-1993  Created
        MuraliK     15-Nov-1994    Generalized it for all services.
--*/
{
    //
    //  Interpret the opcode and let the worker functions update the state.
    //  Also let the workers to update service state as appropriate
    //

    switch( dwOpCode ) {

    case SERVICE_CONTROL_INTERROGATE :
        InterrogateService();
        break;

    case SERVICE_CONTROL_STOP :
    case SERVICE_CONTROL_SHUTDOWN :
        StopService();
        break;

    case SERVICE_CONTROL_PAUSE :
        PauseService();
        break;

    case SERVICE_CONTROL_CONTINUE :
        ContinueService();
        break;


    default :
        DBGPRINTF(( DBG_CONTEXT, "Unrecognized Service Opcode %lu\n",
                     dwOpCode ));
        break;
    }

    return;
}   // IIS_SERVICE::ServiceCtrlHandler()



VOID
IIS_SERVICE::InterrogateService( VOID )
/*++
    Description:

        This function interrogates with the service status.
        Actually, nothing needs to be done here; the
        status is always updated after a service control.
        We have this function here to provide useful
        debug info.

    HISTORY:
        KeithMo     07-Mar-1993 Created.
        MuraliK     15-Nov-1994 Ported to Tcpsvcs.dll
--*/
{
    IF_DEBUG( DLL_SERVICE_INFO) {

        DBGPRINTF(( DBG_CONTEXT, "Interrogating service status for %s\n",
                   QueryServiceName())
                 );
    }

    ReportServiceStatus();

    return;

}   // IIS_SERVICE::InterrogateService()


VOID
IIS_SERVICE::PauseService( VOID )
/*++
    Description:

        This function pauses the service. When the service is paused,
        no new user sessions are to be accepted, but existing connections
        are not effected.

        This function must update the SERVICE_STATUS::dwCurrentState
         field before returning.

    Returns:

        None. If successful the service is paused.

--*/
{
    PLIST_ENTRY entry;
    IIS_SERVER_INSTANCE *instance;
    DWORD status;

    IF_DEBUG( DLL_SERVICE_INFO) {

        DBGPRINTF(( DBG_CONTEXT, "pausing service %s\n",
                   QueryServiceName())
                 );
    }

    //
    // Scan all installed instances. For each instance, save its current
    // state (so we can retrieve it in ContinueService()) and, if the
    // current state is "started", then pause the instance.
    //

    AcquireServiceLock( TRUE );

    for( entry = m_InstanceListHead.Flink ;
         entry != &m_InstanceListHead ;
         entry = entry->Flink ) {

        instance = CONTAINING_RECORD(
                       entry,
                       IIS_SERVER_INSTANCE,
                       m_InstanceListEntry
                       );

        instance->SaveServerState();

        if( instance->QueryServerState() == MD_SERVER_STATE_STARTED ) {
            status = instance->PauseInstance();
            DBG_ASSERT( status == NO_ERROR );
        }

    }

    ReleaseServiceLock( TRUE );

    //
    // Set the *service* state to paused.
    //

    m_svcStatus.dwCurrentState = SERVICE_PAUSED;
    ReportServiceStatus();

    return;
}   // IIS_SERVICE::PauseService()



VOID
IIS_SERVICE::ContinueService( VOID )
/*++

    Description:
        This function restarts ( continues) a paused service. This
        will return the service to the running state.

        This function must update the m_svcStatus.dwCurrentState
         field to running mode before returning.

    Returns:
        None. If successful then the service is running.

--*/
{
    PLIST_ENTRY entry;
    IIS_SERVER_INSTANCE *instance;
    DWORD status;

    IF_DEBUG( DLL_SERVICE_INFO) {

        DBGPRINTF(( DBG_CONTEXT, "continuing service %s\n",
                   QueryServiceName())
                 );
    }

    //
    // Scan all installed instances. For each instance, if its current
    // state is "paused" and its saved state is "running", then we know
    // the instanced was paused in PauseService(), so continue it.
    //

    AcquireServiceLock( TRUE );

    for( entry = m_InstanceListHead.Flink ;
         entry != &m_InstanceListHead ;
         entry = entry->Flink ) {

        instance = CONTAINING_RECORD(
                       entry,
                       IIS_SERVER_INSTANCE,
                       m_InstanceListEntry
                       );

        if( instance->QueryServerState() == MD_SERVER_STATE_PAUSED &&
            instance->QuerySavedState() == MD_SERVER_STATE_STARTED ) {
            status = instance->ContinueInstance();
            DBG_ASSERT( status == NO_ERROR );
        }

    }

    ReleaseServiceLock( TRUE );

    //
    // Set the *service* state to running.
    //

    m_svcStatus.dwCurrentState = SERVICE_RUNNING;
    ReportServiceStatus();

    return;
}   // IIS_SERVICE::ContinueService()



VOID
IIS_SERVICE::StopService( VOID )
/*++
    Description:

        This function performs the shutdown on a service.
        This is called during system shutdown.

        This function is time constrained. The service controller gives a
        maximum of 20 seconds for shutdown for all active services.
         Only timely operations should be performed in this function.

        What we really do in IIS is, this thread sets the Shutdown Event
         inside the IIS_SERVICE structure. The shutdown event will wake
         the intial thread that started this service (see
          IIS_SERVICE::StartServiceOperation()) => some other thread does
          the bulk of cleanup operations.

    Returns:

        None. If successful, the service is shutdown.
--*/
{
    IF_DEBUG( DLL_SERVICE_INFO) {

        DBGPRINTF(( DBG_CONTEXT, "shutting down service %s\n",
                   QueryServiceName())
                 );
    }

    m_svcStatus.dwCurrentState = SERVICE_STOP_PENDING;
    m_svcStatus.dwCheckPoint   = 0;

    //
    // Update state before setting the event to wake up the waiting thread
    //

    ReportServiceStatus();

    DBG_REQUIRE( SetEvent( m_hShutdownEvent ));

    return;
} // IIS_SERVICE::StopService()



DWORD
IIS_SERVICE::InitializeSockets( VOID )
/*++

    Initializes Socket access.
    It is responsible for connecting to WinSock.

    Returns:

       NO_ERROR on success
       Otherwise returns a Win32 error code.

    Limitations:
       This is for a single thread and not mult-thread safe.
       This function should be called after initializing globals.

--*/
{

#ifndef ATQ_FORGOT_TO_CALL_WSASTARTUP
    return ( NO_ERROR);
#else

    DWORD dwError = NO_ERROR;

    WSADATA   wsaData;
    INT       serr;

    //
    //  Connect to WinSock
    //

    serr = WSAStartup( MAKEWORD( 2, 0), & wsaData);

    if( serr != 0 ) {

        SetServiceSpecificExitCode( ( DWORD) serr);
        dwError =  ( ERROR_SERVICE_SPECIFIC_ERROR);
        m_EventLog.LogEvent( INET_SVC_WINSOCK_INIT_FAILED,
                            0,
                            (const CHAR **) NULL,
                            serr);
    }

    m_fSocketsInitialized = ( dwError == NO_ERROR);

    return  ( dwError);
#endif //  ATQ_FORGOT_TO_CALL_WSASTARTUP
} // IIS_SERVICE::InitializeSockets()




DWORD
IIS_SERVICE::CleanupSockets( VOID)
/*++

    Cleansup the static information of sockets

    Returns:

       0 if no errors,
       non-zero error code for any socket errors

    Limitations:
       This is for a single thread and not mult-thread safe.
       This function should be called after initializing globals.

    Note:
       This function should be called after shutting down all
        active socket connections.

--*/
{
#ifndef ATQ_FORGOT_TO_CALL_WSASTARTUP
    return ( NO_ERROR);
#else
    DWORD  dwError = NO_ERROR;

    if ( m_fSocketsInitialized ) {

        INT serr = WSACleanup();

        if ( serr != 0) {

            SetServiceSpecificExitCode( ( DWORD) serr);
            dwError =  ( ERROR_SERVICE_SPECIFIC_ERROR);
        }
    }

    m_fSocketsInitialized = FALSE;

    return (dwError);
#endif //  ATQ_FORGOT_TO_CALL_WSASTARTUP

} // IIS_SERVICE::CleanupSockets()



# if 0

VOID
IIS_SERVICE::Print( VOID) const
{
    IIS_SERVICE::Print();

    DBGPRINTF( ( DBG_CONTEXT,
                " Printing IIS_SERVICE object ( %08p) \n"
                " State = %u. SocketsInitFlag = %u\n"
                " ServiceStatusHandle = %08p. ShutDownEvent = %08p\n"
                " MimeMap = %08p\n"
             /* " InitFunction = %08x. CleanupFunction = %08x.\n" */
                ,
                this,
                m_state, m_fSocketsInitialized,
                m_hsvcStatus, m_hShutdownEvent,
                m_pMimeMap
                ));

    DBGPRINTF(( DBG_CONTEXT,
               " Printing IIS_SERVICE object (%08p)\n"
               " IpcStarted = %u\n"
               " EnableSvcLoc = %u; SvcLocationDone = %u\n"
               " Service Id = %u. Service Name = %s\n"
               " Module handle = %08p.  ModuleName = %s\n"
               " Reg Parameters Key = %s\n"
               ,
               this,
               m_fIpcStarted,
               m_fEnableSvcLocation, m_fSvcLocationDone,
               m_dwServiceId, m_strServiceName.QueryStr(),
               m_hModule, m_strModuleName.QueryStr(),
               m_strParametersKey.QueryStr()
               ));

    DBGPRINTF(( DBG_CONTEXT,
               " Eventlog      = %08p\n",
               &m_EventLog
               ));

    return;
}   // IIS_SERVICE::Print()

#endif // DBG



// Former inline functions that make of class static variables

BOOL
IIS_SERVICE::CheckAndReference(  )
{
    AcquireServiceLock( );
    if ( m_state == BlockStateActive ) {
        InterlockedIncrement( &m_reference );
        ReleaseServiceLock( );
        LONG lEntry = SHARED_LOG_REF_COUNT();
        LOCAL_LOG_REF_COUNT();
        IF_DEBUG( INSTANCE )
            DBGPRINTF((DBG_CONTEXT,"IIS_SERVICE ref count %ld (%ld)\n",
                       m_reference, lEntry));
        return(TRUE);
    }
    ReleaseServiceLock( );
    return(FALSE);
}


VOID
IIS_SERVICE::Dereference( )
{
    LONG lEntry = SHARED_EARLY_LOG_REF_COUNT();
    LOCAL_EARLY_LOG_REF_COUNT();

    LONG Reference = InterlockedDecrement( &m_reference );
    if ( 0 == Reference) {
        IF_DEBUG( INSTANCE )
            DBGPRINTF((DBG_CONTEXT,"deleting IIS_SERVICE %p (%ld)\n",
                       this, lEntry));
        delete this;
    } else {
        IF_DEBUG( INSTANCE )
            DBGPRINTF((DBG_CONTEXT,"IIS_SERVICE deref count %ld (%ld)\n",
                       Reference, lEntry));
    }
}


PISRPC
IIS_SERVICE::QueryInetInfoRpc( VOID )
{
    return sm_isrpc;
}


//
//  Static Functions belonging to IIS_SERVICE class
//

BOOL
IIS_SERVICE::InitializeServiceInfo( VOID)
/*++
    Description:

        This function initializes all necessary local data for IIS_SERVICE class

        Only the first initialization call does the initialization.
        Others return without any effect.

        Should be called from the entry function for DLL.

    Arguments:
        None

    Returns:
        TRUE on success and FALSE if any failure.

--*/
{
    DWORD dwError = NO_ERROR;

    if ( !IIS_SERVICE::sm_fInitialized) {

        //
        // The static data was Not Already initialized
        //

#if SERVICE_REF_TRACKING
        sm_pDbgRefTraceLog = CreateRefTraceLog(C_SERVICE_REFTRACES, 0);
        IF_DEBUG( INSTANCE ) {
            DBGPRINTF((DBG_CONTEXT,"IIS_SERVICE RefTraceLog=%p\n",
                       sm_pDbgRefTraceLog));
        }
#endif // SERVICE_REF_TRACKING

        INITIALIZE_CRITICAL_SECTION( & IIS_SERVICE::sm_csLock);
        InitializeListHead( & IIS_SERVICE::sm_ServiceInfoListHead);
        IIS_SERVICE::sm_fInitialized = TRUE;

        IIS_SERVER_INSTANCE::Initialize();

        dwError = ISRPC::Initialize();

        if ( dwError != NO_ERROR) {
            SetLastError( dwError);
        }
    }

    return ( dwError == NO_ERROR);
} // IIS_SERVICE::InitializeServiceInfo()



VOID
IIS_SERVICE::CleanupServiceInfo(
                        VOID
                        )
/*++
    Description:

        Cleanup the data stored and services running.
        This function should be called only after freeing all the
         services running using this DLL.
        This function is called typically when the DLL is unloaded.

    Arguments:
        None

    Returns:
        None

--*/
{
    RPC_STATUS rpcerr;

    DBG_REQUIRE( ISRPC::Cleanup() == NO_ERROR);

    //
    // Should we walk down the list of all services and stop them?
    //  Are should we expect the caller to have done that?  NYI
    //

    DBG_ASSERT( IsListEmpty(&sm_ServiceInfoListHead) );

    IIS_SERVER_INSTANCE::Cleanup();

    //
    //  The DLL is going away so make sure all of the threads get terminated
    //  here
    //

    DeleteCriticalSection( & sm_csLock);

#if SERVICE_REF_TRACKING
    if (sm_pDbgRefTraceLog != NULL)
    {
        IF_DEBUG( INSTANCE ) {
            DBGPRINTF((DBG_CONTEXT,
                       "IIS_SERVICE: Closing RefTraceLog=%p\n",
                       sm_pDbgRefTraceLog));
        }
        DestroyRefTraceLog( sm_pDbgRefTraceLog );
    }
    sm_pDbgRefTraceLog = NULL;
#endif // SERVICE_REF_TRACKING

    IIS_SERVICE::sm_fInitialized = FALSE;

} // IIS_SERVICE::CleanupServiceInfo()



BOOL
IIS_SERVICE::InitializeServiceRpc(
                       IN LPCSTR        pszServiceName,
                       IN RPC_IF_HANDLE hRpcInterface
                       )
/*++
    Description:

        Initializes the rpc endpoint for the infocomm service.

    Arguments:
        pszServiceName - pointer to null-terminated string containing the name
          of the service.

        hRpcInterface - Handle for RPC interface.

    Returns:
        Win32 Error Code.

--*/
{

    DWORD dwError = NO_ERROR;
    PISRPC  pIsrpc = NULL;

    DBG_ASSERT( pszServiceName != NULL);
    DBG_ASSERT( sm_isrpc == NULL );

    pIsrpc = new ISRPC( pszServiceName);

    if ( pIsrpc == NULL) {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto exit;
    }

    //
    //  bind over Named pipe only.
    //  If needed to bind over TCP, bind with bit flag ISRPC_OVER_TCPIP on.
    //

    dwError = pIsrpc->AddProtocol( ISRPC_OVER_TCPIP
                                  | ISRPC_OVER_NP | ISRPC_OVER_LPC
                                  );

    if( (dwError == RPC_S_DUPLICATE_ENDPOINT) ||
       (dwError == RPC_S_OK)
       ) {

        dwError = pIsrpc->RegisterInterface(hRpcInterface);
    }

    if ( dwError != RPC_S_OK ) {
        goto exit;
    }

    //
    //  Start the RPC listen thread
    //

    dwError = pIsrpc->StartServer( );

exit:

    if ( dwError != NO_ERROR ) {
        DBGPRINTF(( DBG_CONTEXT,
                   "Cannot start RPC Server for %s, error %lu\n",
                   pszServiceName, dwError ));

        delete pIsrpc;
        SetLastError(dwError);
        return(FALSE);
    }

    sm_isrpc = pIsrpc;
    return(TRUE);

} // IIS_SERVICE::InitializeServiceRpc




IIS_SERVICE::CleanupServiceRpc(
                       VOID
                       )
/*++
    Description:

        Cleanup the data stored and services running.
        This function should be called only after freeing all the
         services running using this DLL.
        This function is called typically when the DLL is unloaded.

    Arguments:
        pszServiceName - pointer to null-terminated string containing the name
          of the service.

        hRpcInterface - Handle for RPC interface.


    Returns:
        Win32 Error Code.

--*/
{
    DWORD dwError = NO_ERROR;

    if ( sm_isrpc == NULL ) {
        DBGPRINTF((DBG_CONTEXT,
            "no isrpc object to cleanup. Returning success\n"));
        return(TRUE);
    }

    (VOID) sm_isrpc->StopServer( );
    dwError = sm_isrpc->CleanupData();

    if( dwError != RPC_S_OK ) {
        DBGPRINTF(( DBG_CONTEXT,
                   "ISRPC(%08p) Cleanup returns %lu\n", sm_isrpc, dwError ));
        DBG_ASSERT( !"RpcServerUnregisterIf failure" );
        SetLastError( dwError);
    }

    delete sm_isrpc;
    sm_isrpc = NULL;

    return TRUE;
} // CleanupServiceRpc


BOOL
IIS_SERVICE::InitializeMetabaseComObject(
    VOID
    )
/*++
    Description:

        This function initializes the metabase object

    Arguments:
        None

    Returns:
        TRUE on success and FALSE if any failure.

--*/
{

    HANDLE      hThreadHandle = NULL;
    DWORD       dwTemp;
    BOOL        fRet = FALSE;

    IF_DEBUG(METABASE) {
        DBGPRINTF((DBG_CONTEXT,"Initializing metabase object\n"));
    }

    fRet = InitMetadataDCom( (PVOID)&IIS_SERVICE::sm_MDObject,
                             (PVOID)&IIS_SERVICE::sm_MDNseObject );

    if ( fRet )
    {
        fRet = InitializeMetabaseSink( sm_MDObject );
    }

    return(fRet);

} // IIS_SERVICE::InitializeMetabaseComObject



BOOL
IIS_SERVICE::CleanupMetabaseComObject(
    VOID
    )
/*++
    Description:

        This function initializes the metabase object

    Arguments:
        None

    Returns:
        TRUE on success and FALSE if any failure.

--*/
{
    IF_DEBUG(METABASE) {
        DBGPRINTF((DBG_CONTEXT,"Cleaning up metabase object %p\n",
            IIS_SERVICE::sm_MDObject));
    }

    TerminateMetabaseSink();

    if ( IIS_SERVICE::sm_MDObject != NULL ) {
        ((IMDCOM*)IIS_SERVICE::sm_MDObject)->ComMDTerminate(TRUE);
        IIS_SERVICE::sm_MDObject = NULL;
    }
    if ( IIS_SERVICE::sm_MDNseObject != NULL ) {
        ((IMDCOM*)IIS_SERVICE::sm_MDNseObject)->ComMDTerminate(TRUE);
        ((IMDCOM*)IIS_SERVICE::sm_MDNseObject)->Release();
        IIS_SERVICE::sm_MDNseObject = NULL;
    }

    return(TRUE);

} // IIS_SERVICE::CleanupMetabaseComObject


VOID
IIS_SERVICE::MDChangeNotify(
    DWORD            dwMDNumElements,
    MD_CHANGE_OBJECT pcoChangeList[]
    )
/*++

  This method handles the metabase change notification for the running
  services. Note that since we're not allowed to reenter the metabase from
  this notification, we do not directly notify the running services here.
  Rather, we capture the state of this notification and queue the request
  to a worker thread.

  Arguments:

    hMDHandle - Metabase handle generating the change notification
    dwMDNumElements - Number of change elements in pcoChangeList
    pcoChangeList - Array of paths and ids that have changed

--*/
{

    DWORD totalLength;
    DWORD i;
    LPDWORD nextIdArray;
    LPBYTE prevString;
    PMD_CHANGE_OBJECT mdScan;
    PMD_CHANGE_OBJECT nextObject;
    PDEFERRED_MD_CHANGE pdeferredChange;

#if DO_NOTIFICATION_DEFERRED
    //
    // First off, we need to calculate the size of the buffer required
    // to capture the change data. We'll start off with the known
    // fixed-size data.
    //

    totalLength = sizeof(DEFERRED_MD_CHANGE) +
                  ( sizeof(MD_CHANGE_OBJECT) * dwMDNumElements );

    //
    // Now, we'll scan the change list and accumulate the lengths
    // of the metadata paths and the ID arrays.
    //

    for( i = dwMDNumElements, mdScan = pcoChangeList ;
         i > 0 ;
         i--, mdScan++ ) {

        totalLength += (DWORD)strlen( (CHAR *)mdScan->pszMDPath ) + 1;
        totalLength += mdScan->dwMDNumDataIDs * sizeof(DWORD);

    }

    //
    // Now we can actually allocate the work item.
    //

    pdeferredChange = (PDEFERRED_MD_CHANGE) TCP_ALLOC( totalLength );

    if( pdeferredChange == NULL ) {

        DBGPRINTF((
            DBG_CONTEXT,
            "MDChangeNotify: Cannot allocate work item (%lu)\n",
            totalLength
            ));

    } else {

        //
        // Capture the change information.
        //

        nextObject = (PMD_CHANGE_OBJECT)( pdeferredChange + 1 );
        prevString = (LPBYTE)pdeferredChange + totalLength;
        nextIdArray = (LPDWORD)( (LPBYTE)nextObject +
                          ( sizeof(MD_CHANGE_OBJECT) * dwMDNumElements ) );

        for( i = 0, mdScan = pcoChangeList ;
             i < dwMDNumElements ;
             i++, mdScan++, nextObject++ ) {

            DWORD cchPath;

            //
            // Initialize the object.
            //

            cchPath = (DWORD)strlen( (CHAR *)mdScan->pszMDPath ) + 1;
            prevString -= cchPath;

            nextObject->pszMDPath = prevString;
            memcpy(
                nextObject->pszMDPath,
                mdScan->pszMDPath,
                cchPath
                );

            nextObject->dwMDChangeType = mdScan->dwMDChangeType;
            nextObject->dwMDNumDataIDs = mdScan->dwMDNumDataIDs;

            nextObject->pdwMDDataIDs = nextIdArray;
            memcpy(
                nextObject->pdwMDDataIDs,
                mdScan->pdwMDDataIDs,
                nextObject->dwMDNumDataIDs * sizeof(DWORD)
                );

            nextIdArray += nextObject->dwMDNumDataIDs;

        }

        //
        // Ensure we didn't mess up the buffer.
        //

        DBG_ASSERT( (LPBYTE)nextIdArray == prevString );

        //
        // Now, just enqueue the request.
        //

        pdeferredChange->dwMDNumElements = dwMDNumElements;

        if( !ScheduleWorkItem( DeferredMDChange,
                               pdeferredChange,
                                0 ) ) {
            DBGPRINTF((
                DBG_CONTEXT,
                "MDChangeNotify: cannot queue work item\n"
                ));

            TCP_FREE( pdeferredChange );
        }

    }
#else
    IIS_SERVICE::DeferredMDChangeNotify( dwMDNumElements,
                                         pcoChangeList );

    IIS_SERVICE::DeferredGlobalConfig( dwMDNumElements,
                                       pcoChangeList );
#endif

}   // IIS_SERVICE::MDChangeNotify

#if DO_NOTIFICATION_DEFERRED
VOID
WINAPI
DeferredMDChange(
    PVOID pv
    )
{
    PDEFERRED_MD_CHANGE pdmc = (PDEFERRED_MD_CHANGE) pv;

    IF_DEBUG(METABASE) {
        DBGPRINTF((DBG_CONTEXT,"DeferredMDChange(%p)\n", pdmc));
    }

    IIS_SERVICE::DeferredMDChangeNotify( pdmc->dwMDNumElements,
                                         (PMD_CHANGE_OBJECT)(pdmc + 1) );

    IIS_SERVICE::DeferredGlobalConfig( pdmc->dwMDNumElements,
                                       (PMD_CHANGE_OBJECT)(pdmc + 1 ) );

    TCP_FREE( pdmc );
}
#endif

VOID
IIS_SERVICE::DeferredGlobalConfig(
    DWORD               dwMDNumElements,
    MD_CHANGE_OBJECT    pcoChangeList[]
)
/*++

    Update configuration of options that are above the service name in the
    metabase (global to all services).  For example, global Bandwidth
    Throttling

  Arguments:

    dwMDNumElements - Number of change elements in pcoChangeList
    pcoChangeList - Array of paths and ids that have changed

--*/
{
    DWORD               i;
    BOOL                fUpdateGlobalConfig = FALSE;

    for ( i = 0; i < dwMDNumElements; i++ )
    {
        if ( !_stricmp( (CHAR*) pcoChangeList[i].pszMDPath, LM_PREFIX ) )
        {
            fUpdateGlobalConfig = TRUE;
            break;
        }
    }

    if ( fUpdateGlobalConfig )
    {
        DWORD           dwVal;

        AcquireGlobalLock();

        MB mb( (IMDCOM*) IIS_SERVICE::QueryMDObject()  );

        if (!mb.Open("/lm", METADATA_PERMISSION_READ) ||
            !mb.GetDword("", MD_MAX_BANDWIDTH, IIS_MD_UT_SERVER, &dwVal))
        {
            dwVal = INETA_DEF_BANDWIDTH_LEVEL;
        }

        AtqSetInfo( AtqBandwidthThrottle, (ULONG_PTR)dwVal);

        if ( mb.GetDword("", MD_MAX_BANDWIDTH_BLOCKED, IIS_MD_UT_SERVER, &dwVal))
        {
            AtqSetInfo( AtqBandwidthThrottleMaxBlocked, (ULONG_PTR)dwVal );
        }

        ReleaseGlobalLock();
    }
}


VOID
IIS_SERVICE::DeferredMDChangeNotify(
    DWORD            dwMDNumElements,
    MD_CHANGE_OBJECT pcoChangeList[]
    )
/*++

  This method handles the metabase change notification for the running services
  and notifies the appropriate service.  This is a static method, invoked by
  the deferred worker thread.

  Arguments:

    dwMDNumElements - Number of change elements in pcoChangeList
    pcoChangeList - Array of paths and ids that have changed

--*/
{
    LIST_ENTRY *        pEntry;

#ifdef _KNFOCOMM
    //
    //  Knfocomm sink will only process MB notifications whose path
    //  corresponds to services that use knfocomm...
    //
    const CHAR *  pszKnfoSvcName;
    DWORD         cchKnfoSvcName;
    DWORD         i,j;
    BOOL          fMatch = FALSE;

    for( j=0; j < gNumKnfoServices; j++ )
    {
        pszKnfoSvcName = rgKnfoServices[j];
        cchKnfoSvcName = strlen( pszKnfoSvcName );

        for ( i = 0; i < dwMDNumElements; i++ )
        {
            if ( !_strnicmp( (CHAR *) pcoChangeList[i].pszMDPath + LM_PREFIX_CCH,
                             pszKnfoSvcName,
                             cchKnfoSvcName ))
            {
                //  MB change list contains a path that matches one of the known
                //  knfocomm services.
                fMatch = TRUE;
            }
        }
    }

    if( !fMatch ) {
        //  Knfocomm has nothing to do with this notification...
        return;
    }
#endif

    //
    //  Walk the list of services and change notifications looking for a match
    //

    AcquireGlobalLock();

    for ( pEntry =  sm_ServiceInfoListHead.Flink;
          pEntry != &sm_ServiceInfoListHead;
          pEntry =  pEntry->Flink )
    {
        const CHAR *  pszSvcName;
        DWORD         cchSvcName;
        DWORD         i;
        IIS_SERVICE * pService = CONTAINING_RECORD( pEntry,
                                                    IIS_SERVICE,
                                                    m_ServiceListEntry );

        pszSvcName = pService->QueryServiceName();
        cchSvcName = strlen( pszSvcName );

        for ( i = 0; i < dwMDNumElements; i++ )
        {
            if ( !_strnicmp( (CHAR *) pcoChangeList[i].pszMDPath + LM_PREFIX_CCH,
                             pszSvcName,
                             cchSvcName ))
            {
                if( pService->CheckAndReference() ) {
                    pService->MDChangeNotify( &pcoChangeList[i] );
                    pService->Dereference();
                }
            }
        }
    }

    ReleaseGlobalLock();

}   // IIS_SERVICE::DeferredMDChangeNotify


VOID
IIS_SERVICE::MDChangeNotify(
    MD_CHANGE_OBJECT * pco
    )
/*++

  This method handles the metabase change notification for this server instance

  Arguments:

    pco - path and id that has changed

--*/
{
    LIST_ENTRY * pEntry;
    LPSTR serviceName;
    DWORD serviceNameLength;
    DWORD instanceId;
    LPSTR instanceIdString;
    LPSTR stringEnd;
    BOOL parentChange;
    BOOL didAddOrDelete;
    DWORD i;

    //
    //  Find the instance ID in the path.
    //

    serviceName = (LPSTR)QueryServiceName();
    serviceNameLength = (DWORD)strlen( serviceName );

    DBG_ASSERT( !_strnicmp(
                     (CHAR *)pco->pszMDPath,
                     LM_PREFIX,
                     LM_PREFIX_CCH
                     ) );

    DBG_ASSERT( !_strnicmp(
                     (CHAR *)pco->pszMDPath + LM_PREFIX_CCH,
                     serviceName,
                     (size_t)serviceNameLength
                     ) );

    instanceIdString = (LPSTR)pco->pszMDPath + LM_PREFIX_CCH + serviceNameLength;

    //
    //  Lock the service before we start mucking with things too much.
    //

    parentChange = TRUE;
    didAddOrDelete = FALSE;

    AcquireServiceLock();

    if( instanceIdString[0] == '/' &&
        instanceIdString[1] != '\0' ) {

        parentChange = FALSE;
        instanceId = strtoul( instanceIdString + 1, &stringEnd, 10 );

        //
        //  If this is an "instance add" or "instance delete", then Do The
        //  Right Thing. Note that strtoul() will set stringEnd to point to
        //  the character that "stopped" the conversion. This will point to
        //  the string terminator ('\0') if the converted ulong is at the end
        //  of the string. In our case, this would indicate the string is of
        //  the form:
        //
        //      /LM/{service_name}/{instance_id}/
        //
        //  Note there are no path components beyond the instance ID. This is
        //  our indication that an instance is getting created/deleted.
        //

        if( ( pco->dwMDChangeType & MD_CHANGE_TYPE_ADD_OBJECT ) &&
            stringEnd[0] == '/' &&
            stringEnd[1] == '\0' ) {

            didAddOrDelete = TRUE;

            if( !AddInstanceInfo( instanceId ) ) {

                DBGPRINTF((
                    DBG_CONTEXT,
                    "MDChangeNotify: cannot add instance %lu, error %lu\n",
                    instanceId,
                    GetLastError()
                    ));

            }

        } else
        if( ( pco->dwMDChangeType & MD_CHANGE_TYPE_DELETE_OBJECT ) &&
            stringEnd[0] == '/' &&
            stringEnd[1] == '\0' ) {

            didAddOrDelete = TRUE;

            if( !DeleteInstanceInfo( instanceId ) ) {

                DBGPRINTF((
                    DBG_CONTEXT,
                    "MDChangeNotify: cannot delete instance %lu, error %lu\n",
                    instanceId,
                    GetLastError()
                    ));

            }

        }

    }

    if( !didAddOrDelete ) {

        //
        //  Walk the list of instances and change notifications looking
        //  for a match on the metabase path or a path that is above the
        //  instance (to make sure any inherited changes are picked up).
        //

        DWORD pathLength = strlen( (CHAR *)pco->pszMDPath );

        for ( pEntry  = m_InstanceListHead.Flink;
              pEntry != &m_InstanceListHead;
              pEntry  = pEntry->Flink )
        {
            IIS_SERVER_INSTANCE * pInstance = CONTAINING_RECORD( pEntry,
                                                                 IIS_SERVER_INSTANCE,
                                                                 m_InstanceListEntry );

            if ( parentChange ||
                 ( pInstance->QueryMDPathLen() <= pathLength &&
                   !_strnicmp( (CHAR *) pco->pszMDPath,
                               pInstance->QueryMDPath(),
                               pInstance->QueryMDPathLen() ) &&
                   ( pco->pszMDPath[pInstance->QueryMDPathLen()] == '\0' ||
                     pco->pszMDPath[pInstance->QueryMDPathLen()] == '/' ) ) )
            {
                pInstance->MDChangeNotify( pco );

                if ( !parentChange )
                    break;
            }
        }

    }

    //
    //  Watch for the downlevel instance changing
    //

    for ( i = 0; i < pco->dwMDNumDataIDs; i++ )
    {
        switch ( pco->pdwMDDataIDs[i] )
        {
        case MD_DOWNLEVEL_ADMIN_INSTANCE:
            {
                MB                    mb( (IMDCOM*) QueryMDObject() );
                IIS_SERVER_INSTANCE * pInst;

                if ( mb.Open( QueryMDPath() ) )
                {
                    if ( !mb.GetDword( "",
                                       MD_DOWNLEVEL_ADMIN_INSTANCE,
                                       IIS_MD_UT_SERVER,
                                       &m_dwDownlevelInstance ))
                    {
                        m_dwDownlevelInstance = 0xffffffff;
                    }
                }

                //
                //  Mirror the new vroots to the registry
                //

                if ( pInst = FindIISInstance( m_dwDownlevelInstance ))
                {
                    pInst->MDMirrorVirtualRoots();
                }
            }

        default:
            break;
        }
    }


    ReleaseServiceLock();

} // IIS_SERVICE::MDChangeNotify


BOOL
IIS_SERVICE::LoadStr(
            OUT STR & str,
            IN DWORD dwResId,
            IN BOOL fForceEnglish ) const
/*++

  This function loads the string, whose resource id is ( dwResId), into
   the string str passed.

  Arguments:
    str      reference to string object into which the string specified
             by resource id is loaded
    dwResId  DWORD containing the resource id for string to be loaded.

  Returns:
    TRUE on success and FALSE if there is any failure.
--*/
{
    BOOL fReturn = FALSE;

    if ( (dwResId >= WSABASEERR) && (dwResId <  WSA_MAX_ERROR) ) {

        if (( fReturn  = str.Resize((sizeof(SOCK_ERROR_STR_A) + 11) *
                                     sizeof( WCHAR )))) {

            wsprintfA( str.QueryStr(), SOCK_ERROR_STR_A, dwResId );

        } // if ( Resize()

    } else {

        //
        // Try to load the string from current module or system table
        //  depending upon if the Id < STR_RES_ID_BASE.
        // System table contains strings for id's < STR_RES_ID_BASE.
        //

        if ( dwResId < STR_RES_ID_BASE)  {

            // Use English strings for System table
            fReturn = str.LoadString( dwResId, (LPCTSTR ) NULL,
                                      ( m_fIsDBCS && fForceEnglish ) ? 0x409 : 0);

        } else {

            fReturn = str.LoadString( dwResId, m_hModule );
        }
    }

    if ( !fReturn ) {
        DBGPRINTF((DBG_CONTEXT,"Error %d in load string[%d]\n",
            GetLastError(), dwResId ));
    }

    return ( fReturn);

} // IIS_SERVICE::LoadStr()




DWORD
IIS_SERVICE::InitializeDiscovery(
            VOID
            )
/*++

    Register this server and service with service discoverer.
    It will discover us using these information for administering us.

  Arguments:

    None.

  Return Value:
    Win32 Error Code;

--*/
{
    DWORD           dwError = NO_ERROR;
    PISRPC          pIsrpc;

    //
    // Only enable on server as we don't have remove admin on
    // the PWS.  -jra  !!! of course, we could change our minds again.
    //

    if ( g_hSvcLocDll == NULL ) {
        m_fEnableSvcLocation = FALSE;
        return(NO_ERROR);
    }

    INET_BINDINGS   TotalBindings = { 0, NULL};
    HKEY  hkey = NULL;

    dwError = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                           QueryRegParamKey(),
                           0,
                           KEY_READ,
                           &hkey );

    if ( dwError != NO_ERROR )
    {
        IF_DEBUG( ERROR) {

            DBGPRINTF(( DBG_CONTEXT,
                       "IIS_SERVICE::InitializeDiscovery() "
                       " RegOpenKeyEx returned error %d\n",
                       dwError ));
        }

        return (dwError);
    }

    m_fEnableSvcLocation = !!ReadRegistryDword( hkey,
                                               INETA_ENABLE_SVC_LOCATION,
                                               INETA_DEF_ENABLE_SVC_LOCATION);

    if ( hkey != NULL) {

        RegCloseKey( hkey);
    }

    if ( !m_fEnableSvcLocation ) {

        //
        // Service Location is not enabled (by admin presumably).
        // So Let us not register ourselves now.
        //
        return ( NO_ERROR);
    }

    //
    // Form the global binding information
    //

    pIsrpc = QueryInetInfoRpc( );
    dwError = pIsrpc->EnumBindingStrings( &TotalBindings);

    if ( dwError == NO_ERROR) {

        dwError = pfnInetRegisterSvc(
                      m_SvcLocId,
                      INetServiceRunning,
                      m_strServiceComment.QueryStr(),
                      &TotalBindings
                      );

        IF_DEBUG( DLL_RPC) {
            DBGPRINTF(( DBG_CONTEXT,
                       "INetRegisterService( %u), Running, returns %u\n",
                       QueryServiceId(),
                       dwError));
        }
    }

    //
    //  Log the error then ignore it as it only affects service discovery
    //

    if ( dwError != NO_ERROR ) {

        m_EventLog.LogEvent( INET_SVC_SERVICE_REG_FAILED,
                            0,
                            (const CHAR **) NULL,
                            dwError );

        dwError = NO_ERROR;  // Ignore the error .....
    } else {

        m_fSvcLocationDone = TRUE;
    }

    pIsrpc->FreeBindingStrings( &TotalBindings);

    return( dwError);

}  // IIS_SERVICE::InitializeDiscovery()



DWORD
IIS_SERVICE::TerminateDiscovery(
                        VOID
                        )
{
    DWORD           dwError = NO_ERROR;

    //
    //  Deregister the service from the Discovery Service. This will
    //  prevent admins from picking up our machine for administration.
    //

    if ( m_fEnableSvcLocation && m_fSvcLocationDone) {

        dwError = pfnInetDeregisterSvc(m_SvcLocId);

        DBG_ASSERT( dwError == NO_ERROR);
        m_fSvcLocationDone = FALSE;
    }

    return( dwError);

} // IIS_SERVICE::TerminateDiscovery()



VOID
IIS_SERVICE::DestroyAllServerInstances(
        VOID
        )
/*++

    Description:

        Destroys all server instanes of this service.

    Arguments:

        None.

    Returns:

        None.
--*/
{

    PLIST_ENTRY listEntry;
    PIIS_SERVER_INSTANCE pInstance;

    IF_DEBUG( INSTANCE ) {
        DBGPRINTF(( DBG_CONTEXT, "DestroyAllServerInstances called\n"));
    }

    //
    // Loop and delete all instances
    //

    AcquireServiceLock( );

    while ( !IsListEmpty(&m_InstanceListHead) ) {

        listEntry = RemoveHeadList( &m_InstanceListHead );
        m_nInstance--;
        ReleaseServiceLock( );

        pInstance = CONTAINING_RECORD(
                                listEntry,
                                IIS_SERVER_INSTANCE,
                                m_InstanceListEntry
                                );

        //
        // Close and dereference the instance.
        //

        pInstance->CloseInstance();
        pInstance->Dereference();

        AcquireServiceLock( );

    }

    ReleaseServiceLock( );

} // IIS_SERVICE::DestroyAllServerInstances



BOOL
IIS_SERVICE::EnumServiceInstances(
    PVOID             pvContext,
    PVOID             pvContext2,
    PFN_INSTANCE_ENUM pfnEnum
    )
/*++

    Description:

        Enumerates all instances on this service

    Arguments:

        pvContext - Context to pass back to the caller
        pvContext2 - 2nd context to pass back to the caller
        pfnEnum - Callback to make for each instance

    Returns:

        TRUE if no errors were returned, FALSE if a callback returned
        an error
--*/
{

    PLIST_ENTRY          listEntry;
    PIIS_SERVER_INSTANCE pInstance;
    BOOL                 fRet = TRUE;

    IF_DEBUG( INSTANCE ) {
        DBGPRINTF(( DBG_CONTEXT, "EnumServiceInstances called\n"));
    }

    //
    // Loop and delete all instances
    //

    AcquireServiceLock( TRUE );

    for ( listEntry  = m_InstanceListHead.Flink;
          listEntry != &m_InstanceListHead;
          listEntry  = listEntry->Flink ) {

        pInstance = CONTAINING_RECORD(
                                listEntry,
                                IIS_SERVER_INSTANCE,
                                m_InstanceListEntry
                                );

        if ( !(fRet = pfnEnum( pvContext,
                               pvContext2,
                               pInstance )))
        {
            break;
        }
    }

    ReleaseServiceLock( TRUE );
    return fRet;

} // IIS_SERVICE::EnumServerInstances




VOID
IIS_SERVICE::CloseService(
    VOID
    )
/*++

  Description:
     This function cleans up the service object.

  Returns:
     None.
--*/
{

    IF_DEBUG( INSTANCE ) {
        DBGPRINTF(( DBG_CONTEXT,
            "IIS_SERVICE:Destroy service object %p ref %d\n",this,m_reference));
    }

    DBG_ASSERT(m_state != BlockStateActive);

    DestroyAllServerInstances( );

    //
    // We can't return from this function before the refcount hits zero, because
    // after we return TerminateGlobals will destroy structures that the other
    // threads might need while cleaning up.  To prevent this we busy wait here
    // until the reference count reaches 1.
    //

#if DBG
    int cRetries = 0;
    const int nDelay = 1000;
#else
    const int nDelay =  200;
#endif

    while ( m_reference > 1 )
    {
        DBGPRINTF(( DBG_CONTEXT,
            "IIS_SERVICE:Destroy service object %p ref %d\n",this,m_reference ));

#if DBG
        ++cRetries;
#endif

        Sleep(nDelay);
    }

    Dereference( );

} // IIS_SERVICE::CloseService





BOOL
IIS_SERVICE::AddServerInstance(
        IN PIIS_SERVER_INSTANCE pInstance
        )
/*++
    Description:

        References a new instane of this service

    Arguments:

        pInstance - instance to link.

    Returns:

        NO_ERROR on success and Win32 error code if any failure.
--*/
{
    DWORD err;

    IF_DEBUG( INSTANCE ) {
        DBGPRINTF((DBG_CONTEXT,"AddServerInstance called with %p\n",
            pInstance ));
    }

    //
    // Insert instance into service list
    //

    AcquireServiceLock( );

    if ( !IsActive() ) {
        err = ERROR_NOT_READY;
        goto error_exit;
    }

    //
    // reference the instance since we now have a link to it.
    //

    pInstance->Reference();

    InsertTailList( &m_InstanceListHead, &pInstance->m_InstanceListEntry );
    m_nInstance++;
    ReleaseServiceLock( );
    return(TRUE);

error_exit:
    ReleaseServiceLock( );
    SetLastError(err);
    return(FALSE);

} // AddServerInstance



BOOL
IIS_SERVICE::RemoveServerInstance(
        IN PIIS_SERVER_INSTANCE pInstance
        )
/*++
    Description:

        References a new instane of this service

    Arguments:

        pInstance - instance to link.

    Returns:

        NO_ERROR on success and Win32 error code if any failure.
--*/
{

    IF_DEBUG( INSTANCE ) {
        DBGPRINTF((DBG_CONTEXT,"RemoveServerInstance called with %p\n",
            pInstance ));
    }

    //
    // Remove instance from service list
    //

    AcquireServiceLock( );
    RemoveEntryList( &pInstance->m_InstanceListEntry );
    m_nInstance--;
    ReleaseServiceLock( );

    pInstance->Dereference( );

    return(TRUE);

} // RemoveServerInstance


IIS_ENDPOINT *
IIS_SERVICE::FindAndReferenceEndpoint(
    IN USHORT   Port,
    IN DWORD    IpAddress,
    IN BOOL     CreateIfNotFound,
    IN BOOL     IsSecure,
    IN BOOL     fDisableSocketPooling

    )
/*++

    Description:

        Searches the service's endpoint list looking for one bound to
        the specified port.

    Arguments:

        Port - The port to search for.

        IpAddress - The IP Address to search for.

        CreateIfNotFound - If TRUE, and the port cannot be found in
            the endpoint list, then a new endpoint is created and
            attached to the list.

        IsSecure - TRUE for secure ports. Only used when a new
            endpoint is created.

        fDisableSocketPooling - Used only if CreateIfNotFound is TRUE.
            If TRUE, create an endpoint qualified by both Port & IP.
            Else create an endpoint qualified only by Port.

    Returns:

        IIS_ENDPOINT * - Pointer to the endpoint if successful, NULL
            otherwise. If !NULL, then the endpoint is referenced and it
            is the caller's responsibility to dereference the endpoint
            at a later time.

--*/
{

    PLIST_ENTRY     listEntry;
    PIIS_ENDPOINT   endpoint = NULL;
    DWORD           searchIpAddress = IpAddress;

    //
    // Walk the list looking for a matching port. Note that the endpoints
    // are stored in ascending port order.
    //
    // Initially we search for an endpoint that is qualified by both IpAddress
    // and Port.

    AcquireServiceLock();

SearchEndpointList:

    for( listEntry = m_EndpointListHead.Flink ;
         listEntry != &m_EndpointListHead ;
         listEntry = listEntry->Flink ) {

        endpoint = CONTAINING_RECORD(
                       listEntry,
                       IIS_ENDPOINT,
                       m_EndpointListEntry
                       );

        if( endpoint->m_Port > Port ) {
            break;
        }

        if( endpoint->m_Port == Port &&
            endpoint->m_IpAddress == searchIpAddress
          )
        {
            endpoint->Reference();
            goto done;
        }
    }

    //
    //  The search failed. If this was a search qualified by IpAddress,
    //  we need to re-search using INADDR_ANY as the IP Address
    //

    if (INADDR_ANY != searchIpAddress)
    {
        searchIpAddress = INADDR_ANY;
        goto SearchEndpointList;
    }

    //
    // The port is not in the list. Create a new endpoint if required.
    //

    if( CreateIfNotFound ) {

        //
        // CODEWORK: It may be necessary in the future to move this
        // endpoint creation to a virtual method so that classes derived
        // from IIS_SERVICE can create specific types of endpoints.
        //

        endpoint = new IIS_ENDPOINT(
                           this,
                           Port,
                           fDisableSocketPooling ? IpAddress : INADDR_ANY,
                           IsSecure
                           );

        if( endpoint != NULL ) {

            //
            // Insert it into the list.
            //

            listEntry = listEntry->Blink;
            InsertHeadList(
                listEntry,
                &endpoint->m_EndpointListEntry
                );

            goto done;
        }
    }

    //
    // If we made it this far, then we could not find the endpoint and
    // either could not create a new one OR were not asked to create one.
    //

    endpoint = NULL;

done:

    ReleaseServiceLock();
    return endpoint;

}   // IIS_SERVICE::FindAndReferenceEndpoint


BOOL
IIS_SERVICE::AddInstanceInfoHelper(
    IN IIS_SERVER_INSTANCE * pInstance
    )
/*++

    Description:

        Helper routine called by the service-specific AddInstanceInfo()
        virtual routine. This helper just commonizes some startup code
        that all services need to do.

    Arguments:

        pInstance - The instance to associate with the service.

    Returns:

        BOOL - TRUE if successful, FALSE otherwise.

    Notes:

        If this routine returns FALSE, then the instance object passed in
        is properly destroyed and extended error information is available
        via GetLastError().

--*/
{

    DWORD status;

    if( pInstance == NULL ) {

        status = ERROR_NOT_ENOUGH_MEMORY;

        DBGPRINTF((
            DBG_CONTEXT,
            "AddInstanceInfoHelper: cannot create new instance, error %lu\n",
            status
            ));

        //
        // The memory allocation failed, so we've nothing to delete.
        //

    } else
    if( pInstance->QueryServerState() == MD_SERVER_STATE_INVALID ) {

        //
        // Unfortunately, I don't think we can depend on "last error"
        // getting set correctly on a constructor failure, so we'll
        // just kludge up an error code.
        //

        status = ERROR_NOT_ENOUGH_MEMORY;

        DBGPRINTF((
            DBG_CONTEXT,
            "AddInstanceInfoHelper: constructor failed, error %lu\n",
            status
            ));

        //
        // The constructor failed. The instance may or may not be on
        // the service's instance list. If the base constructor failed,
        // then the instance is NOT on the list. If the derived constructor
        // failed, then the instance IS on the list.
        //
        // CleanupAfterConstructorFailure() will Do The Right Thing
        // to properly destroy the partially constructed instance.
        //

        pInstance->CleanupAfterConstructorFailure();

    } else
    if( pInstance->IsAutoStart() && !AssociateInstance( pInstance ) ) {

        status = GetLastError();

        DBGPRINTF((
            DBG_CONTEXT,
            "AddInstanceInfoHelper: cannot associate instance, error %lu\n",
            status
            ));

        //
        // The constructor succeeded, but the instance could not be
        // associated with the service. The reference count should be
        // exactly one. We can't just delete the object as the destructor
        // will assert because the reference count is non-zero, so we'll
        // call RemoveServerInstance(), which will remove the instance from
        // the service's list and then dereference the instance.
        //

        RemoveServerInstance( pInstance );

    } else {
        return TRUE;
    }

    SetLastError( status );
    return FALSE;

}   // IIS_SERVICE::AddInstanceInfoHelper


BOOL
IIS_SERVICE::IsService()
{
    return TRUE;
}


VOID
IIS_SERVICE::AdvertiseServiceInformationInMB(
    VOID
    )
{

    MB          mb( (IMDCOM*) QueryMDObject() );
    CHAR        szServiceKey[MAX_PATH+1];
    DWORD       capabilities = 0;
    DWORD       version = 0;
    DWORD       productType = 0;
    HKEY        hkey;

    strcpy( szServiceKey, IIS_MD_LOCAL_MACHINE_PATH "/" );
    strcat( szServiceKey, QueryServiceName() );

    if ( !mb.Open( szServiceKey,
                   METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE ))
    {
        DBGPRINTF(( DBG_CONTEXT,
                   "[AddCapabilityFlag] Cannot open path %s, error %lu\n",
                    szServiceKey, GetLastError() ));
        return;
    }

    //
    // set version
    //

    if ( !mb.SetDword( IIS_MD_SVC_INFO_PATH,
                       MD_SERVER_VERSION_MAJOR,
                       IIS_MD_UT_SERVER,
#ifdef _IIS_5_1
                       IIS_VERSION_MAJOR,
#else
                       IIS_SERVER_VERSION_MAJOR,
#endif
                       0 ))
    {
        DBGPRINTF((DBG_CONTEXT,
            "Error %d setting major version %x\n",
            GetLastError(), IIS_VERSION_MAJOR));
    }

    if ( !mb.SetDword( IIS_MD_SVC_INFO_PATH,
                       MD_SERVER_VERSION_MINOR,
                       IIS_MD_UT_SERVER,
#ifdef _IIS_5_1
                       IIS_VERSION_MINOR,
#else
                       IIS_SERVER_VERSION_MINOR,
#endif
                       0 ))
    {
        DBGPRINTF((DBG_CONTEXT,
            "Error %d setting minor version %x\n",
            GetLastError(), IIS_VERSION_MINOR));
    }

    //
    // set platform type
    //

    switch (IISGetPlatformType()) {

        case PtNtServer:
            productType = INET_INFO_PRODUCT_NTSERVER;
            capabilities = IIS_CAP1_NTS;
            break;
        case PtNtWorkstation:
            productType = INET_INFO_PRODUCT_NTWKSTA;
            capabilities = IIS_CAP1_NTW;
            break;
        default:
            productType = INET_INFO_PRODUCT_UNKNOWN;
            capabilities = IIS_CAP1_NTW;
    }

    if ( !mb.SetDword( IIS_MD_SVC_INFO_PATH,
                       MD_SERVER_PLATFORM,
                       IIS_MD_UT_SERVER,
                       productType,
                       0 ))
    {
        DBGPRINTF((DBG_CONTEXT,
            "Error %d setting platform type %x\n",
            GetLastError(), productType));

    }

    //
    //  Check to see if FrontPage is installed
    //

    if ( !RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                        REG_FP_PATH,
                        0,
                        KEY_READ,
                        &hkey ))
    {
        capabilities |= IIS_CAP1_FP_INSTALLED;

        DBG_REQUIRE( !RegCloseKey( hkey ));
    }

    //
    // We also need to determine the IIS_CAP1_DIGEST_SUPPORT and IIS_CAP1_NT_CERTMAP_SUPPORT
    // bits but we don't do it here because Net Api calls take forever resulting in Service Control
    // Manager timeouts. Hence we do that check in the InitializeService method (only for W3C).
    //

    //
    // Set the capabilities flag
    //

    if ( !mb.SetDword( IIS_MD_SVC_INFO_PATH,
                       MD_SERVER_CAPABILITIES,
                       IIS_MD_UT_SERVER,
                       capabilities,
                       0 ))
    {
        DBGPRINTF((DBG_CONTEXT,
            "Error %d setting capabilities flag %x\n",
            GetLastError(), capabilities));

    }

    mb.Close();
    return;

} // IIS_SERVICE::AdvertiseServiceInformationInMB



IUnknown *
IIS_SERVICE::QueryMDObject(
    VOID
    )
{
    return IIS_SERVICE::sm_MDObject;

} // IIS_SERVICE::QueryMDObject


IUnknown *
IIS_SERVICE::QueryMDNseObject(
    VOID
    )
{
    return IIS_SERVICE::sm_MDNseObject;

} // IIS_SERVICE::QueryMDObject


DWORD
InitMetadataDCom(
    PVOID Context,
    PVOID NseContext
    )
/*++

    Routine:
        A dummy thread, used only to create the Metadata DCOM object in
            the right fashion.

    Arguments:
        Context - Pointer to the global md object pointer
        NseContext - Pointer to the global md NSE object pointer
                     Note: NSE (NSEPM) is legacy not supported on IIS6 any more.
                     It will always be set to NULL


    Returns:
        TRUE if we initialized DCOM properly, FALSE otherwise.

--*/
{
    HRESULT     hRes;
    IMDCOM*     pcCom;
    BOOL        fRet = FALSE;
    IMDCOM **   pMetaObject = (IMDCOM**)Context;
    IMDCOM **   pNseMetaObject = (IMDCOM**)NseContext;

    hRes = CoInitializeEx(NULL, COINIT_MULTITHREADED);

    if (FAILED(hRes) && (hRes != E_INVALIDARG) ) {
        DBGPRINTF((DBG_CONTEXT,"CoInitializeEx failed %x\n", hRes));
        DBG_ASSERT(FALSE);
        return FALSE;
    }

    hRes = CoCreateInstance(
#ifndef _KETADATA
                        GETMDCLSID(TRUE),
#else
                        GETMDPCLSID(TRUE),
#endif
                        NULL,
                        CLSCTX_SERVER,
                        IID_IMDCOM,
                        (void**) &pcCom
                        );

    if (!FAILED(hRes)) {

        hRes = pcCom->ComMDInitialize();

        if (FAILED(hRes)) {

            DBGPRINTF((DBG_CONTEXT,"MDInitialize failed with %x\n", hRes));
            pcCom->Release();
            goto exit;

        }

        *pMetaObject = pcCom;
        *pNseMetaObject = NULL;
        
        IF_DEBUG(METABASE) {
            DBGPRINTF((DBG_CONTEXT,"CoCreateInstance returns %x\n", pcCom));
        }
        fRet = TRUE;
        goto exit;

    } else {
        DBGPRINTF((DBG_CONTEXT,"CoCreateInstance failed with %x\n", hRes));
    }

exit:

    CoUninitialize( );
    return(fRet);

} // InitMetadataDCom


BOOL
IIS_SERVICE::RecordInstanceStart( VOID )
/*++

    Description:

        Records that an instance is starting.

    Arguments:

        None.

    Returns:

        BOOL - TRUE if it's OK to start the instance, FALSE if it
            must not be started.

--*/
{

    LONG result;

    result = InterlockedIncrement( &m_nStartedInstances );

    if( !TsIsNtServer() && result > 1 ) {
        InterlockedDecrement( &m_nStartedInstances );
        return FALSE;
    }

    return TRUE;

}   // IIS_SERVICE::RecordInstanceStart


VOID
IIS_SERVICE::RecordInstanceStop( VOID )
/*++

    Description:

        Records that an instance is stopping.

    Arguments:

        None.

    Returns:

        None.

--*/
{

    LONG result;

    result = InterlockedDecrement( &m_nStartedInstances );
    DBG_ASSERT( result >= 0 );

}   // IIS_SERVICE::RecordInstanceStop


BOOL
I_StopInstanceEndpoint( PVOID                 pvContext1,
                        PVOID                 pvContext2,
                        IIS_SERVER_INSTANCE * pInstance )
{
    IF_DEBUG( INSTANCE) {

        DBGPRINTF(( DBG_CONTEXT,
                    "I_StopInstanceEndpoint( %p, %p, %08p)\n",
                    pvContext1, pvContext2, pInstance));
    }

    DBG_ASSERT( NULL == pvContext1);
    DBG_ASSERT( NULL == pvContext2);

    return ( pInstance->StopEndpoints());
} // I_StopInstanceEndpoint()




VOID
WINAPI
ServiceShutdownIndicator( VOID * pSvcContext)
{
    IIS_SERVICE * pIisService = (IIS_SERVICE * ) pSvcContext;

    IF_DEBUG( INSTANCE) {
        DBGPRINTF(( DBG_CONTEXT,
                    "ServiceShutdownIndicator(%p)\n", pSvcContext));
    }

    if ( pSvcContext == NULL) {

        DBGPRINTF(( DBG_CONTEXT,
                    " ServiceShutdownIndicator() called with NULL service\n"));
    }

    // Do Shutdown processing work ...
    DBG_ASSERT( pIisService->QueryShutdownScheduleId() != 0);
    pIisService->ShutdownScheduleCallback();

    return;

} // ServiceShutdownIndicator()


DWORD
IIS_SERVICE::ShutdownScheduleCallback(VOID)
/*++
  Description:
    This function is the periodic callback from scheduler for IIS_SERVICE to
    tell the Service Control Manager that we are shutting down
    and need more time.

    Problem: IIS_SERVICE shutdown operation takes long time. The time is
    highly dependent on the number of components to be shutdown, number
    of IO operations to be cancelled and cleaned up, etc.
    Service Control Manager(SCM) in NT allows the Service shutdown to
    happen within a specified time limit - usually less than 20 seconds.
    If the shutdown did not happen within this window, NT SCM will report
    shutdown failure.

    This function will indicate to SCM that we will need more time to shutdown.

  Arguments:
    None

  Returns:
    NO_ERROR on success. DWORD on error.

--*/
{

    m_nShutdownIndicatorCalls++;

# define NUM_SHUTDOWN_INDICATOR_CALLS_FOR_ONE_MINUTE \
    ( (60 * 1000) / MS_SERVICE_SHUTDOWN_INDICATOR_TIME_INTERVAL)

    if ( (m_nShutdownIndicatorCalls %
          NUM_SHUTDOWN_INDICATOR_CALLS_FOR_ONE_MINUTE)
         == 0) {

        char rgchShutdown[256];

        //
        // Generate a message telling that shutdown is in progress
        //

        wsprintf( rgchShutdown,
                  "[%d]Service (%s) shutting down for %d minutes ... \n",
                  GetCurrentThreadId(),
                  QueryServiceName(),
                  (m_nShutdownIndicatorCalls /
                   NUM_SHUTDOWN_INDICATOR_CALLS_FOR_ONE_MINUTE
                   )
                  );

        OutputDebugString( rgchShutdown);
    }

    DBG_ASSERT( m_dwShutdownScheduleId);

    //
    // Indicate to the SCM that we are in shutdown
    //

    DBG_REQUIRE( NO_ERROR ==
                DelayCurrentServiceCtrlOperation( SERVICE_STOP_WAIT_HINT)
                );

    return (NO_ERROR);
} // IIS_SERVICE::ShutdownScheduleCallback()



VOID
IIS_SERVICE::StartUpIndicateClientActivity(VOID)
{
    DWORD dwCurrentTime;

    if ( m_svcStatus.dwCurrentState == SERVICE_START_PENDING)
    {
        m_dwClientStartActivityIndicator++;

        dwCurrentTime = GetCurrentTimeInSeconds();
        if (dwCurrentTime > m_dwNextSCMUpdateTime)
        {
            m_dwNextSCMUpdateTime = dwCurrentTime + IIS_SERVICE_START_INDICATOR_INTERVAL_SECONDS;
            m_dwStartUpIndicatorCalls++;
            if (m_dwStartUpIndicatorCalls < MAX_NUMBER_OF_START_HINT_REPETITIONS)
            {
                UpdateServiceStatus( SERVICE_START_PENDING,
                                     NO_ERROR,
                                     m_dwClientStartActivityIndicator,
                                     IIS_SERVICE_START_WAIT_HINT_EXTENDED + IIS_SERVICE_START_INDICATOR_INTERVAL);
            }
            else
            {
                DBGPRINTF(( DBG_CONTEXT," StartUpIndicateClientActivity max startup extension periods exceeded\n"));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\common\inetreg.h ===
/*++

   Copyright    (c)    1995    Microsoft Corporation

   Module  Name :

      inetreg.h

   Abstract:

      This file consists of the registry entries used by Internet Services
       common dll.

   Author:

       Murali R. Krishnan    ( MuraliK )    31-July-1995

   Environment:

       Win32 - User Mode

   Project:

       Internet Services Common DLL

   Revision History:

--*/

#ifndef _INETREG_H_
#define _INETREG_H_


/************************************************************
 *   Symbolic Constants
 ************************************************************/


//
//  Common service configuration value names.
//

//  common for all objects

#define INETA_BANDWIDTH_LEVEL           TEXT("BandwidthLevel")
#define INETA_OBJECT_CACHE_TTL          TEXT("ObjectCacheTTL")

//
// per instance
//

//#define INETA_ADMIN_NAME               TEXT("AdminName")
//#define INETA_ADMIN_NAME_W             L"AdminName"
//#define INETA_ADMIN_EMAIL              TEXT("AdminEmail")
//#define INETA_ADMIN_EMAIL_W            L"AdminEmail"
#define INETA_SERVER_COMMENT           TEXT("ServerComment")
#define INETA_SERVER_COMMENT_W         L"ServerComment"
#define INETA_AUTHENTICATION           TEXT("Authorization")
#define INETA_LOG_ANONYMOUS            TEXT("LogAnonymous")
#define INETA_LOG_NONANONYMOUS         TEXT("LogNonAnonymous")
#define INETA_ANON_USER_NAME           TEXT("AnonymousUserName")
#define INETA_ANON_USER_NAME_W         L"AnonymousUserName"
//#define INETA_MAX_CONNECTIONS          TEXT("MaxConnections")
//#define INETA_CONNECTION_TIMEOUT       TEXT("ConnectionTimeout")
#define INETA_DEBUG_FLAGS              TEXT("DebugFlags")
//#define INETA_PORT                     TEXT("Port")
//#define INETA_PORT_SECURE              TEXT("SecurePort")
#define INETA_DEFAULT_LOGON_DOMAIN     TEXT("DefaultLogonDomain")
#define INETA_DEFAULT_LOGON_DOMAIN_W   L"DefaultLogonDomain"
#define INETA_LOGON_METHOD             TEXT("LogonMethod")
//#define INETA_SERVER_NAME              TEXT("ServerName")
//#define INETA_SERVER_NAME_W            L"ServerName"
//#define INETA_IP_ADDRESS               TEXT("IPAddress")
//#define INETA_HOST_NAME                TEXT("HostName")
//#define INETA_HOST_NAME_W              L"HostName"
#define INETA_LOGON_ANON_SUBAUTH       TEXT("LogonAnonymousUsingSubAuth")
#define INETA_DEF_LEVELS_TO_SCAN       2
//
// per service
//

#define INETA_ENABLE_SVC_LOCATION      TEXT("EnableSvcLoc")

//
//  The registry parameter key names for the grant list and deny
//  list.  We use the kludgemultisz thing for Chicago
//

#define IPSEC_DENY_LIST             "Deny IP List"
#define IPSEC_GRANT_LIST            "Grant IP List"

//
//  Size of the server.  0 - small, 1 - medium, 2 - big
//

#define INETA_SERVER_SIZE              TEXT("ServerSize")

//
//  Determines the number of outstanding AcceptEx sockets that should always
//  be available
//

#define INETA_ACCEPTEX_OUTSTANDING     TEXT("AcceptExOutstanding")

//
//  Determines the time (in seconds) we'll allow an AcceptEx socket to be
//  in the initial "Receive" state before timing it out
//

#define INETA_ACCEPTEX_TIMEOUT         TEXT("AcceptExTimeout")

//
//  Default values for the above parameters
//
#define INETA_DEF_BANDWIDTH_LEVEL                   (INFINITE)
#define INETA_DEF_OBJECT_CACHE_TTL                  (30)   // 30 seconds

//
// Timeouts are high to prevent async ios from being cancelled if a thread
// goes away.
//

#define INETA_DEF_THREAD_TIMEOUT                    (24*60*60) // 24 hours
#define INETA_DEF_THREAD_TIMEOUT_PWS                (30*60)    // 30 mins
#define INETA_DEF_ENABLE_SVC_LOCATION               (TRUE)

//
// fake xmit file buffer size
//

#define INETA_DEF_NONTF_BUFFER_SIZE                 (4096)
#define INETA_MIN_NONTF_BUFFER_SIZE                 (512)
#define INETA_MAX_NONTF_BUFFER_SIZE                 (64 * 1024)


#define INETA_DEF_ADMIN_NAME            ""
#define INETA_DEF_ADMIN_EMAIL           ""
#define INETA_DEF_SERVER_COMMENT        ""

#define INETA_LOGM_INTERACTIVE          0
#define INETA_LOGM_BATCH                1
#define INETA_LOGM_NETWORK              2

#define INETA_DEF_AUTHENTICATION        INET_INFO_AUTH_ANONYMOUS
#define INETA_DEF_LOG_ANONYMOUS         FALSE
#define INETA_DEF_LOG_NONANONYMOUS      FALSE
#define INETA_DEF_ANON_USER_NAME        "Guest"
#define INETA_DEF_MAX_CONNECTIONS       (DWORD)(0x77359400)
#define INETA_DEF_MAX_ENDPOINT_CONNECTIONS (DWORD)(0x77359400)
#define INETA_DEF_CONNECTION_TIMEOUT    600
#define INETA_DEF_DEBUG_FLAGS           0
#define INETA_DEF_PORT                  0
#define INETA_DEF_ACCEPTEX_OUTSTANDING  40
#define INETA_DEF_ACCEPTEX_TIMEOUT      120
#define INETA_DEF_SERVER_SIZE           MD_SERVER_SIZE_MEDIUM
#define INETA_DEF_MIN_KB_SEC            1000
#define INETA_DEF_DEFAULT_LOGON_DOMAIN  ""
#define INETA_DEF_LOGON_METHOD          INETA_LOGM_INTERACTIVE
#define INETA_DEF_SERVER_NAME           ""
#define INETA_DEF_AUTO_START            TRUE
#define INETA_DEF_IP_ADDRESS            INADDR_ANY
#define INETA_DEF_HOST_NAME             ""
#define INETA_DEF_LOGON_ANON_SUBAUTH    FALSE

//
// PWS connection limit
//

#define INETA_DEF_MAX_CONNECTIONS_PWS   10
#define INETA_MAX_MAX_CONNECTIONS_PWS   40
#define INETA_DEF_MAX_ENDPOINT_CONNECTIONS_PWS   10
#define INETA_MAX_MAX_ENDPOINT_CONNECTIONS_PWS   40

//
//  The key name the list of virtual roots is stored under
//

#define VIRTUAL_ROOTS_SEC_KEY   L"Virtual Roots\\Security"
#define VIRTUAL_ROOTS_KEY_A     "Virtual Roots"
#define HTTP_EXT_MAPS           "Script Map"

#endif // _INETREG_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\common\instance.cxx ===
/*++

   Copyright    (c)    1994    Microsoft Corporation

   Module  Name :

        instance.cxx

   Abstract:

        Defines the functions for TCP services Info class.
        This module is intended to capture the common scheduler
            code for the tcp services ( especially internet services)
            which involves the Service Controller dispatch functions.
        Also this class provides an interface for common dll of servers.

   Author:

           Murali R. Krishnan    ( MuraliK )     15-Nov-1994

   Project:

          Internet Servers Common DLL

--*/


#include "tcpdllp.hxx"
#include <rpc.h>
#include <tsunami.hxx>
#include <iistypes.hxx>
#include <iisbind.hxx>
#include "inetreg.h"
#include "tcpcons.h"
#include "apiutil.h"
#include <imd.h>
#include <mb.hxx>

#include "reftrce2.h"

/************************************************************
 *    Symbolic Constants
 ************************************************************/

//
// LOCAL Functions
//

static ULONGLONG InetServiceIdForService( IN DWORD serviceId);

#define MAX_ADDRESSES_SUPPORTED           20
#define SIZEOF_IP_SEC_LIST( IPList )      (sizeof(INET_INFO_IP_SEC_LIST) + \
                                           (IPList)->cEntries *        \
                                           sizeof(INET_INFO_IP_SEC_ENTRY))


#if SERVICE_REF_TRACKING
//
//  Ref count trace log size
//
#define C_INSTANCE_REFTRACES        4000
#define C_LOCAL_INSTANCE_REFTRACES    40

#endif // SERVICE_REF_TRACKING
//
PTRACE_LOG IIS_SERVER_INSTANCE::sm_pDbgRefTraceLog = NULL;


IIS_SERVER_INSTANCE::IIS_SERVER_INSTANCE(
        IN PIIS_SERVICE pService,
        IN DWORD  dwInstanceId,
        IN USHORT sPort,
        IN LPCSTR lpszRegParamKey,
        IN LPWSTR lpwszAnonPasswordSecretName,
        IN LPWSTR lpwszVirtualRootsSecretName,
        IN BOOL   fMigrateVroots
        )
/*++
    Desrcription:

        Contructor for IIS_SERVER_INSTANCE class.
        This constructs a new service info object for the service specified.

    Arguments:

        pService - pointer to the service object.

        dwInstanceId - Instance number of this instance.

        sPort - Default port number

        lpszRegParamKey
            fully qualified name of the registry key that contains the
            common service data for this server

        lpszAnonPasswordSecretName
            The name of the LSA secret the anonymous password is stored under

        lpszVirtualRootsSecretName
            The name of the LSA secret the virtual root passwords are stored
            under

    On success it initializes all the members of the object,
     inserts itself to the global list of service info objects and
     returns with success.

    Note:
        The caller of this function should check the validity by
        invoking the member function IsValid() after constructing
        this object.

--*/
:
    m_tslock              ( ),
    m_fZapRegKey          ( FALSE),
    m_fDoServerNameCheck  ( FALSE),
    m_reference           ( 0),
    m_pDbgRefTraceLog     ( NULL),
    m_sDefaultPort        ( sPort ),
    m_dwServerState       ( MD_SERVER_STATE_STOPPED),
    m_dwSavedState        ( MD_SERVER_STATE_STOPPED),
    m_Service             ( pService),
    m_instanceId          ( dwInstanceId),
    m_strParametersKey    ( lpszRegParamKey),
    m_cReadLocks          ( 0),
    m_lpwszAnonPasswordSecretName( lpwszAnonPasswordSecretName ),
    m_lpwszRootPasswordSecretName( lpwszVirtualRootsSecretName ),
    m_strMDPath           ( ),
    m_strSiteName         ( ),
    m_strMDVirtualRootPath( ),
    m_dwMaxConnections    ( INETA_DEF_MAX_CONNECTIONS),
    m_dwMaxEndpointConnections( INETA_DEF_MAX_ENDPOINT_CONNECTIONS ),
    m_dwCurrentConnections( 0),
    m_dwConnectionTimeout ( INETA_DEF_CONNECTION_TIMEOUT),
    m_dwServerSize        ( INETA_DEF_SERVER_SIZE),
    m_nAcceptExOutstanding( INETA_DEF_ACCEPTEX_OUTSTANDING),
    m_AcceptExTimeout     ( INETA_DEF_ACCEPTEX_TIMEOUT),
    m_dwLevelsToScan      ( INETA_DEF_LEVELS_TO_SCAN ),
    m_fAddedToServerInstanceList( FALSE ),
    m_pBandwidthInfo      ( NULL )
{

    BOOL                    fReferenced = FALSE;

    DBG_ASSERT( lpszRegParamKey != NULL );

    IF_DEBUG(INSTANCE) {
        DBGPRINTF( ( DBG_CONTEXT,"Creating iis instance %p [%u]. \n",
                     this, dwInstanceId));
    }

    //
    // Limit PWS connections
    //

    if ( !TsIsNtServer() ) {
        m_dwMaxConnections = INETA_DEF_MAX_CONNECTIONS_PWS;
    }

    //
    // initialize locks
    //

    INITIALIZE_CRITICAL_SECTION(&m_csLock);

    //
    // initialize binding support
    //

    InitializeListHead( &m_NormalBindingListHead );
    InitializeListHead( &m_SecureBindingListHead );

#if SERVICE_REF_TRACKING
    m_pDbgRefTraceLog = CreateRefTraceLog(C_LOCAL_INSTANCE_REFTRACES, 0);
#endif // SERVICE_REF_TRACKING

    //
    // reference the service
    //

    if ( !pService->CheckAndReference( )) {
        goto error_exit;
    }

    //
    // remember if we referenced the service
    //

    fReferenced = TRUE;

    m_Service = pService;

    //
    // Set the metabase path
    //

    if ( QueryInstanceId() == INET_INSTANCE_ROOT ) {

        DBG_ASSERT( FALSE );

    } else {

        CHAR szTemp[64];

        wsprintf(szTemp,"/%s/%s/%d",
            IIS_MD_LOCAL_MACHINE_PATH,
            pService->QueryServiceName(),
            QueryInstanceId());

        m_strMDPath.Copy(szTemp);

        wsprintf(szTemp,"/%s/%s/%d/%s/",
            IIS_MD_LOCAL_MACHINE_PATH,
            pService->QueryServiceName(),
            QueryInstanceId(),
            IIS_MD_INSTANCE_ROOT );

        m_strMDVirtualRootPath.Copy(szTemp);

        /* This doesn't do anything.

        if ( fMigrateVroots ) {
            MoveVrootFromRegToMD();
        }

        */
    }

    //
    // Initialize the bare minimum parameters needed to start.
    //

    if ( !RegReadCommonParams( FALSE, FALSE))
    {
        goto error_exit;
    }

    //
    // Set a reasonable initial state.
    //

    SetServerState(
        MD_SERVER_STATE_STOPPED,
        NO_ERROR
        );

    //
    // link this to the service
    //

    if ( dwInstanceId != INET_INSTANCE_ROOT ) {
        if ( !pService->AddServerInstance( this ) ) {
            DBG_ASSERT(m_reference == 0);
            goto error_exit;
        }
        DBG_ASSERT(m_reference == 1);
    }

    m_fAddedToServerInstanceList = TRUE;
    return;

error_exit:

    if ( fReferenced )
    {
        m_Service->Dereference();
    }

    m_dwServerState = MD_SERVER_STATE_INVALID;
    DBG_ASSERT(m_reference == 0);
    return;

} // IIS_SERVER_INSTANCE::IIS_SERVER_INSTANCE()



IIS_SERVER_INSTANCE::~IIS_SERVER_INSTANCE( VOID)
/*++

    Description:

        Cleanup the instance object. If the service is not already
         terminated, it terminates the service before cleanup.

    Arguments:
        None

    Returns:
        None

--*/
{
    DBG_ASSERT(m_dwServerState != MD_SERVER_STATE_STARTED);
    DBG_ASSERT(m_reference == 0);

    //
    //  If we failed to create this instance or it's getting deleted, remove
    //  the configuration tree
    //

    if ( m_fZapRegKey ) {
        DBGPRINTF((DBG_CONTEXT,"Zapping reg key for %p\n",this));
        ZapRegistryKey( NULL, QueryRegParamKey() );
        ZapInstanceMBTree( );
    }

    //
    // endpoints should have been dereferenced
    //

    DBG_ASSERT(IsListEmpty( &m_NormalBindingListHead ));
    DBG_ASSERT(IsListEmpty( &m_SecureBindingListHead ));

    //
    // dereference the service
    //

    if ( m_fAddedToServerInstanceList && m_Service != NULL ) {
        m_Service->Dereference( );
    }

    //
    // destroy bandwidth throttling descriptor
    //

    if ( m_pBandwidthInfo != NULL )
    {
        AtqFreeBandwidthInfo( m_pBandwidthInfo );
        m_pBandwidthInfo = NULL;
    }

#if SERVICE_REF_TRACKING
    DestroyRefTraceLog( m_pDbgRefTraceLog );
#endif // SERVICE_REF_TRACKING

    DeleteCriticalSection(&m_csLock);

} // IIS_SERVER_INSTANCE::~IIS_SERVER_INSTANCE()




//
//  Static Functions belonging to IIS_SERVICE class
//

BOOL
IIS_SERVER_INSTANCE::Initialize( VOID)
/*++
    Description:

        This function initializes all necessary local data for
        IIS_SERVER_INSTANCE class

        Only the first initialization call does the initialization.
        Others return without any effect.

        Should be called from the entry function for DLL.

    Arguments:
        None

    Returns:
        TRUE on success and FALSE if any failure.

--*/
{
#if SERVICE_REF_TRACKING
    if (sm_pDbgRefTraceLog == NULL)
    {
        sm_pDbgRefTraceLog = CreateRefTraceLog(C_INSTANCE_REFTRACES, 0);
        IF_DEBUG( INSTANCE ) {
            DBGPRINTF((DBG_CONTEXT,"IIS_SERVER_INSTANCE RefTraceLog=%p\n",
                       sm_pDbgRefTraceLog));
        }
    }
#endif // SERVICE_REF_TRACKING

    return TRUE;
}



VOID
IIS_SERVER_INSTANCE::Cleanup(
                        VOID
                        )
/*++
    Description:

        Cleanup the data stored.
        This function should be called only after freeing all the
        services running using this DLL.
        This function is called typically when the DLL is unloaded.

    Arguments:
        None

    Returns:
        None

--*/
{
#if SERVICE_REF_TRACKING
    if (sm_pDbgRefTraceLog != NULL)
    {
        IF_DEBUG( INSTANCE ) {
            DBGPRINTF((DBG_CONTEXT,
                       "IIS_SERVER_INSTANCE: Closing RefTraceLog=%p\n",
                       sm_pDbgRefTraceLog));
        }
        DestroyRefTraceLog( sm_pDbgRefTraceLog );
    }
    sm_pDbgRefTraceLog = NULL;
#endif // SERVICE_REF_TRACKING
}



# if 0

VOID
IIS_SERVER_INSTANCE::Print( VOID) const
{
    IIS_SERVER_INSTANCE::Print();

    DBGPRINTF( ( DBG_CONTEXT,
                " Printing IIS_SERVER_INSTANCE object ( %08p) \n"
                " State = %u.\n"
                ,
                this, m_dwServerState
                ));

    DBGPRINTF(( DBG_CONTEXT,
               " Server Admin Params: \n"
               " Log Anon = %u. Log NonAnon = %u.\n"
               ,
               m_fLogAnonymous, m_fLogNonAnonymous
               ));

    DBGPRINTF(( DBG_CONTEXT,
               " Printing IIS_SERVER_INSTANCE object (%08p)\n"
               " Readers # = %u.\n"
               " Reg Parameters Key = %s\n"
               " MaxConn = %d. ConnTimeout = %u secs.\n"
               ,
               this,
               m_cReadLocks,
               m_strParametersKey.QueryStr(),
               m_dwMaxConnections, m_dwConnectionTimeout
               ));
    return;
}   // IIS_SERVER_INSTANCE::Print()

#endif // DBG


VOID
IIS_SERVER_INSTANCE::Reference(  )
{
    InterlockedIncrement( &m_reference );
    LONG lEntry = SHARED_LOG_REF_COUNT();
    LOCAL_LOG_REF_COUNT();
    IF_DEBUG( INSTANCE )
        DBGPRINTF((DBG_CONTEXT, "IIS_SERVER_INSTANCE ref count %ld\n (%ld)",
                   m_reference, lEntry));
}

VOID
IIS_SERVER_INSTANCE::Dereference( )
{
    LONG lEntry = SHARED_EARLY_LOG_REF_COUNT();
    LOCAL_EARLY_LOG_REF_COUNT();

    LONG Reference = InterlockedDecrement( &m_reference );
    if ( 0 == Reference) {
        IF_DEBUG( INSTANCE )
            DBGPRINTF((DBG_CONTEXT, "deleting IIS_SERVER_INSTANCE %p (%ld)\n",
                       this, lEntry));
        delete this;
    } else {
        IF_DEBUG( INSTANCE )
            DBGPRINTF((DBG_CONTEXT, "IIS_SERVER_INSTANCE deref count %ld (%ld)\n",
                       Reference, lEntry));
    }
}


VOID
IIS_SERVER_INSTANCE::ZapInstanceMBTree(
    VOID
    )
{

    MB  mb( (IMDCOM*) m_Service->QueryMDObject()  );

    //
    // Do the metabase
    //

    IF_DEBUG(METABASE) {
        DBGPRINTF((DBG_CONTEXT,"Deleting metabase node %s\n",
                  QueryMDPath()));
    }

    if ( !mb.Open( "/",
                   METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE ))
    {
        IF_DEBUG(METABASE) {
            DBGPRINTF((DBG_CONTEXT,"Open MD instance root %s returns %d\n",
                      "/", GetLastError() ));
        }
        return;
    }

    //
    // Delete the instance tree
    //

    if ( !mb.DeleteObject( QueryMDPath() ))
    {
        IF_DEBUG(METABASE) {
            DBGPRINTF((DBG_CONTEXT,
                      "Deleting instance node %s returns %d\n",
                      QueryMDPath(),
                      GetLastError()));
        }
    }

    return;

} // IIS_SERVER_INSTANCE::ZapInstanceMBTree


DWORD
IIS_SERVER_INSTANCE::BindInstance(
    VOID
    )
/*++

Routine Description:

    Binds an instance to all configured endpoints (normal & secure).

Arguments:

    None.

Return Value:

    DWORD - Completion status, 0 if successful, !0 otherwise.

--*/
{

    DWORD err;

    //
    // Update the "normal" (i.e. non-secure) bindings.
    //

    err = UpdateNormalBindings();

    if( err != NO_ERROR ) {

        IF_DEBUG(INSTANCE) {
            DBGPRINTF((DBG_CONTEXT, "UpdateNormalBindings() failed, %lu\n", err));
        }

        return err;

    }

    //
    // Update the secure bindings.
    //

    err = UpdateSecureBindings();

    if( err != NO_ERROR ) {

        IF_DEBUG(INSTANCE) {
            DBGPRINTF((DBG_CONTEXT, "UpdateSecureBindings() failed, %lu\n", err));
        }

        //
        // The main port(s) are OK, but the SSL port(s) failed,
        // so start anyway.
        //

        err = NO_ERROR;

    }

    //
    // Success!
    //

    DBG_ASSERT( err == NO_ERROR );
    return NO_ERROR;

}   // IIS_SERVER_INSTANCE::BindInstance


DWORD
IIS_SERVER_INSTANCE::UnbindInstance(
    VOID
    )
/*++

Routine Description:

    Removes all bindings from an instance.

Arguments:

    None.

Return Value:

    DWORD - Completion status, 0 if successful, !0 otherwise.

--*/
{

    LockThisForWrite();
    DBG_REQUIRE( RemoveNormalBindings() == NO_ERROR );
    DBG_REQUIRE( RemoveSecureBindings() == NO_ERROR );
    UnlockThis();

    return NO_ERROR;

}   // IIS_SERVER_INSTANCE::UnbindInstance


DWORD
IIS_SERVER_INSTANCE::UnbindHelper(
    IN PLIST_ENTRY BindingListHead
    )
/*++

Routine Description:

    Helper routine for UnbindInstance().

Arguments:

    BindingListHead - The binding list to remove.

Return Value:

    DWORD - Completion status, 0 if successful, !0 otherwise.

--*/
{

    PLIST_ENTRY listEntry;
    PIIS_SERVER_BINDING binding;

    //
    // Walk the list of bindings and destroy them.
    //

    while( !IsListEmpty( BindingListHead ) ) {

        listEntry = RemoveHeadList( BindingListHead );

        binding = CONTAINING_RECORD(
                      listEntry,
                      IIS_SERVER_BINDING,
                      m_BindingListEntry
                      );

        IF_DEBUG( INSTANCE ) {
            DBGPRINTF((
                DBG_CONTEXT,
                "unbinding %p from %p, binding %p (%lx:%d:%s)\n",
                binding->QueryEndpoint(),
                this,
                binding,
                binding->QueryIpAddress(),
                binding->QueryEndpoint()->QueryPort(),
                binding->QueryHostName()
                ));
        }

        binding->QueryEndpoint()->RemoveInstance(
            this,
            binding->QueryIpAddress(),
            binding->QueryHostName()
            );

        binding->QueryEndpoint()->Dereference();
        delete binding;

    }

    //
    // Success!
    //

    return NO_ERROR;

}   // IIS_SERVER_INSTANCE::UnbindHelper


DWORD
IIS_SERVER_INSTANCE::UpdateBindingsHelper(
    IN BOOL IsSecure
    )
/*++

Routine Description:

    Helper routine for UpdateNormalBindings() and UpdateSecureBindings().

Arguments:

    IsSecure - TRUE if we're to update the secure bindings, FALSE for
        the normal bindings.

Return Value:

    DWORD - Completion status, 0 if successful, !0 otherwise.

--*/
{

    MB mb( (IMDCOM*)m_Service->QueryMDObject() );
    MULTISZ msz;
    DWORD status = NO_ERROR;
    const CHAR * scan;
    DWORD ipAddress;
    USHORT ipPort;
    const CHAR * hostName;
    PIIS_SERVER_BINDING binding;
    LIST_ENTRY createdBindings;
    PLIST_ENTRY listEntry;
    PLIST_ENTRY targetBindingListHead;
    USHORT targetDefaultPort;
    DWORD targetMetadataId;
    DWORD numBindings = 0;
    const CHAR * apszSubStrings[2];
    CHAR instanceIdString[sizeof("4294967295")];
    DWORD fDisableSocketPooling;

    //
    // Setup locals.
    //

    InitializeListHead( &createdBindings );

    if( IsSecure ) {
        targetBindingListHead = &m_SecureBindingListHead;
        targetDefaultPort = 0;
        targetMetadataId = MD_SECURE_BINDINGS;
    } else {
        targetBindingListHead = &m_NormalBindingListHead;
        targetDefaultPort = m_sDefaultPort;
        targetMetadataId = MD_SERVER_BINDINGS;
    }

    //
    // Open the metabase and get the current binding list.
    //

    if( mb.Open( QueryMDPath() ) ) {

        if( !mb.GetMultisz(
                "",
                targetMetadataId,
                IIS_MD_UT_SERVER,
                &msz
                ) ) {

            status = GetLastError();

        }

        //
        // Get socket pooling flag.
        //

        mb.GetDword( "",
                     MD_DISABLE_SOCKET_POOLING,
                     IIS_MD_UT_SERVER,
                     FALSE,
                     &fDisableSocketPooling
                     );
        //
        // Close the metabase before continuing, as anyone that needs
        // to update the service status will need write access.
        //

        mb.Close();

    } else {

        status = GetLastError();

    }

    //
    // Lock the instance.
    //

    LockThisForWrite();

    if ( status == MD_ERROR_DATA_NOT_FOUND ) {
        //
        // if the bindings just don't exist (as happens on service creation)
        // don't log an error.
        //
        goto fatal_nolog;
    } else if( status != NO_ERROR ) {
        goto fatal;
    }

    //
    // Scan the multisz and look for instances we'll need to create.
    //

    for( scan = msz.First() ;
         scan != NULL ;
         scan = msz.Next( scan ) ) {

        //
        // Parse the descriptor (in "ip_address:port:host_name" form)
        // into its component parts.
        //

        status = IIS_SERVER_BINDING::ParseDescriptor(
                                         scan,
                                         &ipAddress,
                                         &ipPort,
                                         &hostName
                                         );

        if( status == NO_ERROR ) {

            if( IsSecure ) {

                //
                // Secure bindings cannot key off the hostname, as
                // the hostname is encrypted in the header.
                //

                if( *hostName != '\0' ) {

                    DBGPRINTF((
                        DBG_CONTEXT,
                        "Secure bindings cannot have host name! %s\n",
                        scan
                        ));

                    wsprintfA(
                        instanceIdString,
                        "%lu",
                        QueryInstanceId()
                        );

                    apszSubStrings[0] = (const CHAR *)instanceIdString;
                    apszSubStrings[1] = (const CHAR *)scan;

                    m_Service->LogEvent(
                        INET_SVC_INVALID_SECURE_BINDING,
                        2,
                        apszSubStrings
                        );

                    //
                    // Press on regardless, but ignore the hostname.
                    //

                    hostName = "";

                }

            }

            //
            // See if the descriptor is in our current binding list.
            //

            if( IsInCurrentBindingList(
                    targetBindingListHead,
                    ipAddress,
                    ipPort,
                    hostName
                    ) ) {

                //
                // It is, so remember that we have a binding.
                //

                numBindings++;

            } else {

                //
                // It's not, so we need to create a new binding.
                //

                IF_DEBUG( INSTANCE ) {
                    DBGPRINTF((
                        DBG_CONTEXT,
                        "Adding %lx:%d:%s\n",
                        ipAddress,
                        ipPort,
                        hostName
                        ));
                }

                DBG_CODE( binding = NULL );

                status = CreateNewBinding(
                             ipAddress,
                             ipPort,
                             hostName,
                             IsSecure,
                             fDisableSocketPooling,
                             &binding
                             );

                if( status == NO_ERROR ) {

                    //
                    // Add the new binding to the local list of
                    // newly created bindings.
                    //

                    DBG_ASSERT( binding != NULL );

                    InsertTailList(
                        &createdBindings,
                        &binding->m_BindingListEntry
                        );

                    numBindings++;

                } else {

                    //
                    // Could not create the new binding.
                    //
                    // Press on regardless.
                    //

                }

            }

        } else {

            //
            // Could not parse the descriptor.
            //

            DBGPRINTF((
                DBG_CONTEXT,
                "UpdateNormalBindings: could not parse %s, error %lu\n",
                scan,
                status
                ));

            wsprintfA(
                instanceIdString,
                "%lu",
                QueryInstanceId()
                );

            apszSubStrings[0] = (const CHAR *)instanceIdString;
            apszSubStrings[1] = (const CHAR *)scan;

            m_Service->LogEvent(
                INET_SVC_INVALID_BINDING,
                2,
                apszSubStrings
                );

            //
            // Press on regardless.
            //

        }

    }

    if( status != NO_ERROR ) {

        if( numBindings == 0 ) {

            //
            // All bindings failed, so fail the request.
            //

            goto fatal;

        }

        //
        // At least one binding succeeded, so succeed the request.
        //

        status = NO_ERROR;

    }

    //
    // Scan the existing bindings and look for those that need to
    // be deleted.
    //

    listEntry = targetBindingListHead->Flink;

    while( listEntry != targetBindingListHead ) {

        binding = CONTAINING_RECORD(
                      listEntry,
                      IIS_SERVER_BINDING,
                      m_BindingListEntry
                      );

        listEntry = listEntry->Flink;

        if( !IsBindingInMultiSz(
                binding,
                msz
                ) ) {

            //
            // Got one. Remove it from the instance list, dereference
            // the corresponding endpoint, then delete the binding.
            //

            IF_DEBUG( INSTANCE ) {
                DBGPRINTF((
                    DBG_CONTEXT,
                    "zapping %p from %p, binding %p (%lx:%d:%s)\n",
                    binding->QueryEndpoint(),
                    this,
                    binding,
                    binding->QueryIpAddress(),
                    binding->QueryEndpoint()->QueryPort(),
                    binding->QueryHostName()
                    ));
            }

            binding->QueryEndpoint()->RemoveInstance(
                this,
                binding->QueryIpAddress(),
                binding->QueryHostName()
                );

            RemoveEntryList(
                &binding->m_BindingListEntry
                );

            binding->QueryEndpoint()->Dereference();
            delete binding;

        }

    }

    //
    // Move the newly created bindings over to the current binding
    // list.
    //

    targetBindingListHead->Blink->Flink = createdBindings.Flink;
    createdBindings.Flink->Blink = targetBindingListHead->Blink;
    createdBindings.Blink->Flink = targetBindingListHead;
    targetBindingListHead->Blink = createdBindings.Blink;

    UnlockThis();

    DBG_ASSERT( status == NO_ERROR );
    return NO_ERROR;

fatal:

    //
    // An unrecoverable binding error occured. Log an event.
    //

    DBG_ASSERT( status != NO_ERROR );

    wsprintfA(
        instanceIdString,
        "%lu",
        QueryInstanceId()
        );

    apszSubStrings[0] = (const CHAR *)instanceIdString;

    //
    // map ERROR_INVALID_PARAMETER to ERROR_DUP_NAME. this is what the UI expect, and results in
    // a more useful message
    //

    if (status == ERROR_INVALID_PARAMETER) {
        status = ERROR_DUP_NAME;
    }

    m_Service->LogEvent(
        INET_SVC_FATAL_BINDING_ERROR,
        1,
        apszSubStrings,
        status
        );

fatal_nolog:

    //
    // Loop through the local list of newly created bindings and delete them.
    //

    while( !IsListEmpty( &createdBindings ) ) {

        listEntry = RemoveHeadList(
                        &createdBindings
                        );

        binding = CONTAINING_RECORD(
                      listEntry,
                      IIS_SERVER_BINDING,
                      m_BindingListEntry
                      );

        IF_DEBUG( INSTANCE ) {
            DBGPRINTF((
                DBG_CONTEXT,
                "zapping %p from %p, binding %p (%lx:%d:%s) (ERROR)\n",
                binding->QueryEndpoint(),
                this,
                binding,
                binding->QueryIpAddress(),
                binding->QueryEndpoint()->QueryPort(),
                binding->QueryHostName()
                ));
        }

        binding->QueryEndpoint()->RemoveInstance(
            this,
            binding->QueryIpAddress(),
            binding->QueryHostName()
            );

        binding->QueryEndpoint()->Dereference();
        delete binding;

    }

    //
    // this is a fatal error - stop the service if it was running
    //

    DWORD serviceState = m_Service->QueryCurrentServiceState();
    DWORD currentState = QueryServerState();

    if( ( serviceState == SERVICE_RUNNING ||
          serviceState == SERVICE_PAUSED ) &&
        ( currentState == MD_SERVER_STATE_STARTED ||
          currentState == MD_SERVER_STATE_PAUSED ) ) {

        DWORD err = StopInstance();

        if( err != NO_ERROR ) {

            DBGPRINTF((
                DBG_CONTEXT,
                "UpdateBindingsHelper(): cannot stop instance, error %lu\n",
                err
                ));
        }
    }

    UnlockThis();
    return status;

}   // IIS_SERVER_INSTANCE::UpdateBindingsHelper


DWORD
IIS_SERVER_INSTANCE::CreateNewBinding(
    IN DWORD        IpAddress,
    IN USHORT       IpPort,
    IN const CHAR * HostName,
    IN BOOL         IsSecure,
    IN BOOL         fDisableSocketPooling,
    OUT IIS_SERVER_BINDING ** NewBinding
    )
/*++

Routine Description:

    Creates a new binding object for the specified ip address, port, and
    host name, and creates/references the appropriate endpoint object.

Arguments:

    IpAddress - The binding IP address. May be INADDR_ANY.

    IpPort - The binding IP port. Required.

    HostName - The binding host name. May be empty ("").

    IsSecure - TRUE for secure endpoints. Only used if a new endpoint
        is created.

    fDisableSocketPooling - TRUE to create unique endpoints based on both
        port & IP. Only used if a new endpoint is created.

    NewBinding - Receives a pointer to the new binding object if successful.

Return Value:

    DWORD - Completion status, 0 if successful, !0 otherwise.

--*/
{

    PIIS_ENDPOINT endpoint;
    PIIS_SERVER_BINDING binding;
    DWORD status;

    //
    // Sanity check.
    //

    DBG_ASSERT( IpPort != 0 );
    DBG_ASSERT( HostName != NULL );
    DBG_ASSERT( NewBinding != NULL );

    //
    // Setup locals so we know how to cleanup on exit.
    //

    endpoint = NULL;
    binding = NULL;

    //
    // Try to find an endpoint for the specified port.
    //

    endpoint = m_Service->FindAndReferenceEndpoint(
                   IpPort,
                   IpAddress,
                   TRUE,                    // CreateIfNotFound
                   IsSecure,
                   fDisableSocketPooling
                   );

    if( endpoint != NULL ) {

        //
        // Create a new binding.
        //

        binding = new IIS_SERVER_BINDING(
                          IpAddress,
                          IpPort,
                          HostName,
                          endpoint
                          );

        if( binding != NULL ) {

            if( endpoint->AddInstance(
                    this,
                    IpAddress,
                    HostName
                    ) ) {

                endpoint->Reference();
                *NewBinding = binding;
                status = NO_ERROR;

            } else {

                //
                // Could not associate the instance with the endpoint.
                //

                status = GetLastError();
                ASSERT( status != NO_ERROR );

                //
                // if we didn't get an error code back for some reason
                // we choose this one since resource shortages are
                // the most likely failure case.
                //
                if ( NO_ERROR == status ) {
                    status = ERROR_NOT_ENOUGH_MEMORY;
                }

            }

        } else {

            //
            // Could not create new binding object.
            //

            status = ERROR_NOT_ENOUGH_MEMORY;

        }

    } else {

        //
        // Could not find & reference endpoint.
        //

        status = ERROR_NOT_ENOUGH_MEMORY;

    }

    //
    // Remove the reference added in FindAndReferenceEndpoint().
    //

    if( endpoint != NULL ) {

        endpoint->Dereference();

    }

    //
    // Cleanup if necessary.
    //

    if( status != NO_ERROR ) {

        if( binding != NULL ) {

            delete binding;

        }

    }

    return status;

}   // IIS_SERVER_INSTANCE::CreateNewBinding


BOOL
IIS_SERVER_INSTANCE::IsInCurrentBindingList(
    IN PLIST_ENTRY BindingListHead,
    IN DWORD IpAddress OPTIONAL,
    IN USHORT IpPort,
    IN const CHAR * HostName OPTIONAL
    )
/*++

Routine Description:

    Scans the current binding list looking for the specified IP address,
    port, and host name.

Arguments:

    BindingListHead - The binding list to scan.

    IpAddress - The IP address to search for. May be INADDR_ANY.

    IpPort - The IP port to search for. Required.

    HostName - The host name to search for. May be empty ("").

Return Value:

    BOOL - TRUE if the binding was found, FALSE otherwise.

--*/
{

    PLIST_ENTRY listEntry;
    PIIS_SERVER_BINDING binding;

    //
    // Sanity check.
    //

    DBG_ASSERT( IpPort != 0 );
    DBG_ASSERT( HostName != NULL );

    //
    // Scan the bindings.
    //

    for( listEntry = BindingListHead->Flink ;
         listEntry != BindingListHead ;
         listEntry = listEntry->Flink ) {

        binding = CONTAINING_RECORD(
                      listEntry,
                      IIS_SERVER_BINDING,
                      m_BindingListEntry
                      );

        if( binding->Compare(
                IpAddress,
                IpPort,
                HostName
                ) ) {

            return TRUE;

        }

    }

    return FALSE;

}   // IIS_SERVER_INSTANCE::IsInCurrentBindingList


BOOL
IIS_SERVER_INSTANCE::IsBindingInMultiSz(
    IN PIIS_SERVER_BINDING Binding,
    IN const MULTISZ &msz
    )
/*++

Routine Description:

    Scans the specified MULTISZ object to see if it contains a descriptor
    matching the specified binding object.

Arguments:

    Binding - The binding to search for.

    msz - The MULTISZ to search.

Return Value:

    DWORD - Completion status, 0 if successful, !0 otherwise.

--*/
{

    const CHAR * scan;
    DWORD status;
    BOOL result;

    //
    // Sanity check.
    //

    DBG_ASSERT( Binding != NULL );

    //
    // Scan the MULTISZ.
    //

    for( scan = msz.First() ;
         scan != NULL ;
         scan = msz.Next( scan ) ) {

        status = Binding->Compare( scan, &result );

        if( status == NO_ERROR && result ) {

            return TRUE;

        }

    }

    return FALSE;

}   // IIS_SERVER_INSTANCE::IsBindingInMultiSz

DWORD
IIS_SERVER_INSTANCE::PerformClusterModeChange(
    VOID
    )
/*++

Routine Description:

    Reads the server cluster mode from the metabase and performs any
    necessary changes.

Arguments:

    None.

Return Value:

    DWORD - Completion status, 0 if successful, !0 otherwise.

--*/
{
    MB      mb( (IMDCOM *)m_Service->QueryMDObject() );
    DWORD   status;
    DWORD   currentState;
    DWORD   serviceState;
    BOOL    fPreviousClusterEnabled;

    //
    // Setup locals.
    //

    status = NO_ERROR;
    fPreviousClusterEnabled = m_fClusterEnabled;
    serviceState = m_Service->QueryCurrentServiceState();
    currentState = QueryServerState();

    //
    // Open the metabase and query the cluster enabled flag
    //

    if( mb.Open(
            QueryMDPath(),
            METADATA_PERMISSION_READ ) )
    {
        if( !mb.GetDword(
                "",
                MD_CLUSTER_ENABLED,
                IIS_MD_UT_SERVER,
                (LPDWORD)&m_fClusterEnabled
                ) )
        {
            m_fClusterEnabled = FALSE;

            status = GetLastError();

            IF_DEBUG( INSTANCE )
            {
                DBGPRINTF((
                    DBG_CONTEXT,
                    "PerformClusterModeChange: cannot read server command, error %lu\n",
                    status
                    ));
            }

        }

        //
        // Close it so that code needed to update the metabase when
        // changing state can indeed open the metabase.
        //

        mb.Close();
    }
    else
    {
        status = GetLastError();

        IF_DEBUG( INSTANCE )
        {
            DBGPRINTF((
                DBG_CONTEXT,
                "PerformClusterModeChange: cannot open metabase for READ, error %lu\n",
                status
                ));
        }

    }

    //
    // If cluster mode transition from non-cluster to cluster
    // then must make sure that instance is stopped.
    // instance will be started as required by cluster manager.
    //

    if ( status == NO_ERROR &&
         m_fClusterEnabled &&
         !fPreviousClusterEnabled )
    {
        if( ( serviceState == SERVICE_RUNNING ||
              serviceState == SERVICE_PAUSED ) &&
            ( currentState == MD_SERVER_STATE_STARTED ||
              currentState == MD_SERVER_STATE_PAUSED ) ) {

            LockThisForWrite();

            status = StopInstance();

            if( status != NO_ERROR ) {

                DBGPRINTF((
                    DBG_CONTEXT,
                    "PerformClusterModeChange: cannot stop instance, error %lu\n",
                    status
                    ));

            }

            UnlockThis();
        }

        //
        // Restore the state to the previous value if the state change failed.
        //

        if( status != NO_ERROR ) {
            SetServerState( currentState, status );
        }
    }

    return status;
}

DWORD
IIS_SERVER_INSTANCE::PerformStateChange(
    VOID
    )
/*++

Routine Description:

    Reads the server instance state from the metabase and performs any
    necessary state changes.

Arguments:

    None.

Return Value:

    DWORD - Completion status, 0 if successful, !0 otherwise.

--*/
{

    MB mb( (IMDCOM *)m_Service->QueryMDObject() );
    DWORD status;
    DWORD command;
    DWORD currentState;
    DWORD serviceState;

    //
    // Setup locals.
    //

    status = NO_ERROR;
    serviceState = m_Service->QueryCurrentServiceState();
    currentState = QueryServerState();

    //
    // Open the metabase and query the state change command.
    //

    if( mb.Open(
            QueryMDPath(),
            METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE ) ) {

        if( !mb.GetDword(
                "",
                IsClusterEnabled() ? MD_CLUSTER_SERVER_COMMAND : MD_SERVER_COMMAND,
                IIS_MD_UT_SERVER,
                &command
                ) ) {

            status = GetLastError();

            IF_DEBUG( INSTANCE ) {
                DBGPRINTF((
                    DBG_CONTEXT,
                    "PerformStateChange: cannot read server command, error %lu\n",
                    status
                    ));
            }

        }

        //
        //  Update the instance AutoStart value so the instance state is
        //  persisted across service restarts
        //

        if( status == NO_ERROR ) {

            switch( command ) {
            case MD_SERVER_COMMAND_START :

                mb.SetDword(
                   "",
                   MD_SERVER_AUTOSTART,
                   IIS_MD_UT_SERVER,
                   TRUE,
                   METADATA_NO_ATTRIBUTES );
                break;

            case MD_SERVER_COMMAND_STOP :

                mb.SetDword(
                   "",
                   MD_SERVER_AUTOSTART,
                   IIS_MD_UT_SERVER,
                   FALSE,
                   METADATA_NO_ATTRIBUTES );
                break;

            default:
                break;
            }
        }

        //
        // Close it so that code needed to update the metabase when
        // changing state can indeed open the metabase.
        //

        mb.Close();

    } else {

        status = GetLastError();

        IF_DEBUG( INSTANCE ) {
            DBGPRINTF((
                DBG_CONTEXT,
                "PerformStateChange: cannot open metabase for READ, error %lu\n",
                status
                ));
        }

    }

    //
    // Lock the instance.
    //

    LockThisForWrite();

    //
    // Interpret the command. Note that the StartInstance(), StopInstance(),
    // PauseInstance(), and ContinueInstance() methods will set the instance
    // state if they complete successfully, but it is this routine's
    // responsibility to reset the state to the original value if the
    // methods fail.
    //

    if( status == NO_ERROR ) {

        switch( command ) {

        case MD_SERVER_COMMAND_START :

            //
            // Start the instance.
            //
            // If it's stopped, then start it. If it's in any other state,
            // this is an invalid state transition.
            //
            // Note that the *service* must be running before an instance
            // can be started.
            //

            if( serviceState == SERVICE_RUNNING &&
                currentState == MD_SERVER_STATE_STOPPED ) {

                status = DoStartInstance();

                if( status != NO_ERROR ) {

                    DBGPRINTF((
                        DBG_CONTEXT,
                        "PerformStateChange: cannot start instance, error %lu\n",
                        status
                        ));

                }

            } else {

                DBGPRINTF((
                    DBG_CONTEXT,
                    "PerformStateChange: invalid command %lu for state %lu\n",
                    command,
                    currentState
                    ));

                status = ERROR_INVALID_SERVICE_CONTROL;

            }
            break;

        case MD_SERVER_COMMAND_STOP :

            //
            // Stop the instance.
            //
            // If it's running or paused, then stop it. If it's in any
            // other state, this is an invalid state transition.
            //
            // Note that the *service* must be either running or paused
            // before an instance can be paused.
            //

            if( ( serviceState == SERVICE_RUNNING ||
                  serviceState == SERVICE_PAUSED ) &&
                ( currentState == MD_SERVER_STATE_STARTED ||
                  currentState == MD_SERVER_STATE_PAUSED ) ) {

                status = StopInstance();

                if( status != NO_ERROR ) {

                    DBGPRINTF((
                        DBG_CONTEXT,
                        "PerformStateChange: cannot stop instance, error %lu\n",
                        status
                        ));

                }

            } else {

                DBGPRINTF((
                    DBG_CONTEXT,
                    "PerformStateChange: invalid command %lu for state %lu\n",
                    command,
                    currentState
                    ));

                status = ERROR_INVALID_SERVICE_CONTROL;

            }
            break;

        case MD_SERVER_COMMAND_PAUSE :

            //
            // Pause the instance.
            //
            // If it's running, then pause it. If it's in any other state,
            // this is an invalid state transition.
            //
            // Note that the *service* must be running before an instance
            // can be paused.
            //

            if( serviceState == SERVICE_RUNNING &&
                currentState == MD_SERVER_STATE_STARTED ) {

                status = PauseInstance();

                if( status != NO_ERROR ) {

                    DBGPRINTF((
                        DBG_CONTEXT,
                        "PerformStateChange: cannot pause instance, error %lu\n",
                        status
                        ));

                }

            } else {

                DBGPRINTF((
                    DBG_CONTEXT,
                    "PerformStateChange: invalid command %lu for state %lu\n",
                    command,
                    currentState
                    ));

                status = ERROR_INVALID_SERVICE_CONTROL;

            }
            break;

        case MD_SERVER_COMMAND_CONTINUE :

            //
            // Continue the instance.
            //
            // If it's paused, then continue it. If it's in any other
            // state, this is an invalid state transition.
            //
            // Note that the *service* must be running before an instance
            // can be continued.
            //

            if( serviceState == SERVICE_RUNNING &&
                currentState == MD_SERVER_STATE_PAUSED ) {

                status = ContinueInstance();

                if( status != NO_ERROR ) {

                    DBGPRINTF((
                        DBG_CONTEXT,
                        "PerformStateChange: cannot continue instance, error %lu\n",
                        status
                        ));

                }

            } else {

                DBGPRINTF((
                    DBG_CONTEXT,
                    "PerformStateChange: invalid command %lu for state %lu\n",
                    command,
                    currentState
                    ));

                status = ERROR_INVALID_SERVICE_CONTROL;

            }
            break;

        default :
            DBGPRINTF((
                DBG_CONTEXT,
                "PerformStateChange: invalid command %lu\n",
                command
                ));

            status = ERROR_INVALID_SERVICE_CONTROL;
            break;

        }

    } else {

        DBGPRINTF((
            DBG_CONTEXT,
            "PerformStateChange: cannot read metabase, error %lu\n",
            status
            ));

    }

    //
    // Unlock the instance before trying to reopen the metabase.
    //

    UnlockThis();

    //
    // Restore the state to the previous value if the state change failed.
    //

    if( status != NO_ERROR ) {
        SetServerState( currentState, status );
    }

    return status;

}   // IIS_SERVER_INSTANCE::PerformStateChange


VOID
IIS_SERVER_INSTANCE::SetServerState(
    IN DWORD NewState,
    IN DWORD Win32Error
    )
/*++

Routine Description:

    Sets the new server state, storing it locally and also storing the
    new state in the metabase.

Arguments:

    NewState - The new server state.

    Win32Error - New Win32 error value.

Return Value:

    None.

--*/
{

    DWORD status = NO_ERROR;
    MB mb( (IMDCOM *)m_Service->QueryMDObject() );

    //
    // Open the metabase and save the new state. Note that we map
    // MD_SERVER_STATE_INVALID to MD_SERVER_STATE_STOPPED in the metabase.
    // Client applications would probably be confused by the _INVALID state.
    //

    if( mb.Open(
            QueryMDPath(),
            METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE ) ) {

        if( !mb.SetDword(
                "",
                MD_WIN32_ERROR,
                IIS_MD_UT_SERVER,
                Win32Error,
                METADATA_VOLATILE
                ) ||
            !mb.SetDword(
                "",
                MD_SERVER_STATE,
                IIS_MD_UT_SERVER,
                NewState == MD_SERVER_STATE_INVALID
                    ? MD_SERVER_STATE_STOPPED
                    : NewState,
                METADATA_VOLATILE
                ) ) {

            status = GetLastError();

        }

    } else {

        status = GetLastError();

    }

    if( status != NO_ERROR ) {

        DBGPRINTF((
            DBG_CONTEXT,
            "SetServerState: cannot write metabase (%lu), error %lu\n",
            NewState,
            status
            ));

    }

    //
    // Save it in the object also.
    //

    m_dwServerState = NewState;

}   // IIS_SERVER_INSTANCE::SetServerState



BOOL
IIS_SERVER_INSTANCE::StopEndpoints( VOID)
/*++

Routine Description:

    Walks down the list of Endpoints held by the Server instance and
    calls IIS_ENDPOINT::StopEndpoint for the endpoints.

Arguments:

    None

Return Value:

    TRUE if stop is successful,
    FALSE otherwise
--*/
{
    BOOL  fReturn = TRUE;

    //
    // Inside the locked section walk the normal & secure bindings
    //  to stop all relevant endpoints
    //

    LockThisForWrite();

    if (!StopEndpointsHelper( &m_NormalBindingListHead)) {
        fReturn = FALSE;
    }

    if (!StopEndpointsHelper( &m_SecureBindingListHead)) {
        fReturn = FALSE;
    }

    UnlockThis();

    return ( fReturn);

} // IIS_SERVER_INSTANCE::StopEndpoints()


BOOL
IIS_SERVER_INSTANCE::StopEndpointsHelper( PLIST_ENTRY pBindingListHead)
/*++

Routine Description:

    Helper routine for StopEndpoints().
    This function should be called with the Endpoints lock held

Arguments:

    pBindingListHead - pointer to the binding list for endpoints to be stopped

Return Value:

    BOOL  - TRUE on success and FALSE on failure

--*/
{
    BOOL fReturn = TRUE;
    PLIST_ENTRY plBindingScan;
    PIIS_SERVER_BINDING binding;

    //
    // Walk the list of bindings and destroy them.
    //

    for( plBindingScan = pBindingListHead->Flink;
         plBindingScan != pBindingListHead;
         plBindingScan = plBindingScan->Flink
         ) {

        binding = CONTAINING_RECORD(
                      plBindingScan,
                      IIS_SERVER_BINDING,
                      m_BindingListEntry
                      );

        IF_DEBUG( INSTANCE ) {
            DBGPRINTF((
                DBG_CONTEXT,
                "stop ATQ EP of %p from instance %p, "
                " binding %p (%lx:%d:%s)\n",
                binding->QueryEndpoint(),
                this,
                binding,
                binding->QueryIpAddress(),
                binding->QueryEndpoint()->QueryPort(),
                binding->QueryHostName()
                ));
        }

        if ( !binding->QueryEndpoint()->StopEndpoint()) {
            fReturn = FALSE;
        }
    } // for

    //
    // Success!
    //

    return ( fReturn);

}   // IIS_SERVER_INSTANCE::StopEndpointsHelper()




BOOL
IIS_SERVER_INSTANCE::CloseInstance(
    VOID
    )
/*++

Routine Description:

    Shuts down instance

Arguments:

    None

Return Value:

    TRUE if Shutdown successful,
    FALSE otherwise

--*/
{

    IF_DEBUG(INSTANCE) {
        DBGPRINTF((
            DBG_CONTEXT,
            "IIS_SERVER_INSTANCE::Close called for %p\n",
            this
            ));
    }

    (VOID)m_Service->DisassociateInstance( this );
    return TRUE;

} // IIS_SERVER_INSTANCE::CloseInstance


DWORD
IIS_SERVER_INSTANCE::StartInstance()
/*++

Routine Description:

    Sets instance to RUNNING

Arguments:

    None.

Return Value:

    DWORD - 0 if successful, !0 otherwise.

--*/
{

    DWORD status;

    IF_DEBUG(INSTANCE) {
        DBGPRINTF((
            DBG_CONTEXT,
            "IIS_SERVER_INSTANCE::StartInstance called for %p. Current state %d\n",
            this,
            QueryServerState()
            ));
    }

    DBG_ASSERT( QueryServerState() == MD_SERVER_STATE_STOPPED );

    //
    // Set the transient state.
    //

    SetServerState( MD_SERVER_STATE_STARTING, NO_ERROR );

    //
    // Set cache parameters
    //

    m_tsCache.SetParameters(
                m_Service->QueryServiceId(),
                QueryInstanceId(),
                this );

    if (( QueryInstanceId() != INET_INSTANCE_ROOT ) && IsDownLevelInstance() )
    {
        MoveMDVroots2Registry();
        // no longer supporting migrating VRoots back from the registry
        //PdcHackVRReg2MD( );
    }

    //
    // Read all common parameters and initialize VDirs
    //

    if ( !RegReadCommonParams( TRUE, TRUE)  ) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Start logging
    //

    m_Logging.ActivateLogging(
                    m_Service->QueryServiceName(),
                    QueryInstanceId(),
                    m_strMDPath.QueryStr(),
                    m_Service->QueryMDObject() );

    //
    // Verify the service can handle another instance.
    //

    if( !m_Service->RecordInstanceStart() ) {

        m_Logging.ShutdownLogging();
        QueryVrootTable()->RemoveVirtualRoots();

        return ERROR_NOT_SUPPORTED;
    }

    //
    // Bind the instance.
    //

    status = BindInstance();

    if ( status != NO_ERROR ) {

        m_Logging.ShutdownLogging();
        QueryVrootTable()->RemoveVirtualRoots();

        //
        // Tell the service that we failed to start the instance.
        //

        m_Service->RecordInstanceStop();

    }

    return status;

} // IIS_SERVER_INSTANCE::StartInstance


DWORD
IIS_SERVER_INSTANCE::StopInstance()
/*++

Routine Description:

    Sets instance to STOPPED

Arguments:

    None.

Return Value:

    DWORD - 0 if successful, !0 otherwise.

--*/
{

    DWORD status;

    IF_DEBUG(INSTANCE) {
        DBGPRINTF((
            DBG_CONTEXT,
            "IIS_SERVER_INSTANCE::StopInstance called for %p. Current state %d\n",
            this,
            QueryServerState()
            ));
    }

    DBG_ASSERT( QueryServerState() == MD_SERVER_STATE_STARTED ||
                QueryServerState() == MD_SERVER_STATE_PAUSED );

    Reference();

    //
    // Set the transient state.
    //

    SetServerState( MD_SERVER_STATE_STOPPING, NO_ERROR );

    m_Service->StopInstanceProcs( this );

    //
    // Note that we call DisconnectUsersByInstance() before *and* after
    // unbinding the instance. This is to prevent a potential race condition
    // that can occur if another thread is already in IIS_ENDPOINT::
    // FindAndReferenceInstance(), has found the instance, checked its state,
    // and found it to be MD_SERVER_STATE_STARTED. The call to UnbindInstance()
    // will lock any affected endpoints, ensuring that there are no other
    // threads in the midst of a FindAndReferenceInstance(). The second
    // (seemingly redundant) call to DisconnectUsersByInstance() will catch
    // any threads that "snuck in" under these conditions.
    //

    status = m_Service->DisconnectUsersByInstance( this );

    if( status == NO_ERROR ) {
        status = UnbindInstance();
    }

    if( status == NO_ERROR ) {
        status = m_Service->DisconnectUsersByInstance( this );
    }

    if( status == NO_ERROR ) {
        SetServerState( MD_SERVER_STATE_STOPPED, NO_ERROR );
        m_dwSavedState = MD_SERVER_STATE_STOPPED;
        m_Service->RecordInstanceStop();
    }

    //
    // logging cleanup
    //

    DBG_REQUIRE( m_Logging.ShutdownLogging());
    DBG_REQUIRE( QueryVrootTable()->RemoveVirtualRoots());

    Dereference();
    return status;

} // IIS_SERVER_INSTANCE::StopInstance


DWORD
IIS_SERVER_INSTANCE::PauseInstance()
/*++

Routine Description:

    Sets instance to PAUSE

Arguments:

    None.

Return Value:

    DWORD - 0 if successful, !0 otherwise.

--*/
{

    IF_DEBUG(INSTANCE) {
        DBGPRINTF((
            DBG_CONTEXT,
            "IIS_SERVER_INSTANCE::Pause called for %p. Current state %d\n",
            this,
            QueryServerState()
            ));
    }

    //
    // Just set the paused state (no need for a transient state).
    // Setting the instance to paused will prevent new incoming
    // connections on the instance.
    //

    DBG_ASSERT( QueryServerState() == MD_SERVER_STATE_STARTED );
    SetServerState( MD_SERVER_STATE_PAUSED, NO_ERROR );

    //
    // Success!
    //

    return NO_ERROR;

} // IIS_SERVER_INSTANCE::PauseInstance


DWORD
IIS_SERVER_INSTANCE::ContinueInstance()
/*++

Routine Description:

    Sets instance to STARTED.

Arguments:

    None.

Return Value:

    DWORD - 0 if successful, !0 otherwise.

--*/
{

    IF_DEBUG(INSTANCE) {
        DBGPRINTF((
            DBG_CONTEXT,
            "IIS_SERVER_INSTANCE::Continue called for %p. Current state %d\n",
            this,
            QueryServerState()
            ));
    }

    //
    // Just set the stated state (no need for a transient state).
    // Setting the instance to started will allow new incoming
    // connections on the instance.
    //

    DBG_ASSERT( QueryServerState() == MD_SERVER_STATE_PAUSED );
    SetServerState( MD_SERVER_STATE_STARTED, NO_ERROR );

    //
    // Success!
    //

    return NO_ERROR;

} // IIS_SERVER_INSTANCE::ContinueInstance


VOID
IIS_SERVER_INSTANCE::SetWin32Error(
    DWORD err
    )
{

    MB mb( (IMDCOM *)m_Service->QueryMDObject() );
    DWORD status = NO_ERROR;

    //
    // Open the metabase and save the error code.
    //

    if( mb.Open(
            QueryMDPath(),
            METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE ) ) {

        if( !mb.SetDword(
                "",
                MD_WIN32_ERROR,
                IIS_MD_UT_SERVER,
                err,
                METADATA_VOLATILE
                ) ) {

            status = GetLastError();

        }

    } else {

        status = GetLastError();

    }

    if( status != NO_ERROR ) {

        DBGPRINTF((
            DBG_CONTEXT,
            "SetWin32Error: cannot save error %lu (%lx), error %lx\n",
            err,
            err,
            status
            ));

    }

}   // IIS_SERVER_INSTANCE::SetWin32Error

BOOL
IIS_SERVER_INSTANCE::SetBandwidthThrottle(
    IN MB *              pMB
)
/*++

Routine Description:

    Set the bandwidth throttle threshold for this instance

Arguments:

    pMB - pointer to metabase handle

Return Value:

    TRUE if successful, FALSE otherwise

--*/
{
    DWORD       dwBandwidth;

    if ( !TsIsNtServer() )
    {
        return TRUE;
    }

    DBG_ASSERT( pMB != NULL );

    if ( !pMB->GetDword( "",
                         MD_MAX_BANDWIDTH,
                         IIS_MD_UT_SERVER,
                         &dwBandwidth,
                         0 ) )
    {
        VOID * pTemp;

        pTemp = InterlockedExchangePointer( (PVOID *) &m_pBandwidthInfo, NULL );

        if ( pTemp )
        {
            DBG_REQUIRE( AtqFreeBandwidthInfo( pTemp ) );
        }
    }
    else
    {
        if ( m_pBandwidthInfo == NULL )
        {
            VOID * pTemp = AtqCreateBandwidthInfo();
            if ( pTemp != NULL )
            {
                AtqBandwidthSetInfo( pTemp,
                                     ATQ_BW_BANDWIDTH_LEVEL,
                                     dwBandwidth );

                AtqBandwidthSetInfo( pTemp,
                                     ATQ_BW_DESCRIPTION,
                                     (ULONG_PTR) m_strMDPath.QueryStr() );

                InterlockedExchangePointer( (PVOID *) &m_pBandwidthInfo, (PVOID) pTemp );
            }
        }
        else
        {
            AtqBandwidthSetInfo( m_pBandwidthInfo,
                                 ATQ_BW_BANDWIDTH_LEVEL,
                                 (ULONG_PTR)dwBandwidth );
        }
    }

    return TRUE;
}

BOOL
IIS_SERVER_INSTANCE::SetBandwidthThrottleMaxBlocked(
    IN MB *             pMB
)
{
    DWORD               dwMaxBlocked = INFINITE;

    if ( !TsIsNtServer() )
    {
        return TRUE;
    }

    DBG_ASSERT( pMB != NULL );

    if ( pMB->GetDword( "",
                        MD_MAX_BANDWIDTH_BLOCKED,
                        IIS_MD_UT_SERVER,
                        &dwMaxBlocked,
                        0 ) )
    {
        if ( m_pBandwidthInfo )
        {
            AtqBandwidthSetInfo( m_pBandwidthInfo,
                                 ATQ_BW_MAX_BLOCKED,
                                 dwMaxBlocked );
        }
    }
    return TRUE;
}

DWORD
IIS_SERVER_INSTANCE::DoStartInstance(
    VOID
)
/*++

Routine Description:

    Start an instance.  This call encompasses the IIS_SERVER_INSTANCE and
    inherited invocations of StartInstance

Arguments:

    None.

Return Value:

    DWORD - 0 if successful, !0 otherwise.

--*/
{
    DWORD               dwError;

    dwError = StartInstance();
    if ( dwError == NO_ERROR )
    {
        if( m_Service->QueryCurrentServiceState() == SERVICE_PAUSED )
        {
            SetServerState( MD_SERVER_STATE_PAUSED, NO_ERROR );
        }
        else
        {
            SetServerState( MD_SERVER_STATE_STARTED, NO_ERROR );
        }
    }

    return dwError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\common\mimemap.cxx ===
/*++

   Copyright    (c)    1996    Microsoft Corporation

   Module  Name :

        mimemap.cxx

   Abstract:

        This module defines the member functions for MIME_MAP class
            and MIME_MAP_ENTRY class

   Author:

           Murali R. Krishnan    ( MuraliK )     10-Jan-1995

   Functions Exported:

        MIME_MAP_ENTRY::MIME_MAP_ENTRY()

        MIME_MAP::MIME_MAP()
        MIME_MAP::~MIME_MAP()
        MIME_MAP::CleanupThis()
        MIME_MAP::InitFromRegistry()
        MIME_MAP::LookupMimeEntryForFileExt()
        MIME_MAP::LookupMimeEntryForMimeType()

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

# include <tchar.h>
# include <tcpdllp.hxx>

# include "mimemap.hxx"
# include "hashtab.hxx"

# include "iistypes.hxx"
# include <imd.h>
# include <mb.hxx>
#if 1 // DBCS
# include <mbstring.h>
#endif


//
// Hard coded defaults for MimeEntries.
//

static const TCHAR  sg_rgchDefaultFileExt[] =  TEXT( "*");

static const TCHAR  sg_rgchDefaultMimeType[] =  TEXT("application/octet-stream");
static TCHAR  sg_rgchDefaultMimeEntry[] =
                        TEXT( "*,application/octet-stream");

/************************************************************
 *    Functions
 ************************************************************/

static LPTSTR
MMNextField( IN OUT LPTSTR *  ppchFields);

static BOOL
ReadMimeMapFromMetabase( MULTISZ *pmszMimeMap );


/************************************************************
 *    MIME_MAP_ENTRY member functions
 ************************************************************/

MIME_MAP_ENTRY::MIME_MAP_ENTRY(
    IN LPCTSTR pchMimeType,
    IN LPCTSTR pchFileExt)
: m_strFileExt      ( pchFileExt),
  m_strMimeType     ( pchMimeType),
  HT_ELEMENT        (),
  m_nRefs           ( 1)
/*++
    This function constructs a new MIME_MAP_ENTRY object.
    After initializing  various fields, it also sets the m_fValid flag.
    The user needs to check MIME_MAP_ENTRY::IsValid() for the newly
     constructed object.
--*/
{
    m_fValid = ( m_strFileExt.IsValid()  &&
                 m_strMimeType.IsValid());

} // MIME_MAP_ENTRY::MIME_MAP_ENTRY()



# if DBG

VOID
MIME_MAP_ENTRY::Print( VOID) const
{

    DBGPRINTF( ( DBG_CONTEXT,
                 "MIME_MAP_ENTRY( %08x)\tRefs=%d\tFileExt=%s\tMimeType=%s\t",
                 this,
                 m_nRefs,
                 m_strFileExt.QueryStr(),
                 m_strMimeType.QueryStr()
                 ));

    return;
} // MIME_MAP_ENTRY::Print()

# endif // DBG



/************************************************************
 *    MIME_MAP member functions
 ************************************************************/

# define NUM_MIME_BUCKETS      (7)

MIME_MAP::MIME_MAP( VOID)
/*++
    This function constructs a new MIME_MAP container object for
     containing the MIME_MAP_ENTRY objects.

    The MIME_MAP object is dummy constructed.
    It is set valid when we initialize the elements and
      create the MmeDefault entry.
--*/
:   m_fValid        ( FALSE),
    m_pMmeDefault   ( NULL),
    m_htMimeEntries ( NUM_MIME_BUCKETS, "MimeMapper", 0)
{
} // MIME_MAP::MIME_MAP()



VOID
MIME_MAP::CleanupThis( VOID)
/*++
    This function cleans up the MIME_MAP object, freeing all
     dynamically allocated space and reinitiallizing the list head.

    Returns:
        None
--*/
{

    if ( m_fValid) {

        // The mime entries in the hash table are cleaned when the hash
        // object is deleted.
        m_htMimeEntries.Cleanup();
        m_pMmeDefault = NULL;
        m_fValid = FALSE;
    }

    return;
} // MIME_MAP::CleanupThis()



static LPTSTR
MMNextField( IN OUT LPTSTR *  ppchFields)
/*++
    This function separates and terminates the next field and returns a
        pointer to the same.
    Also it updates the incoming pointer to point to start of next field.

    The fields are assumed to be separated by commas.

--*/
{
    LPTSTR pchComma;
    LPTSTR pchField = NULL;

    DBG_ASSERT( ppchFields != NULL);

    //
    // Look for a comma in the input.
    // If none present, assume that rest of string
    //  consists of the next field.
    //

    pchField  = *ppchFields;

    if ( ( pchComma = _tcschr( *ppchFields, TEXT(','))) != NULL) {

        //
        // Terminate current field. Store current field name in pchComma and
        //  update *ppchFields to contain the next field.
        //
        *pchComma = TEXT( '\0');    // terminate this field with a NULL.
        *ppchFields = pchComma + 1; // goto next field.

    } else {

        //
        // Assume everything till end of string is the current field.
        //

        *ppchFields = *ppchFields + _tcslen( *ppchFields) + 1;
    }

    pchField = ( *pchField == TEXT( '\0')) ? NULL : pchField;
    return ( pchField);
} // MMNextField()



static PMIME_MAP_ENTRY
ReadAndParseMimeMapEntry( IN OUT LPTSTR * ppszValues)
/*++
    This function parses the string containing next mime map entry and
        related fields and if successful creates a new MIME_MAP_ENTRY
        object and returns it.
    Otherwise it returns NULL.
    In either case, the incoming pointer is updated to point to next entry
     in the string ( past terminating NULL), assuming incoming pointer is a
     multi-string ( double null terminated).

    Arguments:
        ppszValues    pointer to string containing the MimeEntry values.

    Returns:
        On successful MIME_ENTRY being parsed, a new MIME_MAP_ENTRY object.
        On error returns NULL.
--*/
{
    PMIME_MAP_ENTRY  pMmeNew = NULL;
    DBG_ASSERT( ppszValues != NULL);
    LPTSTR pszMimeEntry = *ppszValues;


    IF_DEBUG( MIME_MAP) {

        DBGPRINTF( ( DBG_CONTEXT, "ReadAndParseMimeMapEntry( %s)\n",
                     *ppszValues));
    }

    if ( pszMimeEntry != NULL && *pszMimeEntry != TEXT( '\0')) {

        LPTSTR pchMimeType;
        LPTSTR pchFileExt;

        pchFileExt      = MMNextField( ppszValues);
        pchMimeType     = MMNextField( ppszValues);

        if ( pchMimeType  == NULL  ||
             pchFileExt   == NULL
            )  {

            DBGPRINTF( ( DBG_CONTEXT,
                        " ReadAndParseMimeEntry()."
                        " Invalid Mime String ( %s)."
                        "MimeType( %08x): %s, FileExt( %08x): %s,",
                        pszMimeEntry,
                        pchMimeType, pchMimeType,
                        pchFileExt,  pchFileExt
                        ));

            DBG_ASSERT( pMmeNew == NULL);

        } else {


            // Strip leading dot.

            if (*pchFileExt == '.')
            {
                pchFileExt++;
            }

            pMmeNew = new MIME_MAP_ENTRY( pchMimeType, pchFileExt);

            if ( pMmeNew != NULL && !pMmeNew->IsValid()) {

                //
                // unable to create a new MIME_MAP_ENTRY object. Delete it.
                //
                delete pMmeNew;
                pMmeNew = NULL;
            }
        }
    }

    return ( pMmeNew);
} // ReadAndParseMimeMapEntry()


DWORD
MIME_MAP::InitMimeMap( VOID )
/*++
  This function reads the mimemap stored either as a MULTI_SZ or as a sequence
   of REG_SZ and returns a double null terminated sequence of mime types on
   success. If there is any failure, the failures are ignored and it returns
   a NULL.

  Arguments:

  Returns:
     NULL on failure to open/read metabase entries
     non-NULL string allocated using TCP_ALLOC containing double null
      terminated sequence of strings with MimeMapEntries.
     If non-NULL the pointer should be freed using TCP_FREE by caller.
--*/

{
    DWORD   dwError  = NO_ERROR;
    DWORD   dwErrorChicago  = NO_ERROR;


    if ( IsValid()) {

        //
        //  There is some mime mapping already present. Cleanup first
        //

        CleanupThis();
    }

    DBG_ASSERT( !IsValid());

    // First read INETSERVICES MIME database ( common types will have priority)
    dwError = InitFromMetabase( );

    if (dwError == NO_ERROR ) {
        m_fValid = TRUE;
    }

    //  Now read Chicago shell registration database
    dwErrorChicago = InitFromRegistryChicagoStyle( );

    // If at least one succeeded - return success
    if (dwErrorChicago == NO_ERROR ||
        dwError == NO_ERROR ) {
        m_fValid = TRUE;
        return NO_ERROR;
    }

    return dwError;
}


static VOID
GetFileExtension( IN CONST TCHAR *  pchPathName,
                  OUT LPCTSTR *     ppstrExt,
                  OUT LPCTSTR *     ppstrLastSlash)
{
    LPCTSTR   pchExt  = sg_rgchDefaultFileExt;

    DBG_ASSERT( ppstrExt != NULL && ppstrLastSlash != NULL );

    *ppstrLastSlash = NULL;

    if ( pchPathName ) {

        LPCTSTR   pchLastDot;

        pchLastDot = _tcsrchr( pchPathName, TEXT( '.'));

        if ( pchLastDot != NULL) {

            LPCTSTR   pchLastWhack;

#if 1 // DBCS enabling for document path and file name
            pchLastWhack = (PCHAR)_mbsrchr( (PUCHAR)pchPathName, TEXT( '\\'));
#else
            pchLastWhack = _tcsrchr( pchPathName, TEXT( '\\'));
#endif

            if ( pchLastWhack == NULL) {

                pchLastWhack = pchPathName;  // only file name specified.
            }

            if ( pchLastDot >= pchLastWhack) {
                // if the dot comes only in the last component, then get ext
                pchExt = pchLastDot + 1;  // +1 to skip last dot.
                *ppstrLastSlash = pchLastWhack;
            }
        }

    }
    *ppstrExt = pchExt;
} // GetFileExtension()




DWORD
MIME_MAP::LookupMimeEntryForMimeType(
    IN const STR &                 strMimeType,
    OUT PCMIME_MAP_ENTRY  *        prgMme,
    IN OUT LPDWORD                 pnMmeEntries)
/*++
    This function maps MimeType to an array of MimeMapEntry objects that match
        the given MimeType.

    Before calling this function,
       ensure that you had already locked this object.
    After completing use of the array, unlock the MIME_MAP.
    The reason is:
       To avoid changes in the data while using the read only members of
            MIME_MAP.

    Arguments:
        strMimeType         string containing the MimeType used in search
        prgpMme             pointer to an array of pointers to Mme.
                            The array is initialized to contain the
                              read only pointers to the MIME_MAP_ENTRY objects.
                            If prgpMme is NULL, then
                              number of matches is counted and returned.
        pnMmeEntries        pointer to count of entries in the array
                             ( when called).
                            On successful return contains total numb of entries
                             present in the array or count of entries required.

    Returns:

        NO_ERROR on success.
        ERROR_INSUFFICIENT_BUFFER  if the prgMme does not have enough space for
                copying all the read-only pointers to matched entries.
        other Win32 errors if any.
--*/
{
    DWORD nMaxMme   = 0;
    DWORD iMmeFound = 0;   // index into array for MmeFound
    HT_ITERATOR   hti;
    HT_ELEMENT * phte;

    DBG_ASSERT( IsValid());

    if ( pnMmeEntries != NULL) {

        nMaxMme = *pnMmeEntries;   // max that we can store.
        *pnMmeEntries = 0;         // number found. set to default value
    }

    if ( strMimeType.IsEmpty() || nMaxMme == 0) {

        SetLastError( ERROR_INVALID_PARAMETER);
        return ( ERROR_INVALID_PARAMETER);
    }

    DWORD dwErr;
    dwErr = m_htMimeEntries.InitializeIterator( &hti);

    if ( NO_ERROR == dwErr) {
        DWORD iMmeFound = 0;

        while ( (dwErr =  m_htMimeEntries.FindNextElement( &hti, &phte))
                == NO_ERROR) {


            PMIME_MAP_ENTRY pMme = (PMIME_MAP_ENTRY ) phte;
            DBG_ASSERT( pMme!= NULL);

            if ( !_tcsicmp( pMme->QueryMimeType(),
                            strMimeType.QueryStr())) {

                //
                // We found the matching Mme. Add it to array of found.
                //

                if ( prgMme != NULL && iMmeFound < nMaxMme) {

                    // store the pointer to found match

                    prgMme[iMmeFound] = pMme;
                }

                iMmeFound++;
            } // found a match

            //
            // release the element foind before fetching the next one
            //
            phte->Dereference();
        } // while
    }

    DBG_REQUIRE( NO_ERROR == m_htMimeEntries.CloseIterator( &hti));

    dwErr = ( iMmeFound > nMaxMme) ? ERROR_INSUFFICIENT_BUFFER : NO_ERROR;

    *pnMmeEntries = iMmeFound;

    return ( dwErr);
} // MIME_MAP::LookupMimeEntryForMimeType()



PCMIME_MAP_ENTRY
MIME_MAP::LookupMimeEntryForFileExt(
    IN const TCHAR *     pchPathName)
/*++
    This function mapes FileExtension to MimeEntry.
    The function returns a single mime entry for given file's extension.
    If no match is found, the default mime entry is returned.
     The returned entry is a readonly pointer and should not be altered.

    The file extension is the key field in the Hash table for mime entries.
    We can use the hash table lookup function to find the entry.

    Arguments:
        pchPathName     pointer to string containing the path for file.
                    ( either full path or just the file name)
                    If NULL, then the default MimeMapEntry is returned.

    Returns:
        If a matching mime entry is found,
               a const pointer to MimeMapEntry object is returned.
        Otherwise the default mime map entry object is returned.

--*/
{
    PMIME_MAP_ENTRY pMmeMatch = m_pMmeDefault;

    DBG_ASSERT( IsValid());

    if ( pchPathName != NULL && *pchPathName ) {

        LPCTSTR         pchExt;
        LPCTSTR         pchLastSlash;

        GetFileExtension( pchPathName, &pchExt, &pchLastSlash );
        DBG_ASSERT( pchExt);
        DWORD cchExt = strlen( pchExt);

        for ( ;; )
        {
            //
            // Successfully got extension. Search in the list of MimeEntries.
            //

            pMmeMatch = (PMIME_MAP_ENTRY ) m_htMimeEntries.Lookup( pchExt, cchExt);

            pchExt--;

            if ( NULL == pMmeMatch)
            {
                pMmeMatch = m_pMmeDefault;

                // Look backwards for another '.' so we can support extensions
                // like ".xyz.xyz" or ".a.b.c".

                if ( pchExt > pchLastSlash )
                {
                    pchExt--;
                    while ( ( pchExt > pchLastSlash ) && ( *pchExt != '.' ) )
                    {
                        pchExt--;
                    }

                    if ( *(pchExt++) != '.' )
                    {
                        break;
                    }
                }
                else
                {
                    break;
                }
            }
            else
            {
                // mime map table is special - we do not handle ref counts
                // at all outside the mime-map object. Neither is there
                // deletion till the program ends. Just deref it here.

                DBG_REQUIRE( pMmeMatch->Dereference() > 0);
                break;
            }
        }
    }

    return ( pMmeMatch);
} // MIME_MAP::LookupMimeEntryForFileExt()



BOOL
MIME_MAP::AddMimeMapEntry( IN PMIME_MAP_ENTRY  pMmeNew)
/*++

    This function adds the new MIME_MAP_ENTRY to the list of entries
     maintained in MIME_MAP

    Arguments:
        pMmeNew      poitner to newly created MimeMapEntry object.

    Returns:
        Win32 error codes. NO_ERROR on success.
--*/
{
    BOOL fReturn = FALSE;

    if ( pMmeNew == NULL || !pMmeNew->IsValid()) {

        SetLastError( ERROR_INVALID_PARAMETER);
        DBG_ASSERT( !fReturn);
    } else {

        DBG_ASSERT( m_htMimeEntries.IsValid());

        fReturn = m_htMimeEntries.Insert( (HT_ELEMENT * ) pMmeNew);

        if ( !_tcscmp( pMmeNew->QueryFileExt(), sg_rgchDefaultFileExt)) {

            m_pMmeDefault = pMmeNew;    // Use this as default
        }
    }

    return ( fReturn);
} // MIME_MAP::AddMimeMapEntry()



# if DBG

VOID
MIME_MAP::Print( VOID)
{
    DBGPRINTF( ( DBG_CONTEXT,
                "MIME_MAP ( %08x). \tIsValid() = %d\n",
                this,  IsValid())
              );


#if 0
    HT_ITERATOR hti;
    HT_ELEMENT * phte;

    DWORD dwErr;

    dwErr = m_htMimeEntries.InitializeIterator( &hti);

    if ( NO_ERROR == dwErr) {

        while ( (dwErr = m_htMimeEntries.FindNextElement( &hti, &phte))
                == NO_ERROR) {

            DBG_ASSERT( NULL != phte);
            phte->Print();
        } // while()
    }

    DBG_REQUIRE( NO_ERROR == m_htMimeEntries.CloseIterator( &hti));
# endif // 0

    m_htMimeEntries.Print( 1);

    if ( m_pMmeDefault != NULL) {

        DBGPRINTF( ( DBG_CONTEXT, "Default MimeMapEntry is: \n"));
        m_pMmeDefault->Print();
    } else {

        DBGPRINTF( ( DBG_CONTEXT, "Default MimeMapEntry is NULL\n"));
    }

    return;

} // MIME_MAP::Print()


# endif // DBG




static BOOL
ReadMimeMapFromMetabase( MULTISZ *pmszMimeMap )
/*++
  This function reads the mimemap stored either as a MULTI_SZ or as a sequence
   of REG_SZ and returns a double null terminated sequence of mime types on
   success. If there is any failure, the failures are ignored and it returns
   a NULL.

  Arguments:
     pszRegKey   pointer to NULL terminated string containing  registry entry.

  Returns:
     NULL on failure to open/read registry entries
     non-NULL string allocated using TCP_ALLOC containing double null
      terminated sequence of strings with MimeMapEntries.
     If non-NULL the pointer should be freed using TCP_FREE by caller.
--*/
{
    MB      mb( (IMDCOM*) IIS_SERVICE::QueryMDObject()  );

    if ( !mb.Open( "/LM/MimeMap", METADATA_PERMISSION_READ))
    {
        //
        // if this fails, we're hosed.
        //

        DBGPRINTF((DBG_CONTEXT,"Open MD /LM/MimeMap returns %d\n",GetLastError() ));
        return FALSE;
    }

    if (!mb.GetMultisz("", MD_MIME_MAP, IIS_MD_UT_FILE, pmszMimeMap))
    {
        DBGPRINTF((DBG_CONTEXT,"Unable to read mime map from metabase: %d\n",GetLastError() ));
        return FALSE;
    }

    return TRUE;

} // ReadMimeMapFromMetabase()


DWORD
MIME_MAP::InitFromMetabase( VOID )
/*++
    This function reads the MIME_MAP entries from metabase and parses
     the entry, creates MIME_MAP_ENTRY object and adds the object to list
     of MimeMapEntries.

    Arguments:

    Returns:
        Win32 error code. NO_ERROR on success.

    Format of Storage in registry:
        The entries are stored in NT in tbe metabase
          with a list of values in following format.
            file-extension,i mimetype
        It can be stored using MULTI_SZ, but above form is convenient for both
          Windows 95 ( withoug MULTI_SZ) and WindowsNT.

--*/
{
    DWORD   dwError  = NO_ERROR;


    LPTSTR  pszValueAlloc = NULL;    // to be free using TCP_FREE()
    LPTSTR  pszValue;
    MULTISZ mszMimeMap;

    //
    //  There is some registry key for Mime Entries. Try open and read.
    //

    if ( !ReadMimeMapFromMetabase( &mszMimeMap ) )
    {
        mszMimeMap.Reset();

        if (!mszMimeMap.Append(sg_rgchDefaultMimeEntry))
        {
            return GetLastError();
        }
    }

    // Ignore all errors.
    dwError  = NO_ERROR;

    pszValue = (LPTSTR)mszMimeMap.QueryPtr();

    //
    // Parse each MimeEntry in the string containing list of mime objects.
    //

    for( ; m_pMmeDefault == NULL;              // repeat until default is set
        pszValue = sg_rgchDefaultMimeEntry  // force default mapping in iter 2.
        ) {

        while ( *pszValue != TEXT( '\0')) {

            PMIME_MAP_ENTRY pMmeNew;

            pMmeNew = ReadAndParseMimeMapEntry( &pszValue);

            //
            // If New MimeMap entry found, Create a new object and update list
            //

            if ( (pMmeNew != NULL) &&
                !AddMimeMapEntry( pMmeNew)) {

                DBGPRINTF( ( DBG_CONTEXT,
                                "MIME_MAP::InitFromRegistry()."
                                " Failed to add new MIME Entry. Error = %d\n",
                                GetLastError())
                              );

                    delete pMmeNew;
                    //break;
            }
        } // while
    } // for


    return ( dwError);

} // MIME_MAP::InitFromRegistryNtStyle




DWORD
MIME_MAP::InitFromRegistryChicagoStyle( VOID )
/*++
  This function reads the list of MIME content-types available for regsitered file
  extensions. Global list of MIME objects is updated with not added yet extensions.
  This method should be invoked after server-specific map had been read, so it does not
  overwrite extensions common for two.

  Arguments:
     None.

  Returns:

     FALSE on failure to open/read registry entries
     TRUE  on success ( does not mean any objects were added)

--*/
{
    HKEY    hkeyMimeMap = NULL;
    HKEY    hkeyMimeType = NULL;
    HKEY    hkeyExtension = NULL;

    DWORD   dwError = ERROR_SUCCESS;
    DWORD   dwErrorChild = ERROR_SUCCESS;
    DWORD   dwIndexSubKey;
    DWORD   dwMimeSizeAllowed ;
    DWORD   dwType;
    DWORD   cbValue;

    LPTSTR  pszMimeMap = NULL;

    TCHAR   szSubKeyName[MAX_PATH];
    TCHAR   szExtension[MAX_PATH];

    PTSTR   pszMimeType;

    //
    // Read content types from all registered extensions
    //
    dwError = RegOpenKeyEx(HKEY_CLASSES_ROOT,       // hkey
                           "",                      // reg entry string
                           0,                       // dwReserved
                           KEY_READ,                // access
                           &hkeyMimeMap);           // pHkeyReturned.

    if ( dwError != NO_ERROR) {

        DBGPRINTF( ( DBG_CONTEXT,
                "MIME_MAP::InitFromRegistry(). Cannot open RegKey %s."
                "Error = %d\n",
                "HKCR_",
                dwError) );

          goto AddDefault;
    }

    dwIndexSubKey = 0;

    *szSubKeyName = '\0';
    pszMimeType = szSubKeyName ;

    dwError = RegEnumKey(hkeyMimeMap,
                         dwIndexSubKey,
                         szExtension,
                         sizeof(szExtension));

    while (dwError == ERROR_SUCCESS ) {

        //
        // Some entries in HKEY_CLASSES_ROOT are extensions ( start with dot)
        // and others are file types. We don't need file types here .
        //
        if (!::IsDBCSLeadByte(*szExtension) &&
            TEXT('.') == *szExtension) {

            //
            // Got next eligible extension
            //
            dwErrorChild = RegOpenKeyEx( HKEY_CLASSES_ROOT, // hkey
                                         szExtension,       // reg entry string
                                         0,                 // dwReserved
                                         KEY_READ,          // access
                                         &hkeyExtension);   // pHkeyReturned.

            if ( dwErrorChild != NO_ERROR) {

                DBGPRINTF( ( DBG_CONTEXT,
                             "MIME_MAP::InitFromRegistry(). "
                             " Cannot open RegKey HKEY_CLASSES_ROOT\\%s."
                             "Ignoring Error = %d\n",
                             szExtension,
                             dwErrorChild));
                break;
            }

            //
            // Now get content type for this extension if present
            //
            *szSubKeyName = '\0';
            cbValue = sizeof(szSubKeyName);

            dwErrorChild = RegQueryValueEx(hkeyExtension,
                                         "Content Type",
                                         NULL,
                                         &dwType,
                                         (LPBYTE)&szSubKeyName[0],
                                         &cbValue);
            if ( dwErrorChild == NO_ERROR) {

                //
                // Now we have MIME type and file extension
                // Create a new object and update list
                //

                if (!CreateAndAddMimeMapEntry(szSubKeyName,szExtension)) {
                    dwError = GetLastError();

                    DBGPRINTF( ( DBG_CONTEXT,
                                 "MIME_MAP::InitFromRegistry()."
                                 " Failed to add new MIME Entry. Error = %d\n",
                                 dwError)) ;
                }

            }

            RegCloseKey(hkeyExtension);

        }

        //
        // Attempt to read next extension
        //
        dwIndexSubKey++;

        dwError = RegEnumKey(hkeyMimeMap,
                             dwIndexSubKey,
                             szExtension,
                             sizeof(szExtension));

    } // end_while

    dwError = RegCloseKey( hkeyMimeMap);

AddDefault:

    //
    // Now after we are done with registry mapping - add default MIME type in case
    // if NT database does not exist
    //
    if (!CreateAndAddMimeMapEntry(sg_rgchDefaultMimeType,
                              sg_rgchDefaultFileExt)) {

        dwError = GetLastError();

        DBGPRINTF( ( DBG_CONTEXT,
                     "MIME_MAP::InitFromRegistry()."
                     "Failed to add new MIME Entry. Error = %d\n",
                     dwError) );
    }

    return ( NO_ERROR);

} // InitFromRegistryChicagoStyle



BOOL
MIME_MAP::CreateAndAddMimeMapEntry(
    IN  LPCTSTR     pszMimeType,
    IN  LPCTSTR     pszExtension
    )
{
    DWORD                   dwError;
    PCMIME_MAP_ENTRY        pEntry = NULL;

    //
    // First check if this extension is not yet present
    //

    pEntry = LookupMimeEntryForFileExt( pszExtension );
    if ( pEntry )
    {
        if ( !_tcscmp( pszExtension, sg_rgchDefaultFileExt ) ||
             ( pEntry != m_pMmeDefault ) )
        {
            IF_DEBUG(MIME_MAP) {
                DBGPRINTF( ( DBG_CONTEXT,
                         "MIME_MAP::CreateAndAddMimeEntry."
                         " New MIME Entry already exists for extension %s .\n",
                        pszExtension)
                       );
            }
            return TRUE;
        }
    }

    //
    // File extensions, stored by OLE/shell registration UI have leading
    // dot, we need to remove it , as other code won't like it.
    //
    if (!::IsDBCSLeadByte(*pszExtension) &&
        TEXT('.') == *pszExtension) {
        pszExtension = ::CharNext(pszExtension);
    }

    PMIME_MAP_ENTRY pMmeNew;

    pMmeNew = new MIME_MAP_ENTRY(pszMimeType,    //
                                  pszExtension   //
                                  );

    if (!pMmeNew || !pMmeNew->IsValid()) {

        //
        // unable to create a new MIME_MAP_ENTRY object.
        //
        if (pMmeNew) {
            delete pMmeNew;
        }
        return FALSE;
    }

    if ( !AddMimeMapEntry( pMmeNew)) {

        dwError = GetLastError();

        DBGPRINTF( ( DBG_CONTEXT,
                     "MIME_MAP::InitFromRegistry()."
                     " Failed to add new MIME Entry. Error = %d\n",
                     dwError)
                   );

        delete pMmeNew;
        return FALSE;
    }

    return TRUE;

} // MIME_MAP::CreateAndAddMimeMapEntry


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\common\isrpc.cxx ===
/*++


Copyright (c) 1999  Microsoft Corporation

Module Name:

    isrpc.cxx

Abstract:

    Contains ISRPC class implementation.

Author:

    Murali R. Krishnan         11-Dec-1995

Environment:

    User Mode - Win32

Revision History:

--*/


/************************************************************
 *  Include Headers
 ************************************************************/

#include <tcpdllp.hxx>

#include "dbgutil.h"
#include "isrpc.hxx"

extern PFN_INETINFO_START_RPC_SERVER pfnInetinfoStartRpcServer;
extern PFN_INETINFO_STOP_RPC_SERVER  pfnInetinfoStopRpcServer;

/************************************************************
 *  Functions
 ************************************************************/


ISRPC::ISRPC(IN LPCTSTR  pszServiceName)
/*++

  This function constructs a new ISRPC object, initializing the
   members to proper state.
  Always the ISRPC members will use RPC_C_AUTHN_WINNT.

  Arguments:

    pszServiceName -  pointer to string containing the name of the service
    dwServiceAuthId - DWORD containing the service Authentication Identifier.

  Returns:
    A valid initialized ISRPC object on success.

--*/
:  m_dwProtocols         ( 0),
   m_fInterfaceAdded     ( FALSE),
   m_fEpRegistered       ( FALSE),
   m_fServerStarted      ( FALSE),
   m_hRpcInterface       ( NULL),
   m_pszServiceName      ( pszServiceName),
   m_pBindingVector      ( NULL)
{

    DBG_REQUIRE( SetSecurityDescriptor() == NO_ERROR);

    IF_DEBUG( DLL_RPC) {

        DBGPRINTF(( DBG_CONTEXT,
                   " Created new ISRPC object for %s at %08p\n",
                   m_pszServiceName, this));
    }

} // ISRPC::ISRPC()




ISRPC::~ISRPC(VOID)
/*++

  This function cleans up the ISRPC object and releases any dynamic memory or
  state associated with this object.

--*/
{
    if( m_hRpcInterface != NULL ) {
        // CleanupData() should not be called twice
        CleanupData();
    }

    IF_DEBUG( DLL_RPC) {

        DBGPRINTF(( DBG_CONTEXT,
                   " Destroyed ISRPC object for %s at %p\n",
                   m_pszServiceName, this));
    }

} // ISRPC::~ISRPC()




DWORD
ISRPC::CleanupData(VOID)
/*++

Routine Description:

    This member function cleans up the ISRPC object.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DWORD rpcStatus = RPC_S_OK;

    IF_DEBUG( DLL_RPC) {

        DBGPRINTF(( DBG_CONTEXT,
                   " ISRPC(%p)::Cleaning up for %s\n",
                   this, m_pszServiceName));
    }

    if ( m_fServerStarted) {

        rpcStatus = StopServer( );
    }

    DBG_ASSERT( rpcStatus == RPC_S_OK);

    rpcStatus = UnRegisterInterface();

    m_dwProtocols     = 0;
    m_hRpcInterface   = NULL;

    return (rpcStatus);
} // ISRPC::CleanupData()




DWORD
ISRPC::RegisterInterface( IN RPC_IF_HANDLE  hRpcInterface)
/*++

  This function registers the RPC inteface in the object.
  If there is already a valid instance present in the object,
   this function fails and returns error.
  If this is the new interface specified, the function registers the
    interface both for dynamic and static bindings.

   Should be called after calling AddProtocol() and before StartServer()

  Arguments:
    hRpcInteface - RPC inteface handle.

  Returns:
    Win32 Error Code - NO_ERROR on success.

--*/
{
    DWORD dwError = NO_ERROR;

    if ( m_dwProtocols == 0) {

        // No protocol added. Return failure.
        return ( ERROR_INVALID_PARAMETER);
    }

    if ( m_hRpcInterface != NULL) {

        dwError =  ( RPC_S_DUPLICATE_ENDPOINT);
    } else {

        //
        // since there is no duplicate, just set the new value and return.
        //

        if ( hRpcInterface == NULL) {

            dwError = ERROR_INVALID_PARAMETER;
        } else {

            m_hRpcInterface = hRpcInterface;
        }
    }


    if ( dwError == RPC_S_OK) {

        dwError = RpcServerRegisterIf(m_hRpcInterface,
                                      0,   // MgrUuid
                                      0    // MgrEpv (Entry Point Vector)
                                      );

        if ( dwError == RPC_S_OK ) {

            m_fInterfaceAdded = TRUE;

            //
            //  Establish the dynamic bindings if any.
            //

            if ( (m_dwProtocols & (ISRPC_OVER_TCPIP | ISRPC_OVER_SPX)) != 0) {

                dwError = RpcServerInqBindings( &m_pBindingVector);

                if ( dwError == RPC_S_OK) {

                    DBG_ASSERT( m_pBindingVector != NULL);

                    dwError = RpcEpRegister(m_hRpcInterface,
                                            m_pBindingVector,
                                            NULL,
                                            (unsigned char *) "" );

                    if ( dwError == RPC_S_OK) {

                        m_fEpRegistered = TRUE;
                    }
                } // Ep registering
            } // dynamic bindings
        } // registration successful
    }


    IF_DEBUG(DLL_RPC) {

        DBGPRINTF(( DBG_CONTEXT, "ISRPC(%p)::RegisterInterface(%08x)"
                   " returns %ld\n",
                   this, hRpcInterface, dwError));
    }

    return ( dwError);

} // ISRPC::RegisterInterface()



DWORD
ISRPC::UnRegisterInterface( VOID)
/*++

  This function unregisters the RPC inteface in the object.

   Should be called after after StopServer() and before cleanup.

  Arguments:
    None

  Returns:
    Win32 Error Code - NO_ERROR on success.

--*/
{
    DWORD rpcStatus = RPC_S_OK;

    if ( m_fEpRegistered) {

        DBG_ASSERT( m_hRpcInterface != NULL && m_pBindingVector != NULL);
        rpcStatus = RpcEpUnregister(m_hRpcInterface,
                                    m_pBindingVector,
                                    NULL              // pUuidVector
                                    );
        IF_DEBUG( DLL_RPC) {

            DBGPRINTF(( DBG_CONTEXT,
                       "%p::RpcEpUnregister(%s) returns %d\n",
                       this, m_pszServiceName, rpcStatus));
        }

        if( rpcStatus == EPT_S_CANT_PERFORM_OP )
        {
            // This error can be returned in cases such as system
            // shutdown that are not severe errors. So we don't
            // want to assert.
            DBGWARN(( DBG_CONTEXT,
                      "%p::RpcEpUnregister(%s) failed with EPT_S_CANT_PERFORM_OP\n",
                      this, m_pszServiceName
                      ));
        }
        else
        {
            DBG_ASSERT( rpcStatus == RPC_S_OK );
            m_fEpRegistered = FALSE;
        }
    }

    if ( m_pBindingVector != NULL) {

        rpcStatus = RpcBindingVectorFree( &m_pBindingVector);

        IF_DEBUG( DLL_RPC) {

            DBGPRINTF(( DBG_CONTEXT,
                       "%p::RpcBindingVectorFree(%s, %p) returns %d\n",
                       this, m_pszServiceName,
                       m_pBindingVector, rpcStatus));
        }

        DBG_ASSERT( rpcStatus == RPC_S_OK);

        m_pBindingVector = NULL;
    }

    if ( m_fInterfaceAdded != NULL) {

        rpcStatus = RpcServerUnregisterIf(m_hRpcInterface,
                                          NULL,      // MgrUuid
                                          TRUE  // wait for calls to complete
                                          );

        IF_DEBUG( DLL_RPC) {

            DBGPRINTF(( DBG_CONTEXT,
                       "%p::RpcServerUnregisterIf(%s, %08x) returns %d\n",
                       this, m_pszServiceName, m_hRpcInterface, rpcStatus));
        }
    }

    IF_DEBUG(DLL_RPC) {

        DBGPRINTF(( DBG_CONTEXT, "ISRPC(%p)::UnRegisterInterface(%08x)"
                   " returns %ld\n",
                   this, m_hRpcInterface, rpcStatus));
    }

    return ( rpcStatus);
} // ISRPC::UnRegisterInterface()




DWORD
ISRPC::AddProtocol( IN DWORD Protocol)
/*++

Routine Description:

    This member function adds another protocol to the binding list.

Arguments:

    protocol - protocol binding opcode.

Return Value:

    RPC error code.

--*/
{
    DWORD rpcStatus = RPC_S_OK;

    if ( Protocol & ISRPC_OVER_LPC ) {

        // Currently we only support static binding
        rpcStatus = BindOverLpc( FALSE);
    }

    //
    // Enable all remote bindings
    //

    if ( rpcStatus == RPC_S_OK && Protocol & ISRPC_OVER_TCPIP ) {

        // Currently we only support dynamic binding
        rpcStatus = BindOverTcp( TRUE);
    }

    if ( rpcStatus == RPC_S_OK && Protocol & ISRPC_OVER_NP ) {

        // Currently we only support static binding
        rpcStatus = BindOverNamedPipe( FALSE);
    }

    if ( rpcStatus == RPC_S_OK &&  Protocol & ISRPC_OVER_SPX  ) {

        // Currently we only support dynamic binding
        rpcStatus = BindOverSpx( TRUE);
    }

    IF_DEBUG( DLL_RPC) {

        DBGPRINTF(( DBG_CONTEXT,
                   "ISRPC(%p)::AddProtocol(%08x) returns %ld.\n",
                   this, Protocol, rpcStatus ));
    }

    return( rpcStatus );

} // ISRPC::AddProtocol()

DWORD
ISRPC::RemoveProtocol(IN DWORD Protocol)
/*++

Routine Description:

    This member function removes a protocol from the binding list.

Arguments:

    protocol - protocol binding opcode.

Return Value:

    RPC error code.

Note:
    As a side effect, this function removes the dynamic endpoing on
     TCPIP when SPX binding is removed and vice-versa.

--*/
{

    DBGPRINTF(( DBG_CONTEXT,
               " ISRPC(%p)::RemoveProtocol(%s) is not implemented\n",
               this, m_pszServiceName));
    DBG_ASSERT( FALSE);

    return ( ERROR_CALL_NOT_IMPLEMENTED);
} // ISRPC::RemoveProtocol()




DWORD
ISRPC::StartServer(
            VOID
            )
/*++

Routine Description:

    This member function start RPC server.

Arguments:

    None.

Return Value:

    RPC error code.

--*/
{
    DWORD rpcStatus;

    //
    // add the interface.
    //

    if ( m_hRpcInterface == NULL) {

        return (ERROR_INVALID_PARAMETER);
    }

    //
    // start rpc server.
    //

#ifndef SERVICE_AS_EXE

    rpcStatus =  pfnInetinfoStartRpcServer();

#else

    rpcStatus = RpcServerListen(
                                1,          // minimum num threads.
                                1,          // max concurrent calls.
                                TRUE );     // don't wait

#endif // SERVICE_AS_EXE

    if ( rpcStatus == RPC_S_OK ) {
        m_fServerStarted = TRUE;
    }

    IF_DEBUG( DLL_RPC) {

        DBGPRINTF(( DBG_CONTEXT, "ISRPC(%p)::StartServer(%s) returns %ld\n",
                   this, m_pszServiceName, rpcStatus));
    }

    return( rpcStatus );

} // ISRPC::StartServer()




DWORD
ISRPC::StopServer(
            VOID
            )
{
    DWORD  rpcStatus = RPC_S_OK;

    if( m_fServerStarted ) {

#ifndef SERVICE_AS_EXE

        rpcStatus = pfnInetinfoStopRpcServer();
#else

        //
        // stop server listen.
        //

        rpcStatus = RpcMgmtStopServerListening(0);

        //
        // wait for all RPC threads to go away.
        //

        if( rpcStatus == RPC_S_OK) {

            rpcStatus = RpcMgmtWaitServerListen();
        }

#endif // SERVICE_AS_EXE

        m_fServerStarted = FALSE;
    }

    IF_DEBUG( DLL_RPC) {

        DBGPRINTF(( DBG_CONTEXT,
                   "ISRPC(%p)::StopServer( %s) returns %d\n",
                   this, m_pszServiceName, rpcStatus));
    }

    return ( rpcStatus);
} // ISRPC::StopServer()



DWORD
ISRPC::EnumBindingStrings(
    IN OUT LPINET_BINDINGS pBindings
    )
/*++

Routine Description:

    This member function enumurates the binding strings of the protocols
    bound to the server.

Arguments:

    pBindings : pointer to a binding strings structure. The caller
        should call FreeBindingStrings member function to free the string
        after use.

Return Value:

    Windows Error Code;

--*/
{
   DWORD dwError;
   RPC_BINDING_VECTOR * pBindingVector = NULL;
   LPINET_BIND_INFO pBindingsInfo;
   DWORD  dwCount = 0;
   DWORD i;

   //
   // query RPC for RPC_BINDING_VECTORS.
   //

   dwError =   RpcServerInqBindings( &pBindingVector );

   if( dwError != NO_ERROR ) {

       goto Cleanup;
   }

   DBG_ASSERT( pBindingVector->Count > 0 );

   //
   // alloc memory for  INET_RPC_BINDING_STRINGS.
   //

   pBindingsInfo = (LPINET_BIND_INFO)
     LocalAlloc( GPTR, sizeof(INET_BIND_INFO) * pBindingVector->Count );

   if( pBindingsInfo == NULL ) {

       dwError = ERROR_NOT_ENOUGH_MEMORY;
       goto Cleanup;
   }

   //
   // convert binding handle to binding vectors.
   //

   pBindings->NumBindings  = 0;
   pBindings->BindingsInfo = pBindingsInfo;

   for( i = 0; i < pBindingVector->Count; i++ ) {

       LPSTR BindingString;

       BindingString = NULL;
       dwError = RpcBindingToStringBindingA(pBindingVector->BindingH[i],
                                            (LPBYTE *)&BindingString );

       if( dwError != NO_ERROR ) {
           goto Cleanup;
       }

       IF_DEBUG( DLL_RPC) {
           DBGPRINTF(( DBG_CONTEXT, "Binding Handle[%d] = %08x. String = %s\n",
                      i, pBindingVector->BindingH[i], BindingString));
       }


       //
       // check to we get only our named-pipe endpoint.
       //

       if ( ( strstr( BindingString, "ncacn_np" ) == NULL ) ||
            ( strstr(BindingString, m_pszServiceName ) == NULL ) ) {

           RpcStringFreeA( (LPBYTE *)&BindingString );

       } else {

           //
           // found a named-pipe binding string with service name.
           //

           IF_DEBUG( DLL_RPC) {
               DBGPRINTF(( DBG_CONTEXT, "Binding String Chosen = %s\n",
                          BindingString));
           }

           pBindings->BindingsInfo[dwCount].Length =
             (strlen(BindingString) + 1) * sizeof(CHAR);
           pBindings->BindingsInfo[dwCount].BindData = BindingString;
           dwCount++;
       }

   } // for

   dwError = NO_ERROR;
   pBindings->NumBindings = dwCount;

   IF_DEBUG( DLL_RPC) {

       DBGPRINTF(( DBG_CONTEXT, "Binding Vectors chosen"
                  " Service = %s, NumBindings = %d of Total = %d\n",
                  m_pszServiceName, dwCount, pBindingVector->Count));
   }

 Cleanup:

   if( pBindingVector != NULL ) {

       DWORD LocalError;
       LocalError = RpcBindingVectorFree( &pBindingVector );
       DBG_ASSERT( LocalError == NO_ERROR );
   }

   if( dwError != NO_ERROR ) {
       FreeBindingStrings( pBindings );
       pBindings->NumBindings = 0;

       IF_DEBUG( DLL_RPC) {

           DBGPRINTF(( DBG_CONTEXT,
                      "ISRPC(%p)::EnumBindingStrings(%s) failed, %ld.",
                      this, m_pszServiceName, dwError ));
       }
   }

   return( dwError );

} // ISRPC::EnumBindingStrings()




VOID
ISRPC::FreeBindingStrings(
     IN OUT LPINET_BINDINGS pInetBindings
    )
/*++

Routine Description:

    This member function deletes a binding vector that was returned by the
    EnumBindingStrings member function.

Arguments:

    pBindings : pointer to a binding vector.

Return Value:

    Windows Error Code;

--*/
{
    DWORD dwError;
    DWORD i;


    //
    // free binding strings.
    //

    for( i = 0; i < pInetBindings->NumBindings; i++) {
        dwError = RpcStringFreeA( ((LPBYTE *)&pInetBindings
                                 ->BindingsInfo[i].BindData ));
        DBG_ASSERT( dwError == NO_ERROR );
    }

    pInetBindings->NumBindings = 0;

    //
    // free bindings info array.
    //

    if( pInetBindings->BindingsInfo != NULL ) {
        LocalFree( (LPWSTR)pInetBindings->BindingsInfo );
        pInetBindings->BindingsInfo = NULL;
    }

    return;

} // ISRPC::FreeBindingStrings()




DWORD
ISRPC::BindOverTcp(IN BOOL fDynamic)
{
    DWORD rpcStatus = RPC_S_OK;

    DBG_ASSERT( (m_dwProtocols & ISRPC_OVER_TCPIP) == 0);

    if ( !fDynamic) {

        rpcStatus =  ( ERROR_CALL_NOT_IMPLEMENTED);

    } else {

        rpcStatus = ( ISRPC::DynamicBindOverTcp());
    }

    if ( rpcStatus == RPC_S_OK) {

        m_dwProtocols |= ISRPC_OVER_TCPIP;
    }

    if (rpcStatus == RPC_S_PROTSEQ_NOT_SUPPORTED) {

        //
        // This error gets written to the event log by the service controller,
        // so give it something the user is more likely to understand.
        //

        rpcStatus = DNS_ERROR_NO_TCPIP;


        IF_DEBUG( DLL_RPC) {

            DBGPRINTF(( DBG_CONTEXT,
                        "(%p)::BindOverTcp(%s) mapping error %d to error %d\n",
                        this,
                        m_pszServiceName,
                        RPC_S_PROTSEQ_NOT_SUPPORTED,
                        DNS_ERROR_NO_TCPIP));
        }

    }

    IF_DEBUG( DLL_RPC) {

        DBGPRINTF(( DBG_CONTEXT, "(%p)::BindOverTcp(%s) returns %d\n",
                   this, m_pszServiceName, rpcStatus));
    }

    return ( rpcStatus);
} // ISRPC::BindOverTcpIp()

DWORD
ISRPC::BindOverNamedPipe(IN BOOL fDynamic)
{
    DWORD rpcStatus = RPC_S_OK;

    DBG_ASSERT( (m_dwProtocols & ISRPC_OVER_NP) == 0);


    //
    // On Named Pipe, we support only static bindings. No dynamic Binding.
    //

    if ( fDynamic) {

        return ( ERROR_CALL_NOT_IMPLEMENTED);
    }

    if( (m_dwProtocols & ISRPC_OVER_NP) == 0 ) {

        WCHAR  rgchNp[1024];

        wsprintfW( rgchNp,
#ifdef UNICODE
                  L"%ws%s"
#else
                  L"%ws%S"
#endif // UNICODE
                  ,
                  ISRPC_NAMED_PIPE_PREFIX_W,
                  m_pszServiceName);

        //
        // Establish a static Named pipe binding.
        //

        rpcStatus =
          RpcServerUseProtseqEpW(
                                 L"ncacn_np",        // protocol string.
                                 ISRPC_PROTSEQ_MAX_REQS, //max concurrent calls
                                 rgchNp,             // end point!
                                 &sm_sid[ACL_INDEX_ALLOW_ADMIN] );          // security

        IF_DEBUG( DLL_RPC) {

            CHAR pszBuff[100];
            wsprintfA( pszBuff, "%S", rgchNp);
            DBGPRINTF(( DBG_CONTEXT,
                       " RpcServerUseProtseqEpW( %s, %d, %s, %p) returns"
                       " %d\n",
                       "ncacn_np", ISRPC_PROTSEQ_MAX_REQS,
                       pszBuff, &sm_sid[ACL_INDEX_ALLOW_ADMIN], rpcStatus));
        }

        switch (rpcStatus) {

          case RPC_S_OK:

            //
            // set the protocol bit.
            //
            m_dwProtocols |= ISRPC_OVER_NP;
            break;

          case RPC_S_DUPLICATE_ENDPOINT:

            //
            // Ignore the duplicate end point error
            //
            DBGPRINTF(( DBG_CONTEXT,
                       "(%p) ncacn_np is already added for %s\n",
                       this,
                       m_pszServiceName));
            m_dwProtocols |= ISRPC_OVER_NP;
            rpcStatus = RPC_S_OK;
            break;

          case RPC_S_PROTSEQ_NOT_SUPPORTED:
          case RPC_S_CANT_CREATE_ENDPOINT:

            DBGPRINTF(( DBG_CONTEXT,
                       "(%p) ncacn_np is not supported for %s (%ld).\n",
                       this, m_pszServiceName, rpcStatus ));
            rpcStatus = RPC_S_OK;
            break;

          default:
            break;
        } // switch()
    }

    return ( rpcStatus);

} // ISRPC::BindOverNamedPipe()





DWORD
ISRPC::BindOverLpc(IN BOOL fDynamic)
{
    DWORD rpcStatus = RPC_S_OK;

    DBG_ASSERT( (m_dwProtocols & ISRPC_OVER_LPC) == 0);


    //
    // On LPC, we support only static bindings. No dynamic Binding.
    //

    if ( fDynamic) {

        return ( ERROR_CALL_NOT_IMPLEMENTED);
    }

    if( (m_dwProtocols & ISRPC_OVER_LPC) == 0 ) {

        WCHAR  rgchLpc[1024];

        // LPC Endpoint string is:   <InterfaceName>_LPC
        wsprintfW( rgchLpc,
#ifdef UNICODE
                  L"%s_%ws"
#else
                  L"%S_%ws"
#endif // UNICODE
                  ,
                  m_pszServiceName,
                  ISRPC_LPC_NAME_SUFFIX_W);

        //
        // Establish a static Lpc binding.
        //

        rpcStatus =
          RpcServerUseProtseqEpW(
                                 L"ncalrpc",         // protocol string.
                                 ISRPC_PROTSEQ_MAX_REQS, //max concurrent calls
                                 rgchLpc,            // end point!
                                 &sm_sid[ACL_INDEX_ALLOW_ALL] );          // security

        IF_DEBUG( DLL_RPC) {

            CHAR pszBuff[100];
            wsprintfA( pszBuff, "%S", rgchLpc);
            DBGPRINTF(( DBG_CONTEXT,
                       " RpcServerUseProtseqEpW( %s, %d, %s, %p) returns"
                       " %d\n",
                       "ncalrpc", ISRPC_PROTSEQ_MAX_REQS,
                       pszBuff, &sm_sid[ACL_INDEX_ALLOW_ALL], rpcStatus));
        }

        switch (rpcStatus) {

          case RPC_S_OK:

            //
            // set the protocol bit.
            //
            m_dwProtocols |= ISRPC_OVER_LPC;
            break;

          case RPC_S_DUPLICATE_ENDPOINT:

            //
            // Ignore the duplicate end point error
            //
            DBGPRINTF(( DBG_CONTEXT,
                       "(%p) ncalrpc is already added for %s\n",
                       this,
                       m_pszServiceName));
            m_dwProtocols |= ISRPC_OVER_LPC;
            rpcStatus = RPC_S_OK;
            break;

          case RPC_S_PROTSEQ_NOT_SUPPORTED:
          case RPC_S_CANT_CREATE_ENDPOINT:

            DBGPRINTF(( DBG_CONTEXT,
                       "(%p) ncalrpc is not supported for %s (%ld).\n",
                       this, m_pszServiceName, rpcStatus ));
            rpcStatus = RPC_S_OK;
            break;

          default:
            break;
        } // switch()
    }

    return ( rpcStatus);

} // ISRPC::BindOverLpc()




DWORD
ISRPC::BindOverSpx(IN BOOL fDynamic)
{
    DWORD rpcStatus = RPC_S_OK;

    DBG_ASSERT( (m_dwProtocols & ISRPC_OVER_SPX) == 0);

    if ( !fDynamic) {

        rpcStatus =  ( ERROR_CALL_NOT_IMPLEMENTED);

    } else {

        rpcStatus = ISRPC::DynamicBindOverSpx();
    }

    if ( rpcStatus == RPC_S_OK) {

        m_dwProtocols |= ISRPC_OVER_SPX;
    }

    IF_DEBUG( DLL_RPC) {

        DBGPRINTF(( DBG_CONTEXT, "(%p)::BindOverSpx(%s) returns %d\n",
                   this, m_pszServiceName, rpcStatus));
    }

    return ( rpcStatus);
} // ISRPC::BindOverSpx()


# if DBG

VOID
ISRPC::Print(VOID) const
{
    DBGPRINTF(( DBG_CONTEXT,
               " ISRPC(%p). SvcName=%s\n"
               " Protocols = %d.\n"
               " RPC Interface = %08x. Binding Vector = %p\n"
               " InterfaceAdded = %d.\n"
               " EpRegistered = %d. ServerStarted = %d.\n"
               ,
               this, m_pszServiceName,
               m_dwProtocols,
               m_hRpcInterface, m_pBindingVector,
               m_fInterfaceAdded,
               m_fEpRegistered, m_fServerStarted
               ));

} // ISRPC::Print()

# endif // DBG



/******************************
 * STATIC Member Definitions
 ******************************/

DWORD ISRPC::sm_dwProtocols = 0;

SECURITY_DESCRIPTOR ISRPC::sm_sid[2];
PACL ISRPC::sm_pACL[2] = {NULL, NULL};
BOOL  ISRPC::sm_fSecurityEnabled = FALSE;


DWORD
ISRPC::Initialize(VOID)
{
    sm_dwProtocols  = 0;

    return SetSecurityDescriptor();

} // ISRPC::Initialize()



DWORD
ISRPC::Cleanup(VOID)
{
    //
    // Free up the memory holding the ACL for the security descriptor
    //
    if (sm_pACL[0]) {
        delete [] ((BYTE *) sm_pACL[0]);
        sm_pACL[0] = NULL;
    }
    if (sm_pACL[1]) {
        delete [] ((BYTE *) sm_pACL[1]);
        sm_pACL[1] = NULL;
    }

    //
    // Free up the security descriptor
    //

    ZeroMemory( (PVOID) &sm_sid, sizeof(sm_sid));

    //
    // For now nothing to do. Just a place holder.
    //

    return ( NO_ERROR);

} // ISRPC::Cleanup()


DWORD
ISRPC::DynamicBindOverTcp(VOID)
/*++
  This static function (ISRPC member) establishes a dynamic endpoing
   RPC binding over TCP/IP, using a run-time library call to RPC.
  RPC run-time library allows one to create as many dynamic end points
   as one wishes. So we maintain external state and control the number
   of end points created to 1.

  Arguments:
    None

  Returns:
    RPC status - RPC_S_OK for success.

--*/
{
    DWORD rpcStatus = RPC_S_OK;

    if( (sm_dwProtocols & ISRPC_OVER_TCPIP) == 0 ) {

        //
        // Not already present. Add dynamic endpoint over TCP/IP
        //

        rpcStatus =
          RpcServerUseProtseqW(
                               L"ncacn_ip_tcp",    // protocol string.
                               ISRPC_PROTSEQ_MAX_REQS, //max concurrent calls
                               &sm_sid[ACL_INDEX_ALLOW_ADMIN] );          // security

        switch (rpcStatus) {

          case RPC_S_OK:

            //
            // set the protocol bit.
            //

            sm_dwProtocols |= ISRPC_OVER_TCPIP;
            break;

          case RPC_S_DUPLICATE_ENDPOINT:

            DBGPRINTF(( DBG_CONTEXT,
                       "ncacn_ip_tcp is already added.\n"));
            sm_dwProtocols |= ISRPC_OVER_TCPIP;
            rpcStatus = RPC_S_OK;
            break;

          case RPC_S_PROTSEQ_NOT_SUPPORTED:
          case RPC_S_CANT_CREATE_ENDPOINT:

            DBGPRINTF(( DBG_CONTEXT,
                       "ncacn_ip_tcp is not supported. Error = %ld\n",
                       rpcStatus));

            break;

          default:
            break;
        } // switch()

        //
        // if the security support provider is not enabled, do so.
        //

        if( rpcStatus == RPC_S_OK && !IsSecurityEnabled() ) {

            rpcStatus = AddSecurity();

        }
    }

    IF_DEBUG( DLL_RPC) {

        DBGPRINTF(( DBG_CONTEXT, "DynamicBindOverTcp() returns %d\n",
                   rpcStatus));
    }

    return ( rpcStatus);

} // ISRPC::DynamicBindOverTcp()




DWORD
ISRPC::DynamicBindOverSpx(VOID)
/*++
  This static function (ISRPC member) establishes a dynamic endpoing
   RPC binding over SPX, using a run-time library call to RPC.
  RPC run-time library allows one to create as many dynamic end points
   as one wishes. So we maintain external state and control the number
   of end points created to 1.

  Arguments:
    None

  Returns:
    RPC status - RPC_S_OK for success.

--*/
{
    DWORD rpcStatus = RPC_S_OK;

    if( (sm_dwProtocols & ISRPC_OVER_SPX) == 0 ) {

        // Use dynamic end point for the server.
        rpcStatus =
          RpcServerUseProtseqW(
                               L"ncacn_spx",       // protocol string.
                               ISRPC_PROTSEQ_MAX_REQS, //max concurrent calls
                               &sm_sid[ACL_INDEX_ALLOW_ADMIN] );          // security

        switch (rpcStatus) {

          case RPC_S_OK:

            //
            // set the protocol bit.
            //
            sm_dwProtocols |= ISRPC_OVER_SPX;
            break;

          case RPC_S_DUPLICATE_ENDPOINT:

            DBGPRINTF(( DBG_CONTEXT,
                       "ncacn_spx is already added.\n"
                       ));
            sm_dwProtocols |= ISRPC_OVER_SPX;
            rpcStatus = RPC_S_OK;
            break;

          case RPC_S_PROTSEQ_NOT_SUPPORTED:
          case RPC_S_CANT_CREATE_ENDPOINT:

            DBGPRINTF(( DBG_CONTEXT,
                       "ncacn_spx is not supported. Error (%ld).\n",
                       rpcStatus ));
            break;

          default:
            break;
        } // switch()

        //
        // if the security support provider is not enabled, do so.
        //

        if( rpcStatus == RPC_S_OK && !IsSecurityEnabled()) {

            rpcStatus = AddSecurity();
        }
    }

    IF_DEBUG( DLL_RPC) {

        DBGPRINTF(( DBG_CONTEXT, "DynamicBindOverSpx() returns %d\n",
                   rpcStatus));
    }

    return ( rpcStatus);

} // ISRPC::DynamicBindOverSpx()





DWORD
ISRPC::SetSecurityDescriptor( VOID)
/*++

Routine Description:

    This member function builds the security descriptor used by RPC module.
    The security descriptor denies everybody the ability to change/see anything
    connected to the DACL and allows everybody to read from/write to the pipe.

    Create a pair of security descriptors. One allow everyone access,
    which is intended for LPC binding. One allow only administrator
    access, which is intended for remote transports.

Arguments:

    None.

Return Value:

    Windows error code.

--*/
{
    DWORD dwError = NO_ERROR;
    BOOL  fSuccess = FALSE;
    SID_IDENTIFIER_AUTHORITY siaWorld = SECURITY_WORLD_SID_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY siaNt    = SECURITY_NT_AUTHORITY;
    PSID psidWorld = NULL;
    PSID psidAdmins = NULL;
    int sdCount;

    //
    // Create the "WORLD" sid and "LOCAL Administrators" sid
    //
    if ( !AllocateAndInitializeSid( &siaWorld,
                                    1,
                                    SECURITY_WORLD_RID,
                                    0,0,0,0,0,0,0,
                                    &psidWorld )
        || !AllocateAndInitializeSid( &siaNt,
                                    2,
                                    SECURITY_BUILTIN_DOMAIN_RID,
                                    DOMAIN_ALIAS_RID_ADMINS,
                                    0,0,0,0,0,0,
                                    &psidAdmins ) )
    {
        DBGPRINTF((DBG_CONTEXT,
                   "AllocateAndInitializeSid failed : 0x%x\n",
                   GetLastError()));
        goto cleanup;
    }

    for (sdCount=0; sdCount<2; sdCount++)
    {
        BYTE *pbBuffer = NULL;
        DWORD cbAcl = 0;

        PSID pSid2Allow = (sdCount==ACL_INDEX_ALLOW_ALL)? psidWorld: psidAdmins;

        InitializeSecurityDescriptor(&sm_sid[sdCount],
                                    SECURITY_DESCRIPTOR_REVISION );

        //
        // Calculate the size of the ACL that will hold the the ACESS_DENIED and ACCESS_ALLOW ace
        // [ripped off from MSDN docs]
        //
        cbAcl = sizeof(ACL) +
            sizeof( ACCESS_ALLOWED_ACE ) +
            sizeof( ACCESS_DENIED_ACE )  +
            2*GetLengthSid(pSid2Allow) -
            2*sizeof(DWORD) ;

        if ( ! ( pbBuffer = new BYTE[cbAcl] ) )
        {
            goto cleanup;
        }

        sm_pACL[sdCount] = (PACL) pbBuffer;

        //
        // Initialize the ACL
        //
        if ( !InitializeAcl( sm_pACL[sdCount],
                            cbAcl,
                            ACL_REVISION ) )
        {
            DBGPRINTF((DBG_CONTEXT,
                    "InitializeAcl failed : 0x%x\n",
                    GetLastError()));
            goto cleanup;
        }

        //
        // Add the Access Denied ACE; this has to be first in the list to make sure
        // that any attempt to muck with the DACL will be disallowed
        //
        if ( !AddAccessDeniedAce( sm_pACL[sdCount],
                                ACL_REVISION,
                                WRITE_DAC | DELETE | WRITE_OWNER,
                                psidWorld ) )
        {
            DBGPRINTF((DBG_CONTEXT,
                    "AddAccessDeniedAce failed : 0x%x\n",
                    GetLastError()));
            goto cleanup;
        }

        //
        // Add the Access Allowed ACE
        //
        if ( !AddAccessAllowedAce( sm_pACL[sdCount],
                                ACL_REVISION,
                                FILE_ALL_ACCESS,
                                pSid2Allow ) )
        {
            DBGPRINTF((DBG_CONTEXT,
                    "AddAccessAllowedAce failed : 0x%x\n",
                    GetLastError()));
            goto cleanup;
        }

        //
        // Set (no) group & owner for the security descriptor
        //
        if ( !SetSecurityDescriptorOwner( &sm_sid[sdCount],
                                        NULL,
                                        FALSE ) )
        {
            DBGPRINTF((DBG_CONTEXT,
                    "SetsecurityDescriptorOwner failed : 0x%x\n",
                    GetLastError()));
            goto cleanup;
        }


        if ( !SetSecurityDescriptorGroup( &sm_sid[sdCount],
                                        NULL,
                                        FALSE ) )
        {
            DBGPRINTF((DBG_CONTEXT,
                    "SetsecurityDescriptorGroup failed : 0x%x\n",
                    GetLastError()));
            goto cleanup;
        }

        if ( !SetSecurityDescriptorDacl ( &sm_sid[sdCount],
                                                    TRUE,          // Dacl present
                                                    sm_pACL[sdCount],
                                                    FALSE ) )    // Not defaulted
        {
            DBGPRINTF((DBG_CONTEXT,
                    "SetSecurityDescriptorDacl failed : 0x%x\n",
                    GetLastError()));
            goto cleanup;
        }
    }

    fSuccess = TRUE;

cleanup:


    if ( psidWorld )
    {
        FreeSid( psidWorld );
    }

    if ( psidAdmins )
    {
        FreeSid( psidAdmins );
    }

    if (!fSuccess)
    {

        dwError = GetLastError();

        if ( sm_pACL[0] )
        {
            delete (BYTE*) sm_pACL[0];
            sm_pACL[0] = NULL;
        }

        if ( sm_pACL[1] )
        {
            delete (BYTE*) sm_pACL[1];
            sm_pACL[1] = NULL;
        }

        //
        // free up security discriptor memory and set it to NULL.
        //
        memset( (PVOID ) &sm_sid,  0, sizeof(sm_sid));
    }

    return( dwError );

} // ISRPC::SetSecurityDescriptor()




DWORD
ISRPC::AddSecurity(
    VOID
    )
/*++

Routine Description:

    This member function adds security support provider over RPC.

Arguments:

    None.

Return Value:

    Windows error code.

--*/
{
    DWORD rpcStatus;

    //
    // Register for authentication using WinNT.
    //

    rpcStatus = RpcServerRegisterAuthInfo(
                    (unsigned char * ) NULL, // app name to security provider
                    RPC_C_AUTHN_WINNT,       // Auth package ID.
                    NULL,                    // RPC_C_AUTHN_WINNT ==> NULL
                    NULL                     // args ptr for authn function.
                    );

    if ( rpcStatus == RPC_S_OK) {

        sm_fSecurityEnabled = TRUE;
    }

    IF_DEBUG( DLL_RPC) {

        DBGPRINTF(( DBG_CONTEXT, "AddSecurity() returns Error %u\n",
                   rpcStatus));
    }

    //
    // Hide the failure that occurs when the server is locked
    // down and does not have the network client installed. This will
    // cause performance counters to fail.
    //
    if( rpcStatus == RPC_S_UNKNOWN_AUTHN_SERVICE )
    {
        DBGWARN(( DBG_CONTEXT,
                  "RpcServerRegisterAuthInfo failed with "
                  "RPC_S_UNKNOWN_AUTHN_SERVICE. Some features, such as "
                  "performance counters, may not function.\n"
                  ));

        rpcStatus = RPC_S_OK;
    }

    return (rpcStatus);
} // ISRPC::AddSecurity()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\common\logon32.cxx ===
/*++


Copyright (c) 1996  Microsoft Corporation

Module Name:

    logon32.cxx

Abstract:

    Provide a replacement for LogonUser to login a user
    as a net logon. Also support sub-authentication DLL IDs

Author:

    Philippe Choquier (phillich)    10-january-1996
    Created from base\advapi\logon32.c

--*/


#include "tcpdllp.hxx"

#pragma hdrstop

#include <lmjoin.h>
#include <lonsi.hxx>
#include <infosec.hxx>

//
// externs
//

extern LOGON32_INITIALIZE_FN           pfnLogon32Initialize;
extern LOGON_NET_USER_A_FN             pfnLogonNetUserA;
extern LOGON_NET_USER_W_FN             pfnLogonNetUserW;
extern NET_USER_COOKIE_A_FN            pfnNetUserCookieA;
extern LOGON_DIGEST_USER_A_FN          pfnLogonDigestUserA;

BOOL
Logon32Initialize(
    IN PVOID    hMod,
    IN ULONG    Reason,
    IN PCONTEXT Context)
/*++

Routine Description:

    Initializes the critical section

Arguments:

    hMod -- reserved, must be NULL
    Reason -- DLL_PROCESS_ATTACH or DLL_PROCESS_DETACH
    Context -- reserved, must be NULL

Returns:

    TRUE if initialization success, else FALSE

--*/
{
    DBG_ASSERT( pfnLogon32Initialize != NULL );
    return pfnLogon32Initialize(
                            hMod,
                            Reason,
                            Context );
} // Logon32Initialize


BOOL
WINAPI
LogonNetUserW(
    PWSTR           lpszUsername,
    PWSTR           lpszDomain,
    PSTR            lpszPassword,
    PWSTR           lpszWorkstation,
    DWORD           dwSubAuth,
    DWORD           dwLogonType,
    DWORD           dwLogonProvider,
    HANDLE *        phToken,
    LARGE_INTEGER * pExpiry
    )
/*++

Routine Description:

    Logs a user on via username and domain
    name via the LSA.

Arguments:

    lpszUsername -- user name
    lpszDomain -- domain validating the user name
    lpszPassword -- clear text password, can be empty if a sub-auth DLL
                    is used
    lpszWorkstation -- workstation requesting the login, can be NULL
                       for local workstation
    dwSubAuth -- sub-auth DLL ID
    dwLogonType -- one of LOGON32_LOGON_NETWORK, LOGON32_LOGON_IIS_NETWORK
    dwLogonProvider -- must be LOGON32_PROVIDER_DEFAULT
    phToken -- created access token
    pExpiry -- ptr to pwd expiration time

Returns:

    TRUE if success, FALSE if error

--*/
{
    DBG_ASSERT( pfnLogonNetUserW != NULL );
    return pfnLogonNetUserW(
                    lpszUsername,
                    lpszDomain,
                    lpszPassword,
                    lpszWorkstation,
                    dwSubAuth,
                    dwLogonType,
                    dwLogonProvider,
                    phToken,
                    pExpiry
                    );
} // LogonNetUserW


dllexp
BOOL
WINAPI
LogonNetUserA(
    PSTR            lpszUsername,
    PSTR            lpszDomain,
    PSTR            lpszPassword,
    PSTR            lpszWorkstation,
    DWORD           dwSubAuth,
    DWORD           dwLogonType,
    DWORD           dwLogonProvider,
    HANDLE *        phToken,
    LARGE_INTEGER * pExpiry
    )
/*++

Routine Description:

    Logs a user on via username and domain
    name via the LSA.

Arguments:

    lpszUsername -- user name
    lpszDomain -- domain validating the user name
    lpszPassword -- clear text password, can be empty if a sub-auth DLL
                    is used
    lpszWorkstation -- workstation requesting the login, can be NULL
                       for local workstation
    dwSubAuth -- sub-auth DLL ID
    dwLogonType -- one of LOGON32_LOGON_NETWORK, LOGON32_LOGON_IIS_NETWORK
    dwLogonProvider -- must be LOGON32_PROVIDER_DEFAULT
    phToken -- created access token
    pExpiry -- ptr to pwd expiration time

Returns:

    TRUE if success, FALSE if error

--*/
{
    DBG_ASSERT( pfnLogonNetUserA != NULL );
    return pfnLogonNetUserA(
                    lpszUsername,
                    lpszDomain,
                    lpszPassword,
                    lpszWorkstation,
                    dwSubAuth,
                    dwLogonType,
                    dwLogonProvider,
                    phToken,
                    pExpiry);

} // LogonNetUserA


dllexp
BOOL
WINAPI
NetUserCookieA(
    LPSTR       lpszUsername,
    DWORD       dwSeed,
    LPSTR       lpszCookieBuff,
    DWORD       dwBuffSize
    )
/*++

Routine Description:

    Compute logon validator ( to be used as password )
    for IISSuba

Arguments:

    lpszUsername -- user name
    dwSeed -- start value of cookie

Returns:

    TRUE if success, FALSE if error

--*/
{
    DBG_ASSERT(pfnNetUserCookieA != NULL);
    return pfnNetUserCookieA(
                    lpszUsername,
                    dwSeed,
                    lpszCookieBuff,
                    dwBuffSize
                    );
} // NetUserCookieA


dllexp
BOOL
WINAPI
LogonDigestUserA(
    VOID *                  pDigestBuffer,
    DWORD                   dwAlgo,
    HANDLE *                phToken
    )
/*++

Routine Description:

    Logs a user on via username and domain name via the LSA using Digest authentication.
    AMallet, 5/11/98 - This function is currently only called by the Digest Auth filter.

Arguments:

    pDigestBuffer - Digest parameters
    dwAlgo - Logon type
    phToken -- created access token

Returns:

    TRUE if success, FALSE if error

--*/
{
    PDIGEST_LOGON_INFO pDigestLogonInfo = (PDIGEST_LOGON_INFO) pDigestBuffer;

    static CHAR achDefaultDomain[IIS_DNLEN + 1];
    
    //
    // [See comment above about where this function is called from]
    // The digest filter will do what it can to pass in a non-empty domain [it'll try the
    // domain specified by the user, the metabase-configured domain and the domain the computer
    // is a part of, in that order], but if everything fails, we'll just have to use the
    // "default" domain name, which is usually the name of the machine itself
    //

    if ( !pDigestLogonInfo->pszDomain || 
         pDigestLogonInfo->pszDomain[ 0 ] == '\0' )
    {
        if ( achDefaultDomain[0] == '\0' )
        {
            if ( !pfnGetDefaultDomainName( achDefaultDomain,
                                           sizeof(achDefaultDomain) ) )
            {
                return FALSE;
            }
        }
        pDigestLogonInfo->pszDomain = achDefaultDomain;
    }
    else if ( pDigestLogonInfo->pszDomain[ 0 ] == '\\' )
    {
        pDigestLogonInfo->pszDomain[ 0 ] = '\0';
    }
    
    return pfnLogonDigestUserA( pDigestLogonInfo,
                                dwAlgo,
                                phToken );

} // LogonDigestUserA
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\common\mimeutil.cxx ===
/*++

   Copyright    (c)    1995    Microsoft Corporation

   Module  Name :

      mimeutil.cxx

   Abstract:

      This module defines MIME utility functions: Initialize and Cleanup
        of global MimeMap. Also provides function for obtaining the MimeType
        for given file extension

   Author:

       Murali R. Krishnan    ( MuraliK )     23-Jan-1995

   Environment:

       Win32

   Project:

       TCP Internet services common dll

   Functions Exported:

       BOOL InitializeMimeMap( VOID)
       BOOL CleanupMimeMap( VOID)


   Revision History:

--*/


/************************************************************
 *     Include Headers
 ************************************************************/
# include <tcpdllp.hxx>

# include <tchar.h>
# include "mimemap.hxx"
# include <iistypes.hxx>

# define   PSZ_MIME_MAP       TEXT( "MimeMap")

PMIME_MAP     g_pMimeMap = NULL;


/************************************************************
 *    Functions
 ************************************************************/


BOOL
InitializeMimeMap(
    IN LPCTSTR  pszRegEntry
    )
/*++

  Creates a new mime map object and loads the registry entries from
    under this entry from  \\MimeMap.


--*/
{
    BOOL fReturn = FALSE;

    DBG_ASSERT( g_pMimeMap == NULL);

    g_pMimeMap = new MIME_MAP();

    if ( g_pMimeMap != NULL) {


        DWORD dwError;

        dwError = g_pMimeMap->InitMimeMap( );

        if ( dwError == NO_ERROR ) {
            fReturn = TRUE;
        } else {

            DBGPRINTF((DBG_CONTEXT,"InitMimeMap failed with %d\n",
                dwError));

            SetLastError( dwError);
        }
    }

    IF_DEBUG( MIME_MAP ) {

        DBGPRINTF( ( DBG_CONTEXT, "InitializeMimeMap() from Reg %s. returns %d."
                    " Error = %d\n",
                     PSZ_MIME_MAP, fReturn, GetLastError()));
    }

    return ( fReturn);
} // InitializeMimeMap()


BOOL
CleanupMimeMap( VOID)
{
    BOOL fReturn = TRUE;

    if ( g_pMimeMap != NULL) {

         delete g_pMimeMap;
         g_pMimeMap = NULL;
   }

   return ( fReturn);
} // CleanupMimeMap()




BOOL
SelectMimeMappingForFileExt(
    IN const PIIS_SERVICE pInetSvc,
    IN const TCHAR *       pchFilePath,
    OUT STR *              pstrMimeType,          // optional
    OUT STR *              pstrIconFile)          // optional
/*++
   Locks and obtains the mime type and/or icon file
    for file based on the file extension.

  pTsvcInfo       pointer to service's tsvcinfo object
  pchFilePath     pointer to path for the given file
  pstrMimeType    pointer to string to store the mime type on return
                   ( if ! NULL)
  pstrIconFile    pointer to string to store the icon file name on return
                   ( if ! NULL)

  Returns:
     TRUE on success and
     FALSE if there is any error.

--*/
{
    BOOL  fReturn = TRUE;

    if ( pstrIconFile != NULL || pstrMimeType != NULL) {

        PMIME_MAP  pMm;
        PCMIME_MAP_ENTRY   pMmeMatch;

        DBG_ASSERT( pInetSvc);
        pMm = pInetSvc->QueryMimeMap();

        DBG_ASSERT( pMm != NULL);

        pMmeMatch = pMm->LookupMimeEntryForFileExt( pchFilePath);
        DBG_ASSERT( pMmeMatch != NULL);

        if ( pstrIconFile != NULL) {

            fReturn = fReturn &&
                    pstrIconFile->Copy( pMmeMatch->QueryIconFile());
        }

        if ( pstrMimeType != NULL) {

            fReturn = fReturn &&
                    pstrMimeType->Copy( pMmeMatch->QueryMimeType());
        }
    }

    return ( fReturn);
} // SelectMimeMappingForFileExt()



/************************ End of File ***********************/

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\common\nsistubs.cxx ===
/*++

   Copyright    (c)    1994    Microsoft Corporation

   Module  Name :
        nsistubs.cxx

   Abstract:
        non standard interface stubs

   Author:

        Johnson R Apacible  (johnsona)          15-Nov-1996

--*/


#include <tcpdllp.hxx>
#pragma hdrstop

#include <lonsi.hxx>


dllexp
BOOL
IISDuplicateTokenEx(
    IN  HANDLE hExistingToken,
    IN  DWORD dwDesiredAccess,
    IN  LPSECURITY_ATTRIBUTES lpTokenAttributes,
    IN  SECURITY_IMPERSONATION_LEVEL ImpersonationLevel,
    IN  TOKEN_TYPE TokenType,
    OUT PHANDLE phNewToken
    )
/*++
    Description:

        Stub for DuplicateTokenEx

    Arguments:

        same as DuplicateTokenEx

    Returns:

        ditto
--*/
{

    DBG_ASSERT( pfnDuplicateTokenEx != NULL );

    return(pfnDuplicateTokenEx(
                        hExistingToken,
                        dwDesiredAccess,
                        lpTokenAttributes,
                        ImpersonationLevel,
                        TokenType,
                        phNewToken
                        ) );

} // IISDuplicateTokenEx
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\common\mbsink.cxx ===
/*++

   Copyright    (c)    1996    Microsoft Corporation

   Module  Name :

      mbsink.cxx

   Abstract:

      This module implements the metabase notification support

   Author:

      Johnl         01-Nov-1996

   Project:

      Internet Services Common DLL

   Functions Exported:


   Revision History:

--*/


#include <tcpdllp.hxx>
#include <objbase.h>
#include <initguid.h>
#include <ole2.h>
#include <imd.h>
#include <iistypes.hxx>
#include <issched.hxx>

//
//  Constants
//

//
//  Derived metadata sink object
//

class CImpIMDCOMSINK : public IMDCOMSINK {

public:

    CImpIMDCOMSINK();
    ~CImpIMDCOMSINK();


    HRESULT _stdcall
    QueryInterface(REFIID riid, void **ppObject);

    ULONG _stdcall
    AddRef();

    ULONG _stdcall
    Release();

    HRESULT STDMETHODCALLTYPE ComMDSinkNotify(
        /* [in] */ METADATA_HANDLE hMDHandle,
        /* [in] */ DWORD dwMDNumElements,
        /* [size_is][in] */ MD_CHANGE_OBJECT __RPC_FAR pcoChangeList[  ]);

    HRESULT STDMETHODCALLTYPE ComMDShutdownNotify()
    {
        return RETURNCODETOHRESULT(ERROR_NOT_SUPPORTED);
    }

private:
    ULONG m_dwRefCount;
};


//
//  Globals
//

DWORD               g_dwSinkCookie = 0;
CImpIMDCOMSINK *    g_pEventSink = NULL;
IConnectionPoint *  g_pConnPoint = NULL;



//
//  Functions
//


BOOL
InitializeMetabaseSink(
    IUnknown * pmb
    )
{

    IConnectionPointContainer * pConnPointContainer = NULL;
    HRESULT                     hRes;
    BOOL                        fSinkConnected = FALSE;

    g_pEventSink = new CImpIMDCOMSINK();

    if ( !g_pEventSink )
    {
        return FALSE;
    }

    //
    // First query the object for its Connection Point Container. This
    // essentially asks the object in the server if it is connectable.
    //

    hRes = pmb->QueryInterface( IID_IConnectionPointContainer,
                                (PVOID *)&pConnPointContainer);
    if SUCCEEDED(hRes)
    {
        // Find the requested Connection Point. This AddRef's the
        // returned pointer.

        hRes = pConnPointContainer->FindConnectionPoint( IID_IMDCOMSINK,
                                                         &g_pConnPoint);

        if (SUCCEEDED(hRes))
        {
            hRes = g_pConnPoint->Advise( (IUnknown *)g_pEventSink,
                                          &g_dwSinkCookie);

            if (SUCCEEDED(hRes))
            {
                fSinkConnected = TRUE;
            }
        }

        if ( pConnPointContainer )
        {
            pConnPointContainer->Release();
            pConnPointContainer = NULL;
        }
    }

    if ( !fSinkConnected )
    {
        delete g_pEventSink;
        g_pEventSink = NULL;
    }

    return fSinkConnected;
}



VOID
TerminateMetabaseSink(
    VOID
    )
{
    HRESULT hRes;

    DBGPRINTF(( DBG_CONTEXT,
                "[TerminateMetabaseSink] Cleaning up sinc notification\n" ));

    if ( g_dwSinkCookie )
    {
        hRes = g_pConnPoint->Unadvise( g_dwSinkCookie );
    }

    g_pEventSink = NULL;
}




CImpIMDCOMSINK::CImpIMDCOMSINK()
{
    m_dwRefCount=0;
}

CImpIMDCOMSINK::~CImpIMDCOMSINK()
{
}




HRESULT
CImpIMDCOMSINK::QueryInterface(REFIID riid, void **ppObject) {
    if (riid==IID_IUnknown || riid==IID_IMDCOMSINK) {
        *ppObject = (IMDCOMSINK *) this;
    }
    else {
        return E_NOINTERFACE;
    }
    AddRef();
    return NO_ERROR;
}

ULONG
CImpIMDCOMSINK::AddRef()
{
    DWORD dwRefCount;
    dwRefCount = InterlockedIncrement((long *)&m_dwRefCount);
    return dwRefCount;
}

ULONG
CImpIMDCOMSINK::Release()
{
    DWORD dwRefCount;
    dwRefCount = InterlockedDecrement((long *)&m_dwRefCount);
    if (dwRefCount == 0) {
        delete this;
    }
    return dwRefCount;
}

HRESULT STDMETHODCALLTYPE
CImpIMDCOMSINK::ComMDSinkNotify(
        /* [in] */ METADATA_HANDLE hMDHandle,
        /* [in] */ DWORD dwMDNumElements,
        /* [size_is][in] */ MD_CHANGE_OBJECT __RPC_FAR pcoChangeList[  ])
{
    DWORD i, j;


    IIS_SERVICE::MDChangeNotify( dwMDNumElements,
                                 pcoChangeList );
#if 0
    DBGPRINTF(( DBG_CONTEXT,
                "Recieved callback for handle 0x%08x, NumElements = %d\n",
                hMDHandle,
                dwMDNumElements ));

    for (i = 0; i < dwMDNumElements; i++)
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Change Type = %X, Path = %s, NumIDs = %d\n",
                    pcoChangeList[i].dwMDChangeType,
                    pcoChangeList[i].pszMDPath,
                    pcoChangeList[i].dwMDNumDataIDs ));

        for ( j = 0; j < pcoChangeList[i].dwMDNumDataIDs; j++ )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "\tid[j] = %6d  ",
                        pcoChangeList[i].pdwMDDataIDs[j] ));
        }

        DBGPRINTF(( DBG_CONTEXT,
                    "\n" ));
    }
#endif

    return (0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\common\odbcconn.cxx ===
/*++

   Copyright    (c)    1995    Microsoft Corporation

   Module  Name :

       odbcconn.cxx

   Abstract:

       This module defines member functions for ODBC_CONNECTION object.

   Author:

       Murali R. Krishnan    ( MuraliK )     16-Feb-1995

   Environment:

       User Mode - Win32.

   Project:

       Internet Services Common DLL

   Functions Exported:

       ODBC_PARAMETER::CopyValue( IN LPCWSTR pwszValue);
       ODBC_PARAMETER::Bind( IN HSTMT hstmt);

       ODBC_STATEMENT::~ODBC_STATEMENT()
       ODBC_STATEMENT::PrepareStatement( IN LPCSTR  pszStatement)
       ODBC_STATEMENT::PrepareStatement( IN LPCWSTR pwszStatement)
       ODBC_STATEMENT::BindParameter( IN PODBC_PARAMETER pOdbcParam)
       ODBC_STATEMENT::ExecuteStatement( VOID)
       ODBC_STATEMENT::ExecDirect( IN LPCSTR pwszSqlCommand,  IN DWORD cch)
       ODBC_STATEMENT::ExecDirect( IN LPCWSTR pwszSqlCommand, IN DWORD cch)
       ODBC_STATEMENT::QueryColNames( OUT STR * *  apstrCols,
                                      OUT DWORD *  cCols,
                                      IN  DWORD    cchMaxFieldSize = 0 );
       ODBC_STATEMENT::QueryValuesAsStr( OUT STR * *   apstrValues,
                                         OUT DWORD * * apcbValues,
                                         OUT BOOL *    pfLast );


       ODBC_CONNECTION::~ODBC_CONNECTION();
       ODBC_CONNECTION::Open();
       ODBC_CONNECTION::Close();
       ODBC_CONNECTION::GetLastErrorCode();
       ODBC_CONNECTION::AllocStatement();


   Revision History:

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

# include <tcpdllp.hxx>            // for debugging macros & Unicode functions
# include "odbcconn.hxx"


//
// Since the ODBC does not support UNICODE APIs, we convert unicode to ANSI
//   to call the APIs. This will have to go away once we find some other
//   better way to do manage the same.
//


//
//  Constants for display widths
//

#define MAX_NUM_PRECISION 15

//
//  Constant for all non string and non binary data.  40 is chosen to account
//  for things such as Oracle's numeric types, which can have up to 38 digits
//  of precision
//

#define MAX_NONCHAR_DATA_LEN        40

//
//  If no default maximum field size is specified, then use this value
//  as the maximum
//

#define DEFAULT_MAX_FIELD_SIZE      8192



/************************************************************
 *  Local Functions
 ************************************************************/

static inline VOID
CheckAndPrintErrorMessage( IN ODBC_CONNECTION * poc,
                           IN RETCODE rc)
{

# if DBG
    if ( !ODBC_CONNECTION::Success( rc))  {

        STR str;
        poc->GetLastErrorText( &str, NULL, rc );

        DBGPRINTF( ( DBG_CONTEXT,
                    "ODBC Error Code( %d). Text: %s\n",
                    rc,
                    str.QueryStr() ));
    }
# endif // DBG

    return;

} // CheckAndPrintErrorMessage()


static inline VOID
CheckAndPrintErrorMessage( IN ODBC_STATEMENT * pos,
                           IN RETCODE rc)
{

# if DBG
    if ( !ODBC_CONNECTION::Success( rc))  {

        STR str;
        pos->GetLastErrorText( &str );

        DBGPRINTF( ( DBG_CONTEXT,
                    "ODBC Error Code( %d). Text: %s\n",
                    rc,
                    str.QueryStr() ));
    }
# endif // DBG

    return;

} // CheckAndPrintErrorMessage()


// 
// 64BIT
// Not 64 Bit Compatible
//
// SQLPOINTER is treated here as a 32 bit value. To make this work for
// sundown this needs to be reconciled.
//
# if 0  


static VOID
PrintMultiString( IN char * pszMsg, IN DWORD cbLen, IN char * pmsz)
{

    DBGPRINTF( ( DBG_CONTEXT,
                "Values of %s. %d bytes.\n", pszMsg, cbLen));
    for( char * psz = pmsz; *psz != '\0'; psz += (strlen( psz) + 1)) {

        DBGPRINTF( ( DBG_CONTEXT, "%s\n", psz));
    }

    return;
} // PrintMultiString()



static VOID
AuxOdbcFunctions( IN HENV henv, IN HDBC hdbc)
/*++

  Function useful in walking throug a few additional ODBC functions
    to find out the ODBC setup information.
  Not to be part of the shipped code. Useful for development purposes.
  - MuraliK
--*/
{
    RETCODE rc;

    //
    // Set the trace file to a standard file.
    //
    rc = SQLSetConnectOption( hdbc, SQL_OPT_TRACE, SQL_OPT_TRACE_ON);
    DBG_ASSERT( ODBC_CONNECTION::Success( rc));

    rc = SQLSetConnectOption( hdbc, SQL_OPT_TRACEFILE,
                             (unsigned long )  //64BIT
                             "%systemroot%\\system32\\gophsql.log");
    DBG_ASSERT( ODBC_CONNECTION::Success( rc));

    UCHAR szDriverDesc[ 300];
    UCHAR szDriverAttrib[ 300];
    SWORD cbDD = 300;
    SWORD cbDA = 300;
    SWORD cbDDCur = 0;
    SWORD cbDACur = 0;

    szDriverDesc[0] = szDriverAttrib[0] = '\0';
    rc = SQLDrivers( henv, SQL_FETCH_FIRST,
                    szDriverDesc, cbDD, &cbDDCur,
                    szDriverAttrib, cbDA, &cbDACur);
    DBG_ASSERT( ODBC_CONNECTION::Success( rc));

    DBGPRINTF( ( DBG_CONTEXT,
                " SQLDrivers( %08x) ==> RetCode = %d."
                " Driver Desc. = ( %d bytes) %s. ",
                henv, rc, cbDDCur, szDriverDesc));
    PrintMultiString( " Driver Attributes", cbDACur, (char *) szDriverAttrib);


    szDriverDesc[0] = szDriverAttrib[0] = '\0';
    cbDDCur = cbDACur = 0;
    rc = SQLDataSources( henv, SQL_FETCH_FIRST,
                        szDriverDesc, cbDD, &cbDDCur,
                        szDriverAttrib, cbDA, &cbDACur);
    DBG_ASSERT( ODBC_CONNECTION::Success( rc));

    DBGPRINTF( ( DBG_CONTEXT,
                " SQLDataSources( %08x) ==> RetCode = %d."
                " Data Sources. = ( %d bytes) %s. ",
                henv, rc, cbDDCur, szDriverDesc));
    PrintMultiString( " Data Source Description", cbDACur,
                     (char *) szDriverAttrib);

    return;
} // AuxOdbcFunctions()


# endif // 0



/************************************************************
 *    Member Functions of ODBC_PARAMETER
 ************************************************************/


BOOL
ODBC_PARAMETER::CopyValue( IN LPCWSTR  pwszValue)
/*++
  Description:
    This function copies the given Unicode string as the value into
      current parameter marker to be used for future insertion.

  Arguments:
    pwszValue   pointer to null-terminated string containing Unicode value to
                    be copied into the parameter marker.

  Returns:
    TRUE on success and FALSE if there is any error.

  Note:
    Since ODBC does not support Unicode directly right now, we convert
      string value to be ANSI before copying the value over.
--*/
{
    BOOL fReturn = FALSE;

    CHAR * pszValue = ConvertUnicodeToAnsi( pwszValue, NULL, 0 );

    //
    // If successful then Copy ASCII value to buffer in the parameter block.
    //

    if ( pszValue != NULL) {

        fReturn = this->CopyValue( pszValue);

        TCP_FREE( pszValue);
    }

    return ( fReturn);
} // ODBC_PARAMETER::CopyValue()



BOOL
ODBC_PARAMETER::CopyValue( IN LPSYSTEMTIME lpst)
/*++
  Description:
    This function copies the given system time into the ODBC timestamp
     structure for the current parameter marker to be used for
     future insertion.

  Arguments:
   lpSystemTime   pointer to System Time structure containing current time.

  Returns:
    TRUE on success and FALSE if there is any error.

--*/
{
    TIMESTAMP_STRUCT * ptsOdbc;

    DBG_ASSERT( lpst != NULL);
    DBG_ASSERT( m_CType == SQL_C_TIMESTAMP);
    DBG_ASSERT( m_SqlType == SQL_TIMESTAMP);
    DBG_ASSERT( m_cbValueMax >= sizeof(TIMESTAMP_STRUCT));

    ptsOdbc = (TIMESTAMP_STRUCT * ) m_pValue;

    DBG_ASSERT( m_pValue != NULL);

    //
    // Copy the individual fields over properly
    // The types used in ODBC/Win32 are different
    //  So do a type specific copy of the values.
    //

    ptsOdbc->year   = (SWORD ) lpst->wYear;
    ptsOdbc->month  = (UWORD ) lpst->wMonth;
    ptsOdbc->day    = (UWORD ) lpst->wDay;
    ptsOdbc->hour   = (UWORD ) lpst->wHour;
    ptsOdbc->minute = (UWORD ) lpst->wMinute;
    ptsOdbc->second = (UWORD ) lpst->wSecond;
    ptsOdbc->fraction = (UDWORD ) lpst->wMilliseconds;

    return ( TRUE);
} // ODBC_PARAMETER::CopyValue()





RETCODE
ODBC_PARAMETER::Bind( IN HSTMT hStmt)
/*++
  Description:

    This functions binds the data about the parameter marker 'this'
     ( this object) represents to the statement provided.

  Arguments:
    hStmt        HANDLE for the statement to which this parameter
                  is to be bound.

  Returns:
    RETCODE value returned by SQLBindParamater().
--*/
{
    RETCODE  rc;
    DBG_ASSERT( hStmt != SQL_NULL_HSTMT);

    rc = SQLBindParameter( hStmt,              // statement
                           QueryParamNumber(),
                           QueryParamType(),
                           QueryCType(),
                           QuerySqlType(),
                           QueryPrecision(),
                           QueryScale(),
                           QueryValue(),
                           QueryMaxCbValue(),
                           &(QueryCbValueRef())
                           );

    return ( rc);
} // ODBC_STATEMENT::BindParameter()





# if DBG

VOID
ODBC_PARAMETER::Print( VOID) const
{
    DBGPRINTF( ( DBG_CONTEXT,
                "Printing ODBC_PARAMETER ( %08x).\n"
                " Num=%u; Type=%d; CType=%d; SqlType=%d; Prec=%u; Scale=%d;"
                " CbMax=%d; Cb=%d.\n",
                this,
                QueryParamNumber(),
                QueryParamType(),
                QueryCType(),
                QuerySqlType(),
                QueryPrecision(),
                QueryScale(),
                QueryMaxCbValue(),
                QueryCbValue()));

    switch ( QuerySqlType()) {

      case SQL_INTEGER:
        {
            DWORD  dwValue = *(DWORD *) QueryValue();
            DBGPRINTF( ( DBG_CONTEXT, " Integer Value = %u\n", dwValue));
            break;
        }

      case SQL_CHAR:
        {
            LPCSTR pszValue = (LPCSTR ) QueryValue();
            DBGPRINTF( ( DBG_CONTEXT, " String Value( %08x) = %s\n",
                         pszValue, pszValue));
            break;
        }

      default:
        {
            DBGPRINTF( ( DBG_CONTEXT, " Type=%d. Unknown value at %08x\n",
                        QuerySqlType(), QueryValue()));
            break;
        }

    } // switch

    return;
} // ODBC_PARAMETER::Print()


# endif // DBG



/************************************************************
 * ODBC_STATEMENT  member functions
 ************************************************************/


ODBC_STATEMENT::~ODBC_STATEMENT( VOID)
{
    //
    // Free the statement handle
    //
    if ( m_hStmt != SQL_NULL_HSTMT) {

        m_rc = SQLFreeStmt( m_hStmt, SQL_DROP);
        m_hStmt = SQL_NULL_HSTMT;

        // Ignore the error code here.
        DBG_ASSERT( ODBC_CONNECTION::Success( m_rc));


        IF_DEBUG( ODBC) {

            DBGPRINTF( ( DBG_CONTEXT,
                        "SqlFreeStmt() return code %d.\n",
                        m_rc));

            CheckAndPrintErrorMessage( this, m_rc);
        }
    }

    FreeColumnMemory();

} // ODBC_STATEMENT::~ODBC_STATEMENT()





BOOL
ODBC_STATEMENT::ExecDirect(
    IN LPCSTR pszSqlCommand,
    IN DWORD cchSqlCommand)
{
    BOOL fReturn;

    IF_DEBUG( ODBC) {
        DBGPRINTF( ( DBG_CONTEXT,
                    " Executing the SQL command (%d bytes) %s.\n",
                    cchSqlCommand * sizeof( CHAR),
                    pszSqlCommand));
    }

    //
    //  SQLExecDirect only likes Unsigned chars !
    //
    m_rc = SQLExecDirect( m_hStmt, (UCHAR FAR *) pszSqlCommand, cchSqlCommand);
    fReturn = ODBC_CONNECTION::Success( m_rc);

    IF_DEBUG( ODBC) {

        DBGPRINTF( ( DBG_CONTEXT,
                    " SQLExecDirect() returns code %d\n",
                    m_rc));
        CheckAndPrintErrorMessage( this, m_rc);
    }

    return ( fReturn);
} // ODBC_STATEMENT::ExecDirect()



BOOL
ODBC_STATEMENT::ExecDirect(
    IN LPCWSTR pszSqlCommand,
    IN DWORD cchSqlCommand)
{
    BOOL fReturn = FALSE;
    char * pszCommand;

    if ( ( pszCommand = ConvertUnicodeToAnsi( pszSqlCommand, NULL, 0))
        != NULL ) {

        fReturn = ExecDirect( pszCommand, strlen( pszCommand));

        TCP_FREE( pszCommand);
    }

    return ( fReturn);
} // ODBC_STATEMENT::ExecDirect()






BOOL
ODBC_STATEMENT::PrepareStatement(IN LPCSTR    pszStatement)
/*++

  This function prepares the SQL statement for future execution.

  Arguments:
     pszStatement    pointer to null terminated string containing the
                        statement.

  Returns:
     TRUE on success and FALSE if there is any failure.
--*/
{
    BOOL fReturn;

    DBG_ASSERT( QueryErrorCode() == SQL_SUCCESS && pszStatement != NULL);

    m_rc = SQLPrepare( m_hStmt, (UCHAR FAR *) pszStatement, SQL_NTS);

    IF_DEBUG( ODBC) {

        DBGPRINTF( ( DBG_CONTEXT,
                    " SQLPrepare( %s) returns ErrorCode = %d.\n",
                     pszStatement, m_rc));

        CheckAndPrintErrorMessage( this, m_rc);
    }

    return ( m_fPreparedStmt = ODBC_CONNECTION::Success( m_rc));
} // ODBC_STATEMENT::PrepareStatment()




BOOL
ODBC_STATEMENT::PrepareStatement( IN LPCWSTR   pwszCommand)
/*++
  This function prepares an ODBC statement for execution.
  Since ODBC does not support UNICODE, we convert the statement into ANSI
   before calling the APIs.

  Arguments:
     pwszCommand      pointer to null-terminated string containing the
                       statement to be prepared.

  Returns:
     TRUE on success and FALSE if there is any failure.
--*/
{
    BOOL fReturn = FALSE;
    CHAR * pszCommand = NULL;

    DBG_ASSERT( pwszCommand != NULL);

    pszCommand = ConvertUnicodeToAnsi( pwszCommand, NULL, 0);

    if ( pszCommand != NULL) {

        fReturn = PrepareStatement( pszCommand);

        TCP_FREE( pszCommand);

    } // pszCommand != NULL

    return ( fReturn);
} // ODBC_STATEMENT::PrepareStatement()





BOOL
ODBC_STATEMENT::BindParameter( IN PODBC_PARAMETER pOdbcParameter)
{

    DBG_ASSERT( ODBC_CONNECTION::Success( m_rc) && pOdbcParameter != NULL);

    m_rc = pOdbcParameter->Bind( m_hStmt);

    IF_DEBUG( ODBC) {

        CheckAndPrintErrorMessage( this, m_rc);
    }

    return ( ODBC_CONNECTION::Success( m_rc));
} // ODBC_STATEMENT::BindParameter()





BOOL
ODBC_STATEMENT::ExecuteStatement( VOID)
/*++

  This function executes a prepared ODBC statement. At the end of execution,
   the transaction is also committed to ensure that the record is automatically
   written to the database.

  Arguments:
    None

  Returns:
    TRUE on success and FALSE if there is any failure.

--*/
{
    DBG_ASSERT( m_fPreparedStmt != FALSE);

    if ( !ODBC_CONNECTION::Success( QueryErrorCode()) ) {

        DBGPRINTF(( DBG_CONTEXT,
                    "!!WARNING!! - Attempting to use Invalid ODBC Connection!\n" ));
    }

    m_rc = SQLExecute( m_hStmt);

    IF_DEBUG( ODBC) {

        CheckAndPrintErrorMessage( this, m_rc);
    }

    return ( ODBC_CONNECTION::Success( m_rc));
} // ODBC_STATEMENT::ExecuteStatement()

BOOL
ODBC_STATEMENT::QueryRowCount(
    OUT SQLLEN *pcRows
    )
/*++

  Calls SQLRowCount on the current result set.

  NOTE: Not all database implementations support this!!

  Arguments:

    pcRows - Receives count of rows

  Returns:
    TRUE on success and FALSE if there are any failures.

  Note:

--*/
{
    m_rc = SQLRowCount( m_hStmt,
                        pcRows );

    return ( ODBC_CONNECTION::Success( m_rc));
}


BOOL
ODBC_STATEMENT::QueryColNames(
    STR * *  pastrCols,
    DWORD  * cCols,
    DWORD    cchMaxFieldSize,
    BOOL *   pfHaveResultSet
    )
/*++

  This method returns the list of column names from the result table

  Arguments:

    pastrCols - Receives an array of STRs containing the column names
    cCols - Count of columns returned (zero for no result set)
    cchMaxFieldSize - Maximum buffer size to allocate for any data fields,
        zero means use the default value.
    pfHaveResultSet - Set to TRUE if the current query was a SELECT and thus has
        rows that can be enumerated

  Returns:
    TRUE on success and FALSE if there are any failures.

  Note:

--*/
{
    SWORD   nresultcols;
    SWORD   i;
    CHAR    achColName[64];
    SWORD   cchColName;
    SWORD   ColType;
    SQLULEN cchColLength;
    SWORD   scale;
    SWORD   nullable;

    *pastrCols       = NULL;
    *cCols           = 0;
    *pfHaveResultSet = TRUE;

    //
    //  Return the old binding info if we already have it
    //

    if ( m_astrColNames )
    {
        *pastrCols = m_astrColNames;
        *cCols = m_cCols;

        return TRUE;
    }

    //
    //  Provide a default maximum field size if none was specified
    //

    if ( !cchMaxFieldSize )
        cchMaxFieldSize = DEFAULT_MAX_FIELD_SIZE;

    //
    //  See what kind of statement it was.  If there are no result
    //  columns, the statement is not a SELECT statement.
    //

    m_rc = SQLNumResultCols( m_hStmt,
                             &nresultcols);

    if ( !ODBC_CONNECTION::Success( m_rc ))
        return FALSE;

    if ( nresultcols > 0 )
    {
        //
        //  Allocate an array of strings for the column names and the column
        //  values
        //

        m_cCols = nresultcols;
        *cCols  = m_cCols;

        m_astrColNames = new STR[m_cCols];
        m_astrValues   = new STR[m_cCols];
        m_acbValue     = new SQLLEN[m_cCols];

        //
        //  Otherwise, get the column names of the result set and use the
        //  display_size() function to compute the length needed by each data
        //  type.  Next, bind the columns and specify all data will be
        //  converted to char.
        //

        for (i = 0; i < m_cCols; i++)
        {
            m_rc = SQLDescribeCol( m_hStmt,
                                   i + 1,
                                   (UCHAR *) achColName,
                                   (SWORD)sizeof(achColName),
                                   &cchColName,
                                   &ColType,
                                   &cchColLength,
                                   &scale,
                                   &nullable);

            if ( !ODBC_CONNECTION::Success( m_rc ))
                return FALSE;

            //
            //  Select the buffer size for the retrieved data for this column
            //

            cchColLength = ODBC_CONNECTION::DisplaySize( ColType,
                                  (DWORD)min( cchColLength, cchMaxFieldSize) );

            //
            //  Copy the column name and set the column data size
            //

            if ( !m_astrColNames[i].Copy( achColName ) ||
                 !m_astrValues[i].Resize( (DWORD)cchColLength + 1 ))
            {
                return FALSE;
            }

            m_rc = SQLBindCol( m_hStmt,
                               i + 1,
                               SQL_C_CHAR,
                               m_astrValues[i].QueryPtr(),
                               cchColLength,
                               &m_acbValue[i] );

            if ( !ODBC_CONNECTION::Success( m_rc ))
                return FALSE;
        }

        *pastrCols = m_astrColNames;
        *cCols     = m_cCols;
    }
    else
    {
        *pfHaveResultSet = FALSE;
    }

    return TRUE;
}


BOOL
ODBC_STATEMENT::QueryValuesAsStr(
    STR * *       pastrValues,
    OUT DWORD * * pacbValues,
    BOOL *  pfLast
    )
/*++

  This method gets the data at the current position.

  Arguments:

    pastrValues - Receives a pointer to an array of strings that contains
        the alphanumeric representation of that field
    pacbValues - Receives pointer to array of DWORDs that contain the length
        of the field
    pfLast - Set to TRUE if there are no more values to retrieve

  Returns:

    TRUE on success and FALSE if there are any failures.

  Note:

--*/
{
    *pastrValues = NULL;

    //
    //  Build the bindings if we haven't already
    //

    if ( !m_astrColNames )
    {
        STR * astrCols;
        DWORD cCols;
        BOOL  fHaveResultSet;

        if ( !QueryColNames( &astrCols,
                             &cCols,
                             0,
                             &fHaveResultSet ))
        {
            return FALSE;
        }
    }

    //
    //  If there are columns to enumerate, get them now
    //

    if ( m_astrColNames )
    {
        DWORD i;

        //
        //  Zero terminate the columns as some drivers don't write anything
        //  for NULL fields
        //

        for ( i = 0; i < m_cCols; i++ )
        {
            *((CHAR *) m_astrValues[i].QueryPtr()) = '\0';
            m_acbValue[i] = 0;
        }

        //
        //  Fill in the binding values
        //

        m_rc = SQLFetch( m_hStmt );

        if ( m_rc == SQL_NO_DATA_FOUND )
        {
            *pfLast = TRUE;
        }
        else
        {
            if ( !ODBC_CONNECTION::Success( m_rc ))
                return FALSE;

            *pfLast = FALSE;
        }

        *pastrValues = m_astrValues;
        *pacbValues  = (DWORD *) m_acbValue;
    }
    else
    {
        *pfLast = TRUE;
    }

    return TRUE;
}

BOOL
ODBC_STATEMENT::MoreResults(
    BOOL * pfMoreResults
    )
/*++

    Determines if there are any more results sets to return to the user

    pfMoreResults - Set to TRUE if there are more results in the result set

--*/
{
    *pfMoreResults = TRUE;

    m_rc = SQLMoreResults( m_hStmt );

    if ( m_rc == SQL_NO_DATA_FOUND )
    {
        *pfMoreResults = FALSE;
        return TRUE;
    }

    if ( !ODBC_CONNECTION::Success( m_rc ))
        return FALSE;

    return TRUE;
}


VOID
ODBC_STATEMENT::FreeColumnMemory(
    VOID
    )
/*++
    This method frees memory allocated by the QueryColNames and
    QueryValuesAsStr methods.

--*/
{
    if ( m_astrColNames ) delete [] m_astrColNames;
    if ( m_astrValues )   delete [] m_astrValues;
    if ( m_acbValue )     delete [] m_acbValue;

    m_astrColNames = NULL;
    m_astrValues = NULL;
    m_acbValue = NULL;

}

# if DBG


VOID
ODBC_STATEMENT::Print( VOID) const
{
    DBGPRINTF( ( DBG_CONTEXT,
                " Printing ODBC_STATEMENT( %08x)."
                " HStmt = %08x. OdbcConn=%08x. RetCode = %d\n",
                m_hStmt, m_pOdbcConnection, m_rc));

} // ODBC_STATEMENT::Print()

# endif // DBG


/**************************************************
 *  Member Functions of class ODBC_CONNECTION
 **************************************************/


ODBC_CONNECTION::~ODBC_CONNECTION( VOID)
/*++
   This function closes the odbc connection ( if open) and cleans up.

--*/
{
    DBG_REQUIRE( Close());
    return;
} // ODBC_CONNECTION::~ODBC_CONNECTION()





BOOL
ODBC_CONNECTION::Open(
    IN LPCSTR   pszDataSource,
    IN LPCSTR   pszUserName,
    IN LPCSTR   pszPassword)
/*++
  This function opens a new odbc connection to given data source
    using the user name and password supplied.

  Arguments:
    pszDataSource    pointer to null-terminated string containing ODBC
                         data source name
    pszUserName      pointer to null-terminated string containing UserName
    pszPassword      pointer to null-terminated string containing Password

  Returns:

    TRUE on success and FALSE if there is an error.
--*/
{
    BOOL fReturn = FALSE;

    DBG_ASSERT( pszDataSource != NULL &&
                pszUserName != NULL &&
                pszPassword != NULL);

    //
    //  Allocate an ODBC environment
    //

    m_rc = SQLAllocEnv( &m_henv);
    fReturn = Success( m_rc);

    IF_DEBUG( ODBC) {

        DBGPRINTF( ( DBG_CONTEXT,
                    "SQLAllocEnv() returned ErrorCode %d. henv = %08x\n",
                    m_rc, m_henv));

        CheckAndPrintErrorMessage( this, m_rc);
    }

    if ( fReturn) {

        //
        // Establish memory for connection handle within the environment
        //

        m_rc = SQLAllocConnect( m_henv, &m_hdbc);
        fReturn = Success( m_rc);

        IF_DEBUG( ODBC) {

            DBGPRINTF( ( DBG_CONTEXT,
                        "SQLAllocConnect() returns code %d. hdbc = %08x\n",
                        m_rc, m_hdbc));

            CheckAndPrintErrorMessage( this, m_rc);
        }
    }

    if ( fReturn) {

        //
        // Use Following call to just printout the dynamic values for ODBC
        //
        // AuxOdbcFunctions( m_henv, m_hdbc);

#if 0
        {
            STR str;
            STR strOut;
            SWORD swStrOut;

            if ( !str.Append( pszDataSource )   ||
                 !str.Append( ";UID=" )         ||
                 !str.Append( pszUserName )     ||
                 !str.Append( ";PWD=" )         ||
                 !str.Append( pszPassword )     ||
                 !str.Append( ";APP=Internet Services") ||
                 !strOut.Resize( 255 ))
            {
                return FALSE;
            }

            m_rc = SQLDriverConnect( m_hdbc,
                                     NULL,
                                     (UCHAR *) str.QueryStr(),
                                     SQL_NTS,
                                     (UCHAR *) strOut.QueryStr(),
                                     strOut.QuerySize(),
                                     &swStrOut,
                                     SQL_DRIVER_NOPROMPT );
        }
#else
        {
            m_rc = SQLConnect( m_hdbc,
                               (UCHAR FAR *) pszDataSource, SQL_NTS,
                               (UCHAR FAR *) pszUserName,   SQL_NTS,
                               (UCHAR FAR *) pszPassword,   SQL_NTS);
        }
#endif

        fReturn = Success( m_rc);

        IF_DEBUG( ODBC) {

            DBGPRINTF( ( DBG_CONTEXT,
                        "SQLConnect( %s, %s, %s) returns code %d.\n",
                        pszDataSource,
                        pszUserName,
                        pszPassword,
                        m_rc));

            CheckAndPrintErrorMessage( this, m_rc);
        }
    }

    m_fValid = fReturn;

    if ( !fReturn) {
        SetLastError( ERROR_GEN_FAILURE );
    }

    return ( fReturn);
} // ODBC_CONNECTION::Open()





BOOL
ODBC_CONNECTION::Open(
    IN LPCWSTR  pwszDataSource,
    IN LPCWSTR  pwszUserName,
    IN LPCWSTR  pwszPassword)
/*++
  This function opens a new odbc connection to given data source
    using the user name and password supplied.

  Arguments:
    pwszDataSource    pointer to null-terminated string containing ODBC
                         data source name
    pwszUserName      pointer to null-terminated string containing UserName
    pwszPassword      pointer to null-terminated string containing Password

  Returns:
    TRUE on success and FALSE if there is an error.

  Note:
     Poor me.  ODBC Does not take UNICODE strings :(. 2/15/95
     So we will explicitly convert parameters to ANSI on stack.
--*/
{
    BOOL   fReturn;
    DWORD  dwError = NO_ERROR;
    CHAR * pszDataSource;
    CHAR * pszUserName;
    CHAR * pszPassword;

    //
    // Convert all parameters from UNICODE to ANSI
    //
    pszDataSource = ConvertUnicodeToAnsi( pwszDataSource, NULL, 0);
    pszUserName   = ConvertUnicodeToAnsi( pwszUserName, NULL, 0);
    pszPassword   = ConvertUnicodeToAnsi( pwszPassword, NULL, 0);

    //
    // Make an ANSI open call.
    //
    fReturn = Open( pszDataSource, pszUserName, pszPassword);

    if ( !fReturn)  {

        dwError = GetLastError();
    }

    //
    //  Freeup the space allocated.
    //
    if ( pszDataSource != NULL) {

        TCP_FREE( pszDataSource);
        pszDataSource = NULL;
    }

    if ( pszUserName != NULL) {

        TCP_FREE( pszUserName);
        pszUserName = NULL;
    }

    if ( pszPassword != NULL) {

        //
        // Zero the password for security reasons.
        //
        memset( pszPassword, 0, strlen( pszPassword));

        TCP_FREE( pszPassword);
        pszPassword = NULL;
    }

    if ( !fReturn) {

        SetLastError( dwError);
    }

    return ( fReturn);
} // ODBC_CONNECTION::Open()




BOOL
ODBC_CONNECTION::Close( VOID)
/*++
  This function closes the connection established with the ODBC
   and frees up and dynamic memory used.

  Returns:
    TRUE on success and FALSE if there are any failures.

  Note:
    Intermediate failures are ignored. Normally they should not occur.

--*/
{
    BOOL fReturn = TRUE;


    //
    // Disconnect and free the connection.
    //
    if ( m_hdbc != SQL_NULL_HDBC) {

        m_rc = SQLDisconnect( m_hdbc );

        //
        //  Disconnect is allowed to fail w/o being fatal so don't set
        //  fReturn
        //

        IF_DEBUG( ODBC) {

            DBGPRINTF( ( DBG_CONTEXT,
                        "Warning: SQLDisconnect() returns code %d.\n",
                        m_rc));
            CheckAndPrintErrorMessage( this, m_rc);
        }

        m_rc = SQLFreeConnect( m_hdbc);

        m_hdbc = SQL_NULL_HDBC;
        fReturn = fReturn && Success( m_rc);

        IF_DEBUG( ODBC) {

            DBGPRINTF( ( DBG_CONTEXT,
                        "SQLFreeConnect() returns code %d.\n",
                        m_rc));

            CheckAndPrintErrorMessage( this, m_rc);
        }
    }

    //
    //  Free the ODBC environment handle.
    //
    if ( m_henv != SQL_NULL_HENV) {

        m_rc = SQLFreeEnv( m_henv);
        m_henv = SQL_NULL_HENV;
        fReturn = fReturn && Success( m_rc);

        IF_DEBUG( ODBC) {

            DBGPRINTF( ( DBG_CONTEXT,
                        "SQLFreeEnv() returns code %d.\n",
                        m_rc));

            CheckAndPrintErrorMessage( this, m_rc);
        }
    }

    return ( fReturn);
} // ODBC_CONNECTION::Close()





PODBC_STATEMENT
ODBC_CONNECTION::AllocStatement( VOID)
/*++
  Description:
    This function allocates a new ODBC statement object and also calls
     SQLAllocStatement to create the state required for establishing the
     statement in the ODBC Manager.

  Arguments:
    None

  Returns:
    TRUE on success and FALSE if there is any failure.
--*/
{
    PODBC_STATEMENT pOdbcStmt = NULL;
    HSTMT   hstmt = SQL_NULL_HSTMT;

    DBG_ASSERT( Success( m_rc));

    //
    // Allocate a statement handle and associate it with the connection.
    //
    m_rc = SQLAllocStmt( m_hdbc, &hstmt);

    IF_DEBUG( ODBC) {

        DBGPRINTF( ( DBG_CONTEXT,
                    "SqlAllocStmt() returns code %d."
                    " New Hstmt is : %08x\n",
                    m_rc, hstmt));
        CheckAndPrintErrorMessage( this, m_rc);
    }

    if ( ODBC_CONNECTION::Success( m_rc)) {

        pOdbcStmt = new ODBC_STATEMENT( this, hstmt);
    }

    return ( pOdbcStmt);
} // ODBC_CONNECTION::AllocStatement()


BOOL
ODBC_CONNECTION::SetConnectOption(
    IN UWORD        Option, 
    IN SQLUINTEGER  Param
    )
/*++

  Sets various options on this connection

  Arguments:

    Option - Option to set
    Param - Option value (32 bit dword or pointer to null terminated string)

  Returns:
    TRUE on success and FALSE if there are any failures.  Failures are
    considered to be soft errors as the problem may be the driver doesn't
    support the option etc.

  Note:

--*/
{
    BOOL    fReturn = TRUE;
    RETCODE rc;

    if ( m_hdbc != SQL_NULL_HDBC)
    {
        rc = SQLSetConnectOption( m_hdbc, Option, Param);

        fReturn = Success( rc);

        IF_DEBUG( ODBC) {

            DBGPRINTF( ( DBG_CONTEXT,
                        "SQLSetConnectOption( %d, %d ) returns code %d.\n",
                        Option,
                        Param,
                        rc));

            CheckAndPrintErrorMessage( this, rc);
        }
    }
    else
    {
        DBGPRINTF( ( DBG_CONTEXT,
                     "[SetConnectOption] Warning: Setting option on closed connection\n" ));
    }

    return fReturn;
}



BOOL
ODBC_CONNECTION::GetLastErrorText(
    OUT STR *    pstrError,
    IN  HSTMT    hstmt,
    IN  RETCODE  rc
    ) const
/*++

  This method returns the textual representation of the last ODBC or windows
  error that occurred.  Even though the ODBC methods return FALSE on failure,
  if it was an ODBC call that failed, then GetLastError won't return the
  needed error code.  Clients of this class should call this method to get
  a descriptive text string of the failure.

  Returns:

    TRUE on success and FALSE if there are any failures.

  Note:
    If this function returns FALSE, then a client should call GetLastError
    for the error code.

--*/
{
    BOOL fReturn = TRUE;

    if ( ODBC_CONNECTION::Success( rc)) {

        fReturn = pstrError->LoadString( GetLastError());

    } else {

        CHAR     rgchMsg[ SQL_MAX_MESSAGE_LENGTH + 10];
        CHAR     achState[30];
        CHAR     rgchFullMsg[ sizeof(rgchMsg) + sizeof(achState) + 60];
        SWORD    cbMsg;
        LONG     lError;
        DWORD    dwError;

        //
        //  If we're formatting as HTML, we bullet list the items
        //

        pstrError->Reset();

        //
        //  Loop to pick up all of the errors
        //

        do {
            cbMsg = SQL_MAX_MESSAGE_LENGTH;

            rc = SQLError( m_henv,
                           m_hdbc,
                           hstmt,
                           (UCHAR *) achState,
                           &lError,
                           (UCHAR *) rgchMsg,
                           cbMsg,
                           &cbMsg );

            if ( ODBC_CONNECTION::Success( rc)) {

                wsprintf( rgchFullMsg,
                             "[State=%s][Error=%d]%s\n",
                             achState, lError, rgchMsg);

                if ( !pstrError->Append( rgchFullMsg )) {

                    fReturn = FALSE;
                    break;
                }
            } else {

                //
                //  This is indicates there are no more error strings
                //  to pick up so we should get out
                //

                if ( rc == SQL_NO_DATA_FOUND ) {

                    //
                    //  Append the end of unorder list marker
                    //

                    rc = SQL_SUCCESS;
                    break;
                }
            }

        } while ( ODBC_CONNECTION::Success( rc) );

        if ( !ODBC_CONNECTION::Success( rc) )
        {
            DBGPRINTF( ( DBG_CONTEXT,
                        "[GetLastErrorText] SqlError() returned error %d.\n",
                        rc));

            SetLastError( ERROR_GEN_FAILURE );
            fReturn = FALSE;
        }
    }

    return ( fReturn);

} // ODBC_CONNECTION::GetLastErrorText()



BOOL
ODBC_CONNECTION::GetLastErrorTextAsHtml(
    OUT STR *    pstrError,
    IN  HSTMT    hstmt,
    IN  RETCODE  rc
    ) const
/*++

  This method returns the textual representation of the last ODBC or windows
  error that occurred.  Even though the ODBC methods return FALSE on failure,
  if it was an ODBC call that failed, then GetLastError won't return the
  needed error code.  Clients of this class should call this method to get
  a descriptive text string of the failure.

  Returns:

    TRUE on success and FALSE if there are any failures.

  Note:
    If this function returns FALSE, then a client should call GetLastError
    for the error code.

--*/
{
    BOOL fReturn = TRUE;

    if ( ODBC_CONNECTION::Success( rc)) {

        fReturn = pstrError->LoadString( GetLastError());

    } else {

        CHAR     rgchMsg[ SQL_MAX_MESSAGE_LENGTH + 10];
        CHAR     achState[30];
        CHAR     rgchFullMsg[ sizeof(rgchMsg) + sizeof(achState) + 60];
        SWORD    cbMsg;
        LONG     lError;
        DWORD    dwError;

        //
        //  If we're formatting as HTML, we bullet list the items
        //

        if ( !pstrError->Copy( "<UL>" ))
        {
            return FALSE;
        }

        //
        //  Loop to pick up all of the errors
        //

        do {
            cbMsg = SQL_MAX_MESSAGE_LENGTH;

            rc = SQLError( m_henv,
                           m_hdbc,
                           hstmt,
                           (UCHAR *) achState,
                           &lError,
                           (UCHAR *) rgchMsg,
                           cbMsg,
                           &cbMsg );

            if ( ODBC_CONNECTION::Success( rc)) {

                wsprintf( rgchFullMsg,
                          "<LI>[State=%s][Error=%d]%s\n",
                          achState, lError, rgchMsg);

                if ( !pstrError->Append( rgchFullMsg )) {

                    fReturn = FALSE;
                    break;
                }
            } else {

                //
                //  This is indicates there are no more error strings
                //  to pick up so we should get out
                //

                if ( rc == SQL_NO_DATA_FOUND ) {

                    //
                    //  Append the end of unorder list marker
                    //

                    if ( !pstrError->Append( "</UL>" )) {
                        return FALSE;
                    }

                    rc = SQL_SUCCESS;
                    break;
                }
            }

        } while ( ODBC_CONNECTION::Success( rc) );

        if ( !ODBC_CONNECTION::Success( rc) )
        {
            DBGPRINTF( ( DBG_CONTEXT,
                        "[GetLastErrorText] SqlError() returned error %d.\n",
                        rc));

            SetLastError( ERROR_GEN_FAILURE );
            fReturn = FALSE;
        }
    }

    return ( fReturn);

} // ODBC_CONNECTION::GetLastErrorTextAsHtml()



BOOL
ODBC_CONNECTION::GetInfo(IN DWORD fInfoType,
                         IN PVOID rgbInfoValue,
                         IN DWORD cbInfoValueMax,
                         IN OUT DWORD * pcbInfoValue)
/*++
  This function obtains the value of the fInfoType for a specific
   ODBC Connection. It mimicks the SQLGetInfo() and uses it to obtain
   this value. On successful return the pointer rgbInfoValue contains
   the requested value and pcbInfoValue contains the size in bytes of
   data.

  Arguments:
    fInfoType - flag containing the Information Type (name) to be fetched.
    rgbInfoValue - pointer to buffer which will contain the return data.
    cbInfoValue  - size of rgbInfoValue in bytes.
    pcbInfoValue - pointer to location that will contain the size of
                    information stored in rgbInfoValue, on successful return.
                   If buffer is insufficient, this location will contain the
                    required number of bytes.

  Returns:
    TRUE on success and FALSE if there is any failure.

--*/
{
    BOOL fReturn = FALSE;

    if ( m_hdbc != SQL_NULL_HDBC) {

        RETCODE rc;

        rc = SQLGetInfo( m_hdbc, (UWORD ) fInfoType,
                         (PTR)   rgbInfoValue,
                         (SWORD) cbInfoValueMax,
                         (SWORD FAR *) pcbInfoValue);

        fReturn = Success( rc);

        IF_DEBUG( ODBC) {

            DBGPRINTF( ( DBG_CONTEXT,
                        "SQLGetInfo( %08x, %d, %08x, %d, %08x) returns %d.\n",
                        m_hdbc, fInfoType, rgbInfoValue, cbInfoValueMax,
                        pcbInfoValue, rc));

            CheckAndPrintErrorMessage( this, rc);
        }
    } else {

        DBGPRINTF( ( DBG_CONTEXT,
                    "[SQLGetInfo] Invalid Connection to ODBC\n"));
    }

    return (fReturn);
} // ODBC_CONNECTION::GetInfo()



DWORD
ODBC_CONNECTION::DisplaySize(
    SWORD coltype,
    DWORD collen
    )
{
    DWORD cbSize = MAX_NONCHAR_DATA_LEN;

    //
    //  Note that we always set the size to at least four bytes.  This prevents
    //  any possible problems if the column to be bound is NULLable, which can
    //  cause a NULL to be written for the data during a fetch
    //

    switch (coltype)
    {
      case SQL_CHAR:
      case SQL_VARCHAR:
      case SQL_LONGVARCHAR:
      case SQL_BINARY:
      case SQL_VARBINARY:
      case SQL_LONGVARBINARY:
        cbSize = max(collen + sizeof(CHAR), sizeof(PVOID));
        break;

      default:
        break;
    }

    return ( cbSize);
} // ODBC_CONNECTION::DisplaySize()




# if DBG
VOID
ODBC_CONNECTION::Print( VOID) const
{
    DBGPRINTF( ( DBG_CONTEXT,
                "Printing ODBC_CONNECTION ( %08x). fValid = %d\n"
                " HENV = %08x. HDBC = %08x. ReturnCode =%d\n",
                this, m_fValid,
                m_henv, m_hdbc, m_rc));
    return;
} // ODBC_CONNECTION::Print()


# endif // DBG

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\common\parse.cxx ===
/*++

   Copyright    (c)    1995    Microsoft Corporation

   Module  Name :

        parse.hxx

   Abstract:

        Simple parser class for extrapolating HTTP headers information

   Author:
           John Ludeman     (JohnL)    18-Jan-1995

   Project:
           HTTP server

   Revision History:

--*/

#include <tcpdllp.hxx>
# include <parse.hxx>


INET_PARSER::INET_PARSER(
    CHAR * pszStart
    )
/*++

Routine Description:

    Sets the initial position of the buffer for parsing

Arguments:

    pszStart - start of character buffer
    pszEnd - End of buffer

Return Value:

--*/
    : m_fListMode   ( FALSE ),
      m_pszPos      ( pszStart ),
      m_pszTokenTerm( NULL ),
      m_pszLineTerm ( NULL )
{
    DBG_ASSERT( pszStart );

    //
    //  Chew up any initial white space at the beginning of the buffer
    //  and terminate the first token in the string.
    //

    EatWhite();

    TerminateToken();
}


INET_PARSER::~INET_PARSER(
    VOID
    )
/*++

Routine Description:

    Restores any changes we made to the string while parsing

Arguments:

--*/
{
    RestoreBuffer();
}


CHAR *
INET_PARSER::QueryPos(
    VOID
    )
/*++

Routine Description:

    Removes the terminators and returns the current parser position

Arguments:

Return Value:

    Zero terminated string if we've reached the end of the buffer

--*/
{
    RestoreToken();
    RestoreLine();

    return m_pszPos;
}

VOID
INET_PARSER::SetPtr(
    CHAR * pch
    )
/*++

Routine Description:

    Sets the parser to point at a new location

Arguments:

    pch - New position for parser to start parsing from

Return Value:

--*/
{
    RestoreToken();
    RestoreLine();

    m_pszPos = pch;
}


CHAR *
INET_PARSER::QueryToken(
    VOID
    )
/*++

Routine Description:

    Returns a pointer to the current zero terminated token

    If list mode is on, then a comma is considered a delimiter.

Arguments:

Return Value:

    Zero terminated string if we've reached the end of the buffer

--*/
{
    if ( !m_pszTokenTerm )
        TerminateToken( m_fListMode ? ',' : '\0' );

    return m_pszPos;
}


CHAR *
INET_PARSER::QueryLine(
    VOID
    )
/*++

Routine Description:

    Returns a pointer to the current zero terminated line

Arguments:

Return Value:

    Zero terminated string if we've reached the end of the buffer

--*/
{
    RestoreToken();

    if ( !m_pszLineTerm )
        TerminateLine();

    return m_pszPos;
}


BOOL
INET_PARSER::CopyToken(
    STR * pStr,
    BOOL  fAdvanceToken
    )
/*++

Routine Description:

    Copies the token at the current position to *pStr

Arguments:

    pStr - Receives token
    fAdvanceToken - True if we should advance to the next token

Return Value:

    TRUE if successful, FALSE otherwise

--*/
{
    BOOL fRet;

    DBG_ASSERT( pStr );

    if ( !m_pszTokenTerm )
        TerminateToken();

    fRet = pStr->Copy( m_pszPos );

    if ( fAdvanceToken )
        NextToken();

    return fRet;
}


BOOL
INET_PARSER::CopyToEOL(
    STR   * pstr,
    BOOL    fAdvance
    )
/*++

Routine Description:

    Copies the token at the current character position

Arguments:

--*/
{
    BOOL fRet;

    RestoreToken();

    if ( !m_pszLineTerm )
        TerminateLine();

    fRet = pstr->Copy( m_pszPos );

    if ( fAdvance )
        NextLine();

    return fRet;
}

BOOL
INET_PARSER::AppendToEOL(
    STR   * pstr,
    BOOL    fAdvance
    )
/*++

Routine Description:

    Same as CopyToEOL except the text from the current line is appended to
    pstr

Arguments:

--*/
{
    BOOL fRet;

    RestoreToken();

    if ( !m_pszLineTerm )
        TerminateLine();

    fRet = pstr->Append( m_pszPos );

    if ( fAdvance )
        NextLine();

    return fRet;
}


CHAR *
INET_PARSER::NextLine(
    VOID
    )
/*++

Routine Description:

    Sets the current position to the first non-white character after the
    next '\n' (or terminating '\0').

--*/
{
    RestoreToken();
    RestoreLine();

    m_pszPos = AuxSkipTo( '\n' );

    if ( *m_pszPos )
        m_pszPos++;

    return EatWhite();
}

CHAR *
INET_PARSER::NextToken(
    VOID
    )
/*++

Routine Description:

    Sets the current position to the next non-white character after the
    current token

--*/
{
    //
    //  Make sure the line is terminated so a '\0' will be returned after
    //  the last token is found on this line
    //

    RestoreToken();

    if ( !m_pszLineTerm )
        TerminateLine();

    //
    //  Skip the current token
    //

    EatNonWhite();

    EatWhite();

    TerminateToken();

    return m_pszPos;
}


CHAR *
INET_PARSER::NextToken(
    CHAR ch
    )
/*++

Routine Description:

    Advances the position to the next token after ch (stopping
    at the end of the line)

--*/
{
    //
    //  Make sure the line is terminated so a '\0' will be returned after
    //  the last token is found on this line
    //

    RestoreToken();

    if ( !m_pszLineTerm )
        TerminateLine();

    //
    //  Look for the specified character (generally ',' or ';')
    //

    SkipTo( ch );

    if ( *m_pszPos )
        m_pszPos++;

    EatWhite();

    TerminateToken( ch );

    return m_pszPos;
}


CHAR *
INET_PARSER::SkipTo(
    CHAR ch
    )
/*++

Routine Description:

    Skips to the specified character or returns a null terminated string
    if the end of the line is reached


--*/
{
    //
    //  Make sure the line is terminated so a '\0' will be returned after
    //  the last token is found on this line
    //

    RestoreToken();

    if ( !m_pszLineTerm )
        TerminateLine();

    m_pszPos = AuxSkipTo( ch );

    return m_pszPos;
}


VOID
INET_PARSER::SetListMode(
    BOOL fListMode
    )
/*++

Routine Description:

    Resets the parser mode to list mode or non-list mode

Arguments:

--*/
{
    RestoreToken();

    if ( !m_pszLineTerm )
        TerminateLine();

    m_fListMode = fListMode;
}

VOID
INET_PARSER::TerminateToken(
    CHAR ch
    )
/*++

Routine Description:

    Zero terminates after the white space of the current token

Arguments:

--*/
{
    DBG_ASSERT( !m_pszTokenTerm );

    m_pszTokenTerm = AuxEatNonWhite( ch );

    m_chTokenTerm = *m_pszTokenTerm;

    *m_pszTokenTerm = '\0';
}

VOID
INET_PARSER::RestoreToken(
    VOID
    )
/*++

Routine Description:

    Restores the character replaced by the zero terminator

Arguments:

--*/
{
    if ( m_pszTokenTerm )
    {
        *m_pszTokenTerm = m_chTokenTerm;
        m_pszTokenTerm = NULL;
    }
}

VOID
INET_PARSER::TerminateLine(
    VOID
    )
/*++

Routine Description:

    Zero terminates at the end of this line

Arguments:

--*/
{
    DBG_ASSERT( !m_pszLineTerm );

    m_pszLineTerm = AuxSkipTo( '\n' );

    //
    //  Now trim any trailing white space on the line
    //

    if ( m_pszLineTerm > m_pszPos )
    {
        m_pszLineTerm--;

        while ( m_pszLineTerm >= m_pszPos &&
                ISWHITEA( *m_pszLineTerm ))
        {
            m_pszLineTerm--;
        }
    }

    //
    //  Go forward one (trimming found the last non-white
    //  character)
    //

    if ( *m_pszLineTerm &&
         *m_pszLineTerm != '\n' &&
         !ISWHITEA( *m_pszLineTerm ))
    {
        m_pszLineTerm++;
    }

    m_chLineTerm = *m_pszLineTerm;

    *m_pszLineTerm = '\0';
}

VOID
INET_PARSER::RestoreLine(
    VOID
    )
/*++

Routine Description:

    Restores the character replaced by the zero terminator

Arguments:

--*/
{
    if ( m_pszLineTerm )
    {
        *m_pszLineTerm = m_chLineTerm;
        m_pszLineTerm = NULL;
    }
}




CHAR *
INET_PARSER::AuxEatNonWhite(
    CHAR ch
    )
/*++

Routine Description:

    In non list mode returns the first white space character after 
    the current parse position
    In list mode returns the first delimiter ( "';\n" ) character after 
    the current parse position

Arguments:

    ch - Optional character that is considered white space (such as ',' or ';'
        when doing list processing).

--*/
{
    CHAR * psz = m_pszPos;

    //
    //  Note that ISWHITEA includes '\r'.  In list mode, comma and semi-colon
    //  are considered delimiters
    //

    if ( !m_fListMode )
    {
        while ( *psz           &&
                *psz != '\n'   &&
                !ISWHITEA(*psz)&&
                *psz != ch )
        {
            psz++;
        }

        return psz;
    }
    else
    {
        while ( *psz           &&
                *psz != '\n'   &&
#if 0
                // fix #20931
                !ISWHITEA(*psz)&&
#endif
                *psz != ','    &&
                *psz != ';'    &&
                *psz != ch )
        {
            psz++;
        }

        return psz;
    }
}


CHAR *
INET_PARSER::AuxEatWhite(
    VOID
    )
/*++

Routine Description:

    Returns the first non-white space character after the current parse
    position

Arguments:

--*/
{
    CHAR * psz = m_pszPos;

    //
    //  Note that ISWHITEA includes '\r'
    //

    while ( *psz           &&
            *psz != '\n'   &&
            ISWHITEA(*psz))
    {
        psz++;
    }

    return psz;
}


CHAR *
INET_PARSER::AuxSkipTo(
    CHAR ch
    )
/*++

Routine Description:

    Skips to the specified character or returns a null terminated string
    if the end of the line is reached


--*/
{
    CHAR * psz = m_pszPos;

    while ( *psz           &&
            *psz != '\n'   &&
            *psz != ch )
    {
        psz++;
    }

    return psz;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\common\reftrce2.h ===
#ifndef __REFTRCE2_H__
#define __REFTRCE2_H__

#if SERVICE_REF_TRACKING

# include <reftrace.h>

# define SHARED_LOG_REF_COUNT()     \
    ( sm_pDbgRefTraceLog != NULL ) ?        \
        WriteRefTraceLog(                   \
            sm_pDbgRefTraceLog              \
            , m_reference                   \
            , this                          \
        )                                   \
    : -1                                    \

//
//  This macro logs the IIS_SERVICE-specific ref trace log
//

# define LOCAL_LOG_REF_COUNT()      \
    ( m_pDbgRefTraceLog != NULL ) ?         \
        WriteRefTraceLog(                   \
            m_pDbgRefTraceLog               \
            , m_reference                   \
            , this                          \
        )                                   \
    : -1                                    \

//
//  Usage of above macros AFTER we decremented reference count
//  was unsafe.  Under stress we would sometimes hit assert
//  in WriteTraceLog() because IIS_SERVICE::m_pDbgRefTraceLog
//  was no longer valid.  This was due to a race condition where
//  another thread deletes IIS_SERVICE object while we are still
//  doing the log.
//  So, instead of using original macros AFTER the decrement
//  use modified macros BEFORE the decrement.  This should
//  result in identical logs most of the time (subject to
//  race conditions and our guessing of what post decrement
//  reference count will be).
//

# define SHARED_EARLY_LOG_REF_COUNT()       \
    ( sm_pDbgRefTraceLog != NULL ) ?        \
        WriteRefTraceLog(                   \
            sm_pDbgRefTraceLog              \
            , m_reference - 1               \
            , this                          \
        )                                   \
    : -1                                    \

# define LOCAL_EARLY_LOG_REF_COUNT()        \
    ( m_pDbgRefTraceLog != NULL ) ?         \
        WriteRefTraceLog(                   \
            m_pDbgRefTraceLog               \
            , m_reference - 1               \
            , this                          \
        )                                   \
    : -1                                    \

#else  // !SERVICE_REF_TRACKING
# define SHARED_LOG_REF_COUNT() (-1)
# define LOCAL_LOG_REF_COUNT()  (-1)
# define SHARED_EARLY_LOG_REF_COUNT() (-1)
# define LOCAL_EARLY_LOG_REF_COUNT()  (-1)
#endif // !SERVICE_REF_TRACKING

#endif // __REFTRCE2_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\common\refb.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    refb.cxx

Abstract:

    Reference counting blob class

Author:

    Philippe Choquier (phillich)    11-sep-1996

--*/

#include "tcpdllp.hxx"

#pragma hdrstop

#include <refb.hxx>


RefBlob::RefBlob(
    ) 
/*++
    Description:

        Constructor for RefBlob

    Arguments:
        None

    Returns:
        Nothing

--*/
{ 
    m_lRef = 0; 
    m_pvBlob = 0; 
    m_dwSize = 0; 
    m_pfnFree = NULL;
}


RefBlob::~RefBlob(
    ) 
/*++
    Description:

        Destructor for RefBlob

    Arguments:
        None

    Returns:
        Nothing

--*/
{
}


BOOL 
RefBlob::Init( 
    LPVOID          pv, 
    DWORD           sz,
    PFN_FREE_BLOB   pFn
    ) 
/*++
    Description:

        Initialize a RefBlob
        ownership of buffer pointed to by pv is transferred
        to this object. buffer must have been allocated using
        LocalAlloc( LMEM_FIXED, )

    Arguments:
        pv - pointer to blob
        sz - size of blob
        pFn - ptr to function to call to free blob

    Returns:
        TRUE if success, otherwise FALSE

--*/
{ 
    m_pvBlob = pv; 
    m_dwSize = sz; 
    m_pfnFree = pFn;
    AddRef(); 
    return TRUE; 
}


VOID 
RefBlob::AddRef(
    VOID
    ) 
/*++
    Description:

        Add a reference to this object

    Arguments:
        None

    Returns:
        Nothing

--*/
{ 
    InterlockedIncrement( &m_lRef ); 
}


VOID 
RefBlob::Release(
    VOID
    )
/*++
    Description:

        Remove a reference to this object
        When the reference count drops to zero
        the object is destroyed, blob memory freed

    Arguments:
        None

    Returns:
        Nothing

--*/
{
    if ( !InterlockedDecrement( &m_lRef ) )
    {
        if ( m_pfnFree )
        {
            (m_pfnFree)( m_pvBlob );
        }
        else
        {
            LocalFree( m_pvBlob );
        }
        delete this;
    }
}


LPVOID 
RefBlob::QueryPtr(
    ) 
/*++
    Description:

        Returns a ptr to blob

    Arguments:
        None

    Returns:
        ptr to blob

--*/
{ 
    return m_pvBlob; 
}


DWORD
RefBlob::QuerySize(
    ) 
/*++
    Description:

        Returns a blob size

    Arguments:
        None

    Returns:
        size of blob

--*/
{ 
    return m_dwSize; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\common\sslinfo.cxx ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    sslinfo.cxx

Abstract:

    Implementation of IIS_SSL_INFO class

Author:

    Alex Mallet (amallet)    03-Feb-1997

--*/


#include "tcpdllp.hxx"
#pragma hdrstop

#include <wincrypt.h>

#include <dbgutil.h>
#include <buffer.hxx>
#include <ole2.h>
#include <imd.h>
#include <mb.hxx>
#include <eventlog.hxx>
#include <reftrace.h>

#include "iiscert.hxx"
#include "capiutil.hxx"
#include "iisctl.hxx"
#include "certnotf.hxx"
#include "sslinfo.hxx"

#if DBG
#define VALIDATE_HEAP() DBG_ASSERT( RtlValidateHeap( RtlProcessHeap(), 0, NULL ) )
#else
#define VALIDATE_HEAP() 
#endif 

IIS_SSL_INFO::IIS_SSL_INFO( IN LPTSTR pszMBPath,
                            IN IMDCOM *pMDObject ) :
m_pCert( NULL ),
m_fDefaultCert( FALSE ),
m_fCertOK( FALSE ),
m_pCTL( NULL ),
m_fDefaultCTL ( FALSE ),
m_fCTLOK( FALSE ),
m_strMBPath( pszMBPath ),
m_pMDObject(pMDObject),
m_hTrustedIssuerStore( NULL ),
m_hRestrictedRoot( NULL ),
m_hRestrictedTrust( NULL ),
m_dwRefCount( 0 ),
m_dwSignature( IIS_SSL_INFO_SIGNATURE ),
m_fUseDSMapper( FALSE ),
m_fCheckedDSMapper( FALSE ),
m_hChainEngine( NULL ),
m_hMyStore( NULL ),
m_hCAStore( NULL ),
m_hRootStore( NULL ),
m_acRootCerts( NULL ),
m_cRootCerts( 0 ),
m_dwCertChainStatus( -1 )
/*++

   Description

      Constructor; doesn't do anything, really

   Arguments:

      pszMBPath - path in metabase where SSL-related information is to be found
      pMDObject - metabase object to be used for metabase operations
      pNotifFnc - function to be called when object destructor is called. May be NULL.
      pvArg - argument to pNotifFnc. Ignored if pNotifFnc == NULL

   Returns:

      Nothing

--*/
{
    DBG_ASSERT( pszMBPath );
    DBG_ASSERT( pMDObject );

    INITIALIZE_CRITICAL_SECTION( &m_CritSec );

    m_hMyStore = CertOpenStore( CERT_STORE_PROV_SYSTEM_A,
                                0,
                                NULL,
                                CERT_SYSTEM_STORE_LOCAL_MACHINE,
                                MY_STORE_NAME );

    m_hCAStore = CertOpenStore( CERT_STORE_PROV_SYSTEM_A,
                                0,
                                NULL,
                                CERT_SYSTEM_STORE_LOCAL_MACHINE,
                                CA_STORE_NAME );

    m_hRootStore = CertOpenStore( CERT_STORE_PROV_SYSTEM_A,
                                  0,
                                  NULL,
                                  CERT_SYSTEM_STORE_LOCAL_MACHINE,
                                  ROOT_STORE_NAME );


#if SSLINFO_REF_COUNT 

    m_pRefTraceLog = CreateRefTraceLog( C_SSLINFO_REFTRACES, 0 );
    DBGPRINTF((DBG_CONTEXT,
               "Created ref trace object %p for SSL object %p\n",
               m_pRefTraceLog, this));

#endif 

}


IIS_SSL_INFO::~IIS_SSL_INFO( VOID )
/*++

   Description

     Destructor

   Arguments:

      None

   Returns:

      Nothing

--*/
{
    DBG_ASSERT( CheckSignature() );
    DBG_ASSERT( m_dwRefCount == 0 );

    if ( m_pCert )
    {
        delete m_pCert;
        m_pCert = NULL;
    }

    if ( m_pCTL )
    {
        delete m_pCTL;
        m_pCTL = NULL;
    }

    if ( m_hChainEngine )
    {
        CertFreeCertificateChainEngine( m_hChainEngine );
        m_hChainEngine = NULL;
    }

    if ( m_hTrustedIssuerStore )
    {
        CertCloseStore( m_hTrustedIssuerStore,
                        0 );
        m_hTrustedIssuerStore = NULL;
    }

    if ( m_hRestrictedRoot )
    {
        CertCloseStore( m_hRestrictedRoot,
                        0 );
        m_hRestrictedRoot = NULL;
    }

    if ( m_hRestrictedTrust )
    {
        CertCloseStore( m_hRestrictedTrust,
                        0 );
        m_hRestrictedTrust = NULL;
    }

    if ( m_hRootStore )
    {
        CertCloseStore( m_hRootStore,
                        0 );
        m_hRootStore = NULL;
    }

    if ( m_hCAStore )
    {
        CertCloseStore( m_hCAStore,
                        0 );
        m_hCAStore = NULL;
    }

    if ( m_hMyStore )
    {
        CertCloseStore( m_hMyStore,
                        0 );
        m_hMyStore = NULL;
    }

    if ( m_acRootCerts )
    {
        for ( DWORD i = 0; i < m_cRootCerts; i++ )
        {
            CertFreeCertificateContext( m_acRootCerts[i] );
        }
        delete [] m_acRootCerts;
        m_acRootCerts = NULL;
        m_cRootCerts = 0;
    }

    DeleteCriticalSection( &m_CritSec );

    m_dwSignature = IIS_SSL_INFO_SIGNATURE_FREE;

#if SSLINFO_REF_COUNT

    if ( m_pRefTraceLog )
    {
        DBGPRINTF((DBG_CONTEXT,
                   "Deleting ref trace object %p for ssl object %p\n",
                   m_pRefTraceLog, this));
        DestroyRefTraceLog( m_pRefTraceLog );
    }

#endif //SSLINFO_REF_COUNT 
}

IIS_SSL_INFO *
IIS_SSL_INFO::CreateSSLInfo(
    IN LPTSTR                       pszMBPath,
    IN IMDCOM *                     pMDObject 
)
{
    return new IIS_SSL_INFO( pszMBPath, pMDObject );
}

IIS_SERVER_CERT* IIS_SSL_INFO::GetCertificate( VOID )
/*++

   Description

      Returns server certificate for this instance of the server

   Arguments:

      None 

   Returns:

       ptr to IIS_SERVER_CERT object for this instance, NULL if none can be found/constructed

--*/

{
    DBG_ASSERT( CheckSignature() );

    BOOL fDefault = FALSE;
    LPTSTR pszMDPath = NULL;
    BOOL fHasCert = FALSE;

    Lock();

    if ( !m_pCert )
    {
        if ( HasCertificate( &fHasCert,
                             &m_fDefaultCert ) &&
              //
              // server has cert
              //
             fHasCert )
        {
            if ( m_fDefaultCert )
            {
                pszMDPath = DEFAULT_SERVER_CERT_MD_PATH;
            }
            else
            {
                pszMDPath = m_strMBPath.QueryStr();
            }
            
            m_pCert = new IIS_SERVER_CERT( m_pMDObject,
                                           pszMDPath );

            if ( !m_pCert || !m_pCert->IsValid() )
            {
                DBGPRINTF((DBG_CONTEXT,
                           "Failed to construct cert from path %s, error 0x%x\n",
                           pszMDPath, GetLastError()));
            }
        }
    }

    Unlock();

    return m_pCert;
}

IIS_CTL*
IIS_SSL_INFO::GetCTL( VOID )
/*++

   Description

      Returns Certificate Trust List [CTL] for this instance of the server

   Arguments:

      None 

   Returns:

       ptr to IIS_CTL  object for this instance, NULL if none can be found/constructed

--*/

{
    DBG_ASSERT( CheckSignature() );

    BOOL fDefault = FALSE;
    LPTSTR pszMDPath = NULL;
    BOOL fHasCTL = FALSE;

    Lock();

    if ( !m_pCTL )
    {
        if ( HasCTL( &fHasCTL,
                     &m_fDefaultCTL ) &&
             //
             // instance has CTL
             //
             fHasCTL )
        {
            if ( m_fDefaultCTL )
            {
                pszMDPath = DEFAULT_CTL_MD_PATH;
            }
            else
            {
                pszMDPath = m_strMBPath.QueryStr();
            }
            
            m_pCTL = new IIS_CTL( m_pMDObject,
                                  pszMDPath );
            
            if ( !m_pCTL || !m_pCTL->IsValid() )
            {
                DBGPRINTF((DBG_CONTEXT,
                           "Failed to construct CTL from path %s, error 0x%x\n",
                           pszMDPath, GetLastError()));
            }
        }
    }

    Unlock();

    return (m_pCTL);
}



BOOL IIS_SSL_INFO::HasCertificate( OUT PBOOL pfHasCert,
                                   OUT PBOOL pfIsDefaultCert )
/*++

   Description

      Check whether this instance has certificate info in the metabase 

   Arguments:

      pfHasCert - pointer to bool set to TRUE if server has a cert, FALSE if not 
      pfIsDefaultCert  - Pointer to bool that is set to true if the server has a cert and 
      that cert is the default [global] cert. Not set if the server doesn't have a cert

   Returns:

      TRUE if check succeeds, FALSE if not 

--*/
{
    DBG_ASSERT( CheckSignature() );

    return CheckCAPIInfo( pfHasCert,
                          pfIsDefaultCert,
                          DEFAULT_SERVER_CERT_MD_PATH,
                          adwMetabaseCertProperties,
                          cNumCertMetabaseProperties );
}




BOOL IIS_SSL_INFO::HasCTL( OUT PBOOL pfHasCTL,
                           OUT PBOOL pfIsDefaultCTL )
/*++

   Description

      Check whether this instance has CTL info in the metabase 

   Arguments:

      pfHasCTL - pointer to bool set to TRUE if server has a CTL, FALSE if not 
      pfIsDefaultCTL  - Pointer to bool that is set to true if the server has a CTL
      and that CTL is the default [global] CTL. Not set if the server doesn't have a CTL

   Returns:

      TRUE if check succeeds, FALSE if not 

--*/
{
    DBG_ASSERT( CheckSignature() );

    return CheckCAPIInfo( pfHasCTL,
                          pfIsDefaultCTL,
                          DEFAULT_CTL_MD_PATH,
                          adwMetabaseCTLProperties,
                          cNumCTLMetabaseProperties);
}


BOOL IIS_SSL_INFO::CheckCAPIInfo( OUT PBOOL pfHasInfo,
                                  OUT PBOOL pfIsDefaultInfo,
                                  IN LPTSTR pszDefaultPath,
                                  IN DWORD  *adwMetabaseProperties, 
                                  IN DWORD  cProperties )
/*++

   Description

      Check whether this instance has CAPI info in the metabase 

   Arguments:

      pfHasInfo - pointer to bool set to TRUE if server has CAPI info, FALSE if not 

      pfIsDefaultInfo  - Pointer to bool that is set to true if the server doesn't have 
      its own copy of the CTL info but is to use the default [global] info. Not set if there 
      is no CAPI info. 

      pszDefaultPath - metabase path to default info

      adwMetabaseProperties - metabase properties to be checked

      cProperties - number of entries in adwMetabaseProperties 

   Returns:

      TRUE if check for info succeeds, FALSE if not 
      NB : TRUE doesn't mean CAPI info was found, it means there were no internal errors 
      looking for the info
--*/
{
    DBG_ASSERT( CheckSignature() );

    MB mb( m_pMDObject );
    BOOL fGotCertInfo = FALSE;
    m_fDefaultCert = FALSE;

    if ( !mb.Open( "/" ) )
    {
       return FALSE;
    }

    if ( !( *pfHasInfo = ServerAddressHasCAPIInfo( &mb,
                                                   m_strMBPath.QueryStr(),
                                                   adwMetabaseProperties,
                                                   cProperties ) ) )
    {
        *pfHasInfo = ServerAddressHasCAPIInfo( &mb,
                                               pszDefaultPath,
                                               adwMetabaseProperties,
                                               cProperties );
        if ( *pfHasInfo )
        {
            *pfIsDefaultInfo = TRUE;
        }
    }
    else
    {
        *pfIsDefaultInfo = FALSE;
    }

    mb.Close();

    return (TRUE);
}

BOOL IIS_SSL_INFO::GetTrustedIssuerCerts( OUT PCCERT_CONTEXT **ppcCertContext,
                                          OUT DWORD *pdwCertsFound )
/*++

Routine Description:

    Tries to retrieve CERT_CONTEXT pointers for the trusted CA certs for the given object.
    Trusted CA certs are either retrieved from the appropriate Certificate Trust List or
    from the Local Machine Root store.


Arguments:

    pppCertContext - pointer to array of CERT_CONTEXT pointers, filled out with the found 
    CERT_CONTEXTS.
    Caller is responsible for releasing the contexts when done with them and deleting
    the array used to hold them.

    pdwCertsFound - pointer to number of cert contexts returned in ppCertContext

Returns:

    TRUE if no internal errors occurred, FALSE if NOT
--*/

{
    DBG_ASSERT( CheckSignature() );

    BOOL fOk = TRUE;

    Lock();

    //
    // Use the certs in the CTL, if we have metabase information for one, else get the certs 
    // from the Root store
    //
    if ( GetCTL() )
    {
        if ( m_pCTL->IsValid() )
        {
            DWORD dwCertsInCTL = 0;

            fOk = QueryCTL()->GetContainedCertificates( ppcCertContext,
                                                        pdwCertsFound,
                                                        &dwCertsInCTL );
        }
        else
        {
            fOk = FALSE;
        }
    }
    else
    {
        fOk = GetRootStoreCertificates( ppcCertContext,
                                        pdwCertsFound );
    }

    Unlock();

    return fOk;
}

BOOL IIS_SSL_INFO::GetTrustedIssuerStore( OUT HCERTSTORE *phCertStore )
/*++

Routine Description:

    Returns a pointer to a handle to a cert store that contains the certs for all the
    trusted CAs for this server instance. If there is a CTL, the store will contain
    the certs in the CTL, else it will be a handle to the Local Machine Root store.

Arguments:

    phCertStore - pointer to handle to cert store containing trusted issuers. Updated on
    success. Caller has to call CertCloseStore() when done with the store handle.

Returns:

    TRUE if no internal errors occurred, FALSE if NOT
--*/
{
    DBG_ASSERT( CheckSignature() );

    Lock();

    BOOL fSuccess = FALSE;
    DWORD dwIndex = 0;
    PCCERT_CONTEXT *rgContexts = NULL;
    DWORD cCertsFound = 0;

    *phCertStore = NULL;

    //
    // If there is no CTL configurated, then return NULL for trusted store to
    // be used by schannel.  When NULL, schannel will use the root store +
    // the trusted store to determine trusted CAs (the desired effect)
    //

    if ( !GetCTL() )
    {
        Unlock();
        return TRUE;
    }

    if ( !m_hTrustedIssuerStore )
    {
        //
        // If there's no CTL configured, the store that holds our trusted issuers is the 
        // Root store;
        // we could just fall through and call GetTrustedIssuerCerts() [which will read all
        // the certs out of the Root store], but that's unnecessary because we can just
        // hand back a handle to the Root store.
        //

        {
            if ( !m_pCTL->IsValid() )
            {
                goto clean_up;
            }

            //
            // Get an in-memory store that will hold all the trusted issuer certs 
            //
            if ( !( m_hTrustedIssuerStore = CertOpenStore( CERT_STORE_PROV_MEMORY,
                                                           0,
                                                           0,
                                                           0,
                                                           0 ) ) )
            {
                goto clean_up;
            }


            //
            // Try to retrieve all the certs in it and stuff them 
            // into the in-memory store
            //
            if ( !GetTrustedIssuerCerts( &rgContexts,
                                         &cCertsFound ) )
            {
                goto clean_up;
            }
            
            
            for ( dwIndex = 0; dwIndex < cCertsFound ; dwIndex++ )
            {
                if ( !CertAddCertificateContextToStore( m_hTrustedIssuerStore,
                                                        rgContexts[dwIndex],
                                                        CERT_STORE_ADD_ALWAYS,
                                                        NULL ) )
                {
                    goto clean_up;
                }
            }

            //
            // And finally make a copy of the store handle; note that the store will be empty if 
            // we don't have a valid CTL or we couldn't retrieve the certs in the CTL 
            //
            if ( !(*phCertStore = CertDuplicateStore( m_hTrustedIssuerStore ) ) )
            {
                goto clean_up;
            }
        }

        fSuccess = TRUE;

    clean_up:
        
        //
        // cleanup done only on failure
        //
        if ( !fSuccess )
        {
            if ( *phCertStore )
            {
                CertCloseStore( *phCertStore,
                                0 );
            }
            
            if ( m_hTrustedIssuerStore )
            {
                CertCloseStore( m_hTrustedIssuerStore,
                                0 );
                m_hTrustedIssuerStore = NULL;
            }
        }
        
        //
        // cleanup done regardless of success/failure
        //
        
        //
        // clean up all the cert contexts, because the store has a copy of them
        //
        if ( rgContexts )
        {
            for ( dwIndex = 0; dwIndex < cCertsFound; dwIndex++ )
            {
                if ( rgContexts[dwIndex] )
                {
                    CertFreeCertificateContext( rgContexts[dwIndex] );
                }
            }
            
            delete [] rgContexts;
        }
    }
    else
    {
        if ( *phCertStore = CertDuplicateStore(m_hTrustedIssuerStore) )
        {
            fSuccess = TRUE;
        }
    }
    
    Unlock();

    return fSuccess;
}

BOOL IIS_SSL_INFO::CreateEngineRootStore()
/*++

   Description

      Sets up the "Restricted Root" store that is passed to the cert chain engine used to
      verify client certificates. If there's a CTL attached to this object, the store contains
      only the self-signed cert that is at the top of the chain for the cert that signed 
      the CTL. If there's no CTL, the store is the Local Machine Root store.

   Arguments:

      None

   Returns:

      TRUE if successful, FALSE if not

--*/
{
    DBG_ASSERT( CheckSignature() );

    BOOL fOk = TRUE;

    Lock();

    if ( !m_hRestrictedRoot )
    {
        //
        // No CTL, we'll just use the Root store
        //
        if ( !GetCTL() )
        {
            if ( m_hRootStore )
            {
                m_hRestrictedRoot = CertDuplicateStore( m_hRootStore );
            }
            else
            {
                fOk = FALSE;
            }
        }
        else
        {
            if ( !m_pCTL->IsValid() )
            {
                Unlock();
                return FALSE;
            }
                 
            //
            // If we're signing our CTLs, the restricted root store should contain the
            // top of the chain for the cert that signed the CTL and this cert should be 
            // in the ROOT store
            //
            // If we're not signing our CTLs, the restricted root store is just an empty
            // store
            //
#if SIGNED_CTL
            PCCERT_CONTEXT pSigner = NULL;
            PCCERT_CONTEXT pIssuerCert = NULL;
            DWORD cCerts = 0;
            BOOL fTrustedRoot = FALSE;
            
            //
            // Get the cert that signed the CTL and try to find the issuers up to a self-signed
            // cert in the ROOT store
            //
            if ( m_pCTL->QuerySignerCert( &pSigner ) &&
                 pSigner )
            {
                if ( FindTopOfChain( pSigner,
                                     &pIssuerCert ) &&
                     IsTrustedRoot( pIssuerCert,
                                    &fTrustedRoot) &&
                     fTrustedRoot )
                {
                    //
                    // Create in memory store, put top of chain into it - this is the
                    // restricted-root store to use.
                    //
                    if ( m_hRestrictedRoot = CertOpenStore( CERT_STORE_PROV_MEMORY,
                                                            0,
                                                            0,
                                                            0,
                                                            0 ) )
                    {
                        fOk = CertAddCertificateContextToStore( m_hRestrictedRoot,
                                                                pIssuerCert,
                                                                CERT_STORE_ADD_ALWAYS,
                                                                NULL );
                    }
                    else
                    {
                        fOk = FALSE;
                    }
                }
                else
                {
                    fOk = FALSE;
                }
            } // if ( QueryCTL()->QuerySigner
            else
            {
                fOk = FALSE;
            }
#else //SIGNED_CTL
            if ( !( m_hRestrictedRoot = CertOpenStore( CERT_STORE_PROV_MEMORY,
                                                       0,
                                                       0,
                                                       0,
                                                       0 ) ) )
            {
                fOk = FALSE;
            }
            
#endif //SIGNED_CTL
        } //else clause for if ( !GetCTL() )
    }

    Unlock();

    return fOk;
}

BOOL IIS_SSL_INFO::CreateEngineTrustStore()
/*++

   Description

      Sets up the "Restricted Trust" store that is passed to the cert chain engine used to
      verify client certificates. If there is a CTL associated with this object, this store 
      contains only the CTL associated with this object. Else, we'll just leave it as
      NULL so that the chain engine uses the default. 


   Arguments:

      None

   Returns:

      TRUE if successful, FALSE if not

--*/
{
    DBG_ASSERT( CheckSignature() );

    BOOL fOk = TRUE;

    Lock();

    if ( !m_hRestrictedTrust )
    {
        if ( GetCTL() )
        {
            if ( !m_pCTL->IsValid() )
            {
                Unlock();
                return FALSE;
            }

            m_hRestrictedTrust = m_pCTL->GetMemoryStore();
            
            if ( !m_hRestrictedTrust )
            {
                fOk = FALSE;
            }
        }
        else
        {
            m_hRestrictedTrust = NULL;
        }
    }
    
    Unlock();

    return fOk;
}
        

DWORD IIS_SSL_INFO::Reference()
/*++

   Description

      Increases ref count

   Arguments:

   Returns:

       # of outstanding references

--*/
{
    DBG_ASSERT( CheckSignature() );

    DWORD dwRefCount = 0;

    Lock();

    dwRefCount = InterlockedIncrement( (LONG *) &m_dwRefCount );

#if SSLINFO_REF_COUNT

    if ( m_pRefTraceLog )
    {
        WriteRefTraceLogEx( m_pRefTraceLog,
                            dwRefCount,
                            (PVOID) this,
                            (PVOID) -1,
                            (PVOID) -1,
                            (PVOID) -1 );
    }

#endif //SSLINFO_REF_COUNT 
         
    Unlock();

    return dwRefCount;

}
                                   
DWORD IIS_SSL_INFO::Release( PVOID pvParam )
/*++

   Description

      Decreases ref count; deletes object if zero. Changed to static function to
      avoid not-quite-kosher "delete this" call.

   Arguments:

      pvParam - pointer to IIS_SSL_INFO 

   Returns:

       # of outstanding references

--*/

{
    IIS_SSL_INFO *pInfo = (IIS_SSL_INFO *) pvParam;

    pInfo->Lock();

    DBG_ASSERT( pInfo->m_dwRefCount > 0 );

    DWORD dwRefCount = InterlockedDecrement( (LONG *) &(pInfo->m_dwRefCount)  );


#if SSLINFO_REF_COUNT

    if ( pInfo->m_pRefTraceLog )
    {
        WriteRefTraceLogEx( pInfo->m_pRefTraceLog,
                            dwRefCount,
                            (PVOID) pInfo,
                            (PVOID) -1,
                            (PVOID) -1,
                            (PVOID) -1 );
    }

#endif //SSLINFO_REF_COUNT 

    if ( !dwRefCount )
    {
        pInfo->Unlock();
        delete pInfo;
    }
    else
    {
        pInfo->Unlock();
    }

    return dwRefCount;
}



BOOL IIS_SSL_INFO::UseDSMapper( VOID )
/*++

   Description

      Checks whether the NT 5 DS mapper is to be used for client certificate mapping

   Arguments:

      None 

   Returns:

      TRUE if mapper is to be used, false otherwise
--*/
{
    DBG_ASSERT( CheckSignature() );

    DBG_ASSERT( m_pMDObject );
    BOOL fUseMapper = FALSE;
    MB mb( m_pMDObject );

    if ( !mb.Open("/LM/W3SVC") )
    {
        return FALSE;
    }
   
    Lock();

    if ( !m_fCheckedDSMapper )
    {
        DWORD dwUseMapper = 0;

        if ( mb.GetDword( NULL,
                          MD_SSL_USE_DS_MAPPER,
                          IIS_MD_UT_SERVER,
                          &dwUseMapper,
                          METADATA_NO_ATTRIBUTES ) )
        {
            m_fUseDSMapper = (BOOL) dwUseMapper;
            m_fCheckedDSMapper = TRUE;
        }
    }

    fUseMapper = m_fUseDSMapper;
    
    Unlock();

    mb.Close();

    return fUseMapper;
}
                                 

BOOL IIS_SSL_INFO::GetCertChainEngine( OUT HCERTCHAINENGINE *phEngine )
/*++

   Description

      Returns a handle to an initialized cert chain engine

   Arguments:

      pEngine - pointer to engine handle, updated on success

   Returns:

      TRUE if engine was constructed successfully, FALSE if not
--*/
{
    DBG_ASSERT( CheckSignature() );

    *phEngine = NULL;
    
    Lock();

    if ( !m_hChainEngine )
    {
        DBG_ASSERT( !m_hRestrictedRoot && !m_hRestrictedTrust );

        //
        // Set up the "Restricted Root" store, which contains all the certs to be accepted as the
        // top of a cert chain for this instance
        //
        if ( !CreateEngineRootStore() )
        {
            Unlock();

            DBGPRINTF((DBG_CONTEXT,
                       "Failed to get engine root store : 0x%x\n",
                       GetLastError()));

            return FALSE;
        }
        //
        // Trust store to be used for CTLs
        //
        if ( !CreateEngineTrustStore() )
        {
            CertCloseStore( m_hRestrictedRoot,
                            0 );

            m_hRestrictedRoot = NULL;

            Unlock();

            DBGPRINTF((DBG_CONTEXT,
                       "Failed to get engine trust store : 0x%x\n",
                       GetLastError()));

            return FALSE;
        }

        //
        // Initialize cert chain config
        //
        CERT_CHAIN_ENGINE_CONFIG CCEC;

        memset( &CCEC, 0, sizeof(CCEC) );

        CCEC.cbSize = sizeof(CCEC);
        CCEC.hRestrictedRoot = m_hRestrictedRoot;
        CCEC.hRestrictedTrust = m_hRestrictedTrust;
        CCEC.dwFlags = CERT_CHAIN_ENABLE_CACHE_AUTO_UPDATE;

        if( m_hRootStore )
        {
            //
            // Include the root store in the collection of stores
            // to search.
            //
            CCEC.cAdditionalStore = 1;
            CCEC.rghAdditionalStore = &m_hRootStore;
        }

        //
        // Get us a chain engine, will you, Jeeves ...
        //
        if ( !CertCreateCertificateChainEngine( &CCEC,
                                                &m_hChainEngine ) )
        {
            CertCloseStore( m_hRestrictedRoot,
                            0 );
            m_hRestrictedRoot = NULL;

            CertCloseStore( m_hRestrictedTrust,
                            0 );
            m_hRestrictedTrust = NULL;

            Unlock();

            DBGPRINTF((DBG_CONTEXT,
                       "Failed to create chain engine : 0x%d\n",
                       GetLastError()));

            return FALSE;
        }

    }

    //
    // Got this far, everything is cool
    //
    *phEngine = m_hChainEngine;
        
    Unlock();    

    return TRUE;
}


BOOL IIS_SSL_INFO::FindTopOfChain( PCCERT_CONTEXT pcLeafCert,
                                   PCCERT_CONTEXT *ppcTopCert )
/*++

   Description

      Finds the top of the chain for a given cert

   Arguments:

      pcLeafCert - cert whose chain is to be built
      ppcTopCert - pointer to pointer to as far up as we could go in pcLeafCert's hierarchy. 
      Updated on success. Caller is responsible for cleaning it up.

   Returns:

      TRUE if search proceeded with no errors, FALSE otherwise
--*/

{
    DBG_ASSERT( CheckSignature() );

    *ppcTopCert = NULL;

    DBG_ASSERT( pcLeafCert );
    if( !pcLeafCert )
    {
        DBGERROR(( DBG_CONTEXT, 
                   "NULL cert context passed to IIS_SSL_INFO::FindTopOfChain\n" 
                   ));
        return FALSE;
    }

    //
    // To build the chain, look for issuers in 4 stores : the store the cert came from,
    // and the "MY", "CA" and "ROOT" stores, cycling through the stores as necessary
    //

    PCCERT_CONTEXT pcIssuer = NULL;
    PCCERT_CONTEXT pcPresentLeaf = CertDuplicateCertificateContext( pcLeafCert );
    DWORD dwFlags = 0;
    DWORD dwStoresTried = 0;
    BOOL fCompleteChain = FALSE;
    HCERTSTORE hPresentStore = pcPresentLeaf->hCertStore;
    DWORD cNumCerts = 0;

    while ( 1 )
    {
        //
        // Bail when we get to the top of a chain
        //
        if ( IsSelfSignedCert( pcPresentLeaf ) )
        {
            fCompleteChain = TRUE;
            break;
        }

        pcIssuer = CertGetIssuerCertificateFromStore( hPresentStore,
                                                      pcPresentLeaf,
                                                      NULL,
                                                      &dwFlags );

        //
        // Got an issuer in this store
        //
        if ( pcIssuer )
        {
            //
            // Set up for next round
            //
            CertFreeCertificateContext( pcPresentLeaf );

            pcPresentLeaf = pcIssuer;

            dwStoresTried = 0;

            cNumCerts++;
        }
        //
        // No issuer in this store, switch to next store to look in
        //
        else
        {

            dwStoresTried++;

            if ( dwStoresTried == 4 ) //we've tried all the stores, time to bail
            {
                break;
            }

            if ( hPresentStore == m_hMyStore )
            {
                hPresentStore = m_hCAStore;
            }
            else if ( hPresentStore == m_hCAStore )
            {
                hPresentStore = m_hRootStore;
            }
            else if ( hPresentStore == m_hRootStore )
            {
                hPresentStore = pcPresentLeaf->hCertStore;
            }
            else
            {
                hPresentStore = m_hMyStore;
            }
        }
    } //while ( 1 )

    *ppcTopCert = pcPresentLeaf;

    return TRUE;
}


BOOL IIS_SSL_INFO::IsTrustedRoot( IN PCCERT_CONTEXT pcCert,
                                  OUT BOOL *pfTrustedRoot )
/*++

   Description

     Checks whether a cert is a trusted root ie in the Local Machine Root store and 
     self-signed

   Arguments:

      pcCert - cert to be checked
      pfTrustedRoot - pointer to bool that is updated on success

   Returns:

      TRUE if no errors occured, FALSE otherwise
--*/
{
    DBG_ASSERT( CheckSignature() );

    //
    // if cert isn't self-signed, it's not a trusted root
    //
    if ( !IsSelfSignedCert( pcCert ) )
    {
        *pfTrustedRoot = FALSE;
        return TRUE;
    }

    //
    // Check if cert can be found in ROOT store
    //
#define SHA1_HASH_SIZE 20

    BYTE rgbHash[SHA1_HASH_SIZE];
    DWORD cbHash = SHA1_HASH_SIZE;

    if ( !CertGetCertificateContextProperty( pcCert,
                                             CERT_SHA1_HASH_PROP_ID,
                                             (VOID *) rgbHash,
                                             &cbHash ) )
    {
        return FALSE;
    }

    CRYPT_HASH_BLOB HashBlob;
    HashBlob.cbData = cbHash;
    HashBlob.pbData = rgbHash;
        
    if ( !m_hRootStore ||
         !CertFindCertificateInStore( m_hRootStore,
                                      X509_ASN_ENCODING,
                                      0,
                                      CERT_FIND_SHA1_HASH,
                                      (VOID *) &HashBlob,
                                      NULL ) )
    {
        if ( !m_hRootStore || 
             GetLastError() != CRYPT_E_NOT_FOUND )
        {
            return FALSE;
        }
        else
        {
            *pfTrustedRoot = FALSE;
        }
    }
    else
    {
        *pfTrustedRoot = TRUE;
    }

    return TRUE;
}

BOOL IIS_SSL_INFO::GetRootStoreCertificates( OUT PCCERT_CONTEXT **ppcCertContext,
                                             OUT DWORD *pdwCerts )
/*++

Routine Description:

    Reads all the certificates out of the Local Machine Root store.
Arguments:

    pppCertContext - pointer to array of CERT_CONTEXT pointers, filled out with the found 
    CERT_CONTEXTS.
    Caller is responsible for releasing the contexts when done with them and deleting
    the array used to hold them.

    pdwCertsFound - pointer to number of cert contexts returned in ppCertContext

Returns:

    TRUE if no internal errors occurred, FALSE if NOT
--*/
{
    DBG_ASSERT( CheckSignature() );

    DWORD i = 0;

    Lock();

    //
    // Whatever the case, make sure we don't accidentally return garbage
    //
    *pdwCerts = 0;
    *ppcCertContext = NULL;

    if ( !m_acRootCerts )
    {
        if ( m_hRootStore )
        {
            *pdwCerts = 0;
            PCCERT_CONTEXT pCert = NULL;
            PCCERT_CONTEXT pPrevCert = NULL;
            m_cRootCerts = 0;

            //
            // In an ideal world, we'd know how many certs there are in the store, but it's not
            // an ideal world, so we have to count them ourselves
            //
            while ( pCert = CertEnumCertificatesInStore( m_hRootStore,
                                                         pPrevCert ) )
            {
                m_cRootCerts++;
                pPrevCert = pCert;
            }

            if ( GetLastError() != CRYPT_E_NOT_FOUND )
            {
                Unlock();
                return FALSE;
            }
                
            //
            // Guard against nothing being in the Root store. Unlikely, but we're
            // paranoid
            //
            if ( m_cRootCerts == 0 )
            {
                Unlock();
                return TRUE;
            }

            m_acRootCerts = new PCCERT_CONTEXT[m_cRootCerts];
            
            if ( !m_acRootCerts )
            {
                Unlock();
                return FALSE;
            }

            //
            // Make a copy of all the certs in the root store
            //
            pCert = NULL;
            pPrevCert = NULL;
            
            while ( pCert = CertEnumCertificatesInStore( m_hRootStore,
                                                         pPrevCert ) )
            {
                m_acRootCerts[i++] = CertDuplicateCertificateContext( pCert );
                pPrevCert = pCert;
            }

            DBG_ASSERT( i == m_cRootCerts );

            if ( GetLastError() != CRYPT_E_NOT_FOUND )
            {
                for ( i = 0; i < m_cRootCerts; i++ )
                {
                    CertFreeCertificateContext( m_acRootCerts[i] );
                }
                delete [] m_acRootCerts;

                m_acRootCerts = NULL;
                m_cRootCerts = 0;

                Unlock();
                return FALSE;
            }
        }
        else
        {
            Unlock();
            return FALSE;
        }
    }

    //
    // By this time, m_acRootCerts should have been allocated
    //
    *ppcCertContext = new PCCERT_CONTEXT[m_cRootCerts];

    if ( !*ppcCertContext )
    {
        Unlock();
        return FALSE;
    }

    //
    // Copy the certs 
    //
    for ( i = 0; i < m_cRootCerts; i++ )
    {
        (*ppcCertContext)[(*pdwCerts)++] = CertDuplicateCertificateContext( m_acRootCerts[i] );
    }

    Unlock();

    return TRUE;
}

BOOL IsSelfSignedCert( IN PCCERT_CONTEXT pCertContext )
/*++

Routine Description:

    Determines whether a cert is self-signed ie the top of a hierarchy

Arguments:

    pCertContext - cert to be checked

Returns:

    TRUE if cert is self-signed, FALSE otherwise

--*/

{
    //
    // Compare subject and issuer.
    //
    if(pCertContext->pCertInfo->Subject.cbData == pCertContext->pCertInfo->Issuer.cbData)
    {
        if(memcmp(pCertContext->pCertInfo->Subject.pbData,
                  pCertContext->pCertInfo->Issuer.pbData,  
                  pCertContext->pCertInfo->Issuer.cbData) == 0)
        {
            return TRUE;
        }
    }

    return FALSE;
}

BOOL IIS_SSL_INFO::QueryCertValidity( DWORD *pdwStatus )
/*++

Routine Description:

    Retrieves status bits for server certificate ie ie not expired, whether 
    it's possible to construct a full chain up to a trusted root, whether it's 
    signature-valid etc and writes an entry to the system log if necessary.

Arguments:

     pdwStatus - pointer to status, updated on success

Returns:

    TRUE if status check was successful, FALSE if not

--*/
{
    *pdwStatus = 0;

    Lock();

    if ( !GetCertificate() || !m_pCert->IsValid() )
    {
        Unlock();
        return FALSE;
    }

    //
    // Should have a valid cert at this point
    //
    DBG_ASSERT( m_pCert );

    if ( m_pCert->IsFortezzaCert() )
    {
        m_dwCertChainStatus = 0;
    }

    if ( m_dwCertChainStatus == -1 )
    {
        //
        // Use the default per-process chain engine to try to build a chain
        //
        CERT_CHAIN_PARA CCP;
        PCCERT_CHAIN_CONTEXT pCertChain = NULL;
        memset( &CCP, 0, sizeof(CCP) );
        CCP.cbSize = sizeof(CCP);

        if ( CertGetCertificateChain( NULL,
                                      m_pCert->QueryCertContext(),
                                      NULL,
                                      m_pCert->QueryCertContext()->hCertStore,
                                      &CCP,
                                      0,
                                      NULL,
                                      &pCertChain ) )
        {
            m_dwCertChainStatus = pCertChain->TrustStatus.dwErrorStatus;
            
            CertFreeCertificateChain( pCertChain );
            pCertChain = NULL;

        }
        else
        {
            Unlock();

            return FALSE;
        }
    }

    *pdwStatus = m_dwCertChainStatus;

    Unlock();

    return TRUE;
}


VOID IIS_SSL_INFO::ReleaseFortezzaHandlers( VOID )
/*++
    Description:

       Uninstalls the context used to verify signatures on Fortezza certs.
       (The context is installed in the IIS_SERVER_CERT constructor)

    Arguments:

       None

    Returns:

       Nothing
--*/

{
    if ( IIS_SERVER_CERT::m_hFortezzaCtxt )
    {
        CryptUninstallDefaultContext( IIS_SERVER_CERT::m_hFortezzaCtxt,
                                      0,
                                      NULL );
        
        IIS_SERVER_CERT::m_hFortezzaCtxt = NULL;
    }

    if ( IIS_SERVER_CERT::m_hFortezzaCSP )
    {
        CryptReleaseContext( IIS_SERVER_CERT::m_hFortezzaCSP,
                             0 );
        
        IIS_SERVER_CERT::m_hFortezzaCSP = NULL;
    }

}                                          



BOOL IIS_SSL_INFO::CTLContainsCert( IN PCCERT_CONTEXT pCert,
                                    OUT BOOL* pfContains )
/*++
    Description:

       Checks whether a given cert is in the CTL for this object 

    Arguments:

        pCert - certificate to check for in CTL
        pfContains - flag that is set to true/false, if cert is/is not in CTL respectively
        
    Returns:

        BOOL indicating success/failure of attempt to check 
--*/
{
    DBG_ASSERT( CheckSignature() );

    PCCERT_CONTEXT *ppCertContext = NULL;
    DWORD dwCertsFound = 0;
    DWORD dwCertsInCTL = 0;
    BOOL fOK = TRUE;

    *pfContains = FALSE;


    if ( GetCTL() &&
         m_pCTL->IsValid() &&
         m_pCTL->GetContainedCertificates( &ppCertContext,
                                           &dwCertsFound,
                                           &dwCertsInCTL ) )
    {
#define SHA1_HASH_SIZE 20
        BYTE rgbCert1Hash[SHA1_HASH_SIZE];
        BYTE rgbCert2Hash[SHA1_HASH_SIZE];
        DWORD cbSize = SHA1_HASH_SIZE;

        if ( !CertGetCertificateContextProperty( pCert,
                                                 CERT_SHA1_HASH_PROP_ID,
                                                 rgbCert1Hash,
                                                 &cbSize ) )
        {
            DBGPRINTF((DBG_CONTEXT,
                       "Failed to get cert hash : 0x%d\n",
                       GetLastError()));

            fOK = FALSE;
            goto cleanup;
        }

        //
        // Iterate through all the certs in the CTL and compare hashes
        // This is a bit simple-minded
        //
        // CODEWORK : ask the CAPI people how to be smarter about this
        //
        for ( DWORD i = 0; i < dwCertsFound; i++ )
        {
            if ( !CertGetCertificateContextProperty( ppCertContext[i],
                                                     CERT_SHA1_HASH_PROP_ID,
                                                     rgbCert2Hash,
                                                     &cbSize ) )
            {
                DBGPRINTF((DBG_CONTEXT,
                           "Failed to get cert hash : 0x%d\n",
                           GetLastError()));

                fOK = FALSE;
                goto cleanup;
            }
            
            if ( !memcmp( rgbCert1Hash, rgbCert2Hash, SHA1_HASH_SIZE ) )
            {
                *pfContains = TRUE;
                break;
            }
        }
    }
    else
    {
        fOK = FALSE;
    }

cleanup:
    
    if ( ppCertContext )
    {
        for ( DWORD i = 0; i < dwCertsFound; i++ )
        {
            CertFreeCertificateContext( ppCertContext[i] );
        }

        delete [] ppCertContext;
    }

    return fOK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\common\security.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    security.c

    This module manages security for the Internet Services.


    FILE HISTORY:
        KeithMo     07-Mar-1993 Created.
        MuraliK     05-Jan-1995 Enable statistics query on RPC to go free.

*/


#include "tcpdllp.hxx"
#pragma hdrstop
#include <string.h>
#include <mbstring.h>
#include <limits.h>

#include "infosec.hxx"
#include <inetsvcs.h>
#include "TokenAcl.hxx"

//
//  Token Cache lock.  Controls access to the token cache list
//

#define LockTokenCache()        EnterCriticalSection( &csTokenCacheLock )
#define UnlockTokenCache()      LeaveCriticalSection( &csTokenCacheLock )


//
//  The check period for how long a token can be in the cache.  Tokens can
//  be in the cache for up to two times this value (in seconds)
//

#define DEFAULT_CACHED_TOKEN_TTL        (15 * 60)

//
// Globals
//

CRITICAL_SECTION    csTokenCacheLock;
HANDLE              g_hProcessImpersonationToken = NULL;
HANDLE              g_hProcessPrimaryToken = NULL;
BOOL                g_fUseSingleToken = FALSE;
BOOL                g_fAlwaysCheckForDuplicateLogon = FALSE;
BOOL                g_fUseAdvapi32Logon = FALSE;
BOOL                g_fCertCheckForRevocation = FALSE;
TS_TOKEN            g_pctProcessToken;
BOOL                g_fCertCheckCA = TRUE;
HINSTANCE           g_hWinTrust = NULL;
PFN_WinVerifyTrust  g_pfnWinVerifyTrust = NULL;
BOOL                g_fLastPriorityUPNLogon = FALSE;

//
//  Well-known SIDs.
//

PSID                    psidWorld;
PSID                    psidLocalSystem;
PSID                    psidAdmins;
PSID                    psidServerOps;
PSID                    psidPowerUsers;
PSID                    g_psidGuestUser;
PSID                    g_psidProcessUser;

# define GUEST_USER_SID_BUFFER_LEN   (200)

BYTE    g_GuestUserSidBuffer[GUEST_USER_SID_BUFFER_LEN];

//
//  The API security object.  Client access to the TCP Server APIs
//  are validated against this object.
//

PSECURITY_DESCRIPTOR    sdApiObject;

LUID g_ChangeNotifyPrivilegeTcbValue;
PTOKEN_PRIVILEGES g_pTokPrev = NULL;

//
//  This table maps generic rights (like GENERIC_READ) to
//  specific rights (like TCP_QUERY_SECURITY).
//

GENERIC_MAPPING         TCPApiObjectMapping = {
                            TCP_GENERIC_READ,          // generic read
                            TCP_GENERIC_WRITE,         // generic write
                            TCP_GENERIC_EXECUTE,       // generic execute
                            TCP_ALL_ACCESS             // generic all
                        };

//
//  List of cached tokens, the token list lock and the cookie to the token
//  scavenger schedule item.  The token cache TTL gets converted to msecs
//  during startup
//

BOOL IsTokenCacheInitialized = FALSE;
LIST_ENTRY       TokenCacheList;
DWORD            dwScheduleCookie   = 0;
DWORD            cmsecTokenCacheTTL = DEFAULT_CACHED_TOKEN_TTL;
CHAR             g_achComputerName[DNLEN+1];

LIST_ENTRY       CredentialCacheList;
CRITICAL_SECTION csCredentialCacheLock;


//
//  Private prototypes.
//

DWORD
CreateWellKnownSids(
        HINSTANCE hDll
        );

VOID
FreeWellKnownSids(
    VOID
    );

DWORD
CreateApiSecurityObject(
    VOID
    );

VOID
DeleteApiSecurityObject(
    VOID
    );

TS_TOKEN
ValidateUser(
    PCHAR   pszDomainName,
    PCHAR   pszUserName,
    PCHAR   pszPassword,
    BOOL    fAnonymous,
    BOOL *  pfAsGuest,
    DWORD   dwLogonMethod,
    TCHAR * pszWorkstation,
    LARGE_INTEGER * pExpiry,
    BOOL          * pfExpiry,
    BOOL    fUseSubAuthIfAnonymous
    );


VOID EnableTcbPrivilege(
    VOID
    );

BOOL
BuildAcctDesc(
    IN  const CHAR *     pszUser,
    IN  const CHAR *     pszDomain,
    IN  const CHAR *     pszPwd,
    IN  BOOL             fUseSubAuth,
    OUT CHAR  *          pchAcctDesc,       // must be MAX_ACCT_DESC_LEN
    OUT LPDWORD          pdwAcctDescLen
    );

BOOL
AddTokenToCache(
    IN const CHAR *      pszUser,
    IN const CHAR *      pszDomain,
    IN const CHAR *      pszPwd,
    IN BOOL              fUseSubAuth,
    IN HANDLE            hToken,
    IN DWORD             dwLogonMethod,
    OUT CACHED_TOKEN * * ppct,
    BOOL                 fCheckAlreadyExist,
    LPBOOL               pfAlreadyExist
    );


BOOL
FindCachedToken(
    IN  const CHAR *     pszUser,
    IN  const CHAR *     pszDomain,
    IN  const CHAR *     pszPwd,
    IN  BOOL             fResetTTL,
    IN  BOOL             fUseSubAuth,
    IN  DWORD            dwLogonMethod,
    OUT CACHED_TOKEN * * ppct
    );

VOID
WINAPI
TokenCacheScavenger(
    IN VOID * pContext
    );

//
//  Public functions.
//

/*******************************************************************

    NAME:       InitializeSecurity

    SYNOPSIS:   Initializes security authentication & impersonation
                routines.

    RETURNS:    DWORD - NO_ERROR if successful, otherwise a Win32
                    error code.

    NOTES:      This routine may only be called by a single thread
                of execution; it is not necessarily multi-thread safe.

    HISTORY:
        KeithMo     07-Mar-1993 Created.

********************************************************************/
DWORD
InitializeSecurity(
    IN HINSTANCE hDll
    )
{
    NTSTATUS ntStatus;
    DWORD    err;
    DWORD    nName;
    HANDLE   hAccToken;
    HKEY     hKey;
    DWORD    dwType;
    DWORD    dwValue;
    DWORD    nBytes;

    //
    // Read the registry key to see whether tsunami caching is enabled
    //

    err = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                INETA_PARAMETERS_KEY,
                0,
                KEY_READ,
                &hKey
                );

    if ( err == ERROR_SUCCESS ) {
        nBytes = sizeof(dwValue);
        err = RegQueryValueEx(
                    hKey,
                    INETA_W3ONLY_NO_AUTH,
                    NULL,
                    &dwType,
                    (LPBYTE)&dwValue,
                    &nBytes
                    );

        if ( (err == ERROR_SUCCESS) && (dwType == REG_DWORD) ) {
            g_fW3OnlyNoAuth = (BOOL)!!dwValue;
            if ( g_fW3OnlyNoAuth ) {
                DbgPrint("W3OnlyNoAuth set to TRUE in Registry.\n");
            } else {
                DbgPrint("W3OnlyNoAuth set to FALSE in Registry.\n");
            }
        }

        nBytes = sizeof(dwValue);
        err = RegQueryValueEx(
                    hKey,
                    INETA_ALWAYS_CHECK_FOR_DUPLICATE_LOGON,
                    NULL,
                    &dwType,
                    (LPBYTE)&dwValue,
                    &nBytes
                    );

        if ( (err == ERROR_SUCCESS) && (dwType == REG_DWORD) ) {
            g_fAlwaysCheckForDuplicateLogon = (BOOL)dwValue;
        }

        nBytes = sizeof(dwValue);
        err = RegQueryValueEx(
                    hKey,
                    INETA_USE_ADVAPI32_LOGON,
                    NULL,
                    &dwType,
                    (LPBYTE)&dwValue,
                    &nBytes
                    );

        if ( (err == ERROR_SUCCESS) && (dwType == REG_DWORD) ) {
            g_fUseAdvapi32Logon = (BOOL)dwValue;
        }


        nBytes = sizeof(dwValue);
        err = RegQueryValueEx(
                    hKey,
                    INETA_CHECK_CERT_REVOCATION,
                    NULL,
                    &dwType,
                    (LPBYTE)&dwValue,
                    &nBytes
                    );

        if ( (err == ERROR_SUCCESS) && (dwType == REG_DWORD) ) {
            g_fCertCheckForRevocation = (BOOL)dwValue;
        }

        nBytes = sizeof(dwValue);
        err = RegQueryValueEx(
                    hKey,
                    "CertCheckCA",
                    NULL,
                    &dwType,
                    (LPBYTE)&dwValue,
                    &nBytes
                    );

        if ( (err == ERROR_SUCCESS) && (dwType == REG_DWORD) ) {
            g_fCertCheckCA = (BOOL)dwValue;
        }

        nBytes = sizeof(dwValue);
        err = RegQueryValueEx(
                    hKey,
                    "LastPriorityUPNLogon",
                    NULL,
                    &dwType,
                    (LPBYTE)&dwValue,
                    &nBytes
                    );

        if ( (err == ERROR_SUCCESS) && (dwType == REG_DWORD) ) {
            g_fLastPriorityUPNLogon = !!dwValue;
        }

        RegCloseKey( hKey );
    }

    IF_DEBUG( DLL_SECURITY )
    {
        DBGPRINTF(( DBG_CONTEXT, "Initializing security\n" ));
    }

    IsTokenCacheInitialized = TRUE;
    InitializeListHead( &TokenCacheList );
    INITIALIZE_CRITICAL_SECTION( &csTokenCacheLock );

    InitializeListHead( &CredentialCacheList );
    INITIALIZE_CRITICAL_SECTION( &csCredentialCacheLock );

    if ( g_fW3OnlyNoAuth  ) {
        DBGPRINTF((DBG_CONTEXT,
            "InitializeSecurity: NT Security disabled for W3OnlyNoAuth\n"));

        g_fUseSingleToken = TRUE;

        if ( !(g_pctProcessToken = new CACHED_TOKEN) )
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        g_pctProcessToken->_cRef = INT_MAX/2;
        InitializeListHead( &g_pctProcessToken->_ListEntry );

        if ( !OpenProcessToken (
                     GetCurrentProcess(),
                     TOKEN_DUPLICATE|TOKEN_IMPERSONATE|TOKEN_QUERY,
                     &hAccToken
                     ) )
        {
            DBGPRINTF((DBG_CONTEXT, "fail OpenProcessToken\n"));
            return GetLastError();
        }

        if ( !pfnDuplicateTokenEx( hAccToken,
                                0,
                                NULL,
                                SecurityImpersonation,
                                TokenPrimary,
                                &g_hProcessPrimaryToken ))
        {
            DBGPRINTF((DBG_CONTEXT, "fail pfnDuplicateTokenEx primary\n"));
            CloseHandle( hAccToken );
            return GetLastError();
        }

        if ( !pfnDuplicateTokenEx( hAccToken,
                                0,
                                NULL,
                                SecurityImpersonation,
                                TokenImpersonation,
                                &g_hProcessImpersonationToken ))
        {
            DBGPRINTF((DBG_CONTEXT, "fail pfnDuplicateTokenEx impersonate\n"));
            CloseHandle( hAccToken );
            CloseHandle( g_hProcessPrimaryToken );
            return GetLastError();
        }

        err = CreateWellKnownSids( hDll );

        if ( err != NO_ERROR ) {
            DBGPRINTF((DBG_CONTEXT,"CreateWellKnownSids failed with %d\n",err));
            goto exit;
        }

        //
        //  Create the API security object.
        //

        err = CreateApiSecurityObject();

        if ( err != NO_ERROR  ) {
            DBGPRINTF((DBG_CONTEXT,"CreateApiSecurityObjects failed with %d\n",err));
            goto exit;
        }

        g_pctProcessToken->_hToken = g_hProcessPrimaryToken;
        g_pctProcessToken->m_hImpersonationToken = g_hProcessImpersonationToken;

        return(NO_ERROR);
    }


    //
    //  Create well-known SIDs.
    //

    err = CreateWellKnownSids( hDll );

    if ( err != NO_ERROR ) {
        DBGPRINTF((DBG_CONTEXT,"CreateWellKnownSids failed with %d\n",err));
        goto exit;
    }

    //
    //  Create the API security object.
    //

    err = CreateApiSecurityObject();

    if ( err != NO_ERROR  ) {
        DBGPRINTF((DBG_CONTEXT,"CreateApiSecurityObjects failed with %d\n",err));
        goto exit;
    }

    {
        HKEY hkey;

        //
        //  Get the default token TTL, must be at least one second
        //

        if ( !RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                            INETA_PARAMETERS_KEY,
                            0,
                            KEY_READ,
                            &hkey )) {

             cmsecTokenCacheTTL = ReadRegistryDword( hkey,
                                                     "UserTokenTTL",
                                                     DEFAULT_CACHED_TOKEN_TTL);

            RegCloseKey( hkey );
        }

        cmsecTokenCacheTTL = max( 1, cmsecTokenCacheTTL );
        cmsecTokenCacheTTL *= 1000;

        IF_DEBUG( DLL_SECURITY )
        {
            DBGPRINTF(( DBG_CONTEXT,
                       "Scheduling token cached scavenger to %d seconds\n",
                       cmsecTokenCacheTTL/1000 ));
        }

        //
        //  Schedule a work item for the token scavenger
        //

        dwScheduleCookie = ScheduleWorkItem( TokenCacheScavenger,
                                             NULL,
                                             cmsecTokenCacheTTL,
                                             TRUE );    // Periodic
    }

    pfnLogon32Initialize( NULL, DLL_PROCESS_ATTACH, NULL );

    if ( g_pTokPrev = (PTOKEN_PRIVILEGES)LocalAlloc( LMEM_FIXED,
            sizeof(TOKEN_PRIVILEGES) + sizeof(LUID_AND_ATTRIBUTES)) )
    {
        if ( !LookupPrivilegeValue(
                     NULL,
                     "SeChangeNotifyPrivilege",
                     &g_ChangeNotifyPrivilegeTcbValue
                     ) )
        {
            g_pTokPrev->PrivilegeCount = 0;
        }
        else
        {
            g_pTokPrev->PrivilegeCount = 1;

            g_pTokPrev->Privileges[0].Luid = g_ChangeNotifyPrivilegeTcbValue;
            g_pTokPrev->Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
        }
    }

    nName = sizeof(g_achComputerName);
    if ( !GetComputerName( g_achComputerName, &nName ) )
    {
        g_achComputerName[0] = '\0';
    }

    g_hWinTrust = LoadLibrary( "wintrust.dll" );
    if ( g_hWinTrust != NULL )
    {
        g_pfnWinVerifyTrust = (PFN_WinVerifyTrust)GetProcAddress( g_hWinTrust, "WinVerifyTrust" );
    }

    //
    //  Success!
    //

    IF_DEBUG( DLL_SECURITY )
    {
        DBGPRINTF(( DBG_CONTEXT, "Security initialized\n" ));
    }

exit:
    return err;

}   // InitializeSecurity

/*******************************************************************

    NAME:       TerminateSecurity

    SYNOPSIS:   Terminate security authentication & impersonation
                routines.

    NOTES:      This routine may only be called by a single thread
                of execution; it is not necessarily multi-thread safe.

    HISTORY:
        KeithMo     07-Mar-1993 Created.

********************************************************************/
VOID
TerminateSecurity(
    VOID
    )
{
    CACHED_TOKEN * pct;
    CACHED_CREDENTIAL * pcred;

    DBGPRINTF((DBG_CONTEXT,"TerminateSecurity called\n"));

    IF_DEBUG( DLL_SECURITY )
    {
        DBGPRINTF(( DBG_CONTEXT,
                   "Terminating security\n" ));
    }

    //
    //  Delete any tokens still in the cache
    //

    if ( IsTokenCacheInitialized )
    {

        LockTokenCache();

        while ( !IsListEmpty( &TokenCacheList ))
        {
            pct = CONTAINING_RECORD( TokenCacheList.Flink,
                                     CACHED_TOKEN,
                                     _ListEntry );

            RemoveEntryList( &pct->_ListEntry );
            pct->_ListEntry.Flink = NULL;

            //
            //  If the ref count isn't zero then somebody didn't delete all of
            //  their tokens
            //

            DBG_ASSERT( pct->_cRef == 1 );

            CACHED_TOKEN::Dereference( pct );
        }

        UnlockTokenCache();

        DeleteCriticalSection( &csTokenCacheLock );
    }

    //
    //  Delete any credential in the cache
    //

    EnterCriticalSection( &csCredentialCacheLock );

    while ( !IsListEmpty( &CredentialCacheList ))
    {
        pcred = CONTAINING_RECORD( CredentialCacheList.Flink,
                                   CACHED_CREDENTIAL,
                                   _ListEntry );

        RemoveEntryList( &pcred->_ListEntry );
        pcred->_ListEntry.Flink = NULL;

        delete pcred;
    }

    LeaveCriticalSection( &csCredentialCacheLock );

    DeleteCriticalSection( &csCredentialCacheLock );

    if ( g_fUseSingleToken ) {
        CloseHandle( g_hProcessImpersonationToken );
        CloseHandle( g_hProcessPrimaryToken );
        delete g_pctProcessToken;
        return;
    }

    FreeWellKnownSids();
    DeleteApiSecurityObject();

    //
    //  Remove the scheduled scavenger
    //

    if ( dwScheduleCookie )
    {
        RemoveWorkItem( dwScheduleCookie );
    }

    if ( g_pTokPrev )
    {
        LocalFree( g_pTokPrev );
        g_pTokPrev = NULL;
    }

    if ( g_hWinTrust != NULL )
    {
        g_pfnWinVerifyTrust = NULL;
        FreeLibrary( g_hWinTrust );
        g_hWinTrust = NULL;
    }

    pfnLogon32Initialize( NULL, DLL_PROCESS_DETACH, NULL );

    IF_DEBUG( DLL_SECURITY )
    {
        DBGPRINTF(( DBG_CONTEXT,
                   "Security terminated\n" ));
    }
} // TerminateSecurity

/*******************************************************************

    NAME:       TsLogonUser

    SYNOPSIS:   Validates a user's credentials, then sets the
                impersonation for the current thread.  In effect,
                the current thread "becomes" the user.

    ENTRY:      pUserData - The user initiating the request (NULL for
                    the default account).

                pszPassword - The user's password.  May be NULL.

                pfAsGuest - Will receive TRUE if the user was validated
                    with guest privileges.

                pfAsAnonymous - Will receive TRUE if the user received the
                    services anonymous token

                pszWorkstation - workstation name for remote user
                    can be NULL if default ( local computer) to be used

                pExpiry - updated with pwd expiration date/time

                pfExpiryAvailable - updated with TRUE if pwd expiration
                                    date/time available

    RETURNS:    HANDLE - Token handle to use for impersonation or NULL
                    if the user couldn't be validated.  Call GetLastError
                    for more information.

    HISTORY:
        KeithMo     18-Mar-1993 Created.
        Johnl       14-Oct-1994 Mutilated for TCPSvcs

********************************************************************/

TS_TOKEN
TsLogonUser(
    IN  CHAR          * pszUser,
    IN  CHAR          * pszPassword,
    OUT BOOL          * pfAsGuest,
    OUT BOOL          * pfAsAnonymous,
    IN  PIIS_SERVER_INSTANCE psi,
    PTCP_AUTHENT_INFO pTAI,
    IN  CHAR          * pszWorkstation,
    OUT LARGE_INTEGER * pExpiry,
    OUT BOOL          * pfExpiryAvailable
    )
{
    DBG_ASSERT( pfAsGuest != NULL );
    DBG_ASSERT( pfAsAnonymous != NULL );

    STACK_STATSTR    (strAnonPwd, PWLEN+1);
    STACK_STATSTR    (strDomainAndUser, IIS_DNLEN+UNLEN+2);
    STACK_STATSTR    (strAnonUser, UNLEN+1);
    CHAR   *         pszUserOnly;
    CHAR   *         pszDomain;
    TS_TOKEN         hToken;
    BOOL             fUseDefaultDomain = TRUE;
    TCP_AUTHENT_INFO InstanceAuthentInfo;

    if ( g_fUseSingleToken ) {
        *pfAsGuest = TRUE;
        *pfAsAnonymous = TRUE;
        *pfExpiryAvailable = FALSE;
        CACHED_TOKEN::Reference( g_pctProcessToken );
        return g_pctProcessToken;
    }

    // If the client didn't pass in metabase info, grab what we need from
    // the instance.
    //

    if (pTAI == NULL)
    {
        InstanceAuthentInfo.strAnonUserName.Copy( "iusr_xxx" ); //(CHAR *)psi->QueryAnonUserName();
        InstanceAuthentInfo.strAnonUserPassword.Copy( "" );
        InstanceAuthentInfo.strDefaultLogonDomain.Copy( "" ); //(CHAR *)psi->QueryDefaultLogonDomain();
        InstanceAuthentInfo.dwLogonMethod = MD_LOGON_INTERACTIVE; //psi->QueryLogonMethod();
        InstanceAuthentInfo.fDontUseAnonSubAuth = TRUE;
        pTAI = &InstanceAuthentInfo;
    }

    //
    //  Make a quick copy of the anonymous user for this server for later
    //  usage
    //

    if ( !pTAI->strAnonUserName.Clone( &strAnonUser) ||
         !pTAI->strAnonUserPassword.Clone( &strAnonPwd) )
    {
        goto InvalidParamError;
    }

    // if the password is stored hashed, unhash it for usage
    if (pTAI->fPwdIsHashed)
    {
        strAnonPwd.Unhash();
    }

    //
    //  Empty user defaults to the anonymous user
    //

    if ( !pszUser || *pszUser == '\0' )
    {
        pszUser = strAnonUser.QueryStr();
        pszPassword = strAnonPwd.QueryStr();
        fUseDefaultDomain = FALSE;
        *pfAsAnonymous = TRUE;
    }
    else
    {
        *pfAsAnonymous = FALSE;
    }

    //
    //  Validate parameters & state.
    //

    if ( strlen(pszUser) >= (IIS_DNLEN+UNLEN+2) )
    {
        goto InvalidParamError;
    }

    if( pszPassword == NULL )
    {
        pszPassword = "";
    }
    else if ( strlen(pszPassword) > PWLEN )
    {
        goto InvalidParamError;
    }

    //
    // Did the user specify a domain in the domain\user format?
    //

    PSTR  pszDefDom = NULL;

    if (strchr( pszUser, '/' ) || _mbschr( (PUCHAR)pszUser, '\\' ))
    {
        //
        //  Save a copy of the domain\user so we can squirrel around
        //  with it a bit.
        //

        if ( !strDomainAndUser.Copy( pszUser))
        {
            goto InvalidParamError;
        }

        //
        //  Crack the name into domain/user components.
        //

        if ( !CrackUserAndDomain( strDomainAndUser.QueryStr(),
                                  &pszUserOnly,
                                  &pszDomain ))
        {
            goto InvalidParamError;
        }

        fUseDefaultDomain = FALSE;
    }
    else
    {
        //
        // it's either a user only, or UPN format
        //
        pszUserOnly = pszUser;
        pszDomain = NULL;

        //
        // we may need to use the default domain, so let's see if it's valid
        //
        pszDefDom = pTAI->strDefaultLogonDomain.QueryStr();

        if ( !pszDefDom ||
             !*pszDefDom ||
             strchr( pszDefDom, '/' ) ||
             _mbschr( (PUCHAR)pszDefDom, '\\' ))
        {
            fUseDefaultDomain = FALSE;
        }
    }

    //
    // So, here is what we do:
    // - if the user specified a domain in the domain\user format, we'll only try that.
    // - if we had any reason not to use the default domain, we will not try to.
    // - if the username has a '@' in it and no '\', we'll try a UPN logon and also the default domain
    //

    PSTR  pszD1, pszD2;
    BOOL   fAttemptSecondLogon;

    if (pszDomain)
    {
        //
        // user specified domain\user
        //
        pszD1 = pszDomain;
        pszD2 = NULL;
        fAttemptSecondLogon = FALSE;
    }
    else if (!fUseDefaultDomain)
    {
        //
        // we are not trying the default domain, so it's either a local user or UPN format
        //
        pszD1 = "";
        pszD2 = NULL;
        fAttemptSecondLogon = FALSE;
    }
    else if (!strchr( pszUserOnly, '@' ))
    {
        //
        // it's not a UPN format, so use the default domain
        //
        pszD1 = pszDefDom;
        pszD2 = NULL;
        fAttemptSecondLogon = FALSE;
    }
    else
    {
        //
        // here is the tricky part:
        // - no domain\user was specified,
        // - we could use a default domain name
        // - there is a '@' in the username, so it might be a UPN format
        // we resolve this ambiguity by attempting logon twice, the order depends on the
        // registry key LastPriorityUPNLogon
        //
        if (g_fLastPriorityUPNLogon)
        {
            //
            // try the default domain first
            //
            pszD1 = pszDefDom;
            pszD2 = "";
        }
        else
        {
            //
            // try UPN logon first
            //
            pszD1 = "";
            pszD2 = pszDefDom;
        }
        fAttemptSecondLogon = TRUE;
    }

    //
    //  Validate the domain/user/password combo and create
    //  an impersonation token.
    //

    hToken = ValidateUser( pszD1,
                           pszUserOnly,
                           pszPassword,
                           *pfAsAnonymous,
                           pfAsGuest,
                           pTAI->dwLogonMethod,
                           pszWorkstation,
                           pExpiry,
                           pfExpiryAvailable,
                           !pTAI->fDontUseAnonSubAuth
                          );

    if (hToken == NULL &&
        fAttemptSecondLogon &&
        GetLastError() == ERROR_LOGON_FAILURE)
    {
        //
        // the logon failed, but we get to try again with a different format
        //
        hToken = ValidateUser( pszD2,
                               pszUserOnly,
                               pszPassword,
                               *pfAsAnonymous,
                               pfAsGuest,
                               pTAI->dwLogonMethod,
                               pszWorkstation,
                               pExpiry,
                               pfExpiryAvailable,
                               !pTAI->fDontUseAnonSubAuth
                              );
    }

    strAnonPwd.Clear();

    if( hToken == NULL )
    {
        STR          strError;
        const CHAR * psz[2];
        DWORD        dwErr = GetLastError();

        psi->LoadStr( strError, dwErr, FALSE );

        psz[0] = pszUser;
        psz[1] = strError.QueryStr();

        psi->m_Service->LogEvent(
                        INET_SVCS_FAILED_LOGON,
                        2,
                        psz,
                        dwErr );

        //
        //  Validation failure.
        //

        if ( dwErr == ERROR_LOGON_TYPE_NOT_GRANTED ||
             dwErr == ERROR_ACCOUNT_DISABLED )
        {
            SetLastError( ERROR_ACCESS_DENIED );
        }
        else
        {
            //
            // Reset LastError(), as LogEvent() may have overwritten it
            // e.g log is full
            //

            SetLastError( dwErr );
        }

        return NULL;
    }

    //
    //  Success!
    //

    return hToken;

InvalidParamError:
    return NULL;

}   // TsLogonUser

/*******************************************************************

    NAME:       ValidateUser

    SYNOPSIS:   Validate a given domain/user/password tuple.

    ENTRY:      pszDomainName - The user's domain (NULL = current).

                pszUserName - The user's name.

                pszPassword - The user's (plaintext) password.

                fAnonymous - TRUE if this is the anonymous user

                pfAsGuest - Will receive TRUE if the user was validated
                    with guest privileges.

                dwLogonMethod - interactive or batch

                pszWorkstation - workstation name for remote user
                    can be NULL if default ( local computer) to be used

                pExpiry - updated with pwd expiration date/time

                pfExpiryAvailable - updated with TRUE if pwd expiration
                                    date/time available

                fUseSubAuthIfAnonymous - TRUE if logon anonymous user
                                         using IIS sub-auth

    RETURNS:    HANDLE - An impersonation token, NULL if user cannot
                    be validated.  Call GetLastError for more information.

    HISTORY:
        KeithMo     07-Mar-1993 Created.

********************************************************************/
TS_TOKEN ValidateUser(
    PCHAR  pszDomainName,
    PCHAR  pszUserName,
    PCHAR  pszPassword,
    BOOL   fAnonymous,
    BOOL * pfAsGuest,
    DWORD  dwLogonMethod,
    CHAR * pszWorkstation,
    LARGE_INTEGER * pExpiry,
    BOOL * pfExpiryAvailable,
    BOOL   fUseSubAuthIfAnonymous
    )
{
    CACHED_TOKEN * pct = NULL;
    HANDLE         hToken;
    HANDLE         hImpersonationToken = NULL;
    BOOL           fExpiry = FALSE;
    DWORD          dwSubAuth = 0;
    CHAR           achCookie[32];
    BOOL           fExist;

    if ( pfExpiryAvailable )
    {
        *pfExpiryAvailable = FALSE;
    }

    if ( fAnonymous && fUseSubAuthIfAnonymous )
    {
        if ( !pfnNetUserCookieA( pszUserName,
                              IIS_SUBAUTH_SEED,
                              achCookie,
                              sizeof(achCookie ) ) )
        {
            return FALSE;
        }

        dwSubAuth = IIS_SUBAUTH_ID;
        pszPassword = achCookie;
        dwLogonMethod = LOGON32_LOGON_IIS_NETWORK;
    }

    //
    //  Is it in the cache?  References the token if we find it
    //

    if ( FindCachedToken( pszUserName,
                          pszDomainName,
                          pszPassword,
                          fAnonymous,    // Reset the TTL if anonymous
                          fAnonymous && fUseSubAuthIfAnonymous,
                          dwLogonMethod,
                          &pct ))
    {
        *pfAsGuest = pct->IsGuest();

        if ( NULL != pExpiry) {
            memcpy( pExpiry, pct->QueryExpiry(), sizeof(LARGE_INTEGER) );
        }

        if ( pfExpiryAvailable )
        {
            *pfExpiryAvailable = TRUE;
        }

        return pct;
    }

    if ( (dwLogonMethod == LOGON32_LOGON_NETWORK ||
          dwLogonMethod == LOGON32_LOGON_BATCH ||
          dwLogonMethod == LOGON32_LOGON_INTERACTIVE ||
          dwLogonMethod == LOGON32_LOGON_IIS_NETWORK ||
          dwLogonMethod == LOGON32_LOGON_NETWORK_CLEARTEXT ) &&
          ( !g_fUseAdvapi32Logon || dwSubAuth == IIS_SUBAUTH_ID ) )
    {
        if ( !pfnLogonNetUserA( pszUserName,
                             pszDomainName,
                             pszPassword,
                             pszWorkstation,
                             dwSubAuth,
                             dwLogonMethod,
                             LOGON32_PROVIDER_DEFAULT,
                             &hToken,
                             pExpiry ))
        {
            if ( fAnonymous &&
                 ( GetLastError() == ERROR_LOGON_TYPE_NOT_GRANTED ) &&
                 ( dwLogonMethod == LOGON32_LOGON_INTERACTIVE ) )
            {
                // try again

                dwLogonMethod = LOGON32_LOGON_BATCH;

                if ( !pfnLogonNetUserA( pszUserName,
                                        pszDomainName,
                                        pszPassword,
                                        pszWorkstation,
                                        dwSubAuth,
                                        dwLogonMethod,
                                        LOGON32_PROVIDER_DEFAULT,
                                        &hToken,
                                        pExpiry ))
                {
                    return NULL;
                }
            }
            else
            {
                return NULL;
            }
        }

        fExpiry = TRUE;

        if ( pfExpiryAvailable )
        {
            *pfExpiryAvailable = TRUE;
        }
    }
    else
    {
        if ( !LogonUserA( pszUserName,
                          pszDomainName,
                          pszPassword,
                          dwLogonMethod,
                          LOGON32_PROVIDER_WINNT50,
                          &hToken ))
        {
            return NULL;
        }
    }

    if ( dwLogonMethod == LOGON32_LOGON_NETWORK ||
         dwLogonMethod == LOGON32_LOGON_IIS_NETWORK ||
         dwLogonMethod == LOGON32_LOGON_NETWORK_CLEARTEXT )
    {
        hImpersonationToken = hToken;

        if ( !pfnDuplicateTokenEx( hImpersonationToken,
                                TOKEN_ALL_ACCESS,
                                NULL,
                                SecurityDelegation,
                                TokenPrimary,
                                &hToken ))
        {
            if ( !pfnDuplicateTokenEx( hImpersonationToken,
                                    TOKEN_ALL_ACCESS,
                                    NULL,
                                    SecurityImpersonation,
                                    TokenPrimary,
                                    &hToken ))
            {
                CloseHandle( hImpersonationToken );
                return NULL;
            }
        }
    }

    *pfAsGuest = IsGuestUser(hToken);

    //
    //  Add this new token to the cache, hToken gets replaced by the
    //  cached token object
    //

    if ( !AddTokenToCache( pszUserName,
                           pszDomainName,
                           pszPassword,
                           fAnonymous && fUseSubAuthIfAnonymous,
                           hToken,
                           dwLogonMethod,
                           &pct,
                           g_fAlwaysCheckForDuplicateLogon | fAnonymous,
                           &fExist ))
    {
        if ( hImpersonationToken != NULL )
        {
            CloseHandle( hImpersonationToken );
        }
        CloseHandle( hToken );
        return NULL;
    }

    pct->SetGuest(*pfAsGuest);
    if ( fExpiry )
    {
        pct->SetExpiry( pExpiry );
    }

    //
    // DuplicateToken() apparently returns an impersonated token
    // so it is not necessary to call pfnDuplicateTokenEx
    //

    if ( !fExist )
    {
        if ( hImpersonationToken == NULL
             && !pfnDuplicateTokenEx( hToken,      // hSourceToken
                                   TOKEN_ALL_ACCESS,
                                   NULL,
                                   SecurityDelegation,  // Obtain impersonation
                                   TokenImpersonation,
                                   &hImpersonationToken)  // hDestinationToken
            ) {
            if ( !pfnDuplicateTokenEx( hToken,      // hSourceToken
                                       TOKEN_ALL_ACCESS,
                                       NULL,
                                       SecurityImpersonation,  // Obtain impersonation
                                       TokenImpersonation,
                                       &hImpersonationToken)  // hDestinationToken
                ) {
                hImpersonationToken = NULL;
            }
        }

        // Bug 86489:
        // Grant all access to the token for "Everyone" so that ISAPIs that run out of proc
        // can do an OpenThreadToken call
        if (FAILED( GrantAllAccessToToken( hImpersonationToken ) ) )
        {
            CloseHandle( hImpersonationToken );
            DBG_ASSERT( FALSE );
            return NULL;
        }

        pct->SetImpersonationToken( hImpersonationToken);
    }
    else if ( hImpersonationToken )
    {
        CloseHandle( hImpersonationToken );
    }

    return pct;

}   // ValidateUser





# define MAX_TOKEN_USER_INFO   (300)
BOOL
IsGuestUser(IN HANDLE hToken)
/*++
  Given a user token, this function determines if the token belongs
   to a guest user. It returns true if the token is a guest user token.

  Arguments:
    hToken  - handle for the Security token for a user.


  Returns:
    BOOL.

  History:
    MuraliK   22-Jan-1996   Created.
--*/
{
    BOOL fGuest = FALSE;
    BYTE rgbInfo[MAX_TOKEN_USER_INFO];
    DWORD cbTotalRequired;

    //
    // Get the user information associated with the token.
    // Using this we can then query to find out if it belongs to a guest user.
    //

    if (GetTokenInformation( hToken,
                            TokenUser,
                            (LPVOID ) rgbInfo,
                            MAX_TOKEN_USER_INFO,
                            &cbTotalRequired)
        ) {

        TOKEN_USER * pTokenUser = (TOKEN_USER *) rgbInfo;
        PSID pSid = pTokenUser->User.Sid;

        fGuest = EqualSid( pSid, g_psidGuestUser);

    } else {

        IF_DEBUG( DLL_SECURITY) {

            DBGPRINTF(( DBG_CONTEXT,
                       "GetTokenInformation(%08x) failed. Error = %d."
                       " sizeof(TOKEN_USER) = %d, cb = %d\n",
                       hToken,
                       GetLastError(),
                       sizeof(TOKEN_USER), cbTotalRequired
                       ));
        }
    }

    return ( fGuest);

} // IsGuestUser()


/*******************************************************************

    NAME:       TsImpersonateUser

    SYNOPSIS:   Causes the current thread to impersonate the user
                represented by the given impersonation token.

    ENTRY:      hToken - A handle to an impersonation token created
                    with ValidateUser.  This is actually a pointer to
                    a cached token object.

    RETURNS:    BOOL - TRUE if successful, FALSE otherwise.

    HISTORY:
        KeithMo     07-Mar-1993 Created.
        MuraliK     21-Feb-1996 Optimized Token caching

********************************************************************/
BOOL TsImpersonateUser( TS_TOKEN hToken )
{
    HANDLE  hTok;

    IF_DEBUG( DLL_SECURITY )
    {
        DBGPRINTF(( DBG_CONTEXT,
                   "impersonating user token %08lX : Imperonation(%08lx)\n",
                   CTO_TO_TOKEN(hToken),
                   ((CACHED_TOKEN *) hToken)->QueryImpersonationToken()
                   ));
    }

    hTok = ((CACHED_TOKEN *) hToken)->QueryImpersonationToken();
    if ( hTok == NULL) {
        // if there is no impersonation token use the normal token itself.
        hTok = CTO_TO_TOKEN(hToken);
    }

#if DBG
    if( !ImpersonateLoggedOnUser( hTok ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                   "cannot impersonate user token %08lX, error %08lX\n",
                    CTO_TO_TOKEN(hToken),
                    GetLastError() ));
        return FALSE;
    }

    return TRUE;

# else

    return ( ImpersonateLoggedOnUser(hTok));

# endif // DBG

}   // TsImpersonateUser

/*******************************************************************

    NAME:       TsDeleteUserToken

    SYNOPSIS:   Deletes a token created with ValidateUser.

    ENTRY:      hToken - An impersonation token created with
                    ValidateUser.

    RETURNS:    BOOL - TRUE if successful, FALSE otherwise.

    HISTORY:
        KeithMo     07-Mar-1993 Created.

********************************************************************/
BOOL TsDeleteUserToken(
    TS_TOKEN    hToken
    )
{
    NTSTATUS ntStatus = STATUS_SUCCESS;

    CACHED_TOKEN::Dereference( (CACHED_TOKEN *) hToken );

    return TRUE;
}   // DeleteUserToken

HANDLE
TsTokenToHandle(
    TS_TOKEN    hToken
    )
/*++
  Description:

    Converts the token object into a real impersonation handle

  Arguments:

    hToken - pointer to cached token object

  Returns:
      Handle of real impersonation token
--*/
{
    DBG_ASSERT( hToken != NULL );

    return CTO_TO_TOKEN( hToken );
}


HANDLE
TsTokenToImpHandle(
    TS_TOKEN    hToken
    )
/*++
  Description:

    Converts the token object into an impersonation handle

  Arguments:

    hToken - pointer to cached token object

  Returns:
      Handle of impersonation token
--*/
{
    DBG_ASSERT( hToken != NULL );

    return CTO_TO_IMPTOKEN( hToken );
}

BOOL
BuildAnonymousAcctDesc(
    PTCP_AUTHENT_INFO pTAI
    )
/*++

Routine Description:

    Builds the anonymous account description based on the authentication
    info structure.

Arguments:

    pTAI - Pointer to authentication info to build

Returns:

    TRUE if Success, FALSE otherwise

--*/
{
    STACK_STATSTR (strDomainAndUser, IIS_DNLEN+UNLEN+2);
    STACK_STATSTR (strPassword, PWLEN+1);
    PCHAR   pszUserOnly;
    PCHAR   pszDomain;
    CHAR    achAcctDesc[MAX_ACCT_DESC_LEN];
    DWORD   cbDescLen;
    BOOL    RetVal;


    if ( g_fUseSingleToken ) {
        pTAI->cbAnonAcctDesc = 0;
        return TRUE;
    }

    if ( !pTAI->strAnonUserName.Clone( &strDomainAndUser) ||
         !pTAI->strAnonUserPassword.Clone( &strPassword) )
    {
        RetVal = FALSE;
        goto BuildAnonymousAcctDesc_exit;
    }

    // if the password is stored hashed, unhash it for usage
    if (pTAI->fPwdIsHashed) {
        strPassword.Unhash();
    }

    if ( !CrackUserAndDomain( strDomainAndUser.QueryStr(),
                              &pszUserOnly,
                              &pszDomain ))
    {
        DBGPRINTF((DBG_CONTEXT,
            "BuildAnonymousAcctDesc: Call to CrackUserAndDomain failed\n"));

        RetVal = FALSE;
        goto BuildAnonymousAcctDesc_exit;
    }

    if ( !BuildAcctDesc( pszUserOnly,
                         pszDomain,
                         strPassword.QueryStr(),
                         !pTAI->fDontUseAnonSubAuth,
                         achAcctDesc,
                         &pTAI->cbAnonAcctDesc ) ||
         !pTAI->bAnonAcctDesc.Resize( pTAI->cbAnonAcctDesc ))
    {
        RetVal = FALSE;
        goto BuildAnonymousAcctDesc_exit;
    }

    memcpy( pTAI->bAnonAcctDesc.QueryPtr(),
            achAcctDesc,
            pTAI->cbAnonAcctDesc );

    RetVal = TRUE;

BuildAnonymousAcctDesc_exit:

    strPassword.Clear();

    return RetVal;
}

BOOL
BuildAcctDesc(
    IN  const CHAR *     pszUser,
    IN  const CHAR *     pszDomain,
    IN  const CHAR *     pszPwd,
    IN  BOOL             fUseSubAuth,
    OUT CHAR  *          pchAcctDesc,
    OUT LPDWORD          pdwAcctDescLen
    )
/*++
  Description:

    Builds a cache descriptor for account cache

  Arguments:

    pszUser - User name attempting to logon
    pszDomain - Domain the user belongs to
    pszPwd - password (case sensitive)
    fUseSubAuth - TRUE if sub-authenticator used
    pchAcctDesc - updated with descriptor
    pdwAcctDescLen - updated with descriptor length

  Returns:
      TRUE on success, otherwise FALSE

--*/
{
    if ( fUseSubAuth )
    {
        pszPwd = "";
    }

    size_t lU = strlen( pszUser ) + 1;
    size_t lD = strlen( pszDomain ) + 1;
    size_t lP = strlen( pszPwd ) + 1;

    if ( lU > (UNLEN+1) ||
         lD > (IIS_DNLEN+1) ||
         lP > (PWLEN+1) )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    *pdwAcctDescLen = (DWORD)(1 + lU + lD + lP);

    LPBYTE pD = (BYTE *) pchAcctDesc;

    *pD++ = (BYTE)fUseSubAuth;

    memcpy( pD, pszUser, lU );
    CharLower( (LPSTR)pD );

    memcpy( pD + lU, pszDomain, lD );
    _strlwr( (LPSTR)(pD+lU) );

    memcpy( pD + lU + lD, pszPwd, lP );

    DBG_ASSERT( (lU + lD + lP) < MAX_ACCT_DESC_LEN );
    return TRUE;
}


BOOL
FindCachedToken(
    IN  const CHAR *     pszUser,
    IN  const CHAR *     pszDomain,
    IN  const CHAR *     pszPwd,
    IN  BOOL             fResetTTL,
    IN  BOOL             fUseSubAuth,
    IN  DWORD            dwLogonMethod,
    OUT CACHED_TOKEN * * ppct
    )
/*++
  Description:

    Checks to see if the specified user token handle is cached

  Arguments:

    pszUser - User name attempting to logon
    pszDomain - Domain the user belongs to
    pszPwd - password (case sensitive)
    fResetTTL - Resets the TTL for this token
    fUseSubAuth - TRUE if sub-authenticator used
    dwLogonMethod - Logon method (Batch, Interactive, Network)
    ppct - Receives token object

  Returns:
      TRUE on success and FALSE if the entry couldn't be found

--*/
{
    LIST_ENTRY *   pEntry;
    CACHED_TOKEN * pct;
    CHAR           achAcctDesc[MAX_ACCT_DESC_LEN];
    DWORD          dwAcctDescLen;
    LPBYTE         pAcctDesc;

    DBG_ASSERT( pszUser != NULL );

    if ( !BuildAcctDesc( pszUser, pszDomain, pszPwd, fUseSubAuth, achAcctDesc, &dwAcctDescLen) )
    {
        return FALSE;
    }

    DBG_ASSERT( dwAcctDescLen < sizeof(achAcctDesc ));

    pAcctDesc = (LPBYTE)achAcctDesc;

    LockTokenCache();

    for ( pEntry  = TokenCacheList.Flink;
          pEntry != &TokenCacheList;
          pEntry  = pEntry->Flink )
    {
        pct = CONTAINING_RECORD( pEntry, CACHED_TOKEN, _ListEntry );

        if ( pct->m_dwAcctDescLen == dwAcctDescLen &&
             pct->m_dwLogonMethod == dwLogonMethod &&
             !memcmp( pct->_achAcctDesc, pAcctDesc, dwAcctDescLen ) )
        {
            CACHED_TOKEN::Reference( pct );
            *ppct = pct;

            //
            //  Reset the TTL if this is the anonymous user so items in the
            //  cache don't get invalidated (token handle used as a
            //  discriminator)

            if ( fResetTTL )
            {
                pct->_TTL = 2;
            }

            UnlockTokenCache();

            return TRUE;
        }

        if( !_stricmp( pct->m_achUserName, pszUser )     &&
            !_stricmp( pct->m_achDomainName, pszDomain ) &&
            pct->m_dwLogonMethod == dwLogonMethod )
        {
            UnlockTokenCache();

            RemoveTokenFromCache( pct );

            return FALSE;
        }
    }

    UnlockTokenCache();

    return FALSE;

} // FindCachedToken



TS_TOKEN
FastFindAnonymousToken(
    IN PTCP_AUTHENT_INFO    pTAI
    )
/*++

  Description:

    Checks to see if the specified anonymous user token handle is cached.

    Don't call this function when using the sub-authenticator!

  Arguments:

    pTAI - pointer to the anonymous authentication info

  Returns:
      Pointer to the cached object.

--*/
{
    LIST_ENTRY *   pEntry;
    CACHED_TOKEN * pct;

    LockTokenCache();

    for ( pEntry  = TokenCacheList.Flink;
          pEntry != &TokenCacheList;
          pEntry  = pEntry->Flink ) {

        pct = CONTAINING_RECORD( pEntry, CACHED_TOKEN, _ListEntry );

        DBG_ASSERT(pct->m_dwAcctDescLen > 0);

        if ( (pct->m_dwAcctDescLen == pTAI->cbAnonAcctDesc ) &&
             RtlEqualMemory(
                    pct->_achAcctDesc,
                    pTAI->bAnonAcctDesc.QueryPtr(),
                    pct->m_dwAcctDescLen ) ) {

            CACHED_TOKEN::Reference( pct );

            //
            //  Reset the TTL if this is the anonymous user so items in the
            //  cache don't get invalidated (token handle used as a
            //  discriminator)

            pct->_TTL = 2;

            UnlockTokenCache();
            return pct;
        }
    }

    UnlockTokenCache();
    return NULL;
} // FastFindAnonymousToken



BOOL
AddTokenToCache(
    IN const CHAR *      pszUser,
    IN const CHAR *      pszDomain,
    IN const CHAR *      pszPwd,
    IN BOOL              fUseSubAuth,
    IN HANDLE            hToken,
    IN DWORD             dwLogonMethod,
    OUT CACHED_TOKEN * * ppct,
    BOOL                 fCheckAlreadyExist,
    LPBOOL               pfExist
    )
/*++
  Description:

    Adds the specified token to the cache and converts the token handle
    to a cached token object

  Arguments:

    pszUser - User name attempting to logon
    pszDomain - Domain the user belongs to
    pszPwd - Cast sensitive password
    fUseSubAuth - TRUE if subauth to be used
    phToken - Contains the token handle that was just logged on
    dwLogonMethod - Logon Method
    ppct - Receives cached token object
    fCheckAlreadyExist - check if entry with same name already exist
    pfExist - updated with TRUE if acct already exists

  Returns:
      TRUE on success and FALSE if the entry couldn't be found

--*/
{
    LIST_ENTRY *    pEntry;
    CACHED_TOKEN *  pctF;
    CACHED_TOKEN *  pct;
    DWORD           dwAcctDescLen;
    BOOL            fFound = FALSE;
    CHAR            achAcctDesc[MAX_ACCT_DESC_LEN];

    DBG_ASSERT( pszUser != NULL );

    if( ( strlen( pszUser ) >= UNLEN ) ||
        ( strlen( pszDomain ) >= IIS_DNLEN ) )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    if ( !BuildAcctDesc( pszUser, pszDomain, pszPwd, fUseSubAuth, achAcctDesc, &dwAcctDescLen) )
    {
        return FALSE;
    }

    pct = new CACHED_TOKEN;

    if ( !pct )
    {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return FALSE;
    }

    pct->_hToken = hToken;
    pct->m_hImpersonationToken = NULL;         // initialize to invalid value
    CopyMemory( pct->_achAcctDesc, achAcctDesc, dwAcctDescLen );
    pct->m_dwAcctDescLen = dwAcctDescLen;
    pct->m_dwLogonMethod = dwLogonMethod;

    strcpy( pct->m_achUserName, pszUser );
    strcpy( pct->m_achDomainName, pszDomain );

    //
    //  Add the token to the list, we check for duplicates at callers's request
    //

    LockTokenCache();

    if ( fCheckAlreadyExist )
    {
        for ( pEntry  = TokenCacheList.Flink;
              pEntry != &TokenCacheList;
              pEntry  = pEntry->Flink )
        {
            pctF = CONTAINING_RECORD( pEntry, CACHED_TOKEN, _ListEntry );

            if ( pctF->m_dwAcctDescLen == dwAcctDescLen &&
                 !memcmp( pctF->_achAcctDesc, pct->_achAcctDesc, dwAcctDescLen ) &&
                 pctF->m_dwLogonMethod == dwLogonMethod )
            {
                fFound = TRUE;
                break;
            }
        }
    }

    *pfExist = fFound;

    if ( !fFound )
    {
        InsertHeadList( &TokenCacheList, &pct->_ListEntry );
    }
    else
    {
        // delete cache item ( was not yet on list )

        CACHED_TOKEN::Dereference( pct );

        pct = pctF;
    }

    CACHED_TOKEN::Reference( pct );

    UnlockTokenCache();

    *ppct = pct;

    return TRUE;
} // AddTokenToCache




VOID
RemoveTokenFromCache( IN CACHED_TOKEN *  pct)
{
    DBG_ASSERT( pct != NULL);
    LockTokenCache();

    //
    //  Remove from the list
    //

    if ( pct->_ListEntry.Flink )
    {
        RemoveEntryList( &pct->_ListEntry );
        pct->_ListEntry.Flink = NULL;

        //
        //  Free any handles this user may still have open
        //

        TsCacheFlushUser( pct->_hToken, FALSE );

        CACHED_TOKEN::Dereference( pct );
    }

    UnlockTokenCache();

    return;
} // RemoveTokenFromCache()



VOID
WINAPI
TokenCacheScavenger(
    IN VOID * /* pContext */
    )
/*++
  Description:

    Decrements TTLs and removes tokens that have timed out

  Arguments:

    pContext - Not used

--*/
{
    LIST_ENTRY *   pEntry;
    LIST_ENTRY *   pEntryNext;
    CACHED_TOKEN * pct;


    LockTokenCache();

    for ( pEntry  = TokenCacheList.Flink;
          pEntry != &TokenCacheList; )
    {
        pEntryNext = pEntry->Flink;

        pct = CONTAINING_RECORD( pEntry, CACHED_TOKEN, _ListEntry );

        if ( !(--pct->_TTL) )
        {
            IF_DEBUG( DLL_SECURITY )
            {
                DBGPRINTF(( DBG_CONTEXT,
                           "[TokenCacheScavenger] Timing out token for %s\n",
                           pct->_achAcctDesc ));
            }

            //
            //  This item has timed out, remove from the list
            //

            RemoveEntryList( &pct->_ListEntry );
            pct->_ListEntry.Flink = NULL;

            //
            //  Free any handles this user may still have open
            //

            TsCacheFlushUser( pct->_hToken, FALSE );

            CACHED_TOKEN::Dereference( pct );
        }

        pEntry = pEntryNext;
    }

    UnlockTokenCache();

} // TokenCacheScavenger


BOOL
TsGetSecretW(
    WCHAR *       pszSecretName,
    BUFFER *      pbufSecret
    )
/*++
    Description:

        Retrieves the specified unicode secret

    Arguments:

        pszSecretName - LSA Secret to retrieve
        pbufSecret - Receives found secret

    Returns:
        TRUE on success and FALSE if any failure.

--*/
{
    BOOL              fResult;
    NTSTATUS          ntStatus;
    PUNICODE_STRING   punicodePassword = NULL;
    UNICODE_STRING    unicodeSecret;
    LSA_HANDLE        hPolicy;
    OBJECT_ATTRIBUTES ObjectAttributes;

    if ( pfnLsaOpenPolicy == NULL ) {
        DBGPRINTF((DBG_CONTEXT,"LsaOpenPolicy does not exist on win95\n"));
        SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
        return(FALSE);
    }

    //
    //  Open a policy to the remote LSA
    //

    InitializeObjectAttributes( &ObjectAttributes,
                                NULL,
                                0L,
                                NULL,
                                NULL );

    ntStatus = pfnLsaOpenPolicy( NULL,
                              &ObjectAttributes,
                              POLICY_ALL_ACCESS,
                              &hPolicy );

    if (  !NT_SUCCESS( ntStatus ) )
    {
        SetLastError( pfnLsaNtStatusToWinError( ntStatus ) );
        return FALSE;
    }

    InitUnicodeString( &unicodeSecret, pszSecretName );

    //
    //  Query the secret value.
    //

    ntStatus = pfnLsaRetrievePrivateData( hPolicy,
                                       &unicodeSecret,
                                       &punicodePassword );

    if( NT_SUCCESS(ntStatus) )
    {
        DWORD cbNeeded;

        cbNeeded = punicodePassword->Length + sizeof(WCHAR);

        if ( !pbufSecret->Resize( cbNeeded ) )
        {
            ntStatus = STATUS_NO_MEMORY;
            goto Failure;
        }

        CopyMemory(
            pbufSecret->QueryPtr(),
            punicodePassword->Buffer,
            punicodePassword->Length
            );

        *((WCHAR *) pbufSecret->QueryPtr() +
           punicodePassword->Length / sizeof(WCHAR)) = L'\0';

        ZeroMemory( punicodePassword->Buffer,
                    punicodePassword->MaximumLength );

    }

Failure:

    fResult = NT_SUCCESS(ntStatus);

    //
    //  Cleanup & exit.
    //

    if( punicodePassword != NULL )
    {
        pfnLsaFreeMemory( (PVOID)punicodePassword );
    }

    pfnLsaClose( hPolicy );

    if ( !fResult )
    {
        SetLastError( pfnLsaNtStatusToWinError( ntStatus ));
    }

    return fResult;
}   // TsGetSecretW


DWORD
TsSetSecretW(
    IN  LPWSTR       SecretName,
    IN  LPWSTR       pSecret,
    IN  DWORD        cbSecret
    )
/*++

   Description

     Sets the specified LSA secret

   Arguments:

     SecretName - Name of the LSA secret
     pSecret - Pointer to secret memory
     cbSecret - Size of pSecret memory block

   Note:

--*/
{
    LSA_HANDLE        hPolicy;
    UNICODE_STRING    unicodePassword;
    UNICODE_STRING    unicodeServer;
    NTSTATUS          ntStatus;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING    unicodeSecret;


    InitUnicodeString( &unicodeServer,
                       L"" );

    //
    //  Initialize the unicode string by hand so we can handle '\0' in the
    //  string
    //

    unicodePassword.Buffer        = pSecret;
    unicodePassword.Length        = (USHORT) cbSecret;
    unicodePassword.MaximumLength = (USHORT) cbSecret;

    //
    //  Open a policy to the remote LSA
    //

    InitializeObjectAttributes( &ObjectAttributes,
                                NULL,
                                0L,
                                NULL,
                                NULL );

    ntStatus = pfnLsaOpenPolicy( &unicodeServer,
                                 &ObjectAttributes,
                                 POLICY_ALL_ACCESS,
                                 &hPolicy );

    if ( !NT_SUCCESS( ntStatus ) )
        return pfnLsaNtStatusToWinError( ntStatus );

    //
    //  Create or open the LSA secret
    //

    InitUnicodeString( &unicodeSecret,
                       SecretName );

    ntStatus = pfnLsaStorePrivateData( hPolicy,
                                       &unicodeSecret,
                                       &unicodePassword );

    pfnLsaClose( hPolicy );

    if ( !NT_SUCCESS( ntStatus ))
    {
        return pfnLsaNtStatusToWinError( ntStatus );
    }

    return NO_ERROR;
} // TsSetSecretW()

/*******************************************************************

    NAME:       ApiAccessCheck

    SYNOPSIS:   Impersonate the RPC client, then check for valid
                access against our server security object.

    ENTRY:      maskDesiredAccess - Specifies the desired access mask.
                    This mask must not contain generic accesses.

    RETURNS:    DWORD - NO_ERROR if access granted, ERROR_ACCESS_DENIED
                    if access denied, other Win32 errors if something
                    tragic happened.

    HISTORY:
        KeithMo     26-Mar-1993 Created.

********************************************************************/
DWORD TsApiAccessCheck( ACCESS_MASK maskDesiredAccess )
{
    DWORD          err;
    BOOL           fRet;

    if ( maskDesiredAccess == TCP_QUERY_STATISTICS) {

        //
        // Statistics query should be allowed without authentication.
        // Any body can bring up perfmon and request statistics.
        //

        return ( NO_ERROR);
    }

    //
    //  Impersonate the RPC client.
    //

    err = (DWORD)RpcImpersonateClient( NULL );

    if( err != NO_ERROR )
    {
        IF_DEBUG( DLL_SECURITY )
        {
            DBGPRINTF(( DBG_CONTEXT,
                       "cannot impersonate rpc client, error %lu\n",
                        err ));
        }

    } else {

        BOOL           fAccessStatus;
        BOOL           fGenerateOnClose;
        ACCESS_MASK    maskAccessGranted = 0;

        //
        //  Validate access.
        //

        if ( g_fUseSingleToken )
        {
            HANDLE  hAccToken;
            BYTE    Set[256];
            DWORD   dwSet = sizeof(Set);

            if ( OpenThreadToken( GetCurrentThread(), TOKEN_READ, TRUE, &hAccToken ) )
            {
                fRet = AccessCheck( sdApiObject,
                                    hAccToken,
                                    maskDesiredAccess,
                                    &TCPApiObjectMapping,
                                    (PPRIVILEGE_SET)&Set,
                                    &dwSet,
                                    &maskAccessGranted,
                                    &fAccessStatus );

                CloseHandle( hAccToken );
            }
            else
            {
                fRet = FALSE;
            }
        }
        else
        {
            fRet = AccessCheckAndAuditAlarmW( SUBSYSTEM_NAME,
                                             NULL,
                                             OBJECTTYPE_NAME,
                                             OBJECT_NAME,
                                             sdApiObject,
                                             maskDesiredAccess,
                                             &TCPApiObjectMapping,
                                             FALSE,
                                             &maskAccessGranted,
                                             &fAccessStatus,
                                             &fGenerateOnClose );
        }

        if ( !fRet ) {

            err = GetLastError();
        }

        //
        //  Revert to our former self.
        //

        DBG_REQUIRE( !RpcRevertToSelf() );

        //
        //  Check the results.
        //

        if( err != NO_ERROR ) {

            IF_DEBUG( DLL_SECURITY ) {

                DBGPRINTF(( DBG_CONTEXT,
                           "cannot check access, error %lu\n",
                           err ));
            }
        } else if( !fAccessStatus ) {

            err = ERROR_ACCESS_DENIED;

            IF_DEBUG( DLL_SECURITY ) {

                DBGPRINTF(( DBG_CONTEXT,
                           "bad access status, error %lu\n",
                           err ));
            }
        }
    }

    return (err);

}   // ApiAccessCheck

/*******************************************************************

    NAME:       CreateWellKnownSids

    SYNOPSIS:   Create some well-known SIDs used to create a security
                descriptor for the API security object.

    RETURNS:    NTSTATUS - An NT Status code.

    HISTORY:
        KeithMo     26-Mar-1993 Created.

********************************************************************/

DWORD CreateWellKnownSids( HINSTANCE hDll )
{
    DWORD                    error    = NO_ERROR;
    SID_IDENTIFIER_AUTHORITY siaWorld = SECURITY_WORLD_SID_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY siaNt    = SECURITY_NT_AUTHORITY;
    BOOL                     fRet;

    fRet = AllocateAndInitializeSid( &siaWorld,
                                     1,
                                     SECURITY_WORLD_RID,
                                     0,0,0,0,0,0,0,
                                     &psidWorld );

    if( fRet )
    {
        fRet = AllocateAndInitializeSid( &siaNt,
                                         1,
                                         SECURITY_LOCAL_SYSTEM_RID,
                                         0,0,0,0,0,0,0,
                                         &psidLocalSystem );
    }

    if( fRet )
    {
        fRet = AllocateAndInitializeSid( &siaNt,
                                         2,
                                         SECURITY_BUILTIN_DOMAIN_RID,
                                         DOMAIN_ALIAS_RID_ADMINS,
                                         0,0,0,0,0,0,
                                         &psidAdmins );
    }

    if( fRet )
    {
        fRet = AllocateAndInitializeSid( &siaNt,
                                         2,
                                         SECURITY_BUILTIN_DOMAIN_RID,
                                         DOMAIN_ALIAS_RID_SYSTEM_OPS,
                                         0,0,0,0,0,0,
                                         &psidServerOps );
    }

    if( fRet )
    {
        fRet = AllocateAndInitializeSid( &siaNt,
                                         2,
                                         SECURITY_BUILTIN_DOMAIN_RID,
                                         DOMAIN_ALIAS_RID_POWER_USERS,
                                         0,0,0,0,0,0,
                                         &psidPowerUsers );
    }

    if( fRet )
    {
        USER_MODALS_INFO_2 * pUsrModals2 =  NULL;
        HINSTANCE   hInstance = NULL;
        NET_USER_MODALS_GET_FN pfnNetUserModalsGet = NULL;
        NET_API_BUFFER_FREE_FN pfnNetApiBufferFree = NULL;

        //
        // Construct well-known-sid for Guest User on the local computer
        //
        //  1) Obtain the sid for the local machine's domain
        //  2) copy domain sid to guest user sid
        //  3) append DOMAIN_USER_RID_GUEST to the domain sid in GuestUser sid.
        //

        g_psidGuestUser = (PSID ) g_GuestUserSidBuffer;

        hInstance = LoadLibrary("netapi32.dll");
        if ( hInstance != NULL ) {

            pfnNetUserModalsGet = (NET_USER_MODALS_GET_FN)
                GetProcAddress(hInstance,"NetUserModalsGet");
            pfnNetApiBufferFree = (NET_API_BUFFER_FREE_FN)
                GetProcAddress(hInstance,"NetApiBufferFree");
        }

        if ( (pfnNetUserModalsGet != NULL) &&
             (pfnNetApiBufferFree != NULL) ) {

            fRet = ( (pfnNetUserModalsGet(NULL,  // local computer
                                   2,      // get level 2 information
                                   (LPBYTE *) &pUsrModals2
                                   ) == 0)
                &&
                CopySid(GUEST_USER_SID_BUFFER_LEN - 4,// Buffer len
                        g_psidGuestUser,             // psidDestination
                        pUsrModals2->usrmod2_domain_id // obtain domain sid.
                        )
                );
        } else {

            DBGPRINTF((DBG_CONTEXT,"Unable to get netapi32 entrypoints\n"));
            fRet = FALSE;
        }

        //
        // if successful append the DOMAIN_USER_RID_GUEST.
        //

        if ( fRet) {

            DWORD lenSid = GetLengthSid( g_psidGuestUser);
            CHAR  nSubAuth;

            //
            //  There is no Win32 way to set a SID value.
            //  We will munge around on our own.
            //  Pretty dangerous thing to do :-(
            //

            // increment the number of sub authorities
            nSubAuth = *((UCHAR *) ((UCHAR *) g_psidGuestUser + 1));
            nSubAuth++;
            *((UCHAR *) ((UCHAR *) g_psidGuestUser + 1)) = nSubAuth;

            // Store the new sub authority (Domain User Rid for Guest).
            *((ULONG *) ((BYTE *) g_psidGuestUser + lenSid)) =
              DOMAIN_USER_RID_GUEST;
        } else {

            g_psidGuestUser = NULL;
        }

        if ( pUsrModals2 != NULL) {

            NET_API_STATUS ns = pfnNetApiBufferFree( (LPVOID )pUsrModals2);
            pUsrModals2 = NULL;
        }

        if ( hInstance != NULL ) {
            FreeLibrary(hInstance);
        }
    }

    if ( fRet && g_fUseSingleToken )
    {
        BYTE    abInfo[256];
        DWORD   dwInfo;

        if ( GetTokenInformation( g_hProcessPrimaryToken,
                                  TokenUser,
                                  abInfo,
                                  sizeof(abInfo),
                                  &dwInfo ) )
        {
            if ( !(g_psidProcessUser = (PSID)LocalAlloc( LMEM_FIXED,
                                                         GetLengthSid(((TOKEN_USER*)abInfo)->User.Sid))) )
            {
                fRet = FALSE;
            }
            else
            {
                memcpy ( g_psidProcessUser,
                         ((TOKEN_USER*)abInfo)->User.Sid,
                         GetLengthSid(((TOKEN_USER*)abInfo)->User.Sid) );
            }
        }
        else
        {
            fRet = FALSE;
        }
    }

    if ( !fRet ) {
        error = GetLastError( );
        IF_DEBUG( DLL_SECURITY ) {
            DBGPRINTF(( DBG_CONTEXT,
                       "cannot create well-known sids\n" ));
        }
    }

    return error;

}   // CreateWellKnownSids

/*******************************************************************

    NAME:       FreeWellKnownSids

    SYNOPSIS:   Frees the SIDs created with CreateWellKnownSids.

    HISTORY:
        KeithMo     26-Mar-1993 Created.

********************************************************************/
VOID FreeWellKnownSids( VOID )
{

    if( psidWorld != NULL )
    {
        FreeSid( psidWorld );
        psidWorld = NULL;
    }

    if( psidLocalSystem != NULL )
    {
        FreeSid( psidLocalSystem );
        psidLocalSystem = NULL;
    }

    if( psidAdmins != NULL )
    {
        FreeSid( psidAdmins );
        psidAdmins = NULL;
    }

    if( psidServerOps != NULL )
    {
        FreeSid( psidServerOps );
        psidServerOps = NULL;
    }

    if( psidPowerUsers != NULL )
    {
        FreeSid( psidPowerUsers );
        psidPowerUsers = NULL;
    }

    if( g_psidProcessUser != NULL )
    {
        LocalFree( g_psidProcessUser );
        g_psidProcessUser = NULL;
    }

}   // FreeWellKnownSids

/*******************************************************************

    NAME:       CreateApiSecurityObject

    SYNOPSIS:   Create an abstract security object used for validating
                user access to the TCP Server APIs.

    RETURNS:    NTSTATUS - An NT Status code.

    HISTORY:
        KeithMo     26-Mar-1993 Created.

********************************************************************/
DWORD CreateApiSecurityObject( VOID )
{
    DWORD err;
    ACE_DATA aces[] =
                 {
                     {
                         ACCESS_ALLOWED_ACE_TYPE,
                         0,
                         0,
                         TCP_ALL_ACCESS,
                         &psidLocalSystem
                     },

                     {
                         ACCESS_ALLOWED_ACE_TYPE,
                         0,
                         0,
                         TCP_ALL_ACCESS,
                         &psidAdmins
                     },

                     {
                         ACCESS_ALLOWED_ACE_TYPE,
                         0,
                         0,
                         TCP_ALL_ACCESS,
                         &psidServerOps
                     },

                     {
                         ACCESS_ALLOWED_ACE_TYPE,
                         0,
                         0,
                         TCP_ALL_ACCESS,
                         &psidPowerUsers
                     },
                     {
                         ACCESS_ALLOWED_ACE_TYPE,
                         0,
                         0,
                         TCP_GENERIC_EXECUTE,
                         &psidWorld
                     },
                     {
                         ACCESS_ALLOWED_ACE_TYPE,
                         0,
                         0,
                         TCP_GENERIC_EXECUTE,
                         &g_psidProcessUser
                     },

                 };

#define NUM_ACES (sizeof(aces) / sizeof(RTL_ACE_DATA))

    err = INetCreateSecurityObject( aces,
                                    (ULONG)(g_fUseSingleToken ? NUM_ACES : NUM_ACES-1),
                                    NULL,
                                    NULL,
                                    &TCPApiObjectMapping,
                                    &sdApiObject  );


    IF_DEBUG( DLL_SECURITY )
    {
        if( err )
        {
            DBGPRINTF(( DBG_CONTEXT,
                       "cannot create api security object, error %d\n",
                        err ));
        }
    }

    return err;

}   // CreateApiSecurityObject

/*******************************************************************

    NAME:       DeleteApiSecurityObject

    SYNOPSIS:   Frees the security descriptor created with
                CreateApiSecurityObject.

    HISTORY:
        KeithMo     26-Mar-1993 Created.

********************************************************************/
VOID DeleteApiSecurityObject( VOID )
{
    INetDeleteSecurityObject( &sdApiObject );

}   // DeleteApiSecurityObject



//
//  Short routine to enable the TcbPrivilege for testing services running
//  as an executable (rather then a service).  Note that the account
//  running the .exe must be added in User Manager's User Right's dialog
//  under "Act as part of the OS"
//

VOID EnableTcbPrivilege(
    VOID
    )
{
    HANDLE ProcessHandle = NULL;
    HANDLE TokenHandle = NULL;
    BOOL Result;
    LUID TcbValue;
    LUID AuditValue;
    TOKEN_PRIVILEGES * TokenPrivileges;
    CHAR buf[ 5 * sizeof(TOKEN_PRIVILEGES) ];

    ProcessHandle = OpenProcess(
                        PROCESS_QUERY_INFORMATION,
                        FALSE,
                        GetCurrentProcessId()
                        );

    if ( ProcessHandle == NULL ) {

        //
        // This should not happen
        //

        goto Cleanup;
    }


    Result = OpenProcessToken (
                 ProcessHandle,
                 TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                 &TokenHandle
                 );

    if ( !Result ) {

        //
        // This should not happen
        //

        goto Cleanup;

    }

    //
    // Find out the value of TakeOwnershipPrivilege
    //


    Result = LookupPrivilegeValue(
                 NULL,
                 "SeTcbPrivilege",
                 &TcbValue
                 );

    if ( !Result ) {

        goto Cleanup;
    }

    //
    //  Need this for RPC impersonation (calls NtAccessCheckAndAuditAlarm)
    //

    Result = LookupPrivilegeValue(
                 NULL,
                 "SeAuditPrivilege",
                 &AuditValue
                 );

    if ( !Result ) {

        goto Cleanup;
    }

    //
    // Set up the privilege set we will need
    //

    TokenPrivileges = (TOKEN_PRIVILEGES *) buf;

    TokenPrivileges->PrivilegeCount = 2;
    TokenPrivileges->Privileges[0].Luid = TcbValue;
    TokenPrivileges->Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
    TokenPrivileges->Privileges[1].Luid = AuditValue;
    TokenPrivileges->Privileges[1].Attributes = SE_PRIVILEGE_ENABLED;

    (VOID) AdjustTokenPrivileges (
                TokenHandle,
                FALSE,
                TokenPrivileges,
                sizeof(buf),
                NULL,
                NULL
                );

Cleanup:

    if ( TokenHandle )
    {
        CloseHandle( TokenHandle );
    }

    if ( ProcessHandle )
    {
        CloseHandle( ProcessHandle );
    }
}


BOOL CrackUserAndDomain(
    CHAR *   pszDomainAndUser,
    CHAR * * ppszUser,
    CHAR * * ppszDomain
    )
/*++

Routine Description:

    Given a user name potentially in the form domain\user, zero terminates
    the domain name and returns pointers to the domain name and the user name

Arguments:

    pszDomainAndUser - Pointer to user name or domain and user name
    ppszUser - Receives pointer to user portion of name
    ppszDomain - Receives pointer to domain portion of name

Return Value:

    TRUE if successful, FALSE otherwise (call GetLastError)

--*/
{
    static CHAR szDefaultDomain[MAX_COMPUTERNAME_LENGTH+1];
    // BUGBUG: how come this does not screw up multi domain per multi site???

    //
    //  Crack the name into domain/user components.
    //

    *ppszDomain = pszDomainAndUser;
    *ppszUser   = (PCHAR)_mbspbrk( (PUCHAR)pszDomainAndUser, (PUCHAR)"/\\" );

    if( *ppszUser == NULL )
    {
        //
        //  No domain name specified, just the username so we assume the
        //  user is on the local machine
        //

        if ( !*szDefaultDomain )
        {
            if ( !pfnGetDefaultDomainName( szDefaultDomain,
                                        sizeof(szDefaultDomain)))
            {
                return FALSE;
            }
        }

        *ppszDomain = szDefaultDomain;
        *ppszUser   = pszDomainAndUser;
    }
    else
    {
        //
        //  Both domain & user specified, skip delimiter.
        //

        **ppszUser = '\0';
        (*ppszUser)++;

        if( ( **ppszUser == '\0' ) ||
            ( **ppszUser == '\\' ) ||
            ( **ppszUser == '/' )  ||
            ( *pszDomainAndUser == '\0' ) )
        {
            //
            //  Name is of one of the following (invalid) forms:
            //
            //      "domain\"
            //      "domain\\..."
            //      "domain/..."
            //      "\username"
            //      "/username"
            //

            SetLastError( ERROR_INVALID_PARAMETER );
            return FALSE;
        }
    }

    return TRUE;
}


LONG
WINAPI
NullReferenceMapper(
    IN HMAPPER     *pMap
    )
/*++

Routine Description:

    Increment reference count to mapper

Arguments:

    pMap - ptr to mapper struct

Returns:

    Ref count

--*/
{
    DBG_ASSERT( ((IisMapper*)pMap)->dwSignature == IIS_MAPPER_SIGNATURE );

    return pfnInterlockedExchangeAdd( &((IisMapper*)pMap)->lRefCount, 1 ) + 1;
}


LONG
WINAPI
NullDeReferenceMapper(
    IN HMAPPER     *pMap
    )
/*++

Routine Description:

    Decrement reference count to mapper

Arguments:

    pMap - ptr to mapper struct

Returns:

    Ref count

--*/
{
    LONG l;

    DBG_ASSERT( ((IisMapper*)pMap)->dwSignature == IIS_MAPPER_SIGNATURE );

    if ( !(l = pfnInterlockedExchangeAdd( &((IisMapper*)pMap)->lRefCount, -1 ) - 1 ) )
    {
        LocalFree( pMap );
    }

    return l;
}


DWORD WINAPI NullGetIssuerList(
    HMAPPER        *phMapper,           // in
    VOID *          Reserved,           // in
    BYTE *          pIssuerList,       // out
    DWORD *         pcbIssuerList       // out
)
/*++

Routine Description:

    Called to retrieve the list of preferred cert issuers

Arguments:

    ppIssuer -- updated with ptr buffer of issuers
    pdwIssuer -- updated with issuers buffer size

Returns:

    TRUE if success, FALSE if error

--*/
{
    return SEC_E_UNSUPPORTED_FUNCTION;
}


DWORD WINAPI NullGetChallenge(
    HMAPPER         *pMap,              // in
    BYTE *          pAuthenticatorId,   // in
    DWORD           cbAuthenticatorId,  // in
    BYTE *          pChallenge,        // out
    DWORD *         pcbChallenge        // out
)
/*++

Routine Description:

    Get challenge for auth sequence

Arguments:

    Not used

Returns:

    FALSE ( not supported )

--*/
{
    DBG_ASSERT( ((IisMapper*)pMap)->dwSignature == IIS_MAPPER_SIGNATURE );

    return SEC_E_UNSUPPORTED_FUNCTION;
}


DWORD WINAPI NullMapCredential(
    HMAPPER *   phMapper,
    DWORD       dwCredentialType,
    const VOID* pCredential,        // in
    const VOID* pAuthority,         // in
    HLOCATOR *  phToken
)
/*++

Routine Description:

    Called to map a certificate to a NT account

Arguments:

    phMapper - ptr to mapper descriptor
    dwCredentialType -- type of credential
    pCredential - ptr to PCERT_CONTEXT for client cert
    pAuthority - ptr to PCERT_CONTEXT for Certifying authority
    phToken -- updated with impersonation access token

Returns:

    FALSE ( mapping always fail )

--*/
{
    DBG_ASSERT( ((IisMapper*)phMapper)->dwSignature == IIS_MAPPER_SIGNATURE );

    return SEC_E_UNSUPPORTED_FUNCTION;
}


DWORD WINAPI NullCloseLocator(
    HMAPPER  *pMap,
    HLOCATOR hLocator   //in
)
/*++

Routine Description:

    Called to close a HLOCATOR returned by MapCredential

Arguments:

    tokenhandle -- HLOCATOR

Returns:

    TRUE if success, FALSE if error

--*/
{
    DBG_ASSERT( ((IisMapper*)pMap)->dwSignature == IIS_MAPPER_SIGNATURE );

    if (hLocator == 1) {
        return SEC_E_OK;
    }
    else {
        if (CloseHandle( (HANDLE)hLocator )) {\
            return SEC_E_OK;
        }
        else {
        }
    }
    return hLocator == 1 ? TRUE : CloseHandle( (HANDLE)hLocator );
}


DWORD WINAPI NullGetAccessToken(
    HMAPPER     *pMap,
    HLOCATOR    tokenhandle,
    HANDLE *    phToken
    )
/*++

Routine Description:

    Called to retrieve an access token from a mapping

Arguments:

    tokenhandle -- HLOCATOR returned by MapCredential
    phToken -- updated with potentially new token

Returns:

    TRUE if success, FALSE if error

--*/
{
    DBG_ASSERT( ((IisMapper*)pMap)->dwSignature == IIS_MAPPER_SIGNATURE );

    if ( tokenhandle == 1 )
    {
        *phToken = (HANDLE)tokenhandle;
    }

    else if ( !pfnDuplicateTokenEx( (HANDLE)tokenhandle,
                            TOKEN_ALL_ACCESS,
                            NULL,
                            SecurityImpersonation,
                            TokenImpersonation,
                            phToken ))
    {
        return SEC_E_UNSUPPORTED_FUNCTION;
    }

    return SEC_E_OK;
}


DWORD WINAPI NullQueryMappedCredentialAttributes(
    HMAPPER     *phMapper,  // in
    HLOCATOR    hLocator,   // in
    ULONG       ulAttribute, // in
    PVOID       pBuffer, //out
    DWORD       *pcbBuffer // in out
    )
{
    return ( SEC_E_NOT_SUPPORTED );
}


QuerySingleAccessToken(
    VOID
    )
/*++

Routine Description:

    Query status of single access token mode

Arguments:

    None

Returns:

    TRUE if single access token mode used, otherwise FALSE

--*/
{
    return g_fUseSingleToken;
}


BOOL
CACHED_CREDENTIAL::GetCredential(
    LPSTR                   pszPackage,
    PIIS_SERVER_INSTANCE    psi,
    PTCP_AUTHENT_INFO       pTAI,
    CredHandle*             prcred,
    ULONG*                  pcbMaxToken
    )
/*++

Routine Description:

    Get SSPI credential handle from cache

Arguments:

    pszPackage - SSPI package name, e.g NTLM
    psi - pointer to server instance
    pTAI - pointer to authent info, only DomainName used
    prcred - updated with CredHandle from cache
    pcbMaxToken - updated with max token size used by this package

Returns:

    TRUE if success, otherwise FALSE

--*/
{
    LIST_ENTRY *                pEntry;
    CACHED_CREDENTIAL *         pcred;
    SEC_WINNT_AUTH_IDENTITY     AuthIdentity;
    SEC_WINNT_AUTH_IDENTITY *   pAuthIdentity;
    SecPkgInfo *                pspkg;
    TimeStamp                   Lifetime;
    STACK_STR                   ( strDefaultLogonDomain, IIS_DNLEN+1 );
    SECURITY_STATUS             ss;


    DBG_ASSERT( pszPackage != NULL );
    DBG_ASSERT( pTAI != NULL );

    EnterCriticalSection( &csCredentialCacheLock );

    for ( pEntry  = CredentialCacheList.Flink;
          pEntry != &CredentialCacheList;
          pEntry  = pEntry->Flink )
    {
        pcred = CONTAINING_RECORD( pEntry, CACHED_CREDENTIAL, _ListEntry );

        if ( !strcmp( pszPackage, pcred->_PackageName.QueryStr() ) &&
             !strcmp( pTAI->strDefaultLogonDomain.QueryStr(), pcred->_DefaultDomain.QueryStr() ) )
        {
            goto Exit;
        }
    }

    if ( (pcred = new CACHED_CREDENTIAL) == NULL )
    {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        goto Exit;
    }

    if ( !pcred->_PackageName.Copy( pszPackage ) ||
         !pcred->_DefaultDomain.Copy( pTAI->strDefaultLogonDomain ) )
    {
        delete pcred;
        pcred = NULL;
        goto Exit;
    }

    //
    // provide default logon domain
    //

    if ( psi == NULL )
    {
        pAuthIdentity = NULL;
    }
    else
    {
        pAuthIdentity = &AuthIdentity;

        memset( &AuthIdentity,
                0,
                sizeof( AuthIdentity ));

        if ( pTAI->strDefaultLogonDomain.QueryCCH() <= IIS_DNLEN )
        {
            strDefaultLogonDomain.Copy( pTAI->strDefaultLogonDomain );
            AuthIdentity.Domain = (LPBYTE)strDefaultLogonDomain.QueryStr();
        }
        if ( AuthIdentity.Domain != NULL )
        {
            if ( AuthIdentity.DomainLength =
                    strlen( (LPCTSTR)AuthIdentity.Domain ) )
            {
                // remove trailing '\\' if present

                if ( AuthIdentity.Domain[AuthIdentity.DomainLength-1]
                        == '\\' )
                {
                    --AuthIdentity.DomainLength;
                }
            }
        }
        if ( AuthIdentity.DomainLength == 0 )
        {
            pAuthIdentity = NULL;
        }
        else
        {
            AuthIdentity.Flags = SEC_WINNT_AUTH_IDENTITY_ANSI;
        }
    }

    ss = pfnAcquireCredentialsHandle( NULL,             // New principal
                                   pszPackage,       // Package name
                                   SECPKG_CRED_INBOUND,
                                   NULL,             // Logon ID
                                   pAuthIdentity,    // Auth Data
                                   NULL,             // Get key func
                                   NULL,             // Get key arg
                                   &pcred->_hcred,
                                   &Lifetime );

    //
    //  Need to determine the max token size for this package
    //

    if ( ss == STATUS_SUCCESS )
    {
        pcred->_fHaveCredHandle = TRUE;
        ss = pfnQuerySecurityPackageInfo( (char *) pszPackage,
                                       &pspkg );
    }

    if ( ss == STATUS_SUCCESS )
    {
        pcred->_cbMaxToken = pspkg->cbMaxToken;
        DBG_ASSERT( pspkg->fCapabilities & SECPKG_FLAG_CONNECTION );
        pfnFreeContextBuffer( pspkg );
    }

    if ( ss != STATUS_SUCCESS )
    {
        DBGPRINTF(( DBG_CONTEXT,
                   "[GetCredential] AcquireCredentialsHandle or QuerySecurityPackageInfo failed, error %d\n",
                    ss ));

        SetLastError( ss );

        delete pcred;
        pcred = NULL;
    }
    else
    {
        InsertHeadList( &CredentialCacheList, &pcred->_ListEntry );
    }

Exit:

    if ( pcred )
    {
        *pcbMaxToken = pcred->_cbMaxToken;
        *prcred = pcred->_hcred;
    }

    LeaveCriticalSection( &csCredentialCacheLock );

    return pcred ? TRUE : FALSE;
}


CACHED_CREDENTIAL::~CACHED_CREDENTIAL(
    )
/*++

Routine Description:

    SSPI Credential cache entry destructor

Arguments:

    None

Returns:

    Nothing

--*/
{
    if ( _fHaveCredHandle )
    {
        pfnFreeCredentialsHandle( &_hcred );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\common\tcputil.cxx ===
/*++

   Copyright    (c)    1996    Microsoft Corporation

   Module  Name :

        tcputil.cxx

   Abstract:

        This module contains common utility routines for the TCP services

   Author:

        Johnl       09-Oct-1994     Created.
--*/


#include "tcpdllp.hxx"

#include <datetime.hxx>

LPSTR
ConvertUnicodeToAnsi(
    IN LPCWSTR  lpszUnicode,
    IN LPSTR    lpszAnsi,
    IN DWORD    cbAnsi
    )
/*++
    Description:
        Converts given null-terminated string into ANSI in the buffer supplied.

    Arguments:
        lpszUnicode         null-terminated string in Unicode
        lpszAnsi            buffer supplied to copy  string after conversion.
                    if ( lpszAnsi == NULL), then this module allocates space
                      using TCP_ALLOC, which should be freed calling TCP_FREE
                      by user.
        cbAnsi              number of bytes in lpszAnsi if specified

    Returns:
        pointer to converted ANSI string. NULL on errors.

    History:
        MuraliK     12-01-1994      Created.
--*/
{

    DWORD cchLen;
    DWORD nBytes;
    LPSTR lpszAlloc = NULL;

    if ( lpszUnicode == NULL) {
        return (NULL);
    }

    if ( lpszAnsi == NULL) {

        //
        // multiply by 2 to accomodate DBCS
        //

        cchLen = wcslen( lpszUnicode);
        nBytes = (cchLen+1) * sizeof(CHAR) * 2;
        lpszAlloc = (LPSTR ) TCP_ALLOC( nBytes );

    } else {

        lpszAlloc = lpszAnsi;
        nBytes = cbAnsi;
        DBG_ASSERT(nBytes > 0);
    }

    if ( lpszAlloc != NULL) {

        cchLen = WideCharToMultiByte( CP_ACP,
                                      WC_COMPOSITECHECK,
                                      lpszUnicode,
                                      -1,
                                      lpszAlloc,
                                      nBytes,
                                      NULL,  // lpszDefaultChar
                                      NULL   // lpfDefaultUsed
                                     );

        DBG_ASSERT(cchLen == (strlen(lpszAlloc)+1) );

        if ( cchLen == 0 ) {

            //
            // There was a failure. Free up buffer if need be.
            //

            DBGPRINTF((DBG_CONTEXT,"WideCharToMultiByte failed with %d\n",
                GetLastError()));

            if ( lpszAnsi == NULL) {
                TCP_FREE( lpszAlloc);
                lpszAlloc = NULL;
            } else {
                lpszAlloc[cchLen] = '\0';
            }

        } else {

            DBG_ASSERT( cchLen <= nBytes );
            DBG_ASSERT(lpszAlloc[cchLen-1] == '\0');

            lpszAlloc[cchLen-1] = '\0';
        }
    }

    return ( lpszAlloc);

} // ConvertUnicodeToAnsi



/*******************************************************************

    NAME:       ReadRegistryDword

    SYNOPSIS:   Reads a DWORD value from the registry.

    ENTRY:      hkey - Openned registry key to read

                pszValueName - The name of the value.

                dwDefaultValue - The default value to use if the
                    value cannot be read.

    RETURNS     DWORD - The value from the registry, or dwDefaultValue.

********************************************************************/
DWORD ReadRegistryDwordA( HKEY    hkey,
                         LPCSTR   pszValueName,
                         DWORD    dwDefaultValue )
{
    DWORD  err;
    DWORD  dwBuffer;

    DWORD  cbBuffer = sizeof(dwBuffer);
    DWORD  dwType;

    if( hkey != NULL )
    {
        err = RegQueryValueExA( hkey,
                               pszValueName,
                               NULL,
                               &dwType,
                               (LPBYTE)&dwBuffer,
                               &cbBuffer );

        if( ( err == NO_ERROR ) && ( dwType == REG_DWORD ) )
        {
            dwDefaultValue = dwBuffer;
        }
    }
    return dwDefaultValue;
}   // ReadRegistryDwordA()


DWORD
WriteRegistryDwordA(
    IN HKEY hkey,
    IN LPCSTR pszValueName,
    IN DWORD   dwValue)
/*++
    Description:
        Writes the given DWORD value into registry entry specified
        by hkey\pszValueName

    Arguments:
        hkey            handle to registry key
        pszValueName    name of the value
        dwValue         new value for write

    Returns:
        Win32 error codes. NO_ERROR if successful.

    History:
        MuraliK     12-01-1994  Created.
--*/
{
    DWORD err;

    if ( (hkey == NULL) || (pszValueName == NULL) ) {

        err = ( ERROR_INVALID_PARAMETER);

    } else {
        err = RegSetValueExA( hkey,
                             pszValueName,
                             0,
                             REG_DWORD,
                             (LPBYTE ) &dwValue,
                             sizeof( dwValue));
    }

    return ( err);
} // WriteRegistryDwordA()





DWORD
WriteRegistryStringA(
    IN HKEY hkey,
    IN LPCSTR  pszValueName,
    IN LPCSTR  pszValue,
    IN DWORD   cbValue,
    IN DWORD   dwType
    )
/*++
    Description:
        Writes the given ANSI String into registry entry specified
        by hkey\pszValueName.

    Arguments:
        hkey            handle to registry key
        pszValueName    name of the value
        pszValue        new value for write
        cbValue         count of bytes of value written.
                        Should include terminating null characters.
         dwType         type of the value being written
                            ( REG_SZ, REG_MULTI_SZ etc)

    Returns:
        Win32 error codes. NO_ERROR if successful.

--*/
{
    DWORD err;

    DBG_ASSERT(dwType != REG_MULTI_SZ);
    DBG_ASSERT( (dwType == REG_SZ) || (dwType == REG_EXPAND_SZ) );

    if ( (hkey == NULL) ||
         (pszValueName == NULL) ||
         (cbValue == 0) ) {

        err = ERROR_INVALID_PARAMETER;
    } else {

        err = RegSetValueExA(
                    hkey,
                    pszValueName,
                    0,
                    dwType,
                    (LPBYTE ) pszValue,
                    cbValue);      // + 1 for null character
    }

    return ( err);
} // WriteRegistryStringA()


DWORD
WriteRegistryStringW(
    IN HKEY     hkey,
    IN LPCWSTR  pszValueName,
    IN LPCWSTR  pszValue,
    IN DWORD    cbValue,
    IN DWORD    dwType)
/*++
    Description:
        Writes the given ANSI String into registry entry specified
        by hkey\pszValueName.

    Arguments:
        hkey            handle to registry key
        pszValueName    name of the value
        pszValue        new value for write
        cbValue         count of bytes of value written.
                        Should include terminating null characters.
         dwType         type of the value being written
                            ( REG_SZ, REG_MULTI_SZ etc)

    Returns:
        Win32 error codes. NO_ERROR if successful.

--*/
{
    DWORD err;

    LPSTR ansiValue = NULL;
    LPSTR ansiName = NULL;

    if ( (hkey == NULL) ||
         (pszValueName == NULL) ||
         (cbValue == 0) ) {

        err = ERROR_INVALID_PARAMETER;
    } else {

        //
        // Convert to ansi
        //

        ansiName = ConvertUnicodeToAnsi( pszValueName, NULL, 0 );
        ansiValue = ConvertUnicodeToAnsi( pszValue, NULL, 0 );

        if ( (ansiName != NULL) && (ansiValue != NULL) ) {

            err = WriteRegistryStringA(hkey,
                                       ansiName,
                                       ansiValue,
                                       strlen(ansiValue)+1,
                                       dwType
                                       );
        } else {
            err = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    if ( ansiName != NULL ) {
        TCP_FREE(ansiName);
    }

    if ( ansiValue != NULL ) {
        TCP_FREE(ansiValue);
    }

    return ( err);
} // WriteRegistryStringW()


/*******************************************************************

    NAME:       ReadRegistryString

    SYNOPSIS:   Allocates necessary buffer space for a registry
                    string, then reads the string into the buffer.

    ENTRY:      pszValueName - The name of the value.

                pszDefaultValue - The default value to use if the
                    value cannot be read.

                fExpand - Expand environment strings if TRUE.

    RETURNS:    TCHAR * - The string, NULL if error.

    NOTES:      I always allocate one more character than actually
                necessary.  This will ensure that any code expecting
                to read a REG_MULTI_SZ will not explode if the
                registry actually contains a REG_SZ.

                This function cannot be called until after
                InitializeGlobals().

    HISTORY:
        KeithMo     15-Mar-1993 Created.

********************************************************************/
TCHAR * ReadRegistryString( HKEY     hkey,
                            LPCTSTR  pszValueName,
                            LPCTSTR  pszDefaultValue,
                            BOOL     fExpand )
{
    TCHAR   * pszBuffer1;
    TCHAR   * pszBuffer2;
    DWORD     cbBuffer;
    DWORD     dwType;
    DWORD     err;

    //
    //  Determine the buffer size.
    //

    pszBuffer1 = NULL;
    pszBuffer2 = NULL;
    cbBuffer   = 0;

    if( hkey == NULL )
    {
        //
        //  Pretend the key wasn't found.
        //

        err = ERROR_FILE_NOT_FOUND;
    }
    else
    {
        err = RegQueryValueEx( hkey,
                               pszValueName,
                               NULL,
                               &dwType,
                               NULL,
                               &cbBuffer );

        if( ( err == NO_ERROR ) || ( err == ERROR_MORE_DATA ) )
        {
            if( ( dwType != REG_SZ ) &&
                ( dwType != REG_MULTI_SZ ) &&
                ( dwType != REG_EXPAND_SZ ) )
            {
                //
                //  Type mismatch, registry data NOT a string.
                //  Use default.
                //

                err = ERROR_FILE_NOT_FOUND;
            }
            else
            {
                //
                //  Item found, allocate a buffer.
                //

                pszBuffer1 = (TCHAR *) TCP_ALLOC( cbBuffer+sizeof(TCHAR) );

                if( pszBuffer1 == NULL )
                {
                    err = ERROR_NOT_ENOUGH_MEMORY;
                }
                else
                {
                    //
                    //  Now read the value into the buffer.
                    //

                    err = RegQueryValueEx( hkey,
                                           pszValueName,
                                           NULL,
                                           NULL,
                                           (LPBYTE)pszBuffer1,
                                           &cbBuffer );
                }
            }
        }
    }

    if( err == ERROR_FILE_NOT_FOUND )
    {
        //
        //  Item not found, use default value.
        //

        err = NO_ERROR;

        if( pszDefaultValue != NULL )
        {
            pszBuffer1 = (TCHAR *)TCP_ALLOC( (_tcslen(pszDefaultValue)+1) * sizeof(TCHAR) );

            if( pszBuffer1 == NULL )
            {   
                err = ERROR_NOT_ENOUGH_MEMORY;
            }
            else
            {
                _tcscpy( pszBuffer1, pszDefaultValue );
            }
        }
    }

    if( err != NO_ERROR )
    {
        //
        //  Tragic error reading registry, abort now.
        //

        goto ErrorCleanup;
    }

    //
    //  pszBuffer1 holds the registry value.  Now expand
    //  the environment strings if necessary.
    //

    if( !fExpand )
    {
        return pszBuffer1;
    }

    //
    //  Returns number of characters
    //
    cbBuffer = ExpandEnvironmentStrings( pszBuffer1,
                                         NULL,
                                         0 );

    //
    // The ExpandEnvironmentStrings() API is kinda poor.  In returning the
    // number of characters, we have no clue how large to make the buffer
    // in the case of DBCS characters.  Lets assume that each character is
    // 2 bytes. 
    //

    pszBuffer2 = (TCHAR *) TCP_ALLOC( (cbBuffer+1)*sizeof(WCHAR) );

    if( pszBuffer2 == NULL )
    {
        goto ErrorCleanup;
    }

    if( ExpandEnvironmentStrings( pszBuffer1,
                                  pszBuffer2,
                                  cbBuffer ) > cbBuffer )
    {
        goto ErrorCleanup;
    }

    //
    //  pszBuffer2 now contains the registry value with
    //  environment strings expanded.
    //

    TCP_FREE( pszBuffer1 );
    pszBuffer1 = NULL;

    return pszBuffer2;

ErrorCleanup:

    //
    //  Something tragic happend; free any allocated buffers
    //  and return NULL to the caller, indicating failure.
    //

    if( pszBuffer1 != NULL )
    {
        TCP_FREE( pszBuffer1 );
        pszBuffer1 = NULL;
    }

    if( pszBuffer2 != NULL )
    {
        TCP_FREE( pszBuffer2 );
        pszBuffer2 = NULL;
    }

    return NULL;

}   // ReadRegistryString


//
//  Chicago does not support the REG_MULTI_SZ registry value.  As
//  a hack (er, workaround), we'll create *keys* in the registry
//  in place of REG_MULTI_SZ *values*.  We'll then use the names
//  of any values under the key as the REG_MULTI_SZ entries.  So,
//  instead of this:
//
//      ..\Control\ServiceProvider
//          ProviderOrder = REG_MULTI_SZ "MSTCP"
//                                       "NWLINK"
//                                       "FOOBAR"
//
//  We'll use this:
//
//      ..\Control\Service\Provider\ProviderOrder
//          MSTCP = REG_SZ ""
//          NWLINK = REG_SZ ""
//          FOOBAR = REG_SZ ""
//
//  This function takes an open registry key handle, enumerates
//  the names of values contained within the key, and constructs
//  a REG_MULTI_SZ string from the value names.
//
//  Note that this function is not multithread safe; if another
//  thread (or process) creates or deletes values under the
//  specified key, the results are indeterminate.
//
//  This function returns NULL on error.  It returns non-NULL
//  on success, even if the resulting REG_MULTI_SZ is empty.
//

TCHAR *
KludgeMultiSz(
    HKEY hkey,
    LPDWORD lpdwLength
    )
{
    LONG  err;
    DWORD iValue;
    DWORD cchTotal;
    DWORD cchValue;
    TCHAR szValue[MAX_PATH];
    LPTSTR lpMultiSz;
    LPTSTR lpTmp;
    LPTSTR lpEnd;

    //
    //  Enumerate the values and total up the lengths.
    //

    iValue = 0;
    cchTotal = 0;

    for( ; ; )
    {
        cchValue = sizeof(szValue)/sizeof(TCHAR);

        err = RegEnumValue( hkey,
                            iValue,
                            szValue,
                            &cchValue,
                            NULL,
                            NULL,
                            NULL,
                            NULL );

        if( err != NO_ERROR )
        {
            break;
        }

        //
        //  Add the length of the value's name, plus one
        //  for the terminator.
        //

        cchTotal += _tcslen( szValue ) + 1;

        //
        //  Advance to next value.
        //

        iValue++;
    }

    //
    //  Add one for the final terminating NULL.
    //

    cchTotal++;
    *lpdwLength = cchTotal;

    //
    //  Allocate the MULTI_SZ buffer.
    //

    lpMultiSz = (TCHAR *) TCP_ALLOC( cchTotal * sizeof(TCHAR) );

    if( lpMultiSz == NULL )
    {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return NULL;
    }

    memset( lpMultiSz, 0, cchTotal * sizeof(TCHAR) );

    //
    //  Enumerate the values and append to the buffer.
    //

    iValue = 0;
    lpTmp = lpMultiSz;
    lpEnd = lpMultiSz + cchTotal;

    for( ; ; )
    {
        cchValue = sizeof(szValue)/sizeof(TCHAR);

        err = RegEnumValue( hkey,
                            iValue,
                            szValue,
                            &cchValue,
                            NULL,
                            NULL,
                            NULL,
                            NULL );

        if( err != NO_ERROR )
        {
            break;
        }

        //
        //  Compute the length of the value name (including
        //  the terminating NULL).
        //

        cchValue = _tcslen( szValue ) + 1;

        //
        //  Determine if there is room in the array, taking into
        //  account the second NULL that terminates the string list.
        //

        if( ( lpTmp + cchValue + 1 ) > lpEnd )
        {
            break;
        }

        //
        //  Append the value name.
        //

        _tcscpy( lpTmp, szValue );
        lpTmp += cchValue;

        //
        //  Advance to next value.
        //

        iValue++;
    }

    //
    //  Success!
    //

    return (LPTSTR)lpMultiSz;

}   // KludgeMultiSz



BOOL
ReadRegistryStr(
    IN HKEY hkeyReg,
    OUT STR & str,
    IN LPCTSTR lpszValueName,
    IN LPCTSTR lpszDefaultValue,
    IN BOOL  fExpand )
/*++

  Reads the registry string into the string buffer supplied.
  If there is no value in the registry the default value is set to
  be the value of the string.

  If an environment expansion is requested, it is also performed.

  Arguments:

    hkeyReg     handle for registry entry
    str         string to contain the result of read operation
    lpszValueName
                pointer to string containing the key name whose
                    value needs to be fetched.
    lpszDefaultValue
                pointer to string containing a value which is used if no
                     value exists in the registry.
    fExpand     boolean flag indicating if an expansion is desired.

  Returns:
    FALSE if there is any error.
    TRUE when the string is successfully set.
--*/
{
    BOOL fReturn = FALSE;
    LPTSTR pszValueAlloc;

    pszValueAlloc = ReadRegistryString( hkeyReg, lpszValueName,
                                       lpszDefaultValue, fExpand);

    if ( pszValueAlloc != NULL) {

        fReturn = str.Copy( pszValueAlloc);
        TCP_FREE( pszValueAlloc);
    } else {

        DBG_ASSERT( fReturn == FALSE);
    }

    if ( !fReturn) {

        IF_DEBUG( ERROR) {

            DWORD err = GetLastError();

            DBGPRINTF(( DBG_CONTEXT,
                       " Error %u in ReadRegistryString( %08x, %s).\n",
                       err, hkeyReg, lpszValueName));

            SetLastError(err);
        }
    }

    return ( fReturn);
} // ReadRegistryStr

/*******************************************************************

    NAME:       FlipSlashes

    SYNOPSIS:   Flips the Unix-ish forward slashes ('/') into Dos-ish
                back slashes ('\').

    ENTRY:      pszPath - The path to munge.

    RETURNS:    TCHAR * - pszPath.

    HISTORY:
        KeithMo     04-Jun-1993 Created.

********************************************************************/
TCHAR * FlipSlashes( TCHAR * pszPath )
{
    TCHAR   ch;
    TCHAR * pszScan = pszPath;

    while( ( ch = *pszScan ) != TEXT('\0') )
    {
        if( ch == TEXT('/') )
        {
            *pszScan = TEXT('\\');
        }

        pszScan++;
    }

    return pszPath;

}   // FlipSlashes





/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    i_ntoa.c

Abstract:

    This module implements a routine to convert a numerical IP address
    into a dotted-decimal character string Internet address.

Author:

    Mike Massa (mikemas)           Sept 20, 1991

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    mikemas     9-20-91     created
    davidtr     9-19-95     completely rewritten for performance
    muralik     3-Oct-1995  massaged it for Internet services

Notes:

    Exports:
        InetNtoa()

--*/


#define UC(b)   (((int)b)&0xff)

//
// This preinitialized array defines the strings to be used for
// inet_ntoa.  The index of each row corresponds to the value for a byte
// in an IP address.  The first three bytes of each row are the
// char/string value for the byte, and the fourth byte in each row is
// the length of the string required for the byte.  This approach
// allows a fast implementation with no jumps.
//

static BYTE NToACharStrings[][4] = {
    '0', 'x', 'x', 1,
    '1', 'x', 'x', 1,
    '2', 'x', 'x', 1,
    '3', 'x', 'x', 1,
    '4', 'x', 'x', 1,
    '5', 'x', 'x', 1,
    '6', 'x', 'x', 1,
    '7', 'x', 'x', 1,
    '8', 'x', 'x', 1,
    '9', 'x', 'x', 1,
    '1', '0', 'x', 2,
    '1', '1', 'x', 2,
    '1', '2', 'x', 2,
    '1', '3', 'x', 2,
    '1', '4', 'x', 2,
    '1', '5', 'x', 2,
    '1', '6', 'x', 2,
    '1', '7', 'x', 2,
    '1', '8', 'x', 2,
    '1', '9', 'x', 2,
    '2', '0', 'x', 2,
    '2', '1', 'x', 2,
    '2', '2', 'x', 2,
    '2', '3', 'x', 2,
    '2', '4', 'x', 2,
    '2', '5', 'x', 2,
    '2', '6', 'x', 2,
    '2', '7', 'x', 2,
    '2', '8', 'x', 2,
    '2', '9', 'x', 2,
    '3', '0', 'x', 2,
    '3', '1', 'x', 2,
    '3', '2', 'x', 2,
    '3', '3', 'x', 2,
    '3', '4', 'x', 2,
    '3', '5', 'x', 2,
    '3', '6', 'x', 2,
    '3', '7', 'x', 2,
    '3', '8', 'x', 2,
    '3', '9', 'x', 2,
    '4', '0', 'x', 2,
    '4', '1', 'x', 2,
    '4', '2', 'x', 2,
    '4', '3', 'x', 2,
    '4', '4', 'x', 2,
    '4', '5', 'x', 2,
    '4', '6', 'x', 2,
    '4', '7', 'x', 2,
    '4', '8', 'x', 2,
    '4', '9', 'x', 2,
    '5', '0', 'x', 2,
    '5', '1', 'x', 2,
    '5', '2', 'x', 2,
    '5', '3', 'x', 2,
    '5', '4', 'x', 2,
    '5', '5', 'x', 2,
    '5', '6', 'x', 2,
    '5', '7', 'x', 2,
    '5', '8', 'x', 2,
    '5', '9', 'x', 2,
    '6', '0', 'x', 2,
    '6', '1', 'x', 2,
    '6', '2', 'x', 2,
    '6', '3', 'x', 2,
    '6', '4', 'x', 2,
    '6', '5', 'x', 2,
    '6', '6', 'x', 2,
    '6', '7', 'x', 2,
    '6', '8', 'x', 2,
    '6', '9', 'x', 2,
    '7', '0', 'x', 2,
    '7', '1', 'x', 2,
    '7', '2', 'x', 2,
    '7', '3', 'x', 2,
    '7', '4', 'x', 2,
    '7', '5', 'x', 2,
    '7', '6', 'x', 2,
    '7', '7', 'x', 2,
    '7', '8', 'x', 2,
    '7', '9', 'x', 2,
    '8', '0', 'x', 2,
    '8', '1', 'x', 2,
    '8', '2', 'x', 2,
    '8', '3', 'x', 2,
    '8', '4', 'x', 2,
    '8', '5', 'x', 2,
    '8', '6', 'x', 2,
    '8', '7', 'x', 2,
    '8', '8', 'x', 2,
    '8', '9', 'x', 2,
    '9', '0', 'x', 2,
    '9', '1', 'x', 2,
    '9', '2', 'x', 2,
    '9', '3', 'x', 2,
    '9', '4', 'x', 2,
    '9', '5', 'x', 2,
    '9', '6', 'x', 2,
    '9', '7', 'x', 2,
    '9', '8', 'x', 2,
    '9', '9', 'x', 2,
    '1', '0', '0', 3,
    '1', '0', '1', 3,
    '1', '0', '2', 3,
    '1', '0', '3', 3,
    '1', '0', '4', 3,
    '1', '0', '5', 3,
    '1', '0', '6', 3,
    '1', '0', '7', 3,
    '1', '0', '8', 3,
    '1', '0', '9', 3,
    '1', '1', '0', 3,
    '1', '1', '1', 3,
    '1', '1', '2', 3,
    '1', '1', '3', 3,
    '1', '1', '4', 3,
    '1', '1', '5', 3,
    '1', '1', '6', 3,
    '1', '1', '7', 3,
    '1', '1', '8', 3,
    '1', '1', '9', 3,
    '1', '2', '0', 3,
    '1', '2', '1', 3,
    '1', '2', '2', 3,
    '1', '2', '3', 3,
    '1', '2', '4', 3,
    '1', '2', '5', 3,
    '1', '2', '6', 3,
    '1', '2', '7', 3,
    '1', '2', '8', 3,
    '1', '2', '9', 3,
    '1', '3', '0', 3,
    '1', '3', '1', 3,
    '1', '3', '2', 3,
    '1', '3', '3', 3,
    '1', '3', '4', 3,
    '1', '3', '5', 3,
    '1', '3', '6', 3,
    '1', '3', '7', 3,
    '1', '3', '8', 3,
    '1', '3', '9', 3,
    '1', '4', '0', 3,
    '1', '4', '1', 3,
    '1', '4', '2', 3,
    '1', '4', '3', 3,
    '1', '4', '4', 3,
    '1', '4', '5', 3,
    '1', '4', '6', 3,
    '1', '4', '7', 3,
    '1', '4', '8', 3,
    '1', '4', '9', 3,
    '1', '5', '0', 3,
    '1', '5', '1', 3,
    '1', '5', '2', 3,
    '1', '5', '3', 3,
    '1', '5', '4', 3,
    '1', '5', '5', 3,
    '1', '5', '6', 3,
    '1', '5', '7', 3,
    '1', '5', '8', 3,
    '1', '5', '9', 3,
    '1', '6', '0', 3,
    '1', '6', '1', 3,
    '1', '6', '2', 3,
    '1', '6', '3', 3,
    '1', '6', '4', 3,
    '1', '6', '5', 3,
    '1', '6', '6', 3,
    '1', '6', '7', 3,
    '1', '6', '8', 3,
    '1', '6', '9', 3,
    '1', '7', '0', 3,
    '1', '7', '1', 3,
    '1', '7', '2', 3,
    '1', '7', '3', 3,
    '1', '7', '4', 3,
    '1', '7', '5', 3,
    '1', '7', '6', 3,
    '1', '7', '7', 3,
    '1', '7', '8', 3,
    '1', '7', '9', 3,
    '1', '8', '0', 3,
    '1', '8', '1', 3,
    '1', '8', '2', 3,
    '1', '8', '3', 3,
    '1', '8', '4', 3,
    '1', '8', '5', 3,
    '1', '8', '6', 3,
    '1', '8', '7', 3,
    '1', '8', '8', 3,
    '1', '8', '9', 3,
    '1', '9', '0', 3,
    '1', '9', '1', 3,
    '1', '9', '2', 3,
    '1', '9', '3', 3,
    '1', '9', '4', 3,
    '1', '9', '5', 3,
    '1', '9', '6', 3,
    '1', '9', '7', 3,
    '1', '9', '8', 3,
    '1', '9', '9', 3,
    '2', '0', '0', 3,
    '2', '0', '1', 3,
    '2', '0', '2', 3,
    '2', '0', '3', 3,
    '2', '0', '4', 3,
    '2', '0', '5', 3,
    '2', '0', '6', 3,
    '2', '0', '7', 3,
    '2', '0', '8', 3,
    '2', '0', '9', 3,
    '2', '1', '0', 3,
    '2', '1', '1', 3,
    '2', '1', '2', 3,
    '2', '1', '3', 3,
    '2', '1', '4', 3,
    '2', '1', '5', 3,
    '2', '1', '6', 3,
    '2', '1', '7', 3,
    '2', '1', '8', 3,
    '2', '1', '9', 3,
    '2', '2', '0', 3,
    '2', '2', '1', 3,
    '2', '2', '2', 3,
    '2', '2', '3', 3,
    '2', '2', '4', 3,
    '2', '2', '5', 3,
    '2', '2', '6', 3,
    '2', '2', '7', 3,
    '2', '2', '8', 3,
    '2', '2', '9', 3,
    '2', '3', '0', 3,
    '2', '3', '1', 3,
    '2', '3', '2', 3,
    '2', '3', '3', 3,
    '2', '3', '4', 3,
    '2', '3', '5', 3,
    '2', '3', '6', 3,
    '2', '3', '7', 3,
    '2', '3', '8', 3,
    '2', '3', '9', 3,
    '2', '4', '0', 3,
    '2', '4', '1', 3,
    '2', '4', '2', 3,
    '2', '4', '3', 3,
    '2', '4', '4', 3,
    '2', '4', '5', 3,
    '2', '4', '6', 3,
    '2', '4', '7', 3,
    '2', '4', '8', 3,
    '2', '4', '9', 3,
    '2', '5', '0', 3,
    '2', '5', '1', 3,
    '2', '5', '2', 3,
    '2', '5', '3', 3,
    '2', '5', '4', 3,
    '2', '5', '5', 3
};



DWORD
InetNtoa(
    IN  struct in_addr  inaddr,
    OUT CHAR * pchBuffer
    )

/*++

Routine Description:

    This function takes an Internet address structure specified by the
    in parameter.  It returns an ASCII string representing the address
    in ".'' notation as "a.b.c.d".

Arguments:

    inaddr - A structure which represents an Internet host address.
    pchBuffer - pointer to at least 16 character buffer for storing
                 the result of conversion.
Return Value:

    If no error occurs, InetNtoa() returns NO_ERROR with the buffer containing
     the text address in standard "." notation.
    Otherwise, it returns Win32 error code.


--*/

{
    PUCHAR p;
    PUCHAR buffer = (PUCHAR ) pchBuffer;
    PUCHAR b = buffer;

    if ( pchBuffer == NULL) {

        return ( ERROR_INSUFFICIENT_BUFFER);
    }

    //
    // We do not check for sufficient length of the buffer yet. !!
    //

    //
    // In an unrolled loop, calculate the string value for each of the four
    // bytes in an IP address.  Note that for values less than 100 we will
    // do one or two extra assignments, but we save a test/jump with this
    // algorithm.
    //

    p = (PUCHAR) &inaddr;

    *b = NToACharStrings[*p][0];
    *(b+1) = NToACharStrings[*p][1];
    *(b+2) = NToACharStrings[*p][2];
    b += NToACharStrings[*p][3];
    *b++ = '.';

    p++;
    *b = NToACharStrings[*p][0];
    *(b+1) = NToACharStrings[*p][1];
    *(b+2) = NToACharStrings[*p][2];
    b += NToACharStrings[*p][3];
    *b++ = '.';

    p++;
    *b = NToACharStrings[*p][0];
    *(b+1) = NToACharStrings[*p][1];
    *(b+2) = NToACharStrings[*p][2];
    b += NToACharStrings[*p][3];
    *b++ = '.';

    p++;
    *b = NToACharStrings[*p][0];
    *(b+1) = NToACharStrings[*p][1];
    *(b+2) = NToACharStrings[*p][2];
    b += NToACharStrings[*p][3];
    *b = '\0';

    return ( NO_ERROR);

} // InetNtoa()


BOOL
TcpSockSend(
    IN SOCKET      sock,
    IN LPVOID      pBuffer,
    IN DWORD       cbBuffer,
    OUT PDWORD     pcbTotalSent,
    IN DWORD       nTimeout
    )
/*++

    Description:
        Do async socket send

    Arguments:
        sock - socket
        pBuffer - buffer to send
        cbBuffer - size of buffer
        pcbTotalSent - bytes sent
        nTimeout - timeout in seconds to use

    Returns:
        FALSE if there is any error.
        TRUE otherwise

--*/
{
    INT         serr = 0;
    INT         cbSent;
    DWORD       dwBytesSent = 0;

    DBG_ASSERT( pBuffer != NULL );

    //
    //  Loop until there's no more data to send.
    //

    while( cbBuffer > 0 ) {

        //
        //  Wait for the socket to become writeable.
        //

        serr = 0;

        if( serr == 0 ) {

            //
            //  Write a block to the socket.
            //

            cbSent = send( sock, (CHAR *)pBuffer, (INT)cbBuffer, 0 );

            if( cbSent < 0 ) {

                //
                //  Socket error.
                //

                serr = WSAGetLastError();
                DBGPRINTF((DBG_CONTEXT, "TcpSockSend error %d\n",serr));

            } else {

                dwBytesSent += (DWORD)cbSent;

                IF_DEBUG( ERROR ) {
                    DBGPRINTF(( DBG_CONTEXT,
                       "HTTP: Synchronous send %d bytes @%p to socket %d\n",
                       cbSent, pBuffer, sock ));
                }
            }
        }

        if( serr != 0 ) {
            break;
        }

        pBuffer   = (LPVOID)( (LPBYTE)pBuffer + cbSent );
        cbBuffer -= (DWORD)cbSent;
    }

    if (pcbTotalSent) {
        *pcbTotalSent = dwBytesSent;
    }

    //
    // Set up i/o handle to non-blocking mode , default for ATQ
    //

    if ( serr == 0 ) {
        return(TRUE);
    } else {

        IF_DEBUG( ERROR ) {
            DBGPRINTF(( DBG_CONTEXT,
                "HTTP: Synchronous send socket error %d on socket %d.\n",
                 serr, sock));
        }

        SetLastError(serr);
        return(FALSE);
    }

}   // SockSend



BOOL
TcpSockRecv(
    IN SOCKET       sock,
    IN LPVOID       pBuffer,
    IN DWORD        cbBuffer,
    OUT LPDWORD     pbReceived,
    IN DWORD        nTimeout
    )
/*++

    Description:
        Do async socket recv

    Arguments:
        sock - The target socket.
        pBuffer - Will receive the data.
        cbBuffer - The size (in bytes) of the buffer.
        pbReceived - Will receive the actual number of bytes
        nTimeout - timeout in seconds

    Returns:
        TRUE, if successful

--*/
{
    INT         serr = 0;
    DWORD       cbTotal = 0;
    INT         cbReceived;
    DWORD       dwBytesRecv = 0;

    BOOL fRead = FALSE;

    DBG_ASSERT( pBuffer != NULL );
    DBG_ASSERT( pbReceived != NULL );

    //
    //  Wait for the socket to become readable.
    //

    serr = WaitForSocketWorker(
                        sock,
                        INVALID_SOCKET,
                        &fRead,
                        NULL,
                        nTimeout
                        );

    if( serr == 0 )
    {
        //
        //  Read a block from the socket.
        //
        DBG_ASSERT( fRead);

        cbReceived = recv( sock, (CHAR *)pBuffer, (INT)cbBuffer, 0 );

        if( cbReceived < 0 )
        {
            //
            //  Socket error.
            //

            serr = WSAGetLastError();
        }
        else {
            cbTotal = cbReceived;
        }
    }

    if( serr == 0 )
    {
        //
        //  Return total byte count to caller.
        //

        *pbReceived = cbTotal;
    }
    else
    {
        IF_DEBUG( ERROR )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "HTTP: Syncronous rcv socket error %d during recv on socket %d\n",
                        serr,
                        sock ));
        }
    }

    //
    // Set up i/o handle to blocking mode , as blocking I/O is requested
    //

    if ( serr == 0 ) {
        return(TRUE);
    } else {
        SetLastError(serr);
        return(FALSE);
    }

}   // SockRecv


INT
WaitForSocketWorker(
    IN SOCKET   sockRead,
    IN SOCKET   sockWrite,
    IN LPBOOL   pfRead,
    IN LPBOOL   pfWrite,
    IN DWORD    nTimeout
    )
/*++

    Description:
        Wait routine
        NOTES:      Any (but not all) sockets may be INVALID_SOCKET.  For
                    each socket that is INVALID_SOCKET, the corresponding
                    pf* parameter may be NULL.

    Arguments:
        sockRead - The socket to check for readability.
        sockWrite - The socket to check for writeability.
        pfRead - Will receive TRUE if sockRead is readable.
        pfWrite - Will receive TRUE if sockWrite is writeable.
        nTimeout - timeout in seconds

    Returns:
        SOCKERR - 0 if successful, !0 if not.  Will return
            WSAETIMEDOUT if the timeout period expired.

--*/
{
    INT       serr = 0;
    TIMEVAL   timeout;
    LPTIMEVAL ptimeout;
    fd_set    fdsRead;
    fd_set    fdsWrite;
    INT       res;

    //
    //  Ensure we got valid parameters.
    //

    if( ( sockRead  == INVALID_SOCKET ) &&
        ( sockWrite == INVALID_SOCKET ) ) {

        return WSAENOTSOCK;
    }

    timeout.tv_sec = (LONG )nTimeout;

    if( timeout.tv_sec == 0 ) {

        //
        //  If the connection timeout == 0, then we have no timeout.
        //  So, we block and wait for the specified conditions.
        //

        ptimeout = NULL;

    } else {

        //
        //  The connectio timeout is > 0, so setup the timeout structure.
        //

        timeout.tv_usec = 0;

        ptimeout = &timeout;
    }

    for( ; ; ) {

        //
        //  Setup our socket sets.
        //

        FD_ZERO( &fdsRead );
        FD_ZERO( &fdsWrite );

        if( sockRead != INVALID_SOCKET ) {

            FD_SET( sockRead, &fdsRead );
            DBG_ASSERT( pfRead != NULL );
            *pfRead = FALSE;
        }

        if( sockWrite != INVALID_SOCKET ) {

            FD_SET( sockWrite, &fdsWrite );
            DBG_ASSERT( pfWrite != NULL );
            *pfWrite = FALSE;
        }

        //
        //  Wait for one of the conditions to be met.
        //

        res = select( 0, &fdsRead, &fdsWrite, NULL, ptimeout );

        if( res == 0 ) {

            //
            //  Timeout.
            //

            serr = WSAETIMEDOUT;
            break;

        } else if( res == SOCKET_ERROR ) {

            //
            //  Bad news.
            //

            serr = WSAGetLastError();
            break;
        } else {

            BOOL fSomethingWasSet = FALSE;

            if( pfRead != NULL ) {

                *pfRead   = FD_ISSET( sockRead,   &fdsRead   );
                fSomethingWasSet = TRUE;
            }

            if( pfWrite != NULL ) {
                *pfWrite  = FD_ISSET( sockWrite,  &fdsWrite  );
                fSomethingWasSet = TRUE;
            }

            if( fSomethingWasSet ) {

                //
                //  Success.
                //

                serr = 0;
                break;
            } else {
                //
                //  select() returned with neither a timeout, nor
                //  an error, nor any bits set.  This feels bad...
                //

                DBG_ASSERT( FALSE );
                continue;
            }
        }
    }

    return serr;

} // WaitForSocketWorker()


BOOL
TcpSockTest(
    IN SOCKET      sock
    )
/*++

    Description:
        Test the socket if still connected.
        Use select, and if readable, use recv

    Arguments:
        sock - socket

    Returns:
        TRUE if the socket most likely is still connected
        FALSE if the socket is disconnected or an error occured

--*/
{
    TIMEVAL   timeout;
    fd_set    fdsRead;
    INT       res;
    CHAR      bOneByte;

    // select for read with zero timeout

    FD_ZERO( &fdsRead );
    FD_SET( sock, &fdsRead );

    timeout.tv_sec = 0;
    timeout.tv_usec = 0;
   
    res = select( 0, &fdsRead, NULL, NULL, &timeout );

    if ( res == 0 ) {
    
        // No data to be read -- 
        //   have to assume socket is still connected
        return TRUE;

    } else if ( res == SOCKET_ERROR ) {
    
        // Something went wrong during select -- assume disconnected
        return FALSE;
    }

    DBG_ASSERT( res == 1 );

    // recv 1 byte (PEEK)
    // select returning 1 above guarantees recv will not block

    res = recv( sock, &bOneByte, 1, MSG_PEEK );

    if ( res == 0 || res == SOCKET_ERROR ) {
        // Socket closed or an error -- socket is disconnected
        return FALSE;
    }
    
    DBG_ASSERT( res == 1 );

    // Read one byte successfully -- assume still connected
    return TRUE;
    
}   // SockTest



BOOL
DoSynchronousReadFile(
    IN HANDLE hFile,
    IN PCHAR  Buffer,
    IN DWORD  nBuffer,
    OUT PDWORD nRead,
    IN LPOVERLAPPED Overlapped
    )
/*++

    Description:
        Does Asynchronous file reads.  Assumes that NT handles are
        opened for OVERLAPPED I/O.

    Arguments:
        hFile - Handle to use for the read
        Buffer - Buffer to read with
        nBuffer - size of buffer
        nRead - returns the number of bytes read
        Overlapped - user supplied overlapped structure

    Returns:
        TRUE/FALSE
--*/
{
    BOOL        fNewEvent = FALSE;
    OVERLAPPED  ov;
    BOOL        fRet = FALSE;

    if ( Overlapped == NULL ) {

        Overlapped = &ov;
        ov.Offset = 0;
        ov.OffsetHigh = 0;
        ov.hEvent = IIS_CREATE_EVENT(
                        "OVERLAPPED::hEvent",
                        &ov,
                        TRUE,
                        FALSE
                        );

        if ( ov.hEvent == NULL ) {
            DBGPRINTF((DBG_CONTEXT,"CreateEvent failed with %d\n",
                GetLastError()));
            goto ErrorExit;
        }

        fNewEvent = TRUE;
    }


    DWORD err = NO_ERROR;

    if ( !ReadFile( hFile,
                    Buffer,
                    nBuffer,
                    nRead,
                    Overlapped )) {

        err = GetLastError();

        if ( (err != ERROR_IO_PENDING) &&
             (err != ERROR_HANDLE_EOF) ) {

            DBGPRINTF((DBG_CONTEXT,"Error %d in ReadFile\n",
                err));

            goto ErrorExit;
        }
    }

    if ( err == ERROR_IO_PENDING ) {

        if ( !GetOverlappedResult( hFile,
                                   Overlapped,
                                   nRead,
                                   TRUE )) {

            err = GetLastError();

            DBGPRINTF((DBG_CONTEXT,"Error %d in GetOverlappedResult\n",
                err));

            if ( err != ERROR_HANDLE_EOF ) {
                goto ErrorExit;
            }
        }
    }

    fRet = TRUE;

ErrorExit:

    if ( fNewEvent ) {
        DBG_REQUIRE(CloseHandle( ov.hEvent ));
    }

    return(fRet);

} // DoSynchronousReadFile
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\common\rnr.cxx ===
/*++

   Copyright    (c)    1996    Microsoft Corporation

   Module  Name :

        rnr.cxx     (ripped out of tsvcinfo.cxx)

   Abstract:

        Defines the functions for TCP services Info class.
        This module is intended to capture the common scheduler
            code for the tcp services ( especially internet services)
            which involves the Service Controller dispatch functions.
        Also this class provides an interface for common dll of servers.

   Author:

           Murali R. Krishnan    ( MuraliK )     15-Nov-1994

   Project:

          Internet Servers Common DLL

--*/

#include "tcpdllp.hxx"
#include <tsunami.hxx>
#include <iistypes.hxx>


#define  MAX_SOCKETS        ( 20)

#if 0
inline
BOOL
IsConnectionOriented(
    IN PPROTOCOL_INFO  pProtocolInfo
    )
{

    return ( ( pProtocolInfo->dwServiceFlags & XP_CONNECTIONLESS) == 0);

} // IsConnectionOriented()


inline
BOOL
IsReliable(
    IN PPROTOCOL_INFO  pProtocolInfo
    )
/*++

  This should be a protocol which delivers all packets and in order in which
  they are sent.
--*/
{
    return ( ( pProtocolInfo->dwServiceFlags & XP_GUARANTEED_DELIVERY) &&
             ( pProtocolInfo->dwServiceFlags & XP_GUARANTEED_ORDER)    &&
             IsConnectionOriented( pProtocolInfo));

} // IsReliable()



INT
GetValidListenAddresses( IN LPCTSTR      pszServiceName,
                         IN LPGUID       lpServiceGuid,
                         IN PCSADDR_INFO pcsAddrInfo,
                         IN OUT LPDWORD  lpcbAddrInfo )
/*++
  This function obtains the list of valid listen addresses for the service
   specified. It uses the RNR API set to enumerate the list of protocols
   installed in a machine and queries using GetAddressByName() to obtain
   the list of valid addresses that can be used for establishing a listen
   socket.

  Arguments:
    pszServiceName  pointer to null-terminated string containing service name.
    lpServiceGuid   pointer to GUID for the service.
    pcsAddrInfo     pointer to an array of CSADDR_INFO structures which
                     on successful return contains the address information.
    lpcbAddInfo     pointer to a DWORD containing the count of bytes
                     available under pcsAddrInfo. When this function is
                     called, it contains the number of bytes pointed to by
                     pcsAddrInfo. On return contains the number of
                     bytes required.

  Returns:
     count of valid CSADDR_INFO structures found for the given service to
       establish a listen socket.

     On error returns a value <= 0.
--*/
{
    int nAddresses = 0;       // assume a safe value == failure.

    DWORD  cbBuffer;
    int    cProtocols;
    PPROTOCOL_INFO  pProtocolInfo;
    int    rgProtocols[ MAX_SOCKETS + 1];
    int *  pProtocol;
    int    i;
    BUFFER buff;

#define ENUM_PROTO_BUFF_SIZE    49152

    //
    // First Look up the protocols installed on this machine. The
    //   EnumProtocols() API returns about all the windows sockets protocols
    //   loaded on this machine. We will use this information to identify the
    //   protocols which provide the necessary semantics.
    //

    if ( !buff.Resize( ENUM_PROTO_BUFF_SIZE )) {

        return 0;
    }

    cbBuffer = buff.QuerySize();
    cProtocols = EnumProtocols( NULL, buff.QueryPtr(), &cbBuffer);

    if ( cProtocols < 0) {

        return 0;
    }


    //
    // Walk through the available protocols and pick out the ones that
    //  support the desired characteristics.
    //

    for( pProtocolInfo = (PPROTOCOL_INFO ) buff.QueryPtr(),
         pProtocol = rgProtocols,
         i = 0;
         ( i < cProtocols &&
           ( pProtocol < rgProtocols + MAX_SOCKETS));
         pProtocolInfo++, i++ ) {

        if ( IsReliable( pProtocolInfo)) {

            //
            // This protocol matches our requirement of being reliable.
            //  Make a note of the protocol.
            //

            IF_DEBUG( DLL_SERVICE_INFO) {
                DBGPRINTF( ( DBG_CONTEXT,
                            " Protocol %d ( %s) matches condition\n",
                            pProtocolInfo->iProtocol,
                            pProtocolInfo->lpProtocol));
            }

            *pProtocol++ = pProtocolInfo->iProtocol;
        }

    } // for()   : Protocol filter ()

    IF_DEBUG( DLL_SERVICE_INFO) {
        DBGPRINTF( ( DBG_CONTEXT, " Filtering yields %d of %d protocols. \n",
                    ( pProtocol - rgProtocols), cProtocols));
    }

    // terminate the protocols array.
    *pProtocol = 0;
    cProtocols = ( pProtocol - rgProtocols);

    //
    // Make sure we found at least one acceptable protocol.
    // If there is no protocol on this machine, which suit our condition,
    //   this function fails.
    //

    if ( cProtocols > 0) {

        //
        // Use GetAddressByName() to get addresses for chosen protocols.
        // We restrict the scope of the search to those protocols of interest
        //  by passing the protocols array we generated. The function
        //  returns socket addresses only for the protocols we can support.
        //

        nAddresses = GetAddressByName(
                                      NS_DEFAULT, //  lpszNameSpace
                                      lpServiceGuid,
                                      (char *) pszServiceName,
                                      rgProtocols,
                                      RES_SERVICE | RES_FIND_MULTIPLE,
                                      NULL,       // lpServiceAsyncInfo
                                      (PVOID )pcsAddrInfo,
                                      lpcbAddrInfo,
                                      NULL,       // lpAliasBuffer
                                      NULL        // lpdwAliasBufferLen
                                      );

        IF_DEBUG( DLL_SERVICE_INFO) {

            // take a copy of error code and set it back, to avoid lost errors
            DWORD dwError = GetLastError();

            DBGPRINTF( ( DBG_CONTEXT,
                        " GetAddressByName() returned %d."
                        " Bytes Written=%d. Error = %ld\n",
                        nAddresses, *lpcbAddrInfo,
                        ( nAddresses <= 0) ? dwError: NO_ERROR));

            if ( nAddresses <= 0) { SetLastError( dwError); }
        }
    }
    return ( nAddresses);
} // GetValidListenAddress()
#endif




BOOL
RegisterServiceForAdvertising(
    IN LPCTSTR pszServiceName,
    IN LPGUID  lpServiceGuid,
    IN SOCKET  s,
    IN BOOL    fRegister
    )

/*++
  This function registers a service for the purpose of advertising.
  By registering using RnR apis, we advertise the fact that this particular
   service is running on the protocols designated. Hence RnR compliant
   clients can get access to the same.

  Arguments:
    pszService      name of the service
    lpServiceGuid   pointer to GUID for the service.
    s               socket whose address needs to be advertised.
    fRegister       whether to register to deregister

  Returns:
    TRUE on success and FALSE if there is any failure.
    Use GetLastError() for further details on failure.
--*/
{
    BOOL         fReturn = TRUE;
#if 0
    BYTE *       pbAddressBuffer;
    DWORD        cbAddressBuffer;
    INT          err;
    SERVICE_INFO serviceInfo;
    SERVICE_ADDRESSES  * pServiceAddress;

    DBG_ASSERT( pszServiceName && lpServiceGuid );
    DBG_ASSERT( s != INVALID_SOCKET );

    /*++
      Advertising service involves following steps:
      1. Set up a service info structure.
      2. Allocate memory for service addresses for as many sockets need to
           be advertised.
      3. Fill in the information containing the socket addresses
      4. Execute call for advertising the service (use SetService( REGISTER)).
      --*/

    //
    // Alloc space for SERVICE_ADDRESSES and n-1 SERVICE_ADDRESS structures.
    //
    pServiceAddress = ( ( SERVICE_ADDRESSES *)
                       TCP_ALLOC( sizeof( SERVICE_ADDRESSES) )
                       );

    // Alloc space for SOCKADDR addresses returned.
    cbAddressBuffer = sizeof(SOCKADDR);
    pbAddressBuffer = (BYTE *) TCP_ALLOC(cbAddressBuffer);

    if ( pServiceAddress == NULL || pbAddressBuffer == NULL) {

        if ( pServiceAddress != NULL)   { TCP_FREE( pServiceAddress); }
        if ( pbAddressBuffer != NULL)   { TCP_FREE( pbAddressBuffer); }
        SetLastError( ERROR_NOT_ENOUGH_MEMORY);
        return (FALSE);
    }

    //
    // set up service info structure.
    // Here the interesting fields are lpServiceType, lpServiceName,
    //  and lpServiceAddress fields.
    //
    serviceInfo.lpServiceType    = lpServiceGuid ;
    // surprisingly enough! RNR structures dont like constants
    serviceInfo.lpServiceName    = (LPTSTR ) pszServiceName ;
    // do we need better comment ? NYI
    serviceInfo.lpComment        = "Microsoft Internet Services";
    serviceInfo.lpLocale         = NULL;
    serviceInfo.lpMachineName    = NULL ;
    serviceInfo.dwVersion        = 1;
    serviceInfo.dwDisplayHint    = 0;
    serviceInfo.dwTime           = 0;
    serviceInfo.lpServiceAddress = pServiceAddress;

    serviceInfo.ServiceSpecificInfo.cbSize = 0 ;
    serviceInfo.ServiceSpecificInfo.pBlobData = NULL ;

    //
    // For each socket, get its local association and store the same.
    //

    PSOCKADDR    pSockAddr = (PSOCKADDR ) pbAddressBuffer;

    int size = (int) cbAddressBuffer;

    //
    // Call getsockname() to get the local association for the socket.
    //

    if ( getsockname( s, pSockAddr, &size) == 0 ) {

        //
        // Now setup the Addressing information for this socket.
        // Only the dwAddressType, dwAddressLength and lpAddress
        // is of any interest in this example.
        //

        pServiceAddress->Addresses[0].dwAddressType    = pSockAddr->sa_family;
        pServiceAddress->Addresses[0].dwAddressFlags   = 0;
        pServiceAddress->Addresses[0].dwAddressLength  = size ;
        pServiceAddress->Addresses[0].dwPrincipalLength= 0 ;
        pServiceAddress->Addresses[0].lpAddress        = (LPBYTE) pSockAddr;
        pServiceAddress->Addresses[0].lpPrincipal      = NULL ;

        //
        // Advance pointer and adjust buffer size. Assumes that
        // the structures are aligned.  Unaligned accesses !! NYI
        //

        cbAddressBuffer -= size;
        pSockAddr = (PSOCKADDR) ((BYTE*)pSockAddr + size);

        pServiceAddress->dwAddressCount = 1;

        //
        // If we got at least one address, go ahead and advertise it.
        //

        DWORD  dwStatusFlags;
        err =  SetService(
                   NS_DEFAULT,       // for all default name spaces
                   fRegister ? SERVICE_REGISTER : SERVICE_DEREGISTER,
                   0,                // no flags specified
                   &serviceInfo,     // SERVICE_INFO structure
                   NULL,             // no async support yet
                   &dwStatusFlags) ;   // returns status flags
        IF_DEBUG( DLL_CONNECTION ) {

            DBGPRINTF(( DBG_CONTEXT, " SetService(%s, NS_DEFAULT, Register=%d)"
                       " returns Status = %08x,"
                       " err = %d\n",
                       pszServiceName, fRegister,
                       dwStatusFlags, err));
        }

    } else {

        SetLastError( ERROR_INVALID_PARAMETER);
        fReturn = FALSE;
    }

    TCP_FREE( pbAddressBuffer);
    TCP_FREE( pServiceAddress);
#endif
    return ( fReturn);

} // RegisterServiceForAdvertising()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\common\tokenacl.cxx ===
/*===================================================================
Microsoft Internet Information Server

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

File: TokenAcl.cxx

Owner: AndrewS

This file contains code related to NT security on impersonation tokens
===================================================================*/
#include "tcpdllp.hxx"
#pragma hdrstop


// Local Defines


// Local functions
HRESULT ExpandAcl(PACL paclOld, ULONG cbAclOld, PACL *ppAclNew, PSID psid);
HRESULT AddSidToTokenAcl(HANDLE hToken, PSID pSid, ACCESS_MASK amDesiredAccess);
HRESULT GetEveryoneSid(PSID *ppSidEveryone);


/*===================================================================
GrantAllAccessToToken

Given an impersonation token, grant "Everyone" permissions to that
token so that Out Of Proc ISAPIs will be able to do a GetThreadToken call.

Parameters:
    HANDLE hToken - handle to impersonation token for a user

Returns:
    HRESULT        NOERROR on success
===================================================================*/
HRESULT GrantAllAccessToToken
(
HANDLE hToken
)
    {
    HRESULT hr = NOERROR;
    DWORD err;
    PSID pSidEveryone;

    hr = GetEveryoneSid(&pSidEveryone);
    if (FAILED(hr))
        goto LExit;
        
    hr = AddSidToTokenAcl(hToken, pSidEveryone, TOKEN_ALL_ACCESS);

    FreeSid( pSidEveryone );

LExit:
    DBG_ASSERT(SUCCEEDED(hr));

    return(hr);
    }
    
/*===================================================================
AddSidToTokenAcl

When creating Local server objects (e.g. EXE's) we have some problems because of DCOM security.
The user creating the object must have appropriate permissions on the IIS process WindowStation (bug 549)
and the Desktop.

Add ACE's on the ACL for our WindowStation & Desktop for the current user.

Parameters:
    HANDLE hImpersonate - handle to impersonation token for the current user

Returns:
    HRESULT        NOERROR on success
===================================================================*/
HRESULT AddSidToTokenAcl
(
HANDLE hToken,
PSID pSid,
ACCESS_MASK amDesiredAccess
)
    {
    HRESULT hr;
    DWORD err;
    PSECURITY_DESCRIPTOR psdRelative = NULL;
    SECURITY_DESCRIPTOR sdAbsolute;
    ULONG cbSdPost;
    PACL pDacl = NULL;
    PACL pDaclNew = NULL;
    ULONG cbSD;
    ULONG cbDacl;
    ULONG cbSacl;
    ULONG cbOwner;
    ULONG cbGroup;
    ACL_SIZE_INFORMATION AclSize;

    //
    // Get the SD of the token.
    // Call this twice; once to get the size, then again to get the info
    //
    GetKernelObjectSecurity(hToken,
                            DACL_SECURITY_INFORMATION,
                            NULL,
                            0,
                            &cbSD);

    psdRelative = (PSECURITY_DESCRIPTOR) new BYTE[cbSD];
    if (psdRelative == NULL)
        {
        hr = E_OUTOFMEMORY;
        goto LExit;
        }

    if (!GetKernelObjectSecurity(hToken,
                                 DACL_SECURITY_INFORMATION,
                                 psdRelative,
                                 cbSD,
                                 &cbSD))
        {
        DBG_ASSERT(FALSE);

        err = GetLastError();
        hr = HRESULT_FROM_WIN32(err);
        goto LExit;
        }

    //
    // Allocate a new Dacl
    //
    pDacl = (PACL) new BYTE[cbSD];
    if (pDacl == NULL)
        {
        hr = E_OUTOFMEMORY;
        goto LExit;
        }

    //
    // Make an absolute SD from the relative SD we have, and get the Dacl at the same time
    //
    cbSdPost = sizeof(sdAbsolute);
    cbDacl = cbSD;
    cbSacl = 0;
    cbOwner = 0;
    cbGroup = 0;
    if (!MakeAbsoluteSD(psdRelative,
                        &sdAbsolute,
                        &cbSdPost,
                        pDacl,
                        &cbDacl,
                        NULL,
                        &cbSacl,
                        NULL,
                        &cbOwner,
                        NULL,
                        &cbGroup))
        {
        DBG_ASSERT(FALSE);

        err = GetLastError();
        hr = HRESULT_FROM_WIN32(err);
        goto LExit;
        }

    //
    // Copy ACEs over
    //
    hr = ExpandAcl(pDacl, cbSD, &pDaclNew, pSid);
    if (FAILED(hr))
        goto LExit;
    
    //
    // Add ACE to allow access
    //
    if (!AddAccessAllowedAce(pDaclNew, ACL_REVISION, amDesiredAccess, pSid))
        {
        DBG_ASSERT(FALSE);

        err = GetLastError();
        hr = HRESULT_FROM_WIN32(err);
        goto LExit;
        }

    //
    // Set the new DACL in the SD
    //
    if (!SetSecurityDescriptorDacl(&sdAbsolute, TRUE, pDaclNew, FALSE))
        {
        DBG_ASSERT(FALSE);

        err = GetLastError();
        hr = HRESULT_FROM_WIN32(err);
        goto LExit;
        }

    //
    // Set the new SD on the token object
    //
    if (!SetKernelObjectSecurity(hToken, DACL_SECURITY_INFORMATION, &sdAbsolute))
        {
        DBG_ASSERT(FALSE);

        err = GetLastError();
        hr = HRESULT_FROM_WIN32(err);
        goto LExit;
        }

LExit:
    delete pDacl;
    delete pDaclNew;
    delete psdRelative;

    return hr;
    }

/*===================================================================
GetEveryoneSid

Get a sid for "Everyone"

Parameters:
    PSID pSidEveryone
    
Returns:
    HRESULT        NOERROR on success
===================================================================*/
HRESULT GetEveryoneSid
(
PSID *ppSidEveryone
)
    {
    BOOL fT;
    SID_IDENTIFIER_AUTHORITY sidWorldAuthority = SECURITY_WORLD_SID_AUTHORITY;

    fT = AllocateAndInitializeSid(
                 &sidWorldAuthority,    // pIdentifierAuthority
                 1,                     // nSubAuthorityCount
                 SECURITY_WORLD_RID,    // nSubAuthority0
                 0,                     // nSubAuthority1
                 0,                     // nSubAuthority2
                 0,                     // nSubAuthority3
                 0,                     // nSubAuthority4
                 0,                     // nSubAuthority5
                 0,                     // nSubAuthority6
                 0,                     // nSubAuthority7
                 ppSidEveryone          // pSid
                 );
    if( !fT )
        return HRESULT_FROM_WIN32(GetLastError());
    else
        return NOERROR;
    }

/*===================================================================
ExpandAcl

Support routine for AddWindowStationSecurity.

Expands the given ACL so that there is room for an additional ACE

Parameters:
    paclOld    - the old ACL to expand
    ppAclNew   - the newly allocated expanded acl
    psid       - the sid to use

Returns:
    HRESULT        NOERROR on success
===================================================================*/
HRESULT ExpandAcl
(
PACL paclOld,
ULONG cbAclOld,
PACL *ppAclNew,
PSID psid
)
    {
    HRESULT                 hr;
    DWORD                   err;
    PACL                    pAclNew = NULL;
    ACL_SIZE_INFORMATION    asi;
    int                     dwAclSize;
    DWORD                   iAce;
    LPVOID                  pAce;

    DBG_ASSERT(paclOld != NULL);
    DBG_ASSERT(ppAclNew != NULL);
    
    //
    // Create a new ACL to play with
    //
    if (!GetAclInformation (paclOld, (LPVOID) &asi, (DWORD) sizeof (asi), AclSizeInformation))
        goto LExit;

    dwAclSize = cbAclOld + GetLengthSid(psid) + (8 * sizeof(DWORD));

    pAclNew = (PACL) new BYTE[dwAclSize];
    if (pAclNew == NULL)
        {
        return(E_OUTOFMEMORY);
        }
        
    if (!InitializeAcl(pAclNew, dwAclSize, ACL_REVISION))
        goto LExit;

    //
    // Copy all of the ACEs to the new ACL
    //
    for (iAce = 0; iAce < asi.AceCount; iAce++)
        {
        //
        // Get the ACE and header info
        //
        if (!GetAce(paclOld, iAce, &pAce))
            goto LExit;

        //
        // Add the ACE to the new list
        //
        if (!AddAce(pAclNew, ACL_REVISION, iAce, pAce, ((ACE_HEADER *)pAce)->AceSize))
            goto LExit;
        }

    *ppAclNew = pAclNew;
    return(NOERROR);
    
LExit:
    if (pAclNew != NULL)
        delete pAclNew;
    
    DBG_ASSERT(FALSE);

    err = GetLastError();
    hr = HRESULT_FROM_WIN32(err);
    return hr;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\common\tsvccfg.cxx ===
/*++

   Copyright    (c)    1994    Microsoft Corporation

   Module  Name :

        tsvccfg.cxx

   Abstract:

        Defines the functions for TCP services Info class.
        This module is intended to capture the common scheduler
            code for the tcp services ( especially internet services)
            which involves the Service Controller dispatch functions.
        Also this class provides an interface for common dll of servers.

   Author:

           Murali R. Krishnan    ( MuraliK )     15-Nov-1994

   Project:

          Internet Servers Common DLL

--*/

#include "tcpdllp.hxx"
#include <rpc.h>
#include <tsunami.hxx>
#include <iistypes.hxx>
#include <iisendp.hxx>
#include <iisbind.hxx>
#include <iisassoc.hxx>
#include "inetreg.h"
#include "tcpcons.h"
#include "apiutil.h"
#include <rdns.hxx>

#include <ole2.h>
#include <imd.h>
#include <inetreg.h>
#include <mb.hxx>

//
// Used to configure
//

typedef struct _IIS_SOCKET_CONFIG {
    DWORD nAcceptExOutstanding;
} IIS_SOCKET_CONFIG;
IIS_SOCKET_CONFIG TsSocketConfig[3] = {{5}, {40}, {100}};

//
// private functions
//

extern VOID
CopyUnicodeStringToBuffer(
   OUT WCHAR * pwchBuffer,
   IN  DWORD   cchMaxSize,
   IN  LPCWSTR pwszSource
   );


DWORD
SetInetLogConfiguration(
        IN LOGGING *pLogging,
        IN EVENT_LOG * pEventLog,
        IN const INET_LOG_CONFIGURATION * pRpcLogConfig
        );

DWORD
GetRPCLogConfiguration(
        LOGGING *pLogging,
        OUT LPINET_LOG_CONFIGURATION * ppLogConfig
        );

BOOL
GenerateIpList(
    BOOL fIsGrant,
    ADDRESS_CHECK *pCheck,
    LPINET_INFO_IP_SEC_LIST *ppInfo
    );

BOOL
FillAddrCheckFromIpList(
    BOOL fIsGrant,
    LPINET_INFO_IP_SEC_LIST pInfo,
    ADDRESS_CHECK *pCheck
    );

BOOL
GetVrootCount(
    PVOID          pvContext,
    MB *           pmb,
    VIRTUAL_ROOT * pvr
    );

BOOL
GetVroots(
    PVOID          pvContext,
    MB *           pmb,
    VIRTUAL_ROOT * pvr
    );

VOID
CopyUnicodeStringToBuffer(
   OUT WCHAR * pwchBuffer,
   IN  DWORD   cchMaxSize,
   IN  LPCWSTR pwszSource)
/*
   copies at most cbMaxSize-1 characters from pwszSource to pwchBuffer
*/
{
    DBG_ASSERT( pwszSource != NULL);

    DWORD cchLen = lstrlenW( pwszSource);
    if ( cchLen >= cchMaxSize) {

        DBGPRINTF( ( DBG_CONTEXT,
                    "Long String ( %d chars) %ws given."
                    " Truncating to %d chars\n",
                    cchLen, pwszSource,
                    cchMaxSize - 1));


    //  There is a bug in the lstrcpyn. hence need to work around it.
#ifndef  LSTRCPYN_DEBUGGED
        cchLen = cchMaxSize - 2;
# else
       cchLen = cchMaxSize -1;
# endif
    }

#ifndef  LSTRCPYN_DEBUGGED
    lstrcpynW( pwchBuffer, pwszSource, cchLen + 1);
# else
    lstrcpynW( pwchBuffer, pwszSource, cchLen );
# endif

    return;
} // CopyUnicodeStringToBuffer()




BOOL
IIS_SERVER_INSTANCE::GetCommonConfig(
                                IN OUT PCHAR pConfig,
                                IN DWORD dwLevel
                                )
/*++
  This function copies the current configuration for a service (IIS_SERVER_INSTANCE)
    into the given RPC object pConfig.
  In case of any failures, it deallocates any memory block that was
     allocated during the process of copy by this function alone.

  Arguments:
     pConfig  - pointer to RPC configuration object for a service.
     dwLevel  - level of our configuration.

  Returns:

     TRUE for success and FALSE for any errors.
--*/
{
    BOOL fReturn = TRUE;
    LPINETA_CONFIG_INFO pInfoConfig = (LPINETA_CONFIG_INFO)pConfig;
    ADDRESS_CHECK       acCheck;
    BOOL                fMustRel;
    MB                  mb( (IMDCOM*) m_Service->QueryMDObject() );
    DWORD               cRoots = 0;
    STR                 strAnon;
    STR                 strAnonPwd;
    STR                 strServerComment;
    DWORD               err = NO_ERROR;


    IF_DEBUG(INSTANCE) {
        DBGPRINTF((DBG_CONTEXT,"GetCommonConfig called with L%d for instance %d\n",
            dwLevel, QueryInstanceId() ));
    }

    LockThisForRead();

    //
    //  Get always retrieves all of the parameters except for the anonymous
    //  password, which is retrieved as a secret
    //

    pInfoConfig->FieldControl = (FC_INET_INFO_ALL & ~FC_INET_INFO_ANON_PASSWORD);

    pInfoConfig->dwConnectionTimeout = QueryConnectionTimeout();
    pInfoConfig->dwMaxConnections    = QueryMaxConnections();

    pInfoConfig->LangId              = GetSystemDefaultLangID();
    pInfoConfig->LocalId             = GetSystemDefaultLCID();

    //
    //  This is the PSS product ID
    //

    ZeroMemory( pInfoConfig->ProductId,sizeof( pInfoConfig->ProductId ));

    //
    //  Copy the strings
    //

    fReturn = (ConvertStringToRpc(&pInfoConfig->lpszAdminName,
                                  ""/*QueryAdminName()*/ )           &&
               ConvertStringToRpc( &pInfoConfig->lpszAdminEmail,
                                  "" /*QueryAdminEmail()*/ )
               );

    if ( !fReturn ) {

        IF_DEBUG(INSTANCE) {
            DBGPRINTF((DBG_CONTEXT,"ConvertStringToRpc failed with %d\n",
                GetLastError() ));
        }

        goto Exit;
    } else {

        DWORD dwError;

        dwError = GetRPCLogConfiguration(&m_Logging,
                                         &pInfoConfig->lpLogConfig);

        if ( dwError != NO_ERROR)  {

            IF_DEBUG(INSTANCE) {
                DBGPRINTF((DBG_CONTEXT,"GetRPCLogConfiguration failed with %d\n",
                    dwError));
            }
            SetLastError( dwError);
            fReturn = FALSE;
            goto Exit;
        }
    }

    pInfoConfig->fLogAnonymous       = QueryLogAnonymous();
    pInfoConfig->fLogNonAnonymous    = QueryLogNonAnonymous();

    ZeroMemory(
        pInfoConfig->szAnonPassword,
        sizeof( pInfoConfig->szAnonPassword )
        );

    //
    //  Copy the IP security info from metabase
    //

    if ( mb.Open( QueryMDVRPath() ) )
    {
        VOID * pvData;
        DWORD  cbData;
        DWORD  dwTag;

        if ( mb.ReferenceData( "",
                               MD_IP_SEC,
                               IIS_MD_UT_FILE,
                               BINARY_METADATA,
                               &pvData,
                               &cbData,
                               &dwTag ) &&
             dwTag )
        {
            acCheck.BindCheckList( (BYTE *) pvData, cbData );
            fMustRel = TRUE;
        }
        else
        {
            fMustRel = FALSE;
        }

        fReturn = GenerateIpList( TRUE, &acCheck, &pInfoConfig->GrantIPList ) &&
                  GenerateIpList( FALSE, &acCheck, &pInfoConfig->DenyIPList );

        if ( fMustRel )
        {
            DBG_REQUIRE( mb.ReleaseReferenceData( dwTag ));
        }

        DBG_REQUIRE( mb.Close() );
    }
    else
    {
        fReturn = FALSE;
    }

    if ( !fReturn )
    {
        goto Exit;
    }

    //
    //  Copy the virtual root info, note a NULL VirtualRoots is not
    //  valid as it is for IP security.  This should be the last
    //  allocated item for the pConfig structure
    //

    if ( !mb.Open( QueryMDPath(),
                   METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE ))
    {
        fReturn = FALSE;
        goto Exit;
    }

    if ( TsEnumVirtualRoots( GetVrootCount, &cRoots, &mb ) )
    {
        DWORD cbSize = sizeof(INET_INFO_VIRTUAL_ROOT_LIST) +
                       cRoots * sizeof(INET_INFO_VIRTUAL_ROOT_ENTRY)
                       ;
        pInfoConfig->VirtualRoots = (LPINET_INFO_VIRTUAL_ROOT_LIST)
                 MIDL_user_allocate( cbSize );

        memset( pInfoConfig->VirtualRoots, 0, cbSize );

        if ( pInfoConfig->VirtualRoots )
        {
            fReturn = TsEnumVirtualRoots( GetVroots, pInfoConfig->VirtualRoots, &mb );
        }

        // only used for UNC virtual directories (to store the passwords)
        err = TsSetSecretW( m_lpwszRootPasswordSecretName,
                            L"",
                            sizeof(WCHAR) );
        if ( err == ERROR_ACCESS_DENIED && g_fW3OnlyNoAuth )
        {
            err = 0;
        }
    }

    mb.Close();

    if ( !fReturn )
    {
        goto Exit;
    }

    if ( !mb.Open( QueryMDPath() ))
    {
        fReturn = FALSE;
        goto Exit;
    }

    mb.GetDword( "",
                 MD_AUTHORIZATION,
                 IIS_MD_UT_FILE,
                 MD_AUTH_ANONYMOUS,
                 &pInfoConfig->dwAuthentication );

    if ( !mb.GetStr( "",
                     MD_ANONYMOUS_USER_NAME,
                     IIS_MD_UT_FILE,
                     &strAnon,
                     METADATA_INHERIT,
                     "<>" ))
    {
        fReturn = FALSE;
        goto Exit;
    }

    if ( !mb.GetStr( "",
                     MD_SERVER_COMMENT,
                     IIS_MD_UT_SERVER,
                     &strServerComment,
                     METADATA_INHERIT,
                     INETA_DEF_SERVER_COMMENT ))
    {
        //
        // If this is a single instance service, this is also the
        // service comment
        //

        if ( !m_Service->IsMultiInstance() ) {
            m_Service->SetServiceComment( strServerComment.QueryStr() );
        }
    }

    fReturn = ConvertStringToRpc( &pInfoConfig->lpszServerComment,
                                  strServerComment.QueryStr() ) &&
              ConvertStringToRpc( &pInfoConfig->lpszAnonUserName,
                                  strAnon.QueryStr() );

    //
    //  Get the anonymous user password but store it as an LSA secret
    //

    if ( mb.GetStr( "",
                    MD_ANONYMOUS_PWD,
                    IIS_MD_UT_FILE,
                    &strAnonPwd,
                    METADATA_INHERIT | METADATA_SECURE ))
    {
        BUFFER buff;

        if ( buff.Resize( (strAnonPwd.QueryCCH() + 1) * sizeof(WCHAR )))
        {
            if ( MultiByteToWideChar( CP_ACP,
                                      MB_PRECOMPOSED,
                                      strAnonPwd.QueryStr(),
                                      strAnonPwd.QueryCCH() + 1,
                                      (LPWSTR) buff.QueryPtr(),
                                      strAnonPwd.QueryCCH() + 1 ))
            {
                err = TsSetSecretW( m_lpwszAnonPasswordSecretName,
                                    (LPWSTR) buff.QueryPtr(),
                                    wcslen( (LPWSTR) buff.QueryPtr()) * sizeof(WCHAR) );
                if ( err == ERROR_ACCESS_DENIED && g_fW3OnlyNoAuth )
                {
                    err = 0;
                }
            }
        }
    }
    else
    {
        //
        //  store an empty password if there's no anonymous user at this level
        //

        err = TsSetSecretW( m_lpwszAnonPasswordSecretName,
                            L"",
                            sizeof(WCHAR) );
        if ( err == ERROR_ACCESS_DENIED && g_fW3OnlyNoAuth )
        {
            err = 0;
        }
    }

    if ( err ) {
        SetLastError( err );
        fReturn = FALSE;
    }

    if ( !fReturn ) {
        IF_DEBUG(INSTANCE) {
            DBGPRINTF((DBG_CONTEXT,"Cannot get anonymous user name"));
        }
    }

Exit:

    if ( !fReturn ) {

        if ( pInfoConfig->lpLogConfig != NULL) {

            MIDL_user_free( pInfoConfig->lpLogConfig);
            pInfoConfig->lpLogConfig = NULL;
        }

        //
        //  FreeRpcString checks for NULL pointer
        //

        FreeRpcString( pInfoConfig->lpszAdminName );
        FreeRpcString( pInfoConfig->lpszAdminEmail );
        FreeRpcString( pInfoConfig->lpszServerComment );
        FreeRpcString( pInfoConfig->lpszAnonUserName );

        pInfoConfig->lpszAdminName     = NULL;
        pInfoConfig->lpszAdminEmail    = NULL;
        pInfoConfig->lpszServerComment = NULL;
        pInfoConfig->lpszAnonUserName  = NULL;

        if ( pInfoConfig->DenyIPList ) {

            MIDL_user_free( pInfoConfig->DenyIPList );
            pInfoConfig->DenyIPList = NULL;
        }

        if ( pInfoConfig->GrantIPList ) {
            MIDL_user_free( pInfoConfig->GrantIPList );
            pInfoConfig->GrantIPList = NULL;
        }
    }

    UnlockThis();

    return (fReturn);

} // IIS_SERVER_INSTANCE::GetConfiguration()



BOOL
IIS_SERVER_INSTANCE::RegReadCommonParams(
    BOOL fReadAll,
    BOOL fReadVirtualDirs
    )
/*++

   Description

     Reads the service common items from the registry

   Arguments:

     fReadAll - If TRUE read all parameters.
                If FALSE read only those parameters that are necessary for initialization.

     fReadVirtualDirs - Initalize Virtual DIrectories.

   Note:

--*/
{
    MB                      mb( (IMDCOM*) m_Service->QueryMDObject()  );

    DBG_ASSERT( QueryInstanceId() != INET_INSTANCE_ROOT );

    IF_DEBUG( DLL_RPC) {
        DBGPRINTF(( DBG_CONTEXT,
                   "IIS_SERVER_INSTANCE::ReadParamsFromRegistry() Entered. fReadAll = %d\n",
                   fReadAll));
    }

    //
    // Open the metabase and read parameters for IIS_SERVER_INSTANCE object
    // itself.
    //


    if ( !mb.Open( QueryMDPath(),
                   TsIsNtServer() ? METADATA_PERMISSION_READ :
                                    METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE ))
    {
        DBGPRINTF(( DBG_CONTEXT,
                   "[ReadParamsFromRegistry] mb.Open returned error %d for path %s\n",
                    GetLastError(),
                    QueryMDPath() ));

    }

    LockThisForWrite();

    //
    // Values needed for initialization
    //

    mb.GetDword( "",
                 MD_SERVER_AUTOSTART,
                 IIS_MD_UT_SERVER,
                 TRUE,
                 (DWORD *) &m_fAutoStart,
                 METADATA_NO_ATTRIBUTES
                 );

    mb.GetDword( "",
                 MD_CLUSTER_ENABLED,
                 IIS_MD_UT_SERVER,
                 FALSE,
                 (DWORD *) &m_fClusterEnabled
                 );

    /*
    That's a fix for a bug 367791 when restarting IIS with
    vhost sites marked for auto restart isn't bringing them online
    becuase of current disgn limitation how cluster service is checking for helth of
    vhost site it is not able to distinguish  that only one of few vhost sites are running
    and is not starting the rest. The fix is to allow to admin to set autorestart on site
    and then during startup of IIS to start that site not with cluster command but automaticcally
    Because of that the following lines are removed.

    if ( m_fClusterEnabled )
    {
        m_fAutoStart = FALSE;
    }
    */

    if ( !mb.GetStr( "",
                     MD_SERVER_COMMENT,
                     IIS_MD_UT_SERVER,
                     &m_strSiteName ) ||
         m_strSiteName.IsEmpty())
    {
        m_strSiteName.Copy(QueryMDPath());
    }

    //
    // Other values needed to run the instance
    //

    if ( fReadAll)
    {

        mb.GetDword( "",
                     MD_CONNECTION_TIMEOUT,
                     IIS_MD_UT_SERVER,
                     INETA_DEF_CONNECTION_TIMEOUT,
                     &m_dwConnectionTimeout
                     );

        mb.GetDword( "",
                     MD_MAX_CONNECTIONS,
                     IIS_MD_UT_SERVER,
                     INETA_DEF_MAX_CONNECTIONS,
                     &m_dwMaxConnections
                     );

        mb.GetDword( "",
                     MD_MAX_ENDPOINT_CONNECTIONS,
                     IIS_MD_UT_SERVER,
                     (TsIsNtServer()
                      ? TsSocketConfig[MD_SERVER_SIZE_LARGE].nAcceptExOutstanding
                      : INETA_DEF_MAX_ENDPOINT_CONNECTIONS_PWS
                      ),
                     &m_dwMaxEndpointConnections
                     );

        mb.GetDword( "",
                     MD_LEVELS_TO_SCAN,
                     IIS_MD_UT_SERVER,
                     INETA_DEF_LEVELS_TO_SCAN,
                     &m_dwLevelsToScan
                     );

        //
        // if not NTS, limit the connections.  If reg value exceeds 40,
        // set it to 10.
        //

        if ( !TsIsNtServer() ) {

            if ( m_dwMaxConnections > INETA_MAX_MAX_CONNECTIONS_PWS ) {
                m_dwMaxConnections = INETA_DEF_MAX_CONNECTIONS_PWS;

                mb.SetDword( "",
                             MD_MAX_CONNECTIONS,
                             IIS_MD_UT_SERVER,
                             m_dwMaxConnections
                             );
            }

            if ( m_dwMaxEndpointConnections > INETA_MAX_MAX_ENDPOINT_CONNECTIONS_PWS ) {
                m_dwMaxEndpointConnections = INETA_DEF_MAX_ENDPOINT_CONNECTIONS_PWS;

                mb.SetDword( "",
                             MD_MAX_ENDPOINT_CONNECTIONS,
                             IIS_MD_UT_SERVER,
                             m_dwMaxEndpointConnections
                             );
            }
        }

        //
        //  Log anonymous and Log non-anonymous or for FTP only
        //

        mb.GetDword( "",
                     MD_LOG_TYPE,
                     IIS_MD_UT_SERVER,
                     TRUE,
                     (DWORD *) &m_fLoggingEnabled
                     );

        mb.GetDword( "",
                     MD_LOG_ANONYMOUS,
                     IIS_MD_UT_SERVER,
                     INETA_DEF_LOG_ANONYMOUS,
                     (DWORD *) &m_fLogAnonymous
                     );

        mb.GetDword( "",
                     MD_LOG_NONANONYMOUS,
                     IIS_MD_UT_SERVER,
                     INETA_DEF_LOG_NONANONYMOUS,
                     (DWORD *) &m_fLogNonAnonymous
                     );

#if 0
        //
        // I don't believe that ServerCommand can be set to
        // started without our noticing, so I'm removing this
        // code.
        //
        if (!m_fAutoStart) {

            //
            // Server Command to start this instance may
            // have been written while service was stopped.
            // Need to pick it up
            //

            DWORD dwServerCommand;

            mb.GetDword( "",
                         MD_SERVER_COMMAND,
                         IIS_MD_UT_SERVER,
                         TRUE,
                         (DWORD *) &dwServerCommand
                         );

            if (dwServerCommand == MD_SERVER_COMMAND_START) {
                m_fAutoStart = TRUE;
            }

        }
#endif

        //
        //  Other fields
        //

        //
        // socket values
        //

        mb.GetDword( "",
                     MD_SERVER_SIZE,
                     IIS_MD_UT_SERVER,
                     INETA_DEF_SERVER_SIZE,
                     &m_dwServerSize
                     );

        if ( m_dwServerSize > MD_SERVER_SIZE_LARGE ) {
            m_dwServerSize = INETA_DEF_SERVER_SIZE;
        }

        mb.GetDword( "",
                     MD_SERVER_LISTEN_BACKLOG,
                     IIS_MD_UT_SERVER,
                     TsSocketConfig[m_dwServerSize].nAcceptExOutstanding,
                     &m_nAcceptExOutstanding
                     );

        mb.GetDword( "",
                     MD_SERVER_LISTEN_TIMEOUT,
                     IIS_MD_UT_SERVER,
                     INETA_DEF_ACCEPTEX_TIMEOUT,
                     &m_AcceptExTimeout
                     );
        //
        // Setup a bandwidth throttle descriptor if necessary (for NT server)
        //

        SetBandwidthThrottle( &mb );

        //
        // Set the maximum number of blocked requests for throttler
        //

        SetBandwidthThrottleMaxBlocked( &mb );

        // Root instance does not have VRs.  Close the metabase because the
        // virtual directories are going to be re-enumerated.
        //
    }

    mb.Close();

    if ( fReadVirtualDirs ) {
        TsReadVirtualRoots( );
    }

    UnlockThis();
    return TRUE;

} // IIS_SERVER_INSTANCE::ReadParamsFromRegistry()



BOOL
IIS_SERVER_INSTANCE::SetCommonConfig(
    IN LPINETA_CONFIG_INFO  pInfoConfig,
    IN BOOL  fRefresh
    )
/*++

   Description

     Writes the service common items to the registry

   Arguments:

      pInfoConfig - Admin items to write to the registry
      fRefresh    - Indicates whether we need to read back the data

   Note:
      We don't need to lock "this" object because we only write to the registry

      The anonymous password is set as a secret from the client side

--*/
{
    DWORD               err = NO_ERROR;
    FIELD_CONTROL       fcConfig;
    ADDRESS_CHECK       acCheck;
    BUFFER              buff;

    MB                  mb( (IMDCOM*) m_Service->QueryMDObject()  );

    //
    // Open the metabase and read parameters for IIS_SERVER_INSTANCE object
    // itself.
    //

    if ( !mb.Open( QueryMDPath(),
                   METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE )) {

        DBGPRINTF(( DBG_CONTEXT,
                   "[SetCommonConfig] mb.Open returned error %d for path %s\n",
                    GetLastError(),
                    QueryMDPath() ));


        return FALSE;
    }


    fcConfig = pInfoConfig->FieldControl;

    if ( IsFieldSet( fcConfig, FC_INET_INFO_CONNECTION_TIMEOUT ))
    {
        mb.SetDword( "",
                     MD_CONNECTION_TIMEOUT,
                     IIS_MD_UT_SERVER,
                     pInfoConfig->dwConnectionTimeout );
    }

    if ( (err == NO_ERROR) && IsFieldSet( fcConfig, FC_INET_INFO_MAX_CONNECTIONS ))
    {
        mb.SetDword( "",
                     MD_MAX_CONNECTIONS,
                     IIS_MD_UT_SERVER,
                     pInfoConfig->dwMaxConnections );
    }

    if ( (err == NO_ERROR) &&
         IsFieldSet( fcConfig, FC_INET_INFO_SERVER_COMMENT ) &&
         (pInfoConfig->lpszServerComment != NULL) )
    {
        if ( buff.Resize( 2 * (wcslen(pInfoConfig->lpszServerComment) + 1) *
                          sizeof(CHAR) ) )
        {
            (VOID) ConvertUnicodeToAnsi( pInfoConfig->lpszServerComment,
                                         (CHAR *) buff.QueryPtr(),
                                         buff.QuerySize() );

            mb.SetString( "",
                          MD_SERVER_COMMENT,
                          IIS_MD_UT_SERVER,
                          (CHAR *) buff.QueryPtr() );
        }
    }

    if ( (err == NO_ERROR) &&
         IsFieldSet( fcConfig, FC_INET_INFO_ANON_USER_NAME ) &&
         (pInfoConfig->lpszAnonUserName != NULL) )
    {
        STR strAnonPwd;

        if ( buff.Resize( 2 * (wcslen(pInfoConfig->lpszAnonUserName) + 1) *
                          sizeof(CHAR) ) )
        {
            (VOID) ConvertUnicodeToAnsi( pInfoConfig->lpszAnonUserName,
                                         (CHAR *) buff.QueryPtr(),
                                         buff.QuerySize() );

            mb.SetString( "",
                          MD_ANONYMOUS_USER_NAME,
                          IIS_MD_UT_FILE,
                          (CHAR *) buff.QueryPtr() );
        }

        //
        //  Set the anonymous password also.  The client sets it as an LSA
        //  secret
        //

        if ( TsGetSecretW( m_lpwszAnonPasswordSecretName,
                           &strAnonPwd ) &&
             mb.SetString( "",
                           MD_ANONYMOUS_PWD,
                           IIS_MD_UT_FILE,
                           strAnonPwd.QueryStr() ))
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "Failed to get/set anonymous secret, err %d\n",
                        GetLastError() ));
        }

    }

    if ( (err == NO_ERROR) && IsFieldSet( fcConfig, FC_INET_INFO_AUTHENTICATION ))
    {
        mb.SetDword( "",
                     MD_AUTHORIZATION,
                     IIS_MD_UT_FILE,
                     pInfoConfig->dwAuthentication );
    }

    //
    //  Write other fields
    //

    if ( (err == NO_ERROR) &&
         IsFieldSet( fcConfig, FC_INET_INFO_SITE_SECURITY ))
    {
        if ( (pInfoConfig->GrantIPList && pInfoConfig->GrantIPList->cEntries)
             || (pInfoConfig->DenyIPList && pInfoConfig->DenyIPList->cEntries) )
        {
            acCheck.BindCheckList( NULL, 0 );

            if ( FillAddrCheckFromIpList( TRUE, pInfoConfig->GrantIPList, &acCheck ) &&
                 FillAddrCheckFromIpList( FALSE, pInfoConfig->DenyIPList, &acCheck ) )
            {
                if ( !mb.SetData( IIS_MD_INSTANCE_ROOT,
                                  MD_IP_SEC,
                                  IIS_MD_UT_FILE,
                                  BINARY_METADATA,
                                  (acCheck.GetStorage()->GetAlloc()
                                         ? acCheck.GetStorage()->GetAlloc() : (LPBYTE)""),
                                  acCheck.GetStorage()->GetUsed(),
                                  METADATA_INHERIT | METADATA_REFERENCE ))
                {
                    err = GetLastError();
                }
            }

            acCheck.UnbindCheckList();
        }
        else
        {
            if ( !mb.DeleteData( IIS_MD_INSTANCE_ROOT,
                                 MD_IP_SEC,
                                 IIS_MD_UT_FILE,
                                 BINARY_METADATA ) )
            {
                // not an error : property may not exists
                //err = GetLastError();
            }
        }
    }

    DBG_REQUIRE( mb.Close() );

    if ( (err == NO_ERROR) &&
        IsFieldSet( fcConfig, FC_INET_INFO_LOG_CONFIG) &&
        (pInfoConfig->lpLogConfig != NULL) ) {

        err = SetInetLogConfiguration(&m_Logging,
                                      m_Service->QueryEventLog(),
                                      pInfoConfig->lpLogConfig);

        if ( err != NO_ERROR) {

            DBGPRINTF(( DBG_CONTEXT,
                       "SetConfiguration() SetInetLogConfig() failed. "
                       " Err=%u\n",
                       err));
        }
    }

    if ( (err == NO_ERROR) &&
        IsFieldSet( fcConfig, FC_INET_INFO_VIRTUAL_ROOTS )) {

        if ( QueryInstanceId() != INET_INSTANCE_ROOT ) {

            if ( !TsSetVirtualRoots(  pInfoConfig
                                     )) {

                err = GetLastError();
                DBGPRINTF(( DBG_CONTEXT,
                           "[SetConfiguration()]SetVirtualRoots "
                           " returns error %d\n",
                            err));
            }
        }
    }

    if ( err != NO_ERROR ) {

        IF_DEBUG( ERROR) {

            DBGPRINTF(( DBG_CONTEXT,
                       "IIS_SERVER_INSTANCE::SetCommonConfig ==> Error = %u\n",
                       err));
        }

        SetLastError( err );
        return(FALSE);
    }

    return TRUE;

} // IIS_SERVER_INSTANCE::SetCommonConfig


VOID
IIS_SERVER_INSTANCE::MDChangeNotify(
    MD_CHANGE_OBJECT * pcoChangeList
    )
/*++

  This method handles the metabase change notification for this service.

  Arguments:
    pcoChangeList - path and id that has changed

--*/
{
    DWORD i;
    DWORD status = NO_ERROR;
    BOOL  fVRUpdated = FALSE;
    BOOL  fReadCommon = FALSE;
    BOOL  fShouldMirror = FALSE;
    HRESULT hr;
    BOOL   fShouldCoUninitialize = FALSE;

    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    if ( SUCCEEDED(hr) ) {
        fShouldCoUninitialize = TRUE;
    }
    else if (hr != E_INVALIDARG &&
             hr != RPC_E_CHANGED_MODE) {

        //
        // E_INVALIDARG and RPC_E_CHANGED_MODE could mean com was already
        // initialized with different parameters, so ignore it but don't
        // Uninit. Assert on other errors.
        //

        DBGPRINTF((DBG_CONTEXT,"CoInitializeEx failed with %x\n",hr));
        DBG_ASSERT(FALSE);
    }

    if ( (pcoChangeList->dwMDChangeType &
                (MD_CHANGE_TYPE_DELETE_OBJECT |
                 MD_CHANGE_TYPE_RENAME_OBJECT |
                 MD_CHANGE_TYPE_ADD_OBJECT) ) != 0 )
    {

        //
        // Something got added/deleted/renamed
        //

        fShouldMirror = TRUE;
    }

    LockThisForWrite();
    for ( i = 0; i < pcoChangeList->dwMDNumDataIDs; i++ )
    {
        m_Logging.NotifyChange( pcoChangeList->pdwMDDataIDs[i] );

        switch ( pcoChangeList->pdwMDDataIDs[i] )
        {
        case MD_SERVER_BINDINGS:
            if( QueryServerState() != MD_SERVER_STATE_STOPPED ) {
                status = UpdateNormalBindings();
                if( status != NO_ERROR ) {
                    DBGPRINTF((
                        DBG_CONTEXT,
                        "MDChangeNotify: UpdateNormalBindings() failed,error %lu\n",
                        status
                        ));
                }
                SetWin32Error( status );
            }
            break;

        case MD_SECURE_BINDINGS:
            if( QueryServerState() != MD_SERVER_STATE_STOPPED ) {
                status = UpdateSecureBindings();
                if( status != NO_ERROR ) {
                    DBGPRINTF((
                        DBG_CONTEXT,
                        "MDChangeNotify: UpdateSecureBindings() failed,error %lu\n",
                        status
                        ));
                }
                SetWin32Error( status );
            }
            break;

        case MD_DISABLE_SOCKET_POOLING:
            if( QueryServerState() != MD_SERVER_STATE_STOPPED )
            {
                if (HasNormalBindings())
                {
                    status = RemoveNormalBindings();

                    if (NO_ERROR == status)
                    {
                        status = UpdateNormalBindings();

                        if( status != NO_ERROR ) {
                            DBGPRINTF((
                                DBG_CONTEXT,
                                "MDChangeNotify: UpdateNormalBindings() failed,error %lu\n",
                                status
                            ));
                        }
                    }
                    else
                    {
                        DBGPRINTF((
                            DBG_CONTEXT,
                            "MDChangeNotify: RemoveNormalBindings() failed,error %lu\n",
                            status
                        ));
                    }
                }

                if ( (status == NO_ERROR) && HasSecureBindings())
                {
                    status = RemoveSecureBindings();

                    if (NO_ERROR == status)
                    {
                        status = UpdateSecureBindings();

                        if( status != NO_ERROR ) {
                            DBGPRINTF((
                                DBG_CONTEXT,
                                "MDChangeNotify: UpdateSecureBindings() failed,error %lu\n",
                                status
                            ));
                        }
                    }
                    else
                    {
                        DBGPRINTF((
                            DBG_CONTEXT,
                            "MDChangeNotify: RemoveSecureBindings() failed,error %lu\n",
                            status
                        ));
                    }
                }

                SetWin32Error( status );
            }
            break;

        case MD_CLUSTER_ENABLED:
            status = PerformClusterModeChange();
            if( status != NO_ERROR ) {
                IF_DEBUG( INSTANCE ) {
                    DBGPRINTF((
                        DBG_CONTEXT,
                        "MDChangeNotify: PerformClusterModeChange() failed, error %lu\n",
                        status
                        ));
                }
            }
            break;

        case MD_SERVER_COMMAND:

            //
            // If cluster mode is enabled command must be specified
            // using MD_CLUSTER_SERVER_COMMAND, so that ISM cannot set the server state :
            // State management is to be done by cluster code exclusively.
            //

            if ( IsClusterEnabled() )
            {
                break;
            }

        case MD_CLUSTER_SERVER_COMMAND:
            status = PerformStateChange();
            if( status != NO_ERROR ) {
                IF_DEBUG( INSTANCE ) {
                    DBGPRINTF((
                        DBG_CONTEXT,
                        "MDChangeNotify: ProcessStateChange() failed, error %lu\n",
                        status
                        ));
                }
            }

            //
            // if command started server then need to reload virtual roots
            // as failing-over may have enabled new file system resources
            //

            if ( QueryServerState() != MD_SERVER_STATE_STARTED )
            {
                break;
            }

            // fall-through

        case MD_VR_PATH:
        case MD_VR_USERNAME:
        case MD_VR_PASSWORD:

            fShouldMirror = TRUE;
            if ( !fVRUpdated )
            {
                //
                //  Note individual root errors log an event
                //

                if ( !TsReadVirtualRoots(pcoChangeList) )
                {
                    DBGPRINTF(( DBG_CONTEXT,
                                "Error %d (0x%lx) reading virtual root info for %s\n",
                                GetLastError(), GetLastError(), pcoChangeList->pszMDPath ));
                }

                fVRUpdated = TRUE;
            }
            break;

        case MD_MAX_BANDWIDTH:
        {
            MB mb( (IMDCOM*) m_Service->QueryMDObject() );

            if ( mb.Open( QueryMDPath() ) )
            {
                if ( !SetBandwidthThrottle( &mb ) )
                {
                    DWORD dwError = GetLastError();

                    DBGPRINTF(( DBG_CONTEXT,
                                "MDChangeNotify: SetBandwidthThrottle failed, error %lu\n",
                                dwError ));

                    SetWin32Error( dwError );
                }
                DBG_REQUIRE( mb.Close() );
            }
            break;
        }

        case MD_MAX_BANDWIDTH_BLOCKED:
        {
            MB mb( (IMDCOM*) m_Service->QueryMDObject() );

            if ( mb.Open( QueryMDPath() ) )
            {
                if ( !SetBandwidthThrottleMaxBlocked( &mb ) )
                {
                    DWORD dwError = GetLastError();

                    DBGPRINTF(( DBG_CONTEXT,
                                "MDChangeNotify: SetBandwidthThrottle failed, error %lu\n",
                                dwError ));

                    SetWin32Error( dwError );
                }
                DBG_REQUIRE( mb.Close() );
            }
            break;
        }

        //
        //  Ignore state & status updates
        //

        case MD_SERVER_STATE:
        case MD_WIN32_ERROR:
            break;

        case MD_ACCESS_PERM:
            fShouldMirror = TRUE;
            break;

        case MD_LOG_TYPE:
        {
            DWORD   dwLogType;
            MB mb( (IMDCOM*) m_Service->QueryMDObject() );

            if ( mb.Open( QueryMDPath() ) &&
                 mb.GetDword("", MD_LOG_TYPE, IIS_MD_UT_SERVER, &dwLogType)
               )
            {
                m_fLoggingEnabled = (1 == dwLogType);
            }

            fReadCommon       = TRUE;
            break;
        }

        default:
            fReadCommon = TRUE;
            break;
        }
    }

    if ( fReadCommon )
    {
        m_Logging.NotifyChange( 0 );
        RegReadCommonParams( TRUE, FALSE );
    }

    if ((MD_CHANGE_TYPE_DELETE_OBJECT == pcoChangeList->dwMDChangeType) &&
        (! _strnicmp( (LPCSTR) pcoChangeList->pszMDPath+QueryMDPathLen()+1,
                      IIS_MD_INSTANCE_ROOT,
                      sizeof(IIS_MD_INSTANCE_ROOT)-1))
       )
    {
        if ( !TsReadVirtualRoots(pcoChangeList) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "Error %d (0x%lx) removing virtual root %s\n",
                         GetLastError(), GetLastError(), pcoChangeList->pszMDPath ));
        }
    }

    //
    // reflect the changes to the registry
    //

    if ( fShouldMirror && IsDownLevelInstance() )
    {
        MDMirrorVirtualRoots( );
    }

    UnlockThis();

    if ( fShouldCoUninitialize ) {
        CoUninitialize( );
    }

    return;

} // IIS_SERVER_INSTANCE::MDChangeNotify



VOID
IIS_SERVER_INSTANCE::MDMirrorVirtualRoots(
    VOID
    )
{
    DWORD err;
    HKEY hkey = NULL;

    //
    // Delete VR key
    //

    err = RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE,
                    m_Service->QueryRegParamKey(),
                    0,
                    KEY_ALL_ACCESS,
                    &hkey );

    if ( err != NO_ERROR ) {
        DBGPRINTF(( DBG_CONTEXT, "RegOpenKeyEx for returned error %d\n",err ));
        return;
    }

    //
    //  First delete the key to remove any old values
    //

    err = RegDeleteKey( hkey, VIRTUAL_ROOTS_KEY_A );
    RegCloseKey(hkey);

    if ( err != NO_ERROR )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "[MDMirrorVRoots] Unable to remove old values\n"));
        return;
    }

    //
    // Now recreate the keys
    //

    MoveMDVroots2Registry( );
    return;

} // IIS_SERVER_INSTANCE::MDMirrorVirtualRoots



DWORD
GetRPCLogConfiguration(IN LOGGING *pLogging,
                       OUT LPINET_LOG_CONFIGURATION * ppLogConfig)
/*++
  This function allocates space (using MIDL_ functions) and stores
  log configuration for the given log handle in it.

  Arguments:
    hInetLog     handle for InetLog object.
    ppLogConfig  pointer to INET_LOG_CONFIGURATION object which on return
                  contains valid log config informtion, on success.

  Returns:
    Win32 error code.
--*/
{
    DWORD  dwError = NO_ERROR;
    LPINET_LOG_CONFIGURATION pRpcConfig;
    WCHAR cBuffer[MAX_PATH];

    DBG_ASSERT( ppLogConfig != NULL);

    pRpcConfig = ((LPINET_LOG_CONFIGURATION )
                  MIDL_user_allocate( sizeof(INET_LOG_CONFIGURATION)));

    if ( pRpcConfig != NULL) {

        INETLOG_CONFIGURATIONA  ilogConfig;
        DWORD cbConfig = sizeof(ilogConfig);
        BOOL fReturn=TRUE;

        ZeroMemory( &ilogConfig, sizeof(ilogConfig ));
        pLogging->GetConfig( &ilogConfig );

        //
        // we got valid config. copy it into pRpcConfig.
        // since the enumerated values in inetlog.w are same in inetasrv.h
        //  we do no mapping, we directly copy values.

        ZeroMemory( pRpcConfig, sizeof( INET_LOG_CONFIGURATION));
        pRpcConfig->inetLogType = ilogConfig.inetLogType;

        switch ( ilogConfig.inetLogType) {

          case INET_LOG_TO_FILE:

            pRpcConfig->ilPeriod = ilogConfig.u.logFile.ilPeriod;
            pRpcConfig->cbSizeForTruncation =
              ilogConfig.u.logFile.cbSizeForTruncation;

             ::MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED,
                  ilogConfig.u.logFile.rgchLogFileDirectory, -1,
                  (WCHAR *)cBuffer, MAX_PATH );

            CopyUnicodeStringToBuffer(
                pRpcConfig->rgchLogFileDirectory,
                MAX_PATH,
                cBuffer);

            *((DWORD *)&(pRpcConfig->rgchDataSource[MAX_PATH-sizeof(DWORD)]))=ilogConfig.u.logFile.ilFormat;
            *((DWORD *)&(pRpcConfig->rgchDataSource[MAX_PATH-2*sizeof(DWORD)]))=ilogConfig.u.logFile.dwFieldMask;

            break;

          case INET_LOG_TO_SQL:

            ::MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED,
                  ilogConfig.u.logSql.rgchDataSource, -1,
                  (WCHAR *)cBuffer, MAX_PATH );

            CopyUnicodeStringToBuffer(
                pRpcConfig->rgchDataSource,
                MAX_PATH,
                cBuffer);

            ::MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED,
                  ilogConfig.u.logSql.rgchTableName, -1,
                  (WCHAR *)cBuffer, MAX_PATH );

            CopyUnicodeStringToBuffer(
                pRpcConfig->rgchTableName,
                MAX_TABLE_NAME_LEN,
                cBuffer);

            ::MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED,
                  ilogConfig.u.logSql.rgchUserName, -1,
                  (WCHAR *)cBuffer, MAX_PATH );

            CopyUnicodeStringToBuffer(
                pRpcConfig->rgchUserName,
                UNLEN,
                cBuffer);

            ::MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED,
                  ilogConfig.u.logSql.rgchPassword, -1,
                  (WCHAR *)cBuffer, MAX_PATH );

            CopyUnicodeStringToBuffer(
                pRpcConfig->rgchPassword,
                PWLEN,
                cBuffer);
            break;


          case INET_LOG_DISABLED:
          default:
            // do nothing
            break;

        } // switch()
    } else {

        dwError = ERROR_NOT_ENOUGH_MEMORY;
    }

    *ppLogConfig = pRpcConfig;

    return (dwError);
} // GetRPCLogConfiguration()



DWORD
SetInetLogConfiguration(IN LOGGING       *pLogging,
                        IN EVENT_LOG *    pEventLog,
                        IN const INET_LOG_CONFIGURATION * pRpcLogConfig)
/*++
  This function modifies the logconfiguration associated with a given InetLog
  handle. It also updates the registry containing log configuration for service
  with which the inetlog handle is associated.

  Arguments:
     hInetLog        Handle to INETLOG object whose configuration needs to be
                      changed.
     pRpcLogConfig   new RPC log configuration


  Returns:
    Win32 Error code. NO_ERROR returned on success.

--*/
{
    DWORD dwError = NO_ERROR;
    INETLOG_CONFIGURATIONA  ilConfig;
    WCHAR cBuffer[MAX_PATH];

    //
    // initialize
    //

    ZeroMemory( &ilConfig, sizeof(INETLOG_CONFIGURATIONA));

    // Copy the RPC inet log configuration into local INETLOG_CONFIGURATIONW

    ilConfig.inetLogType = pRpcLogConfig->inetLogType;

    switch (ilConfig.inetLogType) {

      case INET_LOG_DISABLED:
            break;   // do nothing

      case INET_LOG_TO_FILE:

        CopyUnicodeStringToBuffer(cBuffer,
                                  MAX_PATH,
                                  pRpcLogConfig->rgchLogFileDirectory);

        (VOID) ConvertUnicodeToAnsi(
                            cBuffer,
                            ilConfig.u.logFile.rgchLogFileDirectory,
                            MAX_PATH
                            );

        ilConfig.u.logFile.ilPeriod = pRpcLogConfig->ilPeriod;

        if ( ilConfig.u.logFile.ilPeriod > INET_LOG_PERIOD_MONTHLY ) {
            return (ERROR_INVALID_PARAMETER);
        }

        ilConfig.u.logFile.cbSizeForTruncation =
            pRpcLogConfig->cbSizeForTruncation;

        ilConfig.u.logFile.ilFormat =
            *((DWORD *)&(pRpcLogConfig->rgchDataSource[MAX_PATH-sizeof(DWORD)]));

        ilConfig.u.logFile.dwFieldMask =
            *((DWORD *)&(pRpcLogConfig->rgchDataSource[MAX_PATH-2*sizeof(DWORD)]));
        break;

      case INET_LOG_TO_SQL:

        CopyUnicodeStringToBuffer(cBuffer,
                                  MAX_PATH,
                                  pRpcLogConfig->rgchDataSource);

        (VOID) ConvertUnicodeToAnsi(
                            cBuffer,
                            ilConfig.u.logSql.rgchDataSource,
                            MAX_PATH);

        CopyUnicodeStringToBuffer(cBuffer,
                                  MAX_TABLE_NAME_LEN,
                                  pRpcLogConfig->rgchTableName);

        (VOID) ConvertUnicodeToAnsi(
                            cBuffer,
                            ilConfig.u.logSql.rgchTableName,
                            MAX_TABLE_NAME_LEN);

        CopyUnicodeStringToBuffer(cBuffer,
                                  UNLEN,
                                  pRpcLogConfig->rgchUserName);

        (VOID) ConvertUnicodeToAnsi(
                            cBuffer,
                            ilConfig.u.logSql.rgchUserName,
                            MAX_USER_NAME_LEN);

        CopyUnicodeStringToBuffer(cBuffer,
                                  CNLEN,
                                  pRpcLogConfig->rgchPassword);

        (VOID) ConvertUnicodeToAnsi(
                            cBuffer,
                            ilConfig.u.logSql.rgchPassword,
                            MAX_PASSWORD_LEN);

        break;

      default:
        return (ERROR_INVALID_PARAMETER);
    } // switch()


    //
    // Now the ilConfig contains the local data related to configuration.
    //   call modify log config to modify dynamically the log handle.
    //

    pLogging->SetConfig( &ilConfig );
    return (dwError);

} // SetInetLogConfiguration()


BOOL
GenerateIpList(
    BOOL fIsGrant,
    ADDRESS_CHECK *pCheck,
    LPINET_INFO_IP_SEC_LIST *ppInfo
    )
/*++

Routine Description:

    generate an IP address list from an access check object

Arguments:

    fIsGrant - TRUE to access grant list, FALSE to access deny list
    pCheck - ptr to address check object to query from
    ppInfo - updated with ptr to IP list if success

Return:

    TRUE if success, otherwise FALSE

--*/
{
    UINT                        iM = pCheck->GetNbAddr( fIsGrant );
    LPINET_INFO_IP_SEC_LIST     pInfo;
    LPINET_INFO_IP_SEC_ENTRY    pI;
    UINT                        x;

    if ( iM == 0 )
    {
        *ppInfo = NULL;
        return TRUE;
    }

    if ( pInfo = (LPINET_INFO_IP_SEC_LIST)MIDL_user_allocate( sizeof(INET_INFO_IP_SEC_LIST) + iM * sizeof(INET_INFO_IP_SEC_ENTRY) ) )
    {
        pInfo->cEntries = 0;

        for ( x = 0, pI = pInfo->aIPSecEntry ;
              x < iM ;
              ++x )
        {
            LPBYTE pM;
            LPBYTE pA;
            DWORD dwF;

            if ( pCheck->GetAddr( fIsGrant, x, &dwF, &pM, &pA ) && dwF == AF_INET )
            {
                pI->dwMask = *(LPDWORD)pM;
                pI->dwNetwork = *(LPDWORD)pA;
                ++pI;
                ++pInfo->cEntries;
            }
        }

        *ppInfo = pInfo;

        return TRUE;
    }

    SetLastError( ERROR_NOT_ENOUGH_MEMORY );

    return FALSE;
}


BOOL
FillAddrCheckFromIpList(
    BOOL fIsGrant,
    LPINET_INFO_IP_SEC_LIST pInfo,
    ADDRESS_CHECK *pCheck
    )
/*++

Routine Description:

    Fill an access check object from an IP address list from

Arguments:

    fIsGrant - TRUE to access grant list, FALSE to access deny list
    pInfo - ptr to IP address list
    pCheck - ptr to address check object to update

Return:

    TRUE if success, otherwise FALSE

--*/
{
    UINT    x;

    if ( pInfo )
    {
        for ( x = 0 ; x < pInfo->cEntries ; ++x )
        {
            if ( ! pCheck->AddAddr( fIsGrant,
                                    AF_INET,
                                    (LPBYTE)&pInfo->aIPSecEntry[x].dwMask,
                                    (LPBYTE)&pInfo->aIPSecEntry[x].dwNetwork ) )
            {
                return FALSE;
            }
        }
    }

    return TRUE;
}

BOOL
GetVrootCount(
    PVOID          pvContext,
    MB *           pmb,
    VIRTUAL_ROOT * pvr
    )
/*++

Routine Description:

    Virtual directory enumerater callback that calculates the total required
    buffer size

Arguments:
    pvContext is a dword * that receives the count of virtual directories

Return:

    TRUE if success, otherwise FALSE

--*/
{
    *((DWORD *) pvContext) += 1;

    return TRUE;
}

BOOL
GetVroots(
    PVOID          pvContext,
    MB *           pmb,
    VIRTUAL_ROOT * pvr
    )
/*++

Routine Description:

    Virtual directory enumerater callback that allocates and builds the
    virtual directory structure list

Arguments:
    pvContext is a pointer to the midl allocated memory

Return:

    TRUE if success, otherwise FALSE

--*/
{
    LPINET_INFO_VIRTUAL_ROOT_LIST  pvrl = (LPINET_INFO_VIRTUAL_ROOT_LIST) pvContext;
    DWORD                          i = pvrl->cEntries;
    LPINET_INFO_VIRTUAL_ROOT_ENTRY pvre = &pvrl->aVirtRootEntry[i];

    //
    //  Password doesn't go on the wire
    //

    DBG_ASSERT( pvr->pszAlias[0] == '/' );

    if ( !ConvertStringToRpc( &pvre->pszRoot,
                              pvr->pszAlias ) ||
         !ConvertStringToRpc( &pvre->pszDirectory,
                              pvr->pszPath ) ||
         !ConvertStringToRpc( &pvre->pszAddress,
                              "" ) ||
         !ConvertStringToRpc( &pvre->pszAccountName,
                              pvr->pszUserName ))
    {
        FreeRpcString( pvre->pszRoot );        pvre->pszRoot      = NULL;
        FreeRpcString( pvre->pszDirectory );   pvre->pszDirectory = NULL;
        FreeRpcString( pvre->pszAddress );     pvre->pszAddress   = NULL;
        FreeRpcString( pvre->pszAccountName ); pvre->pszAccountName = NULL;

        return FALSE;
    }

    pvre->dwMask = pvr->dwAccessPerm;

    pmb->GetDword( pvr->pszAlias,
                   MD_WIN32_ERROR,
                   IIS_MD_UT_SERVER,
                   &pvre->dwError );

    pvrl->cEntries++;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\common\vroots.cxx ===
/*++
   Copyright    (c)    1994        Microsoft Corporation

   Module Name:
        vroots.cxx

   Abstract:

        This module contains the front end to the virtual roots interface



   Author:

        John Ludeman    (johnl)     16-Mar-1995

   Project:

          Internet Servers Common Server DLL

   Revisions:

--*/

//
//  Include Headers
//

#include <tcpdllp.hxx>
#include <tsunami.hxx>
#include <iistypes.hxx>
#include <inetinfo.h>
#include <imd.h>
#include <inetreg.h>
#include <mb.hxx>
#include <w3svc.h>
#if 1 // DBCS
#include <mbstring.h>
#endif
#include <initguid.h>
#include <iwamreg.h>


BOOL
RetrieveRootPassword(
    PCHAR   pszRoot,
    PCHAR   pszPassword,
    WCHAR * pszSecret
    );

DWORD
GetFileSystemType(
    IN  LPCSTR      pszRealPath,
    OUT LPDWORD     lpdwFileSystem
    );

VOID
LogRootAddFailure(
    IN PIIS_SERVER_INSTANCE psi,
    PCHAR           pszRoot,
    PCHAR           pszDirectory,
    DWORD           err,
    IN PCHAR        pszMetaPath,
    IN MB *         pmb
    );

BOOL
TsAddVrootsWithScmUpdate(
    PVOID          pvContext,
    MB *           pmb,
    VIRTUAL_ROOT * pvr
    );

BOOL
TsAddVroots(
    PVOID          pvContext,
    MB *           pmb,
    VIRTUAL_ROOT * pvr
    );

HANDLE
VrootLogonUser(
    IN CHAR  * pszUser,
    IN CHAR  * pszPassword
    );

BOOL
CrackUserAndDomain(
    CHAR *   pszDomainAndUser,
    CHAR * * ppszUser,
    CHAR * * ppszDomain
    );

VOID
ClearSentinelEntry(
    IN MB * pMB
    );

VOID
RemoveUnmarkedRoots(
    IN MB * pMB
    );

BOOL
ReadVrootConfig(
    LPVOID          pvMB,
    LPSTR           szVRPath,
    LPSTR           szDirectory,
    DWORD           cbDirectory,
    LPSTR           szUser,
    DWORD           cbUser,
    LPSTR           szPassword,
    DWORD           cbPassword,
    DWORD           *pdwMask,
    BOOL            *pfDoCache
    );

DWORD
hextointW(
    WCHAR * pch
    );

DWORD
hextointA(
    CHAR * pch
    );

BOOL
IIS_SERVER_INSTANCE::TsReadVirtualRoots(
    MD_CHANGE_OBJECT * pcoChangeList
    )
/*++
    Description:

        NT Version

        This function is overloaded. The behavaior keys on pcoChangeList
        being NULL or not.

        If pcoChangeList is NULL (default value), it reads the metabase
        key pointed at by pmb and adds each root item.

        If pcoChangeList is not NULL then it only reads the necessary values.

    Arguments:

        pcoChangeList : pointer to metabase changes.

    Note:
        Failure to add a virtual root is not fatal.  An appropriate event
        will be logged listing the error and root.

    Returns:
        TRUE on success and FALSE if any failure.

--*/
{
    BOOL    fRet;
    MB      mb( (IMDCOM*) m_Service->QueryMDObject() );

    //
    // Unfortunately rename doesn't give us the name of the old object.
    // So treat it as default processing
    //

    if ((NULL == pcoChangeList) ||
        (MD_CHANGE_TYPE_RENAME_OBJECT == pcoChangeList->dwMDChangeType))
    {
        //
        // Default processing. Remove & Re-Read all VRoots. Expensive.
        //

        if ( !mb.Open( QueryMDPath(),
                   METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE ))
        {
            return FALSE;
        }

        //
        //  Remove all of the old roots for this server
        //

        fRet = QueryVrootTable()->RemoveVirtualRoots();

        if ( fRet )
        {
            QueryVrootTable()->LockExclusive();
            if (NULL == pcoChangeList)
            {
                fRet = TsEnumVirtualRoots( TsAddVrootsWithScmUpdate, this, &mb );
            }
            else
            {
                fRet = TsEnumVirtualRoots( TsAddVroots, this, &mb );
            }
            QueryVrootTable()->Unlock();
        }
    }
    else
    {
        VIRTUAL_ROOT    vr;

        CHAR            szUser[UNLEN+1];
        CHAR            szPassword[PWLEN+1];
        CHAR            szDirectory[MAX_PATH + UNLEN + 3];
        DWORD           dwMask;
        BOOL            fDoCache;

        if (MD_CHANGE_TYPE_DELETE_OBJECT == pcoChangeList->dwMDChangeType)
        {
            return QueryVrootTable()->RemoveVirtualRoot(
                                        (LPSTR)pcoChangeList->pszMDPath + QueryMDPathLen()
                                        + sizeof(IIS_MD_INSTANCE_ROOT)
                                      );
        }

        if ( !mb.Open( (LPCSTR)pcoChangeList->pszMDPath,
                   METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE ))
        {
            return FALSE;
        }

        if (!ReadVrootConfig( &mb,
                              "",
                              szDirectory,
                              sizeof(szDirectory),
                              szUser,
                              sizeof(szUser),
                              szPassword,
                              sizeof(szPassword),
                              &dwMask,
                              &fDoCache
                              ))
        {
            return FALSE;
        }

        vr.pszAlias     = (LPSTR)pcoChangeList->pszMDPath + QueryMDPathLen()
                            + sizeof(IIS_MD_INSTANCE_ROOT);
        vr.pszMetaPath  = "";
        vr.pszPath      = szDirectory;
        vr.dwAccessPerm = dwMask;
        vr.pszUserName  = szUser;
        vr.pszPassword  = szPassword;
        vr.fDoCache     = fDoCache;

        if (pcoChangeList->dwMDChangeType & MD_CHANGE_TYPE_ADD_OBJECT)
        {
            fRet = TsAddVroots(this, &mb, &vr);
        }
        else
        {
            //
            // Remove the original entry & re-read
            //

            if (!QueryVrootTable()->RemoveVirtualRoot(vr.pszAlias))
            {
                DBGPRINTF((DBG_CONTEXT,"Error %x removing vroot %s. \n",
                          GetLastError(), vr.pszMetaPath ));
            }

            fRet = TsAddVroots(this, &mb, &vr);
        }
    }

    return fRet;

}   // TsReadVirtualRoots



BOOL
TsAddVrootsWithScmUpdate(
    PVOID          pvContext,
    MB *           pmb,
    VIRTUAL_ROOT * pvr
    )
{
    ((IIS_SERVER_INSTANCE *) pvContext)->m_Service->StartUpIndicateClientActivity();
    return TsAddVroots(pvContext,pmb,pvr);
}



BOOL
TsAddVroots(
    PVOID          pvContext,
    MB *           pmb,
    VIRTUAL_ROOT * pvr
    )
{
    DWORD           err = NO_ERROR;
    DWORD           dwFileSystem;
    BOOL            fRet = FALSE;
    HANDLE          hToken = NULL;



    //
    //  Clear this virtual directory's error status
    //

    if ( !pmb->SetDword( pvr->pszMetaPath,
                         MD_WIN32_ERROR,
                         IIS_MD_UT_SERVER,
                         NO_ERROR,
                         METADATA_VOLATILE ))
    {
        DBGPRINTF((DBG_CONTEXT,"Error %x setting win32 status from %s. \n",
                  GetLastError(), pvr->pszMetaPath ));
        return FALSE;
    }

    if ( (pvr->pszUserName[0] != '\0') &&
         (pvr->pszPath[0] == '\\') && (pvr->pszPath[1] == '\\') )
    {
        if ( g_fW3OnlyNoAuth )
        {
            hToken = NULL;
        }
        else
        {
            hToken = VrootLogonUser( pvr->pszUserName,
                                     pvr->pszPassword );

            if ( hToken == NULL)
            {
                DBGPRINTF(( DBG_CONTEXT,
                            "Adding path %s err %d, user=%s, pwd=%d\n",
                            pvr->pszPath, GetLastError(), pvr->pszUserName, pvr->pszPassword ));

                //
                //  Log error
                //

                LogRootAddFailure( (IIS_SERVER_INSTANCE *) pvContext,
                                                   pvr->pszAlias,
                                                   pvr->pszPath,
                                                   GetLastError(),
                                                   pvr->pszMetaPath,
                                                   pmb );
            }


            // Impersonate as user for GetFileSystemType()
            if ( hToken != NULL && !ImpersonateLoggedOnUser(hToken))
            {
               err = GetLastError();
            }
        }
    }

    if ( err == NO_ERROR )
    {
        if (pvr->pszPath[0] != '\0')
        {
            err = GetFileSystemType( pvr->pszPath, &dwFileSystem);
        } else {
            dwFileSystem = FS_ERROR;
        }


        if ( err != NO_ERROR) {

            DBGPRINTF(( DBG_CONTEXT,
                        " GetFileSystemType(%s) failed.Error = %u.\n",
                        pvr->pszPath,
                        err));

            LogRootAddFailure( (IIS_SERVER_INSTANCE *) pvContext,
                               pvr->pszAlias,
                               pvr->pszPath,
                               err,
                               pvr->pszMetaPath,
                               pmb );
        }
    }

    //
    //  Don't add roots that are invalid
    //

    if ( err == NO_ERROR )
    {
        if ( !((IIS_SERVER_INSTANCE *) pvContext)->QueryVrootTable()->AddVirtualRoot(
                                    pvr->pszAlias,
                                    pvr->pszPath,
                                    pvr->dwAccessPerm,
                                    pvr->pszUserName,
                                    hToken,
                                    dwFileSystem,
                                    pvr->fDoCache ))
        {
            err = GetLastError();

            DBGPRINTF(( DBG_CONTEXT,
                        " AddVirtualRoot() failed. Error = %u.\n", err));

            LogRootAddFailure( (IIS_SERVER_INSTANCE *) pvContext,
                               pvr->pszAlias,
                               pvr->pszPath,
                               err,
                               pvr->pszMetaPath,
                               pmb );
        }
    }

    if ( hToken != NULL)
    {
        RevertToSelf();
    }

    if ( err == NO_ERROR )
    {
        fRet = TRUE;
    }

    return fRet;

} // TsAddVroots


BOOL
IIS_SERVER_INSTANCE::TsEnumVirtualRoots(
    PFN_VR_ENUM pfnCallback,
    VOID *      pvContext,
    MB *        pmbWebSite
    )
{
    return TsRecursiveEnumVirtualRoots(
                    pfnCallback,
                    pvContext,
                    IIS_MD_INSTANCE_ROOT "/",
                    m_dwLevelsToScan,
                    (LPVOID)pmbWebSite,
                    TRUE );
}


BOOL
IIS_SERVER_INSTANCE::TsRecursiveEnumVirtualRoots(
    PFN_VR_ENUM pfnCallback,
    VOID *      pvContext,
    LPSTR       pszCurrentPath,
    DWORD       dwLevelsToScan,
    LPVOID      pvMB,
    BOOL        fGetRoot
    )
/*++
    Description:

        Enumerates all of the virtual directories defined for this server
        instance

    Arguments:
        pfnCallback - Enumeration callback to call for each virtual directory
        pvContext - Context pfnCallback receives
        pszCurrentPath - path where to start scanning for VRoots
        dwLevelsToScan - # of levels to scan recursively for vroots
        pvMB - ptr to MB to access metabase. Is LPVOID to avoid having to include
               mb.hxx before any ref to iistypes.hxx
        fGetRoot - TRUE if pszCurrentPath is to be considered as vroot to process

    Returns:
        TRUE on success and FALSE if any failure.

--*/
{

    DWORD           err;
    MB*             pMB = (MB*)pvMB;

    DWORD           cb;

    CHAR            nameBuf[METADATA_MAX_NAME_LEN+2];
    CHAR            tmpBuf[sizeof(nameBuf)];

    DWORD           cbCurrentPath;
    DWORD           i = 0;

    VIRTUAL_ROOT    vr;

    CHAR            szUser[UNLEN+1];
    CHAR            szPassword[PWLEN+1];
    CHAR            szDirectory[MAX_PATH + UNLEN + 3];
    DWORD           dwMask;
    BOOL            fDoCache;

    //
    //  Enumerate all of the listed items in the metabase
    //  and add them
    //

    cbCurrentPath = strlen( pszCurrentPath );
    CopyMemory( nameBuf, pszCurrentPath, cbCurrentPath + 1);

    while ( TRUE ) {

        METADATA_RECORD mdRecord;
        DWORD  dwFileSystem = FS_ERROR;

        err = NO_ERROR;

        if ( fGetRoot ) {

            fGetRoot = FALSE;

        } else {

            if ( !pMB->EnumObjects( pszCurrentPath,
                                  nameBuf + cbCurrentPath,
                                  i++ ))
            {
                break;
            }

            if ( dwLevelsToScan > 1 )
            {
                cb = strlen( nameBuf );
                nameBuf[ cb ] = '/';
                nameBuf[ cb + 1 ] = '\0';

                if ( !TsRecursiveEnumVirtualRoots(
                    pfnCallback,
                    pvContext,
                    nameBuf,
                    dwLevelsToScan - 1,
                    pMB,
                    FALSE ) )
                {
                    return FALSE;
                }

                nameBuf[ cb ] = '\0';
            }
        }

        if (!ReadVrootConfig( pvMB,
                              nameBuf,
                              szDirectory,
                              sizeof(szDirectory),
                              szUser,
                              sizeof(szUser),
                              szPassword,
                              sizeof(szPassword),
                              &dwMask,
                              &fDoCache
                              ))
        {
            continue;
        }

        //
        //  Now set things up for the callback
        //

        DBG_ASSERT( !_strnicmp( nameBuf, IIS_MD_INSTANCE_ROOT, sizeof(IIS_MD_INSTANCE_ROOT) - 1));

        //
        //  Add can modify the root - don't modify the working vroot path
        //

        strcpy( tmpBuf, nameBuf );

        vr.pszAlias     = tmpBuf + sizeof(IIS_MD_INSTANCE_ROOT) - 1;
        vr.pszMetaPath  = tmpBuf;
        vr.pszPath      = szDirectory;
        vr.dwAccessPerm = dwMask;
        vr.pszUserName  = szUser;
        vr.pszPassword  = szPassword;
        vr.fDoCache     = fDoCache;

        if ( !pfnCallback( pvContext, pMB, &vr ))
        {
            //
            // !!! so what do we do here?
            //

            DBGPRINTF((DBG_CONTEXT,"EnumCallback returns FALSE\n"));
        }

    } // while

    return TRUE;

} // Enum



VOID
LogRootAddFailure(
    IN PIIS_SERVER_INSTANCE psi,
    IN PCHAR        pszRoot,
    IN PCHAR        pszDirectory,
    IN DWORD        err,
    IN PCHAR        pszMetaPath,
    IN MB *         pmb
    )
{
    const CHAR *    apsz[3];
    STR             strError;

    psi->LoadStr( strError, err, FALSE );  // loads ANSI message. Convert to UNICODE

    apsz[0] = pszRoot;
    apsz[1] = pszDirectory;
    apsz[2] = strError.QueryStrA();

    psi->m_Service->LogEvent( INET_SVC_ADD_VIRTUAL_ROOT_FAILED,
                              3,
                              apsz,
                              err );

    //
    //  Indicate the error on this virtual directory
    //

    if ( !pmb->SetDword( pszMetaPath,
                         MD_WIN32_ERROR,
                         IIS_MD_UT_SERVER,
                         err,
                         METADATA_VOLATILE ))
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "LogRootAddFailure: Unable to set win32 status\n" ));
    }
} // LogRootAddFailure


BOOL
RetrieveRootPassword(
    PCHAR   pszRoot,
    PCHAR   pszPassword,
    PWCHAR  pszSecret
    )
/*++
    Description:

        This function retrieves the password for the specified root & address

    Arguments:

        pszRoot - Name of root + address in the form "/root,<address>".
        pszPassword - Receives password, must be at least PWLEN+1 characters
        pszSecret - Virtual Root password secret name

    Returns:
        TRUE on success and FALSE if any failure.

--*/
{
    BUFFER  bufSecret;
    WCHAR * psz;
    WCHAR * pszTerm;
    WCHAR * pszNextLine;
    WCHAR   wsRoot[MAX_PATH+1];

    DWORD   cch;

    if ( !TsGetSecretW( pszSecret,
                        &bufSecret ))
    {
        return FALSE;
    }

    //
    // Convert root to WCHAR
    //

    cch = MultiByteToWideChar( CP_ACP,
                               MB_PRECOMPOSED,
                               pszRoot,
                               -1,
                               wsRoot,
                               MAX_PATH );

    wsRoot[cch] = L'\0';
    if ( cch == 0 ) {
        return FALSE;
    }

    psz = (WCHAR *) bufSecret.QueryPtr();

    //
    //  Scan the list of roots looking for a match.  The list looks like:
    //
    //     <root>,<address>=<password>\0
    //     <root>,<address>=<password>\0
    //     \0
    //

    while ( *psz )
    {
        PWCHAR pszComma;

        pszNextLine = psz + wcslen(psz) + 1;

        pszTerm = wcschr( psz, L'=' );

        if ( !pszTerm )
            goto NextLine;

        *pszTerm = L'\0';

        //
        // remove the ,
        //

        pszComma = wcschr( psz, L',' );
        if ( pszComma != NULL ) {
            *pszComma = '\0';
        }

        if ( !_wcsicmp( wsRoot, psz ) )
        {

            //
            //  We found a match, copy the password
            //

            (VOID) ConvertUnicodeToAnsi(
                               pszTerm + 1,
                               pszPassword,
                               PWLEN + sizeof(CHAR));

            return TRUE;
        }

NextLine:
        psz = pszNextLine;
    }

    //
    //  If the matching root wasn't found, default to the empty password
    //

    *pszPassword = '\0';
    return TRUE;

} // RetrieveRootPassword



BOOL
IIS_SERVER_INSTANCE::TsSetVirtualRoots(
    IN LPINETA_CONFIG_INFO  pConfig
    )
/*++
    Description:

        Writes the virtual roots specified in the config structure to the
        registry

        NOTE: This is basically legacy code for the IIS 3.0 RPC interface.

    Arguments:
        pConfig - new list of virtual

    Returns:
        TRUE on success and FALSE if any failure.

--*/
{
    DWORD               err;
    DWORD               dwDummy;
    LPINET_INFO_VIRTUAL_ROOT_LIST pRootsList;
    DWORD               cch;
    DWORD               i;
    DWORD               dwMask;
    DWORD               sentinelValue = 7777777;
    IWamAdmin*          pIWamAdmin = NULL;
    MB                  mb( (IMDCOM*) m_Service->QueryMDObject()  );
    HRESULT             hr = NOERROR;
    STR                 strTmp;

    //
    // Do the metabase
    //

    IF_DEBUG(METABASE) {
        DBGPRINTF((DBG_CONTEXT,"Setting VR data on %s\n",
                  QueryMDPath()));
    }

    if ( !mb.Open( QueryMDPath(),
                   METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE ))
    {
        IF_DEBUG(METABASE) {
            DBGPRINTF((DBG_CONTEXT,"Open MD instance root %s returns %d\n",
                      QueryMDPath(), GetLastError() ));
        }
        return FALSE;
    }

    //
    //  We need to create an application for each new virtual root set via
    //  the IIS 3.0 RPC interface for ASP compatability
    //

    hr = CoCreateInstance(CLSID_WamAdmin,
                          NULL,
                          CLSCTX_SERVER,
                          IID_IWamAdmin,
                          (void **)&pIWamAdmin);

    if ( FAILED(hr) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Failed to create WamAdmin interface, error %08lx\n",
                    hr ));

        SetLastError( hr );
        return FALSE;
    }

    //
    // See if we need to delete any VRs
    //

    pRootsList = pConfig->VirtualRoots;

    if ( (pRootsList == NULL) || (pRootsList->cEntries == 0) ) {

        //
        // NO VRs.  Delete the entire VR tree
        //

        if ( !mb.DeleteObject( IIS_MD_INSTANCE_ROOT ) )
        {
            IF_DEBUG(METABASE) {
                DBGPRINTF((DBG_CONTEXT,
                          "Deleting VR root returns %d\n",GetLastError()));
            }
        }

        IF_DEBUG(METABASE) {
            DBGPRINTF((DBG_CONTEXT,"Empty list set on %s\n", QueryMDPath()));
        }

        goto exit;

    } else {

        //
        // Remove our secret value
        //

        ClearSentinelEntry( &mb );
    }

    for ( i = 0; i < pRootsList->cEntries; i++ ) {

        CHAR tmpRoot[MAX_PATH+1];
        CHAR tmpBuffer[MAX_PATH+1];
        BOOL fCreateApp = FALSE;

        DWORD rootLen;

        //
        // strings to ANSI
        //

#define VROOT_ROOT       IIS_MD_INSTANCE_ROOT
#define CCH_VROOT_ROOT   (sizeof(VROOT_ROOT) - 1)

        strcpy( tmpRoot, VROOT_ROOT );

        (VOID) ConvertUnicodeToAnsi(
                           pRootsList->aVirtRootEntry[i].pszRoot,
                           &tmpRoot[CCH_VROOT_ROOT],
                           MAX_PATH);

        IF_DEBUG(METABASE) {
            DBGPRINTF((DBG_CONTEXT,"Setting data for root %s\n",tmpRoot));
        }

        rootLen = strlen(tmpRoot);

        //
        // Create the root
        //

        if ( !mb.AddObject( tmpRoot ) &&
             (GetLastError() != ERROR_ALREADY_EXISTS) )
        {

            DBGPRINTF((DBG_CONTEXT,"AddMetaObject %s failed with %d\n",
                          tmpRoot, GetLastError() ));
            goto exit;
        }

        //
        // Set sentinel entry
        //

        if ( !mb.SetDword( tmpRoot,
                           MD_VR_UPDATE,
                           IIS_MD_UT_FILE,
                           sentinelValue,
                           0 ))
        {
            DBGPRINTF((DBG_CONTEXT,
                "Error %d setting sentinel value %x for %s\n",
                GetLastError(), sentinelValue, tmpRoot));

            goto exit;
        }

        //
        // Set Path
        //

        (VOID) ConvertUnicodeToAnsi(
                        pRootsList->aVirtRootEntry[i].pszDirectory,
                        tmpBuffer,
                        MAX_PATH+1);

        IF_DEBUG(METABASE) {
            DBGPRINTF((DBG_CONTEXT,"Directory path is %s\n",tmpBuffer));
        }

        //
        //  Check to see if the path property already exists - if it does
        //  then we won't create the application - only new virtual directories
        //  get an application created for them
        //

        if ( !mb.GetStr( tmpRoot,
                         MD_VR_PATH,
                         IIS_MD_UT_FILE,
                         &strTmp,
                         METADATA_NO_ATTRIBUTES ))
        {
            fCreateApp = TRUE;
        }

        if ( !mb.SetString( tmpRoot,
                            MD_VR_PATH,
                            IIS_MD_UT_FILE,
                            tmpBuffer ))
        {
            DBGPRINTF((DBG_CONTEXT,"Error %d setting path[%s] for %s\n",
                      GetLastError(), tmpBuffer, tmpRoot));
        }

        if ( !mb.SetString( tmpRoot,
                            MD_KEY_TYPE,
                            IIS_MD_UT_SERVER,
                           "IIsWebVirtualDir" ))
        {
            DBGPRINTF((DBG_CONTEXT,"Error %d setting ADSI type for %s\n",
                      GetLastError(), tmpRoot));
        }


        //
        // Set Username
        //

        (VOID) ConvertUnicodeToAnsi(
                           pRootsList->aVirtRootEntry[i].pszAccountName,
                           tmpBuffer,
                           MAX_PATH+1);

        if ( !mb.SetString( tmpRoot,
                            MD_VR_USERNAME,
                            IIS_MD_UT_FILE,
                            tmpBuffer ))
        {
            DBGPRINTF((DBG_CONTEXT,"Error %d setting username for %s\n",
                      GetLastError(), tmpRoot));
        }

        //
        // Set Mask
        //

        if ( !mb.SetDword( tmpRoot,
                           MD_ACCESS_PERM,
                           IIS_MD_UT_FILE,
                           pRootsList->aVirtRootEntry[i].dwMask ))
        {
            DBGPRINTF((DBG_CONTEXT,"Error %d setting mask for %s\n",
                      GetLastError(), tmpRoot));
        }

        if ( fCreateApp )
        {
            WCHAR wchFullPath[MAX_PATH];

            strcpy( tmpRoot, QueryMDPath() );
            strcat( tmpRoot, "/" VROOT_ROOT );

            if ( MultiByteToWideChar( CP_ACP,
                                      MB_PRECOMPOSED,
                                      tmpRoot,
                                      -1,
                                      wchFullPath,
                                      sizeof( wchFullPath ) / sizeof(WCHAR) ))
            {
                wcscat( wchFullPath, pRootsList->aVirtRootEntry[i].pszRoot );

                DBGPRINTF(( DBG_CONTEXT,
                            "Creating application at %S\n",
                            wchFullPath ));

                //
                //  We need to close our metabase handle so WAM can create
                //  the in process application
                //

                DBG_REQUIRE( mb.Close() );

                hr = pIWamAdmin->AppCreate( wchFullPath, TRUE);

                if ( FAILED( hr ))
                {
                    DBGPRINTF(( DBG_CONTEXT,
                                "Failed to create application, error %08lx\n",
                                hr ));
                }

                //
                //  Reopen the metabase for the next vroot
                //

                if ( !mb.Open( QueryMDPath(),
                               METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE ))
                {
                    IF_DEBUG(METABASE) {
                        DBGPRINTF((DBG_CONTEXT,"Open MD instance root %s returns %d\n",
                                  QueryMDPath(), GetLastError() ));
                    }

                    goto exit;
                }

            }
        }
    }

    //
    // Delete entries that do not have the sentinel entry
    //

    RemoveUnmarkedRoots( &mb );

exit:

    //
    // If this is the downlevel instance, mirror it to the registry
    //

    if ( IsDownLevelInstance() ) {
        TsMirrorVirtualRoots( pConfig );
    }

    if ( pIWamAdmin ) {
        pIWamAdmin->Release();
    }

    return TRUE;

} // IIS_SERVER_INSTANCE::TsSetVirtualRoots


DWORD
GetFileSystemType(
    IN  LPCSTR      pszRealPath,
    OUT LPDWORD     lpdwFileSystem
    )
/*++
    Gets file system specific information for a given path.
    It uses GetVolumeInfomration() to query the file system type
       and file system flags.
    On success the flags and file system type are returned in
       passed in pointers.

    Arguments:

        pszRealPath    pointer to buffer containing path for which
                         we are inquiring the file system details.

        lpdwFileSystem
            pointer to buffer to fill in the type of file system.

    Returns:
        NO_ERROR  on success and Win32 error code if any error.

--*/
{
# define MAX_FILE_SYSTEM_NAME_SIZE    ( MAX_PATH)

    CHAR    rgchBuf[MAX_FILE_SYSTEM_NAME_SIZE];
    CHAR    rgchRoot[MAX_FILE_SYSTEM_NAME_SIZE];
    int     i;
    DWORD   dwReturn = ERROR_PATH_NOT_FOUND;
    DWORD   len;

    if ( (pszRealPath == NULL) || (lpdwFileSystem == NULL)) {
        return ( ERROR_INVALID_PARAMETER);
    }

    ZeroMemory( rgchRoot, sizeof(rgchRoot) );
    *lpdwFileSystem = FS_ERROR;

    //
    // Copy just the root directory to rgchRoot for querying
    //

    IF_DEBUG( DLL_VIRTUAL_ROOTS) {
        DBGPRINTF( ( DBG_CONTEXT, " GetFileSystemType(%s).\n", pszRealPath));
    }

    if ( (pszRealPath[0] == '\\') &&
         (pszRealPath[1] == '\\')) {

        PCHAR pszEnd;

        //
        // this is an UNC name. Extract just the first two components
        //
        //

        pszEnd = strchr( pszRealPath+2, '\\');

        if ( pszEnd == NULL) {

            // just the server name present

            return ( ERROR_INVALID_PARAMETER);
        }

#if 1 // DBCS enabling for share name
        pszEnd = (PCHAR)_mbschr( (PUCHAR)pszEnd+1, '\\');
#else
        pszEnd = strchr( pszEnd+1, '\\');
#endif

        len = ( ( pszEnd == NULL) ? strlen(pszRealPath)
               : (DIFF(pszEnd - pszRealPath) + 1) );

        //
        // Copy till the end of UNC Name only (exclude all other path info)
        //

        if ( len < (MAX_FILE_SYSTEM_NAME_SIZE - 1) ) {

            CopyMemory( rgchRoot, pszRealPath, len);
            rgchRoot[len] = '\0';
        } else {

            return ( ERROR_INVALID_NAME);
        }

#if 1 // DBCS enabling for share name
        if ( *CharPrev( rgchRoot, rgchRoot + len ) != '\\' ) {
#else
        if ( rgchRoot[len - 1] != '\\' ) {
#endif

            if ( len < MAX_FILE_SYSTEM_NAME_SIZE - 2 ) {
                rgchRoot[len]   = '\\';
                rgchRoot[len+1] = '\0';
            } else {

                return (ERROR_INVALID_NAME);
            }
        }
    } else {

        //
        // This is non UNC name.
        // Copy just the root directory to rgchRoot for querying
        //


        for( i = 0; i < 9 && pszRealPath[i] != '\0'; i++) {

            if ( (rgchRoot[i] = pszRealPath[i]) == ':') {

                break;
            }
        } // for


        if ( rgchRoot[i] != ':') {

            //
            // we could not find the root directory.
            //  return with error value
            //

            return ( ERROR_INVALID_PARAMETER);
        }

        rgchRoot[i+1] = '\\';     // terminate the drive spec with a slash
        rgchRoot[i+2] = '\0';     // terminate the drive spec with null char

    } // else

    IF_DEBUG( DLL_VIRTUAL_ROOTS) {
        DBGPRINTF( ( DBG_CONTEXT, " GetVolumeInformation(%s).\n",
                    rgchRoot));
    }

    //
    // The rgchRoot should end with a "\" (slash)
    // otherwise, the call will fail.
    //

    if (  GetVolumeInformation( rgchRoot,        // lpRootPathName
                                NULL,            // lpVolumeNameBuffer
                                0,               // len of volume name buffer
                                NULL,            // lpdwVolSerialNumber
                                NULL,            // lpdwMaxComponentLength
                                NULL,            // lpdwSystemFlags
                                rgchBuf,         // lpFileSystemNameBuff
                                sizeof(rgchBuf)
                                ) ) {



        dwReturn = NO_ERROR;

        if ( strcmp( rgchBuf, "FAT") == 0) {

            *lpdwFileSystem = FS_FAT;

        } else if ( strcmp( rgchBuf, "NTFS") == 0) {

            *lpdwFileSystem = FS_NTFS;

        } else if ( strcmp( rgchBuf, "HPFS") == 0) {

            *lpdwFileSystem = FS_HPFS;

        } else if ( strcmp( rgchBuf, "CDFS") == 0) {

            *lpdwFileSystem = FS_CDFS;

        } else if ( strcmp( rgchBuf, "OFS") == 0) {

            *lpdwFileSystem = FS_OFS;

        } else {

            *lpdwFileSystem = FS_FAT;
        }

    } else {

        dwReturn = GetLastError();

        IF_DEBUG( DLL_VIRTUAL_ROOTS) {

            DBGPRINTF( ( DBG_CONTEXT,
                        " GetVolumeInformation( %s) failed with error %d\n",
                        rgchRoot, dwReturn));
        }

    }

    return ( dwReturn);
} // GetFileSystemType()


HANDLE
VrootLogonUser(
    IN CHAR  * pszUser,
    IN CHAR  * pszPassword
    )
/*++
  This function uses the given parameters and logs on to generate
   a user handle for the account.

  Arguments:
    pszUser - pointer to string containing the user name.
    pszPassword - pointer to string containing the password.

  Returns:
    Handle for the logged on user on success.
    Returns NULL for errors.

  History:
    MuraliK  18-Jan-1996  Created.
--*/
{
    CHAR        szDomainAndUser[IIS_DNLEN+UNLEN+2];
    CHAR   *    pszUserOnly;
    CHAR   *    pszDomain;
    HANDLE      hToken = NULL;
    BOOL        fReturn;

    //
    //  Validate parameters & state.
    //

    DBG_ASSERT( pszUser != NULL && *pszUser != '\0');
    DBG_ASSERT( strlen(pszUser) < sizeof(szDomainAndUser) );
    DBG_ASSERT( pszPassword != NULL);
    DBG_ASSERT( strlen(pszPassword) <= PWLEN );

    //
    //  Save a copy of the domain\user so we can squirrel around
    //  with it a bit.
    //

    strcpy( szDomainAndUser, pszUser );

    //
    //  Crack the name into domain/user components.
    //  Then try and logon as the specified user.
    //

    fReturn = ( CrackUserAndDomain( szDomainAndUser,
                                   &pszUserOnly,
                                   &pszDomain ) &&
               LogonUserA(pszUserOnly,
                          pszDomain,
                          pszPassword,
                          LOGON32_LOGON_NETWORK_CLEARTEXT, //LOGON32_LOGON_NETWORK,
                          LOGON32_PROVIDER_DEFAULT,
                          &hToken )
               );

    if ( !fReturn) {

        //
        //  Logon user failed.
        //

        IF_DEBUG( DLL_SECURITY) {

            DBGPRINTF(( DBG_CONTEXT,
                       " CrachUserAndDomain/LogonUser (%s) failed Error=%d\n",
                       pszUser, GetLastError()));
        }

        hToken = NULL;
    } else {
        HANDLE hImpersonation = NULL;

        // we need to obtain the impersonation token, the primary token cannot
        // be used for a lot of purposes :(
        if (!pfnDuplicateTokenEx( hToken,      // hSourceToken
                               TOKEN_ALL_ACCESS,
                               NULL,
                               SecurityImpersonation,  // Obtain impersonation
                               TokenImpersonation,
                               &hImpersonation)  // hDestinationToken
            ) {

            DBGPRINTF(( DBG_CONTEXT,
                        "Creating ImpersonationToken failed. Error = %d\n",
                        GetLastError()
                        ));

            // cleanup and exit.
            hImpersonation = NULL;

            // Fall through for cleanup
        }

        //
        // close original token. If Duplicate was successful,
        //  we should have ref in the hImpersonation.
        // Send the impersonation token to the client.
        //
        CloseHandle( hToken);
        hToken = hImpersonation;
    }


    //
    //  Success!
    //

    return hToken;

} // VrootLogonUser()

DWORD
hextointW(
    WCHAR * pch
    )
{
    WCHAR * pchStart;
    DWORD sum = 0;
    DWORD mult = 1;

    while ( *pch == L' ' )
        pch++;

    pchStart = pch;

    while ( iswxdigit( *pch ) )
        pch++;

    while ( --pch >= pchStart )
    {
        sum += mult * ( *pch  >= L'A' ? *pch + 10 - L'A' :
                                       *pch - L'0' );
        mult *= 16;
    }

    return sum;
}



DWORD
hextointA(
    CHAR * pch
    )
{
    CHAR * pchStart;
    DWORD sum = 0;
    DWORD mult = 1;

    while ( *pch == ' ' )
        pch++;

    pchStart = pch;

    while ( isxdigit( (UCHAR)(*pch) ) )
        pch++;

    while ( --pch >= pchStart )
    {
        sum += mult * ( *pch  >= 'A' ? *pch + 10 - 'A' :
                                      *pch - '0' );
        mult *= 16;
    }

    return sum;

} // hextointA




BOOL
IIS_SERVER_INSTANCE::MoveVrootFromRegToMD(
    VOID
    )
{
    DBGPRINTF((DBG_CONTEXT,"MoveVrootFromRegToMD called!!!\n"));
    return(TRUE);

} // IIS_SERVER_INSTANCE::MoveVrootFromRegToMD


BOOL
TsCopyVrootToRegistry(
    PVOID          pvContext,
    MB *           pmb,
    VIRTUAL_ROOT * pvr
    )
{

    DWORD cch;
    DWORD err;
    HKEY hkey = (HKEY)pvContext;
    CHAR szValue[ MAX_PATH + UNLEN + 2 ];

    IF_DEBUG(METABASE) {
        DBGPRINTF((DBG_CONTEXT,"CopyVrootToReg: Adding %s to registry\n",
            pvr->pszAlias));
    }

    cch = wsprintfA( szValue,
                     "%s,%s,%X",
                     pvr->pszPath,
                     pvr->pszUserName,
                     pvr->dwAccessPerm );

    DBG_ASSERT( cch < sizeof( szValue ) );

    err = WriteRegistryStringA(hkey,
                   pvr->pszAlias,
                   szValue,
                   strlen(szValue),
                   REG_SZ);

    DBG_ASSERT(err == NO_ERROR);

    return(TRUE);

} // TsCopyVrootToRegistry



BOOL
IIS_SERVER_INSTANCE::MoveMDVroots2Registry(
    VOID
    )
/*++

Routine Description:

    Moves MD VR entries to the registry if registry VR key
    does not exist at startup.

Arguments:

    None.

Return Value:

    None.

--*/
{

    HKEY hkey = NULL;
    HKEY hkeyRoots = NULL;
    DWORD dwDisp;
    DWORD err;
    BOOL  fMigrated = FALSE;

    MB mb( (IMDCOM*) m_Service->QueryMDObject()  );

    DBG_ASSERT(IsDownLevelInstance());

    IF_DEBUG(METABASE) {
        DBGPRINTF((DBG_CONTEXT,"Entering MoveMDToRegAtStartup.\n"));
    }

    //
    // see if the key exists
    //

    err = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                        m_Service->QueryRegParamKey( ),
                        0,
                        KEY_READ|KEY_WRITE,
                        &hkey );

    if ( err != NO_ERROR ) {
        DBGPRINTF(( DBG_CONTEXT,
            "RegOpenKeyEx %s returned error %d\n",
            m_Service->QueryRegParamKey(), err ));

        goto exit;
    }

    //
    // VR key?
    //

    err = RegCreateKeyEx( hkey,
                        VIRTUAL_ROOTS_KEY_A,
                        0,
                        NULL,
                        0,
                        KEY_READ|KEY_WRITE,
                        NULL,
                        &hkeyRoots,
                        &dwDisp );

    if ( err != NO_ERROR ) {
        IF_DEBUG(METABASE) {
            DBGPRINTF((DBG_CONTEXT,
                "Error %d in RegCreateKeyEx\n",err));
        }

        goto exit;
    }

#if 0
    Removing this if will mean everytime the server starts we migrate the registry
    keys to the metabase.  The only side effect this has is if somebody deleted the
    a virtual directory from the metabase w/o the server started, that key will be
    migrated back from the registry.  With the server running it's not a big deal
    since the server always mirrors the metabase to the registry on vroot changes.

    if ( dwDisp == REG_OPENED_EXISTING_KEY ) {
        IF_DEBUG(METABASE) {
            DBGPRINTF((DBG_CONTEXT,
                "Registry VR key found, aborting startup migration.\n"));
        }

        goto exit;
    }
#endif

    //
    // Get the MD handle to the VR root
    //

    if ( !mb.Open( QueryMDPath(),
                   METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE ))
    {
        DBGPRINTF((DBG_CONTEXT,"Open MD vr root returns %d\n",GetLastError()));
        goto exit;
    }

    IF_DEBUG(METABASE) {
        DBGPRINTF((DBG_CONTEXT,"Opening MD path[%s]\n",QueryMDPath()));
    }

    TsRecursiveEnumVirtualRoots(
                    TsCopyVrootToRegistry,
                    hkeyRoots,
                    IIS_MD_INSTANCE_ROOT "/",
                    1,
                    (LPVOID)&mb,
                    TRUE );

    mb.Close();
    fMigrated = TRUE;

exit:

    if ( hkey != NULL ) {
        RegCloseKey(hkey);
    }

    if ( hkeyRoots != NULL ) {
        RegCloseKey(hkeyRoots);
    }

    IF_DEBUG(METABASE) {
        DBGPRINTF((DBG_CONTEXT,"Leaving MoveMDToRegAtStartup.\n"));
    }
    return(fMigrated);

} // IIS_SERVER_INSTANCE::MoveMDVroots2Registry



VOID
IIS_SERVER_INSTANCE::PdcHackVRReg2MD(
    VOID
    )
/*++

Routine Description:

    Moves VR entries to the MD at startup.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DWORD     err;
    CHAR      pszRoot[MAX_LENGTH_VIRTUAL_ROOT + MAX_LENGTH_ROOT_ADDR + 2];
    CHAR      pszDirectory[MAX_PATH + UNLEN + 3];

    CHAR *    pszUser;
    DWORD     cchRoot;
    DWORD     cchDir;
    DWORD     cch;
    BOOL      fRet = TRUE;
    DWORD     i = 0;
    DWORD     dwRegType;

    DWORD     dwMask;
    PCHAR     pszMask;
    PCHAR     tmpRoot;
    DWORD     dwAuthorization;
    MB        mb( (IMDCOM*) m_Service->QueryMDObject()  );

    HKEY      hkey = NULL;
    HKEY      hkeyRoots = NULL;

    DBG_ASSERT(IsDownLevelInstance());

    IF_DEBUG(METABASE) {
        DBGPRINTF((DBG_CONTEXT,"In MoveVrootFromRegToMD\n"));
    }

    //
    // see if the key exists
    //

    err = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                        m_Service->QueryRegParamKey( ),
                        0,
                        KEY_READ,
                        &hkey );

    if ( err != NO_ERROR ) {
        DBGPRINTF(( DBG_CONTEXT, "RegOpenKeyEx returned error %d\n",err ));
        return;
    }

    //
    // VR key?
    //

    if ( err = RegOpenKeyEx( hkey,
                           VIRTUAL_ROOTS_KEY_A,
                           0,
                           KEY_READ,
                           &hkeyRoots )) {

        IF_DEBUG(METABASE) {
            DBGPRINTF((DBG_CONTEXT,"RegOpenKeyEx %s failed with %d\n",
                      VIRTUAL_ROOTS_KEY_A, err));
        }
        goto exit;
    }

    //
    // Key exists. Get the authorization key
    //

    {
        HKEY instanceKey;

        err = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                            QueryRegParamKey(),
                            0,
                            KEY_ALL_ACCESS,
                            &instanceKey );

        if ( err != NO_ERROR ) {
            goto exit;
        }

        dwAuthorization = ReadRegistryDword( instanceKey,
                                         INETA_AUTHENTICATION,
                                         INET_INFO_AUTH_ANONYMOUS );

        RegCloseKey( instanceKey );
    }

    //
    // Get the MD handle to the VR root
    //

    if ( !mb.Open( QueryMDPath(),
                   METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE ))
    {
        DBGPRINTF((DBG_CONTEXT,"Open MD vr root returns %d\n",GetLastError()));
        goto exit;
    }

    IF_DEBUG(METABASE) {
        DBGPRINTF((DBG_CONTEXT,"Adding MD path[%s]\n",QueryMDPath()));
    }

    //
    //  Enumerate all of the listed items in the registry
    //  and add them
    //

    strcpy( pszRoot, IIS_MD_INSTANCE_ROOT );
    tmpRoot = (PCHAR)pszRoot+sizeof( IIS_MD_INSTANCE_ROOT ) - 1;

    while ( TRUE ) {

        PCHAR pszComma;

        cchRoot = sizeof( pszRoot ) - 1;
        cchDir  = sizeof( pszDirectory );

        err = RegEnumValue( hkeyRoots,
                             i++,
                             tmpRoot,
                             &cchRoot,
                             NULL,
                             &dwRegType,
                             (LPBYTE) pszDirectory,
                             &cchDir );

        if ( err == ERROR_NO_MORE_ITEMS ) {
            break;
        }

        if ( dwRegType == REG_SZ ) {

            //
            //  The optional user name is kept after the directory.
            //  Only used for UNC roots, ignore for others
            //

            if ( pszUser = strchr( pszDirectory, ',' ) )
            {
                *pszUser = '\0';
                pszUser++;
            } else {
                pszUser = "";
            }

            //
            //  The optional access mask is kept after the user name.  It must
            //  appear in upper case hex.
            //

            if ( pszUser && (pszMask = strchr( pszUser, ',' )) ) {

                *pszMask = '\0';
                pszMask++;

                dwMask = hextointA( pszMask );
            } else {
                dwMask = VROOT_MASK_READ;
            }

            //
            // Remove commas from the root
            //

            pszComma = strchr(tmpRoot, ',');
            if ( pszComma != NULL ) {
                *pszComma = '\0';
                cchRoot--;
            }

            //
            // Write it out to the metabase
            //

            cchRoot++;

            //
            // This is the root
            //

            if ( !mb.AddObject( pszRoot ) )
            {
                if ( GetLastError() != ERROR_ALREADY_EXISTS )
                {
                     DBGPRINTF((DBG_CONTEXT,"AddMetaObject %s failed with %d\n",
                                pszRoot, GetLastError() ));
                }

                continue;
            }

            //
            // Set Path
            //

            mb.SetString( pszRoot,
                          MD_VR_PATH,
                          IIS_MD_UT_FILE,
                          pszDirectory );

            mb.SetString( pszRoot,
                          MD_KEY_TYPE,
                          IIS_MD_UT_SERVER,
                          "IIsWebVirtualDir" );

            //
            // Set Username
            //

            if ( pszUser && *pszUser )
            {
                mb.SetString( pszRoot,
                              MD_VR_USERNAME,
                              IIS_MD_UT_FILE,
                              pszUser );
            }

            //
            // Set Mask
            //

            mb.SetDword( pszRoot,
                         MD_ACCESS_PERM,
                         IIS_MD_UT_FILE,
                         dwMask );
        }

    } // while

    mb.Close();

exit:

    if ( hkeyRoots != NULL ) {
        RegCloseKey( hkeyRoots );
    }

    if ( hkey != NULL ) {
        RegCloseKey( hkey );
    }

    return;

} // IIS_SERVER_INSTANCE::PdcHackVRReg2MD


VOID
IIS_SERVER_INSTANCE::TsMirrorVirtualRoots(
    IN  LPINETA_CONFIG_INFO pConfig
    )
/*++
    Description:

        Writes the virtual roots specified in the config structure to the
        registry

    Arguments:
        pConfig - new list of virtual

    Returns:
        TRUE on success and FALSE if any failure.

--*/
{
    DWORD               err;
    HKEY                hkey = NULL;
    HKEY                hkeyRoots = NULL;

    DWORD               dwDummy;
    LPINET_INFO_VIRTUAL_ROOT_LIST pRootsList;
    DWORD               cch;
    DWORD               i;

    DBG_ASSERT(IsDownLevelInstance());

    pRootsList = pConfig->VirtualRoots;

    //
    // Write it to the root key
    //

    err = RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE,
                    m_Service->QueryRegParamKey(),
                    0,
                    KEY_ALL_ACCESS,
                    &hkey );

    if ( err != NO_ERROR ) {
        DBGPRINTF(( DBG_CONTEXT, "RegOpenKeyEx for returned error %d\n",err ));
        return;
    }

    //
    //  First delete the key to remove any old values
    //

    if (err = RegDeleteKey( hkey,
                            VIRTUAL_ROOTS_KEY_A ))
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "[TsMirrorVRoots] Unable to remove old values\n"));

    }

    if ( err = RegCreateKeyEx( hkey,
                               VIRTUAL_ROOTS_KEY_A,
                               0,
                               NULL,
                               0,
                               KEY_ALL_ACCESS,
                               NULL,
                               &hkeyRoots,
                               &dwDummy ))
    {
        goto exit;
    }

    //
    //  Permit empty list
    //

    if ( pRootsList == NULL ) {
        goto exit;
    }

    for ( i = 0; i < pRootsList->cEntries; i++ ) {

        WCHAR achValue[ MAX_PATH + UNLEN + 2 ];

        cch = _snwprintf( achValue,
                          MAX_PATH + UNLEN + 1,
                          L"%s,%s,%X",
                          pRootsList->aVirtRootEntry[i].pszDirectory,
                          pRootsList->aVirtRootEntry[i].pszAccountName,
                          pRootsList->aVirtRootEntry[i].dwMask );

        DBG_ASSERT( cch < sizeof( achValue ) / sizeof(WCHAR) );

        achValue[ MAX_PATH + UNLEN + 1 ] = L'\0';

        err = WriteRegistryStringW(hkeyRoots,
                       pRootsList->aVirtRootEntry[i].pszRoot,
                       achValue,
                       (wcslen(achValue) + 1) * sizeof(WCHAR),
                       REG_SZ);

        if ( err != NO_ERROR ) {
            goto exit;
        }
    }

exit:

    if ( hkeyRoots != NULL ) {
        RegCloseKey( hkeyRoots );
    }

    if ( hkey != NULL ) {
        RegCloseKey( hkey );
    }

    return;

} // IIS_SERVER_INSTANCE::TsMirrorVirtualRoots


VOID
ClearSentinelEntry(
    IN MB * pMB
    )
/*++
    Description:

        Removes the sentinel entry from all VR for this instance

    Arguments:
        pMD - pointer to metabase helper object that points to the
            instance metadatabase root.

    Returns:
        None.

--*/
{
    BOOL fGetRoot = TRUE;
    CHAR nameBuf[METADATA_MAX_NAME_LEN+2];
    DWORD i = 0;

    IF_DEBUG(METABASE) {
        DBGPRINTF((DBG_CONTEXT,"Entering ClearSentinelEntry\n"));
    }

    while ( TRUE ) {

        METADATA_RECORD mdRecord;

        nameBuf[0] = nameBuf[1] = '/';

        if ( fGetRoot ) {

            fGetRoot = FALSE;
            nameBuf[2] = '\0';

        } else {

            if ( !pMB->EnumObjects( IIS_MD_INSTANCE_ROOT,
                                    &nameBuf[2],
                                    i++ ))
            {
                break;
            }
        }

        //
        // Delete sentinel value
        //

        if ( !pMB->DeleteData( nameBuf,
                            MD_VR_UPDATE,
                            IIS_MD_UT_FILE,
                            DWORD_METADATA
                            ))
        {
            IF_DEBUG(METABASE) {
                DBGPRINTF((DBG_CONTEXT,"Error %x deleting sentinel from %s\n",
                      GetLastError(), nameBuf));
            }
        }
    }

    return;

} // ClearSentinelEntry


VOID
RemoveUnmarkedRoots(
    IN MB * pMB
    )
/*++
    Description:

        Removes roots that are not marked by sentinel

    Arguments:
        pMD - pointer to metabase helper object that points to the
            instance metadatabase root.

    Returns:
        None.

--*/
{
    BOOL fGetRoot = TRUE;
    CHAR nameBuf[METADATA_MAX_NAME_LEN+2];
    CHAR szDirectory[MAX_PATH+1];
    DWORD cb;
    DWORD i = 0;
    BOOL fProcessingRoot;

    IF_DEBUG(METABASE) {
        DBGPRINTF((DBG_CONTEXT,"Entering RemoveUnmarkedRoots\n"));
    }

    while ( TRUE ) {

        if ( fGetRoot ) {

            strcpy( nameBuf, IIS_MD_INSTANCE_ROOT );
            fProcessingRoot = TRUE;
            fGetRoot = FALSE;

        } else {

            strcpy( nameBuf, IIS_MD_INSTANCE_ROOT "/" );


            fProcessingRoot = FALSE;
            if ( !pMB->EnumObjects( IIS_MD_INSTANCE_ROOT,
                                    &nameBuf[strlen(nameBuf)],
                                    i++ ))
            {
                break;
            }
        }

        //
        // Delete sentinel value.  If delete successful, leave alone
        //

        if ( pMB->DeleteData( nameBuf,
                            MD_VR_UPDATE,
                            IIS_MD_UT_FILE,
                            DWORD_METADATA
                            ))
        {
            continue;
        }

        IF_DEBUG(METABASE) {
            DBGPRINTF((DBG_CONTEXT,"Error %x deleting sentinel from %s\n",
                  GetLastError(), nameBuf));
        }

        //
        // See if it has the path parameter
        //

        cb = sizeof( szDirectory );

        if ( !pMB->GetString( nameBuf,
                            MD_VR_PATH,
                            IIS_MD_UT_FILE,
                            szDirectory,
                            &cb,
                            0 ))
        {
            //
            // Not a VR
            //

            DBGPRINTF((DBG_CONTEXT,
                "Error %x reading path from %s. Not a VR.\n",
                      GetLastError(), nameBuf));
            continue;
        }

        //
        // Unmarked, delete the VR
        //

        IF_DEBUG(METABASE) {
            DBGPRINTF((DBG_CONTEXT,"Deleting vroot %s[%d]\n",
                nameBuf, fGetRoot));
        }

        if ( fProcessingRoot ) {

            //
            // if this is the root, just remove the path.  Deleting the
            // root is a potentially dangerous undertaking!
            //

            if ( !pMB->DeleteData( nameBuf,
                                MD_VR_PATH,
                                IIS_MD_UT_FILE,
                                STRING_METADATA
                                ))
            {
                DBGPRINTF((DBG_CONTEXT,"Error %x deleting root path\n",
                    GetLastError()));
            }

        } else {

            //
            // Delete the Vroot
            //

            if ( !pMB->DeleteObject( nameBuf ) )
            {
                DBGPRINTF((DBG_CONTEXT,"Error %x deleting %s\n",
                    GetLastError(), nameBuf));

            } else {

                //
                // the delete moved the index back by 1
                //

                DBG_ASSERT( i != 0 );

                --i;

            }
        }

        fGetRoot = FALSE;
    }

    return;

} // RemoveUnmarkedRoots


BOOL
ReadVrootConfig(
    LPVOID          pvMB,
    LPSTR           szVRPath,
    LPSTR           szDirectory,
    DWORD           cbDirectory,
    LPSTR           szUser,
    DWORD           cbUser,
    LPSTR           szPassword,
    DWORD           cbPassword,
    DWORD           *pdwMask,
    BOOL            *pfDoCache
    )
{

    DWORD           cb;
    DWORD           dwNoCache = 0;

    MB*             pMB = (MB*)pvMB;

    //
    // Get Directory path
    //

    cb = cbDirectory;

    if ( !pMB->GetString( szVRPath,
                        MD_VR_PATH,
                        IIS_MD_UT_FILE,
                        szDirectory,
                        &cb,
                        0 ))
    {
#if DBG
        if ( GetLastError() != MD_ERROR_DATA_NOT_FOUND )
        {
            DBGPRINTF((DBG_CONTEXT,"Error %x reading path from %s. Not a VR.\n",
                      GetLastError(), szVRPath));
        }
#endif

        return FALSE;
    }

    //
    // Get mask
    //

    if ( !pMB->GetDword( szVRPath,
                       MD_ACCESS_PERM,
                       IIS_MD_UT_FILE,
                       pdwMask,
                       0))
    {
        *pdwMask = VROOT_MASK_READ;

        IF_DEBUG(ERROR) {
            DBGPRINTF((DBG_CONTEXT,"Error %x reading mask from %s\n",
                  GetLastError(), szVRPath));
        }
    }

    //
    // Get username
    //

    cb = cbUser;

    if ( !pMB->GetString( szVRPath,
                        MD_VR_USERNAME,
                        IIS_MD_UT_FILE,
                        szUser,
                        &cb,
                        0))
    {
        szUser[0] = '\0';
    }

    IF_DEBUG(METABASE) {
        DBGPRINTF((DBG_CONTEXT,"Read %s: Path[%s] User[%s] Mask[%d]\n",
                  szVRPath, szDirectory, szUser, *pdwMask));
    }

    if ( (szUser[0] != '\0') &&
         (szDirectory[0] == '\\') && (szDirectory[1] == '\\') ) {

        cb = cbPassword;

        //
        //  Retrieve the password for this address/share
        //

        if ( !pMB->GetString( szVRPath,
                            MD_VR_PASSWORD,
                            IIS_MD_UT_FILE,
                            szPassword,
                            &cb,
                            METADATA_SECURE))
        {
            szPassword[0] = '\0';
        }
    }
    else
    {
        szPassword[0] = '\0';
    }

    //
    // Should we cache this vdir
    //

    pMB->GetDword( szVRPath,
                   MD_VR_NO_CACHE,
                   IIS_MD_UT_FILE,
                   &dwNoCache,
                   0 );

    *pfDoCache = !dwNoCache;

    return TRUE;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\dcomadm\dll\admacl.cxx ===
/*++

   Copyright    (c)    1996    Microsoft Corporation

   Module  Name :
      admacl.cxx

   Abstract:
      This module defines Admin API Access Check API

   Author:

       Philippe Choquier    02-Dec-1996
--*/
#include "precomp.hxx"

#include <imd.h>
#include <iadm.h>
#include <mb.hxx>

#include "admacl.hxx"
#include "coiadm.hxx"

#ifndef ARRAYSIZE
    #define ARRAYSIZE(_a) (sizeof((_a))/sizeof(*(_a)))
#endif

//
// Globals
//
CInitAdmacl             g_cinitadmacl;
CAdminAclCache          g_AclCache;

CInitAdmacl::CInitAdmacl()
{
    DBG_REQUIRE(SUCCEEDED(g_AclCache.Init()));
}

CInitAdmacl::~CInitAdmacl()
{
    DBG_ASSERT(g_AclCache.IsEmpty()==S_OK);
}

//
//  Generic mapping for Application access check

GENERIC_MAPPING g_FileGenericMapping =
{
    FILE_READ_DATA,
    FILE_WRITE_DATA,
    FILE_EXECUTE,
    FILE_ALL_ACCESS
};

BOOL
AdminAclNotifyClose(
    LPVOID          pvAdmin,
    METADATA_HANDLE hAdminHandle
    )
/*++

Routine Description:

    Notify admin acl access check module of close request

Arguments:

    pvAdmin - admin context
    hAdminHandle - handle to metadata

Returns:

    TRUE on success, FALSE on failure

--*/
{
    g_AclCache.Remove(pvAdmin, hAdminHandle);

    return TRUE;
}

void
AdminAclDisableAclCache()
{
    g_AclCache.Disable();
}

void
AdminAclEnableAclCache()
{
    g_AclCache.Enable();
}

BOOL
AdminAclFlushCache(
    )
/*++

Routine Description:

    Flush cache

Arguments:

    None

Returns:

    TRUE on success, FALSE on failure

--*/
{
    g_AclCache.Flush();

    return TRUE;
}

BOOL
AdminAclNotifySetOrDeleteProp(
    METADATA_HANDLE ,
    DWORD           dwId
    )
/*++

Routine Description:

    Notify admin acl access check module of update to metabase

Arguments:

    hAdminHandle - handle to metadata
    dwId - property ID set or deleted

Returns:

    TRUE on success, FALSE on failure

--*/
{
    // flush cache for all ACLs
    if ( dwId == MD_ADMIN_ACL )
    {
        g_AclCache.Flush();
    }

    return TRUE;
}

static HRESULT
_GetThreadToken(
    HANDLE          *phThreadToken)
/*++
Routine Description:
    Returns handle to the thread impersonation token.
    The caller must close the handle.

Arguments:
    phThreadToken   -   Out, a handle to the thread token

Returns:
    S_OK on success, E_* on failure
--*/
{
    // Locals
    HRESULT             hr=S_OK;
    HANDLE              hThread;
    HANDLE              hToken=NULL;
    IServerSecurity*    pServerSecurity=NULL;

    // Check args
    if (phThreadToken)
    {
        // Initialize to NULL
        *phThreadToken=NULL;
    }
    else
    {
        hr=E_INVALIDARG;
        goto exit;
    }

    // Get the pseudo handle to the current thread
    hThread=GetCurrentThread();

    //
    // test if already impersonated ( inprocess call w/o marshalling )
    // If not call DCOM to retrieve security context & impersonate, then
    // extract access token.
    //
    if (!OpenThreadToken(hThread, TOKEN_EXECUTE|TOKEN_QUERY, TRUE, &hToken))
    {
        // this thread is not impersonating -> process token


        // Get the DCOM server security object
        hr=CoGetCallContext(IID_IServerSecurity, (VOID**)&pServerSecurity);
        if (FAILED(hr))
        {
            goto exit;
        }

        // Impersonate the caller
        hr=pServerSecurity->ImpersonateClient();
        if (FAILED(hr))
        {
            goto exit;
        }

        // Try again to get the token
        if (!OpenThreadToken(hThread, TOKEN_EXECUTE|TOKEN_QUERY, TRUE, &hToken))
        {
            hr=HRESULT_FROM_WIN32(GetLastError());
            goto exit;
        }
    }

    // Return the token
    *phThreadToken=hToken;
    hToken=NULL;

exit:
    // Cleanup
    if (pServerSecurity)
    {
        if (pServerSecurity->IsImpersonating())
        {
            // better here, since
            // COM otherwise is reclaiming the
            // thread token too late.
            pServerSecurity->RevertToSelf();
        }
        pServerSecurity->Release();
    }
    if (hToken)
    {
        CloseHandle(hToken);
    }

    // Done
    return (hr);
}

BOOL
AdminAclAccessCheck(
    IMDCOM*         pMDCom,
    LPVOID          pvAdmin,
    METADATA_HANDLE hAdminHandle,
    LPCWSTR         pszRelPath,
    DWORD           dwId,           // check for MD_ADMIN_ACL, must have special right to write them
                                    // can be 0 for non ID based access ( enum, create )
                                    // or -1 for GetAll
    DWORD           dwAccess,       // METADATA_PERMISSION_*
    COpenHandle*    pohHandle,
    LPBOOL          pfEnableSecureAccess
    )
/*++

Routine Description:

    Perform access check based on path, ID and access type

Arguments:

    hAdminHandle - Open handle
    pszRelPath - path to object ( relative to open path )
    dwId - property ID
    dwAccess - access type, as defined by metabase header
    pfEnableSecureAccess - update with TRUE if read access to secure properties granted

Returns:

    TRUE on success, FALSE on failure

--*/
{
    CAdminAcl*          pAdminAclCurrent = NULL;
    BOOL                bReturn = TRUE;
    HANDLE              hAccTok = NULL;
    LPBYTE              pAcl = NULL;
    DWORD               dwRef;
    BOOL                fIsAnyAcl;
    BOOL                bAddToCache = FALSE;
    DWORD               dwAcc;
    DWORD               dwGrantedAccess;
    BYTE                PrivSet[400];
    DWORD               cbPrivilegeSet = sizeof(PrivSet);
    BOOL                fAccessGranted;

    if ( pfEnableSecureAccess )
    {
        *pfEnableSecureAccess = TRUE;
    }

    if ( pszRelPath == NULL )
    {
        pszRelPath = L"";
    }

    // Get the token
    _GetThreadToken(&hAccTok);
    // can be non null only if obtained from thread
    if (hAccTok==NULL)
    {
        //
        // For now, assume failure to get IServerSecurity means we are
        // in the SYSTEM context, so grant access.
        //

        bReturn = TRUE;
        goto exit;
    }

    // find match : look for exact path match
    // keep at most N entry, reset at top of list when accessed
    // Investigate: if in <NSE> : cut-off point just before <nse>
    g_AclCache.Find(pvAdmin, hAdminHandle, pszRelPath, &pAdminAclCurrent);

    //
    // BUGBUG This checking only checks path and handle, not DCOM instance
    // So there could be incorrect matches.
    //

    if( pAdminAclCurrent == NULL )
    {
        pAdminAclCurrent = new CAdminAcl;
        if ( pAdminAclCurrent==NULL )
        {
            //
            // failed to create new cache entry
            //

            bReturn = FALSE;
            goto exit;
        }

        // read ACL

        if ( !pohHandle->GetAcl( pMDCom, pszRelPath, &pAcl, &dwRef ) )
        {
            pAcl = NULL;
            dwRef = NULL;
        }

        //
        // BUGBUG should normalize the path so /x and x don't generate
        // 2 entries
        //

        //
        // If path is too long,
        // Go ahead and check the ACL, but don't put in cache
        //

        bReturn = pAdminAclCurrent->Init( pMDCom,
                                          pvAdmin,
                                          hAdminHandle,
                                          pszRelPath,
                                          pAcl,
                                          dwRef,
                                          &bAddToCache );
        //
        // Currently no possible failures
        //
        DBG_ASSERT(bReturn);

        if ( !bReturn )
        {


            goto exit;
        }

        if (bAddToCache)
        {
            g_AclCache.Add(pAdminAclCurrent);
        }

    }

    DBG_ASSERT(pAdminAclCurrent);

    //
    // Access check
    //
    pAcl = pAdminAclCurrent->GetAcl();

    if (pAcl==NULL)
    {
        //
        // No ACL : access check succeed
        //

        bReturn = TRUE;
        goto exit;
    }

    //
    // Protected properties require EXECUTE access rights instead of WRITE
    //

    if ( dwAccess & METADATA_PERMISSION_WRITE )
    {
        if ( dwId == MD_ADMIN_ACL ||
             dwId == MD_VPROP_ADMIN_ACL_RAW_BINARY ||
             dwId == MD_APPPOOL_ORPHAN_ACTION_EXE ||
             dwId == MD_APPPOOL_ORPHAN_ACTION_PARAMS ||
             dwId == MD_APPPOOL_AUTO_SHUTDOWN_EXE ||
             dwId == MD_APPPOOL_AUTO_SHUTDOWN_PARAMS ||
             dwId == MD_APPPOOL_IDENTITY_TYPE ||
             dwId == MD_APP_APPPOOL_ID ||
             dwId == MD_APP_ISOLATED ||
             dwId == MD_VR_PATH ||
             dwId == MD_ACCESS_PERM ||
             dwId == MD_VR_USERNAME ||
             dwId == MD_VR_PASSWORD ||
             dwId == MD_ANONYMOUS_USER_NAME ||
             dwId == MD_ANONYMOUS_PWD ||
             dwId == MD_LOGSQL_USER_NAME ||
             dwId == MD_LOGSQL_PASSWORD ||
             dwId == MD_WAM_USER_NAME ||
             dwId == MD_WAM_PWD ||
             dwId == MD_AD_CONNECTIONS_USERNAME ||
             dwId == MD_AD_CONNECTIONS_PASSWORD ||
             dwId == MD_MAX_BANDWIDTH ||
             dwId == MD_MAX_BANDWIDTH_BLOCKED ||
             dwId == MD_ISM_ACCESS_CHECK ||
             dwId == MD_FILTER_LOAD_ORDER ||
             dwId == MD_FILTER_ENABLED ||
             dwId == MD_FILTER_IMAGE_PATH ||
             dwId == MD_SECURE_BINDINGS ||
             dwId == MD_SERVER_BINDINGS ||
             dwId == MD_ASP_ENABLECLIENTDEBUG ||
             dwId == MD_ASP_ENABLESERVERDEBUG ||
             dwId == MD_ASP_ENABLEPARENTPATHS ||
             dwId == MD_ASP_ERRORSTONTLOG ||
             dwId == MD_ASP_KEEPSESSIONIDSECURE ||
             dwId == MD_ASP_LOGERRORREQUESTS ||
             dwId == MD_ASP_DISKTEMPLATECACHEDIRECTORY ||
             dwId == 36948 || // RouteUserName
             dwId == 36949 || // RoutePassword
             dwId == 36958 || // SmtpDsPassword
             dwId == 41191 || // Pop3DsPassword
             dwId == 45461 || // FeedAccountName
             dwId == 45462 || // FeedPassword
             dwId == 49384 )  // ImapDsPassword
        {
            dwAcc = MD_ACR_RESTRICTED_WRITE;
        }
        else
        {
            dwAcc = MD_ACR_WRITE;
        }
    }
    else // ! only METADATA_PERMISSION_WRITE
    {
        if ( dwId == AAC_ENUM_KEYS )
        {
            dwAcc = MD_ACR_ENUM_KEYS;
        }
        else
        {
            // assume read access
            dwAcc = MD_ACR_READ;
        }
    }

    //
    // If copy or delete key, check if ACL exists in subtree
    // if yes required MD_ACR_RESTRICTED_WRITE
    //

    if ( dwAcc == MD_ACR_WRITE &&
         (dwId == AAC_COPYKEY || dwId == AAC_DELETEKEY) )
    {
        if ( pohHandle->CheckSubAcls( pMDCom, pszRelPath, &fIsAnyAcl ) &&
             fIsAnyAcl )
        {
            dwAcc = MD_ACR_RESTRICTED_WRITE;
        }
    }

CheckAgain:
    if ( !AccessCheck( pAcl,
                       hAccTok,
                       dwAcc,
                       &g_FileGenericMapping,
                       (PRIVILEGE_SET *) PrivSet,
                       &cbPrivilegeSet,
                       &dwGrantedAccess,
                       &fAccessGranted ) ||
         !fAccessGranted )
    {
        if ( dwAcc != MD_ACR_WRITE_DAC && (dwId == MD_ADMIN_ACL) )
        {
            dwAcc = MD_ACR_WRITE_DAC;
            goto CheckAgain;
        }

        //
        // If read access denied, retry with restricted read right
        // only if not called from GetAll()
        //

        if ( dwAcc == MD_ACR_READ &&
             pfEnableSecureAccess )
        {
            dwAcc = MD_ACR_UNSECURE_PROPS_READ;
            *pfEnableSecureAccess = FALSE;
            goto CheckAgain;
        }

        SetLastError( ERROR_ACCESS_DENIED );
        bReturn = FALSE;
    }

exit:
    // Cleanup
    if (pAdminAclCurrent)
    {
        pAdminAclCurrent->Release();
    }
    if (hAccTok)
    {
        CloseHandle( hAccTok );
    }

    return bReturn;
}

CAdminAcl::~CAdminAcl(
    )
/*++

Routine Description:

    Destructor for Admin Acl cache entry

Arguments:

    None

Returns:

    Nothing

--*/
{
    if ( m_pMDCom )
    {
        if ( m_dwAclRef )
        {
            m_pMDCom->ComMDReleaseReferenceData( m_dwAclRef );
        }
        m_pMDCom->Release();
    }

    m_dwSignature = ADMINACL_FREED_SIGN;
}

DWORD
CAdminAcl::AddRef()
/*++
Routine Description:
    Interlocked increments the reference count.

Arguments:
    None

Returns:
    The new reference count.
--*/
{
    return ((DWORD)InterlockedIncrement((LONG*)&m_cRef));
}

DWORD
CAdminAcl::Release()
/*++
Routine Description:
    Interlocked decrements the reference count.
    When the reference count reaches 0 deletes the object.

Arguments:
    None

Returns:
    The new reference count.
--*/
{
    DWORD               cRef;

    cRef=(DWORD)InterlockedDecrement((LONG*)&m_cRef);

    if (cRef==0)
    {
        delete this;
    }

    return (cRef);
}

BOOL
CAdminAcl::Init(
    IMDCOM*         pMDCom,
    LPVOID          pvAdmin,
    METADATA_HANDLE hAdminHandle,
    LPCWSTR         pszPath,
    LPBYTE          pAcl,
    DWORD           dwAclRef,
    PBOOL           pbIsPathCorrect
    )
/*++

Routine Description:

    Initialize an Admin Acl cache entry

Arguments:

    hAdminHandle - metadata handle
    pszPath - path to object ( absolute )
    pAcl - ptr to ACL for this path ( may be NULL )
    dwAclRef - access by reference ID

Returns:

    Nothing

--*/
{
    m_hAdminHandle = hAdminHandle;
    m_pvAdmin = pvAdmin;
    *pbIsPathCorrect = TRUE;

    if (pszPath != NULL)
    {
        if ( wcslen( pszPath ) < (sizeof(m_wchPath) / sizeof(WCHAR)) )
        {
            wcscpy( m_wchPath, pszPath );
        }
        else
        {
            m_wchPath[0] = (WCHAR)'\0';
            *pbIsPathCorrect = FALSE;
        }
    }
    else
    {
        m_wchPath[0] = (WCHAR)'\0';
    }
    m_pAcl = pAcl;
    m_dwAclRef = dwAclRef;
    m_pMDCom = pMDCom;
    pMDCom->AddRef();

    m_dwSignature = ADMINACL_INIT_SIGN;

    return TRUE;
}

HRESULT
COpenHandle::Init(
    METADATA_HANDLE hAdminHandle,
    LPCWSTR          pszRelPath,
    LPCWSTR          pszParentPath

    )
/*++

Routine Description:

    Initialize an open context cache entry

Arguments:

    pvAdmin - admin context
    hAdminHandle - metadata handle
    pszRelPath - path to object ( absolute )


Returns:

    Nothing

--*/
{

    HRESULT hresReturn = ERROR_SUCCESS;
    LPWSTR pszRelPathIndex = (LPWSTR)pszRelPath;

    m_hAdminHandle = hAdminHandle;
    m_lRefCount = 1;

    if (pszRelPath == NULL)
    {
        pszRelPathIndex = L"";
    }

    DBG_ASSERT(pszParentPath != NULL);
    DBG_ASSERT((*pszParentPath == (WCHAR)'\0') ||
               ISPATHDELIMW(*pszParentPath));

    //
    // Strip front slash now, add it in later
    //

    if (ISPATHDELIMW(*pszRelPathIndex))
    {
        pszRelPathIndex++;
    }

    DWORD dwRelPathLen = (DWORD)wcslen(pszRelPathIndex);
    DWORD dwParentPathLen = (DWORD)wcslen(pszParentPath);

    DBG_ASSERT((dwParentPathLen == 0) ||
               (!ISPATHDELIMW(pszParentPath[dwParentPathLen -1])));

    //
    // Get rid of trailing slash for good
    //

    if ((dwRelPathLen > 0) && (ISPATHDELIMW(pszRelPathIndex[dwRelPathLen -1])))
    {
        dwRelPathLen--;
    }

    //
    // Include space for mid slash if Relpath exists
    // Include space for termination
    //

    DWORD dwTotalSize =
        (dwRelPathLen + dwParentPathLen + 1 + ((dwRelPathLen > 0) ? 1 : 0)) * sizeof(WCHAR);

    m_pszPath = (LPWSTR)LocalAlloc(LMEM_FIXED, dwTotalSize);

    if (m_pszPath == NULL)
    {
        hresReturn = RETURNCODETOHRESULT(GetLastError());
    }
    else
    {

        //
        // OK to always copy the first part
        //

        memcpy(m_pszPath,
               pszParentPath,
               dwParentPathLen * sizeof(WCHAR));

        //
        // Don't need slash if there is no RelPath
        //

        if (dwRelPathLen > 0)
        {

            m_pszPath[dwParentPathLen] = (WCHAR)'/';

            memcpy(m_pszPath + dwParentPathLen + 1,
                   pszRelPathIndex,
                   dwRelPathLen * sizeof(WCHAR));

        }

        m_pszPath[(dwTotalSize / sizeof(WCHAR)) - 1] = (WCHAR)'\0';

        //
        // Now convert \ to / for string compares
        //

        LPWSTR pszPathIndex = m_pszPath;

        while ((pszPathIndex = wcschr(pszPathIndex, (WCHAR)'\\')) != NULL)
        {
            *pszPathIndex = (WCHAR)'/';
        }

    }


    return hresReturn;
}

// Whistler 53924
/*++

  function backstrchr
  returns the last occurrence of a charcter or NULL if not found
  --*/

WCHAR * backstrchr(WCHAR * pString,WCHAR ThisChar)
{
	WCHAR *pCurrentPos = NULL;

	while(*pString)
    {
		if (*pString == ThisChar)
        {
            pCurrentPos = pString;
		}
		pString++;
	};
	return pCurrentPos;
}


BOOL
COpenHandle::GetAcl(
    IMDCOM* pMDCom,
    LPCWSTR  pszRelPath,
    LPBYTE* pAcl,
    LPDWORD pdwRef
    )
/*++

Routine Description:

    Retrieve Acl

Arguments:

    pszPath - path to object
    ppAcl - updated with ptr to ACL if success
    pdwRef - updated with ref to ACL if success

Returns:

    TRUE if success, otherwise FALSE

--*/
{
    METADATA_RECORD mdRecord = { 0 };
    HRESULT         hRes;
    DWORD           dwRequiredLen;
    BOOL            bReturn = TRUE;
    LPWSTR          pszFullPath;
    LPWSTR          pszRelPathIndex = (LPWSTR)pszRelPath;



    if (pszRelPathIndex == NULL)
    {
        pszRelPathIndex = L"";
    }

    DBG_ASSERT(m_pszPath != NULL);
    DBG_ASSERT((*m_pszPath == (WCHAR)'\0') ||
               ISPATHDELIMW(*m_pszPath));

    //
    // Strip front slash now, add it in later
    //

    if (ISPATHDELIMW(*pszRelPathIndex))
    {
        pszRelPathIndex++;
    }


    DWORD dwPathLen = (DWORD)wcslen(m_pszPath);
    DWORD dwRelPathLen = (DWORD)wcslen(pszRelPathIndex);

    DBG_ASSERT((dwPathLen == 0) ||
               (!ISPATHDELIMW(m_pszPath[dwPathLen -1])));

    //
    // Get rid of trailing slash for good
    //

    if ((dwRelPathLen > 0) && (ISPATHDELIMW(pszRelPathIndex[dwRelPathLen -1])))
    {
        dwRelPathLen--;
    }

    //
    // Include space for mid slash and termination
    //

    DWORD dwTotalSize = (dwPathLen + dwRelPathLen + 1 + ((dwRelPathLen > 0) ? 1 : 0)) * sizeof(WCHAR);

    pszFullPath = (LPWSTR)LocalAlloc(LMEM_FIXED, dwTotalSize);

    if (pszFullPath == NULL)
    {
        bReturn = FALSE;
    }
    else
    {
        memcpy(pszFullPath,
               m_pszPath,
               dwPathLen * sizeof(WCHAR));

        //
        // Don't need slash if there is no RelPath
        //

        if (dwRelPathLen > 0)
        {
            pszFullPath[dwPathLen] = (WCHAR)'/';

            memcpy(pszFullPath + dwPathLen + 1,
                   pszRelPathIndex,
                   dwRelPathLen * sizeof(WCHAR));

        }

        pszFullPath[(dwTotalSize - sizeof(WCHAR)) / sizeof(WCHAR)] = (WCHAR)'\0';

        //
        // Now convert \ to / for string compares
        // m_pszPath was already converted, so start at relpath
        //

        LPWSTR pszPathIndex = pszFullPath + (dwPathLen);

        while ((pszPathIndex = wcschr(pszPathIndex, (WCHAR)'\\')) != NULL)
        {
            *pszPathIndex = (WCHAR)'/';
        }

        //
        // Use /schema ACL if path = /schema/...
        //

        if (_wcsnicmp(pszFullPath,
                      IIS_MD_ADSI_SCHEMA_PATH_W L"/",
                      ((sizeof(IIS_MD_ADSI_SCHEMA_PATH_W L"/") / sizeof(WCHAR)) - 1)) == 0)
        {
            pszFullPath[(sizeof(IIS_MD_ADSI_SCHEMA_PATH_W) / sizeof(WCHAR)) -1] = (WCHAR)'\0';
        }

        mdRecord.dwMDIdentifier  = MD_ADMIN_ACL;
        mdRecord.dwMDAttributes  = METADATA_INHERIT | METADATA_PARTIAL_PATH | METADATA_REFERENCE;
        mdRecord.dwMDUserType    = IIS_MD_UT_SERVER;
        mdRecord.dwMDDataType    = BINARY_METADATA;
        mdRecord.dwMDDataLen     = 0;
        mdRecord.pbMDData        = NULL;
        mdRecord.dwMDDataTag     = NULL;

        hRes = pMDCom->ComMDGetMetaDataW( METADATA_MASTER_ROOT_HANDLE,
                                          pszFullPath,
                                          &mdRecord,
                                          &dwRequiredLen );

        // Whistler 53924
        if(HRESULTTOWIN32(hRes) == ERROR_INSUFFICIENT_BUFFER)
        {
            WCHAR * pLastSlash = NULL;
            while ((pLastSlash = backstrchr(pszFullPath,L'/')) != NULL)
            {
                *pLastSlash = L'\0';
                pLastSlash = NULL;

                mdRecord.dwMDDataLen     = 0;
                mdRecord.pbMDData        = NULL;
                mdRecord.dwMDDataTag     = NULL;

                hRes = pMDCom->ComMDGetMetaDataW( METADATA_MASTER_ROOT_HANDLE,
                                                  pszFullPath,
                                                  &mdRecord,
                                                  &dwRequiredLen );
                if (SUCCEEDED(hRes)) break;
            }
        }

        if ( FAILED( hRes ) || !mdRecord.dwMDDataTag )
        {
            bReturn = FALSE;
        }

        LocalFree( pszFullPath );
    }

    if ( bReturn )
    {
        *pAcl = mdRecord.pbMDData;
        *pdwRef = mdRecord.dwMDDataTag;
    }

    return bReturn;
}


BOOL
COpenHandle::CheckSubAcls(
    IMDCOM* pMDCom,
    LPCWSTR  pszRelPath,
    LPBOOL  pfIsAnyAcl
    )
/*++

Routine Description:

    Check if Acls exist in subtree

Arguments:

    pszRelPath - path to object
    pfIsAnyAcl - updated with TRUE if sub-acls exists, otherwise FALSE

Returns:

    TRUE if success, otherwise FALSE

--*/
{
    HRESULT         hRes;
    DWORD           dwRequiredLen;
    BOOL            bReturn = TRUE;
    LPWSTR          pszFullPath;

    *pfIsAnyAcl = FALSE;

    LPWSTR          pszRelPathIndex = (LPWSTR)pszRelPath;

    if (pszRelPathIndex == NULL)
    {
        pszRelPathIndex = L"";
    }

    DBG_ASSERT(m_pszPath != NULL);
    DBG_ASSERT((*m_pszPath == (WCHAR)'\0') ||
               ISPATHDELIMW(*m_pszPath));

    //
    // Strip front slash now, add it in later
    //

    if (ISPATHDELIMW(*pszRelPathIndex))
    {
        pszRelPathIndex++;
    }


    DWORD dwPathLen = (DWORD)wcslen(m_pszPath);
    DWORD dwRelPathLen = (DWORD)wcslen(pszRelPathIndex);

    DBG_ASSERT((dwPathLen == 0) ||
               (!ISPATHDELIMW(m_pszPath[dwPathLen -1])));

    //
    // Get rid of trailing slash for good
    //

    if ((dwRelPathLen > 0) && (ISPATHDELIMW(pszRelPathIndex[dwRelPathLen -1])))
    {
        dwRelPathLen--;
    }

    //
    // Include space for mid slash and termination
    //

    DWORD dwTotalSize = (dwPathLen + dwRelPathLen + 1 + ((dwRelPathLen > 0) ? 1 : 0)) * sizeof(WCHAR);

    pszFullPath = (LPWSTR)LocalAlloc(LMEM_FIXED, dwTotalSize);

    if (pszFullPath == NULL)
    {
        bReturn = FALSE;
    }
    else
    {
        memcpy(pszFullPath,
               m_pszPath,
               dwPathLen * sizeof(WCHAR));

        //
        // Don't need slash if there is no RelPath
        //

        if (dwRelPathLen > 0)
        {

            pszFullPath[dwPathLen] = (WCHAR)'/';

            memcpy(pszFullPath + dwPathLen + 1,
                   pszRelPathIndex,
                   dwRelPathLen * sizeof(WCHAR));
        }

        pszFullPath[(dwTotalSize - sizeof(WCHAR)) / sizeof(WCHAR)] = (WCHAR)'\0';

        hRes = pMDCom->ComMDGetMetaDataPathsW(METADATA_MASTER_ROOT_HANDLE,
                                             pszFullPath,
                                             MD_ADMIN_ACL,
                                             BINARY_METADATA,
                                             0,
                                             NULL,
                                             &dwRequiredLen );

        LocalFree( pszFullPath );

        if ( FAILED( hRes ) )
        {
            if ( hRes == RETURNCODETOHRESULT( ERROR_INSUFFICIENT_BUFFER ) )
            {
                bReturn = TRUE;
                *pfIsAnyAcl = TRUE;
            }
            else
            {
                bReturn = FALSE;
            }
        }
    }

    return bReturn;
}

VOID
COpenHandle::Release(PVOID pvAdmin)
{
    if (InterlockedDecrement(&m_lRefCount) == 0)
    {

        //
        //
        //

        AdminAclNotifyClose(pvAdmin, m_hAdminHandle);

        ((CADMCOMW *)pvAdmin)->DeleteNode(m_hAdminHandle);
    }
}

CAdminAclCache::CAdminAclCache()
/*++
Routine Description:
    C++ constructor. Initializes all members to 0.

Arguments:
    None

Returns:
    n/a
--*/
{
    m_fEnabled=1;
    m_cAdminAclCache=0;
    memset(m_rgpAdminAclCache, 0, sizeof(m_rgpAdminAclCache));
}

CAdminAclCache::~CAdminAclCache()
/*++
Routine Description:
    C++ destructor. Deletes everthing in the cache.

Arguments:
    None

Returns:
    n/a
--*/
{
    Flush();
}

STDMETHODIMP
CAdminAclCache::Init()
/*++
Routine Description:
    Initializes the cache. Right now there is nothing to do.

Arguments:
    None

Returns:
    S_OK on success. E_* failure.
--*/
{
    // Locals
    HRESULT             hr=S_OK;

//exit:
    // Done
    return (hr);
}

STDMETHODIMP
CAdminAclCache::IsEnabled()
/*++
Routine Description:
    Checks whether the cache is enabled.

Arguments:
    None

Returns:
    S_OK enabled, S_FALSE disabled
--*/
{
    // Locals
    HRESULT             hr=S_OK;

    // Check
    if (m_fEnabled<=0)
    {
        // Return S_FALSE
        hr=S_FALSE;
    }

//exit:
    // Done
    return (hr);
}

STDMETHODIMP
CAdminAclCache::IsEmpty()
/*++
Routine Description:
    Checks whether the cache is empty.

Arguments:
    None

Returns:
    S_OK empty, S_FALSE not empty
--*/
{
    // Locals
    HRESULT             hr=S_OK;

    // Check
    if (m_cAdminAclCache!=0)
    {
        // Return S_FALSE
        hr=S_FALSE;
    }

//exit:
    // Done
    return (hr);
}

STDMETHODIMP
CAdminAclCache::Disable()
/*++
Routine Description:
    Disables the cache.

Arguments:
    None

Returns:
    S_OK
--*/
{
    // Locals
    HRESULT             hr=S_OK;

    InterlockedDecrement(&m_fEnabled);

//exit:
    // Done
    return (hr);
}

STDMETHODIMP
CAdminAclCache::Enable()
/*++
Routine Description:
    Enables the cache.

Arguments:
    None

Returns:
    S_OK
--*/
{
    // Locals
    HRESULT             hr=S_OK;

    InterlockedIncrement(&m_fEnabled);

//exit:
    // Done
    return (hr);
}

STDMETHODIMP
CAdminAclCache::Flush()
/*++
Routine Description:
    Removes all times from the cache.

Arguments:
    None

Returns:
    S_OK
--*/
{
    // Locals
    HRESULT             hr=S_OK;
    CAdminAcl           *rgpToDelete[ARRAYSIZE(m_rgpAdminAclCache)];
    DWORD               cToDelete;
    DWORD               i;

    // Lock exlcusive
    m_Lock.WriteLock();

    // Copy to local vars
    cToDelete=m_cAdminAclCache;
    memmove(rgpToDelete,
            m_rgpAdminAclCache,
            cToDelete*sizeof(*rgpToDelete));

    // Wipe out
    InterlockedExchange((LONG*)&m_cAdminAclCache, 0);
    memset(m_rgpAdminAclCache, 0, sizeof(m_rgpAdminAclCache));

    // Unlock
    m_Lock.WriteUnlock();

    // Loop over the cached elements
    for (i=0; i<cToDelete; i++)
    {
        // Release
        rgpToDelete[i]->Release();
    }

//exit:
    return (hr);
}

STDMETHODIMP
CAdminAclCache::Remove(
    LPVOID              pvAdmin,
    METADATA_HANDLE     hAdminHandle)
/*++
Routine Description:
    Removes all items matching the object and the handle.

Arguments:
    pvAdmin         -   the admin context
    hAdminHandle    -   the metadata handle

Returns:
    S_OK
--*/
{
    // Locals
    HRESULT             hr=S_OK;
    CAdminAcl           *rgpToDelete[ARRAYSIZE(m_rgpAdminAclCache)];
    DWORD               cToDelete;
    DWORD               dwRead;
    DWORD               dwWrite;
    DWORD               i;

    // Try to lock shared
    if (m_Lock.TryReadLock())
    {
        // Loop over the cached elements
        for (i=0; i<m_cAdminAclCache; i++)
        {
            // Match?
            if ((m_rgpAdminAclCache[i]->GetAdminContext()==pvAdmin)&&
                (m_rgpAdminAclCache[i]->GetAdminHandle()==hAdminHandle))
            {
                // Found one
                break;
            }
        }

        // Not found?
        if (i==m_cAdminAclCache)
        {
            // Unlock
            m_Lock.ReadUnlock();

            // Done
            goto exit;
        }

        // Lock exlcusive
        m_Lock.ConvertSharedToExclusive();
    }
    else
    {
        // Lock exlcusive
        m_Lock.WriteLock();
    }

    // In both case we have a write lock now

    // Loop over the cached elements
    for (cToDelete=dwWrite=dwRead=0; dwRead<m_cAdminAclCache; dwRead++)
    {
        // Match?
        if ((m_rgpAdminAclCache[dwRead]->GetAdminContext()==pvAdmin)&&
            (m_rgpAdminAclCache[dwRead]->GetAdminHandle()==hAdminHandle))
        {
            // Copy to the local array
            rgpToDelete[cToDelete++]=m_rgpAdminAclCache[dwRead];
        }
        else
        {
            // If we removed some
            if (dwWrite!=dwRead)
            {
                // Move to the empty place
                m_rgpAdminAclCache[dwWrite]=m_rgpAdminAclCache[dwRead];
            }

            // Advance
            dwWrite++;
        }
    }

    DBG_ASSERT((dwWrite+cToDelete)==m_cAdminAclCache);

    // Set the new size
    InterlockedExchange((LONG*)&m_cAdminAclCache, dwWrite);

    // Unlock
    m_Lock.WriteUnlock();

    // Loop over the elements to be deleted
    for (i=0; i<cToDelete; i++)
    {
        // Release
        rgpToDelete[i]->Release();
    }

exit:
    return (hr);
}

STDMETHODIMP
CAdminAclCache::Find(
    LPVOID              pvAdmin,
    METADATA_HANDLE     hAdminHandle,
    LPCWSTR             pwszRelPath,
    CAdminAcl           **ppAdminAcl)
/*++
Routine Description:
    Finds ACL matching the object, the handle and the path.

Arguments:
    pvAdmin         -   the admin context
    hAdminHandle    -   the metadata handle
    pwszRelPath     -   the path (NULL is treated as empty string)
    ppAdminAcl      -   out the acl if found. the caller must release it.

Returns:
    S_OK found, S_FALSE not found. E_* on failure
--*/
{
    // Locals
    HRESULT             hr=S_OK;
    CAdminAcl           *pAdminAcl=NULL;
    DWORD               i;
    BOOL                fWriteLocked=FALSE;

    // Check args
    if (ppAdminAcl==NULL)
    {
        hr=E_INVALIDARG;
        goto exit;
    }
    else
    {
        // Init
        *ppAdminAcl=NULL;
    }

    // Don't search if the cache is disabled
    hr=IsEnabled();
    if (hr!=S_OK)
    {
        // Not found
        goto exit;
    }

    if (pwszRelPath==NULL)
    {
        // Set to empty
        pwszRelPath=L"";
    }

    // Try to lock shared
    if (!m_Lock.TryReadLock())
    {
        // Report potentially wrong "Not found" instead of waiting for the writes to finish.
        hr=S_FALSE;
        goto exit;
    }

    // Try to find
    hr=_Find(pvAdmin, hAdminHandle, pwszRelPath, &pAdminAcl, &i);

    // If found
    if (hr==S_OK)
    {
        DBG_ASSERT(pAdminAcl&&(i<m_cAdminAclCache));

        // Try to lock exclusive
        if (m_Lock.TryConvertSharedToExclusive())
        {
            // Move to be 1st element
            _MoveFirst(i);

            // Remember to write unlock
            fWriteLocked=TRUE;
        }
    }

    // Write locked?
    if (fWriteLocked)
    {
        // Unlock
        m_Lock.WriteUnlock();
    }
    else
    {
        // Unlock
        m_Lock.ReadUnlock();
    }

    // Return
    *ppAdminAcl=pAdminAcl;
    pAdminAcl=NULL;

exit:
    // Cleanup
    if (pAdminAcl)
    {
        pAdminAcl->Release();
    }

    // Done
    return (hr);
}

STDMETHODIMP
CAdminAclCache::Add(
    CAdminAcl           *pAdminAcl)
/*++
Routine Description:
    Adds ACL to the cache.

Arguments:
    pAdminAcl      -    the acl.

Returns:
    S_OK the element was added. S_FALSE the element was not added. E_* failure.
--*/
{
    // Locals
    HRESULT             hr=S_OK;
    DWORD               i;
    CAdminAcl           *pTemp=NULL;
    LPVOID              pvAdmin;
    METADATA_HANDLE     hAdminHandle;
    LPCWSTR             pwszRelPath;
    CAdminAcl           *pAdminAclToRelease = NULL;

    // Check args
    if (pAdminAcl==NULL)
    {
        hr=E_INVALIDARG;
        goto exit;
    }

    // Don't add anything if the cache is disabled
    hr=IsEnabled();
    if (hr!=S_OK)
    {
        // Not found
        goto exit;
    }

    // Get in locals
    pvAdmin=pAdminAcl->GetAdminContext();
    hAdminHandle=pAdminAcl->GetAdminHandle();
    pwszRelPath=pAdminAcl->GetPath()?pAdminAcl->GetPath():L"";

    // Try to lock exclusive
    if (!m_Lock.TryWriteLock())
    {
        // Couldn't add
        hr=S_FALSE;
        goto exit;
    }

    // TryWriteLock() above succeeded, so here we have a write lock

    // Try to find
    hr=_Find(pvAdmin, hAdminHandle, pwszRelPath, &pTemp, &i);

    // If found
    if (hr==S_OK)
    {
        DBG_ASSERT(i<m_cAdminAclCache);

        // Move to be 1st element
        _MoveFirst(i);
    }
    else
    {
        // Add
        hr=_InsertFirst(pAdminAcl, &pAdminAclToRelease);
    }

    // Unlock
    m_Lock.WriteUnlock();

exit:
    // Cleanup
    if (pTemp)
    {
        pTemp->Release();
    }
    if ( pAdminAclToRelease )
    {
        pAdminAclToRelease->Release();
    }

    // Done
    return (hr);
}

STDMETHODIMP
CAdminAclCache::_Find(
    LPVOID              pvAdmin,
    METADATA_HANDLE     hAdminHandle,
    LPCWSTR             pwszRelPath,
    CAdminAcl           **ppAdminAcl,
    DWORD               *pdwIndex)
/*++
Routine Description:
    Finds ACL matching the object, the handle and the path.
    The caller must acquire any lock.

Arguments:
    pvAdmin         -   the admin context
    hAdminHandle    -   the metadata handle
    pwszRelPath     -   the path (NULL is treated as empty string)
    ppAdminAcl      -   out the acl if found. the caller must release it.
    pdwIndex        -   out the index of the acl if found.

Returns:
    S_OK found, S_FALSE not found. E_* on failure
--*/
{
    // Locals
    HRESULT             hr=S_OK;
    CAdminAcl           *pAdminAcl=NULL;
    DWORD               i;
    LPCWSTR             pwszAclPath;

    // Check args
    if (ppAdminAcl==NULL)
    {
        hr=E_INVALIDARG;
    }
    else
    {
        // Init
        *ppAdminAcl=NULL;
    }
    if (pdwIndex==NULL)
    {
        hr=E_INVALIDARG;
    }
    else
    {
        // Init
        *pdwIndex=0;
    }
    // Invalid args?
    if (FAILED(hr))
    {
        // Bail
        goto exit;
    }

    if (pwszRelPath==NULL)
    {
        // Set to empty
        pwszRelPath=L"";
    }

    // Loop and search
    for (i=0; i<m_cAdminAclCache; i++)
    {
        DBG_ASSERT(m_rgpAdminAclCache[i]);

        pwszAclPath=m_rgpAdminAclCache[i]->GetPath()?
                        m_rgpAdminAclCache[i]->GetPath():L"";

        if ((m_rgpAdminAclCache[i]->GetAdminContext()==pvAdmin)&&
            (m_rgpAdminAclCache[i]->GetAdminHandle()==hAdminHandle)&&
            (_wcsicmp(pwszAclPath, pwszRelPath)==0))
        {
            pAdminAcl=m_rgpAdminAclCache[i];
            break;
        }
    }

    // Found one?
    if (pAdminAcl)
    {
        // Addref
        pAdminAcl->AddRef();
        // Return
        *ppAdminAcl=pAdminAcl;
        *pdwIndex=i;
        // Don't free
        pAdminAcl=NULL;
    }
    else
    {
        // Not found
        hr=S_FALSE;
    }

exit:
    // In all cases here pAdminAcl should be NULL:
    // 1. If we failed, because of invalid arguments it is initialized to NULL
    // 2. If we couldn't find it in the cache it still as initialized to NULL
    // 3. If we found in the cache we moved it to *ppAdminAcl and set it back to NULL
    DBG_ASSERT( pAdminAcl == NULL );

    // Done
    return (hr);
}

STDMETHODIMP
CAdminAclCache::_MoveFirst(
    DWORD               i)
/*++
Routine Description:
    Moves the i-th element to be 1st (at possition 0).
    The caller must acquire write lock.

Arguments:
    i               -   in the index of the acl to move 1st.

Returns:
    S_OK success. E_* on failure.
--*/
{
    // Locals
    HRESULT             hr=S_OK;
    CAdminAcl           *pAdminAcl=NULL;

    DBG_ASSERT(i<m_cAdminAclCache);

    // Check args
    if (i>=m_cAdminAclCache)
    {
        // Bail
        hr=E_INVALIDARG;
        goto exit;
    }

    // If already 1st
    if (i==0)
    {
        // Nothing to do
        goto exit;
    }

    // Save
    pAdminAcl=m_rgpAdminAclCache[i];
    DBG_ASSERT(pAdminAcl);

    // Move the 1st i elements 1 position right
    memmove(m_rgpAdminAclCache+1,
            m_rgpAdminAclCache,
            i*sizeof(*m_rgpAdminAclCache));

    // Move to 1st place
    m_rgpAdminAclCache[0]=pAdminAcl;

exit:
    // Done
    return (hr);
}

STDMETHODIMP
CAdminAclCache::_InsertFirst(
    CAdminAcl           *pAdminAcl,
    CAdminAcl           **ppAdminAclToRelease)
/*++
Routine Description:
    Adds ACL as the 1st element of the cache.
    The caller must acquire write lock.

Arguments:
    pAdminAcl           -   the acl.
    ppAdminAclToRelease -   since the function is called under a write lock
                            it should not call directly release on the element that
                            is to be deleted from the cache. Instead it will return
                            the element to caller to release after unlocking.

Returns:
    S_OK the element was added. E_* failure.
--*/
{
    // Locals
    HRESULT             hr=S_OK;

    if ( ppAdminAclToRelease == NULL )
    {
        hr=E_INVALIDARG;
        goto exit;
    }
    else
    {
        // Initialize to NULL
        *ppAdminAclToRelease = NULL;
    }

    // Check args
    if (pAdminAcl==NULL)
    {
        hr=E_INVALIDARG;
        goto exit;
    }

    // If the cache is full
    if (m_cAdminAclCache==ARRAYSIZE(m_rgpAdminAclCache))
    {
        // Delete one element
        InterlockedDecrement((LONG*)&m_cAdminAclCache);

        DBG_ASSERT(m_rgpAdminAclCache[m_cAdminAclCache]);

        // Return the last element to the caller to release
        *ppAdminAclToRelease = m_rgpAdminAclCache[m_cAdminAclCache];
        m_rgpAdminAclCache[m_cAdminAclCache]=NULL;
    }

    // Anything in the cache?
    if (m_cAdminAclCache)
    {
        // Move all elements 1 position right
        memmove(m_rgpAdminAclCache+1,
                m_rgpAdminAclCache,
                m_cAdminAclCache*sizeof(*m_rgpAdminAclCache));

    }

    // Put on 1st place
    m_rgpAdminAclCache[0]=pAdminAcl;
    pAdminAcl->AddRef();

    // Added 1 element
    InterlockedIncrement((LONG*)&m_cAdminAclCache);

exit:

    // Done
    return (hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\dcomadm\dll\cofact.cxx ===
#include "precomp.hxx"

#include <iadm.h>
#include "coiadm.hxx"

extern ULONG g_dwRefCount;


CADMCOMSrvFactoryW::CADMCOMSrvFactoryW()
{
    m_dwRefCount=0;
}

CADMCOMSrvFactoryW::~CADMCOMSrvFactoryW()
{
}

HRESULT
CADMCOMSrvFactoryW::CreateInstance(
    IUnknown *pUnkOuter,
    REFIID riid,
    void ** ppObject
    )
{
//    DBGPRINTF( (DBG_CONTEXT, "[CADMCOMSrvFactoryW::CreateInstance]\n"));

    HRESULT hresReturn = E_NOINTERFACE;

    if (pUnkOuter != NULL) {
        return CLASS_E_NOAGGREGATION;
    }

    if (IID_IUnknown==riid ||
        IID_IMSAdminBase_W==riid ||
        IID_IMSAdminBase2_W==riid ||
        IID_IMSAdminBase3_W==riid) {
        CADMCOMW *padmcomw = new CADMCOMW();

        if( padmcomw == NULL ) {
            hresReturn = E_OUTOFMEMORY;
        }
        else {
            hresReturn = padmcomw->GetStatus();
            if (SUCCEEDED(hresReturn)) {
                hresReturn = padmcomw->QueryInterface(riid, ppObject);
                if( FAILED(hresReturn) ) {
                    DBGPRINTF( (DBG_CONTEXT, "[CADMCOMSrvFactoryW::CreateInstance] no I/F\n"));
                }
            }
            padmcomw->Release();
        }
    }

    return hresReturn;
}

HRESULT
CADMCOMSrvFactoryW::LockServer(BOOL fLock)
{
    if (fLock) {
        InterlockedIncrement((long *)&g_dwRefCount);
    }
    else {
        InterlockedDecrement((long *)&g_dwRefCount);
    }
    return NO_ERROR;
}

HRESULT
CADMCOMSrvFactoryW::QueryInterface(
    REFIID riid,
    void **ppObject
    )
{
//    DBGPRINTF( (DBG_CONTEXT, "[CADMCOMSrvFactoryW::QueryInterface]\n"));

    if (riid==IID_IUnknown || riid == IID_IClassFactory) {
        *ppObject = (IClassFactory *) this;
    }
    else {
        return E_NOINTERFACE;
    }

    AddRef();
    return NO_ERROR;
}

ULONG
CADMCOMSrvFactoryW::AddRef(
    )
{
    DWORD dwRefCount;
    dwRefCount = InterlockedIncrement((long *)&m_dwRefCount);
    InterlockedIncrement((long *)&g_dwRefCount);
    return dwRefCount;
}

ULONG
CADMCOMSrvFactoryW::Release()
{
    DWORD dwRefCount;
    dwRefCount = InterlockedDecrement((long *)&m_dwRefCount);
    InterlockedDecrement((long *)&g_dwRefCount);
    if (dwRefCount == 0) {
        delete this;
    }
    return dwRefCount;
}

STDAPI
SetABOLaunchPermissions(
    HKEY                hKey )
{
    HRESULT             hr = S_OK;
    DWORD               dwError;
    BOOL                fRet;
    SECURITY_DESCRIPTOR SecurityDesc = {0};
    SECURITY_DESCRIPTOR *pSelfRelative = NULL;
    DWORD               cbSelfRelative = 0;
    EXPLICIT_ACCESS     ea = {0};
    ACL                 *pAcl = NULL;
    SID                 *pSidAdmins = NULL;
    DWORD               cbSidAdmins = SECURITY_MAX_SID_SIZE;

    // Initialize the security descriptor
    fRet = InitializeSecurityDescriptor( &SecurityDesc, SECURITY_DESCRIPTOR_REVISION );
    if ( !fRet )
    {
        dwError = GetLastError();
        hr = HRESULT_FROM_WIN32( dwError );
        goto exit;
    }

    // Allocate memory for the SID
    pSidAdmins = (SID*)LocalAlloc( LPTR, cbSidAdmins );
    if ( pSidAdmins == NULL )
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    // Create SID for Administrators
    fRet = CreateWellKnownSid( WinBuiltinAdministratorsSid, NULL, pSidAdmins, &cbSidAdmins );
    if ( !fRet )
    {
        dwError = GetLastError();
        hr = HRESULT_FROM_WIN32( dwError );
        goto exit;
    }

    DBG_ASSERT( pSidAdmins != NULL );

    // Setup AuthenticatedUsers for COM access.
    ea.grfAccessPermissions = COM_RIGHTS_EXECUTE;
    ea.grfAccessMode = SET_ACCESS;
    ea.grfInheritance = NO_INHERITANCE;
    ea.Trustee.pMultipleTrustee = NULL;
    ea.Trustee.MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
    ea.Trustee.TrusteeForm = TRUSTEE_IS_SID;
    ea.Trustee.TrusteeType = TRUSTEE_IS_GROUP;
    ea.Trustee.ptstrName = (LPSTR)pSidAdmins;

    // Create new ACL with this ACE.
    dwError = SetEntriesInAcl( 1, &ea, NULL, &pAcl );
    if ( dwError != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( dwError );
        goto exit;
    }
    DBG_ASSERT( pAcl != NULL );

    // Set the security descriptor owner to Administrators
    fRet = SetSecurityDescriptorOwner( &SecurityDesc, pSidAdmins, FALSE);
    if ( !fRet )
    {
        dwError = GetLastError();
        hr = HRESULT_FROM_WIN32( dwError );
        goto exit;
    }

    // Set the security descriptor group to Administrators
    fRet = SetSecurityDescriptorGroup( &SecurityDesc, pSidAdmins, FALSE);
    if ( !fRet )
    {
        dwError = GetLastError();
        hr = HRESULT_FROM_WIN32( dwError );
        goto exit;
    }

    // Set the ACL to the security descriptor.
    fRet = SetSecurityDescriptorDacl( &SecurityDesc, TRUE, pAcl, FALSE );
    if ( !fRet )
    {
        dwError = GetLastError();
        hr = HRESULT_FROM_WIN32( dwError );
        goto exit;
    }

    // Get the size of the self relative copy
    fRet = MakeSelfRelativeSD( &SecurityDesc, NULL, &cbSelfRelative );
    DBG_ASSERT( !fRet );

    // Allocate memory for the self relative security descriptor
    pSelfRelative = (SECURITY_DESCRIPTOR*)LocalAlloc( LPTR, cbSelfRelative );
    if ( pSelfRelative == NULL )
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    // Create a self relative copy, which we can store in the registry
    fRet = MakeSelfRelativeSD( &SecurityDesc, pSelfRelative, &cbSelfRelative );
    if ( !fRet )
    {
        dwError = GetLastError();
        hr = HRESULT_FROM_WIN32( dwError );
        goto exit;
    }

    // Write the security descriptor
    dwError = RegSetValueEx( hKey,
                             "LaunchPermission",
                             0,
                             REG_BINARY,
                             (BYTE*)pSelfRelative,
                             cbSelfRelative );
    if ( dwError != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( dwError );
        goto exit;
    }


exit:
    if ( pSelfRelative != NULL )
    {
        LocalFree( pSelfRelative );
        pSelfRelative = NULL;
    }
    if ( pSidAdmins != NULL )
    {
        LocalFree( pSidAdmins );
        pSidAdmins = NULL;
    }
    if ( pAcl != NULL )
    {
        LocalFree( pAcl );
        pAcl = NULL;
    }

    return (hr);
}


STDAPI
DllRegisterServer()
{
    DWORD               dwError;
    HKEY                hKeyCLSID;
    HKEY                hKeyIF;
    HKEY                hKeyAppExe;
    HKEY                hKeyAppID;
    DWORD               dwDisposition;

    //
    // register AppExe
    //

    //
    // register inetinfo AppID
    //
    dwError = RegCreateKeyExA( HKEY_CLASSES_ROOT,
                               "AppID\\inetinfo.exe",
                               0,
                               "",
                               REG_OPTION_NON_VOLATILE,
                               KEY_ALL_ACCESS,
                               NULL,
                               &hKeyAppExe,
                               &dwDisposition );
    if ( dwError != ERROR_SUCCESS )
    {
        return E_UNEXPECTED;
    }

    dwError = RegSetValueExA( hKeyAppExe,
                              "AppID",
                              0,
                              REG_SZ,
                              (BYTE*)"{A9E69610-B80D-11D0-B9B9-00A0C922E750}",
                              sizeof("{A9E69610-B80D-11D0-B9B9-00A0C922E750}") );
    if ( dwError != ERROR_SUCCESS )
    {
        RegCloseKey(hKeyAppExe);
        return E_UNEXPECTED;
    }

    RegCloseKey(hKeyAppExe);

    //
    // register AppID
    //
    dwError = RegCreateKeyExA( HKEY_CLASSES_ROOT,
                               "AppID\\{A9E69610-B80D-11D0-B9B9-00A0C922E750}",
                               0,
                               "",
                               REG_OPTION_NON_VOLATILE,
                               KEY_ALL_ACCESS,
                               NULL,
                               &hKeyAppID,
                               &dwDisposition );
    if ( dwError != ERROR_SUCCESS )
    {
        return E_UNEXPECTED;
    }

    if ( FAILED( SetABOLaunchPermissions( hKeyAppID ) ) )
    {
        RegCloseKey(hKeyAppID);
        return E_UNEXPECTED;
    }

    dwError = RegSetValueExA( hKeyAppID,
                              "",
                              0,
                              REG_SZ,
                              (BYTE*)"IIS Admin Service",
                              sizeof("IIS Admin Service") );
    if ( dwError != ERROR_SUCCESS )
    {
        RegCloseKey(hKeyAppID);
        return E_UNEXPECTED;
    }

    dwError = RegSetValueExA( hKeyAppID,
                              "LocalService",
                              0,
                              REG_SZ,
                              (BYTE*)"IISADMIN",
                              sizeof("IISADMIN") );
    if ( dwError != ERROR_SUCCESS )
    {
        RegCloseKey(hKeyAppID);
        return E_UNEXPECTED;
    }

    RegCloseKey(hKeyAppID);

    //
    // register CLSID
    //

    dwError = RegCreateKeyExA( HKEY_CLASSES_ROOT,
                               "CLSID\\{A9E69610-B80D-11D0-B9B9-00A0C922E750}",
                               0,
                               "",
                               REG_OPTION_NON_VOLATILE,
                               KEY_ALL_ACCESS,
                               NULL,
                               &hKeyCLSID,
                               &dwDisposition );
    if ( dwError != ERROR_SUCCESS )
    {
        return E_UNEXPECTED;
    }

    dwError = RegSetValueExA( hKeyCLSID,
                              "",
                              0,
                              REG_SZ,
                              (BYTE*)"IIS Admin Service",
                              sizeof("IIS Admin Servce") );
    if ( dwError != ERROR_SUCCESS )
    {
        RegCloseKey(hKeyCLSID);
        return E_UNEXPECTED;
    }

    dwError = RegSetValueExA( hKeyCLSID,
                              "AppID",
                              0,
                              REG_SZ,
                              (BYTE*)"{A9E69610-B80D-11D0-B9B9-00A0C922E750}",
                              sizeof("{A9E69610-B80D-11D0-B9B9-00A0C922E750}") );
    if ( dwError != ERROR_SUCCESS )
    {
        RegCloseKey(hKeyCLSID);
        return E_UNEXPECTED;
    }

    dwError = RegSetValueExA( hKeyCLSID,
                              "LocalService",
                              0,
                              REG_SZ,
                              (BYTE*)"IISADMIN",
                              sizeof("IISADMIN") );
    if ( dwError !=ERROR_SUCCESS )
    {
        RegCloseKey(hKeyCLSID);
        return E_UNEXPECTED;
    }

    RegCloseKey(hKeyCLSID);

    //
    // IISADMIN registry entries
    //
    dwError = RegCreateKeyExA( HKEY_LOCAL_MACHINE,
                               IISADMIN_EXTENSIONS_REG_KEY,
                               0,
                               "",
                               REG_OPTION_NON_VOLATILE,
                               KEY_ALL_ACCESS,
                               NULL,
                               &hKeyIF,
                               &dwDisposition );
    if ( dwError != ERROR_SUCCESS )
    {
        return E_UNEXPECTED;
    }

    RegCloseKey(hKeyIF);

    return S_OK;
}

STDAPI
DllUnregisterServer()
{
    HRESULT             hr = S_OK;

    //
    // Delete Crypto Keys
    //
    hr = IISCryptoInitialize();
    if (SUCCEEDED(hr))
    {
        IISCryptoDeleteContainerByName( DCOM_SERVER_CONTAINER,
                                        0 );

        IISCryptoDeleteContainerByName( DCOM_SERVER_CONTAINER,
                                        CRYPT_MACHINE_KEYSET );

        IISCryptoDeleteContainerByName( DCOM_CLIENT_CONTAINER,
                                        0 );

        IISCryptoDeleteContainerByName( DCOM_CLIENT_CONTAINER,
                                        CRYPT_MACHINE_KEYSET );

        IISCryptoTerminate();
    }

    //
    // register AppID
    //

    RegDeleteKeyA( HKEY_CLASSES_ROOT,
                   "AppID\\inetinfo.exe" );

    RegDeleteKeyA( HKEY_CLASSES_ROOT,
                   "AppID\\{88E4BA60-537B-11D0-9B8E-00A0C922E703}" );

    RegDeleteKeyA( HKEY_CLASSES_ROOT,
                   "AppID\\{A9E69610-B80D-11D0-B9B9-00A0C922E750}" );

    //
    // register CLSID
    //

    RegDeleteKeyA( HKEY_CLASSES_ROOT,
                   "CLSID\\{88E4BA60-537B-11D0-9B8E-00A0C922E703}" );

    RegDeleteKeyA( HKEY_CLASSES_ROOT,
                   "CLSID\\{A9E69610-B80D-11D0-B9B9-00A0C922E750}" );

    //
    // IISADMIN registry entries
    //

    RegDeleteKeyA( HKEY_LOCAL_MACHINE,
                   IISADMIN_EXTENSIONS_REG_KEY );

    return S_OK;
}

STDAPI
DllCanUnloadNow()
{
    return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\dcomadm\dll\comobj.cxx ===
/*++

   Copyright    (c)    1996    Microsoft Corporation

   Module  Name :

       comobj.cxx

   Abstract:

       This module defines DCOM Admin APIs.

   Author:

       Sophia Chung (sophiac)   23-Nov-1996

--*/
#include "precomp.hxx"

#include <iadm.h>
#include "coiadm.hxx"
#include "admacl.hxx"

//
// Globals
//

DECLARE_DEBUG_PRINTS_OBJECT();

ULONG g_dwRefCount = 0;


COpenHandle     g_ohMasterRootHandle;

HANDLE_TABLE    g_MasterRoot =  {
                                    NULL,
                                    0,
                                    METADATA_MASTER_ROOT_HANDLE,
                                    &g_ohMasterRootHandle
                                };

DWORD           CADMCOMW::sm_dwProcessIdThis = 0;
DWORD           CADMCOMW::sm_dwProcessIdRpcSs = 0;

//
// Private prototypes
//

//
// Used by RestoreHelper
//
#define RESTORE_HISTORY    0x1
#define RESTORE_BACKUP     0x2

BOOL
MakeParentPath(
    LPWSTR  pszPath
    );

//------------------------------


CADMCOMW::CADMCOMW():
    m_ImpIConnectionPointContainer(),
    m_ImpExpHelp(),
    m_pMdObject(NULL),
    m_pMdObject3(NULL),
    m_dwRefCount(1),
    m_dwHandleValue(1),
    m_pEventSink(NULL),
    m_pConnPoint(NULL),
    m_piuFTM(NULL),
    m_bTerminated(FALSE),
    m_bIsTerminateRoutineComplete(FALSE),
    m_dwProcessIdCaller(0),
    m_hProcessCaller(NULL),
    m_hWaitCaller(NULL),
    m_dwThreadIdDisconnect(0)
{
    HRESULT             hRes;

    memset((PVOID)m_hashtab, 0, sizeof(m_hashtab) );

    InitializeListHead( &m_ObjectListEntry );

    hRes = CoCreateInstance(CLSID_MDCOM, NULL, CLSCTX_INPROC_SERVER, IID_IMDCOM2, (void**) &m_pMdObject);

    if (FAILED(hRes))
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "[CADMCOMW::CADMCOMW] CoCreateInstance(MDCOM) failed, error %lx\n",
                    hRes ));
    }
    else
    {
        hRes = m_pMdObject->ComMDInitialize();

        if (FAILED(hRes))
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "[CADMCOMW::CADMCOMW] ComMDInitialize(MDCOM) failed, error %lx\n",
                        hRes ));

            m_pMdObject->Release();
            m_pMdObject = NULL;
        }
    }

    if (SUCCEEDED(hRes))
    {
        // pickup IMDCOM3 if available
        // ignore the return value by design
        // IIS5.1 metadata.dll will fail this call.  IIS6.0+ metadata will succeed this call
        HRESULT hrTemp = m_pMdObject->QueryInterface(IID_IMDCOM3, (void**)&m_pMdObject3);
        DBG_ASSERT(SUCCEEDED(hrTemp) || NULL == m_pMdObject3);
        if ( FAILED( hrTemp ) )
        {
            m_pMdObject3 = NULL;
        }

        m_pEventSink = new CImpIMDCOMSINKW((IMSAdminBaseW*)this);
        if( m_pEventSink == NULL )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "[CADMCOMW::CADMCOMW] CImpIMDCOMSINKW failed, error %lx\n",
                        ERROR_NOT_ENOUGH_MEMORY ));
            hRes = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        }
        else
        {
            m_pEventSink->AddRef();

            // ImpExpHelp
            m_ImpExpHelp.Init(this);

            m_ImpIConnectionPointContainer.Init(this);
            // Rig this COPaper COM object to be connectable. Assign the connection
            // point array. This object's connection points are determined at
            // compile time--it currently has only one connection point:
            // the CONNPOINT_PAPERSINK connection point. Create a connection
            // point object for this and assign it into the array. This array could
            // easily grow to support additional connection points in the future.

            // First try initializing the connection point object. Pass 'this' as the
            // pHostObj pointer used by the connection point to pass its AddRef and
            // Release calls back to the host connectable object.
            // The initialization will create
            // its initial dynamic connection array.

            hRes = m_ConnectionPoint.Init(this, IID_IMSAdminBaseSink_W);

            if (SUCCEEDED(hRes))
            {
                //
                // Admin's sink
                //

                IConnectionPointContainer* pConnPointContainer = NULL;

                // First query the object for its Connection Point Container. This
                // essentially asks the object in the server if it is connectable.
                hRes = m_pMdObject->QueryInterface( IID_IConnectionPointContainer,
                       (PVOID *)&pConnPointContainer);

                if SUCCEEDED(hRes)
                {
                    // Find the requested Connection Point. This AddRef's the
                    // returned pointer.
                    hRes = pConnPointContainer->FindConnectionPoint(IID_IMDCOMSINK_W, &m_pConnPoint);
                    if (SUCCEEDED(hRes))
                    {
                        hRes = m_pConnPoint->Advise((IUnknown *)m_pEventSink, &m_dwCookie);
                    }
                    pConnPointContainer->Release();
                    pConnPointContainer = NULL;

                    if (SUCCEEDED(hRes))
                    {
                        hRes = CoCreateFreeThreadedMarshaler((IUnknown *)this, &m_piuFTM);
                    }
                }
            }
            else
            {
                m_ConnectionPoint.Terminate();
            }

        }
    }
    if ( SUCCEEDED( hRes ) )
    {
        // Initialize watching the caller process
        hRes = InitializeCallerWatch();
        if ( FAILED( hRes ) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "InitializeCallerWatch() failed in CADMCOMW::~CADMCOMW hr=0x%08x.\n",
                        hRes ));
        }
    }

    SetStatus(hRes);

    //
    // Insert our object into the global list only if it is valid.
    //

    if( SUCCEEDED(hRes) )
    {
        AddObjectToList();
    }
    else
    {
        StopNotifications( TRUE );
    }
}

CADMCOMW::~CADMCOMW()
{
    Terminate();
}

HRESULT
CADMCOMW::StopNotifications(
    BOOL                fRemoveAllPending)
{
    HRESULT             hr = S_OK;

    if ( m_pEventSink != NULL )
    {
        m_pEventSink->DetachAdminObject();
    }

    if ( ( m_dwCookie != 0 ) && ( m_pConnPoint != NULL ) )
    {
        m_pConnPoint->Unadvise(m_dwCookie);
        m_dwCookie = 0;
    }

    m_ConnectionPoint.Disable();

    if ( fRemoveAllPending )
    {
        RemoveAllPendingNotifications( TRUE );
    }

    return hr;
}

HRESULT
CADMCOMW::RemoveAllPendingNotifications(
    BOOL                fWaitForCurrent)
{
    HRESULT             hr = S_OK;

    NOTIFY_CONTEXT::RemoveWorkFor( this, fWaitForCurrent );

    return hr;
}

VOID
CADMCOMW::Terminate()
{
    HANDLE_TABLE        *node;
    HANDLE_TABLE        *nextnode;
    DWORD               i;
    BOOL                bTerminated;

    //
    // Terminate must only be called from two locations. And they
    // should synchronize correctly.
    //
    // 1. From ~CADMCOMW. Obviously this should only be called once.
    //
    // 2. From ForceTerminate. That routine should only be called in
    // shutdown. With a reference held on this object. So the final
    // release should call the dtor and this routine should noop.
    //
    bTerminated = (BOOL)InterlockedCompareExchange( (LONG*)&m_bTerminated, TRUE, FALSE );

    if( !bTerminated )
    {
        ShutdownCallerWatch();

        //
        // Tell ADMWPROX.DLL to release this object's associated security
        // context.
        //

        ReleaseObjectSecurityContextW( ( IUnknown* )this );

        //
        // Do final release of the connection point objects.
        // If this isn't the final release, then the client has an outstanding
        // unbalanced reference to a connection point and a memory leak may
        // likely result because the host COPaper object is now going away yet
        // a connection point for this host object will not end up deleting
        // itself (and its connections array).
        //

        m_ConnectionPoint.Terminate();

        if (SUCCEEDED(GetStatus()))
        {
            m_LockHandleResource.WriteLock();

            //
            // Close all opened handles
            //
            for( i = 0; i < HASHSIZE; i++ )
            {
                for( node = nextnode = m_hashtab[i]; node != NULL; node = nextnode )
                {
                    if ( node->hAdminHandle != INVALID_ADMINHANDLE_VALUE )
                    {

                        AdminAclNotifyClose( (LPVOID)this, node->hAdminHandle );

                        //
                        // call metadata com api
                        //

                        m_pMdObject->ComMDCloseMetaObject( node->hActualHandle );
                    }

                    nextnode = node->next;
                    delete node->pohHandle;
                    LocalFree(node);
                }
                m_hashtab[i] = NULL;
            }

            //
            // Issue TaylorW 3/20/2001
            // QFE tree contains this call:
            //
            // AdminAclNotifyClose( (LPVOID)this, METADATA_MASTER_ROOT_HANDLE );
            //
            // I have no idea when this may have entered their tree or been lost
            // from ours. I don't see any record in source depot of it being
            // removed or added. Need to investigate why it would be needed.
            //

            m_LockHandleResource.WriteUnlock();
        }

        if ( m_pEventSink != NULL )
        {
            m_pEventSink->Release();
            m_pEventSink = NULL;
        }

        if ( m_pConnPoint != NULL )
        {
            m_pConnPoint->Release();
            m_pConnPoint = NULL;
        }

        if ( m_pMdObject != NULL )
        {
            m_pMdObject->ComMDTerminate(TRUE);
            m_pMdObject->Release();
            m_pMdObject = NULL;
            if ( m_pMdObject3 != NULL )
            {
                m_pMdObject3->Release();
                m_pMdObject3 = NULL;
            }
        }

        if ( m_piuFTM != NULL )
        {
            m_piuFTM->Release();
            m_piuFTM = NULL;
        }

        m_bIsTerminateRoutineComplete = TRUE;
    }

    while ( m_bIsTerminateRoutineComplete != TRUE )
    {
        Sleep( 100 );
    }

}

VOID
CADMCOMW::ForceTerminate()
{
    const INT           MAX_WAIT_TRIES = 5;
    INT                 WaitTries;

    DBG_ASSERT( !m_bIsTerminateRoutineComplete );
    DBG_ASSERT( !m_bTerminated );

    //
    // Wait on the reference count of this object. But bound
    // the wait so a leaked in process object does not prevent
    // us from shutting down the service.
    //
    // Wait on a ref count of 1, because the caller better be
    // holding our last reference. This assumes all external
    // references are killed through CoDisconnect() and all
    // internal references are released because of dependent
    // services shutting down.
    //
    // Issue TaylorW 3/20/2001
    //
    // In iis 5.1 the web service will shutdown filters after
    // it has already reported that it is done shutting down.
    // This is bad, but changing the shutdown logic of the
    // web service is not worth doing at this time. Hopefully
    // the shutdown timeout will be sufficient to allow this
    // operation to complete.
    //
    // Windows Bugs 318006
    //

    // CoDisconnect the object and the connection point
    DisconnectOrphaned();

    for( WaitTries = 0;
         m_dwRefCount > 1 && WaitTries < MAX_WAIT_TRIES;
         WaitTries++ )
    {
        SleepEx( WaitTries*200, TRUE );
    }

    //
    // If we timed out. Something is wrong. Most likely someone in
    // process has leaked this object. These asserts are actually
    // overactive unless ref tracing is enabled on this object.
    //

    //
    // Issue TaylorW 4/9/2001
    //
    // It looks like front page leaks a base object from in process.
    // So these assertions need to be turned off.
    //
    #define DEBUG_BASE_OBJ_LEAK  0x80000000L

    IF_DEBUG( BASE_OBJ_LEAK )
    {

        DBG_ASSERT( m_dwRefCount == 1 );
        DBG_ASSERT( WaitTries < MAX_WAIT_TRIES );
    }

    //
    // Go ahead and try to clean up.
    //
    Terminate();
}

HRESULT
CADMCOMW::QueryInterface(
    REFIID              riid,
    void                **ppObject)
{
    HRESULT             hr;

    // If caller watch is not initialized
    if ( !IsCallerWatchInitialized() )
    {
        // Initialize the caller watch
        hr = InitializeCallerWatch();
        if ( FAILED( hr ) )
        {
            return hr;
        }
    }

    if (riid==IID_IUnknown || riid==IID_IMSAdminBase_W)
    {
        *ppObject = (IMSAdminBase *) this;
        AddRef();
    }
    else if (IID_IMSAdminBase2_W == riid)
    {
        *ppObject = (IMSAdminBase2 *) this;
        AddRef();
    }
    else if (IID_IMSAdminBase3_W == riid &&
             NULL != m_pMdObject3)
    {
        *ppObject = (IMSAdminBase3 *) this;
        AddRef();
    }
    else if (IID_IMSImpExpHelp_W == riid)
    {
        *ppObject = &m_ImpExpHelp;
        AddRef();
    }
    else if (IID_IConnectionPointContainer == riid)
    {

        METADATA_HANDLE hActualHandle;

        hr = LookupAndAccessCheck( METADATA_MASTER_ROOT_HANDLE,
                                   &hActualHandle,
                                   NULL,
                                   0,
                                   METADATA_PERMISSION_READ);

        if (FAILED(hr))
        {
            return hr;
        }

        *ppObject = &m_ImpIConnectionPointContainer;
        AddRef();
    }
    else if (IID_IMarshal == riid)
    {
        return m_piuFTM->QueryInterface(riid, ppObject);
    }
    else
    {
        return E_NOINTERFACE;
    }

    return S_OK;
}

ULONG
CADMCOMW::AddRef( )
{
    DWORD               dwRefCount;

    dwRefCount = InterlockedIncrement((long *)&m_dwRefCount);

    if( sm_pDbgRefTraceLog )
    {
        WriteRefTraceLog( sm_pDbgRefTraceLog, dwRefCount, this );
    }

    return dwRefCount;
}

ULONG
CADMCOMW::Release( )
{
    DWORD               dwRefCount;

    dwRefCount = InterlockedDecrement((long *)&m_dwRefCount);

    if( sm_pDbgRefTraceLog )
    {
        WriteRefTraceLog( sm_pDbgRefTraceLog, -(LONG)dwRefCount, this );
    }

    if( dwRefCount == 1 )
    {
        //
        // We keep a list of objects around so that we can clean up and
        // shutdown successfully. The list holds a reference to this object
        // when we hit a reference of 1, we know it is time to remove
        // ourselves from the list. If we are in shutdown we may already
        // have been removed from the list. But normally, this call to
        // RemoveObjectFromList removes our last reference and thus sends
        // us back through Release and ultimately to our destructor.
        //

        RemoveObjectFromList();
    }
    else if( dwRefCount == 0 )
    {
        delete this;
    }

    return dwRefCount;
}

HRESULT
CADMCOMW::AddKey(
    IN METADATA_HANDLE  hMDHandle,
    IN LPCWSTR          pszMDPath)
/*++

Routine Description:

    Add meta object and adds it to the list of child objects for the object
    specified by Path.

Arguments:

    hMDHandle - open handle

    pszMDPath - path of the object to be added

Return Value:

    Status.

--*/
{
    HRESULT             hresReturn = S_OK;

    hresReturn = AddKeyHelper(hMDHandle, pszMDPath);

    return hresReturn;
}

HRESULT
CADMCOMW::DeleteKey(
    IN METADATA_HANDLE  hMDHandle,
    IN LPCWSTR          pszMDPath)
/*++

Routine Description:

    Deletes a meta object and all of its data.

Arguments:

    hMDHandle - open handle

    pszMDPath - path of object to be deleted, relative to the path of Handle.
           Must not be NULL.

Return Value:

    Status.

--*/
{
    HRESULT             hresReturn = S_OK;
    METADATA_HANDLE     hActualHandle;

    if (pszMDPath == NULL)
    {
        hresReturn = E_INVALIDARG;
    }
    else
    {

        //
        // lookup and access check
        //

        hresReturn = LookupAndAccessCheck(hMDHandle,
                                          &hActualHandle,
                                          pszMDPath,
                                          AAC_DELETEKEY,
                                          METADATA_PERMISSION_WRITE);
        if (SUCCEEDED(hresReturn))
        {

            //
            // call metadata com api
            //

            hresReturn = m_pMdObject->ComMDDeleteMetaObjectW( hActualHandle,
                                                              pszMDPath );

        }
    }

    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CADMCOMW::DeleteChildKeys(
    METADATA_HANDLE     hMDHandle,
    LPCWSTR             pszMDPath)
/*++

Routine Description:

    Deletes all child meta objects of the specified object, with all of their
    data.

Arguments:

    hMDHandle - open handle

    pszMDPath - path of the parent of the objects to be deleted, relative to
                the path of Handle.

Return Value:

    Status.

--*/
{
    HRESULT             hresReturn = S_OK;
    METADATA_HANDLE     hActualHandle;

    //
    // lookup and access check
    //

    hresReturn = LookupAndAccessCheck(hMDHandle,
                                      &hActualHandle,
                                      pszMDPath,
                                      AAC_DELETEKEY,
                                      METADATA_PERMISSION_WRITE);
    if (SUCCEEDED(hresReturn))
    {

        //
        // call metadata com api
        //

        hresReturn = m_pMdObject->ComMDDeleteChildMetaObjectsW( hActualHandle,
                                                          pszMDPath );

    }

    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CADMCOMW::EnumKeys(
    METADATA_HANDLE     hMDHandle,
    LPCWSTR             pszMDPath,
    LPWSTR              pszMDName,
    DWORD               dwMDEnumObjectIndex)
/*++

Routine Description:

    Enumerate objects in path.

Arguments:

    hMDHandle - open handle

    pszMDPath - path of parent object, relative to the path of Handle
                eg. "Root Object/Child/GrandChild"
    pszMDName - buffer where the Name of the object is returned

    dwEnumObjectIndex - index of the value to be retrieved

Return Value:

    Status.

--*/
{
    HRESULT             hresReturn = S_OK;
    METADATA_HANDLE     hActualHandle;

    if (pszMDName == NULL)
    {
        hresReturn = E_INVALIDARG;
    }
    else
    {

        //
        // lookup and access check
        //

        hresReturn = LookupAndAccessCheck(hMDHandle,
                                          &hActualHandle,
                                          pszMDPath,
                                          AAC_ENUM_KEYS,
                                          METADATA_PERMISSION_READ);
        if (SUCCEEDED(hresReturn))
        {

            //
            // call metadata com api
            //

            hresReturn = m_pMdObject->ComMDEnumMetaObjectsW( hActualHandle,
                                                             pszMDPath,
                                                             pszMDName,
                                                             dwMDEnumObjectIndex );
        }
    }

    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CADMCOMW::CopyKey(
    METADATA_HANDLE     hMDSourceHandle,
    LPCWSTR             pszMDSourcePath,
    METADATA_HANDLE     hMDDestHandle,
    LPCWSTR             pszMDDestPath,
    BOOL                bMDOverwriteFlag,
    BOOL                bMDCopyFlag)
/*++

Routine Description:

    Copy or move source meta object and its data and descendants to Dest.

Arguments:

    hMDSourceHandle - open handle

    pszMDSourcePath - path of the object to be copied

    hMDDestHandle - handle of the new location for the object

    pszMDDestPath - path of the new location for the object, relative
                          to the path of hMDDestHandle

    bMDOverwriteFlag - determine the behavior if a meta object with the same
                       name as source is already a child of pszMDDestPath.

    bMDCopyFlag - determine whether Source is deleted from its original location

Return Value:

    Status

--*/
{
    HRESULT             hresReturn = S_OK;
    METADATA_HANDLE     hSActualHandle;
    METADATA_HANDLE     hDActualHandle;

    //
    // lookup and access check source
    //

    if (bMDCopyFlag)
    {
        hresReturn = LookupAndAccessCheck(hMDSourceHandle,
                                          &hSActualHandle,
                                          pszMDSourcePath,
                                          0,
                                          METADATA_PERMISSION_READ);
    }
    else
    {
        //
        // Deleting source path, so need delete permission
        //

        hresReturn = LookupAndAccessCheck(hMDSourceHandle,
                                          &hSActualHandle,
                                          pszMDSourcePath,
                                          AAC_DELETEKEY,
                                          METADATA_PERMISSION_WRITE);
    }
    if (SUCCEEDED(hresReturn))
    {
        //
        // lookup and access check dest
        //

        hresReturn = LookupAndAccessCheck(hMDDestHandle,
                                          &hDActualHandle,
                                          pszMDDestPath,
                                          AAC_COPYKEY,
                                          METADATA_PERMISSION_WRITE);
        if (SUCCEEDED(hresReturn))
        {

            //
            // call metadata com api
            //

            hresReturn = m_pMdObject->ComMDCopyMetaObjectW( hSActualHandle,
                                                            pszMDSourcePath,
                                                            hDActualHandle,
                                                            pszMDDestPath,
                                                            bMDOverwriteFlag,
                                                            bMDCopyFlag );

        }
    }

    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CADMCOMW::RenameKey(
    METADATA_HANDLE     hMDHandle,
    LPCWSTR             pszMDPath,
    LPCWSTR             pszMDNewName)
{
    HRESULT             hr = S_OK;
    BOOL                fRet;
    DWORD               dwError;
    METADATA_HANDLE     hActualHandle;
    COpenHandle         *pohParent = NULL;
    DWORD               cchMDPath;
    DWORD               i;
    STRAU               strNewPath;

    // Check args
    if ( ( hMDHandle == METADATA_MASTER_ROOT_HANDLE ) ||
         ( pszMDPath == NULL ) ||
         ( pszMDNewName == NULL ) ||
         ( *pszMDNewName == L'\0' ) ||
         ( wcschr( pszMDNewName, MD_PATH_DELIMETERW ) != NULL ) ||
         ( wcschr( pszMDNewName, MD_ALT_PATH_DELIMETERW ) != NULL ) )
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Get the len of the source path
    cchMDPath = (DWORD)wcslen( pszMDPath );

    // Check
    if ( ( cchMDPath == 0 ) || ( cchMDPath >= METADATA_MAX_NAME_LEN ) )
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Map Admin Handle to Actual Handle
    dwError = Lookup( hMDHandle,
                      &hActualHandle,
                      &pohParent );
    if ( dwError != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( dwError );
        goto exit;
    }

    // Check access
    fRet = AdminAclAccessCheck( m_pMdObject,
                                this,
                                hMDHandle,
                                pszMDPath,
                                MD_ADMIN_ACL,
                                METADATA_PERMISSION_WRITE,
                                pohParent );
    if ( !fRet )
    {
        dwError = GetLastError();
        hr = HRESULT_FROM_WIN32( dwError );
        goto exit;
    }

    // Now we need to do the harder part: check whether the caller
    // has access to the new path. To do so we need to construct the
    // target path by replacing the last name in the source path with the new name.

    // If the source path ends with delimiter
    if ( ( pszMDPath[cchMDPath-1] == MD_PATH_DELIMETERW ) ||
         ( pszMDPath[cchMDPath-1] == MD_ALT_PATH_DELIMETERW ) )
    {
        // Ignore it
        cchMDPath--;

        // The resulting path should not be empty or ending with delimiter
        if ( ( cchMDPath == 0 ) ||
             ( pszMDPath[cchMDPath-1] == MD_PATH_DELIMETERW ) ||
             ( pszMDPath[cchMDPath-1] == MD_ALT_PATH_DELIMETERW ) )
        {
            hr = E_INVALIDARG;
            goto exit;
        }
    }

    // Find the last delimiter
    for ( i = cchMDPath; i != 0; i-- )
    {
        // Delimiter?
        if ( ( pszMDPath[i-1] == MD_PATH_DELIMETERW ) ||
             ( pszMDPath[i-1] == MD_ALT_PATH_DELIMETERW ) )
        {
            // The part we are interested in is upto excluding the delimiter
            // It is valid for cchMDPath to become 0.
            cchMDPath = i-1;
            break;
        }
    }

    // If there was no delimiter
    if ( i == 0 )
    {
        // This source was just a name, so bellow we shouldn't copy anything
        cchMDPath = 0;
    }

    // Copy the source path w/o the last name
    fRet = strNewPath.Copy( (const LPWSTR)pszMDPath,  cchMDPath );
    if ( !fRet )
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    fRet = strNewPath.Append( L"/",  1 );
    if ( !fRet )
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    // Append the new name
    fRet = strNewPath.Append( (const LPWSTR)pszMDNewName );
    if ( !fRet )
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    // Check access on the target path
    fRet = AdminAclAccessCheck( m_pMdObject,
                                this,
                                hMDHandle,
                                strNewPath.QueryStrW(),
                                MD_ADMIN_ACL,
                                METADATA_PERMISSION_WRITE,
                                pohParent );
    if ( !fRet )
    {
        dwError = GetLastError();
        hr = HRESULT_FROM_WIN32( dwError );
        goto exit;
    }

    // call metadata com api
    hr = m_pMdObject->ComMDRenameMetaObjectW( hActualHandle,
                                              pszMDPath,
                                              pszMDNewName );
    if ( FAILED( hr ) )
    {
        goto exit;
    }


exit:
    if ( pohParent != NULL )
    {
        pohParent->Release(this);
        pohParent = NULL;
    }

    return hr;
}

HRESULT STDMETHODCALLTYPE
CADMCOMW::SetData(
    METADATA_HANDLE     hMDHandle,
    LPCWSTR             pszMDPath,
    PMETADATA_RECORD    pmdrMDData)
/*++

Routine Description:

    Set a data object.

Arguments:

    hMDHandle - open handle

    pszMDPath - path of the meta object with which this data is associated

    pmdrMDData - data to set

Return Value:

    Status.

--*/
{
    HRESULT             hresReturn = S_OK;
    METADATA_HANDLE     hActualHandle;

    //
    // lookup and access check
    //

    hresReturn = LookupAndAccessCheck(hMDHandle,
                                      &hActualHandle,
                                      pszMDPath,
                                      pmdrMDData->dwMDIdentifier,
                                      METADATA_PERMISSION_WRITE );
    if (SUCCEEDED(hresReturn))
    {

        if ( !AdminAclNotifySetOrDeleteProp(
                                             hMDHandle,
                                             pmdrMDData->dwMDIdentifier ) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "[CADMCOMW::SetData] AdminAclNotifySetOrDel failed, error %lx\n",
                        GetLastError() ));
            hresReturn = RETURNCODETOHRESULT( GetLastError() );
        }
        else
        {


            //
            // call metadata com api
            //

            hresReturn = m_pMdObject->ComMDSetMetaDataW( hActualHandle,
                                                         pszMDPath,
                                                         pmdrMDData );
        }
    }

    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CADMCOMW::GetData(
    METADATA_HANDLE     hMDHandle,
    LPCWSTR             pszMDPath,
    PMETADATA_RECORD    pmdrMDData,
    DWORD               *pdwMDRequiredDataLen)
/*++

Routine Description:

    Get one metadata value

Arguments:

    hMDHandle - open handle

    pszMDPath - path of the meta object with which this data is associated

    pmdrMDData - data structure

    pdwMDRequiredDataLen - updated with required length

Return Value:

    Status.

--*/
{
    HRESULT             hresReturn = S_OK;
    METADATA_HANDLE     hActualHandle;
    BOOL                fEnableSecureAccess;
    BOOL                fRequestedInheritedStatus;
    DWORD               dwRetCode;

    if ((pmdrMDData == NULL) ||
        ((pmdrMDData->dwMDDataLen != 0) && (pmdrMDData->pbMDData == NULL)) ||
        !CheckGetAttributes(pmdrMDData->dwMDAttributes) ||
        (pmdrMDData->dwMDDataType >= INVALID_END_METADATA))
    {
        hresReturn = E_INVALIDARG;
    }
    else
    {
        //
        // lookup and access check
        //

        hresReturn = LookupAndAccessCheck(hMDHandle,
                                          &hActualHandle,
                                          pszMDPath,
                                          pmdrMDData->dwMDIdentifier,
                                          METADATA_PERMISSION_READ,
                                          &fEnableSecureAccess );
        if (SUCCEEDED(hresReturn))
        {

            fRequestedInheritedStatus = pmdrMDData->dwMDAttributes & METADATA_ISINHERITED;
            pmdrMDData->dwMDAttributes |= METADATA_ISINHERITED;

            //
            // call metadata com api
            //

            hresReturn = m_pMdObject->ComMDGetMetaDataW( hActualHandle,
                                                         pszMDPath,
                                                         pmdrMDData,
                                                         pdwMDRequiredDataLen );

            //
            // if metadata is secure, check if can access this property from
            // where it is defined, i.e using the ACL visible at the definition
            // point in tree.
            //

            if ( SUCCEEDED( hresReturn ) &&
                 (pmdrMDData->dwMDAttributes & METADATA_SECURE) &&
                 (dwRetCode = IsReadAccessGranted( hMDHandle,
                                                   (LPWSTR)pszMDPath,
                                                   pmdrMDData ))
                    != ERROR_SUCCESS )
            {
                hresReturn = RETURNCODETOHRESULT( dwRetCode );
            }

            if ( !fRequestedInheritedStatus )
            {
                pmdrMDData->dwMDAttributes &= ~METADATA_ISINHERITED;
            }

            //
            // if metadata secure, check access allowed to secure properties
            //

            if ( SUCCEEDED( hresReturn ) &&
                 (pmdrMDData->dwMDAttributes & METADATA_SECURE) &&
                 !fEnableSecureAccess)
             {
                 *pdwMDRequiredDataLen = 0;
                 pmdrMDData->dwMDDataLen = 0;
                 hresReturn = RETURNCODETOHRESULT( ERROR_ACCESS_DENIED );
            }
        }
    }

    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CADMCOMW::DeleteData(
    METADATA_HANDLE     hMDHandle,
    LPCWSTR             pszMDPath,
    DWORD               dwMDIdentifier,
    DWORD               dwMDDataType)
/*++

Routine Description:

    Deletes a data object.

Arguments:

    hMDHandle - open handle

    pszMDPath - path of the meta object with which this data is associated

    dwMDIdentifier - identifier of the data to remove

    dwMDDataType - optional type of the data to remove

Return Value:

    Status.

--*/
{
    HRESULT             hresReturn = S_OK;
    METADATA_HANDLE     hActualHandle;

    if (dwMDDataType >= INVALID_END_METADATA)
    {
        hresReturn = E_INVALIDARG;
    }
    else
    {
        //
        // lookup and access check
        //

        hresReturn = LookupAndAccessCheck(hMDHandle,
                                          &hActualHandle,
                                          pszMDPath,
                                          dwMDIdentifier,
                                          METADATA_PERMISSION_WRITE);
        if (SUCCEEDED(hresReturn))
        {
            if ( !AdminAclNotifySetOrDeleteProp(
                                                 hMDHandle,
                                                 dwMDIdentifier ) )
            {
                DBGPRINTF(( DBG_CONTEXT,
                        "[CADMCOMW::DeleteData] AdminAclNotifySetOrDel failed, error %lx\n",
                        GetLastError() ));
                hresReturn = RETURNCODETOHRESULT( GetLastError() );
            }

            else
            {
                //
                // call metadata com api
                //

                hresReturn = m_pMdObject->ComMDDeleteMetaDataW( hActualHandle,
                                                          pszMDPath,
                                                          dwMDIdentifier,
                                                          dwMDDataType );
            }
        }
    }

    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CADMCOMW::EnumData(
    METADATA_HANDLE     hMDHandle,
    LPCWSTR             pszMDPath,
    PMETADATA_RECORD    pmdrMDData,
    DWORD               dwMDEnumDataIndex,
    DWORD               *pdwMDRequiredDataLen)
/*++

Routine Description:

    Enumerate properties of object.

Arguments:

    hMDHandle - open handle

    pszMDPath - path of the meta object with which this data is associated

    pmdrMDData - data structure

    pdwMDRequiredDataLen - updated with required length

Return Value:

    Status.

--*/
{
    HRESULT             hresReturn = S_OK;
    METADATA_HANDLE     hActualHandle;
    BOOL                fSecure;
    BOOL                fRequestedInheritedStatus;
    DWORD               dwRetCode;

    if ((pmdrMDData == NULL) ||
        ((pmdrMDData->dwMDDataLen != 0) && (pmdrMDData->pbMDData == NULL)) ||
        !CheckGetAttributes(pmdrMDData->dwMDAttributes) ||
        (pmdrMDData->dwMDDataType >= INVALID_END_METADATA))
    {
        hresReturn = E_INVALIDARG;
    }
    else
    {
        //
        // lookup and access check
        //

        hresReturn = LookupAndAccessCheck(hMDHandle,
                                          &hActualHandle,
                                          pszMDPath,
                                          0,
                                          METADATA_PERMISSION_READ,
                                          &fSecure);

        if (SUCCEEDED(hresReturn))
        {

            fRequestedInheritedStatus = pmdrMDData->dwMDAttributes & METADATA_ISINHERITED;
            pmdrMDData->dwMDAttributes |= METADATA_ISINHERITED;

            //
            // call metadata com api
            //

            hresReturn = m_pMdObject->ComMDEnumMetaDataW( hActualHandle,
                                                    pszMDPath,
                                                    pmdrMDData,
                                                    dwMDEnumDataIndex,
                                                    pdwMDRequiredDataLen );

            //
            // if metadata is secure, check if can access this property from
            // where it is defined, i.e using the ACL visible at the definition
            // point in tree.
            //
            if ( SUCCEEDED( hresReturn ) &&
                 (pmdrMDData->dwMDAttributes & METADATA_SECURE) &&
                 (dwRetCode = IsReadAccessGranted( hMDHandle,
                                                 (LPWSTR)pszMDPath,
                                                 pmdrMDData ))
                    != ERROR_SUCCESS )
            {
                hresReturn = RETURNCODETOHRESULT( dwRetCode );
                if ( !pmdrMDData->dwMDDataTag )
                {
                    memset( pmdrMDData->pbMDData, 0x0, pmdrMDData->dwMDDataLen );
                }
            }

            if ( !fRequestedInheritedStatus )
            {
                pmdrMDData->dwMDAttributes &= ~METADATA_ISINHERITED;
            }

            if ( !fSecure && SUCCEEDED(hresReturn) )
            {
                if ( pmdrMDData->dwMDAttributes & METADATA_SECURE )
                {
                    hresReturn = RETURNCODETOHRESULT( ERROR_ACCESS_DENIED );

                    if ( !pmdrMDData->dwMDDataTag )
                    {
                        memset( pmdrMDData->pbMDData, 0x0, pmdrMDData->dwMDDataLen );
                    }
                }
            }
        }
    }

    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CADMCOMW::GetAllData(
    METADATA_HANDLE     hMDHandle,
    LPCWSTR             pszMDPath,
    DWORD               dwMDAttributes,
    DWORD               dwMDUserType,
    DWORD               dwMDDataType,
    DWORD               *pdwMDNumDataEntries,
    DWORD               *pdwMDDataSetNumber,
    DWORD               dwMDBufferSize,
    unsigned char       *pbMDBuffer,
    DWORD               *pdwMDRequiredBufferSize)
/*++

Routine Description:

    Gets all data associated with a Meta Object

Arguments:

    hMDHandle - open  handle

    pszMDPath - path of the meta object with which this data is associated

    dwMDAttributes - flags for the data

    dwMDUserType - user Type for the data

    dwMDDataType - type of the data

    pdwMDNumDataEntries - number of entries copied to Buffer

    pdwMDDataSetNumber - number associated with this data set

    dwMDBufferSize - size in bytes of buffer

    pbMDBuffer - buffer to store the data

    pdwMDRequiredBufferSize - updated with required length of buffer

Return Value:

    Status.

--*/
{
    HRESULT             hresReturn = S_OK;
    METADATA_HANDLE     hActualHandle;
    BOOL                fSecure;
    BOOL                fRequestedInheritedStatus;

    if ((pdwMDNumDataEntries == NULL) || ((dwMDBufferSize != 0) && (pbMDBuffer == NULL)) ||
        !CheckGetAttributes(dwMDAttributes) ||
        (dwMDDataType >= INVALID_END_METADATA))
    {
        hresReturn = E_INVALIDARG;
    }
    else
    {
        //
        // lookup and access check
        //
        hresReturn = LookupAndAccessCheck(hMDHandle,
                                          &hActualHandle,
                                          pszMDPath,
                                          AAC_GETALL,
                                          METADATA_PERMISSION_READ,
                                          &fSecure );

        if (SUCCEEDED(hresReturn))
        {
            fRequestedInheritedStatus = dwMDAttributes & METADATA_ISINHERITED;
            dwMDAttributes |= METADATA_ISINHERITED;

            //
            // call metadata com api
            //

            hresReturn = m_pMdObject->ComMDGetAllMetaDataW( hActualHandle,
                                                      pszMDPath,
                                                      dwMDAttributes,
                                                      dwMDUserType,
                                                      dwMDDataType,
                                                      pdwMDNumDataEntries,
                                                      pdwMDDataSetNumber,
                                                      dwMDBufferSize,
                                                      pbMDBuffer,
                                                      pdwMDRequiredBufferSize );

            if ( SUCCEEDED(hresReturn) )
            {
                PMETADATA_GETALL_RECORD pMDRecord;
                DWORD                   iP;

                //
                // Scan for secure properties
                // For such properties, check if user has access to it using following rules:
                // - must have right to access secure properties in ACE
                // - must have access to property using ACL visible where property is defined
                // if no access to property then remove it from list of returned properties

                pMDRecord = (PMETADATA_GETALL_RECORD)pbMDBuffer;
                for ( iP = 0 ; iP < *pdwMDNumDataEntries ; )
                {
                    if ( pMDRecord->dwMDAttributes & METADATA_SECURE )
                    {
                        if ( !fSecure ||
                             IsReadAccessGranted( hMDHandle,
                                                  (LPWSTR)pszMDPath,
                                                  (PMETADATA_RECORD)pMDRecord ) != ERROR_SUCCESS )
                        {
                            //
                            // remove this property from METADATA_RECORD list,
                            // zero out content
                            //

                            memset( pbMDBuffer + pMDRecord->dwMDDataOffset,
                                    0x0,
                                    pMDRecord->dwMDDataLen );

                            --*pdwMDNumDataEntries;

                            memmove( pMDRecord,
                                     pMDRecord + 1,
                                     sizeof(METADATA_GETALL_RECORD) * (*pdwMDNumDataEntries-iP) );
                            continue;
                        }
                    }

                    if ( !fRequestedInheritedStatus )
                    {
                        pMDRecord->dwMDAttributes &= ~METADATA_ISINHERITED;
                    }

                    ++iP;
                    ++pMDRecord;
                }
            }
        }
    }

    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CADMCOMW::DeleteAllData(
    METADATA_HANDLE     hMDHandle,
    LPCWSTR             pszMDPath,
    DWORD               dwMDUserType,
    DWORD               dwMDDataType)
{
    HRESULT             hresReturn = S_OK;
    METADATA_HANDLE     hActualHandle;

    if (dwMDDataType >= INVALID_END_METADATA)
    {
        hresReturn = E_INVALIDARG;
    }
    else
    {
        //
        // lookup and access check
        //

        hresReturn = LookupAndAccessCheck(hMDHandle,
                                          &hActualHandle,
                                          pszMDPath,
                                          0,
                                          METADATA_PERMISSION_WRITE);

        if (SUCCEEDED(hresReturn))
        {

            //
            // call metadata com api
            //

            hresReturn = m_pMdObject->ComMDDeleteAllMetaDataW( hActualHandle,
                                                         pszMDPath,
                                                         dwMDUserType,
                                                         dwMDDataType );

        }
    }

    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CADMCOMW::CopyData(
    METADATA_HANDLE     hMDSourceHandle,
    LPCWSTR             pszMDSourcePath,
    METADATA_HANDLE     hMDDestHandle,
    LPCWSTR             pszMDDestPath,
    DWORD               dwMDAttributes,
    DWORD               dwMDUserType,
    DWORD               dwMDDataType,
    BOOL                bMDCopyFlag)
/*++

Routine Description:

    Copies or moves data associated with the source object to the destination
    object.

Arguments:

    hMDSourceHandle - open handle

    pszMDSourcePath - path of the meta object with which then source data is
                      associated

    hMDDestHandle - handle returned by MDOpenKey with write permission

    pszMDDestPath - path of the meta object for data to be copied to

    dwMDAttributes - flags for the data

    dwMDUserType - user Type for the data

    dwMDDataType - optional type of the data to copy

    bMDCopyFlag - if true, data will be copied; if false, data will be moved.

Return Value:

    Status.

--*/
{
    HRESULT             hresReturn = S_OK;
    METADATA_HANDLE     hSActualHandle;
    METADATA_HANDLE     hDActualHandle;

    if (((!bMDCopyFlag) && (dwMDAttributes & METADATA_INHERIT)) ||
        ((dwMDAttributes & METADATA_PARTIAL_PATH) && !(dwMDAttributes & METADATA_INHERIT)))
    {
        hresReturn = E_INVALIDARG;
    }
    else
    {
        //
        // lookup and access check source
        //

        if (bMDCopyFlag)
        {
            hresReturn = LookupAndAccessCheck(hMDSourceHandle,
                                              &hSActualHandle,
                                              pszMDSourcePath,
                                              0,
                                              METADATA_PERMISSION_READ);
        }
        else
        {
            //
            // Deleting source data, so need delete permission
            //

            hresReturn = LookupAndAccessCheck(hMDSourceHandle,
                                              &hSActualHandle,
                                              pszMDSourcePath,
                                              0,
                                              METADATA_PERMISSION_WRITE);
        }
        if (SUCCEEDED(hresReturn))
        {
            //
            // lookup and access check dest
            //

            hresReturn = LookupAndAccessCheck(hMDDestHandle,
                                              &hDActualHandle,
                                              pszMDDestPath,
                                              0,
                                              METADATA_PERMISSION_WRITE);
            if (SUCCEEDED(hresReturn))
            {

                //
                // call metadata com api
                //

                hresReturn = m_pMdObject->ComMDCopyMetaDataW(hSActualHandle,
                                                       pszMDSourcePath,
                                                       hDActualHandle,
                                                       pszMDDestPath,
                                                       dwMDAttributes,
                                                       dwMDUserType,
                                                       dwMDDataType,
                                                       bMDCopyFlag );
            }
        }
    }

    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CADMCOMW::GetDataPaths(
    METADATA_HANDLE     hMDHandle,
    LPCWSTR             pszMDPath,
    DWORD               dwMDIdentifier,
    DWORD               dwMDDataType,
    DWORD               dwMDBufferSize,
    LPWSTR              pszMDBuffer,
    DWORD               *pdwMDRequiredBufferSize)
{
    HRESULT             hresReturn = S_OK;
    METADATA_HANDLE     hActualHandle;
    BOOL                fSecure;

    if (((pszMDBuffer == NULL) && (dwMDBufferSize != 0)) ||
        (dwMDDataType >= INVALID_END_METADATA) ||
        (pdwMDRequiredBufferSize == NULL))
    {
        hresReturn = E_INVALIDARG;
    }
    else
    {
        //
        // lookup and access check
        //

        hresReturn = LookupAndAccessCheck(hMDHandle,
                                          &hActualHandle,
                                          pszMDPath,
                                          0,
                                          METADATA_PERMISSION_READ,
                                          &fSecure);

        if (SUCCEEDED(hresReturn))
        {

            //
            // call metadata com api
            //

            hresReturn = m_pMdObject->ComMDGetMetaDataPathsW( hActualHandle,
                                                        pszMDPath,
                                                        dwMDIdentifier,
                                                        dwMDDataType,
                                                        dwMDBufferSize,
                                                        pszMDBuffer,
                                                        pdwMDRequiredBufferSize );
        }
    }

    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CADMCOMW::OpenKey(
    METADATA_HANDLE     hMDHandle,
    LPCWSTR             pszMDPath,
    DWORD               dwMDAccessRequested,
    DWORD               dwMDTimeOut,
    PMETADATA_HANDLE    phMDNewHandle)
/*++

Routine Description:

    Opens a meta object for read and/or write access.

Arguments:

    hMDHandle - open handle

    pszMDPath - path of the object to be opened

    dwMDAccessRequested - permissions requested

    dwMDTimeOut - time to block waiting for open to succeed, in miliseconds.

    phMDNewHandle - handle to be passed to other MD routines

Return Value:

    Status.

--*/
{
    HRESULT             hresReturn = S_OK;

    // If caller watch is not initialized
    if ( !IsCallerWatchInitialized() )
    {
        // Initialize the caller watch
        hresReturn = InitializeCallerWatch();
        if ( FAILED( hresReturn ) )
        {
            return hresReturn;
        }
    }

    hresReturn = OpenKeyHelper(hMDHandle, pszMDPath, dwMDAccessRequested, dwMDTimeOut, phMDNewHandle);

    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CADMCOMW::CloseKey(
    METADATA_HANDLE     hMDHandle)
/*++

Routine Description:

    Closes a handle to a meta object.

Arguments:

    hMDHandle - open handle

Return Value:

    Status.

--*/
{
    HRESULT             hresReturn = S_OK;
    METADATA_HANDLE     hActualHandle;
    DWORD               dwTemp;
    COpenHandle         *pohHandle;

    if ((hMDHandle == METADATA_MASTER_ROOT_HANDLE))
    {
        hresReturn = E_HANDLE;
    }
    else
    {
        //
        // Map Admin Handle to Actual Handle
        //

        if( (dwTemp = Lookup( hMDHandle,
                              &hActualHandle,
                              &pohHandle )) != ERROR_SUCCESS )
        {
            hresReturn = RETURNCODETOHRESULT(dwTemp);
        }
        else
        {

            //
            // call metadata com api
            //

            hresReturn = m_pMdObject->ComMDCloseMetaObject( hActualHandle );


            pohHandle->Release(this);

            //
            // Remove node from handle table
            //
            if (SUCCEEDED(hresReturn))
            {
                pohHandle->Release(this);
            }
        }
    }

    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CADMCOMW::ChangePermissions(
    METADATA_HANDLE     hMDHandle,
    DWORD               dwMDTimeOut,
    DWORD               dwMDAccessRequested)
/*++

Routine Description:

    Changes permissions on an open meta object handle.

Arguments:

    hMDHandle - handle to be modified

    dwMDTimeOut - time to block waiting for open to succeed, in miliseconds.

    dwMDAccessRequested - requested permissions

Return Value:

    Status.

--*/
{
    HRESULT             hr = S_OK;
    METADATA_HANDLE     hActualHandle;

    if ( hMDHandle == METADATA_MASTER_ROOT_HANDLE )
    {
        hr = E_HANDLE;
        goto exit;
    }

    if ( ( ( dwMDAccessRequested & ( METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE ) ) == 0 ) ||
         ( ( dwMDAccessRequested & ~( METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE ) ) != 0 ) )
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    //
    // Map Admin Handle to Actual Handle
    // and check access
    //
    hr = LookupAndAccessCheck( hMDHandle,
                               &hActualHandle,
                               L"",
                               0,
                               dwMDAccessRequested );
    if( FAILED( hr ) )
    {
        goto exit;
    }


    //
    // call metadata com api
    //
    hr = m_pMdObject->ComMDChangePermissions( hActualHandle,
                                              dwMDTimeOut,
                                              dwMDAccessRequested );

exit:
    return hr;
}

HRESULT STDMETHODCALLTYPE
CADMCOMW::SaveData( )
/*++

Routine Description:

    Saves all data changed since the last load or save to permanent storage.

Arguments:

    None.

Return Value:

    Status.

--*/
{
    HRESULT             hr = S_OK;
    METADATA_HANDLE     mdhRoot = METADATA_MASTER_ROOT_HANDLE;
    METADATA_HANDLE     hActualHandle;


    //
    // lookup and access check
    //
    hr = LookupAndAccessCheck( METADATA_MASTER_ROOT_HANDLE,
                               &hActualHandle,
                               L"",
                               0,
                               METADATA_PERMISSION_READ);
    if ( FAILED( hr ) )
    {
        goto exit;
    }

    //
    // First try to lock the tree
    //
    hr = m_pMdObject->ComMDOpenMetaObjectW( METADATA_MASTER_ROOT_HANDLE,
                                            NULL,
                                            METADATA_PERMISSION_READ,
                                            DEFAULT_SAVE_TIMEOUT,
                                            &mdhRoot );
    if ( FAILED( hr ) )
    {
        goto exit;
    }

    //
    // call metadata com api
    //
    hr = m_pMdObject->ComMDSaveData(mdhRoot);

    m_pMdObject->ComMDCloseMetaObject(mdhRoot);

exit:
    return hr;
}

HRESULT STDMETHODCALLTYPE
CADMCOMW::GetHandleInfo(
    METADATA_HANDLE         hMDHandle,
    PMETADATA_HANDLE_INFO   pmdhiInfo)
/*++

Routine Description:

    Gets the information associated with a handle.

Arguments:

    hMDHandle - handle to get information about

    pmdhiInfo - structure filled in with the information

Return Value:

    Status.

--*/
{
    HRESULT             hresReturn = S_OK;
    METADATA_HANDLE     hActualHandle;
    DWORD               dwRetCode = ERROR_SUCCESS;

    if (pmdhiInfo == NULL)
    {
        hresReturn = E_INVALIDARG;
    }
    else
    {
        //
        // Map Admin Handle to Actual Handle
        //

        if( (dwRetCode = Lookup( hMDHandle,
                               &hActualHandle
                               )) != ERROR_SUCCESS )
        {
            hresReturn = RETURNCODETOHRESULT(dwRetCode);
        }
        else
        {
            //
            // call metadata com api
            //

            hresReturn = m_pMdObject->ComMDGetHandleInfo( hActualHandle,
                                                    pmdhiInfo );

        }
    }

    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CADMCOMW::GetSystemChangeNumber(
    DWORD           *pdwSystemChangeNumber)
/*++

Routine Description:

    Gets the System Change Number.

Arguments:

    pdwSystemChangeNumber - system change number

Return Value:

    Status.

--*/
{
    HRESULT             hr = S_OK;
    METADATA_HANDLE     hActualHandle;

    // Check args
    if ( pdwSystemChangeNumber == NULL )
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    //
    // lookup and access check
    //
    hr = LookupAndAccessCheck( METADATA_MASTER_ROOT_HANDLE,
                               &hActualHandle,
                               L"",
                               0,
                               METADATA_PERMISSION_READ );
    if ( FAILED( hr ) )
    {
        goto exit;
    }

    //
    // call metadata com api
    //
    hr = m_pMdObject->ComMDGetSystemChangeNumber( pdwSystemChangeNumber );

exit:
    return hr;
}

HRESULT STDMETHODCALLTYPE
CADMCOMW::GetDataSetNumber(
    METADATA_HANDLE     hMDHandle,
    LPCWSTR             pszMDPath,
    DWORD               *pdwMDDataSetNumber)
/*++

Routine Description:

    Gets all the data set number associated with a Meta Object.

Arguments:

    hMDHandle - open handle

    pszMDPath - path of the meta object with which this data is associated

    pdwMDDataSetNumber - number associated with this data set

Return Value:

    Status.

--*/
{
    HRESULT             hresReturn = S_OK;
    METADATA_HANDLE     hActualHandle;

    if (pdwMDDataSetNumber == NULL)
    {
        hresReturn = E_INVALIDARG;
    }
    else
    {
        //
        // lookup and access check
        //

        hresReturn = LookupAndAccessCheck(hMDHandle,
                                          &hActualHandle,
                                          pszMDPath,
                                          0,
                                          METADATA_PERMISSION_READ);

        if (SUCCEEDED(hresReturn))
        {
            //
            // call metadata com api
            //

            hresReturn = m_pMdObject->ComMDGetDataSetNumberW( hActualHandle,
                                                        pszMDPath,
                                                        pdwMDDataSetNumber );
        }
    }

    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CADMCOMW::SetLastChangeTime(
    METADATA_HANDLE     hMDHandle,
    LPCWSTR             pszMDPath,
    PFILETIME           pftMDLastChangeTime,
    BOOL                bLocalTime)
/*++

Routine Description:

    Set the last change time associated with a Meta Object.

Arguments:

    hMDHandle - open handle

    pszMDPath - path of the affected meta object

    pftMDLastChangeTime - new change time for the meta object

Return Value:

    Status.

--*/
{
    HRESULT             hr = S_OK;
    BOOL                fRet;
    DWORD               dwError;
    METADATA_HANDLE     hActualHandle;
    FILETIME            ftTime;
    FILETIME            *pftTime = NULL;

    // Check arhs
    if ( ( pftMDLastChangeTime == NULL ) ||
         ( hMDHandle == METADATA_MASTER_ROOT_HANDLE ) )
    {
        hr = E_INVALIDARG;
        goto exit;
    }


    // lookup and access check
    hr = LookupAndAccessCheck( hMDHandle,
                               &hActualHandle,
                               pszMDPath,
                               0,
                               METADATA_PERMISSION_WRITE );
    if ( FAILED( hr ) )
    {
        goto exit;
    }

    if ( bLocalTime )
    {
        fRet = LocalFileTimeToFileTime( pftMDLastChangeTime, &ftTime );
        if ( !fRet )
        {
            dwError = GetLastError();
            hr = HRESULT_FROM_WIN32( dwError );
            goto exit;
        }

        pftTime = &ftTime;
    }
    else
    {
        pftTime = pftMDLastChangeTime;
    }

    // call metadata com api
    hr = m_pMdObject->ComMDSetLastChangeTimeW( hActualHandle,
                                               pszMDPath,
                                               pftTime );
    if ( FAILED( hr ) )
    {
        goto exit;
    }

exit:
    return hr;
}

HRESULT STDMETHODCALLTYPE
CADMCOMW::GetLastChangeTime(
    METADATA_HANDLE     hMDHandle,
    LPCWSTR             pszMDPath,
    PFILETIME           pftMDLastChangeTime,
    BOOL                bLocalTime)
/*++

Routine Description:

    Set the last change time associated with a Meta Object.

Arguments:

    Handle - open handle

    pszMDPath - path of the affected meta object

    pftMDLastChangeTime - place to return the change time for the meta object

Return Value:

    Status.

--*/
{
    HRESULT             hresReturn = S_OK;
    METADATA_HANDLE     hActualHandle;
    FILETIME            ftTime;

    if (pftMDLastChangeTime == NULL)
    {
        hresReturn = E_INVALIDARG;
    }
    else
    {
        //
        // lookup and access check
        //

        hresReturn = LookupAndAccessCheck(hMDHandle,
                                          &hActualHandle,
                                          pszMDPath,
                                          0,
                                          METADATA_PERMISSION_READ);

        if (SUCCEEDED(hresReturn))
        {

            //
            // call metadata com api
            //

            hresReturn = m_pMdObject->ComMDGetLastChangeTimeW( hActualHandle,
                                                               pszMDPath,
                                                               &ftTime );


            if (bLocalTime)
            {
                if (!FileTimeToLocalFileTime(&ftTime, pftMDLastChangeTime))
                {
                    hresReturn = E_UNEXPECTED;
                }
            }
            else
            {
                *pftMDLastChangeTime = ftTime;
            }
        }
    }

    return hresReturn;
}

HRESULT
CADMCOMW::BackupHelper(
    LPCWSTR             pszMDBackupLocation,
    DWORD               dwMDVersion,
    DWORD               dwMDFlags,
    LPCWSTR             pszPasswd)
{
    HRESULT             hresReturn = S_OK;
    HRESULT             hresWarning = S_OK;
    METADATA_HANDLE     mdhRoot = METADATA_MASTER_ROOT_HANDLE;

    if ( !AdminAclAccessCheck( m_pMdObject,
                               (LPVOID)this,
                               METADATA_MASTER_ROOT_HANDLE,
                               L"",
                               MD_ADMIN_ACL,
                               METADATA_PERMISSION_WRITE,
                               &g_ohMasterRootHandle ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                "[CADMCOMW::Backup] AdminAclAccessCheck failed, error %lx\n",
                GetLastError() ));
        hresReturn = RETURNCODETOHRESULT( GetLastError() );
    }
    else
    {
        if ((dwMDFlags & MD_BACKUP_SAVE_FIRST) != 0)
        {
            //
            // First lock the tree
            //

            hresReturn = m_pMdObject->ComMDOpenMetaObjectW( METADATA_MASTER_ROOT_HANDLE,
                                                            NULL,
                                                            METADATA_PERMISSION_READ,
                                                            DEFAULT_SAVE_TIMEOUT,
                                                            &mdhRoot);
        }

        if (FAILED(hresReturn))
        {
            if ((dwMDFlags & MD_BACKUP_FORCE_BACKUP) != 0)
            {
                hresWarning = MD_WARNING_SAVE_FAILED;
                hresReturn = ERROR_SUCCESS;
                dwMDFlags &= ~(MD_BACKUP_FORCE_BACKUP | MD_BACKUP_SAVE_FIRST);
            }
        }

        if (SUCCEEDED(hresReturn))
        {
            //
            // call metadata com api
            //
            if( !pszPasswd )
            {
                hresReturn = m_pMdObject->ComMDBackupW(mdhRoot,
                                                       pszMDBackupLocation,
                                                       dwMDVersion,
                                                       dwMDFlags);
            }
            else
            {
                hresReturn = m_pMdObject->ComMDBackupWithPasswdW(mdhRoot,
                                                                  pszMDBackupLocation,
                                                                  dwMDVersion,
                                                                  dwMDFlags,
                                                                  pszPasswd);
            }

            if ((dwMDFlags & MD_BACKUP_SAVE_FIRST) != 0)
            {
                m_pMdObject->ComMDCloseMetaObject(mdhRoot);
            }
        }

        if (hresReturn == ERROR_SUCCESS)
        {
            hresReturn = hresWarning;
        }
    }

    return hresReturn;
}


#define MD_DEFAULT_BACKUP_LOCATION_W            L"MDBackUp"

HRESULT
CADMCOMW::RestoreHelper(
    LPCWSTR             pszMDBackupLocation,
    DWORD               dwMDVersion,
    DWORD               dwMDMinorVersion,
    LPCWSTR             pszPasswd,
    DWORD               dwMDFlags,
    DWORD               dwRestoreType) // RESTORE_HISTORY or RESTORE_BACKUP
{
    HRESULT             hr = S_OK;
    DWORD               dwError;
    BOOL                fRet;
    BUFFER              bufDependentServices;
    DWORD               cServices = 0;
    WCHAR               pszEnumLocation[MD_BACKUP_MAX_LEN] = {0};
    DWORD               dwEnumVersion;
    DWORD               dwEnumMinorVersion;
    FILETIME            ftEnumTime;
    DWORD               i;
    DWORD               dwEnableHistory = FALSE;
    DWORD               dwEnableEWR = FALSE;
    BOOL                fEnableAclCache = FALSE;

    // This should be called only internally, so passing wrong restore type is a bug
    DBG_ASSERT( dwRestoreType == RESTORE_HISTORY || dwRestoreType == RESTORE_BACKUP );

    // Check args
    if ( ( dwRestoreType != RESTORE_HISTORY && dwRestoreType != RESTORE_BACKUP ) ||
         ( dwRestoreType == RESTORE_BACKUP && pszMDBackupLocation == NULL ) ||
         ( pszMDBackupLocation && wcslen(pszMDBackupLocation) >= MD_BACKUP_MAX_LEN ) )
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Check access
    fRet = AdminAclAccessCheck( m_pMdObject,
                                (LPVOID)this,
                                METADATA_MASTER_ROOT_HANDLE,
                                L"",
                                MD_ADMIN_ACL,
                                METADATA_PERMISSION_WRITE,
                                &g_ohMasterRootHandle );
    if ( !fRet )
    {
        dwError = GetLastError();

        DBGPRINTF(( DBG_CONTEXT,
                    ( ( dwRestoreType == RESTORE_HISTORY ) ?
                        "[CADMCOMW::RestoreHistory] AdminAclAccessCheck failed, error %lx\n" :
                        "[CADMCOMW::Restore] AdminAclAccessCheck failed, error %lx\n" ),
                    dwError ));
        hr = HRESULT_FROM_WIN32( dwError );
        goto exit;
    }

    // Find the requested backup/history
    for ( i = 0; SUCCEEDED( hr ); i++ )
    {
        if ( dwRestoreType == RESTORE_HISTORY )
        {
            if( pszMDBackupLocation != NULL )
            {
                wcscpy( pszEnumLocation, pszMDBackupLocation );
            }
            else
            {
                *pszEnumLocation = L'\0';
            }
            hr = m_pMdObject->ComMDEnumHistoryW( pszEnumLocation,
                                                 &dwEnumVersion,
                                                 &dwEnumMinorVersion,
                                                 &ftEnumTime,
                                                 i);
            if ( FAILED( hr ) )
            {
                break;
            }

            if( dwMDFlags & MD_HISTORY_LATEST )
            {
                break;
            }
            else
            {
                if ( ( dwEnumVersion == dwMDVersion ) &&
                     ( dwEnumMinorVersion == dwMDMinorVersion ) )
                {
                    break;
                }
            }
        }
        else
        {
            if( pszMDBackupLocation != NULL )
            {
                wcscpy( pszEnumLocation, pszMDBackupLocation );
            }
            else
            {
                wcscpy( pszEnumLocation, MD_DEFAULT_BACKUP_LOCATION_W );
            }
            hr = m_pMdObject->ComMDEnumBackupsW( pszEnumLocation,
                                                 &dwEnumVersion,
                                                 &ftEnumTime,
                                                 i);
            if ( FAILED( hr ) )
            {
                break;
            }

            if ( ( dwEnumVersion == dwMDVersion ) ||
                 ( dwMDVersion == MD_BACKUP_HIGHEST_VERSION ) )
            {
                break;
            }
        }
    }

    // If we failed to find the requested backup/history
    if ( FAILED( hr ) )
    {
        // If asked for an version that doesn't exist
        // adjust the error code
        if ( hr == HRESULT_FROM_WIN32( ERROR_NO_MORE_ITEMS ) )
        {
            if( dwRestoreType == RESTORE_HISTORY )
            {
                if( dwMDFlags & MD_HISTORY_LATEST )
                {
                    hr = HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND );
                }
                else
                {
                    hr = MD_ERROR_INVALID_VERSION;
                }
            }
            else
            {
                hr = E_INVALIDARG;
            }
        }

        goto exit;
    }

    //
    // Looks like a valid metabase
    //

    // Disable History (and EWR) to prevent the dependent services creating
    // history and deleting currently valid history files during their stoppping.
    // Keep the current state of EnableHistory and EnableEWR, so we can restore
    // them if restore fails.
    hr = DisableHistory(&dwEnableHistory, &dwEnableEWR);
    if ( FAILED( hr ) )
    {
        goto exit;
    }

    // Stop all dependent services, keeping their list so later we can start them again
    hr = EnumAndStopDependentServices( &cServices, &bufDependentServices );
    if ( FAILED( hr ) )
    {
        goto exit;
    }

    // Disable the Acl cache, since we are going to re-load the whole metabase
    AdminAclDisableAclCache();
    // Remember to re-enable it
    fEnableAclCache = TRUE;

    // Discard everything from the Acl caches
    AdminAclFlushCache();

    // Finally call the CMDCOM method
    if( dwRestoreType == RESTORE_HISTORY )
    {
        hr = m_pMdObject->ComMDRestoreHistoryW( pszMDBackupLocation,
                                                dwMDVersion,
                                                dwMDMinorVersion,
                                                dwMDFlags );
    }
    else
    {
        if( !pszPasswd )
        {
            hr = m_pMdObject->ComMDRestoreW( pszMDBackupLocation,
                                             dwMDVersion,
                                             dwMDFlags );
        }
        else
        {
            hr = m_pMdObject->ComMDRestoreWithPasswdW( pszMDBackupLocation,
                                                       dwMDVersion,
                                                       dwMDFlags,
                                                       pszPasswd );
        }
    }
    if ( FAILED( hr ) )
    {
        goto exit;
    }

    //
    // Issue TaylorW 4/10/2001
    //
    // After the restore, notify clients, as data has changed
    // and all handles have become invalid
    //
    // Windows Bug 82423
    //

    // If restore succeed the values of the EnableHistory and EnableEWR are
    // set as from the backup/history file, so we don't restore them.
    dwEnableHistory = FALSE;
    dwEnableEWR = FALSE;

exit:
    // If something went wrong after we got the EnableHistoy and EnableEWR and
    // at least one of them was not FALSE set them back
    if ( dwEnableHistory || dwEnableEWR )
    {
        SetHistoryAndEWR( dwEnableHistory, dwEnableEWR );
    }

    // If we disable the acl cache
    if ( fEnableAclCache )
    {
        // Re-enable it
        AdminAclEnableAclCache();
    }

    // If we stopped any services
    if ( cServices )
    {
        // Enable them back
        StartDependentServices( cServices, (ENUM_SERVICE_STATUS*)bufDependentServices.QueryPtr() );
    }

    return hr;
}


HRESULT
CADMCOMW::EnumAndStopDependentServices(
    DWORD               *pcServices,
    BUFFER              *pbufDependentServices)
{
    // Locals
    HRESULT             hr = S_OK;
    DWORD               dwError;
    BOOL                fRet;
    SC_HANDLE           schSCM = NULL;
    SC_HANDLE           schIISADMIN = NULL;
    SC_HANDLE           schDependent = NULL;
    SERVICE_STATUS      ssDependent;
    DWORD               dwBytesNeeded;
    ENUM_SERVICE_STATUS *pessDependentServices = NULL;
    DWORD               cServices = 0;
    DWORD               i;

    // Check args
    DBG_ASSERT( ( pcServices != NULL ) && ( pbufDependentServices != NULL ) );
    if ( ( pcServices == NULL ) || ( pbufDependentServices == NULL ) )
    {
        hr = E_INVALIDARG;
        goto exit;
    }


    // Init
    *pcServices = 0;

    // Open SCM
    schSCM = OpenSCManager( NULL,
                            NULL,
                            SC_MANAGER_ALL_ACCESS );
    if ( schSCM == NULL )
    {
        dwError = GetLastError();
        hr = HRESULT_FROM_WIN32( dwError );
        goto exit;
    }


    // Open IISADMIN
    schIISADMIN = OpenService( schSCM,
                               "IISADMIN",
                               STANDARD_RIGHTS_REQUIRED | SERVICE_ENUMERATE_DEPENDENTS );
    if ( schIISADMIN == NULL )
    {
        dwError = GetLastError();
        hr = HRESULT_FROM_WIN32( dwError );
        goto exit;
    }

    pessDependentServices = (ENUM_SERVICE_STATUS*)pbufDependentServices->QueryPtr();
    DBG_ASSERT( pessDependentServices );
    fRet = EnumDependentServices( schIISADMIN,
                                  SERVICE_ACTIVE,
                                  pessDependentServices,
                                  pbufDependentServices->QuerySize(),
                                  &dwBytesNeeded,
                                  &cServices );
    // The buffer is too small?
    if ( !fRet && ( GetLastError() == ERROR_MORE_DATA ) )
    {
        // Resize the buffer
        fRet = pbufDependentServices->Resize( dwBytesNeeded );
        if ( !fRet )
        {
            hr = E_OUTOFMEMORY;
            goto exit;
        }

        // Retry the call
        pessDependentServices = (ENUM_SERVICE_STATUS*)pbufDependentServices->QueryPtr();
        DBG_ASSERT( pessDependentServices );
        fRet = EnumDependentServices( schIISADMIN,
                                      SERVICE_ACTIVE,
                                      pessDependentServices,
                                      dwBytesNeeded,
                                      &dwBytesNeeded,
                                      &cServices );
    }

    if ( !fRet )
    {
        dwError = GetLastError();
        hr = HRESULT_FROM_WIN32( dwError );
        goto exit;
    }

    //
    // Open handles and send service control stop command
    //
    for ( i = 0; i < cServices; i++ )
    {
        if ( ( pessDependentServices[i].ServiceStatus.dwCurrentState == SERVICE_STOP_PENDING ) ||
             ( pessDependentServices[i].ServiceStatus.dwCurrentState == SERVICE_STOPPED ) )
        {
            continue;
        }

        schDependent = OpenService( schSCM,
                                    pessDependentServices[i].lpServiceName,
                                    SERVICE_ALL_ACCESS );
        if ( schDependent == NULL )
        {
            continue;
        }

        //Stop Service
        ControlService( schDependent, SERVICE_CONTROL_STOP, &ssDependent );
        WaitForServiceStatus( schDependent, SERVICE_STOPPED );
        CloseServiceHandle( schDependent );
        schDependent = NULL;
    }

    // Return
    *pcServices = cServices;

exit:
    if ( schSCM != NULL )
    {
        CloseServiceHandle( schSCM );
        schSCM = NULL;
    }
    if ( schIISADMIN != NULL )
    {
        CloseServiceHandle( schIISADMIN );
        schIISADMIN = NULL;
    }
    if ( schDependent != NULL )
    {
        CloseServiceHandle( schDependent );
        schDependent = NULL;
    }

    return hr;
}

HRESULT
CADMCOMW::StartDependentServices(
    DWORD               cServices,
    ENUM_SERVICE_STATUS *pessDependentServices)
{
    // Locals
    HRESULT             hr = S_OK;
    DWORD               dwError;
    DWORD               i = 0;
    SC_HANDLE           schSCM = NULL;
    SC_HANDLE           schDependent = NULL;

    // Check agrs
    if ( cServices == 0 )
    {
        // Nop
        goto exit;
    }

    DBG_ASSERT( pessDependentServices != NULL );
    if ( pessDependentServices == NULL )
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Open SCM
    schSCM = OpenSCManager( NULL,
                            NULL,
                            SC_MANAGER_ALL_ACCESS );
    if ( schSCM == NULL )
    {
        dwError = GetLastError();
        hr = HRESULT_FROM_WIN32( dwError );
        goto exit;
    }

    //
    // Open handles and start services
    // Use reverse order, since EnumServices orders
    // list by dependencies
    //
    for ( i = 0; i < cServices; i++ )
    {
        if ( ( pessDependentServices[cServices-1-i].ServiceStatus.dwCurrentState == SERVICE_STOP_PENDING ) ||
             ( pessDependentServices[cServices-1-i].ServiceStatus.dwCurrentState == SERVICE_STOPPED ) )
        {
            continue;
        }

        schDependent = OpenService( schSCM,
                                    pessDependentServices[cServices-1-i].lpServiceName,
                                    SERVICE_ALL_ACCESS );
        if ( schDependent == NULL )
        {
            continue;
        }

        //Start Service
        StartService( schDependent, 0, NULL );
        WaitForServiceStatus( schDependent, SERVICE_RUNNING );
        CloseServiceHandle( schDependent );
        schDependent = NULL;
    }

exit:
    if ( schSCM != NULL )
    {
        CloseServiceHandle( schSCM );
        schSCM = NULL;
    }
    if ( schDependent != NULL )
    {
        CloseServiceHandle( schDependent );
        schDependent = NULL;
    }

    return hr;
}

HRESULT
CADMCOMW::SetHistoryAndEWR(
    DWORD               dwEnableHistory,
    DWORD               dwEnableEWR)
{
    // Locals
    HRESULT             hr = S_OK;
    METADATA_HANDLE     mdhRoot = METADATA_MASTER_ROOT_HANDLE;
    METADATA_RECORD     mdrHistory =    {
                                            MD_ROOT_ENABLE_HISTORY,
                                            METADATA_NO_ATTRIBUTES,
                                            IIS_MD_UT_SERVER,
                                            DWORD_METADATA,
                                            sizeof(DWORD),
                                            (BYTE*)&dwEnableHistory,
                                            0
                                        };
    METADATA_RECORD     mdrEWR =        {
                                            MD_ROOT_ENABLE_EDIT_WHILE_RUNNING,
                                            METADATA_NO_ATTRIBUTES,
                                            IIS_MD_UT_SERVER,
                                            DWORD_METADATA,
                                            sizeof(DWORD),
                                            (BYTE*)&dwEnableEWR,
                                            0
                                        };


    // Open the the root for writting
    hr = m_pMdObject->ComMDOpenMetaObjectW( METADATA_MASTER_ROOT_HANDLE,
                                            L"/LM",
                                            METADATA_PERMISSION_WRITE,
                                            DEFAULT_SAVE_TIMEOUT,
                                            &mdhRoot );
    if ( FAILED( hr ) )
    {
        goto exit;
    }

    // Set EWR 1st
    hr = m_pMdObject->ComMDSetMetaDataW( mdhRoot,
                                         L"",
                                         &mdrEWR );
    if ( FAILED( hr ) )
    {
        goto exit;
    }

    // Set History after EWR
    hr = m_pMdObject->ComMDSetMetaDataW( mdhRoot,
                                         L"",
                                         &mdrHistory );
    if ( FAILED( hr ) )
    {
        goto exit;
    }

    // Close the write handle to allow saving the metabase
    DBG_ASSERT( mdhRoot != METADATA_MASTER_ROOT_HANDLE );
    m_pMdObject->ComMDCloseMetaObject( mdhRoot );
    mdhRoot = METADATA_MASTER_ROOT_HANDLE;

    // Save the metabase
    hr = m_pMdObject->ComMDSaveData();
    if ( FAILED( hr ) )
    {
        goto exit;
    }

exit:
    if ( mdhRoot != METADATA_MASTER_ROOT_HANDLE )
    {
        m_pMdObject->ComMDCloseMetaObject( mdhRoot );
        mdhRoot = METADATA_MASTER_ROOT_HANDLE;
    }

    return hr;
}

HRESULT
CADMCOMW::DisableHistory(
    DWORD               *pdwEnableHistoryOld,
    DWORD               *pdwEnableEWROld)
{
    // Locals
    HRESULT             hr = S_OK;
    DWORD               dwEnableHistory = FALSE;
    DWORD               dwEnableEWR = FALSE;
    DWORD               dwT;
    METADATA_HANDLE     mdhRoot = METADATA_MASTER_ROOT_HANDLE;
    METADATA_RECORD     mdrHistory =    {
                                            MD_ROOT_ENABLE_HISTORY,
                                            METADATA_NO_ATTRIBUTES,
                                            IIS_MD_UT_SERVER,
                                            DWORD_METADATA,
                                            sizeof(DWORD),
                                            (BYTE*)&dwEnableHistory,
                                            0
                                        };
    METADATA_RECORD     mdrEWR =        {
                                            MD_ROOT_ENABLE_EDIT_WHILE_RUNNING,
                                            METADATA_NO_ATTRIBUTES,
                                            IIS_MD_UT_SERVER,
                                            DWORD_METADATA,
                                            sizeof(DWORD),
                                            (BYTE*)&dwEnableEWR,
                                            0
                                        };

    // Check agrs
    if ( ( pdwEnableHistoryOld == NULL ) || ( pdwEnableEWROld == NULL ) )
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Intialize
    *pdwEnableHistoryOld = FALSE;
    *pdwEnableEWROld = FALSE;

    hr = m_pMdObject->ComMDOpenMetaObjectW( METADATA_MASTER_ROOT_HANDLE,
                                            L"/LM",
                                            METADATA_PERMISSION_READ,
                                            DEFAULT_SAVE_TIMEOUT,
                                            &mdhRoot );
    if ( hr == HRESULT_FROM_WIN32( ERROR_PATH_NOT_FOUND ) )
    {
        // If /LM is not there don't fail.
        // Treat as if EWR and History are not enabled (*pdwEnableHistoryOld and *pdwEnableEWROld are initialized to FALSE)
        // This can happen only during sysprep.
        hr = S_OK;
        goto exit;
    }
    if ( FAILED( hr ) )
    {
        goto exit;
    }

    // Get EWR
    hr = m_pMdObject->ComMDGetMetaDataW( mdhRoot,
                                         L"",
                                         &mdrEWR,
                                         &dwT );
    if ( hr == MD_ERROR_DATA_NOT_FOUND )
    {
        // If the property is not there don't fail.
        // Treat as if EWR is not enabled (dwEnableEWR is initialized to FALSE)
        hr = S_OK;
    }
    if ( FAILED( hr ) )
    {
        goto exit;
    }

    // Get History
    hr = m_pMdObject->ComMDGetMetaDataW( mdhRoot,
                                         L"",
                                         &mdrHistory,
                                         &dwT );
    if ( hr == MD_ERROR_DATA_NOT_FOUND )
    {
        // If the property is not there don't fail.
        // Treat as if History is not enabled (dwEnableHistory is initialized to FALSE)
        hr = S_OK;
    }
    if ( FAILED( hr ) )
    {
        goto exit;
    }

    // If both are already disabled
    if ( !dwEnableHistory && !dwEnableEWR )
    {
        // No need to change anything in the metabase.
        // No need to change the out parameters,
        // because they are already initialized to FALSE
        // Just exit.
        goto exit;
    }

    // Close the read handle to allow writing in SetHistoryAndEWR
    DBG_ASSERT( mdhRoot != METADATA_MASTER_ROOT_HANDLE );
    m_pMdObject->ComMDCloseMetaObject( mdhRoot );
    mdhRoot = METADATA_MASTER_ROOT_HANDLE;

    // Disable history and ewr
    // They have to be changed in pairs, because EWR turns history on
    hr = SetHistoryAndEWR( FALSE, FALSE );
    if ( FAILED( hr ) )
    {
        goto exit;
    }

    // Return
    *pdwEnableHistoryOld = dwEnableHistory;
    *pdwEnableEWROld = dwEnableEWR;

exit:
    if ( mdhRoot != METADATA_MASTER_ROOT_HANDLE )
    {
        m_pMdObject->ComMDCloseMetaObject( mdhRoot );
        mdhRoot = METADATA_MASTER_ROOT_HANDLE;
    }

    return hr;
}


HRESULT STDMETHODCALLTYPE
CADMCOMW::Backup(
    LPCWSTR             pszMDBackupLocation,
    DWORD               dwMDVersion,
    DWORD               dwMDFlags)
{
    return BackupHelper( pszMDBackupLocation,
                         dwMDVersion,
                         dwMDFlags );
}

HRESULT STDMETHODCALLTYPE
CADMCOMW::BackupWithPasswd(
    LPCWSTR             pszMDBackupLocation,
    DWORD               dwMDVersion,
    DWORD               dwMDFlags,
    LPCWSTR             pszPasswd)
{
    return BackupHelper( pszMDBackupLocation,
                         dwMDVersion,
                         dwMDFlags,
                         pszPasswd );
}

HRESULT STDMETHODCALLTYPE
CADMCOMW::Restore(
    LPCWSTR             pszMDBackupLocation,
    DWORD               dwMDVersion,
    DWORD               dwMDFlags)
{
    return RestoreHelper( pszMDBackupLocation,
                          dwMDVersion,
                          0,
                          NULL,
                          dwMDFlags,
                          RESTORE_BACKUP );
}

HRESULT STDMETHODCALLTYPE
CADMCOMW::RestoreWithPasswd(
    LPCWSTR             pszMDBackupLocation,
    DWORD               dwMDVersion,
    DWORD               dwMDFlags,
    LPCWSTR             pszPasswd)
{
    return RestoreHelper( pszMDBackupLocation,
                          dwMDVersion,
                          0,
                          pszPasswd,
                          dwMDFlags,
                          RESTORE_BACKUP );
}

HRESULT STDMETHODCALLTYPE
CADMCOMW::EnumBackups(
    LPWSTR              pszMDBackupLocation,
    DWORD               *pdwMDVersion,
    PFILETIME           pftMDBackupTime,
    DWORD               dwMDEnumIndex)
{
    HRESULT             hresReturn = S_OK;

    if ( !AdminAclAccessCheck( m_pMdObject,
                               (LPVOID)this,
                               METADATA_MASTER_ROOT_HANDLE,
                               L"",
                               MD_ADMIN_ACL,
                               METADATA_PERMISSION_WRITE,
                               &g_ohMasterRootHandle ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                "[CADMCOMW::EnumBackups AdminAclAccessCheck failed, error %lx\n",
                GetLastError() ));
        hresReturn = RETURNCODETOHRESULT( GetLastError() );
    }
    else
    {
        //
        // call metadata com api
        //

        hresReturn = m_pMdObject->ComMDEnumBackupsW(pszMDBackupLocation,
                                                    pdwMDVersion,
                                                    pftMDBackupTime,
                                                    dwMDEnumIndex);
    }

    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CADMCOMW::DeleteBackup(
    LPCWSTR             pszMDBackupLocation,
    DWORD               dwMDVersion)
{
    HRESULT             hresReturn = S_OK;

    if ( !AdminAclAccessCheck( m_pMdObject,
                               (LPVOID)this,
                               METADATA_MASTER_ROOT_HANDLE,
                               L"",
                               MD_ADMIN_ACL,
                               METADATA_PERMISSION_WRITE,
                               &g_ohMasterRootHandle ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                "[CADMCOMW::DeleteBackup] AdminAclAccessCheck failed, error %lx\n",
                GetLastError() ));
        hresReturn = RETURNCODETOHRESULT( GetLastError() );
    }

    else
    {
        //
        // call metadata com api
        //

        hresReturn = m_pMdObject->ComMDDeleteBackupW(pszMDBackupLocation,
                                                     dwMDVersion);
    }

    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CADMCOMW::Export(
    LPCWSTR             i_wszPasswd,
    LPCWSTR             i_wszFileName,
    LPCWSTR             i_wszSourcePath,
    DWORD               i_dwMDFlags)
{
    HRESULT             hr           = S_OK;
    DWORD               dwError;
    METADATA_HANDLE     mdh          = METADATA_MASTER_ROOT_HANDLE;
    METADATA_HANDLE     mdhActual    = METADATA_MASTER_ROOT_HANDLE;
    COpenHandle*        pohActual    = NULL;
    STRAU               strFileName;

    //
    // parameter validation
    //
    if ( ( i_wszFileName == NULL ) || ( *i_wszFileName == L'\0' ) ||
         ( i_wszSourcePath == NULL ) )
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    hr = CoImpersonateClient();
    if ( FAILED( hr ) )
    {
        goto exit;
    }

    // IVANPASH 598894 (SCR)
    // Restrict the access to Export only to administrators
    if ( !AdminAclAccessCheck( m_pMdObject,
                               (LPVOID)this,
                               METADATA_MASTER_ROOT_HANDLE,
                               L"",
                               MD_ADMIN_ACL,
                               METADATA_PERMISSION_WRITE,
                               &g_ohMasterRootHandle ) )
    {
        dwError = GetLastError();
        DBGPRINTF(( DBG_CONTEXT,
                    "[CADMCOMW::Export] AdminAclAccessCheck failed, error %lx\n",
                    dwError ));
        hr = RETURNCODETOHRESULT( dwError );
        goto exit;
    }

    hr = OpenKeyHelper( METADATA_MASTER_ROOT_HANDLE,
                        i_wszSourcePath,
                        METADATA_PERMISSION_READ,
                        DEFAULT_SAVE_TIMEOUT,
                        &mdh);
    if ( FAILED( hr ) )
    {
        goto exit;
    }

    //
    // pohActual refCount = 2 after Lookup.
    //
    dwError = Lookup(mdh, &mdhActual, &pohActual);
    if ( dwError != ERROR_SUCCESS )
    {
        hr = RETURNCODETOHRESULT( dwError );
        DBG_ASSERT( pohActual == NULL );
        //
        // Yes, an open key does not get closed, but Lookup really should
        // not fail if mdh is a valid key.
        // Also CloseKey would do exactly the same Lookup call and will fail too.
        //
        goto exit;
    }

    //
    // Move refCount down to 1.
    //
    pohActual->Release(this);

    if( !AdminAclAccessCheck( m_pMdObject,
                              (LPVOID)this,
                              mdh,
                              L"",
                              MD_ADMIN_ACL,
                              METADATA_PERMISSION_WRITE,
                              pohActual ) )
    {
        dwError = GetLastError();
        DBGPRINTF(( DBG_CONTEXT,
                    "[CADMCOMW::Export] AdminAclAccessCheck failed, error %lx\n",
                    dwError ));
        hr = RETURNCODETOHRESULT( dwError );
        goto exit;
    }

    // IVANPASH 598894 (SCR)
    // Prepend the file name with \\?\ (or \\?\UNC\) to prevent canonicalization
    hr = MakePathCanonicalizationProof( i_wszFileName, FALSE, &strFileName );
    if ( FAILED( hr ) )
    {
        goto exit;
    }
    // Don't use i_wszFileName any more
    i_wszFileName = NULL;

    // call metadata com api
    hr = m_pMdObject->ComMDExportW( mdhActual,
                                    i_wszPasswd,
                                    strFileName.QueryStrW(),
                                    i_wszSourcePath,
                                    i_dwMDFlags);
    if ( FAILED( hr ) )
    {
        goto exit;
    }

exit:
    // At this moment mdh can actually contain a valid CMDCOMW handle.
    // It is not explicitely closed, because the code bellow actually does
    // the same as CloseKey(mdh).

    if ( pohActual )
    {
        // close key
        if ( mdhActual != METADATA_MASTER_ROOT_HANDLE )
        {
            // call metadata com api
            m_pMdObject->ComMDCloseMetaObject( mdhActual );
        }

        // Remove node from handle table
        pohActual->Release(this);
        pohActual=NULL;
    }

    return hr;
}


HRESULT STDMETHODCALLTYPE
CADMCOMW::Import(
    LPCWSTR             i_wszPasswd,
    LPCWSTR             i_wszFileName,
    LPCWSTR             i_wszSourcePath,
    LPCWSTR             i_wszDestPath,
    DWORD               i_dwMDFlags)
/*++

Synopsis:

Arguments: [i_wszPasswd] -
           [i_wszFileName] -
           [i_wszSourcePath] - Absolute metabase path
           [i_wszDestPath] -   Absolute metabase path
           [i_dwMDFlags] -

Return Value:

--*/
{
    HRESULT             hr           = S_OK;
    DWORD               dwError;
    METADATA_HANDLE     mdh          = 0;
    METADATA_HANDLE     mdhActual    = 0;
    COpenHandle*        pohActual    = NULL;
    LPWSTR              wszDeepest   = NULL;
    LONG                cchDeepest   = 0;
    LPWSTR              wszEnd       = NULL;
    LONG                idx          = 0;
    WCHAR               wszKeyType[METADATA_MAX_STRING_LEN] = {0};
    DWORD               dwRequiredSize = 0;
    METADATA_RECORD     mr           =
    {
        MD_KEY_TYPE,
        METADATA_NO_ATTRIBUTES,
        IIS_MD_UT_SERVER,
        STRING_METADATA,
        METADATA_MAX_STRING_LEN*sizeof(WCHAR),
        (LPBYTE)wszKeyType,
        0
    };
    STRAU               strFileName;

    //
    // parameter validation
    //
    if ( ( i_wszFileName == NULL ) || ( *i_wszFileName == L'\0' ) ||
         ( i_wszSourcePath == NULL ) ||
         ( i_wszDestPath == NULL ) )
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    if (i_wszPasswd == NULL)
    {
        i_wszPasswd = L"";
    }

    hr = CoImpersonateClient();
    if ( FAILED( hr ) )
    {
        goto exit;
    }

    // IVANPASH 598894 (SCR)
    // Restrict the access to Import only to administrators
    if ( !AdminAclAccessCheck( m_pMdObject,
                               (LPVOID)this,
                               METADATA_MASTER_ROOT_HANDLE,
                               L"",
                               MD_ADMIN_ACL,
                               METADATA_PERMISSION_WRITE,
                               &g_ohMasterRootHandle ) )
    {
        dwError = GetLastError();
        DBGPRINTF(( DBG_CONTEXT,
                    "[CADMCOMW::Import] AdminAclAccessCheck failed, error %lx\n",
                    dwError ));
        hr = RETURNCODETOHRESULT( dwError );
        goto exit;
    }

    //
    // Copy i_wszDestPath to wszDeepest
    // Remove trailing slashes
    //
    cchDeepest = (LONG)wcslen(i_wszDestPath);
    wszDeepest = new WCHAR[1+cchDeepest];
    if(!wszDeepest)
    {
        hr = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        goto exit;
    }
    memcpy(wszDeepest, i_wszDestPath, sizeof(WCHAR)*(cchDeepest+1));

    while( cchDeepest > 0 && IS_MD_PATH_DELIM(wszDeepest[cchDeepest-1]) )
    {
        cchDeepest--;
    }

    //
    // Open the deepest level key possible
    //
    wszEnd = wszDeepest + cchDeepest;
    for(idx = cchDeepest; idx >= 0; idx--)
    {
        if(idx == 0 || idx == cchDeepest || IS_MD_PATH_DELIM(*wszEnd))
        {
            *wszEnd = L'\0';
            hr = OpenKeyHelper(
                    METADATA_MASTER_ROOT_HANDLE,
                    wszDeepest,
                    METADATA_PERMISSION_WRITE | METADATA_PERMISSION_READ,
                    DEFAULT_SAVE_TIMEOUT,
                    &mdh);
            if( FAILED(hr) &&
                hr != RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND) )
            {
                goto exit;
            }
            else if(SUCCEEDED(hr))
            {
                break;
            }
        }
        wszEnd--;
    }
    if(FAILED(hr))
    {
        goto exit;
    }

    //
    // If we are here, we now have an Open metabase handle
    //

    dwError = Lookup(mdh, &mdhActual, &pohActual);
    hr = RETURNCODETOHRESULT(dwError);
    if(FAILED(hr))
    {
        //
        // Yes, an open key does not get closed, but Lookup really should
        // not fail if mdh is a valid key.
        // Also CloseKey would do exactly the same Lookup call and will fail too.
        //
        goto exit;
    }
    pohActual->Release(this);           // Decrements refcount from 2 to 1.

    if( !AdminAclAccessCheck( m_pMdObject,
                              (LPVOID)this,
                              mdh,
                              L"",
                              MD_ADMIN_ACL,
                              METADATA_PERMISSION_WRITE | METADATA_PERMISSION_READ,
                              pohActual ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                "[CADMCOMW::Import] AdminAclAccessCheck failed, error %lx\n",
                GetLastError() ));
        hr = RETURNCODETOHRESULT( GetLastError() );
        goto exit;
    }

    //
    // Get the keytype
    // If the node does not exist, or node exists but keytype doesn't, we
    // will not set wszKeytype and hence ComMDImport will not attempt to match
    // the source and dest keytype
    //
    hr = m_pMdObject->ComMDGetMetaDataW(
            mdhActual,
            i_wszDestPath+idx,
            &mr,
            &dwRequiredSize);
    if(hr == RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND))
    {
        hr = S_OK;
    }
    else if(hr == MD_ERROR_DATA_NOT_FOUND)
    {
        hr = S_OK;
    }
    if(FAILED(hr))
    {
        DBGPRINTF((DBG_CONTEXT, "Error trying to retrieve keytype for %ws\n", i_wszDestPath+idx));
        goto exit;
    }

    // IVANPASH 598894 (SCR)
    // Prepend the file name with \\?\ (or \\?\UNC\) to prevent canonicalization
    hr = MakePathCanonicalizationProof( i_wszFileName, TRUE, &strFileName );
    if ( FAILED( hr ) )
    {
        goto exit;
    }
    // Don't use i_wszFileName any more
    i_wszFileName = NULL;

    //
    // Call Import
    //
    hr = m_pMdObject->ComMDImportW(
        mdhActual,
        i_wszDestPath+idx,
        wszKeyType,
        i_wszPasswd,
        strFileName.QueryStrW(),
        i_wszSourcePath,
        i_dwMDFlags);
    if(FAILED(hr))
    {
        goto exit;
    }

exit:
    if(pohActual != NULL)
    {
        //
        // Close Key
        //
        m_pMdObject->ComMDCloseMetaObject( mdhActual );

        pohActual->Release(this);
        pohActual = NULL;
    }

    if ( wszDeepest )
    {
        delete [] wszDeepest;
        wszDeepest = NULL;
    }

    return hr;
}

HRESULT STDMETHODCALLTYPE
CADMCOMW::RestoreHistory(
    LPCWSTR             pszMDHistoryLocation,
    DWORD               dwMDMajorVersion,
    DWORD               dwMDMinorVersion,
    DWORD               dwMDFlags)
{
    HRESULT             hresReturn = S_OK;

    if( (dwMDFlags & ~MD_HISTORY_LATEST) != 0 &&
        dwMDFlags != 0 )
    {
        return HRESULT_FROM_WIN32(ERROR_INVALID_FLAGS);
    }

    if( (dwMDFlags & MD_HISTORY_LATEST) &&
        (dwMDMajorVersion != 0 || dwMDMinorVersion != 0) )
    {
        return E_INVALIDARG;
    }

    //
    // parameter validation done in here.
    //
    hresReturn = RestoreHelper(pszMDHistoryLocation,
        dwMDMajorVersion,
        dwMDMinorVersion,
        NULL,
        dwMDFlags,
        RESTORE_HISTORY);

    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CADMCOMW::EnumHistory(
    LPWSTR              io_wszMDHistoryLocation,
    DWORD               *o_pdwMDMajorVersion,
    DWORD               *o_pdwMDMinorVersion,
    PFILETIME           o_pftMDHistoryTime,
    DWORD               i_dwMDEnumIndex)
{
    HRESULT             hresReturn = S_OK;

    if (io_wszMDHistoryLocation == NULL ||
        o_pdwMDMajorVersion == NULL ||
        o_pdwMDMinorVersion == NULL ||
        o_pftMDHistoryTime == NULL)
    {
        return E_INVALIDARG;
    }

    if ( !AdminAclAccessCheck( m_pMdObject,
                               (LPVOID)this,
                               METADATA_MASTER_ROOT_HANDLE,
                               L"",
                               MD_ADMIN_ACL,
                               METADATA_PERMISSION_WRITE,
                               &g_ohMasterRootHandle ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                "[CADMCOMW::EnumHistory AdminAclAccessCheck failed, error %lx\n",
                GetLastError() ));
        hresReturn = RETURNCODETOHRESULT( GetLastError() );
    }
    else
    {
        //
        // call metadata com api
        //

        hresReturn = m_pMdObject->ComMDEnumHistoryW(io_wszMDHistoryLocation,
                                                    o_pdwMDMajorVersion,
                                                    o_pdwMDMinorVersion,
                                                    o_pftMDHistoryTime,
                                                    i_dwMDEnumIndex);
    }

    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CADMCOMW::GetChildPaths(
    METADATA_HANDLE     hMDHandle,
    LPCWSTR             pszMDPath,
    DWORD               cchMDBufferSize,
    WCHAR               *pszBuffer,
    DWORD               *pcchMDRequiredBufferSize)
/*++

Routine Description:

    Retrieves all child keys of a given path from a given handle

Arguments:

    hMDHandle - open handle

    pszMDPath - path of the meta object with which this data is associated

    cchMDBufferSize - sizeof buffer passed in, in wchars

    pszBuffer - buffer, allocated by caller, that result is placed into

    pcchMDRequiredBufferSize - required size, filled in only if buffer is insufficient

Return Value:

    Status.  s_ok on success.

--*/
{
    HRESULT             hr = S_OK;
    METADATA_HANDLE     hActualHandle;
    BOOL                fSecure;

    //
    // lookup and access check
    //

    hr = LookupAndAccessCheck(hMDHandle,
        &hActualHandle,
        pszMDPath,
        0,
        METADATA_PERMISSION_READ,
        &fSecure);

    if (FAILED(hr))
    {
        goto done;
    }

    DBG_ASSERT( NULL != m_pMdObject3 );

    hr = m_pMdObject3->ComMDGetChildPathsW(hActualHandle,
                                          pszMDPath,
                                          cchMDBufferSize,
                                          pszBuffer,
                                          pcchMDRequiredBufferSize);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;

done:
    return hr;
}

HRESULT
CADMCOMW::AddKeyHelper(
    IN METADATA_HANDLE  hMDHandle,
    IN LPCWSTR          pszMDPath)
/*++

Routine Description:

    Add meta object and adds it to the list of child objects for the object
    specified by Path.

Arguments:

    hMDHandle - open handle

    pszMDPath - path of the object to be added

Return Value:

    Status.

--*/
{
    HRESULT             hresReturn = S_OK;
    METADATA_HANDLE     hActualHandle;

    if ((pszMDPath == NULL) ||
             (*pszMDPath == (WCHAR)'\0'))
    {
        hresReturn = E_INVALIDARG;
    }
    else
    {
        //
        // lookup and access check
        //

        hresReturn = LookupAndAccessCheck(hMDHandle,
                                          &hActualHandle,
                                          pszMDPath,
                                          0,
                                          METADATA_PERMISSION_WRITE);
        if (SUCCEEDED(hresReturn))
        {

            //
            // call metadata com api
            //

            hresReturn = m_pMdObject->ComMDAddMetaObjectW( hActualHandle,
                                                           pszMDPath );
        }
    }

    return hresReturn;
}


HRESULT
CADMCOMW::OpenKeyHelper(
    METADATA_HANDLE     hMDHandle,
    LPCWSTR             pszMDPath,
    DWORD               dwMDAccessRequested,
    DWORD               dwMDTimeOut,
    PMETADATA_HANDLE    phMDNewHandle)
/*++

Routine Description:

    Opens a meta object for read and/or write access.
    - This is used by Export.

Arguments:

    hMDHandle - open handle

    pszMDPath - path of the object to be opened

    dwMDAccessRequested - permissions requested

    dwMDTimeOut - time to block waiting for open to succeed, in miliseconds.

    phMDNewHandle - handle to be passed to other MD routines

Return Value:

    Status.

--*/
{
    HRESULT             hr = S_OK;
    DWORD               dwError;
    BOOL                fRet;
    METADATA_HANDLE     hNewHandle = METADATA_MASTER_ROOT_HANDLE;
    METADATA_HANDLE     hActualHandle = METADATA_MASTER_ROOT_HANDLE;
    COpenHandle         *pohParent = NULL;

    // Check args
    if ( ( phMDNewHandle == NULL ) ||
         ( ( dwMDAccessRequested & ( METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE ) ) == 0 ) ||
         ( ( dwMDAccessRequested & ~( METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE ) ) != 0 ) ||
         ( ( pszMDPath != NULL ) && ( wcsstr( pszMDPath, L"<nsepm>" ) != NULL ) ) )
    {
        //
        // <nsepm> used to be magic name for the Name Space Extension access
        // It was removed for IIS6 but to prevent legacy applications
        // to write obsolete and unusable data to metabase deny access to path
        // containing <nsepm>
        //

        hr = E_INVALIDARG;
        goto exit;
    }

    //
    // Map Admin Handle to Actual Handle
    //

    //
    // This Addrefs pohParent, which makes sure it doesn't do away
    // pohParent is needed by AddNode
    //
    dwError = Lookup( hMDHandle,
                      &hActualHandle,
                      &pohParent );

    if( dwError != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( dwError );
        goto exit;
    }

    // Check access
    fRet = AdminAclAccessCheck( m_pMdObject,
                                this,
                                hMDHandle,
                                pszMDPath,
                                0,
                                dwMDAccessRequested,
                                pohParent );
    if ( !fRet )
    {
        dwError = GetLastError();

        if ( dwError != ERROR_ACCESS_DENIED )
        {
            hr = HRESULT_FROM_WIN32( dwError );
            goto exit;
        }

        // If failed with access denied for writing or writing+reading
        if ( ( dwMDAccessRequested & METADATA_PERMISSION_WRITE ) != 0 )
        {
            // Retry checking access for writing MD_ADMIN_ACL
            // AdminAclAccessCheck will try 1st to check MD_ACR_RESTRICTED_WRITE and than for MD_ACR_WRITE_DAC
            fRet = AdminAclAccessCheck( m_pMdObject,
                                        this,
                                        hMDHandle,
                                        pszMDPath,
                                        MD_ADMIN_ACL,
                                        dwMDAccessRequested,
                                        pohParent );
        }
        else
        {
            // If failed with access denied for reading (and the write bit is not set)
            if ( dwMDAccessRequested == METADATA_PERMISSION_READ )
            {
                // Retry checking access for enum only
                // AdminAclAccessCheck internally already check for both MD_ACR_UNSECURE_PROPS_READ and MD_ACR_READ
                fRet = AdminAclAccessCheck( m_pMdObject,
                                            this,
                                            hMDHandle,
                                            pszMDPath,
                                            AAC_ENUM_KEYS,
                                            dwMDAccessRequested,
                                            pohParent );
            }
        }
    }

    if ( !fRet )
    {
        dwError = GetLastError();
        hr = HRESULT_FROM_WIN32( dwError );
        goto exit;
    }

    //
    // call metadata com api
    //
    hr = m_pMdObject->ComMDOpenMetaObjectW( hActualHandle,
                                            pszMDPath,
                                            dwMDAccessRequested,
                                            dwMDTimeOut,
                                            &hNewHandle );
    if( FAILED( hr ) )
    {
        goto exit;
    }

    // Add the opened handle to table
    hr = AddNode( hNewHandle,
                  pohParent,
                  phMDNewHandle,
                  pszMDPath );
    if( FAILED( hr ) )
    {
        goto exit;
    }

    // Don't close the metadata handle
    hNewHandle = METADATA_MASTER_ROOT_HANDLE;

exit:

    if ( hNewHandle != METADATA_MASTER_ROOT_HANDLE )
    {
        m_pMdObject->ComMDCloseMetaObject( hNewHandle );
        hNewHandle = METADATA_MASTER_ROOT_HANDLE;
    }
    if ( pohParent != NULL )
    {
        pohParent->Release(this);
        pohParent = NULL;
    }

    return hr;
}


DWORD
CADMCOMW::Lookup(
    IN METADATA_HANDLE  hHandle,
    OUT METADATA_HANDLE *phActualHandle,
    OUT COpenHandle     **ppohHandle)
{
    HANDLE_TABLE        *phtNode;
    DWORD               dwReturn = ERROR_INVALID_HANDLE;

    if( hHandle == METADATA_MASTER_ROOT_HANDLE )
    {
        *phActualHandle = g_MasterRoot.hActualHandle;
        if (ppohHandle != NULL)
        {
            *ppohHandle = g_MasterRoot.pohHandle;
            (*ppohHandle)->AddRef();
        }
        dwReturn = ERROR_SUCCESS;
    }
    else
    {
        m_LockHandleResource.ReadLock();

        for( phtNode = m_hashtab[(DWORD)hHandle % HASHSIZE]; phtNode != NULL;
             phtNode = phtNode->next )
            {

            if( phtNode->hAdminHandle == hHandle )
            {
                *phActualHandle = phtNode->hActualHandle;
                if (ppohHandle != NULL)
                {
                    *ppohHandle = phtNode->pohHandle;
                    (*ppohHandle)->AddRef();
                }
                dwReturn = ERROR_SUCCESS;
                break;
            }
        }

        m_LockHandleResource.ReadUnlock();
    }

    return dwReturn;
}

VOID
CADMCOMW::DisableAllHandles( )
{
    HANDLE_TABLE        *phtNode;
    DWORD               i;

    //
    // At this point, all metadata handles should be closed because a retore
    // just happened. So don't need to close these handles.
    //

    //
    // Can't just delete them, becuase of syncronization problems
    // with CloseKey and Lookup. Set the hande to an invalid value
    // So Lookup won't use them.
    //

    m_LockHandleResource.WriteLock();

    for( i = 0; i < HASHSIZE; i++ )
    {
        for( phtNode = m_hashtab[i]; phtNode != NULL; phtNode = phtNode->next )
        {
            phtNode->hAdminHandle = INVALID_ADMINHANDLE_VALUE;
        }
    }

    m_LockHandleResource.WriteUnlock();
}

HRESULT
CADMCOMW::LookupAndAccessCheck(
    IN METADATA_HANDLE  hHandle,
    OUT METADATA_HANDLE *phActualHandle,
    IN LPCWSTR          pszPath,
    IN DWORD            dwId,           // check for MD_ADMIN_ACL, must have special right to write them
    IN DWORD            dwAccess,       // METADATA_PERMISSION_*
    OUT LPBOOL          pfEnableSecureAccess)
{
    DWORD               dwReturn = ERROR_SUCCESS;
    COpenHandle         *pohParent;

    //
    // Map Admin Handle to Actual Handle
    //

    //
    // This Addrefs pohParent, which makes sure it doesn't go away
    // until AdminAclAccessCheck is done
    //

    dwReturn = Lookup( hHandle,
                       phActualHandle,
                       &pohParent);

    if (dwReturn == ERROR_SUCCESS)
    {
        if (!AdminAclAccessCheck(m_pMdObject,
                                 (LPVOID)this,
                                 hHandle,
                                 pszPath,
                                 dwId,
                                 dwAccess,
                                 pohParent,
                                 pfEnableSecureAccess))
        {
            dwReturn = GetLastError();
        }
        pohParent->Release(this);
    }

    return RETURNCODETOHRESULT(dwReturn);
}

DWORD
CADMCOMW::LookupActualHandle(
    IN METADATA_HANDLE  hHandle)
{
    HANDLE_TABLE        *phtNode;
    DWORD               i;
    DWORD               dwReturn = ERROR_INVALID_HANDLE;

    m_LockHandleResource.ReadLock();

    for( i = 0; (i < HASHSIZE) && (dwReturn != ERROR_SUCCESS); i++ )
    {
        for( phtNode = m_hashtab[i]; (phtNode != NULL) && (dwReturn != ERROR_SUCCESS); phtNode = phtNode->next )
        {
            if( phtNode->hActualHandle == hHandle )
            {
                dwReturn = ERROR_SUCCESS;
            }
        }
    }

    m_LockHandleResource.ReadUnlock();

    return dwReturn;
}

HRESULT
CADMCOMW::AddNode(
    METADATA_HANDLE     hActualHandle,
    COpenHandle         *pohParentHandle,
    PMETADATA_HANDLE    phAdminHandle,
    LPCWSTR             pszPath)
{
    HRESULT             hresReturn = S_OK;
    HANDLE_TABLE        *phtNode = (HANDLE_TABLE *)LocalAlloc(LMEM_FIXED, sizeof(*phtNode));
    DWORD               hashVal;
    COpenHandle         *pohHandle = new COpenHandle;

    if ((phtNode == NULL) ||
        (pohHandle == NULL))
    {
        hresReturn = E_OUTOFMEMORY;
        if( phtNode )
        {
            LocalFree(phtNode);
        }
        if( pohHandle )
        {
            delete pohHandle;
        }
    }
    else
    {

        m_LockHandleResource.WriteLock();

        hresReturn = pohHandle->Init( m_dwHandleValue,
                                      pszPath,
                                      pohParentHandle->GetPath() );
        if (FAILED(hresReturn))
        {
            LocalFree(phtNode);
            delete pohHandle;
        }
        else
        {
            phtNode->pohHandle = pohHandle;
            phtNode->hAdminHandle = m_dwHandleValue;
            *phAdminHandle = m_dwHandleValue++;
            phtNode->hActualHandle = hActualHandle;
            hashVal = (phtNode->hAdminHandle) % HASHSIZE;
            phtNode->next = m_hashtab[hashVal];
            m_hashtab[hashVal] = phtNode;
        }

        m_LockHandleResource.WriteUnlock();
    }

    return hresReturn;
}

DWORD
CADMCOMW::DeleteNode(
    METADATA_HANDLE     hHandle)
{
    HANDLE_TABLE        *phtNode;
    HANDLE_TABLE        *phtDelNode;
    DWORD               HashValue = (DWORD)hHandle % HASHSIZE;

    if( hHandle == METADATA_MASTER_ROOT_HANDLE )
    {
        return ERROR_SUCCESS;
    }

    m_LockHandleResource.WriteLock();

    phtNode = m_hashtab[HashValue];

    //
    // check single node linked list
    //

    if( phtNode->hAdminHandle == hHandle )
    {
        m_hashtab[HashValue] = phtNode->next;
        delete phtNode->pohHandle;
        LocalFree(phtNode);
    }
    else
    {
        for( ; phtNode != NULL; phtNode = phtNode->next )
        {
            phtDelNode = phtNode->next;
            if( phtDelNode != NULL )
            {
                if( phtDelNode->hAdminHandle == hHandle )
                {
                    phtNode->next = phtDelNode->next;
                    delete phtDelNode->pohHandle;
                    LocalFree(phtDelNode);
                    break;
                }
            }
        }
    }

    m_LockHandleResource.WriteUnlock();

    return ERROR_SUCCESS;
}
//---------------

/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   CADMCOMW::NotifySinks

  Summary:  Internal utility method of this COM object used to fire event
            notification calls to all listening connection sinks in the
            client.

  Args:     PAPER_EVENT PaperEvent
              Type of notification event.
            SHORT nX
              X cordinate. Value is 0 unless event needs it.
            SHORT nY
              Y cordinate. Value is 0 unless event needs it.
            SHORT nInkWidth
              Ink Width. Value is 0 unless event needs it.
            SHORT crInkColor
              COLORREF RGB color value. Value is 0 unless event needs it.

  Modifies: ...

  Returns:  HRESULT
              Standard OLE result code. NOERROR for success.
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/

// Initialize class static members
NOTIFY_CONTEXT *    NOTIFY_CONTEXT::s_pCurrentlyWorkingOn = NULL;
CReaderWriterLock3  NOTIFY_CONTEXT::s_LockCurrentlyWorkingOn;
LIST_ENTRY          NOTIFY_CONTEXT::s_listEntry;
CRITICAL_SECTION    NOTIFY_CONTEXT::s_critSec;
BOOL                NOTIFY_CONTEXT::s_fInitializedCritSec = FALSE;
HANDLE              NOTIFY_CONTEXT::s_hShutdown = NULL;
HANDLE              NOTIFY_CONTEXT::s_hDataAvailable = NULL;
HANDLE              NOTIFY_CONTEXT::s_hThread = NULL;
DWORD               NOTIFY_CONTEXT::s_dwThreadId = 0;

HRESULT
CADMCOMW::NotifySinks(
    METADATA_HANDLE     hMDHandle,
    DWORD               dwMDNumElements,
    MD_CHANGE_OBJECT_W  pcoChangeList[],
    BOOL                bIsMainNotification)
{
    HRESULT             hr = S_OK;

    // if the object is terminated, or calling sinks is disabled or IISADMIN is shutting
    // down ignore the notification and return S_OK to the caller.
    if ( m_bTerminated || sm_fShutdownInProgress )
    {
        goto done;
    }

    //
    // if the meta handle is for this object, return S_OK to
    // the caller (admin's sink).
    //
    if( bIsMainNotification && ( LookupActualHandle( hMDHandle ) == ERROR_SUCCESS ) )
    {
        goto done;
    }

    // Any listeners registered for notifications?
    hr = m_ConnectionPoint.ListenersPresent();
    if ( hr != S_OK )
    {
        // We are going to ingore this notification, but return S_OK to the caller.
        hr = S_OK;
        goto done;
    }

    // Enqueue the notification, which will AddRef this.
    hr = NOTIFY_CONTEXT::CreateNewContext( this,
                                           hMDHandle,
                                           dwMDNumElements,
                                           pcoChangeList,
                                           bIsMainNotification );
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;

done:
    return hr;
}

NOTIFY_CONTEXT::NOTIFY_CONTEXT() :
    _dwSignature(NOTIFY_CONTEXT_SIGNATURE),
    _pCADMCOMW(NULL),
    _dwMDNumElements(0),
    _pcoChangeList(NULL),
    _bIsMainNotification(FALSE)
{
    InitializeListHead(&_listEntry);
}

NOTIFY_CONTEXT::~NOTIFY_CONTEXT()
{
    InitializeListHead(&_listEntry);
    _dwSignature = NOTIFY_CONTEXT_SIGNATURE_FREE;

    s_LockCurrentlyWorkingOn.ReadLock();
    if ( this == s_pCurrentlyWorkingOn )
    {
        s_LockCurrentlyWorkingOn.ConvertSharedToExclusive();
        if ( this == s_pCurrentlyWorkingOn )
        {
            s_pCurrentlyWorkingOn = NULL;
        }
        s_LockCurrentlyWorkingOn.WriteUnlock();
    }
    else
    {
        s_LockCurrentlyWorkingOn.ReadUnlock();
    }

    if (_pCADMCOMW)
    {
        _pCADMCOMW->Release();
        _pCADMCOMW = NULL;
    }

    if (_pcoChangeList)
    {
        for (DWORD i = 0; i < _dwMDNumElements; i++)
        {
            delete [] _pcoChangeList[i].pszMDPath;
            _pcoChangeList[i].pszMDPath = NULL;
            _pcoChangeList[i].dwMDChangeType = 0;
            _pcoChangeList[i].dwMDNumDataIDs = 0;
            delete [] _pcoChangeList[i].pdwMDDataIDs;
            _pcoChangeList[i].pdwMDDataIDs = NULL;
        }
    }
    _dwMDNumElements = 0;
    delete [] _pcoChangeList;
    _pcoChangeList = NULL;

    _bIsMainNotification = FALSE;
}

//static
HRESULT
NOTIFY_CONTEXT::CreateNewContext(
    CADMCOMW            *pCADMCOMW,
    METADATA_HANDLE     ,
    DWORD               dwMDNumElements,
    MD_CHANGE_OBJECT_W  *pcoChangeList,
    BOOL                bIsMainNotification)
{
    HRESULT             hr = S_OK;
    BOOL                fRet = FALSE;
    NOTIFY_CONTEXT      *pContext = NULL;

    DBG_ASSERT( pCADMCOMW != NULL );
    if ( pCADMCOMW == NULL )
    {
        hr = E_INVALIDARG;
        goto done;
    }

    pContext = new NOTIFY_CONTEXT;
    if (NULL == pContext)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }
    pContext->_pCADMCOMW = pCADMCOMW;
    pContext->_pCADMCOMW->AddRef();

    pContext->_dwMDNumElements = dwMDNumElements;
    pContext->_bIsMainNotification = bIsMainNotification;

    pContext->_pcoChangeList = new MD_CHANGE_OBJECT_W[dwMDNumElements];
    if (NULL == pContext->_pcoChangeList)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }
    ZeroMemory(pContext->_pcoChangeList, dwMDNumElements * sizeof(MD_CHANGE_OBJECT_W));

    for (DWORD i = 0; i < dwMDNumElements; i++)
    {
        DWORD dwLength = (DWORD)wcslen(pcoChangeList[i].pszMDPath);
        pContext->_pcoChangeList[i].pszMDPath = new WCHAR[dwLength + 1];
        if (NULL == pContext->_pcoChangeList[i].pszMDPath)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
        wcscpy(pContext->_pcoChangeList[i].pszMDPath, pcoChangeList[i].pszMDPath);

        pContext->_pcoChangeList[i].dwMDChangeType = pcoChangeList[i].dwMDChangeType;
        pContext->_pcoChangeList[i].dwMDNumDataIDs = pcoChangeList[i].dwMDNumDataIDs;
        pContext->_pcoChangeList[i].pdwMDDataIDs = new DWORD[pContext->_pcoChangeList[i].dwMDNumDataIDs];
        if (NULL == pContext->_pcoChangeList[i].pdwMDDataIDs)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
        memcpy(pContext->_pcoChangeList[i].pdwMDDataIDs,
               pcoChangeList[i].pdwMDDataIDs,
               sizeof(DWORD) * pContext->_pcoChangeList[i].dwMDNumDataIDs);
    }


    EnterCriticalSection(&s_critSec);
    InsertTailList(&s_listEntry, &pContext->_listEntry);
    LeaveCriticalSection(&s_critSec);

    fRet = SetEvent(s_hDataAvailable);
    if (FALSE == fRet)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto done;
    }

    hr = S_OK;
done:
    if (FAILED(hr))
    {
        delete pContext;
    }
    return hr;
}

//static
HRESULT
NOTIFY_CONTEXT::Initialize()
{
    HRESULT             hr = S_OK;
    BOOL                fRet = FALSE;

    s_hShutdown = NULL;
    s_hDataAvailable = NULL;
    s_fInitializedCritSec = FALSE;

    InitializeListHead(&s_listEntry);

    fRet = InitializeCriticalSectionAndSpinCount(&s_critSec, 0x80000001);
    if (FALSE == fRet)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto done;
    }

    s_fInitializedCritSec = TRUE;

    s_hShutdown = CreateEvent(NULL, // security descrpitor
                              TRUE, // manual reset
                              FALSE, // initial state
                              NULL); // name
    if (NULL == s_hShutdown)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto done;
    }

    s_hDataAvailable = CreateEvent(NULL,  // security descriptor
                                   FALSE, // auto reset
                                   FALSE, // initial state
                                   NULL); // name
    if (NULL == s_hDataAvailable)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto done;
    }

    s_hThread = CreateThread(NULL,
        0,
        NotifyThreadProc,
        NULL,
        0,
        &s_dwThreadId);
    if (NULL == s_hThread)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto done;
    }

    hr = S_OK;

done:
    return hr;
}

//static
VOID
NOTIFY_CONTEXT::RemoveWorkFor(
    CADMCOMW            *pCADMCOMW,
    BOOL                fWaitForCurrent)
{
    LIST_ENTRY          ListToDelete;
    LIST_ENTRY          *ple;
    NOTIFY_CONTEXT      *pContext;
    LIST_ENTRY          *pleNext;
    CADMCOMW            *pCurrentCADMCOMW;

    if ( !s_fInitializedCritSec )
    {
        return;
    }

    InitializeListHead( &ListToDelete );

    EnterCriticalSection(&s_critSec);

    // eat all remaining data
    ple = s_listEntry.Flink;
    while ( ple != &s_listEntry )
    {
        pleNext = ple->Flink;

        pContext = NOTIFY_CONTEXTFromListEntry( ple );
        if ( pContext->_pCADMCOMW == pCADMCOMW )
        {
            RemoveEntryList( ple );
            InitializeListHead( ple );
            InsertTailList( &ListToDelete, ple );
        }
        pContext = NULL;

        ple = pleNext;
    }

    LeaveCriticalSection(&s_critSec);

    // Delete all collected notification contexts
    ple = ListToDelete.Flink;
    while ( ple != &ListToDelete )
    {
        pleNext = ple->Flink;

        RemoveEntryList( ple );
        InitializeListHead( ple );

        pContext = NOTIFY_CONTEXTFromListEntry( ple );
        delete pContext;
        pContext = NULL;

        ple = pleNext;
    }

    if ( fWaitForCurrent && ( s_dwThreadId != GetCurrentThreadId() ) )
    {
        do
        {
            s_LockCurrentlyWorkingOn.ReadLock();
            if ( s_pCurrentlyWorkingOn != NULL )
            {
                pCurrentCADMCOMW = s_pCurrentlyWorkingOn->_pCADMCOMW;
            }
            else
            {
                pCurrentCADMCOMW = NULL;
            }
            s_LockCurrentlyWorkingOn.ReadUnlock();

            // waiting for the NOTIFY_CONTEXT currently being processed to be
            // released so we can return and guarantee that no more work is queued.
            if ( pCADMCOMW == pCurrentCADMCOMW )
            {
                Sleep(100);
            }
        }
        while ( pCADMCOMW == pCurrentCADMCOMW );
    }

}

//static
VOID
NOTIFY_CONTEXT::RemoveAllWork( VOID )
{
    LIST_ENTRY          * ple;
    NOTIFY_CONTEXT      * pContext;
    LIST_ENTRY          * pleNext;
    LIST_ENTRY          ListToDelete;
    BOOL                fShutdownNotifications = FALSE;

    if ( !s_fInitializedCritSec )
    {
        return;
    }

    InitializeListHead( &ListToDelete );

    EnterCriticalSection( &s_critSec );

    // Delete all data notifications
    ple = s_listEntry.Flink;
    while ( ple != &s_listEntry )
    {
        pleNext = ple->Flink;

        pContext = NOTIFY_CONTEXTFromListEntry( ple );
        if ( pContext->_bIsMainNotification )
        {
            RemoveEntryList( ple );
            InitializeListHead( ple );
            InsertTailList( &ListToDelete, ple );
        }
        else
        {
            fShutdownNotifications = TRUE;
        }
        pContext = NULL;

        ple = pleNext;
    }

    LeaveCriticalSection( &s_critSec );

    // Delete all collected notification contexts
    ple = ListToDelete.Flink;
    while ( ple != &ListToDelete )
    {
        pleNext = ple->Flink;

        RemoveEntryList( ple );
        InitializeListHead( ple );

        pContext = NOTIFY_CONTEXTFromListEntry( ple );
        delete pContext;
        pContext = NULL;

        ple = pleNext;
    }

    if ( fShutdownNotifications )
    {
        Sleep( 1000 );
    }

    EnterCriticalSection( &s_critSec );

    ple = s_listEntry.Flink;
    InitializeListHead( &s_listEntry );

    LeaveCriticalSection( &s_critSec );

    // eat all remaining data
    while ( ple != &s_listEntry )
    {
        pleNext = ple->Flink;

        InitializeListHead( ple );

        pContext = NOTIFY_CONTEXTFromListEntry(ple);
        delete pContext;
        pContext = NULL;

        ple = pleNext;
    }

    if ( s_dwThreadId != GetCurrentThreadId() )
    {
        while( s_pCurrentlyWorkingOn )
        {
            // waiting for the NOTIFY_CONTEXT currently being processed to be
            // released so we can return and guarantee that no more work is queued.
            Sleep(100);
        }
    }

}

//static
VOID
NOTIFY_CONTEXT::Terminate()
{
    DWORD               dwRet;
    DBG_ASSERT(IsListEmpty(&s_listEntry));

    if (s_hShutdown)
    {
        SetEvent(s_hShutdown);
    }

    if (s_hThread)
    {
        // need thread to terminate before shutting down more
        dwRet = WaitForSingleObject(s_hThread, INFINITE);
        DBG_ASSERT(WAIT_OBJECT_0 == dwRet);
        CloseHandle(s_hThread);
        s_hThread = NULL;
    }

    if (s_hDataAvailable)
    {
        CloseHandle(s_hDataAvailable);
        s_hDataAvailable = NULL;
    }

    if (s_hShutdown)
    {
        CloseHandle(s_hShutdown);
        s_hShutdown = NULL;
    }

    if (s_fInitializedCritSec)
    {
        DeleteCriticalSection(&s_critSec);
        s_fInitializedCritSec = FALSE;
    }
}

//static
HRESULT
NOTIFY_CONTEXT::GetNextContext(
    NOTIFY_CONTEXT      ** ppContext)
{
    HRESULT             hr = S_OK;
    DWORD               dwRet;
    NOTIFY_CONTEXT      * pContext = NULL;
    PLIST_ENTRY         ple;
    HANDLE              arrHandles[2];

    DBG_ASSERT(ppContext != NULL);
    *ppContext = NULL;

    EnterCriticalSection(&s_critSec);
    if (!IsListEmpty(&s_listEntry))
    {
        ple = RemoveHeadList(&s_listEntry);
        InitializeListHead( ple );
        pContext = NOTIFY_CONTEXTFromListEntry(ple);
    }
    LeaveCriticalSection(&s_critSec);

    arrHandles[0] = s_hDataAvailable;
    arrHandles[1] = s_hShutdown;

    while ( pContext == NULL )
    {
        dwRet = WaitForMultipleObjects( 2,
                                        arrHandles,
                                        FALSE,
                                        INFINITE);
        if (dwRet == WAIT_OBJECT_0)
        {
            // data was signalled as available
            EnterCriticalSection(&s_critSec);
            if (!IsListEmpty(&s_listEntry))
            {
                ple = RemoveHeadList(&s_listEntry);
                InitializeListHead( ple );
                pContext = NOTIFY_CONTEXTFromListEntry(ple);
            }
            LeaveCriticalSection(&s_critSec);
        }
        else if (dwRet == WAIT_OBJECT_0 + 1)
        {
            hr = HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS);
            goto done;
        }
        else
        {
            DBG_ASSERT( ( dwRet == WAIT_OBJECT_0 ) || ( dwRet == WAIT_OBJECT_0+1 ) );
            hr = E_UNEXPECTED;
            goto done;
        }
    }

    DBG_ASSERT( pContext );
    s_LockCurrentlyWorkingOn.WriteLock();
    s_pCurrentlyWorkingOn = pContext;
    s_LockCurrentlyWorkingOn.WriteUnlock();
    *ppContext = pContext;
    pContext = NULL;
    hr = S_OK;

done:
    DBG_ASSERT( pContext == NULL );

    return hr;
}

//static
DWORD WINAPI
NOTIFY_CONTEXT::NotifyThreadProc(
    LPVOID              )
{
    HRESULT             hr = S_OK;
    CADMCOMW            *pCADMCOMW;
    NOTIFY_CONTEXT      *pContext = NULL;

    hr = CoInitializeEx( NULL, COINIT_MULTITHREADED );
    if (FAILED(hr))
    {
        // bleh.  Nothing to be done then.
        return (DWORD)-1;
    }


    for( ; ; )
    {
        hr = NOTIFY_CONTEXT::GetNextContext(&pContext);
        if (FAILED(hr))
        {
            goto done;
        }

        DBG_ASSERT(NULL != pContext);
        DBG_ASSERT(NULL != pContext->_pCADMCOMW);

        pCADMCOMW = pContext->_pCADMCOMW;

        // Keep the object alive during the call to NotifySinksAsync
        pCADMCOMW->AddRef();

        pCADMCOMW->NotifySinksAsync(
            pContext->_dwMDNumElements,
            pContext->_pcoChangeList,
            pContext->_bIsMainNotification );

        delete pContext;

        // Release after deleting the context
        pCADMCOMW->Release();
        pCADMCOMW = NULL;
    }

done:
    CoUninitialize();

    return 0;
}

HRESULT
CADMCOMW::NotifySinksAsync(
    DWORD               dwMDNumElements,
    MD_CHANGE_OBJECT_W  pcoChangeList[],
    BOOL                bIsMainNotification)
{
    HRESULT             hr = S_OK;
    CONNECTDATA         *pConnData = NULL;
    ULONG               cConnData = 0;
    ULONG               i;

    if ( m_bTerminated )
    {
        goto exit;
    }

    hr = m_ConnectionPoint.ListenersPresent();
    if ( hr != S_OK )
    {
        goto exit;
    }

    hr = m_ConnectionPoint.InternalEnumSinks( &pConnData, &cConnData );
    if ( FAILED( hr ) || ( cConnData == 0 ) )
    {
        goto exit;
    }

    // Loop thru the connection point's connections
    // and dispatch the event notification to that sink.
    for ( i = 0; i<cConnData; i++ )
    {
        DBG_ASSERT( pConnData[i].pUnk != NULL );

        // Notify the sink
        NotifySinkHelper( pConnData[i].pUnk,
                          dwMDNumElements,
                          pcoChangeList,
                          bIsMainNotification );

        pConnData[i].pUnk->Release();
        pConnData[i].pUnk = NULL;
        pConnData[i].dwCookie = 0;
    }

exit:
    if ( pConnData != NULL )
    {
        for ( i = 0; i<cConnData; i++ )
        {
            if ( pConnData[i].pUnk != NULL )
            {
                pConnData[i].pUnk->Release();
                pConnData[i].pUnk = NULL;
            }
        }

        delete [] pConnData;
        pConnData = NULL;
    }

    return hr;
}

HRESULT
CADMCOMW::NotifySinkHelper(
    IUnknown                        *pUnk,
    DWORD                           dwMDNumElements,
    MD_CHANGE_OBJECT_W              pcoChangeList[],
    BOOL                            bIsMainNotification)
{
    // Locals
    HRESULT                         hr = S_OK;
    ICallFactory                    *pCF = NULL;
    IMSAdminBaseSinkW               *pIADMCOMSINKW_Synchro = NULL;
    AsyncIMSAdminBaseSinkW          *pIADMCOMSINKW_Async = NULL;

    // Check args
    DBG_ASSERT( pUnk != NULL );
    if ( pUnk == NULL )
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // If we are talking to a proxy
    if ( m_dwProcessIdCaller != sm_dwProcessIdThis )
    {
        //
        // asynchronous callback
        //

        // Get the call factory
        hr = pUnk->QueryInterface( IID_ICallFactory,
                                   (VOID**)&pCF );
        if ( FAILED( hr ) )
        {
            DBGPRINTF(( DBG_CONTEXT, "Failled in to get ICallFactory !!!\n" ));
            goto exit;
        }

        // Create a asynchronous call
        hr = pCF->CreateCall( IID_AsyncIMSAdminBaseSink_W,
                              NULL,
                              IID_AsyncIMSAdminBaseSink_W,
                              (IUnknown**)&pIADMCOMSINKW_Async );
        if ( FAILED( hr ) )
        {
            DBGPRINTF(( DBG_CONTEXT, "Failled in CreateCall to ICallFactory !!!\n" ));
            goto exit;
        }

        // Set the impersonation level to identify to prevent
        // elevation to LocalSystem in the client process.
        hr = SetSinkCallbackSecurityBlanket( pIADMCOMSINKW_Async );
        if ( FAILED( hr ) )
        {
            DBGPRINTF(( DBG_CONTEXT, "SetSinkCallbackSecurityBlanket failled for the async sink !!!\n" ));
            goto exit;
        }

        if (bIsMainNotification)
        {
            hr = pIADMCOMSINKW_Async->Begin_SinkNotify( dwMDNumElements,
                                                         pcoChangeList );
        }
        else
        {
            hr = pIADMCOMSINKW_Async->Begin_ShutdownNotify();
        }
    }
    else
    {
        // The client is inproc -> synchronous notifications

        //
        // synchronous callback
        //
        hr = pUnk->QueryInterface( IID_IMSAdminBaseSink_W,
                                   (VOID**)&pIADMCOMSINKW_Synchro );
        if ( FAILED( hr ) )
        {
            DBGPRINTF(( DBG_CONTEXT, "Failled in QueryInterface for IID_IMSAdminBaseSink_W\n" ));
            goto exit;
        }

        if (bIsMainNotification)
        {
            hr = pIADMCOMSINKW_Synchro->SinkNotify( dwMDNumElements,
                                                    pcoChangeList );
        }
        else
        {
            hr = pIADMCOMSINKW_Synchro->ShutdownNotify();
        }
    }

exit:
    if ( pIADMCOMSINKW_Synchro != NULL )
    {
        pIADMCOMSINKW_Synchro->Release();
        pIADMCOMSINKW_Synchro = NULL;
    }
    if ( pIADMCOMSINKW_Async != NULL )
    {
        pIADMCOMSINKW_Async->Release();
        pIADMCOMSINKW_Async = NULL;
    }
    if ( pCF != NULL )
    {
        pCF->Release();
        pCF = NULL;
    }

    return hr;
}

//
// Stubs for routine that clients shouldn't be calling anyway.
//

HRESULT
CADMCOMW::KeyExchangePhase1()
{
    return E_FAIL;
}

HRESULT
CADMCOMW::KeyExchangePhase2()
{
    return E_FAIL;
}


HRESULT STDMETHODCALLTYPE
CADMCOMW::GetServerGuid( void)
{
    return E_FAIL;
}

HRESULT STDMETHODCALLTYPE
CADMCOMW::UnmarshalInterface(
    IMSAdminBaseW       * *piadmbwInterface)
{
    AddRef();       // Always return interfaces addref'ed
    *piadmbwInterface = (IMSAdminBaseW *)this;

    return (S_OK);
}

BOOL
CADMCOMW::CheckGetAttributes(
    DWORD               dwAttributes)
{
    DWORD               dwReturn = TRUE;

    if ((dwAttributes & METADATA_REFERENCE) ||
        ((dwAttributes & METADATA_PARTIAL_PATH) &&
            !(dwAttributes & METADATA_INHERIT)))
    {
        dwReturn = FALSE;
    }

    return dwReturn;
}

VOID
WaitForServiceStatus(
    SC_HANDLE           schDependent,
    DWORD               dwDesiredServiceState)
{
    DWORD               dwSleepTotal = 0;
    SERVICE_STATUS      ssDependent;

    while (dwSleepTotal < MAX_SLEEP)
    {
        if (QueryServiceStatus(schDependent, &ssDependent))
        {
            if (ssDependent.dwCurrentState == dwDesiredServiceState)
            {
                break;
            }
            else
            {
                //
                // Still pending...
                //
                Sleep(SLEEP_INTERVAL);

                dwSleepTotal += SLEEP_INTERVAL;
            }
        }
        else
        {
            break;
        }
    }
}

DWORD
CADMCOMW::IsReadAccessGranted(
    METADATA_HANDLE     hHandle,
    LPWSTR              pszPath,
    METADATA_RECORD*    pmdRecord)
/*++

Routine Description:

    Check if read access to property granted based on ACL visible at point in metabase
    where property is stored ( as opposed as check made by AdminAclAccessCheck which uses
    the ACL visible at path specified during data access )

Arguments:

    hHandle - DCOM metabase handle
    pszPath - path relative to hHandle
    pmdRecord - metadata info to access property

Returns:

    ERROR_SUCCESS if access granted, otherwise error code

--*/
{
    DWORD               dwStatus = ERROR_SUCCESS;
    LPWSTR              pszPropPath;

    //
    // If property is not inherited then we already checked the correct ACL
    //

    if ( !(pmdRecord->dwMDAttributes & METADATA_ISINHERITED) )
    {
        return dwStatus;
    }

    // determine from where we got it
    // do AccessCheck

    if ( (dwStatus = FindClosestProp( hHandle,
                                      pszPath,
                                      &pszPropPath,
                                      pmdRecord->dwMDIdentifier,
                                      pmdRecord->dwMDDataType,
                                      pmdRecord->dwMDUserType,
                                      METADATA_SECURE,
                                      TRUE )) == ERROR_SUCCESS )
    {
        if ( pszPropPath )   // i.e such a property exist
        {
            dwStatus = AdminAclAccessCheck( m_pMdObject,
                                            (LPVOID)this,
                                            METADATA_MASTER_ROOT_HANDLE,
                                            pszPropPath,
                                            pmdRecord->dwMDIdentifier,
                                            METADATA_PERMISSION_READ,
                                            &g_ohMasterRootHandle ) ?
                       ERROR_SUCCESS :
                       GetLastError();
            LocalFree( pszPropPath );
        }
        else
        {
            dwStatus = MD_ERROR_DATA_NOT_FOUND;

            //
            // Should not happen unless handle is master root :
            // if we are here then we succeeded accessing data and as we have a read handle
            // nobody should be able to delete it
            // if master root handle we don't have such protection, so property could
            // have been deleted.
            //

            DBG_ASSERT ( METADATA_MASTER_ROOT_HANDLE == hHandle );
        }
    }

    return dwStatus;
}


DWORD
CADMCOMW::FindClosestProp(
    METADATA_HANDLE     hHandle,
    LPWSTR              pszRelPath,
    LPWSTR*             ppszPropPath,
    DWORD               dwPropId,
    DWORD               dwDataType,
    DWORD               dwUserType,
    DWORD               dwAttr,
    BOOL                fSkipCurrentNode)
/*++

Routine Description:

    Find the closest path where the specified property exist ( in the direction of
    the root ) in metabase

Arguments:

    hHandle - DCOM metabase handle
    pszRelPath - path relative to hHandle
    ppszPropPath - updated with path to property or NULL if property not found
    dwPropId - property ID
    dwDataType - property data type
    dwUserType - property user type
    dwAttr - property attribute
    fSkipCurrentNode - TRUE to skip current node while scanning for property

Returns:

    TRUE if success ( including property not found ), otherwise FALSE

--*/
{
    DWORD               dwReturn;
    LPWSTR              pszParentPath;
    METADATA_HANDLE     hActualHandle;
    COpenHandle         *pohParent;
    HRESULT             hRes;
    METADATA_RECORD     mdRecord;
    DWORD               dwRequiredLen;
    LPWSTR              pszPath;
    BOOL                fFound;
    DWORD               dwRelPathLen;
    DWORD               dwParentPathLen;
    DWORD               dwTotalSize;


    dwReturn = Lookup( hHandle,
                       &hActualHandle,
                       &pohParent);

    if ( dwReturn != ERROR_SUCCESS )
    {
        return dwReturn;
    }

    pszParentPath = pohParent->GetPath();

    if (pszRelPath == NULL)
    {
        pszRelPath = L"";
    }

    DBG_ASSERT(pszParentPath != NULL);
    DBG_ASSERT((*pszParentPath == (WCHAR)'\0') ||
               ISPATHDELIMW(*pszParentPath));

    //
    // Strip front slash now, add it in later
    //

    if (ISPATHDELIMW(*pszRelPath))
    {
        pszRelPath++;
    }

    dwRelPathLen = (DWORD)wcslen(pszRelPath);
    dwParentPathLen = (DWORD)wcslen(pszParentPath);

    DBG_ASSERT((dwParentPathLen == 0) ||
               (!ISPATHDELIMW(pszParentPath[dwParentPathLen -1])));

    //
    // Get rid of trailing slash for good
    //

    if ((dwRelPathLen > 0) && (ISPATHDELIMW(pszRelPath[dwRelPathLen -1])))
    {
        dwRelPathLen--;
    }

    //
    // Include space for mid slash if Relpath exists
    // Include space for termination
    //

    dwTotalSize =
        (dwRelPathLen + dwParentPathLen + 1 + ((dwRelPathLen > 0) ? 1 : 0)) * sizeof(WCHAR);

    *ppszPropPath = pszPath = (LPWSTR)LocalAlloc(LMEM_FIXED, dwTotalSize);

    if (pszPath == NULL)
    {
        dwReturn = GetLastError();
    }
    else
    {
        //
        // OK to always copy the first part
        //

        memcpy(pszPath,
               pszParentPath,
               dwParentPathLen * sizeof(WCHAR));

        //
        // Don't need slash if there is no RelPath
        //

        if (dwRelPathLen > 0)
        {

            pszPath[dwParentPathLen] = (WCHAR)'/';

            memcpy(pszPath + dwParentPathLen + 1,
                   pszRelPath,
                   dwRelPathLen * sizeof(WCHAR));

        }

        pszPath[(dwTotalSize / sizeof(WCHAR)) - 1] = (WCHAR)'\0';

        //
        // Now convert \ to / for string compares
        //

        LPWSTR pszPathIndex = pszPath;

        while ((pszPathIndex = wcschr(pszPathIndex, (WCHAR)'\\')) != NULL)
        {
            *pszPathIndex = (WCHAR)'/';
        }

        // scan for property

        pszPathIndex = pszPath + wcslen(pszPath);

        for ( ; ; )
        {
            if ( !fSkipCurrentNode )
            {
                // check prop exist
                mdRecord.dwMDIdentifier  = dwPropId;
                mdRecord.dwMDAttributes  = dwAttr;
                mdRecord.dwMDUserType    = dwUserType;
                mdRecord.dwMDDataType    = dwDataType;
                mdRecord.dwMDDataLen     = 0;
                mdRecord.pbMDData        = NULL;
                mdRecord.dwMDDataTag     = NULL;

                hRes = m_pMdObject->ComMDGetMetaDataW( METADATA_MASTER_ROOT_HANDLE,
                                                       pszPath,
                                                       &mdRecord,
                                                       &dwRequiredLen );
                if ( hRes == RETURNCODETOHRESULT(ERROR_INSUFFICIENT_BUFFER) )
                {
                    break;
                }
            }

            // scan backward for delimiter

            fFound = FALSE;
            if ( pszPathIndex > pszPath )
            {
                do
                {
                    if ( *--pszPathIndex == L'/' )
                    {
                        *pszPathIndex = L'\0';
                        fFound = TRUE;
                        break;
                    }
                } while ( pszPathIndex > pszPath );
            }

            if ( !fFound )
            {
                // Property not found, return OK status with NULL string

                *ppszPropPath = NULL;
                LocalFree( pszPath );
                break;
            }

            fSkipCurrentNode = FALSE;
        }
    }

    pohParent->Release( this );

    return dwReturn;
}


BOOL
MakeParentPath(
    LPWSTR              pszPath)
/*++

Routine Description:

    Make the path points to parent

Arguments:

    pszPath - path to adjust

Returns:

    TRUE if success, otherwise FALSE ( no parent )

--*/
{
    LPWSTR              pszPathIndex = pszPath + wcslen( pszPath );
    BOOL                fFound = FALSE;

    while ( pszPathIndex > pszPath )
    {
        if ( *--pszPathIndex == L'/' )
        {
            *pszPathIndex = L'\0';
            fFound = TRUE;
            break;
        }
    }

    return fFound;
}

HRESULT
CADMCOMW::InitializeCallerWatch(VOID)
/*++

Routine Description:

    Sets up watching the caller process.

Arguments:

    none

Returns:

    HRESULT.

--*/
{
    // Locals
    HRESULT             hr = S_OK;
    RPC_STATUS          RpcStatus = RPC_S_OK;
    HANDLE              hProcessCaller = NULL;
    HANDLE              hWaitCaller = NULL;
    HANDLE              hToken = NULL;
    IServerSecurity     *pServerSecurity = NULL;
    unsigned int        fClientLocal = 0;
    DWORD               dwProcessId = 0;
    BOOL                fRet;

    // If already initialized
    if ( IsCallerWatchInitialized() )
    {
        // Just exit
        goto exit;
    }

    // Get the COM context for the call
    hr = CoGetCallContext( IID_IServerSecurity, (VOID**)&pServerSecurity );

    if ( FAILED( hr ) )
    {
        // Succeess if there is no call context (inproc call).
        if ( hr == RPC_E_CALL_COMPLETE )
        {
            // This is not a failure
            hr = S_OK;

            // The caller is our process
            m_dwProcessIdCaller = sm_dwProcessIdThis;
        }

        if ( FAILED( hr ) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "CoGetCallContext() failed in InitializeCallerWatch hr=0x%08x.\n",
                        hr ));
        }

        // Bail out
        goto exit;
    }

    // Check whether the client is on the same machine
    RpcStatus = I_RpcBindingIsClientLocal( NULL, &fClientLocal );

    // Not a RPC call?
    if ( ( RpcStatus == RPC_S_NO_CALL_ACTIVE ) ||
         ( RpcStatus == RPC_S_INVALID_BINDING ) )
    {
        // The caller is our process
        m_dwProcessIdCaller = sm_dwProcessIdThis;

        goto exit;
    }

    // Remote client?
    if ( ( RpcStatus == RPC_S_OK ) &&
         ( fClientLocal == 0 ) )
    {
        // There is no way to watch the caller
        m_dwProcessIdCaller = (DWORD)-1;

        goto exit;
    }

    // Failed?
    if ( ( RpcStatus != RPC_S_OK ) &&
         ( RpcStatus != RPC_S_CANNOT_SUPPORT ) )
    {
        hr = HRESULT_FROM_WIN32( RpcStatus );

        DBGPRINTF(( DBG_CONTEXT,
                    "I_RpcBindingIsClientLocal() failed in InitializeCallerWatch hr=0x%08x.\n",
                    hr ));

        goto exit;
    }

    // Try to get the caller pid
    RpcStatus = I_RpcBindingInqLocalClientPID( NULL, &dwProcessId );

    // Not a RPC call?
    if ( ( RpcStatus == RPC_S_NO_CALL_ACTIVE ) ||
         ( RpcStatus == RPC_S_INVALID_BINDING ) )
    {
        // The caller is our process
        m_dwProcessIdCaller = sm_dwProcessIdThis;

        goto exit;
    }

    // Failed?
    if ( RpcStatus != RPC_S_OK )
    {
        hr = HRESULT_FROM_WIN32( RpcStatus );

        DBGPRINTF(( DBG_CONTEXT,
                    "I_RpcBindingInqLocalClientPID() failed in InitializeCallerWatch hr=0x%08x.\n",
                    hr ));

        goto exit;
    }

    // If the caller is RpcSs
    if ( dwProcessId == sm_dwProcessIdRpcSs )
    {
        // wait for the next call to come
        goto exit;
    }

    // If the caller is in our process
    if ( dwProcessId == sm_dwProcessIdThis )
    {
        // Save the caller pid
        m_dwProcessIdCaller = sm_dwProcessIdThis;

        // Not need to watch outself
        goto exit;
    }

    // Try to get the thread impersonation token
    fRet = OpenThreadToken( GetCurrentThread(),
                            TOKEN_IMPERSONATE | TOKEN_QUERY,
                            TRUE,
                            &hToken );
    DBG_ASSERT( !fRet || hToken );

    // Check whether the thread was impersonated
    if ( fRet && ( hToken != NULL ) )
    {
        // Revet to LocalSystem
        fRet = RevertToSelf();

        if ( !fRet )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );

            DBGPRINTF(( DBG_CONTEXT,
                        "RevertToSelf() failed in InitializeCallerWatch hr=0x%08x.\n",
                        hr ));

            // Since RevertToSelf failed do not try to impersonate
            CloseHandle( hToken );
            hToken = NULL;

            goto exit;
        }
    }

    // Open the process
    hProcessCaller = OpenProcess( SYNCHRONIZE,
                                  FALSE,
                                  dwProcessId );

    if ( hProcessCaller == NULL )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );

        DBGPRINTF(( DBG_CONTEXT,
                    "OpenProcess() failed in InitializeCallerWatch hr=0x%08x.\n",
                    hr ));

        goto exit;
    }

    // Register wait for the process to end
    fRet = RegisterWaitForSingleObject( &hWaitCaller,
                                        hProcessCaller,
                                        CallerWatchWaitOrTimerCallback,
                                        this,
                                        INFINITE,
                                        WT_EXECUTEONLYONCE);
    if ( !fRet )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );

        DBGPRINTF(( DBG_CONTEXT,
                    "RegisterWaitForSingleObject() failed in InitializeCallerWatch hr=0x%08x.\n",
                    hr ));

        goto exit;
    }

    DBG_ASSERT( hWaitCaller != NULL );

    // Save the handles in the object
    if ( NULL == InterlockedCompareExchangePointer( &m_hProcessCaller,
                                                    hProcessCaller,
                                                    NULL ) )
    {
        m_hWaitCaller = hWaitCaller;
        m_dwProcessIdCaller = dwProcessId;
        hProcessCaller = NULL;
        hWaitCaller = NULL;
    }

    DBG_ASSERT( m_dwProcessIdCaller == dwProcessId );

exit:
    // Cleanup
    if ( pServerSecurity )
    {
        pServerSecurity->Release();
        pServerSecurity = NULL;
    }
    if ( hWaitCaller != NULL)
    {
        UnregisterWaitEx( hWaitCaller, INVALID_HANDLE_VALUE );
        hWaitCaller = NULL;
    }
    if ( hProcessCaller != NULL )
    {
        CloseHandle( hProcessCaller );
        hProcessCaller = NULL;
    }
    if ( hToken )
    {
        fRet = ImpersonateLoggedOnUser( hToken );
        if ( !fRet )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );

            DBGPRINTF(( DBG_CONTEXT,
                        "ImpersonateLoggedOnUser() failed in InitializeCallerWatch hr=0x%08x.\n",
                        hr ));
        }

        CloseHandle( hToken );
        hToken = NULL;
    }

    DBG_ASSERT( SUCCEEDED( hr ) );

    // Done
    return hr;
}

HRESULT
CADMCOMW::ShutdownCallerWatch(VOID)
/*++

Routine Description:

    Shuts down watching the caller process.

Arguments:

    none

Returns:

    HRESULT.

--*/
{
    // Locals
    HRESULT             hr = S_OK;
    BOOL                fRet;
    HANDLE              hWaitCaller = NULL;
    HANDLE              hProcessCaller = NULL;
    DWORD               dwOldThreadId;
    DWORD               dwThreadId = GetCurrentThreadId();

    // Set the thread id
    dwOldThreadId = InterlockedCompareExchange( (LONG*)&m_dwThreadIdDisconnect,
                                                (LONG)dwThreadId,
                                                0 );
    // Get the wait object
    hWaitCaller = InterlockedExchangePointer( &m_hWaitCaller, NULL );

    // If not initialized/already closed
    if ( hWaitCaller == NULL )
    {
        // Nothing
        goto exit;
    }

    // Get the process
    hProcessCaller = InterlockedExchangePointer( &m_hProcessCaller, NULL );

    // If we are in the same thread as the callback function
    // we cannot wait for it to finish
    if ( dwOldThreadId == dwThreadId )
    {
        // Delete the registered wait for the caller process
        // NULL passed as completion event causes
        // UnregisterWaitEx to return w/o blocking
        fRet = UnregisterWaitEx( hWaitCaller, NULL );

        // The call fails with ERROR_IO_PENDING if the callback function
        // is still running (which is expected, because it called us indirectly),
        // but any other error is failure
        if ( !fRet && ( GetLastError() == ERROR_IO_PENDING ) )
        {
            // This is not a failure
            fRet = TRUE;
            SetLastError( ERROR_SUCCESS );
        }
    }
    else
    {
        // Delete the registered wait for the caller process
        // INVALID_HANDLE_VALUE passed as completion event causes
        // UnregisterWaitEx not to return until the callback function returns
        fRet = UnregisterWaitEx( hWaitCaller, INVALID_HANDLE_VALUE );
    }
    hWaitCaller = NULL;
    if ( !fRet )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );

        DBGPRINTF(( DBG_CONTEXT,
                    "UnregisterWaitEx() failed in ShutdownCallerWatch hr=0x%08x.\n",
                    hr ));
        goto exit;
    }

exit:
    if ( hProcessCaller )
    {
        // Close the process handle
        CloseHandle( hProcessCaller );
        hProcessCaller = NULL;
    }
    if ( dwOldThreadId == 0 )
    {
        // Restore the thread id
        dwOldThreadId = InterlockedCompareExchange( (LONG*)&m_dwThreadIdDisconnect,
                                                    0,
                                                    (LONG)dwThreadId );
        DBG_ASSERT( dwOldThreadId == dwThreadId );
    }

    DBG_ASSERT( SUCCEEDED( hr ) );

    // Done
    return hr;
}

HRESULT
CADMCOMW::DisconnectOrphaned(VOID)
/*++

Routine Description:

    Calls CoDisconnectObject on the object and the connection point.

Arguments:

    none

Returns:

    HRESULT.

--*/
{
    // Locals
    HRESULT             hr = S_OK;
    DWORD               dwOldThreadId = (DWORD)-1;
    DWORD               dwThreadId = GetCurrentThreadId();
    DWORD               cRef = 0;

    // If already terminated
    if ( m_bTerminated )
    {
        // Do nothing
        goto exit;
    }

    // Set the thread id
    dwOldThreadId = InterlockedCompareExchange( (LONG*)&m_dwThreadIdDisconnect,
                                                (LONG)dwThreadId,
                                                0 );
    if ( dwOldThreadId != 0 )
    {
        goto exit;
    }

    // AddRef, to prevent the object being destroyed by one of the CoDisconnect calls
    AddRef();

    // Disconnect the object
    CoDisconnectObject( static_cast<IUnknown*>( this ), 0 );

    // Disconnect the connection point
    CoDisconnectObject( static_cast<IConnectionPoint*>( &m_ConnectionPoint ), 0 );

    // Stop getting and firing notifications.
    // This is a forcible termination so remove all pending notifications
    StopNotifications( TRUE );

    // Release (which may delete the object)
    cRef = Release();

exit:
    if ( ( cRef > 1 ) && ( dwOldThreadId == 0 ) )
    {
        // Set the thread id
        dwOldThreadId = InterlockedCompareExchange( (LONG*)&m_dwThreadIdDisconnect,
                                                    0,
                                                    (LONG)dwThreadId );
        DBG_ASSERT( dwOldThreadId == dwThreadId );
    }

    DBG_ASSERT( SUCCEEDED( hr ) );

    // Done
    return hr;
}

VOID
CALLBACK
CADMCOMW::CallerWatchWaitOrTimerCallback(
  PVOID                 lpParameter,        // thread data
  BOOLEAN               TimerOrWaitFired)   // reason
/*++

Routine Description:

    Passed as a callback to RegisterWaitForSingleObject.
    Called when the caller process terminates.
    CoDisconnects the object to force COM to release it before the 10 min timeout.

Arguments:

    lpParameter         -   the callback context passed to RegisterWaitForSingleObject.
                            Must be the CADMCOMW object used by the process waiting on.
    TimerOrWaitFired    -   The reason to call the callback. Since we are waiting
                            on the handle for INFINITE time must be always FALSE.

Returns:

    VOID.

--*/
{
    // Locals
    HRESULT             hr = S_OK;
    CADMCOMW            *pThis;
    BOOL                fUninitCom = FALSE;

    DBG_ASSERT( lpParameter != NULL );
    DBG_ASSERT( TimerOrWaitFired == FALSE );

    // Check
    if ( ( lpParameter == NULL ) || ( TimerOrWaitFired != FALSE ) )
    {
        hr = E_INVALIDARG;

        DBGPRINTF(( DBG_CONTEXT,
                    "Invadil args passed to CallerWatchWaitOrTimerCallback.\n",
                    hr ));

        goto exit;
    }

    // Initialize COM
    hr = CoInitializeEx( NULL, COINIT_MULTITHREADED );
    // If succeeded
    if ( SUCCEEDED( hr ) )
    {
        // Remember to uninit
        fUninitCom = TRUE;
    }
    // If already initialized w/ different model
    if ( hr == RPC_E_CHANGED_MODE )
    {
        // Ok it is thread is apartment threaded, but this means that
        // COM is already initialized and there is no need to uninitialize it.
        hr = S_OK;
    }
    DBG_ASSERT( SUCCEEDED( hr ) );
    // If really failed
    if ( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "CoInitializeEx() failed in CallerWatchWaitOrTimerCallback hr=0x%08x.\n",
                    hr ));

        // Ouch! Nothing we can do. The object will have to wait the timeout.
        goto exit;
    }

    // Get the object
    pThis = (CADMCOMW*)lpParameter;

    // Disconnect it
    hr = pThis->DisconnectOrphaned();
    DBG_ASSERT( SUCCEEDED( hr ) );
    if ( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "DisconnectOrphaned() failed in CallerWatchWaitOrTimerCallback hr=0x%08x.\n",
                    hr ));

        goto exit;
    }

exit:
    DBG_ASSERT( SUCCEEDED( hr ) );

    // Cleanup
    if ( fUninitCom )
    {
        // Uninitialize COM
        CoUninitialize();
    }
}

HRESULT
CADMCOMW::GetPids(VOID)
/*++

Routine Description:

    Gets the pid of this process (inetinfo.exe) and saves it to
    sm_dwProcessIdThis.
    Gets the pid of the svchost process running RpcSs and saves it to
    sm_dwProcessIdRpcSs.

Arguments:

    None

Returns:

    HRESULT.

--*/
{
    // Locals
    HRESULT                 hr = S_OK;
    BOOL                    fRet;
    SC_HANDLE               schSCM = NULL;
    SC_HANDLE               schRpcSs = NULL;
    SERVICE_STATUS_PROCESS  ServiceStatusProcessRcpSs = {0};
    DWORD                   cbRequired = 0;

    // Save the current processid
    sm_dwProcessIdThis = GetCurrentProcessId();
    DBG_ASSERT( sm_dwProcessIdThis != 0 );

    // If already initialized don't play w/ SCM again
    if ( sm_dwProcessIdRpcSs != 0 )
    {
        goto exit;
    }

    // Open SCM
    schSCM = OpenSCManager( NULL,
                            NULL,
                            SC_MANAGER_ENUMERATE_SERVICE );
    if (schSCM == NULL)
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );

        DBGPRINTF(( DBG_CONTEXT,
                    "OpenSCManager() failed in GetPids hr=0x%08x.\n",
                    hr ));
        goto exit;
    }

    // Open RpcSs
    schRpcSs = OpenServiceA( schSCM,
                             "RpcSs",
                             SERVICE_QUERY_STATUS);
    if ( schRpcSs == NULL )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );

        DBGPRINTF(( DBG_CONTEXT,
                    "OpenService() failed in GetPids hr=0x%08x.\n",
                    hr ));
        goto exit;
    }

    // Query the status of RpcSs to get the pid
    fRet = QueryServiceStatusEx( schRpcSs,
                                 SC_STATUS_PROCESS_INFO,
                                 (BYTE*)&ServiceStatusProcessRcpSs,
                                 sizeof(ServiceStatusProcessRcpSs),
                                 &cbRequired );
    if ( !fRet )
    {
        DBG_ASSERT( GetLastError() != ERROR_INSUFFICIENT_BUFFER );
        hr = HRESULT_FROM_WIN32( GetLastError() );

        DBGPRINTF(( DBG_CONTEXT,
                    "QueryServiceStatusEx() failed in GetPids hr=0x%08x.\n",
                    hr ));
        goto exit;
    }

    // Save the pid
    sm_dwProcessIdRpcSs = ServiceStatusProcessRcpSs.dwProcessId;
    DBG_ASSERT( sm_dwProcessIdRpcSs != 0 );

exit:
    // Cleanup
    if ( schRpcSs != NULL )
    {
        CloseServiceHandle( schRpcSs );
        schRpcSs = NULL;
    }
    if ( schSCM != NULL )
    {
        CloseServiceHandle( schSCM );
        schSCM = NULL;
    }

    DBG_ASSERT( SUCCEEDED( hr ) );

    return hr;
}

HRESULT
MakePathCanonicalizationProof(
    LPCWSTR                 pwszName,
    BOOL                    fResolve,
    STRAU                   *pstrPath)
/*++

Routine Description:

    The function tries make a file name proof to all canonicalization problems.
    If fResolve is FALSE:
        This functions adds a prefix to the string,
        which is "\\?\UNC\" for a UNC path, and "\\?\" for other paths.
        This prefix tells Windows not to parse the path.
    If fResolve is TRUE:
        This function constructs a file name as above, opens the file and gets
        the real name from the handle.

    Stolen from iisutil.dll, because coadmin links only with iisrtl

Arguments:

    IN  pszName     - The path to be converted
    IN  fResolve    - Whether the caller can live with the name just prefixed or needs the real name.
    OUT pstrPath    - Output path created

Return Values:

    HRESULT

--*/
{
    HRESULT                 hr = S_OK;
    DWORD                   dwError;
    BOOL                    fRet;
    NTSTATUS                Status = STATUS_SUCCESS;
    IO_STATUS_BLOCK         IoStatusBlock;
    HANDLE                  hFile = NULL;
    BUFFER                  Buff;
    FILE_NAME_INFORMATION   *pFileNameInfo = NULL;
    DWORD                   dwSize;
    DWORD                   dwReqSize;
    WCHAR                   wszPrefix[4];
    WCHAR                   wchT;

    // Check args
    if ( ( pwszName == NULL ) || ( pstrPath == NULL ) )
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    pstrPath->Reset();

    if ( pwszName[ 0 ] == L'\\' && pwszName[ 1 ] == L'\\' )
    {
        // If the path is already canonicalized, just return
        if ( ( pwszName[ 2 ] == '?' || pwszName[ 2 ] == '.' ) &&
             pwszName[ 3 ] == '\\' )
        {
            // Prepend "\\?\"
            // If the path was in DOS form ("\\.\"),
            // we need to change it to Win32 from ("\\?\")
            fRet = pstrPath->Append( L"\\\\?\\" );
            if ( !fRet )
            {
                hr = E_OUTOFMEMORY;
                goto exit;
            }

            // Copy the path into the string
            fRet = pstrPath->Append( (const LPWSTR)(pwszName+4) );
            if ( !fRet )
            {
                hr = E_OUTOFMEMORY;
                goto exit;
            }

            // Just return the copy
            goto exit;
        }

        if ( fResolve )
        {
            wszPrefix[0] = L'\\';
            wszPrefix[1] = L'\0';
        }

        // Skip the "\\"
        pwszName += 2;

        // Prepend "\\?\UNC\"
        fRet = pstrPath->Append( L"\\\\?\\UNC\\" );
        if ( !fRet )
        {
            hr = E_OUTOFMEMORY;
            goto exit;
        }

    }
    else
    {
        if ( fResolve )
        {
            wchT = pwszName[0];
            if ( ( wchT >= L'A' ) && ( wchT <= L'Z' ) )
            {
                wchT = wchT - L'A' + L'a';
            }

            if ( ( wchT < L'a' ) || ( wchT > L'z' ) )
            {
                hr = E_INVALIDARG;
                goto exit;
            }

            if ( pwszName[1] != L':' )
            {
                hr = E_INVALIDARG;
                goto exit;
            }

            if ( pwszName[2] != L'\\' )
            {
                hr = E_INVALIDARG;
                goto exit;
            }

            wszPrefix[0] = pwszName[0];
            wszPrefix[1] = pwszName[1];
            wszPrefix[2] = L'\0';
        }

        // Prepend "\\?\"
        fRet = pstrPath->Append( L"\\\\?\\" );
        if ( !fRet )
        {
            hr = E_OUTOFMEMORY;
            goto exit;
        }

    }

    // Add the path
    fRet = pstrPath->Append( (const LPWSTR)pwszName );
    if ( !fRet )
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    // Don't use the original filename anymore
    pwszName = NULL;

    // If the caller can work with the anti-canonicalized file name
    if ( !fResolve )
    {
        // We are done, return
        goto exit;
    }

    // Well have to do it the hard way
    hFile = CreateFileW( pstrPath->QueryStrW(),
                         GENERIC_READ,
                         FILE_SHARE_READ,
                         NULL,
                         OPEN_EXISTING,
                         FILE_ATTRIBUTE_NORMAL,
                         NULL );

    if ( ( hFile == NULL ) || ( hFile == INVALID_HANDLE_VALUE ) )
    {
        dwError = GetLastError();
        hr = HRESULT_FROM_WIN32( dwError );
        goto exit;
    }

    // Assume the size of the name should approximate the same
    dwSize = sizeof( FILE_NAME_INFORMATION ) + pstrPath->QueryCBW()+ sizeof( WCHAR );
    dwSize = ( dwSize + 0x0000000Ful ) & ~0x0000000Ful;

    // Set the size
    fRet = Buff.Resize( dwSize );
    if ( !fRet )
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    pFileNameInfo = (FILE_NAME_INFORMATION*)Buff.QueryPtr();
    DBG_ASSERT( pFileNameInfo );

    // Get the name from the handle
    Status = NtQueryInformationFile( hFile,
                                     &IoStatusBlock,
                                     pFileNameInfo,
                                     dwSize,
                                     FileNameInformation );

    // If the buffer is not big enough
    if ( ( Status == STATUS_BUFFER_OVERFLOW ) ||
         ( Status == STATUS_BUFFER_TOO_SMALL ) )
    {
        // Calculate the new size
        dwReqSize = sizeof(FILE_NAME_INFORMATION) + pFileNameInfo->FileNameLength + sizeof( WCHAR );

        DBG_ASSERT( dwReqSize > dwSize );

        dwSize = ( dwReqSize + 0x0000000Ful ) & ~0x0000000Ful;

        fRet = Buff.Resize( dwSize );
        if ( !fRet )
        {
            hr = E_OUTOFMEMORY;
            goto exit;
        }

        pFileNameInfo = (FILE_NAME_INFORMATION*)Buff.QueryPtr();
        DBG_ASSERT( pFileNameInfo );

        // Retry getting the name from the handle
        Status = NtQueryInformationFile( hFile,
                                         &IoStatusBlock,
                                         pFileNameInfo,
                                         dwSize,
                                         FileNameInformation );

    }

    if ( !NT_SUCCESS( Status ) )
    {
        dwError = RtlNtStatusToDosError( Status );
        DBG_ASSERT( dwError != ERROR_SUCCESS );

        if ( dwError != ERROR_MR_MID_NOT_FOUND )
        {
            hr = HRESULT_FROM_WIN32( dwError );
        }
        else
        {
            hr = HRESULT_FROM_NT( Status );
            DBG_ASSERT ( FAILED( hr ) );
        }

        goto exit;
    }

    pstrPath->Reset();

    // Set the prefix
    fRet = pstrPath->Copy( wszPrefix );
    if ( !fRet )
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    // Append the name
    fRet = pstrPath->Append( pFileNameInfo->FileName, pFileNameInfo->FileNameLength/sizeof( WCHAR ) );
    if ( !fRet )
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

exit:
    if ( ( hFile != NULL ) && ( hFile != INVALID_HANDLE_VALUE ) )
    {
        CloseHandle(hFile);
        hFile = NULL;
    }

    if ( FAILED( hr ) )
    {
        pstrPath->Reset();
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\dcomadm\dll\cimpexp.cxx ===
// cimpexp.cxx

#include "precomp.hxx"

#include <atlbase.h>

#include <iadm.h>
#include "coiadm.hxx"

#define DEFAULT_TIMEOUT_VALUE 30000

// Implementation of CImpExpHelp

CADMCOMW::CImpExpHelp::CImpExpHelp()
{
    return;
}

CADMCOMW::CImpExpHelp::~CImpExpHelp(void)
{
  return;
}

VOID CADMCOMW::CImpExpHelp::Init(CADMCOMW *pBackObj)
{
  // Init the Back Object Pointer to point to the parent object.

  m_pUnkOuter = (IUnknown*)pBackObj;

  return;
}

STDMETHODIMP CADMCOMW::CImpExpHelp::QueryInterface(
               REFIID riid,
               PPVOID ppv)
{
  // Delegate this call to the outer object's QueryInterface.
  return m_pUnkOuter->QueryInterface(riid, ppv);
}

STDMETHODIMP_(ULONG) CADMCOMW::CImpExpHelp::AddRef(void)
{
  // Delegate this call to the outer object's AddRef.
  return m_pUnkOuter->AddRef();
}

STDMETHODIMP_(ULONG) CADMCOMW::CImpExpHelp::Release(void)
{
  // Delegate this call to the outer object's Release.
  return m_pUnkOuter->Release();
}

STDMETHODIMP CADMCOMW::CImpExpHelp::EnumeratePathsInFile (
        /* [unique, in, string] */ LPCWSTR pszFileName,
        /* [unique, in, string] */ LPCWSTR pszKeyType,
        /* [in] */ DWORD dwMDBufferSize,
        /* [out, size_is(dwMDBufferSize)] */ WCHAR *pszBuffer,
        /* [out] */ DWORD *pdwMDRequiredBufferSize)
{
    HRESULT hr = S_OK;
    CComPtr<ISimpleTableDispenser2> spISTDisp;
    CComPtr<ISimpleTableRead2>      spISTProperty;
    CComPtr<IErrorInfo>             spErrorInfo;
    CComPtr<ISimpleTableRead2>      spISTError;
    CComPtr<ICatalogErrorLogger2>   spILogger;
    CComPtr<IAdvancedTableDispenser> spISTDispAdvanced;
    ULONG                           iRowDuplicateLocation = 0;
    STRAU                           strFileName;

    if ((!pszFileName)||(!*pszFileName)||(!pszKeyType))
    {
        hr = RETURNCODETOHRESULT(ERROR_INVALID_PARAMETER);
        goto done;
    }

    if (!pszBuffer)
    {
        dwMDBufferSize = 0;
    }

    hr = CoImpersonateClient();

    if (FAILED(hr))
    {
        goto done;
    }

    METADATA_HANDLE hActualHandle;

    CADMCOMW* pOuter = NULL;

    pOuter = (CADMCOMW*)m_pUnkOuter;

    hr = pOuter->LookupAndAccessCheck( METADATA_MASTER_ROOT_HANDLE,
                                       &hActualHandle,
                                       L"",
                                       MD_ADMIN_ACL,
                                       METADATA_PERMISSION_WRITE);

    if (FAILED(hr))
    {
        goto done;
    }

    // IVANPASH 598894 (SCR)
    // Prepend the file name with \\?\ (or \\?\UNC\) to prevent canonicalization
    hr = MakePathCanonicalizationProof( pszFileName, TRUE, &strFileName );
    if ( FAILED( hr ) )
    {
        goto done;
    }
    // Don't use i_wszFileName any more
    pszFileName = NULL;

    STQueryCell QueryCell[1];

    //
    // Get the property table.
    //
    QueryCell[0].pData     = (LPVOID)strFileName.QueryStrW();
    QueryCell[0].eOperator = eST_OP_EQUAL;
    QueryCell[0].iCell     = iST_CELL_FILE;
    QueryCell[0].dbType    = DBTYPE_WSTR;
    QueryCell[0].cbSize    = (lstrlenW(strFileName.QueryStrW())+1)*sizeof(WCHAR);

    ULONG cCell            = sizeof(QueryCell)/sizeof(STQueryCell);

    //
    // No need to initilize dispenser (InitializeSimpleTableDispenser()),
    // because we now specify USE_CRT=1 in sources, which means that
    // globals will be initialized.
    //

    hr = DllGetSimpleObjectByIDEx( eSERVERWIRINGMETA_TableDispenser, IID_ISimpleTableDispenser2, (VOID**)&spISTDisp, WSZ_PRODUCT_IIS );
    if(FAILED(hr))
    {
        DBGERROR((
            DBG_CONTEXT,
            "[%s] DllGetSimpleObjectByIDEx failed with hr = 0x%x.\n",__FUNCTION__,hr));
        goto done;
    }

    hr = spISTDisp->GetTable(
        wszDATABASE_METABASE,
        wszTABLE_MBProperty,
        (LPVOID)QueryCell,
        (LPVOID)&cCell,
        eST_QUERYFORMAT_CELLS,
        fST_LOS_DETAILED_ERROR_TABLE | fST_LOS_NO_LOGGING,
        (LPVOID *)&spISTProperty);

    //
    // Log warnings/errors in getting the mb property table
    // Do this BEFORE checking the return code of GetTable.
    //
    HRESULT hrErrorTable = GetErrorInfo(0, &spErrorInfo);
    if(hrErrorTable == S_OK) // GetErrorInfo returns S_FALSE when there is no error object
    {
        //
        // Get the ICatalogErrorLogger interface to log the errors.
        //
        hrErrorTable = spISTDisp->QueryInterface(
            IID_IAdvancedTableDispenser,
            (LPVOID*)&spISTDispAdvanced);
        if(FAILED(hrErrorTable))
        {
            DBGWARN((
                DBG_CONTEXT,
                "[%s] Could not QI for Adv Dispenser, hr=0x%x\n", __FUNCTION__, hrErrorTable));
            goto done;
        }

        hrErrorTable = spISTDispAdvanced->GetCatalogErrorLogger(&spILogger);
        if(FAILED(hrErrorTable))
        {
            DBGWARN((
                DBG_CONTEXT,
                "[%s] Could not get ICatalogErrorLogger2, hr=0x%x\n", __FUNCTION__, hrErrorTable));
            goto done;
        }

        //
        // Get the ISimpleTableRead2 interface to read the errors.
        //
        hrErrorTable =
            spErrorInfo->QueryInterface(IID_ISimpleTableRead2, (LPVOID*)&spISTError);
        if(FAILED(hrErrorTable))
        {
            DBGWARN((DBG_CONTEXT, "[%s] Could not get ISTRead2 from IErrorInfo\n, __FUNCTION__"));
            goto done;
        }

        for(ULONG iRow=0; ; iRow++)
        {
            tDETAILEDERRORSRow ErrorInfo;
            hrErrorTable = spISTError->GetColumnValues(
                iRow,
                cDETAILEDERRORS_NumberOfColumns,
                0,
                0,
                (LPVOID*)&ErrorInfo);
            if(hrErrorTable == E_ST_NOMOREROWS)
            {
                break;
            }
            if(FAILED(hrErrorTable))
            {
                DBGWARN((DBG_CONTEXT, "[%s] Could not read an error row.\n", __FUNCTION__));
                goto done;
            }

            DBG_ASSERT(ErrorInfo.pEvent);
            switch(*ErrorInfo.pEvent)
            {
            case IDS_METABASE_DUPLICATE_LOCATION:
                iRowDuplicateLocation = iRow;
                break;
            default:
                hrErrorTable =
                    spILogger->ReportError(
                        BaseVersion_DETAILEDERRORS,
                        ExtendedVersion_DETAILEDERRORS,
                        cDETAILEDERRORS_NumberOfColumns,
                        0,
                        (LPVOID*)&ErrorInfo);
                if(FAILED(hrErrorTable))
                {
                    DBGWARN((DBG_CONTEXT, "[%s] Could not log error.\n", __FUNCTION__));
                    goto done;
                }
                hr = MD_ERROR_READ_METABASE_FILE;
            }
        } // for(ULONG iRow=0; ; iRow++)
    } // if(hrErrorTable == S_OK)

    if(FAILED(hr))
    {
        DBGERROR((DBG_CONTEXT, "[%s] GetTable failed with hr = 0x%x.\n",__FUNCTION__,hr));
        goto done;
    }

    //
    // All of the stuff is read into pISTProperty.
    // Now loop through and populate in-memory cache.
    // Properties are sorted by location.
    //
    ULONG          acbMBPropertyRow[cMBProperty_NumberOfColumns];
    tMBPropertyRow MBPropertyRow;
    DWORD          dwPreviousLocationID = (DWORD)-1;
    DWORD          bufLoc = 0;
    DWORD          dSize = 0;
    const WCHAR    cSpace[2] = L" ";
    const WCHAR    cNoName[2] = L"/";
    const WCHAR    cWebDirType[17] = L"IIsWebVirtualDir";
    const WCHAR    cFtpDirType[17] = L"IIsFtpVirtualDir";
    const WCHAR    cRoot[6] = L"ROOT/";
    DWORD          dwWSLoc = (DWORD)-1;
    bool           bServCommAdded = true;
    ULONG          topIndex = 0;
    bool           bSameLocation = true;
    long           spot = 0;
    long           avail = dwMDBufferSize - 1;

    for(ULONG i=0; ;i++)
    {
        hr = spISTProperty->GetColumnValues(
            i,
            cMBProperty_NumberOfColumns,
            0,
            acbMBPropertyRow,
            (LPVOID*)&MBPropertyRow);
        if(E_ST_NOMOREROWS == hr)
        {
            hr = S_OK;
            break;
        }
        else if(FAILED(hr))
        {
            DBGINFO((DBG_CONTEXT,
                      "[ReadSomeDataFromXML] GetColumnValues failed with hr = 0x%x. Table:%ws. Read row index:%d.\n",           \
                      hr, wszTABLE_MBProperty, i));
            goto done;
        }

        if(dwPreviousLocationID != *MBPropertyRow.pLocationID)
        {
            dwPreviousLocationID = *MBPropertyRow.pLocationID;
            topIndex = i;
        }

        if(*MBPropertyRow.pID == MD_KEY_TYPE)
        {
            if (!wcscmp((LPCWSTR)MBPropertyRow.pValue, pszKeyType))
            {
                // MBPropertyRow.pLocation
                dSize = (DWORD)wcslen(MBPropertyRow.pLocation);
                spot = bufLoc + dSize;
                if (spot < avail)
                {
                    wcscpy(&(pszBuffer[bufLoc]), MBPropertyRow.pLocation);
                    pszBuffer[bufLoc + dSize] = 0;
                }
                bufLoc += dSize+1;

                dwWSLoc = *MBPropertyRow.pLocationID;

                bServCommAdded = false;

                // now check from topIndex down for a ServerComment
                hr = S_OK;
                bSameLocation = true;

                while (SUCCEEDED(hr) && !bServCommAdded && bSameLocation)
                {
                    // special case for "IIsWebVirtualDir"
                    if (!wcscmp(pszKeyType, cWebDirType) || !wcscmp(pszKeyType, cFtpDirType))
                    {
                        WCHAR* pCopy = NULL;
                        WCHAR* pPos  = NULL;

                        pCopy = _wcsdup(MBPropertyRow.pLocation);
                        if (!pCopy)
                        {
                            hr = E_OUTOFMEMORY;
                            goto done;
                        }

                        if (!_wcsupr(pCopy))
                        {
                            hr = E_FAIL;
                            goto done;
                        }

                        pPos = wcsstr(pCopy, cRoot);

                        if (pPos)
                        {
                            LONG_PTR lPos = pPos - pCopy;
                            pPos = MBPropertyRow.pLocation + lPos + wcslen(cRoot);
                        }
                        else
                        {
                            pPos = (WCHAR*)cNoName;
                        }

                        // now copy pPos if applicable
                        dSize = (DWORD)wcslen(pPos);

                        spot = bufLoc + dSize;
                        if (spot < avail)
                        {
                            wcscpy(&(pszBuffer[bufLoc]), pPos);
                            pszBuffer[bufLoc + dSize] = 0;
                        }
                        bufLoc += dSize+1;

                        free(pCopy);

                        bServCommAdded = true;
                        break;
                    }

                    hr = spISTProperty->GetColumnValues(
                        topIndex,
                        cMBProperty_NumberOfColumns,
                        0,
                        acbMBPropertyRow,
                        (LPVOID*)&MBPropertyRow);

                    if (*MBPropertyRow.pLocationID != dwWSLoc)
                    {
                        bSameLocation = false;
                        break;
                    }

                    if (*MBPropertyRow.pID == MD_SERVER_COMMENT)
                    {
                        dSize = (DWORD)wcslen((WCHAR*)MBPropertyRow.pValue);
                        spot = bufLoc + dSize;
                        if (spot < avail)
                        {
                            wcscpy(&(pszBuffer[bufLoc]), (WCHAR*)MBPropertyRow.pValue);
                            pszBuffer[bufLoc + dSize] = 0;
                        }
                        bufLoc += dSize+1;

                        bServCommAdded = true;
                    }

                    topIndex++;
                }

                if (!bServCommAdded)
                {
                    // need to add in " "
                    dSize = (DWORD)wcslen(cSpace);
                    spot = bufLoc + dSize;
                    if (spot < avail)
                    {
                        wcscpy(&(pszBuffer[bufLoc]), cSpace);
                        pszBuffer[bufLoc + dSize] = 0;
                    }
                    bufLoc += dSize+1;
                }
            }
        }
    }

    if (bufLoc < dwMDBufferSize)
    {
        pszBuffer[bufLoc] = 0;
    }
    else if (pszBuffer)
    {
        pszBuffer[dwMDBufferSize-1] = 0;
        pszBuffer[dwMDBufferSize-2] = 0;

        hr = RETURNCODETOHRESULT(ERROR_INSUFFICIENT_BUFFER);
    }

    *pdwMDRequiredBufferSize = bufLoc + 1;

done:

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\dcomadm\dll\connect.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    connect.cxx

Abstract:

    IIS DCOM Admin connection point code.

Author:

    Michael W. Thomas            02-Oct-96

Revision History:

--*/
#include "precomp.hxx"

#include <iadm.h>
#include "coiadm.hxx"

/*+==========================================================================
  File:      CONNECT.CPP

  Summary:   Implementation file for the connection points (and their
             connections) offered by the connectable objects in the
             STOSERVE server sample. COM objects are implemented for
             Connection Point Enumerators, Connection Points, and
             Connection Enumerators.

             For a comprehensive tutorial code tour of this module's
             contents and offerings see the accompanying STOSERVE.TXT
             file. For more specific technical details on the internal
             workings see the comments dispersed throughout the module's
             source code.

  Classes:   COEnumConnectionPoints, COConnectionPoint, and
             COEnumConnections.

  Functions: none.

  Origin:    6-10-96: atrent - Editor inheritance from CONSERVE OLE
             Tutorial Code Sample. Very little change was required.

----------------------------------------------------------------------------
  This file is part of the Microsoft OLE Tutorial Code Samples.

  Copyright (C) Microsoft Corporation, 1996.  All rights reserved.

  This source code is intended only as a supplement to Microsoft
  Development Tools and/or on-line documentation.  See these other
  materials for detailed information regarding Microsoft code samples.

  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
  PARTICULAR PURPOSE.
==========================================================================+*/


/*---------------------------------------------------------------------------
  We include WINDOWS.H for all Win32 applications.
  We include OLE2.H because we will be making calls to the OLE Libraries.
  We include OLECTL.H because it has definitions for connectable objects.
  We include APPUTIL.H because we will be building this application using
    the convenient Virtual Window and Dialog classes and other
    utility functions in the APPUTIL Library (ie, APPUTIL.LIB).
  We include IPAPER.H and PAPGUIDS.H for the common paper-related
    Interface class, GUID, and CLSID specifications.
  We include SERVER.H because it has internal class declarations and
    resource ID definitions specific for this DLL.
  We include CONNECT.H for object class declarations for the various
    connection point and connection COM objects used in CONSERVE.
  We include PAPER.H because it has the class COEnumConnectionPoints
    declarations as well as the COPaper class declaration.
---------------------------------------------------------------------------*/

// Helper functions

/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   SetSinkCallbackSecurityBlanket

  Summary:  Sink callbacks are vulnerable to privilege elevation attack
            It must be prevented to make callbacks through proxies that enable
            impersonation level IMPERSONATE because callbacks are happening
            on thead with SYSTEM user.
            SetSinkCallbackSecurityBlanket must be called on any sink proxy before
            any call as made

  Note:     See details on previous implementation and related bugs in
            WinSE 5611, 7579, 10575.
            Function introduced for fixing Windows Bugs 431282


  Args:     IUnknown *

  Modifies: security blanket

  Returns:  void
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/

HRESULT SetSinkCallbackSecurityBlanket(
    IUnknown            * pUnkSink )
{
    HRESULT             hr = S_OK;
    IClientSecurity     * pICS = NULL;

    DBG_ASSERT( pUnkSink != NULL );

    //
    // Check to see if we have a ClientSecurity interface
    // (meaning the sink is oop or on another thread).
    //
    hr = pUnkSink->QueryInterface( IID_IClientSecurity,
                                   (void **) &pICS );
    if ((SUCCEEDED(hr)) && (pICS != NULL))
    {
        hr = pICS->SetBlanket(pUnkSink,
                         RPC_C_AUTHN_DEFAULT,      // use NT default security
                         RPC_C_AUTHZ_DEFAULT,      // use NT default authentication
                         COLE_DEFAULT_PRINCIPAL,   //
                         RPC_C_AUTHN_LEVEL_DEFAULT,
                         RPC_C_IMP_LEVEL_IDENTIFY, // THIS IS VERY IMPORTANT
                                                   // TO KEEP IMPERSONATION LEVEL
                                                   // on IDENTIFY to PREVENT privilege
                                                   // elevation
                         COLE_DEFAULT_AUTHINFO,
                         EOAC_DEFAULT );
        pICS->Release();
        pICS = NULL;
    }
    else
    {
        //
        // in the inproc case it is OK to not to set blanket because there is no proxy
        //
        hr = S_OK;
    }
    return hr;
}



/*---------------------------------------------------------------------------
  COEnumConnectionPoints's implementation of its main COM object class
  including Constructor, Destructor, QueryInterface, AddRef, Release,
  Next, Skip, Reset, and Clone.
---------------------------------------------------------------------------*/

/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COEnumConnectionPoints::COEnumConnectionPoints

  Summary:  COEnumConnectionPoints Constructor.

  Args:     IUnknown* pHostObj
              Pointer to the host object whose connection points are
              being enumerated.

  Modifies: m_cRefs, m_pHostObj, m_iEnumIndex, m_cConnPts, and m_paConnPts.

  Returns:  void
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
COEnumConnectionPoints::COEnumConnectionPoints(
    IUnknown            * pHostObj)
{
    // Zero the COM object's reference count.
    m_cRefs = 0;

    // Assign the Host Object pointer.
    m_pHostObj = pHostObj;

    // Initialize the Connection Point enumerator variables.
    m_iEnumIndex = 0;
    m_cConnPts = 0;
    m_paConnPts = NULL;
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COEnumConnectionPoints::~COEnumConnectionPoints

  Summary:  COEnumConnectionPoints Destructor.

  Args:     void

  Modifies: m_paConnPts.

  Returns:  void
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
COEnumConnectionPoints::~COEnumConnectionPoints(void)
{
    if (NULL != m_paConnPts)
    {
        UINT i;

        // Release all the connection point interface pointers.
        for (i=0; i<m_cConnPts; i++)
        {
            if (NULL != m_paConnPts[i])
            {
                m_paConnPts[i]->Release();
            }
        }

        // Delete the array of interface pointers.
        delete [] m_paConnPts;
    }
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COEnumConnectionPoints::Init

  Summary:  COEnumConnectionPoints Initialization method.  Create any
            necessary arrays, structures, and objects.

  Args:     ULONG cConnPts,
              Number of Connections Points.
            IConnectionPoint** paConnPts,
              Pointer to array of connection point interface pointers.
            ULONG iEnumIndex
              The initial Enumerator index value.

  Modifies: m_cConnPts, m_paConnPts, m_iEnumIndex.

  Returns:  HRESULT
              Standard OLE result code. S_OK for success.
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
HRESULT COEnumConnectionPoints::Init(
    ULONG               cConnPts,
    IConnectionPoint    ** paConnPts,
    ULONG               iEnumIndex)
{
    HRESULT             hr = S_OK;
    UINT                i;

    // Remember the number of Connection points.
    m_cConnPts = cConnPts;

    // Remember the initial enumerator index.
    m_iEnumIndex = iEnumIndex;

    // Create a copy of the array of connection points and keep it inside
    // this enumerator COM object.
    m_paConnPts = new IConnectionPoint* [(UINT) cConnPts];

    // Fill the array copy with the IConnectionPoint interface pointers from
    // the array passed. AddRef for each new Interface pointer copy made.
    if (NULL != m_paConnPts)
    {
        for (i=0; i<cConnPts; i++)
        {
            m_paConnPts[i] = paConnPts[i];
            m_paConnPts[i]->AddRef();
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return (hr);
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COEnumConnectionPoints::QueryInterface

  Summary:  QueryInterface of the COEnumConnectionPoints non-delegating
            IUnknown implementation.

  Args:     REFIID riid,
              [in] GUID of the Interface being requested.
            PPVOID ppv)
              [out] Address of the caller's pointer variable that will
              receive the requested interface pointer.

  Modifies: .

  Returns:  HRESULT
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
STDMETHODIMP COEnumConnectionPoints::QueryInterface(
    REFIID              riid,
    PPVOID              ppv)
{
    HRESULT             hr = E_NOINTERFACE;

    *ppv = NULL;

    // The IEnumConnectionPoints interface is implemented directly in
    // this COM object rather than being a nested interface implementation.
    if (IID_IUnknown == riid || IID_IEnumConnectionPoints == riid)
    {
        *ppv = (LPVOID)this;
    }

    if (NULL != *ppv)
    {
        // We've handed out a pointer to the interface so obey the COM rules
        // and AddRef the reference count.
        ((LPUNKNOWN)*ppv)->AddRef();
        hr = S_OK;
    }

    return (hr);
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COEnumConnectionPoints::AddRef

  Summary:  AddRef of the COEnumConnectionPoints non-delegating IUnknown
            implementation.

  Args:     void

  Modifies: m_cRefs.

  Returns:  ULONG
              New value of m_cRefs (COM object's reference count).
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
STDMETHODIMP_(ULONG) COEnumConnectionPoints::AddRef(void)
{
    ULONG               cRefs;

    cRefs = ++m_cRefs;

    // Also AddRef the host object to ensure it stays around as long as
    // this enumerator.
    m_pHostObj->AddRef();

    return cRefs;
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COEnumConnectionPoints::Release

  Summary:  Release of the COEnumConnectionPoints non-delegating IUnknown
            implementation.

  Args:     void

  Modifies: m_cRefs.

  Returns:  ULONG
              New value of m_cRefs (COM object's reference count).
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
STDMETHODIMP_(ULONG) COEnumConnectionPoints::Release(void)
{
    ULONG               cRefs;

    // Pass this release along to the Host object being enumerated.
    m_pHostObj->Release();

    cRefs = --m_cRefs;

    if (0 == cRefs)
    {
        // We artificially bump the main ref count to prevent reentrancy via
        // the main object destructor.
        m_cRefs++;
        delete this;
    }

    return cRefs;
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COEnumConnectionPoints::Next

  Summary:  The Next member method of this IEnumConnectionPoints interface
            implementation. Called by outside clients of a
            COEnumConnectionPoints object to request that a number of next
            connection point interface pointers be deposited into an array
            supplied by the caller.

  Args:     ULONG cReq
              Number of connection points requested for return (starting at
              the current Enumerator index).
            IConnectionPoint** paConnPts,
              Pointer to a caller's output array that will receive the
              enumerated IConnectionPoint interface pointers.
            ULONG* cEnumerated)
              Pointer to a ULONG variable that will contain the number of
              connection points actually enumerated by this call.

  Modifies: .

  Returns:  HRESULT
              Standard OLE result code. S_OK for success.
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
STDMETHODIMP COEnumConnectionPoints::Next(
    ULONG               cReq,
    IConnectionPoint    ** paConnPts,
    ULONG               * pcEnumerated)
{
    HRESULT             hr = S_OK;
    ULONG               cRet = 0;

    // Make sure the argument values passed are valid.
    if (NULL != m_paConnPts)
    {
        if (NULL != paConnPts)
        {
            if (NULL != *paConnPts && m_iEnumIndex < m_cConnPts)
            {
                if (NULL != pcEnumerated)
                {
                    *pcEnumerated = 0L;
                }
                else
                {
                    if (1L != cReq)
                    {
                        hr = E_POINTER;
                    }
                }
            }
            else
            {
                hr = S_FALSE;
            }
        }
        else
        {
            hr = E_POINTER;
        }
    }
    else
    {
        hr = S_FALSE;
    }

    if (SUCCEEDED(hr))
    {
        // Starting at the current Enumerator index, loop to assign the
        // requested number of output connection point interface pointers.
        for (; m_iEnumIndex < m_cConnPts && cReq > 0;
           paConnPts++, cRet++, cReq--)
        {
            // Assign from the inside Enumerator array to the specified receiving
            // array.
            *paConnPts = m_paConnPts[m_iEnumIndex++];
            // After assigning a copy of an IConnectionPoint pointer, AddRef it.
            if (NULL != *paConnPts)
            {
                (*paConnPts)->AddRef();
            }
        }

        // Assign the output number of connection points enumerated.
        if (NULL != pcEnumerated)
        {
            *pcEnumerated = cRet;
        }
    }

    return hr;
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COEnumConnectionPoints::Skip

  Summary:  The Skip member method of this IEnumConnectionPoints interface
            implementation. Starting at the current Enumerator index, skip
            the specified number of connection point items.

  Args:     ULONG cSkip
              Number of Connection Point items to skip.

  Modifies: .

  Returns:  HRESULT
              Standard OLE result code. S_OK for success.
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
STDMETHODIMP COEnumConnectionPoints::Skip(
    ULONG               cSkip)
{
    HRESULT             hr = S_OK;

    // If there really is a connection point array and the requested
    // amount of skip does not exceed the number of connection points,
    // then bump the index by the requested skip amount.
    if (NULL != m_paConnPts && (m_iEnumIndex + cSkip) < m_cConnPts)
    {
        m_iEnumIndex += cSkip;
    }
    else
    {
        hr = S_FALSE;
    }

    return hr;
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COEnumConnectionPoints::Reset

  Summary:  The Reset member method of the IEnumConnectionPoints interface
            implementation. Resets the Enumeration index to the first
            connection point item in the array.

  Args:     void.

  Modifies: .

  Returns:  HRESULT
              Standard OLE result code. S_OK for success.
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
STDMETHODIMP COEnumConnectionPoints::Reset(void)
{
    // Zero the main Enumerator index.
    m_iEnumIndex = 0;

    return S_OK;
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COEnumConnectionPoints::Clone

  Summary:  The Clone member method of this IEnumConnectionPoints
            interface implementation. Creates a new clone of this entire
            Connection Point enumerator COM object.

  Args:     IEnumConnectionPoints** ppIEnum
              Address of the caller's output pointer variable that will
              receive the IEnumConnectionPoints interface pointer of the
              new enumerator clone.

  Modifies: ...

  Returns:  HRESULT
              Standard OLE result code. S_OK for success.
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
STDMETHODIMP COEnumConnectionPoints::Clone(
    IEnumConnectionPoints   ** ppIEnum)
{
    HRESULT                 hr;
    COEnumConnectionPoints  * pCOEnum;

    // NULL the output variable first.
    *ppIEnum = NULL;

    // Create the Clone Enumerator COM object.
    pCOEnum = new COEnumConnectionPoints(m_pHostObj);
    if (NULL != pCOEnum)
    {
        // Initialize it with same values as in this existing enumerator.
        hr = pCOEnum->Init(m_cConnPts, m_paConnPts, m_iEnumIndex);
        if (SUCCEEDED(hr))
        {
            // QueryInterface to return the requested interface pointer.
            // An AddRef will be conveniently done by the QI.
            hr = pCOEnum->QueryInterface(
                                IID_IEnumConnectionPoints,
                                (PPVOID)ppIEnum);
        }

        if( FAILED( hr ) )
        {
            delete pCOEnum;
            pCOEnum = NULL;
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}


/*---------------------------------------------------------------------------
  COConnectionPoint's implementation of its main COM object class
  including Constructor, Destructor, QueryInterface, AddRef, Release,
  GetConnectionInterface, GetConnectionPointContainer, Advise, Unadvise,
  and EnumConnections.
---------------------------------------------------------------------------*/

/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COConnectionPoint::COConnectionPoint

  Summary:  COConnectionPoint Constructor.

  Args:     IUnknown* pHostObj
              Pointer to IUnknown of the connectable object offering this
              connection point.

  Modifies: ...

  Returns:  void
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
COConnectionPoint::COConnectionPoint(void)
{
    // Initialize the Connection Point variables.
    m_pHostObj = NULL;
    m_uiMaxIndex = 0;
    m_cConnections = 0;
    m_paConnections = NULL;
    m_bTerminated = FALSE;
    m_bEnabled = TRUE;
    m_pGIT = NULL;
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COConnectionPoint::~COConnectionPoint

  Summary:  COConnectionPoint Destructor.

  Args:     void

  Modifies: m_paConnections, m_bTerminated.

  Returns:  void
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
COConnectionPoint::~COConnectionPoint(void)
{
    Terminate();
}

/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COConnectionPoint::Terminate

  Summary:  Shuts down the object. Can be called from the destructor or from the
            outer object Terminate

  Args:     void

  Modifies: m_paConnections, m_bTerminated.

  Returns:  Right now only S_OK
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
STDMETHODIMP COConnectionPoint::Terminate(void)
{
    HRESULT             hr = S_OK;
    UINT                i;

    m_Lock.WriteLock();

    if (!m_bTerminated)
    {
        if (NULL != m_paConnections)
        {
            DBG_ASSERT(m_pGIT != NULL);
            if (m_pGIT != NULL)
            {
                // Release all the connection sink interface pointers.
                for (i=0; i<m_uiMaxIndex; i++)
                {
                    if (m_paConnections[i].dwCookie != 0)
                    {
                        m_pGIT->RevokeInterfaceFromGlobal (m_paConnections[i].dwCookie);
                    }
                }
            }

            // Delete the array of interface pointers.
            delete [] m_paConnections;
            m_paConnections=NULL;

        }

        DBG_ASSERT(m_pGIT != NULL);
        if (m_pGIT)
        {
            m_pGIT->Release();
            m_pGIT = NULL;
        }

        m_uiMaxIndex = 0;
        m_cConnections = 0;
        m_bTerminated = TRUE;
    }

    m_Lock.WriteUnlock();

    return hr;
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COConnectionPoint::Init

  Summary:  COConnectionPoint Initialization method.  Create any
            necessary arrays, structures, and subordinate objects.

  Args:     IUnknown* pHostObj
              Pointer to IUnknown of the connectable object offering this
              connection point.
            REFIID riid
              Reference to the IID of the Sink interface associated with
              this connection point.

  Modifies: ...

  Returns:  HRESULT
              Standard OLE result code. S_OK for success.
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
HRESULT COConnectionPoint::Init(
    IUnknown            * pHostObj,
    REFIID              riid)
{
    HRESULT             hr = S_OK;
    CONNECTDATA         * paConns;

    if (m_bTerminated)
    {
        hr=E_UNEXPECTED;
        goto exit;
    }

    // Remember an IUnknown pointer to the connectable object that offers
    // this connection point. Since this connection point object's lifetime
    // is geared to that of the connectable object there is no need to
    // AddRef the following copied pointer to the connectable object.
    m_pHostObj = pHostObj;

    // Keep a copy of the reference to the IID of the sink interface
    // associated with this connection point. Needed for later
    // use by the GetConnectionInterface method.
    m_iidSink = riid;
    DBG_ASSERT(m_iidSink == IID_IMSAdminBaseSink_W);

    // Build the initial dynamic array for connections.
    paConns = new CONNECTDATA[ALLOC_CONNECTIONS];
    if (NULL != paConns)
    {
        // Zero the array.
        memset(paConns, 0, ALLOC_CONNECTIONS * sizeof(CONNECTDATA));

        // Rig this connection point object so that it will use the
        // new internal array of connections.
        m_uiMaxIndex = ALLOC_CONNECTIONS;
        m_paConnections = paConns;

        hr = CoCreateInstance (
                CLSID_StdGlobalInterfaceTable,
                NULL,
                CLSCTX_INPROC_SERVER,
                IID_IGlobalInterfaceTable,
                (void **)&m_pGIT
                );
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

exit:
    return (hr);
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COConnectionPoint::QueryInterface

  Summary:  QueryInterface of the COConnectionPoint non-delegating
            IUnknown implementation.

  Args:     REFIID riid,
              [in] GUID of the Interface being requested.
            PPVOID ppv)
              [out] Address of the caller's pointer variable that will
              receive the requested interface pointer.

  Modifies: .

  Returns:  HRESULT
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
STDMETHODIMP COConnectionPoint::QueryInterface(
    REFIID              riid,
    PPVOID              ppv)
{
    HRESULT             hr = E_NOINTERFACE;

    if (ppv)
    {
        *ppv = NULL;
    }
    else
    {
        hr=E_POINTER;
        goto exit;
    }

    if (m_bTerminated)
    {
        hr=E_UNEXPECTED;
        goto exit;
    }

    // The IConnectionPoint interface is implemented directly in this
    // COM object rather than being a nested interface implementation.
    if (IID_IUnknown == riid || IID_IConnectionPoint == riid)
    {
        *ppv = (LPVOID)this;
    }

    if (NULL != *ppv)
    {
        // We've handed out a pointer to the interface so obey the COM rules
        // and AddRef the reference count.
        ((LPUNKNOWN)*ppv)->AddRef();
        hr = S_OK;
    }

exit:
    return (hr);
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COConnectionPoint::AddRef

  Summary:  AddRef of the COConnectionPoint non-delegating IUnknown
            implementation.

  Args:     void

  Modifies: .

  Returns:  ULONG
              New value of the host objects m_cRefs (COM object's reference count).
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
STDMETHODIMP_(ULONG) COConnectionPoint::AddRef(void)
{
    if (m_bTerminated)
    {
        return 1;
    }
    else
    {
        return m_pHostObj->AddRef();
    }
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COConnectionPoint::Release

  Summary:  Release of the COConnectionPoint non-delegating IUnknown
            implementation.

  Args:     void

  Modifies: .

  Returns:  ULONG
              New value of m_cRefs (COM object's reference count).
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
STDMETHODIMP_(ULONG) COConnectionPoint::Release(void)
{
    if (m_bTerminated)
    {
        return 0;
    }
    else
    {
        return m_pHostObj->Release();
    }
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COConnectionPoint::GetSlot

  Summary:  An internal private utility member method to obtain a free
            slot in the dynamic connections array. GetSlot will expand the
            dynamic array for more entries if needed. To guarantee thread
            safety, this private method should always be called within the
            protection of a bracketed OwnThis, UnOwnThis pair.

  Args:     UINT* puiFreeSlot
              Address of an output variable to receive the free slot index.

  Modifies: m_uiMaxIndex, m_paConnections.

  Returns:  HRESULT
              Standard OLE result code. S_OK for success.
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
HRESULT COConnectionPoint::GetSlot(
    UINT                * puiFreeSlot)
{
    HRESULT             hr = S_OK;
    BOOL                bOpen = FALSE;
    UINT                i;
    CONNECTDATA         * paConns;

    // Zero the output variable.
    *puiFreeSlot = 0;

    if (m_bTerminated)
    {
        hr = E_UNEXPECTED;
        goto exit;
    }

    // Loop to find an empty slot.
    for (i=0; i<m_uiMaxIndex; i++)
    {
        if (m_paConnections[i].dwCookie == 0)
        {
            // We found an open empty slot.
            *puiFreeSlot = i;
            bOpen = TRUE;
            break;
        }
    }

    if (!bOpen)
    {
        // We didn't find an existing open slot in the array--it's full.
        // Expand the array by ALLOC_CONNECTIONS entries and assign the
        // appropriate output index.
        paConns = new CONNECTDATA[m_uiMaxIndex + ALLOC_CONNECTIONS];
        if (NULL != paConns)
        {
            // Copy the content of the old full array to the new larger array.
            for (i=0; i<m_uiMaxIndex; i++)
            {
                paConns[i].pUnk = m_paConnections[i].pUnk;
                paConns[i].dwCookie = m_paConnections[i].dwCookie;
            }

            // Zero (ie mark as empty) the expanded portion of the new array.
            for (i=m_uiMaxIndex; i<m_uiMaxIndex+ALLOC_CONNECTIONS; i++)
            {
                paConns[i].pUnk = NULL;
                paConns[i].dwCookie = 0;
            }

            // New larger array is ready--delete the old array.
            delete [] m_paConnections;

            // Rig the connection point to use the new larger array.
            m_paConnections = paConns;

            // Assign the output free slot as first entry in new expanded area.
            *puiFreeSlot = m_uiMaxIndex;

            // Calculate the new max index.
            m_uiMaxIndex += ALLOC_CONNECTIONS;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

exit:
    return hr;
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COConnectionPoint::FindSlot

  Summary:  An internal private utility member method to find an existing
            slot (identified by the specified dwCookie value) in the
            dynamic connections array.

  Args:     DWORD dwCookie,
              The connection key (cookie) to find.
            UINT* puiSlot)
              Address of an output variable to receive the slot index.

  Modifies: ...

  Returns:  HRESULT
              Standard OLE result code. S_OK for success.
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
HRESULT COConnectionPoint::FindSlot(
    DWORD               dwCookie,
    UINT                * puiSlot)
{
    HRESULT             hr = CONNECT_E_NOCONNECTION;
    UINT                i;

    if (m_bTerminated)
    {
        hr = E_UNEXPECTED;
        goto exit;
    }

    // Loop to find the Cookie.
    for (i=0; i<m_uiMaxIndex; i++)
    {
        if (dwCookie == m_paConnections[i].dwCookie)
        {
            // If a cookie match is found, assign the output slot index.
            *puiSlot = i;
            hr = S_OK;
            break;
        }
    }

exit:
    return hr;
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COConnectionPoint::GetConnectionInterface

  Summary:  The GetConnectionInterface member method of this
            IConnectionPoint interface implementation. Called to get the
            IID of the Sink interface associated with this connection
            point.

  Args:     IID* piidSink
              Pointer to the IID of the associated sink interface.

  Modifies: .

  Returns:  HRESULT
              Standard OLE result code. S_OK for success.
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
STDMETHODIMP COConnectionPoint::GetConnectionInterface(
    IID                 * piidSink)
{
    HRESULT             hr = S_OK;

    if (m_bTerminated)
    {
        hr = E_UNEXPECTED;
        goto exit;
    }

    if (NULL != piidSink)
    {
        *piidSink = m_iidSink;
    }
    else
    {
        hr = E_POINTER;
    }

exit:
  return hr;
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COConnectionPoint::GetConnectionPointContainer

  Summary:  The GetConnectionPointContainer member method of this
            IConnectionPoint interface implementation. Called to get the
            connection point container that contains this connection
            point.

  Args:     IConnectionPointContainer** ppConnPtCon
              Address of the pointer variable that will recieve the
              IConnectionPointContainer interface pointer.

  Modifies: .

  Returns:  HRESULT
              Standard OLE result code. S_OK for success.
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
STDMETHODIMP COConnectionPoint::GetConnectionPointContainer(
    IConnectionPointContainer   ** ppConnPtCon)
{
    HRESULT                     hr;

    if (m_bTerminated)
    {
        hr = E_UNEXPECTED;
    }
    else
    {
        // Use QueryInterface to get the interface pointer and to perform the
        // needed AddRef on the returned pointer.
        hr = m_pHostObj->QueryInterface(
                            IID_IConnectionPointContainer,
                            (PPVOID) ppConnPtCon);
    }

    return hr;
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COConnectionPoint::Advise

  Summary:  The Advise member method of this IConnectionPoint interface
            implementation. Called by clients to establish a connection of
            their sink to this connection point. Uses the CThreaded
            OwnThis mechanism to provide mutually exclusive access by
            multiple threads.

  Args:     IUnknown* pUnkSink
              IUnknown interface pointer of the Sink object in the client.
            DWORD* pdwCookie
              Pointer to a DWORD in the client that will receive a unique
              key used by the client to refer to the connection established
              by this Advise call.

  Modifies: ...

  Returns:  HRESULT
              Standard OLE result code. S_OK for success.
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
STDMETHODIMP COConnectionPoint::Advise(
    IUnknown            * pUnkSink,
    DWORD               * pdwCookie)
{
    HRESULT             hr = S_OK;
    UINT                uiFreeSlot = 0;
    IUnknown            * pISink = NULL;
    DWORD               dwCookie = 0;

    //
    // Lock was moved after the QI calls to eliminate long calls under lock
    //

    // Zero the output connection key.
    *pdwCookie = 0;

    if (m_bTerminated)
    {
        hr = E_UNEXPECTED;
        goto exit;
    }

    // It is necessary to set ProxyBlanket
    // to prevent privilege elevation by client
    // since callbacks would otherwise happen with impersonated SYSTEM
    // user

    hr = SetSinkCallbackSecurityBlanket( pUnkSink );

    if (SUCCEEDED(hr))
    {
        //
        // Verify if m_iidSink is supported
        //
        hr = pUnkSink->QueryInterface(m_iidSink, (PPVOID)&pISink);

        if (hr == E_NOINTERFACE)
        {
            hr = CONNECT_E_CANNOTCONNECT;
        }
    }

    if (FAILED(hr))
    {
        goto exit;
    }

    //
    // We will lock only after the QI call was made
    // to eliminate locking the resource for the long time
    // So far there was no data requiring synchronization.
    //
    m_Lock.WriteLock();

    if (SUCCEEDED(hr)&&m_bTerminated)
    {
        hr = E_UNEXPECTED;
    }

    if (SUCCEEDED(hr))
    {
        // Store the specific sink interface in this connection point's
        // array of live connections. First find a free slot (expand the
        // array if needed).
        hr = GetSlot(&uiFreeSlot);
        if (SUCCEEDED(hr))
        {
            //
            // store interface ref in GIP
            //
            if (pISink != NULL)
            {
                DBG_ASSERT(m_pGIT != NULL);
                hr = m_pGIT->RegisterInterfaceInGlobal (pUnkSink, IID_IUnknown, &dwCookie);
                if (SUCCEEDED(hr))
                {
                    m_paConnections[uiFreeSlot].pUnk = NULL;
                    m_paConnections[uiFreeSlot].dwCookie = dwCookie;

                    // Assign the output Cookie value.
                    *pdwCookie = dwCookie;

                    // Increment the number of live connections.
                    m_cConnections++;
                }
            }
        }
    }

    m_Lock.WriteUnlock();

exit:
    //
    // Cleanup
    //

    if ( pISink != NULL )
    {
        pISink->Release();
        pISink = NULL;
    }

  return hr;
}

/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COConnectionPoint::Unadvise

  Summary:  The Unadvise member method of this IConnectionPoint interface
            implementation. Called by clients to disconnect a connection
            of their sink to this connection point. The connection is
            identified by the dwCookie argument (obtained by a previous
            Advise call). Uses the CThreaded OwnThis mechanism to provide
            mutually exclusive access by multiple threads.

  Args:     DWORD dwCookie
              Connection key that was obtained by a previous Advise call.

  Modifies: .

  Returns:  HRESULT
              Standard OLE result code. S_OK for success.
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/

STDMETHODIMP COConnectionPoint::Unadvise(
    DWORD               dwCookie)
{
    HRESULT             hr;

    if ( m_bTerminated )
    {
        hr = E_UNEXPECTED;
        goto exit;
    }

    m_Lock.WriteLock();

    if ( m_bTerminated )
    {
        hr = E_UNEXPECTED;
    }
    else
    {
        hr = Unadvise_Worker( dwCookie );
    }

    // If we unadvised the last listener remove all notifications for the
    // host ABO object in the notifications queue
    if ( ( hr != E_UNEXPECTED ) && ( m_cConnections == 0 ) )
    {
        m_Lock.ConvertExclusiveToShared();
        if ( m_cConnections == 0 )
        {
            ((CADMCOMW*)m_pHostObj)->RemoveAllPendingNotifications( FALSE );
        }
        m_Lock.ReadUnlock();
    }
    else
    {
        m_Lock.WriteUnlock();
    }

exit:
    // Done
    return hr;
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COConnectionPoint::ListenersPresent

  Summary:  Checks whether there are any listeners (sinks) presently registered
            for notifications. Acquires read lock.

  Args:     None

  Modifies: None

  Returns:  HRESULT
            S_OK if sending notifications is enabled and there is at least one registered listener sink for notifications.
            S_FALSE if sending notifications is disabled or there are no registered listeners.
            E_UNEXPECTED if the object was already terminated.
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
STDMETHODIMP
COConnectionPoint::ListenersPresent(VOID)
{
    HRESULT             hr = S_OK;

    m_Lock.ReadLock();

    // Already terminated?
    if ( m_bTerminated )
    {
        hr = E_UNEXPECTED;
        goto exit;
    }

    // If disabled
    if ( !m_bEnabled )
    {
        // Don't send any notifications
        hr = S_FALSE;
        goto exit;
    }

    // Any listeners currently?
    if ( m_cConnections == 0 )
    {
        // No listeners
        hr = S_FALSE;
        goto exit;
    }

exit:
    m_Lock.ReadUnlock();

    // Done
    return hr;
}

/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COConnectionPoint::Disable

  Summary:  Set m_bEnabled to FALSE. This will cause ListenersPresent to return S_FALSE ever after.
            Acquires write lock.

  Args:     None

  Modifies: None

  Returns:  HRESULT
            S_OK
            E_UNEXPECTED if the object was already terminated.
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
STDMETHODIMP
COConnectionPoint::Disable(VOID)
{
    HRESULT             hr = S_OK;

    m_Lock.WriteLock();

    // Already terminated?
    if ( m_bTerminated )
    {
        hr = E_UNEXPECTED;
        goto exit;
    }

    // Disable
    m_bEnabled = FALSE;

exit:
    m_Lock.WriteUnlock();

    // Done
    return hr;
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COConnectionPoint::Unadvise_Worker

  Summary:  Does the actual work of Unadvise. Assume a write lock is already
            held.

  Args:     DWORD dwCookie
              Connection key that was obtained by a previous Advise call.

  Modifies: .

  Returns:  HRESULT
              Standard OLE result code. S_OK for success.
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/

STDMETHODIMP
COConnectionPoint::Unadvise_Worker(
    DWORD               dwCookie)
{
    HRESULT             hr = S_OK;
    UINT                uiSlot;

    if (m_bTerminated)
    {
        hr = E_UNEXPECTED;
        goto exit;
    }

    if ( 0 == dwCookie )
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    hr = FindSlot(dwCookie, &uiSlot);
    if ( FAILED( hr ) )
    {
        goto exit;
    }

    DBG_ASSERT(m_pGIT != NULL);
    if (m_pGIT != NULL)
    {
        m_pGIT->RevokeInterfaceFromGlobal (dwCookie);
    }

    // Mark the array entry as empty.
    m_paConnections[uiSlot].dwCookie = 0;

    // nothing is supposed to be stored in  m_paConnections[uiSlot].pUnk
    DBG_ASSERT( m_paConnections[uiSlot].pUnk == NULL );

    // Decrement the number of live connections.
    m_cConnections--;

exit:
    return hr;
}

/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COConnectionPoint::EnumConnections

  Summary:  The EnumConnections member method of this IConnectionPoint
            interface implementation. Called to obtain an IEnumConnections
            enumerator interface that can be used to enumerate the
            connections of this connection point. Uses the CThreaded
            OwnThis mechanism to ensure mutually exclusive access by
            multiple threads.

  Args:     IEnumConnections** ppIEnum
              Address of the caller's output pointer variable that will
              receive the enumerator IEnumConnections interface pointer.

  Modifies: ...

  Returns:  HRESULT
              Standard OLE result code. S_OK for success.
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
STDMETHODIMP COConnectionPoint::EnumConnections(
    IEnumConnections    ** ppIEnum)
{
    HRESULT             hr = OLE_E_NOCONNECTION;
    CONNECTDATA         * paConns;
    COEnumConnections   * pCOEnum;
    UINT                i,j;

    if (ppIEnum)
    {
        // Zero the output enumerator interface pointer.
        *ppIEnum = NULL;
    }
    else
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    if (m_bTerminated)
    {
        hr = E_UNEXPECTED;
        goto exit;
    }

    m_Lock.ReadLock();

    if (m_bTerminated)
    {
        hr = E_UNEXPECTED;
    }
    else
    {
        if (0 != m_cConnections)
        {
            // Create an array of CONNECTDATA structures.
            paConns = new CONNECTDATA[(UINT)m_cConnections];
            if (NULL != paConns)
            {
                for (i=0, j=0; i<m_uiMaxIndex && j<m_cConnections; i++)
                {
                    // Copy non-empty entries only.
                    if (0 != m_paConnections[i].dwCookie)
                    {
                      //
                      // Assign the occupied entry
                      //

                      paConns[j].dwCookie = m_paConnections[i].dwCookie;
                      paConns[j].pUnk = m_paConnections[i].pUnk;
                      j++;
                    }
                }

                //
                // Create a new COM object for enumerating connections. Pass
                // 'this' as a pHostObj pointer used later to ensure the host
                // connection point object stays alive as long as the enumerator
                // that enumerates connections to that connection point.
                //

                pCOEnum = new COEnumConnections(this);
                if (NULL != pCOEnum)
                {
                    // Use the previously constructed (paConns) array of connections
                    // to init the new COEnumConnections COM object. The Init will
                    // build yet another internal copy of this array. Set the
                    // initial enumerator index to 0.
                    hr = pCOEnum->Init(m_cConnections, paConns, 0, m_pGIT);

                    // QueryInterface to return the requested interface pointer.
                    // An AddRef will be conveniently done by the QI.
                    if (SUCCEEDED(hr))
                    {
                      hr = pCOEnum->QueryInterface(
                                        IID_IEnumConnections,
                                        (PPVOID)ppIEnum);
                    }

                    if (FAILED(hr))
                    {
                      delete pCOEnum;
                    }
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }

                // We're done with the locally constructed array copy--delete it.
                delete [] paConns;

            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }

    m_Lock.ReadUnlock();

exit:
    return hr;
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COConnectionPoint::InternalEnumSinks

  Summary:  Returns a copy of the CONNECTDATA array.

  Returns:  HRESULT
              Standard OLE result code. S_OK for success.
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
STDMETHODIMP
COConnectionPoint::InternalEnumSinks(
    CONNECTDATA         **prgConnections,
    ULONG               *pcConnections)
{
    // Locals
    HRESULT             hr = S_OK;
    BOOL                fUnlock = FALSE;
    CONNECTDATA         *pConns = NULL;
    ULONG               cConns = 0;
    ULONG               i;
    ULONG               j;
    IUnknown            *pUnkSink = NULL;

    // Check args
    if ( ( prgConnections == NULL ) || ( pcConnections == NULL ) )
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Init
    *prgConnections = NULL;
    *pcConnections = 0;

    m_Lock.ReadLock();
    fUnlock = TRUE;

    cConns = m_cConnections;

    if ( m_pGIT == NULL )
    {
        DBG_ASSERT( m_pGIT != NULL );
        hr = E_FAIL;
        goto exit;
    }

    // Any listeners?
    if ( cConns == 0 )
    {
        goto exit;
    }

    // Create an array of CONNECTDATA structures.
    pConns = new CONNECTDATA[cConns];
    if ( pConns == NULL )
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    // Set to 0.
    memset( pConns, 0, sizeof(CONNECTDATA)*cConns );

    // Copy
    for ( i = 0, j = 0; ( i<m_uiMaxIndex ) && ( j<cConns ); i++ )
    {
        // Copy non-empty entries only.
        if ( m_paConnections[i].dwCookie == 0 )
        {
            continue;
        }

        // Unmarshal
        hr = m_pGIT->GetInterfaceFromGlobal( m_paConnections[i].dwCookie,
                                             IID_IUnknown,
                                             (VOID**)&pUnkSink );
        if ( FAILED( hr ) )
        {
            goto exit;
        }

        DBG_ASSERT( pUnkSink != NULL );

        // It is necessary to set ProxyBlanket
        // to prevent privilege elevation by client
        // since callbacks would otherwise happen with impersonated SYSTEM user
        hr = SetSinkCallbackSecurityBlanket( pUnkSink );
        if ( FAILED( hr ) )
        {
            goto exit;
        }

        // Assign the occupied entry.
        pConns[j].pUnk = pUnkSink;
        pUnkSink = NULL;
        pConns[j].dwCookie = m_paConnections[i].dwCookie;
        j++;
    }

    // Return
    *prgConnections = pConns;
    *pcConnections = cConns;

    // Don't delete
    pConns = NULL;
    cConns = 0;

exit:
    if ( fUnlock )
    {
        m_Lock.ReadUnlock();
    }

    if ( pUnkSink != NULL )
    {
        pUnkSink->Release();
        pUnkSink = NULL;
    }

    if ( pConns != NULL )
    {
        for ( j = 0; j<cConns; j++ )
        {
            if ( pConns[j].pUnk != NULL )
            {
                pConns[j].pUnk->Release();
                pConns[j].pUnk = NULL;
            }
        }

        delete [] pConns;
        pConns = NULL;
    }

    return hr;
}


/*---------------------------------------------------------------------------
  COEnumConnections's implementation of its main COM object class
  including Constructor, Destructor, QueryInterface, AddRef, Release,
  Next, Skip, Reset, and Clone.
---------------------------------------------------------------------------*/

/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COEnumConnections::COEnumConnections

  Summary:  COEnumConnections Constructor.

  Args:     IUnknown* pHostObj
              Pointer to IUnknown interface of the host Connection Point
              COM object whose connections are being enumerated.

  Modifies: m_cRefs, m_pHostObj, m_iEnumIndex, m_cConnections,
            and m_paConnections.

  Returns:  void
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
COEnumConnections::COEnumConnections(
    IUnknown*           pHostObj)
{
    // Zero the COM object's reference count.
    m_cRefs = 0;

    // Assign the Host Object pointer.
    m_pHostObj = pHostObj;

    // Initialize the Connection Point enumerator variables.
    m_iEnumIndex = 0;
    m_cConnections = 0;
    m_paConnections = NULL;
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COEnumConnections::~COEnumConnections

  Summary:  COEnumConnections Destructor.

  Args:     void

  Modifies: m_paConnections.

  Returns:  void
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
COEnumConnections::~COEnumConnections(void)
{
    if (NULL != m_paConnections)
    {
        UINT i;

        // Release all the connected sink interface pointers.
        for (i=0; i<m_cConnections; i++)
        {
            if (m_paConnections[i].pUnk != NULL)
            {
                m_paConnections[i].pUnk->Release();
            }
        }

        // Delete the array of connections.
        delete [] m_paConnections;
    }
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COEnumConnections::Init

  Summary:  COEnumConnections Initialization method.  Create any
            necessary arrays, structures, and objects.

  Args:     ULONG cConnections
              Number of Connections.
            CONNECTDATA* paConnections,
              Pointer to array of connections.
            ULONG iEnumIndex
              The Enumerator index initial value.

  Modifies: m_cConnections, m_paConnections, m_pHostObj, m_iEnumIndex.

  Returns:  HRESULT
              Standard OLE result code. S_OK for success.
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
HRESULT COEnumConnections::Init(
    ULONG                   cConnections,
    CONNECTDATA             * paConnections,
    ULONG                   iEnumIndex,
    IGlobalInterfaceTable   * pGIT)
{
    HRESULT                 hr = S_OK;
    UINT                    i;
    IUnknown                * pUnkSink = NULL;
    IUnknown                * pISink = NULL;

    // Remember the number of live Connections.
    m_cConnections = cConnections;

    // Remember the initial enumerator index.
    m_iEnumIndex = iEnumIndex;

    // Create a copy of the array of connections and keep it inside
    // this enumerator COM object.
    m_paConnections = new CONNECTDATA [(UINT) cConnections];

    // Fill the array copy with the connection data from the connections
    // array passed. AddRef for each new sink Interface pointer copy made.
    if (NULL != m_paConnections)
    {
        for (i=0; (i < cConnections) ; i++)
        {
            m_paConnections[i].dwCookie = paConnections[i].dwCookie;
            m_paConnections[i].pUnk = NULL;

            if (SUCCEEDED(hr))
            {
                //
                // Get the interface.
                // Don't do this after a failure, to avoid overriding a previous
                // error code.
                //

                if (pGIT != NULL)
                {
                    hr = pGIT->GetInterfaceFromGlobal(m_paConnections[i].dwCookie,
                                                    IID_IUnknown,
                                                    (void**)&( pUnkSink ));

                    if(SUCCEEDED(hr) && pUnkSink != NULL)
                    {
                        //
                        // It is necessary to set ProxyBlanket
                        // to prevent privilege elevation by client
                        // since callbacks would otherwise happen with impersonated SYSTEM user
                        //

                        hr = SetSinkCallbackSecurityBlanket( pUnkSink );
                        if ( SUCCEEDED( hr ) )
                        {

                            hr = pUnkSink->QueryInterface(IID_IMSAdminBaseSink_W,
                                                             (void **)&(pISink) );

                            if ( SUCCEEDED( hr ) )
                            {
                                //
                                // We have to set blanket again for pISink
                                //

                                hr = SetSinkCallbackSecurityBlanket( pISink );
                                if ( SUCCEEDED( hr ) )
                                {
                                    DBG_ASSERT( m_paConnections[i].pUnk == NULL );
                                    m_paConnections[i].pUnk = pISink;
                                    pISink = NULL;
                                }
                            }
                        }

                        pUnkSink->Release();
                        pUnkSink = NULL;
                    }
                }
                else
                {
                    //
                    // This case only occurs when Clone is called, in which case the pUnk field
                    // is valid.
                    //

                    DBG_ASSERT(paConnections[i].pUnk != NULL);
                    hr = paConnections[i].pUnk->QueryInterface(IID_IMSAdminBaseSink_W,
                                                             (void **)&(m_paConnections[i].pUnk));
                }
            }
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    if ( pUnkSink != NULL )
    {
        pUnkSink->Release();
        pUnkSink = NULL;
    }

    if ( pISink != NULL )
    {
        pISink->Release();
        pISink = NULL;
    }

    return (hr);
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COEnumConnections::QueryInterface

  Summary:  QueryInterface of the COEnumConnections non-delegating
            IUnknown implementation.

  Args:     REFIID riid,
              [in] GUID of the Interface being requested.
            PPVOID ppv)
              [out] Address of the caller's pointer variable that will
              receive the requested interface pointer.

  Modifies: .

  Returns:  HRESULT
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
STDMETHODIMP COEnumConnections::QueryInterface(
    REFIID              riid,
    PPVOID              ppv)
{
    HRESULT             hr = E_NOINTERFACE;

    *ppv = NULL;

    // The IEnumConnections interface is implemented directly in
    // this COM object rather than being a nested interface implementation.
    if (IID_IUnknown == riid || IID_IEnumConnections == riid)
    {
        *ppv = (LPVOID)this;
    }

    if (NULL != *ppv)
    {
        // We've handed out a pointer to the interface so obey the COM rules
        // and AddRef the reference count.
        ((LPUNKNOWN)*ppv)->AddRef();
        hr = S_OK;
    }

    return (hr);
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COEnumConnections::AddRef

  Summary:  AddRef of the COEnumConnections non-delegating IUnknown
            implementation.

  Args:     void

  Modifies: m_cRefs.

  Returns:  ULONG
              New value of m_cRefs (COM object's reference count).
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
STDMETHODIMP_(ULONG) COEnumConnections::AddRef(void)
{
    ULONG               cRefs;

    cRefs = InterlockedIncrement((long *)&m_cRefs);

    // Also AddRef the host object to ensure it stays around as long as
    // this enumerator.
    m_pHostObj->AddRef();

    return cRefs;
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COEnumConnections::Release

  Summary:  Release of the COEnumConnections non-delegating IUnknown
            implementation.

  Args:     void

  Modifies: m_cRefs.

  Returns:  ULONG
              New value of m_cRefs (COM object's reference count).
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
STDMETHODIMP_(ULONG) COEnumConnections::Release(void)
{
    ULONG               cRefs;

    // Pass this release along to the Host object being enumerated.
    m_pHostObj->Release();

    cRefs = InterlockedDecrement((long *)&m_cRefs);

    if (0 == cRefs)
    {
        // We artificially bump the main ref count to prevent reentrancy via
        // the main object destructor.
        InterlockedIncrement((long *)&m_cRefs);
        delete this;
    }

    return cRefs;
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COEnumConnections::Next

  Summary:  The Next member method of this IEnumConnections interface
            implementation. Called by outside clients of a
            COEnumConnections object to request a number of next
            connections be returned in an array supplied by the caller.

  Args:     ULONG cReq
              Number of connection points requested for return (starting at
              the current Enumerator index).
            CONNECTDATA* paConnections,
              Pointer to a caller's output array that will receive the
              enumerated connection data structures.
            ULONG* pcEnumerated)
              Pointer to a ULONG variable that will contain the number of
              connection points actually enumerated by this call.

  Modifies: .

  Returns:  HRESULT
              Standard OLE result code. S_OK for success.
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
STDMETHODIMP COEnumConnections::Next(
    ULONG               cReq,
    CONNECTDATA         * paConnections,
    ULONG               * pcEnumerated)
{
    HRESULT             hr = S_OK;
    ULONG               cRet = 0;

    // Make sure the argument values passed are valid.
    if (NULL != m_paConnections)
    {
        if (NULL != paConnections)
        {
            if (m_iEnumIndex < m_cConnections)
            {
                if (NULL != pcEnumerated)
                {
                    *pcEnumerated = 0L;
                }
                else
                {
                    if (1L != cReq)
                    {
                        hr = E_POINTER;
                    }
                }
            }
            else
            {
                hr = S_FALSE;
            }
        }
        else
        {
            hr = E_POINTER;
        }
    }
    else
    {
        hr = S_FALSE;
    }

    if (SUCCEEDED(hr))
    {
        // Starting at the current Enumerator index, loop to assign the
        // requested number of output connection data structures.
        for (; m_iEnumIndex < m_cConnections && cReq > 0;
               paConnections++, m_iEnumIndex++, cRet++, cReq--)
        {
            // Because we are assigning a copy of a connection's data, AddRef
            // its sink interface pointer.
            if (NULL != m_paConnections[m_iEnumIndex].pUnk)
            {
                m_paConnections[m_iEnumIndex].pUnk->AddRef();
            }

            // Assign a connection's data from the inside Enumerator array to
            // the specified output receiving array.
            *paConnections = m_paConnections[m_iEnumIndex];
        }

        // Assign the output number of connections enumerated.
        if (NULL != pcEnumerated)
        {
            *pcEnumerated = cRet;
        }
    }

    return hr;
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COEnumConnections::Skip

  Summary:  The Skip member method of this IEnumConnections interface
            implementation. Starting at the current Enumerator index, skip
            the specified number of connection items.

  Args:     ULONG cSkip
              Number of Connection items to skip.

  Modifies: .

  Returns:  HRESULT
              Standard OLE result code. S_OK for success.
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
STDMETHODIMP COEnumConnections::Skip(
    ULONG               cSkip)
{
    HRESULT             hr = S_OK;

    // If there really is a connection array and the requested
    // amount of skip does not exceed the number of connections,
    // then bump the index by the requested skip amount.
    if (NULL != m_paConnections && (m_iEnumIndex + cSkip) < m_cConnections)
    {
        m_iEnumIndex += cSkip;
    }
    else
    {
        hr = S_FALSE;
    }

    return hr;
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COEnumConnections::Reset

  Summary:  The Reset member method of the IEnumConnections interface
            implementation. Resets the Enumeration index to the first
            connection item in the array.

  Args:     void.

  Modifies: .

  Returns:  HRESULT
              Standard OLE result code. S_OK for success.
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
STDMETHODIMP COEnumConnections::Reset(void)
{
    // Zero the main Enumerator index.
    m_iEnumIndex = 0;

    return S_OK;
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COEnumConnections::Clone

  Summary:  The Clone member method of this IEnumConnections interface
            implementation. Creates a new clone of this entire Connection
            enumerator COM object and returns a pointer to its
            IEnumConnections interface.

  Args:     IEnumConnections** ppIEnum
              Address of the caller's output pointer variable that will
              receive the IEnumConnections interface pointer of the
              new enumerator clone.

  Modifies: ...

  Returns:  HRESULT
              Standard OLE result code. S_OK for success.
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
STDMETHODIMP COEnumConnections::Clone(
    IEnumConnections    ** ppIEnum)
{
    HRESULT             hr;
    COEnumConnections   * pCOEnum;

    // NULL the output variable first.
    *ppIEnum = NULL;

    // Create the Clone Enumerator COM object.
    pCOEnum = new COEnumConnections(m_pHostObj);
    if (NULL != pCOEnum)
    {
        // Initialize it with same values as in this existing enumerator.
        hr = pCOEnum->Init(m_cConnections, m_paConnections, m_iEnumIndex);
        if (SUCCEEDED(hr))
        {
            // QueryInterface to return the requested interface pointer.
            // An AddRef will be conveniently done by the QI.
            hr = pCOEnum->QueryInterface(
                            IID_IEnumConnections,
                            (PPVOID)ppIEnum);
        }

        if( FAILED( hr ) )
        {
            delete pCOEnum;
            pCOEnum = NULL;
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\dcomadm\dll\globlist.cxx ===
/*++

   Copyright    (c)    1997    Microsoft Corporation

   Module  Name :

       globlist.cxx

   Abstract:

       Global object list for DCOMADM.

   Author:

       Michael Thomas (michth)   4-June-1997

--*/
#include "precomp.hxx"

#include <iadm.h>
#include "coiadm.hxx"
#include "admacl.hxx"

CRITICAL_SECTION    CADMCOMW::sm_csObjectListLock;
LIST_ENTRY          CADMCOMW::sm_ObjectList = { NULL, NULL };
BOOL                CADMCOMW::sm_fShutdownInProgress = FALSE;

PTRACE_LOG CADMCOMW::sm_pDbgRefTraceLog = NULL;

DECLARE_PLATFORM_TYPE();

// static
VOID
CADMCOMW::InitObjectList()
{
    InitializeListHead( &sm_ObjectList );

    INITIALIZE_CRITICAL_SECTION( &sm_csObjectListLock );

    sm_fShutdownInProgress = FALSE;

    sm_pDbgRefTraceLog = CreateRefTraceLog( 4096, 0 );

    NOTIFY_CONTEXT::Initialize();
}

// static
VOID
CADMCOMW::TerminateObjectList()
{
    NOTIFY_CONTEXT::Terminate();

    DBG_ASSERT( IsListEmpty( &sm_ObjectList ) );

    sm_ObjectList.Flink = NULL;
    sm_ObjectList.Blink = NULL;

    DeleteCriticalSection( &sm_csObjectListLock );

    if( sm_pDbgRefTraceLog )
    {
        DestroyRefTraceLog( sm_pDbgRefTraceLog );
        sm_pDbgRefTraceLog = NULL;
    }
}

VOID
CADMCOMW::AddObjectToList()
{
    DBG_ASSERT( IsListEmpty( &m_ObjectListEntry ) );

    GetObjectListLock();

    AddRef();
    InsertHeadList( &sm_ObjectList, &m_ObjectListEntry );

    ReleaseObjectListLock();
}

BOOL
CADMCOMW::RemoveObjectFromList(
    BOOL                bIgnoreShutdown )
{
    BOOL                bRemovedIt = FALSE;

    // Stop getting and firing notifications.
    // Assuming this is a gracefull termination do not remove any pending notifications
    StopNotifications( FALSE );

    if( !bIgnoreShutdown && sm_fShutdownInProgress )
    {
        goto exit;
    }

    GetObjectListLock();

    if( bIgnoreShutdown || !sm_fShutdownInProgress )
    {
        if( !IsListEmpty( &m_ObjectListEntry ) )
        {
            bRemovedIt = TRUE;

            RemoveEntryList( &m_ObjectListEntry );
            InitializeListHead( &m_ObjectListEntry );
        }
    }

    ReleaseObjectListLock();

    if (bRemovedIt)
    {
        Release();
    }

exit:
    return bRemovedIt;
}

// static
VOID
CADMCOMW::ShutDownObjects()
{

    CADMCOMW *  pCurrentObject = NULL;
    PLIST_ENTRY pCurrentEntry = NULL;

    //
    // Loop as long as we can get objects from the list
    //

    GetObjectListLock();

    sm_fShutdownInProgress = TRUE;

    ReleaseObjectListLock();

    // Remove all pending notifications
    NOTIFY_CONTEXT::RemoveAllWork();

    for ( ; ; )
    {
        GetObjectListLock();

        //
        // Remove the first object from the list
        //

        if( !IsListEmpty( &sm_ObjectList ) )
        {
            pCurrentEntry = sm_ObjectList.Flink;

            pCurrentObject = CONTAINING_RECORD( pCurrentEntry,
                                                CADMCOMW,
                                                m_ObjectListEntry );

            pCurrentObject->AddRef();

            DBG_REQUIRE( pCurrentObject->RemoveObjectFromList( TRUE ) );
        }

        ReleaseObjectListLock();

        if( pCurrentObject == NULL )
        {
            //
            // No more objects in the list.
            //

            break;
        }

        //
        // Shutdown the object. ForceTerminate will do a bounded wait
        // if the object is still being used.
        //

        pCurrentObject->ForceTerminate();

        pCurrentObject->Release();
        pCurrentObject = NULL;

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\dcomadm\dll\connect.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    connect.h

Abstract:

    defines for event/sink interface for IIS DCOM Admin.

Author:

    Sophia Chung (sophiac)   14-Jan-97

Revision History:

--*/

#if !defined(CONNECT_H)
#define CONNECT_H

#ifdef __cplusplus

// Types that should be in OLE2.H
#ifndef PPVOID
typedef LPVOID* PPVOID;
#endif

enum
{
  // A constant for the number of connections to add to the allocation
  // of the dynamic connection array.
  ALLOC_CONNECTIONS = 8,

  // The start value for the connection key (cookie) counter.
  COOKIE_START_VALUE = 500
};


/*O+O+++O+++O+++O+++O+++O+++O+++O+++O+++O+++O+++O+++O+++O+++O+++O+++O+++O+++O
  ObjectClass: COEnumConnectionPoints

  Summary:     COM object class for enumerating the Connection Points
               offered by a connectable object.

  Interfaces:  IUnknown
                 Standard interface providing COM object features.
               IEnumConnectionPoints
                 Interface for connection point enumeration.

  Aggregation: COEnumConnectionPoints COM Objects are not aggregatable.
O---O---O---O---O---O---O---O---O---O---O---O---O---O---O---O---O---O---O-O*/
class COEnumConnectionPoints : public IEnumConnectionPoints
{
  public:
    // Main Object Constructor & Destructor.
    COEnumConnectionPoints(IUnknown* pHostObj);
    ~COEnumConnectionPoints(void);

    // A general method for initializing this newly created object.
    // Creates any subordinate arrays, structures, or objects.
    HRESULT Init(
              ULONG cConnPts,
              IConnectionPoint** paConnPts,
              ULONG iEnumIndex);

    // IUnknown methods. Main object, non-delegating.
    STDMETHODIMP         QueryInterface(REFIID, PPVOID);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IEnumConnectionPoints methods.
    STDMETHODIMP         Next(ULONG, IConnectionPoint**, ULONG*);
    STDMETHODIMP         Skip(ULONG);
    STDMETHODIMP         Reset(void);
    STDMETHODIMP         Clone(IEnumConnectionPoints**);

  private:
    // Private data of COEnumConnectionPoints COM objects.

    // Main Object reference count.
    ULONG              m_cRefs;

    // IUnknown pointer to host COM object being enumerated.
    IUnknown*          m_pHostObj;

    // Connection Point index variable.
    ULONG              m_iEnumIndex;

    // Number of Connection Points being enumerated.
    ULONG              m_cConnPts;

    // Allocated array of Connection Point interface pointers.
    IConnectionPoint** m_paConnPts;
};

typedef COEnumConnectionPoints* PCOEnumConnectionPoints;


/*O+O+++O+++O+++O+++O+++O+++O+++O+++O+++O+++O+++O+++O+++O+++O+++O+++O+++O+++O
  ObjectClass: COConnectionPoint

  Summary:     Connection Point COM object class. Implements a native
               IConnectionPoint interface. The Advise, Unadvise, and
               EnumConnections methods use the CThreaded OwnThis mechanism
               to provide thread-safe mutually exclusive access to this
               connection point object.

  Interfaces:  IUnknown
                 Standard interface providing COM object features.
               IConnectionPoint
                 Interface for connection point features.

  Aggregation: COConnectionPoint COM Objects are not aggregatable.
O---O---O---O---O---O---O---O---O---O---O---O---O---O---O---O---O---O---O-O*/
class COConnectionPoint : public IConnectionPoint
{
  public:
    // Main Object Constructor & Destructor.
    COConnectionPoint();
    ~COConnectionPoint(void);

    // A general method for initializing this newly created object.
    // Creates any subordinate arrays, structures, or objects.
    HRESULT Init(IUnknown* pHostObj, REFIID riid);

    // IUnknown methods. Main object, non-delegating.
    STDMETHODIMP         QueryInterface(REFIID, PPVOID);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IConnectionPoint methods.
    STDMETHODIMP    GetConnectionInterface(IID*);
    STDMETHODIMP    GetConnectionPointContainer(IConnectionPointContainer**);
    STDMETHODIMP    Advise(IUnknown*, DWORD*);
    STDMETHODIMP    Unadvise(DWORD);
    STDMETHODIMP    EnumConnections(IEnumConnections**);

    // Our own methods
    STDMETHODIMP    ListenersPresent(VOID);
    STDMETHODIMP    Terminate(VOID);
    STDMETHODIMP    Disable(VOID);
    STDMETHODIMP    InternalEnumSinks(
        CONNECTDATA         **prgConnections,
        ULONG               *pcConnections);

  private:
    // Private utility methods of COConnectionPoint.
    STDMETHODIMP    Unadvise_Worker(DWORD dwCookie);
    HRESULT GetSlot(UINT* puiFreeSlot);
    HRESULT FindSlot(DWORD dwCookie, UINT* puiSlot);

    // Private data of COConnectionPoint COM objects.

    // Used to protect access to the member data.
    CReaderWriterLock3  m_Lock;

    // IUnknown pointer to host COM object offering this connection point.
    IUnknown*           m_pHostObj;

    // The IID of the sink interface associated with this connection point.
    IID                 m_iidSink;

    // The current number of live sink connections to this connection point.
    UINT                m_cConnections;

    // The current maximum index into the dynamic connection array.
    UINT                m_uiMaxIndex;

    // The dynamic array of sink connections to this connection point.
    CONNECTDATA*        m_paConnections;

    // Determines whether the host object is shuting down and force terminated us
    volatile BOOL       m_bTerminated;

    BOOL                m_bEnabled;

    IGlobalInterfaceTable* m_pGIT;

};

typedef COConnectionPoint* PCOConnectionPoint;


/*O+O+++O+++O+++O+++O+++O+++O+++O+++O+++O+++O+++O+++O+++O+++O+++O+++O+++O+++O
  ObjectClass: COEnumConnections

  Summary:     COM object class for enumerating the connections of a
               connection point of a connectable object.

  Interfaces:  IUnknown
                 Standard interface providing COM object features.
               IEnumConnections
                 Interface for connection enumeration features.

  Aggregation: COEnumConnections COM Objects are not aggregatable.
O---O---O---O---O---O---O---O---O---O---O---O---O---O---O---O---O---O---O-O*/
class COEnumConnections : public IEnumConnections
{
  public:
    // Main Object Constructor & Destructor.
    COEnumConnections(IUnknown* pHostObj);
    ~COEnumConnections(void);

    // A general method for initializing this newly created object.
    // Creates any subordinate arrays, structures, or objects.
    HRESULT Init(
              ULONG cConnections,
              CONNECTDATA* paConnections,
              ULONG iEnumIndex,
              IGlobalInterfaceTable* pGIT = NULL
              );

    // IUnknown methods. Main object, non-delegating.
    STDMETHODIMP         QueryInterface(REFIID, PPVOID);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IEnumConnections methods.
    STDMETHODIMP         Next(ULONG, CONNECTDATA*, ULONG*);
    STDMETHODIMP         Skip(ULONG);
    STDMETHODIMP         Reset(void);
    STDMETHODIMP         Clone(IEnumConnections**);

  private:
    // Private data of COEnumConnections COM objects.

    // Main Object reference count.
    ULONG            m_cRefs;

    // IUnknown pointer to host connection point COM object being
    // enumerated.
    IUnknown*        m_pHostObj;

    // Connection index variable.
    ULONG            m_iEnumIndex;

    // Number of Connections being enumerated.
    ULONG            m_cConnections;

    // Allocated array of live Connections only.
    CONNECTDATA*     m_paConnections;

};

typedef COEnumConnections* PCOEnumConnections;

HRESULT SetSinkCallbackSecurityBlanket(
    IUnknown            * pUnkSink);

#endif // __cplusplus

#endif // CONNECT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\dcomadm\dll\loadadm.cxx ===
// %%Includes: ---------------------------------------------------------------
#include "precomp.hxx"

#include <initguid.h>

#include <imd.h>
#include <mb.hxx>
#include <iadm.h>
#include "coiadm.hxx"
#include "admacl.hxx"

extern ULONG g_dwRefCount;
extern COpenHandle      g_ohMasterRootHandle;

#ifdef _M_IX86
static  BYTE  SP3Sig[] = {0xbd, 0x9f, 0x13, 0xc5, 0x92, 0x12, 0x2b, 0x72,
                          0x4a, 0xba, 0xb6, 0x2a, 0xf9, 0xfc, 0x54, 0x46,
                          0x6f, 0xa1, 0xb4, 0xbb, 0x43, 0xa8, 0xfe, 0xf8,
                          0xa8, 0x23, 0x7d, 0xd1, 0x85, 0x84, 0x22, 0x6e,
                          0xb4, 0x58, 0x00, 0x3e, 0x0b, 0x19, 0x83, 0x88,
                          0x6a, 0x8d, 0x64, 0x02, 0xdf, 0x5f, 0x65, 0x7e,
                          0x3b, 0x4d, 0xd4, 0x10, 0x44, 0xb9, 0x46, 0x34,
                          0xf3, 0x40, 0xf4, 0xbc, 0x9f, 0x4b, 0x82, 0x1e,
                          0xcc, 0xa7, 0xd0, 0x2d, 0x22, 0xd7, 0xb1, 0xf0,
                          0x2e, 0xcd, 0x0e, 0x21, 0x52, 0xbc, 0x3e, 0x81,
                          0xb1, 0x1a, 0x86, 0x52, 0x4d, 0x3f, 0xfb, 0xa2,
                          0x9d, 0xae, 0xc6, 0x3d, 0xaa, 0x13, 0x4d, 0x18,
                          0x7c, 0xd2, 0x28, 0xce, 0x72, 0xb1, 0x26, 0x3f,
                          0xba, 0xf8, 0xa6, 0x4b, 0x01, 0xb9, 0xa4, 0x5c,
                          0x43, 0x68, 0xd3, 0x46, 0x81, 0x00, 0x7f, 0x6a,
                          0xd7, 0xd1, 0x69, 0x51, 0x47, 0x25, 0x14, 0x40,
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
#else // other than _M_IX86
static  BYTE  SP3Sig[] = {0x8a, 0x06, 0x01, 0x6d, 0xc2, 0xb5, 0xa2, 0x66,
                          0x12, 0x1b, 0x9c, 0xe4, 0x58, 0xb1, 0xf8, 0x7d,
                          0xad, 0x17, 0xc1, 0xf9, 0x3f, 0x87, 0xe3, 0x9c,
                          0xdd, 0xeb, 0xcc, 0xa8, 0x6b, 0x62, 0xd0, 0x72,
                          0xe7, 0xf2, 0xec, 0xd6, 0xd6, 0x36, 0xab, 0x2d,
                          0x28, 0xea, 0x74, 0x07, 0x0e, 0x6c, 0x6d, 0xe1,
                          0xf8, 0x17, 0x97, 0x13, 0x8d, 0xb1, 0x8b, 0x0b,
                          0x33, 0x97, 0xc5, 0x46, 0x66, 0x96, 0xb4, 0xf7,
                          0x03, 0xc5, 0x03, 0x98, 0xf7, 0x91, 0xae, 0x9d,
                          0x00, 0x1a, 0xc6, 0x86, 0x30, 0x5c, 0xc8, 0xc7,
                          0x05, 0x47, 0xed, 0x2d, 0xc2, 0x0b, 0x61, 0x4b,
                          0xce, 0xe5, 0xb7, 0xd7, 0x27, 0x0c, 0x9e, 0x2f,
                          0xc5, 0x25, 0xe3, 0x81, 0x13, 0x9d, 0xa2, 0x67,
                          0xb2, 0x26, 0xfc, 0x99, 0x9d, 0xce, 0x0e, 0xaf,
                          0x30, 0xf3, 0x30, 0xec, 0xa3, 0x0a, 0xfe, 0x16,
                          0xb6, 0xda, 0x16, 0x90, 0x9a, 0x9a, 0x74, 0x7a,
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
#endif      // _M_IX86

DWORD       g_dwComRegisterW;
DWORD       g_bInitialized = FALSE;
IMDCOM3     *g_pcCom = NULL;

STDAPI
InitComAdmindata()
{

    HRESULT             hr = S_OK;
    DWORD               dwError;
    CADMCOMSrvFactoryW  *pADMClassFactoryW = NULL;

    CREATE_DEBUG_PRINT_OBJECT( "coadmin" );
    LOAD_DEBUG_FLAGS_FROM_REG_STR( "System\\CurrentControlSet\\Services\\iisadmin\\Parameters", 0 );

    INITIALIZE_PLATFORM_TYPE();

    CADMCOMW::InitObjectList();

    hr = g_ohMasterRootHandle.Init( METADATA_MASTER_ROOT_HANDLE,
                                    L"",
                                    L"");
    DBG_ASSERT( SUCCEEDED( hr ) );
    if ( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "[InitComAdmindata] g_ohMasterRootHandle.Init failed, hr 0x%8x\n",
                    hr ));
        goto exit;
    }

    // Cache the pids of this process and the process hosting RpcSs
    hr = CADMCOMW::GetPids();
    if( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "[InitComAdmindata] CADMCOMW::GetPids failed, hr 0x%08x\n",
                    hr ));
        goto exit;
    }

    hr = CoCreateInstance( GETMDCLSID( TRUE ),
                           NULL,
                           CLSCTX_INPROC_SERVER,
                           IID_IMDCOM3,
                           (void**) &g_pcCom );
    if ( FAILED( hr ) )
    {
        goto exit;
    }

    hr = g_pcCom->ComMDInitialize();
    if( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "[InitComAdmindata] Error initialize MDCOM object.  hr = %x\n",
                    hr ));
        goto exit;
    }

    pADMClassFactoryW = new CADMCOMSrvFactoryW;
    if ( pADMClassFactoryW == NULL )
    {
        dwError = GetLastError();
        DBGPRINTF(( DBG_CONTEXT,
                    "[InitComAdmindata] CADMCOMSrvFactoryW failed, error %lx\n",
                    GetLastError() ));
        hr = HRESULT_FROM_WIN32( dwError );
        goto exit;
    }

    pADMClassFactoryW->AddRef();

    // register the class-object with OLE
    hr = CoRegisterClassObject( GETAdminBaseCLSIDW( TRUE ),
                                pADMClassFactoryW,
                                CLSCTX_SERVER,
                                REGCLS_MULTIPLEUSE,
                                &g_dwComRegisterW );
    if ( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "[InitComAdmindata] CoRegisterClassObject failed, error %lx\n",
                    GetLastError() ));
        goto exit;
    }

exit:
    if ( pADMClassFactoryW )
    {
        pADMClassFactoryW->Release();
    }

    if ( FAILED( hr ) )
    {
        AdminAclDisableAclCache();
        AdminAclFlushCache();

        if ( g_dwComRegisterW != 0 )
        {
            CoRevokeClassObject( g_dwComRegisterW );
            g_dwComRegisterW = 0;
        }

        if ( g_pcCom != NULL )
        {
            g_pcCom->ComMDSendShutdownNotifications();
            g_pcCom->ComMDStopEWR();
        }

        CADMCOMW::ShutDownObjects();
        CADMCOMW::TerminateObjectList();

        if ( g_pcCom != NULL )
        {
            g_pcCom->ComMDShutdown();
            g_pcCom->ComMDTerminate(FALSE);
            g_pcCom->Release();
            g_pcCom = NULL;
        }
    }

    g_bInitialized = SUCCEEDED( hr );

    return hr;
}  // main

STDAPI
TerminateComAdmindata()
{
    HRESULT             hr = S_OK;
    int                 i;

    DBGPRINTF(( DBG_CONTEXT,
                "[TerminateComAdmindata] Terminating ABO.\n" ));

    if ( !g_bInitialized )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "[TerminateComAdmindata] Not initialized!\n" ));
        goto exit;
    }

    g_bInitialized = FALSE;

    // Go ahead and flush the acl cache, since it holds
    // references to the CMDCOM object.  If users come in
    // after this and recreate the acls, they will be created
    // again and we will just wait the 7 seconds below.
    AdminAclDisableAclCache();
    AdminAclFlushCache();
    DBGPRINTF(( DBG_CONTEXT,
                "[TerminateComAdmindata] Disabled the ACL cache.\n" ));

    if ( g_dwComRegisterW != 0 )
    {
        hr = CoRevokeClassObject( g_dwComRegisterW );
        DBGPRINTF(( DBG_CONTEXT,
                    "[TerminateComAdmindata] Revoked the ABO class factory %d with hr = 0x%08x.\n",
                    g_dwComRegisterW,
                    hr ));
        g_dwComRegisterW = 0;
    }

    if ( g_pcCom != NULL )
    {
        hr = g_pcCom->ComMDSendShutdownNotifications();
        DBGPRINTF(( DBG_CONTEXT,
                    "[TerminateComAdmindata] Sent shutdown notifications with hr = 0x%08x.\n",
                    hr ));
        hr = g_pcCom->ComMDStopEWR();
        DBGPRINTF(( DBG_CONTEXT,
                    "[TerminateComAdmindata] Stopped EWR with hr = 0x%08x.\n",
                    hr ));
    }

    DBGPRINTF(( DBG_CONTEXT,
                "[TerminateComAdmindata] Terminating all ABO objects.\n" ));
    CADMCOMW::ShutDownObjects();

    // Wait for remaining accesses to the factory to complete
    // Do this after ShutDownObject to avoid extra waiting
    for ( i = 0; (g_dwRefCount > 0) && (i < 5); i++ )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "[TerminateComAdmindata] Waiting on factory shutdown, i = %d\n",
                    i ));
        Sleep( 1000 );
    }

    // Just in case another object was allocated came through
    // while we were waiting
    CADMCOMW::ShutDownObjects();
    DBGPRINTF(( DBG_CONTEXT,
                "[TerminateComAdmindata] Terminated all ABO objects.\n" ));

    AdminAclDisableAclCache();
    AdminAclFlushCache();

    CADMCOMW::TerminateObjectList();
    DBGPRINTF(( DBG_CONTEXT,
                "[TerminateComAdmindata] Terminated ABO ROT.\n" ));

    if ( g_pcCom != NULL )
    {
        hr = g_pcCom->ComMDShutdown();
        DBGPRINTF(( DBG_CONTEXT,
                    "[TerminateComAdmindata] Shutdown metadata with hr = 0x%08x.\n",
                    hr ));
        hr = g_pcCom->ComMDTerminate(FALSE);
        DBGPRINTF(( DBG_CONTEXT,
                    "[TerminateComAdmindata] Terminated metadata with hr = 0x%08x.\n",
                    hr ));
        g_pcCom->Release();
        g_pcCom = NULL;
    }

    DBGPRINTF(( DBG_CONTEXT,
                "[TerminateComAdmindata] Done with hr = 0x%08x.\n",
                hr ));

#ifndef _NO_TRACING_
    DELETE_DEBUG_PRINT_OBJECT();
#endif

exit:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\dcomadm\inc\secpriv.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    secpriv.y

Abstract:

    This module contains private function prototypes exported by the
    ADMPROX proxy DLL for the exclusive use of the COADMIN server
    implementation.

Author:

    Keith Moore (keithmo)        25-Feb-1997

Revision History:

--*/


#ifndef _SECPRIV_H_
#define _SECPRIV_H_


#ifdef __cplusplus
extern "C" {
#endif  // __cplusplus


//
// Function to release the security context for a given object. The
// server is expected to call this routine from within the object's
// destructor.
//

VOID
WINAPI
ReleaseObjectSecurityContextA(
    IUnknown * Object
    );

VOID
WINAPI
ReleaseObjectSecurityContextW(
    IUnknown * Object
    );

typedef
VOID
(WINAPI * LPFN_RELEASE_OBJECT_SECURITY_CONTEXT)(
    IUnknown * Object
    );


#ifdef __cplusplus
}   // extern "C"
#endif  // __cplusplus


#endif  // _SECPRIV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\dcomadm\dll\sink.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    sink.cxx

Abstract:

    IIS DCOM Admin connection point container code for sinks

Author:

    Sophia Chung            12-Jan-97

Revision History:

--*/
#include "precomp.hxx"

#include <iadm.h>
#include "coiadm.hxx"


/*---------------------------------------------------------------------------
  CADMCOM's nested implementation of the COM standard
  IConnectionPointContainer interface including Constructor, Destructor,
  QueryInterface, AddRef, Release, FindConnectionPoint, and
  EnumConnectionPoints.
---------------------------------------------------------------------------*/

/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   CADMCOMW::CImpIConnectionPointContainer
              ::CImpIConnectionPointContainer

  Summary:  Constructor for the CImpIConnectionPointContainer interface
            instantiation.

  Args:     CADMCOMW* pBackObj,
              Back pointer to the parent outer object.
            IUnknown* pUnkOuter
              Pointer to the outer Unknown.  For delegation.

  Modifies: m_pBackObj, m_pUnkOuter.

  Returns:  void
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
CADMCOMW::CImpIConnectionPointContainer::CImpIConnectionPointContainer()
{
  // Init the Back Object Pointer to point to the parent object.
  //m_pBackObj = pBackObj;

  //m_pUnkOuter = pBackObj;

  return;
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   CADMCOMW::CImpIConnectionPointContainer
              ::~CImpIConnectionPointContainer

  Summary:  Destructor for the CImpIConnectionPointContainer interface
            instantiation.

  Args:     void

  Modifies: .

  Returns:  void
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
CADMCOMW::CImpIConnectionPointContainer::~CImpIConnectionPointContainer(void)
{
  return;
}

VOID CADMCOMW::CImpIConnectionPointContainer::Init(CADMCOMW *pBackObj)
{
  // Init the Back Object Pointer to point to the parent object.
  m_pBackObj = pBackObj;

  m_pUnkOuter = (IUnknown*)pBackObj;

  return;
}

/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   CADMCOMW::CImpIConnectionPointContainer::QueryInterface

  Summary:  The QueryInterface IUnknown member of this IPaper interface
            implementation that delegates to m_pUnkOuter, whatever it is.

  Args:     REFIID riid,
              [in] GUID of the Interface being requested.
            PPVOID ppv)
              [out] Address of the caller's pointer variable that will
              receive the requested interface pointer.

  Modifies: .

  Returns:  HRESULT
              Standard OLE result code. NOERROR for success.
              Returned by the delegated outer QueryInterface call.
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
STDMETHODIMP CADMCOMW::CImpIConnectionPointContainer::QueryInterface(
               REFIID riid,
               PPVOID ppv)
{
  // Delegate this call to the outer object's QueryInterface.
  return m_pUnkOuter->QueryInterface(riid, ppv);
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   CADMCOMW::CImpIConnectionPointContainer::AddRef

  Summary:  The AddRef IUnknown member of this IPaper interface
            implementation that delegates to m_pUnkOuter, whatever it is.

  Args:     void

  Modifies: .

  Returns:  ULONG
              Returned by the delegated outer AddRef call.
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
STDMETHODIMP_(ULONG) CADMCOMW::CImpIConnectionPointContainer::AddRef(void)
{
  // Delegate this call to the outer object's AddRef.
  return m_pUnkOuter->AddRef();
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   CADMCOMW::CImpIConnectionPointContainer::Release

  Summary:  The Release IUnknown member of this IPaper interface
            implementation that delegates to m_pUnkOuter, whatever it is.

  Args:     void

  Modifies: .

  Returns:  ULONG
              Returned by the delegated outer Release call.
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
STDMETHODIMP_(ULONG) CADMCOMW::CImpIConnectionPointContainer::Release(void)
{
  // Delegate this call to the outer object's Release.
  return m_pUnkOuter->Release();
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   CADMCOMW::CImpIConnectionPointContainer::FindConnectionPoint

  Summary:  Given an IID for a connection point sink find and return the
            interface pointer for that connection point sink.

  Args:     REFIID riid
              Reference to an IID
            IConnectionPoint** ppConnPt
              Address of the caller's IConnectionPoint interface pointer
              variable that will receive the requested interface pointer.

  Modifies: .

  Returns:  HRESULT
              Standard OLE result code. NOERROR for success.
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
STDMETHODIMP CADMCOMW::CImpIConnectionPointContainer::FindConnectionPoint(
               REFIID riid,
               IConnectionPoint** ppConnPt)
{
    HRESULT hr = E_NOINTERFACE;
    IConnectionPoint* pIConnPt;

    if (ppConnPt == NULL)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // NULL the output variable.
    *ppConnPt = NULL;

    // This connectable CADMCOMW object currently has only the Paper Sink
    // connection point. If the associated interface is requested,
    // use QI to get the Connection Point interface and perform the
    // needed AddRef.
    if (IID_IMSAdminBaseSink_W == riid)
    {
        pIConnPt = static_cast<IConnectionPoint*>(&m_pBackObj->m_ConnectionPoint);

        hr = pIConnPt->QueryInterface(
                           IID_IConnectionPoint,
                           (PPVOID)ppConnPt);
    }
    else
    {
        hr=CONNECT_E_NOCONNECTION;
    }

exit:
    return hr;
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   CADMCOMW::CImpIConnectionPointContainer::EnumConnectionPoints

  Summary:  Return Enumerator for the connectable object's contained
            connection points.

  Args:     IEnumConnectionPoints** ppIEnum
              Address of the caller's Enumerator interface pointer
              variable. An output variable that will receive a pointer to
              the connection point enumerator COM object.

  Modifies: .

  Returns:  HRESULT
              Standard OLE result code. NOERROR for success.
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
STDMETHODIMP CADMCOMW::CImpIConnectionPointContainer::EnumConnectionPoints(
                       IEnumConnectionPoints** ppIEnum)
{
    HRESULT hr = NOERROR;
    IConnectionPoint* aConnPts[1];
    COEnumConnectionPoints* pCOEnum;

    if (ppIEnum == NULL)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Zero the output interface pointer.
    *ppIEnum = NULL;

    // Make a copy on the stack of the array of connection point
    // interfaces. The copy is used below in the creation of the new
    // Enumerator object.
    aConnPts[0] = static_cast<IConnectionPoint*>(&m_pBackObj->m_ConnectionPoint);

    // Create a Connection Point enumerator COM object for the connection
    // points offered by this CADMCOMW object. Pass 'this' to be used to
    // hook the lifetime of the host object to the life time of this
    // enumerator object.
    pCOEnum = new COEnumConnectionPoints(this);
    if (NULL != pCOEnum)
    {
        // Use the array copy to Init the new Enumerator COM object.
        // Set the initial Enumerator index to 0.
        hr = pCOEnum->Init(1, aConnPts, 0);
        if (SUCCEEDED(hr))
        {
              // QueryInterface to return the requested interface pointer.
              // An AddRef will be conveniently done by the QI.
              if (SUCCEEDED(hr))
              {
                hr = pCOEnum->QueryInterface(
                                IID_IEnumConnectionPoints,
                                (PPVOID)ppIEnum);
              }
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

exit:
    return hr;
}

CImpIMDCOMSINKW::CImpIMDCOMSINKW(
    IMSAdminBaseW *pAdm
    )
{
    m_dwRefCount=0;
    m_pAdmObj = pAdm;
}

CImpIMDCOMSINKW::~CImpIMDCOMSINKW()
{
}

STDMETHODIMP
CImpIMDCOMSINKW::QueryInterface(
    REFIID              riid,
    VOID                **ppObject)
{
    HRESULT             hr = S_OK;

    if ( ppObject == NULL )
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    *ppObject = NULL;

    if ( riid==IID_IUnknown || riid==IID_IMDCOMSINK_W )
    {
        *ppObject = (IMDCOMSINK *) this;
        AddRef();
    }
    else
    {
        hr = E_NOINTERFACE;
    }

exit:
    return hr;
}

STDMETHODIMP_(ULONG)
CImpIMDCOMSINKW::AddRef()
{
    DWORD               dwRefCount;

    dwRefCount = InterlockedIncrement((long *)&m_dwRefCount);

    return dwRefCount;
}

STDMETHODIMP_(ULONG)
CImpIMDCOMSINKW::Release()
{
    DWORD               dwRefCount;

    dwRefCount = (DWORD)InterlockedDecrement((long *)&m_dwRefCount);

    if ( dwRefCount == 0 )
    {
        delete this;
    }

    return dwRefCount;
}

STDMETHODIMP
CImpIMDCOMSINKW::ComMDSinkNotify(
    METADATA_HANDLE                 hMDHandle,
    DWORD                           dwMDNumElements,
    MD_CHANGE_OBJECT_W __RPC_FAR    pcoChangeList[])
{
    HRESULT             hr = S_OK;

    m_Lock.ReadLock();
    if ( m_pAdmObj != NULL )
    {
        hr = ((CADMCOMW *)m_pAdmObj)->NotifySinks( hMDHandle, dwMDNumElements, pcoChangeList, TRUE );
    }
    m_Lock.ReadUnlock();

    return hr;
}

STDMETHODIMP
CImpIMDCOMSINKW::ComMDShutdownNotify()
{
    HRESULT             hr = S_OK;

    m_Lock.ReadLock();
    if ( m_pAdmObj != NULL )
    {
        hr = ((CADMCOMW *)m_pAdmObj)->NotifySinks( 0, 0, NULL, FALSE );
    }
    m_Lock.ReadUnlock();

    DetachAdminObject();

    return hr;
}

STDMETHODIMP
CImpIMDCOMSINKW::ComMDEventNotify(
    DWORD               dwMDEvent)
{
    HRESULT             hr = S_OK;

    if ( dwMDEvent == MD_EVENT_MID_RESTORE )
    {
        m_Lock.ReadLock();
        if ( m_pAdmObj != NULL )
        {
            ((CADMCOMW *)m_pAdmObj)->DisableAllHandles();
        }
        m_Lock.ReadUnlock();
    }

    return hr;
}

STDMETHODIMP
CImpIMDCOMSINKW::DetachAdminObject()
{
    HRESULT             hr = S_OK;

    m_Lock.WriteLock();
    m_pAdmObj = NULL;
    m_Lock.WriteUnlock();

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\dcomadm\interf2\dlldata_holder.c ===
/*++

Copyright (c) 2002 Microsoft Corporation

Module Name:

    dlldata_holder.c

Abstract:

    Wrapper around the MIDL-generated dlldata.c. This wrapper allows us
    to disable warning 4100.

Author:

    Ivan Pashov (IVANPASH)       20-Feb-2002

Revision History:

--*/
#pragma warning(disable: 4100)
#include "dlldata.c"

STDAPI DllRegisterServer()
{
    DWORD               dwError;
    HKEY                hKeyCLSID;
    HKEY                hKeyInproc32;
    HKEY                hKeyIF;
    HKEY                hKeyStub32;
    DWORD               dwDisposition;

    //
    // Main Interfaces
    //

    //
    // UNICODE Main Interface
    //
    dwError = RegCreateKeyExA( HKEY_CLASSES_ROOT,
                               "CLSID\\{70B51430-B6CA-11D0-B9B9-00A0C922E750}",
                               0,
                               "",
                               REG_OPTION_NON_VOLATILE,
                               KEY_ALL_ACCESS,
                               NULL,
                               &hKeyCLSID,
                               &dwDisposition );
    if ( dwError != ERROR_SUCCESS )
    {
        return E_UNEXPECTED;
    }

    dwError = RegSetValueExA( hKeyCLSID,
                              "",
                              0,
                              REG_SZ,
                              (BYTE*)"PSFactoryBuffer",
                              sizeof("PSFactoryBuffer") );
    if ( dwError != ERROR_SUCCESS )
    {
        RegCloseKey(hKeyCLSID);
        return E_UNEXPECTED;
    }

    dwError = RegCreateKeyExA( hKeyCLSID,
                               "InprocServer32",
                               0,
                               "",
                               REG_OPTION_NON_VOLATILE,
                               KEY_ALL_ACCESS,
                               NULL,
                               &hKeyInproc32,
                               &dwDisposition );
    if ( dwError != ERROR_SUCCESS )
    {
        RegCloseKey(hKeyCLSID);
        return E_UNEXPECTED;
    }

    dwError = RegSetValueExA( hKeyInproc32,
                              "",
                              0,
                              REG_SZ,
                              (BYTE*)"ADMWPROX.DLL",
                              sizeof("ADMWPROX.DLL") );
    if ( dwError != ERROR_SUCCESS )
    {
        RegCloseKey(hKeyInproc32);
        RegCloseKey(hKeyCLSID);
        return E_UNEXPECTED;
    }

    dwError = RegSetValueExA( hKeyInproc32,
                              "ThreadingModel",
                              0,
                              REG_SZ,
                              (BYTE*)"Both",
                              sizeof("Both") );
    if ( dwError != ERROR_SUCCESS )
    {
        RegCloseKey(hKeyInproc32);
        RegCloseKey(hKeyCLSID);
        return E_UNEXPECTED;
    }

    RegCloseKey(hKeyInproc32);
    RegCloseKey(hKeyCLSID);

    dwError = RegCreateKeyExA( HKEY_CLASSES_ROOT,
                               "CLSID\\{8298d101-f992-43b7-8eca-5052d885b995}",
                               0,
                               "",
                               REG_OPTION_NON_VOLATILE,
                               KEY_ALL_ACCESS,
                               NULL,
                               &hKeyCLSID,
                               &dwDisposition );
    if ( dwError != ERROR_SUCCESS )
    {
        return E_UNEXPECTED;
    }

    dwError = RegSetValueExA( hKeyCLSID,
                              "",
                              0,
                              REG_SZ,
                              (BYTE*)"PSFactoryBuffer",
                              sizeof("PSFactoryBuffer") );
    if ( dwError != ERROR_SUCCESS )
    {
        RegCloseKey(hKeyCLSID);
        return E_UNEXPECTED;
    }

    dwError = RegCreateKeyExA( hKeyCLSID,
                               "InprocServer32",
                               0,
                               "",
                               REG_OPTION_NON_VOLATILE,
                               KEY_ALL_ACCESS,
                               NULL,
                               &hKeyInproc32,
                               &dwDisposition );
    if ( dwError != ERROR_SUCCESS )
    {
        RegCloseKey(hKeyCLSID);
        return E_UNEXPECTED;
    }

    dwError = RegSetValueExA( hKeyInproc32,
                              "",
                              0,
                              REG_SZ,
                              (BYTE*)"ADMWPROX.DLL",
                              sizeof("ADMWPROX.DLL") );
    if ( dwError != ERROR_SUCCESS )
    {
        RegCloseKey(hKeyInproc32);
        RegCloseKey(hKeyCLSID);
        return E_UNEXPECTED;
    }

    dwError = RegSetValueExA( hKeyInproc32,
                              "ThreadingModel",
                              0,
                              REG_SZ,
                              (BYTE*)"Both",
                              sizeof("Both") );
    if ( dwError != ERROR_SUCCESS )
    {
        RegCloseKey(hKeyInproc32);
        RegCloseKey(hKeyCLSID);
        return E_UNEXPECTED;
    }

    RegCloseKey(hKeyInproc32);
    RegCloseKey(hKeyCLSID);

    dwError = RegCreateKeyExA( HKEY_CLASSES_ROOT,
                               "CLSID\\{f612954d-3b0b-4c56-9563-227b7be624b4}",
                               0,
                               "",
                               REG_OPTION_NON_VOLATILE,
                               KEY_ALL_ACCESS,
                               NULL,
                               &hKeyCLSID,
                               &dwDisposition );
    if ( dwError !=ERROR_SUCCESS )
    {
        return E_UNEXPECTED;
    }

    dwError = RegSetValueExA( hKeyCLSID,
                              "",
                              0,
                              REG_SZ,
                              (BYTE*)"PSFactoryBuffer",
                              sizeof("PSFactoryBuffer") );
    if ( dwError != ERROR_SUCCESS )
    {
        RegCloseKey(hKeyCLSID);
        return E_UNEXPECTED;
    }

    dwError = RegCreateKeyExA( hKeyCLSID,
                               "InprocServer32",
                               0,
                               "",
                               REG_OPTION_NON_VOLATILE,
                               KEY_ALL_ACCESS,
                               NULL,
                               &hKeyInproc32,
                               &dwDisposition );
    if ( dwError != ERROR_SUCCESS )
    {
        RegCloseKey(hKeyCLSID);
        return E_UNEXPECTED;
    }

    dwError = RegSetValueExA( hKeyInproc32,
                              "",
                              0,
                              REG_SZ,
                              (BYTE*)"ADMWPROX.DLL",
                              sizeof("ADMWPROX.DLL") );
    if ( dwError != ERROR_SUCCESS )
    {
        RegCloseKey(hKeyInproc32);
        RegCloseKey(hKeyCLSID);
        return E_UNEXPECTED;
    }

    dwError = RegSetValueExA( hKeyInproc32,
                              "ThreadingModel",
                              0,
                              REG_SZ,
                              (BYTE*)"Both",
                              sizeof("Both") );
    if ( dwError != ERROR_SUCCESS )
    {
        RegCloseKey(hKeyInproc32);
        RegCloseKey(hKeyCLSID);
        return E_UNEXPECTED;
    }

    RegCloseKey(hKeyInproc32);
    RegCloseKey(hKeyCLSID);

    dwError = RegCreateKeyExA( HKEY_CLASSES_ROOT,
                               "CLSID\\{29FF67FF-8050-480f-9F30-CC41635F2F9D}",
                               0,
                               "",
                               REG_OPTION_NON_VOLATILE,
                               KEY_ALL_ACCESS,
                               NULL,
                               &hKeyCLSID,
                               &dwDisposition );
    if ( dwError != ERROR_SUCCESS )
    {
        return E_UNEXPECTED;
    }

    dwError = RegSetValueExA( hKeyCLSID,
                              "",
                              0,
                              REG_SZ,
                              (BYTE*)"PSFactoryBuffer",
                              sizeof("PSFactoryBuffer") );
    if ( dwError != ERROR_SUCCESS )
    {
        RegCloseKey(hKeyCLSID);
        return E_UNEXPECTED;
    }

    dwError = RegCreateKeyExA( hKeyCLSID,
                               "InprocServer32",
                               0,
                               "",
                               REG_OPTION_NON_VOLATILE,
                               KEY_ALL_ACCESS,
                               NULL,
                               &hKeyInproc32,
                               &dwDisposition );
    if ( dwError != ERROR_SUCCESS )
    {
        RegCloseKey(hKeyCLSID);
        return E_UNEXPECTED;
    }

    dwError = RegSetValueExA( hKeyInproc32,
                              "",
                              0,
                              REG_SZ,
                              (BYTE*)"ADMWPROX.DLL",
                              sizeof("ADMWPROX.DLL") );
    if ( dwError != ERROR_SUCCESS )
    {
        RegCloseKey(hKeyInproc32);
        RegCloseKey(hKeyCLSID);
        return E_UNEXPECTED;
    }

    dwError = RegSetValueExA( hKeyInproc32,
                              "ThreadingModel",
                              0,
                              REG_SZ,
                              (BYTE*)"Both",
                              sizeof("Both") );
    if ( dwError != ERROR_SUCCESS )
    {
        RegCloseKey(hKeyInproc32);
        RegCloseKey(hKeyCLSID);
        return E_UNEXPECTED;
    }

    RegCloseKey(hKeyInproc32);
    RegCloseKey(hKeyCLSID);

    //
    // Sink Interfaces
    //

    //
    // UNICODE Sink
    //

    dwError = RegCreateKeyExA( HKEY_CLASSES_ROOT,
                               "CLSID\\{A9E69612-B80D-11D0-B9B9-00A0C922E750}",
                               0,
                               "",
                               REG_OPTION_NON_VOLATILE,
                               KEY_ALL_ACCESS,
                               NULL,
                               &hKeyCLSID,
                               &dwDisposition );
    if ( dwError != ERROR_SUCCESS )
    {
        return E_UNEXPECTED;
    }

    dwError = RegSetValueExA( hKeyCLSID,
                              "",
                              0,
                              REG_SZ,
                              (BYTE*)"PSFactoryBuffer",
                              sizeof("PSFactoryBuffer") );
    if ( dwError != ERROR_SUCCESS )
    {
        RegCloseKey(hKeyCLSID);
        return E_UNEXPECTED;
    }

    dwError = RegCreateKeyExA( hKeyCLSID,
                               "InprocServer32",
                               0,
                               "",
                               REG_OPTION_NON_VOLATILE,
                               KEY_ALL_ACCESS,
                               NULL,
                               &hKeyInproc32,
                               &dwDisposition );
    if ( dwError != ERROR_SUCCESS )
    {
        RegCloseKey(hKeyCLSID);
        return E_UNEXPECTED;
    }

    dwError = RegSetValueExA( hKeyInproc32,
                              "",
                              0,
                              REG_SZ,
                              (BYTE*)"ADMWPROX.DLL",
                              sizeof("ADMWPROX.DLL") );
    if ( dwError != ERROR_SUCCESS )
    {
            RegCloseKey(hKeyInproc32);
            RegCloseKey(hKeyCLSID);
            return E_UNEXPECTED;
    }

    dwError = RegSetValueExA( hKeyInproc32,
                              "ThreadingModel",
                              0,
                              REG_SZ,
                              (BYTE*)"Both",
                              sizeof("Both") );
    if ( dwError != ERROR_SUCCESS )
    {
        RegCloseKey(hKeyInproc32);
        RegCloseKey(hKeyCLSID);
        return E_UNEXPECTED;
    }

    RegCloseKey(hKeyInproc32);
    RegCloseKey(hKeyCLSID);

    //
    // register Interfaces
    //

    //
    // UNICODE Main Interface
    //

    dwError = RegCreateKeyExA( HKEY_CLASSES_ROOT,
                               "Interface\\{70B51430-B6CA-11D0-B9B9-00A0C922E750}",
                               0,
                               "",
                               REG_OPTION_NON_VOLATILE,
                               KEY_ALL_ACCESS,
                               NULL,
                               &hKeyIF,
                               &dwDisposition );
    if ( dwError != ERROR_SUCCESS )
    {
        return E_UNEXPECTED;
    }

    dwError = RegSetValueExA( hKeyIF,
                              "",
                              0,
                              REG_SZ,
                              (BYTE*)"IADMCOM",
                              sizeof("IADMCOM") );
    if ( dwError != ERROR_SUCCESS )
    {
        RegCloseKey(hKeyIF);
        return E_UNEXPECTED;
    }

    dwError = RegCreateKeyExA( hKeyIF,
                               "ProxyStubClsid32",
                               0,
                               "",
                               REG_OPTION_NON_VOLATILE,
                               KEY_ALL_ACCESS,
                               NULL,
                               &hKeyStub32,
                               &dwDisposition );
    if ( dwError != ERROR_SUCCESS )
    {
        RegCloseKey(hKeyIF);
        return E_UNEXPECTED;
    }

    dwError = RegSetValueExA( hKeyStub32,
                              "",
                              0,
                              REG_SZ,
                              (BYTE*)"{70B51430-B6CA-11D0-B9B9-00A0C922E750}",
                              sizeof("{70B51430-B6CA-11D0-B9B9-00A0C922E750}") );
    if ( dwError != ERROR_SUCCESS )
    {
        RegCloseKey(hKeyStub32);
        RegCloseKey(hKeyIF);
        return E_UNEXPECTED;
    }

    RegCloseKey(hKeyStub32);
    RegCloseKey(hKeyIF);

    dwError = RegCreateKeyExA( HKEY_CLASSES_ROOT,
                               "Interface\\{8298d101-f992-43b7-8eca-5052d885b995}",
                               0,
                               "",
                               REG_OPTION_NON_VOLATILE,
                               KEY_ALL_ACCESS,
                               NULL,
                               &hKeyIF,
                               &dwDisposition );
    if ( dwError != ERROR_SUCCESS )
    {
        return E_UNEXPECTED;
    }

    dwError = RegSetValueExA( hKeyIF,
                              "",
                              0,
                              REG_SZ,
                              (BYTE*)"IADMCOM2",
                              sizeof("IADMCOM2") );
    if ( dwError != ERROR_SUCCESS )
    {
        RegCloseKey(hKeyIF);
        return E_UNEXPECTED;
    }

    dwError = RegCreateKeyExA( hKeyIF,
                               "ProxyStubClsid32",
                               0,
                               "",
                               REG_OPTION_NON_VOLATILE,
                               KEY_ALL_ACCESS,
                               NULL,
                               &hKeyStub32,
                               &dwDisposition );
    if ( dwError != ERROR_SUCCESS )
    {
        RegCloseKey(hKeyIF);
        return E_UNEXPECTED;
    }

    dwError = RegSetValueExA( hKeyStub32,
                              "",
                              0,
                              REG_SZ,
                              (BYTE*)"{8298d101-f992-43b7-8eca-5052d885b995}",
                              sizeof("{8298d101-f992-43b7-8eca-5052d885b995}") );
    if ( dwError != ERROR_SUCCESS )
    {
        RegCloseKey(hKeyStub32);
        RegCloseKey(hKeyIF);
        return E_UNEXPECTED;
    }

    RegCloseKey(hKeyStub32);
    RegCloseKey(hKeyIF);

    dwError = RegCreateKeyExA( HKEY_CLASSES_ROOT,
                               "Interface\\{f612954d-3b0b-4c56-9563-227b7be624b4}",
                               0,
                               "",
                               REG_OPTION_NON_VOLATILE,
                               KEY_ALL_ACCESS,
                               NULL,
                               &hKeyIF,
                               &dwDisposition );
    if ( dwError != ERROR_SUCCESS )
    {
        return E_UNEXPECTED;
    }

    dwError = RegSetValueExA( hKeyIF,
                              "",
                              0,
                              REG_SZ,
                              (BYTE*)"IADMCOM3",
                              sizeof("IADMCOM3") );
    if ( dwError != ERROR_SUCCESS )
    {
        RegCloseKey(hKeyIF);
        return E_UNEXPECTED;
    }

    dwError = RegCreateKeyExA( hKeyIF,
                               "ProxyStubClsid32",
                               0,
                               "",
                               REG_OPTION_NON_VOLATILE,
                               KEY_ALL_ACCESS,
                               NULL,
                               &hKeyStub32,
                               &dwDisposition );
    if ( dwError != ERROR_SUCCESS )
    {
        RegCloseKey(hKeyIF);
        return E_UNEXPECTED;
    }

    dwError = RegSetValueExA( hKeyStub32,
                              "",
                              0,
                              REG_SZ,
                              (BYTE*)"{f612954d-3b0b-4c56-9563-227b7be624b4}",
                              sizeof("{f612954d-3b0b-4c56-9563-227b7be624b4}") );
    if ( dwError != ERROR_SUCCESS )
    {
        RegCloseKey(hKeyStub32);
        RegCloseKey(hKeyIF);
        return E_UNEXPECTED;
    }

    RegCloseKey(hKeyStub32);
    RegCloseKey(hKeyIF);

    dwError = RegCreateKeyExA( HKEY_CLASSES_ROOT,
                               "Interface\\{29FF67FF-8050-480f-9F30-CC41635F2F9D}",
                               0,
                               "",
                               REG_OPTION_NON_VOLATILE,
                               KEY_ALL_ACCESS,
                               NULL,
                               &hKeyIF,
                               &dwDisposition );
    if ( dwError != ERROR_SUCCESS )
    {
        return E_UNEXPECTED;
    }

    dwError = RegSetValueExA( hKeyIF,
                              "",
                              0,
                              REG_SZ,
                              (BYTE*)"IADMIMPEXPHLP",
                              sizeof("IADMIMPEXPHLP") );
    if ( dwError != ERROR_SUCCESS )
    {
        RegCloseKey(hKeyIF);
        return E_UNEXPECTED;
    }

    dwError = RegCreateKeyExA( hKeyIF,
                               "ProxyStubClsid32",
                               0,
                               "",
                               REG_OPTION_NON_VOLATILE,
                               KEY_ALL_ACCESS,
                               NULL,
                               &hKeyStub32,
                               &dwDisposition );
    if ( dwError != ERROR_SUCCESS )
    {
        RegCloseKey(hKeyIF);
        return E_UNEXPECTED;
    }

    dwError = RegSetValueExA( hKeyStub32,
                              "",
                              0,
                              REG_SZ,
                              (BYTE*)"{29FF67FF-8050-480f-9F30-CC41635F2F9D}",
                              sizeof("{29FF67FF-8050-480f-9F30-CC41635F2F9D}") );
    if ( dwError != ERROR_SUCCESS )
    {
        RegCloseKey(hKeyStub32);
        RegCloseKey(hKeyIF);
        return E_UNEXPECTED;
    }

    RegCloseKey(hKeyStub32);
    RegCloseKey(hKeyIF);

    //
    // UNICODE Sink Interface
    //


    dwError = RegCreateKeyExA( HKEY_CLASSES_ROOT,
                               "Interface\\{A9E69612-B80D-11D0-B9B9-00A0C922E750}",
                               0,
                               "",
                               REG_OPTION_NON_VOLATILE,
                               KEY_ALL_ACCESS,
                               NULL,
                               &hKeyIF,
                               &dwDisposition );
    if ( dwError != ERROR_SUCCESS )
    {
        return E_UNEXPECTED;
    }

    dwError = RegSetValueExA( hKeyIF,
                              "",
                              0,
                              REG_SZ,
                              (BYTE*)"IADMCOMSINK",
                              sizeof("IADMCOMSINK") );
    if ( dwError != ERROR_SUCCESS )
    {
        RegCloseKey(hKeyIF);
        return E_UNEXPECTED;
    }

    dwError = RegCreateKeyExA( hKeyIF,
                               "ProxyStubClsid32",
                               0,
                               "",
                               REG_OPTION_NON_VOLATILE,
                               KEY_ALL_ACCESS,
                               NULL,
                               &hKeyStub32,
                               &dwDisposition );
    if ( dwError != ERROR_SUCCESS )
    {
        RegCloseKey(hKeyIF);
        return E_UNEXPECTED;
    }

    dwError = RegSetValueExA( hKeyStub32,
                              "",
                              0,
                              REG_SZ,
                              (BYTE*)"{A9E69612-B80D-11D0-B9B9-00A0C922E750}",
                              sizeof("{A9E69612-B80D-11D0-B9B9-00A0C922E750}") );
    if ( dwError != ERROR_SUCCESS )
    {
        RegCloseKey(hKeyStub32);
        RegCloseKey(hKeyIF);
        return E_UNEXPECTED;
    }

    // an entry for async version
    dwError = RegSetValueExA( hKeyStub32,
                              "AsynchronousInterface",
                              0,
                              REG_SZ,
                              (BYTE*)"{A9E69613-B80D-11D0-B9B9-00A0C922E750}",
                              sizeof("{A9E69613-B80D-11D0-B9B9-00A0C922E750}") );
    if ( dwError != ERROR_SUCCESS )
    {
        RegCloseKey(hKeyStub32);
        RegCloseKey(hKeyIF);
        return E_UNEXPECTED;
    }

    RegCloseKey(hKeyStub32);
    RegCloseKey(hKeyIF);

    //
    // UNICODE Async Sink Interface
    //

    dwError = RegCreateKeyExA( HKEY_CLASSES_ROOT,
                               "Interface\\{A9E69613-B80D-11D0-B9B9-00A0C922E750}",
                               0,
                               "",
                               REG_OPTION_NON_VOLATILE,
                               KEY_ALL_ACCESS,
                               NULL,
                               &hKeyIF,
                               &dwDisposition );
    if ( dwError != ERROR_SUCCESS )
    {
        return E_UNEXPECTED;
    }

    dwError = RegSetValueExA( hKeyIF,
                              "",
                              0,
                              REG_SZ,
                              (BYTE*)"AsyncIADMCOMSINK",
                              sizeof("AsyncIADMCOMSINK") );
    if ( dwError != ERROR_SUCCESS )
    {
        RegCloseKey(hKeyIF);
        return E_UNEXPECTED;
    }

    // back link to synchronous version
    dwError = RegCreateKeyExA( hKeyIF,
                               "SynchronousInterface",
                               0,
                               "",
                               REG_OPTION_NON_VOLATILE,
                               KEY_ALL_ACCESS,
                               NULL,
                               &hKeyStub32,
                               &dwDisposition );
    if ( dwError != ERROR_SUCCESS )
    {
        RegCloseKey(hKeyIF);
        return E_UNEXPECTED;
    }

    dwError = RegSetValueExA( hKeyStub32,
                              "",
                              0,
                              REG_SZ,
                              (BYTE*)"{A9E69612-B80D-11D0-B9B9-00A0C922E750}",
                              sizeof("{A9E69612-B80D-11D0-B9B9-00A0C922E750}") );
    if ( dwError != ERROR_SUCCESS )
    {
        RegCloseKey(hKeyStub32);
        return E_UNEXPECTED;
    }

    RegCloseKey(hKeyStub32);
    RegCloseKey(hKeyIF);

    return S_OK;
}

STDAPI DllUnregisterServer()
{
    //
    // Main Interfaces
    //

    //
    // ANSI Main Interface
    //

    RegDeleteKey( HKEY_CLASSES_ROOT,
                  "CLSID\\{CBA424F0-483A-11D0-9D2A-00A0C922E703}\\InprocServer32" );

    RegDeleteKey( HKEY_CLASSES_ROOT,
                  "CLSID\\{CBA424F0-483A-11D0-9D2A-00A0C922E703}" );

    //
    // UNICODE Main Interface
    //

    RegDeleteKey( HKEY_CLASSES_ROOT,
                  "CLSID\\{70B51430-B6CA-11D0-B9B9-00A0C922E750}\\InprocServer32" );

    RegDeleteKey( HKEY_CLASSES_ROOT,
                  "CLSID\\{70B51430-B6CA-11D0-B9B9-00A0C922E750}" );

    RegDeleteKey( HKEY_CLASSES_ROOT,
                  "CLSID\\{8298d101-f992-43b7-8eca-5052d885b995}\\InprocServer32" );

    RegDeleteKey( HKEY_CLASSES_ROOT,
                  "CLSID\\{8298d101-f992-43b7-8eca-5052d885b995}" );

    //
    // Sink Interfaces
    //

    //
    // Ansi Sink
    //

    RegDeleteKey( HKEY_CLASSES_ROOT,
                  "CLSID\\{1E056350-761E-11D0-9BA1-00A0C922E703}\\InprocServer32" );

    RegDeleteKey( HKEY_CLASSES_ROOT,
                  "CLSID\\{1E056350-761E-11D0-9BA1-00A0C922E703}" );

    //
    // UNICODE Sink
    //

    RegDeleteKey( HKEY_CLASSES_ROOT,
                  "CLSID\\{A9E69612-B80D-11D0-B9B9-00A0C922E750}\\InprocServer32" );

    RegDeleteKey( HKEY_CLASSES_ROOT,
                  "CLSID\\{A9E69612-B80D-11D0-B9B9-00A0C922E750}" );


    //
    // deregister Interfaces
    //

    //
    // ANSI Main Interface
    //

    RegDeleteKey( HKEY_CLASSES_ROOT,
                  "Interface\\{CBA424F0-483A-11D0-9D2A-00A0C922E703}\\ProxyStubClsid32" );

    RegDeleteKey( HKEY_CLASSES_ROOT,
                  "Interface\\{CBA424F0-483A-11D0-9D2A-00A0C922E703}" );

    //
    // UNICODE Main Interface
    //

    RegDeleteKey( HKEY_CLASSES_ROOT,
                  "Interface\\{70B51430-B6CA-11d0-B9B9-00A0C922E750}\\ProxyStubClsid32" );

    RegDeleteKey( HKEY_CLASSES_ROOT,
                  "Interface\\{70B51430-B6CA-11d0-B9B9-00A0C922E750}" );

    RegDeleteKey( HKEY_CLASSES_ROOT,
                  "Interface\\{8298d101-f992-43b7-8eca-5052d885b995}\\ProxyStubClsid32" );

    RegDeleteKey( HKEY_CLASSES_ROOT,
                  "Interface\\{8298d101-f992-43b7-8eca-5052d885b995}" );

    //
    // ANSI Sink Interface
    //

    RegDeleteKey( HKEY_CLASSES_ROOT,
                  "Interface\\{1E056350-761E-11D0-9BA1-00A0C922E703}\\ProxyStubClsid32" );

    RegDeleteKey( HKEY_CLASSES_ROOT,
                  "Interface\\{1E056350-761E-11D0-9BA1-00A0C922E703}" );

    //
    // UNICODE Sink Interface
    //

    RegDeleteKey( HKEY_CLASSES_ROOT,
                  "Interface\\{A9E69612-B80D-11D0-B9B9-00A0C922E750}\\ProxyStubClsid32" );

    RegDeleteKey( HKEY_CLASSES_ROOT,
                  "Interface\\{A9E69612-B80D-11D0-B9B9-00A0C922E750}" );

    //
    // UNICODE Async Sink
    //

    RegDeleteKey( HKEY_CLASSES_ROOT,
                  "Interface\\{A9E69613-B80D-11D0-B9B9-00A0C922E750}\\SynchronousInterface" );

    RegDeleteKey( HKEY_CLASSES_ROOT,
                  "Interface\\{A9E69613-B80D-11D0-B9B9-00A0C922E750}" );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\dcomadm\interf2\makefile.inc ===
#
#   makefile.inc
#       Makefile for generating files from the .idl file
#
#   Specify the following in the file for use
#
#   IDL_FILE_NAME   ( without the .idl suffix)
#   IDL_FLAGS       if any thing specific required
#

!INCLUDE $(NTMAKEENV)\makefile.plt


IDL_FILE_NAME   = iadmw
IDL_FLAGS       = /I $(BASEDIR)\public\sdk\inc /I..\..\metadata\interfac -DREGISTER_PROXY_DLL


SDKINC          = $(BASEDIR)\public\sdk\inc

INCS            = -I. -I..\..\..\..\inc

CLIENT_STUB     =$(O)\$(IDL_FILE_NAME)_i.c
SERVER_STUB     =$(O)\$(IDL_FILE_NAME)_p.c
DLL_STUB        =$(O)\dlldata.c
HEADER_FILE     =$(IISBASEDIR)\inc\$(O)\$(IDL_FILE_NAME).h

CLIENT_TARGETS  = $(CLIENT_STUB) \

SERVER_TARGETS  = $(SERVER_STUB) \

DLL_TARGETS     = $(DLL_STUB) \

TARGETS         = $(CLIENT_TARGETS)  $(SERVER_TARGETS)  \
                  $(HEADER_FILE) $(DLL_TARGETS)

CPP             = -cpp_cmd "$(MIDL_CPP)" $(MIDL_FLAGS) \
                   $(C_DEFINES) $(NET_C_DEFINES) -DMIDL_PASS

MSC_WARNING_LEVEL= /W4 /WX

#
#  Define output and dependencies
#


all:    $(TARGETS) $(EXTRN_DEPENDS)
!IF "$(BUILDMSG)" != ""
    @ech ; $(BUILDMSG) ;
!ENDIF

clean: delsrc all

delsrc:
        -erase $(TARGETS)

#
#  MIDL Compile stuff
#
$(HEADER_FILE) $(CLIENT_TARGETS) $(SERVER_TARGETS) $(DLL_TARGETS):  .\$(IDL_FILE_NAME).idl
    midl -no_stamp $(MIDL_OPTIMIZATION_NT5) -h $(HEADER_FILE) -iid $(CLIENT_STUB) -proxy $(SERVER_STUB) -dlldata $(DLL_STUB) $(IDL_FLAGS) $(CPP) $(INCS) .\$(IDL_FILE_NAME).idl
    munge postmidl.scr -t $(HEADER_FILE) >nul
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\dcomadm\interf2\iadmwxp.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    iadmxp.c

Abstract:

    Wrapper around the MIDL-generated IADM_P.C. This wrapper allows us
    to "hook" the RPC-runtime-supplied IUnknown_Release_Proxy used in
    the client-side object's VTable. We need to hook this method so
    we may determine the exact lifetime of the client-side object. We
    need the exact lifetime so we can know when to destroy the security
    context we associate with each object.

    Hooked_IUnknown_Release_Proxy is implemented in SECURITY.CXX.

Author:

    Keith Moore (keithmo)       29-Feb-1997

Revision History:

--*/
#pragma warning(disable: 4100 4115 4152 4201 4211 4232 4310 4306)
#define IUnknown_Release_Proxy Hooked_IUnknown_Release_Proxy
#include "iadmw_p.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\dcomadm\interf2\main.cxx ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    main.cxx

Abstract:

    DLL startup routine.

Author:

    Keith Moore (keithmo)       17-Feb-1997

Revision History:

--*/


extern "C" {

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include <dbgutil.h>

}   // extern "C"

#include <iadmw.h>
#include <icrypt.hxx>
#include <secdat.hxx>


//
// Private globals.
//


extern "C" void InitializeIISRTL2();
extern "C" void TerminateIISRTL2();

//
// Private prototypes.
//


//
// DLL Entrypoint.
//

extern "C" {

BOOL
WINAPI
DllMain(
    HINSTANCE hDll,
    DWORD dwReason,
    LPVOID
    )
{

    BOOL status = TRUE;

    switch( dwReason ) {

    case DLL_PROCESS_ATTACH :
        INITIALIZE_PLATFORM_TYPE();

        // This needs to be called to initialize the Critical Section which
        // is used by the CREATE_DEBUG_PRINT_OBJECT
        InitializeIISRTL2();
        // NOTE: Now you might be wondering why this needs to do an initialize.
        // This is because this module links with iisrtl2.lib, not with
        // iisrtl.lib and hence not with iisrtl.dll. So in order for tracing
        // to get started this needs to do the initialize.
        CREATE_DEBUG_PRINT_OBJECT( "admwprox");
        LOAD_DEBUG_FLAGS_FROM_REG_STR( "System\\CurrentControlSet\\Services\\iisadmin\\Parameters", 0 );

        status = ADM_SECURE_DATA::Initialize( hDll );
        ADM_GUID_MAP::Initialize();
        DisableThreadLibraryCalls( hDll );
        break;

    case DLL_PROCESS_DETACH :
        ADM_GUID_MAP::Terminate();
        ADM_SECURE_DATA::Terminate();
        DELETE_DEBUG_PRINT_OBJECT();

        // This needs to be called to remove the Critical Section which
        // was used by the DELETE_DEBUG_PRINT_OBJECT
        TerminateIISRTL2();

        break;

    }

    return status;

}   // DLLEntry

}   // extern "C"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\dcomadm\interf2\secdat.cxx ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    secdat.cxx

Abstract:

    This module implements the ADM_SECURE_DATA class.

Author:

    Keith Moore (keithmo)       17-Feb-1997

Revision History:

--*/


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ole2.h>
#include <windows.h>

#define DEFAULT_TRACE_FLAGS     (DEBUG_ERROR)

#include <dbgutil.h>
#include <iadmw.h>
#include <icrypt.hxx>
#include <secdat.hxx>


//
// Private constants.
//

#define FREE_BLOB(blob)                                                 \
            if( blob != NULL ) {                                        \
                HRESULT _res;                                           \
                _res = ::IISCryptoFreeBlob( blob );                     \
                DBG_ASSERT( SUCCEEDED(_res) );                          \
            } else

#if DBG
#define ENABLE_ADM_COUNTERS 1
#define ADM_NOISY           0
#else
#define ENABLE_ADM_COUNTERS 0
#define ADM_NOISY           0
#endif

#if ADM_NOISY
#define NOISYPRINTF(x) DBGPRINTF(x)
#else
#define NOISYPRINTF(x)
#endif


//
// Private types.
//

#if ENABLE_ADM_COUNTERS

typedef struct _ADM_COUNTERS {
    LONG ObjectsCreated;
    LONG ObjectsDestroyed;
} ADM_COUNTERS, *PADM_COUNTERS;

#define DECLARE_ADM_COUNTERS() ADM_COUNTERS g_AdmCounters

#define UpdateObjectsCreated() InterlockedIncrement( &g_AdmCounters.ObjectsCreated )
#define UpdateObjectsDestroyed() InterlockedIncrement( &g_AdmCounters.ObjectsDestroyed )

#else

#define DECLARE_ADM_COUNTERS()

#define UpdateObjectsCreated()
#define UpdateObjectsDestroyed()

#endif


//
// Private globals.
//

LIST_ENTRY ADM_SECURE_DATA::sm_ServerSecureDataListHead;
LIST_ENTRY ADM_SECURE_DATA::sm_ClientSecureDataListHead;
LIST_ENTRY ADM_GUID_MAP::sm_GuidMapListHead;
CRITICAL_SECTION ADM_SECURE_DATA::sm_ServerSecureDataLock;
CRITICAL_SECTION ADM_SECURE_DATA::sm_ClientSecureDataLock;
CRITICAL_SECTION ADM_GUID_MAP::sm_GuidMapDataLock;
#if DBG
DWORD ADM_SECURE_DATA::sm_ServerSecureDataLockOwner;
DWORD ADM_SECURE_DATA::sm_ClientSecureDataLockOwner;
DWORD ADM_GUID_MAP::sm_GuidMapLockOwner;
PTRACE_LOG ADM_SECURE_DATA::sm_RefTraceLog;
PTRACE_LOG ADM_GUID_MAP::sm_RefTraceLog;
#endif
HCRYPTPROV ADM_SECURE_DATA::sm_ServerCryptoProvider;
HCRYPTPROV ADM_SECURE_DATA::sm_ClientCryptoProvider;

DECLARE_ADM_COUNTERS();

//
// ADM_SECURE_DATA methods.
//


ADM_SECURE_DATA::ADM_SECURE_DATA(
    IN IUnknown * Object,
    IN GUID guidServer,
    IN BOOL bServer
    ) :
    m_Object( Object ),
    m_KeyExchangeClient( NULL ),
    m_KeyExchangeServer( NULL ),
    m_SendCryptoStorage( NULL ),
    m_ReceiveCryptoStorage( NULL ),
    m_ReferenceCount( 1 ),
    m_guidServer(guidServer),
    m_bIsServer(bServer)
/*++

Routine Description:

    ADM_SECURE_DATA object constructor.

Arguments:

    Object - Pointer to the object to associate.

Return Value:

    None.

--*/
{
    NOISYPRINTF((
        DBG_CONTEXT,
        "ADM_SECURE_DATA: creating %08lx,%08lx\n",
        this,
        Object
        ));

    //
    // Sanity check.
    //

    DBG_ASSERT( (Object != NULL) || !bServer );

    //
    // Initialize any complex data members.
    //

    INITIALIZE_CRITICAL_SECTION( &m_ObjectLock );

    //
    // Put ourselves on the list.
    //

    if (bServer) {
        AcquireServerDataLock();
        InsertHeadList( &sm_ServerSecureDataListHead, &m_SecureDataListEntry );
        ReleaseServerDataLock();
    }
    else {
        AcquireClientDataLock();
        InsertHeadList( &sm_ClientSecureDataListHead, &m_SecureDataListEntry );
        ReleaseClientDataLock();
        //
        // Clients lifespan is controlled by ADM_GUID_MAP
        //
    }

    UpdateObjectsCreated();

}   // ADM_SECURE_DATA::ADM_SECURE_DATA


ADM_SECURE_DATA::~ADM_SECURE_DATA()
/*++

Routine Description:

    ADM_SECURE_DATA object destructor.

Arguments:

    None.

Return Value:

    None.

--*/
{

    NOISYPRINTF((
        DBG_CONTEXT,
        "~ADM_SECURE_DATA: destroying %08lx,%08lx\n",
        this,
        m_Object
        ));

    //
    // Sanity check.
    //

    DBG_ASSERT( m_ReferenceCount == 0 );

    //
    // Cleanup.
    //

    CleanupCryptoData();

    if (m_bIsServer) {
        AcquireServerDataLock();
        RemoveEntryList( &m_SecureDataListEntry );
        ReleaseServerDataLock();
    }
    else {
        AcquireClientDataLock();
        RemoveEntryList( &m_SecureDataListEntry );
        ReleaseClientDataLock();
    }

    DeleteCriticalSection( &m_ObjectLock );
    UpdateObjectsDestroyed();

    m_Object = NULL;

}   // ADM_SECURE_DATA::~ADM_SECURE_DATA


BOOL
ADM_SECURE_DATA::Initialize(
    HINSTANCE
    )
/*++

Routine Description:

    Initializes static global data private to ADM_SECURE_DATA.

Arguments:

    hDll - Handle to this DLL.

Return Value:

    None.

--*/
{

    HRESULT result;

    //
    // Initialize the crypto stuff.
    //

    result = ::IISCryptoInitialize();

    if( SUCCEEDED(result) ) {

        INITIALIZE_CRITICAL_SECTION( &sm_ServerSecureDataLock );
        INITIALIZE_CRITICAL_SECTION( &sm_ClientSecureDataLock );

#if DBG
        sm_ServerSecureDataLockOwner = 0;
        sm_ClientSecureDataLockOwner = 0;
        sm_RefTraceLog = CreateRefTraceLog( 1024, 0 );
#endif

        InitializeListHead( &sm_ServerSecureDataListHead );
        InitializeListHead( &sm_ClientSecureDataListHead );

    } else {
        DBGPRINTF((
            DBG_CONTEXT,
            "ADM_SECURE_DATA::Initialize: error %lx\n",
            result
            ));
    }

    return SUCCEEDED(result);

}   // ADM_SECURE_DATA::Initialize


VOID
ADM_SECURE_DATA::Terminate()
/*++

Routine Description:

    Terminates static global data private to ADM_SECURE_DATA.

Arguments:

    None.

Return Value:

    None.

--*/
{

    PLIST_ENTRY entry;
    ADM_SECURE_DATA * data;
    HRESULT result;

    //
    // Free any secure data objects on our list.
    //

    AcquireServerDataLock();

    entry = sm_ServerSecureDataListHead.Flink;

    while( entry != &sm_ServerSecureDataListHead ) {

        data = CONTAINING_RECORD(
                   entry,
                   ADM_SECURE_DATA,
                   m_SecureDataListEntry
                   );

        data->Dereference();

        entry = sm_ServerSecureDataListHead.Flink;
    }
    ReleaseServerDataLock();

    AcquireClientDataLock();

    entry = sm_ClientSecureDataListHead.Flink;

    while( entry != &sm_ClientSecureDataListHead ) {

        data = CONTAINING_RECORD(
                   entry,
                   ADM_SECURE_DATA,
                   m_SecureDataListEntry
                   );

        data->Dereference();

        entry = sm_ClientSecureDataListHead.Flink;
    }

    ReleaseClientDataLock();

    DBG_ASSERT( IsListEmpty( &sm_ServerSecureDataListHead ) );
    DBG_ASSERT( IsListEmpty( &sm_ClientSecureDataListHead ) );

    //
    // Terminate the crypto stuff.
    //

    if( sm_ServerCryptoProvider != CRYPT_NULL ) {
        result = ::IISCryptoCloseContainer( sm_ServerCryptoProvider );
        DBG_ASSERT( SUCCEEDED(result) || (result == RETURNCODETOHRESULT(ERROR_BUSY)) );
        sm_ServerCryptoProvider = CRYPT_NULL;
    }

    if( sm_ClientCryptoProvider != CRYPT_NULL ) {
        result = ::IISCryptoCloseContainer( sm_ClientCryptoProvider );
        DBG_ASSERT( SUCCEEDED(result) || (result == RETURNCODETOHRESULT(ERROR_BUSY)) );
        sm_ClientCryptoProvider = CRYPT_NULL;
    }

    result = ::IISCryptoTerminate();
    DBG_ASSERT( SUCCEEDED(result) );

    //
    // Final cleanup.
    //

    DeleteCriticalSection( &sm_ServerSecureDataLock );
    DeleteCriticalSection( &sm_ClientSecureDataLock );

#if DBG
    if( sm_RefTraceLog != NULL ) {
        DestroyRefTraceLog( sm_RefTraceLog );
    }
#endif

}   // ADM_SECURE_DATA::Terminate


ADM_SECURE_DATA *
ADM_SECURE_DATA::FindAndReferenceServerSecureData(
    IN IUnknown * Object,
    IN BOOL CreateIfNotFound
    )
/*++

Routine Description:

    Finds the ADM_SECURE_DATA object associated with Object. If it
    cannot be found, then a new ADM_SECURE_DATA object is created
    and put on the global list.

Arguments:

    Object - The object to search for.

    CreateIfNotFound - If the object is not on the list, a new association
        will only be created if this flag is TRUE.

Return Value:

    ADM_SECURE_DATA * - Pointer to the ADM_SECURE_DATA object if
        successful, NULL otherwise.

--*/
{

    PLIST_ENTRY entry;
    ADM_SECURE_DATA * data;

    AcquireServerDataLock();

    for( entry = sm_ServerSecureDataListHead.Flink ;
         entry != &sm_ServerSecureDataListHead ;
         entry = entry->Flink ) {

        data = CONTAINING_RECORD(
                   entry,
                   ADM_SECURE_DATA,
                   m_SecureDataListEntry
                   );

        if( data->m_Object == Object ) {

            data->Reference();
            ReleaseServerDataLock();
            return data;

        }

    }

    data = NULL;
    if( CreateIfNotFound ) {

        GUID guidServer;
        HRESULT hresError;

        hresError = CoCreateGuid(&guidServer);

        if (SUCCEEDED(hresError)) {
            data = new ADM_SECURE_DATA( Object,
                                        guidServer,
                                        TRUE );

            if( data == NULL ) {

                DBGPRINTF((
                    DBG_CONTEXT,
                    "ADM_SECURE_DATA::FindAndReferenceServerSecureData: out of memory\n"
                    ));

            } else {

                data->Reference();

            }
        }
        else {
            DBGPRINTF((
                DBG_CONTEXT,
                "ADM_SECURE_DATA::FindAndReferenceServerSecureData: CoCreateGuid failed\n"
                ));
        }
    }

    ReleaseServerDataLock();
    return data;

}   // ADM_SECURE_DATA::FindAndReferenceServerSecureData


ADM_SECURE_DATA *
ADM_SECURE_DATA::FindOrAddAndReferenceClientSecureData(
    IN IUnknown         *Object )
/*++

Routine Description:

    Finds the ADM_SECURE_DATA object associated with Object. If it
    cannot be found, then a new ADM_SECURE_DATA object is created
    and put on the global list.

Arguments:

    Object - The object to search for.

Return Value:

    ADM_SECURE_DATA * - Pointer to the ADM_SECURE_DATA object if
        successful, NULL otherwise.

--*/
{
    HRESULT             hr;
    ADM_SECURE_DATA     *psecdatData = NULL;
    ADM_GUID_MAP        *pguidmapData = NULL;
    GUID                guidServer = { 0 };

    AcquireClientDataLock();

    pguidmapData = ADM_GUID_MAP::FindAndReferenceGuidMap( Object );

    if ( pguidmapData == NULL )
    {
        // IVANPASH: 591269.
        // We cannot keep the critical section locked while making the R_ call
        ReleaseClientDataLock();
        hr = IMSAdminBaseW_R_GetServerGuid_Proxy( (IMSAdminBaseW *)Object,
                                                  &guidServer );
        AcquireClientDataLock();

        if ( FAILED( hr ) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "ADM_SECURE_DATA::FindOrAddAndReferenceClientSecureData: IMSAdminBaseW_R_GetServerGuid_Proxy failed\n" ));
            goto exit;
        }

        // Retry
        pguidmapData = ADM_GUID_MAP::FindAndReferenceGuidMap( Object );

        if ( pguidmapData == NULL )
        {
            pguidmapData = new ADM_GUID_MAP( Object,
                                             guidServer );
            if( pguidmapData == NULL )
            {
                DBGPRINTF(( DBG_CONTEXT,
                            "ADM_SECURE_DATA::FindOrAddAndReferenceClientSecureData: out of memory\n" ));
                goto exit;
            }
            pguidmapData->Reference();
        }
    }

    DBG_ASSERT( pguidmapData != NULL );
    psecdatData = FindAndReferenceClientSecureData( pguidmapData );
    if ( psecdatData == NULL )
    {
        //
        // AddRef the ADM_SECURE_DATA
        // Do this here instead of constructor to
        // all handing of errors.
        // this may create the ADM_SECURE_DATA
        //
        psecdatData = new ADM_SECURE_DATA( Object,
                                           pguidmapData->GetGuid(),
                                           FALSE );
        if ( psecdatData == NULL )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "ADM_SECURE_DATA::FindOrAddAndReferenceClientSecureData: out of memory\n" ));
            goto exit;
        }

        psecdatData->Reference();
    }

exit:
    if ( pguidmapData != NULL )
    {
        pguidmapData->Dereference();
        pguidmapData = NULL;
    }

    ReleaseClientDataLock();
    return psecdatData;

}   // ADM_SECURE_DATA::FindAndReferenceSecureData

ADM_SECURE_DATA *
ADM_SECURE_DATA::FindAndReferenceClientSecureData(
    IN ADM_GUID_MAP     *pguidmapRelated )
/*++

Routine Description:

    Finds the ADM_SECURE_DATA object associated with Object.

Arguments:

    pguidmapRelated - The GUID to search for.

Return Value:

    ADM_SECURE_DATA * - Pointer to the ADM_SECURE_DATA object if
        successful, NULL otherwise.

--*/
{
    PLIST_ENTRY         entry;
    ADM_SECURE_DATA     *psecdatData = NULL;

    AcquireClientDataLock();

    if ( pguidmapRelated == NULL )
    {
        goto exit;
    }

    for ( entry = sm_ClientSecureDataListHead.Flink ;
          entry != &sm_ClientSecureDataListHead ;
          entry = entry->Flink )
    {
        psecdatData = CONTAINING_RECORD( entry,
                                         ADM_SECURE_DATA,
                                         m_SecureDataListEntry );

        DBG_ASSERT( psecdatData->m_guidServer != GUID_NULL );

        if ( psecdatData->m_guidServer == pguidmapRelated->GetGuid() )
        {
            psecdatData->Reference();
            goto exit;
        }
    }

    psecdatData = NULL;

exit:
    ReleaseClientDataLock();

    return psecdatData;
}   // ADM_SECURE_DATA::FindAndReferenceSecureData

ADM_SECURE_DATA *
ADM_SECURE_DATA::FindAndReferenceClientSecureData(
    IN IUnknown         *Object )
/*++

Routine Description:

    Finds the ADM_SECURE_DATA object associated with Object.

Arguments:

    Object - The object to search for.

Return Value:

    ADM_SECURE_DATA * - Pointer to the ADM_SECURE_DATA object if
        successful, NULL otherwise.

--*/
{
    ADM_SECURE_DATA     *psecdatData = NULL;
    ADM_GUID_MAP        *pguidmapData = NULL;

    AcquireClientDataLock();

    pguidmapData = ADM_GUID_MAP::FindAndReferenceGuidMap( Object );

    if ( pguidmapData == NULL )
    {
        goto exit;
    }

    psecdatData = FindAndReferenceClientSecureData( pguidmapData );

exit:
    if ( pguidmapData != NULL )
    {
        pguidmapData->Dereference();
        pguidmapData = NULL;
    }

    ReleaseClientDataLock();

    return psecdatData;
}   // ADM_SECURE_DATA::FindAndReferenceSecureData


HRESULT
ADM_SECURE_DATA::GetClientSendCryptoStorage(
    OUT IIS_CRYPTO_STORAGE ** SendCryptoStorage,
    IN  IUnknown * Object
    )
/*++

Routine Description:

    Retrieves the client-side IIS_CRYPTO_STORAGE object to be used for
    sending data to the server. This routine will perform the client-side
    key exchange if necessary.

Arguments:

    SendCryptoStorage - Receives a pointer to the newly created
        IIS_CRYPTO_STORAGE object if successful.

Return Value:

    HRESULT - 0 if successful, !0 otherwise.

--*/
{

    HRESULT result;

    //
    // Sanity check.
    //

    DBG_ASSERT( SendCryptoStorage != NULL );

    //
    // Do that key exchange thang if we don't yet have it.
    //

    if( m_KeyExchangeClient == NULL ) {

        LockThis();

        if( m_KeyExchangeClient == NULL ) {

            result = DoClientSideKeyExchange(Object);

            if( FAILED(result) ) {

                UnlockThis();
                return result;

            }

        }

        UnlockThis();

    }

    DBG_ASSERT( m_SendCryptoStorage != NULL );

    *SendCryptoStorage = m_SendCryptoStorage;
    return NO_ERROR;

}   // ADM_SECURE_DATA::GetClientSendCryptoStorage


HRESULT
ADM_SECURE_DATA::GetClientReceiveCryptoStorage(
    OUT IIS_CRYPTO_STORAGE ** ReceiveCryptoStorage,
    IUnknown * Object
    )
/*++

Routine Description:

    Retrieves the client-side IIS_CRYPTO_STORAGE object to be used for
    receiving data from the server. This routine will perform the
    client-side key exchange if necessary.

Arguments:

    ReceiveCryptoStorage - Receives a pointer to the newly created
        IIS_CRYPTO_STORAGE object if successful.

Return Value:

    HRESULT - 0 if successful, !0 otherwise.

--*/
{

    HRESULT result;

    //
    // Sanity check.
    //

    DBG_ASSERT( ReceiveCryptoStorage != NULL );

    //
    // Do that key exchange thang if we don't yet have it.
    //

    if( m_KeyExchangeClient == NULL ) {

        LockThis();

        if( m_KeyExchangeClient == NULL ) {

            result = DoClientSideKeyExchange(Object);

            if( FAILED(result) ) {

                UnlockThis();
                return result;

            }

        }

        UnlockThis();

    }

    DBG_ASSERT( m_ReceiveCryptoStorage != NULL );

    *ReceiveCryptoStorage = m_ReceiveCryptoStorage;
    return NO_ERROR;

}   // ADM_SECURE_DATA::GetClientReceiveCryptoStorage


HRESULT
ADM_SECURE_DATA::GetServerSendCryptoStorage(
    OUT IIS_CRYPTO_STORAGE ** SendCryptoStorage
    )
/*++

Routine Description:

    Retrieves the server-side IIS_CRYPTO_STORAGE object to be used for
    sending data to the client.

Arguments:

    SendCryptoStorage - Receives a pointer to the newly created
        IIS_CRYPTO_STORAGE object if successful.

Return Value:

    HRESULT - 0 if successful, !0 otherwise.

--*/
{

    if( m_SendCryptoStorage != NULL ) {

        *SendCryptoStorage = m_SendCryptoStorage;
        return NO_ERROR;

    }

    return MD_ERROR_SECURE_CHANNEL_FAILURE;

}   // ADM_SECURE_DATA::GetServerSendCryptoStorage


HRESULT
ADM_SECURE_DATA::GetServerReceiveCryptoStorage(
    OUT IIS_CRYPTO_STORAGE ** ReceiveCryptoStorage
    )
/*++

Routine Description:

    Retrieves the server-side IIS_CRYPTO_STORAGE object to be used for
    receiving data from the client.

Arguments:

    ReceiveCryptoStorage - Receives a pointer to the newly created
        IIS_CRYPTO_STORAGE object if successful.

Return Value:

    HRESULT - 0 if successful, !0 otherwise.

--*/
{

    if( m_ReceiveCryptoStorage != NULL ) {

        *ReceiveCryptoStorage = m_ReceiveCryptoStorage;
        return NO_ERROR;

    }

    return MD_ERROR_SECURE_CHANNEL_FAILURE;

}   // ADM_SECURE_DATA::GetServerReceiveCryptoStorage


HRESULT
ADM_SECURE_DATA::DoClientSideKeyExchange(
    IUnknown * Object
    )
/*++

Routine Description:

    Performs all the client-side magic necessary to exchange session
    keys with the server.

Arguments:

    None.

Return Value:

    HRESULT - 0 if successful, !0 otherwise.

--*/
{

    HRESULT result;
    HCRYPTPROV prov;
    IIS_CRYPTO_EXCHANGE_CLIENT * keyExchangeClient;
    IIS_CRYPTO_BLOB *clientKeyExchangeKeyBlob;
    IIS_CRYPTO_BLOB *clientSignatureKeyBlob;
    IIS_CRYPTO_BLOB *clientSessionKeyBlob;
    IIS_CRYPTO_BLOB *clientHashBlob;
    IIS_CRYPTO_BLOB *serverKeyExchangeKeyBlob;
    IIS_CRYPTO_BLOB *serverSignatureKeyBlob;
    IIS_CRYPTO_BLOB *serverSessionKeyBlob;
    IIS_CRYPTO_BLOB *serverHashBlob;

    //
    // Sanity check.
    //

    DBG_ASSERT( Object != NULL );
    DBG_ASSERT( m_KeyExchangeClient == NULL );
    DBG_ASSERT( m_SendCryptoStorage == NULL );
    DBG_ASSERT( m_ReceiveCryptoStorage == NULL );

    //
    // Setup locals so we know how to cleanup on exit.
    //

    keyExchangeClient = NULL;
    clientKeyExchangeKeyBlob = NULL;
    clientSignatureKeyBlob = NULL;
    clientSessionKeyBlob = NULL;
    clientHashBlob = NULL;
    serverKeyExchangeKeyBlob = NULL;
    serverSignatureKeyBlob = NULL;
    serverSessionKeyBlob = NULL;
    serverHashBlob = NULL;

    HANDLE hToken = NULL;

    if (OpenThreadToken( GetCurrentThread(), MAXIMUM_ALLOWED, TRUE, &hToken ) ) {
        RevertToSelf();
    }
    //
    // Get the crypto provider to use.
    //

    DBG_CODE( prov = CRYPT_NULL );

    result = GetClientCryptoProvider( &prov );

    if( FAILED(result) ) {
        goto cleanup;
    }

    DBG_ASSERT( prov != CRYPT_NULL );

    //
    // Create & initialize the client-side key exchange object.
    //
    // N.B. Do not set the m_KeyExchangeClient to a non-NULL value
    // until key exchange is complete.
    //

    keyExchangeClient = new IIS_CRYPTO_EXCHANGE_CLIENT;

    if( keyExchangeClient == NULL ) {
        result = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        goto cleanup;
    }

    result = keyExchangeClient->Initialize(
                 prov,                      // hProv
                 CRYPT_NULL,                // hKeyExchangeKey
                 CRYPT_NULL,                // hSignatureKey
                 TRUE                       // fUseMachineKeyset was FALSE before fix for  213126
                 );

    if( FAILED(result) ) {
        goto cleanup;
    }

    //
    // Phase 1: Get the client's key exchange and signature key blobs,
    // send them to the server, and get the server's key exchange,
    // signature, and session key blobs.
    //

    result = keyExchangeClient->ClientPhase1(
                 &clientKeyExchangeKeyBlob,
                 &clientSignatureKeyBlob
                 );

    if( FAILED(result) ) {
        goto cleanup;
    }

    result = IMSAdminBaseW_R_KeyExchangePhase1_Proxy(
                 (IMSAdminBaseW *)Object,
                 clientKeyExchangeKeyBlob,
                 clientSignatureKeyBlob,
                 &serverKeyExchangeKeyBlob,
                 &serverSignatureKeyBlob,
                 &serverSessionKeyBlob
                 );

    if( FAILED(result) ) {
        goto cleanup;
    }

    //
    // Phase 2: Import the server's key exchange, signature, and session
    // key blobs, get the client's session key and hash blobs, send them
    // to the server, and get the server's hash blob.
    //

    result = keyExchangeClient->ClientPhase2(
                 serverKeyExchangeKeyBlob,
                 serverSignatureKeyBlob,
                 serverSessionKeyBlob,
                 &clientSessionKeyBlob,
                 &clientHashBlob
                 );

    if( FAILED(result) ) {
        goto cleanup;
    }

    result = IMSAdminBaseW_R_KeyExchangePhase2_Proxy(
                 (IMSAdminBaseW *)Object,
                 clientSessionKeyBlob,
                 clientHashBlob,
                 &serverHashBlob
                 );

    if( FAILED(result) ) {
        goto cleanup;
    }

    //
    // Phase 3: Import the server's hash blob.
    //

    result = keyExchangeClient->ClientPhase3(
                 serverHashBlob
                 );

    if( FAILED(result) ) {
        goto cleanup;
    }

    //
    // OK, the key exchange is complete. We just need to create the
    // appropriate storage objects.
    //

    m_SendCryptoStorage = new IIS_CRYPTO_STORAGE;

    if( m_SendCryptoStorage == NULL ) {
        result = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        goto cleanup;
    }

    result = m_SendCryptoStorage->Initialize(
                 keyExchangeClient->QueryProviderHandle(),      // hProv
                 keyExchangeClient->AssumeClientSessionKey(),   // hSessionKey
                 CRYPT_NULL,                                    // hKeyExchangeKey
                 CRYPT_NULL,                                    // hSignatureKey
                 TRUE                                            // fUseMachineKeyset was FALSE before fix for  213126
                 );

    if( FAILED(result) ) {
        goto cleanup;
    }

    m_ReceiveCryptoStorage = new IIS_CRYPTO_STORAGE;

    if( m_ReceiveCryptoStorage == NULL ) {
        result = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        goto cleanup;
    }

    result = m_ReceiveCryptoStorage->Initialize(
                 keyExchangeClient->QueryProviderHandle(),        // hProv
                 keyExchangeClient->AssumeServerSessionKey(),     // hSessionKey
                 CRYPT_NULL,                                      // hKeyExchangeKey
                 keyExchangeClient->AssumeServerSignatureKey(),   // hSignatureKey
                 TRUE                                              // fUseMachineKeyset was FALSE before fix for  213126
                 );

    if( FAILED(result) ) {
        goto cleanup;
    }

    //
    // Success!
    //

    m_KeyExchangeClient = keyExchangeClient;

cleanup:

    //
    // Free any blobs we allocated.
    //

    FREE_BLOB( clientKeyExchangeKeyBlob );
    FREE_BLOB( clientSignatureKeyBlob );
    FREE_BLOB( clientSessionKeyBlob );
    FREE_BLOB( clientHashBlob );
    FREE_BLOB( serverKeyExchangeKeyBlob );
    FREE_BLOB( serverSignatureKeyBlob );
    FREE_BLOB( serverSessionKeyBlob );
    FREE_BLOB( serverHashBlob );

    //
    // If we're failing the call, then free the associated objects we
    // created.
    //

    if( FAILED(result) ) {

        delete keyExchangeClient;
        CleanupCryptoData();

    }
    if (hToken) {
       if( ImpersonateLoggedOnUser( hToken ) )
       {
          // Nothing needs to be done here
       }

       CloseHandle(hToken);
       hToken = NULL;
    }
    return result;

}   // ADM_SECURE_DATA::DoClientSideKeyExchange


HRESULT
ADM_SECURE_DATA::DoServerSideKeyExchangePhase1(
    IN PIIS_CRYPTO_BLOB pClientKeyExchangeKeyBlob,
    IN PIIS_CRYPTO_BLOB pClientSignatureKeyBlob,
    OUT PIIS_CRYPTO_BLOB * ppServerKeyExchangeKeyBlob,
    OUT PIIS_CRYPTO_BLOB * ppServerSignatureKeyBlob,
    OUT PIIS_CRYPTO_BLOB * ppServerSessionKeyBlob
    )
/*++

Routine Description:

    Performs the first phase of server-side key exchange.

Arguments:

    pClientKeyExchangeKeyBlob - The client-side key exchange key blob.

    pClientSignatureKeyBlob - The client-side signature key blob.

    ppServerKeyExchangeKeyBlob - Receives a pointer to the server-side
        key exchange key blob if successful.

    ppServerSignatureKeyBlob - Receives a pointer to the server-side
        signature key blob if successful.

    ppServerSessionKeyBlob - Receives a pointer to the server-side session
        key blob if successful.

Return Value:

    HRESULT - 0 if successful, !0 otherwise.

--*/
{

    HRESULT result;
    HCRYPTPROV prov;
    IIS_CRYPTO_EXCHANGE_SERVER * keyExchangeServer;

    //
    // Sanity check.
    //

    DBG_ASSERT( m_Object != NULL );
    DBG_ASSERT( m_KeyExchangeServer == NULL );
    DBG_ASSERT( m_SendCryptoStorage == NULL );
    DBG_ASSERT( m_ReceiveCryptoStorage == NULL );
    DBG_ASSERT( pClientKeyExchangeKeyBlob != NULL );
    DBG_ASSERT( pClientSignatureKeyBlob != NULL );
    DBG_ASSERT( ppServerKeyExchangeKeyBlob != NULL );
    DBG_ASSERT( ppServerSignatureKeyBlob != NULL );
    DBG_ASSERT( ppServerSessionKeyBlob != NULL );

    HANDLE hToken = NULL;

    if (OpenThreadToken( GetCurrentThread(), MAXIMUM_ALLOWED, TRUE, &hToken ) ) {
        RevertToSelf();
    }
    //
    // Setup locals so we know how to cleanup on exit.
    //

    keyExchangeServer = NULL;

    //
    // Get the crypto provider to use.
    //

    DBG_CODE( prov = CRYPT_NULL );

    result = GetServerCryptoProvider( &prov );

    if( FAILED(result) ) {
        goto cleanup;
    }

    DBG_ASSERT( prov != CRYPT_NULL );

    //
    // Create & initialize the server-side key exchange object.
    //
    // N.B. Do not set the m_KeyExchangeServer to a non-NULL value
    // until key exchange is complete.
    //

    keyExchangeServer = new IIS_CRYPTO_EXCHANGE_SERVER;

    if( keyExchangeServer == NULL ) {
        result = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        goto cleanup;
    }

    result = keyExchangeServer->Initialize(
                 prov,                      // hProv
                 CRYPT_NULL,                // hKeyExchangeKey
                 CRYPT_NULL,                // hSignatureKey
                 FALSE                      // fUseMachineKeyset
                 );

    if( FAILED(result) ) {
        goto cleanup;
    }

    //
    // Do the first phase of the key exchange.
    //

    result = keyExchangeServer->ServerPhase1(
                 pClientKeyExchangeKeyBlob,
                 pClientSignatureKeyBlob,
                 ppServerKeyExchangeKeyBlob,
                 ppServerSignatureKeyBlob,
                 ppServerSessionKeyBlob
                 );

    if( FAILED(result) ) {
        goto cleanup;
    }

    //
    // Success!
    //

    m_KeyExchangeServer = keyExchangeServer;

cleanup:

    //
    // If we're failing the call, then free the associated objects we
    // created.
    //

    if( FAILED(result) ) {

        delete keyExchangeServer;

    }
    if (hToken) {
       if( ImpersonateLoggedOnUser( hToken ) )
       {
           // Don't need to anything here
       }

       CloseHandle(hToken);
       hToken = NULL;
    }

    return result;

}   // ADM_SECURE_DATA::DoServerSideKeyExchangePhase1


HRESULT
ADM_SECURE_DATA::DoServerSideKeyExchangePhase2(
    IN PIIS_CRYPTO_BLOB pClientSessionKeyBlob,
    IN PIIS_CRYPTO_BLOB pClientHashBlob,
    OUT PIIS_CRYPTO_BLOB * ppServerHashBlob
    )
/*++

Routine Description:

    Performs the second phase of server-side key exchange.

Arguments:

    pClientSessionKeyBlob - The client-side session key blob.

    pClientHashBlob - The client-side hash blob.

    ppServerHashBlob - Receives a pointer to the server-side hash blob
        if successful.

Return Value:

    HRESULT - 0 if successful, !0 otherwise.

--*/
{

    HRESULT result;

    //
    // Sanity check.
    //

    DBG_ASSERT( m_Object != NULL );
    DBG_ASSERT( m_KeyExchangeServer != NULL );
    DBG_ASSERT( m_SendCryptoStorage == NULL );
    DBG_ASSERT( m_ReceiveCryptoStorage == NULL );
    DBG_ASSERT( pClientSessionKeyBlob != NULL );
    DBG_ASSERT( pClientHashBlob != NULL );
    DBG_ASSERT( ppServerHashBlob != NULL );

    HANDLE hToken = NULL;

    if (OpenThreadToken( GetCurrentThread(), MAXIMUM_ALLOWED, TRUE, &hToken ) ) {
        RevertToSelf();
    }
    //
    // Do the second phase of the key exchange.
    //

    result = m_KeyExchangeServer->ServerPhase2(
                 pClientSessionKeyBlob,
                 pClientHashBlob,
                 ppServerHashBlob
                 );

    if( FAILED(result) ) {
        goto cleanup;
    }

    //
    // OK, the key exchange is complete. We just need to create the
    // appropriate storage objects.
    //

    m_SendCryptoStorage = new IIS_CRYPTO_STORAGE;

    if( m_SendCryptoStorage == NULL ) {
        result = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        goto cleanup;
    }

    result = m_SendCryptoStorage->Initialize(
                 m_KeyExchangeServer->QueryProviderHandle(),    // hProv
                 m_KeyExchangeServer->AssumeServerSessionKey(), // hSessionKey
                 CRYPT_NULL,                                    // hKeyExchangeKey
                 CRYPT_NULL,                                    // hSignatureKey
                 FALSE                                          // fUseMachineKeyset
                 );

    if( FAILED(result) ) {
        goto cleanup;
    }

    m_ReceiveCryptoStorage = new IIS_CRYPTO_STORAGE;

    if( m_ReceiveCryptoStorage == NULL ) {
        result = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        goto cleanup;
    }

    result = m_ReceiveCryptoStorage->Initialize(
                 m_KeyExchangeServer->QueryProviderHandle(),      // hProv
                 m_KeyExchangeServer->AssumeClientSessionKey(),   // hSessionKey
                 CRYPT_NULL,                                      // hKeyExchangeKey
                 m_KeyExchangeServer->AssumeClientSignatureKey(), // hSignatureKey
                 FALSE                                            // fUseMachineKeyset
                 );

    if( FAILED(result) ) {
        goto cleanup;
    }

    //
    // Success!
    //

cleanup:

    //
    // If we're failing the call, then free the associated objects we
    // created.
    //

    if( FAILED(result) ) {

        CleanupCryptoData();

    }
    if (hToken) {
       if( ImpersonateLoggedOnUser( hToken ) )
       {
           // Don't need to do anything here
       }

       CloseHandle(hToken);
       hToken = NULL;
    }

    return result;

}   // ADM_SECURE_DATA::DoServerSideKeyExchangePhase2


HRESULT
ADM_SECURE_DATA::GetCryptoProviderHelper(
    OUT HCRYPTPROV * UserProvider,
    OUT HCRYPTPROV * CachedProvider,
    IN LPTSTR ContainerName,
    IN DWORD CryptoFlags
    )
/*++

Routine Description:

    Helper routine for GetServerCryptoProvider and GetClientCryptoProvider().
    Provides necessary locking to ensure exactly one provider of each type
    is opened.

Arguments:

    UserProvider - Receives the handle to the provider.

    CachedProvider - Also receives the handle to the provider.

    ContainerName - The name of the container to open/create.

    CryptoFlags - Flags to pass into IISCryptoGetStandardContainer().

Return Value:

    HRESULT - 0 if successful, !0 otherwise.

--*/
{

    HRESULT result = NO_ERROR;
    HCRYPTPROV hprov;

    //
    // Sanity check.
    //

    DBG_ASSERT( UserProvider != NULL );
    DBG_ASSERT( CachedProvider != NULL );

    LockThis();

    //
    // Recheck the provider handle under the guard of the lock, just
    // in case another thread has already created it.
    //

    hprov = *CachedProvider;

    if( hprov == CRYPT_NULL ) {

        //
        // Open/create the container.
        //

        result = IIS_CRYPTO_BASE::GetCryptoContainerByName(
                     &hprov,
                     ContainerName,
                     CryptoFlags,
                     FALSE              // fApplyAcl
                     );

    }

    if( SUCCEEDED(result) ) {
        DBG_ASSERT( hprov != CRYPT_NULL );
        *CachedProvider = hprov;
        *UserProvider = hprov;
    }

    UnlockThis();
    return result;

}   // ADM_SECURE_DATA::GetCryptoProviderHelper


VOID
ADM_SECURE_DATA::CleanupCryptoData()
/*++

Routine Description:

    Frees any crypto data associated with the current object.

Arguments:

    None.

Return Value:

    None.

--*/
{

    delete m_KeyExchangeClient;
    m_KeyExchangeClient = NULL;

    delete m_KeyExchangeServer;
    m_KeyExchangeServer = NULL;

    delete m_SendCryptoStorage;
    m_SendCryptoStorage = NULL;

    delete m_ReceiveCryptoStorage;
    m_ReceiveCryptoStorage = NULL;

}   // ADM_SECURE_DATA::CleanupCryptoData



HRESULT
ADM_SECURE_DATA::GetClientCryptoProvider(
    OUT HCRYPTPROV * Provider
    )
/*++

Routine Description:

    This method calls down to GetCryptoProviderHelper to create key
    and before that it prepares a name for key container

Arguments:

    Provider - returns handle to provider


Return Value:

    HRESULT error code if fail

--*/
{
    HRESULT retVal = NO_ERROR;

    if( sm_ClientCryptoProvider != CRYPT_NULL ) {
        *Provider = sm_ClientCryptoProvider;
        return retVal;
    }

    //
    // Previously each user had a unique container name generated
    // and keys would be stored persistently.
    // Currently temporary container will be created to store temporary
    // keys. This way the race condition will be prevented where multiple
    // processes running under the same user identity would try to create
    // container of the same name (and one would eventually fail)
    //

    retVal =  GetCryptoProviderHelper( Provider,
                                       &sm_ClientCryptoProvider,
                                       NULL, // CREATE temporary container
                                       0
                                       );

    return retVal;
}


#define BUFSIZE_FOR_TOKEN   256

HRESULT
ADM_SECURE_DATA::GenerateNameForContainer(
    IN OUT PCHAR pszContainerName,
    IN DWORD dwBufferLen
    )
/*++

Routine Description:

    This method generates the name for crypoto container by taking some string
    which has 'IIS client ' appending that with suer name and user SID for uniqueness

Arguments:

    pszContainerName - pointer to a buffer which will receive a generated string

    dwBufferLen - size of buffer suplied for receiving string

Return Value:

    HRESULT

--*/
{
    HANDLE      hToken;
    BYTE        buf[BUFSIZE_FOR_TOKEN];
    PTOKEN_USER ptgUser = (PTOKEN_USER)buf;
    DWORD       cbBuffer=BUFSIZE_FOR_TOKEN;
    DWORD       dwLenOfBuffer, dwLenOfBuffAvailable;
    BOOL        bSuccess;
    PCHAR       pszPlaceToAppend;
    DWORD       dwError;



    //
    // initialize string with some name for IIS client container
    //
    if (sizeof (DCOM_CLIENT_CONTAINER)  >= dwBufferLen)
    {
        return RETURNCODETOHRESULT(ERROR_INSUFFICIENT_BUFFER);
    }
    strcpy (pszContainerName, DCOM_CLIENT_CONTAINER);

    dwLenOfBuffer = (DWORD)strlen(pszContainerName);
    pszPlaceToAppend = pszContainerName + dwLenOfBuffer;
    dwLenOfBuffAvailable =  dwBufferLen - dwLenOfBuffer;

    if ( !GetUserName(pszPlaceToAppend,&dwLenOfBuffAvailable) )
    {
        return RETURNCODETOHRESULT(GetLastError());
    }

    dwLenOfBuffer += dwLenOfBuffAvailable;
    pszPlaceToAppend = pszContainerName + dwLenOfBuffer - 1;
    dwLenOfBuffAvailable = dwBufferLen - dwLenOfBuffer - 1;


    //
    // obtain current process token
    //

    if(!OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, TRUE, &hToken ))
    {
        if(GetLastError() != ERROR_NO_TOKEN)
        {
            return RETURNCODETOHRESULT(GetLastError());
        }

        //
        // retry against process token if no thread token exists
        //
        if(!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken))
        {
            return RETURNCODETOHRESULT(GetLastError());
        }
    }


    //
    // obtain user identified by current process' access token
    //

    bSuccess = GetTokenInformation( hToken,    // identifies access token
                                    TokenUser, // TokenUser info type
                                    ptgUser,   // retrieved info buffer
                                    cbBuffer,  // size of buffer passed-in
                                    &cbBuffer  // required buffer size
                                    );

    if (!bSuccess)
    {
        dwError= GetLastError();

        // close token handle.  do this even if error above
        CloseHandle(hToken);
        return RETURNCODETOHRESULT(dwError);
    }

    // close token handle
    CloseHandle(hToken);

    //
    // obtain the textual representaion of the Sid
    //
    return GetTextualSid( ptgUser->User.Sid,        // user binary Sid
                          pszPlaceToAppend,         // buffer for TextualSid
                          &dwLenOfBuffAvailable     // size/required buffer
                          );
}

HRESULT
ADM_SECURE_DATA::GetTextualSid(
    PSID pSid,          // binary Sid
    LPTSTR TextualSid,  // buffer for Textual representaion of Sid
    LPDWORD cchSidSize  // required/provided TextualSid buffersize
    )
/*++

Routine Description:

    Thsi method converts bianry SID to text representation

Arguments:

    pSid -  binary SID

    TextualSid - buffer for Textual representaiton of SID

    cchSidSize - required/provided TextualSid buffersize


Return Value:

    HRESULT

--*/
{
    PSID_IDENTIFIER_AUTHORITY psia;
    DWORD dwSubAuthorities;
    DWORD dwCounter;
    DWORD cchSidCopy;

    //
    // test if Sid passed in is valid
    //
    if(!IsValidSid(pSid))
    {
        return RETURNCODETOHRESULT(ERROR_INVALID_SID);
    }

    // obtain SidIdentifierAuthority
    psia = GetSidIdentifierAuthority(pSid);

    // obtain sidsubauthority count
    dwSubAuthorities = *GetSidSubAuthorityCount(pSid);

    //
    // compute approximate buffer length
    // S-SID_REVISION- + identifierauthority- + subauthorities- + NULL
    //
    cchSidCopy = (15 + 12 + (12 * dwSubAuthorities) + 1) * sizeof(TCHAR);

    //
    // check provided buffer length.
    // If not large enough, indicate proper size and setlasterror
    //
    if(*cchSidSize < cchSidCopy)
    {
        *cchSidSize = cchSidCopy;
        return RETURNCODETOHRESULT(ERROR_INSUFFICIENT_BUFFER);
    }

    //
    // prepare S-SID_REVISION-
    //
    cchSidCopy = wsprintf(TextualSid, "S-%lu-", SID_REVISION );

    //
    // prepare SidIdentifierAuthority
    //
    if ( (psia->Value[0] != 0) || (psia->Value[1] != 0) )
    {
        cchSidCopy += wsprintf(TextualSid + cchSidCopy,
            "0x%02hx%02hx%02hx%02hx%02hx%02hx",
            (USHORT)psia->Value[0],
            (USHORT)psia->Value[1],
            (USHORT)psia->Value[2],
            (USHORT)psia->Value[3],
            (USHORT)psia->Value[4],
            (USHORT)psia->Value[5]);
    }
    else
    {
        cchSidCopy += wsprintf(TextualSid + cchSidCopy,
            "%lu",
            (ULONG)(psia->Value[5]      )   +
            (ULONG)(psia->Value[4] <<  8)   +
            (ULONG)(psia->Value[3] << 16)   +
            (ULONG)(psia->Value[2] << 24)   );
    }

    //
    // loop through SidSubAuthorities
    //
    for(dwCounter = 0 ; dwCounter < dwSubAuthorities ; dwCounter++)
    {
        cchSidCopy += wsprintf(TextualSid + cchSidCopy, "-%lu",
            *GetSidSubAuthority(pSid, dwCounter) );
    }

    //
    // tell the caller how many chars we provided, not including NULL
    //
    *cchSidSize = cchSidCopy;

    return NO_ERROR;
}




ADM_GUID_MAP::ADM_GUID_MAP(
        IN IUnknown * Object,
        IN GUID guidServer
        ):m_Object( Object ),
          m_ReferenceCount( 1 ),
          m_guidServer(guidServer)
/*++

Routine Description:

    ADM_GUID_MAP object constructor.

Arguments:

    Object - Pointer to the object to associate.

Return Value:

    None.

--*/
{
    //
    // Sanity check.
    //

    DBG_ASSERT( Object != NULL );
    DBG_ASSERT( guidServer != GUID_NULL );

    //
    // Initialize any complex data members.
    //

    INITIALIZE_CRITICAL_SECTION( &m_ObjectLock );

    //
    // Put ourselves on the list.
    //

    AcquireDataLock();
        InsertHeadList( &sm_GuidMapListHead, &m_GuidMapListEntry );
    ReleaseDataLock();

}   // ADM_GUID_MAP::ADM_GUID_MAP


ADM_GUID_MAP::~ADM_GUID_MAP()
/*++

Routine Description:

    ADM_SECURE_DATA object destructor.

Arguments:

    None.

Return Value:

    None.

--*/
{

    //
    // Sanity check.
    //

    DBG_ASSERT( m_ReferenceCount == 0 );

    //
    // AddRef the ADM_SECURE_DATA
    // Do this here instead of constructor to
    // all handing of errors.
    //

    ADM_SECURE_DATA *psecdatData;
    psecdatData = ADM_SECURE_DATA::FindAndReferenceClientSecureData( this );
    if (psecdatData != NULL) {
        psecdatData->Dereference();
        psecdatData->Dereference();
    }


    //
    // Cleanup.
    //

    AcquireDataLock();
    RemoveEntryList( &m_GuidMapListEntry );
    ReleaseDataLock();

    DeleteCriticalSection( &m_ObjectLock );

}   // ADM_SECURE_DATA::~ADM_SECURE_DATA

VOID
ADM_GUID_MAP::Initialize( VOID
    )
/*++

Routine Description:

    Initializes static global data private to ADM_SECURE_DATA.

Arguments:

    hDll - Handle to this DLL.

Return Value:

    None.

--*/
{

    INITIALIZE_CRITICAL_SECTION( &sm_GuidMapDataLock );

#if DBG
    sm_GuidMapLockOwner = 0;
    sm_RefTraceLog = CreateRefTraceLog( 1024, 0 );
#endif

    InitializeListHead( &sm_GuidMapListHead );

}   // ADM_SECURE_DATA::Initialize

VOID
ADM_GUID_MAP::Terminate()
{
    PLIST_ENTRY entry;
    ADM_GUID_MAP * data;

    //
    // Free any secure data objects on our list.
    //

    AcquireDataLock();

    entry = sm_GuidMapListHead.Flink;

    while( entry != &sm_GuidMapListHead ) {

        data = CONTAINING_RECORD(
                   entry,
                   ADM_GUID_MAP,
                   m_GuidMapListEntry
                   );

        data->Dereference();

        entry = sm_GuidMapListHead.Flink;
    }


    ReleaseDataLock();

    DBG_ASSERT( IsListEmpty( &sm_GuidMapListHead ) );

    //
    // Final cleanup.
    //

    DeleteCriticalSection( &sm_GuidMapDataLock );

#if DBG
    if( sm_RefTraceLog != NULL ) {
        DestroyRefTraceLog( sm_RefTraceLog );
    }
#endif
}

    //
    // Find and reference the ADM_GUID_MAP object associatd with the
    // given object; create if not found.
    //

ADM_GUID_MAP *
ADM_GUID_MAP::FindAndReferenceGuidMap(
    IN IUnknown         *Object )
{
    PLIST_ENTRY         entry;
    ADM_GUID_MAP        *pguidmapData;

    AcquireDataLock();

    for( entry = sm_GuidMapListHead.Flink ;
         entry != &sm_GuidMapListHead ;
         entry = entry->Flink )
    {
        pguidmapData = CONTAINING_RECORD( entry,
                                          ADM_GUID_MAP,
                                          m_GuidMapListEntry );

        if( pguidmapData->m_Object == Object )
        {
            pguidmapData->Reference();
            goto exit;
        }
    }

    pguidmapData = NULL;

exit:
    ReleaseDataLock();

    return pguidmapData;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\dcomadm\mdutil\admutil.cpp ===
/*++

   Copyright    (c)    1997    Microsoft Corporation

   Module  Name :

       admutil.cpp

   Abstract:

        IADMCOM interface WRAPPER functions implemetation

   Environment:

      Win32 User Mode

   Author:

      jaroslad  (jan 1997)

--*/



#define INITGUID

#include <tchar.h>
#include <afx.h>
#include <debnot.h>

#ifdef UNICODE
    #include <iadmw.h>
    #define IADM_PBYTE
#else
    #include "ansimeta.h"
    //convert when using ANSI interface
    #define IADM_PBYTE   (PBYTE)
#endif

//#define SPECIAL_SHOW_ALL_METABASE

#include <iiscnfg.h>

#include <ole2.h>

#include <ctype.h>  //import toupper
#include <stdlib.h>
#include <stdio.h>
#include <conio.h>

#include "admutil.h"
#include "tables.h"
#include <jd_misc.h>

#undef SHOW_SECURE
//////////////////////////////
//global variable definition
DWORD g_dwTIMEOUT_VALUE =30000;

DWORD g_dwDELAY_AFTER_OPEN_VALUE=0;
//////////////////////////////

//*********************

CString FindCommonPath(CString a_strPath1, CString a_strPath2)
{
    CString strCommonPath=_TEXT("");
    int MinLength=a_strPath1.GetLength();
    int i;
    //find shorter from strings
    if(a_strPath2.GetLength() < MinLength)
            MinLength=a_strPath2.GetLength();
    for(i=0; i<MinLength; i++)
    {
        if(a_strPath1.GetAt(i)!=a_strPath2.GetAt(i) )
            // common path cannot be any longer;
            break;
    }
    //  now find the previous '/' and all before '/' is the common path
    for(i=i-1; i>=0;i--)
    {
        if(a_strPath1.GetAt(i)==_T('/'))
        {
            strCommonPath=a_strPath1.Left(i+1);//take the trailing '/' with you
            //strRelSrcPath=strPath1.Mid(i+1);
            //strRelDstPath=strPath2.Mid(i+1);
            break;
        }
    }
    return strCommonPath;
}


//**********************************************************************
//IMPLEMENTATION  of CAdmNode
//**********************************************************************



//return the position of '/' that is iSeqNumber in the order
//e.g: GetSlashIndex("aaa/bbb/ccc/ddd",2) returns position of 2nd index that equals 7)
INT CAdmNode::GetSlashIndex(const CString& strPath, INT iSeqNumber)
{
    INT count=0;
    if (iSeqNumber==0)
        return 0;
    for(INT i=0; i<strPath.GetLength();i++)
    {
        if(strPath[i]==_T('/'))
            if((++count)==iSeqNumber)
                return i;
    }
    return -1;

}

//return the count of '/' in strPath

INT CAdmNode::GetCountOfSlashes(const CString& strPath)
{
    INT count=0;
    for(INT i=0; i<strPath.GetLength();i++)
    {
        if(strPath[i]==_T('/'))
            count++;
    }
    return count;
}

//return selement within the given string with sequence number wIndex
//e.g.: GetPartOfPath("aaa/bbb/ccc",1,1) will return "bbb"
//e.g.: GetPartOfPath("aaa/bbb/ccc",1) will return "bbb/ccc"
//e.g.: GetPartOfPath("aaa/bbb/ccc",0,1) will return "aaa/bbb"

//iStart- sequence number of first slash
//iEnd- sequence number of last slash
CString CAdmNode::GetPartOfPath(const CString& strPath, INT iStart, INT iEnd)
{
    if(iEnd!=-1 && iEnd <= iStart)
        return _TEXT("");
    INT i=0;
    INT iPosBegin = GetSlashIndex(strPath,iStart);
    if(iPosBegin==-1) //not found (exceeds number of slashes available in strPath
    {
        return _TEXT("");
    }
    iPosBegin+=((iStart==0)?0:1); //adjust iPosBegin

    INT iPosEnd = GetSlashIndex(strPath,iEnd);
    CString strToReturn;
    if(iEnd==-1 || iPosEnd==-1)
        strToReturn = strPath.Mid(iPosBegin);
    else
        strToReturn = strPath.Mid(iPosBegin,iPosEnd-iPosBegin);
    if(iStart==0 && strToReturn==_TEXT("") && strPath!=_TEXT(""))
        return _TEXT("/"); //this had to be root
    else
        return strToReturn;
}


//within path can be given computer name, service, instance number
// function will split the path to Computer, Service, Instance, Path relative to instance
//

void CAdmNode::SetPath(CString a_strPath)
{
    if(a_strPath.IsEmpty())
        return;

    // change backslashes
    for(int i=0; i<a_strPath.GetLength(); i++)
    {
        // skip DBCS
        if(IsDBCSLeadByte(a_strPath[i]))
        {
            i++;
            continue;
        }
        if(a_strPath[i]==_T('\\'))
            a_strPath.SetAt(i,_T('/'));
    }

    //trim  leading '/'
    while (a_strPath.GetLength()!=0 && a_strPath[0]==_T('/'))
        a_strPath=a_strPath.Mid(1);


    int iSvc=-1;

    if( IsServiceName(GetPartOfPath(a_strPath,1,2))) //get the second name within path
    { //if second is service then first has to be computer name
        strComputer = GetPartOfPath(a_strPath,0,1);
        strService  = GetPartOfPath(a_strPath,1,2);
        if( IsNumber(GetPartOfPath(a_strPath,2,3))) {
            strInstance = GetPartOfPath(a_strPath,2,3);
            strIPath = GetPartOfPath(a_strPath,3); //store the rest
        }
        else {
            strIPath = GetPartOfPath(a_strPath,2); //store the rest

        }
    }
    else if( IsServiceName(GetPartOfPath(a_strPath,0,1))) //get the second name within path
    { //if second is service then first has to be computer name
        strComputer = _TEXT("");
        strService  = GetPartOfPath(a_strPath,0,1);
        if( IsNumber(GetPartOfPath(a_strPath,1,2))) {
            strInstance = GetPartOfPath(a_strPath,1,2);
            strIPath = GetPartOfPath(a_strPath,2); //store the rest
        }
        else {
            strIPath = GetPartOfPath(a_strPath,1); //store the rest
        }
    }
    else
    {
        strIPath = a_strPath;
    }

    //in IPath there can be Property name at the end
    INT iCount= GetCountOfSlashes(strIPath);
    CString LastName= GetPartOfPath(strIPath,iCount); //get last name within path;

     if(MapPropertyNameToCode(LastName)!=NAME_NOT_FOUND)
     {  //the Last name in the path is valid Property name
        strProperty = LastName;
        strIPath = GetPartOfPath(strIPath,0,iCount); //Strip Last name from IPath
     }
}

CString CAdmNode::GetLMRootPath(void)
{
#ifdef SPECIAL_SHOW_ALL_METABASE
    return _T("/");
#else
    return _T("/")+CString(IIS_MD_LOCAL_MACHINE_PATH);
#endif
}



CString CAdmNode::GetLMServicePath(void)
{
    if(strService.IsEmpty())
        return GetLMRootPath();
    else
        return GetLMRootPath()+_T("/")+strService;
}

CString CAdmNode::GetLMInstancePath(void)
{
    if(strInstance.IsEmpty())
        return GetLMServicePath();
    else
        return GetLMServicePath()+_T("/")+strInstance;
}

CString CAdmNode::GetLMNodePath(void)
{
    if(strIPath.IsEmpty())
        return GetLMInstancePath();
    else
        return GetLMInstancePath()+_T("/")+strIPath;
}

CString CAdmNode::GetServicePath(void)
{
    if(strService.IsEmpty())
        return _TEXT("");
    else
        return _T("/")+strService;
}

CString CAdmNode::GetInstancePath(void)
{
    if(!strInstance.IsEmpty())
        return GetServicePath() + _T("/")+ strInstance;
    else
        return GetServicePath();
}

CString CAdmNode::GetNodePath(void)
{

    if(!strIPath.IsEmpty())
        return GetInstancePath() + _T("/")+ strIPath;
    else
        return GetInstancePath();
}



CString CAdmNode::GetParentNodePath(void)
{
    CString strNodePath;
    strNodePath = GetNodePath();

    if(strNodePath.IsEmpty())
        return strNodePath;
    else
    {
        INT i= strNodePath.GetLength()-1; //point to the end of strNodePath
        if (strNodePath.Right(1)==_T("/"))
            i--;
        for(; i>=0; i--)
        {
            if(strNodePath.GetAt(i)==_T('/'))
                return strNodePath.Left(i+1);
        }
        return _TEXT("");
    }
}
//can return _TEXT("") for nonamed
CString CAdmNode::GetCurrentNodeName(void)
{
    CString strNodePath;
    strNodePath = GetNodePath();

    if(strNodePath.IsEmpty())
        return strNodePath;
    else
    {
        INT i= strNodePath.GetLength()-1; //point to the end of strNodePath
        if (strNodePath.Right(1)==_T("/"))
            i--;
        for(int count=0; i>=0; i--, count++) //search backward for '/'
        {
            if(strNodePath.GetAt(i)==_T('/'))
                return strNodePath.Mid(i+1,count);
        }
        return strNodePath;
    }
}


CString CAdmNode::GetRelPathFromService(void)
{
    CString str=strService;
    if (!strInstance.IsEmpty())
        str=str+_T("/")+strInstance;
    if (!strIPath.IsEmpty())
        str=str+_T("/")+strIPath;
    return str;
}

CString CAdmNode::GetRelPathFromInstance(void)
{
    if(strInstance.IsEmpty())
        return strIPath;
    else
        return  strInstance+_T("/")+strIPath;
}

//**********************************************************************
//**********************************************************************
//IMPLEMENTATION  of CAdmProp object
//**********************************************************************
//**********************************************************************

CAdmProp::CAdmProp(METADATA_RECORD &a_mdr)
{
    memcpy (&mdr,&a_mdr,sizeof(METADATA_RECORD));
}

void CAdmProp::SetValue(DWORD a_dwValue)
{
    if(mdr.pbMDData!=0)
        delete mdr.pbMDData;
    mdr.dwMDDataLen= sizeof(DWORD);
    mdr.pbMDData = (PBYTE) new char[mdr.dwMDDataLen];
    memcpy(mdr.pbMDData,&a_dwValue,mdr.dwMDDataLen);


}


void CAdmProp::SetValue(CString a_strValue)
{
    if(mdr.pbMDData!=0)
        delete mdr.pbMDData;
    mdr.dwMDDataLen = (a_strValue.GetLength()+1)*sizeof(_TCHAR);
    mdr.pbMDData = (PBYTE) new _TCHAR [mdr.dwMDDataLen/sizeof(_TCHAR)];
    memcpy(mdr.pbMDData,LPCTSTR(a_strValue),mdr.dwMDDataLen-sizeof(_TCHAR));
    ((_TCHAR *)mdr.pbMDData)[mdr.dwMDDataLen/sizeof(_TCHAR)-1]=0; //terminate with zero
}

void CAdmProp::SetValue(LPCTSTR *a_lplpszValue, DWORD a_dwValueCount)
{
    if(mdr.pbMDData!=NULL)
    {
        delete mdr.pbMDData;
        mdr.pbMDData=0;
    }
    mdr.dwMDDataLen=0;
    for(DWORD i=0; i< a_dwValueCount; i++)
    {
        if(a_lplpszValue[i]==NULL)
            break;

        mdr.dwMDDataLen += (DWORD)(_tcslen(a_lplpszValue[i])+1)*sizeof(_TCHAR);
    }
    mdr.dwMDDataLen+=sizeof(_TCHAR); // two 0 at the end
    mdr.pbMDData = (PBYTE) new char[mdr.dwMDDataLen];
    //merge strings in one area of memory
    DWORD j=0; //index to destination where stings will be merged
    for( i=0; i< a_dwValueCount; i++) //index to aray of strings
    {
        if(a_lplpszValue[i]==NULL)
            break;
        DWORD k=0; //index within string
        while(a_lplpszValue[i][k]!=0)
            ((_TCHAR *)mdr.pbMDData)[j++]=a_lplpszValue[i][k++];
        ((_TCHAR *)mdr.pbMDData)[j++]=0;
    }
    ((_TCHAR *)mdr.pbMDData)[j++]=0;
}

void
CAdmProp::SetValue(
    LPBYTE pbValue,
    DWORD dwValueLength
    )
{
    if( mdr.pbMDData != NULL )
    {
        delete mdr.pbMDData;
    }
    mdr.dwMDDataLen = dwValueLength;
    mdr.pbMDData = (PBYTE) new BYTE[mdr.dwMDDataLen];
    memcpy( mdr.pbMDData, pbValue, mdr.dwMDDataLen );
}


//sets the value depending on GetDataType()

BOOL CAdmProp::SetValueByDataType(LPCTSTR *a_lplpszPropValue, DWORD* a_lpdwPropValueLength, WORD a_wPropValueCount)
{
//process the value
    WORD i;
    if(a_wPropValueCount!=0)
    {   DWORD dwValue=0;
        switch(GetDataType())
        {
        case DWORD_METADATA:
            {
                for (i=0;i<a_wPropValueCount;i++)
                {
                    if( _tcslen(a_lplpszPropValue[i]) > 2 && a_lplpszPropValue[i][0]==_T('0') && _toupper(a_lplpszPropValue[i][1])==_T('X'))
                    {   _TCHAR * lpszX;
                        dwValue += _tcstoul(a_lplpszPropValue[i]+2, &lpszX, 16);
                    }
                    else if(IsNumber(a_lplpszPropValue[i]))
                        dwValue += _ttol(a_lplpszPropValue[i]);
                    else
                    {
                        DWORD dwMapped=MapValueNameToCode(a_lplpszPropValue[i],GetIdentifier());

                        if(dwMapped==NAME_NOT_FOUND)
                        {
                            printf/*Print*/(_TEXT("value not resolved: %s\n"),a_lplpszPropValue[i]);
                            return FALSE;
                        }
                        else
                        // it has to be checked if adding can be performed
                            dwValue |= dwMapped;
                    }
                }
                SetValue(dwValue);
            }
            break;
        case STRING_METADATA:
        case EXPANDSZ_METADATA:
            {
                CString strValue=_TEXT("");
                for (i=0;i<a_wPropValueCount;i++)
                {
                    strValue += a_lplpszPropValue[i];
                }
                SetValue(strValue);
            }
            break;
        case MULTISZ_METADATA:
            {
                SetValue(a_lplpszPropValue, a_wPropValueCount);
            }
            break;
        case BINARY_METADATA:
            SetValue( (LPBYTE)a_lplpszPropValue[0], a_lpdwPropValueLength[0] );
            break;
        default:
            return FALSE;
        }
    }
    return TRUE;
}

void CAdmProp::Print(const _TCHAR * format,...)
{
   _TCHAR buffer[2000];
   va_list marker;
   va_start( marker, format );     /* Initialize variable arguments. */
   //_vstprintf(buffer,format, marker);
   _vsnprintf(buffer,1500,format, marker);
   _tprintf(_TEXT("%s"),buffer);

   va_end( marker );              /* Reset variable arguments.      */

}


void CAdmProp::PrintProperty(void)
{
    CString strPropName=tPropertyNameTable::MapCodeToName(mdr.dwMDIdentifier);
    BOOL    fSecure =(mdr.dwMDAttributes&METADATA_SECURE);

    //print code or name of property
    if(strPropName.IsEmpty())
        printf/*Print*/(_TEXT("%-30ld: "), mdr.dwMDIdentifier);
    else
    {
	if(getenv("MDUTIL_PRINT_ID")!=NULL) //let's print out Identifier numeric values when environment variable is set
        	printf/*Print*/(_TEXT("%ld %-25s: "), mdr.dwMDIdentifier,LPCTSTR(strPropName));
	else
	        printf/*Print*/(_TEXT("%-30s: "), LPCTSTR(strPropName));
    }
    CString strFlagsToPrint=_TEXT("");

    strFlagsToPrint+=_TEXT("[");
    if(mdr.dwMDAttributes&METADATA_INHERIT)
        strFlagsToPrint+=_TEXT("I");
    if(mdr.dwMDAttributes&METADATA_SECURE)
        strFlagsToPrint+=_TEXT("P");
    if(mdr.dwMDAttributes&METADATA_REFERENCE)
        strFlagsToPrint+=_TEXT("R");
    if(mdr.dwMDUserType==IIS_MD_UT_SERVER)
        strFlagsToPrint+=_TEXT("S");
    if(mdr.dwMDUserType==IIS_MD_UT_FILE)
        strFlagsToPrint+=_TEXT("F");
    if(mdr.dwMDUserType==IIS_MD_UT_WAM)
        strFlagsToPrint+=_TEXT("W");
    if(mdr.dwMDUserType==ASP_MD_UT_APP)
        strFlagsToPrint+=_TEXT("A");
    strFlagsToPrint+=_TEXT("]");
    printf/*Print*/(_TEXT("%-8s"),LPCTSTR(strFlagsToPrint));

    //print property value
    DWORD i;
    switch (mdr.dwMDDataType) {
    case DWORD_METADATA:
#ifndef SHOW_SECURE
        if ( fSecure && getenv("MDUTIL_PRINT_SECURE")==NULL)

        {
            printf/*Print*/(_TEXT("(DWORD)  ********")); // *(DWORD *)(mdr.pbMDData));
        }
        else
#endif
        {
            printf/*Print*/(_TEXT("(DWORD)  0x%x"), *(DWORD *)(mdr.pbMDData));
            // try to convert to readable info
            CString strNiceContent;
            strNiceContent=tValueTable::MapValueContentToString(*(DWORD *)(mdr.pbMDData), mdr.dwMDIdentifier);
            if(!strNiceContent.IsEmpty())
                printf/*Print*/(_TEXT("={%s}"),LPCTSTR(strNiceContent));
            else //at least decimal value can be useful
                printf/*Print*/(_TEXT("={%ld}"),*(DWORD *)(mdr.pbMDData));
        }
        break;
    case BINARY_METADATA:

        printf/*Print*/(_TEXT("(BINARY) 0x"));
#ifndef SHOW_SECURE
	if ( fSecure && getenv("MDUTIL_PRINT_SECURE")==NULL)
        {
                printf/*Print*/(_TEXT(" * " ));
        }
	else
#endif
        {
	        for (i = 0; i < mdr.dwMDDataLen; i++)
		{
	       	        printf/*Print*/(_TEXT("%02x "), ((PBYTE)(mdr.pbMDData))[i]);
	        }
	}
        break;

    case STRING_METADATA:
    case EXPANDSZ_METADATA:
        if(mdr.dwMDDataType==STRING_METADATA)
                printf/*Print*/(_TEXT("(STRING) "));
        else
                printf/*Print*/(_TEXT("(EXPANDSZ) "));
#ifndef SHOW_SECURE
        if( fSecure && getenv("MDUTIL_PRINT_SECURE")==NULL)
        { //do not expose the length of secure data
           printf/*Print*/( _TEXT("\"********************\"" ));
        }
        else
#endif
        {
          printf/*Print*/(_TEXT("\""));
          for (i = 0; i < mdr.dwMDDataLen/sizeof(_TCHAR); i++) {
            if(((_TCHAR *)(mdr.pbMDData))[i]==0)
            {
                if( i+1 == mdr.dwMDDataLen/sizeof(_TCHAR))
                { //we are at the end print only terminating "
                    printf/*Print*/(_TEXT("\""));
                }
                else
                {
                    printf/*Print*/(_TEXT("\" \""));
                }
            }
            else
            {
	            if(((_TCHAR *)(mdr.pbMDData))[i]=='\r')
        	        printf/*Print*/(_TEXT("\t"));
	            else
        	    {
                	printf/*Print*/( _TEXT("%c"), ((_TCHAR *)(mdr.pbMDData))[i]);
	            }
            }
          }
        }
        break;
    case MULTISZ_METADATA:
        printf/*Print*/(_TEXT("(MULTISZ) ")); //0 should be separator of mulisz strings

#ifndef SHOW_SECURE
        if( fSecure && getenv("MDUTIL_PRINT_SECURE")==NULL)
        { //do not expose the length of secure data
           printf/*Print*/( _TEXT("\"********************\"" ));
            }
        else
#endif
        {
            printf/*Print*/(_TEXT("\""));
            for (i = 0; i < mdr.dwMDDataLen/sizeof(_TCHAR); i++) {
                if(((_TCHAR *)(mdr.pbMDData))[i]==0)
                {
                    if( i+1 == mdr.dwMDDataLen/sizeof(_TCHAR) || (mdr.dwMDDataLen/sizeof(_TCHAR)-i==2 && ((_TCHAR *)(mdr.pbMDData))[i]==0 && ((_TCHAR *)(mdr.pbMDData))[i+1]==0))
                    { //we are at the end print only terminating "
                        printf/*Print*/(_TEXT("\"")); break;
                    }
                    else
                    {
                        printf/*Print*/(_TEXT("\" \""));
                    }
                }
                else
                    printf/*Print*/(_TEXT("%c"),((_TCHAR *)(mdr.pbMDData))[i]);
            }
        }
        break;
    default:
        printf/*Print*/(_TEXT("(UNKNOWN) "));
        break;
    }
    printf/*Print*/(_TEXT("\n"));
}

//**********************************************************************
//**********************************************************************
//IMPLEMENTATION  of CAdmUtil object
//**********************************************************************
//**********************************************************************


//nesting for recursive enumeration
static void nest_print(BYTE bLevel)
{
    for(int i=0; i<=bLevel;i++)
        _tprintf(_T(" "));
}

CAdmUtil::CAdmUtil (const CString & strComputer)
{
    UNREFERENCED_PARM(strComputer);

    EnablePrint(); // by default print error messages


    pIWamAdm=0; //interface pointer to Wam Admin
    pIWamAdm2=0; //interface pointer to Wam Admin2
    pcAdmCom=0;
    m_hmd=0;
    pbDataBuffer=new BYTE [DEFAULTBufferSize];
    wDataBufferSize=DEFAULTBufferSize;

#if UNICODE
    pcAdmCom=0;
#else
    pcAdmCom=new ANSI_smallIMSAdminBase;  //we will access metabase through wrapper class
#endif

    //Open (strComputer);
}

void CAdmUtil::Open (const CString & strComputer)
{
    IClassFactory * pcsfFactory = NULL;
    COSERVERINFO csiMachineName;
    COSERVERINFO *pcsiParam = NULL;
    OLECHAR rgchMachineName[MAX_PATH];


#if UNICODE
   //release previous interface if needed
    if(pcAdmCom!=0)
    {
                if (m_hmd!=0) CloseObject(m_hmd);
                m_hmd=0;
        pcAdmCom->Release();
        pcAdmCom=0;
    }
    //convert to OLECHAR[];
    if (!strComputer.IsEmpty())
    {
           wsprintf( rgchMachineName, L"%s", LPCTSTR(strComputer));

#else
   //release previous interface if needed
    if(pcAdmCom!=0 &&pcAdmCom->m_pcAdmCom!=0)
    {
                if (m_hmd!=0) CloseObject(m_hmd);
                m_hmd=0;
        pcAdmCom->m_pcAdmCom->Release();
        pcAdmCom->m_pcAdmCom=0;
    }
    //convert to OLECHAR[];
    if (!strComputer.IsEmpty())
    {
            wsprintfW( rgchMachineName, L"%S", LPCTSTR(strComputer));
#endif
    }
    //fill the structure for CoGetClassObject
    ZeroMemory( &csiMachineName, sizeof(csiMachineName) );
    // csiMachineName.pAuthInfo = NULL;
    // csiMachineName.dwFlags = 0;
    // csiMachineName.pServerInfoExt = NULL;
    pcsiParam = &csiMachineName;
    csiMachineName.pwszName =  (strComputer.IsEmpty())?NULL:rgchMachineName;

    hresError = CoGetClassObject(GETAdminBaseCLSID(TRUE), CLSCTX_SERVER, pcsiParam,
                            IID_IClassFactory, (void**) &pcsfFactory);

    if (FAILED(hresError))
    {
     Error(_TEXT("CoGetClassObject"));
    }
    else {
        hresError = pcsfFactory->CreateInstance(NULL, IID_IMSAdminBase,
#if UNICODE
                         (void **) &pcAdmCom);
#else
                         (void **) &pcAdmCom->m_pcAdmCom);
#endif
        if (FAILED(hresError)) Error(_TEXT("CreateInstance"));
        pcsfFactory->Release();
    }
}



void CAdmUtil::Close (void)
{
    //release the interface
#if UNICODE
    if(pcAdmCom!=0)
    {
                if (m_hmd!=0) CloseObject(m_hmd);
                m_hmd=0;
        pcAdmCom->Release();
        pcAdmCom=0;
    }

#else
    if(pcAdmCom!=0 &&pcAdmCom->m_pcAdmCom!=0)
    {
                if (m_hmd!=0) CloseObject(m_hmd);
                m_hmd=0;
        pcAdmCom->m_pcAdmCom->Release();
        pcAdmCom->m_pcAdmCom=0;
    }
#endif
}



CAdmUtil::~CAdmUtil (void)
{
    //release the interface
    if(pbDataBuffer!=NULL)
        delete [] pbDataBuffer;
    //the following may fail if class is static
#if UNICODE
    if(pcAdmCom!=0)
    {
                if (m_hmd!=0) CloseObject(m_hmd);
                m_hmd=0;
        pcAdmCom->Release();
        pcAdmCom=0;
    }

#else
    if(pcAdmCom!=0 &&pcAdmCom->m_pcAdmCom!=0)
    {
                if (m_hmd!=0) CloseObject(m_hmd);
                m_hmd=0;
        pcAdmCom->m_pcAdmCom->Release();
        pcAdmCom->m_pcAdmCom=0;
    }
#endif
}

//*******************************************************************************
//with fCreate set to TRUE the node will be created if it doesn't exist

METADATA_HANDLE CAdmUtil::OpenObject(CAdmNode & a_AdmNode, DWORD dwPermission, BOOL fCreate)
{
    METADATA_HANDLE hmdToReturn = 0;

    //try to open the full path
    CString strPathToOpen=a_AdmNode.GetLMNodePath();

    hresError = pcAdmCom->OpenKey(METADATA_MASTER_ROOT_HANDLE,
        IADM_PBYTE LPCTSTR(strPathToOpen), dwPermission, g_dwTIMEOUT_VALUE, &hmdToReturn);

    if (FAILED(hresError)) {
        if ( ((dwPermission==(dwPermission|METADATA_PERMISSION_READ)) || fCreate==FALSE) ||(hresError != RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND))) {
            CString strErrMsg=_TEXT("OpenKey");
            strErrMsg += _TEXT("(\"")+a_AdmNode.GetNodePath()+_TEXT("\")");
            Error(LPCTSTR(strErrMsg));
        }
        else {
            //!!!!!!!!!!!!!Place the dialog to ask to create the path
            // open the service object for write
            METADATA_HANDLE hmdServicePathHandle;
            hresError = pcAdmCom->OpenKey(METADATA_MASTER_ROOT_HANDLE,
                IADM_PBYTE LPCTSTR(a_AdmNode.GetLMServicePath()), METADATA_PERMISSION_WRITE, g_dwTIMEOUT_VALUE, &hmdServicePathHandle);

            if (FAILED(hresError))
            {
                CString strErrMsg=_TEXT("OpenKey");
                strErrMsg += _TEXT("(\"")+a_AdmNode.GetServicePath()+_TEXT(",WRITE")+_TEXT("\")");
                Error(LPCTSTR(strErrMsg));
            }
            else {
                // create the node
                hresError = pcAdmCom->AddKey(hmdServicePathHandle,
                                    IADM_PBYTE LPCTSTR(a_AdmNode.GetRelPathFromInstance()));
                if (FAILED(hresError)) {
                    CString strErrMsg=_TEXT("AddKey");
                    strErrMsg += _TEXT("(\"")+a_AdmNode.GetRelPathFromInstance()+_TEXT("\")");
                    Error(LPCTSTR(strErrMsg));
                }

                //close the service object
                pcAdmCom->CloseKey(hmdServicePathHandle);
                if (FAILED(hresError))  Error(_TEXT("CloseKey"));
                else {
                    // now finally we can open the full path
                    hresError = pcAdmCom->OpenKey(METADATA_MASTER_ROOT_HANDLE,
                        IADM_PBYTE LPCTSTR(strPathToOpen), dwPermission, g_dwTIMEOUT_VALUE, &hmdToReturn);
                    if (FAILED(hresError))
                    {
                        CString strErrMsg=_TEXT("OpenKey");
                        strErrMsg += _TEXT("(\"")+a_AdmNode.GetServicePath()+_TEXT(",WRITE")+_TEXT("\")");
                        Error(LPCTSTR(strErrMsg));
                    }
                }
            }
        }
    }
    Sleep(g_dwDELAY_AFTER_OPEN_VALUE);
    return hmdToReturn;
}

//*******************************************************************************
void CAdmUtil::CloseObject(METADATA_HANDLE hmd)
{
    HRESULT hresStore=hresError;
    hresError=pcAdmCom->CloseKey(hmd);
    if (FAILED(hresError)) Error(_TEXT("CloseData"));
    else    hresError=hresStore; //restore the previous hresError


}
//*******************************************************************************

void CAdmUtil::CreateObject(CAdmNode & a_AdmNode)
{
        OpenObjectTo_hmd(a_AdmNode, METADATA_PERMISSION_WRITE, TRUE/* fCreate*/);
}

#if 0
    METADATA_HANDLE hmdToReturn = 0;

    //try to open the full path
    CString strPathToOpen=a_AdmNode.GetLMNodePath();

    METADATA_HANDLE hmdServicePathHandle;
    hresError = pcAdmCom->OpenKey(METADATA_MASTER_ROOT_HANDLE,
            IADM_PBYTE LPCTSTR(a_AdmNode.GetLMServicePath()), METADATA_PERMISSION_WRITE, g_dwTIMEOUT_VALUE, &hmdServicePathHandle);
    if (FAILED(hresError))
    {
        CString strErrMsg=_TEXT("OpenKey");
        strErrMsg += _TEXT("(\"")+a_AdmNode.GetServicePath()+_TEXT(",WRITE")+_TEXT("\")");
        Error(LPCTSTR(strErrMsg));
    }
    else
    {
        // create the node
        hresError = pcAdmCom->AddKey(hmdServicePathHandle,
                            IADM_PBYTE LPCTSTR(a_AdmNode.GetRelPathFromInstance()));
        if (FAILED(hresError)) {
            CString strErrMsg=_TEXT("AddKey");
            strErrMsg += _TEXT("(\"")+a_AdmNode.GetRelPathFromInstance()+_TEXT("\")");
            Error(LPCTSTR(strErrMsg));
        }
        //close the service object
        CloseObject(hmdServicePathHandle);
    }
#endif


// This function enables to reuse open handles in order to improve performance
// !!it supports only one acticve handle (otherwise the processing may fail)

METADATA_HANDLE CAdmUtil::OpenObjectTo_hmd(CAdmNode & a_AdmNode, DWORD dwPermission, BOOL fCreate)
{
        CString strPathToOpen=a_AdmNode.GetLMNodePath();
        if(m_hmd!=0 && strPathToOpen.CompareNoCase(m_strNodePath)==0 && m_dwPermissionOfhmd == dwPermission )
        {  //we can reuse already opened node

        }
        else
        {
                if(m_hmd != 0)
                {
                        CloseObject(m_hmd);
                        m_hmd=0;
                }
                m_hmd = OpenObject(a_AdmNode, dwPermission, fCreate);
                m_dwPermissionOfhmd = dwPermission;
                m_strNodePath = strPathToOpen;
        }
    return m_hmd;
}

void CAdmUtil::CloseObject_hmd(void)
{
	if(m_hmd != 0)
	{
		CloseObject(m_hmd);
		m_hmd=0;
	}
}
//*******************************************************************************

void CAdmUtil::GetProperty(CAdmNode& a_AdmNode, CAdmProp& a_AdmProp)
{
    DWORD dwRequiredDataLen=0;
    WORD wDataBufferSize=0;
    PBYTE DataBuffer=0;

    DWORD dwPropertyCode=a_AdmProp.GetIdentifier();

    if(dwPropertyCode==0)   Error(_TEXT("Property name not found"));
    else
    {
        //MD_SET_DATA_RECORD(&a_AdmProp.mdr,
        //                 0,
        //                 METADATA_INHERIT | METADATA_PARTIAL_PATH,
        //                 0,
        //                 0,
        //                 wDataBufferSize,
        //                 pbDataBuffer);

        //a_AdmProp.SetIdentifier(dwPropertyCode); //has to be set beforehand
        a_AdmProp.SetDataType(0);
        a_AdmProp.SetUserType(0);
        a_AdmProp.SetAttrib(0);

        METADATA_HANDLE hmd = OpenObjectTo_hmd(a_AdmNode,
                                         METADATA_PERMISSION_READ);
        if (SUCCEEDED(hresError))
        {
            hresError = pcAdmCom->GetData(hmd,
                IADM_PBYTE  _TEXT(""),
        &a_AdmProp.mdr, &dwRequiredDataLen);
            if (FAILED(hresError)) {
                if (hresError == RETURNCODETOHRESULT(ERROR_INSUFFICIENT_BUFFER)) {
    ///////////             delete []pbDataBuffer;
                    pbDataBuffer=new BYTE[dwRequiredDataLen];
                    if (pbDataBuffer==0) {
                        hresError = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                        Error(_TEXT("Buffer resize failed"));
                    }
                    else {
                        a_AdmProp.mdr.dwMDDataLen = dwRequiredDataLen;
                        a_AdmProp.mdr.pbMDData = pbDataBuffer;
                        hresError = pcAdmCom->GetData(hmd,
                        IADM_PBYTE _TEXT(""), &a_AdmProp.mdr, &dwRequiredDataLen);
                        if (FAILED(hresError)) Error(_TEXT("GetData"));
                    }
                }
                else
                     Error(_TEXT("GetData"));;

            }
            //CloseObject (hmd);  we might reuse it
        }

    }
}

//if lplpszPropertyValue[1]==NULL it means there is only one value (it is not a multistring)


void CAdmUtil::SetProperty(CAdmNode& a_AdmNode, CAdmProp& a_AdmProp)
{
    METADATA_HANDLE hmd = OpenObjectTo_hmd(a_AdmNode,
                                         METADATA_PERMISSION_WRITE,TRUE/*create node if doesn't exist*/);
    if (SUCCEEDED(hresError))
    {
        SetProperty(&a_AdmProp.mdr,hmd);
        //CloseObject(hmd); we will reuse it
    }
}


void CAdmUtil::SetProperty(PMETADATA_RECORD a_pmdrData,METADATA_HANDLE a_hmd)
{
    hresError = pcAdmCom->SetData(a_hmd,
                            IADM_PBYTE _TEXT(""), a_pmdrData);
    if (FAILED(hresError))  Error(_TEXT("SetData"));

}

void CAdmUtil::SaveData(void)
{
        if (m_hmd!=0)
        {  //we have to close reusable handle in order to save successfully
                CloseObject(m_hmd);
                m_hmd=0;
        }
    hresError = pcAdmCom->SaveData();
        if (FAILED(hresError)) Error(_TEXT("SaveData"));
}

//****************************************************************************
//DELETE PROPERTY

void CAdmUtil::DeleteProperty(CAdmNode& a_AdmNode, CAdmProp& a_AdmProp)
{
    METADATA_HANDLE hmd = OpenObjectTo_hmd(a_AdmNode,
                                         METADATA_PERMISSION_WRITE,TRUE/*create node if doesn't exist*/);
    if (SUCCEEDED(hresError))
    {
        DeleteProperty(&a_AdmProp.mdr,hmd);
        // CloseObject(hmd); we will reuse it
    }
}


void CAdmUtil::DeleteProperty(PMETADATA_RECORD a_pmdrData,METADATA_HANDLE a_hmd)
{
    hresError = pcAdmCom->DeleteData(a_hmd,
                IADM_PBYTE  _TEXT(""), a_pmdrData->dwMDIdentifier,ALL_METADATA);
    if (FAILED(hresError))  Error(_TEXT("DeleteData"));

}

//****************************************************************************
//DELETE OBJECT

void CAdmUtil::DeleteObject(CAdmNode& a_AdmNode, CAdmProp& a_AdmProp)
{
    CAdmNode NodeToOpen = a_AdmNode.GetParentNodePath();
    METADATA_HANDLE hmd = OpenObjectTo_hmd(NodeToOpen,
                                         METADATA_PERMISSION_WRITE,FALSE/*create node if doesn't exist*/);

    UNREFERENCED_PARM(a_AdmProp);

    if (SUCCEEDED(hresError))
    {
        CString strToDelete=a_AdmNode.GetCurrentNodeName();
        if(strToDelete==_TEXT(""))
            strToDelete=_TEXT("//"); //empty name has to be wrapped with '/'
        DeleteObject(hmd,strToDelete);
        //CloseObject(hmd); we will reuse it
    }
}

void CAdmUtil::DeleteObject(METADATA_HANDLE a_hmd, CString& a_strObjectName)
{
    hresError = pcAdmCom->DeleteKey(a_hmd, IADM_PBYTE LPCTSTR(a_strObjectName));
    if (FAILED(hresError))  Error(_TEXT("DeleteKey"));

}






void CAdmUtil::EnumPropertiesAndPrint(CAdmNode& a_AdmNode,
                                      CAdmProp a_AdmProp, //cannot be passed by reference
                                      BYTE bRecurLevel,
                                      METADATA_HANDLE a_hmd,
                                      CString & a_strRelPath)
{
    CAdmProp mdrData=a_AdmProp;
    DWORD dwRequiredDataLen=0;
    PBYTE DataBuffer=0;
    METADATA_HANDLE hmdMain;

    if(a_hmd==0) //if handle was not passed then open one
    {
        hmdMain = OpenObjectTo_hmd(a_AdmNode, METADATA_PERMISSION_READ);
        if (FAILED(hresError))
                return;
    }
    else
        hmdMain = a_hmd;

    for (int j=0;;j++) { //cycle for properties
        MD_SET_DATA_RECORD(&mdrData.mdr,
                       0,
                       a_AdmProp.mdr.dwMDAttributes,
                       a_AdmProp.mdr.dwMDUserType,
                       a_AdmProp.mdr.dwMDDataType,
                       dwRequiredDataLen,
                       pbDataBuffer);

        hresError = pcAdmCom->EnumData(hmdMain,
            IADM_PBYTE LPCTSTR(a_strRelPath), &mdrData.mdr,j, &dwRequiredDataLen);
        if (FAILED(hresError))
        {
            if(hresError == RETURNCODETOHRESULT(ERROR_NO_MORE_ITEMS))
            {
                hresError=0; //NO MORE ITEMS IS NOT ERROR FOR US
                break; //end of items
            }
            else if (hresError == RETURNCODETOHRESULT(ERROR_INSUFFICIENT_BUFFER))
            {
                delete pbDataBuffer;
                pbDataBuffer=new BYTE[dwRequiredDataLen];
                if (pbDataBuffer==0)
                {
                    hresError = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                    Error(_TEXT("Buffer resize failed"));
                }
                else
                {
                    mdrData.mdr.dwMDDataLen = dwRequiredDataLen;
                    mdrData.mdr.pbMDData = pbDataBuffer;
                    hresError = pcAdmCom->EnumData(hmdMain,
                            IADM_PBYTE LPCTSTR(a_strRelPath), &mdrData.mdr,j, &dwRequiredDataLen);
                    if (FAILED(hresError)) Error(_TEXT("GetData"));
                }
            }
            else
                Error(_TEXT("EnumData"));
        }
        //else
          //  Error(_TEXT("EnumData"));

        if(SUCCEEDED(hresError)) //we  enumerated successfully, let's print
        {
            nest_print(bRecurLevel+1);

            mdrData.PrintProperty();
        }
        else
        {
            break;
        }
    }  //end for j   - cycle for properties
    //if(a_hmd==0)
    //    CloseObject(hmdMain); we will reuse it //close only if we opened at the beginning
}


void CAdmUtil::EnumAndPrint(CAdmNode&   a_AdmNode,
                            CAdmProp&   a_AdmProp,
                            BOOL        a_fRecursive,
                            BYTE        a_bRecurLevel,
                            METADATA_HANDLE a_hmd,
                            CString&    a_strRelPath)
{
    _TCHAR NameBuf[METADATA_MAX_NAME_LEN];

    METADATA_HANDLE hmdMain;

    if(a_hmd==0) //if handle was not passed then open one
    {
        hmdMain = OpenObjectTo_hmd(a_AdmNode, METADATA_PERMISSION_READ);
        if (FAILED(hresError))
                return;
    }
    else
        hmdMain = a_hmd;


    //printf("[RELATIVE PATH : \"%s\"]\n",LPCTSTR(a_strRelPath));
    //print the properties of the node
    EnumPropertiesAndPrint(a_AdmNode,a_AdmProp,a_bRecurLevel,hmdMain,a_strRelPath);


    for (int i=0; ;i++) {  //cycle for subnodes
        hresError = pcAdmCom->EnumKeys(hmdMain,
            IADM_PBYTE LPCTSTR(a_strRelPath), IADM_PBYTE NameBuf, i);
        if(FAILED(hresError)) {
            if(hresError == RETURNCODETOHRESULT(ERROR_NO_MORE_ITEMS)) {
                hresError=0; //NO MORE ITEMS IS NOT ERROR FOR US
                break; //end of cycle
            }
            else
            {
                Error(_TEXT("EnumKeys"));
                break;
            }

        }
        else {

          //process and print node info

            CString strNewRelPath( a_strRelPath );
            if(NameBuf[0]==0) //empty name
                strNewRelPath+=_TEXT("//"); //add two slashes -> this is required by metabase
            else
            {
                UINT  nLen;
                //if(strNewRelPath.GetLength()>=1 && strNewRelPath.Right(1)==_TEXT("/")) {
                if( (nLen=strNewRelPath.GetLength())>=1 && (strNewRelPath.GetAt(nLen-1)=='/') ) {
                }
                else {
                    strNewRelPath+=_TEXT("/"); //add only if it is not at the end of string.
                }
                strNewRelPath+=NameBuf;
            }
            CString strStringToPrint( a_AdmNode.GetNodePath() );
            UINT  nLen = strStringToPrint.GetLength();

            //if (strStringToPrint.Right(2)==_TEXT("//"))
            if ((nLen > 2) && strStringToPrint.GetAt(nLen-1)=='/'
                           && strStringToPrint.GetAt(nLen-2)=='/' )
            {
                strStringToPrint += strNewRelPath.Mid(1); //strip first '/'
            }
            else
            {
                strStringToPrint += strNewRelPath;
            }
            LPCTSTR lpszStr=LPCTSTR(strStringToPrint);
            this->Print(_TEXT("[%s]\n"),lpszStr );

            if(a_fRecursive)
            {
                EnumAndPrint(a_AdmNode,a_AdmProp ,a_fRecursive, a_bRecurLevel+1, hmdMain,strNewRelPath);
            }
            else
            {  //no recursion

            }
        }
    } //end for i  - cycle for nodes
    //if(a_hmd==0)
    //    CloseObject(hmdMain); //we will reuse it //close only if we opened at the beginning
}


//****************************************************************
//  the following function is somehow complicated because
//  metadata copy function doesn't support copying of one object to another place with different name
//  e.g. ComAdmCopyKey will copy /W3SVC/1//scripts/oldscripts1 /W3SVC/1//oldscripts2
//                          will create /W3SVC/1//oldscripts2/oldscripts1
//

void CAdmUtil::CopyObject(CAdmNode& a_AdmNode,
                          CAdmNode& a_AdmNodeDst)
{
    CString strSrcPath=a_AdmNode.GetNodePath();
    CString strDstPath=a_AdmNodeDst.GetNodePath();


    CString strCommonPath; //=_TEXT("");
    CString strRelSrcPath=strSrcPath; //relative to common path
    CString strRelDstPath=strDstPath; //relative to common path


    //we cannot open Source Path for reading because if will diable wrining to all parent nodes
    //e.g. copy /W3SVC/1//scripts/oldscripts /W3SVC/1//oldscripts would fail
    //It is necessary to find common partial path and open metabase object for that common partial path for READ/WRITE

    //!!!!!!!!!!!!!!!!! assume that paths are not case sensitive

    int MinLength=strSrcPath.GetLength();
    int i;
    //find shorter from strings
    if(strDstPath.GetLength() < MinLength)
            MinLength=strDstPath.GetLength();
    for(i=0; i<MinLength; i++)
    {
        if(strSrcPath.GetAt(i)!=strDstPath.GetAt(i) )
            // common path cannot be any longer;
            break;
    }
    //  now find the previous '/' and all before '/' is the common path
    for(i=i-1; i>=0;i--)
    {
        if(strSrcPath.GetAt(i)==_T('/'))
        {
            strCommonPath=strSrcPath.Left(i+1);//take the trailing '/' with you
            strRelSrcPath=strSrcPath.Mid(i+1);
            strRelDstPath=strDstPath.Mid(i+1);
            break;
        }
    }




    METADATA_HANDLE hmdCommon=0;

    CAdmNode CommonNode;
    CommonNode.SetPath(strCommonPath);


    hmdCommon = OpenObjectTo_hmd(CommonNode, METADATA_PERMISSION_READ+METADATA_PERMISSION_WRITE);
    if (FAILED(hresError))
            return;

// Altered by Adam Stone on 30-Jan-97  The following code was changed to comply with
// the changes to the metabase ComMDCopyKey function.
    // Copy the metadata to the destination
    hresError = pcAdmCom->CopyKey (hmdCommon,
                                    IADM_PBYTE LPCTSTR(strRelSrcPath),
                                    hmdCommon,
                                    IADM_PBYTE LPCTSTR(strRelDstPath),
                                    FALSE, // Do NOT overwrite
                                    TRUE); // Copy do NOT move

    if (FAILED(hresError)) // if the node already exists, it is error
    {
        CString strErrMsg=_TEXT("CopyKey");
        strErrMsg += _TEXT("(\"")+a_AdmNodeDst.GetRelPathFromInstance()+_TEXT("\")");
        Error(LPCTSTR(strErrMsg));
    }

// All of the commented out code has become unneccessary as of 30-Jan-97  because of a change
// in the metabase.  ComMDCopyKey now copies to the destination, overwriting if
// requested.  It used to copy to a child of the destination object.
/*  // create the node
*   hresError = pcAdmCom->AddKey(hmdCommon,
*                       IADM_PBYTE LPCTSTR(strRelDstPath));
*   if (FAILED(hresError)) { //if the node exists, it is error)
*       CString strErrMsg=_TEXT("AddKey");
*       strErrMsg += _TEXT("(\"")+a_AdmNodeDst.GetRelPathFromInstance()+_TEXT("\")");
*       Error(LPCTSTR(strErrMsg));
*   }
*   else //no error when creating new node
*   {
*       for (i=0; ;i++) {  //cycle for subnodes
*           hresError = pcAdmCom->EnumKeys(hmdCommon,
*               IADM_PBYTE LPCTSTR(strRelSrcPath), (PBYTE)NameBuf, i);
*           if(FAILED(hresError)) {
*               if(hresError == RETURNCODETOHRESULT(ERROR_NO_MORE_ITEMS)) {
*                   hresError=0; //this is not an error
*                   break; //end of cycle
*               }
*               else
*               {
*                   Error(_TEXT("EnumKeys"));
*                   break;
*               }
*
*           }
*           else {
*
*             //process and copy node child node
*
*               CString strNewRelSrcPath=strRelSrcPath;
*               if(NameBuf[0]==0) //empty name
*                   strNewRelSrcPath+=_TEXT("//"); //add two slashes -> this is required by metabase
*               else
*               {   if(strNewRelSrcPath.GetLength()>=1 && strNewRelSrcPath.Right(1)==_TEXT("/")) {
*                   }
*                   else {
*                       strNewRelSrcPath+=_TEXT("/"); //add only if it is not at the end of string.
*                   }
*                   strNewRelSrcPath+=NameBuf;
*               }
*               hresError = pcAdmCom->CopyKey(
*                   hmdCommon, (PBYTE) LPCTSTR(strNewRelSrcPath),
*                   hmdCommon, (PBYTE) LPCTSTR(strRelDstPath),TRUE,TRUE);
*               if(FAILED(hresError)) {
*                   Error(_TEXT("CopyKey"));
*               }
*
*
*           }
*       } //end for i  - cycle for nodes
*
*
*       //WE COPIED ALL NODES, COPY PARAMETERS NOW
*       CAdmProp mdrData;
*       DWORD dwRequiredDataLen=0;
*       PBYTE DataBuffer=0;
*
*
*
*       for (int j=0;;j++) { //cycle for properties
*           MD_SET_DATA_RECORD(&mdrData.mdr,
*                          0,
*                          0,
*                          0,
*                          0,
*                          dwRequiredDataLen,
*                          pbDataBuffer);
*
*           hresError = pcAdmCom->EnumData(hmdCommon,
*                           (PBYTE) LPCTSTR(strRelSrcPath)
*                           , &mdrData.mdr,j, &dwRequiredDataLen);
*           if (FAILED(hresError))
*           {
*               if(hresError == RETURNCODETOHRESULT(ERROR_NO_MORE_ITEMS))
*               {
*                   hresError=0; //NO MORE ITEMS IS NOT ERROR FOR US
*                   break; //end of items
*               }
*               else if (hresError == RETURNCODETOHRESULT(ERROR_INSUFFICIENT_BUFFER))
*               {
///////////                 delete pbDataBuffer;
*                   pbDataBuffer=new BYTE[dwRequiredDataLen];
*                   if (pbDataBuffer==0)
*                   {
*                       hresError = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
*                       Error(_TEXT("Buffer resize failed"));
*                   }
*                   else
*                   {
*                       mdrData.mdr.dwMDDataLen = dwRequiredDataLen;
*                       mdrData.mdr.pbMDData = pbDataBuffer;
*                       hresError = pcAdmCom->EnumData(hmdCommon,
*                           (PBYTE) LPCTSTR(strRelSrcPath)
*                           , &mdrData.mdr,j, &dwRequiredDataLen);
*                       if (FAILED(hresError)) Error(_TEXT("GetData"));
*                   }
*               }
*               else
*                   Error(_TEXT("EnumData"));
*           }
*           else
*               Error(_TEXT("EnumData"));
*
*           if(SUCCEEDED(hresError)) //we  enumerated successfully, let's print
*           {
*               hresError = pcAdmCom->SetData(hmdCommon, (PBYTE) LPCTSTR(strRelDstPath),&mdrData.mdr);
*               if (FAILED(hresError))  Error(_TEXT("SetData"));
*           }
*           else
*           {
*               break;
*           }
*       }  //end for j   - cycle for properties
*   }
*/


    //CloseObject(hmdCommon); //we will reuse handle //close only if we opened at the beginning

}

void CAdmUtil::RenameObject(CAdmNode& a_AdmNode,
                          CAdmNode& a_AdmNodeDst)
{
    CString strSrcPath=a_AdmNode.GetNodePath();
    CString strDstPath=a_AdmNodeDst.GetNodePath();


    CString strCommonPath=_TEXT("");
    CString strRelSrcPath=strSrcPath; //relative to common path
    CString strRelDstPath=strDstPath; //relative to common path


    //we cannot open Source Path for reading because if will diable wrining to all parent nodes
    //e.g. copy /W3SVC/1//scripts/oldscripts /W3SVC/1//oldscripts would fail
    //It is necessary to find common partial path and open metabase object for that common partial path for READ/WRITE

    //!!!!!!!!!!!!!!!!! assume that paths are not case sensitive

    int MinLength=strSrcPath.GetLength();
    int i;
    //find shorter from strings
    if(strDstPath.GetLength() < MinLength)
            MinLength=strDstPath.GetLength();
    for(i=0; i<MinLength; i++)
    {
        if(strSrcPath.GetAt(i)!=strDstPath.GetAt(i) )
            // common path cannot be any longer;
            break;
    }
    //  now find the previous '/' and all before '/' is the common path
    for(i=i-1; i>=0;i--)
    {
        if(strSrcPath.GetAt(i)==_T('/'))
        {
            strCommonPath=strSrcPath.Left(i+1);//take the trailing '/' with you
            strRelSrcPath=strSrcPath.Mid(i); // keep the trailing '/' in case it's "//"
            strRelDstPath=strDstPath.Mid(i+1);
            break;
        }
    }




    METADATA_HANDLE hmdCommon=0;

    CAdmNode CommonNode;
    CommonNode.SetPath(strCommonPath);


    hmdCommon = OpenObjectTo_hmd(CommonNode, METADATA_PERMISSION_READ+METADATA_PERMISSION_WRITE);
    if (FAILED(hresError))
            return;

    hresError = pcAdmCom->RenameKey (hmdCommon,
                                    IADM_PBYTE LPCTSTR(strRelSrcPath),
                                    IADM_PBYTE LPCTSTR(strRelDstPath)
                                   );


    if (FAILED(hresError)) // if the node already exists, it is error
    {
        CString strErrMsg=_TEXT("RenameKey");
        strErrMsg += _TEXT("(\"")+a_AdmNodeDst.GetRelPathFromInstance()+_TEXT("\")");
        Error(LPCTSTR(strErrMsg));
    }

    //CloseObject(hmdCommon); //we will reuse it//close only if we opened at the beginning

}



//**********************************************************************
//IMPLEMENTATION  of AdmUtil
//**********************************************************************


void CAdmUtil::Run(CString& strCommand, CAdmNode& a_AdmNode, CAdmProp& a_AdmProp, CAdmNode& a_AdmDstNode,
                LPCTSTR *a_lplpszPropValue,
                DWORD *a_lpdwPropValueLength,
                WORD wPropValueCount)

{

    DWORD dwCommandCode=0;

    dwCommandCode = tCommandNameTable::MapNameToCode(strCommand);

    switch(dwCommandCode)
    {

    case CMD_SAVE:
    SaveData();
    if (FAILED(hresError)) {}
    else{
        printf/*Print*/(_TEXT("saved\n"));
    }
    break;

    case CMD_CREATE:
    {
        if (a_AdmNode.GetProperty()!=_TEXT("")) //property name cannot be used
            Error(_TEXT("property name for CREATE not supported"));
    //    else if (a_AdmNode.GetService()==_TEXT("")) //property name cannot be used
    //        Error(_TEXT("service name for CREATE is missing"));
        else
        {
            CreateObject(a_AdmNode);
            if( SUCCEEDED(QueryLastHresError()))
            {
              //  SaveData(); //end of transaction
                if( SUCCEEDED(QueryLastHresError()))
                {
                    printf/*Print*/(_TEXT("created \"%s\"\n"), LPCTSTR(a_AdmNode.GetNodePath()));
                }
            }
        }
    }
    break;
    case CMD_SET:
    {
        CAdmProp AdmPropToGet;
        AdmPropToGet = a_AdmProp;
        AdmPropToGet.SetAttrib(0);
        AdmPropToGet.SetUserType(0);
        AdmPropToGet.SetDataType(0);

        DisablePrint(); //do not print any error message
        GetProperty(a_AdmNode, AdmPropToGet);
        EnablePrint(); //continue printing error messages

        //*************************SETTING ATTRIB, DATATYPE, USERTYPE
        // if the parameter exists in the metabase, then existing ATTRIB, DATATYPE, USERTYPE
        //              will be used , but this can be overwritten from a_AdmProp
        // if the parameter doesn't exists in the metabase, then default ATTRIB, DATATYPE, USERTYPE
        //              (see tables.cpp) will be used , but this can be overwritten from a_AdmProp

        if(FAILED(QueryLastHresError()))
        {  //store the value to be set into a_AdmProp
                //FIND DEFAULT SETTINGS
                DWORD dwPropCode=a_AdmProp.GetIdentifier();
                tPropertyNameTable * PropNameTableRecord = tPropertyNameTable::FindRecord(dwPropCode);
                if (PropNameTableRecord!=NULL)
                {
                        AdmPropToGet.SetIdentifier(PropNameTableRecord->dwCode);
                        AdmPropToGet.SetAttrib(PropNameTableRecord->dwDefAttributes) ;
                        AdmPropToGet.SetUserType(PropNameTableRecord->dwDefUserType);
                        AdmPropToGet.SetDataType(PropNameTableRecord->dwDefDataType);
                }
        }
        else
        {  //reuse the existing settings
                if( a_AdmProp.GetDataType()!=0 &&(a_AdmProp.GetDataType()!= AdmPropToGet.GetDataType()))
                {
                        Error(_TEXT("Cannot redefine data type from %s to %s"),
                                tDataTypeNameTable::MapCodeToName(AdmPropToGet.GetDataType()),
                                tDataTypeNameTable::MapCodeToName(a_AdmProp.GetDataType()));
                        break;
                }
        }
        // use settings passed to the function if set
        if(!a_AdmProp.IsSetDataType())
                a_AdmProp.SetDataType(AdmPropToGet.GetDataType()); //reuse existing data type
        if(!a_AdmProp.IsSetUserType())
                a_AdmProp.SetUserType(AdmPropToGet.GetUserType()); //reuse existing user type
        if(!a_AdmProp.IsSetAttrib())
                a_AdmProp.SetAttrib(AdmPropToGet.GetAttrib()); //reuse exixting attrib




        if(a_AdmProp.SetValueByDataType( (LPCTSTR *)a_lplpszPropValue, a_lpdwPropValueLength, wPropValueCount)==0)
             Error(_TEXT("SetValueByDataType failed"));
        else
        {
           // if (a_AdmNode.GetService()==_TEXT("")) //property name cannot be used
           //     Error(_TEXT("service name for SET is missing"));
           // else
            if (a_AdmNode.GetProperty()!=_TEXT(""))
            {
                SetProperty(a_AdmNode, a_AdmProp);
                if( SUCCEEDED(QueryLastHresError()))
                {
                    //SaveData(); //end of transaction
                    if( SUCCEEDED(QueryLastHresError()))
                    {
                        GetProperty(a_AdmNode, a_AdmProp);
                        if(SUCCEEDED(QueryLastHresError()))
                            a_AdmProp.PrintProperty();
                    }
                }
            }else
                Error(_TEXT("property name missing for SET command"));
        }
        break;
    }
    case CMD_DELETE:

        //if (a_AdmNode.GetService()==_TEXT("")) //property name cannot be used
        //    Error(_TEXT("service name for DELETE is missing"));
        if (IsServiceName(a_AdmNode.GetService()) && a_AdmNode.GetInstance()==_TEXT("") && a_AdmNode.GetIPath()==_TEXT("") && a_AdmNode.GetProperty()==_TEXT(""))
            Error(_TEXT("cannot delete service"));
        else if (a_AdmNode.GetInstance()==_TEXT("1") && a_AdmNode.GetIPath()==_TEXT("") && a_AdmNode.GetProperty()==_TEXT("")) //property name cannot be used
            Error(_TEXT("cannot delete 1. instance"));
        else if (a_AdmNode.GetProperty()!=_TEXT(""))
        {
            DeleteProperty(a_AdmNode, a_AdmProp);
        }
        else
        {
            DeleteObject(a_AdmNode, a_AdmProp);
        }
            //if( SUCCEEDED(QueryLastHresError()))
            //{
            //  GetProperty(a_AdmNode, a_AdmProp);
            //  if(SUCCEEDED(QueryLastHresError()))
            //      a_AdmProp.PrintProperty();
            //}
        if(SUCCEEDED(QueryLastHresError()))
        {
            //SaveData(); //end of transaction
            if( SUCCEEDED(QueryLastHresError()))
            {
                printf/*Print*/(_TEXT("deleted \"%s"), LPCTSTR(a_AdmNode.GetNodePath()));
                if(a_AdmNode.GetProperty()!=_TEXT(""))
                    printf/*Print*/(_TEXT("%s"),LPCTSTR(((a_AdmNode.GetNodePath().Right(1)==_TEXT("/"))?_TEXT(""):_TEXT("/"))+
                                    a_AdmNode.GetProperty()));
                printf/*Print*/(_TEXT("\"\n"));
            }

        }
        break;

    case CMD_GET:
        //    if (a_AdmNode.GetService()==_TEXT("")) //property name cannot be used
        //        Error(_TEXT("service name for GET is missing"));

        //    else
            if (a_AdmNode.GetProperty()!=_TEXT(""))
            {
                GetProperty(a_AdmNode, a_AdmProp);
                if(SUCCEEDED(QueryLastHresError()))
                    a_AdmProp.PrintProperty();
            }
            else
            {
                CString strT("");
                EnumPropertiesAndPrint(a_AdmNode, a_AdmProp, 0 , 0, strT);
            }
        break;
    case CMD_COPY:

            if(a_AdmDstNode.GetNodePath()==_TEXT(""))
                Error(_TEXT("destination path is missing"));
            else if(a_AdmNode.GetProperty()!=_TEXT("") || a_AdmDstNode.GetProperty()!=_TEXT(""))
                Error(_TEXT("copying of properties (parameters) not supported\n"));
            //else if (a_AdmNode.GetService()==_TEXT("")) //property name cannot be used
            //    Error(_TEXT("service name in source path for COPY is missing"));
            //else if (a_AdmDstNode.GetService()==_TEXT("")) //property name cannot be used
            //    Error(_TEXT("service name for destination path COPY is missing"));
            //else if (a_AdmNode.GetInstance()==_TEXT("")) //property name cannot be used
            //    Error(_TEXT("instance number in source path for COPY is missing"));
            //else if (a_AdmDstNode.GetInstance()==_TEXT("")) //property name cannot be used
            //    Error(_TEXT("instance number in destination path for COPY is missing"));

            else
            {
                CopyObject(a_AdmNode,a_AdmDstNode);
                if(SUCCEEDED(QueryLastHresError()))
                {
                    //SaveData(); //end of transaction
                    if( SUCCEEDED(QueryLastHresError()))
                    {

                        printf/*Print*/(_TEXT("copied from %s to %s\n"), LPCTSTR(a_AdmNode.GetNodePath()),LPCTSTR(a_AdmDstNode.GetNodePath()));
                    }
                }
                break;
            }
        break;
    case CMD_RENAME:
            if(a_AdmDstNode.GetNodePath()==_TEXT(""))
                Error(_TEXT("destination path is missing"));
            else if(a_AdmNode.GetProperty()!=_TEXT("") || a_AdmDstNode.GetProperty()!=_TEXT(""))
                Error(_TEXT("renaming of properties (parameters) not supported"));
            //else if (a_AdmNode.GetService()==_TEXT("")) //property name cannot be used
            //    Error(_TEXT("service name in source path for RENAME is missing"));
            //else if (a_AdmDstNode.GetService()==_TEXT(""))
            //    Error(_TEXT("service name for destination path RENAME is missing"));
            //else if (a_AdmNode.GetInstance()==_TEXT(""))
            //    Error(_TEXT("instance number in source path for RENAME is missing"));
            //else if (a_AdmDstNode.GetInstance()==_TEXT(""))
            //   Error(_TEXT("instance number in destination path for RENAME is missing"));
            else if (a_AdmNode.GetInstance()==_TEXT("1") && a_AdmNode.GetIPath()==_TEXT(""))
                Error(_TEXT("cannot rename 1. instance"));
            else if (a_AdmNode.GetRelPathFromService().CompareNoCase(a_AdmDstNode.GetRelPathFromService())==0)
                Error(_TEXT("cannot rename to itself"));
            else
            {  //check if one of the paths is not the child of the other one
                CString str1=a_AdmNode.GetRelPathFromService();
                CString str2=a_AdmDstNode.GetRelPathFromService();

                CString strCommonPath=FindCommonPath(str1,str2);

                if(strCommonPath.CompareNoCase(str1)==0 ||
                        strCommonPath.CompareNoCase(str1)==0)
                    Error(_TEXT("cannot rename - one path is the child of the other"));
                else
                { //O.K.
                    //CopyObject(a_AdmNode,a_AdmDstNode);
                    //if(SUCCEEDED(QueryLastHresError()))
                    //{
                    //    DeleteObject(a_AdmNode,a_AdmProp);
                    //    if(SUCCEEDED(QueryLastHresError()))
                    //    {
                    //       // SaveData(); //end of transaction
                    //        if( SUCCEEDED(QueryLastHresError()))
                    //        {
                    //            printf/*Print*/("renamed from %s to %s\n", LPCTSTR(a_AdmNode.GetNodePath()),LPCTSTR(a_AdmDstNode.GetNodePath()));
                    //        }
                    //    }
                    // }
                    RenameObject(a_AdmNode,a_AdmDstNode);
                    if(SUCCEEDED(QueryLastHresError()))
                    {
                      // SaveData(); //end of transaction
                       if( SUCCEEDED(QueryLastHresError()))
                       {

                           printf/*Print*/(_TEXT("renamed from %s to %s\n"), LPCTSTR(a_AdmNode.GetNodePath()),LPCTSTR(a_AdmDstNode.GetNodePath()));
                       }
                    }
                }
            }

            break;

    case CMD_ENUM:
            {
                CString strT("");

                EnumAndPrint(a_AdmNode, a_AdmProp, FALSE/*no recursion*/, 0, 0, strT);
            }
            break;

    case CMD_ENUM_ALL:
            {
                CString strT("");

                EnumAndPrint(a_AdmNode, a_AdmProp,TRUE/*no recursion*/, 0, 0, strT);
            }
            break;
    case CMD_APPCREATEINPROC:
            AppCreateInProc(LPCTSTR(a_AdmNode.GetLMNodePath()),a_AdmNode.GetComputer());
            break;

    case CMD_APPCREATEOUTPOOL:
            AppCreateOutPool(LPCTSTR(a_AdmNode.GetLMNodePath()),a_AdmNode.GetComputer());
            break;

    case CMD_APPDELETE:
            AppDelete(LPCTSTR(a_AdmNode.GetLMNodePath()),a_AdmNode.GetComputer());
            break;

    case CMD_APPRENAME:
            AppRename(a_AdmNode,a_AdmDstNode,a_AdmNode.GetComputer());
            break;

    case CMD_APPCREATEOUTPROC:
            AppCreateOutProc(LPCTSTR(a_AdmNode.GetLMNodePath()),a_AdmNode.GetComputer());
            break;

    case CMD_APPGETSTATUS:
            AppGetStatus(LPCTSTR(a_AdmNode.GetLMNodePath()),a_AdmNode.GetComputer());
            break;

    case CMD_APPUNLOAD:
            AppUnLoad(LPCTSTR(a_AdmNode.GetLMNodePath()),a_AdmNode.GetComputer());
            break;


    default:
        printf/*Print*/(_TEXT("Command not recognized: %s\n"),strCommand.operator LPCTSTR());
        hresError=RETURNCODETOHRESULT(ERROR_INVALID_PARAMETER);
        return ;

    }
    return;
}


//if hresError is 0, we will set it to invalid parameter

void CAdmUtil::Error(const _TCHAR * format,...)
{
   _TCHAR buffer[2000];
   va_list marker;
   va_start( marker, format );     /* Initialize variable arguments. */

   int x=_vstprintf(buffer, format, marker);

   va_end( marker );              /* Reset variable arguments.      */
    if(hresError==0)
    {
        if(fPrint)
    {
            _ftprintf(stderr,_TEXT("Error: %s\n"),buffer);
    }

        hresError=RETURNCODETOHRESULT(ERROR_INVALID_PARAMETER); //little trick
    }
    else
    {


        if(fPrint)
        {
            _ftprintf(stderr,_TEXT("Error: %s - HRES(0x%x)   %s\n"), buffer, hresError/*, ConvertHresToDword(hresError),ConvertHresToDword(hresError)*/,ConvertReturnCodeToString(ConvertHresToDword(hresError)));
	    if(getenv("MDUTIL_ASCENT_LOG")!=NULL)
	    {
		//we got to do some ascent logging

		FILE *fpAscent;
		fpAscent=fopen("Ascent.log","a");
		if (fpAscent)
		{
			//new variation description
			fprintf(fpAscent,"Variation1: METADATA ACCESS (by mdutil.exe)\n");
			fprintf(fpAscent,"Explain: READ OR WRITE OPERATION TO METADATA \n");

			//variation summary
			fprintf(fpAscent,"Attempted: 1 \n");
			fprintf(fpAscent,"Passed: 0 \n");
			fprintf(fpAscent,"Failed: 1 \n");


			_ftprintf(fpAscent,_TEXT("Error: Operation failed with HRES(0x%x)\n"), hresError);

			fclose(fpAscent);
		}
	    }
	}
    }

    if(fPrint)
    {
	  if(getenv("MDUTIL_BLOCK_ON_ERROR")!=NULL && hresError!=0x80070003)  //path not found
	  {
		_ftprintf(stdout,_TEXT("\nHit SPACE to continue or Ctrl-C to abort.\n"));
		while(1)
		{
			while(!_kbhit())
			{
				;
			}

			if(_getch()==' ')
			{
				_ftprintf(stdout,_TEXT("Continuing...\n"));
				break;
			}
		}
	  }
     }

}

void CAdmUtil::Print(const _TCHAR * format,...)
{

   va_list marker;
   va_start( marker, format );     /* Initialize variable arguments. */
   if(fPrint)
    _vtprintf(format, marker);
   va_end( marker );              /* Reset variable arguments.      */
}


LPTSTR ConvertReturnCodeToString(DWORD ReturnCode)
{
    LPTSTR RetCode = NULL;
    switch (ReturnCode) {
    case ERROR_SUCCESS:
        RetCode = _TEXT("ERROR_SUCCESS");
        break;
    case ERROR_PATH_NOT_FOUND:
        RetCode = _TEXT("ERROR_PATH_NOT_FOUND");
        break;
    case ERROR_INVALID_HANDLE:
        RetCode = _TEXT("ERROR_INVALID_HANDLE");
        break;
    case ERROR_INVALID_DATA:
        RetCode =_TEXT("ERROR_INVALID_DATA");
        break;
    case ERROR_INVALID_PARAMETER:
        RetCode =_TEXT("ERROR_INVALID_PARAMETER");
        break;
    case ERROR_NOT_SUPPORTED:
        RetCode =_TEXT("ERROR_NOT_SUPPORTED");
        break;
    case ERROR_ACCESS_DENIED:
        RetCode =_TEXT("ERROR_ACCESS_DENIED");
        break;
    case ERROR_NOT_ENOUGH_MEMORY:
        RetCode =_TEXT("ERROR_NOT_ENOUGH_MEMORY");
        break;
    case ERROR_FILE_NOT_FOUND:
        RetCode =_TEXT("ERROR_FILE_NOT_FOUND");
        break;
    case ERROR_DUP_NAME:
        RetCode =_TEXT("ERROR_DUP_NAME");
        break;
    case ERROR_PATH_BUSY:
        RetCode =_TEXT("ERROR_PATH_BUSY");
        break;
    case ERROR_NO_MORE_ITEMS:
        RetCode =_TEXT("ERROR_NO_MORE_ITEMS");
        break;
    case ERROR_INSUFFICIENT_BUFFER:
        RetCode =_TEXT("ERROR_INSUFFICIENT_BUFFER");
        break;
    case ERROR_PROC_NOT_FOUND:
        RetCode =_TEXT("ERROR_PROC_NOT_FOUND");
        break;
    case ERROR_INTERNAL_ERROR:
        RetCode =_TEXT("ERROR_INTERNAL_ERROR");
        break;
    case MD_ERROR_NOT_INITIALIZED:
        RetCode =_TEXT("MD_ERROR_NOT_INITIALIZED");
        break;
    case MD_ERROR_DATA_NOT_FOUND:
        RetCode =_TEXT("MD_ERROR_DATA_NOT_FOUND");
        break;
    case ERROR_ALREADY_EXISTS:
        RetCode =_TEXT("ERROR_ALREADY_EXISTS");
        break;
    case MD_WARNING_PATH_NOT_FOUND:
        RetCode =_TEXT("MD_WARNING_PATH_NOT_FOUND");
        break;
    case MD_WARNING_DUP_NAME:
        RetCode =_TEXT("MD_WARNING_DUP_NAME");
        break;
    case MD_WARNING_INVALID_DATA:
        RetCode =_TEXT("MD_WARNING_INVALID_DATA");
        break;
    case ERROR_INVALID_NAME:
        RetCode =_TEXT("ERROR_INVALID_NAME");
        break;
    default:
        RetCode= _TEXT("");//RetCode = "Unrecognized Error Code");
        break;
    }
    return (RetCode);
}

DWORD ConvertHresToDword(HRESULT hRes)
{
    return HRESULTTOWIN32(hRes);
}

LPTSTR ConvertHresToString(HRESULT hRes)
{
    LPTSTR strReturn = NULL;

    if ((HRESULT_FACILITY(hRes) == FACILITY_WIN32) ||
        (HRESULT_FACILITY(hRes) == FACILITY_ITF) ||
        (hRes == 0)) {
        strReturn = ConvertReturnCodeToString(ConvertHresToDword(hRes));
    }
    else {
        switch (hRes) {
        case CO_E_SERVER_EXEC_FAILURE:
            strReturn =_TEXT("CO_E_SERVER_EXEC_FAILURE");
            break;
        default:
            strReturn =_TEXT("Unrecognized hRes facility");
        }
    }
    return(strReturn);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\dcomadm\interf2\security.cxx ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    security.cxx

Abstract:

    This module contains the code necessary to implement secure DCOM data
    transfers on-the-wire. It includes the implementation of the "hooked"
    (call_as) methods from IMSAdminBase.

Author:

    Keith Moore (keithmo)       17-Feb-1997

Revision History:

--*/


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ole2.h>
#include <windows.h>
#include <dbgutil.h>
#include <iadmw.h>
#include <icrypt.hxx>
#include <secdat.hxx>
#include <secpriv.h>


//
// Private constants.
//

#define ALLOC_MEM(cb) (LPVOID)::LocalAlloc( LPTR, (cb) )
#define FREE_MEM(ptr) (VOID)::LocalFree( (HLOCAL)(ptr) )

#if DBG
BOOL g_fEnableSecureChannel = TRUE;
#define ENABLE_SECURE_CHANNEL g_fEnableSecureChannel
#else
#define ENABLE_SECURE_CHANNEL TRUE
#endif

BOOL g_fStopOnKeyset = TRUE;

//
// Private prototypes.
//

VOID
CalculateGetAllBufferAttributes(
    IN PMETADATA_GETALL_RECORD Data,
    IN DWORD NumEntries,
    OUT DWORD * TotalBufferLength,
    OUT BOOL * IsBufferSecure
    );



HRESULT
STDMETHODCALLTYPE
IMSAdminBaseW_SetData_Proxy(
    IMSAdminBaseW __RPC_FAR * This,
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [in] */ PMETADATA_RECORD pmdrMDData
    )
/*++

Routine Description:

    Set a data object.

Arguments:

    hMDHandle - open handle

    pszMDPath - path of the meta object with which this data is associated

    pmdrMDData - data to set

Return Value:

    Status.

--*/
{

    HRESULT result;
    ADM_SECURE_DATA * secureData;
    IIS_CRYPTO_STORAGE * sendCrypto;
    PIIS_CRYPTO_BLOB dataBlob;
    METADATA_RECORD capturedRecord = {0};

    //
    // Setup locals so we know how to cleanup on exit.
    //

    secureData = NULL;
    sendCrypto = NULL;
    dataBlob = NULL;
    result = NO_ERROR;

    //
    // Trap the case of a null METADATA_RECORD
    //

    if( pmdrMDData == NULL )
    {
        result = RETURNCODETOHRESULT(ERROR_INVALID_PARAMETER);
        goto cleanup;
    }

    //
    // Capture the METADATA_RECORD so we can muck with it.
    //

    __try {
        capturedRecord = *pmdrMDData;
    } __except( EXCEPTION_EXECUTE_HANDLER ) {
        result = HRESULT_FROM_NT( GetExceptionCode() );
    }

    if( FAILED(result) ) {
        goto cleanup;
    }

    //
    // If this is a secure data item, then encrypt the data before
    // sending.
    //

#if DBG
    if( ENABLE_SECURE_CHANNEL &&
        (capturedRecord.dwMDAttributes & METADATA_SECURE) &&
        ((PVOID)capturedRecord.pbMDData != NULL) ) {
#else
    if( (capturedRecord.dwMDAttributes & METADATA_SECURE) &&
        ((PVOID)capturedRecord.pbMDData != NULL) ) {
#endif
        //
        // Find an ADM_SECURE_DATA object for "This".
        //

        secureData = ADM_SECURE_DATA::FindOrAddAndReferenceClientSecureData( This );

        if( secureData == NULL ) {
            result = MD_ERROR_SECURE_CHANNEL_FAILURE;
            goto cleanup;
        }

        //
        // Get the appropriate crypto storage object. This will perform
        // key exchange if necessary.
        //

        result = secureData->GetClientSendCryptoStorage( &sendCrypto,
                                                         This );

        DBG_ASSERT( SUCCEEDED( result ) || !g_fStopOnKeyset );

        if( FAILED(result) ) {
            goto cleanup;
        }

        //
        // Protect ourselves from malicious users.
        //

        __try {

            //
            // Encrypt the data.
            //

            result = sendCrypto->EncryptData(
                         &dataBlob,
                         (PVOID)capturedRecord.pbMDData,
                         capturedRecord.dwMDDataLen,
                         0                                      // dwRegType
                         );

        } __except( EXCEPTION_EXECUTE_HANDLER ) {

            result = HRESULT_FROM_NT(GetExceptionCode());

        }

        DBG_ASSERT( SUCCEEDED( result ) || !g_fStopOnKeyset );

        if( FAILED(result) ) {
            goto cleanup;
        }

        //
        // Update the fields of the captured metadata record so the
        // RPC runtime will send the data to the server.
        //

        capturedRecord.pbMDData = (PBYTE)dataBlob;
        capturedRecord.dwMDDataLen = IISCryptoGetBlobLength( dataBlob );

    }

    //
    // Call through to the "real" remoted API to get this over to the
    // server.
    //

    result = IMSAdminBaseW_R_SetData_Proxy(
                 This,
                 hMDHandle,
                 pszMDPath,
                 &capturedRecord
                 );

cleanup:

    DBG_ASSERT( !g_fStopOnKeyset ||
                ( ( result != NTE_BAD_KEYSET ) &&
                  ( result != NTE_KEYSET_NOT_DEF ) &&
                  ( result != NTE_KEYSET_ENTRY_BAD ) &&
                  ( result != NTE_BAD_KEYSET_PARAM ) ) );

    if( dataBlob != NULL ) {
        IISCryptoFreeBlob( dataBlob );
    }

    if( secureData != NULL ) {
        secureData->Dereference();
    }

    return result;

}   // IMSAdminBaseW_SetData_Proxy


HRESULT
STDMETHODCALLTYPE
IMSAdminBaseW_SetData_Stub(
    IMSAdminBaseW __RPC_FAR * This,
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [in] */ PMETADATA_RECORD pmdrMDData
    )
/*++

Routine Description:

    Set a data object.

Arguments:

    hMDHandle - open handle

    pszMDPath - path of the meta object with which this data is associated

    pmdrMDData - data to set

Return Value:

    Status.

--*/
{

    HRESULT result;
    ADM_SECURE_DATA * secureData;
    IIS_CRYPTO_STORAGE * recvCrypto;
    METADATA_RECORD capturedRecord;
    DWORD clearDataType;

    //
    // Setup locals so we know how to cleanup on exit.
    //

    secureData = NULL;
    recvCrypto = NULL;
    result = NO_ERROR;

    //
    // Capture the metadata record so we can muck with it.
    //

    capturedRecord = *pmdrMDData;

    //
    // If this is a secure data item, then decrypt the data before
    // passing it to the actual implementation object.
    //

#if DBG
    if( ENABLE_SECURE_CHANNEL &&
        (capturedRecord.dwMDAttributes & METADATA_SECURE) &&
        (capturedRecord.pbMDData != NULL) ) {
#else
    if( (capturedRecord.dwMDAttributes & METADATA_SECURE) &&
        (capturedRecord.pbMDData != NULL) ) {
#endif
        //
        // Find an ADM_SECURE_DATA object for "This".
        //

        secureData = ADM_SECURE_DATA::FindAndReferenceServerSecureData(
                         This,
                         TRUE       // CreateIfNotFound
                         );

        if( secureData == NULL ) {
            result = MD_ERROR_SECURE_CHANNEL_FAILURE;
            goto cleanup;
        }

        //
        // Get the appropriate crypto storage object.
        //

        result = secureData->GetServerReceiveCryptoStorage( &recvCrypto );

        DBG_ASSERT( SUCCEEDED( result ) || !g_fStopOnKeyset );

        if ( FAILED(result) ) {
            goto cleanup;
        }

        //
        // Decrypt the data, then replace the pointer in the metadata
        // record.
        //

        result = recvCrypto->DecryptData(
                     (PVOID *)&capturedRecord.pbMDData,
                     &capturedRecord.dwMDDataLen,
                     &clearDataType,
                     (PIIS_CRYPTO_BLOB)capturedRecord.pbMDData
                     );

        DBG_ASSERT( SUCCEEDED( result ) || !g_fStopOnKeyset );

        if( FAILED(result) ) {
            goto cleanup;
        }

    }

    //
    // Call through to the "real" server stub to set the data.
    //

    result = This->SetData(
                 hMDHandle,
                 pszMDPath,
                 &capturedRecord
                 );

cleanup:
    DBG_ASSERT( !g_fStopOnKeyset ||
                ( ( result != NTE_BAD_KEYSET ) &&
                  ( result != NTE_KEYSET_NOT_DEF ) &&
                  ( result != NTE_KEYSET_ENTRY_BAD ) &&
                  ( result != NTE_BAD_KEYSET_PARAM ) ) );

    if( secureData != NULL ) {
        secureData->Dereference();
    }

    return result;

}   // IMSAdminBaseW_SetData_Stub


HRESULT
STDMETHODCALLTYPE
IMSAdminBaseW_GetData_Proxy(
    IMSAdminBaseW __RPC_FAR * This,
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [out][in] */ PMETADATA_RECORD pmdrMDData,
    /* [out] */ DWORD __RPC_FAR *pdwMDRequiredDataLen
    )
/*++

Routine Description:

    Get one metadata value

Arguments:

    hMDHandle - open handle

    pszMDPath - path of the meta object with which this data is associated

    pmdrMDData - data structure

    pdwMDRequiredDataLen - updated with required length

Return Value:

    Status.

--*/
{

    HRESULT result;
    ADM_SECURE_DATA * secureData;
    IIS_CRYPTO_STORAGE * recvCrypto;
    IIS_CRYPTO_BLOB *dataBlob;
    METADATA_RECORD capturedRecord;
    PVOID dataBuffer;
    DWORD dataBufferLength;
    DWORD dataBufferType;

    //
    // Setup locals so we know how to cleanup on exit.
    //

    secureData = NULL;
    recvCrypto = NULL;
    dataBlob = NULL;

    //
    // Trap the case of a null METADATA_RECORD
    //

    if( pmdrMDData == NULL )
    {
        result = RETURNCODETOHRESULT(ERROR_INVALID_PARAMETER);
        goto cleanup;
    }

    //
    // Find an ADM_SECURE_DATA object for "This".
    //

    secureData = ADM_SECURE_DATA::FindOrAddAndReferenceClientSecureData( This );

    if( secureData == NULL ) {
        result = MD_ERROR_SECURE_CHANNEL_FAILURE;
        goto cleanup;
    }

    //
    // Get the appropriate crypto storage object. This will perform
    // key exchange if necessary.
    //

    result = secureData->GetClientReceiveCryptoStorage( &recvCrypto,
                                                        This );

    if( FAILED(result) ) {
        goto cleanup;
    }

    //
    // Capture the METADATA_RECORD so we can muck with it.
    //

    __try {
        capturedRecord = *pmdrMDData;
    } __except( EXCEPTION_EXECUTE_HANDLER ) {
        result = HRESULT_FROM_NT( GetExceptionCode() );
    }

    if( FAILED(result) ) {
        goto cleanup;
    }

    //
    // Call through to the "real" remoted API to get the data from
    // the server. Note that we set the data pointer to NULL before
    // calling the remoted API. This prevents the RPC runtime from
    // sending plaintext data over to the server.
    //

    capturedRecord.pbMDData = NULL;

    result = IMSAdminBaseW_R_GetData_Proxy(
                 This,
                 hMDHandle,
                 pszMDPath,
                 &capturedRecord,
                 pdwMDRequiredDataLen,
                 &dataBlob
                 );

    if( FAILED(result) ) {
        goto cleanup;
    }

    //
    // Decrypt the data if necessary. This method properly handles
    // cleartext (unencrypted) blobs.
    //

    result = recvCrypto->DecryptData(
                 &dataBuffer,
                 &dataBufferLength,
                 &dataBufferType,
                 dataBlob
                 );

    if( FAILED(result) ) {
        goto cleanup;
    }

    //
    // Copy it back to the user.
    //

    __try {

        if( pmdrMDData->dwMDDataLen >= dataBufferLength ) {

            RtlCopyMemory(
                pmdrMDData->pbMDData,
                dataBuffer,
                dataBufferLength
                );

            pmdrMDData->dwMDDataLen = dataBufferLength;
            pmdrMDData->dwMDIdentifier = capturedRecord.dwMDIdentifier;
            pmdrMDData->dwMDAttributes = capturedRecord.dwMDAttributes;
            pmdrMDData->dwMDUserType = capturedRecord.dwMDUserType;
            pmdrMDData->dwMDDataType = capturedRecord.dwMDDataType;
            pmdrMDData->dwMDDataTag = capturedRecord.dwMDDataTag;

        } else {

            *pdwMDRequiredDataLen = dataBufferLength;
            result = RETURNCODETOHRESULT( ERROR_INSUFFICIENT_BUFFER );

        }

    } __except( EXCEPTION_EXECUTE_HANDLER ) {

        result = HRESULT_FROM_NT( GetExceptionCode() );

    }

    if( FAILED(result) ) {
        goto cleanup;
    }

cleanup:

    if( secureData != NULL ) {
        secureData->Dereference();
    }

    if( dataBlob != NULL ) {
        ::IISCryptoFreeBlob( dataBlob );
    }

    return result;

}   // IMSAdminBaseW_GetData_Proxy


HRESULT
STDMETHODCALLTYPE
IMSAdminBaseW_GetData_Stub(
    IMSAdminBaseW __RPC_FAR * This,
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [out][in] */ PMETADATA_RECORD pmdrMDData,
    /* [out] */ DWORD __RPC_FAR *pdwMDRequiredDataLen,
    /* [out] */ struct _IIS_CRYPTO_BLOB __RPC_FAR *__RPC_FAR *ppDataBlob
    )
/*++

Routine Description:

    Get one metadata value

Arguments:

    hMDHandle - open handle

    pszMDPath - path of the meta object with which this data is associated

    pmdrMDData - data structure

    pdwMDRequiredDataLen - updated with required length

    ppDataBlob - Receives a blob for the encrypted data.

Return Value:

    Status.

--*/
{

    HRESULT result;
    ADM_SECURE_DATA * secureData;
    IIS_CRYPTO_STORAGE * sendCrypto;
    IIS_CRYPTO_BLOB *dataBlob;
    PVOID dataBuffer;

    //
    // Setup locals so we know how to cleanup on exit.
    //

    secureData = NULL;
    sendCrypto = NULL;
    dataBuffer = NULL;
    dataBlob = NULL;

    //
    // Allocate a temporary memory block for the meta data. Use the
    // same size as the user passed into the API.
    //

    dataBuffer = ALLOC_MEM( pmdrMDData->dwMDDataLen );

    if( dataBuffer == NULL ) {
        result = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        goto cleanup;
    }

    pmdrMDData->pbMDData = (PBYTE)dataBuffer;

    //
    // Call through to the "real" server stub to get the data.
    //

    result = This->GetData(
                 hMDHandle,
                 pszMDPath,
                 pmdrMDData,
                 pdwMDRequiredDataLen
                 );

    if( FAILED(result) ) {
        goto cleanup;
    }

    //
    // If this is a secure data item, then we'll need to encrypt it
    // before returning it to the client. Otherwise, we'll build a
    // cleartext blob to contain the data.
    //

#if DBG
    if( ENABLE_SECURE_CHANNEL &&
        pmdrMDData->dwMDAttributes & METADATA_SECURE ) {
#else
    if( pmdrMDData->dwMDAttributes & METADATA_SECURE ) {
#endif
        //
        // Find an ADM_SECURE_DATA object for "This".
        //

        secureData = ADM_SECURE_DATA::FindAndReferenceServerSecureData(
                         This,
                         TRUE       // CreateIfNotFound
                         );

        if( secureData == NULL ) {
            result = MD_ERROR_SECURE_CHANNEL_FAILURE;
            goto cleanup;
        }

        //
        // Get the appropriate crypto storage object.
        //

        result = secureData->GetServerSendCryptoStorage( &sendCrypto );

        if( FAILED(result) ) {
            goto cleanup;
        }

        //
        // Encrypt the data.
        //

        result = sendCrypto->EncryptData(
                     &dataBlob,
                     (PVOID)pmdrMDData->pbMDData,
                     pmdrMDData->dwMDDataLen,
                     0
                     );

        if( FAILED(result) ) {
            goto cleanup;
        }

    } else {

        result = ::IISCryptoCreateCleartextBlob(
                       &dataBlob,
                       (PVOID)pmdrMDData->pbMDData,
                       pmdrMDData->dwMDDataLen
                       );

        if( FAILED(result) ) {
            goto cleanup;
        }

    }

    //
    // Success!
    //

    DBG_ASSERT( SUCCEEDED(result) );
    *ppDataBlob = dataBlob;

cleanup:

    //
    // NULL the data pointer in the METADATA_RECORD so the RPC runtime
    // won't send the plaintext data back to the client.
    //

    pmdrMDData->pbMDData = NULL;

    if( secureData != NULL ) {
        secureData->Dereference();
    }

    if( dataBuffer != NULL ) {
        FREE_MEM( dataBuffer );
    }

    if( FAILED(result) && dataBlob != NULL ) {
        ::IISCryptoFreeBlob( dataBlob );
    }

    return result;

}   // IMSAdminBaseW_GetData_Stub


HRESULT
STDMETHODCALLTYPE
IMSAdminBaseW_EnumData_Proxy(
    IMSAdminBaseW __RPC_FAR * This,
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [out][in] */ PMETADATA_RECORD pmdrMDData,
    /* [in] */ DWORD dwMDEnumDataIndex,
    /* [out] */ DWORD __RPC_FAR *pdwMDRequiredDataLen
    )
/*++

Routine Description:

    Enumerate properties of object.

Arguments:

    hMDHandle - open handle

    pszMDPath - path of the meta object with which this data is associated

    pmdrMDData - data structure

    pdwMDRequiredDataLen - updated with required length

Return Value:

    Status.

--*/
{

    HRESULT result;
    ADM_SECURE_DATA * secureData;
    IIS_CRYPTO_STORAGE * recvCrypto;
    IIS_CRYPTO_BLOB *dataBlob;
    METADATA_RECORD capturedRecord;
    PVOID dataBuffer;
    DWORD dataBufferLength;
    DWORD dataBufferType;

    //
    // Setup locals so we know how to cleanup on exit.
    //

    secureData = NULL;
    recvCrypto = NULL;
    dataBlob = NULL;

    //
    // Trap the case of a null METADATA_RECORD
    //

    if( pmdrMDData == NULL )
    {
        result = RETURNCODETOHRESULT(ERROR_INVALID_PARAMETER);
        goto cleanup;
    }


    //
    // Find an ADM_SECURE_DATA object for "This".
    //

    secureData = ADM_SECURE_DATA::FindOrAddAndReferenceClientSecureData( This );

    if( secureData == NULL ) {
        result = MD_ERROR_SECURE_CHANNEL_FAILURE;
        goto cleanup;
    }

    //
    // Get the appropriate crypto storage object. This will perform
    // key exchange if necessary.
    //

    result = secureData->GetClientReceiveCryptoStorage( &recvCrypto,
                                                        This );

    if( FAILED(result) ) {
        goto cleanup;
    }

    //
    // Capture the METADATA_RECORD so we can muck with it.
    //

    __try {
        capturedRecord = *pmdrMDData;
    } __except( EXCEPTION_EXECUTE_HANDLER ) {
        result = HRESULT_FROM_NT( GetExceptionCode() );
    }

    if( FAILED(result) ) {
        goto cleanup;
    }

    //
    // Call through to the "real" remoted API to get the data from
    // the server. Note that we set the data pointer to NULL before
    // calling the remoted API. This prevents the RPC runtime from
    // sending plaintext data over to the server.
    //

    capturedRecord.pbMDData = NULL;

    result = IMSAdminBaseW_R_EnumData_Proxy(
                 This,
                 hMDHandle,
                 pszMDPath,
                 &capturedRecord,
                 dwMDEnumDataIndex,
                 pdwMDRequiredDataLen,
                 &dataBlob
                 );

    if( FAILED(result) ) {
        goto cleanup;
    }

    //
    // Decrypt the data if necessary. This method properly handles
    // cleartext (unencrypted) blobs.
    //

    result = recvCrypto->DecryptData(
                 &dataBuffer,
                 &dataBufferLength,
                 &dataBufferType,
                 dataBlob
                 );

    if( FAILED(result) ) {
        goto cleanup;
    }

    //
    // Copy it back to the user.
    //

    __try {

        if( pmdrMDData->dwMDDataLen >= dataBufferLength ) {

            RtlCopyMemory(
                pmdrMDData->pbMDData,
                dataBuffer,
                dataBufferLength
                );

            pmdrMDData->dwMDDataLen = dataBufferLength;
            pmdrMDData->dwMDIdentifier = capturedRecord.dwMDIdentifier;
            pmdrMDData->dwMDAttributes = capturedRecord.dwMDAttributes;
            pmdrMDData->dwMDUserType = capturedRecord.dwMDUserType;
            pmdrMDData->dwMDDataType = capturedRecord.dwMDDataType;
            pmdrMDData->dwMDDataTag = capturedRecord.dwMDDataTag;

        } else {

            *pdwMDRequiredDataLen = dataBufferLength;
            result = RETURNCODETOHRESULT( ERROR_INSUFFICIENT_BUFFER );

        }

    } __except( EXCEPTION_EXECUTE_HANDLER ) {

        result = HRESULT_FROM_NT( GetExceptionCode() );

    }

    if( FAILED(result) ) {
        goto cleanup;
    }

cleanup:

    if( secureData != NULL ) {
        secureData->Dereference();
    }

    if( dataBlob != NULL ) {
        ::IISCryptoFreeBlob( dataBlob );
    }

    return result;

}   // IMSAdminBaseW_EnumData_Proxy


HRESULT
STDMETHODCALLTYPE
IMSAdminBaseW_EnumData_Stub(
    IMSAdminBaseW __RPC_FAR * This,
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [out][in] */ PMETADATA_RECORD pmdrMDData,
    /* [in] */ DWORD dwMDEnumDataIndex,
    /* [out] */ DWORD __RPC_FAR *pdwMDRequiredDataLen,
    /* [out] */ struct _IIS_CRYPTO_BLOB __RPC_FAR *__RPC_FAR *ppDataBlob
    )
/*++

Routine Description:

    Enumerate properties of object.

Arguments:

    hMDHandle - open handle

    pszMDPath - path of the meta object with which this data is associated

    pmdrMDData - data structure

    pdwMDRequiredDataLen - updated with required length

    ppDataBlob - Receives a blob for the encrypted data.

Return Value:

    Status.

--*/
{

    HRESULT result;
    ADM_SECURE_DATA * secureData;
    IIS_CRYPTO_STORAGE * sendCrypto;
    IIS_CRYPTO_BLOB *dataBlob;
    PVOID dataBuffer;

    //
    // Setup locals so we know how to cleanup on exit.
    //

    secureData = NULL;
    sendCrypto = NULL;
    dataBuffer = NULL;
    dataBlob = NULL;

    //
    // Allocate a temporary memory block for the meta data. Use the
    // same size as the user passed into the API.
    //

    dataBuffer = ALLOC_MEM( pmdrMDData->dwMDDataLen );

    if( dataBuffer == NULL ) {
        result = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        goto cleanup;
    }

    pmdrMDData->pbMDData = (PBYTE)dataBuffer;

    //
    // Call through to the "real" server stub to get the data.
    //

    result = This->EnumData(
                 hMDHandle,
                 pszMDPath,
                 pmdrMDData,
                 dwMDEnumDataIndex,
                 pdwMDRequiredDataLen
                 );

    if( FAILED(result) ) {
        goto cleanup;
    }

    //
    // If this is a secure data item, then we'll need to encrypt it
    // before returning it to the client. Otherwise, we'll build a
    // cleartext blob to contain the data.
    //

#if DBG
    if( ENABLE_SECURE_CHANNEL &&
        pmdrMDData->dwMDAttributes & METADATA_SECURE ) {
#else
    if( pmdrMDData->dwMDAttributes & METADATA_SECURE ) {
#endif

        //
        // Find an ADM_SECURE_DATA object for "This".
        //

        secureData = ADM_SECURE_DATA::FindAndReferenceServerSecureData(
                         This,
                         TRUE       // CreateIfNotFound
                         );

        if( secureData == NULL ) {
            result = MD_ERROR_SECURE_CHANNEL_FAILURE;
            goto cleanup;
        }

        //
        // Get the appropriate crypto storage object.
        //

        result = secureData->GetServerSendCryptoStorage( &sendCrypto );

        if( FAILED(result) ) {
            goto cleanup;
        }

        //
        // Encrypt the data.
        //

        result = sendCrypto->EncryptData(
                     &dataBlob,
                     (PVOID)pmdrMDData->pbMDData,
                     pmdrMDData->dwMDDataLen,
                     0
                     );

        if( FAILED(result) ) {
            goto cleanup;
        }

    } else {

        result = ::IISCryptoCreateCleartextBlob(
                       &dataBlob,
                       (PVOID)pmdrMDData->pbMDData,
                       pmdrMDData->dwMDDataLen
                       );

        if( FAILED(result) ) {
            goto cleanup;
        }

    }

    //
    // Success!
    //

    DBG_ASSERT( SUCCEEDED(result) );
    *ppDataBlob = dataBlob;

cleanup:

    //
    // NULL the data pointer in the METADATA_RECORD so the RPC runtime
    // won't send the plaintext data back to the client.
    //

    pmdrMDData->pbMDData = NULL;

    if( secureData != NULL ) {
        secureData->Dereference();
    }

    if( dataBuffer != NULL ) {
        FREE_MEM( dataBuffer );
    }

    if( FAILED(result) && dataBlob != NULL ) {
        ::IISCryptoFreeBlob( dataBlob );
    }

    return result;

}   // IMSAdminBaseW_EnumData_Stub


HRESULT
STDMETHODCALLTYPE
IMSAdminBaseW_GetAllData_Proxy(
    IMSAdminBaseW __RPC_FAR * This,
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [in] */ DWORD dwMDAttributes,
    /* [in] */ DWORD dwMDUserType,
    /* [in] */ DWORD dwMDDataType,
    /* [out] */ DWORD __RPC_FAR *pdwMDNumDataEntries,
    /* [out] */ DWORD __RPC_FAR *pdwMDDataSetNumber,
    /* [in] */ DWORD dwMDBufferSize,
    /* [size_is][out] */ unsigned char __RPC_FAR *pbBuffer,
    /* [out] */ DWORD __RPC_FAR *pdwMDRequiredBufferSize
    )
/*++

Routine Description:

    Gets all data associated with a Meta Object

Arguments:

    hMDHandle - open  handle

    pszMDPath - path of the meta object with which this data is associated

    dwMDAttributes - flags for the data

    dwMDUserType - user Type for the data

    dwMDDataType - type of the data

    pdwMDNumDataEntries - number of entries copied to Buffer

    pdwMDDataSetNumber - number associated with this data set

    dwMDBufferSize - size in bytes of buffer

    pbBuffer - buffer to store the data

    pdwMDRequiredBufferSize - updated with required length of buffer

Return Value:

    Status.

--*/
{

    HRESULT result;
    ADM_SECURE_DATA * secureData;
    IIS_CRYPTO_STORAGE * recvCrypto;
    IIS_CRYPTO_BLOB *dataBlob;
    PVOID dataBuffer;
    DWORD dataBufferLength;
    DWORD dataBufferType;

    //
    // Setup locals so we know how to cleanup on exit.
    //

    secureData = NULL;
    recvCrypto = NULL;
    dataBlob = NULL;

    //
    // Find an ADM_SECURE_DATA object for "This".
    //

    secureData = ADM_SECURE_DATA::FindOrAddAndReferenceClientSecureData( This );

    if( secureData == NULL ) {
        result = MD_ERROR_SECURE_CHANNEL_FAILURE;
        goto cleanup;
    }

    //
    // Get the appropriate crypto storage object. This will perform
    // key exchange if necessary.
    //

    result = secureData->GetClientReceiveCryptoStorage( &recvCrypto,
                                                        This );

    if( FAILED(result) ) {
        goto cleanup;
    }

    //
    // Call through to the "real" remoted API to get the data from
    // the server.
    //

    result = IMSAdminBaseW_R_GetAllData_Proxy(
                 This,
                 hMDHandle,
                 pszMDPath,
                 dwMDAttributes,
                 dwMDUserType,
                 dwMDDataType,
                 pdwMDNumDataEntries,
                 pdwMDDataSetNumber,
                 dwMDBufferSize,
                 pdwMDRequiredBufferSize,
                 &dataBlob
                 );

    if( FAILED(result) ) {
        goto cleanup;
    }

    //
    // Decrypt the data if necessary. This method properly handles
    // cleartext (unencrypted) blobs.
    //

    result = recvCrypto->DecryptData(
                 &dataBuffer,
                 &dataBufferLength,
                 &dataBufferType,
                 dataBlob
                 );


    if( FAILED(result) ) {
        goto cleanup;
    }

    //
    // Copy it back to the user.
    //

    __try {

        if( dwMDBufferSize >= dataBufferLength ) {

            RtlCopyMemory(
                pbBuffer,
                dataBuffer,
                dataBufferLength
                );

        } else {

            *pdwMDRequiredBufferSize = dataBufferLength;
            result = RETURNCODETOHRESULT( ERROR_INSUFFICIENT_BUFFER );

        }

    } __except( EXCEPTION_EXECUTE_HANDLER ) {

        result = HRESULT_FROM_NT( GetExceptionCode() );

    }

    if( FAILED(result) ) {
        goto cleanup;
    }

cleanup:

    if( secureData != NULL ) {
        secureData->Dereference();
    }

    if( dataBlob != NULL ) {
        ::IISCryptoFreeBlob( dataBlob );
    }

    return result;

}   // IMSAdminBaseW_GetAllData_Proxy

HRESULT
STDMETHODCALLTYPE
IMSAdminBaseW_GetAllData_Stub(
    IMSAdminBaseW __RPC_FAR * This,
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [in] */ DWORD dwMDAttributes,
    /* [in] */ DWORD dwMDUserType,
    /* [in] */ DWORD dwMDDataType,
    /* [out] */ DWORD __RPC_FAR *pdwMDNumDataEntries,
    /* [out] */ DWORD __RPC_FAR *pdwMDDataSetNumber,
    /* [in] */ DWORD dwMDBufferSize,
    /* [out] */ DWORD __RPC_FAR *pdwMDRequiredBufferSize,
    /* [out] */ struct _IIS_CRYPTO_BLOB __RPC_FAR *__RPC_FAR *ppDataBlob
    )
/*++

Routine Description:

    Gets all data associated with a Meta Object

Arguments:

    hMDHandle - open  handle

    pszMDPath - path of the meta object with which this data is associated

    dwMDAttributes - flags for the data

    dwMDUserType - user Type for the data

    dwMDDataType - type of the data

    pdwMDNumDataEntries - number of entries copied to Buffer

    pdwMDDataSetNumber - number associated with this data set

    dwMDBufferSize - size in bytes of buffer

    pdwMDRequiredBufferSize - updated with required length of buffer

    ppDataBlob - Receives a blob for the encrypted data.

Return Value:

    Status.

--*/
{

    HRESULT result;
    ADM_SECURE_DATA * secureData;
    IIS_CRYPTO_STORAGE * sendCrypto;
    IIS_CRYPTO_BLOB *dataBlob;
    PVOID dataBuffer;
    DWORD getAllBufferLength;
    BOOL getAllBufferIsSecure;

    //
    // Setup locals so we know how to cleanup on exit.
    //

    secureData = NULL;
    sendCrypto = NULL;
    dataBuffer = NULL;
    dataBlob = NULL;

    //
    // Allocate a temporary memory block for the meta data. Use the
    // same size as the user passed into the API.
    //

    dataBuffer = ALLOC_MEM( dwMDBufferSize );

    if( dataBuffer == NULL ) {
        result = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        goto cleanup;
    }

    //
    // Call through to the "real" server stub to get the data.
    //

    result = This->GetAllData(
                 hMDHandle,
                 pszMDPath,
                 dwMDAttributes,
                 dwMDUserType,
                 dwMDDataType,
                 pdwMDNumDataEntries,
                 pdwMDDataSetNumber,
                 dwMDBufferSize,
                 (PBYTE)dataBuffer,
                 pdwMDRequiredBufferSize
                 );

    if( FAILED(result) ) {
        goto cleanup;
    }

    //
    // Compute the total size of the METADATA_GETALL_RECORD. Also
    // take this opportunity to determine if any of the data items
    // within the record are marked as secure. We'll encrypt the
    // entire record if any entry is secure.
    //

    CalculateGetAllBufferAttributes(
        (PMETADATA_GETALL_RECORD)dataBuffer,
        *pdwMDNumDataEntries,
        &getAllBufferLength,
        &getAllBufferIsSecure
        );

    //
    // Encrypt if necessary.
    //

    if( getAllBufferIsSecure ) {

        //
        // Find an ADM_SECURE_DATA object for "This".
        //

        secureData = ADM_SECURE_DATA::FindAndReferenceServerSecureData(
                         This,
                         TRUE       // CreateIfNotFound
                         );

        if( secureData == NULL ) {
            result = MD_ERROR_SECURE_CHANNEL_FAILURE;
            goto cleanup;
        }

        //
        // Get the appropriate crypto storage object.
        //

        result = secureData->GetServerSendCryptoStorage( &sendCrypto );

        if( FAILED(result) ) {
            goto cleanup;
        }

        //
        // Encrypt the data.
        //

        result = sendCrypto->EncryptData(
                     &dataBlob,
                     dataBuffer,
                     getAllBufferLength,
                     0
                     );

        if( FAILED(result) ) {
            goto cleanup;
        }

    } else {

        result = ::IISCryptoCreateCleartextBlob(
                       &dataBlob,
                       dataBuffer,
                       getAllBufferLength
                       );

        if( FAILED(result) ) {
            goto cleanup;
        }

    }

    //
    // Success!
    //

    DBG_ASSERT( SUCCEEDED(result) );
    *ppDataBlob = dataBlob;

cleanup:

    if( secureData != NULL ) {
        secureData->Dereference();
    }

    if( dataBuffer != NULL ) {
        FREE_MEM( dataBuffer );
    }

    if( FAILED(result) && dataBlob != NULL ) {
        ::IISCryptoFreeBlob( dataBlob );
    }

    return result;

}   // IMSAdminBaseW_GetAllData_Stub


HRESULT
STDMETHODCALLTYPE
IMSAdminBaseW_GetServerGuid_Proxy(
    IMSAdminBaseW __RPC_FAR *
    )
{

    return E_FAIL;

}   // IMSAdminBaseW_GetServerGuid_Proxy



HRESULT
STDMETHODCALLTYPE
IMSAdminBaseW_GetServerGuid_Stub(
    IMSAdminBaseW __RPC_FAR * This,
    /* [out] */ GUID __RPC_FAR *pServerGuid)
{
    ADM_SECURE_DATA * secureData;

    //
    // Find an ADM_SECURE_DATA object for "This".
    //

    secureData = ADM_SECURE_DATA::FindAndReferenceServerSecureData(
                     This,
                     TRUE       // CreateIfNotFound
                     );

    if( secureData == NULL ) {
        return MD_ERROR_SECURE_CHANNEL_FAILURE;
    }

    *pServerGuid = secureData->GetGuid();

    secureData->Dereference();

    return ERROR_SUCCESS;

}


HRESULT
STDMETHODCALLTYPE
IMSAdminBaseW_KeyExchangePhase1_Proxy(
    IMSAdminBaseW __RPC_FAR *
    )
{

    return E_FAIL;

}   // IMSAdminBaseW_KeyExchangePhase1_Proxy

HRESULT
STDMETHODCALLTYPE
IMSAdminBaseW_KeyExchangePhase1_Stub(
    IMSAdminBaseW __RPC_FAR * This,
    /* [in][unique] */ struct _IIS_CRYPTO_BLOB __RPC_FAR *pClientKeyExchangeKeyBlob,
    /* [in][unique] */ struct _IIS_CRYPTO_BLOB __RPC_FAR *pClientSignatureKeyBlob,
    /* [out] */ struct _IIS_CRYPTO_BLOB __RPC_FAR *__RPC_FAR *ppServerKeyExchangeKeyBlob,
    /* [out] */ struct _IIS_CRYPTO_BLOB __RPC_FAR *__RPC_FAR *ppServerSignatureKeyBlob,
    /* [out] */ struct _IIS_CRYPTO_BLOB __RPC_FAR *__RPC_FAR *ppServerSessionKeyBlob
    )
{

    HRESULT result;
    ADM_SECURE_DATA * secureData;

    //
    // Find an ADM_SECURE_DATA object for "This".
    //

    secureData = ADM_SECURE_DATA::FindAndReferenceServerSecureData(
                     This,
                     TRUE       // CreateIfNotFound
                     );

    if( secureData == NULL ) {
        return MD_ERROR_SECURE_CHANNEL_FAILURE;
    }

    //
    // Do the phase 1 server-side key exchange.
    //

    result = secureData->DoServerSideKeyExchangePhase1(
                 pClientKeyExchangeKeyBlob,
                 pClientSignatureKeyBlob,
                 ppServerKeyExchangeKeyBlob,
                 ppServerSignatureKeyBlob,
                 ppServerSessionKeyBlob
                 );

    secureData->Dereference();

    return result;

}   // IMSAdminBaseW_KeyExchangePhase1_Stub


HRESULT
STDMETHODCALLTYPE
IMSAdminBaseW_KeyExchangePhase2_Proxy(
    IMSAdminBaseW __RPC_FAR *
    )
{

    return E_FAIL;

}   // IMSAdminBaseW_KeyExchangePhase2_Proxy


HRESULT
STDMETHODCALLTYPE
IMSAdminBaseW_KeyExchangePhase2_Stub(
    IMSAdminBaseW __RPC_FAR * This,
    /* [in][unique] */ struct _IIS_CRYPTO_BLOB __RPC_FAR *pClientSessionKeyBlob,
    /* [in][unique] */ struct _IIS_CRYPTO_BLOB __RPC_FAR *pClientHashBlob,
    /* [out] */ struct _IIS_CRYPTO_BLOB __RPC_FAR *__RPC_FAR *ppServerHashBlob
    )
{



    HRESULT result;
    ADM_SECURE_DATA * secureData;

    //
    // Find an ADM_SECURE_DATA object for "This".
    //

    secureData = ADM_SECURE_DATA::FindAndReferenceServerSecureData(
                     This,
                     FALSE      // CreateIfNotFound
                     );

    if( secureData == NULL ) {
        return MD_ERROR_SECURE_CHANNEL_FAILURE;
    }

    //
    // Do the phase 2 server-side key exchange.
    //

    result = secureData->DoServerSideKeyExchangePhase2(
                 pClientSessionKeyBlob,
                 pClientHashBlob,
                 ppServerHashBlob
                 );

    secureData->Dereference();

    return result;

}   // IMSAdminBaseW_KeyExchangePhase2_Stub


VOID
CalculateGetAllBufferAttributes(
    IN PMETADATA_GETALL_RECORD Data,
    IN DWORD NumEntries,
    OUT DWORD * TotalBufferLength,
    OUT BOOL * IsBufferSecure
    )
/*++

Routine Description:

    This routine performs three major functions:

        1. It calculates the total size of the METADATA_GETALL_RECORD,
           including all data.

        2. It determines if any of the METADATA_GETALL_RECORDs are marked
           as secure.

Arguments:

    Data - Pointer to the METADATA_GETALL_RECORD buffer.

    NumEntries - The number of entries in the buffer.

    TotalBufferLength - Receives the total buffer length.

    IsBufferSecure - Receives TRUE if any of the entries are marked secure.

Return Value:

    None.

--*/
{

    PMETADATA_GETALL_RECORD scan;
    DWORD i;
    DWORD_PTR usedBufferLength;
    DWORD_PTR nextOffset;
    BOOL isSecure;

    //
    // Setup.
    //

    usedBufferLength = NumEntries * sizeof(METADATA_GETALL_RECORD);
    isSecure = FALSE;

    //
    // Scan the entries, accumulating the total data length.
    //
    // Because the individual data entries may be padded. We will
    // consider the amount of buffer used to be the highest offset
    // + the length of that record's data.
    //
    // While we're at it, determine if any are marked as secure.
    //

    for( scan = Data, i = NumEntries ; i > 0 ; scan++, i-- ) {

        nextOffset = scan->dwMDDataOffset + scan->dwMDDataLen;

        if( nextOffset > usedBufferLength ) {
            usedBufferLength = nextOffset;
        }

        if( scan->dwMDAttributes & METADATA_SECURE ) {
            isSecure = ENABLE_SECURE_CHANNEL;
        }

    }

    *TotalBufferLength = static_cast<DWORD>(usedBufferLength);
    *IsBufferSecure = isSecure;

}   // CalculateGetAllBufferAttributes


VOID
WINAPI
ReleaseObjectSecurityContextW(
    IUnknown * Object
    )
/*++

Routine Description:

    Releases any security context associated with the specified object.

Arguments:

    Object - The object.

Return Value:

    None.

--*/
{

    ADM_SECURE_DATA * data;

    //
    // Find the data associated with the object.
    //

    data = ADM_SECURE_DATA::FindAndReferenceServerSecureData(
               Object,
               FALSE                // CreateIfNotFound
               );

    if( data != NULL ) {

        //
        // Dereference the secure data object *twice*, once
        // to remove the reference added above, and once to
        // remove the "active" reference.
        //

        data->Dereference();
        data->Dereference();
    }
    else {

        ADM_GUID_MAP *pguidmapData;

        pguidmapData = ADM_GUID_MAP::FindAndReferenceGuidMap( Object );

        if( pguidmapData == NULL ) {
#if 0       // stop whining
            DBGPRINTF((
                DBG_CONTEXT,
                "ReleaseObjectSecurityContextW: cannot find data for %08lx\n",
                Object
                ));
#endif      // stop whining
        }

        else {
            //
            // Dereference the secure data object *twice*, once
            // to remove the reference added above, and once to
            // remove the "active" reference.
            //

            pguidmapData->Dereference();
            pguidmapData->Dereference();

        }

    }

}   // ReleaseObjectSecurityContextW


extern "C" {

ULONG
STDMETHODCALLTYPE
Hooked_IUnknown_Release_Proxy(
    IUnknown __RPC_FAR * This
    )
/*++

Routine Description:

    This is the hooked IUnknown::Release() method (see IADMXP.C for
    details).

Arguments:

    This - The object being released.

Return Value:

    ULONG - The updated reference count.

--*/
{

    ULONG result;

    //
    // AddRef and Release to find out if this is the final release. If so,
    // destroy any security context associated with this object.
    // This must be done before the final Release, to avoid a window
    // between the object getting freed and the security info getting
    // removed from the lists.
    //

    IUnknown_AddRef_Proxy( This );
    result = IUnknown_Release_Proxy( This );

    if( result == 1 ) {
        ReleaseObjectSecurityContextW( This );
    }

    //
    // Call the original release method.
    //

    result = IUnknown_Release_Proxy( This );

    return result;

}   // Hooked_IUnknown_Release_Proxy

}   // extern "C"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\dcomadm\mdutil\jd_misc.h ===
#if !defined (JD_MISC_H)
#define JD_MISC_H 

/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    jd_misc.h

Abstract:
	header file for jd_misc.cpp


Author:

    jaroslad  

Revision History:
    06-01-96      ( Jaroslad ) Original.

--*/

#include <windows.h>

int random(int low, int high);


enum Tptr_type {TYPE_TCHAR,TYPE_INT,TYPE_LONG, TYPE_WORD,TYPE_DWORD,TYPE_LPCTSTR};
enum Topt_mand {OPT,MAND}; // switches can be optional or mandatory


struct SParamDef
{
	_TCHAR *sw;     // letter for switch
	int  param_number; //number of parameters (0-zero,1 means exactly one,
					   // >1 means not more param than
	void * ptr;  // pointer to assign value of switch (depends on sw_type)
    
	enum Tptr_type  ptr_type;
	enum Topt_mand  opt_mand;

	_TCHAR * text_desc;  //description for usage print
	_TCHAR * text_param; //what param the switch requires 
					   //(if in usage is '...-c [file]' text_param is "file" )
	WORD * param_read; //same as curr_param_read, but used to export value to caller
	WORD  curr_param_read; // current nuber of params already assigned to ptr;
						// applies only with param_number >1
};
typedef struct SParamDef TParamDef;


void DisplayUsageAndExit( _TCHAR **argv, TParamDef *tt);
void DisplayUsage( _TCHAR **argv, TParamDef *tt);

void ParseParam(int argc, _TCHAR ** argv, TParamDef * tt);

int time_printf(_TCHAR *format, ...);

void fatal_error_printf(_TCHAR *format, ...);
void error_printf(_TCHAR *format, ...);




#define YES			TRUE
#define NO			FALSE

#define SUCCESS     TRUE
#define FAILURE     FALSE

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\dcomadm\mdutil\ansimeta.h ===
/*++

   Copyright    (c)    1997    Microsoft Corporation

   Module  Name :

       ansimeta.h

   Abstract:

        WRAPPER functions for ANSI calls of UNICODE ADMCOM interface

   Environment:

      Win32 User Mode

   Author:

      jaroslad  (jan 1997)

--*/

#ifndef _ANSIMETA__H
#define _ANSIMETA__H

#include <tchar.h>
#include <afx.h>

#include <iadmw.h>




class ANSI_smallIMSAdminBase
    {

        
    public:
		IMSAdminBase * m_pcAdmCom;   //interface pointer to Metabase Admin

		ANSI_smallIMSAdminBase (){m_pcAdmCom=0;};

	  void SetInterfacePointer(IMSAdminBase * a_pcAdmCom) {a_pcAdmCom = m_pcAdmCom;}
          virtual HRESULT STDMETHODCALLTYPE AddKey( 
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath) ;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteKey( 
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath) ;
        
        
        virtual HRESULT STDMETHODCALLTYPE EnumKeys( 
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
            /* [size_is][out] */ unsigned char __RPC_FAR *pszMDName,
            /* [in] */ DWORD dwMDEnumObjectIndex) ;
        
        virtual HRESULT STDMETHODCALLTYPE CopyKey( 
            /* [in] */ METADATA_HANDLE hMDSourceHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDSourcePath,
            /* [in] */ METADATA_HANDLE hMDDestHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDDestPath,
            /* [in] */ BOOL bMDOverwriteFlag,
            /* [in] */ BOOL bMDCopyFlag) ;
        
        virtual HRESULT STDMETHODCALLTYPE RenameKey( 
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDNewName) ;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE SetData( 
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
            /* [in] */ PMETADATA_RECORD pmdrMDData) ;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetData( 
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
            /* [out][in] */ PMETADATA_RECORD pmdrMDData,
            /* [out] */ DWORD __RPC_FAR *pdwMDRequiredDataLen) ;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteData( 
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
            /* [in] */ DWORD dwMDIdentifier,
            /* [in] */ DWORD dwMDDataType) ;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE EnumData( 
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
            /* [out][in] */ PMETADATA_RECORD pmdrMDData,
            /* [in] */ DWORD dwMDEnumDataIndex,
            /* [out] */ DWORD __RPC_FAR *pdwMDRequiredDataLen) ;
        
        
        virtual HRESULT STDMETHODCALLTYPE CopyData( 
            /* [in] */ METADATA_HANDLE hMDSourceHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDSourcePath,
            /* [in] */ METADATA_HANDLE hMDDestHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDDestPath,
            /* [in] */ DWORD dwMDAttributes,
            /* [in] */ DWORD dwMDUserType,
            /* [in] */ DWORD dwMDDataType,
            /* [in] */ BOOL bMDCopyFlag) ;
        
        virtual HRESULT STDMETHODCALLTYPE OpenKey( 
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
            /* [in] */ DWORD dwMDAccessRequested,
            /* [in] */ DWORD dwMDTimeOut,
            /* [out] */ PMETADATA_HANDLE phMDNewHandle) ;
        
        virtual HRESULT STDMETHODCALLTYPE CloseKey( 
            /* [in] */ METADATA_HANDLE hMDHandle) ;
        
        
        virtual HRESULT STDMETHODCALLTYPE SaveData( void) ;
        
     };

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\dcomadm\mdutil\admutil.h ===
/*++

   Copyright    (c)    1997    Microsoft Corporation

   Module  Name :

       admutil.cpp

   Abstract:

        IMSAdminBase interface WRAPPER functions definition

   Environment:

      Win32 User Mode

   Author:

          jaroslad  (jan 1997)

--*/


#if !defined (ADMUTIL_H)
#define ADMUTIL_H

#include <afx.h>
#ifdef UNICODE
	#include <iadmw.h>
#else
	#include "ansimeta.h"
#endif
#include <iwamreg.h>

class CAdmUtil;

//************************************************************************
//CAdmNode DEFINITION
//- store all the complex information about accessing MetaObject or MetaData


class CAdmNode
{
        CString strComputer; //computer to access
        CString strService;
        CString strInstance;
        CString strIPath; //path relative to instance
                                          //(/LM/{strService}/{strInstance}/{strIPath} gives the full path to MEtaObject
        CString strProperty; // name of the MetaData within given Path


        static INT              GetSlashIndex(const CString& strPath, INT iSeqNumber);
        static INT              GetCountOfSlashes(const CString& strPath);
        static CString  GetPartOfPath(const CString& strPath, INT iStart, INT iEnd=-1);

public:
        CAdmNode(const CString& a_strPath=CString("")) {SetPath(a_strPath);};
        void SetPath(CString a_strPath);

        //magic functions to provide various kinds of paths within metabase
        CString GetLMRootPath(void);
        CString GetLMServicePath(void);
        CString GetLMInstancePath(void);
        CString GetLMNodePath(void);
        CString GetServicePath(void);
        CString GetInstancePath(void);
        CString GetNodePath(void);
        CString GetRelPathFromService(void);
        CString GetRelPathFromInstance(void);

        CString GetParentNodePath(void);
        CString GetCurrentNodeName(void);

        //access to METADATA_RECORD items
        CString GetComputer(void)  {return strComputer;};
        CString GetService(void)  {return strService;};
        CString GetInstance(void)  {return strInstance;};
        CString GetIPath(void)  {return strIPath;};
        CString GetProperty(void)  {return strProperty;};

        //setting the METADATA_RECORD items
        void SetComputer(const CString& a_strComputer)  {strComputer=a_strComputer;};
        void SetService(const CString& a_strService)    {strService=a_strService;};
        void SetInstance(const CString& a_strInstance)  {strInstance=a_strInstance;};
        void SetIPath(const CString& a_strIPath)        {strIPath=a_strIPath;};
        void SetProperty(const CString& a_strProperty)  {strProperty=a_strProperty;};


        friend CAdmUtil;
};


//************************************************************************
//CAdmProp DEFINITION
//
// -convenience wrapper for METADATA_RECORD


class CAdmProp
{
        enum {USERTYPESET=0x01,DATATYPESET=0x02,ATTRIBSET=0x04}; //value indicates that the variable was not set
                                                           //0 cannot be used, because that is valid value
        METADATA_RECORD mdr;
        DWORD dwFlags;

public:
        CAdmProp(){dwFlags=0;mdr.dwMDIdentifier=0; mdr.dwMDAttributes=0; mdr.dwMDUserType=0;
                                        mdr.dwMDDataType=0;mdr.pbMDData=0; mdr.dwMDDataLen=0;};
        CAdmProp(METADATA_RECORD &a_mdr);
	CAdmProp(const CString &a_strProperty);
        void SetIdentifier(DWORD a_dwIdentif) {mdr.dwMDIdentifier=a_dwIdentif;};
        void SetAttrib(DWORD a_dwAttrib) {mdr.dwMDAttributes=a_dwAttrib;dwFlags|=ATTRIBSET;};
        void SetUserType(DWORD a_dwUserType) {mdr.dwMDUserType=a_dwUserType;dwFlags|=USERTYPESET;};
        void SetDataType(DWORD a_dwDataType) {mdr.dwMDDataType=a_dwDataType;dwFlags|=DATATYPESET;};

        BOOL IsSetAttrib(void)
                { return (((dwFlags&ATTRIBSET)!=0)?TRUE:FALSE); };
        BOOL IsSetUserType(void)
                {return (((dwFlags&USERTYPESET)!=0)?TRUE:FALSE); };
        BOOL IsSetDataType(void)
                {return (((dwFlags&DATATYPESET)!=0)?TRUE:FALSE); };


        DWORD GetAttrib(void) {return mdr.dwMDAttributes;};
        DWORD GetDataType(void) {return mdr.dwMDDataType;};
        DWORD GetUserType(void) {return mdr.dwMDUserType;};
        DWORD GetIdentifier(void) {return mdr.dwMDIdentifier;};
        PBYTE GetMDData(void) {return mdr.pbMDData;};
        DWORD GetMDDataLen(void) {return mdr.dwMDDataLen;};

        void SetValue(DWORD a_dwValue);
        void SetValue(CString a_strValue);
        void SetValue(LPCTSTR *a_lplpszValue, DWORD a_dwValueCount); //for multisz
        void SetValue(LPBYTE pbValue, DWORD dwValueLength ); //for binary
        BOOL SetValueByDataType(LPCTSTR *a_lplpszPropValue,DWORD* a_lpdwPropValueLength,WORD a_wPropValueCount);

        void PrintProperty(void);


        virtual void Print(const _TCHAR *format,...);


        friend CAdmUtil;
};

//************************************************************************
//CAdmUtil DEFINITION
//
//-convenience wrapper for calling IMSAdminBase interface functions

//defined in admutil.cpp
extern DWORD g_dwTIMEOUT_VALUE;
extern DWORD g_dwDELAY_AFTER_OPEN_VALUE;


class CAdmUtil
{
        static enum {
                DEFAULTBufferSize=4
        };

#ifdef UNICODE
        IMSAdminBase * pcAdmCom;   //interface pointer to Metabase Admin
#else
		ANSI_smallIMSAdminBase * pcAdmCom;   //interface pointer to Metabase Admin Ansi Wrapper
#endif
		IWamAdmin*	pIWamAdm; //interface pointer to Wam Admin
		IWamAdmin2*	pIWamAdm2; //interface pointer to Wam Admin

		METADATA_HANDLE m_hmd;    //metabase handle that micht be reused for sequence of commands
		CString m_strNodePath;    //related to m_hmd - if h_hmd!=NULL it points to m_strNodePath
		DWORD m_dwPermissionOfhmd; //related to m_hmd

        PBYTE pbDataBuffer;   //buffer to get data from METABASE (used for METADATA_RECORD)
        WORD wDataBufferSize; //size of the above buffer
protected:
        BOOL fPrint ; //print Error messages
        HRESULT hresError;    //store the last HRESULT of calling interface IMSAdminBase interface function
                                                  // this is used to store some other error as is OUT_OF_MEMORY or INVALID_PARAMETER



        //with wIndex it is possible to open more than one METADATA object, opening multiple object is not available outside the class
        void OpenObject(WORD wIndex, LPCSTR lpszService,WORD wInstance, LPCSTR lpszPath, DWORD dwPermission=METADATA_PERMISSION_WRITE+METADATA_PERMISSION_READ, BOOL fCreate=TRUE);
        void CloseObject(WORD wIndex);

        METADATA_HANDLE OpenObjectTo_hmd(CAdmNode & a_AdmNode,
                        DWORD dwPermission=METADATA_PERMISSION_READ|METADATA_PERMISSION_WRITE,
                        BOOL fCreate=FALSE);
		void CloseObject_hmd(void);

public:
        CAdmUtil(const CString & strComputer=CString(""));
        ~CAdmUtil();
#ifdef UNICODE
		IMSAdminBase * GetpcAdmCom(void) {return pcAdmCom;};
#else
		IMSAdminBase * GetpcAdmCom(void) {return (pcAdmCom==0)?0:pcAdmCom->m_pcAdmCom;};
#endif

        //connect to computer, call class factory for IMSAdminBase
        void Open(const CString & strComputer);
        //close connection to computer, throw away IMSAdminBase
        void Close(void);


        //OPEN , CLOSE, CREATE, DELETE, COPY METAOBJECT
        METADATA_HANDLE OpenObject(CAdmNode & a_AdmNode,
                                                DWORD dwPermission=METADATA_PERMISSION_READ|METADATA_PERMISSION_WRITE,
                                                BOOL fCreate=FALSE);
        void CloseObject(METADATA_HANDLE hmd);
        void CreateObject(CAdmNode & a_AdmNode);
        void DeleteObject(CAdmNode& a_AdmNode, CAdmProp& a_AdmProp);
        void DeleteObject(METADATA_HANDLE a_hmd, CString& a_strNodeNameToDelete);
        void CopyObject(CAdmNode&       a_AdmNode,  CAdmNode&   a_AdmNodeDst);
        void RenameObject(CAdmNode&     a_AdmNode,  CAdmNode&   a_AdmNodeDst);

        void GetProperty(CAdmNode& a_AdmNode, CAdmProp& a_AdmProp);

        void SetProperty(CAdmNode& a_AdmNode, CAdmProp& a_AdmProp);
        void SetProperty(PMETADATA_RECORD a_pmdrData, METADATA_HANDLE a_hmd);

        void DeleteProperty(CAdmNode& a_AdmNode, CAdmProp& a_AdmProp);
        void DeleteProperty(PMETADATA_RECORD a_pmdrData, METADATA_HANDLE a_hmd);

        //ENUMERATE
        void EnumPropertiesAndPrint(CAdmNode& a_AdmNode,
                                                                          CAdmProp a_AdmProp,
                                                                          BYTE bRecurLevel,         // =0
                                                                          METADATA_HANDLE a_hmd,    // =0
                                                                          CString & a_strRelPath);  // = CString("")
        void EnumAndPrint(CAdmNode&     a_AdmNode,
                                                        CAdmProp&       a_AdmProp,
                                                        BOOL            a_fRecursive,   // =FALSE
                                                        BYTE            a_bRecurLevel,  // =0
                                                        METADATA_HANDLE a_hmd,          // =0
                                                        CString&        a_strRelPath);  // CString("")
        //SAVE METABASE DATA
        void SaveData(void);

        //FUNCTION TO RUN CHOSEN METABASE COMMAND WITH GIVEN PARAMATERS
        void Run(CString& strCommand,                       //command to run
                         CAdmNode& a_AdmNode,               //PATH TO METABASE OBJECT
                         CAdmProp& a_AdmProp,               //METADATA object
                         CAdmNode& a_AdmDstNode,            //=CAdmNode(""), //DESTINATION PATH (as used for COPY)
                         LPCTSTR *a_lplpszPropValue=0,      //VALUES TO BE STORED (for SET command)
                         DWORD *a_lpdwPropValueLength=0,    //LENGTH OF VALUES TO BE STORED (for SET command)
                         WORD wPropValueCount=0);           //NUMBER OF VALUES TO BE STORED

        //virtual functions for Error and regular messages to be printed.
        // these can be redefined in order to fit custom needs
        virtual void Error(const _TCHAR * format,...);
        virtual void Print(const _TCHAR * format,...);

        //Disable and enable to print error or regular messages
        void EnablePrint(void) {fPrint=TRUE;};
        void DisablePrint(void) {fPrint=FALSE;};

        HRESULT QueryLastHresError(void) {return hresError;};
        void SetLastHresError(HRESULT hr) {hresError=hr;};

	//defined in vptool
	void OpenWamAdm(const CString & strComputer);
	void CloseWamAdm(void);
	void AppCreateInProc(const _TCHAR* szPath,const CString & strComputer);
	void AppCreateOutPool(const _TCHAR* szPath,const CString & strComputer);
	void AppCreateOutProc(const _TCHAR* szPath,const CString & strComputer);
	void AppDelete(const _TCHAR* szPath,const CString & strComputer);
        void AppRename(CAdmNode& a_AdmNode, CAdmNode& a_AdmDstNode, const CString & strComputer);
	void AppUnLoad(const _TCHAR* szPath,const CString & strComputer);
	void AppGetStatus(const _TCHAR* szPath,const CString & strComputer);

};


//runs administration command based on given parameters



LPTSTR ConvertHresToString(HRESULT hRes);
DWORD ConvertHresToDword(HRESULT hRes);
LPTSTR ConvertReturnCodeToString(DWORD ReturnCode);

CString FindCommonPath(CString a_strPath1,CString a_strPath2);

#define M_LOCAL_MACHINE "/LM/"


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\dcomadm\mdutil\ansimeta.cpp ===
/*++

   Copyright    (c)    1997    Microsoft Corporation

   Module  Name :

       ansimeta.cpp

   Abstract:

        WRAPPER functions for ANSI calls of UNICODE ADMCOM interface

   Environment:

      Win32 User Mode

   Author:

      jaroslad  (jan 1997)

--*/


#include "ansimeta.h"

#include <mbstring.h>


WCHAR * ConvertToUnicode(unsigned char * pszString);


WCHAR * ConvertToUnicode(CHAR * pszString)
{
    return ConvertToUnicode((unsigned char *) pszString);
}

WCHAR * ConvertToUnicode(unsigned char * pszString)
{
    if (pszString==NULL)
        return NULL;
    int Size_wszString = (int)(_mbslen((const unsigned char *) pszString)+1)*sizeof(WCHAR);
    WCHAR * pwszString = new WCHAR[Size_wszString];
    if (pwszString== NULL)
    {
        return NULL;
    }
    MultiByteToWideChar(0, 0, (char *) pszString, -1, pwszString, Size_wszString);
    return pwszString;
}


CHAR * ConvertToMultiByte(WCHAR * pwszString)
{
    if(pwszString==NULL)
        return NULL;
    int Size_szString = (int)(wcslen(pwszString)*sizeof(WCHAR)+1);
    CHAR * pszString = new CHAR[Size_szString];
    if (pszString== NULL)
    {
        return NULL;
    }
    WideCharToMultiByte(0, 0, pwszString, -1, pszString,Size_szString, NULL,NULL );
    return pszString;
}


HRESULT ConvertMetadataToAnsi(PMETADATA_RECORD pmdrMDData)
{
        HRESULT hRes=ERROR_SUCCESS;

        //convert data if STRING, EXPAND STRING or MULTISZ
        switch(pmdrMDData->dwMDDataType )
        {
        case STRING_METADATA:
            case EXPANDSZ_METADATA:
        {
            CHAR * pszData= ConvertToMultiByte((WCHAR *) pmdrMDData->pbMDData);
            if (pszData==0)  {hRes=E_OUTOFMEMORY; goto Exit;}
            strcpy((char *)pmdrMDData->pbMDData,pszData);
            pmdrMDData->dwMDDataLen=(DWORD)strlen((char *)pmdrMDData->pbMDData)+1;
            delete [] pszData;
            break;
        }
        case MULTISZ_METADATA:
        {
            WCHAR *pwszMultiString = (WCHAR *) pmdrMDData->pbMDData;
            DWORD dwAnsiDataLen=0;
            do
            {
                CHAR * pszData= ConvertToMultiByte(pwszMultiString);
                if (pszData==0)  {hRes=E_OUTOFMEMORY; goto Exit;}
                strcpy((char *)(pmdrMDData->pbMDData)+dwAnsiDataLen,pszData);
                dwAnsiDataLen+=(DWORD)strlen(pszData)+1;
                pwszMultiString+=_mbslen((const unsigned char *)pszData)+1; //move pointer to the next string in MULTISZ
                delete [] pszData;

            }while((void *) pwszMultiString < (void *) (pmdrMDData->pbMDData+pmdrMDData->dwMDDataLen));

            pmdrMDData->dwMDDataLen=dwAnsiDataLen;
            break;
        }
        }
Exit:
    return hRes;
}

HRESULT STDMETHODCALLTYPE ANSI_smallIMSAdminBase::AddKey(
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath)
{
    HRESULT hRes=0;
    WCHAR * pwszMDPath=ConvertToUnicode(pszMDPath);
    if (pwszMDPath==0) { hRes=E_OUTOFMEMORY; goto Exit;}

    //call real interface function
    if(this->m_pcAdmCom==0) {hRes=CO_E_NOTINITIALIZED;goto Exit;}
    hRes= this->m_pcAdmCom->AddKey(hMDHandle, pwszMDPath);

Exit:
    //release memory
    if( pwszMDPath!=0) delete [] pwszMDPath;
    return hRes;
}


HRESULT STDMETHODCALLTYPE ANSI_smallIMSAdminBase::DeleteKey(
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath)
{
    HRESULT hRes=0;
    WCHAR * pwszMDPath=ConvertToUnicode(pszMDPath);

    if (pwszMDPath==0) { hRes=E_OUTOFMEMORY; goto Exit;}

    //call real interface function
    if(this->m_pcAdmCom==0) {hRes=CO_E_NOTINITIALIZED;goto Exit;}
    if(this->m_pcAdmCom==0) {hRes=CO_E_NOTINITIALIZED;goto Exit;}
    hRes= this->m_pcAdmCom->DeleteKey(hMDHandle, pwszMDPath);

Exit:
    //release memory
    if( pwszMDPath!=0) delete [] pwszMDPath;
    return hRes;

}


 HRESULT STDMETHODCALLTYPE ANSI_smallIMSAdminBase::EnumKeys(
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
            /* [size_is][out] */ unsigned char __RPC_FAR *pszMDName,
            /* [in] */ DWORD dwMDEnumObjectIndex)
{
    HRESULT hRes=0;
    CHAR * pszMDName1=0;

    WCHAR * pwszMDPath=ConvertToUnicode(pszMDPath);
    WCHAR pwszMDName[METADATA_MAX_NAME_LEN];


    if ((pwszMDPath==0) || (pwszMDName==0)) { hRes=E_OUTOFMEMORY; goto Exit;}

    //call real interface function
    if(this->m_pcAdmCom==0) {hRes=CO_E_NOTINITIALIZED;goto Exit;}
    hRes= this->m_pcAdmCom->EnumKeys(hMDHandle, pwszMDPath,pwszMDName,dwMDEnumObjectIndex);

    //convert pszMDName to ANSI
    pszMDName1=ConvertToMultiByte(pwszMDName);
    strcpy((char *)pszMDName,pszMDName1);
Exit:
    //release memory
    if( pwszMDPath!=0) delete [] pwszMDPath;
    if( pszMDName1!=0) delete [] pszMDName1;
    return hRes;
}



 HRESULT STDMETHODCALLTYPE ANSI_smallIMSAdminBase::CopyKey(
            /* [in] */ METADATA_HANDLE hMDSourceHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDSourcePath,
            /* [in] */ METADATA_HANDLE hMDDestHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDDestPath,
            /* [in] */ BOOL bMDOverwriteFlag,
            /* [in] */ BOOL bMDCopyFlag)

{
    HRESULT hRes=0;

    WCHAR * pwszMDSourcePath=ConvertToUnicode(pszMDSourcePath);
    WCHAR * pwszMDDestPath=ConvertToUnicode(pszMDDestPath);

    if ((pwszMDSourcePath==0) || (pwszMDDestPath==0) ){ hRes=E_OUTOFMEMORY; goto Exit;}

    //call real interface function
    if(this->m_pcAdmCom==0) {hRes=CO_E_NOTINITIALIZED;goto Exit;}
    hRes= this->m_pcAdmCom->CopyKey(hMDSourceHandle, pwszMDSourcePath,
                    hMDDestHandle, pwszMDDestPath, bMDOverwriteFlag, bMDCopyFlag);
Exit:
    //release memory
    if( pwszMDSourcePath!=0) delete [] pwszMDSourcePath;
    if( pwszMDDestPath!=0) delete [] pwszMDDestPath;
    return hRes;
}




 HRESULT STDMETHODCALLTYPE ANSI_smallIMSAdminBase::RenameKey(
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDNewName)
{
    HRESULT hRes=0;

    WCHAR * pwszMDPath=ConvertToUnicode(pszMDPath);
    WCHAR * pwszMDNewName=ConvertToUnicode(pszMDNewName);

    if ((pwszMDPath==0) || (pwszMDNewName==0)) { hRes=E_OUTOFMEMORY; goto Exit;}

    //call real interface function
    if(this->m_pcAdmCom==0) {hRes=CO_E_NOTINITIALIZED;goto Exit;}
    hRes= this->m_pcAdmCom->RenameKey(hMDHandle, pwszMDPath,pwszMDNewName);
Exit:
    //release memory
    if( pwszMDPath!=0) delete [] pwszMDPath;
    if( pwszMDNewName!=0) delete [] pwszMDNewName;
    return hRes;
}





 HRESULT STDMETHODCALLTYPE ANSI_smallIMSAdminBase::SetData(
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
            /* [in] */ PMETADATA_RECORD pmdrMDData)
{
    HRESULT hRes=0;
    WCHAR *pwszMDData = NULL;
    WCHAR * pwszMDPath=ConvertToUnicode(pszMDPath);

    if (pwszMDPath==0) { hRes=E_OUTOFMEMORY; goto Exit;}

    //call real interface function
    if(this->m_pcAdmCom==0) {hRes=CO_E_NOTINITIALIZED;goto Exit;}


    //convert data if STRING, EXPAND STRING or MULTISZ
    switch(pmdrMDData->dwMDDataType )
    {
    case STRING_METADATA:
    case EXPANDSZ_METADATA:
    {
        WCHAR * pwszData= ConvertToUnicode((CHAR *) pmdrMDData->pbMDData);
        if (pwszData==0)  {hRes=E_OUTOFMEMORY; goto Exit;}
        PBYTE  pbMDStoreData=pmdrMDData->pbMDData;
        DWORD dwMDStoreDataLen=pmdrMDData->dwMDDataLen;
        pmdrMDData->pbMDData= (PBYTE) pwszData;
        pmdrMDData->dwMDDataLen=(DWORD)(wcslen((WCHAR *)pmdrMDData->pbMDData)+1)*sizeof(WCHAR);

        hRes= this->m_pcAdmCom->SetData(hMDHandle, pwszMDPath,pmdrMDData);

        pmdrMDData->dwMDDataLen = dwMDStoreDataLen;
        pmdrMDData->pbMDData = pbMDStoreData;
        delete [] pwszData;
        break;
    }
    case MULTISZ_METADATA:
    {
        CHAR *pszMultiString = (CHAR *) pmdrMDData->pbMDData;
        pwszMDData=new WCHAR[(pmdrMDData->dwMDDataLen)];
        if (pwszMDData==0)  {hRes=E_OUTOFMEMORY; goto Exit;}
        DWORD dwUniDataLen=0;
        do
        {
            WCHAR * pwszData= ConvertToUnicode(pszMultiString);
            if (pwszData==0)  {hRes=E_OUTOFMEMORY; goto Exit;}
            wcscpy(pwszMDData+dwUniDataLen,pwszData);
            dwUniDataLen+=(DWORD)wcslen(pwszData)+1;
            delete [] pwszData;

            while(*(pszMultiString++)!=0); //move pointer to the next string in MULTISZ
        }while(*pszMultiString!=0);
        pwszMDData[dwUniDataLen++]=0;

        //store original values
        PBYTE pbMDStoreData=pmdrMDData->pbMDData;
        DWORD dwMDStoreDataLen=pmdrMDData->dwMDDataLen;

        pmdrMDData->dwMDDataLen=dwUniDataLen*sizeof(WCHAR);
        pmdrMDData->pbMDData= (PBYTE) pwszMDData;

        hRes= this->m_pcAdmCom->SetData(hMDHandle, pwszMDPath,pmdrMDData);

        delete [] pwszMDData;
        pwszMDData = NULL;

        //restore original values
        pmdrMDData->dwMDDataLen = dwMDStoreDataLen;
        pmdrMDData->pbMDData = pbMDStoreData;
        break;
    }
    default:
    {
        hRes= this->m_pcAdmCom->SetData(hMDHandle, pwszMDPath,pmdrMDData);
    }
    } //end of switch

Exit:
    //release memory
    if( pwszMDPath!=0) delete [] pwszMDPath;
    if( pwszMDData ) delete [] pwszMDData;
    return hRes;
}



 HRESULT STDMETHODCALLTYPE ANSI_smallIMSAdminBase::GetData(
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
            /* [out][in] */ PMETADATA_RECORD pmdrMDData,
            /* [out] */ DWORD __RPC_FAR *pdwMDRequiredDataLen)
{
    HRESULT hRes=0;
    WCHAR * pwszMDPath=ConvertToUnicode(pszMDPath);

    if (pwszMDPath==0) { hRes=E_OUTOFMEMORY; goto Exit;}

    //call real interface function
    if(this->m_pcAdmCom==0) {hRes=CO_E_NOTINITIALIZED;goto Exit;}
    hRes= this->m_pcAdmCom->GetData(hMDHandle, pwszMDPath,pmdrMDData,pdwMDRequiredDataLen);
    if(SUCCEEDED(hRes))
    {
        ConvertMetadataToAnsi(pmdrMDData);
    }

Exit:
    //release memory
    if( pwszMDPath!=0) delete [] pwszMDPath;
    return hRes;
}



 HRESULT STDMETHODCALLTYPE ANSI_smallIMSAdminBase::DeleteData(
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
            /* [in] */ DWORD dwMDIdentifier,
            /* [in] */ DWORD dwMDDataType)
{
    HRESULT hRes=0;
    WCHAR * pwszMDPath=ConvertToUnicode(pszMDPath);

    if (pwszMDPath==0) { hRes=E_OUTOFMEMORY; goto Exit;}

    //call real interface function
    if(this->m_pcAdmCom==0) {hRes=CO_E_NOTINITIALIZED;goto Exit;}
    hRes= this->m_pcAdmCom->DeleteData(hMDHandle, pwszMDPath,dwMDIdentifier,dwMDDataType);

Exit:
    //release memory
    if( pwszMDPath!=0) delete [] pwszMDPath;
    return hRes;
}


 HRESULT STDMETHODCALLTYPE ANSI_smallIMSAdminBase::EnumData(
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
            /* [out][in] */ PMETADATA_RECORD pmdrMDData,
            /* [in] */ DWORD dwMDEnumDataIndex,
            /* [out] */ DWORD __RPC_FAR *pdwMDRequiredDataLen)

{
    HRESULT hRes=0;
    WCHAR * pwszMDPath=ConvertToUnicode(pszMDPath);

    if (pwszMDPath==0) { hRes=E_OUTOFMEMORY; goto Exit;}

    //call real interface function
    if(this->m_pcAdmCom==0) {hRes=CO_E_NOTINITIALIZED;goto Exit;}
    hRes= this->m_pcAdmCom->EnumData(hMDHandle, pwszMDPath,pmdrMDData,dwMDEnumDataIndex,pdwMDRequiredDataLen);
    if(SUCCEEDED(hRes))
    {
        ConvertMetadataToAnsi(pmdrMDData);
    }

Exit:
    //release memory
    if( pwszMDPath!=0) delete [] pwszMDPath;
    return hRes;
}

 HRESULT STDMETHODCALLTYPE ANSI_smallIMSAdminBase::CopyData(
            /* [in] */ METADATA_HANDLE hMDSourceHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDSourcePath,
            /* [in] */ METADATA_HANDLE hMDDestHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDDestPath,
            /* [in] */ DWORD dwMDAttributes,
            /* [in] */ DWORD dwMDUserType,
            /* [in] */ DWORD dwMDDataType,
            /* [in] */ BOOL bMDCopyFlag)
{
    HRESULT hRes=0;

    WCHAR * pwszMDSourcePath=ConvertToUnicode(pszMDSourcePath);
    WCHAR * pwszMDDestPath=ConvertToUnicode(pszMDDestPath);


    if ((pwszMDSourcePath==0) || (pwszMDDestPath==0) ) { hRes=E_OUTOFMEMORY; goto Exit;}

    //call real interface function
    if(this->m_pcAdmCom==0) {hRes=CO_E_NOTINITIALIZED;goto Exit;}
    hRes= this->m_pcAdmCom->CopyData(hMDSourceHandle, pwszMDSourcePath,
                    hMDDestHandle, pwszMDDestPath, dwMDAttributes,
                    dwMDUserType,dwMDDataType,bMDCopyFlag);
Exit:
    //release memory
    if( pwszMDSourcePath!=0) delete [] pwszMDSourcePath;
    if( pwszMDDestPath!=0) delete [] pwszMDDestPath;

    return hRes;
}

 HRESULT STDMETHODCALLTYPE ANSI_smallIMSAdminBase::OpenKey(
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
            /* [in] */ DWORD dwMDAccessRequested,
            /* [in] */ DWORD dwMDTimeOut,
            /* [out] */ PMETADATA_HANDLE phMDNewHandle)
{
    HRESULT hRes=0;
    WCHAR * pwszMDPath=ConvertToUnicode(pszMDPath);

    if (pwszMDPath==0) { hRes=E_OUTOFMEMORY; goto Exit;}

    //call real interface function
    if(this->m_pcAdmCom==0) {hRes=CO_E_NOTINITIALIZED;goto Exit;}
    hRes= this->m_pcAdmCom->OpenKey(hMDHandle, pwszMDPath, dwMDAccessRequested, dwMDTimeOut, phMDNewHandle);

Exit:
    //release memory
    if( pwszMDPath!=0) delete [] pwszMDPath;
    return hRes;
}

 HRESULT STDMETHODCALLTYPE ANSI_smallIMSAdminBase::CloseKey(
            /* [in] */ METADATA_HANDLE hMDHandle)
{
    if(this->m_pcAdmCom==0) { return CO_E_NOTINITIALIZED;}
    return this->m_pcAdmCom->CloseKey(hMDHandle);

}

 HRESULT STDMETHODCALLTYPE ANSI_smallIMSAdminBase::SaveData( void)
{
    if(this->m_pcAdmCom==0) {return CO_E_NOTINITIALIZED;}
    return this->m_pcAdmCom->SaveData();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\dcomadm\mdutil\jd_misc.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    jd_misc.cpp

Abstract:
	variety of assisting functions
	  - command line parameters parsing
	  - displaying the error messages
	  - creating the random file
          - creating the unique identifier based on thread and process
Author:

    jaroslad

Revision History:
     06-01-96      ( Jaroslad ) Original.

--*/

#include <tchar.h>
#include "jd_misc.h"

#include <stdio.h>
#include <stdarg.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <windows.h>

int random (int low, int high)
{
	return ( low+((long)rand()*(long)high)/RAND_MAX );
}


/* Sample structure demonstating how to use comand line definition structure

  TParamDef CmdLineParam[]=
{
 {"c" ,1, &FtpServerIpAddr,TYPE_TCHAR,OPT, "ftp server computer name", "computer"},
 {"b", 0, &fStop,       TYPE_INT,  OPT, "binary flag"},
 {"start", 0, &fStart,     TYPE_INT,  OPT, "start service"},
 {"pause", 0, &fPause,     TYPE_INT,  OPT, "pause service"},
 {"s" ,1, &ServiceName,    TYPE_TCHAR, MAND,"service name","svc"},

 { {NULL,0, NULL ,         TYPE_TCHAR, OPT, "Place the description of the program here" };

*/

void DisplayUsage( _TCHAR **argv, TParamDef *tt)
{
	_tprintf(_T("Usage:\n\t%s "), argv[0]);
	for(int i=0; tt[i].sw!=0;i++)
	{
		if(tt[i].sw[0]==0) //default (do not need switch) parameters
		{
			_tprintf(_T("%s "),(tt[i].text_param!=NULL)?tt[i].text_param:_T("parm"));
		}
		else
		{
			_tprintf(_T("-%s "),tt[i].sw);
			if(tt[i].param_number==1)
				_tprintf(_T("[%s] "),(tt[i].text_param!=NULL)?tt[i].text_param:_T("parm"));
			else if(tt[i].param_number>1)
				_tprintf(_T("[[%s]...] "),(tt[i].text_param!=NULL)?tt[i].text_param:_T("parm"));
		}
	}

	_tprintf(_T("\n\n"));
	for(i=0; tt[i].sw!=0; i++)
	{
		if(tt[i].sw[0]==0) //default parameters
		{
			_tprintf(_T("\"no switch\"  %s\n"),tt[i].text_desc);
		}
		else if(tt[i].text_desc!=NULL)
		{
			_tprintf(_T("-%-6s %s\n"),tt[i].sw,tt[i].text_desc);
		}
	}
	//print description
	if( tt[i].text_desc!=NULL && tt[i].text_desc[0]!=0)
	{
		_tprintf(_T("\nDescription:\n"));
		_tprintf(_T("%s \n"), tt[i].text_desc);
	}
}

void DisplayUsageAndExit( _TCHAR **argv, TParamDef *tt)
{
	DisplayUsage( argv, tt);

	exit(1);
}

//structure that makes easy lexical parsing of the command line arguments

struct sParamLex
{
	int argc;
	TCHAR **argv;
	_TCHAR ParamBuffer[400];
	int iCurrentParamChar;  //character index within the current parameter being processed
	int iCurrentParam;      //index to the current parameter that is processed
public:
	sParamLex(int argc,_TCHAR **argv):argc(argc),argv(argv){iCurrentParamChar=0; iCurrentParam=1;};
	BOOL IsNextSwitch();
	BOOL IsEnd();
	LPTSTR ReadNext();
};

BOOL sParamLex::IsNextSwitch()
{
	if(IsEnd())
		return FALSE;
	if (argv[iCurrentParam][iCurrentParamChar]==_T('-'))
		return TRUE;
	else
		return FALSE;
}

BOOL sParamLex::IsEnd()
{
	if(iCurrentParam>=argc)
		return TRUE;
	else
		return FALSE;
}

LPTSTR sParamLex::ReadNext()
{
	LPTSTR lpszRetval;
	if (IsEnd())
		return NULL;
	if(IsNextSwitch())
	{	int i=0;
		iCurrentParamChar++; //skip '/' or '-'
		while (argv[iCurrentParam][iCurrentParamChar]!=0 && argv[iCurrentParam][iCurrentParamChar]!=_T(':'))
			ParamBuffer[i++]=argv[iCurrentParam][iCurrentParamChar++];
		if(argv[iCurrentParam][iCurrentParamChar]==_T(':'))
			iCurrentParamChar++;
		if(argv[iCurrentParam][iCurrentParamChar]==0)
		{
			iCurrentParam++; iCurrentParamChar=0;
		}
		ParamBuffer[i]=0;
		lpszRetval=ParamBuffer;
	}
	else
	{
		lpszRetval=&argv[iCurrentParam][iCurrentParamChar];
		iCurrentParam++; iCurrentParamChar=0;
	}
	return lpszRetval;
}


void ParseParam(int argc, _TCHAR ** argv, TParamDef * tt)
{

	for(int i=0; tt[i].sw!=NULL ; i++)
	{
		tt[i].curr_param_read=0; //initialize
	}

	sParamLex paramLex(argc,argv);

	BOOL fParseBegin=TRUE;
	while(!paramLex.IsEnd())
	{
		int k=0;
		if(paramLex.IsNextSwitch())
		{
			_TCHAR * sw = paramLex.ReadNext();
			/*find the switch in switch table*/
			for( k=0; tt[k].sw!=NULL ;k++)
			{
				if(tt[k].sw[0]==0) continue; //skip the default parameters
				if(_tcscmp(tt[k].sw, sw)==0 /*equal*/ )
					break;
			}
			if(tt[k].sw == NULL) //switch not found
			{	_tprintf(_T("invalid switch \"%s\"\n"),sw);/*error*/
				DisplayUsageAndExit(argv,tt);
			}
		}
		else if( fParseBegin==TRUE && (_tcscmp(tt[0].sw, _T(""))==0 /*equal*/ ) )
		{
		    //default parameters (has to be the first record in arg description)
			k=0;
		}
		else
		{
			_tprintf(_T("default arguments not expected\n"));/*error*/
			DisplayUsageAndExit(argv,tt);
		}

		if(tt[k].param_number==0) //switch without parameters
		{
			if(paramLex.IsEnd()==FALSE && paramLex.IsNextSwitch()==FALSE)
			{
				_tprintf(_T("switch \"%s\" takes no parameters \n"),tt[k].sw);
				DisplayUsageAndExit(argv,tt);
			}
			tt[k].curr_param_read++;
			*((int *)tt[k].ptr)=1;
		}
		else if(tt[k].param_number>0) //swith with more then 0ne parameter
		{
			if(paramLex.IsEnd()==TRUE || paramLex.IsNextSwitch()==TRUE)
			{  _tprintf(_T(" switch \"%s\" expects parameter\n"),tt[k].sw);//error
				DisplayUsageAndExit(argv,tt);
			}
			else
			{
				_TCHAR * prm;

				do
				{
					prm=paramLex.ReadNext();

					if(tt[k].param_number <= tt[k].curr_param_read)
					{
						_tprintf(_T("number of parameters for switch -%s exceeds maximum allowed (%d)\n"),tt[k].sw,tt[k].param_number);
						DisplayUsageAndExit(argv,tt);
					}


					if(tt[k].ptr_type==TYPE_TCHAR || tt[k].ptr_type==TYPE_LPCTSTR)
						*(((_TCHAR **)tt[k].ptr) + tt[k].curr_param_read++)=prm;
					else if(tt[k].ptr_type==TYPE_INT ||tt[k].ptr_type==TYPE_WORD)
						*(((int *)tt[k].ptr) + tt[k].curr_param_read++)=_ttoi(prm);
					else if(tt[k].ptr_type==TYPE_LONG || tt[k].ptr_type==TYPE_DWORD)
						*(((long *)tt[k].ptr) + tt[k].curr_param_read++)=_ttol(prm);

				}while (paramLex.IsEnd()==FALSE && paramLex.IsNextSwitch()==FALSE);

			}
		}//end tt[k].param_number

	} // end while
	for(i=0; tt[i].sw!=0;i++) //check for mandatory switches
	{
		if (tt[i].opt_mand==MAND && tt[i].curr_param_read==0)
		{
			_tprintf(_T("mandatory switch -%s missing\n"),tt[i].sw);
			DisplayUsageAndExit(argv,tt);
		}

		if(tt[i].param_read!=NULL) // set number of params for switch
			*tt[i].param_read=tt[i].curr_param_read;

	}
}




/******************************************
  time_printf
*******************************************/


int time_printf(_TCHAR *format, ...)
{
   static CRITICAL_SECTION cs;
   static BOOL fInit=0;
   va_list marker;

   if(fInit==0)
   {
	   fInit=1;
	   InitializeCriticalSection(&cs);
   }

   _TCHAR buf[80];

   EnterCriticalSection(&cs);
   va_start( marker, format );     /* Initialize variable arguments. */
   _tprintf(_TEXT("%s - "),_tstrtime(buf));
   _vtprintf(format,marker);
   LeaveCriticalSection(&cs);
   va_end( marker );              /* Reset variable arguments.      */
 //  printf("%s%s",bufa,bufb); //for multithreaded will be printed as one line
   return 1;
}

void error_printf(_TCHAR *format, ...)
{
   va_list marker;

   va_start( marker, format );     /* Initialize variable arguments. */
   _tprintf(_TEXT("Error: "));
   _vftprintf(stderr,format,marker);
   va_end( marker );              /* Reset variable arguments.      */

}

void fatal_error_printf(_TCHAR *format, ...)
{
   va_list marker;

   va_start( marker, format );     /* Initialize variable arguments. */
   _tprintf(_TEXT("Error: "));
   _vftprintf(stderr,format,marker);
   va_end( marker );              /* Reset variable arguments.      */
   exit(EXIT_FAILURE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\dcomadm\mdutil\main.cpp ===
/*++

   Copyright    (c)    1997    Microsoft Corporation

   Module  Name :

       main.cpp

   Abstract:

       command line admin tool main function

   Environment:

      Win32 User Mode

   Author:

      jaroslad  (jan 1997)

--*/

#include <tchar.h>

#include <afx.h>

#include <string.h>
#include <stdlib.h>
#include <stdio.h>


#include "admutil.h"
#include "tables.h"
#include "jd_misc.h"



CAdmUtil oAdmin;  //admin object

#define MAX_NUMBER_OF_SMALL_VALUES  100
#define MAX_NUMBER_OF_VALUES  10100
#define MAX_NUMBER_OF_DEFAULT_ARGS  10110


//structure stores the command line arguments

struct tAdmutilParams
{
    WORD fHelp; //print help - flag
    WORD fFullHelp; //print help - flag
    WORD fNoSave; //do not save metabase
    LPCTSTR lpszCommand;
    LPCTSTR lpszComputer;
    WORD  wInstance;
    LPCTSTR lpszService;
    LPCTSTR lpszPath;
    LPCTSTR lpszComputerDst; //for COPY destination
    WORD  wInstanceDst;     //for COPY destination
    LPCTSTR lpszServiceDst; //for COPY destination
    LPCTSTR lpszPathDst;        //for COPY destination

    LPCTSTR lplpszDefaultArg[MAX_NUMBER_OF_DEFAULT_ARGS];
    WORD wDefaultArgCount;

    LPCTSTR lpszPropName;

    LPCTSTR lplpszPropAttrib[MAX_NUMBER_OF_SMALL_VALUES];
    WORD  wPropAttribCount;
    LPCTSTR lplpszPropDataType[MAX_NUMBER_OF_SMALL_VALUES];
    WORD wPropDataTypeCount;
    LPCTSTR lplpszPropUserType[MAX_NUMBER_OF_SMALL_VALUES];
    WORD wPropUserTypeCount;
    LPCTSTR lplpszPropValue[MAX_NUMBER_OF_VALUES]; //pointer to array of values (e.g multisz type allows the multiple values for one property
    DWORD lpdwPropValueLength[MAX_NUMBER_OF_VALUES];
    WORD  wPropValueCount;
    WORD  wPropFileValueCount;
};

tAdmutilParams Params;
_TCHAR **g_argv;
int g_argc;

static BOOL CompareOutput(_TCHAR *FileToCompare,_TCHAR* FileTemplate);

// definition of command line syntax with some help text -this is the input for ParseParam()

TParamDef CmdLineArgDesc[]=
{
 {_TEXT(""),MAX_NUMBER_OF_DEFAULT_ARGS, (void *) Params.lplpszDefaultArg,TYPE_LPCTSTR,OPT, _TEXT("Command [param ...]"),_TEXT("CMD [param param]"),&Params.wDefaultArgCount},
 {_TEXT("svc") ,1, (void *) &Params.lpszService,TYPE_LPCTSTR,OPT,_TEXT("service (MSFTPSVC, W3SVC)")},
 {_TEXT("s"), 1, (void *) &Params.lpszComputer,TYPE_LPCTSTR,OPT, _TEXT("name of computer to administer"),_TEXT("comp"),},
 {_TEXT("i") ,1, &Params.wInstance, TYPE_WORD, OPT,_TEXT("instance number"),_TEXT("inst")},
 {_TEXT("path"),1, (void *) &Params.lpszPath,   TYPE_LPCTSTR,OPT, _TEXT("path "),_TEXT("path")},
 {_TEXT("pathdst"),1, (void *) &Params.lpszPathDst, TYPE_LPCTSTR,OPT, _TEXT("destination path (use for COPY only)"),_TEXT("path")},
 {_TEXT("prop"),1, (void *) &Params.lpszPropName, TYPE_LPCTSTR,OPT, _T("property (IIS parameter) name")},
 {_TEXT("attrib"),MAX_NUMBER_OF_SMALL_VALUES, (void *) Params.lplpszPropAttrib,TYPE_LPCTSTR,OPT, _T("property attributes"),_T(""),&Params.wPropAttribCount},
 {_TEXT("utype"),MAX_NUMBER_OF_SMALL_VALUES, (void *) Params.lplpszPropUserType,TYPE_LPCTSTR,OPT, _T("property user type"),_T(""),&Params.wPropUserTypeCount},
 {_TEXT("dtype"),MAX_NUMBER_OF_SMALL_VALUES, (void *) Params.lplpszPropDataType,TYPE_LPCTSTR,OPT, _T("property data type"),_T(""),&Params.wPropDataTypeCount},
 {_TEXT("value"),MAX_NUMBER_OF_VALUES, (void *) Params.lplpszPropValue,TYPE_LPCTSTR,OPT, _T("property values"),_T(""),&Params.wPropValueCount},
 {_TEXT("fvalue"),MAX_NUMBER_OF_VALUES, (void *) Params.lplpszPropValue,TYPE_LPCTSTR,OPT, _T("property values as files"),_T(""),&Params.wPropFileValueCount},
 {_TEXT("nosave"),0, &Params.fNoSave,TYPE_WORD,OPT, _T("do not save metabase"),_T("")},
 {_TEXT("timeout"),1, &g_dwTIMEOUT_VALUE,TYPE_DWORD,OPT, _T("timeout for metabase access in ms (default is 30000 sec"),_T("")},
 {_TEXT("delayafteropen"),1, &g_dwDELAY_AFTER_OPEN_VALUE,TYPE_DWORD,OPT, _T("delay after opening node (default is 0 sec)"),_T("")},
 {_TEXT("help"),0, &Params.fFullHelp,TYPE_WORD,OPT, _T("print full help"),_T("")},
 {_TEXT("?"),0, &Params.fHelp,TYPE_WORD,OPT, _T("print help"),_T("")},
  {NULL,0, NULL ,         TYPE_TCHAR, OPT,
   _T("IIS K2 administration utility that enables the manipulation with metabase parameters\n")
   _T("\n")
   _T("Notes:\n")
   _T(" Simpified usage of mdutil doesn't require any switches.\n")
   _T(" \n")
   _T(" mdutil GET      path             - display chosen parameter\n")
   _T(" mdutil SET      path value ...   - assign the new value\n")
   _T(" mdutil ENUM     path             - enumerate all parameters for given path\n")
   _T(" mdutil ENUM_ALL path             - recursively enumerate all parameters\n")
   _T(" mdutil DELETE   path             - delete given path or parameter\n")
   _T(" mdutil CREATE   path             - create given path\n")
   _T(" mdutil COPY     pathsrc pathdst  - copy all from pathsrc to pathdst (will create pathdst)\n")
   _T(" mdutil RENAME   pathsrc pathdst  - rename chosen path\n")
   _T(" mdutil SCRIPT   scriptname       - runs the script\n")
   _T(" mdutil APPCREATEINPROC  w3svc/1/root - Create an in-proc application \n")
   _T(" mdutil APPCREATEOUTPOOL  w3svc/1/root - Create an pooled out-proc application \n")
   _T(" mdutil APPCREATEOUTPROC w3svc/1/root - Create an out-proc application\n")
   _T(" mdutil APPDELETE        w3svc/1/root - Delete the application if there is one\n")
   _T(" mdutil APPRENAME        w3svc/1/root/dira w3svc/1/root/dirb - Rename the application \n")
   _T(" mdutil APPUNLOAD        w3svc/1/root - Unload an application from w3svc runtime lookup table.\n")
   _T(" mdutil APPGETSTATUS     w3svc/1/root - Get status of the application\n")
   _T("\n")
   _T("  -path has format: {computer}/{service}/{instance}/{URL}/{Parameter}\n")
   _T("\n")
   _T("Samples:\n")
   _T("  mdutil GET W3SVC/1/ServerBindings     \n")
   _T("  mdutil SET JAROSLAD2/W3SVC/1/ServerBindings \":81:\"\n")
   _T("  mdutil COPY W3SVC/1/ROOT/iisadmin W3SVC/2/ROOT/adm\n")
   _T("  mdutil ENUM_ALL W3SVC\n")
   _T("  mdutil ENUM W3SVC/1\n")
   _T("\n")
   _T("Additional features\n")
   _T("  set MDUTIL_BLOCK_ON_ERROR environment variable to block mdutil.exe after error (except ERROR_PATH_NOT_FOUND)\n")
   _T("  set MDUTIL_ASCENT_LOG environment variable to force mdutil.exe to append errors to ascent log\n")
   _T("  set MDUTIL_PRINT_ID environment variable to force mdutil.exe to print metadata numeric identifiers along with friendly names\n")
 }
};


BOOL
ReadFromFiles(
    LPTSTR*  lplpszPropValue,
    DWORD*  lpdwPropValueLength,
    DWORD   dwPropFileValueCount
    )
{
    DWORD dwL;

    while ( dwPropFileValueCount-- )
    {
        FILE* fIn = _tfopen( lplpszPropValue[dwPropFileValueCount], _T("rb") );
        if ( fIn == NULL )
        {
            return FALSE;
        }
        if ( fseek( fIn, 0, SEEK_END ) == 0 )
        {
            dwL = ftell( fIn );
            if ( fseek( fIn, 0, SEEK_SET ) != 0 )
            {
                fclose( fIn );
                fatal_error_printf(_T("cannot seek\n"));
                return FALSE;
            }
        }
        else
        {
            fclose( fIn );
            return FALSE;
        }
        if ( (lplpszPropValue[dwPropFileValueCount] = (LPTSTR)malloc( dwL )) == NULL )
        {
            fclose( fIn );
            return FALSE;
        }
        if ( fread( lplpszPropValue[dwPropFileValueCount], 1, dwL, fIn ) != dwL )
        {
            fclose( fIn );
            return FALSE;
        }
        fclose( fIn );
        lpdwPropValueLength[dwPropFileValueCount] = dwL;
    }

    return TRUE;
}

///////////////////////////////

class CScript
{
    FILE * m_fpScript;
    void GetNextToken(/*OUT*/ LPTSTR * lplpszToken);
    DWORD CleanWhiteSpaces(void);
public:
    CScript(void) {m_fpScript=0;};
    DWORD Open(LPCTSTR lpszFile);
    DWORD Close(void);
    DWORD GetNextLineTokens(int *argc, /*OUT*/ _TCHAR *** argv);
};



DWORD CScript::CleanWhiteSpaces()
{

    if(m_fpScript!=NULL)
    {
        int LastChar=0;
        _TINT c=0;
        while(1)
        {
            LastChar=c;
            c=_fgettc(m_fpScript);
            if(c==_T('\t') || c==_T(' ') || c==_T('\r'))
            {
                continue;
            }
            if(c==_T('\\'))
            {
                int cc=_fgettc(m_fpScript);
                if (cc==_T('\r')) //continue with the next line of the file
                {
                    if(_fgettc(m_fpScript)!=_T('\n'))
                    {
                        if ( fseek( m_fpScript, -1, SEEK_CUR ) != 0 )
                        {
                            fatal_error_printf(_T("cannot seek\n"));
                            return 0;
                        }
                    }
                    continue;
                }
                else if (cc==_T('\n')) //continue with the next line of the file
                {
                    continue;
                }
                else
                {
                    if ( fseek( m_fpScript, -2, SEEK_CUR ) != 0 )
                    {
                        fatal_error_printf(_T("cannot seek\n"));
                        return 0;
                    }
                    break;
                }
            }
            if(c==WEOF)
            {
                break;
            }
            else
            {
                if ( fseek( m_fpScript, -1, SEEK_CUR ) != 0 )
                {
                    fatal_error_printf(_T("cannot seek\n"));
                    return 0;
                }
                break;
            }
        }
    }
    return 0;
}

void CScript::GetNextToken(LPTSTR * lplpszToken)
{
    enum {TERMINATE_QUOTE, TERMINATE_WHITESPACE};
    long flag=TERMINATE_WHITESPACE;

    //clean white spaces
    CleanWhiteSpaces();
    //store the beginning offset of token
    long Offset = ftell(m_fpScript);
    _TINT c=_fgettc(m_fpScript);
    long CurrentOffset=0;

    if(c==WEOF)
    {
        *lplpszToken=NULL;
        return ;
    }
    if (c==_T('\n')){
        *lplpszToken=_T("\n");
        return ;
    }
    else
    {
        if (c==_T('\"'))
        {
            //token ends with " or the end of the line
            flag=TERMINATE_QUOTE;
            Offset = ftell(m_fpScript);
        }
        else {
            flag=TERMINATE_WHITESPACE;
        }

        // find the end of the token
        while(1) {
            CurrentOffset=ftell(m_fpScript);
            c=_fgettc(m_fpScript);

            if(c==_T('\n')){
                break;
            }

            if(c==WEOF)
            {
                break;
            }


            if( (flag==TERMINATE_QUOTE && c==_T('\"')) || (
                    flag==TERMINATE_WHITESPACE && (c==_T(' ') || c==_T('\t') || c==_T('\r')) ) ){
                break;
            }
        }


        //get the token size
        long TokenSize = CurrentOffset - Offset;

        if(TokenSize!=0)
        {
            // allocate mamory for the token
            *lplpszToken = new _TCHAR[ TokenSize+1 ];
            //read the token
            if ( fseek( m_fpScript, Offset, SEEK_SET) != 0 )
            {
                fatal_error_printf(_T("cannot seek\n"));
                return;
            }
            for(int i=0;i<TokenSize;i++)
                (*lplpszToken)[i]=(TCHAR)_fgettc(m_fpScript);
            //terminate the token
            (*lplpszToken)[i]=0;
        }
        else
        {
            //empty string
            *lplpszToken=new _TCHAR[1 ];
            (*lplpszToken)[0]=0;
        }
        //discard double quote if it was at the end of the token
        c=_fgettc(m_fpScript);
        if(c!=_T('\"'))
        {
            if (fseek( m_fpScript, ((c==WEOF)?0:-1), SEEK_CUR ) !=0 )
            {
                fatal_error_printf(_T("cannot seek\n"));
                return;
            }
        }
    }
}



DWORD CScript::Open(LPCTSTR lpszFile)
{
    m_fpScript = _tfopen(  lpszFile, _T("rt") );
    if(m_fpScript==NULL)
        return GetLastError();
    else
        return ERROR_SUCCESS;
}

DWORD CScript::Close()
{
    if( m_fpScript!=NULL)
        fclose( m_fpScript);
    return GetLastError();
}


DWORD CScript::GetNextLineTokens(int *argc, /*OUT*/ _TCHAR *** argv)
{
    for(int i=1;i<*argc;i++) {
        delete  (*argv)[i];
        (*argv)[i]=0;
    }
    *argc=0;
    if(*argv==NULL)
        (*argv)=new LPTSTR [ MAX_NUMBER_OF_VALUES ];

    (*argv)[(*argc)++]=_T("mdutil"); //set zero parameter

    LPTSTR lpszNextToken=NULL;
    while((*argc)<MAX_NUMBER_OF_VALUES)
    {
        GetNextToken( &lpszNextToken );
        if( lpszNextToken==NULL )  //end of file
        {
            break;
        }

        if(_tcscmp(lpszNextToken,_T("\n"))==0)  //new line
        {
            delete lpszNextToken;
            lpszNextToken = NULL;

            break;
        }

        (*argv)[(*argc)++]=lpszNextToken;

        lpszNextToken = NULL;
    }

    return GetLastError();
}


int  MainFunc(int argc, _TCHAR **argv); //declaration



//MAIN FUNCTION
int __cdecl main(int argc, CHAR **_argv)
{


    //  convert parameters from SBCS to UNICODE;
    _TCHAR **argv= new LPTSTR [argc];
    for (int i=0;i<argc;i++)
    {
        argv[i]=new _TCHAR[strlen(_argv[i])+1];
        #ifdef UNICODE
            MultiByteToWideChar(0, 0, _argv[i], -1, argv[i],strlen(_argv[i])+1 );
        #else
            strcpy(argv[i],_argv[i]);
        #endif
    }


    DWORD dwCommandCode=0;

    DWORD retval=0;
    HRESULT hRes;
    hRes = CoInitializeEx(NULL, COINIT_MULTITHREADED);

    if (FAILED(hRes)) {
        fatal_error_printf(_T("CoInitializeEx\n"));
    }

    //extract command line parameters
    ParseParam(argc,argv,CmdLineArgDesc);
    //**************************
    //PRINT HELP ON REQUEST
    if(Params.fFullHelp)
    {
        //print help
        DisplayUsage(argv,CmdLineArgDesc);
        PrintTablesInfo();
    }
    else if(Params.wDefaultArgCount==0 || Params.fHelp)
    {
        //print help
        DisplayUsage(argv,CmdLineArgDesc);
    }
    else
    {
            if (Params.wDefaultArgCount>0)
    {
        //first default has to be command
        Params.lpszCommand=Params.lplpszDefaultArg[0];
        dwCommandCode = tCommandNameTable::MapNameToCode(Params.lplpszDefaultArg[0]);
        if( Params.wDefaultArgCount>1)
        {
            //second default
            Params.lpszPath=Params.lplpszDefaultArg[1];
        }
            if(dwCommandCode==CMD_SCRIPT)  //process script
            {
                tAdmutilParams *pStoredParams;

                CScript Script;
                DWORD dwRes;

                pStoredParams = new tAdmutilParams(Params);
                if (pStoredParams == NULL)
                {
                    fatal_error_printf(_T("out of memory"));
                }
                if((dwRes=Script.Open(Params.lpszPath))!=ERROR_SUCCESS)
                    fatal_error_printf(_T("cannot open script file %s (error %d)\n"),Params.lpszPath,dwRes);

                int l_argc=0;
                _TCHAR ** l_argv=NULL;
                while(1)
                {
                    Script.GetNextLineTokens(&l_argc,&l_argv);
                    if(l_argc==1) //end of script file
                        break;
                    Params=*pStoredParams;
                    _tprintf(_T(">"));
                    for(int i=1;i<l_argc;i++)
                        _tprintf(_T("%s "),l_argv[i]);
                    _tprintf(_T("\n"));
                    DWORD retval1=MainFunc(l_argc,l_argv);
                    retval = ((retval==0) ? retval1:retval);
                }
                if (oAdmin.GetpcAdmCom()!=NULL)
                {
                    if(!Params.fNoSave)
                    {
                        oAdmin.SaveData();
                    }
                }

                delete pStoredParams;
            }
            else
            {
                retval=MainFunc(argc,argv); //run only one command typed on the command line
                if (oAdmin.GetpcAdmCom()!=NULL)
                {
                    if(Params.fNoSave)
                    {
                        oAdmin.SaveData();
                    }
                }
            }
        }


    }

    //close admin object
    oAdmin.Close();
    //close wam adm object
    oAdmin.CloseWamAdm();

    CoUninitialize();
    //Cleanup of parameters
    if(argv!=0)
    {
        for (int i=0;i<argc;i++)
        {
            delete [] argv[i];
        }
        delete [] argv;
    }

    return retval;

}

int  MainFunc(int argc, _TCHAR **argv)
{
    g_argc=argc;
    g_argv=argv;
    DWORD retval;

    LPCTSTR lpszCommand=0;

    CAdmNode AdmNode;
    CAdmProp AdmProp;
    CAdmNode AdmDstNode;

    int i;

    DWORD dwCommandCode=0;

    //extract command line parameters
    ParseParam(argc,argv,CmdLineArgDesc);


    //PROCESS THE DEFAULT PARAMETERS
    // trick: place the default arguments into variables that apply for non default one (see Params structure)

    if (Params.wDefaultArgCount>0)
    {
        //first default has to be command
        Params.lpszCommand=Params.lplpszDefaultArg[0];
        dwCommandCode = tCommandNameTable::MapNameToCode(Params.lplpszDefaultArg[0]);
        if( Params.wDefaultArgCount>1)
        {
            //second deault has to be path
            Params.lpszPath=Params.lplpszDefaultArg[1];
        }
        if( Params.wDefaultArgCount>2)
        {
            switch(dwCommandCode)
            {

            case CMD_SET:
                //the rest of default args are values
                Params.wPropValueCount=0;
                for(i=2;i<Params.wDefaultArgCount;i++)
                {
                    Params.lplpszPropValue[i-2] = Params.lplpszDefaultArg[i];
                    Params.wPropValueCount++;
                }
                break;
             case CMD_DELETE:
             case CMD_CREATE:
             case CMD_GET:
             case CMD_ENUM:
             case CMD_ENUM_ALL:
                 if( Params.wDefaultArgCount>2)
                 {
                    error_printf(_T("maximum default arguments number exceeds expected (2)\n"));
                    return 1;
                 }

                        break;
             case CMD_COPY:
             case CMD_RENAME:
             case CMD_APPRENAME:
                 if( Params.wDefaultArgCount>3)
                 {
                    error_printf(_T("maximum default arguments number exceeds expected (3)\n"));
                    return 1;
                 }

                 else
                    Params.lpszPathDst=Params.lplpszDefaultArg[2];
                 break;

             default:
                error_printf(_T("command not recognized: %s or number of parameters doesn't match\n"),Params.lpszCommand);
                return 1;

            }
        }
    } //end of default argument handling


    //extract computer,service,instance, if stored in Path
    AdmNode.SetPath(Params.lpszPath);

    //valid only for copy function
    AdmDstNode.SetPath(Params.lpszPathDst);

    //process computer, service, instance, property name arguments
    if(Params.lpszComputer!=NULL) {
        if(!AdmNode.GetComputer().IsEmpty()) {
            error_printf(_T("computer name entered more than once\n"));
            return 1;
        }
        else
            AdmNode.SetComputer(Params.lpszComputer);
    }

    if(Params.lpszService!=NULL) {
        if(!AdmNode.GetService().IsEmpty()) {
            error_printf(_T("service name entered more than once\n"));
            return 1;
        }
        else {
            if(IsServiceName(Params.lpszService))
                AdmNode.SetService(Params.lpszService);
            else {
                error_printf(_T("service name not recognized: %s\n"), Params.lpszService);
                return 1;
            }
        }
    }

    if(Params.wInstance!=0)
    {
        if(!AdmNode.GetInstance().IsEmpty()) {
            error_printf(_T("instance entered more than once\n"));
            return 1;
        }
        else {
            _TCHAR buf[30];
            //!!! maybe ltoa should be used
            AdmNode.SetInstance(_itot(Params.wInstance,buf,10));
        }
    }

    //******************************************
    //process attrib, utype, dtype, value

    //property name first
    CString strProp=AdmNode.GetProperty();
    if(Params.lpszPropName!=NULL && !strProp.IsEmpty())
    {
        error_printf(_T("property name entered more than once\n"));
        return 1;
    }
    else if (Params.lpszPropName!=NULL)
    {
        AdmNode.SetProperty(Params.lpszPropName);

    }
    if(IsNumber(AdmNode.GetProperty()))
    {
        AdmProp.SetIdentifier(_ttol(AdmNode.GetProperty()));
    }
    else
    {
        DWORD dwIdentifier=MapPropertyNameToCode(AdmNode.GetProperty());
        if(dwIdentifier!=NAME_NOT_FOUND)
        {
            AdmProp.SetIdentifier(dwIdentifier);
        }
    }

    //process the attrib entered on command line
    if(Params.wPropAttribCount!=0)
    {
        DWORD dwAttrib=0;
        for (i=0;i<Params.wPropAttribCount;i++)
        {
            if(IsNumber(Params.lplpszPropAttrib[i]))
                dwAttrib += _ttol(Params.lplpszPropAttrib[i]);
            else
            {
                DWORD dwMapped=MapAttribNameToCode(Params.lplpszPropAttrib[i]);
                if(dwMapped==NAME_NOT_FOUND)
                {
                    error_printf(_T("attribute name not resolved: %s\n"), Params.lplpszPropAttrib[i]);
                    return 1;
                }
                else
                    dwAttrib |= dwMapped;
            }
        }
        //overwrite the default attrib
        AdmProp.SetAttrib(dwAttrib) ;
    }

    //process the usertype entered on command line
    if(Params.wPropUserTypeCount!=0)
    {
        DWORD dwUserType=0;
        for (i=0;i<Params.wPropUserTypeCount;i++)
        {
            if(IsNumber(Params.lplpszPropUserType[i]))
                dwUserType += _ttol(Params.lplpszPropUserType[i]);
            else
            {
                DWORD dwMapped=MapUserTypeNameToCode(Params.lplpszPropUserType[i]);
                if(dwMapped==NAME_NOT_FOUND)
                {
                    error_printf(_T("user type not resolved: %s\n"), Params.lplpszPropUserType[i]);
                    return 1;
                }
                else
                    dwUserType |= dwMapped;
            }
        }
        //overwrite the default UserType
        AdmProp.SetUserType(dwUserType) ;
    }


    //process the datatype entered on command line
    if(Params.wPropDataTypeCount!=0)
    {
        DWORD dwDataType=0;
        for (i=0;i<Params.wPropDataTypeCount;i++)
        {
            if(IsNumber(Params.lplpszPropDataType[i]))
                dwDataType += _ttol(Params.lplpszPropDataType[i]);
            else
            {
                DWORD dwMapped=MapDataTypeNameToCode(Params.lplpszPropDataType[i]);
                if(dwMapped==NAME_NOT_FOUND)
                {
                    error_printf(_T("DataType type not resolved: %s\n"), Params.lplpszPropDataType[i]);
                    return 1;

                }
                else
                    dwDataType |= dwMapped;
            }
        }
        //overwrite the default DataTypeType
        AdmProp.SetDataType(dwDataType) ;
    }
//LPCTSTR lplpszPropValue[MAX_NUMBER_OF_PROPERTY_VALUES]; //pointer to array of values (e.g multisz type allows the multiple values for one property
//WORD  wPropValueCount;


    //create admin object
    if(oAdmin.GetpcAdmCom()==NULL)
    {
        oAdmin.Open(AdmNode.GetComputer());
        if( FAILED(oAdmin.QueryLastHresError()))
        {
            retval= ConvertHresToDword(oAdmin.QueryLastHresError());
        }
    }


    if(oAdmin.GetpcAdmCom()!=NULL)
    {
        //
        // read from files if Params.wPropFileValueCount != 0
        //

        if ( Params.wPropFileValueCount )
        {
            if ( !ReadFromFiles( (LPTSTR*)Params.lplpszPropValue, Params.lpdwPropValueLength, Params.wPropFileValueCount ) )
            {
                error_printf(_T("Can't read value from file %s"), Params.lplpszPropValue[0] );
                return 1;
            }
            Params.wPropValueCount = Params.wPropFileValueCount;
        }

        {
            CString strT(Params.lpszCommand);

            oAdmin.Run( strT,
                        AdmNode,
                        AdmProp,
                        AdmDstNode,
                        Params.lplpszPropValue,
                        Params.lpdwPropValueLength,
                        Params.wPropValueCount);
                        retval=ConvertHresToDword(oAdmin.QueryLastHresError());
        }

    }
    return ((retval==0)?0:1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\dcomadm\mdutil\tables.cpp ===
/*++

   Copyright    (c)    1997    Microsoft Corporation

   Module  Name :

       tables.cpp

   Abstract:

        mapping tables to convert various info between text and binary

   Environment:

      Win32 User Mode

   Author:

      jaroslad  (jan 1997)

--*/


#include "tables.h"

#include <string.h>
#include <stdlib.h>
#include <stdio.h>

#include <iiscnfgp.h>  //get MD_* constants



BOOL IsNumber(const CString & name)
{
    for(INT i=0;i<name.GetLength();i++)
    {
        if (name[i]<_T('0') || name[i]>_T('9'))
            return FALSE;
    }
    return TRUE;
}



BOOL IsServiceName(const CString& name)
{
    BOOL fRetval=FALSE;

    if(name.CompareNoCase(_T("W3SVC"))==0 || name.CompareNoCase(_T("MSFTPSVC"))==0 ||
        name.CompareNoCase(_T("NNTPSVC"))==0 || name.CompareNoCase(_T("SMTPSVC"))==0)
    {
        fRetval=TRUE;
    }
    return fRetval;
}





//**********************************************************************
// COMMAND NAME TABLE IMPLEMENTATION
//**********************************************************************


//constants defined in tables.h
struct tCommandNameTable gCommandNameTable[]=
{
    {CMD_SET, _T("SET")},
    {CMD_GET, _T("GET")},
    {CMD_GET, _T("G")},
    {CMD_COPY, _T("COPY")},
    {CMD_DELETE, _T("DELETE")},
    {CMD_DELETE, _T("DEL")},
    {CMD_ENUM, _T("ENUM")},
    {CMD_ENUM, _T("E")},
    {CMD_ENUM_ALL,_T("ENUM_ALL")},
    {CMD_CREATE, _T("CREATE")},
    {CMD_RENAME, _T("RENAME")},
    {CMD_SCRIPT, _T("SCRIPT")},
    {CMD_SAVE, _T("SAVE")},
    {CMD_APPCREATEINPROC, _T("APPCREATEINPROC")},
    {CMD_APPCREATEOUTPOOL, _T("APPCREATEOUTPOOL")},
    {CMD_APPCREATEOUTPROC, _T("APPCREATEOUTPROC")},
    {CMD_APPDELETE, _T("APPDELETE")},
    {CMD_APPRENAME, _T("APPRENAME")},
    {CMD_APPUNLOAD, _T("APPUNLOAD")},
    {CMD_APPGETSTATUS, _T("APPGETSTATUS")},

    //the end
    {0,0}

};

DWORD MapCommandNameToCode(const CString & strName)
{
    return tCommandNameTable::MapNameToCode(strName);
}


DWORD tCommandNameTable::MapNameToCode(const CString & strName, tCommandNameTable * CommandNameTable)
{
    for(int i=0; CommandNameTable[i].lpszName!=0;i++)
    {
        if(strName.CompareNoCase(CommandNameTable[i].lpszName)==0)
            return CommandNameTable[i].dwCode;
    }
    return NAME_NOT_FOUND;
}

#if 0
CString tCommandNameTable::MapCodeToName(DWORD dwCode, tCommandNameTable * CommandNameTable)
{
    for(int i=0; CommandNameTable[i].lpszName!=0;i++)
    {
        if(dwCode==CommandNameTable[i].dwCode)
            return CommandNameTable[i].dwName;
    }
    return 0;
}
#endif



//**********************************************************************
// PROPERTY NAME TABLE IMPLEMENTATION
//**********************************************************************


#define MD_USE_HOST_NAME             (IIS_MD_HTTP_BASE+66 )
#define MD_NET_LOGON_WKS             (IIS_MD_HTTP_BASE+65 )

tPropertyNameTable  gPropertyNameTable[]=
{
//  These are global to all services and should only be set at
//  the IIS root
    {/**/MD_MAX_BANDWIDTH                ,_T("MaxBandwidth"),           METADATA_NO_ATTRIBUTES, /*SHOULD BE GLOBAL*/IIS_MD_UT_SERVER,       DWORD_METADATA},
    {/**/MD_KEY_TYPE                     ,_T("KeyType"),        METADATA_NO_ATTRIBUTES, /*SHOULD BE GLOBAL*/IIS_MD_UT_SERVER,       STRING_METADATA},
//  These properties are applicable to both HTTP and FTP virtual
//  servers
    {/**/MD_CONNECTION_TIMEOUT           ,_T("ConnectionTimeout"),      METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER,   DWORD_METADATA},
    {/**/MD_MAX_CONNECTIONS              ,_T("MaxConnections"),         METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER,   DWORD_METADATA},
    {/**/MD_SERVER_COMMENT               ,_T("ServerComment"),          METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER,   STRING_METADATA},
    {/**/MD_SERVER_STATE                 ,_T("ServerState"),            METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER,   DWORD_METADATA},
    {/**/MD_SERVER_COMMAND               ,_T("ServerCommand"),          METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER,   DWORD_METADATA},
    {/**/MD_SERVER_AUTOSTART             ,_T("ServerAutostart"),        METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER,   DWORD_METADATA},
    {/**/MD_CLUSTER_SERVER_COMMAND       ,_T("ClusterServerCommand"),   METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER,   DWORD_METADATA},
    {/**/MD_CLUSTER_ENABLED              ,_T("ClusterEnabled"),         METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER,   DWORD_METADATA},
    {/**/MD_SERVER_SIZE                  ,_T("ServerSize"),             METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER,   DWORD_METADATA},
    {/**/MD_SERVER_LISTEN_BACKLOG        ,_T("ServerListenBacklog"),    METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER,   DWORD_METADATA},
    {/**/MD_SERVER_LISTEN_TIMEOUT        ,_T("ServerListenTimeout"),    METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER,   DWORD_METADATA},
    {/**/MD_DOWNLEVEL_ADMIN_INSTANCE     ,_T("DownlevelAdminInstance"), METADATA_INHERIT      , IIS_MD_UT_SERVER,   DWORD_METADATA},
    {/**/MD_SERVER_BINDINGS              ,_T("ServerBindings"),         METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER,   MULTISZ_METADATA},
        { MD_SERVER_CONFIGURATION_INFO    ,   _T("ServerConfigurationInfo"),METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER,   DWORD_METADATA},

        //internals
    {/**/MD_SERVER_PLATFORM              ,_T("ServerPlatform"),         METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER,   DWORD_METADATA},
    {/**/MD_SERVER_VERSION_MAJOR         ,_T("MajorVersion"),           METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER,   DWORD_METADATA},
    {/**/MD_SERVER_VERSION_MINOR         ,_T("MinorVersion"),           METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER,   DWORD_METADATA},
    {/**/MD_SERVER_CAPABILITIES          ,_T("Capabilities"),           METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER,   DWORD_METADATA},

//  These properties are specific to HTTP and belong to the virtual
//  server
    {/**/MD_SECURE_BINDINGS              ,_T("SecureBindings"),         METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER,   MULTISZ_METADATA},
    {/**/MD_NTAUTHENTICATION_PROVIDERS   ,_T("NTAuthenticationProviders"),  METADATA_INHERIT,       IIS_MD_UT_FILE,/*??*/STRING_METADATA},
    {/**/MD_SCRIPT_TIMEOUT               ,_T("ScriptTimeout"),              METADATA_INHERIT,IIS_MD_UT_FILE,DWORD_METADATA},
    {/**/MD_CACHE_EXTENSIONS             ,_T("CacheExtensions"),            METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,/*??*/DWORD_METADATA},
    {/**/MD_CREATE_PROCESS_AS_USER       ,_T("CreateProcessAsUser"),        METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
    {/**/MD_CREATE_PROC_NEW_CONSOLE      ,_T("CreateProcNewConsole"),   METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
    {/**/MD_POOL_IDC_TIMEOUT             ,_T("PoolIDCTimeout"),         METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
    {/**/MD_ALLOW_KEEPALIVES             ,_T("AllowKeepAlives"),            METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
    {/**/MD_FILTER_LOAD_ORDER            ,_T("FilterLoadOrder"),            METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,/*??*/STRING_METADATA},
    {/**/MD_FILTER_IMAGE_PATH            ,_T("FilterImagePath"),            METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,STRING_METADATA},
    {/**/MD_FILTER_STATE                 ,_T("FilterState"),                METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
    {MD_FILTER_ENABLED                   ,_T("FilterEnabled"),              METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
    {MD_FILTER_FLAGS                     ,_T("FilterFlags"),              METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
    {MD_FILTER_DESCRIPTION               ,_T("FilterDescription"),        METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,STRING_METADATA},

    { MD_ALLOW_PATH_INFO_FOR_SCRIPT_MAPPINGS, _T("AllowPathInfoForScriptMappings"), METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, DWORD_METADATA },
    { MD_AUTH_CHANGE_URL                 ,_T("AuthChangeUrl"),  METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
    {MD_AUTH_EXPIRED_URL, _T("AuthExpiredUrl"),     METADATA_INHERIT,IIS_MD_UT_SERVER,STRING_METADATA},
    {MD_AUTH_NOTIFY_PWD_EXP_URL, _T("NotifyPwdExpUrl"), METADATA_INHERIT,IIS_MD_UT_SERVER,STRING_METADATA},
    {MD_AUTH_EXPIRED_UNSECUREURL, _T("AuthExpiredUnsecureUrl"),     METADATA_INHERIT,IIS_MD_UT_SERVER,STRING_METADATA},
    {MD_AUTH_NOTIFY_PWD_EXP_UNSECUREURL, _T("NotifyPwdExpUnsecureUrl"), METADATA_INHERIT,IIS_MD_UT_SERVER,STRING_METADATA},
    {MD_ADV_NOTIFY_PWD_EXP_IN_DAYS, _T("NotifyPwdExpInDays"),   METADATA_INHERIT,IIS_MD_UT_SERVER,DWORD_METADATA},
    {MD_AUTH_CHANGE_FLAGS, _T("AuthChangeFlags"),   METADATA_INHERIT,IIS_MD_UT_SERVER,DWORD_METADATA},
    {MD_ADV_CACHE_TTL, _T("AdvCacheTTL"),   METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
    {MD_NET_LOGON_WKS, _T("NetLogonWks"),METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
    {MD_USE_HOST_NAME, _T("UseHostName"),METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
#if defined(CAL_ENABLED)
    #define MD_CAL_VC_PER_CONNECT        (IIS_MD_HTTP_BASE+130)
    #define MD_CAL_AUTH_RESERVE_TIMEOUT  (IIS_MD_HTTP_BASE+131)
    #define MD_CAL_SSL_RESERVE_TIMEOUT   (IIS_MD_HTTP_BASE+132)
    #define MD_CAL_W3_ERROR              (IIS_MD_HTTP_BASE+133)

    {MD_CAL_VC_PER_CONNECT, "CalVcPerConnect",METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
    {MD_CAL_AUTH_RESERVE_TIMEOUT, "CalAuthReserveTimeout",METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
    {MD_CAL_SSL_RESERVE_TIMEOUT, "CalSslReserveTimeout",METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
    {MD_CAL_W3_ERROR, "CalW3Error",METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
#endif
    { MD_IN_PROCESS_ISAPI_APPS           , _T("InProcessIsapiApps"),        METADATA_INHERIT, IIS_MD_UT_SERVER, MULTISZ_METADATA},
    { MD_CUSTOM_ERROR_DESC               , _T("CustomErrorDesc"),           METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, MULTISZ_METADATA},

    {/**/MD_MAPCERT                      ,_T("MapCert"),                    METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER, STRING_METADATA},
    {/**/MD_MAPNTACCT                    ,_T("MaPNTAccT"),                  METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER, STRING_METADATA},
    {/**/MD_MAPNAME                      ,_T("MapName"),                    METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER, STRING_METADATA},
    {/**/MD_MAPENABLED                   ,_T("MapEnabled"),                 METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER, STRING_METADATA},
    {/**/MD_MAPREALM                     ,_T("MapRealm"),                   METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER, STRING_METADATA},
    {/**/MD_MAPPWD                       ,_T("MapPwd"),                     METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER, STRING_METADATA},
    {/**/MD_ITACCT                       ,_T("ITACCT"),                     METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER, STRING_METADATA},
    {/**/MD_CPP_CERT11                   ,_T("CppCert11"),                  METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER, BINARY_METADATA},
    {/**/MD_SERIAL_CERT11                ,_T("SerialCert11"),               METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER, BINARY_METADATA},
    {/**/MD_CPP_CERTW                    ,_T("CppCertw"),                   METADATA_SECURE,IIS_MD_UT_SERVER, BINARY_METADATA},
    {/**/MD_SERIAL_CERTW                 ,_T("SerialCertw"),                METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER, BINARY_METADATA},
    {/**/MD_CPP_DIGEST                   ,_T("CppDigest"),                  METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER, BINARY_METADATA},
    {/**/MD_SERIAL_DIGEST                ,_T("SerialDigest"),               METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER, BINARY_METADATA},
    {/**/MD_CPP_ITA                      ,_T("CppIta"),                     METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER, BINARY_METADATA},
    {/**/MD_SERIAL_ITA                   ,_T("SerialIta"),                  METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER, BINARY_METADATA},

// Compression Filter Properties
    {/**/MD_HC_COMPRESSION_DIRECTORY     ,_T("HcCompressionDirectory"),     IIS_MD_UT_SERVER, EXPANDSZ_METADATA},
    {/**/MD_HC_CACHE_CONTROL_HEADER      ,_T("HcCacheControlHeader"),       IIS_MD_UT_SERVER, STRING_METADATA},
    {/**/MD_HC_EXPIRES_HEADER            ,_T("HcExpiresHeader"),            IIS_MD_UT_SERVER, STRING_METADATA},
    {/**/MD_HC_DO_DYNAMIC_COMPRESSION    ,_T("HcDoDynamicCompression"),     IIS_MD_UT_SERVER, DWORD_METADATA},
    {/**/MD_HC_DO_STATIC_COMPRESSION     ,_T("HcDoStaticCompression"),      IIS_MD_UT_SERVER, DWORD_METADATA},
    {/**/MD_HC_DO_ON_DEMAND_COMPRESSION  ,_T("HcDoOnDemandCompression"),    IIS_MD_UT_SERVER, DWORD_METADATA},
    {/**/MD_HC_DO_DISK_SPACE_LIMITING    ,_T("HcDoDiskSpaceLimiting"),      IIS_MD_UT_SERVER, DWORD_METADATA},
    {/**/MD_HC_NO_COMPRESSION_FOR_HTTP_10 ,_T("HcNoCompressionForHttp10"),  IIS_MD_UT_SERVER, DWORD_METADATA},
    {/**/MD_HC_NO_COMPRESSION_FOR_PROXIES ,_T("HcNoCompressionForProxies"), IIS_MD_UT_SERVER, DWORD_METADATA},
    {/**/MD_HC_NO_COMPRESSION_FOR_RANGE  ,_T("HcNoCompressionForRange"),    IIS_MD_UT_SERVER, DWORD_METADATA},
    {/**/MD_HC_SEND_CACHE_HEADERS        ,_T("HcSendCacheHeaders"),         IIS_MD_UT_SERVER, DWORD_METADATA},
    {/**/MD_HC_MAX_DISK_SPACE_USAGE      ,_T("HcMaxDiskSpaceUsage"),        IIS_MD_UT_SERVER, DWORD_METADATA},
    {/**/MD_HC_IO_BUFFER_SIZE            ,_T("HcIoBufferSize"),             IIS_MD_UT_SERVER, DWORD_METADATA},
    {/**/MD_HC_COMPRESSION_BUFFER_SIZE   ,_T("HcCompressionBufferSize"),    IIS_MD_UT_SERVER, DWORD_METADATA},
    {/**/MD_HC_MAX_QUEUE_LENGTH          ,_T("HcMaxQueueLength"),           IIS_MD_UT_SERVER, DWORD_METADATA},
    {/**/MD_HC_FILES_DELETED_PER_DISK_FREE ,_T("HcFilesDeletedPerDiskFree"), IIS_MD_UT_SERVER, DWORD_METADATA},
    {/**/MD_HC_MIN_FILE_SIZE_FOR_COMP    ,_T("HcMinFileSizeForComp"),       IIS_MD_UT_SERVER, DWORD_METADATA},
    {/**/MD_HC_COMPRESSION_DLL           ,_T("HcCompressionDll"),           IIS_MD_UT_SERVER, EXPANDSZ_METADATA},
    {/**/MD_HC_FILE_EXTENSIONS           ,_T("HcFileExtensions"),           IIS_MD_UT_SERVER, MULTISZ_METADATA},
    {/**/MD_HC_PRIORITY                  ,_T("HcPriority"),                 IIS_MD_UT_SERVER, DWORD_METADATA},
    {/**/MD_HC_DYNAMIC_COMPRESSION_LEVEL ,_T("HcDynamicCompressionLevel"),  IIS_MD_UT_SERVER, DWORD_METADATA},
    {/**/MD_HC_ON_DEMAND_COMP_LEVEL      ,_T("HcOnDemandCompLevel"),        IIS_MD_UT_SERVER, DWORD_METADATA},
    {/**/MD_HC_CREATE_FLAGS              ,_T("HcCreateFlags"),              IIS_MD_UT_SERVER, DWORD_METADATA},

// Job Object Site Properties
#define MD_CPU_LOGGING_MASK              (IIS_MD_LOGCUSTOM_BASE+7 )
#define MD_CPU_LIMITS_ENABLED            (IIS_MD_HTTP_BASE+143)
#define MD_CPU_LOGGING_INTERVAL          (IIS_MD_HTTP_BASE+145)
#define MD_CPU_LOGGING_OPTIONS           (IIS_MD_HTTP_BASE+146)
#define MD_CPU_CGI_LIMIT                 (IIS_MD_HTTP_BASE+148)
#define MD_CPU_LIMIT_LOGEVENT            (IIS_MD_HTTP_BASE+149)
#define MD_CPU_LIMIT_PRIORITY            (IIS_MD_HTTP_BASE+150)
#define MD_CPU_LIMIT_PROCSTOP            (IIS_MD_HTTP_BASE+151)
#define MD_CPU_LIMIT_PAUSE               (IIS_MD_HTTP_BASE+152)

    {/**/MD_CPU_LIMITS_ENABLED           ,_T("CpuLimitsEnabled"),           METADATA_INHERIT,IIS_MD_UT_SERVER, DWORD_METADATA},
    {/**/MD_CPU_RESET_INTERVAL           ,_T("CpuResetInterval"),           METADATA_INHERIT,IIS_MD_UT_SERVER, DWORD_METADATA},
    {/**/MD_CPU_LOGGING_INTERVAL         ,_T("CpuLoggingInterval"),         METADATA_INHERIT,IIS_MD_UT_SERVER, DWORD_METADATA},
    {/**/MD_CPU_LOGGING_OPTIONS          ,_T("CpuLoggingOptions"),          METADATA_INHERIT,IIS_MD_UT_SERVER, DWORD_METADATA},
    {/**/MD_CPU_LOGGING_MASK             ,_T("CpuLoggingMask"),             METADATA_INHERIT,IIS_MD_UT_SERVER, DWORD_METADATA},
    {/**/MD_CPU_CGI_LIMIT                ,_T("CpuCgiLimit"),                METADATA_INHERIT,IIS_MD_UT_SERVER, DWORD_METADATA},
    {/**/MD_CPU_LIMIT_LOGEVENT           ,_T("CpuLimitLogEvent"),           METADATA_INHERIT,IIS_MD_UT_SERVER, DWORD_METADATA},
    {/**/MD_CPU_LIMIT_PRIORITY           ,_T("CpuLimitPriority"),           METADATA_INHERIT,IIS_MD_UT_SERVER, DWORD_METADATA},
    {/**/MD_CPU_LIMIT_PROCSTOP           ,_T("CpuLimitProcStop"),           METADATA_INHERIT,IIS_MD_UT_SERVER, DWORD_METADATA},
    {/**/MD_CPU_LIMIT_PAUSE              ,_T("CpuLimitPause"),              METADATA_INHERIT,IIS_MD_UT_SERVER, DWORD_METADATA},

// Job Object per file properties
#define MD_CPU_CGI_ENABLED               (IIS_MD_HTTP_BASE+140)
#define MD_CPU_APP_ENABLED               (IIS_MD_HTTP_BASE+141)

    {/**/MD_CPU_CGI_ENABLED              ,_T("CpuCgiEnabled"),              METADATA_INHERIT,IIS_MD_UT_FILE, DWORD_METADATA},
    {/**/MD_CPU_APP_ENABLED              ,_T("CpuAppEnabled"),              METADATA_INHERIT,IIS_MD_UT_FILE, DWORD_METADATA},
    {/**/MD_CERT_CHECK_MODE              ,_T("CertCheckMode"),              METADATA_INHERIT,IIS_MD_UT_SERVER,DWORD_METADATA},


// Virtual root properties - note MD_ACCESS_PERM is also generally set at
// the virtual directory.  These are used for both HTTP and FTP
    {/**/MD_VR_PATH                   ,_T("VrPath"),                    METADATA_INHERIT,IIS_MD_UT_FILE,STRING_METADATA},
    {/**/MD_VR_USERNAME               ,_T("VrUsername"),                METADATA_INHERIT,IIS_MD_UT_FILE,STRING_METADATA},
    {/**/MD_VR_PASSWORD               ,_T("VrPassword") ,           METADATA_INHERIT|METADATA_SECURE,IIS_MD_UT_FILE,     STRING_METADATA},
    {/**/MD_VR_ACL                    ,_T("VrAcl"),                 METADATA_INHERIT,IIS_MD_UT_FILE,BINARY_METADATA},
// This is used to flag down updated vr entries - Used for migrating vroots
    {/**/MD_VR_UPDATE                    ,_T("VrUpdate"),              METADATA_NO_ATTRIBUTES,IIS_MD_UT_FILE,DWORD_METADATA},
//  Logging related attributes
    {MD_LOG_TYPE                      ,_T("LogType"),                   METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
    {MD_LOGFILE_DIRECTORY            ,_T("LogFileDirectory"),           METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
    {MD_LOGFILE_PERIOD               ,_T("LogFilePeriod"),              METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
    {MD_LOGFILE_TRUNCATE_SIZE        ,_T("LogFileTruncateSize"),        METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
    {MD_LOGSQL_DATA_SOURCES          ,_T("LogSqlDataSources"),          METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
    {MD_LOGSQL_TABLE_NAME            ,_T("LogSqlTableName"),            METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
    {MD_LOGSQL_USER_NAME             ,_T("LogSqlUserName"),             METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
    {MD_LOGSQL_PASSWORD              ,_T("LogSqlPassword"),             METADATA_SECURE,IIS_MD_UT_FILE,DWORD_METADATA},
//  {MD_LOG_CLSID                       ,_T("LogClsid"),                   METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
//  {MD_LOG_STATE                       ,_T("LogState"),                   METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
    {MD_LOGEXT_FIELD_MASK               ,_T("ExtLogFieldMask"),            METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
    {MD_LOGEXT_FIELD_MASK2              ,_T("ExtLogFieldMask2"),           METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
    {MD_LOG_PLUGIN_ORDER                ,_T("LogPluginOrder"),             METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,STRING_METADATA},
    {MD_LOGFILE_LOCALTIME_ROLLOVER      ,_T("LogFileLocaltimeRollover"),   METADATA_INHERIT,IIS_MD_UT_SERVER,BINARY_METADATA},
//  These are FTP specific properties
    {/**/MD_EXIT_MESSAGE                 ,_T("ExitMessage"),                METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,STRING_METADATA},
    {/**/MD_GREETING_MESSAGE             ,_T("GreetingMessage"),            METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,/*!!*/MULTISZ_METADATA},
    {/**/MD_MAX_CLIENTS_MESSAGE          ,_T("MaxClientsMessage"),      METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,STRING_METADATA},
    {/**/MD_BANNER_MESSAGE               ,_T("BannerMessage"),            METADATA_INHERIT,IIS_MD_UT_SERVER,MULTISZ_METADATA},
    {/**/MD_MSDOS_DIR_OUTPUT             ,_T("MSDOSDirOutput"),         METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
    {/**/MD_ALLOW_ANONYMOUS              ,_T("AllowAnonymous"),         METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,BINARY_METADATA},
    {/**/MD_ANONYMOUS_ONLY               ,_T("AnonymousOnly"),              METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,BINARY_METADATA},
    {/**/MD_LOG_ANONYMOUS                ,_T("LogAnonymous"),               METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
    {/**/MD_LOG_NONANONYMOUS             ,_T("LogNonAnonymous"),            METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
    {/**/MD_USER_ISOLATION               ,_T("UserIsolationMode"),          METADATA_INHERIT,IIS_MD_UT_SERVER,DWORD_METADATA},
    {/**/MD_AD_CONNECTIONS_USERNAME      ,_T("ActiveDirectoryAccessUser"),  METADATA_INHERIT,IIS_MD_UT_SERVER,STRING_METADATA},
    {/**/MD_AD_CONNECTIONS_PASSWORD      ,_T("ActiveDirectoryAccessPwd"),   METADATA_INHERIT,IIS_MD_UT_SERVER,STRING_METADATA},
//  These are SSL specific properties
    {/**/MD_SSL_PUBLIC_KEY               ,_T("SslPublicKey"),               METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,BINARY_METADATA},
    {/**/MD_SSL_PRIVATE_KEY              ,_T("SslPrivateKey"),          METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,BINARY_METADATA},
    {/**/MD_SSL_KEY_PASSWORD             ,_T("SslKeyPassword"),         METADATA_SECURE,IIS_MD_UT_SERVER,BINARY_METADATA},
    {/**/MD_SSL_KEY_REQUEST             ,_T("SslKeyRequest"),         METADATA_SECURE,IIS_MD_UT_SERVER,BINARY_METADATA},
    {/**/MD_SSL_FRIENDLY_NAME           ,_T("SslFriendlyName"),         METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,STRING_METADATA},
    {/**/MD_SSL_IDENT                   ,_T("SslIdent"),                 METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,STRING_METADATA},
//FTP specific
    {MD_SHOW_4_DIGIT_YEAR          ,_T("FtpDirBrowseShowLongDate"),       METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},

//
// These are server certificate properties
//
    {/**/MD_SSL_CERT_HASH                ,_T("SslCertHash"),         METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,BINARY_METADATA},
    {/**/MD_SSL_CERT_CONTAINER           ,_T("SslCertContainer"),    METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,STRING_METADATA},
    {/**/MD_SSL_CERT_PROVIDER            ,_T("SslCertProvider"),     METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,STRING_METADATA},
    {/**/MD_SSL_CERT_PROVIDER_TYPE       ,_T("SslCertProviderType"),     METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
    {/**/MD_SSL_CERT_OPEN_FLAGS          ,_T("SslCertOpenFlags"),     METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,STRING_METADATA},
    {/**/MD_SSL_CERT_STORE_NAME          ,_T("SslCertStoreName"),     METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,STRING_METADATA},
//
// These are Certificate Trust List properties
//
    {/**/MD_SSL_CTL_IDENTIFIER          ,_T("SslCtlIdentifier"),    METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,STRING_METADATA},
    {/**/MD_SSL_CTL_CONTAINER           ,_T("SslCtlContainer"),     METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,STRING_METADATA},
    {/**/MD_SSL_CTL_PROVIDER            ,_T("SslCtlProvider"),      METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,STRING_METADATA},
    {/**/MD_SSL_CTL_PROVIDER_TYPE       ,_T("SslCtlProviderType"),  METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
    {/**/MD_SSL_CTL_OPEN_FLAGS          ,_T("SslCtlOpenFlags"),     METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,STRING_METADATA},
    {/**/MD_SSL_CTL_STORE_NAME          ,_T("SslCtlStoreName"),     METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,STRING_METADATA},
    {/**/MD_SSL_CTL_SIGNER_HASH         ,_T("SslCtlSignerHash"),    METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,STRING_METADATA},
//
// Metabase property that defines whether to use DS mapper or not
//
    {/**/MD_SSL_USE_DS_MAPPER           ,_T("SslUseDSMapper"),     METADATA_INHERIT,IIS_MD_UT_FILE,DWORD_METADATA},
//
// Metabase property that holds SSL replication information
//
    {/**/MD_SSL_REPLICATION_INFO        ,_T("SslReplicationInfo"),  METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,STRING_METADATA},
//
// Metabase properties that are used by the CertWiz ActiveX control, that
// is used for the Certificate/CTL UI management tool
//
    {/**/MD_SSL_CERT_ENROLL_HISTORY     ,_T("SslCertEnrollHistory"),  METADATA_INHERIT,IIS_MD_UT_SERVER,STRING_METADATA},
    {/**/MD_SSL_CERT_ENROLL_TIME        ,_T("SslCertEnrollTime"),  METADATA_INHERIT,IIS_MD_UT_SERVER,STRING_METADATA},
    {/**/MD_SSL_CERT_ENROLL_STATE       ,_T("SslCertEnrollState"),  METADATA_INHERIT,IIS_MD_UT_SERVER,STRING_METADATA},
    {/**/MD_SSL_CERT_ENROLL_STATE_ERROR ,_T("SslCertEnrollStateError"),  METADATA_INHERIT,IIS_MD_UT_SERVER,STRING_METADATA},

//
// Metabase properties used for Fortezza certificates
//
    {/**/MD_SSL_CERT_IS_FORTEZZA        ,_T("IsFortezza"), METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
    {/**/MD_SSL_CERT_FORTEZZA_PIN       ,_T("FortezzaPin"),  METADATA_INHERIT,IIS_MD_UT_SERVER,STRING_METADATA},
    {/**/MD_SSL_CERT_FORTEZZA_SERIAL_NUMBER     ,_T("FortezzaPin"),  METADATA_INHERIT,IIS_MD_UT_SERVER,STRING_METADATA},
    {/**/MD_SSL_CERT_FORTEZZA_PERSONALITY       ,_T("FortezzaPersonality"),  METADATA_INHERIT,IIS_MD_UT_SERVER,STRING_METADATA},
    {/**/MD_SSL_CERT_FORTEZZA_PROG_PIN          ,_T("FortezzaProgPin"),  METADATA_INHERIT,IIS_MD_UT_SERVER,STRING_METADATA},

//
// Metabase properties that are used by the CertWiz ActiveX control to keep
// track of the user's entry history, and whether DEBUG is enabled.  We keep
// these private properties on a per VS basis.
//

    {/**/MD_SSL_CERT_WIZ_DEBUG                  ,_T("WizDebug"),  METADATA_INHERIT,IIS_MD_UT_SERVER,STRING_METADATA},
    {/**/MD_SSL_CERT_WIZHIST_SZ_TARGET_CA       ,_T("WizhistTargetCA"),  METADATA_INHERIT,IIS_MD_UT_SERVER,STRING_METADATA},
    {/**/MD_SSL_CERT_WIZHIST_SZ_FILE_NAME_USED_LAST     ,_T("WizhistFileNameUsedLast"),  METADATA_INHERIT,IIS_MD_UT_SERVER,STRING_METADATA},
    {/**/MD_SSL_CERT_WIZHIST_SZ_DN_COMMON_NAME  ,_T("WizhistCN"),  METADATA_INHERIT,IIS_MD_UT_SERVER,STRING_METADATA},
    {/**/MD_SSL_CERT_WIZHIST_SZ_DN_O            ,_T("WizhistO"),  METADATA_INHERIT,IIS_MD_UT_SERVER,STRING_METADATA},
    {/**/MD_SSL_CERT_WIZHIST_SZ_DN_OU           ,_T("WizhistOU"),  METADATA_INHERIT,IIS_MD_UT_SERVER,STRING_METADATA},
    {/**/MD_SSL_CERT_WIZHIST_SZ_DN_C            ,_T("WizhistC"),  METADATA_INHERIT,IIS_MD_UT_SERVER,STRING_METADATA},
    {/**/MD_SSL_CERT_WIZHIST_SZ_DN_L            ,_T("WizhistL"),  METADATA_INHERIT,IIS_MD_UT_SERVER,STRING_METADATA},
    {/**/MD_SSL_CERT_WIZHIST_SZ_DN_S            ,_T("WizhistS"),  METADATA_INHERIT,IIS_MD_UT_SERVER,STRING_METADATA},
    {/**/MD_SSL_CERT_WIZHIST_SZ_USER_NAME       ,_T("WizhistUserName"),  METADATA_INHERIT,IIS_MD_UT_SERVER,STRING_METADATA},
    {/**/MD_SSL_CERT_WIZHIST_SZ_USER_PHONE      ,_T("WizhistUserPhone"),  METADATA_INHERIT,IIS_MD_UT_SERVER,STRING_METADATA},
    {/**/MD_SSL_CERT_WIZHIST_SZ_USER_EMAIL      ,_T("WizhistUserEmail"),  METADATA_INHERIT,IIS_MD_UT_SERVER,STRING_METADATA},

    {/**/MD_SSL_CERT_WIZGUID_ICERTGETCONFIG     ,_T("WizguidICERTGETCONFIG"),  METADATA_INHERIT,IIS_MD_UT_SERVER,STRING_METADATA},
    {/**/MD_SSL_CERT_WIZGUID_ICERTREQUEST       ,_T("WizguidICERTREQUEST"),  METADATA_INHERIT,IIS_MD_UT_SERVER,STRING_METADATA},
    {/**/MD_SSL_CERT_WIZGUID_XENROLL            ,_T("WizguidXENROLL"),  METADATA_INHERIT,IIS_MD_UT_SERVER,STRING_METADATA},

//  File and Directory related properties - these should be added in the
//  metabase with a user type of IIS_MD_UT_FILE
    {/**/MD_AUTHORIZATION                ,_T("Authorization"),              METADATA_INHERIT,   IIS_MD_UT_FILE,DWORD_METADATA},
    {/**/MD_AUTHORIZATION_PERSISTENCE    ,_T("AuthorizationPersistence"),   METADATA_INHERIT,   IIS_MD_UT_FILE,DWORD_METADATA},
    {/**/MD_REALM                        ,_T("Realm"),                      METADATA_INHERIT,   IIS_MD_UT_FILE,STRING_METADATA},
    {/**/MD_HTTP_EXPIRES                 ,_T("HttpExpires"),                METADATA_INHERIT,   IIS_MD_UT_FILE,STRING_METADATA},
    {/**/MD_HTTP_PICS                    ,_T("HtpPics"),                    METADATA_INHERIT,   IIS_MD_UT_FILE,STRING_METADATA},
    {/**/MD_HTTP_CUSTOM                  ,_T("HttpCustom"),             METADATA_INHERIT,   IIS_MD_UT_FILE,MULTISZ_METADATA},
    {/**/MD_DIRECTORY_BROWSING           ,_T("DirectoryBrowsing"),          METADATA_INHERIT,   IIS_MD_UT_FILE,DWORD_METADATA},
    {/**/MD_DEFAULT_LOAD_FILE            ,_T("DefaultLoadFile"),            METADATA_INHERIT,   IIS_MD_UT_FILE,/**/STRING_METADATA},
    {MD_CONTENT_NEGOTIATION          ,    _T("ContentNegotiation"),     METADATA_INHERIT    ,IIS_MD_UT_FILE,DWORD_METADATA},
    {/**/MD_CUSTOM_ERROR                 ,_T("CustomError"),                METADATA_INHERIT,   IIS_MD_UT_FILE,MULTISZ_METADATA},
    {/**/MD_FOOTER_DOCUMENT              ,_T("FooterDocument"),         METADATA_INHERIT,   IIS_MD_UT_FILE,STRING_METADATA},
    /**/{MD_FOOTER_ENABLED               ,_T("FooterEnabled"),              METADATA_INHERIT,   IIS_MD_UT_FILE,DWORD_METADATA},
    {MD_HTTP_REDIRECT                    ,_T("HttpRedirect"),               METADATA_NO_ATTRIBUTES,IIS_MD_UT_FILE,STRING_METADATA},
    {/**/MD_DEFAULT_LOGON_DOMAIN         ,_T("DefaultLogonDomain"), METADATA_INHERIT,      IIS_MD_UT_FILE,STRING_METADATA},
    {/**/MD_LOGON_METHOD                 ,_T("LogonMethod"),            METADATA_INHERIT,      IIS_MD_UT_FILE,DWORD_METADATA},
    {MD_SCRIPT_MAPS                     ,_T("ScriptMaps"),              METADATA_INHERIT,IIS_MD_UT_FILE,MULTISZ_METADATA},
    {MD_SCRIPT_TIMEOUT                     ,_T("ScriptTimeout"),        METADATA_INHERIT,IIS_MD_UT_FILE,DWORD_METADATA},
    {MD_MIME_MAP                     ,_T("MimeMap"),                    METADATA_INHERIT,IIS_MD_UT_FILE,MULTISZ_METADATA},
    {/**/MD_ACCESS_PERM                  ,_T("AccessPerm"),             METADATA_INHERIT,   IIS_MD_UT_FILE,DWORD_METADATA},
    {/**/MD_SSL_ACCESS_PERM          ,_T("SslAccessPerm"),             METADATA_INHERIT,   IIS_MD_UT_FILE,DWORD_METADATA},
    {MD_IP_SEC                       ,_T("IpSec")   ,                   METADATA_INHERIT,IIS_MD_UT_FILE,DWORD_METADATA},
    {/**/MD_ANONYMOUS_USER_NAME          ,_T("AnonymousUserName"),      METADATA_INHERIT,   IIS_MD_UT_FILE,STRING_METADATA},
    {/**/MD_ANONYMOUS_PWD                ,_T("AnonymousPwd"),               METADATA_INHERIT|METADATA_SECURE,IIS_MD_UT_FILE,STRING_METADATA},
    {MD_ANONYMOUS_USE_SUBAUTH        ,_T("AnonymousUseSubAuth"),        METADATA_INHERIT,IIS_MD_UT_FILE,DWORD_METADATA},
    {/**/MD_DONT_LOG                     ,_T("DontLOG"),                    METADATA_INHERIT,   IIS_MD_UT_FILE,DWORD_METADATA},
    {/**/MD_ADMIN_ACL                    ,_T("AdminAcl"),                   METADATA_INHERIT,   IIS_MD_UT_FILE,BINARY_METADATA},
    {MD_SSI_EXEC_DISABLED                ,_T("SSIExecDisabled"),            METADATA_INHERIT,   IIS_MD_UT_FILE,DWORD_METADATA},
    {MD_DO_REVERSE_DNS                   ,_T("DoReverseDns"),               METADATA_INHERIT,   IIS_MD_UT_FILE,DWORD_METADATA},
    {MD_WIN32_ERROR                  ,_T("Win32Error"),            METADATA_VOLATILE,   IIS_MD_UT_SERVER,DWORD_METADATA},
    {MD_ALLOW_REPLACE_ON_RENAME          ,_T("AllowReplaceOnRename"),       METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, DWORD_METADATA},
    {/**/MD_CC_NO_CACHE                  ,_T("CacheControlNoCache"),             METADATA_INHERIT,   IIS_MD_UT_FILE,DWORD_METADATA},
    {/**/MD_CC_MAX_AGE                  ,_T("CacheControlMaxAge"),             METADATA_INHERIT,   IIS_MD_UT_FILE,DWORD_METADATA},
    {/**/MD_CC_OTHER                  ,_T("CacheControlOther"),             METADATA_INHERIT,   IIS_MD_UT_FILE,STRING_METADATA},
    {MD_FRONTPAGE_WEB          ,_T("FrontPageWeb"),       METADATA_INHERIT, IIS_MD_UT_SERVER, DWORD_METADATA},
    {MD_IS_CONTENT_INDEXED      ,_T("IsContentIndexed"),       METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_ISM_ACCESS_CHECK          ,_T("IsmAccessCheck"),       METADATA_NO_ATTRIBUTES, IIS_MD_UT_FILE, DWORD_METADATA},


////////ASP and WAM params

        { MD_ASP_BUFFERINGON                  , _T("AspBufferingOn"),           METADATA_INHERIT, ASP_MD_UT_APP, DWORD_METADATA},
        { MD_ASP_LOGERRORREQUESTS             , _T("AspLogErrorRequests"),      METADATA_INHERIT, IIS_MD_UT_WAM, DWORD_METADATA},
        { MD_ASP_SCRIPTERRORSSENTTOBROWSER    , _T("AspScriptErrorSentToBrowser"),METADATA_INHERIT, ASP_MD_UT_APP, DWORD_METADATA},
        { MD_ASP_SCRIPTERRORMESSAGE           , _T("AspScriptErrorMessage"),METADATA_INHERIT, ASP_MD_UT_APP, STRING_METADATA},
        { MD_ASP_SCRIPTFILECACHESIZE          , _T("AspScriptFileCacheSize"),METADATA_INHERIT, IIS_MD_UT_WAM, DWORD_METADATA},
        { MD_ASP_SCRIPTENGINECACHEMAX         , _T("AspScriptEngineCacheMax"),METADATA_INHERIT, IIS_MD_UT_WAM, DWORD_METADATA},
        { MD_ASP_SCRIPTTIMEOUT                , _T("AspScriptTimeout"),         METADATA_INHERIT, ASP_MD_UT_APP, DWORD_METADATA},
        { MD_ASP_SESSIONTIMEOUT               , _T("AspSessionTimeout"),        METADATA_INHERIT, ASP_MD_UT_APP, DWORD_METADATA},
        { MD_ASP_ENABLEPARENTPATHS            , _T("AspEnableParentPaths"), METADATA_INHERIT, ASP_MD_UT_APP, DWORD_METADATA},
        { MD_ASP_MEMFREEFACTOR                , _T("AspMemFreeFactor"),         METADATA_INHERIT, IIS_MD_UT_WAM, DWORD_METADATA},
        { MD_ASP_MINUSEDBLOCKS                , _T("AspMinUseDblocks"),         METADATA_INHERIT, IIS_MD_UT_WAM, DWORD_METADATA},
        { MD_ASP_ALLOWSESSIONSTATE            , _T("AspAllowSessionState"),     METADATA_INHERIT, ASP_MD_UT_APP, DWORD_METADATA},
        { MD_ASP_SCRIPTLANGUAGE               , _T("AspScriptLanguage")         ,METADATA_INHERIT, ASP_MD_UT_APP, STRING_METADATA},
        { MD_ASP_QUEUETIMEOUT                 , _T("AspQueueTimeout")           ,METADATA_INHERIT, ASP_MD_UT_APP, DWORD_METADATA},
        //{ MD_ASP_STARTCONNECTIONPOOL          , _T("AspStartConnectionPool"),METADATA_INHERIT, IIS_MD_UT_WAM, DWORD_METADATA},
        { MD_ASP_ALLOWOUTOFPROCCMPNTS         , _T("AspAllowOutOfProcComponents"),METADATA_INHERIT, ASP_MD_UT_APP, DWORD_METADATA},
        { MD_ASP_EXCEPTIONCATCHENABLE         , _T("AspExceptionCatchEnable"),METADATA_INHERIT, ASP_MD_UT_APP, DWORD_METADATA},
        { MD_ASP_CODEPAGE                     , _T("AspCodepage")                       ,METADATA_INHERIT, ASP_MD_UT_APP, DWORD_METADATA},
        { MD_ASP_SCRIPTLANGUAGELIST           , _T("AspScriptLanguages")        ,METADATA_INHERIT, ASP_MD_UT_APP, DWORD_METADATA},
        { MD_ASP_ENABLESERVERDEBUG                        , _T("AspEnableServerDebug")  ,METADATA_INHERIT,ASP_MD_UT_APP, DWORD_METADATA},
        { MD_ASP_ENABLECLIENTDEBUG                        , _T("AspEnableClientDebug")  ,METADATA_INHERIT, ASP_MD_UT_APP, DWORD_METADATA},
        { MD_ASP_TRACKTHREADINGMODEL              , _T("AspTrackThreadingModel") ,METADATA_INHERIT, IIS_MD_UT_WAM, DWORD_METADATA},

        // new 5.0 ASP params
        { MD_ASP_ENABLEASPHTMLFALLBACK        , _T("AspEnableAspHTMLFallback") ,METADATA_INHERIT, IIS_MD_UT_WAM, DWORD_METADATA},
        { MD_ASP_ENABLECHUNKEDENCODING        , _T("AspEnableChunkedEncoding") ,METADATA_INHERIT, IIS_MD_UT_WAM, DWORD_METADATA},
        { MD_ASP_ENABLETYPELIBCACHE           , _T("AspEnableTypeLibCache")    ,METADATA_INHERIT, IIS_MD_UT_WAM, DWORD_METADATA},
        { MD_ASP_ERRORSTONTLOG                , _T("AspErrorsToNTLog")         ,METADATA_INHERIT, IIS_MD_UT_WAM, DWORD_METADATA},
        { MD_ASP_PROCESSORTHREADMAX           , _T("AspProcessorThreadMax")    ,METADATA_INHERIT, IIS_MD_UT_WAM, DWORD_METADATA},
        { MD_ASP_REQEUSTQUEUEMAX              , _T("AspRequestQueueMax")       ,METADATA_INHERIT, IIS_MD_UT_WAM, DWORD_METADATA},
        { MD_ASP_ENABLEAPPLICATIONRESTART     , _T("AspEnableApplicationRestart") ,METADATA_INHERIT, ASP_MD_UT_APP, DWORD_METADATA},
        { MD_ASP_QUEUECONNECTIONTESTTIME      , _T("AspQueueConnectionTestTime") ,METADATA_INHERIT, ASP_MD_UT_APP, DWORD_METADATA},
        { MD_ASP_SESSIONMAX                   , _T("AspSessionMax")            ,METADATA_INHERIT, ASP_MD_UT_APP, DWORD_METADATA},
        { MD_ASP_KEEPSESSIONIDSECURE          , _T("AspKeepSessionIDSecure")   ,METADATA_INHERIT, ASP_MD_UT_APP, DWORD_METADATA},

        #define MD_ASP_THREADGATEENABLED         (ASP_MD_SERVER_BASE + 30)
        #define MD_ASP_THREADGATETIMESLICE       (ASP_MD_SERVER_BASE + 31)
        #define MD_ASP_THREADGATESLEEPDELAY      (ASP_MD_SERVER_BASE + 32)
        #define MD_ASP_THREADGATESLEEPMAX        (ASP_MD_SERVER_BASE + 33)
        #define MD_ASP_THREADGATELOADLOW         (ASP_MD_SERVER_BASE + 34)
        #define MD_ASP_THREADGATELOADHIGH        (ASP_MD_SERVER_BASE + 35)

        // Thread gate params
        { MD_ASP_THREADGATEENABLED            , _T("AspThreadGateEnabled")     ,METADATA_INHERIT, IIS_MD_UT_WAM, DWORD_METADATA},
        { MD_ASP_THREADGATETIMESLICE          , _T("AspThreadGateTimeSlice")   ,METADATA_INHERIT, IIS_MD_UT_WAM, DWORD_METADATA},
        { MD_ASP_THREADGATESLEEPDELAY         , _T("AspThreadGateSleepDelay")  ,METADATA_INHERIT, IIS_MD_UT_WAM, DWORD_METADATA},
        { MD_ASP_THREADGATESLEEPMAX           , _T("AspThreadGateSleepMax")    ,METADATA_INHERIT, IIS_MD_UT_WAM, DWORD_METADATA},
        { MD_ASP_THREADGATELOADLOW            , _T("AspThreadGateLoadLow")     ,METADATA_INHERIT, IIS_MD_UT_WAM, DWORD_METADATA},
        { MD_ASP_THREADGATELOADHIGH           , _T("AspThreadGateLoadHigh")    ,METADATA_INHERIT, IIS_MD_UT_WAM, DWORD_METADATA},

        // persist template cache....
        { MD_ASP_DISKTEMPLATECACHEDIRECTORY   , _T("AspDiskTemplateCacheDirectory"),METADATA_INHERIT, IIS_MD_UT_WAM, EXPANDSZ_METADATA},
        { MD_ASP_MAXDISKTEMPLATECACHEFILES    , _T("AspMaxDiskTemplateCacheFiles"),METADATA_INHERIT, IIS_MD_UT_WAM, DWORD_METADATA},

        { MD_ASP_EXECUTEINMTA                 , _T("AspExecuteInMTA"),METADATA_INHERIT, ASP_MD_UT_APP, DWORD_METADATA},

        { MD_ASP_LCID                         , _T("AspLCID")                  ,METADATA_INHERIT, ASP_MD_UT_APP, DWORD_METADATA},

        { MD_ASP_SERVICE_FLAGS                , _T("AspAppServiceFlags")       ,METADATA_INHERIT, ASP_MD_UT_APP, DWORD_METADATA},
        { MD_ASP_SERVICE_FLAG_TRACKER         , _T("AspEnableTracker")         ,METADATA_INHERIT, ASP_MD_UT_APP, DWORD_METADATA},
        { MD_ASP_SERVICE_FLAG_FUSION          , _T("AspEnableSxs")             ,METADATA_INHERIT, ASP_MD_UT_APP, DWORD_METADATA},
        { MD_ASP_SERVICE_FLAG_PARTITIONS      , _T("AspUsePartition")          ,METADATA_INHERIT, ASP_MD_UT_APP, DWORD_METADATA},
        { MD_ASP_SERVICE_PARTITION_ID         , _T("AspPartitionID")           ,METADATA_INHERIT, ASP_MD_UT_APP, DWORD_METADATA},

        //////// WAM params
        //{ MD_APP_COMMAND                  , _T("AppCommand") ,        METADATA_INHERIT, IIS_MD_UT_WAM, DWORD_METADATA},
        //{ MD_APP_STATUS                   , _T("AppStatus")  ,        METADATA_INHERIT, IIS_MD_UT_WAM, DWORD_METADATA},
        //{ MD_APP_ERRORCODE                , _T("AppErrorCode"),       METADATA_INHERIT, IIS_MD_UT_WAM, DWORD_METADATA},
        { MD_APP_ROOT                     , _T("AppRoot"),              METADATA_INHERIT, IIS_MD_UT_WAM, STRING_METADATA},
        { MD_APP_ISOLATED                 , _T("AppIsolated"),  METADATA_INHERIT, IIS_MD_UT_WAM, DWORD_METADATA},
        { MD_APP_WAM_CLSID                , _T("AppWamClsid"),  METADATA_INHERIT, IIS_MD_UT_WAM, STRING_METADATA},
        { MD_APP_PACKAGE_ID               , _T("AppPackageId"), METADATA_INHERIT, IIS_MD_UT_WAM, STRING_METADATA},
        { MD_APP_PACKAGE_NAME             , _T("ApPackageName"),METADATA_INHERIT, IIS_MD_UT_WAM, STRING_METADATA},
        { MD_APP_LAST_OUTPROC_PID         , _T("AppLastOutprocId"),     METADATA_INHERIT, IIS_MD_UT_WAM, DWORD_METADATA},
  //{ MD_APP_WAM_RUNTIME_FLAG         , _T("AppWamRuntimmeFlag"),METADATA_INHERIT, IIS_MD_UT_WAM, DWORD_METADATA},
        //{ MD_APP_OOP_CRASH_LIMIT                , _T("AppOopCrashLimit"),METADATA_INHERIT, IIS_MD_UT_WAM, DWORD_METADATA},

        { MD_VR_NO_CACHE,                   _T("NoCache"),      METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},

        { MD_ENABLE_URL_AUTHORIZATION,      _T("EnableUrlAuthorization"), METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
        { MD_URL_AUTHORIZATION_STORE_NAME,   _T("UrlAuthorizationStoreName"), METADATA_INHERIT, IIS_MD_UT_FILE, STRING_METADATA},
        { MD_URL_AUTHORIZATION_SCOPE_NAME,   _T("UrlAuthorizationScopeName"), METADATA_INHERIT, IIS_MD_UT_FILE, STRING_METADATA},

        {0,0}
};


DWORD MapPropertyNameToCode(const CString & strName)
{
    return tPropertyNameTable::MapNameToCode(strName);
}

// function finds the record within given property name table,
// with the name equal to parameter lpszName
tPropertyNameTable * tPropertyNameTable::FindRecord(const CString strName, tPropertyNameTable * PropertyNameTable)
{
    for(int i=0; PropertyNameTable[i].lpszName!=0;i++)
    {
        if( strName.CompareNoCase(PropertyNameTable[i].lpszName)==0)
            return PropertyNameTable+i;
    }
    return 0;
}

tPropertyNameTable * tPropertyNameTable::FindRecord(DWORD dwCode, tPropertyNameTable * PropertyNameTable)
{
    if(dwCode==0)
            return NULL;
    for(int i=0; PropertyNameTable[i].lpszName!=0;i++)
    {
        if( dwCode==PropertyNameTable[i].dwCode)
            return PropertyNameTable+i;
    }
    return 0;
}

DWORD tPropertyNameTable::MapNameToCode(const CString & strName, tPropertyNameTable * PropertyNameTable)
{
    for(int i=0; PropertyNameTable[i].lpszName!=0;i++)
    {
        if(strName.CompareNoCase(PropertyNameTable[i].lpszName)==0)
            return PropertyNameTable[i].dwCode;
    }
    return NAME_NOT_FOUND;
}

CString tPropertyNameTable::MapCodeToName(DWORD dwCode, tPropertyNameTable * PropertyNameTable)
{
    for(int i=0; PropertyNameTable[i].lpszName!=0;i++)
    {
        if(dwCode == PropertyNameTable[i].dwCode)
            return PropertyNameTable[i].lpszName;
    }
    return _T("");
}


//**********************************************************************
// PROPERTY ATTRIB NAME TABLE  IMPLEMENTATION
//**********************************************************************


//constants defined in imd.h
struct tAttribNameTable gAttribNameTable[]=
{
    {METADATA_NO_ATTRIBUTES, _T("NO_ATTRIBUTES")},
    {METADATA_INHERIT, _T("INHERIT")},
    {METADATA_PARTIAL_PATH, _T("PARTIAL_PATH")},
    {METADATA_SECURE,_T("SECURE")},
    {METADATA_INSERT_PATH,_T("INSERT_PATH")},
//  {METADATA_REFERENCE,_T("REFERENCE")},
//  {METADATA_MASTER_ROOT_HANDLE, _T("MASTER_ROOT_HANDLE")},
//the end
    {0,0}
};

DWORD MapAttribNameToCode(const CString & strName)
{
    return tAttribNameTable::MapNameToCode(strName);
}


DWORD tAttribNameTable::MapNameToCode(const CString& strName, tAttribNameTable * AttribNameTable)
{
    for(int i=0; AttribNameTable[i].lpszName!=0;i++)
    {
        if(strName.CompareNoCase(AttribNameTable[i].lpszName)==0)
            return AttribNameTable[i].dwCode;
    }
    return NAME_NOT_FOUND;
}


//**********************************************************************
// PROPERTY DATA TYPE NAME TABLE MPLEMENTATION
//**********************************************************************

//constants defined in imd.h
tDataTypeNameTable  gDataTypeNameTable[]=
{
    {DWORD_METADATA,    _T("DWORD")},
    {STRING_METADATA,   _T("STRING")},
    {BINARY_METADATA,   _T("BINARY")},
    {EXPANDSZ_METADATA, _T("EXPANDSZ")},
    {MULTISZ_METADATA,  _T("MULTISZ")},
//the end
    {0,0}
};

DWORD MapDataTypeNameToCode(const CString & strName)
{
    return tDataTypeNameTable::MapNameToCode(strName);
}


DWORD tDataTypeNameTable::MapNameToCode(const CString& strName, tDataTypeNameTable * DataTypeNameTable)
{
    for(int i=0; DataTypeNameTable[i].lpszName!=0;i++)
    {
        if(strName.CompareNoCase(DataTypeNameTable[i].lpszName)==0)
            return DataTypeNameTable[i].dwCode;
    }
    return NAME_NOT_FOUND;
}

CString tDataTypeNameTable::MapCodeToName(DWORD a_dwCode, tDataTypeNameTable * DataTypeNameTable)
{
    for(int i=0; DataTypeNameTable[i].lpszName!=0;i++)
    {
        if(a_dwCode==DataTypeNameTable[i].dwCode)
            return DataTypeNameTable[i].lpszName;
    }
    return _T("");
}


//**********************************************************************
// PROPERTY USER TYPE NAME TABLE  IMPLEMENTATION
//**********************************************************************

//constants defined in iiscnfg.h
struct tUserTypeNameTable gUserTypeNameTable[]=
{
    {IIS_MD_UT_SERVER, _T("UT_SERVER")},
    {IIS_MD_UT_FILE, _T("UT_FILE")},
    {IIS_MD_UT_WAM,  _T("UT_WAM")},
    {ASP_MD_UT_APP,  _T("UT_APP")},
//the end
    {0,0}

};

DWORD MapUserTypeNameToCode(const CString & strName)
{
    return tUserTypeNameTable::MapNameToCode(strName);
}


DWORD tUserTypeNameTable::MapNameToCode(const CString& strName, tUserTypeNameTable * UserTypeNameTable)
{
    for(int i=0; UserTypeNameTable[i].lpszName!=0;i++)
    {
        if(strName.CompareNoCase(UserTypeNameTable[i].lpszName)==0)
            return UserTypeNameTable[i].dwCode;
    }
    return NAME_NOT_FOUND;
}



//**********************************************************************
// PROPERTY PREDEFINED VALUES TABLE IMPLEMENTATION
//**********************************************************************

//constants defined in iiscnfg.h

//Predefined values table
struct tValueTable gValueTable[]=
{
//  Valid values for MD_AUTHORIZATION
    {MD_AUTH_ANONYMOUS               ,_T("Anonymous"),  MD_AUTHORIZATION},
    {MD_AUTH_BASIC                   ,_T("Basic"),      MD_AUTHORIZATION},
    {MD_AUTH_NT                      ,_T("NT"),     MD_AUTHORIZATION},
    {MD_AUTH_MD5                     ,_T("MD5"),        MD_AUTHORIZATION},
    {MD_AUTH_MAPBASIC                ,_T("MapBasic"),   MD_AUTHORIZATION},
//  Valid values for MD_ACCESS_PERM
    {MD_ACCESS_READ                  ,_T("Read"),   MD_ACCESS_PERM},
    {MD_ACCESS_WRITE                 ,_T("Write"),  MD_ACCESS_PERM},
    {MD_ACCESS_EXECUTE               ,_T("Execute"),    MD_ACCESS_PERM},
    {MD_ACCESS_SSL                   ,_T("SSL"),        MD_ACCESS_PERM},// Require SSL
    {MD_ACCESS_NEGO_CERT             ,_T("NegoCert"),   MD_ACCESS_PERM},// Allow client SSL certs
    {MD_ACCESS_REQUIRE_CERT          ,_T("RequireCert"),MD_ACCESS_PERM},// Require client SSL certs
    {MD_ACCESS_MAP_CERT              ,_T("MapCert"),MD_ACCESS_PERM},// Map SSL cert to NT account
    {MD_ACCESS_SSL128                ,_T("SSL128"), MD_ACCESS_PERM},// Require 128 bit SSL
    {MD_ACCESS_SCRIPT                ,_T("Script"), MD_ACCESS_PERM},// Script
    {MD_ACCESS_NO_REMOTE_READ        ,_T("NoRemoteRead"), MD_ACCESS_PERM},// NO_REMOTE only
    {MD_ACCESS_NO_REMOTE_WRITE       ,_T("NoRemoteWrite"), MD_ACCESS_PERM},// NO_REMOTE only
    {MD_ACCESS_NO_REMOTE_EXECUTE     ,_T("NoRemoteExecute"), MD_ACCESS_PERM},// NO_REMOTE only
    {MD_ACCESS_NO_REMOTE_SCRIPT      ,_T("NoRemoteScript"), MD_ACCESS_PERM},// NO_REMOTE only
    {MD_ACCESS_MASK                  ,_T("MaskAll"),    MD_ACCESS_PERM},
//  Valid values for MD_SSL_ACCESS_PERM
    {MD_ACCESS_READ                  ,_T("Read"),   MD_SSL_ACCESS_PERM},
    {MD_ACCESS_WRITE                 ,_T("Write"),  MD_SSL_ACCESS_PERM},
    {MD_ACCESS_EXECUTE               ,_T("Execute"),    MD_SSL_ACCESS_PERM},
    {MD_ACCESS_SSL                   ,_T("SSL"),        MD_SSL_ACCESS_PERM},// Require SSL
    {MD_ACCESS_NEGO_CERT             ,_T("NegoCert"),   MD_SSL_ACCESS_PERM},// Allow client SSL certs
    {MD_ACCESS_REQUIRE_CERT          ,_T("RequireCert"),MD_SSL_ACCESS_PERM},// Require client SSL certs
    {MD_ACCESS_MAP_CERT              ,_T("MapCert"),MD_SSL_ACCESS_PERM},// Map SSL cert to NT account
    {MD_ACCESS_SSL128                ,_T("SSL128"), MD_SSL_ACCESS_PERM},// Require 128 bit SSL
    {MD_ACCESS_SCRIPT                ,_T("Script"), MD_SSL_ACCESS_PERM},// Script
    {MD_ACCESS_NO_REMOTE_READ        ,_T("NoRemoteRead"), MD_SSL_ACCESS_PERM},// NO_REMOTE only
    {MD_ACCESS_NO_REMOTE_WRITE       ,_T("NoRemoteWrite"), MD_SSL_ACCESS_PERM},// NO_REMOTE only
    {MD_ACCESS_NO_REMOTE_EXECUTE     ,_T("NoRemoteExecute"), MD_SSL_ACCESS_PERM},// NO_REMOTE only
    {MD_ACCESS_NO_REMOTE_SCRIPT      ,_T("NoRemoteScript"), MD_SSL_ACCESS_PERM},// NO_REMOTE only
    {MD_ACCESS_MASK                  ,_T("MaskAll"),    MD_SSL_ACCESS_PERM},
//  Valid values for MD_DIRECTORY_BROWSING
    {MD_DIRBROW_SHOW_DATE            ,_T("Date"),   MD_DIRECTORY_BROWSING},
    {MD_DIRBROW_SHOW_TIME            ,_T("Time"),   MD_DIRECTORY_BROWSING},
    {MD_DIRBROW_SHOW_SIZE            ,_T("Size"),   MD_DIRECTORY_BROWSING},
    {MD_DIRBROW_SHOW_EXTENSION       ,_T("Extension"), MD_DIRECTORY_BROWSING},
    {MD_DIRBROW_LONG_DATE            ,_T("LongDate"),   MD_DIRECTORY_BROWSING},
    {MD_DIRBROW_ENABLED              ,_T("Enabled"),   MD_DIRECTORY_BROWSING},// Allow directory browsing
    {MD_DIRBROW_LOADDEFAULT          ,_T("LoadDefault"),MD_DIRECTORY_BROWSING},// Load default doc if exists
    {MD_DIRBROW_MASK                 ,_T("MaskAll"),        MD_DIRECTORY_BROWSING},
//  Valid values for MD_LOGON_METHOD
    {MD_LOGON_INTERACTIVE    ,_T("Interactive"),    MD_LOGON_METHOD, tValueTable::TYPE_EXCLUSIVE},
    {MD_LOGON_BATCH          ,_T("Batch"),      MD_LOGON_METHOD, tValueTable::TYPE_EXCLUSIVE},
    {MD_LOGON_NETWORK        ,_T("Network"),        MD_LOGON_METHOD, tValueTable::TYPE_EXCLUSIVE},
//  Valid values for MD_FILTER_STATE
    {MD_FILTER_STATE_LOADED          ,_T("Loaded"), MD_FILTER_STATE,    tValueTable::TYPE_EXCLUSIVE},
    {MD_FILTER_STATE_UNLOADED        ,_T("Unloaded"),   MD_FILTER_STATE,    tValueTable::TYPE_EXCLUSIVE },
//  Valid values for MD_FILTER_FLAGS
    {/*SF_NOTIFY_SECURE_PORT*/0x00000001         ,_T("SecurePort"), MD_FILTER_FLAGS},
    {/*SF_NOTIFY_NONSECURE_PORT*/0x00000002      ,_T("NonSecurePort"), MD_FILTER_FLAGS},
    {/*SF_NOTIFY_READ_RAW_DATA*/0x000008000      ,_T("ReadRawData"), MD_FILTER_FLAGS},
    {/*SF_NOTIFY_PREPROC_HEADERS*/0x00004000     ,_T("PreprocHeaders"), MD_FILTER_FLAGS},
    {/*SF_NOTIFY_AUTHENTICATION*/0x00002000      ,_T("Authentication"), MD_FILTER_FLAGS},
    {/*SF_NOTIFY_URL_MAP*/0x00001000             ,_T("UrlMap"), MD_FILTER_FLAGS},
    {/*SF_NOTIFY_ACCESS_DENIED*/0x00000800       ,_T("AccessDenied"), MD_FILTER_FLAGS},
    {/*SF_NOTIFY_SEND_RESPONSE*/0x00000040       ,_T("SendResponse"), MD_FILTER_FLAGS},
    {/*SF_NOTIFY_SEND_RAW_DATA*/0x00000400       ,_T("SendRawData"), MD_FILTER_FLAGS},
    {/*SF_NOTIFY_LOG*/0x00000200                 ,_T("NotifyLog"), MD_FILTER_FLAGS},
    {/*SF_NOTIFY_END_OF_REQUEST*/0x00000080      ,_T("EndOfRequest"), MD_FILTER_FLAGS},
    {/*SF_NOTIFY_END_OF_NET_SESSION*/0x00000100  ,_T("EndOfNetSession"), MD_FILTER_FLAGS},
    {/*SF_NOTIFY_AUTHENTICATIONEX*/  0x20000000  ,_T("AuthenticationX"), MD_FILTER_FLAGS},
    {/*SF_NOTIFY_REQUEST_SECURITY_CONTEXT_CLOSE*/0x10000000,_T("RequestSecurityContextClose"), MD_FILTER_FLAGS},
    {/*SF_NOTIFY_RENEGOTIATE_CERT*/0x08000000,   _T("RenegotiateCert"), MD_FILTER_FLAGS},

    {/*SF_NOTIFY_ORDER_HIGH*/0x00080000   ,_T("OrderHigh"), MD_FILTER_FLAGS},
    {/*SF_NOTIFY_ORDER_MEDIUM*/0x00040000   ,_T("OrderMedium"), MD_FILTER_FLAGS},
    {/*SF_NOTIFY_ORDER_LOW*/0x00020000   ,_T("OrderLow"), MD_FILTER_FLAGS},

//  Valid values for MD_SERVER_STATE
    {MD_SERVER_STATE_STARTING        ,_T("Starting"),   MD_SERVER_STATE,    tValueTable::TYPE_EXCLUSIVE},
    {MD_SERVER_STATE_STARTED         ,_T("Started"),    MD_SERVER_STATE,    tValueTable::TYPE_EXCLUSIVE},
    {MD_SERVER_STATE_STOPPING        ,_T("Stopping"),   MD_SERVER_STATE,    tValueTable::TYPE_EXCLUSIVE},
    {MD_SERVER_STATE_STOPPED         ,_T("Stopped"),    MD_SERVER_STATE,    tValueTable::TYPE_EXCLUSIVE},
    {MD_SERVER_STATE_PAUSING         ,_T("Pausing"),    MD_SERVER_STATE,    tValueTable::TYPE_EXCLUSIVE},
    {MD_SERVER_STATE_PAUSED          ,_T("Paused"),     MD_SERVER_STATE,    tValueTable::TYPE_EXCLUSIVE},
    {MD_SERVER_STATE_CONTINUING      ,_T("Continuing"), MD_SERVER_STATE,    tValueTable::TYPE_EXCLUSIVE},
//  Valid values for MD_SERVER_COMMAND
    {MD_SERVER_COMMAND_START         ,_T("Start"),      MD_SERVER_COMMAND,  tValueTable::TYPE_EXCLUSIVE},
    {MD_SERVER_COMMAND_STOP          ,_T("Stop"),       MD_SERVER_COMMAND,  tValueTable::TYPE_EXCLUSIVE},
    {MD_SERVER_COMMAND_PAUSE         ,_T("Pause"),      MD_SERVER_COMMAND,  tValueTable::TYPE_EXCLUSIVE},
    {MD_SERVER_COMMAND_CONTINUE      ,_T("Continue"),   MD_SERVER_COMMAND,  tValueTable::TYPE_EXCLUSIVE},
//  Valid values for MD_SERVER_SIZE
    {MD_SERVER_SIZE_SMALL            ,_T("Small"),  MD_SERVER_SIZE, tValueTable::TYPE_EXCLUSIVE},
    {MD_SERVER_SIZE_MEDIUM           ,_T("Medium"), MD_SERVER_SIZE, tValueTable::TYPE_EXCLUSIVE},
    {MD_SERVER_SIZE_LARGE            ,_T("Large"),  MD_SERVER_SIZE, tValueTable::TYPE_EXCLUSIVE},
// Valid values for MD_USER_ISOLATION
    {MD_USER_ISOLATION_NONE          ,_T("IsolationDisabled"),   MD_USER_ISOLATION, tValueTable::TYPE_EXCLUSIVE},
    {MD_USER_ISOLATION_BASIC         ,_T("IsolationStandAlone"), MD_USER_ISOLATION, tValueTable::TYPE_EXCLUSIVE},
    {MD_USER_ISOLATION_AD            ,_T("IsolationUsingAD"),    MD_USER_ISOLATION, tValueTable::TYPE_EXCLUSIVE},
// valid values for MD_CERT_CHECK_MODE
    {MD_CERT_NO_REVOC_CHECK          ,_T("NoRevocCheck"), MD_CERT_CHECK_MODE},
    //{APPCMD_NONE, _T("None"),MD_APP_COMMAND, tValueTable::TYPE_EXCLUSIVE},
    //{APPCMD_VERIFY, _T("Verify"),MD_APP_COMMAND, tValueTable::TYPE_EXCLUSIVE},
    //{APPCMD_GETSTATUS, _T("GetStatus"),MD_APP_COMMAND, tValueTable::TYPE_EXCLUSIVE},
    //{APPCMD_CREATE, _T("Create"),MD_APP_COMMAND, tValueTable::TYPE_EXCLUSIVE},
    //{APPCMD_CREATEINPROC, _T("CreateInProc"),MD_APP_COMMAND, tValueTable::TYPE_EXCLUSIVE},
    //{APPCMD_CREATEOUTPROC, _T("CreateOutProc"),MD_APP_COMMAND, tValueTable::TYPE_EXCLUSIVE},
    //{APPCMD_CHANGETOINPROC, _T("ChangeToInProc"),MD_APP_COMMAND, tValueTable::TYPE_EXCLUSIVE},
    //{APPCMD_CHANGETOOUTPROC, _T("ChangeToOutProc"),MD_APP_COMMAND, tValueTable::TYPE_EXCLUSIVE},
    //{APPCMD_DELETE, _T("Delete"),MD_APP_COMMAND, tValueTable::TYPE_EXCLUSIVE},
    //{APPCMD_UNLOAD, _T("Unload"),MD_APP_COMMAND, tValueTable::TYPE_EXCLUSIVE},

    //{APPSTATUS_Error, _T("Error"),            MD_APP_STATUS, tValueTable::TYPE_EXCLUSIVE},
    //{APPSTATUS_Created, _T("Created"),        MD_APP_STATUS, tValueTable::TYPE_EXCLUSIVE},
    //{APPSTATUS_Deleted, _T("Deleted"),        MD_APP_STATUS, tValueTable::TYPE_EXCLUSIVE},
    //{APPSTATUS_UnLoaded, _T("Unloaded"),      MD_APP_STATUS, tValueTable::TYPE_EXCLUSIVE},
    //{APPSTATUS_Killed, _T("Killed"),  MD_APP_STATUS, tValueTable::TYPE_EXCLUSIVE},
    //{APPSTATUS_Running, _T("Running"),        MD_APP_STATUS, tValueTable::TYPE_EXCLUSIVE},
    //{APPSTATUS_Stopped, _T("Stopped"),        MD_APP_STATUS, tValueTable::TYPE_EXCLUSIVE},
    //{APPSTATUS_NoApplication, _T("NoApplication"),    MD_APP_STATUS, tValueTable::TYPE_EXCLUSIVE},
    //{APPSTATUS_AppSubNode, _T("AppSubNode"),  MD_APP_STATUS, tValueTable::TYPE_EXCLUSIVE},


// NEED LOGGING Updates
#if 0
    {MD_LOGTYPE_NONE     ,_T("LOGTYPE_NONE")},
    {MD_LOGTYPE_FILE     ,_T("LOGTYPE_FILE")},
    {MD_LOGTYPE_ODBC     ,_T("LOGTYPE_ODBC")},
    {MD_LOGFILE_PERIOD_MAXSIZE   ,_T("LOGFILE_PERIOD_MAXSIZE")},
    {MD_LOGFILE_PERIOD_DAILY     ,_T("LOGFILE_PERIOD_DAILY")},
    {MD_LOGFILE_PERIOD_WEEKLY    ,_T("LOGFILE_PERIOD_WEEKLY")},
    {MD_LOGFILE_PERIOD_MONTHLY   ,_T("LOGFILE_PERIOD_MONTHLY")},
#endif
//the end
    {0,0}
};

DWORD  MapValueNameToCode(const CString & strName,DWORD dwRelatedPropertyCode)
{
    return tValueTable::MapNameToCode(strName, dwRelatedPropertyCode);
}


DWORD  tValueTable::MapNameToCode(const CString& strName, DWORD dwRelatedPropertyCode, tValueTable * ValueTable)
{
    for(int i=0; ValueTable[i].lpszName!=0;i++)
    {
        if((strName.CompareNoCase(ValueTable[i].lpszName)==0) && ValueTable[i].dwRelatedPropertyCode==dwRelatedPropertyCode)
            return ValueTable[i].dwCode;
    }
    return NAME_NOT_FOUND;
}

CString  tValueTable::MapValueContentToString(DWORD dwValueContent, DWORD dwRelatedPropertyCode, tValueTable * ValueTable)
{
    CString strResult=_T("");
    for(int i=0; ValueTable[i].lpszName!=0;i++)
    {
        if(ValueTable[i].dwRelatedPropertyCode==dwRelatedPropertyCode)
        {
            if(ValueTable[i].dwFlags==tValueTable::TYPE_EXCLUSIVE)
            {
                if (ValueTable[i].dwCode == dwValueContent)
                    return ValueTable[i].lpszName;
            }
            else if ((ValueTable[i].dwCode & dwValueContent) == ValueTable[i].dwCode)
            {
                strResult = strResult + ValueTable[i].lpszName + _T(" ");
            }

        }
    }
    strResult.TrimRight();
    return strResult;
}


//prints info about what is stored in tables so that user can see the predefined names and values

void PrintTablesInfo(void)
{
    //Print supported property names
    _tprintf(_T("***The following list of property names (IIS parameters) is supported:\n"));
    _tprintf(_T("------------------------------------------------------------------------------\n"));
    _tprintf(_T("%-25s: \t%-10s %s\n"),_T("Property Name"), _T("Data type"), _T("Attributes and User Type"));
    _tprintf(_T("\t\t--Predefined Values\n"));
    _tprintf(_T("------------------------------------------------------------------------------\n"));
    for(int i=0; gPropertyNameTable[i].lpszName!=NULL; i++)
    {
       _tprintf(_T("%-25s: \t%-10s "),gPropertyNameTable[i].lpszName,
            LPCTSTR(_T("(")+tDataTypeNameTable::MapCodeToName(gPropertyNameTable[i].dwDefDataType)+_T(")")));
        if( (METADATA_INHERIT & gPropertyNameTable[i].dwDefAttributes) == METADATA_INHERIT)
        {   _tprintf(_T("INHERIT\t"));
        }
        if( (IIS_MD_UT_SERVER & gPropertyNameTable[i].dwDefUserType) == IIS_MD_UT_SERVER)
        {   _tprintf(_T("UT_SERVER\t"));
        }

        if( (IIS_MD_UT_FILE & gPropertyNameTable[i].dwDefUserType) == IIS_MD_UT_FILE)
        {   _tprintf(_T("UT_FILE "));
        }

        _tprintf(_T("\n"));

        //print list of applicable values

        for(int j=0; gValueTable[j].lpszName!=NULL;j++)
        {
            if( gValueTable[j].dwRelatedPropertyCode==gPropertyNameTable[i].dwCode)
            {
                _tprintf(_T("\t\t %-15s (=0x%x)\n"),gValueTable[j].lpszName,gValueTable[j].dwCode);

            }
        }
    }
    _tprintf(_T("\n***The following list of user types (for IIS parameters) is supported:\n"));
    for(i=0; gUserTypeNameTable[i].lpszName!=NULL; i++)
    {
        _tprintf(_T("%s "),gUserTypeNameTable[i].lpszName);
    }

    _tprintf(_T("\n\n***The following list of data types (for IIS parameters) is supported:\n"));
    for(i=0; gDataTypeNameTable[i].lpszName!=NULL; i++)
    {
        _tprintf(_T("%s  "),gDataTypeNameTable[i].lpszName);
    }
    _tprintf(_T("\n\n***The following list of attributes (for IIS parameters) is supported:\n"));
    for( i=0; gAttribNameTable[i].lpszName!=NULL; i++)
    {
        _tprintf(_T("%s  "),gAttribNameTable[i].lpszName);
    }
    _tprintf(_T("\n"));

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\extend\globals.cxx ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    globals.cxx

Abstract:

    IIS Services IISADMIN Extension
    Global Variables

Author:

    Michael W. Thomas            16-Sep-97

--*/

#define INITGUID

extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}
#include <ole2.h>
#include <windows.h>
#include <olectl.h>
#include <stdio.h>
#include <iadmext.h>
#include <coimp.hxx>


ULONG g_dwRefCount;
CAdmExtSrvFactory g_aesFactory;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\dcomadm\mdutil\vptool.cpp ===
/*===================================================================
Microsoft ASP

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: Package Management Tool

File: main.cpp

Owner: leijin

Note:
===================================================================*/


#include <tchar.h>

#include "admutil.h"
#include <stdio.h>
#include <objbase.h>
#include <initguid.h>

//#ifdef _WAMREG_LINK_DIRECT
//#include "..\wmrgexp.h"
//#endif

#include <iwamreg.h>

#define SIZE_STRING_BUFFER  1024


void CAdmUtil::OpenWamAdm (const CString & strComputer)
{
    IClassFactory * pcsfFactory = NULL;
    COSERVERINFO csiMachineName;
    COSERVERINFO *pcsiParam = NULL;
    OLECHAR rgchMachineName[MAX_PATH];

    //release previous interface if needed
    if(pIWamAdm!=0 && pIWamAdm2!=0)
    {
	//reuse the interface
	return;
        //pIWamAdm->Release();
        //pIWamAdm=0;
    }
    //convert to OLECHAR[];
    #if UNICODE
        wsprintfW( rgchMachineName, L"%s", LPCTSTR(strComputer));
    #else
            wsprintfW( rgchMachineName, L"%S", LPCTSTR(strComputer));
    #endif
            
    //fill the structure for CoGetClassObject
    ZeroMemory( &csiMachineName, sizeof(csiMachineName) );
    // csiMachineName.pAuthInfo = NULL;
    // csiMachineName.dwFlags = 0;
    // csiMachineName.pServerInfoExt = NULL;
    pcsiParam = &csiMachineName;
    csiMachineName.pwszName =  (strComputer.IsEmpty())?NULL:rgchMachineName;

    hresError = CoGetClassObject(CLSID_WamAdmin, CLSCTX_SERVER, pcsiParam,
                            IID_IClassFactory, (void**) &pcsfFactory);

    if (FAILED(hresError))
    {
     Error(_T("Failed to CoGetClassObject of WamAdm object"));
    }
    else {
        hresError = pcsfFactory->CreateInstance(NULL, IID_IWamAdmin, (void **) &pIWamAdm);
        if (FAILED(hresError)) Error(_T("Failed to CreateInstance of WamAdm object"));
        hresError = pcsfFactory->CreateInstance(NULL, IID_IWamAdmin2, (void **) &pIWamAdm2);
        if (FAILED(hresError)) Error(_T("Failed to CreateInstance of WamAdm2 object"));

        pcsfFactory->Release();
    }
}

void CAdmUtil::CloseWamAdm (void)
{
	if(pIWamAdm!=0)
    {
        pIWamAdm->Release();
	pIWamAdm2->Release();
        pIWamAdm=0;        pIWamAdm2=0;
    }
}

void CAdmUtil::AppCreateInProc(const _TCHAR* szPath,const CString & strComputer)
{
    WCHAR       wszMetabasePath[SIZE_STRING_BUFFER];
    HRESULT     hr = NOERROR;
    //  
    INT         cSize = 0;
    INT         cch = 0;
#ifndef UNICODE
    cSize = MultiByteToWideChar(0, 0, szPath, -1, wszMetabasePath, SIZE_STRING_BUFFER);
    if (cSize == 0)
    {
        hresError =  GetLastError();
        if (hresError == ERROR_INSUFFICIENT_BUFFER)
        {
            Error(_T("metabase path exceeds 1024 chars"));
        }
        else
            Error("");
        return;
    }
#else
    wcscpy(wszMetabasePath,szPath);
#endif
    
    OpenWamAdm(strComputer);

    if (pIWamAdm!=0)
    {
		CloseObject_hmd(); //close reusable handle; it may conflict with WAM
        hresError = pIWamAdm2->AppCreate2(wszMetabasePath, eAppRunInProc);
        if (FAILED(hresError))
            {
            Error(_T("create failed"));
            }
        else
            {
            Print(_T("inproc application created\n"));
            }
    }

    //CloseWamAdm();

    return;
}


void CAdmUtil::AppCreateOutPool(const _TCHAR* szPath,const CString & strComputer)
{
    WCHAR       wszMetabasePath[SIZE_STRING_BUFFER];
    HRESULT     hr = NOERROR;
    //  
    INT         cSize = 0;
    INT         cch = 0;
#ifndef UNICODE
    cSize = MultiByteToWideChar(0, 0, szPath, -1, wszMetabasePath, SIZE_STRING_BUFFER);
    if (cSize == 0)
    {
        hresError =  GetLastError();
        if (hresError == ERROR_INSUFFICIENT_BUFFER)
        {
            Error(_T("metabase path exceeds 1024 chars"));
        }
        else
            Error("");
        return;
    }
#else
    wcscpy(wszMetabasePath,szPath);
#endif
    
    OpenWamAdm(strComputer);

    if (pIWamAdm!=0)
    {
	CloseObject_hmd(); //close reusable handle; it may conflict with WAM
        hresError = pIWamAdm2->AppCreate2(wszMetabasePath, eAppRunOutProcInDefaultPool);
        if (FAILED(hresError))
            {
            Error(_T("pooled create failed"));
            }
        else
            {
            Print(_T("pooled application created\n"));
            }
    }

    //CloseWamAdm();

    return;
}


void CAdmUtil::AppCreateOutProc(const _TCHAR* szPath,const CString & strComputer)
{
    WCHAR       wszMetabasePath[SIZE_STRING_BUFFER];
    
    
    INT         cSize = 0;
    INT         cch = 0;

#ifndef UNICODE
    cSize = MultiByteToWideChar(0, 0, szPath, -1, wszMetabasePath, SIZE_STRING_BUFFER);
    if (cSize == 0)
    {
        hresError =  GetLastError();
        if (hresError == ERROR_INSUFFICIENT_BUFFER)
        {
            Error(_T("metabase path exceeds 1024 chars"));
        }
        else
            Error("");
        return;
    }
#else
    wcscpy(wszMetabasePath,szPath);
#endif
    OpenWamAdm(strComputer);
    if (pIWamAdm!=0)
    {
		CloseObject_hmd(); //close reusable handle; it may conflict with WAM
        hresError = pIWamAdm->AppCreate(wszMetabasePath, FALSE);
        if (FAILED(hresError))
        {
            Error(_T("create failed"));
        }
        else
        {
            Print(_T("application created\n"));
        }
    }
    //CloseWamAdm();
    return;
}

void CAdmUtil::AppDelete(const _TCHAR* szPath,const CString & strComputer)
{
    WCHAR       wszMetabasePath[SIZE_STRING_BUFFER];


    INT         cSize = 0;
    INT         cch = 0;

#ifndef UNICODE
    cSize = MultiByteToWideChar(0, 0, szPath, -1, wszMetabasePath, SIZE_STRING_BUFFER);
    if (cSize == 0)
    {
        hresError =  GetLastError();
        if (hresError == ERROR_INSUFFICIENT_BUFFER)
        {
            Error(_T("metabase path exceeds 1024 chars"));
        }
        else
            Error("");
        return;
    }
#else
    wcscpy(wszMetabasePath,szPath);
#endif
    OpenWamAdm(strComputer);
    if (pIWamAdm!=0)
        {
		CloseObject_hmd(); //close reusable handle; it may conflict with WAM
        hresError = pIWamAdm->AppDelete(wszMetabasePath,FALSE);
        if (FAILED(hresError))
            {
            Error(_T("delete failed"));
            }   
        else
            {
            Print(_T("application deleted\n"));
            }
        }
    //CloseWamAdm();
    return;
}

void CAdmUtil::AppRename(CAdmNode& a_AdmNode, CAdmNode& a_AdmDstNode, const CString & strComputer)
{
    WCHAR       wszMetabasePath[SIZE_STRING_BUFFER];

    WCHAR       wszMetabaseDstPath[SIZE_STRING_BUFFER];

    INT         cSize = 0;
    INT         cch = 0;

#ifndef UNICODE
    cSize = MultiByteToWideChar(0, 0, LPCTSTR(a_AdmNode.GetLMNodePath()), -1, wszMetabasePath, SIZE_STRING_BUFFER);
    if (cSize == 0)
    {
        hresError =  GetLastError();
        if (hresError == ERROR_INSUFFICIENT_BUFFER)
        {
            Error(_T("metabase path exceeds 1024 chars"));
        }
        else
            Error("");
        return;
    }

    wcscat(wszMetabaseDstPath,L"/");
    cSize = MultiByteToWideChar(0, 0, LPCTSTR(a_AdmDstNode.GetLMNodePath()), -1, wszMetabaseDstPath, SIZE_STRING_BUFFER);
    if (cSize == 0)
    {
        hresError =  GetLastError();
        if (hresError == ERROR_INSUFFICIENT_BUFFER)
        {
            Error(_T("metabase path exceeds 1024 chars"));
        }
        else
            Error("");
        return;
    }
    wcscat(wszMetabaseDstPath,L"/");

#else
    wcscpy(wszMetabasePath,LPCTSTR(a_AdmNode.GetLMNodePath()));
    wcscpy(wszMetabaseDstPath,LPCTSTR(a_AdmDstNode.GetLMNodePath()));
#endif


    OpenWamAdm(strComputer);
    if (pIWamAdm!=0)
        {
	    CloseObject_hmd(); //close reusable handle; it may conflict with WAM
            hresError = pIWamAdm->AppDeleteRecoverable(wszMetabasePath,TRUE /*Recursive*/);
            if (FAILED(hresError))
            {
                Error(_T("AppDeleteRecoverable() failed"));
            }   
            else
            {
                RenameObject(a_AdmNode,a_AdmDstNode);
                if(FAILED(QueryLastHresError()))
                {
                   Error(_T("node failed to be renamed"));
                }
                else
                {  
	          CloseObject_hmd(); //close reusable handle; it may conflict with WAM
                  hresError = pIWamAdm->AppRecover(wszMetabaseDstPath,TRUE /*Recursive*/);
 	          if (FAILED(hresError))
                  {
                     Error(_T("AppRecover() failed"));
                  }
		  else
                  {
                     Print(_T("application renamed\n"));
                  }
                }
             }
        }
    //CloseWamAdm();
    return;
}


void CAdmUtil::AppUnLoad(const _TCHAR* szPath,const CString & strComputer)
{
    WCHAR       wszMetabasePath[SIZE_STRING_BUFFER];


    INT         cSize = 0;
    INT         cch = 0;

#ifndef UNICODE
    cSize = MultiByteToWideChar(0, 0, szPath, -1, wszMetabasePath, SIZE_STRING_BUFFER);
    if (cSize == 0)
    {
        hresError =  GetLastError();
        if (hresError == ERROR_INSUFFICIENT_BUFFER)
        {
            Error(_T("metabase path exceeds 1024 chars"));
        }
        else
            Error("");
        return;
    }
#else
    wcscpy(wszMetabasePath,szPath);
#endif
    OpenWamAdm(strComputer);
    if (pIWamAdm!=0)
        {
		CloseObject_hmd(); //close reusable handle; it may conflict with WAM
        hresError = pIWamAdm->AppUnLoad(wszMetabasePath,FALSE);
        if (FAILED(hresError))
            {
            Error(_T("Unload application failed"));
            }
        else
            {
            Print(_T("application unloaded\n"));
            }

        }
    //CloseWamAdm();
    return;
}

void CAdmUtil::AppGetStatus(const _TCHAR* szPath,const CString & strComputer)
{
    WCHAR       wszMetabasePath[SIZE_STRING_BUFFER];
    

    INT         cSize = 0;
    INT         cch = 0;

#ifndef UNICODE
    cSize = MultiByteToWideChar(0, 0, szPath, -1, wszMetabasePath, SIZE_STRING_BUFFER);
    if (cSize == 0)
    {
        hresError =  GetLastError();
        if (hresError == ERROR_INSUFFICIENT_BUFFER)
        {
            Error(_T("The Metabase path exceeds 1024 chars"));
        }
        else
            Error("");
        return;
    }
#else
    wcscpy(wszMetabasePath,szPath);
#endif
    OpenWamAdm(strComputer);
    if (pIWamAdm!=0)
        {
        DWORD dwStatus;
		CloseObject_hmd(); //close reusable handle; it may conflict with WAM
        hresError = pIWamAdm->AppGetStatus(wszMetabasePath, &dwStatus);
        if (FAILED(hresError))
            {
            Error(_T("GetStatus of application  %s failed"));
            }
        else
            {
            if (dwStatus == APPSTATUS_NOTDEFINED)
                {
                Print(_T("Application is not defined\n"));
                }
            else if (dwStatus == APPSTATUS_STOPPED)
                {
                Print(_T("Application is stopped\n"));
                }
            else if (dwStatus == APPSTATUS_RUNNING)
                {
                Print(_T("Application is running\n"));
                }
            else
                {
                Print(_T("Application is in unknown state\n"));
                }
            }                   
        }
    //CloseWamAdm();
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\extend\logevent.cxx ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    logevent.cxx

Abstract:

    Simple function creating isntance of Event_LOG object
    I need a separate file for that because API for constructor takes
    only ANSI string and can't be called from unicode CPP file

Author:

    Kestutis Patiejunas           05-12-99

--*/
#include <eventlog.hxx>



extern EVENT_LOG *g_eventLogForAccountRecreation; 

BOOL CreateEventLogObject()
{
	g_eventLogForAccountRecreation = new EVENT_LOG("IISADMIN");
	return 	(g_eventLogForAccountRecreation != NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\extend\cofact.cxx ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    cofact.cxx

Abstract:

    IIS Services IISADMIN Extension
    Class Factory and Registration.
    CLSID = CLSID_W3EXTEND

Author:

    Michael W. Thomas            16-Sep-97

--*/

//
// Do not include cominc.hxx, as it sets Unicode, which breaks registration on Win95
//

extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}
#include <ole2.h>
#include <windows.h>
#include <olectl.h>
#include <stdio.h>
#include <imd.h>
#include <iadmext.h>
#include <coimp.hxx>

CAdmExtSrvFactory::CAdmExtSrvFactory()
    :m_admextObject()
{
    m_dwRefCount=0;
    g_dwRefCount = 0;
    //
    // Addref object, so refcount doesn't go to 0 if all clients release.
    //
    m_admextObject.AddRef();
}

CAdmExtSrvFactory::~CAdmExtSrvFactory()
{
    m_admextObject.Release();
}
HRESULT
CAdmExtSrvFactory::CreateInstance(IUnknown *pUnkOuter, REFIID riid, void ** ppObject)
{
    if (pUnkOuter != NULL) {
        return CLASS_E_NOAGGREGATION;
    }
    if (FAILED(m_admextObject.QueryInterface(riid, ppObject))) {
        return E_NOINTERFACE;
    }
    return NO_ERROR;
}

HRESULT
CAdmExtSrvFactory::LockServer(BOOL fLock)
{
    if (fLock) {
        InterlockedIncrement((long *)&g_dwRefCount);
    }
    else {
        InterlockedDecrement((long *)&g_dwRefCount);
    }
    return NO_ERROR;
}

HRESULT
CAdmExtSrvFactory::QueryInterface(REFIID riid, void **ppObject)
{
    if (riid==IID_IUnknown || riid == IID_IClassFactory) {
            *ppObject = (IClassFactory *) this;
    }
    else {
        return E_NOINTERFACE;
    }
    AddRef();
    return NO_ERROR;
}

ULONG
CAdmExtSrvFactory::AddRef()
{
    DWORD dwRefCount;
    InterlockedIncrement((long *)&g_dwRefCount);
    dwRefCount = InterlockedIncrement((long *)&m_dwRefCount);
    return dwRefCount;
}

ULONG
CAdmExtSrvFactory::Release()
{
    DWORD dwRefCount;
    InterlockedDecrement((long *)&g_dwRefCount);
    dwRefCount = InterlockedDecrement((long *)&m_dwRefCount);
    //
    // There must only be one copy of this. So keep the first one around regardless.
    //
    //    if (dwRefCount == 0) {
    //        delete this;
    //    }
    return dwRefCount;
}

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, void** ppObject)
{
    if (rclsid != CLSID_W3EXTEND) {
        return CLASS_E_CLASSNOTAVAILABLE;
    }

    if (FAILED(g_aesFactory.QueryInterface(riid, ppObject))) {
        *ppObject = NULL;
        return E_INVALIDARG;
    }
    return NO_ERROR;
}

HRESULT _stdcall DllCanUnloadNow() {
        if (g_dwRefCount) {
                return S_FALSE;
                }
        else {
                return S_OK;
                }
}

STDAPI DllRegisterServer(void)
{
    HKEY hKeyCLSID, hKeyInproc32;
    DWORD dwDisposition;
    HMODULE hModule;
    DWORD dwReturn = ERROR_SUCCESS;

    dwReturn = RegCreateKeyEx(HKEY_CLASSES_ROOT,
                              TEXT("CLSID\\{FCC764A0-2A38-11d1-B9C6-00A0C922E750}"),
                              NULL,
                              TEXT(""),
                              REG_OPTION_NON_VOLATILE,
                              KEY_ALL_ACCESS,
                              NULL,
                              &hKeyCLSID,
                              &dwDisposition);
    if (dwReturn == ERROR_SUCCESS) {
        dwReturn = RegSetValueEx(hKeyCLSID,
                                 TEXT(""),
                                 NULL,
                                 REG_SZ,
                                 (BYTE*) TEXT("IIS Servers Extension"),
                                 sizeof(TEXT("IIS Servers Extension")));
        if (dwReturn == ERROR_SUCCESS) {
            dwReturn = RegCreateKeyEx(hKeyCLSID,
                "InprocServer32",
                NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                &hKeyInproc32, &dwDisposition);

            if (dwReturn == ERROR_SUCCESS) {
                hModule=GetModuleHandle(TEXT("SVCEXT.DLL"));
                if (!hModule) {
                    dwReturn = GetLastError();
                }
                else {
                    TCHAR szName[MAX_PATH+1];
                    if (GetModuleFileName(hModule,
                                          szName,
                                          sizeof(szName)) == NULL) {
                        dwReturn = GetLastError();
                    }
                    else {
                        dwReturn = RegSetValueEx(hKeyInproc32,
                                                 TEXT(""),
                                                 NULL,
                                                 REG_SZ,
                                                 (BYTE*) szName,
                                                 sizeof(TCHAR)*(lstrlen(szName)+1));
                        if (dwReturn == ERROR_SUCCESS) {
                            dwReturn = RegSetValueEx(hKeyInproc32,
                                                     TEXT("ThreadingModel"),
                                                     NULL,
                                                     REG_SZ,
                                                     (BYTE*) TEXT("Both"),
                                                     sizeof(TEXT("Both")));
                        }
                    }
                }
                RegCloseKey(hKeyInproc32);
            }
        }
        RegCloseKey(hKeyCLSID);
    }

    if (dwReturn == ERROR_SUCCESS) {

        dwReturn = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                                  IISADMIN_EXTENSIONS_REG_KEYA
                                  "\\{FCC764A0-2A38-11d1-B9C6-00A0C922E750}",
                                  NULL,
                                  "",
                                  REG_OPTION_NON_VOLATILE,
                                  KEY_ALL_ACCESS,
                                  NULL,
                                  &hKeyCLSID,
                                  &dwDisposition);

        if (dwReturn == ERROR_SUCCESS) {
            RegCloseKey(hKeyCLSID);
        }

    }

    return HRESULT_FROM_WIN32(dwReturn);
}

STDAPI DllUnregisterServer(void)
{
    DWORD dwReturn = ERROR_SUCCESS;
    DWORD dwTemp;

    dwTemp = RegDeleteKey(HKEY_CLASSES_ROOT,
                          TEXT("CLSID\\{FCC764A0-2A38-11d1-B9C6-00A0C922E750}\\InprocServer32"));
    if (dwTemp != ERROR_SUCCESS) {
        dwReturn = dwTemp;
    }
    dwTemp = RegDeleteKey(HKEY_CLASSES_ROOT,
                          TEXT("CLSID\\{FCC764A0-2A38-11d1-B9C6-00A0C922E750}"));
    if (dwTemp != ERROR_SUCCESS) {
        dwReturn = dwTemp;
    }
    dwTemp = RegDeleteKey(HKEY_LOCAL_MACHINE,
                          IISADMIN_EXTENSIONS_REG_KEY
                              TEXT("\\{FCC764A0-2A38-11d1-B9C6-00A0C922E750}"));
    if (dwTemp != ERROR_SUCCESS) {
        dwReturn = dwTemp;
    }
    return HRESULT_FROM_WIN32(dwReturn);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\extend\checker.cxx ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    checker.cxx

Abstract:

    IIS Services IISADMIN Extension
    Unicode Metadata Sink.

Author:

    Michael W. Thomas            11-19-98

--*/
#include <cominc.hxx>
#include <lmaccess.h>
#include <lmserver.h>
#include <lmapibuf.h>
#include <lmerr.h>
#include <ntlsa.h>
#include <time.h>

#include <ntsam.h>
#include <netlib.h>
#include <resource.h>

#define SECURITY_WIN32
#define ISSP_LEVEL  32
#define ISSP_MODE   1
#include <sspi.h>
#include <sspi.h>
#include <eventlog.hxx>
#include "extend.h"

#include <comadmin.h>
#include <sddl.h>

#include "wmrgexp.h"

typedef TCHAR USERNAME_STRING_TYPE[MAX_PATH];
typedef TCHAR PASSWORD_STRING_TYPE[LM20_PWLEN+1];

const LPCWSTR ROOTMDPath = L"/LM/W3SVC";

#define IIS_WP_GROUP        L"IIS_WPG"

#ifndef ARRAYSIZE
    #define ARRAYSIZE(_a) (sizeof((_a))/sizeof(*(_a)))
#endif

typedef enum
{
    GUFM_SUCCESS,
    GUFM_NO_PATH,
    GUFM_NO_PASSWORD,
    GUFM_NO_USER_ID
} GUFM_RETURN;

typedef struct _COM_APP_THREAD_STRUCT
{
    USERNAME_STRING_TYPE ustWamUserName;
    PASSWORD_STRING_TYPE pstWamUserPass;
} COM_APP_THREAD_STRUCT;


BOOL    ValidatePassword(IN LPCTSTR UserName,IN LPCTSTR Domain,IN LPCTSTR Password);
void    InitLsaString(PLSA_UNICODE_STRING LsaString,LPWSTR String);
DWORD   GetPrincipalSID (LPCTSTR Principal,PSID *Sid,BOOL *pbWellKnownSID);
DWORD   OpenPolicy(LPTSTR ServerName,DWORD DesiredAccess,PLSA_HANDLE PolicyHandle);
DWORD   AddRightToUserAccount(LPCTSTR szAccountName, LPTSTR PrivilegeName);
DWORD   DoesUserHaveThisRight(LPCTSTR szAccountName, LPTSTR PrivilegeName,BOOL *fHaveThatRight);
HRESULT UpdateComApplications(LPCTSTR szWamUserName,LPCTSTR szWamUserPass);
DWORD   UpdateComApplicationsThread(PVOID pv);
int     IsDomainController(void);
BOOL    WaitForDCAvailability(void);
HRESULT UpdateAdminAcl(IMDCOM *pcCom, LPCWSTR szPath, LPCWSTR szAccountName);
BOOL    MakeSureUserGetsCreated(LPTSTR pszAnonyName,LPTSTR pszAnonyPass,DWORD  dwUserCommentResourceId,DWORD  dwUserFullNameResourceId,BOOL   fSpecicaliWamAccount);
// these two lines for logging event about account recreation
EVENT_LOG *g_eventLogForAccountRecreation = NULL;
BOOL    CreateEventLogObject();



VOID
UpdateUserRights(
    LPCTSTR             account,
    LPTSTR              pstrRights[],
    DWORD               dwNofRights)
{
    DWORD               status;
    BOOL                fPresence;

    for (DWORD i=0;i<dwNofRights;i++)
    {
        status = DoesUserHaveThisRight(account,pstrRights[i],&fPresence);
        if (!NT_SUCCESS(status))
        {
            DBGPRINTF(( DBG_CONTEXT,"[UpdateAnonymousUser] DoesUserHaveThisRight returned err=0x%0X for account %s right %s\n",status,account,pstrRights[i]));
        }
        else
        {
            if (!fPresence)
            {
                status = AddRightToUserAccount(account,pstrRights[i]);
                if (!NT_SUCCESS(status))
                {
                    DBGPRINTF(( DBG_CONTEXT,"[UpdateAnonymousUser] AddRightToUserAccount returned err=0x%0X for account %s right %s\n",status,account,pstrRights[i]));
                }
            }
        }
    }
}

DWORD
AddRightToUserAccount(
    LPCTSTR             szAccountName,
    LPTSTR              PrivilegeName)
{
    NTSTATUS            status;
	LSA_UNICODE_STRING  UserRightString;
    LSA_HANDLE          PolicyHandle = NULL;
    PSID                pSID = NULL;
    BOOL                bWellKnownSID = FALSE;

    // Create a LSA_UNICODE_STRING for the privilege name.
    InitLsaString(&UserRightString, PrivilegeName);

    // get the sid of szAccountName
    status = GetPrincipalSID ((LPTSTR)szAccountName, &pSID, &bWellKnownSID);

    if (status != ERROR_SUCCESS)
    {
        DBGPRINTF(( DBG_CONTEXT,"[AddRightToUserAccount] GetPrincipalSID returned err=0x%0X\n",status));
        return (status);
    }


    status = OpenPolicy(NULL, POLICY_ALL_ACCESS,&PolicyHandle);
    if ( status == NERR_Success )
    {
		status = LsaAddAccountRights (
				 PolicyHandle,
				 pSID,
				 &UserRightString,
				 1);
    }

    if (PolicyHandle)
    {
        LsaClose(PolicyHandle);
    }
    if (pSID)
    {
        if (bWellKnownSID)
        {
            FreeSid (pSID);
        }
        else
        {
            free (pSID);
        }
    }
    return status;
}


DWORD
DoesUserHaveThisRight(
    LPCTSTR             szAccountName,
    LPTSTR              PrivilegeName,
    BOOL                *fHaveThatRight)
{
    BOOL                fEnabled = FALSE;
    NTSTATUS            status;
	LSA_UNICODE_STRING  UserRightString;
    LSA_HANDLE          PolicyHandle = NULL;
    PSID                pSID = NULL;
    BOOL                bWellKnownSID = FALSE;

    *fHaveThatRight = FALSE;

    // Create a LSA_UNICODE_STRING for the privilege name.
    InitLsaString(&UserRightString, PrivilegeName);

    // get the sid of szAccountName
    status = GetPrincipalSID ((LPTSTR)szAccountName, &pSID, &bWellKnownSID);
    if (status != ERROR_SUCCESS)
    {
        return status;
    }

    status = OpenPolicy(NULL, POLICY_ALL_ACCESS,&PolicyHandle);
    if ( status == NERR_Success )
    {
		UINT i;
        LSA_UNICODE_STRING *rgUserRights = NULL;
		ULONG cRights;

		status = LsaEnumerateAccountRights(
				 PolicyHandle,
				 pSID,
				 &rgUserRights,
				 &cRights);

		if (status==STATUS_OBJECT_NAME_NOT_FOUND)
        {
			// no rights/privileges for this account
            status = ERROR_SUCCESS;
			fEnabled = FALSE;
		}
		else if (!NT_SUCCESS(status))
        {
            //iisDebugOut((LOG_TYPE_ERROR, _T("DoesUserHaveBasicRights:GetPrincipalSID:Failed to enumerate rights: status 0x%08lx\n"), status));
			goto DoesUserHaveBasicRights_Exit;
		}

		for(i=0; i < cRights; i++)
        {
            if ( RtlEqualUnicodeString(&rgUserRights[i],&UserRightString,FALSE) )
            {
                fEnabled = TRUE;
                break;
            }
		}

        if (rgUserRights)
        {
            LsaFreeMemory(rgUserRights);
        }
    }

DoesUserHaveBasicRights_Exit:

    if (PolicyHandle)
    {
        LsaClose(PolicyHandle);
    }
    if (pSID)
    {
        if (bWellKnownSID)
        {
            FreeSid (pSID);
        }
        else
        {
            free (pSID);
        }
    }

    *fHaveThatRight = fEnabled;
    return status;
}



DWORD
GetCurrentUserSID(
    PSID                *Sid)
{
    DWORD               dwReturn = ERROR_SUCCESS;
    TOKEN_USER          *tokenUser = NULL;
    HANDLE              tokenHandle = NULL;
    DWORD               tokenSize = 0 ;
    DWORD               sidLength = 0;

    if ( !Sid )
    {
        dwReturn = ERROR_BAD_ARGUMENTS;
        goto exit;
    }

    *Sid = NULL;

    if ( !OpenProcessToken( GetCurrentProcess(), TOKEN_QUERY, &tokenHandle ) )
    {
        dwReturn = GetLastError();
        goto exit;
    }

    if ( !GetTokenInformation( tokenHandle, TokenUser, tokenUser, 0, &tokenSize ) )
    {
        if ( GetLastError() != ERROR_INSUFFICIENT_BUFFER )
        {
            dwReturn = GetLastError();
            goto exit;
        }
    }
    else
    {
        dwReturn = (DWORD)E_UNEXPECTED;
        goto exit;
    }

    tokenUser = (TOKEN_USER *)malloc( tokenSize );
    if ( !tokenUser )
    {
        dwReturn = ERROR_OUTOFMEMORY;
        goto exit;
    }

    if ( !GetTokenInformation( tokenHandle, TokenUser, tokenUser, tokenSize, &tokenSize ) )
    {
        dwReturn = GetLastError();
        goto exit;
    }

    sidLength = GetLengthSid( tokenUser->User.Sid );
    *Sid = (PSID)malloc( sidLength );
    if ( !*Sid )
    {
        dwReturn = ERROR_OUTOFMEMORY;
        goto exit;
    }

    memcpy( *Sid, tokenUser->User.Sid, sidLength );

exit:
    if (tokenHandle)
    {
        CloseHandle (tokenHandle);
        tokenHandle = NULL;
    }
    if (tokenUser)
    {
        free(tokenUser);
        tokenUser = NULL;
    }

    return dwReturn;
}

DWORD
CreateNewSD(
    SECURITY_DESCRIPTOR **SD)
{
    PACL                dacl;
    DWORD               sidLength;
    PSID                sid = NULL;
    PSID                groupSID;
    PSID                ownerSID;
    DWORD               returnValue;

    *SD = NULL;

    returnValue = GetCurrentUserSID (&sid);
    if (returnValue != ERROR_SUCCESS)
    {
        if (sid)
        {
            free(sid);
        }
        return returnValue;
    }

    sidLength = GetLengthSid (sid);

    *SD = (SECURITY_DESCRIPTOR *) malloc (
        (sizeof (ACL)+sizeof (ACCESS_ALLOWED_ACE)+sidLength) +
        (2 * sidLength) +
        sizeof (SECURITY_DESCRIPTOR));
    if (!*SD)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return GetLastError();
    }

    groupSID = (SID *) (*SD + 1);
    ownerSID = (SID *) (((BYTE *) groupSID) + sidLength);
    dacl = (ACL *) (((BYTE *) ownerSID) + sidLength);

    if (!InitializeSecurityDescriptor (*SD, SECURITY_DESCRIPTOR_REVISION))
    {
        free (*SD);
        free (sid);
        return GetLastError();
    }

    if (!InitializeAcl (dacl,
                        sizeof (ACL)+sizeof (ACCESS_ALLOWED_ACE)+sidLength,
                        ACL_REVISION2))
    {
        free (*SD);
        free (sid);
        return GetLastError();
    }

    if (!AddAccessAllowedAce (dacl,
                              ACL_REVISION2,
                              COM_RIGHTS_EXECUTE,
                              sid))
    {
        free (*SD);
        free (sid);
        return GetLastError();
    }

    if (!SetSecurityDescriptorDacl (*SD, TRUE, dacl, FALSE))
    {
        free (*SD);
        free (sid);
        return GetLastError();
    }

    memcpy (groupSID, sid, sidLength);
    if (!SetSecurityDescriptorGroup (*SD, groupSID, FALSE))
    {
        free (*SD);
        free (sid);
        return GetLastError();
    }

    memcpy (ownerSID, sid, sidLength);
    if (!SetSecurityDescriptorOwner (*SD, ownerSID, FALSE))
    {
        free (*SD);
        free (sid);
        return GetLastError();
    }

    if (sid)
        free(sid);
    return ERROR_SUCCESS;
}

DWORD
GetNamedValueSD (
    HKEY                RootKey,
    LPTSTR              KeyName,
    LPTSTR              ValueName,
    SECURITY_DESCRIPTOR **SD,
    BOOL                *NewSD)
{
    DWORD               returnValue;
    HKEY                registryKey;
    DWORD               valueType;
    DWORD               valueSize = 0;

    *NewSD = FALSE;

    //
    // Get the security descriptor from the named value. If it doesn't
    // exist, create a fresh one.
    //

    returnValue = RegOpenKeyEx (RootKey, KeyName, 0, KEY_ALL_ACCESS, &registryKey);

    if (returnValue != ERROR_SUCCESS)
    {
        if (returnValue == ERROR_FILE_NOT_FOUND)
        {
            *SD = NULL;
            returnValue = CreateNewSD (SD);
            if (returnValue != ERROR_SUCCESS)
            {
                if (*SD)
                {
                    free(*SD);
                }

                return returnValue;
            }

            *NewSD = TRUE;
            return ERROR_SUCCESS;
        }
        else
        {
            return returnValue;
        }
    }

    returnValue = RegQueryValueEx (registryKey, ValueName, NULL, &valueType, NULL, &valueSize);

    if (returnValue && returnValue != ERROR_INSUFFICIENT_BUFFER)
    {
        *SD = NULL;
        returnValue = CreateNewSD (SD);
        if (returnValue != ERROR_SUCCESS)
        {
            if (*SD)
            {
                free(*SD);
            }
            return returnValue;
        }

        *NewSD = TRUE;
    }
    else
    {
        *SD = (SECURITY_DESCRIPTOR *) malloc (valueSize);
        if (!*SD)
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return GetLastError();
        }

        returnValue = RegQueryValueEx (registryKey,
                                       ValueName,
                                       NULL,
                                       &valueType,
                                       (LPBYTE) *SD,
                                       &valueSize);
        if (returnValue)
        {
            if (*SD)
                free (*SD);

            *SD = NULL;
            returnValue = CreateNewSD (SD);
            if (returnValue != ERROR_SUCCESS)
            {
                if (*SD)
                {
                    free(*SD);
                }

                return returnValue;
            }

            *NewSD = TRUE;
        }
    }

    RegCloseKey (registryKey);

    return ERROR_SUCCESS;
}

DWORD
GetPrincipalSID(
    LPCTSTR                     Principal,
    PSID                        *Sid,
    BOOL                        *pbWellKnownSID)
{
    HRESULT                     hr = S_OK;
    DWORD                       returnValue=ERROR_SUCCESS;
    SID_IDENTIFIER_AUTHORITY    SidIdentifierNTAuthority = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY    SidIdentifierWORLDAuthority = SECURITY_WORLD_SID_AUTHORITY;
    PSID_IDENTIFIER_AUTHORITY   pSidIdentifierAuthority = NULL;
    BYTE                        Count = 0;
    DWORD                       dwRID[8];
    TCHAR                       pszPrincipal[MAX_PATH];

    *pbWellKnownSID = TRUE;
    memset(&(dwRID[0]), 0, 8 * sizeof(DWORD));

    DBG_ASSERT(wcslen(Principal) < MAX_PATH);
    hr = StringCchCopy(pszPrincipal, ARRAYSIZE(pszPrincipal), Principal);
    if ( FAILED(hr) )
    {
        return HRESULTTOWIN32( hr );
    }
    _wcslwr(pszPrincipal);
    if ( wcsstr(pszPrincipal, TEXT("administrators")) != NULL )
    {
        // Administrators group
        pSidIdentifierAuthority = &SidIdentifierNTAuthority;
        Count = 2;
        dwRID[0] = SECURITY_BUILTIN_DOMAIN_RID;
        dwRID[1] = DOMAIN_ALIAS_RID_ADMINS;
    }
    else if ( wcsstr(pszPrincipal, TEXT("system")) != NULL)
    {
        // SYSTEM
        pSidIdentifierAuthority = &SidIdentifierNTAuthority;
        Count = 1;
        dwRID[0] = SECURITY_LOCAL_SYSTEM_RID;
    }
    else if ( wcsstr(pszPrincipal, TEXT("interactive")) != NULL)
    {
        // INTERACTIVE
        pSidIdentifierAuthority = &SidIdentifierNTAuthority;
        Count = 1;
        dwRID[0] = SECURITY_INTERACTIVE_RID;
    }
    else if ( wcsstr(pszPrincipal, TEXT("everyone")) != NULL)
    {
        // Everyone
        pSidIdentifierAuthority = &SidIdentifierWORLDAuthority;
        Count = 1;
        dwRID[0] = SECURITY_WORLD_RID;
    }
    else
    {
        *pbWellKnownSID = FALSE;
    }

    // IVANPASH
    // Going through the above code *pbWellKnownSID and pSidIdentifierAuthority
    // will always be in sync, but still there is warning on /W4
    // so I added initializing pSidIdentifierAuthority to NULL and the
    // additional check for pSidIdentifierAuthority in this if to make cl and prefast happy.
    if ( *pbWellKnownSID && pSidIdentifierAuthority )
    {
        if ( !AllocateAndInitializeSid( pSidIdentifierAuthority,
                                        (BYTE)Count,
                                        dwRID[0],
                                        dwRID[1],
                                        dwRID[2],
                                        dwRID[3],
                                        dwRID[4],
                                        dwRID[5],
                                        dwRID[6],
                                        dwRID[7],
                                        Sid) )
        {
            returnValue = GetLastError();
        }
    }
    else
    {
        // get regular account sid
        DWORD           sidSize;
        TCHAR           refDomain [256];
        DWORD           refDomainSize;
        SID_NAME_USE    snu;

        sidSize = 0;
        refDomainSize = 255;

        LookupAccountName (NULL,
                           pszPrincipal,
                           *Sid,
                           &sidSize,
                           refDomain,
                           &refDomainSize,
                           &snu);

        returnValue = GetLastError();

        if (returnValue == ERROR_INSUFFICIENT_BUFFER)
        {
            *Sid = (PSID) malloc (sidSize);
            if (!*Sid)
            {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                return GetLastError();
            }
            refDomainSize = 255;

            if (!LookupAccountName (NULL,
                                    pszPrincipal,
                                    *Sid,
                                    &sidSize,
                                    refDomain,
                                    &refDomainSize,
                                    &snu))
            {
                free( *Sid );
                *Sid = NULL;
                returnValue = GetLastError();
            }
            else
            {
                returnValue = ERROR_SUCCESS;
            }
        }
    }

    return returnValue;
}

DWORD
CopyACL(
    PACL                    OldACL,
    PACL                    NewACL)
{
    ACL_SIZE_INFORMATION    aclSizeInfo;
    LPVOID                  ace;
    ACE_HEADER              *aceHeader;
    ULONG                   i;

    GetAclInformation (OldACL,
                       (LPVOID) &aclSizeInfo,
                       (DWORD) sizeof (aclSizeInfo),
                       AclSizeInformation);

    //
    // Copy all of the ACEs to the new ACL
    //

    for (i = 0; i < aclSizeInfo.AceCount; i++)
    {
        //
        // Get the ACE and header info
        //

        if (!GetAce (OldACL, i, &ace))
            return GetLastError();

        aceHeader = (ACE_HEADER *) ace;

        //
        // Add the ACE to the new list
        //

        if (!AddAce (NewACL, ACL_REVISION, 0xffffffff, ace, aceHeader->AceSize))
            return GetLastError();
    }

    return ERROR_SUCCESS;
}


DWORD
AddAccessAllowedACEToACL(
    PACL                    *Acl,
    DWORD                   PermissionMask,
    LPTSTR                  Principal)
{
    ACL_SIZE_INFORMATION    aclSizeInfo;
    int                     aclSize;
    DWORD                   returnValue = ERROR_SUCCESS;
    PSID                    principalSID = NULL;
    PACL                    oldACL;
    PACL                    newACL;
    BOOL                    bWellKnownSID = FALSE;

    oldACL = *Acl;

    returnValue = GetPrincipalSID (Principal, &principalSID, &bWellKnownSID);
    if (returnValue != ERROR_SUCCESS)
    {
        return returnValue;
    }

    GetAclInformation (oldACL,
                       (LPVOID) &aclSizeInfo,
                       (DWORD) sizeof (ACL_SIZE_INFORMATION),
                       AclSizeInformation);

    aclSize = aclSizeInfo.AclBytesInUse +
              sizeof (ACL) + sizeof (ACCESS_ALLOWED_ACE) +
              GetLengthSid (principalSID) - sizeof (DWORD);

    newACL = (PACL) new BYTE [aclSize];

    if ( newACL == NULL )
    {
        returnValue = ERROR_OUTOFMEMORY;
        goto cleanup;

    }

    if (!InitializeAcl (newACL, aclSize, ACL_REVISION))
    {
        returnValue = GetLastError();
        goto cleanup;
    }

    returnValue = CopyACL (oldACL, newACL);
    if (returnValue != ERROR_SUCCESS)
    {
        goto cleanup;
    }

    if (!AddAccessAllowedAce (newACL, ACL_REVISION2, PermissionMask, principalSID))
    {
        returnValue = GetLastError();
        goto cleanup;
    }

    *Acl = newACL;
	newACL = NULL;

cleanup:

	// BugFix: 57654 Whistler
	//         Prefix bug leaking memory in error condition.
	//         By setting the newACL to NULL above if we have
	//         relinquished the memory to *Acl, we avoid releasing
	//         memory we have passed back to the caller.
	//         EBK 5/5/2000
	if (newACL)
	{
		delete [] newACL;
		newACL = NULL;
	}

    if (principalSID)
    {
        if (bWellKnownSID)
        {
            FreeSid (principalSID);
        }
        else
        {
            free (principalSID);
        }
    }

    return returnValue;
}

DWORD
RemovePrincipalFromACL (
    PACL                    Acl,
    LPTSTR                  Principal)
{
    ACL_SIZE_INFORMATION    aclSizeInfo;
    ULONG                   i;
    LPVOID                  ace;
    ACCESS_ALLOWED_ACE      *accessAllowedAce;
    ACCESS_DENIED_ACE       *accessDeniedAce;
    SYSTEM_AUDIT_ACE        *systemAuditAce;
    PSID                    principalSID = NULL;
    DWORD                   returnValue = ERROR_SUCCESS;
    ACE_HEADER              *aceHeader;
    BOOL                    bWellKnownSID = FALSE;

    returnValue = GetPrincipalSID (Principal, &principalSID, &bWellKnownSID);
    if (returnValue != ERROR_SUCCESS)
    {
        return returnValue;
    }

    GetAclInformation (Acl,
                       (LPVOID) &aclSizeInfo,
                       (DWORD) sizeof (ACL_SIZE_INFORMATION),
                       AclSizeInformation);

    for (i = 0; i < aclSizeInfo.AceCount; i++)
    {
        if (!GetAce (Acl, i, &ace))
        {
            returnValue = GetLastError();
            break;
        }

        aceHeader = (ACE_HEADER *) ace;

        if (aceHeader->AceType == ACCESS_ALLOWED_ACE_TYPE)
        {
            accessAllowedAce = (ACCESS_ALLOWED_ACE *) ace;

            if (EqualSid (principalSID, (PSID) &accessAllowedAce->SidStart))
            {
                DeleteAce (Acl, i);
                break;
            }
        }
        else if (aceHeader->AceType == ACCESS_DENIED_ACE_TYPE)
        {
            accessDeniedAce = (ACCESS_DENIED_ACE *) ace;

            if (EqualSid (principalSID, (PSID) &accessDeniedAce->SidStart))
            {
                DeleteAce (Acl, i);
                break;
            }
        }
        else if (aceHeader->AceType == SYSTEM_AUDIT_ACE_TYPE)
        {
            systemAuditAce = (SYSTEM_AUDIT_ACE *) ace;

            if (EqualSid (principalSID, (PSID) &systemAuditAce->SidStart))
            {
                DeleteAce (Acl, i);
                break;
            }
        }
    }

    if (principalSID)
    {
        if (bWellKnownSID)
        {
            FreeSid (principalSID);
        }
        else
        {
            free (principalSID);
        }
    }

    return returnValue;
}

DWORD
MakeSDAbsolute(
    PSECURITY_DESCRIPTOR    OldSD,
    PSECURITY_DESCRIPTOR    *NewSD)
{
    PSECURITY_DESCRIPTOR    sd = NULL;
    DWORD                   descriptorSize;
    DWORD                   daclSize;
    DWORD                   saclSize;
    DWORD                   ownerSIDSize;
    DWORD                   groupSIDSize;
    PACL                    dacl = NULL;
    PACL                    sacl = NULL;
    PSID                    ownerSID = NULL;
    PSID                    groupSID = NULL;
    BOOL                    present;
    BOOL                    systemDefault;

    //
    // Get SACL
    //
    if (!GetSecurityDescriptorSacl (OldSD, &present, &sacl, &systemDefault))
    {
        return GetLastError();
    }

    if (sacl && present)
    {
        saclSize = sacl->AclSize;
    }
    else
    {
        saclSize = 0;
    }

    //
    // Get DACL
    //

    if (!GetSecurityDescriptorDacl (OldSD, &present, &dacl, &systemDefault))
        return GetLastError();

    if (dacl && present)
    {
        daclSize = dacl->AclSize;
    }
    else
    {
        daclSize = 0;
    }

    //
    // Get Owner
    //

    if (!GetSecurityDescriptorOwner (OldSD, &ownerSID, &systemDefault))
    {
        return GetLastError();
    }

    ownerSIDSize = GetLengthSid (ownerSID);

    //
    // Get Group
    //

    if (!GetSecurityDescriptorGroup (OldSD, &groupSID, &systemDefault))
    {
        return GetLastError();
    }

    groupSIDSize = GetLengthSid (groupSID);

    //
    // Do the conversion
    //

    descriptorSize = 0;

    MakeAbsoluteSD (OldSD, sd, &descriptorSize, dacl, &daclSize, sacl,
                    &saclSize, ownerSID, &ownerSIDSize, groupSID,
                    &groupSIDSize);

    sd = (PSECURITY_DESCRIPTOR) new BYTE [SECURITY_DESCRIPTOR_MIN_LENGTH];
    if (!sd)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return GetLastError();
    }
    if (!InitializeSecurityDescriptor (sd, SECURITY_DESCRIPTOR_REVISION))
        return GetLastError();

    if (!MakeAbsoluteSD (OldSD, sd, &descriptorSize, dacl, &daclSize, sacl,
                         &saclSize, ownerSID, &ownerSIDSize, groupSID,
                         &groupSIDSize))
    {
        return GetLastError();
    }

    *NewSD = sd;
    return ERROR_SUCCESS;
}

DWORD
SetNamedValueSD(
    HKEY                RootKey,
    LPTSTR              KeyName,
    LPTSTR              ValueName,
    SECURITY_DESCRIPTOR *SD)
{
    DWORD               returnValue;
    DWORD               disposition;
    HKEY                registryKey;

    //
    // Create new key or open existing key
    //

    returnValue = RegCreateKeyEx (RootKey,
                                  KeyName,
                                  0,
                                  TEXT(""),
                                  0,
                                  KEY_ALL_ACCESS,
                                  NULL,
                                  &registryKey,
                                  &disposition);
    if (returnValue != ERROR_SUCCESS)
    {
        return returnValue;
    }

    //
    // Write the security descriptor
    //

    returnValue = RegSetValueEx (registryKey,
                                 ValueName,
                                 0,
                                 REG_BINARY,
                                 (LPBYTE) SD,
                                 GetSecurityDescriptorLength (SD));
    if (returnValue != ERROR_SUCCESS)
    {
        return returnValue;
    }

    RegCloseKey (registryKey);

    return ERROR_SUCCESS;
}


DWORD
RemovePrincipalFromNamedValueSD (
    HKEY                RootKey,
    LPTSTR              KeyName,
    LPTSTR              ValueName,
    LPTSTR              Principal)
{
    DWORD               returnValue = ERROR_SUCCESS;
    SECURITY_DESCRIPTOR *sd = NULL;
    SECURITY_DESCRIPTOR *sdSelfRelative = NULL;
    SECURITY_DESCRIPTOR *sdAbsolute = NULL;
    DWORD               secDescSize;
    BOOL                present;
    BOOL                defaultDACL;
    PACL                dacl = NULL;
    BOOL                newSD = FALSE;
    BOOL                fFreeAbsolute = TRUE;

    returnValue = GetNamedValueSD (RootKey, KeyName, ValueName, &sd, &newSD);

    //
    // Get security descriptor from registry or create a new one
    //

    if (returnValue != ERROR_SUCCESS)
    {
        return returnValue;
    }

    if (!GetSecurityDescriptorDacl (sd, &present, &dacl, &defaultDACL))
    {
        returnValue = GetLastError();
        goto Cleanup;
    }

    //
    // If the security descriptor is new, add the required Principals to it
    //

    if (newSD)
    {
        AddAccessAllowedACEToACL (&dacl, COM_RIGHTS_EXECUTE, TEXT("SYSTEM"));
        AddAccessAllowedACEToACL (&dacl, COM_RIGHTS_EXECUTE, TEXT("INTERACTIVE"));
    }

    //
    // Remove the Principal that the caller wants removed
    //

    returnValue = RemovePrincipalFromACL (dacl, Principal);
    if (returnValue != ERROR_SUCCESS)
    {
        goto Cleanup;
    }

    //
    // Make the security descriptor absolute if it isn't new
    //

    if (!newSD)
    {
        MakeSDAbsolute ((PSECURITY_DESCRIPTOR) sd, (PSECURITY_DESCRIPTOR *) &sdAbsolute);
        fFreeAbsolute = TRUE;
    }
    else
    {
        sdAbsolute = sd;
        fFreeAbsolute = FALSE;
    }

    //
    // Set the discretionary ACL on the security descriptor
    //

    if (!SetSecurityDescriptorDacl (sdAbsolute, TRUE, dacl, FALSE))
    {
        returnValue = GetLastError();
        goto Cleanup;
    }

    //
    // Make the security descriptor self-relative so that we can
    // store it in the registry
    //

    secDescSize = 0;
    MakeSelfRelativeSD (sdAbsolute, sdSelfRelative, &secDescSize);
    sdSelfRelative = (SECURITY_DESCRIPTOR *) malloc (secDescSize);
    if (!sdSelfRelative)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        returnValue = GetLastError();
        goto Cleanup;
    }

    if (!MakeSelfRelativeSD (sdAbsolute, sdSelfRelative, &secDescSize))
    {
        returnValue = GetLastError();
        goto Cleanup;
    }

    //
    // Store the security descriptor in the registry
    //

    SetNamedValueSD (RootKey, KeyName, ValueName, sdSelfRelative);

Cleanup:
    if (sd)
    {
        free (sd);
    }
    if (sdSelfRelative)
    {
        free (sdSelfRelative);
    }
    if (fFreeAbsolute && sdAbsolute)
    {
        free (sdAbsolute);
    }

    return returnValue;
}

DWORD
AddAccessDeniedACEToACL(
    PACL                    *Acl,
    DWORD                   PermissionMask,
    LPTSTR                  Principal)
{
    ACL_SIZE_INFORMATION    aclSizeInfo;
    int                     aclSize;
    DWORD                   returnValue = ERROR_SUCCESS;
    PSID                    principalSID = NULL;
    PACL                    oldACL;
    PACL                    newACL;
    BOOL                    bWellKnownSID = FALSE;

    oldACL = *Acl;

    returnValue = GetPrincipalSID (Principal, &principalSID, &bWellKnownSID);
    if (returnValue != ERROR_SUCCESS)
    {
        return returnValue;
    }

    GetAclInformation (oldACL,
                       (LPVOID) &aclSizeInfo,
                       (DWORD) sizeof (ACL_SIZE_INFORMATION),
                       AclSizeInformation);

    aclSize = aclSizeInfo.AclBytesInUse +
              sizeof (ACL) + sizeof (ACCESS_DENIED_ACE) +
              GetLengthSid (principalSID) - sizeof (DWORD);

    newACL = (PACL) new BYTE [aclSize];

    if ( newACL == NULL )
    {
        returnValue = ERROR_OUTOFMEMORY;
        goto cleanup;

    }

    if (!InitializeAcl (newACL, aclSize, ACL_REVISION))
    {
        returnValue = GetLastError();
        goto cleanup;
    }

    if (!AddAccessDeniedAce (newACL, ACL_REVISION2, PermissionMask, principalSID))
    {
        returnValue = GetLastError();
        goto cleanup;
    }

    returnValue = CopyACL (oldACL, newACL);
    if (returnValue != ERROR_SUCCESS)
    {
        goto cleanup;
    }

    *Acl = newACL;
	newACL = NULL;

cleanup:

	// BugFix: 57654 Whistler
	//         Prefix bug leaking memory in error condition.
	//         By setting the newACL to NULL above if we have
	//         relinquished the memory to *Acl, we avoid releasing
	//         memory we have passed back to the caller.
	//         EBK 5/5/2000
	if (newACL)
	{
		delete[] newACL;
		newACL = NULL;
	}

    if (principalSID)
    {
        if (bWellKnownSID)
        {
            FreeSid (principalSID);
        }
        else
        {
            free (principalSID);
        }
    }

    return returnValue;
}

DWORD
AddPrincipalToNamedValueSD(
    HKEY                RootKey,
    LPTSTR              KeyName,
    LPTSTR              ValueName,
    LPTSTR              Principal,
    BOOL                Permit)
{
    DWORD               returnValue = ERROR_SUCCESS;
    SECURITY_DESCRIPTOR *sd = NULL;
    SECURITY_DESCRIPTOR *sdSelfRelative = NULL;
    SECURITY_DESCRIPTOR *sdAbsolute = NULL;
    DWORD               secDescSize;
    BOOL                present;
    BOOL                defaultDACL;
    PACL                dacl;
    BOOL                newSD = FALSE;
    BOOL                fFreeAbsolute = TRUE;

    returnValue = GetNamedValueSD (RootKey, KeyName, ValueName, &sd, &newSD);

    //
    // Get security descriptor from registry or create a new one
    //

    if (returnValue != ERROR_SUCCESS)
    {
        return returnValue;
    }

    if (!GetSecurityDescriptorDacl (sd, &present, &dacl, &defaultDACL))
    {
        returnValue = GetLastError();
        goto Cleanup;
    }

    if (newSD)
    {
        AddAccessAllowedACEToACL (&dacl, COM_RIGHTS_EXECUTE, TEXT("SYSTEM"));
        AddAccessAllowedACEToACL (&dacl, COM_RIGHTS_EXECUTE, TEXT("INTERACTIVE"));
    }

    //
    // Add the Principal that the caller wants added
    //

    if (Permit)
    {
        returnValue = AddAccessAllowedACEToACL (&dacl, COM_RIGHTS_EXECUTE, Principal);
    }
    else
    {
        returnValue = AddAccessDeniedACEToACL (&dacl, GENERIC_ALL, Principal);
    }

    if (returnValue != ERROR_SUCCESS)
    {
        goto Cleanup;
    }

    //
    // Make the security descriptor absolute if it isn't new
    //

    if (!newSD)
    {
        MakeSDAbsolute ((PSECURITY_DESCRIPTOR) sd, (PSECURITY_DESCRIPTOR *) &sdAbsolute);
        fFreeAbsolute = TRUE;
    }
    else
    {
        sdAbsolute = sd;
        fFreeAbsolute = FALSE;
    }

    //
    // Set the discretionary ACL on the security descriptor
    //

    if (!SetSecurityDescriptorDacl (sdAbsolute, TRUE, dacl, FALSE))
    {
        returnValue = GetLastError();
        goto Cleanup;
    }

    //
    // Make the security descriptor self-relative so that we can
    // store it in the registry
    //

    secDescSize = 0;
    MakeSelfRelativeSD (sdAbsolute, sdSelfRelative, &secDescSize);
    sdSelfRelative = (SECURITY_DESCRIPTOR *) malloc (secDescSize);
    if (!sdSelfRelative)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        returnValue = GetLastError();
        goto Cleanup;
    }


    if (!MakeSelfRelativeSD (sdAbsolute, sdSelfRelative, &secDescSize))
    {
        returnValue = GetLastError();
        goto Cleanup;
    }

    //
    // Store the security descriptor in the registry
    //

    SetNamedValueSD (RootKey, KeyName, ValueName, sdSelfRelative);

Cleanup:
    if (sd)
    {
        free (sd);
    }
    if (sdSelfRelative)
    {
        free (sdSelfRelative);
    }
    if (fFreeAbsolute && sdAbsolute)
    {
        free (sdAbsolute);
    }

    return returnValue;
}


DWORD
ChangeDCOMAccessACL(
    LPTSTR              Principal,
    BOOL                SetPrincipal,
    BOOL                Permit)
{
    DWORD               err;

    if (SetPrincipal)
    {
        // There is not need to check the return value of RemovePrincipalFromNamedValueSD,
        // because its failure is not important (for example DefaultAccessPermission might
        // not exist). The important call that must succeed is AddPrincipalToNamedValueSD
        RemovePrincipalFromNamedValueSD (HKEY_LOCAL_MACHINE,
                                         TEXT("Software\\Microsoft\\OLE"),
                                         TEXT("DefaultAccessPermission"),
                                         Principal);
        err = AddPrincipalToNamedValueSD (HKEY_LOCAL_MACHINE,
                                          TEXT("Software\\Microsoft\\OLE"),
                                          TEXT("DefaultAccessPermission"),
                                          Principal,
                                          Permit);
    }
    else
    {
        err = RemovePrincipalFromNamedValueSD (HKEY_LOCAL_MACHINE,
                                               TEXT("Software\\Microsoft\\OLE"),
                                               TEXT("DefaultAccessPermission"),
                                               Principal);
    }
    return err;
}

DWORD
ChangeDCOMLaunchACL(
    LPTSTR              Principal,
    BOOL                SetPrincipal,
    BOOL                Permit)
{
    TCHAR               keyName [256] = TEXT("Software\\Microsoft\\OLE");
    DWORD               err;

    if (SetPrincipal)
    {
        // There is not need to check the return value of RemovePrincipalFromNamedValueSD,
        // because its failure is not important (for example DefaultAccessPermission might
        // not exist). The important call that must succeed is AddPrincipalToNamedValueSD
        RemovePrincipalFromNamedValueSD (HKEY_LOCAL_MACHINE,
                                         keyName,
                                         TEXT("DefaultLaunchPermission"),
                                         Principal);
        err = AddPrincipalToNamedValueSD (HKEY_LOCAL_MACHINE,
                                          keyName,
                                          TEXT("DefaultLaunchPermission"),
                                          Principal,
                                          Permit);
    }
    else
    {
        err = RemovePrincipalFromNamedValueSD (HKEY_LOCAL_MACHINE,
                                               keyName,
                                               TEXT("DefaultLaunchPermission"),
                                               Principal);
    }
    return err;
}



GUFM_RETURN
GetUserFromMetabase(
    IMDCOM                  *pcCom,
    LPWSTR                  pszPath,
    DWORD                   dwUserMetaId,
    DWORD                   dwPasswordMetaId,
    USERNAME_STRING_TYPE    ustUserBuf,
    PASSWORD_STRING_TYPE    pstPasswordBuf)
{

    HRESULT                 hresTemp;
    GUFM_RETURN             gufmReturn = GUFM_SUCCESS;
    METADATA_RECORD         mdrData;
    DWORD                   dwRequiredDataLen;
    METADATA_HANDLE         mhOpenHandle;

    hresTemp = pcCom->ComMDOpenMetaObject(METADATA_MASTER_ROOT_HANDLE,
                                            pszPath,
                                            METADATA_PERMISSION_READ,
                                            OPEN_TIMEOUT_VALUE,
                                            &mhOpenHandle);
    if (FAILED(hresTemp))
    {
        gufmReturn = GUFM_NO_PATH;
    }
    else
    {
        MD_SET_DATA_RECORD_EXT(&mdrData,
                               dwUserMetaId,
                               METADATA_NO_ATTRIBUTES,
                               ALL_METADATA,
                               STRING_METADATA,
                               MAX_PATH * sizeof(TCHAR),
                               (PBYTE)ustUserBuf)

        hresTemp = pcCom->ComMDGetMetaData(mhOpenHandle,
                                           NULL,
                                           &mdrData,
                                           &dwRequiredDataLen);

        if (FAILED(hresTemp) || (ustUserBuf[0] == (TCHAR)'\0'))
        {
            gufmReturn = GUFM_NO_USER_ID;
        }
        else
        {
            MD_SET_DATA_RECORD_EXT(&mdrData,
                                   dwPasswordMetaId,
                                   METADATA_NO_ATTRIBUTES,
                                   ALL_METADATA,
                                   STRING_METADATA,
                                   (LM20_PWLEN+1) * sizeof(TCHAR),
                                   (PBYTE)pstPasswordBuf)

            hresTemp = pcCom->ComMDGetMetaData(mhOpenHandle,
                                               NULL,
                                               &mdrData,
                                               &dwRequiredDataLen);
            if (FAILED(hresTemp))
            {
                gufmReturn = GUFM_NO_PASSWORD;
            }
        }
        pcCom->ComMDCloseMetaObject(mhOpenHandle);
    }

    return gufmReturn;
}

BOOL
WritePasswordToMetabase(
    IMDCOM                  *pcCom,
    LPWSTR                  pszPath,
    DWORD                   dwPasswordMetaId,
    PASSWORD_STRING_TYPE    pstPasswordBuf)
{
    HRESULT                 hresReturn;
    METADATA_RECORD         mdrData;
    METADATA_HANDLE         mhOpenHandle;

    hresReturn = pcCom->ComMDOpenMetaObject(METADATA_MASTER_ROOT_HANDLE,
                                            pszPath,
                                            METADATA_PERMISSION_WRITE,
                                            OPEN_TIMEOUT_VALUE,
                                            &mhOpenHandle);
    if (SUCCEEDED(hresReturn))
    {
        MD_SET_DATA_RECORD_EXT(&mdrData,
                               dwPasswordMetaId,
                               METADATA_INHERIT | METADATA_SECURE,
                               IIS_MD_UT_FILE,
                               STRING_METADATA,
                               sizeof(pstPasswordBuf),
                               (PBYTE)pstPasswordBuf)

        hresReturn = pcCom->ComMDSetMetaData(mhOpenHandle,
                                             NULL,
                                             &mdrData);

        pcCom->ComMDCloseMetaObject(mhOpenHandle);
    }

    return SUCCEEDED(hresReturn);
}

BOOL
DoesUserExist(
    LPWSTR              strUsername,
    BOOL                *fDisabled)
{
    BYTE                *pBuffer;
    INT                 err = NERR_Success;
    BOOL                fReturn = FALSE;

    *fDisabled = FALSE;

    err = NetUserGetInfo( NULL, strUsername, 3, &pBuffer );

    if ( err == NERR_Success )
    {
        *fDisabled = !!(((PUSER_INFO_3)pBuffer)->usri3_flags  & UF_ACCOUNTDISABLE);
        NetApiBufferFree( pBuffer );
        fReturn = TRUE;
    }

    return( fReturn );
}


NET_API_STATUS
NetpNtStatusToApiStatus (
    IN NTSTATUS         NtStatus)

/*++

Routine Description:

    This function takes an NT status code and maps it to the appropriate
    LAN Man error code.

Arguments:

    NtStatus - Supplies the NT status.

Return Value:

    Returns the appropriate LAN Man error code for the NT status.

--*/
{
    NET_API_STATUS      error;

    //
    // A small optimization for the most common case.
    //
    if ( NtStatus == STATUS_SUCCESS )
    {
        return NERR_Success;
    }

    switch ( NtStatus )
    {
        case STATUS_BUFFER_TOO_SMALL :
            return NERR_BufTooSmall;

        case STATUS_FILES_OPEN :
            return NERR_OpenFiles;

        case STATUS_CONNECTION_IN_USE :
            return NERR_DevInUse;

        case STATUS_INVALID_LOGON_HOURS :
            return NERR_InvalidLogonHours;

        case STATUS_INVALID_WORKSTATION :
            return NERR_InvalidWorkstation;

        case STATUS_PASSWORD_EXPIRED :
            return NERR_PasswordExpired;

        case STATUS_ACCOUNT_EXPIRED :
            return NERR_AccountExpired;

        case STATUS_REDIRECTOR_NOT_STARTED :
            return NERR_NetNotStarted;

        case STATUS_GROUP_EXISTS:
                return NERR_GroupExists;

        case STATUS_INTERNAL_DB_CORRUPTION:
                return NERR_InvalidDatabase;

        case STATUS_INVALID_ACCOUNT_NAME:
                return NERR_BadUsername;

        case STATUS_INVALID_DOMAIN_ROLE:
        case STATUS_INVALID_SERVER_STATE:
        case STATUS_BACKUP_CONTROLLER:
                return NERR_NotPrimary;

        case STATUS_INVALID_DOMAIN_STATE:
                return NERR_ACFNotLoaded;

        case STATUS_MEMBER_IN_GROUP:
                return NERR_UserInGroup;

        case STATUS_MEMBER_NOT_IN_GROUP:
                return NERR_UserNotInGroup;

        case STATUS_NONE_MAPPED:
        case STATUS_NO_SUCH_GROUP:
                return NERR_GroupNotFound;

        case STATUS_SPECIAL_GROUP:
        case STATUS_MEMBERS_PRIMARY_GROUP:
                return NERR_SpeGroupOp;

        case STATUS_USER_EXISTS:
                return NERR_UserExists;

        case STATUS_NO_SUCH_USER:
                return NERR_UserNotFound;

        case STATUS_PRIVILEGE_NOT_HELD:
                return ERROR_ACCESS_DENIED;

        case STATUS_LOGON_SERVER_CONFLICT:
                return NERR_LogonServerConflict;

        case STATUS_TIME_DIFFERENCE_AT_DC:
                return NERR_TimeDiffAtDC;

        case STATUS_SYNCHRONIZATION_REQUIRED:
                return NERR_SyncRequired;

        case STATUS_WRONG_PASSWORD_CORE:
                return NERR_BadPasswordCore;

        case STATUS_DOMAIN_CONTROLLER_NOT_FOUND:
                return NERR_DCNotFound;

        case STATUS_PASSWORD_RESTRICTION:
                return NERR_PasswordTooShort;

        case STATUS_ALREADY_DISCONNECTED:
                return NERR_Success;

        default:

            //
            // Use the system routine to do the mapping to ERROR_ codes.
            //

#ifndef WIN32_CHICAGO
            error = RtlNtStatusToDosError( NtStatus );

            if ( error != (NET_API_STATUS)NtStatus )
            {
                return error;
            }
#endif // WIN32_CHICAGO

            //
            // Could not map the NT status to anything appropriate.
            //

            return NERR_InternalError;
    }
} // NetpNtStatusToApiStatus


NET_API_STATUS
UaspGetDomainId(
    IN LPCWSTR          ServerName OPTIONAL,
    OUT PSAM_HANDLE     SamServerHandle OPTIONAL,
    OUT PPOLICY_ACCOUNT_DOMAIN_INFO     * AccountDomainInfo
    )
/*++
Routine Description:
    Return a domain ID of the account domain of a server.
Arguments:
    ServerName - A pointer to a string containing the name of the
        Domain Controller (DC) to query.  A NULL pointer
        or string specifies the local machine.
    SamServerHandle - Returns the SAM connection handle if the caller wants it.
    DomainId - Receives a pointer to the domain ID.
        Caller must deallocate buffer using NetpMemoryFree.
Return Value:
    Error code for the operation.
--*/
{
    NET_API_STATUS      NetStatus;
    NTSTATUS            Status;
    SAM_HANDLE          LocalSamHandle = NULL;
    ACCESS_MASK         LSADesiredAccess;
    LSA_HANDLE          LSAPolicyHandle = NULL;
    OBJECT_ATTRIBUTES   LSAObjectAttributes;
    UNICODE_STRING      ServerNameString;

    //
    // Connect to the SAM server
    //
    RtlInitUnicodeString( &ServerNameString, ServerName );

    Status = SamConnect(
                &ServerNameString,
                &LocalSamHandle,
                SAM_SERVER_LOOKUP_DOMAIN,
                NULL);

    if ( !NT_SUCCESS(Status))
    {
        LocalSamHandle = NULL;
        NetStatus = NetpNtStatusToApiStatus( Status );
        goto Cleanup;
    }


    //
    // Open LSA to read account domain info.
    //

    if ( AccountDomainInfo != NULL)
    {
        //
        // set desired access mask.
        //
        LSADesiredAccess = POLICY_VIEW_LOCAL_INFORMATION;

        InitializeObjectAttributes( &LSAObjectAttributes,
                                      NULL,             // Name
                                      0,                // Attributes
                                      NULL,             // Root
                                      NULL );           // Security Descriptor

        Status = LsaOpenPolicy( &ServerNameString,
                                &LSAObjectAttributes,
                                LSADesiredAccess,
                                &LSAPolicyHandle );

        if( !NT_SUCCESS(Status) )
        {
            NetStatus = NetpNtStatusToApiStatus( Status );
            goto Cleanup;
        }


        //
        // now read account domain info from LSA.
        //

        Status = LsaQueryInformationPolicy(
                        LSAPolicyHandle,
                        PolicyAccountDomainInformation,
                        (PVOID *) AccountDomainInfo );

        if( !NT_SUCCESS(Status) )
        {
            NetStatus = NetpNtStatusToApiStatus( Status );
            goto Cleanup;
        }
    }

    //
    // Return the SAM connection handle to the caller if he wants it.
    // Otherwise, disconnect from SAM.
    //

    if ( ARGUMENT_PRESENT( SamServerHandle ) )
    {
        *SamServerHandle = LocalSamHandle;
        LocalSamHandle = NULL;
    }

    NetStatus = NERR_Success;

    //
    // Cleanup locally used resources
    //
Cleanup:
    if ( LocalSamHandle != NULL )
    {
        (VOID) SamCloseHandle( LocalSamHandle );
    }

    if( LSAPolicyHandle != NULL )
    {
        LsaClose( LSAPolicyHandle );
    }

    return NetStatus;
} // UaspGetDomainId


NET_API_STATUS
SampCreateFullSid(
    IN PSID             DomainSid,
    IN ULONG            Rid,
    OUT PSID            *AccountSid)
/*++
Routine Description:
    This function creates a domain account sid given a domain sid and
    the relative id of the account within the domain.
    The returned Sid may be freed with LocalFree.
--*/
{
    NET_API_STATUS  NetStatus;
    NTSTATUS        IgnoreStatus;
    UCHAR           AccountSubAuthorityCount;
    ULONG           AccountSidLength;
    PULONG          RidLocation;

    //
    // Calculate the size of the new sid
    //
    AccountSubAuthorityCount = *RtlSubAuthorityCountSid(DomainSid) + (UCHAR)1;
    AccountSidLength = RtlLengthRequiredSid(AccountSubAuthorityCount);

    //
    // Allocate space for the account sid
    //
    *AccountSid = LocalAlloc(LMEM_ZEROINIT,AccountSidLength);
    if (*AccountSid == NULL)
    {
        NetStatus = ERROR_NOT_ENOUGH_MEMORY;
    }
    else
    {
        //
        // Copy the domain sid into the first part of the account sid
        //
        IgnoreStatus = RtlCopySid(AccountSidLength, *AccountSid, DomainSid);
        ASSERT(NT_SUCCESS(IgnoreStatus));

        //
        // Increment the account sid sub-authority count
        //
        *RtlSubAuthorityCountSid(*AccountSid) = AccountSubAuthorityCount;

        //
        // Add the rid as the final sub-authority
        //
        RidLocation = RtlSubAuthoritySid(*AccountSid, AccountSubAuthorityCount-1);
        *RidLocation = Rid;

        NetStatus = NERR_Success;
    }

    return(NetStatus);
}



BOOL
GetGuestUserNameForDomain_FastWay(
    LPTSTR              szDomainToLookUp,
    LPTSTR              lpGuestUsrName,
    DWORD               cchGuestUsrName)
{
    HRESULT             hr = S_OK;
    BOOL                fReturn = FALSE;
    NET_API_STATUS      NetStatus;
    SAM_HANDLE          SamServerHandle = NULL;             // for UaspGetDomainId()
    PPOLICY_ACCOUNT_DOMAIN_INFO pAccountDomainInfo = NULL;
    PSID                pAccountSid = NULL;
    PSID                pDomainSid = NULL;
    SID_NAME_USE        sidNameUse = SidTypeUser;           // for LookupAccountSid()
    TCHAR               szUserName[UNLEN+1];
    DWORD               cbName = UNLEN+1;
    TCHAR               szReferencedDomainName[UNLEN+1];    // use UNLEN because DNLEN is too small
    DWORD               cbReferencedDomainName = sizeof(szReferencedDomainName);

    // make sure not to return back gobble-d-gook
    *lpGuestUsrName = TEXT('\0');

    //
    // Get the Sid for the specified Domain
    //
    // szDomainToLookUp=NULL for local machine
    NetStatus = UaspGetDomainId( szDomainToLookUp,&SamServerHandle,&pAccountDomainInfo );
    if ( NetStatus != NERR_Success )
    {
        goto GetGuestUserNameForDomain_FastWay_Exit;
    }
    pDomainSid = pAccountDomainInfo->DomainSid;
    //
    // Use the Domain Sid and the well known Guest RID to create the Real Guest Sid
    //
    // Well-known users ...
    // DOMAIN_USER_RID_ADMIN          (0x000001F4L)
    // DOMAIN_USER_RID_GUEST          (0x000001F5L)
    NetStatus = NERR_InternalError;
    NetStatus = SampCreateFullSid(pDomainSid, DOMAIN_USER_RID_GUEST, &pAccountSid);
    if ( NetStatus != NERR_Success )
    {
        goto GetGuestUserNameForDomain_FastWay_Exit;
    }

    //
    // Check if the SID is valid
    //
    if (0 == IsValidSid(pAccountSid))
    {
        goto GetGuestUserNameForDomain_FastWay_Exit;
    }

    //
    // Retrieve the UserName for the specified SID
    //
    *szUserName = TEXT('\0');
    *szReferencedDomainName = TEXT('\0');
    // szDomainToLookUp=NULL for local machine
    if (!LookupAccountSid(szDomainToLookUp,
                          pAccountSid,
                          szUserName,
                          &cbName,
                          szReferencedDomainName,
                          &cbReferencedDomainName,
                          &sidNameUse))
    {
        goto GetGuestUserNameForDomain_FastWay_Exit;
    }


    // Return the guest user name that we got.
    hr = StringCchCopy(lpGuestUsrName, cchGuestUsrName, szUserName);
    if ( FAILED(hr) )
    {
        *lpGuestUsrName = TEXT('\0');
        goto GetGuestUserNameForDomain_FastWay_Exit;
    }

    // Wow, after all that, we must have succeeded
    fReturn = TRUE;

GetGuestUserNameForDomain_FastWay_Exit:
    // Free the Domain info if we got some
    if (pAccountDomainInfo)
    {
        NetpMemoryFree(pAccountDomainInfo);
    }
    // Free the sid if we had allocated one
    if (pAccountSid)
    {
        LocalFree(pAccountSid);
    }
    return fReturn;
}

BOOL
GetGuestUserName_SlowWay(
    LPWSTR              lpGuestUsrName,
    DWORD               cchGuestUsrName)
{
    HRESULT             hr = S_OK;
    LPWSTR              ServerName = NULL; // default to local machine
    DWORD               Level = 1; // to retrieve info of all local and global normal user accounts
    DWORD               Index = 0;
    DWORD               EntriesRequested = 5;
    DWORD               PreferredMaxLength = 1024;
    DWORD               ReturnedEntryCount = 0;
    PVOID               SortedBuffer = NULL;
    NET_DISPLAY_USER    *p = NULL;
    DWORD               i=0;
    int                 err = 0;
    BOOL                fStatus = TRUE;

    while (fStatus)
    {
        err = NetQueryDisplayInformation(ServerName,
                                         Level,
                                         Index,
                                         EntriesRequested,
                                         PreferredMaxLength,
                                         &ReturnedEntryCount,
                                         &SortedBuffer);
        if (err == NERR_Success)
        {
            fStatus = FALSE;
        }

        if (err == NERR_Success || err == ERROR_MORE_DATA)
        {
            p = (NET_DISPLAY_USER *)SortedBuffer;
            i = 0;
            while (i < ReturnedEntryCount && (p[i].usri1_user_id != DOMAIN_USER_RID_GUEST))
            {
                i++;
            }

            if (i == ReturnedEntryCount)
            {
                if (err == ERROR_MORE_DATA)
                {
                    // need to get more entries
                    Index = p[i-1].usri1_next_index;
                }
            }
            else
            {
                hr = StringCchCopyW(lpGuestUsrName, cchGuestUsrName, p[i].usri1_name);
                if ( FAILED(hr) )
                {
                    NetApiBufferFree(SortedBuffer);
                    SortedBuffer = NULL;
                    *lpGuestUsrName = TEXT('\0');
                    return FALSE;
                }

                fStatus = FALSE;
            }
        }
        else
        {
            if ( SortedBuffer != NULL )
            {
                NetApiBufferFree(SortedBuffer);
                SortedBuffer = NULL;
            }

            return FALSE;
        }
        NetApiBufferFree(SortedBuffer);
        SortedBuffer = NULL;
    }

    return TRUE;
}

BOOL
GetGuestUserName(
    LPTSTR              lpOutGuestUsrName,
    DWORD               cchOutGuestUsrName)
{
    HRESULT             hr = S_OK;
    TCHAR               szGuestUsrName[UNLEN+1];
    LPTSTR              pszComputerName = NULL;

    // try to retrieve the guest username the fast way
    // meaning = lookup the domain sid, and the well known guest rid, to get the guest sid.
    // then look it up.  The reason for this function is that on large domains with mega users
    // the account can be quickly looked up.
    if (!GetGuestUserNameForDomain_FastWay(pszComputerName, szGuestUsrName, UNLEN+1))
    {
        // if the fast way failed for some reason, then let's do it
        // the slow way, since this way always used to work, only on large domains (1 mil users)
        // it could take 24hrs (since this function actually enumerates thru the domain)
        if (!GetGuestUserName_SlowWay(szGuestUsrName, UNLEN+1))
        {
                return FALSE;
        }
    }

    // Return back the username
    hr = StringCchCopyW(lpOutGuestUsrName, cchOutGuestUsrName, szGuestUsrName);
    if ( FAILED(hr) )
    {
        return FALSE;
    }

    return TRUE;
}

int
GetGuestGrpName(
    LPTSTR              lpGuestGrpName)
{
    LPCTSTR             ServerName = NULL;  // local machine
    DWORD               cbName = UNLEN+1;   // use UNLEN because DNLEN is too small
    TCHAR               ReferencedDomainName[UNLEN+1];
    DWORD               cbReferencedDomainName = sizeof(ReferencedDomainName) / sizeof(TCHAR);
    SID_NAME_USE        sidNameUse = SidTypeUser;
    SID_IDENTIFIER_AUTHORITY    NtAuthority = SECURITY_NT_AUTHORITY;
    PSID                GuestsSid = NULL;

    AllocateAndInitializeSid(&NtAuthority,
                             2,
                             SECURITY_BUILTIN_DOMAIN_RID,
                             DOMAIN_ALIAS_RID_GUESTS,
                             0,
                             0,
                             0,
                             0,
                             0,
                             0,
                             &GuestsSid);

    LookupAccountSid(ServerName,
                     GuestsSid,
                     lpGuestGrpName,
                     &cbName,
                     ReferencedDomainName,
                     &cbReferencedDomainName,
                     &sidNameUse);

    if (GuestsSid)
    {
        FreeSid(GuestsSid);
    }

    return 0;
}

INT
RegisterAccountToLocalGroup(
    LPCTSTR             szAccountName,
    LPCTSTR             szLocalGroupName,
    BOOL                fAction)
{
    HRESULT             hr = S_OK;
    int                 err;
    PSID                pSID = NULL;
    BOOL                bWellKnownSID = FALSE;
    TCHAR               szLocalizedLocalGroupName[GNLEN + 1] = TEXT( "\0" ) ;
    WCHAR               wszLocalGroupName[_MAX_PATH];
    LOCALGROUP_MEMBERS_INFO_0   buf;

    // get the sid of szAccountName
    err = GetPrincipalSID ((LPTSTR)szAccountName, &pSID, &bWellKnownSID);
    if (err != ERROR_SUCCESS)
    {
        return (err);
    }

    // Get the localized LocalGroupName
    if (_wcsicmp(szLocalGroupName, TEXT("Guests")) == 0)
    {
        GetGuestGrpName(szLocalizedLocalGroupName);
    }
    else
    {
        hr = StringCchCopy(szLocalizedLocalGroupName, ARRAYSIZE(szLocalizedLocalGroupName), szLocalGroupName);
        if ( FAILED(hr) )
        {
            err = (INT)HRESULTTOWIN32(hr);
            goto exit;
        }
    }

    // transfer szLocalGroupName to WCHAR
    hr = StringCchCopyW(wszLocalGroupName, ARRAYSIZE(wszLocalGroupName), szLocalizedLocalGroupName);
    if ( FAILED(hr) )
    {
        err = (INT)HRESULTTOWIN32(hr);
        goto exit;
    }

    buf.lgrmi0_sid = pSID;

    if (fAction)
    {
        err = NetLocalGroupAddMembers(NULL, wszLocalGroupName, 0, (LPBYTE)&buf, 1);
    }
    else
    {
        err = NetLocalGroupDelMembers(NULL, wszLocalGroupName, 0, (LPBYTE)&buf, 1);
    }

exit:
    if (pSID)
    {
        if (bWellKnownSID)
        {
            FreeSid (pSID);
        }
        else
        {
            free (pSID);
        }
    }

    return (err);
}

void
InitLsaString(
    PLSA_UNICODE_STRING     LsaString,
    LPWSTR                  String)
{
    DWORD                   StringLength;

    if (String == NULL)
    {
        LsaString->Buffer = NULL;
        LsaString->Length = 0;
        LsaString->MaximumLength = 0;
        return;
    }

    StringLength = (DWORD)wcslen(String);
    LsaString->Buffer = String;
    LsaString->Length = (USHORT) StringLength * sizeof(WCHAR);
    LsaString->MaximumLength=(USHORT)(StringLength+1) * sizeof(WCHAR);
}

DWORD
OpenPolicy(
    LPTSTR              ServerName,
    DWORD               DesiredAccess,
    PLSA_HANDLE         PolicyHandle)
{
    DWORD               Error;
    LSA_OBJECT_ATTRIBUTES       ObjectAttributes;
    LSA_UNICODE_STRING  ServerString;
    PLSA_UNICODE_STRING Server = NULL;
    SECURITY_QUALITY_OF_SERVICE QualityOfService;

    QualityOfService.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
    QualityOfService.ImpersonationLevel = SecurityImpersonation;
    QualityOfService.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    QualityOfService.EffectiveOnly = FALSE;

    //
    // The two fields that must be set are length and the quality of service.
    //
    ObjectAttributes.Length = sizeof(LSA_OBJECT_ATTRIBUTES);
    ObjectAttributes.RootDirectory = NULL;
    ObjectAttributes.ObjectName = NULL;
    ObjectAttributes.Attributes = 0;
    ObjectAttributes.SecurityDescriptor = NULL;
    ObjectAttributes.SecurityQualityOfService = &QualityOfService;

    if (ServerName != NULL)
    {
        //
        // Make a LSA_UNICODE_STRING out of the LPWSTR passed in
        //
        InitLsaString(&ServerString,ServerName);
        Server = &ServerString;
    }
    //
    // Attempt to open the policy for all access
    //
    Error = LsaOpenPolicy(Server,&ObjectAttributes,DesiredAccess,PolicyHandle);
    return(Error);

}


INT
RegisterAccountUserRights(
    LPCTSTR             szAccountName,
    BOOL                fAction,
    BOOL                fSpecicaliWamAccount)
{
    int                 err;
    PSID                pSID = NULL;
    BOOL                bWellKnownSID = FALSE;
    LSA_UNICODE_STRING  UserRightString;
    LSA_HANDLE          PolicyHandle = NULL;

    // get the sid of szAccountName
    err = GetPrincipalSID ((LPTSTR)szAccountName, &pSID, &bWellKnownSID);
    if (err != ERROR_SUCCESS)
    {
        return (err);
    }

    err = OpenPolicy(NULL, POLICY_ALL_ACCESS,&PolicyHandle);
    if ( err == NERR_Success )
    {
        if (fAction)
        {
// defined in ntsecapi.h and ntlsa.h
//#define SE_INTERACTIVE_LOGON_NAME       TEXT("SeInteractiveLogonRight")
//#define SE_NETWORK_LOGON_NAME           TEXT("SeNetworkLogonRight")
//#define SE_BATCH_LOGON_NAME             TEXT("SeBatchLogonRight")
//#define SE_SERVICE_LOGON_NAME           TEXT("SeServiceLogonRight")
// Defined in winnt.h
//#define SE_CREATE_TOKEN_NAME              TEXT("SeCreateTokenPrivilege")
//#define SE_ASSIGNPRIMARYTOKEN_NAME        TEXT("SeAssignPrimaryTokenPrivilege")
//#define SE_LOCK_MEMORY_NAME               TEXT("SeLockMemoryPrivilege")
//#define SE_INCREASE_QUOTA_NAME            TEXT("SeIncreaseQuotaPrivilege")
//#define SE_UNSOLICITED_INPUT_NAME         TEXT("SeUnsolicitedInputPrivilege")
//#define SE_MACHINE_ACCOUNT_NAME           TEXT("SeMachineAccountPrivilege")
//#define SE_TCB_NAME                       TEXT("SeTcbPrivilege")
//#define SE_SECURITY_NAME                  TEXT("SeSecurityPrivilege")
//#define SE_TAKE_OWNERSHIP_NAME            TEXT("SeTakeOwnershipPrivilege")
//#define SE_LOAD_DRIVER_NAME               TEXT("SeLoadDriverPrivilege")
//#define SE_SYSTEM_PROFILE_NAME            TEXT("SeSystemProfilePrivilege")
//#define SE_SYSTEMTIME_NAME                TEXT("SeSystemtimePrivilege")
//#define SE_PROF_SINGLE_PROCESS_NAME       TEXT("SeProfileSingleProcessPrivilege")
//#define SE_INC_BASE_PRIORITY_NAME         TEXT("SeIncreaseBasePriorityPrivilege")
//#define SE_CREATE_PAGEFILE_NAME           TEXT("SeCreatePagefilePrivilege")
//#define SE_CREATE_PERMANENT_NAME          TEXT("SeCreatePermanentPrivilege")
//#define SE_BACKUP_NAME                    TEXT("SeBackupPrivilege")
//#define SE_RESTORE_NAME                   TEXT("SeRestorePrivilege")
//#define SE_SHUTDOWN_NAME                  TEXT("SeShutdownPrivilege")
//#define SE_DEBUG_NAME                     TEXT("SeDebugPrivilege")
//#define SE_AUDIT_NAME                     TEXT("SeAuditPrivilege")
//#define SE_SYSTEM_ENVIRONMENT_NAME        TEXT("SeSystemEnvironmentPrivilege")
//#define SE_CHANGE_NOTIFY_NAME             TEXT("SeChangeNotifyPrivilege")
//#define SE_REMOTE_SHUTDOWN_NAME           TEXT("SeRemoteShutdownPrivilege")
//#define SE_UNDOCK_NAME                    TEXT("SeUndockPrivilege")
//#define SE_SYNC_AGENT_NAME                TEXT("SeSyncAgentPrivilege")
//#define SE_ENABLE_DELEGATION_NAME         TEXT("SeEnableDelegationPrivilege")
            if (fSpecicaliWamAccount)
            {
                // no interactive logon for iwam!
                InitLsaString(&UserRightString, SE_NETWORK_LOGON_NAME);
                err = LsaAddAccountRights(PolicyHandle, pSID, &UserRightString, 1);
                InitLsaString(&UserRightString, SE_BATCH_LOGON_NAME);
                err = LsaAddAccountRights(PolicyHandle, pSID, &UserRightString, 1);
            }
            else
            {
                InitLsaString(&UserRightString, SE_INTERACTIVE_LOGON_NAME);
                err = LsaAddAccountRights(PolicyHandle, pSID, &UserRightString, 1);
                InitLsaString(&UserRightString, SE_NETWORK_LOGON_NAME);
                err = LsaAddAccountRights(PolicyHandle, pSID, &UserRightString, 1);
                InitLsaString(&UserRightString, SE_BATCH_LOGON_NAME);
                err = LsaAddAccountRights(PolicyHandle, pSID, &UserRightString, 1);
            }
        }
        else
        {
            InitLsaString(&UserRightString, SE_INTERACTIVE_LOGON_NAME);
            err = LsaRemoveAccountRights(PolicyHandle, pSID, FALSE, &UserRightString,1);
            InitLsaString(&UserRightString, SE_NETWORK_LOGON_NAME);
            err = LsaRemoveAccountRights(PolicyHandle, pSID, FALSE, &UserRightString,1);
            InitLsaString(&UserRightString, SE_BATCH_LOGON_NAME);
            err = LsaRemoveAccountRights(PolicyHandle, pSID, FALSE, &UserRightString,1);
        }

        LsaClose(PolicyHandle);
    }

    if (pSID)
    {
        if (bWellKnownSID)
        {
            FreeSid (pSID);
        }
        else
        {
            free (pSID);
        }
    }

    return (err);
}


int
ChangeUserPassword(
    IN LPTSTR           szUserName,
    IN LPTSTR           szNewPassword)
{
    HRESULT             hr = S_OK;
    int                 iReturn = TRUE;
    USER_INFO_1003      pi1003;
    NET_API_STATUS      nas;
    TCHAR               szRawComputerName[CNLEN + 10];
    DWORD               dwLen = CNLEN + 10;
    TCHAR               szComputerName[CNLEN + 10];
    TCHAR               szCopyOfUserName[UNLEN+10];
    TCHAR               szTempFullUserName[(CNLEN + 10) + (UNLEN+1)];
    LPTSTR              pch = NULL;

    hr = StringCchCopy(szCopyOfUserName, ARRAYSIZE(szCopyOfUserName), szUserName);
    if ( FAILED(hr) )
    {
        iReturn = FALSE;
        goto ChangeUserPassword_Exit;
    }

    //iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("ChangeUserPassword().Start.name=%s,pass=%s"),szCopyOfUserName,szNewPassword));

    if ( !GetComputerName( szRawComputerName, &dwLen ))
    {
        iReturn = FALSE;
        goto ChangeUserPassword_Exit;
    }

    // Make a copy to be sure not to move the pointer around.
    hr = StringCchCopy(szTempFullUserName, ARRAYSIZE(szTempFullUserName), szCopyOfUserName);
    if ( FAILED(hr) )
    {
        iReturn = FALSE;
        goto ChangeUserPassword_Exit;
    }

    // Check if there is a "\" in there.
    pch = wcschr(szTempFullUserName, '\\');
    if (pch)
    {
        // szCopyOfUserName should now go from something like this:
        // mycomputer\myuser
        // to this myuser
        hr = StringCchCopy(szCopyOfUserName, ARRAYSIZE(szCopyOfUserName), pch+1);
        if ( FAILED(hr) )
        {
            iReturn = FALSE;
            goto ChangeUserPassword_Exit;
        }
        // trim off the '\' character to leave just the domain\computername so we can check against it.
        *pch = '\0';
        // compare the szTempFullUserName with the local computername.
        if (0 == _wcsicmp(szRawComputerName, szTempFullUserName))
        {
            // the computername\username has a hardcoded computername in it.
            // lets try to get only the username
            // look szCopyOfusername is already set
        }
        else
        {
            // the local computer machine name
            // and the specified username are different, so get out
            // and don't even try to change this user\password since
            // it's probably a domain\username

            // return true -- saying that we did in fact change the passoword.
            // we really didn't but we can't
            iReturn = TRUE;
            goto ChangeUserPassword_Exit;
        }
    }

    // Make sure the computername has a \\ in front of it
    if ( szRawComputerName[0] != '\\' )
    {
        hr = StringCchCopyW(szComputerName, ARRAYSIZE(szComputerName), L"\\\\");
        if ( FAILED(hr) )
        {
            iReturn = FALSE;
            goto ChangeUserPassword_Exit;
        }
    }
    hr = StringCchCatW(szComputerName, ARRAYSIZE(szComputerName), szRawComputerName);
    if ( FAILED(hr) )
    {
        iReturn = FALSE;
        goto ChangeUserPassword_Exit;
    }

    //
    // administrative over-ride of existing password
    //
    // by this time szCopyOfUserName
    // should not look like mycomputername\username but it should look like username.
    pi1003.usri1003_password = szNewPassword;
    nas = NetUserSetInfo(
                         szComputerName,   // computer name
                         szCopyOfUserName, // username
                         1003,             // info level
                         (LPBYTE)&pi1003,  // new info
                         NULL
                         );

    if(nas != NERR_Success)
    {
        iReturn = FALSE;
        goto ChangeUserPassword_Exit;
    }

ChangeUserPassword_Exit:
    //iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("ChangeUserPassword().End.Ret=%d"),iReturn));
    return iReturn;
}


//
// Create InternetGuest Account
//
BOOL
CreateUser(
    LPCTSTR             szUsername,
    LPCTSTR             szPassword,
    LPCTSTR             szComment,
    LPCTSTR             szFullName,
    BOOL                fSpecialiWamAccount)
{
    INT                 err = NERR_Success;
    BYTE                *pBuffer;
    WCHAR               defGuest[UNLEN+1];
    TCHAR               defGuestGroup[GNLEN+1];
    WCHAR               wchGuestGroup[GNLEN+1];
    WCHAR               wchUsername[UNLEN+1];
    WCHAR               wchPassword[LM20_PWLEN+1];
    BOOL                fRet;

    fRet = GetGuestUserName(defGuest, UNLEN+1);

    if ( !fRet )
    {
        return FALSE;
    }

    GetGuestGrpName(defGuestGroup);

    SecureZeroMemory((PVOID)wchUsername, sizeof(wchUsername));
    SecureZeroMemory((PVOID)wchPassword, sizeof(wchPassword));
    wcsncpy(wchGuestGroup, defGuestGroup, GNLEN);
    wcsncpy(wchUsername, szUsername, UNLEN);
    wcsncpy(wchPassword, szPassword, LM20_PWLEN);

    err = NetUserGetInfo( NULL, defGuest, 3, &pBuffer );

    if ( err == NERR_Success )
    {
        WCHAR           wchComment[MAXCOMMENTSZ+1];
        WCHAR           wchFullName[UNLEN+1];

        memset((PVOID)wchComment, 0, sizeof(wchComment));
        memset((PVOID)wchFullName, 0, sizeof(wchFullName));
        wcsncpy(wchComment, szComment, MAXCOMMENTSZ);
        wcsncpy(wchFullName, szFullName, UNLEN);

        USER_INFO_3 *lpui3 = (USER_INFO_3 *)pBuffer;

        lpui3->usri3_name = wchUsername;
        lpui3->usri3_password = wchPassword;
        lpui3->usri3_flags &= ~ UF_ACCOUNTDISABLE;
        lpui3->usri3_flags |= UF_DONT_EXPIRE_PASSWD;
        lpui3->usri3_acct_expires = TIMEQ_FOREVER;

        lpui3->usri3_comment = wchComment;
        lpui3->usri3_usr_comment = wchComment;
        lpui3->usri3_full_name = wchFullName;
        lpui3->usri3_primary_group_id = DOMAIN_GROUP_RID_USERS;

        DWORD parm_err;

        err = NetUserAdd( NULL, 3, pBuffer, &parm_err );

        if ( err != NERR_Success )
        {
            if ( err == NERR_UserExists )
            {
                // see if we can just change the password.
                if (TRUE == ChangeUserPassword((LPTSTR) szUsername, (LPTSTR) szPassword))
                {
                    err = NERR_Success;
                }
            }
        }

        NetApiBufferFree( pBuffer );
    }
    if ( err == NERR_Success )
    {
        // add it to the guests or IIS_WPG group
        if (fSpecialiWamAccount)
        {
            RegisterAccountToLocalGroup(szUsername, IIS_WP_GROUP, TRUE);
        }
        else
        {
            RegisterAccountToLocalGroup(szUsername, TEXT("Guests"), TRUE);
        }

        // add certain user rights to this account
        RegisterAccountUserRights(szUsername, TRUE, fSpecialiWamAccount);
    }

    return err == NERR_Success;
}

INT
DeleteGuestUser(
    LPCTSTR             szUsername)
{
    INT                 err = NERR_Success;
    BOOL                fDisabled;
    WCHAR               wchUsername[UNLEN+1];

    wcsncpy(wchUsername, szUsername, UNLEN);

    if (FALSE == DoesUserExist(wchUsername,&fDisabled))
    {
        return err;
    }

    // remove it from the guests group
    RegisterAccountToLocalGroup(szUsername, TEXT("Guests"), FALSE);

    // remove certain user rights of this account
    RegisterAccountUserRights(szUsername, FALSE, TRUE);

    err = ::NetUserDel( TEXT(""), wchUsername );

    return err;
}

#define MAX_REALISTIC_RESOURCE_LEN  MAX_PATH

BOOL
CreateUserAccount(
    LPTSTR              pszAnonyName,
    LPTSTR              pszAnonyPass,
    DWORD               dwUserCommentResourceId,
    DWORD               dwUserFullNameResourceId,
    BOOL                fSpecicaliWamAccount)
{
    BOOL                fReturn = FALSE;
    WCHAR               pszComment[MAX_REALISTIC_RESOURCE_LEN];
    WCHAR               pszFullName[MAX_REALISTIC_RESOURCE_LEN];
    HMODULE             hBinary;

    //
    // First Load the Resources
    //

    hBinary = GetModuleHandle(TEXT("svcext"));

    if (hBinary != NULL)
    {
        fReturn = LoadString(hBinary,
                             dwUserCommentResourceId,
                             pszComment,
                             MAX_REALISTIC_RESOURCE_LEN);
        if (fReturn)
        {
            fReturn = LoadString(hBinary,
                                 dwUserFullNameResourceId,
                                 pszFullName,
                                 MAX_REALISTIC_RESOURCE_LEN);
        }

    }

    if (fReturn)
    {
        fReturn = CreateUser(pszAnonyName,
                             pszAnonyPass,
                             pszComment,
                             pszFullName,
                             fSpecicaliWamAccount
                             );
    }

    if (fReturn)
    {
        ChangeDCOMLaunchACL(pszAnonyName,
                            TRUE,
                            TRUE);
        /* removed when fixing bug 355249
        ChangeDCOMAccessACL(pszAnonyName,
                            TRUE,
                            TRUE);
        */
    }

    return fReturn;
}

typedef void (*P_SslGenerateRandomBits)( PUCHAR pRandomData, LONG size );
P_SslGenerateRandomBits ProcSslGenerateRandomBits = NULL;

BOOL
ValidatePassword(
    IN LPCTSTR          UserName,
    IN LPCTSTR          Domain,
    IN LPCTSTR          Password)
/*++
Routine Description:
    Uses SSPI to validate the specified password
Arguments:
    UserName - Supplies the user name
    Domain - Supplies the user's domain
    Password - Supplies the password
Return Value:
    TRUE if the password is valid.
    FALSE otherwise.
--*/
{
    SECURITY_STATUS SecStatus;
    SECURITY_STATUS AcceptStatus;
    SECURITY_STATUS InitStatus;
    CredHandle      ClientCredHandle;
    CredHandle      ServerCredHandle;
    BOOL            ClientCredAllocated = FALSE;
    BOOL            ServerCredAllocated = FALSE;
    CtxtHandle      ClientContextHandle;
    CtxtHandle      ServerContextHandle;
    TimeStamp       Lifetime;
    ULONG           ContextAttributes;
    PSecPkgInfo     PackageInfo = NULL;
    ULONG           ClientFlags;
    ULONG           ServerFlags;
    TCHAR           TargetName[100];
    SEC_WINNT_AUTH_IDENTITY_W   AuthIdentity;
    BOOL            Validated = FALSE;
    SecBufferDesc   NegotiateDesc;
    SecBuffer       NegotiateBuffer;
    SecBufferDesc   ChallengeDesc;
    SecBuffer       ChallengeBuffer;
    SecBufferDesc   AuthenticateDesc;
    SecBuffer       AuthenticateBuffer;

    AuthIdentity.User = (LPWSTR)UserName;
    AuthIdentity.UserLength = lstrlenW(UserName);
    AuthIdentity.Domain = (LPWSTR)Domain;
    AuthIdentity.DomainLength = lstrlenW(Domain);
    AuthIdentity.Password = (LPWSTR)Password;
    AuthIdentity.PasswordLength = lstrlenW(Password);
    AuthIdentity.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;

    NegotiateBuffer.pvBuffer = NULL;
    ChallengeBuffer.pvBuffer = NULL;
    AuthenticateBuffer.pvBuffer = NULL;

    //
    // Get info about the security packages.
    //

    SecStatus = QuerySecurityPackageInfo( TEXT("NTLM"), &PackageInfo );

    if ( SecStatus != STATUS_SUCCESS )
    {
        goto error_exit;
    }

    //
    // Acquire a credential handle for the server side
    //
    SecStatus = AcquireCredentialsHandle(
                    NULL,
                    TEXT("NTLM"),
                    SECPKG_CRED_INBOUND,
                    NULL,
                    &AuthIdentity,
                    NULL,
                    NULL,
                    &ServerCredHandle,
                    &Lifetime );

    if ( SecStatus != STATUS_SUCCESS )
    {
        goto error_exit;
    }
    ServerCredAllocated = TRUE;

    //
    // Acquire a credential handle for the client side
    //

    SecStatus = AcquireCredentialsHandle(
                    NULL,           // New principal
                    TEXT("NTLM"),
                    SECPKG_CRED_OUTBOUND,
                    NULL,
                    &AuthIdentity,
                    NULL,
                    NULL,
                    &ClientCredHandle,
                    &Lifetime );

    if ( SecStatus != STATUS_SUCCESS )
    {
        goto error_exit;
    }
    ClientCredAllocated = TRUE;

    //
    // Get the NegotiateMessage (ClientSide)
    //

    NegotiateDesc.ulVersion = 0;
    NegotiateDesc.cBuffers = 1;
    NegotiateDesc.pBuffers = &NegotiateBuffer;

    NegotiateBuffer.cbBuffer = PackageInfo->cbMaxToken;
    NegotiateBuffer.BufferType = SECBUFFER_TOKEN;
    NegotiateBuffer.pvBuffer = LocalAlloc( 0, NegotiateBuffer.cbBuffer );
    if ( NegotiateBuffer.pvBuffer == NULL )
    {
        goto error_exit;
    }

    ClientFlags = ISC_REQ_MUTUAL_AUTH | ISC_REQ_REPLAY_DETECT;

    InitStatus = InitializeSecurityContext(
                    &ClientCredHandle,
                    NULL,               // No Client context yet
                    NULL,
                    ClientFlags,
                    0,                  // Reserved 1
                    SECURITY_NATIVE_DREP,
                    NULL,                  // No initial input token
                    0,                  // Reserved 2
                    &ClientContextHandle,
                    &NegotiateDesc,
                    &ContextAttributes,
                    &Lifetime );

    if ( !NT_SUCCESS(InitStatus) )
    {
        goto error_exit;
    }

    //
    // Get the ChallengeMessage (ServerSide)
    //

    NegotiateBuffer.BufferType |= SECBUFFER_READONLY;
    ChallengeDesc.ulVersion = 0;
    ChallengeDesc.cBuffers = 1;
    ChallengeDesc.pBuffers = &ChallengeBuffer;

    ChallengeBuffer.cbBuffer = PackageInfo->cbMaxToken;
    ChallengeBuffer.BufferType = SECBUFFER_TOKEN;
    ChallengeBuffer.pvBuffer = LocalAlloc( 0, ChallengeBuffer.cbBuffer );
    if ( ChallengeBuffer.pvBuffer == NULL )
    {
        goto error_exit;
    }
    ServerFlags = ASC_REQ_EXTENDED_ERROR;

    AcceptStatus = AcceptSecurityContext(
                    &ServerCredHandle,
                    NULL,               // No Server context yet
                    &NegotiateDesc,
                    ServerFlags,
                    SECURITY_NATIVE_DREP,
                    &ServerContextHandle,
                    &ChallengeDesc,
                    &ContextAttributes,
                    &Lifetime );

    if ( !NT_SUCCESS(AcceptStatus) )
    {
        goto error_exit;
    }

    if (InitStatus != STATUS_SUCCESS)
    {
        //
        // Get the AuthenticateMessage (ClientSide)
        //

        ChallengeBuffer.BufferType |= SECBUFFER_READONLY;
        AuthenticateDesc.ulVersion = 0;
        AuthenticateDesc.cBuffers = 1;
        AuthenticateDesc.pBuffers = &AuthenticateBuffer;

        AuthenticateBuffer.cbBuffer = PackageInfo->cbMaxToken;
        AuthenticateBuffer.BufferType = SECBUFFER_TOKEN;
        AuthenticateBuffer.pvBuffer = LocalAlloc( 0, AuthenticateBuffer.cbBuffer );
        if ( AuthenticateBuffer.pvBuffer == NULL )
        {
            goto error_exit;
        }

        SecStatus = InitializeSecurityContext(
                        NULL,
                        &ClientContextHandle,
                        TargetName,
                        0,
                        0,                      // Reserved 1
                        SECURITY_NATIVE_DREP,
                        &ChallengeDesc,
                        0,                  // Reserved 2
                        &ClientContextHandle,
                        &AuthenticateDesc,
                        &ContextAttributes,
                        &Lifetime );

        if ( !NT_SUCCESS(SecStatus) )
        {
            goto error_exit;
        }

        if (AcceptStatus != STATUS_SUCCESS)
        {
            //
            // Finally authenticate the user (ServerSide)
            //

            AuthenticateBuffer.BufferType |= SECBUFFER_READONLY;

            SecStatus = AcceptSecurityContext(
                            NULL,
                            &ServerContextHandle,
                            &AuthenticateDesc,
                            ServerFlags,
                            SECURITY_NATIVE_DREP,
                            &ServerContextHandle,
                            NULL,
                            &ContextAttributes,
                            &Lifetime );

            if ( !NT_SUCCESS(SecStatus) )
            {
                goto error_exit;
            }
            Validated = TRUE;

        }

    }

error_exit:
    if (ServerCredAllocated)
    {
        FreeCredentialsHandle( &ServerCredHandle );
    }
    if (ClientCredAllocated)
    {
        FreeCredentialsHandle( &ClientCredHandle );
    }

    //
    // Final Cleanup
    //

    if ( NegotiateBuffer.pvBuffer != NULL )
    {
        (VOID) LocalFree( NegotiateBuffer.pvBuffer );
    }

    if ( ChallengeBuffer.pvBuffer != NULL )
    {
        (VOID) LocalFree( ChallengeBuffer.pvBuffer );
    }

    if ( AuthenticateBuffer.pvBuffer != NULL )
    {
        (VOID) LocalFree( AuthenticateBuffer.pvBuffer );
    }
    return(Validated);
}



DWORD
ChangeAppIDAccessACL(
    LPTSTR              AppID,
    LPTSTR              Principal,
    BOOL                SetPrincipal,
    BOOL                Permit)
{
    HRESULT             hr = S_OK;
    TCHAR               keyName [256];
    DWORD               err;

    hr = StringCchCopy( keyName, ARRAYSIZE(keyName), TEXT("APPID\\") );
    if ( FAILED(hr) )
    {
        return HRESULTTOWIN32( hr );
    }

    hr = StringCchCat( keyName, ARRAYSIZE(keyName), AppID );
    if ( FAILED(hr) )
    {
        return HRESULTTOWIN32( hr );
    }

    if (SetPrincipal)
    {
        // There is not need to check the return value of RemovePrincipalFromNamedValueSD,
        // because its failure is not important (for example DefaultAccessPermission might
        // not exist). The important call that must succeed is AddPrincipalToNamedValueSD
        RemovePrincipalFromNamedValueSD (HKEY_CLASSES_ROOT,
                                         keyName,
                                         TEXT("AccessPermission"),
                                         Principal);
        err = AddPrincipalToNamedValueSD (HKEY_CLASSES_ROOT,
                                          keyName,
                                          TEXT("AccessPermission"),
                                          Principal,
                                          Permit);
    }
    else
    {
        err = RemovePrincipalFromNamedValueSD (HKEY_CLASSES_ROOT,
                                               keyName,
                                               TEXT("AccessPermission"),
                                               Principal);
    }

    return err;
}

DWORD
ChangeAppIDLaunchACL(
    LPTSTR              AppID,
    LPTSTR              Principal,
    BOOL                SetPrincipal,
    BOOL                Permit)
{
    HRESULT             hr = S_OK;
    TCHAR               keyName [256];
    DWORD               err;

    hr = StringCchCopy( keyName, ARRAYSIZE(keyName), TEXT("APPID\\") );
    if ( FAILED(hr) )
    {
        return HRESULTTOWIN32( hr );
    }

    hr = StringCchCat( keyName, ARRAYSIZE(keyName), AppID );
    if ( FAILED(hr) )
    {
        return HRESULTTOWIN32( hr );
    }

    if (SetPrincipal)
    {
        // There is not need to check the return value of RemovePrincipalFromNamedValueSD,
        // because its failure is not important (for example DefaultAccessPermission might
        // not exist). The important call that must succeed is AddPrincipalToNamedValueSD
        RemovePrincipalFromNamedValueSD (HKEY_CLASSES_ROOT,
                                         keyName,
                                         TEXT("LaunchPermission"),
                                         Principal);
        err = AddPrincipalToNamedValueSD (HKEY_CLASSES_ROOT,
                                          keyName,
                                          TEXT("LaunchPermission"),
                                          Principal,
                                          Permit);
    }
    else
    {
        err = RemovePrincipalFromNamedValueSD (HKEY_CLASSES_ROOT,
                                               keyName,
                                               TEXT("LaunchPermission"),
                                               Principal);
    }

    return err;
}

//
//  Function will open the metabase and check the iusr_ and iwam_ usernames.
//  it will check if the names are still valid and if the passwords are still valid.
//
VOID
UpdateAnonymousUser(
    IMDCOM                  *pcCom,
    LPTSTR                  pszPath,
    DWORD                   dwUserMetaId,
    DWORD                   dwPasswordMetaId,
    DWORD                   dwUserCommentResourceId,
    DWORD                   dwUserFullNameResourceId,
    LPTSTR                  pszDefaultUserNamePrefix,
    USERNAME_STRING_TYPE    ustSyncName,
    PASSWORD_STRING_TYPE    pstSyncPass,
    BOOL                    fPerformPasswordValidate)
{
    HRESULT                 hr = S_OK;
    USERNAME_STRING_TYPE    ustAnonyName = L"\0";
    PASSWORD_STRING_TYPE    pstAnonyPass = L"\0";
    GUFM_RETURN             gufmTemp;
    BOOL                    fRet;
    BOOL                    fExistence;
    BOOL                    fDisabled;
    BOOL                    fUpdateComApplications = FALSE;
    LPTSTR                  pstrRightsFor_IUSR[] =
    {
        L"SeInteractiveLogonRight",
    	L"SeNetworkLogonRight",
        L"SeBatchLogonRight"
    };

    LPTSTR                  pstrRightsFor_IWAM[] =
    {
    	L"SeNetworkLogonRight",
        L"SeBatchLogonRight",
        L"SeAssignPrimaryTokenPrivilege",
        L"SeIncreaseQuotaPrivilege"
    };

    //
    // Get the WAM username and password
    //

    gufmTemp = GetUserFromMetabase(pcCom,
                                   pszPath,
                                   dwUserMetaId,
                                   dwPasswordMetaId,
                                   ustAnonyName,
                                   pstAnonyPass);

    //
    // If the metabase path doesn't exist, then
    // service doesn't exist, punt
    // If ID doesn't exist in the metabase, then punt, assume they
    // don't want an anonymous User. We may want to revisit this.
    //
    //

    if ((gufmTemp != GUFM_NO_PATH) && (gufmTemp != GUFM_NO_USER_ID))
    {
        BOOL            fCreateAccount = FALSE;

        //
        // See if this is our default account. Otherwise do nothing.
        //

        if (_wcsnicmp(pszDefaultUserNamePrefix,
                      ustAnonyName,
                      wcslen(pszDefaultUserNamePrefix)) == 0)
        {

            // Check if this user actually exists...
            fExistence = DoesUserExist(ustAnonyName,&fDisabled);

            if (fExistence)
            {
                if (fDisabled)
                {
                    fCreateAccount = FALSE;
                    if (!g_eventLogForAccountRecreation)
                    {
                        CreateEventLogObject ();
                    }

                    if (g_eventLogForAccountRecreation)
                    {
                        CHAR  szAnsiUserName[MAX_PATH];
                        const CHAR  *pszUserNames[1];


                        if (! WideCharToMultiByte(CP_ACP,
                                                  0,
                                                  ustAnonyName,
                                                  -1,
                                                  szAnsiUserName,
                                                  MAX_PATH-1,
                                                  NULL,
                                                  NULL))
                        {
                            SecureZeroMemory(szAnsiUserName, sizeof(szAnsiUserName));
                        }

                        pszUserNames[0] = szAnsiUserName;

                        g_eventLogForAccountRecreation->LogEvent(
                            INET_SVC_ACCOUNT_DISABLED,
                            1,
                            pszUserNames,
                            0 );
                    }

                }
                else
                {
                        if (gufmTemp != GUFM_NO_PASSWORD)
                        {
                            DBG_ASSERT(gufmTemp == GUFM_SUCCESS);

                            if (fPerformPasswordValidate)
                            {
                                BOOL fCheckPassword = TRUE;

                                //
                                // Make sure this is the same password as other
                                // instances of this account. If not, set it.
                                //

                                if ((pstSyncPass[0] != (TCHAR)'\0') &&
                                    (_wcsicmp(ustSyncName, ustAnonyName) == 0))
                                {
                                    if (wcscmp(pstSyncPass,
                                                 pstAnonyPass) != 0)
                                    {
                                        //
                                        // Passwords are different.
                                        //

                                        if (WritePasswordToMetabase(pcCom,
                                                                    pszPath,
                                                                    dwPasswordMetaId,
                                                                    pstSyncPass))
                                        {
                                            // We already checked there is enough speace in pstAnonyPass
                                            hr = StringCchCopy( pstAnonyPass, ARRAYSIZE(pstAnonyPass), pstSyncPass );
                                            DBG_ASSERT( SUCCEEDED(hr) );
                                        }
                                        else
                                        {
                                            fCheckPassword = FALSE;
                                        }
                                    }
                                }

                                if (fCheckPassword)
                                {
                                    if (ValidatePassword(ustAnonyName,
                                                         TEXT(""),
                                                         pstAnonyPass))
                                    {
                                        // thats a good case account is ok, do nothing there
                                    }
                                    else
                                    {
                                        // we comment out  DeleteGuestUser because we try to change pswd on that user
                                        // DeleteGuestUser(ustAnonyName);
                                        fCreateAccount = TRUE;
                                    }
                                }
                            }

                            //
                            // Set the sync password here
                            //

                            hr = StringCbCopy( pstSyncPass, sizeof(PASSWORD_STRING_TYPE), pstAnonyPass );
                            DBG_ASSERT( SUCCEEDED(hr) );

                            hr = StringCbCopy( ustSyncName, sizeof(USERNAME_STRING_TYPE), ustAnonyName );
                            DBG_ASSERT( SUCCEEDED(hr) );

                    }
                }
            }
            else
            {
                fCreateAccount = TRUE;
            }

            if (fCreateAccount)
            {
                //
                // The user does not exist, so let's create it.
                // Make sure there's a password first.
                //

                if (fCreateAccount)
                {
                    if (MD_WAM_USER_NAME == dwUserMetaId)
                    {
                        fRet = MakeSureUserGetsCreated(ustAnonyName,pstAnonyPass,dwUserCommentResourceId,dwUserFullNameResourceId,TRUE);
                        if( fRet )
                        {
                            fUpdateComApplications = TRUE;
                        }
                    }
                    else
                    {
                        fRet = MakeSureUserGetsCreated(ustAnonyName,pstAnonyPass,dwUserCommentResourceId,dwUserFullNameResourceId,FALSE);
                    }


                    if (!g_eventLogForAccountRecreation)
                    {
                        CreateEventLogObject ();
                    }

                    if (g_eventLogForAccountRecreation)
                    {
                        CHAR  szAnsiUserName[MAX_PATH];
                        const CHAR  *pszUserNames[1];

                        if (! WideCharToMultiByte(CP_ACP,
                                                      0,
                                                      ustAnonyName,
                                                      -1,
                                                      szAnsiUserName,
                                                      MAX_PATH-1,
                                                      NULL,
                                                      NULL))
                        {
                            SecureZeroMemory(szAnsiUserName, sizeof(szAnsiUserName));
                        }

                        pszUserNames[0] = szAnsiUserName;

                        // if succeded to recreate an account then log an event
                        if (fRet)
                        {
                            g_eventLogForAccountRecreation->LogEvent(
                                                INET_SVC_ACCOUNT_RECREATED,
                                                1,
                                                pszUserNames,
                                                0 );
                        }
                        else
                        {
                            // if the creation of the account failed, then log that too.
                            g_eventLogForAccountRecreation->LogEvent(
                                                INET_SVC_ACCOUNT_CREATE_FAILED,
                                                1,
                                                pszUserNames,
                                                0 );
                        }
                    }

                    if (dwUserMetaId == MD_WAM_USER_NAME)
                    {
                        ChangeAppIDLaunchACL(TEXT("{9209B1A6-964A-11D0-9372-00A0C9034910}"),
                                             ustAnonyName,
                                             TRUE,
                                             TRUE);
                        ChangeAppIDAccessACL(TEXT("{9209B1A6-964A-11D0-9372-00A0C9034910}"),
                                             ustAnonyName,
                                             TRUE,
                                             TRUE);
                    }
                } // fCreateAccount == TRUE
            } // fCreateAccount == TRUE

            //
            // check if user has enough rights   otherwise add some (bug 361833)
            //

            if (wcscmp(pszDefaultUserNamePrefix,TEXT("IUSR_")) == 0)
            {
                UpdateUserRights (ustAnonyName,pstrRightsFor_IUSR,sizeof(pstrRightsFor_IUSR)/sizeof(LPTSTR));
            }
            else if (wcscmp(pszDefaultUserNamePrefix,TEXT("IWAM_")) == 0)
            {
                UpdateUserRights (ustAnonyName,pstrRightsFor_IWAM,sizeof(pstrRightsFor_IWAM)/sizeof(LPTSTR));
            }


            // Update the com applications with the new wam user information
            if( fUpdateComApplications )
            {
                DWORD                   dwThreadID = 0;
                HANDLE                  hThread = NULL;
                COM_APP_THREAD_STRUCT * pUpdateComAppInfo = NULL;

                pUpdateComAppInfo = new COM_APP_THREAD_STRUCT;
                if (pUpdateComAppInfo)
                {
                    if ( wcslen(ustAnonyName) < (sizeof(pUpdateComAppInfo->ustWamUserName) / sizeof(WCHAR)) )
                    {
                        hr = StringCchCopy(pUpdateComAppInfo->ustWamUserName, ARRAYSIZE(pUpdateComAppInfo->ustWamUserName), ustAnonyName);
                        DBG_ASSERT( SUCCEEDED(hr) );

                        if ( wcslen(pstAnonyPass) < (sizeof(pUpdateComAppInfo->pstWamUserPass) / sizeof(WCHAR)) )
                        {
                            StringCchCopy(pUpdateComAppInfo->pstWamUserPass, ARRAYSIZE(pUpdateComAppInfo->pstWamUserPass), pstAnonyPass);

                            hThread = CreateThread(NULL,
                                               0,
                                               UpdateComApplicationsThread,
                                               (PVOID) pUpdateComAppInfo,
                                               0,
                                               &dwThreadID);

                            if (hThread != NULL)
                            {
                                CloseHandle(hThread);
                            }
                            else
                            {
                                if (pUpdateComAppInfo)
                                {
                                    delete pUpdateComAppInfo;
                                    pUpdateComAppInfo=NULL;
                                }
                            }
                        }
                    }
                }
            }
        }
        else
        {
            // This is not one of our accouts.
            // in other words -- it doesn't start with
            // iusr_ or iwam_
            //
            // however there is a problem here.
            //
            // on machines that are made to be replica domain controllers or
            // backup domain controllers, when dcpromo is run to create those types
            // of machines, all the local accounts are wiped out.
            //
            // this is fine if the usernames are iusr_ or iwam_, since they are just
            // re-created in the above code (or the user is warned that they were unable
            // to be crated).  however in the case where these are
            // user created accounts, the user has no way of knowing that
            // they're iusr/iwam accounts have been hosed.
            //
            // the code here is just to warn the user of that fact.
            if (TRUE == IsDomainController())
            {
                // check if they are valid.
                // Check if this user actually exists...
                fExistence = DoesUserExist(ustAnonyName,&fDisabled);
                if (!fExistence)
                {
                    if (!fDisabled)
                    {
                        // the user doesn't exist
                        // log SOMETHING at least
                        if (!g_eventLogForAccountRecreation)
                        {
                            CreateEventLogObject ();
                        }

                        if (g_eventLogForAccountRecreation)
                        {
                            CHAR  szAnsiUserName[MAX_PATH];
                            const CHAR  *pszUserNames[1];

                            if (! WideCharToMultiByte(CP_ACP,
                                0,
                                ustAnonyName,
                                -1,
                                szAnsiUserName,
                                MAX_PATH-1,
                                NULL,
                                NULL))
                            {
                                SecureZeroMemory(szAnsiUserName, sizeof(szAnsiUserName));
                            }

                            pszUserNames[0] = szAnsiUserName;

                            g_eventLogForAccountRecreation->LogEvent(
                                                INET_SVC_ACCOUNT_NOT_EXIST,
                                                1,
                                                pszUserNames,
                                                0 );

                        }
                    }
                }
            }
        }
    }
}


HRESULT
CreateGroup(
    LPWSTR              szGroupName,
    LPWSTR              szGroupComment)
{
    HRESULT             hr = S_OK;
    NET_API_STATUS      dwRes;
    LOCALGROUP_INFO_1   MyLocalGroup;
    const DWORD         dwMaxCount = 20;
    DWORD               dwCount = 0;

    MyLocalGroup.lgrpi1_name    = szGroupName;
    MyLocalGroup.lgrpi1_comment = szGroupComment;

    do
    {
        dwRes = NetLocalGroupAdd(NULL, 1, (LPBYTE)&MyLocalGroup, NULL);
        if(dwRes != NERR_Success &&
           dwRes != NERR_GroupExists &&
           dwRes != ERROR_ALIAS_EXISTS)
        {
            hr = HRESULT_FROM_WIN32(dwRes);

            //
            // if this is a domain controller.
            // we have to wait for the domain controller
            // replication to be finished, otherwise The CreateUserAccount
            // call will fail
            //
            // if we failed to create the user
            // it could be because this is a DC and we need
            // to wait for the sysvol to be ready.
            Sleep(10000);
            WaitForDCAvailability();
        }
        else
        {
            hr = S_OK;
        }
    }
    while ((FAILED(hr)) && (++dwCount < dwMaxCount));


    return hr;
}


VOID
UpdateUsers(
    BOOL                fRestore /* = FALSE */)
{
    HRESULT             hresTemp;
    IMDCOM              *pcCom;
    BOOL                fPerformUpdate = TRUE;
    BOOL                fPerformPasswordValidate = FALSE;
    HKEY                hkRegistryKey = NULL;
    DWORD               dwRegReturn;
    DWORD               dwBuffer;
    DWORD               dwSize;
    DWORD               dwType;
    HRESULT             hr;

    //
    // First get the metabase interface
    //


    dwRegReturn = RegOpenKey(HKEY_LOCAL_MACHINE,
                    L"SOFTWARE\\Microsoft\\InetStp",
                     &hkRegistryKey);
    if (dwRegReturn == ERROR_SUCCESS)
    {
        dwSize = sizeof(dwBuffer);

        dwRegReturn = RegQueryValueEx(hkRegistryKey,
                        L"DisableUserAccountRestore",
                        NULL,
                        &dwType,
                        (BYTE *)&dwBuffer,
                        &dwSize);
        if ((dwRegReturn == ERROR_SUCCESS) && dwType == (REG_DWORD))
        {
            fPerformUpdate = FALSE;
        }

        if (fPerformUpdate)
        {
            // we are doing the check to see if the user exists...
            // see if we need to verify that the password is ssynced as well...
            dwRegReturn = RegQueryValueEx(hkRegistryKey,
                            L"EnableUserAccountRestorePassSync",
                            NULL,
                            &dwType,
                            (BYTE *)&dwBuffer,
                            &dwSize);
            if ((dwRegReturn == ERROR_SUCCESS) && dwType == (REG_DWORD))
            {
                fPerformPasswordValidate = TRUE;
            }
        }

        RegCloseKey( hkRegistryKey );
    }


    if( fRestore )
    {
        fPerformPasswordValidate = TRUE;
    }

    if (fPerformUpdate)
    {
        hresTemp = CoCreateInstance(CLSID_MDCOM,
                                    NULL,
                                    CLSCTX_SERVER,
                                    IID_IMDCOM,
                                    (void**) &pcCom);

        if (SUCCEEDED(hresTemp))
        {
            //
            // Make sure the IIS_WPG group exists
            //
            hr = CreateGroup(IIS_WP_GROUP, L"IIS Worker Process Group");
            DBGPRINTF((DBG_CONTEXT, "Called into CreateGroup, hr %x\n", hr));

            LPTSTR          pstrRightsFor_IIS_WPG[] = { L"SeBatchLogonRight", L"SeImpersonatePrivilege" };
            UpdateUserRights(IIS_WP_GROUP,pstrRightsFor_IIS_WPG,sizeof(pstrRightsFor_IIS_WPG)/sizeof(LPTSTR));

            PASSWORD_STRING_TYPE pstAnonyPass;
            USERNAME_STRING_TYPE ustAnonyName;

            pstAnonyPass[0] = (TCHAR)'\0';
            ustAnonyName[0] = (TCHAR)'\0';

            UpdateAnonymousUser(pcCom,
                                TEXT("LM/W3SVC"),
                                MD_WAM_USER_NAME,
                                MD_WAM_PWD,
                                IDS_WAMUSER_COMMENT,
                                IDS_WAMUSER_FULLNAME,
                                TEXT("IWAM_"),
                                ustAnonyName,
                                pstAnonyPass,
                                fPerformPasswordValidate);

            pstAnonyPass[0] = (TCHAR)'\0';
            ustAnonyName[0] = (TCHAR)'\0';
            UpdateAnonymousUser(pcCom,
                                TEXT("LM/W3SVC"),
                                MD_ANONYMOUS_USER_NAME,
                                MD_ANONYMOUS_PWD,
                                IDS_USER_COMMENT,
                                IDS_USER_FULLNAME,
                                TEXT("IUSR_"),
                                ustAnonyName,
                                pstAnonyPass,
                                fPerformPasswordValidate);

            //
            // At this point pstAnonyPass should contain the web server password.
            //

            UpdateAnonymousUser(pcCom,
                                TEXT("LM/MSFTPSVC"),
                                MD_ANONYMOUS_USER_NAME,
                                MD_ANONYMOUS_PWD,
                                IDS_USER_COMMENT,
                                IDS_USER_FULLNAME,
                                TEXT("IUSR_"),
                                ustAnonyName,
                                pstAnonyPass,
                                fPerformPasswordValidate);

            hr = UpdateAdminAcl(pcCom,
                                L"/",
                                IIS_WP_GROUP);

            DBGPRINTF((DBG_CONTEXT, "Called into UpdateAdminAcl, hr %x\n", hr));

            hr = UpdateAdminAcl(pcCom,
                                L"/",
                                L"NT Authority\\Network Service");

            DBGPRINTF((DBG_CONTEXT, "Called into UpdateAdminAcl, hr %x\n", hr));

            hr = UpdateAdminAcl(pcCom,
                                L"/",
                                L"NT Authority\\Local Service");

            DBGPRINTF((DBG_CONTEXT, "Called into UpdateAdminAcl, hr %x\n", hr));

            pcCom->Release();
        }
    }

    if (g_eventLogForAccountRecreation)
    {
        delete g_eventLogForAccountRecreation;
        g_eventLogForAccountRecreation = NULL;
    }
}

void
DumpAdminACL(
    PSECURITY_DESCRIPTOR    pSD)
{
    HRESULT                 hr = S_OK;
    BOOL                    b = FALSE;
    BOOL                    bDaclPresent = FALSE;
    BOOL                    bDaclDefaulted = FALSE;
    PACL                    pDacl = NULL;
    ACCESS_ALLOWED_ACE*     pAce;

    DBGPRINTF((DBG_CONTEXT, "Dumping AdminAcl %p\n", pSD));

    b = GetSecurityDescriptorDacl(pSD, &bDaclPresent, &pDacl, &bDaclDefaulted);
    if (b)
    {
        DBGPRINTF((DBG_CONTEXT, "DumpAdminACL:ACE count: %d\n", (int)pDacl->AceCount));

        // now check if SID's ACE is there
        for (int i = 0; i < pDacl->AceCount; i++)
        {
            if (!GetAce(pDacl, i, (LPVOID *) &pAce))
            {
                DBGPRINTF((DBG_CONTEXT, "DumpAdminACL:GetAce failed with 0x%x\n", GetLastError()));
                continue;
            }

            if (IsValidSid(   (PSID) &(pAce->SidStart)   ) )
            {
                LPTSTR          pszSid;
                LPCTSTR         ServerName = NULL; // local machine
                DWORD           cbName = UNLEN+1;
                TCHAR           ReferencedDomainName[200];
                DWORD           cbReferencedDomainName = sizeof(ReferencedDomainName);
                SID_NAME_USE    sidNameUse = SidTypeUser;
                TCHAR           szUserName[UNLEN + 1];

                // dump out the sid in string format
                if ( ConvertSidToStringSid( (PSID)&(pAce->SidStart), &pszSid ) )
                {
                    hr = StringCchCopy(szUserName, ARRAYSIZE(szUserName), L"(unknown...)");
                    DBG_ASSERT( SUCCEEDED(hr) );

                    if (LookupAccountSid(ServerName, (PSID) &(pAce->SidStart), szUserName, &cbName, ReferencedDomainName, &cbReferencedDomainName, &sidNameUse))
                    {
                        // echo to logfile
                        DBGPRINTF((DBG_CONTEXT, "DumpAdminACL:Sid[%i]=%S,%S,0x%x,0x%x,0x%x,0x%x\n",i,
                                pszSid,
                                szUserName,
                                pAce->Header.AceType,
                                pAce->Header.AceFlags,
                                pAce->Header.AceSize,
                                pAce->Mask
                                ));
                    }
                    else
                    {
                        DBGPRINTF((DBG_CONTEXT, "DumpAdminACL:Sid[%i]=%S='%S'\n",i,pszSid,szUserName));
                    }


                    LocalFree(LocalHandle(pszSid));
                }
            }
            else
            {
                DBGPRINTF((DBG_CONTEXT, "DumpAdminACL:IsValidSid failed with 0x%x\n", GetLastError()));
            }
        }
    }
}

BOOL
MakeAbsoluteCopyFromRelative(
    PSECURITY_DESCRIPTOR    psdOriginal,
    PSECURITY_DESCRIPTOR*   ppsdNew)
{
    // we have to find out whether the original is already self-relative
    SECURITY_DESCRIPTOR_CONTROL sdc = 0;
    PSECURITY_DESCRIPTOR        psdAbsoluteCopy = NULL;
    DWORD                       dwRevision = 0;
    DWORD                       cb = 0;
    PACL                        Dacl = NULL;
    PACL                        Sacl = NULL;
    PSID                        Owner = NULL;
    PSID                        Group = NULL;
    DWORD                       dwDaclSize = 0;
    DWORD                       dwSaclSize = 0;
    DWORD                       dwOwnerSize = 0;
    DWORD                       dwPrimaryGroupSize = 0;

    if( !IsValidSecurityDescriptor( psdOriginal ) )
    {
        goto cleanup;
    }

    if( !GetSecurityDescriptorControl( psdOriginal, &sdc, &dwRevision ) )
    {
        goto cleanup;
    }

    if( sdc & SE_SELF_RELATIVE )
    {
        // the original is in self-relative format, build an absolute copy

        // get required buffer size
        cb = 0;
        MakeAbsoluteSD(
                      psdOriginal,              // address of self-relative SD
                      psdAbsoluteCopy,          // address of absolute SD
                      &cb,                      // address of size of absolute SD
                      NULL,                     // address of discretionary ACL
                      &dwDaclSize,              // address of size of discretionary ACL
                      NULL,                     // address of system ACL
                      &dwSaclSize,              // address of size of system ACL
                      NULL,                     // address of owner SID
                      &dwOwnerSize,             // address of size of owner SID
                      NULL,                     // address of primary-group SID
                      &dwPrimaryGroupSize       // address of size of group SID
                      );

        // alloc the memory
        psdAbsoluteCopy = (PSECURITY_DESCRIPTOR) malloc( cb );
        Dacl = (PACL) malloc( dwDaclSize );
        Sacl = (PACL) malloc( dwSaclSize );
        Owner = (PSID) malloc( dwOwnerSize );
        Group = (PSID) malloc( dwPrimaryGroupSize );

        if(NULL == psdAbsoluteCopy ||
           NULL == Dacl ||
           NULL == Sacl ||
           NULL == Owner ||
           NULL == Group )
        {
            goto cleanup;
        }

        // make the copy
        if( !MakeAbsoluteSD(
                 psdOriginal,            // address of self-relative SD
                 psdAbsoluteCopy,        // address of absolute SD
                 &cb,                    // address of size of absolute SD
                 Dacl,                  // address of discretionary ACL
                 &dwDaclSize,            // address of size of discretionary ACL
                 Sacl,                  // address of system ACL
                 &dwSaclSize,            // address of size of system ACL
                 Owner,                 // address of owner SID
                 &dwOwnerSize,           // address of size of owner SID
                 Group,          // address of primary-group SID
                 &dwPrimaryGroupSize     // address of size of group SID
                 ) )
        {
            goto cleanup;
        }
    }
    else
    {
        // the original is in absolute format, fail
        goto cleanup;
    }

    // paranoia check
    if( !IsValidSecurityDescriptor( psdAbsoluteCopy ) )
    {
        goto cleanup;
    }
    if( !IsValidSecurityDescriptor( psdOriginal ) )
    {
        goto cleanup;
    }

    *ppsdNew = psdAbsoluteCopy;

    return(TRUE);

cleanup:
    if( Dacl != NULL )
    {
        free((PVOID) Dacl );
        Dacl = NULL;
    }
    if( Sacl != NULL )
    {
        free((PVOID) Sacl );
        Sacl = NULL;
    }
    if( Owner != NULL )
    {
        free((PVOID) Owner );
        Owner = NULL;
    }
    if( Group != NULL )
    {
        free((PVOID) Group );
        Group = NULL;
    }
    if( psdAbsoluteCopy != NULL )
    {
        free((PVOID) psdAbsoluteCopy );
        psdAbsoluteCopy = NULL;
    }

    *ppsdNew = NULL;

    return (FALSE);
}

BOOL
AddUserAccessToSD(
    IN  PSECURITY_DESCRIPTOR    pSd,
    IN  PSID                    pSid,
    IN  DWORD                   NewAccess,
    IN  UCHAR                   TheAceType,
    OUT PSECURITY_DESCRIPTOR    *ppSdNew)
{
    ULONG                       i;
    BOOL                        bReturn = FALSE;
    BOOL                        Result;
    BOOL                        DaclPresent;
    BOOL                        DaclDefaulted;
    DWORD                       Length;
    DWORD                       NewAclLength;
    ACCESS_ALLOWED_ACE*         OldAce;
    PACE_HEADER                 NewAce = NULL;
    ACL_SIZE_INFORMATION        AclInfo;
    PACL                        Dacl = NULL;
    PACL                        NewDacl = NULL;
    PACL                        NewAceDacl = NULL;
    PSECURITY_DESCRIPTOR        NewSD = NULL;
    PSECURITY_DESCRIPTOR        OldSD = NULL;
    PSECURITY_DESCRIPTOR        outpSD = NULL;
    DWORD                       cboutpSD = 0;
    BOOL                        fAceForGroupPresent = FALSE;
    DWORD                       dwMask;

    OldSD = pSd;

    // only do if the ace is allowed/denied
    if (ACCESS_ALLOWED_ACE_TYPE != TheAceType && ACCESS_DENIED_ACE_TYPE != TheAceType)
    {
        goto Exit;
    }

    // Convert SecurityDescriptor to absolute format. It generates
    // a new SecurityDescriptor for its output which we must free.
    if ( !MakeAbsoluteCopyFromRelative(OldSD, &NewSD) )
    {
        goto Exit;
    }

    // Must get DACL pointer from new (absolute) SD
    if(!GetSecurityDescriptorDacl(NewSD,&DaclPresent,&Dacl,&DaclDefaulted))
    {
        goto Exit;
    }

    // If no DACL, no need to add the user since no DACL
    // means all accesss
    if( !DaclPresent )
    {
        bReturn = TRUE;
        goto Exit;
    }

    // Code can return DaclPresent, but a NULL which means
    // a NULL Dacl is present. This allows all access to the object.
    if( Dacl == NULL )
    {
        bReturn = TRUE;
        goto Exit;
    }

    // Get the current ACL's size
    if( !GetAclInformation(Dacl,&AclInfo,sizeof(AclInfo),AclSizeInformation) )
    {
        goto Exit;
    }

    // Check if access is already there
    // --------------------------------
    // Check to see if this SID already exists in there
    // if it does (and it has the right access we want) then forget it, we don't have to do anything more.
    for (i = 0; i < AclInfo.AceCount; i++)
    {
        ACE_HEADER *pAceHeader;
        ACCESS_ALLOWED_ACE* pAce = NULL;

        if (!GetAce(Dacl, i, (LPVOID *) &pAce))
        {
            goto Exit;
        }

        pAceHeader = (ACE_HEADER *)pAce;

        // check if group sid is already there
        if (EqualSid((PSID) &(pAce->SidStart), pSid))
        {
            if (pAceHeader->AceType == ACCESS_ALLOWED_ACE_TYPE)
            {
                // If the correct access is present, return success
                if ((pAce->Mask & NewAccess) == NewAccess)
                {
                    bReturn = TRUE;
                    goto Exit;
                }
                else
                {
                    // the ace that exist doesn't have the permissions that we want.
                    // If an ACE for our SID exists, we just need to bump
                    // up the access level instead of creating a new ACE
                    fAceForGroupPresent = TRUE;
                }
            }
            break;
        }
    }

    // If we have to create a new ACE
    // (because our user isn't listed in the existing ACL)
    // then let's Create a new ACL to put the new access allowed ACE on
    // --------------------------------
    if (!fAceForGroupPresent)
    {
        NewAclLength = sizeof(ACL) +
                       sizeof(ACCESS_ALLOWED_ACE) - sizeof(ULONG) +
                       GetLengthSid( pSid );

        NewAceDacl = (PACL) LocalAlloc( LMEM_FIXED, NewAclLength );
        if ( NewAceDacl == NULL )
        {
            goto Exit;
        }

        if(!InitializeAcl( NewAceDacl, NewAclLength, ACL_REVISION ))
        {
            goto Exit;
        }

        if (ACCESS_DENIED_ACE_TYPE == TheAceType)
        {
            Result = AddAccessDeniedAce(NewAceDacl,ACL_REVISION,NewAccess,pSid);
        }
        else
        {
            Result = AddAccessAllowedAce(NewAceDacl,ACL_REVISION,NewAccess,pSid);
        }
        if( !Result )
        {
            goto Exit;
        }
        // Grab the 1st ace from the Newly created Dacl
        if(!GetAce( NewAceDacl, 0, (void **)&NewAce ))
        {
            goto Exit;
        }

        // add CONTAINER_INHERIT_ACE TO AceFlags
        //NewAce->AceFlags |= CONTAINER_INHERIT_ACE;

        Length = AclInfo.AclBytesInUse + NewAce->AceSize;
    }
    else
    {
        Length = AclInfo.AclBytesInUse;
    }

    // Allocate new DACL
    NewDacl = (PACL) LocalAlloc( LMEM_FIXED, Length );
    if(NewDacl == NULL)
    {
        goto Exit;
    }
    if(!InitializeAcl( NewDacl, Length, ACL_REVISION ))
    {
        goto Exit;
    }

    // Insert new ACE at the front of the new DACL
    if (!fAceForGroupPresent)
    {
        if(!AddAce( NewDacl, ACL_REVISION, 0, NewAce, NewAce->AceSize ))
        {
            goto Exit;
        }
    }

    // ----------------------------------------
    // Read thru the old Dacl and get the ACE's
    // add it to the new Dacl
    // ----------------------------------------
    for ( i = 0; i < AclInfo.AceCount; i++ )
    {
        ACE_HEADER *pAceHeader;

        Result = GetAce( Dacl, i, (LPVOID*) &OldAce );
        if( !Result )
        {
            goto Exit;
        }

        pAceHeader = (ACE_HEADER *)OldAce;

        // If an ACE for our SID exists, we just need to bump
        // up the access level instead of creating a new ACE
        //
        if (pAceHeader->AceType == ACCESS_ALLOWED_ACE_TYPE)
        {
            dwMask = OldAce->Mask;
            if (fAceForGroupPresent)
            {
                if (EqualSid((PSID) &(OldAce->SidStart), pSid))
                {
                    dwMask = NewAccess | OldAce->Mask;
                }
            }

            // now add ace to new dacl
            Result = AddAccessAllowedAceEx(NewDacl, ACL_REVISION, OldAce->Header.AceFlags,dwMask,(PSID) &(OldAce->SidStart));
            if( !Result )
            {
                goto Exit;
            }
        }
        else
        {
            // copy denied or audit ace.
            if (!AddAce(NewDacl, ACL_REVISION, 0xFFFFFFFF,OldAce, pAceHeader->AceSize ))
            {
                goto Exit;
            }
        }
    }


    // Set new DACL for Security Descriptor
    if(!SetSecurityDescriptorDacl(NewSD,TRUE,NewDacl,FALSE))
    {
        goto Exit;
    }

    // The new SD is in absolute format. change it to Relative before we pass it back
    cboutpSD = 0;
    MakeSelfRelativeSD(NewSD, outpSD, &cboutpSD);
    outpSD = (PSECURITY_DESCRIPTOR)GlobalAlloc(GPTR, cboutpSD);
    if ( !outpSD )
    {
        goto Exit;
    }

    if (!MakeSelfRelativeSD(NewSD, outpSD, &cboutpSD))
    {
        goto Exit;
    }

    // The new SD is passed back in relative format,
    *ppSdNew = outpSD;

    bReturn = TRUE;

 Exit:
    if (NewSD)
    {
        free( NewSD );
        NewSD = NULL;
    }
    if (NewDacl)
    {
        LocalFree( NewDacl );
        NewDacl = NULL;
    }
    if (NewAceDacl)
    {
        LocalFree( NewAceDacl );
        NewAceDacl = NULL;
    }
    return bReturn;
}

HRESULT
UpdateAdminAcl(
    IMDCOM *                pcCom,
    LPCWSTR                 szPath,
    LPCWSTR                 szAccountName)
/*++
Routine Description:

    After DCPromo, need to update the AdminAcl in the metabase
--*/
{
    METADATA_HANDLE         hMetabase = NULL;
    METADATA_RECORD         mdrAdminAcl;
    BUFFER                  buffSid;
    BUFFER                  buffDomainName;
    PSECURITY_DESCRIPTOR    pOldSd = NULL;
    PSECURITY_DESCRIPTOR    pNewSd = NULL;
    HRESULT                 hr;
    DWORD                   dwMDGetDataLen;
    DWORD                   cbSid;
    DWORD                   cchDomainName;
    SID_NAME_USE            peUse;
    DWORD                   AccessMask = ( MD_ACR_READ |
                                           MD_ACR_UNSECURE_PROPS_READ |
                                           MD_ACR_ENUM_KEYS );

    hr = pcCom->ComMDOpenMetaObject( METADATA_MASTER_ROOT_HANDLE,
                                     szPath,
                                     METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
                                     OPEN_TIMEOUT_VALUE,
                                     &hMetabase
                                     );
    if( FAILED(hr) )
    {
        DBGPRINTF((DBG_CONTEXT, "Error opening metabase path %S, hr %x\n", szPath, hr));
        goto cleanup;
    }

    MD_SET_DATA_RECORD_EXT( &mdrAdminAcl,
                            MD_ADMIN_ACL,
                            METADATA_INHERIT | METADATA_SECURE | METADATA_REFERENCE,
                            IIS_MD_UT_SERVER,
                            BINARY_METADATA,
                            0,
                            NULL
                            );

    hr = pcCom->ComMDGetMetaData(hMetabase,
                                 NULL,
                                 &mdrAdminAcl,
                                 &dwMDGetDataLen);

    if (FAILED(hr))
    {
        DBGPRINTF((DBG_CONTEXT, "Error retrieving data, hr %x\n", hr));
        goto cleanup;
    }

    pOldSd = (PSECURITY_DESCRIPTOR)mdrAdminAcl.pbMDData;

    //
    // obtain the logon sid of the user/group
    //
    cbSid = buffSid.QuerySize();
    cchDomainName = buffDomainName.QuerySize() / sizeof(WCHAR);
    while(!LookupAccountName(NULL,
                             szAccountName,
                             buffSid.QueryPtr(),
                             &cbSid,
                             (LPWSTR)buffDomainName.QueryPtr(),
                             &cchDomainName,
                             &peUse))
    {
        if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
        {
            DBGPRINTF((DBG_CONTEXT, "Error retrieving account %S, hr %x\n", szAccountName, hr));
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto cleanup;
        }

        if (!buffSid.Resize(cbSid) ||
            !buffDomainName.Resize(cchDomainName * sizeof(WCHAR)))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto cleanup;
        }
    }

    DumpAdminACL(pOldSd);

    if (!AddUserAccessToSD(pOldSd,
                           buffSid.QueryPtr(),
                           AccessMask,
                           ACCESS_ALLOWED_ACE_TYPE,
                           &pNewSd))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        DBGPRINTF((DBG_CONTEXT, "Error adding user to AdminAcl, hr %x\n", hr));
        goto cleanup;
    }

    if (pNewSd)
    {
        DumpAdminACL(pNewSd);

        DWORD dwNewSd = GetSecurityDescriptorLength(pNewSd);

        MD_SET_DATA_RECORD_EXT( &mdrAdminAcl,
                                MD_ADMIN_ACL,
                                METADATA_INHERIT | METADATA_SECURE | METADATA_REFERENCE,
                                IIS_MD_UT_SERVER,
                                BINARY_METADATA,
                                dwNewSd,
                                pNewSd
                                );

        hr = pcCom->ComMDSetMetaData(hMetabase,
                                     NULL,
                                     &mdrAdminAcl);

        if (FAILED(hr))
        {
            DBGPRINTF((DBG_CONTEXT, "Error setting adminacl, hr %x\n", hr));
            goto cleanup;
        }
    }

 cleanup:
    if (pNewSd)
    {
        GlobalFree(pNewSd);
        pNewSd = NULL;
    }

    if (hMetabase)
    {
        // Done with the metabase
        pcCom->ComMDCloseMetaObject(hMetabase);
        hMetabase = NULL;
    }

    return hr;
}

HRESULT
UpdateComApplications(
    LPCTSTR             szWamUserName,
    LPCTSTR             szWamUserPass)
/*++
Routine Description:

    If the IWAM account has been modified, it is necessary to update the
    the out of process com+ applications with the correct account
    information. This routine will collect all the com+ applications and
    reset the activation information.

Arguments:

    szWamUserName       - the new user name
    szWamUserPass       - the new user password

Note:

    This routine is a royal pain in the butt. I take back
    all the good things I may have said about com automation.

Return Value:

    HRESULT             - Return value from failed API call
                        - E_OUTOFMEMORY
                        - S_OK - everything worked
                        - S_FALSE - encountered a non-fatal error, unable
                          to reset at least one application.
--*/
{
    HRESULT             hr = S_OK;
    BOOL                fNoErrors = TRUE;
    METADATA_HANDLE     hMetabase = NULL;
    WCHAR *             pwszDataPaths = NULL;
    DWORD               cchDataPaths = 0;
    BOOL                fTryAgain;
    DWORD               cMaxApplications;
    WCHAR *             pwszCurrentPath;
    STACK_BUFFER(       bufMDPath, 64 );
    WCHAR *             pwszMDPath = NULL;
    DWORD               dwMDPathLen;
    SAFEARRAY *         psaApplications = NULL;
    SAFEARRAYBOUND      rgsaBound[1];
    DWORD               cApplications;
    VARIANT             varAppKey;
    LONG                rgIndices[1];
    METADATA_RECORD     mdrAppIsolated;
    METADATA_RECORD     mdrAppPackageId;
    METADATA_RECORD     mdrWamClsid;
    DWORD               dwAppIsolated;
    WCHAR               wszAppPackageId[ 40 ];
    WCHAR               wszWamClsid[ 40 ];
    DWORD               dwMDGetDataLen = 0;
    ICOMAdminCatalog *  pComCatalog = NULL;
    ICatalogCollection  *pComAppCollection = NULL;
    ICatalogObject *    pComApp = NULL;
    LONG                nAppsInCollection;
    LONG                iCurrentApp;
    LONG                nChanges;
    BOOL                fAppCreated = FALSE;
    VARIANT             varOldAppIdentity;
    VARIANT             varNewAppIdentity;
    VARIANT             varNewAppPassword;
    IMDCOM *            pcCom = NULL;
    BSTR                bstrApplications = NULL;
    BSTR                bstrIdentity = NULL;
    BSTR                bstrPassword = NULL;
    DWORD               cbMDPath;

    // This is built unicode right now. Since all the com apis I need
    // are unicode only I'm using wide characters here. I should get
    // plenty of compiler errors if _UNICODE isn't defined, but just
    // in case....
    // DBG_ASSERT( sizeof(TCHAR) == sizeof(WCHAR) );

    DBGPRINTF(( DBG_CONTEXT,
                "Updating activation identity for out of process apps.\n"
                ));

    // Init variants
    VariantInit( &varAppKey );
    VariantInit( &varOldAppIdentity );
    VariantInit( &varNewAppIdentity );
    VariantInit( &varNewAppPassword );

    // Allocate the BSTRs
    bstrApplications = SysAllocString( L"Applications" );
    if ( bstrApplications  == NULL )
    {
        hr = E_OUTOFMEMORY;
        DBGERROR(( DBG_CONTEXT,
                   "Out of memory allocating BSTR\n"
                   ));
        goto cleanup;
    }
    bstrIdentity = SysAllocString( L"Identity" );
    if ( bstrIdentity  == NULL )
    {
        hr = E_OUTOFMEMORY;
        DBGERROR(( DBG_CONTEXT,
                   "Out of memory allocating BSTR\n"
                   ));
        goto cleanup;
    }
    bstrPassword = SysAllocString( L"Password" );
    if ( bstrPassword  == NULL )
    {
        hr = E_OUTOFMEMORY;
        DBGERROR(( DBG_CONTEXT,
                   "Out of memory allocating BSTR\n"
                   ));
        goto cleanup;
    }

    hr = CoCreateInstance(CLSID_MDCOM,
                          NULL,
                          CLSCTX_SERVER,
                          IID_IMDCOM,
                          (void**) &pcCom);
    if( FAILED(hr) )
    {
        DBGERROR(( DBG_CONTEXT,
                   "Failed CoCreateInstance CLSID_MDCOM (%08x)\n",
                   hr
                   ));
        goto cleanup;
    }

    //
    // Get the applications to be reset by querying the metabase paths
    //

    hr = pcCom->ComMDOpenMetaObject( METADATA_MASTER_ROOT_HANDLE,
                                     ROOTMDPath,
                                     METADATA_PERMISSION_READ,
                                     OPEN_TIMEOUT_VALUE,
                                     &hMetabase
                                     );
    if( FAILED(hr) )
    {
        DBGERROR(( DBG_CONTEXT,
                   "Failed to open metabase (%08x)\n",
                   hr
                   ));
        goto cleanup;
    }

    // Get the data paths string

    fTryAgain = TRUE;
    do
    {
        hr = pcCom->ComMDGetMetaDataPaths( hMetabase,
                                           NULL,
                                           MD_APP_PACKAGE_ID,
                                           STRING_METADATA,
                                           cchDataPaths,
                                           pwszDataPaths,
                                           &cchDataPaths
                                           );

        if( HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) == hr )
        {
            delete[] pwszDataPaths;
            pwszDataPaths = NULL;

            pwszDataPaths = new WCHAR[cchDataPaths];
            if( !pwszDataPaths )
            {
                hr = E_OUTOFMEMORY;
                goto cleanup;
            }
        }
        else
        {
            fTryAgain = FALSE;
        }
    }
    while( fTryAgain );

    //
    // Done with the metabase for now
    //
    pcCom->ComMDCloseMetaObject(hMetabase);
    hMetabase = NULL;

    if( FAILED(hr) )
    {
        DBGERROR(( DBG_CONTEXT,
                   "Failed to find metadata (%08x) Data(%d)\n",
                   hr,
                   MD_APP_PACKAGE_ID
                   ));
        goto cleanup;
    }
    else if (pwszDataPaths == NULL)
    {
        //
        // If we found no isolated apps, make the path list an empty multisz
        //
        cchDataPaths = 1;
        pwszDataPaths = new WCHAR[cchDataPaths];
        if( !pwszDataPaths )
        {
            hr = E_OUTOFMEMORY;
            goto cleanup;
        }
        pwszDataPaths[0] = L'\0';
    }

    // Determine the maximum number of applications

    cMaxApplications = 1; // The pooled application

    for( pwszCurrentPath = pwszDataPaths;
         *pwszCurrentPath != L'\0';
         pwszCurrentPath += wcslen(pwszCurrentPath) + 1
         )
    {
        cMaxApplications++;
    }

    //
    // Build a key array and load the com applications.
    //

    // Create an array to hold the keys

    rgsaBound[0].cElements = cMaxApplications;
    rgsaBound[0].lLbound = 0;

    psaApplications = SafeArrayCreate( VT_VARIANT, 1, rgsaBound );
    if( psaApplications == NULL )
    {
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    // Set the out of process pool application key
    varAppKey.vt = VT_BSTR;
    varAppKey.bstrVal = SysAllocString( W3_OOP_POOL_PACKAGE_ID );
    if( !varAppKey.bstrVal )
    {
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    rgIndices[0] = 0;
    hr = SafeArrayPutElement( psaApplications, rgIndices, &varAppKey );
    if( FAILED(hr) )
    {
        DBGERROR(( DBG_CONTEXT,
                   "Failed setting an element in a safe array (%08x)\n",
                   hr
                   ));
        goto cleanup;
    }

    // For each of the application paths determine if an out of process
    // application is defined there and set the appropriate key into
    // our array

    MD_SET_DATA_RECORD_EXT( &mdrAppIsolated,
                            MD_APP_ISOLATED,
                            METADATA_NO_ATTRIBUTES,
                            ALL_METADATA,
                            DWORD_METADATA,
                            sizeof(DWORD),
                            (PBYTE)&dwAppIsolated
                            );

    MD_SET_DATA_RECORD_EXT( &mdrAppPackageId,
                            MD_APP_PACKAGE_ID,
                            METADATA_NO_ATTRIBUTES,
                            ALL_METADATA,
                            STRING_METADATA,
                            sizeof(wszAppPackageId),
                            (PBYTE)wszAppPackageId
                            );

    wszAppPackageId[0] = L'\0';

    MD_SET_DATA_RECORD_EXT( &mdrWamClsid,
                            MD_APP_WAM_CLSID,
                            METADATA_NO_ATTRIBUTES,
                            ALL_METADATA,
                            STRING_METADATA,
                            sizeof(wszWamClsid),
                            (PBYTE)wszWamClsid
                            );

    wszWamClsid[0] = L'\0';

    // Go through each data path and set it into our array if
    // it is an isolated application

    cApplications = 1;  // Actual # of applications - 1 for pool

    for( pwszCurrentPath = pwszDataPaths;
         *pwszCurrentPath != L'\0';
         pwszCurrentPath += wcslen(pwszCurrentPath) + 1
        )
    {
        if( hMetabase != NULL )
        {
            pcCom->ComMDCloseMetaObject(hMetabase);
            hMetabase = NULL;
        }

        //
        // 20 is the size of L"/LM/W3SVC"
        //
        cbMDPath = (DWORD)(wcslen( pwszCurrentPath ) * sizeof( WCHAR )) + 20;
        if ( !bufMDPath.Resize( cbMDPath ) )
        {
            hr = E_OUTOFMEMORY;
            goto cleanup;
        }

        pwszMDPath = ( WCHAR* )bufMDPath.QueryPtr();

        hr = StringCbCopyW( pwszMDPath, cbMDPath, ROOTMDPath );
        if ( FAILED(hr) )
        {
            goto cleanup;

        }

        hr = StringCbCopyW( pwszMDPath, cbMDPath, pwszCurrentPath );
        if ( FAILED(hr) )
        {
            goto cleanup;

        }

        //
        // Get rid of the trailing '/' or '\\'
        //
        dwMDPathLen = (DWORD)wcslen( pwszMDPath );
        if( pwszMDPath[ dwMDPathLen - 1 ] == L'\\' ||
            pwszMDPath[ dwMDPathLen - 1 ] == L'/' )
        {
            pwszMDPath[ dwMDPathLen - 1 ] = L'\0';
        }

        hr = pcCom->ComMDOpenMetaObject( METADATA_MASTER_ROOT_HANDLE,
                                         pwszMDPath,
                                         METADATA_PERMISSION_READ,
                                         OPEN_TIMEOUT_VALUE,
                                         &hMetabase
                                         );
        if( FAILED(hr) )
        {
            DBGERROR(( DBG_CONTEXT,
                       "Failed to open metabase (%08x)\n",
                       hr
                       ));
            goto cleanup;
        }

        hr = pcCom->ComMDGetMetaData( hMetabase,
                                      NULL,
                                      &mdrAppIsolated,
                                      &dwMDGetDataLen
                                      );
        if( FAILED(hr) )
        {
            DBGERROR(( DBG_CONTEXT,
                       "Failed to get data from the metabase (%08x)"
                       " Path(%S) Data(%d)\n",
                       hr,
                       pwszMDPath,
                       mdrAppIsolated.dwMDIdentifier
                       ));

            fNoErrors = FALSE;
            continue;
        }

        // Is the application out of process
        if( dwAppIsolated == 1 )
        {
            // Get the application id

            hr = pcCom->ComMDGetMetaData( hMetabase,
                                          NULL,
                                          &mdrAppPackageId,
                                          &dwMDGetDataLen
                                          );
            if( FAILED(hr) )
            {
                DBGERROR(( DBG_CONTEXT,
                           "Failed to get data from the metabase (%08x)"
                           " Path(%S) Data(%d)\n",
                           hr,
                           pwszMDPath,
                           mdrAppPackageId.dwMDIdentifier
                           ));

                fNoErrors = FALSE;
                continue;
            }

            // Get the wam class id

            hr = pcCom->ComMDGetMetaData( hMetabase,
                                          NULL,
                                          &mdrWamClsid,
                                          &dwMDGetDataLen
                                          );
            if( FAILED(hr) )
            {
                DBGERROR(( DBG_CONTEXT,
                           "Failed to get data from the metabase (%08x)"
                           " Path(%S) Data(%d)\n",
                           hr,
                           pwszMDPath,
                           mdrWamClsid.dwMDIdentifier
                           ));

                fNoErrors = FALSE;
                continue;
            }

            //
            // Close meta object since we may need to write to it after we
            // create a new COM+ application.
            //
            pcCom->ComMDCloseMetaObject(hMetabase);
            hMetabase = NULL;

            if ( g_pfnCreateCOMPlusApplication )
            {
                hr = g_pfnCreateCOMPlusApplication( pwszMDPath,
                                                    wszAppPackageId,
                                                    wszWamClsid,
                                                    &fAppCreated );
            }
            else
            {
                hr = E_FAIL;
            }

            if( FAILED( hr ) )
            {
                fNoErrors = FALSE;
                continue;
            }

            if( fAppCreated )
            {
                //
                // We don't need to fix the password for this
                // COM+ application
                //
                continue;
            }

            // Add the application id to the array

            VariantClear( &varAppKey );
            varAppKey.vt = VT_BSTR;
            varAppKey.bstrVal = SysAllocString( wszAppPackageId );
            if( !varAppKey.bstrVal )
            {
                hr = E_OUTOFMEMORY;
                goto cleanup;
            }

            rgIndices[0]++;
            hr = SafeArrayPutElement( psaApplications,
                                      rgIndices,
                                      &varAppKey
                                      );
            if( FAILED(hr) )
            {
                DBGERROR(( DBG_CONTEXT,
                           "Failed to set safe array element (%08x)\n",
                           hr
                           ));
                VariantClear( &varAppKey );
                rgIndices[0]--;
                fNoErrors = FALSE;
                continue;
            }
            cApplications++;
        }
    }

    //
    // IVANPASH: BUG #524473
    // Close meta object, because if W3SVC is starting it will keep SCM locked
    // until it finishes, but it will be blocked by us from accessing /LM/W3SVC.
    // and we will be blocked in the CoCreate for the COM+ Catalog waiting for
    // SCM to unlock to start the service and SCM is waiting for W3SVC.
    //
    if( hMetabase != NULL )
    {
        pcCom->ComMDCloseMetaObject(hMetabase);
        hMetabase = NULL;
    }

    // Shrink the size of the safe-array if necessary
    if( cApplications < cMaxApplications )
    {
        rgsaBound[0].cElements = cApplications;

        hr = SafeArrayRedim( psaApplications, rgsaBound );
        if( FAILED(hr) )
        {
            DBGERROR(( DBG_CONTEXT,
                       "Failed to redim safe array (%08x)\n",
                       hr
                       ));
            goto cleanup;
        }
    }

    //
    // For each application reset the activation identity
    //

    // Use our key array to get the application collection
    DBG_ASSERT( hMetabase == NULL );

    hr = CoCreateInstance( CLSID_COMAdminCatalog,
                           NULL,
                           CLSCTX_SERVER,
                           IID_ICOMAdminCatalog,
                           (void**)&pComCatalog
                           );
    if( FAILED(hr) )
    {
        DBGERROR(( DBG_CONTEXT,
                   "Failed to create COM catalog (%08x)\n",
                   hr
                   ));
        goto cleanup;
    }

    hr = pComCatalog->GetCollection( bstrApplications,
                                     (IDispatch **)&pComAppCollection
                                     );
    if( FAILED(hr) )
    {
        DBGERROR(( DBG_CONTEXT,
                   "Failed to get Applications collection (%08x)\n",
                   hr
                   ));
        goto cleanup;
    }

    hr = pComAppCollection->PopulateByKey( psaApplications );
    if( FAILED(hr) )
    {
        DBGERROR(( DBG_CONTEXT,
                   "Failed to populate Applications collection (%08x)\n",
                   hr
                   ));
        goto cleanup;
    }

    // Iterate over the application collection and update all the
    // applications that use IWAM.

    hr = pComAppCollection->get_Count( &nAppsInCollection );
    if( FAILED(hr) )
    {
        DBGERROR(( DBG_CONTEXT,
                   "Failed to get Applications count (%08x)\n",
                   hr
                   ));
        goto cleanup;
    }

    // Init our new app identity and password.

    varNewAppIdentity.vt = VT_BSTR;
    varNewAppIdentity.bstrVal = SysAllocString( szWamUserName );
    if( !varNewAppIdentity.bstrVal )
    {
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    varNewAppPassword.vt = VT_BSTR;
    varNewAppPassword.bstrVal = SysAllocString( szWamUserPass );
    if( !varNewAppPassword.bstrVal )
    {
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    for( iCurrentApp = 0; iCurrentApp < nAppsInCollection; ++iCurrentApp )
    {
        if( pComApp )
        {
            pComApp->Release();
            pComApp = NULL;
        }
        if( varOldAppIdentity.vt != VT_EMPTY )
        {
            VariantClear( &varOldAppIdentity );
        }

        hr = pComAppCollection->get_Item( iCurrentApp,
                                          (IDispatch **)&pComApp );
        if( FAILED(hr) )
        {
            DBGERROR(( DBG_CONTEXT,
                       "Failed to get item from Applications collection (%08x)\n",
                       hr
                       ));
            fNoErrors = FALSE;
            continue;
        }

        // If the user has set this to something other than the IWAM_
        // user, then we will respect that and not reset the identiy.

        hr = pComApp->get_Value( bstrIdentity, &varOldAppIdentity );
        if( FAILED(hr) )
        {
            DBGERROR(( DBG_CONTEXT,
                       "Failed to get Identify from Application (%08x)\n",
                       hr
                       ));
            fNoErrors = FALSE;
            continue;
        }

        DBG_ASSERT( varOldAppIdentity.vt == VT_BSTR );
        if( varOldAppIdentity.vt == VT_BSTR )
        {
            if( memcmp( L"IWAM_", varOldAppIdentity.bstrVal, 10 ) == 0 )
            {
                hr = pComApp->put_Value( bstrIdentity, varNewAppIdentity );
                if( FAILED(hr) )
                {
                    DBGERROR(( DBG_CONTEXT,
                               "Failed to set new Identify (%08x)\n",
                               hr
                               ));
                    fNoErrors = FALSE;
                    continue;
                }

                hr = pComApp->put_Value( bstrPassword, varNewAppPassword );
                if( FAILED(hr) )
                {
                    DBGERROR(( DBG_CONTEXT,
                               "Failed to set new Password (%08x)\n",
                               hr
                               ));
                    fNoErrors = FALSE;
                    continue;
                }
            }
            else
            {
                DBGINFO(( DBG_CONTEXT,
                          "Unrecognized application identity (%S)\n",
                          varOldAppIdentity.bstrVal
                          ));
            }
        }
    }

    hr = pComAppCollection->SaveChanges( &nChanges );
    if( FAILED(hr) )
    {
        DBGERROR(( DBG_CONTEXT,
                   "Failed to save changes (%08x)\n",
                   hr
                   ));
        goto cleanup;
    }

cleanup:

    if( hMetabase != NULL )
    {
        pcCom->ComMDCloseMetaObject(hMetabase);
        hMetabase = NULL;
    }

    if( psaApplications != NULL )
    {
        SafeArrayDestroy( psaApplications );
    }

    if( pComCatalog != NULL )
    {
        pComCatalog->Release();
    }

    if( pComAppCollection != NULL )
    {
        pComAppCollection->Release();
    }

    if( pComApp != NULL )
    {
        pComApp->Release();
    }

    if( varAppKey.vt != VT_EMPTY )
    {
        VariantClear( &varAppKey );
    }

    if( varOldAppIdentity.vt != VT_EMPTY )
    {
        VariantClear( &varOldAppIdentity );
    }

    if( varNewAppIdentity.vt != VT_EMPTY )
    {
        VariantClear( &varNewAppIdentity );
    }

    if( varNewAppPassword.vt != VT_EMPTY )
    {
        VariantClear( &varNewAppPassword );
    }

    delete [] pwszDataPaths;

    if ( bstrApplications != NULL)
    {
        SysFreeString( bstrApplications );
        bstrApplications = NULL;
    }
    if ( bstrIdentity != NULL)
    {
        SysFreeString( bstrIdentity );
        bstrIdentity = NULL;
    }
    if ( bstrPassword != NULL)
    {
        SysFreeString( bstrPassword );
        bstrPassword = NULL;
    }

    if( pcCom != NULL )
    {
        pcCom->Release();
    }

    // return
    if( FAILED(hr) )
    {
        return hr;
    }
    else if( fNoErrors == FALSE )
    {
        return S_FALSE;
    }
    else
    {
        return S_OK;
    }
}

int
IsDomainController(void)
{
    int                 iReturn = FALSE;
    OSVERSIONINFOEX     VerInfo;

    ZeroMemory(&VerInfo, sizeof VerInfo);
    VerInfo.dwOSVersionInfoSize = sizeof VerInfo;
    if (GetVersionEx(reinterpret_cast<OSVERSIONINFO *>(&VerInfo)))
    {
        if (VER_NT_DOMAIN_CONTROLLER == VerInfo.wProductType)
        {
            iReturn = TRUE;
        }
    }

    return iReturn;
}

BOOL
MakeSureUserGetsCreated(
    LPTSTR              pszAnonyName,
    LPTSTR              pszAnonyPass,
    DWORD               dwUserCommentResourceId,
    DWORD               dwUserFullNameResourceId,
    BOOL                fSpecicaliWamAccount)
{
    BOOL                bReturn = FALSE;
    const DWORD         dwMaxCount = 20;
    DWORD               dwCount = 0;

    do
    {
        bReturn = CreateUserAccount(pszAnonyName,pszAnonyPass,dwUserCommentResourceId,dwUserFullNameResourceId,fSpecicaliWamAccount);
        if (!bReturn)
        {
            // if this is a domain controller.
            // we have to wait for the domain controller
            // replication to be finished, otherwise The CreateUserAccount
            // call will fail
            //
            // if we failed to create the user
            // it could be because this is a DC and we need
            // to wait for the sysvol to be ready.
            Sleep(10000);
            WaitForDCAvailability();
        }

    }
    while ((!bReturn) && (++dwCount < dwMaxCount));

    return bReturn;
}

BOOL
WaitForDCAvailability(void)
{
    BOOL                bRetVal = FALSE;
    DWORD               dwResult;
    DWORD               dwCount = 0;
    DWORD               dwMaxWait = 60000; // 1 minute max wait
    HKEY                hKeyNetLogonParams;

    if (FALSE == IsDomainController())
    {
        // not a domain controller
        // so we don't have to worry about replication delays...
        return TRUE;
    }

    dwResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE,TEXT("SYSTEM\\CurrentControlSet\\Services\\netlogon\\parameters"),0,KEY_READ,&hKeyNetLogonParams );
    if ( dwResult == ERROR_SUCCESS )
    {
        //
        // value exists
        //
        DWORD           dwSysVolReady = 0;
        DWORD           dwSize = sizeof( DWORD );
        DWORD           dwType = REG_DWORD;

        dwResult = RegQueryValueEx( hKeyNetLogonParams,TEXT("SysVolReady"),0,&dwType,(LPBYTE) &dwSysVolReady,&dwSize );
        if ( dwResult == ERROR_SUCCESS )
        {
            //
            // SysVolReady?
            //
            if ( dwSysVolReady == 0 )
            {
                HANDLE hEvent;
                //
                // wait for SysVol to become ready
                //
                hEvent = CreateEvent( 0, TRUE, FALSE, TEXT("IISSysVolReadyEvent") );
                if ( hEvent )
                {
                    dwResult = RegNotifyChangeKeyValue( hKeyNetLogonParams, FALSE, REG_NOTIFY_CHANGE_LAST_SET, hEvent, TRUE );
                    if ( dwResult == ERROR_SUCCESS )
                    {
                        const DWORD dwMaxCount = 3;
                        do
                        {
                            //
                            // wait for SysVolReady to change
                            // hEvent is signaled for any changes in hKeyNetLogonParams
                            // not just the SysVolReady value.
                            //
                            WaitForSingleObject (hEvent, dwMaxWait / dwMaxCount );
                            dwResult = RegQueryValueEx( hKeyNetLogonParams,TEXT("SysVolReady"),0,&dwType,(LPBYTE) &dwSysVolReady,&dwSize );
                        }
                        while ( dwSysVolReady == 0 && ++dwCount < dwMaxCount );

                        if ( dwSysVolReady )
                        {
                            bRetVal = TRUE;
                        }
                    }
                    CloseHandle( hEvent );
                }
            }
            else
            {
                // sysvol is ready
                bRetVal = TRUE;
            }

        }
        else
        {
            //
            // value is non-existent, SysVol is assumed to be ready
            //
            if ( dwResult == ERROR_FILE_NOT_FOUND )
            {
                bRetVal = TRUE;
            }
        }

        RegCloseKey( hKeyNetLogonParams );
    }
    else
    {
        // error opening regkey, maybe it's not even there
        bRetVal = TRUE;
    }

    return bRetVal;
}


DWORD
UpdateComApplicationsThread(
    PVOID                   pv)
{

    HRESULT                 hr = S_OK;
    COM_APP_THREAD_STRUCT   *pUpdateComAppInfo = (COM_APP_THREAD_STRUCT *) pv;
    BOOL                    fComInitialized = FALSE;


    if ( pUpdateComAppInfo == NULL )
    {
        goto exit;
    }

    hr = CoInitializeEx( NULL, COINIT_MULTITHREADED );
    if ( FAILED( hr ) )
    {
        goto exit;
    }
    fComInitialized = TRUE;

    hr = UpdateComApplications( pUpdateComAppInfo->ustWamUserName,
                                pUpdateComAppInfo->pstWamUserPass );


exit:
    if( hr != S_OK )
    {
        if( !g_eventLogForAccountRecreation )
        {
            CreateEventLogObject();
        }

        if ( g_eventLogForAccountRecreation )
        {
            g_eventLogForAccountRecreation->LogEvent( INET_SVC_ACCOUNT_COMUPDATE_FAILED,
                                                      0,
                                                      NULL,
                                                      hr );
        }
    }
    if ( pUpdateComAppInfo != NULL )
    {
        // erase the memory that we held the username/password in.
        SecureZeroMemory( (PVOID)pUpdateComAppInfo->ustWamUserName,
                          sizeof(pUpdateComAppInfo->ustWamUserName) );
        SecureZeroMemory( (PVOID)pUpdateComAppInfo->pstWamUserPass,
                          sizeof(pUpdateComAppInfo->pstWamUserPass) );

        delete pUpdateComAppInfo;
        pUpdateComAppInfo = NULL;
    }
    if ( fComInitialized )
    {
        CoUninitialize();
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\extend\extcom.cxx ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    extcom.cxx

Abstract:

    IIS Services IISADMIN Extension
    Main COM interface.
    Class CadmExt
    CLSID = CLSID_W3EXTEND
    IID = IID_IADMEXT

Author:

    Michael W. Thomas            16-Sep-97

--*/

#include <cominc.hxx>

#ifdef _IIS_6_0
#include "w3ssl_config.hxx"
#include <iismap.hxx>
#endif

DECLARE_DEBUG_PRINTS_OBJECT();

PFNCREATECOMPLUSAPPLICATION g_pfnCreateCOMPlusApplication = NULL;
static const CHAR           c_szWamReg[] = "wamreg.dll";
static const CHAR           c_szCreateCOMPlusApplication[] = "CreateCOMPlusApplication";

CAdmExt::CAdmExt():
    m_dwRefCount(0),
    m_pcCom(NULL),
    m_dwSinkCookie(0),
    m_pConnPoint(NULL)
{
}

CAdmExt::~CAdmExt()
{
#ifndef _NO_TRACING_
    DELETE_DEBUG_PRINT_OBJECT();
#endif
}

HRESULT
CAdmExt::QueryInterface(
    REFIID              riid,
    void                **ppObject)
{
    if ( ppObject == NULL )
    {
        return E_INVALIDARG;
    }

    *ppObject = NULL;

    if ( riid==IID_IUnknown || riid==IID_IADMEXT )
    {
        *ppObject = (IADMEXT *) this;
    }
    else
    {
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}

ULONG
CAdmExt::AddRef()
{
    DWORD dwRefCount;
    InterlockedIncrement((long *)&g_dwRefCount);
    dwRefCount = InterlockedIncrement((long *)&m_dwRefCount);
    return dwRefCount;
}

ULONG
CAdmExt::Release()
{
    DWORD dwRefCount;
    InterlockedDecrement((long *)&g_dwRefCount);
    dwRefCount = InterlockedDecrement((long *)&m_dwRefCount);
    //
    // This is now a member of class factory.
    // It is not dynamically allocated, so don't delete it.
    //
    return dwRefCount;
}


HRESULT STDMETHODCALLTYPE
CAdmExt::Initialize(void)
{
    HRESULT             hresReturn = S_OK;
    HMODULE             hmodWamReg = NULL;

    CREATE_DEBUG_PRINT_OBJECT( "svcext" );
    LOAD_DEBUG_FLAGS_FROM_REG_STR( "System\\CurrentControlSet\\Services\\iisadmin\\Parameters", 0 );

    hmodWamReg = LoadLibraryA( c_szWamReg );
    if ( hmodWamReg != NULL )
    {
        g_pfnCreateCOMPlusApplication = (PFNCREATECOMPLUSAPPLICATION)GetProcAddress( hmodWamReg, c_szCreateCOMPlusApplication );
        DBG_ASSERT( g_pfnCreateCOMPlusApplication != NULL );
        if ( g_pfnCreateCOMPlusApplication == NULL )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "Loaded %s, but failed to get %s.\n",
                        c_szWamReg,
                        c_szCreateCOMPlusApplication ));

            FreeLibrary( hmodWamReg );
            hmodWamReg = NULL;

            hresReturn = E_FAIL;
            return hresReturn;
        }
        else
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "Loaded %s and got %s.\n",
                        c_szWamReg,
                        c_szCreateCOMPlusApplication ));
            // We need to keep the wamreg.dll loaded as if importing CreateCOMPlusApplication
            hmodWamReg = NULL;
        }
    }
    else
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Failed to load %s.\n",
                    c_szWamReg ));

        // If wamreg is not installed do NOT fail.
        // This is a valid case if we have only ftp installed, but no www.
    }

#ifdef _IIS_6_0

    ImportIISCertMappingsToIIS6();

    hresReturn = W3SSL_CONFIG::Initialize();
    //
    // based on the IIS mode adjust the image path of HTTPFilter service
    //
    if ( FAILED(hresReturn) )
    {
        return hresReturn;
    }

    //
    // ImagePath of HTTPFilter must be changed asynchronously here
    // The reason is that in this moment the service database is locked
    // because iisadmin is in START_PENDING and if we tried to change
    // image path of HTTPFilter synchronously it would cause deadlock
    // Note: Changing asynchronously has a side effect that after iisadmin
    // reports that service started, it is not guaranteed that image path
    // of HTTPFilter was already changed

    W3SSL_CONFIG::StartAsyncAdjustHTTPFilterImagePath();

#endif

    hresReturn = CoCreateInstance(CLSID_MDCOM,
                                  NULL,
                                  CLSCTX_SERVER,
                                  IID_IMDCOM,
                                  (void**) &m_pcCom);
    if (SUCCEEDED(hresReturn))
    {
        //
        // First, set the state of all servers to Stopped.
        //

        SetServerState(L"/LM/W3SVC");
        SetServerState(L"/LM/MSFTPSVC");

        //
        // Set up a sink for special processing.
        //

        IConnectionPointContainer* pConnPointContainer = NULL;
        CSvcExtImpIMDCOMSINK *pEventSink = new CSvcExtImpIMDCOMSINK(m_pcCom);

        if (pEventSink != NULL)
        {
            // First query the object for its Connection Point Container. This
            // essentially asks the object in the server if it is connectable.
            hresReturn = m_pcCom->QueryInterface(
                   IID_IConnectionPointContainer,
                   (PVOID *)&pConnPointContainer);
            if SUCCEEDED(hresReturn)
            {
                // Find the requested Connection Point. This AddRef's the
                // returned pointer.
                hresReturn = pConnPointContainer->FindConnectionPoint(IID_IMDCOMSINK_W, &m_pConnPoint);
                if (SUCCEEDED(hresReturn))
                {
                    hresReturn = m_pConnPoint->Advise((IUnknown *)pEventSink, &m_dwSinkCookie);
                }

                pConnPointContainer->Release();
            }

            pEventSink->Release();
        }
        else
        {
            hresReturn = E_OUTOFMEMORY;
        }
    }

    UpdateUsers();

    return hresReturn;
}


HRESULT STDMETHODCALLTYPE
CAdmExt::EnumDcomCLSIDs(
    CLSID               *,
    DWORD               )
{
    return HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS);
}

HRESULT STDMETHODCALLTYPE
CAdmExt::Terminate(void)
{

#ifdef _IIS_6_0
    //
    // terminate W3SSL_CONFIG before unadvising because
    // that will enable to unblock calls to W3SSL_CONFIG that
    // may have happen from sink callbacks
    //
    W3SSL_CONFIG::Terminate();
#endif

    if (m_pcCom != NULL)
    {
        if (m_pConnPoint != NULL)
        {
            if (m_dwSinkCookie != 0)
            {
                m_pConnPoint->Unadvise(m_dwSinkCookie);
            }
            m_pConnPoint->Release();
        }
        m_pcCom->Release();
    }

    return S_OK;
}

VOID
CAdmExt::SetServerState(
    LPWSTR              pszPath)
{
    HRESULT             hresReturn;
    HRESULT             hresTempReturn;
    TCHAR               pszNameBuf[METADATA_MAX_NAME_LEN];
    int                 i;
    METADATA_RECORD     mdrData;
    DWORD               dwData;
    DWORD               dwRequiredDataLen;
    METADATA_HANDLE     mdhCurrent;

    hresReturn = m_pcCom->ComMDOpenMetaObject(METADATA_MASTER_ROOT_HANDLE,
                                            pszPath,
                                            METADATA_PERMISSION_WRITE | METADATA_PERMISSION_READ,
                                            OPEN_TIMEOUT_VALUE,
                                            &mdhCurrent);

    if (SUCCEEDED(hresReturn))
    {
        for (i=0;hresReturn == ERROR_SUCCESS;i++)
        {
            //
            // enumerate children
            //

            hresReturn = m_pcCom->ComMDEnumMetaObjects(mdhCurrent,
                                                     TEXT(""),
                                                     pszNameBuf,
                                                     i);

            if (SUCCEEDED(hresReturn))
            {
                MD_SET_DATA_RECORD_EXT(&mdrData,
                                       MD_SERVER_STATE,
                                       METADATA_NO_ATTRIBUTES,
                                       0,
                                       DWORD_METADATA,
                                       sizeof(DWORD),
                                       (PBYTE)&dwData)

                //
                // See if Server State exists at this node,
                // and pick up the current attributes, etc.
                //

                hresTempReturn = m_pcCom->ComMDGetMetaData(mdhCurrent,
                                                        pszNameBuf,
                                                        &mdrData,
                                                        &dwRequiredDataLen);

                //
                // PREFIX
                // ComMDGetMetaData should not return success without setting the data
                // value pointed to by dwData. I'm not sure if PREFIX is incapable of
                // recognizing the extra level of indirection or if there is some path
                // that I missed in reviewing ComMDGetMetaData. I'm going to shut down
                // this warning, but I'll open an issue with the PREFIX guys.
                //

                /* INTRINSA suppress = uninitialized */
                if ((SUCCEEDED(hresTempReturn)) && (dwData != MD_SERVER_STATE_STOPPED))
                {
                    //
                    // Set the new data
                    //

                    dwData = MD_SERVER_STATE_STOPPED;
                    hresTempReturn = m_pcCom->ComMDSetMetaData(mdhCurrent,
                                                             pszNameBuf,
                                                             &mdrData);
                }
            }
        }

        hresReturn = m_pcCom->ComMDCloseMetaObject(mdhCurrent);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\dcomadm\mdutil\tables.h ===
/*++

   Copyright    (c)    1997    Microsoft Corporation

   Module  Name :

       tables.h

   Abstract:

        mapping tables to convert various info between text and binary

   Environment:

      Win32 User Mode

   Author: 
     
	  jaroslad  (jan 1997)

--*/

#if !defined (__JD_TABLES_H)
#define __JD_TABLES_H 


#include <afx.h>
#ifdef UNICODE
	#include <iadmw.h>
#else
	#include "ansimeta.h"
#endif

//constanst to be returned by functions that map name to code
//
#define NAME_NOT_FOUND 0xFFFFFFFE

BOOL IsNumber(const CString& name);



BOOL IsServiceName(const CString& name);


//**********************************************************************
// PROPERTY NAME TABLE DEFINITION
//**********************************************************************
struct tPropertyNameTable;
 
tPropertyNameTable gPropertyNameTable[];

struct tPropertyNameTable 
{
	DWORD dwCode;
	LPCTSTR lpszName;
	DWORD dwDefAttributes; //default attributes (metadata compatible)
	DWORD dwDefUserType;   //default user type (metadata compatible)
	DWORD dwDefDataType;   //default data type (metadata compatible)
	DWORD dwFlags;         //internal flags (nothing to do with metadata)

	static tPropertyNameTable * FindRecord(DWORD dwCode, tPropertyNameTable * PropertyNameTable=::gPropertyNameTable);
	static tPropertyNameTable * FindRecord(const CString strName, tPropertyNameTable * PropertyNameTable=::gPropertyNameTable);
	
	static DWORD MapNameToCode(const CString& strName, tPropertyNameTable * PropertyNameTable=::gPropertyNameTable);
	static CString MapCodeToName(DWORD dwCode, tPropertyNameTable * PropertyNameTable=::gPropertyNameTable);
};

DWORD MapPropertyNameToCode(const CString & strName);



//**********************************************************************
// VALUE TABLE DEFINITION
//**********************************************************************

struct tValueTable ;
tValueTable gValueTable[];

struct tValueTable 
{
	enum {TYPE_EXCLUSIVE=1};
	DWORD dwCode;
	LPCTSTR lpszName;
	DWORD dwRelatedPropertyCode; // code of the Property this value can be used for
	DWORD dwFlags;         //internal flags (nothing to do with metadata)

	static DWORD  MapNameToCode(const CString& strName, DWORD dwRelatedPropertyCode, tValueTable * ValueTable=::gValueTable);
	static CString MapValueContentToString(DWORD dwValueContent, DWORD dwRelatedPropertyCode, tValueTable * ValueTable=::gValueTable);

};

DWORD  MapValueNameToCode(const CString & strName, DWORD dwRelatedPropertyCode);



//**********************************************************************
// COMMAND NAME TABLE DEFINITION 
//**********************************************************************

struct tCommandNameTable ;
tCommandNameTable gCommandNameTable[];

struct tCommandNameTable 
{
	DWORD dwCode;
	LPCTSTR lpszName;
	DWORD dwFlags;         //internal flags (nothing to do with metadata)

	static DWORD  MapNameToCode(const CString& strName, tCommandNameTable * CommandNameTable=::gCommandNameTable);
};

DWORD MapCommandNameToCode(const CString & strName);

enum
{	CMD_SET=1,
	CMD_GET,
	CMD_COPY,
	CMD_DELETE,
	CMD_ENUM,
	CMD_ENUM_ALL,
	CMD_CREATE,
	CMD_RENAME,
	CMD_SCRIPT,
	CMD_SAVE,
	CMD_APPCREATEINPROC,
	CMD_APPCREATEOUTPOOL,
	CMD_APPCREATEOUTPROC,
	CMD_APPDELETE,
        CMD_APPRENAME,
	CMD_APPUNLOAD,
	CMD_APPGETSTATUS,
};

//**********************************************************************
// PROPERTY ATTRIB NAME TABLE DEFINITION
//**********************************************************************
struct tAttribNameTable ;
tAttribNameTable gAttribNameTable[];


struct tAttribNameTable 
{
	DWORD dwCode;
	LPCTSTR lpszName;
	DWORD dwFlags;         //internal flags (nothing to do with metadata)

	static DWORD MapNameToCode(const CString& strName, tAttribNameTable * AttribNameTable=::gAttribNameTable);
};

DWORD MapAttribNameToCode(const CString & strName);


//**********************************************************************
// PROPERTY DATA TYPE NAME TABLE DEFINITION 
//**********************************************************************

struct tDataTypeNameTable ;
tDataTypeNameTable gDataTypeNameTable[];

struct tDataTypeNameTable 
{
	DWORD dwCode;
	LPCTSTR lpszName;
	DWORD dwFlags;         //internal flags (nothing to do with metadata)

	static DWORD  MapNameToCode(const CString& strName, tDataTypeNameTable * DataTypeNameTable=::gDataTypeNameTable);
	static CString MapCodeToName(DWORD a_dwCode, tDataTypeNameTable * DataTypeNameTable=::gDataTypeNameTable);

};

DWORD MapDataTypeNameToCode(const CString & strName);

//**********************************************************************
// PROPERTY USER TYPE NAME TABLE DEFINITION AND IMPLEMENTATION
//**********************************************************************

struct tUserTypeNameTable ;
tUserTypeNameTable gUserTypeNameTable[];


struct tUserTypeNameTable 
{
	DWORD dwCode;
	LPCTSTR lpszName;
	DWORD dwFlags;         //internal flags (nothing to do with metadata)

	static DWORD  MapNameToCode(const CString& strName, tUserTypeNameTable * UserTypeNameTable=::gUserTypeNameTable);
};

DWORD MapUserTypeNameToCode(const CString & strName);



void PrintTablesInfo(void);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\extend\resource.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    checker.cxx

Abstract:

    IIS Services IISADMIN Extension
    Unicode Metadata Sink.

Author:

    Michael W. Thomas            11-19-98

--*/

#ifndef _resource_h
#define _resource_h

#define IDS_USER_COMMENT                1
#define IDS_USER_FULLNAME               2
#define IDS_WAMUSER_COMMENT             3
#define IDS_WAMUSER_FULLNAME            4
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\extend\sink.cxx ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    sink.cxx

Abstract:

    IIS Services IISADMIN Extension
    Unicode Metadata Sink.

Author:

    Michael W. Thomas            16-Sep-97

--*/
#include <cominc.hxx>
#include "w3ssl_config.hxx"


//extern HANDLE          hevtDone;

#define REG_FP_LOAD_VALUE         "NewFPWebCmdLine"
#define REG_FP_UNLOAD_VALUE       "DelFPWebCmdLine"

CSvcExtImpIMDCOMSINK::CSvcExtImpIMDCOMSINK(
    IMDCOM *            pcCom):
    m_dwRefCount(1),
    m_pcCom(pcCom)
{
}

CSvcExtImpIMDCOMSINK::~CSvcExtImpIMDCOMSINK()
{
}

HRESULT
CSvcExtImpIMDCOMSINK::QueryInterface(
    REFIID              riid,
    void                **ppObject)
{
    if ( ppObject == NULL )
    {
        return E_INVALIDARG;
    }

    *ppObject = NULL;

    if (riid==IID_IUnknown || riid==IID_IMDCOMSINK_W)
    {
        *ppObject = (IMDCOMSINKW *) this;
    }
    else
    {
        return E_NOINTERFACE;
    }

    AddRef();
    return NO_ERROR;
}

ULONG
CSvcExtImpIMDCOMSINK::AddRef()
{
    DWORD dwRefCount;
    dwRefCount = InterlockedIncrement((long *)&m_dwRefCount);
    return dwRefCount;
}

ULONG
CSvcExtImpIMDCOMSINK::Release()
{
    DWORD dwRefCount;
    dwRefCount = InterlockedDecrement((long *)&m_dwRefCount);
    if (dwRefCount == 0)
    {
        delete this;
    }

    return dwRefCount;
}

#define SCHEMA_PATH_PREFIX IIS_MD_ADSI_SCHEMA_PATH_W L"/"

HRESULT STDMETHODCALLTYPE
CSvcExtImpIMDCOMSINK::ComMDSinkNotify(
    METADATA_HANDLE             ,
    DWORD                       dwMDNumElements,
    MD_CHANGE_OBJECT __RPC_FAR  pcoChangeList[  ])
{
    DWORD                       i;
    DWORD                       j;

    for (i = 0; i < dwMDNumElements; i++)
    {
        if (((pcoChangeList[i].dwMDChangeType | MD_CHANGE_TYPE_SET_DATA) != 0) &&

            //
            // If this is a schema change, then don't do anything
            //

            (_wcsnicmp(pcoChangeList[i].pszMDPath,
                       SCHEMA_PATH_PREFIX,
                       ((sizeof(SCHEMA_PATH_PREFIX) / sizeof(WCHAR)) - 1)) != 0))
        {
            for (j = 0; j < pcoChangeList[i].dwMDNumDataIDs; j++)
            {
                switch (pcoChangeList[i].pdwMDDataIDs[j])
                {
                case MD_FRONTPAGE_WEB:
                    {
                        RegisterFrontPage( pcoChangeList[i].pszMDPath );
                        break;
                    }

                case MD_SERVER_COMMAND:
                    {
                        ProcessCommand(pcoChangeList[i].pszMDPath, MD_SERVER_COMMAND, MD_SERVER_COMMAND_START );
                        break;
                    }

                case MD_APPPOOL_COMMAND:
                    {
                        ProcessCommand(pcoChangeList[i].pszMDPath, MD_APPPOOL_COMMAND, MD_APPPOOL_COMMAND_START);
                        break;
                    }


                case MD_GLOBAL_STANDARD_APP_MODE_ENABLED:
                    {
                        W3SSL_CONFIG::AdjustHTTPFilterImagePath();
                        break;
                    }

                default:
                    ;

                    //
                    // No specific action for this command
                    //
                }
            }
        }
    }
    return S_OK;
}



#define REG_KEY_W3SVC_VROOTS    TEXT("SYSTEM\\CurrentControlSet\\Services\\W3SVC\\Parameters\\Virtual Roots")
#define REG_KEY_MSFTPSVC_VROOTS TEXT("SYSTEM\\CurrentControlSet\\Services\\MSFTPSVC\\Parameters\\Virtual Roots")


HRESULT STDMETHODCALLTYPE
CSvcExtImpIMDCOMSINK::ComMDEventNotify(
    DWORD               dwMDEvent)
{
    DWORD               err;

    if (dwMDEvent == MD_EVENT_MID_RESTORE)
    {
        //
        // Blow away registry VRoots so they won't be brought back to life
        //
        err = RegDeleteKey(HKEY_LOCAL_MACHINE, REG_KEY_W3SVC_VROOTS);
        if ( err != ERROR_SUCCESS )
        {
            DBGINFOW((DBG_CONTEXT,
                      L"[ComMDEventNotify] (%x) Couldn't remove W3SVC VRoot key\n",
                      err  ));
        }

        err = RegDeleteKey(HKEY_LOCAL_MACHINE, REG_KEY_MSFTPSVC_VROOTS);
        if ( err != ERROR_SUCCESS )
        {
            DBGINFOW((DBG_CONTEXT,
                      L"[ComMDEventNotify] (%x) Couldn't remove MSFTPSVC VRoot key\n",
                      err  ));
        }

    }

    //
    // Sync up the user accounts with those from the metabase
    //

    UpdateUsers( TRUE );

    return S_OK;
}

//
// This must be in a non-Unicode file so that registry reads on Win95 work.
//


VOID
CSvcExtImpIMDCOMSINK::RegisterFrontPage(
    LPWSTR              pszPath)
{
    HRESULT             hr = S_OK;
    HKEY                hkey = NULL;
    CHAR                buff[255];
    CHAR                cmd[512];
    CHAR                achPath[512];
    LPSTR               pszOp;
    DWORD               cbBuff = sizeof( buff );
    DWORD               dwType;
    DWORD               dwValue = 0;
    DWORD               dwRequiredDataLen;
    HRESULT             hresReturn;
    METADATA_RECORD     mdrData;

    MD_SET_DATA_RECORD_EXT(&mdrData,
                           MD_FRONTPAGE_WEB,
                           METADATA_NO_ATTRIBUTES,
                           ALL_METADATA,
                           DWORD_METADATA,
                           sizeof(DWORD),
                           (PBYTE)&dwValue)

    hresReturn = m_pcCom->ComMDGetMetaData(METADATA_MASTER_ROOT_HANDLE,
                                           pszPath,
                                           &mdrData,
                                           &dwRequiredDataLen);

    if (FAILED(hresReturn))
    {
        if (hresReturn != MD_ERROR_DATA_NOT_FOUND)
        {
            DBGINFOW((DBG_CONTEXT,
                      L"[RegisterFrontPage] GetData Failed, return code = %X\n",
                      hresReturn));
        }
    }
    else
    {
        DBGINFOW(( DBG_CONTEXT,
                    L"[RegisterFrontPage] Value - %d, Path - %S\n",
                    dwValue,
                    pszPath ));

        //
        // PREFIX
        // ComMDGetMetaData should not return success without setting the data
        // value pointed to by dwValue. I'm not sure if PREFIX is incapable of
        // recognizing the extra level of indirection or if there is some path
        // that I missed in reviewing ComMDGetMetaData. I'm going to shut down
        // this warning, but I'll open an issue with the PREFIX guys.
        //

        /* INTRINSA suppress = uninitialized */
        pszOp = dwValue ? REG_FP_LOAD_VALUE : REG_FP_UNLOAD_VALUE;


        if ( !RegOpenKeyExA( HKEY_LOCAL_MACHINE,
                            REG_FP_PATH,
                            0,
                            KEY_READ,
                            &hkey )   &&
             !RegQueryValueExA( hkey,
                               pszOp,
                               NULL,
                               &dwType,
                               (BYTE *) buff,
                               &cbBuff ))
        {

            if ( WideCharToMultiByte( CP_ACP,
                                      0,
                                      pszPath,
                                      -1,
                                      achPath,
                                      sizeof(achPath),
                                      NULL,
                                      NULL ) == 0 )
            {
                DBGINFOW((DBG_CONTEXT,
                          L"Failed to convert path to Ansi, error = %d\n",
                          GetLastError() ));
            }
            else
            {

                //
                // FrontPage cannot handle trailing slash, so remove it.
                // Need to restore as this is not a local copy of path.
                //

                DWORD   dwPathLen = (DWORD)strlen(achPath);

                DBG_ASSERT(achPath[dwPathLen - 1] == '/');

                achPath[dwPathLen - 1] = '\0';

                if ( (strlen( buff ) + (dwPathLen - 1)) < sizeof( cmd ) )
                {
                    STARTUPINFOA        StartupInfo;
                    PROCESS_INFORMATION ProcessInformation;
                    BOOL                CreateProcessStatus;

                    hr = StringCbVPrintfA( cmd, sizeof(cmd), buff, achPath );
                    if ( SUCCEEDED(hr) )
                    {
                        RtlZeroMemory(&StartupInfo,sizeof(StartupInfo));
                        StartupInfo.cb = sizeof(StartupInfo);
                        StartupInfo.dwFlags = 0;
                        StartupInfo.wShowWindow = 0;
                        CreateProcessStatus = CreateProcessA(
                                                NULL,
                                                cmd,
                                                NULL,
                                                NULL,
                                                FALSE,
                                                0,
                                                NULL,
                                                NULL,
                                                &StartupInfo,
                                                &ProcessInformation );

                        if ( CreateProcessStatus )
                        {
                            DBG_REQUIRE( CloseHandle(ProcessInformation.hProcess) );
                            DBG_REQUIRE( CloseHandle(ProcessInformation.hThread) );
                        }
                        else
                        {
                            DBGPRINTF(( DBG_CONTEXT,
                                        "[RegisterFrontPage] CreateProcess returned %d for %s\n",
                                        GetLastError(),
                                        cmd ));
                        }
                    }
                    else
                    {
                        DBGPRINTF(( DBG_CONTEXT,
                                    "[RegisterFrontPage] StringCbVPrintfA returned 0x%08x for %s\n",
                                    hr,
                                    cmd ));
                    }
                }
            }

        }
        else
        {
            DBGINFOW((DBG_CONTEXT,
                      L"[RegisterFrontPage] Failed to open reg or read value\n"));
        }

        if ( hkey )
        {
            RegCloseKey( hkey );
        }
    }
}


VOID
CSvcExtImpIMDCOMSINK::ProcessCommand(
    LPWSTR              pszPath,
    DWORD               dwMetabaseProperty,
    DWORD               dwStartValue)
{
    WCHAR               pszServiceName[METADATA_MAX_NAME_LEN];
    DWORD               dwValue = 0;
    DWORD               dwRequiredDataLen;
    HRESULT             hresReturn;
    METADATA_RECORD     mdrData;

    MD_SET_DATA_RECORD_EXT(&mdrData,
                           dwMetabaseProperty,
                           METADATA_NO_ATTRIBUTES,
                           ALL_METADATA,
                           DWORD_METADATA,
                           sizeof(DWORD),
                           (PBYTE)&dwValue)

    hresReturn = m_pcCom->ComMDGetMetaData(METADATA_MASTER_ROOT_HANDLE,
                                           pszPath,
                                           &mdrData,
                                           &dwRequiredDataLen);

    if (FAILED(hresReturn))
    {
        DBGINFOW((DBG_CONTEXT,
                  L"[ProcessCommandInternal] GetData Failed, return code = %X\n",
                  hresReturn));
    }
    else
    {
        //
        // PREFIX
        // ComMDGetMetaData should not return success without setting the data
        // value pointed to by dwValue. I'm not sure if PREFIX is incapable of
        // recognizing the extra level of indirection or if there is some path
        // that I missed in reviewing ComMDGetMetaData. I'm going to shut down
        // this warning, but I'll open an issue with the PREFIX guys.
        //

        /* INTRINSA suppress = uninitialized */
        if (dwValue == dwStartValue)
        {
            if (GetServiceNameFromPath(pszPath,
                                       pszServiceName))
            {
                StartIISService(pszServiceName);
            }
        }
    }

}

#define SERVICE_NAME_PREFIX L"/LM/"

BOOL
GetServiceNameFromPath(
    LPWSTR              pszPath,
    LPWSTR              pszServiceName)
/*++

Routine Description:

    Start an IIS service

Arguments:
    pszPath - path spcifying which IIS service to start
    pszServiceName - updated with service name

Return Value:
    TRUE - Success
    FALSE - Failure

--*/
{
    LPWSTR              pszPathIndex;
    UINT                cS;

    DBG_ASSERT(pszPath != NULL);
    DBG_ASSERT(pszServiceName != NULL);

    pszPathIndex = pszPath;
    if ((_wcsnicmp( pszPathIndex, \
                    SERVICE_NAME_PREFIX,
                    ((sizeof(SERVICE_NAME_PREFIX) / sizeof(WCHAR)) - 1)) == 0) &&
        (pszPath[(sizeof(SERVICE_NAME_PREFIX) / sizeof(WCHAR)) - 1] != (WCHAR)'\0'))
    {
        pszPathIndex += ((sizeof(SERVICE_NAME_PREFIX) / sizeof(WCHAR)) -1);

        //
        // copy to temp buffer until path delim
        //

        for ( cS = 0 ; cS < METADATA_MAX_NAME_LEN-1 &&
                       (*pszPathIndex != (WCHAR)'/'); )
        {
            pszServiceName[cS++] = *pszPathIndex++;
        }
        pszServiceName[cS] = (WCHAR)'\0';

        return TRUE;
    }

    return FALSE;
}

VOID
StartIISService(
    LPWSTR              pszServiceName)
/*++

Routine Description:

    Start an IIS service

Arguments:
    pszServiceName - specify which IIS service to start

Return Value:
    TRUE - Success
    FALSE - Failure

--*/
{
    SC_HANDLE           scManagerHandle;
    SC_HANDLE           serviceHandle;

    DBG_ASSERT(pszServiceName != NULL);

    //
    // Start service WinNT-style
    //

    //
    // Open the service control manager
    //

    scManagerHandle = OpenSCManager( NULL,        // local machine
                                     NULL,        // ServicesActive database
                                     SC_MANAGER_ALL_ACCESS ); // all access

    if ( scManagerHandle != NULL )
    {
        //
        // Open the service
        //

        serviceHandle = OpenService( scManagerHandle,
                                     pszServiceName,
                                     SERVICE_START );

        if ( serviceHandle != NULL )
        {
            //
            // Make sure the service is running
            //

            if (!StartService( serviceHandle,
                               0,
                               NULL) &&
                (GetLastError() != ERROR_SERVICE_ALREADY_RUNNING))
            {
                DBGINFOW(( DBG_CONTEXT,
                            L"[StartIISService] StartService(%s) Failed, Error = %X\n",
                            pszServiceName,
                            GetLastError()));
            }

            CloseServiceHandle( serviceHandle );
        }

        //
        // Close open handle
        //

        CloseServiceHandle( scManagerHandle);

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\info\client\info_cli_stub.c ===
#include "info_cli.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\info\client\infostub.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    infostub.c

Abstract:

    Client stubs of the Internet Info Server Admin APIs.

Author:

    Madan Appiah (madana) 10-Oct-1993

Environment:

    User Mode - Win32

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include "info_cli.h"

#include <ntsam.h>
#include <ntlsa.h>

#include <ftpd.h>
#include <w3svc.h>
#include <rpcutil.h>
#include <winsock2.h>
#include <rpcasync.h>

//
//  Quick macro to initialize a unicode string
//

WCHAR  g_wchUnicodeNull[] = L"";

#define _InitUnicodeString( pUnicode, pwch )                       \
   {                                                               \
        (pUnicode)->Buffer    = pwch;                              \
        (pUnicode)->Length    = wcslen( pwch ) * sizeof(WCHAR);    \
        (pUnicode)->MaximumLength = (pUnicode)->Length + sizeof(WCHAR); \
   }

# define InitUnicodeString( pUnicode, pwch)  \
   if (pwch == NULL) { _InitUnicodeString( pUnicode, g_wchUnicodeNull); } \
   else              { _InitUnicodeString( pUnicode, pwch);             } \


//
//  Returns a unicode empty string if the string is NULL
//

#define EMPTY_IF_NULL(str)      (str ? str : L"")

struct SRV_SECRET_NAMES
{
    DWORD   dwID;
    LPWSTR  SecretName;
    LPWSTR  RootSecretName;
}
aSrvSecrets[] =
{
    INET_FTP,     FTPD_ANONYMOUS_SECRET_W,     FTPD_ROOT_SECRET_W,
    INET_HTTP,    W3_ANONYMOUS_SECRET_W,       W3_ROOT_SECRET_W,
    INET_GOPHER,  GOPHERD_ANONYMOUS_SECRET_W , GOPHERD_ROOT_SECRET_W,
    //INET_CHAT,    CHAT_ANONYMOUS_SECRET_W,     CHAT_ROOT_SECRET_W,
    //INET_NNTP,    NNTP_ANONYMOUS_SECRET_W,     NNTP_ROOT_SECRET_W,
    //INET_SMTP,    SMTP_ANONYMOUS_SECRET_W,     SMTP_ROOT_SECRET_W,
    //INET_POP3,    POP3_ANONYMOUS_SECRET_W,     POP3_ROOT_SECRET_W,
    //INET_LDAP,    LDAP_ANONYMOUS_SECRET_W,     LDAP_ROOT_SECRET_W,
    //INET_IMAP,    IMAP_ANONYMOUS_SECRET_W,     IMAP_ROOT_SECRET_W,
    0,            NULL,                        NULL
};

DWORD
GetSecret(
    IN  LPWSTR       Server,
    IN  LPWSTR       SecretName,
    OUT LPWSTR *     ppSecret
    );

DWORD
SetSecret(
    IN  LPWSTR       Server,
    IN  LPWSTR       SecretName,
    IN  LPWSTR       pSecret,
    IN  DWORD        cbSecret
    );


NET_API_STATUS
NET_API_FUNCTION
InetInfoGetVersion(
    IN  LPWSTR   Server OPTIONAL,
    IN  DWORD    dwReserved,
    OUT DWORD *  pdwVersion
    )
{
    NET_API_STATUS status;

    RpcTryExcept
    {
        //
        // Try RPC (local or remote) version of API.
        //
        status = R_InetInfoGetVersion(
                     Server,
                     dwReserved,
                     pdwVersion
                     );
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        status = RpcExceptionCode();
    }
    RpcEndExcept

    return (status);

} // InetInfoGetVersion()




NET_API_STATUS
NET_API_FUNCTION
InetInfoGetServerCapabilities(
    IN  LPWSTR   Server OPTIONAL,
    IN  DWORD    dwReserved,
    OUT LPINET_INFO_CAPABILITIES * ppCap
    )
{
    NET_API_STATUS status;

    *ppCap = NULL;
    RpcTryExcept
    {
        //
        // Try RPC (local or remote) version of API.
        //
        status = R_InetInfoGetServerCapabilities(
                     Server,
                     dwReserved,
                     (LPINET_INFO_CAPABILITIES_STRUCT *)ppCap
                     );
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        status = RpcExceptionCode();
    }
    RpcEndExcept

    return (status);

} // InetInfoServerCapabilities()




NET_API_STATUS
NET_API_FUNCTION
InetInfoQueryStatistics(
    IN  LPWSTR   pszServer OPTIONAL,
    IN  DWORD    Level,
    IN  DWORD    dwServerMask,
    OUT LPBYTE * Buffer
    )
{
    NET_API_STATUS status;

    *Buffer = NULL;
    RpcTryExcept
    {
        //
        // Try RPC (local or remote) version of API.
        //
        status = R_InetInfoQueryStatistics(
                     pszServer,
                     Level,
                     dwServerMask,
                     (LPINET_INFO_STATISTICS_INFO) Buffer
                     );
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        status = RpcExceptionCode();
    }
    RpcEndExcept

    return (status);
} // InetInfoQueryStatistics()




NET_API_STATUS
NET_API_FUNCTION
InetInfoClearStatistics(
    IN  LPWSTR pszServer OPTIONAL,
    IN  DWORD  dwServerMask
    )
{
    NET_API_STATUS status;

    RpcTryExcept
    {

        //
        // Try RPC (local or remote) version of API.
        //
        status = R_InetInfoClearStatistics(
                     pszServer,
                     dwServerMask
                     );
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        status = RpcExceptionCode();
    }
    RpcEndExcept

    return (status);
} // InetInfoClearStatistics()




NET_API_STATUS
NET_API_FUNCTION
InetInfoFlushMemoryCache(
    IN  LPWSTR pszServer OPTIONAL,
    IN  DWORD  dwServerMask
    )
{
    NET_API_STATUS status;

    RpcTryExcept
    {

        //
        // Try RPC (local or remote) version of API.
        //
        status = R_InetInfoFlushMemoryCache(
                     pszServer,
                     dwServerMask
                     );
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        status = RpcExceptionCode();
    }
    RpcEndExcept

    return (status);
} // InetInfoFlushMemoryCache()


NET_API_STATUS
NET_API_FUNCTION
InetInfoGetGlobalAdminInformation(
    IN  LPWSTR                       Server OPTIONAL,
    IN  DWORD                        dwReserved,
    OUT LPINET_INFO_GLOBAL_CONFIG_INFO * ppConfig
    )
{
    NET_API_STATUS status;

    RpcTryExcept
    {
        status = R_InetInfoGetGlobalAdminInformation(
                     Server,
                     dwReserved,
                     ppConfig
                     );
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        status = RpcExceptionCode();
    }
    RpcEndExcept

    return status;
} // InetInfoGetGlobalAdminInformation()



NET_API_STATUS
NET_API_FUNCTION
InetInfoGetSites(
    IN  LPWSTR                pszServer OPTIONAL,
    IN  DWORD                 dwServerMask,
    OUT LPINET_INFO_SITE_LIST * ppSites
    )
{
    NET_API_STATUS status;

    RpcTryExcept
    {
        status = R_InetInfoGetSites(
                     pszServer,
                     dwServerMask,
                     ppSites
                     );
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        status = RpcExceptionCode();
    }
    RpcEndExcept

    return status;
} // InetInfoGetSites()


NET_API_STATUS
NET_API_FUNCTION
InetInfoSetGlobalAdminInformation(
    IN  LPWSTR                     Server OPTIONAL,
    IN  DWORD                      dwReserved,
    IN  INET_INFO_GLOBAL_CONFIG_INFO * pConfig
    )
{
    NET_API_STATUS status;

    RpcTryExcept
    {
        status = R_InetInfoSetGlobalAdminInformation(
                     Server,
                     dwReserved,
                     pConfig
                     );
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        status = RpcExceptionCode();
    }
    RpcEndExcept

    return status;
} // InetInfoSetGlobalAdminInformation()



NET_API_STATUS
NET_API_FUNCTION
InetInfoGetAdminInformation(
    IN  LPWSTR                Server OPTIONAL,
    IN  DWORD                 dwServerMask,
    OUT LPINET_INFO_CONFIG_INFO * ppConfig
    )
{
    NET_API_STATUS             status;
    BOOL                       fGetPassword = TRUE;
    LPWSTR                     pSecret;
    DWORD                      i = 0;
    DWORD                      j;
    LPWSTR                     pszCurrent;
    INET_INFO_VIRTUAL_ROOT_ENTRY * pVirtRoot;

    RpcTryExcept
    {
        status = R_InetInfoGetAdminInformation(
                     Server,
                     dwServerMask,
                     ppConfig
                     );
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        status = RpcExceptionCode();
    }
    RpcEndExcept

    if ( status )
        return status;

#ifndef CHICAGO

    //
    //  Get the anonymous account password
    //

    while ( aSrvSecrets[i].dwID &&
            !(aSrvSecrets[i].dwID & dwServerMask ) )
    {
        i++;
    }

    // Note: Only the service corresponding to first mask is chosen.

    if ( !aSrvSecrets[i].dwID )
        return ERROR_INVALID_PARAMETER;

    status = GetSecret( Server,
                        aSrvSecrets[i].SecretName,
                        &pSecret );

    if ( status )
        return status;

    memcpy( (*ppConfig)->szAnonPassword,
            pSecret,
            sizeof(WCHAR) * min( wcslen( pSecret ), PWLEN ));

    (*ppConfig)->szAnonPassword[PWLEN] = L'\0';

    LocalFree( pSecret );

    //
    //  Zero terminate all of the passwords in case there is no associated
    //  secret
    //

    for ( j = 0; j < (*ppConfig)->VirtualRoots->cEntries; j++ )
    {
        *(*ppConfig)->VirtualRoots->aVirtRootEntry[j].AccountPassword = L'\0';
    }

    status = GetSecret( Server,
                        aSrvSecrets[i].RootSecretName,
                        &pSecret );

    if ( status )
        return status;

    pszCurrent = pSecret;

    while ( *pszCurrent )
    {
        LPWSTR pszRoot;
        LPWSTR pszPassword;
        LPWSTR pszAddress;
        LPWSTR pszNextLine = pszCurrent + wcslen(pszCurrent) + 1;


        //
        //  The list is in the form:
        //
        //     <Root>,<Addresss>=<Password>\0
        //     <Root>,<Addresss>=<Password>\0
        //     \0
        //

        pszRoot = pszCurrent;

        pszPassword = wcschr( pszCurrent, L'=' );

        if ( !pszPassword )
        {
            //
            //  Bad list format, skip this one
            //

            goto NextLine;
        }

        *pszPassword = L'\0';
        pszPassword++;

        pszAddress = wcschr( pszRoot, L',');

        if ( !pszAddress )
        {
            goto NextLine;

        }

        *pszAddress = L'\0';
        pszAddress++;

        //
        //  Now look for this root and address in the virtual root list
        //  so we can set the password
        //

        for ( i = 0; i < (*ppConfig)->VirtualRoots->cEntries; i++ )
        {
            pVirtRoot = &(*ppConfig)->VirtualRoots->aVirtRootEntry[i];

            if ( !_wcsicmp( pszRoot, pVirtRoot->pszRoot ) &&
                 (!pszAddress || !_wcsicmp( pszAddress, pVirtRoot->pszAddress)))
            {
                //
                //  If the password length is invalid, we just ignore it.
                //  This shouldn't happen because we check before setting the
                //  password
                //

                if ( wcslen( pszPassword ) <= PWLEN )
                {
                    wcscpy( pVirtRoot->AccountPassword,
                            pszPassword );
                    break;
                }
            }
        }

NextLine:

        pszCurrent = pszNextLine;
    }

    LocalFree( pSecret );
#else // CHICAGO
    //
    //  Zero terminate all of the passwords in case there is no associated
    //  secret
    //

    for ( j = 0; j < (*ppConfig)->VirtualRoots->cEntries; j++ )
    {
        *(*ppConfig)->VirtualRoots->aVirtRootEntry[j].AccountPassword = L'\0';
    }
#endif // CHICAGO
    return status;
} // InetInfoGetAdminInformation()



NET_API_STATUS
NET_API_FUNCTION
InetInfoSetAdminInformation(
    IN  LPWSTR              Server OPTIONAL,
    IN  DWORD               dwServerMask,
    IN  INET_INFO_CONFIG_INFO * pConfig
    )
{
    NET_API_STATUS status;
    WCHAR          szAnonPassword[PWLEN+1];
    LPWSTR         pszRootPasswords = NULL;
    LPWSTR         pszPassword;
    DWORD          i, j;

#ifndef CHICAGO

    //
    //  Enumerate the LSA secret names for the specified servers.  We set the
    //  secrets first so the anonymous user name password can be refreshed
    //  in the server side InetInfoSetAdminInformation
    //

    i = 0;
    while ( aSrvSecrets[i].dwID )
    {
        if ( !(aSrvSecrets[i].dwID & dwServerMask ))
        {
            i++;
            continue;
        }

        if ( IsFieldSet( pConfig->FieldControl, FC_INET_INFO_ANON_PASSWORD ))
        {
            status = SetSecret( Server,
                                aSrvSecrets[i].SecretName,
                                pConfig->szAnonPassword,
                                (wcslen( pConfig->szAnonPassword ) + 1)
                                    * sizeof(WCHAR));

            if ( status )
                return status;
        }

        if ( IsFieldSet( pConfig->FieldControl, FC_INET_INFO_VIRTUAL_ROOTS ))
        {
            DWORD                      cbNeeded = sizeof(WCHAR);
            INET_INFO_VIRTUAL_ROOT_ENTRY * pVirtRoot;
            LPWSTR                     psz;
            LPWSTR                     pszSecret;

            //
            //  Build a string that looks like:
            //
            //     <Root>,<Addresss>=<Password>\0
            //     <Root>,<Addresss>=<Password>\0
            //     \0
            //

            //
            //  Do a first pass to figure the buffer size we need to build
            //

            for ( j = 0; j < pConfig->VirtualRoots->cEntries; j++ )
            {
                pVirtRoot = &pConfig->VirtualRoots->aVirtRootEntry[j];

                cbNeeded += (wcslen( pVirtRoot->pszRoot ) +
                             wcslen( EMPTY_IF_NULL(pVirtRoot->pszAddress)) +
                             wcslen( pVirtRoot->AccountPassword ) +
                             (PWLEN + 3)) * sizeof(WCHAR);
            }

            //
            //  We always allocate at least enough room for a '\0'
            //

            pszSecret = LocalAlloc( LPTR, cbNeeded + sizeof(WCHAR) );

            if ( !pszSecret )
                return ERROR_NOT_ENOUGH_MEMORY;

            psz = pszSecret;

            //
            //  Now build the string
            //

            for ( j = 0; j < pConfig->VirtualRoots->cEntries; j++ )
            {
                pVirtRoot = &pConfig->VirtualRoots->aVirtRootEntry[j];

                psz += wsprintfW( psz,
                                  L"%ls,%ls=%ls",
                                  pVirtRoot->pszRoot,
                                  EMPTY_IF_NULL(pVirtRoot->pszAddress),
                                  pVirtRoot->AccountPassword );
                psz++;
            }

            //
            //  Add the list terminating NULL
            //

            *psz = L'\0';

            status = SetSecret( Server,
                                aSrvSecrets[i].RootSecretName,
                                pszSecret,
                                cbNeeded );

            LocalFree( pszSecret );

            if ( status )
                return status;
        }

        i++;
    }
#endif // CHICAGO

    //
    //  Set the passwords to NULL so it doesn't go out on the
    //  wire.  We set them as a secrets above
    //

    if ( IsFieldSet( pConfig->FieldControl, FC_INET_INFO_VIRTUAL_ROOTS ))
    {
        pszRootPasswords = LocalAlloc( LPTR,
                                       pConfig->VirtualRoots->cEntries *
                                       (PWLEN + 1) * sizeof(WCHAR) );

        if ( !pszRootPasswords )
            return ERROR_NOT_ENOUGH_MEMORY;

        for ( i = 0; i < pConfig->VirtualRoots->cEntries; i++ )
        {
            pszPassword = pConfig->VirtualRoots->aVirtRootEntry[i].AccountPassword;

            if ( wcslen( pszPassword ) > PWLEN )
            {
                LocalFree( pszRootPasswords );
                return ERROR_INVALID_PARAMETER;
            }

            wcscpy( pszRootPasswords + i * (PWLEN + 1),
                    pszPassword );

            SecureZeroMemory( pszPassword,
                              sizeof( pConfig->VirtualRoots->aVirtRootEntry[i].AccountPassword ));
        }
    }

    if ( IsFieldSet( pConfig->FieldControl, FC_INET_INFO_ANON_PASSWORD ))
    {
        memcpy( szAnonPassword,
                pConfig->szAnonPassword,
                sizeof(pConfig->szAnonPassword) );

        SecureZeroMemory( pConfig->szAnonPassword,
                          sizeof(pConfig->szAnonPassword) );
    }

    RpcTryExcept
    {
        status = R_InetInfoSetAdminInformation(
                     Server,
                     dwServerMask,
                     pConfig
                     );
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        status = RpcExceptionCode();
    }
    RpcEndExcept

    //
    //  Restore the structure we just mucked with
    //

    if ( IsFieldSet( pConfig->FieldControl, FC_INET_INFO_ANON_PASSWORD ))
    {
        memcpy( pConfig->szAnonPassword,
                szAnonPassword,
                sizeof(pConfig->szAnonPassword) );

        SecureZeroMemory( szAnonPassword, sizeof( szAnonPassword ));
    }

    if ( IsFieldSet( pConfig->FieldControl, FC_INET_INFO_VIRTUAL_ROOTS ))
    {
        for ( i = 0; i < pConfig->VirtualRoots->cEntries; i++ )
        {
            pszPassword = pConfig->VirtualRoots->aVirtRootEntry[i].AccountPassword;

            wcscpy( pszPassword,
                    pszRootPasswords + i * (PWLEN + 1) );
        }

        SecureZeroMemory( pszRootPasswords,
                          pConfig->VirtualRoots->cEntries * (PWLEN + 1) * sizeof(WCHAR));

        LocalFree( pszRootPasswords );

        pszRootPasswords = NULL;
    }

    return status;
} // InetInfoSetAdminInformation()


NET_API_STATUS
NET_API_FUNCTION
IISEnumerateUsers(
    IN  LPWSTR                Server OPTIONAL,
    IN  DWORD                 dwLevel,
    IN  DWORD                 dwServiceId,
    IN  DWORD                 dwInstance,
    OUT PDWORD                nRead,
    OUT LPBYTE                *pBuffer
    )
{
    NET_API_STATUS status;
    GENERIC_INFO_CONTAINER genInfo;
    GENERIC_ENUM_STRUCT genStruct;

    genInfo.Buffer = NULL;
    genInfo.EntriesRead = 0;

    genStruct.Container = &genInfo;
    genStruct.Level = dwLevel;

    RpcTryExcept
    {
        status = R_IISEnumerateUsers(
                     Server,
                     dwServiceId,
                     dwInstance,
                     (LPIIS_USER_ENUM_STRUCT)&genStruct
                     );

        if ( genInfo.Buffer != NULL ) {
            *pBuffer = (LPBYTE)genInfo.Buffer;
            *nRead = genInfo.EntriesRead;

        } else {
            *pBuffer = NULL;
            *nRead = 0;
        }
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        status = RpcExceptionCode();
    }
    RpcEndExcept

    return status;

} // IISEnumerateUsers




NET_API_STATUS
NET_API_FUNCTION
IISDisconnectUser(
    IN LPWSTR                   Server OPTIONAL,
    IN DWORD                    dwServiceId,
    IN DWORD                    dwInstance,
    IN DWORD                    dwIdUser
    )
{
    NET_API_STATUS status;

    RpcTryExcept
    {
        status = R_IISDisconnectUser(
                     Server,
                     dwServiceId,
                     dwInstance,
                     dwIdUser
                     );

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        status = RpcExceptionCode();
    }
    RpcEndExcept

    return status;

} // IISDisconnectUser



NET_API_STATUS
NET_API_FUNCTION
InitW3CounterStructure(
    IN LPWSTR  Server OPTIONAL,
    OUT LPDWORD lpcbTotalRequired
        )
{
    NET_API_STATUS             status;

    RpcTryExcept
    {
        status = R_InitW3CounterStructure(Server, lpcbTotalRequired);

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        status = RpcExceptionCode();
    }
    RpcEndExcept

    return status;
} //InitW3CounterStructure


NET_API_STATUS
NET_API_FUNCTION
CollectW3PerfData(
    IN LPWSTR        Server OPTIONAL,
        IN LPWSTR        lpValueName,
    OUT LPBYTE       lppData,
    IN OUT LPDWORD   lpcbTotalBytes,
    OUT LPDWORD      lpNumObjectTypes
        )
{
    NET_API_STATUS             status;

    RpcTryExcept
    {
        status = R_CollectW3PerfData(
                                         Server,
                     lpValueName,
                     lppData,
                     lpcbTotalBytes,
                     lpNumObjectTypes
                     );

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        status = RpcExceptionCode();
    }
    RpcEndExcept

    return status;
} //CollectW3PerfData


NET_API_STATUS
NET_API_FUNCTION
W3QueryStatistics2(
    IN  LPWSTR                Server OPTIONAL,
    IN  DWORD                 dwLevel,
    IN  DWORD                 dwInstance,
    IN  DWORD                 dwReserved,
    OUT LPBYTE                * pBuffer
    )
{
    NET_API_STATUS             status;

    *pBuffer = NULL;
    RpcTryExcept
    {
        status = R_W3QueryStatistics2(
                     Server,
                     dwLevel,
                     dwInstance,
                     dwReserved,
                     (LPW3_STATISTICS_STRUCT)pBuffer
                     );

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        status = RpcExceptionCode();
    }
    RpcEndExcept

    return status;
} // W3QueryStatistics2


NET_API_STATUS
NET_API_FUNCTION
W3ClearStatistics2(
    IN  LPWSTR                Server OPTIONAL,
    IN  DWORD                 dwInstance
    )
{
    NET_API_STATUS             status;

    RpcTryExcept
    {
        status = R_W3ClearStatistics2(
                     Server,
                     dwInstance
                     );

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        status = RpcExceptionCode();
    }
    RpcEndExcept

    return status;

} // W3ClearStatistics2


NET_API_STATUS
NET_API_FUNCTION
FtpQueryStatistics2(
    IN  LPWSTR                Server OPTIONAL,
    IN  DWORD                 dwLevel,
    IN  DWORD                 dwInstance,
    IN  DWORD                 dwReserved,
    OUT LPBYTE                * pBuffer
    )
{
    NET_API_STATUS             status;

    *pBuffer = NULL;
    RpcTryExcept
    {
        status = R_FtpQueryStatistics2(
                     Server,
                     dwLevel,
                     dwInstance,
                     dwReserved,
                     (LPFTP_STATISTICS_STRUCT)pBuffer
                     );

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        status = RpcExceptionCode();
    }
    RpcEndExcept

    return status;
} // FtpQueryStatistics2


NET_API_STATUS
NET_API_FUNCTION
FtpClearStatistics2(
    IN  LPWSTR                Server OPTIONAL,
    IN  DWORD                 dwInstance
    )
{
    NET_API_STATUS             status;

    RpcTryExcept
    {
        status = R_FtpClearStatistics2(
                     Server,
                     dwInstance
                     );

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        status = RpcExceptionCode();
    }
    RpcEndExcept

    return status;

} // FtpClearStatistics2


#ifndef CHICAGO

DWORD
GetSecret(
    IN  LPWSTR       Server,
    IN  LPWSTR       SecretName,
    OUT LPWSTR *     ppSecret
    )
/*++

   Description

     Gets the specified LSA secret

   Arguments:

     Server - Server name (or NULL) secret lives on
     SecretName - Name of the LSA secret
     ppSecret - Receives an allocated block of memory containing the secret.
        Must be freed with LocalFree.

   Note:

--*/
{
    LSA_HANDLE        hPolicy;
    UNICODE_STRING *  punicodePassword;
    UNICODE_STRING    unicodeServer;
    NTSTATUS          ntStatus;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING    unicodeSecret;


    InitUnicodeString( &unicodeServer,
                       Server );

    //
    //  Open a policy to the remote LSA
    //

    InitializeObjectAttributes( &ObjectAttributes,
                                NULL,
                                0L,
                                NULL,
                                NULL );

    ntStatus = LsaOpenPolicy( &unicodeServer,
                              &ObjectAttributes,
                              POLICY_ALL_ACCESS,
                              &hPolicy );

    if ( !NT_SUCCESS( ntStatus ) )
        return LsaNtStatusToWinError( ntStatus );

    InitUnicodeString( &unicodeSecret,
                       SecretName );


    //
    //  Query the secret value
    //

    ntStatus = LsaRetrievePrivateData( hPolicy,
                                       &unicodeSecret,
                                       &punicodePassword );

    LsaClose( hPolicy );

    if ( !NT_SUCCESS( ntStatus ))
        return LsaNtStatusToWinError( ntStatus );

    *ppSecret = LocalAlloc( LPTR, punicodePassword->Length + sizeof(WCHAR) );

    if ( !*ppSecret )
    {
        RtlZeroMemory( punicodePassword->Buffer,
                       punicodePassword->MaximumLength );

        LsaFreeMemory( (PVOID) punicodePassword );
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    //  Copy it into the buffer, Length is count of bytes
    //

    memcpy( *ppSecret,
            punicodePassword->Buffer,
            punicodePassword->Length );

    (*ppSecret)[punicodePassword->Length/sizeof(WCHAR)] = L'\0';

    RtlZeroMemory( punicodePassword->Buffer,
                   punicodePassword->MaximumLength );

    LsaFreeMemory( (PVOID) punicodePassword );

    return NO_ERROR;
} // GetSecret()


DWORD
SetSecret(
    IN  LPWSTR       Server,
    IN  LPWSTR       SecretName,
    IN  LPWSTR       pSecret,
    IN  DWORD        cbSecret
    )
/*++

   Description

     Sets the specified LSA secret

   Arguments:

     Server - Server name (or NULL) secret lives on
     SecretName - Name of the LSA secret
     pSecret - Pointer to secret memory
     cbSecret - Size of pSecret memory block

   Note:

--*/
{
    LSA_HANDLE        hPolicy;
    UNICODE_STRING    unicodePassword;
    UNICODE_STRING    unicodeServer;
    NTSTATUS          ntStatus;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING    unicodeSecret;


    InitUnicodeString( &unicodeServer,
                       Server );

    //
    //  Initialize the unicode string by hand so we can handle '\0' in the
    //  string
    //

    unicodePassword.Buffer        = pSecret;
    unicodePassword.Length        = (USHORT) cbSecret;
    unicodePassword.MaximumLength = (USHORT) cbSecret;

    //
    //  Open a policy to the remote LSA
    //

    InitializeObjectAttributes( &ObjectAttributes,
                                NULL,
                                0L,
                                NULL,
                                NULL );

    ntStatus = LsaOpenPolicy( &unicodeServer,
                              &ObjectAttributes,
                              POLICY_ALL_ACCESS,
                              &hPolicy );

    if ( !NT_SUCCESS( ntStatus ) )
        return LsaNtStatusToWinError( ntStatus );

    //
    //  Create or open the LSA secret
    //

    InitUnicodeString( &unicodeSecret,
                       SecretName );

    ntStatus = LsaStorePrivateData( hPolicy,
                                    &unicodeSecret,
                                    &unicodePassword );

    LsaClose( hPolicy );

    if ( !NT_SUCCESS( ntStatus ))
    {
        return LsaNtStatusToWinError( ntStatus );
    }

    return NO_ERROR;
} // SetSecret()


#else // CHICAGO



DWORD
GetSecret(
    IN  LPWSTR       Server,
    IN  LPWSTR       SecretName,
    OUT LPWSTR *     ppSecret
    )
{
    return(NO_ERROR);
}

DWORD
SetSecret(
    IN  LPWSTR       Server,
    IN  LPWSTR       SecretName,
    IN  LPWSTR       pSecret,
    IN  DWORD        cbSecret
    )
{
    return(NO_ERROR);
}
#endif // CHICAGO


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\info\client\infotest.cxx ===
/*++

   Copyright    (c)    1994    Microsoft Corporation

   Module  Name :
        infotest.cxx

   Abstract:
        main program to test the working of RPC APIs for Internet Services

   Author:

           Murali R. Krishnan    ( MuraliK )     23-Jan-1996

   Project:

           Internet Services Common RPC Client.

   Functions Exported:

   Revision History:

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

# include <windows.h>
# include <lm.h>
# include <stdio.h>
# include <stdlib.h>
# include "inetinfo.h"
# include "apiutil.h"

//
//  size of half dword in bits
//
# define HALF_DWORD_SIZE    ( sizeof(DWORD) * 8 / 2)

//
//  To Avoid overflows I multiply using two parts
//
# define LargeIntegerToDouble( li)      \
        ( ( 1 << HALF_DWORD_SIZE) * \
           (( double) (li).HighPart) * ( 1 << HALF_DWORD_SIZE) + \
          ((li).LowPart) \
        )


static LPWSTR g_lpszServerAddress = NULL;

//
// Prototypes of Functions
//

BOOL GenUsageMessage( int argc, char * argv[]);

BOOL TestGetStatistics( int argc, char * argv[]);

BOOL TestInetGetAdminInfo( int argc, char * argv[]);

BOOL TestInetSetAdminInfo( int argc, char * argv[]);




//
//  The following DefineAllCommands() defines a template for all commands.
//  Format: CmdCodeName     CommandName         Function Pointer   Comments
//
//  To add addditional test commands, add just another line to the
//      given list
//  Dont touch any macros below, they are all automatically generated.
//  Always the first entry should be usage function.
//

#define  DefineAllCommands()    \
 Cmd( CmdUsage,             "usage",                GenUsageMessage,    \
        " Commands Available" )                                         \
 Cmd( CmdGetStatistics,     "getstatistics",        TestGetStatistics,  \
        " Get Common Statistics" )                                      \
 Cmd( CmdInetGetAdminInfo,  "igetadmininfo",        TestInetGetAdminInfo, \
        " Get common Internet Administrative Information" )    \
 Cmd( CmdInetSetAdminInfo,  "isetadmininfo",        TestInetSetAdminInfo, \
        " Set common Internet Administrative Information" )    \
 Cmd( CmdGet1Statistics,     "stats",                TestGetStatistics,  \
        " Get Common Statistics" )                                      \
 Cmd( CmdDebugFlags,        "debug",                NULL,               \
        " isetadmininfo: Set Debugging flags for the server" )          \
 Cmd( CmdPortNumber,        "port",                 NULL,               \
        " isetadmininfo: Set the port number for server")               \
 Cmd( CmdMaxConnections,    "maxconn",              NULL,               \
        " isetadmininfo: Set the max connections allowed in server")    \
 Cmd( CmdConnectionTimeout, "timeout",              NULL,               \
        " isetadmininfo: Set the Connection Timeout interval( in seconds)") \
 Cmd( CmdLogAnonymous,      "loganon",              NULL,               \
        " isetadmininfo: Set the LogAnonymous Flag")                    \
 Cmd( CmdLogNonAnonymous,   "lognonanon",           NULL,               \
        " isetadmininfo: Set the LogNonAnonymous Flag")                 \
 Cmd( CmdAnonUserName,      "anonuser",             NULL,               \
        " isetadmininfo: Set the Anonymous User Name ")                 \
 Cmd( CmdAdminName,         "adminname",            NULL,               \
        " isetadmininfo: Set the Administrator name ")                  \
 Cmd( CmdAdminEmail,        "adminemail",           NULL,               \
        " isetadmininfo: Set the Administrator Email ")                 \
 Cmd( CmdServerComment,     "servercomment",        NULL,               \
        " isetadmininfo: Set the Server Comments for server ")          \


// Define command codes

# define Cmd( CmdCode, CmdName, CmdFunc, CmdComments)       CmdCode,

typedef enum  _CmdCodes {
    DefineAllCommands()
    maxCmdCode
} CmdCodes;

#undef Cmd

// Define the functions and array of mappings

// General command function type
typedef BOOL ( * CMDFUNC)( int argc, char * argv[]);

typedef  struct _CmdStruct {
    CmdCodes    cmdCode;
    char *      pszCmdName;
    CMDFUNC     cmdFunc;
    char *      pszCmdComments;
} CmdStruct;


// Define Prototypes of command functions
# define Cmd( CmdCode, CmdName, CmdFunc, CmdComments)    \
    BOOL CmdFunc(int argc, char * argv[]);

// Cause an expansion to generate prototypes
// DefineAllCommands()
// Automatic generation causes a problem when we have NULL in Function ptrs :(
// Let the user explicitly define the prototypes

#undef Cmd

//
// Define the global array of commands
//

# define Cmd( CmdCode, CmdName, CmdFunc, CmdComments)        \
    { CmdCode, CmdName, CmdFunc, CmdComments},

static CmdStruct   g_cmds[] = {

    DefineAllCommands()
    { maxCmdCode, NULL, NULL}       // sentinel command
};

#undef Cmd



/************************************************************
 *    Functions
 ************************************************************/

BOOL
GenUsageMessage( int argc, char * argv[])
{
    CmdStruct * pCmd;

    printf( " Usage:\n %s <server-name/address> <cmd name> <cmd arguments>\n",
            argv[0]);
    for( pCmd = g_cmds; pCmd != NULL && pCmd->cmdCode != maxCmdCode; pCmd++) {
        printf( "\t%s\t%s\n", pCmd->pszCmdName, pCmd->pszCmdComments);
    }

    return ( TRUE);
} // GenUsageMessage()



static
CmdStruct * DecodeCommand( char * pszCmd)
{
    CmdStruct * pCmd;
    if ( pszCmd != NULL) {

        for( pCmd = g_cmds;
             pCmd != NULL && pCmd->cmdCode != maxCmdCode; pCmd++) {

            if ( lstrcmpiA( pszCmd, pCmd->pszCmdName) == 0) {
                 return ( pCmd);
            }
        } // for
    }

    return ( &g_cmds[0]);      // No match found, return usage message
} // DecodeCommand()



static
LPWSTR
ConvertToUnicode( char * psz)
/*++
    Converts a given string into unicode string (after allocating buffer space)
    Returns NULL on failure. Use GetLastError() for details.
--*/
{
    LPWSTR  pszUnicode;
    int     cch;

    cch = strlen( psz) + 1;
    pszUnicode = ( LPWSTR ) malloc( cch * sizeof( WCHAR));

    if ( pszUnicode != NULL) {

       // Success. Copy the string now
       int iRet;

       iRet = MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED,
                                   psz,    cch,
                                   pszUnicode,  cch);

       if ( iRet == 0 || iRet != cch) {

            free( pszUnicode);      // failure so free the block
            pszUnicode = NULL;
       }
    } else {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY);
    }

    return ( pszUnicode);
} // ConvertToUnicode()


static
VOID
PrintStatisticsInfo( IN LPINET_INFO_STATISTICS_0  pStat)
{
    double gCacheHit = 0;

    if ( pStat == NULL) {

        return ;
    }

    printf( " Printing Statistics Information: \n");
    printf( "%20s = %ld\n", "Cache Bytes Total",
           pStat->CacheCtrs.CacheBytesTotal);
    printf( "%20s = %ld\n", "Cache Bytes In Use",
           pStat->CacheCtrs.CacheBytesInUse);
    printf( "%20s = %ld\n", "Open File Handles ",
           pStat->CacheCtrs.CurrentOpenFileHandles);
    printf( "%20s = %ld\n", "Current Dir Lists",
           pStat->CacheCtrs.CurrentDirLists);
    printf( "%20s = %ld\n", "Current Objects ",
           pStat->CacheCtrs.CurrentObjects);
    printf( "%20s = %ld\n", "Cache Flushes",
           pStat->CacheCtrs.FlushesFromDirChanges);
    printf( "%20s = %ld\n", "Cache Hits",
           pStat->CacheCtrs.CacheHits);
    printf( "%20s = %ld\n", "Cache Misses",
           pStat->CacheCtrs.CacheMisses);
    gCacheHit = (((float) pStat->CacheCtrs.CacheHits * 100) /
                 (pStat->CacheCtrs.CacheHits + pStat->CacheCtrs.CacheMisses));
    printf( "%20s = %6.4g\n", " Cache Hit Ratio",
           gCacheHit);

    printf( "%20s = %ld\n", "Atq Allowed Requests",
           pStat->AtqCtrs.TotalAllowedRequests);
    printf( "%20s = %ld\n", "Atq Blocked Requests",
           pStat->AtqCtrs.TotalBlockedRequests);
    printf( "%20s = %ld\n", "Atq Current Blocked Requests",
           pStat->AtqCtrs.CurrentBlockedRequests);
    printf( "%20s = %ld Bytes/sec\n", "Atq Measured Bandwidth",
           pStat->AtqCtrs.MeasuredBandwidth);



#ifndef NO_AUX_PERF

    printf( " Auxiliary Counters # = %u\n",
           pStat->nAuxCounters);

    for ( DWORD i = 0; i < pStat->nAuxCounters; i++) {

        printf( "Aux Counter[%u] = %u\n", i, pStat->rgCounters[i]);

    } //for

#endif // NO_AUX_PERF

    return;

} // PrintStatisticsInfo()



static
VOID
PrintStatsForTime( IN INET_INFO_STATISTICS_0 *    pStatStart,
                  IN INET_INFO_STATISTICS_0 *    pStatEnd,
                  IN DWORD sInterval)
/*++
  Print the statistics information over a time interval sInterval seconds.
  Arguments:
    pStatStart  pointer to statistics information for starting sample
    pStatEnd    pointer to statistics information for ending sample
    sInterval   Time interval in seconds for the sample

  Returns:
     None

--*/
{
    DWORD dwDiff;

    if ( pStatStart == NULL || pStatEnd == NULL || sInterval == 0 ) {

        return ;
    }

    printf( "Statistics  for Interval = %u seconds\n", sInterval);
    printf( "%20s\t %10s\t%10s\t%10s\t%6s\n\n",
           "Item   ", "Start Sample", "End Sample", "Difference", "Rate/s");

    dwDiff = (pStatEnd->CacheCtrs.CacheBytesTotal -
              pStatStart->CacheCtrs.CacheBytesTotal);
    printf( "%20s\t %10.3g\t %10ld\t %10ld\t%6ld\n",
           "Cache Bytes Total",
           (pStatStart->CacheCtrs.CacheBytesTotal),
           (pStatEnd->CacheCtrs.CacheBytesTotal),
           dwDiff,
           dwDiff/sInterval
           );

    dwDiff = (pStatEnd->CacheCtrs.CacheBytesInUse -
              pStatStart->CacheCtrs.CacheBytesInUse);
    printf( "%20s\t %10.3g\t %10ld\t %10ld\t%6ld\n",
           "Cache Bytes In Use",
           (pStatStart->CacheCtrs.CacheBytesInUse),
           (pStatEnd->CacheCtrs.CacheBytesInUse),
           dwDiff,
           dwDiff/sInterval
           );

    dwDiff = (pStatEnd->CacheCtrs.CurrentOpenFileHandles -
              pStatStart->CacheCtrs.CurrentOpenFileHandles);
    printf( "%20s\t %10ld\t %10ld\t %10ld\t%6ld\n",
           "File Handle Cached ",
           (pStatStart->CacheCtrs.CurrentOpenFileHandles),
           (pStatEnd->CacheCtrs.CurrentOpenFileHandles),
           dwDiff,
           dwDiff/sInterval
           );

    dwDiff = (pStatEnd->CacheCtrs.CurrentDirLists -
              pStatStart->CacheCtrs.CurrentDirLists);
    printf( "%20s\t %10ld\t %10ld\t %10ld\t%6ld\n",
           "Current Dir Lists ",
           (pStatStart->CacheCtrs.CurrentDirLists),
           (pStatEnd->CacheCtrs.CurrentDirLists),
           dwDiff,
           dwDiff/sInterval
           );

    dwDiff = (pStatEnd->CacheCtrs.CurrentObjects -
              pStatStart->CacheCtrs.CurrentObjects);
    printf( "%20s\t %10ld\t %10ld\t %10ld\t%6ld\n",
           "Current Objects Cached",
           (pStatStart->CacheCtrs.CurrentObjects),
           (pStatEnd->CacheCtrs.CurrentObjects),
           dwDiff,
           dwDiff/sInterval
           );

    dwDiff = (pStatEnd->CacheCtrs.FlushesFromDirChanges -
              pStatStart->CacheCtrs.FlushesFromDirChanges);
    printf( "%20s\t %10ld\t %10ld\t %10ld\t%6ld\n",
           "Cache Flushes",
           (pStatStart->CacheCtrs.FlushesFromDirChanges),
           (pStatEnd->CacheCtrs.FlushesFromDirChanges),
           dwDiff,
           dwDiff/sInterval
           );

    dwDiff = (pStatEnd->CacheCtrs.CacheHits -
              pStatStart->CacheCtrs.CacheHits);
    printf( "%20s\t %10ld\t %10ld\t %10ld\t%6ld\n",
           "Cache Hits",
           (pStatStart->CacheCtrs.CacheHits),
           (pStatEnd->CacheCtrs.CacheHits),
           dwDiff,
           dwDiff/sInterval
           );

    dwDiff = (pStatEnd->CacheCtrs.CacheMisses -
              pStatStart->CacheCtrs.CacheMisses);
    printf( "%20s\t %10ld\t %10ld\t %10ld\t%6ld\n",
           "Cache Misses",
           (pStatStart->CacheCtrs.CacheMisses),
           (pStatEnd->CacheCtrs.CacheMisses),
           dwDiff,
           dwDiff/sInterval
           );

    dwDiff = (pStatEnd->AtqCtrs.TotalAllowedRequests -
              pStatStart->AtqCtrs.TotalAllowedRequests);
    printf( "%20s\t %10ld\t %10ld\t %10ld\t%6ld\n",
           "Total Atq Allowed Requests",
           (pStatStart->AtqCtrs.TotalAllowedRequests),
           (pStatEnd->AtqCtrs.TotalAllowedRequests),
           dwDiff,
           dwDiff/sInterval
           );

    dwDiff = (pStatEnd->AtqCtrs.TotalBlockedRequests -
              pStatStart->AtqCtrs.TotalBlockedRequests);
    printf( "%20s\t %10ld\t %10ld\t %10ld\t%6ld\n",
           "Total Atq Blocked Requests",
           (pStatStart->AtqCtrs.TotalBlockedRequests),
           (pStatEnd->AtqCtrs.TotalBlockedRequests),
           dwDiff,
           dwDiff/sInterval
           );

    dwDiff = (pStatEnd->AtqCtrs.TotalRejectedRequests -
              pStatStart->AtqCtrs.TotalRejectedRequests);
    printf( "%20s\t %10ld\t %10ld\t %10ld\t%6ld\n",
           "Total Atq Rejected Requests",
           (pStatStart->AtqCtrs.TotalRejectedRequests),
           (pStatEnd->AtqCtrs.TotalRejectedRequests),
           dwDiff,
           dwDiff/sInterval
           );

    dwDiff = (pStatEnd->AtqCtrs.CurrentBlockedRequests -
              pStatStart->AtqCtrs.CurrentBlockedRequests);
    printf( "%20s\t %10ld\t %10ld\t %10ld\t%6ld\n",
           "Current Atq Blocked Requests",
           (pStatStart->AtqCtrs.CurrentBlockedRequests),
           (pStatEnd->AtqCtrs.CurrentBlockedRequests),
           dwDiff,
           dwDiff/sInterval
           );


    dwDiff = (pStatEnd->AtqCtrs.MeasuredBandwidth -
              pStatStart->AtqCtrs.MeasuredBandwidth);
    printf( "%20s\t %10ld\t %10ld\t %10ld\t%6ld\n",
           "Measured Bandwidth",
           (pStatStart->AtqCtrs.MeasuredBandwidth),
           (pStatEnd->AtqCtrs.MeasuredBandwidth),
           dwDiff,
           dwDiff/sInterval
           );

    return;

} // PrintStatisticsInfo()



BOOL
TestGetStatistics( int argc, char * argv[] )
/*++
   Gets common Statistics from server and prints it.
   If the optional time information is given, then this function
   obtains the statistics, sleeps for specified time interval and then
    again obtains new statistics and prints the difference, neatly formatted.

   Arguments:
      argc = count of arguments
      argv  array of strings for command
            argv[0] = stats or getstatistics
            argv[1] = time interval if specified in seconds
--*/
{
    DWORD   err;
    DWORD   timeToSleep = 0;
    INET_INFO_STATISTICS_0 *  pStat1 = NULL;

    if ( argc > 1 && argv[1] != NULL) {

        timeToSleep = atoi( argv[1]);
    }

    err = InetInfoQueryStatistics(g_lpszServerAddress,
                                  0,
                                  0,
                                  (LPBYTE *) &pStat1);

    if ( err == NO_ERROR) {

        if ( timeToSleep <= 0) {

            PrintStatisticsInfo( pStat1);
        } else {

            INET_INFO_STATISTICS_0  *  pStat2 = NULL;

            printf( "Statistics For Time Interval %u seconds\n\n",
                   timeToSleep);

            Sleep( timeToSleep * 1000);   // sleep for the interval
            err = InetInfoQueryStatistics(g_lpszServerAddress,
                                       0,
                                       0,
                                       (LPBYTE *) &pStat2);

            if ( err == NO_ERROR) {

                PrintStatsForTime( pStat1, pStat2, timeToSleep);
            }

            if ( pStat2 != NULL) {

                MIDL_user_free( pStat2);
            }
        }
    }

    if ( pStat1 != NULL) {

        MIDL_user_free( pStat1);
    }

    SetLastError( err);
    return ( err == NO_ERROR);
} // TestGetStatistics()






static VOID
PrintInetAdminInformation( IN LPINETA_CONFIG_INFO  pConfigInfo)
{
    if ( pConfigInfo == NULL)
        return;

    printf( "\n Printing InetA Config Information in %08x\n", pConfigInfo);
    printf( "%20s= %d\n", "LogAnonymous",   pConfigInfo->fLogAnonymous);
    printf( "%20s= %d\n", "LogNonAnonymous",pConfigInfo->fLogNonAnonymous);
    printf( "%20s= %08x\n", "Authentication Flags",
           pConfigInfo->dwAuthentication);

    printf( "%20s= %d\n", "Port",           pConfigInfo->sPort);
    printf( "%20s= %d\n", "Connection Timeout",
           pConfigInfo->CommonConfigInfo.dwConnectionTimeout);
    printf( "%20s= %d\n",  "Max Connections",
           pConfigInfo->CommonConfigInfo.dwMaxConnections);

    printf( "%20s= %S\n", "AnonUserName",
           pConfigInfo->lpszAnonUserName);
    printf( "%20s= %S\n", "AnonPassword",
           pConfigInfo->szAnonPassword);

    printf( "%20s= %S\n", "Admin Name",
           pConfigInfo->CommonConfigInfo.lpszAdminName);
    printf( "%20s= %S\n", "Admin Email",
           pConfigInfo->CommonConfigInfo.lpszAdminEmail);
    printf( "%20s= %S\n", "Server Comments",
           pConfigInfo->CommonConfigInfo.lpszServerComment);

    //
    // IP lists and Grant lists, Virtual Roots are not included now. Later.
    //

    return;
} // PrintInetAdminInformation()




static DWORD
GetServiceIdFromString( IN LPCSTR pszService)
{
    if ( pszService != NULL) {

        if ( !_stricmp(pszService, "HTTP")) {

            return ( INET_HTTP);
        } else if (!_stricmp( pszService, "GOPHER")) {

            return (INET_GOPHER);
        } else if ( !_stricmp( pszService, "FTP")) {

            return (INET_FTP);
        } else if ( !_stricmp( pszService, "DNS")) {

            return (INET_DNS);
        }
    }

    return ( INET_HTTP);
} // GetServiceIdFromString()



static BOOL
TestInetGetAdminInfo( int argc, char * argv[] )
/*++
   Gets the configuration information using InetInfoGetAdminInformation()
   argv[0] = igetadmininfo
   argv[1] = service name  ( gopher, http, ftp, catapult)

--*/
{
    DWORD err;
    LPINETA_CONFIG_INFO  pConfig = NULL;
    DWORD dwServiceId;

    printf( " InetInfoGetAdminInformation() called at: Time = %d\n",
            GetTickCount());

    dwServiceId = (argc > 1) ? GetServiceIdFromString( argv[1]) : INET_HTTP;

    err = InetInfoGetAdminInformation( NULL,  // g_lpszServerAddress,
                                    dwServiceId,
                                   &pConfig);

    printf( "Finished at Time = %d\n", GetTickCount());
    printf( "InetInfoGetAdminInformation returned Error Code = %d\n", err);

    if ( err == NO_ERROR) {
        PrintInetAdminInformation( pConfig);
        MIDL_user_free( ( LPVOID) pConfig);
    }


    SetLastError( err);
    return ( err == NO_ERROR);
} // TestInetGetAdminInfo()




DWORD
SetInetAdminField(
    IN LPINETA_CONFIG_INFO  pConfigIn,
    IN char * pszSubCmd,
    IN char * pszValue)
{
    DWORD err = NO_ERROR;
    CmdStruct * pCmd = DecodeCommand( pszSubCmd); // get command struct

    if ( pCmd == NULL) {
        // ignore invalid commands
        printf( " Invalid SubCommand for set admin info %s. Ignoring...\n",
                pszSubCmd);
        return ( ERROR_INVALID_PARAMETER);
    }

    switch ( pCmd->cmdCode) {

        case CmdPortNumber:
            SetField( pConfigIn->FieldControl, FC_INET_INFO_PORT_NUMBER);
            pConfigIn->sPort = atoi( pszValue);
            break;

        case CmdConnectionTimeout:
            SetField( pConfigIn->FieldControl, FC_INET_COM_CONNECTION_TIMEOUT);
            pConfigIn->CommonConfigInfo.dwConnectionTimeout = atoi( pszValue);
            break;

        case CmdMaxConnections:
            SetField( pConfigIn->FieldControl, FC_INET_COM_MAX_CONNECTIONS);
            pConfigIn->CommonConfigInfo.dwMaxConnections = atoi( pszValue);
            break;

          case CmdLogAnonymous:
            SetField( pConfigIn->FieldControl, FC_INET_INFO_LOG_ANONYMOUS);
            pConfigIn->fLogAnonymous = atoi( pszValue);
            break;

          case CmdLogNonAnonymous:
            SetField( pConfigIn->FieldControl, FC_INET_INFO_LOG_NONANONYMOUS);
            pConfigIn->fLogNonAnonymous = atoi( pszValue);
            break;

          case CmdAnonUserName:
            SetField( pConfigIn->FieldControl, FC_INET_INFO_ANON_USER_NAME);
            pConfigIn->lpszAnonUserName = ConvertToUnicode( pszValue);
            if ( pConfigIn->lpszAnonUserName == NULL) {
                err = GetLastError();
            }
            break;

          case CmdAdminName:
            SetField( pConfigIn->FieldControl, FC_INET_COM_ADMIN_NAME);
            pConfigIn->CommonConfigInfo.lpszAdminName =
              ConvertToUnicode( pszValue);
            if ( pConfigIn->CommonConfigInfo.lpszAdminName == NULL) {
                err = GetLastError();
            }
            break;

          case CmdAdminEmail:
            SetField( pConfigIn->FieldControl, FC_INET_COM_ADMIN_EMAIL);
            pConfigIn->CommonConfigInfo.lpszAdminEmail =
              ConvertToUnicode( pszValue);
            if ( pConfigIn->CommonConfigInfo.lpszAdminEmail == NULL) {
                err = GetLastError();
            }
            break;

          case CmdServerComment:
            SetField( pConfigIn->FieldControl, FC_INET_COM_SERVER_COMMENT);
            pConfigIn->CommonConfigInfo.lpszServerComment =
              ConvertToUnicode( pszValue);
            if ( pConfigIn->CommonConfigInfo.lpszServerComment == NULL) {
                err = GetLastError();
            }
            break;


        default:
            printf( " Invalid Sub command %s for SetConfigInfo(). Ignoring.\n",
                    pszSubCmd);
            err = ERROR_INVALID_PARAMETER;
            break;

    }  // switch


    return ( err);
} // SetAdminField()


static VOID
FreeBuffer( IN PVOID * ppBuffer)
{
    if ( *ppBuffer != NULL) {
        free( * ppBuffer);
        *ppBuffer = NULL;       // reset the old value
    }
    return;
} // FreeBuffer()

VOID
FreeStringsInInetConfigInfo( IN OUT LPINETA_CONFIG_INFO pConfigInfo)
{
    FreeBuffer( (PVOID *) & pConfigInfo->lpszAnonUserName);

} // FreeStringsInInetConfigInfo()



BOOL
TestInetSetAdminInfo( int argc, char * argv[])
/*++
    Arguments:
        argc = count of arguments
        argv  array of strings for command
            argv[0] = isetadmininfo
            argv[1] = sub function within set info for testing
            argv[2] = value for sub function
 for all information to be set, give <sub command name> <value>
--*/
{
    DWORD err = ERROR_CALL_NOT_IMPLEMENTED;
    LPINETA_CONFIG_INFO  * ppConfigOut = NULL;
    INETA_CONFIG_INFO  configIn;   // config values that are set

    if ( argc < 1 || ( (argc & 0x1) != 0x1 ) ) {  // argc should be > 1 and odd

        printf( "Invalid Number of arguments for %s\n", argv[0]);
        SetLastError( ERROR_INVALID_PARAMETER);
        return ( FALSE);
    }

    //
    // form the admin info block to set the information
    //
    memset( ( LPVOID) &configIn, 0, sizeof( configIn)); // init to Zeros

    // extract each field and value to set in configIn

    for( ; --argc > 1; argc -= 2) {

        if ( SetInetAdminField( &configIn, argv[argc - 1], argv[argc])
             != NO_ERROR)  {

            break;
        }

    } // for() to extract and set all fields

    if ( err != NO_ERROR) {
        // Now make RPC call to set the fields
        err = InetInfoSetAdminInformation( g_lpszServerAddress,
                                          INET_HTTP,
                                          &configIn);
    }

    // Need to free all the buffers allocated for the strings
    FreeStringsInInetConfigInfo( &configIn);

    SetLastError( err );
    return ( err == NO_ERROR );
} // TestSetInetAdminInfo()



int __cdecl
main( int argc, char * argv[])
{
    DWORD err = NO_ERROR;
    char ** ppszArgv;       // arguments for command functions
    int     cArgs;           // arg count for command functions
    char * pszCmdName;
    CmdStruct  * pCmd;
    CMDFUNC pCmdFunc = NULL;

    if ( argc < 3 || argv[1] == NULL ) {

      // Insufficient arguments
       GenUsageMessage( argc, argv);
       return ( 1);
    }

    pszCmdName = argv[2];
    if (( pCmd = DecodeCommand( pszCmdName)) == NULL || pCmd->cmdFunc == NULL) {
        printf( "Internal Error: Invalid Command %s\n", pszCmdName);
        GenUsageMessage( argc, argv);
        return ( 1);
    }

    g_lpszServerAddress = ConvertToUnicode( argv[1]);   // get server address

    cArgs = argc - 2;
    ppszArgv = argv + 2;     // position at the start of the command name

    if ( !(*pCmd->cmdFunc)( cArgs, ppszArgv)) {     // call the test function

        // Test function failed.
        printf( "Command %s failed. Error = %d\n", pszCmdName, GetLastError());
        return ( 1);
    }

    printf( " Command %s succeeded\n", pszCmdName);
    return ( 0);        // success

} // main()





/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\info\client\infobind.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    infobind.c

Abstract:

    Routines which use RPC to bind and unbind the client to the common
    internet Admin APIs.

Author:

    Madan Appiah (madana) 10-Oct-1995

Environment:

    User Mode -Win32

Revision History:

    Madan Appiah (madana) 10-Oct-1995 Created.
    Murali R. Krishnan (MuraliK)   15-Nov-1995   Remove Netp routines
    Murali R. Krishnan (MuraliK)   21-Nov-1995   Support TCP/IP binding

--*/

#define UNICODE
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windef.h>

#include <info_cli.h>
#include <inetinfo.h>
#include "apiutil.h"



handle_t
INET_INFO_IMPERSONATE_HANDLE_bind(
    INET_INFO_IMPERSONATE_HANDLE ServerName
    )

/*++

Routine Description:

    This routine is called from the inet info admin client stubs when
    it is necessary create an RPC binding to the server end with
    impersonation level of security

Arguments:

    ServerName - A pointer to a string containing the name of the server
        to bind with.

Return Value:

    The binding handle is returned to the stub routine.  If the bind is
    unsuccessful, a NULL will be returned.

--*/
{
    handle_t BindHandle;
    RPC_STATUS RpcStatus;

    RpcStatus = RpcBindHandleForServer(&BindHandle,
                                       ServerName,
                                       INET_INFO_INTERFACE_NAME,
                                       PROT_SEQ_NP_OPTIONS_W
                                       );


    return BindHandle;
} // INET_INFO_IMPERSONATE_HANDLE_bind()



handle_t
INET_INFO_IDENTIFY_HANDLE_bind(
    INET_INFO_IDENTIFY_HANDLE ServerName
    )

/*++

Routine Description:

    This routine is called from the inet admin client stubs when
    it is necessary create an RPC binding to the server end with
    identification level of impersonation.

Arguments:

    ServerName - A pointer to a string containing the name of the server
        to bind with.

Return Value:

    The binding handle is returned to the stub routine.  If the bind is
    unsuccessful, a NULL will be returned.

--*/
{
    handle_t BindHandle;
    RPC_STATUS RpcStatus;

    RpcStatus = RpcBindHandleForServer(&BindHandle,
                                       ServerName,
                                       INET_INFO_INTERFACE_NAME,
                                       PROT_SEQ_NP_OPTIONS_W
                                       );

    return BindHandle;
} // INET_INFO_IDENTITY_HANDLE_bind()



void
INET_INFO_IMPERSONATE_HANDLE_unbind(
    INET_INFO_IMPERSONATE_HANDLE ServerName,
    handle_t BindHandle
    )

/*++

Routine Description:

    This routine calls a common unbind routine that is shared by all services.
    This routine is called from the inet admin client stubs when it is
    necessary to unbind from the server end.

Arguments:

    ServerName - This is the name of the server from which to unbind.

    BindingHandle - This is the binding handle that is to be closed.

Return Value:

    None.

--*/
{
    UNREFERENCED_PARAMETER(ServerName);

    (VOID ) RpcBindHandleFree(&BindHandle);

    return;
} // INET_INFO_IMPERSONATE_HANDLE_unbind()



void
INET_INFO_IDENTIFY_HANDLE_unbind(
    INET_INFO_IDENTIFY_HANDLE ServerName,
    handle_t BindHandle
    )

/*++

Routine Description:

    This routine calls a common unbind routine that is shared by all services.
    This routine is called from the inet admin client stubs when it is
    necessary to unbind from a server.

Arguments:

    ServerName - This is the name of the server from which to unbind.

    BindingHandle - This is the binding handle that is to be closed.

Return Value:

    None.

--*/
{
    UNREFERENCED_PARAMETER(ServerName);


    (VOID ) RpcBindHandleFree(&BindHandle);

    return;
} // INET_INFO_IDENTITY_HANDLE_unbind()


/****************************** End Of File ******************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\info\idl\makefile.inc ===
#
#   makefile.idl
#       Created: ???
#
#   Revision
#       MuraliK     2-March-1995 [ Eliminated absolute directory dependencies]
#
#   Specify the following in the file for use
#
#   IDL_FILE_NAME   ( without the .idl suffix)
#   IDL_FLAGS       if any thing specific required
#

!INCLUDE $(NTMAKEENV)\makefile.plt

IDL_FILE_BASENAME   = info

IDL_FILE_NAME   = info
IDL_FLAGS       = -ms_ext -c_ext -oldnames $(MIDL_OPTIMIZATION_NT5)
IMPORTS         = imports

CLIENT_H    = $(O)\$(IDL_FILE_NAME)_cli.h
SERVER_H    = $(O)\$(IDL_FILE_NAME)_srv.h

CLIENT_ACF  = $(IDL_FILE_NAME)cli.acf
SERVER_ACF  = $(IDL_FILE_NAME)srv.acf

!IFNDEF  DISABLE_NET_UNICODE

UNICODE         = 1
NET_C_DEFINES   = -DUNICODE
!ENDIF


SDKINC          = $(SDK_INC_PATH)
SDKCRTINC       = $(CRT_INC_PATH)

INCS            = -I. -I$(SDKINC)  -I$(SDKCRTINC) -I$(IISBASEDIR)\inc

CLIENT_STUB     = $(O)\$(IDL_FILE_NAME)_cli.c
SERVER_STUB     = $(O)\$(IDL_FILE_NAME)_srv.c

CLIENT_TARGETS  = $(CLIENT_STUB) \
                  $(CLIENT_H)
SERVER_TARGETS  = $(SERVER_STUB) \
                  $(SERVER_H)

TARGETS         = $(CLIENT_TARGETS)  $(SERVER_TARGETS)
EXTRN_DEPENDS   = $(IISBASEDIR)\inc\inetinfo.h

CLIENT_FLAGS    =  -server none -acf $(CLIENT_ACF) -header $(CLIENT_H)
SERVER_FLAGS    =  -client none -acf $(SERVER_ACF) -header $(SERVER_H)

CPP             = -cpp_cmd "$(MIDL_CPP)" $(MIDL_FLAGS) \
                   $(C_DEFINES) $(NET_C_DEFINES)

#
#  Define output and dependencies
#


all:    $(TARGETS) $(EXTRN_DEPENDS)
!IF "$(BUILDMSG)" != ""
    @ech ; $(BUILDMSG) ;
!ENDIF


#
#  MIDL Compile stuff
#
$(CLIENT_TARGETS):  .\$(IDL_FILE_BASENAME).idl  $(EXTRN_DEPENDS) .\$(IMPORTS).idl \
                    .\$(IMPORTS).h .\$(CLIENT_ACF)
    midl $(IDL_FLAGS) $(CPP) $(CLIENT_FLAGS) .\$(IDL_FILE_BASENAME).idl  -cstub $(CLIENT_STUB) $(INCS)

$(SERVER_TARGETS):  .\$(IDL_FILE_BASENAME).idl  $(EXTRN_DEPENDS) .\$(IMPORTS).idl \
                    .\$(IMPORTS).h .\$(SERVER_ACF)
    midl $(IDL_FLAGS) $(CPP) $(SERVER_FLAGS) .\$(IDL_FILE_BASENAME).idl -sstub $(SERVER_STUB) $(INCS)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\info\idl\imports.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    imports.h

Abstract:

    This file allows us to include standard system header files in the
    .idl file.  The main .idl file imports a file called import.idl.
    This allows the .idl file to use the types defined in these header
    files.  It also causes the following line to be added in the
    MIDL generated header file:

    #include "imports.h"

    Thus these types are available to the RPC stub routines as well.

Author:

    Madan Appiah (madana) 10-Oct-1995

Revision History:


--*/


#include <windef.h>
#include <lmcons.h>

#ifdef MIDL_PASS
#define LPWSTR [string] wchar_t*
#define LPSTR [string] char*
#define BOOL DWORD
#endif

#include <inetcom.h>
#include <iisinfo.h>    // includes inetinfo.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\extend\w3ssl_config.cxx ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    w3ssl_config.cxx

Abstract:

    IIS Services IISADMIN Extension
    adjust HTTPFilter service imagepath based on IIS mode (old vs new)

Author:

    Jaroslav Dunajsky   (11/05/2001)

--*/

#include <cominc.hxx>
#include <string.h>
#include "w3ssl_config.hxx"



//static
int    W3SSL_CONFIG::s_fConfigTerminationRequested = FALSE;
//static
HANDLE W3SSL_CONFIG::s_hConfigChangeThread = NULL;
//static
LPWSTR W3SSL_CONFIG::s_pszImagePathInetinfo = NULL;
//static
LPWSTR W3SSL_CONFIG::s_pszImagePathLsass = NULL;
//static
LPWSTR W3SSL_CONFIG::s_pszImagePathSvchost = NULL;



//static
HRESULT
W3SSL_CONFIG::SetHTTPFilterImagePath(
    BOOL fIIS5IsolationModeEnabled,
    BOOL fStartInSvchost
)
/*++

Routine Description:

    Configure image path of the service to point either
    lsass.exe or inetinfo.exe based on the IIS Application
    Mode

Arguments:

    fIIS5IsolationModeEnabled - TRUE if IIS runs in old mode
                                FALSE if it runs in new mode
    fStartInSvchost           - preferred location for HTTPFilter is svchost.exe
Return Value:

    HRESULT

--*/

{
    SC_LOCK                   scLock = NULL;
    SC_HANDLE                 schSCManager = NULL;
    SC_HANDLE                 schHTTPFilterService = NULL;
    LPQUERY_SERVICE_CONFIG    pServiceConfig = NULL;
    DWORD                     dwBytesNeeded = 0;
    HRESULT                   hr = E_FAIL;

    // Open a handle to the SC Manager database.

    schSCManager = OpenSCManagerW(
                            NULL,                    // local machine
                            NULL,                    // ServicesActive database
                            SC_MANAGER_ALL_ACCESS ); // full access rights

    if ( schSCManager == NULL )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Finished;
    }

    schHTTPFilterService = OpenServiceW(
                            schSCManager,          // SCM database
                            HTTPFILTER_SERVICE_NAME,    // service name
                            SERVICE_ALL_ACCESS);

    if ( schHTTPFilterService == NULL )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Finished;
    }

    //
    // Get the configuration information.
    // - to find out the current image path of the
    //   HTTPFilter service
    //

    if ( !QueryServiceConfigW(
                            schHTTPFilterService,
                            pServiceConfig,
                            0,
                            &dwBytesNeeded ) )
    {
        if ( GetLastError() == ERROR_INSUFFICIENT_BUFFER )
        {
            pServiceConfig = reinterpret_cast<LPQUERY_SERVICE_CONFIG> (
                                                    new char[dwBytesNeeded] );
            if ( pServiceConfig == NULL )
            {
                hr = HRESULT_FROM_WIN32( ERROR_OUTOFMEMORY );
                goto Finished;
            }
            if ( !QueryServiceConfigW(
                                    schHTTPFilterService,
                                    pServiceConfig,
                                    dwBytesNeeded,
                                    &dwBytesNeeded ) )
            {
                hr = HRESULT_FROM_WIN32( GetLastError() );
                goto Finished;
            }
        }
        else
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            goto Finished;
        }
    }

    //
    // reconfigure image path of HTTPFilter if necessary
    //
    if (  ( fIIS5IsolationModeEnabled  &&
            _wcsicmp( pServiceConfig->lpBinaryPathName,
                      s_pszImagePathInetinfo ) != 0 ) ||
          ( !fIIS5IsolationModeEnabled  &&
            _wcsicmp( pServiceConfig->lpBinaryPathName,
                      s_pszImagePathLsass ) != 0 &&
            _wcsicmp( pServiceConfig->lpBinaryPathName,
                      s_pszImagePathSvchost ) != 0  )

       )
    {

        //
        // figure out what image path to configure
        //
        WCHAR * pszImagePath = ( fIIS5IsolationModeEnabled )?
                                  s_pszImagePathInetinfo :
                                  ( ( fStartInSvchost )?
                                    s_pszImagePathSvchost:
                                    s_pszImagePathLsass );

        if ( fIIS5IsolationModeEnabled )
        {
            BOOL fSave = FALSE;
            //
            // check if we need to store image path information
            // before changing
            //
            if ( _wcsicmp( pServiceConfig->lpBinaryPathName,
                             s_pszImagePathLsass ) == 0 &&
                   fStartInSvchost  )
            {
                fStartInSvchost = FALSE;
                fSave = TRUE;
            }
            if ( _wcsicmp( pServiceConfig->lpBinaryPathName,
                             s_pszImagePathSvchost ) == 0 &&
                   !fStartInSvchost  )
            {
                fStartInSvchost = TRUE;
                fSave = TRUE;
            }
            if ( fSave )
            {
                //
                // let's flag in the registry which one  lsass and svchost
                // was hosting the HTTPFilter service
                //
                DWORD               dwValue = (DWORD) fStartInSvchost;
                DWORD               dwErr;
                HKEY                hKeyParam;


                if ( ( dwErr = RegOpenKeyExW( HKEY_LOCAL_MACHINE,
                                   HTTPFILTER_PARAMETERS_KEY,
                                   0,
                                   KEY_WRITE,
                                   &hKeyParam ) ) == NO_ERROR )
                {
                    dwErr = RegSetValueExW( hKeyParam,
                                            L"StartInSvchost",
                                            NULL,
                                            REG_DWORD,
                                            ( LPBYTE )&dwValue,
                                            sizeof( dwValue )
                                            );
                    //
                    // Ignore the error.
                    //

                    RegCloseKey( hKeyParam );
                }

                if ( dwErr != NO_ERROR )
                {
                    DBGPRINTF(( DBG_CONTEXT,
                                "Failed to write to registry to path %S (hr = %d)\n",
                                HTTPFILTER_PARAMETERS_KEY,
                                HRESULT_FROM_WIN32( dwErr )));
                }


            }

        }

        //
        // loop to acquire service database lock
        //
        for ( ; ; )
        {
            scLock = LockServiceDatabase( schSCManager );
            if ( scLock == NULL )
            {
                if ( GetLastError() == ERROR_SERVICE_DATABASE_LOCKED )
                {
                    if ( s_fConfigTerminationRequested == TRUE )
                    {
                        //
                        // if W3SSL_CONFIG::Terminate() is called
                        // while this function is still waiting for service
                        // to get locked, we simply bail out.
                        // ImagePath will not be changed
                        //
                        hr = HRESULT_FROM_WIN32( ERROR_OPERATION_ABORTED );
                        goto Finished;
                    }

                    Sleep( 1000 );
                    continue;
                }
                else
                {
                    hr = HRESULT_FROM_WIN32( GetLastError() );
                    goto Finished;
                }
            }

            if ( s_fConfigTerminationRequested == TRUE )
            {
                //
                // if W3SSL_CONFIG::Terminate() is called
                // while this function is still waiting for service
                // to get locked, we simply bail out.
                // ImagePath will not be changed
                //
                hr = HRESULT_FROM_WIN32( ERROR_OPERATION_ABORTED );
                goto Finished;
            }

            break;
        }

        if ( !ChangeServiceConfigW(
                            schHTTPFilterService,   // handle of service
                            SERVICE_NO_CHANGE, // service type
                            SERVICE_NO_CHANGE, // change service start type
                            SERVICE_NO_CHANGE, // error control
                            pszImagePath,      // binary path
                            NULL,              // load order group
                            NULL,              // tag ID
                            NULL,              // dependencies
                            NULL,              // account name
                            NULL,              // password
                            NULL) )            // display name
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            goto Finished;
        }
        
        UnlockServiceDatabase( scLock );
        scLock = NULL;

    }


    hr = S_OK;

Finished:

    if ( pServiceConfig != NULL )
    {
        delete [] pServiceConfig;
        pServiceConfig = NULL;
    }

    if ( scLock != NULL )
    {
        UnlockServiceDatabase( scLock );
        scLock = NULL;
    }

    if ( schHTTPFilterService != NULL )
    {
        DBG_REQUIRE( CloseServiceHandle( schHTTPFilterService ) );
        schHTTPFilterService = NULL;
    }

    if ( schSCManager != NULL )
    {
        DBG_REQUIRE( CloseServiceHandle( schSCManager ) );
        schSCManager = NULL;
    }

    return hr;

}

//static
HRESULT
W3SSL_CONFIG::AdjustHTTPFilterImagePath(
    VOID
)
/*++

Routine Description:

    Based on the metabase valuse
    configure image path of the service to point either
    lsass.exe or inetinfo.exe based on the IIS Application
    Mode

Arguments:

    none

Return Value:

    HRESULT

--*/
{

    HRESULT           hr = E_FAIL;
    METADATA_RECORD   mdrData;
    DWORD             dwRequiredDataLen = 0;
    METADATA_HANDLE   mhOpenHandle = 0;
    IMDCOM *          pcCom = NULL;
    DWORD             dwStandardModeEnabled = 1;

    DWORD               dwType;
    DWORD               nBytes;
    DWORD               dwValue;
    DWORD               dwErr;
    BOOL                fStartInSvchost = FALSE;
    HKEY                hKeyParam;


    //
    // read registry to find out if preferred location for HTTPFilter is svchost
    //

    if ( RegOpenKeyExW( HKEY_LOCAL_MACHINE,
                       HTTPFILTER_PARAMETERS_KEY,
                       0,
                       KEY_READ,
                       &hKeyParam ) == NO_ERROR )
    {
        nBytes = sizeof( dwValue );
        dwErr = RegQueryValueExW( hKeyParam,
                                L"StartInSvchost",
                                NULL,
                                &dwType,
                                ( LPBYTE )&dwValue,
                                &nBytes
                                );

        if ( ( dwErr == ERROR_SUCCESS ) && ( dwType == REG_DWORD ) )
        {
            fStartInSvchost = !!dwValue;
        }

        RegCloseKey( hKeyParam );
    }



    hr = CoCreateInstance( CLSID_MDCOM,
                           NULL,
                           CLSCTX_SERVER,
                           IID_IMDCOM,
                           (void**) &pcCom);

    if ( FAILED( hr ) )
    {
        goto Finished;
    }

    hr = pcCom->ComMDOpenMetaObject(  METADATA_MASTER_ROOT_HANDLE,
                                      L"/lm/w3svc",
                                      METADATA_PERMISSION_READ,
                                      OPEN_TIMEOUT_VALUE,
                                      &mhOpenHandle );
    if ( FAILED( hr ) )
    {
        goto Finished;
    }
    else
    {
        MD_SET_DATA_RECORD_EXT( &mdrData,
                                MD_GLOBAL_STANDARD_APP_MODE_ENABLED ,
                                METADATA_NO_ATTRIBUTES,
                                ALL_METADATA,
                                DWORD_METADATA,
                                sizeof( dwStandardModeEnabled ),
                                (PBYTE) &dwStandardModeEnabled );

        hr = pcCom->ComMDGetMetaData( mhOpenHandle,
                                      NULL,
                                      &mdrData,
                                      &dwRequiredDataLen );

        if ( hr == MD_ERROR_DATA_NOT_FOUND )
        {
            //
            // Standard mode is enabled by default
            //
            dwStandardModeEnabled = 1;
        }
        else if ( FAILED ( hr ) )
        {
            //
            // Error different from not found
            // In this case simply bail out
            //
            goto Finished;
        }
    }

    //
    // Cleanup metabase object
    //
    pcCom->ComMDCloseMetaObject( mhOpenHandle );
    mhOpenHandle = 0;

    pcCom->Release();
    pcCom = NULL;

    hr = SetHTTPFilterImagePath( (BOOL) !!dwStandardModeEnabled, fStartInSvchost );
    if ( FAILED( hr ) )
    {
        goto Finished;
    }

    hr = S_OK;

Finished:

    if ( mhOpenHandle != 0 )
    {
        pcCom->ComMDCloseMetaObject( mhOpenHandle );
        mhOpenHandle = 0;
    }


    if ( pcCom != NULL )
    {
        pcCom->Release();
        pcCom = NULL;
    }


    return hr;
}

//static
HRESULT
W3SSL_CONFIG::StartAsyncAdjustHTTPFilterImagePath(
    VOID
)
/*++

Routine Description:

    Configure image path of the service to point either
    lsass.exe or inetinfo.exe based on the IIS Application
    Mode.
    The action is executed on separate thread

    Terminate() must be called to assure proper cleanup

Arguments:

    none

Return Value:

    HRESULT

--*/
{

    s_hConfigChangeThread =
          ::CreateThread(
                  NULL,     // default security descriptor
                  0,        // default process stack size
                  W3SSL_CONFIG::ConfigChangeThread,
                  NULL,     // thread argument - pointer to this class
                  0,        // create running
                  NULL      // don't care for thread identifier
                  );

    if ( s_hConfigChangeThread == NULL )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }

    return S_OK;
}

HRESULT
ExpandImagePath(
    const WCHAR *  pszPath,
    WCHAR       ** ppszExpandedPath
)
{
    DBG_ASSERT( *ppszExpandedPath == NULL );
    DWORD dwLen = ExpandEnvironmentStringsW( pszPath, NULL, 0 );
    * ppszExpandedPath = new WCHAR [dwLen];
    if ( * ppszExpandedPath == NULL )
    {
        return HRESULT_FROM_WIN32( ERROR_OUTOFMEMORY );
    }

    (* ppszExpandedPath)[0] = '\0';

    DWORD dwLen2 = ExpandEnvironmentStringsW( pszPath,
                                              *ppszExpandedPath,
                                              dwLen );
    if ( dwLen2 != dwLen )
    {
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    return S_OK;
}

//static
HRESULT
W3SSL_CONFIG::Initialize(
    VOID
)
/*++

Routine Description:

    Initialization

Arguments:

    none

Return Value:

    VOID

--*/
{
    HRESULT hr = E_FAIL;

    //
    // Expand image path because QueryServiceConfig
    // already returns expanded ImagePath and
    // Image Paths will be compared few times
    //

    hr = ExpandImagePath( HTTPFILTER_SERVICE_IMAGEPATH_INETINFO,
                          &s_pszImagePathInetinfo );
    if ( FAILED( hr ) )
    {
        goto Failed;
    }
    hr = ExpandImagePath( HTTPFILTER_SERVICE_IMAGEPATH_LSASS,
                          &s_pszImagePathLsass );
    if ( FAILED( hr ) )
    {
        goto Failed;
    }
    hr = ExpandImagePath( HTTPFILTER_SERVICE_IMAGEPATH_SVCHOST,
                          &s_pszImagePathSvchost );
    if ( FAILED( hr ) )
    {
        goto Failed;
    }

    return S_OK;

Failed:
    Terminate();
    return hr;
}


//static
VOID
W3SSL_CONFIG::Terminate(
    VOID
)
/*++

Routine Description:

    Quits the asynchronous change of HTTPFILTER image path (if any)
    and/or does final cleanup

Arguments:

    none

Return Value:

    VOID

--*/
{
    s_fConfigTerminationRequested = TRUE;

    if ( s_hConfigChangeThread != NULL )
    {
        DWORD dwRet = WaitForSingleObject( s_hConfigChangeThread,
                                           INFINITE );
        DBG_ASSERT( dwRet == WAIT_OBJECT_0 );

        // IVANPASH dwRet is used only in debug builds, so on /W4 there is
        // a warning, which is cheated by the next otherwise useless line.
        (VOID)dwRet;

        CloseHandle( s_hConfigChangeThread );
        s_hConfigChangeThread = NULL;
    }

    if ( s_pszImagePathInetinfo != NULL )
    {
        delete s_pszImagePathInetinfo;
        s_pszImagePathInetinfo = NULL;
    }

    if ( s_pszImagePathSvchost != NULL )
    {
        delete s_pszImagePathSvchost;
        s_pszImagePathSvchost = NULL;
    }
    if ( s_pszImagePathLsass != NULL )
    {
        delete s_pszImagePathLsass;
        s_pszImagePathLsass = NULL;
    }

}


//static
DWORD
W3SSL_CONFIG::ConfigChangeThread(
    LPVOID
)
/*++

Routine Description:

    Worker thread function used to perform image path change asynchronously

Arguments:

    none

Return Value:

    VOID

--*/

{
    AdjustHTTPFilterImagePath();
    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\info\perfmon\infoctrs.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    infoctrs.h

    Offset definitions for the INFO Server's counter objects & counters.

    These offsets *must* start at 0 and be multiples of 2.  In the
    INFOOpenPerformanceData procecedure, they will be added to the
    INFO Server's "First Counter" and "First Help" values in order to
    determine the absolute location of the counter & object names
    and corresponding help text in the registry.

    This file is used by the INFOCTRS.DLL DLL code as well as the
    INFOCTRS.INI definition file.  INFOCTRS.INI is parsed by the
    LODCTR utility to load the object & counter names into the
    registry.


    FILE HISTORY:
        KeithMo     07-Jun-1993 Created.
        MuraliK     02-Jun-1995 Added Counters for Atq I/O requests
        SophiaC     16-Oct-1995 Info/Access Product Split

*/


#ifndef _INFOCTRS_H_
#define _INFOCTRS_H_


//
//  The INFO Server counter object.
//

#define INFO_COUNTER_OBJECT                     0


//
//  The individual counters.
//

#define INFO_ATQ_TOTAL_ALLOWED_REQUESTS_COUNTER         2
#define INFO_ATQ_TOTAL_BLOCKED_REQUESTS_COUNTER         4
#define INFO_ATQ_TOTAL_REJECTED_REQUESTS_COUNTER        6
#define INFO_ATQ_CURRENT_BLOCKED_REQUESTS_COUNTER       8
#define INFO_ATQ_MEASURED_BANDWIDTH_COUNTER             10

#define INFO_CACHE_FILES_CACHED_COUNTER                 12
#define INFO_CACHE_TOTAL_FILES_CACHED_COUNTER           14
#define INFO_CACHE_FILES_HIT_COUNTER                    16
#define INFO_CACHE_FILES_MISS_COUNTER                   18
#define INFO_CACHE_FILE_RATIO_COUNTER                   20
#define INFO_CACHE_FILE_RATIO_COUNTER_DENOM             22
#define INFO_CACHE_FILE_FLUSHES_COUNTER                 24
#define INFO_CACHE_CURRENT_FILE_CACHE_SIZE_COUNTER      26
#define INFO_CACHE_MAXIMUM_FILE_CACHE_SIZE_COUNTER      28
#define INFO_CACHE_ACTIVE_FLUSHED_FILES_COUNTER         30
#define INFO_CACHE_TOTAL_FLUSHED_FILES_COUNTER          32

#define INFO_CACHE_URI_CACHED_COUNTER                   34
#define INFO_CACHE_TOTAL_URI_CACHED_COUNTER             36
#define INFO_CACHE_URI_HIT_COUNTER                      38
#define INFO_CACHE_URI_MISS_COUNTER                     40
#define INFO_CACHE_URI_RATIO_COUNTER                    42
#define INFO_CACHE_URI_RATIO_COUNTER_DENOM              44
#define INFO_CACHE_URI_FLUSHES_COUNTER                  46
#define INFO_CACHE_TOTAL_FLUSHED_URI_COUNTER            48

#define INFO_CACHE_BLOB_CACHED_COUNTER                  50
#define INFO_CACHE_TOTAL_BLOB_CACHED_COUNTER            52
#define INFO_CACHE_BLOB_HIT_COUNTER                     54
#define INFO_CACHE_BLOB_MISS_COUNTER                    56
#define INFO_CACHE_BLOB_RATIO_COUNTER                   58
#define INFO_CACHE_BLOB_RATIO_COUNTER_DENOM             60
#define INFO_CACHE_BLOB_FLUSHES_COUNTER                 62
#define INFO_CACHE_TOTAL_FLUSHED_BLOB_COUNTER           64

#endif  // _INFOCTRS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\info\perfmon\infodata.c ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    infodata.c

    Constant data structures for the Info Server's counter objects &
    counters.


    FILE HISTORY:
        KeithMo     07-Jun-1993 Created.
        MuraliK     02-Jun-1995 Added Counters for Atq I/O requests
        SophiaC     16-Oct-1995 Info/Access Product Split

*/


#include <windows.h>
#include <winperf.h>
#include <infoctrs.h>
#include <infodata.h>


//
//  Initialize the constant portitions of these data structure.
//  Certain parts (especially the name/help indices) will be
//  updated at initialization time.
//

INFO_DATA_DEFINITION INFODataDefinition =
{
    {   // INFOObjectType
        sizeof(INFO_DATA_DEFINITION) + SIZE_OF_INFO_PERFORMANCE_DATA,
        sizeof(INFO_DATA_DEFINITION),
        sizeof(PERF_OBJECT_TYPE),
        INFO_COUNTER_OBJECT,
        0,
        INFO_COUNTER_OBJECT,
        0,
        PERF_DETAIL_ADVANCED,
        NUMBER_OF_INFO_COUNTERS,
        2,                              // Default = Bytes Total/sec
        PERF_NO_INSTANCES,
        0,
        { 0, 0 },
        { 0, 0 }
    },

    {   // TotalAllowedRequests
        sizeof(PERF_COUNTER_DEFINITION),
        INFO_ATQ_TOTAL_ALLOWED_REQUESTS_COUNTER,
        0,
        INFO_ATQ_TOTAL_ALLOWED_REQUESTS_COUNTER,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        INFO_ATQ_TOTAL_ALLOWED_REQUESTS_OFFSET
    },

    {   // TotalBlockedRequests
        sizeof(PERF_COUNTER_DEFINITION),
        INFO_ATQ_TOTAL_BLOCKED_REQUESTS_COUNTER,
        0,
        INFO_ATQ_TOTAL_BLOCKED_REQUESTS_COUNTER,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        INFO_ATQ_TOTAL_BLOCKED_REQUESTS_OFFSET
    },

    {   // TotalRejectedRequests
        sizeof(PERF_COUNTER_DEFINITION),
        INFO_ATQ_TOTAL_REJECTED_REQUESTS_COUNTER,
        0,
        INFO_ATQ_TOTAL_REJECTED_REQUESTS_COUNTER,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        INFO_ATQ_TOTAL_REJECTED_REQUESTS_OFFSET
    },

    {   // CurrentBlockedRequests
        sizeof(PERF_COUNTER_DEFINITION),
        INFO_ATQ_CURRENT_BLOCKED_REQUESTS_COUNTER,
        0,
        INFO_ATQ_CURRENT_BLOCKED_REQUESTS_COUNTER,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        INFO_ATQ_CURRENT_BLOCKED_REQUESTS_OFFSET
    },

    {   // AtqMeasuredBandwidth
        sizeof(PERF_COUNTER_DEFINITION),
        INFO_ATQ_MEASURED_BANDWIDTH_COUNTER,
        0,
        INFO_ATQ_MEASURED_BANDWIDTH_COUNTER,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        INFO_ATQ_MEASURED_BANDWIDTH_OFFSET
    },
    
    {   // FilesCached
        sizeof(PERF_COUNTER_DEFINITION),
        INFO_CACHE_FILES_CACHED_COUNTER,
        0,
        INFO_CACHE_FILES_CACHED_COUNTER,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        INFO_CACHE_FILES_CACHED_OFFSET
    },

    {   // TotalFilesCached
        sizeof(PERF_COUNTER_DEFINITION),
        INFO_CACHE_TOTAL_FILES_CACHED_COUNTER,
        0,
        INFO_CACHE_TOTAL_FILES_CACHED_COUNTER,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        INFO_CACHE_TOTAL_FILES_CACHED_OFFSET
    },

    {   // FileCacheHits
        sizeof(PERF_COUNTER_DEFINITION),
        INFO_CACHE_FILES_HIT_COUNTER,
        0,
        INFO_CACHE_FILES_HIT_COUNTER,
        0,
        -3,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        INFO_CACHE_FILES_HIT_OFFSET
    },

    {   // FileCacheMisses
        sizeof(PERF_COUNTER_DEFINITION),
        INFO_CACHE_FILES_MISS_COUNTER,
        0,
        INFO_CACHE_FILES_MISS_COUNTER,
        0,
        -3,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        INFO_CACHE_FILES_MISS_OFFSET
    },

    {   // Calculated ratio of hits to misses - Numerator (cache hits)
        sizeof(PERF_COUNTER_DEFINITION),
        INFO_CACHE_FILE_RATIO_COUNTER,
        0,
        INFO_CACHE_FILE_RATIO_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_RAW_FRACTION,
        sizeof(DWORD),
        INFO_CACHE_FILE_RATIO_OFFSET
    },

    {   // Calculated ratio of hits to misses - Denominator, not displayed!
        sizeof(PERF_COUNTER_DEFINITION),
        INFO_CACHE_FILE_RATIO_COUNTER_DENOM,
        0,
        INFO_CACHE_FILE_RATIO_COUNTER_DENOM,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_RAW_BASE,
        sizeof(DWORD),
        INFO_CACHE_FILE_RATIO_DENOM_OFFSET
    },


    {   // File Cache Flushes
        sizeof(PERF_COUNTER_DEFINITION),
        INFO_CACHE_FILE_FLUSHES_COUNTER,
        0,
        INFO_CACHE_FILE_FLUSHES_COUNTER,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        INFO_CACHE_FILE_FLUSHES_OFFSET
    },

    {   // Current file cache size
        sizeof(PERF_COUNTER_DEFINITION),
        INFO_CACHE_CURRENT_FILE_CACHE_SIZE_COUNTER,
        0,
        INFO_CACHE_CURRENT_FILE_CACHE_SIZE_COUNTER,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        INFO_CACHE_CURRENT_FILE_CACHE_SIZE_OFFSET
    },

    {   // Maximum file cache size
        sizeof(PERF_COUNTER_DEFINITION),
        INFO_CACHE_MAXIMUM_FILE_CACHE_SIZE_COUNTER,
        0,
        INFO_CACHE_MAXIMUM_FILE_CACHE_SIZE_COUNTER,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        INFO_CACHE_MAXIMUM_FILE_CACHE_SIZE_OFFSET
    },

    {   // ActiveFlushedFiles
        sizeof(PERF_COUNTER_DEFINITION),
        INFO_CACHE_ACTIVE_FLUSHED_FILES_COUNTER,
        0,
        INFO_CACHE_ACTIVE_FLUSHED_FILES_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        INFO_CACHE_ACTIVE_FLUSHED_FILES_OFFSET
    },

    {   // Total flushed files
        sizeof(PERF_COUNTER_DEFINITION),
        INFO_CACHE_TOTAL_FLUSHED_FILES_COUNTER,
        0,
        INFO_CACHE_TOTAL_FLUSHED_FILES_COUNTER,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        INFO_CACHE_TOTAL_FLUSHED_FILES_OFFSET
    },



    {   // URICached
        sizeof(PERF_COUNTER_DEFINITION),
        INFO_CACHE_URI_CACHED_COUNTER,
        0,
        INFO_CACHE_URI_CACHED_COUNTER,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        INFO_CACHE_URI_CACHED_OFFSET
    },

    {   // TotalURICached
        sizeof(PERF_COUNTER_DEFINITION),
        INFO_CACHE_TOTAL_URI_CACHED_COUNTER,
        0,
        INFO_CACHE_TOTAL_URI_CACHED_COUNTER,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        INFO_CACHE_TOTAL_URI_CACHED_OFFSET
    },

    {   // URICacheHits
        sizeof(PERF_COUNTER_DEFINITION),
        INFO_CACHE_URI_HIT_COUNTER,
        0,
        INFO_CACHE_URI_HIT_COUNTER,
        0,
        -3,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        INFO_CACHE_URI_HIT_OFFSET
    },

    {   // URICacheMisses
        sizeof(PERF_COUNTER_DEFINITION),
        INFO_CACHE_URI_MISS_COUNTER,
        0,
        INFO_CACHE_URI_MISS_COUNTER,
        0,
        -3,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        INFO_CACHE_URI_MISS_OFFSET
    },

    {   // Calculated ratio of hits to misses - Numerator (cache hits)
        sizeof(PERF_COUNTER_DEFINITION),
        INFO_CACHE_URI_RATIO_COUNTER,
        0,
        INFO_CACHE_URI_RATIO_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_RAW_FRACTION,
        sizeof(DWORD),
        INFO_CACHE_URI_RATIO_OFFSET
    },

    {   // Calculated ratio of hits to misses - Denominator, not displayed!
        sizeof(PERF_COUNTER_DEFINITION),
        INFO_CACHE_URI_RATIO_COUNTER_DENOM,
        0,
        INFO_CACHE_URI_RATIO_COUNTER_DENOM,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_RAW_BASE,
        sizeof(DWORD),
        INFO_CACHE_URI_RATIO_DENOM_OFFSET
    },


    {   // URI Cache Flushes
        sizeof(PERF_COUNTER_DEFINITION),
        INFO_CACHE_URI_FLUSHES_COUNTER,
        0,
        INFO_CACHE_URI_FLUSHES_COUNTER,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        INFO_CACHE_URI_FLUSHES_OFFSET
    },


    {   // Total flushed URIs
        sizeof(PERF_COUNTER_DEFINITION),
        INFO_CACHE_TOTAL_FLUSHED_URI_COUNTER,
        0,
        INFO_CACHE_TOTAL_FLUSHED_URI_COUNTER,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        INFO_CACHE_TOTAL_FLUSHED_URI_OFFSET
    },


    

    {   // BlobCached
        sizeof(PERF_COUNTER_DEFINITION),
        INFO_CACHE_BLOB_CACHED_COUNTER,
        0,
        INFO_CACHE_BLOB_CACHED_COUNTER,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        INFO_CACHE_BLOB_CACHED_OFFSET
    },

    {   // TotalBlobCached
        sizeof(PERF_COUNTER_DEFINITION),
        INFO_CACHE_TOTAL_BLOB_CACHED_COUNTER,
        0,
        INFO_CACHE_TOTAL_BLOB_CACHED_COUNTER,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        INFO_CACHE_TOTAL_BLOB_CACHED_OFFSET
    },

    {   // BlobCacheHits
        sizeof(PERF_COUNTER_DEFINITION),
        INFO_CACHE_BLOB_HIT_COUNTER,
        0,
        INFO_CACHE_BLOB_HIT_COUNTER,
        0,
        -3,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        INFO_CACHE_BLOB_HIT_OFFSET
    },

    {   // BlobCacheMisses
        sizeof(PERF_COUNTER_DEFINITION),
        INFO_CACHE_BLOB_MISS_COUNTER,
        0,
        INFO_CACHE_BLOB_MISS_COUNTER,
        0,
        -3,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        INFO_CACHE_BLOB_MISS_OFFSET
    },

    {   // Calculated ratio of hits to misses - Numerator (cache hits)
        sizeof(PERF_COUNTER_DEFINITION),
        INFO_CACHE_BLOB_RATIO_COUNTER,
        0,
        INFO_CACHE_BLOB_RATIO_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_RAW_FRACTION,
        sizeof(DWORD),
        INFO_CACHE_BLOB_RATIO_OFFSET
    },

    {   // Calculated ratio of hits to misses - Denominator, not displayed!
        sizeof(PERF_COUNTER_DEFINITION),
        INFO_CACHE_BLOB_RATIO_COUNTER_DENOM,
        0,
        INFO_CACHE_BLOB_RATIO_COUNTER_DENOM,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_RAW_BASE,
        sizeof(DWORD),
        INFO_CACHE_BLOB_RATIO_DENOM_OFFSET
    },


    {   // Blob Cache Flushes
        sizeof(PERF_COUNTER_DEFINITION),
        INFO_CACHE_BLOB_FLUSHES_COUNTER,
        0,
        INFO_CACHE_BLOB_FLUSHES_COUNTER,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        INFO_CACHE_BLOB_FLUSHES_OFFSET
    },


    {   // Total flushed Blobs
        sizeof(PERF_COUNTER_DEFINITION),
        INFO_CACHE_TOTAL_FLUSHED_BLOB_COUNTER,
        0,
        INFO_CACHE_TOTAL_FLUSHED_BLOB_COUNTER,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        INFO_CACHE_TOTAL_FLUSHED_BLOB_OFFSET
    }


};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\info\perfmon\makefile.inc ===
MY_BINPLACE = -binplace -P $(BINPLACE_PLACEFILE)

copyini:
    $(MY_BINPLACE) infoctrs.ini
    $(MY_BINPLACE) infoctrs.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\info\perfmon\infoperf.c ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    infoperf.c

    This file implements the Extensible Performance Objects for
    the common INFO counters


    FILE HISTORY:
        KeithMo     07-Jun-1993 Created, based on RussBl's sample code.
        MuraliK     02-Jun-1995 Added Counters for Atq I/O requests
        SophiaC     16-Oct-1995 Info/Access Product Split
        MuraliK     16-Nov-1995 Removed undoc apis

*/

#include <windows.h>
#include <winperf.h>
#include <lm.h>
#include <inetinfo.h>

#include <string.h>
#include <stdlib.h>

#include <infoctrs.h>
#include <infodata.h>
#include <perfutil.h>
#include <iis64.h>
#include "infomsg.h"

# include "apiutil.h"

//
//  Private constants.
//
#define APP_NAME                        (TEXT("IISInfoCtrs"))
//
//  Private globals.
//

DWORD   cOpens    = 0;                  // Active "opens" reference count.
BOOL    fInitOK   = FALSE;              // TRUE if DLL initialized OK.
HANDLE  hEventLog = NULL;               // event log handle

#if DBG
DWORD   INFODebug = 0;                  // Debug behaviour flags.
#endif  // DBG

//
//  Public prototypes.
//

PM_OPEN_PROC    OpenINFOPerformanceData;
PM_COLLECT_PROC CollectINFOPerformanceData;
PM_CLOSE_PROC   CloseINFOPerformanceData;


//
//  Public functions.
//

/*******************************************************************

    NAME:       OpenINFOPerformanceData

    SYNOPSIS:   Initializes the data structures used to communicate
                performance counters with the registry.

    ENTRY:      lpDeviceNames - Poitner to object ID of each device
                    to be opened.

    RETURNS:    DWORD - Win32 status code.

    HISTORY:
        KeithMo     07-Jun-1993 Created.

********************************************************************/
DWORD OpenINFOPerformanceData( LPWSTR lpDeviceNames )
{
    DWORD err  = NO_ERROR;
    HKEY  hkey = NULL;
    DWORD size;
    DWORD type;
    DWORD dwFirstCounter;
    DWORD dwFirstHelp;
    PERF_COUNTER_DEFINITION * pctr;
    DWORD                     i;

    //
    //  Since SCREG is multi-threaded and will call this routine in
    //  order to service remote performance queries, this library
    //  must keep track of how many times it has been opened (i.e.
    //  how many threads have accessed it). The registry routines will
    //  limit access to the initialization routine to only one thread
    //  at a time so synchronization (i.e. reentrancy) should not be
    //  a problem.
    //

    if( !fInitOK )
    {

        //
        //  This is the *first* open.
        //
        // open the event log interface
        if (hEventLog == NULL) {
            hEventLog = RegisterEventSource (
                (LPSTR)NULL,    // on the local machine
                APP_NAME);      // register the name to allow message lookup
        }

        //
        //  Open the HTTP Server service's Performance key.
        //

        err = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                            INFO_PERFORMANCE_KEY,
                            0,
                            KEY_READ,
                            &hkey );

        if( err == NO_ERROR )
        {
            //
            //  Read the first counter DWORD.
            //

            size = sizeof(DWORD);

            err = RegQueryValueEx( hkey,
                                   "First Counter",
                                   NULL,
                                   &type,
                                   (LPBYTE)&dwFirstCounter,
                                   &size );
            if( err == NO_ERROR )
            {
                //
                //  Read the first help DWORD.
                //

                size = sizeof(DWORD);

                err = RegQueryValueEx( hkey,
                                    "First Help",
                                    NULL,
                                    &type,
                                    (LPBYTE)&dwFirstHelp,
                                    &size );

                if ( err == NO_ERROR )
                {
                    //
                    //  Update the object & counter name & help indicies.
                    //

                    INFODataDefinition.INFOObjectType.ObjectNameTitleIndex
                        += dwFirstCounter;
                    INFODataDefinition.INFOObjectType.ObjectHelpTitleIndex
                        += dwFirstHelp;

                    pctr = &INFODataDefinition.INFOTotalAllowedRequests;

                    for( i = 0 ; i < NUMBER_OF_INFO_COUNTERS ; i++ )
                    {
                        pctr->CounterNameTitleIndex += dwFirstCounter;
                        pctr->CounterHelpTitleIndex += dwFirstHelp;
                        pctr++;
                    }

                    //
                    //  Remember that we initialized OK.
                    //

                    fInitOK = TRUE;
                    //
                    //  Bump open counter.
                    //

                    cOpens++;

                    // return success
                    err = ERROR_SUCCESS;
                } else {
                    // log event
                    ReportEvent (hEventLog, EVENTLOG_ERROR_TYPE,
                        0, IIS_INFO_UNABLE_READ_FIRST_HELP,
                        (PSID)NULL, 0,
                        sizeof (err), NULL,
                        (PVOID)(&err));
                }
            } else {
                // log event
                ReportEvent (hEventLog, EVENTLOG_ERROR_TYPE,
                    0, IIS_INFO_UNABLE_READ_FIRST_COUNTER,
                    (PSID)NULL, 0,
                    sizeof (err), NULL,
                    (PVOID)(&err));
            }
            //
            //  Close the registry if we managed to actually open it.
            //

            if( hkey != NULL )
            {
                RegCloseKey( hkey );
                hkey = NULL;
            }
        } else {
            // log event
            ReportEvent (hEventLog, EVENTLOG_ERROR_TYPE,
                0, IIS_INFO_UNABLE_OPEN_PERF_KEY,
                (PSID)NULL, 0,
                sizeof (err), NULL,
                (PVOID)(&err));
        }
    }

    return err;

}   // OpenINFOPerformanceData

/*******************************************************************

    NAME:       CollectINFOPerformanceData

    SYNOPSIS:   Initializes the data structures used to communicate

    ENTRY:      lpValueName - The name of the value to retrieve.

                lppData - On entry contains a pointer to the buffer to
                    receive the completed PerfDataBlock & subordinate
                    structures.  On exit, points to the first bytes
                    *after* the data structures added by this routine.

                lpcbTotalBytes - On entry contains a pointer to the
                    size (in BYTEs) of the buffer referenced by lppData.
                    On exit, contains the number of BYTEs added by this
                    routine.

                lpNumObjectTypes - Receives the number of objects added
                    by this routine.

    RETURNS:    DWORD - Win32 status code.  MUST be either NO_ERROR
                    or ERROR_MORE_DATA.

    HISTORY:
        KeithMo     07-Jun-1993 Created.

********************************************************************/
DWORD CollectINFOPerformanceData( LPWSTR    lpValueName,
                                 LPVOID  * lppData,
                                 LPDWORD   lpcbTotalBytes,
                                 LPDWORD   lpNumObjectTypes )
{
    DWORD                  dwQueryType;
    ULONG                  cbRequired;
    DWORD                * pdwCounter;
    INFO_COUNTER_BLOCK   * pCounterBlock;
    INFO_DATA_DEFINITION * pINFODataDefinition;
    INET_INFO_STATISTICS_0   * pINFOStats;
    NET_API_STATUS         neterr;

    //
    //  No need to even try if we failed to open...
    //

    if( !fInitOK )
    {
        *lpcbTotalBytes   = 0;
        *lpNumObjectTypes = 0;

        //
        //  According to the Performance Counter design, this
        //  is a successful exit.  Go figure.
        //

        return NO_ERROR;
    }

    //
    //  Determine the query type.
    //

    dwQueryType = GetQueryType( lpValueName );

    if (( dwQueryType == QUERY_FOREIGN ) || ( dwQueryType == QUERY_COSTLY ))
    {
        //
        //  We don't do foreign or Costly queries.
        //

        *lpcbTotalBytes   = 0;
        *lpNumObjectTypes = 0;

        return NO_ERROR;
    }

    if( dwQueryType == QUERY_ITEMS )
    {
        //
        //  The registry is asking for a specific object.  Let's
        //  see if we're one of the chosen.
        //

        if( !IsNumberInUnicodeList(
                        INFODataDefinition.INFOObjectType.ObjectNameTitleIndex,
                        lpValueName ) )
        {
            *lpcbTotalBytes   = 0;
            *lpNumObjectTypes = 0;

            return NO_ERROR;
        }
    }

    //
    //  See if there's enough space.
    //

    pINFODataDefinition = (INFO_DATA_DEFINITION *)*lppData;

    //
    //  Try to retrieve the data.
    //

    neterr = InetInfoQueryStatistics( NULL,
                                      0,
                                      0,
                                      (LPBYTE *)&pINFOStats );

    if( neterr == NERR_Success ) {

        
        cbRequired = sizeof(INFO_DATA_DEFINITION) + SIZE_OF_INFO_PERFORMANCE_DATA;

        if( *lpcbTotalBytes < cbRequired )
        {
            //
            //  Nope.
            //

            *lpcbTotalBytes   = 0;
            *lpNumObjectTypes = 0;

            return ERROR_MORE_DATA;
        }

        //
        // Copy the (constant, initialized) Object Type and counter definitions
        //  to the caller's data buffer
        //

        memmove( pINFODataDefinition,
                &INFODataDefinition,
                sizeof(INFO_DATA_DEFINITION) );

        //
        //  Format the INFO Server data.
        //

        pCounterBlock = (INFO_COUNTER_BLOCK *)( pINFODataDefinition + 1 );

        pCounterBlock->PerfCounterBlock.ByteLength = SIZE_OF_INFO_PERFORMANCE_DATA;

        //
        //  Now move the DWORDs into the buffer.
        //

        pdwCounter = (DWORD *)(pCounterBlock + 1);

        //
        //  ATQ Global counters
        //
        *pdwCounter++ = pINFOStats->AtqCtrs.TotalAllowedRequests;
        *pdwCounter++ = pINFOStats->AtqCtrs.TotalBlockedRequests;
        *pdwCounter++ = pINFOStats->AtqCtrs.TotalRejectedRequests;
        *pdwCounter++ = pINFOStats->AtqCtrs.CurrentBlockedRequests;
        *pdwCounter++ = pINFOStats->AtqCtrs.MeasuredBandwidth;

        //
        // File Handle Cache counters
        //
        *pdwCounter++ = pINFOStats->CacheCtrs.FilesCached;
        *pdwCounter++ = pINFOStats->CacheCtrs.TotalFilesCached;
        *pdwCounter++ = pINFOStats->CacheCtrs.FileHits;
        *pdwCounter++ = pINFOStats->CacheCtrs.FileMisses;
        *pdwCounter++ = pINFOStats->CacheCtrs.FileHits;
        *pdwCounter++ = ( pINFOStats->CacheCtrs.FileHits +
                        pINFOStats->CacheCtrs.FileMisses);
        *pdwCounter++ = pINFOStats->CacheCtrs.FileFlushes;

        // 64BIT BUGBUG: need to change the caller to expect int64 and then
        // put in the whole 64 bit value here
        // *((DWORDLONG *)pdwCounter) =
        *pdwCounter++ =
            (DWORD)pINFOStats->CacheCtrs.CurrentFileCacheSize;

        // pdwCounter += sizeof(DWORDLONG) / sizeof(*pdwCounter);

        // *((DWORDLONG *)pdwCounter) =
        *pdwCounter++ =
            (DWORD)pINFOStats->CacheCtrs.MaximumFileCacheSize;

        // pdwCounter += sizeof(DWORDLONG) / sizeof(*pdwCounter);

        *pdwCounter++ = pINFOStats->CacheCtrs.FlushedEntries;
        *pdwCounter++ = pINFOStats->CacheCtrs.TotalFlushed;

        //
        // URI Cache counters
        //
        *pdwCounter++ = pINFOStats->CacheCtrs.URICached;
        *pdwCounter++ = pINFOStats->CacheCtrs.TotalURICached;
        *pdwCounter++ = pINFOStats->CacheCtrs.URIHits;
        *pdwCounter++ = pINFOStats->CacheCtrs.URIMisses;
        *pdwCounter++ = pINFOStats->CacheCtrs.URIHits;
        *pdwCounter++ = ( pINFOStats->CacheCtrs.URIHits +
                        pINFOStats->CacheCtrs.URIMisses);
        *pdwCounter++ = pINFOStats->CacheCtrs.URIFlushes;
        *pdwCounter++ = pINFOStats->CacheCtrs.TotalURIFlushed;

        //
        // Blob Cache Counters
        //
        *pdwCounter++ = pINFOStats->CacheCtrs.BlobCached;
        *pdwCounter++ = pINFOStats->CacheCtrs.TotalBlobCached;
        *pdwCounter++ = pINFOStats->CacheCtrs.BlobHits;
        *pdwCounter++ = pINFOStats->CacheCtrs.BlobMisses;
        *pdwCounter++ = pINFOStats->CacheCtrs.BlobHits;
        *pdwCounter++ = ( pINFOStats->CacheCtrs.BlobHits +
                        pINFOStats->CacheCtrs.BlobMisses);
        *pdwCounter++ = pINFOStats->CacheCtrs.BlobFlushes;
        *pdwCounter++ = pINFOStats->CacheCtrs.TotalBlobFlushed;

        //
        //  Update arguments for return.
        //

        *lppData          = (PVOID)pdwCounter;
        *lpNumObjectTypes = 1;
        *lpcbTotalBytes   = DIFF((BYTE *)pdwCounter - (BYTE *)pINFODataDefinition);

        //
        //  Free the API buffer.
        //

        MIDL_user_free( (LPBYTE)pINFOStats );

        //
        //  Success!  Honest!!
        //
    } else {
        //
        //  Error retrieving statistics.
        //

        // if the server is down, we don't log an error.
		if ( !( neterr == RPC_S_SERVER_UNAVAILABLE ||
                neterr == RPC_S_UNKNOWN_IF         ||
                neterr == ERROR_SERVICE_NOT_ACTIVE ||
                neterr == RPC_S_CALL_FAILED_DNE ))
        {

            // log event
            ReportEvent (hEventLog, EVENTLOG_ERROR_TYPE,
                0, IIS_INFO_UNABLE_QUERY_IIS_INFO_DATA,
                (PSID)NULL, 0,
                sizeof (neterr), NULL,
                (PVOID)(&neterr));
        }

        cbRequired = sizeof(INFO_DATA_DEFINITION) +
                     SIZE_OF_INFO_PERFORMANCE_DATA;

        if( *lpcbTotalBytes < cbRequired )
        {
            //
            //  Nope.
            //

            *lpcbTotalBytes   = 0;
            *lpNumObjectTypes = 0;

            return ERROR_MORE_DATA;
        }

        // Attempt to atlest provide the definition 
        // for the counters.  This is so WMI can know 
        // that these counters exist.

        memmove( pINFODataDefinition,
                &INFODataDefinition,
                sizeof(INFO_DATA_DEFINITION) );

        ((PERF_OBJECT_TYPE*) pINFODataDefinition)->NumInstances = PERF_NO_INSTANCES;
        ((PERF_OBJECT_TYPE*) pINFODataDefinition)->TotalByteLength = cbRequired;

        // Copy in the actual data for global 
        memset ( (LPVOID) ( pINFODataDefinition + 1 ), 0, SIZE_OF_INFO_PERFORMANCE_DATA );

        // This is setting the size in the structure, it is the first
        // DWORD in the INFO_COUNTER_BLOCK.
        *((DWORD*) (pINFODataDefinition + 1)) = SIZE_OF_INFO_PERFORMANCE_DATA;

        *lpcbTotalBytes   = cbRequired;
        *lpNumObjectTypes = 1;
        *lppData = (LPBYTE) pINFODataDefinition + cbRequired;

    }

    return NO_ERROR;

}   // CollectINFOPerformanceData

/*******************************************************************

    NAME:       CloseINFOPerformanceData

    SYNOPSIS:   Terminates the performance counters.

    RETURNS:    DWORD - Win32 status code.

    HISTORY:
        KeithMo     07-Jun-1993 Created.

********************************************************************/
DWORD CloseINFOPerformanceData( VOID )
{
    //
    //  No real cleanup to do here.
    //

    if (--cOpens == 0) {
        if (hEventLog != NULL) DeregisterEventSource (hEventLog);
    }

    return NO_ERROR;

}   // CloseINFOPerformanceData
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\info\perfmon\infodata.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    infodata.h

    Extensible object definitions for the Internet Info Services Common
    counter objects & counters.


    FILE HISTORY:
        MuraliK     02-Jun-1995 Added Counters for Atq I/O requests
        SophiaC     16-Oct-1995 Info/Access Product Split

*/


#ifndef _INFODATA_H_
#define _INFODATA_H_

#define INFO_PERFORMANCE_KEY    INET_INFO_KEY "\\Performance"

//
//  This structure is used to ensure the first counter is properly
//  aligned.  Unfortunately, since PERF_COUNTER_BLOCK consists
//  of just a single DWORD, any LARGE_INTEGERs that immediately
//  follow will not be aligned properly.
//
//  This structure requires "natural" packing & alignment (probably
//  quad-word, especially on Alpha).  Ergo, keep it out of the
//  #pragma pack(4) scope below.
//

typedef struct _INFO_COUNTER_BLOCK
{
    PERF_COUNTER_BLOCK  PerfCounterBlock;
    LARGE_INTEGER       DummyEntryForAlignmentPurposesOnly;

} INFO_COUNTER_BLOCK;


//
//  The routines that load these structures assume that all fields
//  are DWORD packed & aligned.
//

#pragma pack(4)


//
//  Offsets within a PERF_COUNTER_BLOCK.
//

#define INFO_ATQ_TOTAL_ALLOWED_REQUESTS_OFFSET  (sizeof(INFO_COUNTER_BLOCK))

#define INFO_ATQ_TOTAL_BLOCKED_REQUESTS_OFFSET  \
                                  (INFO_ATQ_TOTAL_ALLOWED_REQUESTS_OFFSET + \
                                                    sizeof(DWORD))
#define INFO_ATQ_TOTAL_REJECTED_REQUESTS_OFFSET  \
                                  (INFO_ATQ_TOTAL_BLOCKED_REQUESTS_OFFSET + \
                                                    sizeof(DWORD))
#define INFO_ATQ_CURRENT_BLOCKED_REQUESTS_OFFSET  \
                 (INFO_ATQ_TOTAL_REJECTED_REQUESTS_OFFSET + sizeof(DWORD))

#define INFO_ATQ_MEASURED_BANDWIDTH_OFFSET  \
                 (INFO_ATQ_CURRENT_BLOCKED_REQUESTS_OFFSET + sizeof(DWORD))


#define INFO_CACHE_FILES_CACHED_OFFSET \
                 (INFO_ATQ_MEASURED_BANDWIDTH_OFFSET + sizeof(DWORD))

#define INFO_CACHE_TOTAL_FILES_CACHED_OFFSET \
                 (INFO_CACHE_FILES_CACHED_OFFSET + sizeof(DWORD))

#define INFO_CACHE_FILES_HIT_OFFSET \
                 (INFO_CACHE_TOTAL_FILES_CACHED_OFFSET + sizeof(DWORD))

#define INFO_CACHE_FILES_MISS_OFFSET \
                 (INFO_CACHE_FILES_HIT_OFFSET + sizeof(DWORD))

#define INFO_CACHE_FILE_RATIO_OFFSET \
                 (INFO_CACHE_FILES_MISS_OFFSET + sizeof(DWORD))

#define INFO_CACHE_FILE_RATIO_DENOM_OFFSET \
                 (INFO_CACHE_FILE_RATIO_OFFSET + sizeof(DWORD))

#define INFO_CACHE_FILE_FLUSHES_OFFSET \
                 (INFO_CACHE_FILE_RATIO_DENOM_OFFSET + sizeof(DWORD))

#define INFO_CACHE_CURRENT_FILE_CACHE_SIZE_OFFSET \
                 (INFO_CACHE_FILE_FLUSHES_OFFSET + sizeof(DWORD))

#define INFO_CACHE_MAXIMUM_FILE_CACHE_SIZE_OFFSET \
                 (INFO_CACHE_CURRENT_FILE_CACHE_SIZE_OFFSET + sizeof(DWORD))

#define INFO_CACHE_ACTIVE_FLUSHED_FILES_OFFSET \
                 (INFO_CACHE_MAXIMUM_FILE_CACHE_SIZE_OFFSET + sizeof(DWORD))

#define INFO_CACHE_TOTAL_FLUSHED_FILES_OFFSET \
                 (INFO_CACHE_ACTIVE_FLUSHED_FILES_OFFSET + sizeof(DWORD))



#define INFO_CACHE_URI_CACHED_OFFSET \
                 (INFO_CACHE_TOTAL_FLUSHED_FILES_OFFSET + sizeof(DWORD))

#define INFO_CACHE_TOTAL_URI_CACHED_OFFSET \
                 (INFO_CACHE_URI_CACHED_OFFSET + sizeof(DWORD))

#define INFO_CACHE_URI_HIT_OFFSET \
                 (INFO_CACHE_TOTAL_URI_CACHED_OFFSET + sizeof(DWORD))

#define INFO_CACHE_URI_MISS_OFFSET \
                 (INFO_CACHE_URI_HIT_OFFSET + sizeof(DWORD))

#define INFO_CACHE_URI_RATIO_OFFSET \
                 (INFO_CACHE_URI_MISS_OFFSET + sizeof(DWORD))

#define INFO_CACHE_URI_RATIO_DENOM_OFFSET \
                 (INFO_CACHE_URI_RATIO_OFFSET + sizeof(DWORD))

#define INFO_CACHE_URI_FLUSHES_OFFSET \
                 (INFO_CACHE_URI_RATIO_DENOM_OFFSET + sizeof(DWORD))

#define INFO_CACHE_TOTAL_FLUSHED_URI_OFFSET \
                 (INFO_CACHE_URI_FLUSHES_OFFSET + sizeof(DWORD))


#define INFO_CACHE_BLOB_CACHED_OFFSET \
                 (INFO_CACHE_TOTAL_FLUSHED_URI_OFFSET + sizeof(DWORD))

#define INFO_CACHE_TOTAL_BLOB_CACHED_OFFSET \
                 (INFO_CACHE_BLOB_CACHED_OFFSET + sizeof(DWORD))

#define INFO_CACHE_BLOB_HIT_OFFSET \
                 (INFO_CACHE_TOTAL_BLOB_CACHED_OFFSET + sizeof(DWORD))

#define INFO_CACHE_BLOB_MISS_OFFSET \
                 (INFO_CACHE_BLOB_HIT_OFFSET + sizeof(DWORD))

#define INFO_CACHE_BLOB_RATIO_OFFSET \
                 (INFO_CACHE_BLOB_MISS_OFFSET + sizeof(DWORD))

#define INFO_CACHE_BLOB_RATIO_DENOM_OFFSET \
                 (INFO_CACHE_BLOB_RATIO_OFFSET + sizeof(DWORD))

#define INFO_CACHE_BLOB_FLUSHES_OFFSET \
                 (INFO_CACHE_BLOB_RATIO_DENOM_OFFSET + sizeof(DWORD))

#define INFO_CACHE_TOTAL_FLUSHED_BLOB_OFFSET \
                 (INFO_CACHE_BLOB_FLUSHES_OFFSET + sizeof(DWORD))


#define SIZE_OF_INFO_PERFORMANCE_DATA \
                 (INFO_CACHE_TOTAL_FLUSHED_BLOB_OFFSET + sizeof(DWORD))

//
//  The counter structure returned.
//

typedef struct _INFO_DATA_DEFINITION
{
    PERF_OBJECT_TYPE            INFOObjectType;
    PERF_COUNTER_DEFINITION     INFOTotalAllowedRequests;
    PERF_COUNTER_DEFINITION     INFOTotalBlockedRequests;
    PERF_COUNTER_DEFINITION     INFOTotalRejectedRequests;
    PERF_COUNTER_DEFINITION     INFOCurrentRejectedRequests;
    PERF_COUNTER_DEFINITION     INFOMeasuredBandwidth;

    PERF_COUNTER_DEFINITION     INFOFilesCached;
    PERF_COUNTER_DEFINITION     INFOTotalFilesCached;
    PERF_COUNTER_DEFINITION     INFOFileHits;
    PERF_COUNTER_DEFINITION     INFOFileMisses;
    PERF_COUNTER_DEFINITION     INFOFileHitsRatio;
    PERF_COUNTER_DEFINITION     INFOFileHitsRatioDenom;
    PERF_COUNTER_DEFINITION     INFOFileFlushes;
    PERF_COUNTER_DEFINITION     INFOFileCurrentCacheSize;
    PERF_COUNTER_DEFINITION     INFOFileMaximumCacheSize;
    PERF_COUNTER_DEFINITION     INFOFileFlushedEntries;
    PERF_COUNTER_DEFINITION     INFOFileTotalFlushed;

    PERF_COUNTER_DEFINITION     INFOURICached;
    PERF_COUNTER_DEFINITION     INFOTotalURICached;
    PERF_COUNTER_DEFINITION     INFOURIHits;
    PERF_COUNTER_DEFINITION     INFOURIMisses;
    PERF_COUNTER_DEFINITION     INFOURIHitsRatio;
    PERF_COUNTER_DEFINITION     INFOURIHitsRatioDenom;
    PERF_COUNTER_DEFINITION     INFOURIFlushes;
    PERF_COUNTER_DEFINITION     INFOURITotalFlushed;

    PERF_COUNTER_DEFINITION     INFOBlobCached;
    PERF_COUNTER_DEFINITION     INFOTotalBlobCached;
    PERF_COUNTER_DEFINITION     INFOBlobHits;
    PERF_COUNTER_DEFINITION     INFOBlobMisses;
    PERF_COUNTER_DEFINITION     INFOBlobHitsRatio;
    PERF_COUNTER_DEFINITION     INFOBlobHitsRatioDenom;
    PERF_COUNTER_DEFINITION     INFOBlobFlushes;
    PERF_COUNTER_DEFINITION     INFOBlobTotalFlushed;

} INFO_DATA_DEFINITION;


extern  INFO_DATA_DEFINITION    INFODataDefinition;


#define NUMBER_OF_INFO_COUNTERS ((sizeof(INFO_DATA_DEFINITION) -        \
                                  sizeof(PERF_OBJECT_TYPE)) /           \
                                  sizeof(PERF_COUNTER_DEFINITION))


//
//  Restore default packing & alignment.
//

#pragma pack()


#endif  // _INFODATA_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\info\server\info_srv_stub.c ===
#include "info_srv.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\info\server\main.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1994                **/
/**********************************************************************/

/*
    main.cxx

        Library initialization for infocomm.dll  --
           Internet Information Services Common dll.

    FILE HISTORY:
        Johnl       06-Oct-1994 Created.
        MuraliK     15-Nov-1994
               Modified to include new service list initializations

        MuraliK     21-Feb-1995
               Added init and cleanup of debugging variables
        MuraliK     16-May-1995
               Added code to read debug flags.
        MuraliK     6-June-1995
               Initialized Atq Bandwidth Level, reading values from registry

        MuraliK    16-Oct-1995   Tailored it for infocom.dll
*/

#include <tcpdllp.hxx>
#include <atq.h>
#include <info_srv.h>
#include <inetsvcs.h>
#include <lonsi.hxx>
#include <mb.hxx>
#include <irtlmisc.h>

PISRPC  g_pIsrpc = NULL;
HINSTANCE g_hDll = NULL;
LONG    g_cInitializers = 0;
CRITICAL_SECTION g_csDllInitLock;

DECLARE_PLATFORM_TYPE();

enum {
    INIT_NONE,
    INIT_DEBUG_PRINT,
    INIT_ENTRY_POINTS,
    INIT_SVC_LOC,
    INIT_IISRTL,
    INIT_ATQ,
    INIT_SECURITY,
    INIT_SVC_INFO,
    INIT_METABASE,
    INIT_TSUNAMI,
    INIT_SCAVENGER,
    INIT_SVC_RPC,
    INIT_RDNS,
    INIT_MIME_MAP,
    INIT_CONFIG_FROM_REG,
    INIT_LOGGING,
    INIT_ENDPOINT_UTILITIES
} g_InitCommonDllState = INIT_NONE;

//
// externs
//

DWORD
InitGlobalConfigFromReg(
    VOID
    );

#ifdef _NO_TRACING_
DWORD
GetDebugFlagsFromReg(
        IN LPCTSTR pszRegEntry
        );
#endif


extern "C"
BOOL WINAPI DllMain( HINSTANCE hDll, DWORD dwReason, LPVOID lpvReserved )
{
    BOOL  fReturn = TRUE;

    switch ( dwReason )
    {
    case DLL_PROCESS_ATTACH:  {

        CREATE_DEBUG_PRINT_OBJECT( "infocomm.dll");

        LOAD_DEBUG_FLAGS_FROM_REG_STR(INET_INFO_PARAMETERS_KEY, 0);

        g_hDll = hDll;

        //
        // Initialize the platform type
        //

        (VOID)IISGetPlatformType( );

        DBG_REQUIRE( DisableThreadLibraryCalls( hDll ) );

        INITIALIZE_CRITICAL_SECTION( &g_csDllInitLock );
        break;
    }

    case DLL_PROCESS_DETACH:

        DELETE_DEBUG_PRINT_OBJECT();
        DeleteCriticalSection( &g_csDllInitLock );
    break;

    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
    default:
        break ;
    }

    return ( fReturn);

}  // main()


BOOL
CallInitFunctions(
    VOID
    )
/*++
    Description:

        Call all the init functions.

    Return value:

        TRUE of all init's succeed.
--*/
{
    DWORD err = NO_ERROR;

    g_InitCommonDllState = INIT_NONE;

#ifdef _NO_TRACING_
    if (!VALID_DEBUG_PRINT_OBJECT()) goto error;
#endif
    g_InitCommonDllState = INIT_DEBUG_PRINT;

    if (!GetDynamicEntryPoints()) goto error;
    g_InitCommonDllState = INIT_ENTRY_POINTS;

    if (!pfnInitSvcLoc()) goto error;
    g_InitCommonDllState = INIT_SVC_LOC;

    if (!InitializeIISRTL()) goto error;
    g_InitCommonDllState = INIT_IISRTL;

    if (!AtqInitialize(0)) goto error;
    g_InitCommonDllState = INIT_ATQ;

    err = InitializeSecurity(g_hDll);
    if (err != NO_ERROR) goto error;
    g_InitCommonDllState = INIT_SECURITY;

    if (!IIS_SERVICE::InitializeServiceInfo()) goto error;
    g_InitCommonDllState = INIT_SVC_INFO;

    if (!IIS_SERVICE::InitializeMetabaseComObject()) goto error;
    g_InitCommonDllState = INIT_METABASE;

    if (!Tsunami_Initialize()) goto error;
    g_InitCommonDllState = INIT_TSUNAMI;

    if (!InitializeCacheScavenger()) goto error;
    g_InitCommonDllState = INIT_SCAVENGER;

    if (!IIS_SERVICE::InitializeServiceRpc(
                                 INET_INFO_SERVICE_NAME,
                                 inetinfo_ServerIfHandle
                                 )
       ) goto error;
    g_InitCommonDllState = INIT_SVC_RPC;

    if (!InitRDns()) goto error;
    g_InitCommonDllState = INIT_RDNS;

    if (!InitializeMimeMap(INET_INFO_PARAMETERS_KEY)) goto error;
    g_InitCommonDllState = INIT_MIME_MAP;

    err = InitGlobalConfigFromReg();
    if (err != NO_ERROR) goto error;
    g_InitCommonDllState = INIT_CONFIG_FROM_REG;

    err = LOGGING::Initialize();
    if (err != NO_ERROR) goto error;
    g_InitCommonDllState = INIT_LOGGING;

    if (!InitializeEndpointUtilities()) goto error;
    g_InitCommonDllState = INIT_ENDPOINT_UTILITIES;

    return TRUE;
error:

    if (err != NO_ERROR) {
        SetLastError(err);
    }

    return FALSE;
}

VOID
CallUninitFunctions(
    VOID
    )
/*++
    Description:

        Call all the uninit functions.

    Return value:

        None.
--*/
{
    switch (g_InitCommonDllState) {
    case INIT_ENDPOINT_UTILITIES:
        TerminateEndpointUtilities();

    case INIT_LOGGING:
        LOGGING::Terminate();

    case INIT_CONFIG_FROM_REG:
    case INIT_MIME_MAP:
        CleanupMimeMap();

    case INIT_RDNS:
        TerminateRDns();

    case INIT_SVC_RPC:
        IIS_SERVICE::CleanupServiceRpc();

    case INIT_SCAVENGER:
        TerminateCacheScavenger();

    case INIT_TSUNAMI:
        Tsunami_Terminate();

    case INIT_METABASE:
        IIS_SERVICE::CleanupMetabaseComObject();

    case INIT_SVC_INFO:
        IIS_SERVICE::CleanupServiceInfo();

    case INIT_SECURITY:
        TerminateSecurity();

    case INIT_ATQ:
        if ( !AtqTerminate()) {
            DBGPRINTF(( DBG_CONTEXT,
                        " ATQ Terminate Failed with Error %d\n", GetLastError()
                        ));
            DBGPRINTF(( DBG_CONTEXT, " ATQ Terminate Failed\n"));
        }

    case INIT_SVC_LOC:
        pfnTerminateSvcLoc();

    case INIT_IISRTL:
        TerminateIISRTL();

    case INIT_ENTRY_POINTS:
        FreeDynamicLibraries();

    case INIT_DEBUG_PRINT:
    case INIT_NONE:
        /* no complaints Mr. Compiler */ break;
    }

}



BOOL
InitCommonDlls(
    VOID
    )
/*++
    Description:

        DLL Init and uninit functions that don't have to worry about the
        peb lock being taken during PROCESS_ATTACH/DETACH.

--*/
{
    BOOL fReturn = TRUE;
    RECT rect;

    DBGPRINTF(( DBG_CONTEXT,
                "[InitCommonDlls] Entered - Initialization count %d\n",
                g_cInitializers ));

    EnterCriticalSection( &g_csDllInitLock );

    //
    //  Are we already initialized?
    //

    if ( g_cInitializers ) {

        g_cInitializers++;
        LeaveCriticalSection( &g_csDllInitLock );

        return TRUE;
    }

    INITIALIZE_PLATFORM_TYPE();

    if ( !CallInitFunctions() )
    {
        DWORD err;

        IIS_PRINTF((buff,"Initializing infocomm.dll module failed\n"));

        err = GetLastError();
        CallUninitFunctions();
        SetLastError(err);
        fReturn = FALSE;

    } else {

        //
        // Call a windows API that will cause windows server side thread to
        // be created for tcpsvcs.exe. This prevents a severe winsrv memory
        // leak when spawning processes and
        // gives a perf boost so the windows
        // console isn't brought up and torn down each time.   :(
        //

        (VOID) AdjustWindowRectEx( &rect,
                                   0,
                                   FALSE,
                                   0 );

        // fReturn already init to TRUE
    }

    //
    //  Only inc the init count if we initialized successfully
    //

    if ( fReturn ) {

        g_cInitializers++;
    }

    LeaveCriticalSection( &g_csDllInitLock );

    return fReturn;
}

BOOL
TerminateCommonDlls(
    VOID
    )
{
    MB     mb( (IMDCOM*) IIS_SERVICE::QueryMDObject() );

    DBG_ASSERT( g_cInitializers > 0 );

    DBGPRINTF(( DBG_CONTEXT,
                "[TerminateCommonDlls] Init Count = %d\n",
                g_cInitializers ));

    EnterCriticalSection( &g_csDllInitLock );

    if ( --g_cInitializers )
    {
        LeaveCriticalSection( &g_csDllInitLock );
        return TRUE;
    }

    //
    // When we clean up, make sure the metabase has been saved,
    // so no recent modifications get lost.
    //

    DBGPRINTF(( DBG_CONTEXT,
                "[TerminateCommonDlls] Saving Metabase\n" ));

    mb.Save();


    DBGPRINTF(( DBG_CONTEXT,
                "[TerminateCommonDlls] Terminating dlls\n" ));


    CallUninitFunctions();

    LeaveCriticalSection( &g_csDllInitLock );

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\log\comlog\cofact.cxx ===
/*++

   Copyright    (c)    1997    Microsoft Corporation

   Module  Name :
        cofact.cxx

   Abstract:
        class factory

   Author:

       Johnson Apacible (JohnsonA)      02-April-1997


--*/

#include "precomp.hxx"
#define INITGUID
#undef DEFINE_GUID      // Added for NT 5 migration

#include "comlog.hxx"

ULONG g_dwRefCount = 0;

CINETLOGSrvFactory::CINETLOGSrvFactory(
    VOID
    )
{
    m_dwRefCount=0;
}

CINETLOGSrvFactory::~CINETLOGSrvFactory(
    VOID
    )
{
}

HRESULT
CINETLOGSrvFactory::CreateInstance(
    IUnknown *pUnkOuter,
    REFIID   riid,
    void **  ppObject
    )
{
    HRESULT hresReturn = E_NOINTERFACE;

    if (pUnkOuter != NULL) 
    {
        return CLASS_E_NOAGGREGATION;
    }

    if (m_ClsId == CLSID_InetLogPublic)
    {
        CInetLogPublic *pInetLogPublic = new CInetLogPublic();

        if( pInetLogPublic == NULL ) 
        {
            hresReturn = E_OUTOFMEMORY;
        } 
        else 
        {
            hresReturn = pInetLogPublic->QueryInterface(riid, ppObject);

            if( FAILED(hresReturn) ) 
            {
                DBGPRINTF( (DBG_CONTEXT,
                    "[CINETLOGSrvFactory::CreateInstance] no I/F\n"));
                delete pInetLogPublic;
            }
        }
    }
    else if (m_ClsId == CLSID_InetLogInformation)
    {
        CInetLogInformation *pInetLogInfo = new CInetLogInformation();

        if( pInetLogInfo == NULL ) 
        {
            hresReturn = E_OUTOFMEMORY;
        } 
        else 
        {
            hresReturn = pInetLogInfo->QueryInterface(riid, ppObject);

            if( FAILED(hresReturn) ) 
            {
                DBGPRINTF( (DBG_CONTEXT,
                    "[CINETLOGSrvFactory::CreateInstance] no I/F\n"));
                delete pInetLogInfo;
            }
        }
    }
    
    return hresReturn;
}

HRESULT
CINETLOGSrvFactory::LockServer(
    IN BOOL fLock
    )
{
    if (fLock) {
        InterlockedIncrement((long *)&g_dwRefCount);
    } else {
        InterlockedDecrement((long *)&g_dwRefCount);
    }
    return NO_ERROR;
}

HRESULT
CINETLOGSrvFactory::QueryInterface(
    REFIID riid,
    void **ppObject
    )
{
    if (riid==IID_IUnknown || riid == IID_IClassFactory) {
        *ppObject = (IClassFactory *) this;
    }
    else {
        return E_NOINTERFACE;
    }

    AddRef();
    return NO_ERROR;
}

ULONG
CINETLOGSrvFactory::AddRef(
    )
{
    DWORD dwRefCount;
    dwRefCount = InterlockedIncrement((long *)&m_dwRefCount);
    return dwRefCount;
}

ULONG
CINETLOGSrvFactory::Release()
{
    DWORD dwRefCount;
    dwRefCount = InterlockedDecrement((long *)&m_dwRefCount);
    if (dwRefCount == 0) {
        delete this;
    }
    return dwRefCount;
}




STDAPI
DllGetClassObject(
    REFCLSID rclsid,
    REFIID riid,
    void** ppObject)
{
    *ppObject = NULL;

    if ((rclsid != CLSID_InetLogInformation) &&
        (rclsid != CLSID_InetLogPublic)
       )
    {
        DBGPRINTF( (DBG_CONTEXT, "[CINETLOGSrvFactory::DllGetClassObject] bad class\n" ) );
        return CLASS_E_CLASSNOTAVAILABLE;
    }

    CINETLOGSrvFactory *pFactory = new CINETLOGSrvFactory;

    if( pFactory == NULL )
    {
        return E_OUTOFMEMORY;
    }

    pFactory->m_ClsId = rclsid;
    
    if (FAILED(pFactory->QueryInterface(riid, ppObject))) 
    {
        delete pFactory;
        DBGPRINTF( (DBG_CONTEXT, "[CINETLOGSrvFactory::DllGetClassObject] no I/F\n" ) );
        return E_INVALIDARG;
    }
    return NO_ERROR;
}


HRESULT
_stdcall
DllCanUnloadNow(
    VOID
    )
{

   if (g_dwRefCount != 0) {
        return S_FALSE;
    } else {
        return S_OK;
    }
} // DllCanUnloadNow


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\info\test\infotest.cxx ===
/*++

   Copyright    (c)    1994    Microsoft Corporation

   Module  Name :
        infotest.cxx

   Abstract:
        main program to test the working of RPC APIs for Internet Services

   Author:

           Murali R. Krishnan    ( MuraliK )     23-Jan-1996

   Project:

           Internet Services Common RPC Client.

   Functions Exported:

   Revision History:

--*/

/************************************************************
 *     Include Headers
 ************************************************************/

# include <windows.h>
# include <lm.h>
# include <stdio.h>
# include <stdlib.h>
# include "iisinfo.h"
# include "apiutil.h"

WCHAR Server[255];
DWORD Level = 1;

//
//  From tsunami.hxx
//


void
get( DWORD instance)
{
    DWORD err;

    LPINET_INFO_CONFIG_INFO buffer = NULL;

    err = InetInfoGetAdminInformation( Server,
                                       INET_HTTP_SVC_ID,
                                       &buffer );
    printf("err %d buffer %x\n",err,buffer);
    if ( err == NO_ERROR ) {

        DWORD i;

        printf( "dwConnectionTime =     %8d\n", buffer->dwConnectionTimeout );
        printf( "dwAuthentication =   0x%08x\n", buffer->dwAuthentication );
        printf( "Port             =     %8d\n", (DWORD) buffer->sPort);

        printf("vroot 0x%08x\n",buffer->VirtualRoots);
        printf("vr entries is %d\n",buffer->VirtualRoots->cEntries);

        for (i=0 ; i < buffer->VirtualRoots->cEntries ;i++ ) {
            printf("\nroot %S\n",
                buffer->VirtualRoots->aVirtRootEntry[i].pszRoot);
            printf("directory %S\n",
                buffer->VirtualRoots->aVirtRootEntry[i].pszDirectory);
            printf("account %S\n",
                buffer->VirtualRoots->aVirtRootEntry[i].pszAccountName);
            printf("mask %x\n",
                buffer->VirtualRoots->aVirtRootEntry[i].dwMask);
            printf("error %x\n",
                buffer->VirtualRoots->aVirtRootEntry[i].dwError);

        }

        midl_user_free( buffer );
    }
}

void
getftp( DWORD instance)
{
    DWORD err;
    DWORD numEntries;
    LPIIS_USER_INFO_1 info;
    LPIIS_USER_INFO_1 scan;
    IN_ADDR addr;

    err = IISEnumerateUsers(
              Server,
              1,
              INET_FTP_SVC_ID,
              instance,
              &numEntries,
              (LPBYTE *)&info
              );

    printf( "err %lu, buffer %x\n", err, info );

    if( err == NO_ERROR ) {

        printf( "%lu connected users\n", numEntries );

        for( scan = info ; numEntries > 0 ; numEntries--, scan++ ) {

            addr.s_addr = (u_long)scan->inetHost;

            printf(
                "idUser     = %lu\n"
                "pszUser    = %S\n"
                "fAnonymous = %lu\n"
                "inetHost   = %s\n"
                "tConnect   = %lu\n"
                "\n",
                scan->idUser,
                scan->pszUser,
                scan->fAnonymous,
                inet_ntoa( addr ),
                scan->tConnect
                );

        }

        midl_user_free( info );
        
    }

}

void
getweb( DWORD instance)
{
    printf( "Not supported\n" );
#if 0
    DWORD err;

    if (instance == 0 ) {
        instance = INET_INSTANCE_ROOT;
    }

    if ( Level == 1 )
    {
        W3_CONFIG_INFO_1 * buffer = NULL;
        err = W3GetAdminInformation2(
                                Server,
                                Level,
                                instance,
                                (LPBYTE*)&buffer
                                );


        printf("err %d buffer 0x%08x\n",err,buffer);

        if ( err == NO_ERROR ) {

            printf( "csecCGIScriptTimeout    =   %8d\n", buffer->csecCGIScriptTimeout );
            printf( "csecPoolODBCConnections =   %8d\n", buffer->csecPoolODBCConnections );
            printf( "fCacheISAPIApps         =   %s\n", buffer->fCacheISAPIApps ? "TRUE" : "FALSE" );
            printf( "fUseKeepAlives          =   %s\n", buffer->fUseKeepAlives ? "TRUE" : "FALSE" );
        }
    }
#endif
}

void
set( DWORD instance )
{
    DWORD err;

    LPINET_INFO_CONFIG_INFO buffer = NULL;

    err = InetInfoGetAdminInformation( Server,
                                       INET_HTTP_SVC_ID,
                                       &buffer );

    printf("err %d buffer %x\n",err,buffer);
    if ( err == NO_ERROR ) {
        printf("Port is %d\n",buffer->sPort);
        printf("vroot %x\n",buffer->VirtualRoots);
        printf("vr entries is %d\n",buffer->VirtualRoots->cEntries);
    } else {
        return;
    }

    err = InetInfoSetAdminInformation( Server,
                                       INET_HTTP_SVC_ID,
                                       buffer );

    printf("err %d \n",err);
    if ( err == NO_ERROR ) {
        get(instance);
    }
    midl_user_free( buffer );
}

void
setvr( DWORD instance )
{
#if 1
    printf( "Not supported\n" );
#else
    DWORD err;
    IIS_INSTANCE_INFO_1 newt;

    ZeroMemory(&newt,sizeof(IIS_INSTANCE_INFO_1));

    LPIIS_INSTANCE_INFO_1 buffer = NULL;
    err = IISGetAdminInformation(
                            Server,
                            Level,
                            INET_HTTP_SVC_ID,
                            instance,
                            (LPBYTE*)&buffer
                            );


    printf("err %d buffer %x\n",err,buffer);
    if ( err == NO_ERROR ) {
        printf("Port is %d\n",buffer->sPort);
        printf("vroot %x\n",buffer->VirtualRoots);
        printf("vr entries is %d\n",buffer->VirtualRoots->cEntries);
    } else {
        return;
    }

    newt.FieldControl = FC_INET_INFO_VIRTUAL_ROOTS;
    newt.VirtualRoots = buffer->VirtualRoots;
    buffer->VirtualRoots->aVirtRootEntry[1].pszDirectory = L"d:\\nt40";

    err = IISSetAdminInformation(
                            Server,
                            Level,
                            INET_HTTP_SVC_ID,
                            instance,
                            (LPBYTE)&newt
                            );

    printf("err %d \n",err);
    if ( err == NO_ERROR ) {
        get(instance);
    }
    midl_user_free( buffer );
#endif
}


void
enumer()
{
#if 1
    printf( "Not Supported\n" );
#else
    DWORD err;
    DWORD nRead = 0;
    DWORD i;
    LPIIS_INSTANCE_INFO_2 buffer = NULL;
    LPIIS_INSTANCE_INFO_2 p;

    //
    // set the port
    //

    err = IISEnumerateInstances(
                            Server,
                            Level,
                            INET_HTTP_SVC_ID,
                            &nRead,
                            (LPBYTE*)&buffer
                            );


    printf("err %d read %d buffer %x \n",err,nRead, buffer);
    if ( err == NO_ERROR ) {

        for (i=0,p=buffer; i < nRead;i++,p++ ) {
            printf("instance %d  state %d comment %S\n",
            p->dwInstance, p->dwServerState, p->lpszServerComment);
        }
    }
#endif
}

void
add( PDWORD instance )
{
#if 1
    printf( "not supported\n" );
#else
    DWORD err;
    DWORD nRead = 0;
    LPIIS_INSTANCE_INFO_1 buffer = NULL;
    LPW3_CONFIG_INFO_1 w3Buffer = NULL;

    err = IISGetAdminInformation(
                            Server,
                            Level,
                            INET_HTTP_SVC_ID,
                            INET_INSTANCE_ROOT,
                            (LPBYTE*)&buffer
                            );


    printf("IISGetAdminInfo err %d buffer %x\n",err,buffer);
    if ( err != NO_ERROR ) {
        return;
    }

    printf("password %ws\n",buffer->szAnonPassword);
    printf("instance %x\n",buffer->dwInstance);
    printf("port %x\n",buffer->sPort);
    printf("vroot %x\n",buffer->VirtualRoots);

    if ( buffer->VirtualRoots != NULL ) {
        printf("vr entries is %d\n",buffer->VirtualRoots->cEntries);
    }

    err = W3GetAdminInformation2(
                            Server,
                            Level,
                            INET_INSTANCE_ROOT,
                            (LPBYTE*)&w3Buffer
                            );


    printf("W3GetAdminInfo err %d w3Buffer %x\n",err,w3Buffer);
    if ( err != NO_ERROR ) {
        midl_user_free( buffer );
        return;
    }

    //
    // set the port
    //

    buffer->sPort = 8081;

    err = IISAddInstance(
                        Server,
                        INET_HTTP_SVC_ID,
                        1,
                        (LPBYTE)buffer,
                        1,
                        (LPBYTE)w3Buffer,
                        instance
                        );

    printf("IISAddInstance err %d InstanceId %d\n",err,*instance);
#endif
} // Add instance


void
del( DWORD instance )
{
#if 1
    printf( "not supported\n" );
#else
    DWORD err;

    err = IISDeleteInstance(
                    Server,
                    INET_HTTP_SVC_ID,
                    instance
                    );

    printf("err %d\n",err);
#endif
}

void
ctrl( DWORD instance, DWORD Code )
{
#if 1
    printf(" not supported\n" );
#else
    DWORD err;

    err = IISControlInstance(
                    Server,
                    INET_HTTP_SVC_ID,
                    instance,
                    Code
                    );

    printf("err %d\n",err);
#endif
}

void
flush( DWORD Service )
{
    DWORD err;

    err = InetInfoFlushMemoryCache( NULL, 4 );  // '4' is the webserver
    printf("Flush Memory Cache returned %d\n", err );
}

int __cdecl
main( int argc, char * argv[])
{
    CHAR op;
    DWORD instance;
    DWORD iArg = 1;

    if ( argc < 2 ) {
        printf( "infotest.exe [Server] [add | get | enum | web | ... ] \n" );
        printf( "cacheflush to flush the object cache\n" );
        printf( "only add and get are currently supported\n" );
        return 1;
    }


    if ( *argv[iArg] == '\\' ){
        wsprintfW( Server, L"%S", argv[iArg++] );
    }

    if ( argc > 2 ){
        op = argv[iArg++][0];
        printf("operation %c\n",op);
    }else{
        op = 'e';
    }

    if ( argc > 4 ){
        Level = atoi(argv[iArg+1]);
        printf("Level %d\n", Level);
    } else {
        Level = 1;
    }

    switch (op) {
    case 'a':
        add( &instance );
        break;

    case 'b':
        instance = atoi(argv[iArg]);
        set( instance );
        break;

    case 'v':
        instance = atoi(argv[iArg]);
        setvr( instance );
        break;

    case 'd':
        if ( argc > 2 ) {
            instance = atoi(argv[iArg]);
            printf("instance %d\n",instance);
            del(instance);
        }
        break;

    case 'e':
        enumer();
        break;

    case 'c':
        flush( 0 );
        break;
        

#if 0
    case 's':
        if ( argc > 2 ) {
            instance = atoi(argv[iArg]);
            printf("starting instance %d\n",instance);
            ctrl(instance,IIS_CONTROL_CODE_START);
        }
        break;

    case 'p':
        if ( argc > 2 ) {
            instance = atoi(argv[iArg]);
            printf("instance %d\n",instance);
            ctrl(instance,IIS_CONTROL_CODE_PAUSE);
        }
        break;

    case 'c':
        if ( argc > 2 ) {
            instance = atoi(argv[iArg]);
            printf("instance %d\n",instance);
            ctrl(instance,IIS_CONTROL_CODE_CONTINUE);
        }
        break;

    case 'x':
        if ( argc > 2 ) {
            instance = atoi(argv[iArg]);
            printf("instance %d\n",instance);
            ctrl(instance,IIS_CONTROL_CODE_STOP);
        }
        break;
#endif

    case 'g':
        get(0);
        break;

    case 'w':
        if ( argc > 2 ) {
            instance = atoi(argv[iArg]);
            printf("instance %d\n",instance);
            getweb(instance);
        }
        break;

    case 'f':
        if ( argc > 2 ) {
            instance = atoi(argv[iArg]);
            printf("instance %d\n",instance);
            getftp(instance);
        }
        break;

    default:
        printf( "unknown command\n" );
        break;
    }
    return(0);
} // main()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\info\server\rpcsupp.cxx ===
/*++
   Copyright    (c)    1994        Microsoft Corporation

   Module Name:
        rpcsupp.cxx

   Abstract:

        This module contains the server side RPC admin APIs


   Author:

        John Ludeman    (johnl)     02-Dec-1994

   Project:

        Internet Servers Common Server DLL

--*/

//
//  Include Headers
//

#include <tcpdllp.hxx>
#include <tsunami.hxx>

extern "C" {
#include <info_srv.h>
};

#include <atq.h>
#include "inetreg.h"
#include <iistypes.hxx>
#include <iiscnfg.h>
#include <imd.h>
#include <inetreg.h>
#include <mb.hxx>

//
// number of capabilities DWORD
//

#define NUM_CAPABILITIES_FLAGS      1



NET_API_STATUS
NET_API_FUNCTION
R_InetInfoGetVersion(
    IN  LPWSTR   pszServer OPTIONAL,
    IN  DWORD    dwReserved,
    OUT DWORD *  pdwVersion
    )
/*++

   Description

     Returns the version of the TCP server package.  Primarily intended to
     detect downlevel servers for future versions of the admin tool.

   Arguments:

      pszServer - unused
      dwReserved - unused (may eventually indicate an individual server)
      pdwVersion - Receives the major version in the hi-word and the minor
          version in the low word

   Note:

--*/
{
    *pdwVersion = MAKELONG( IIS_VERSION_MAJOR, IIS_VERSION_MINOR );

    return NO_ERROR;
} // R_InetInfoGetVersion



NET_API_STATUS
NET_API_FUNCTION
R_InetInfoGetServerCapabilities(
    IN  LPWSTR   pszServer OPTIONAL,
    IN  DWORD    dwReserved,
    OUT LPINET_INFO_CAPABILITIES_STRUCT *ppCap
    )
/*++

   Description

     Returns the information about the server and its capabilities.

   Arguments:

      pszServer - unused
      dwReserved - unused (may eventually indicate an individual server)
      ppCap - Receives the INET_INFO_CAPABILITIES structure


--*/
{
    DWORD err = NO_ERROR;
    LPINET_INFO_CAPABILITIES_STRUCT pCap;

    IF_DEBUG( DLL_RPC) {

        DBGPRINTF( ( DBG_CONTEXT,
                   " Entering R_InetInfoGetServerCapabilities()\n" ));
    }

    if ( ( err = TsApiAccessCheck( TCP_QUERY_ADMIN_INFORMATION)) != NO_ERROR) {

        IF_DEBUG( DLL_RPC) {

            DBGPRINTF( ( DBG_CONTEXT,
                        " TsApiAccessCheck() Failed. Error = %u\n", err));
        }

    } else {

        OSVERSIONINFO verInfo;
        DWORD   bufSize =
                    sizeof(INET_INFO_CAPABILITIES_STRUCT) +
                    NUM_CAPABILITIES_FLAGS * sizeof(INET_INFO_CAP_FLAGS);

        pCap = (LPINET_INFO_CAPABILITIES_STRUCT) MIDL_user_allocate( bufSize );
        *ppCap = pCap;

        if ( pCap == NULL ) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        ZeroMemory(pCap, bufSize);
        pCap->CapFlags = (LPINET_INFO_CAP_FLAGS)
            ((PCHAR)pCap + sizeof(INET_INFO_CAPABILITIES));

        //
        // Fill in the version and product type
        //

        pCap->CapVersion = 1;
        switch (IISGetPlatformType()) {
        case PtNtServer:
            pCap->ProductType = INET_INFO_PRODUCT_NTSERVER;
            break;
        case PtNtWorkstation:
            pCap->ProductType = INET_INFO_PRODUCT_NTWKSTA;
            break;
        default:
            pCap->ProductType = INET_INFO_PRODUCT_UNKNOWN;
        }

        //
        // Fill in GetVersionEx information
        //

        verInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
        if ( GetVersionEx( &verInfo ) ) {
            pCap->BuildNumber = verInfo.dwBuildNumber;
        } else {
            pCap->BuildNumber = 0;
        }

        pCap->MajorVersion = IIS_VERSION_MAJOR;
        pCap->MinorVersion = IIS_VERSION_MINOR;

        //
        // Fill in the capabilities
        //

        pCap->NumCapFlags = NUM_CAPABILITIES_FLAGS;

        pCap->CapFlags[0].Mask = IIS_CAP1_ALL;

        if ( pCap->ProductType == INET_INFO_PRODUCT_NTSERVER ) {

            //
            //  For downlevel purposes, we take out the multi-instance and virtual
            //  sever support since the downlevel version of the RPC api
            //  doesn't support those concepts.
            //

            pCap->CapFlags[0].Flag = (IIS_CAP1_NTS &
                                    ~(IIS_CAP1_MULTIPLE_INSTANCE | IIS_CAP1_VIRTUAL_SERVER));

        } else {

            pCap->CapFlags[0].Flag = IIS_CAP1_NTW;
        }
    }

    return ( err );

} // R_InetInfoGetServerCapabilities

NET_API_STATUS
NET_API_FUNCTION
R_InetInfoSetGlobalAdminInformation(
    IN  LPWSTR                     pszServer OPTIONAL,
    IN  DWORD                      dwReserved,
    IN  INETA_GLOBAL_CONFIG_INFO * pConfig
    )
/*++

   Description

     Sets the global service admin information

   Arguments:

      pszServer - unused
      dwReserved
      pConfig - Admin information to set

   Note:

--*/
{
    DWORD err;
    HKEY  hkey = NULL;
    HKEY  CacheKey = NULL;
    HKEY  FilterKey = NULL;
    DWORD dwDummy;

    if ( ( err = TsApiAccessCheck( TCP_SET_ADMIN_INFORMATION)) != NO_ERROR) {

       IF_DEBUG( DLL_RPC) {

            DBGPRINTF( ( DBG_CONTEXT,
                        " TsApiAccessCheck() Failed. Error = %u\n", err));
       }

       return err;
    }

    err = ERROR_NOT_SUPPORTED;

    return err;
} // R_InetInfoSetGlobalAdminInformation



NET_API_STATUS
NET_API_FUNCTION
R_InetInfoGetGlobalAdminInformation(
    IN  LPWSTR                       pszServer OPTIONAL,
    IN  DWORD                        dwReserved,
    OUT LPINETA_GLOBAL_CONFIG_INFO * ppConfig
    )
/*++

   Description

     Gets the global service admin information

   Arguments:

      pszServer - unused
      dwReserved
      ppConfig - Receives current operating values of the server

   Note:

--*/
{
    DWORD err = NO_ERROR;
    INETA_GLOBAL_CONFIG_INFO * pConfig;

    IF_DEBUG( DLL_RPC) {

        DBGPRINTF( ( DBG_CONTEXT,
                   " Entering R_InetInfoGetGlobalAdminInformation()\n" ));
    }

    if ( ( err = TsApiAccessCheck( TCP_QUERY_ADMIN_INFORMATION)) != NO_ERROR) {

        IF_DEBUG( DLL_RPC) {

            DBGPRINTF( ( DBG_CONTEXT,
                        " TsApiAccessCheck() Failed. Error = %u\n", err));
        }

    } else {

        *ppConfig = (INETA_GLOBAL_CONFIG_INFO *) MIDL_user_allocate(
                                        sizeof( INET_INFO_GLOBAL_CONFIG_INFO ));

        if ( !*ppConfig ) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        pConfig = *ppConfig;

        memset( pConfig, 0, sizeof( *pConfig ));

        pConfig->FieldControl = FC_GINET_INFO_ALL;

        pConfig->cbMemoryCacheSize = 0;
        pConfig->BandwidthLevel    = (DWORD)AtqGetInfo( AtqBandwidthThrottle);

        if( err != NO_ERROR ) {

            //
            // clean up the allocated memory
            //

            MIDL_user_free( pConfig );

        } else {

            *ppConfig = pConfig;

        }
    }

    IF_DEBUG( DLL_RPC) {

         DBGPRINTF(( DBG_CONTEXT,
                   "R_InetInfoGetGlobalAdminInformation() returns Error = %u \n",
                    err ));
    }

    return ( err );

} // R_InetInfoGetGlobalAdminInformation()




NET_API_STATUS
NET_API_FUNCTION
R_InetInfoSetAdminInformation(
    IN  LPWSTR              pszServer OPTIONAL,
    IN  DWORD               dwServerMask,
    IN  INETA_CONFIG_INFO * pConfig
    )
/*++

   Description

     Sets the common service admin information for the servers specified
     in dwServerMask.

   Arguments:

      pszServer - unused
      dwServerMask - Bitfield of servers to set the information for
      pConfig - Admin information to set

   Note:

--*/
{
    DWORD err;

    LPINET_INFO_VIRTUAL_ROOT_LIST rootList = NULL;

    IF_DEBUG( DLL_RPC) {
        DBGPRINTF( ( DBG_CONTEXT,
              " Entering R_InetInfoSetAdminInformation. Mask %x\n",
              dwServerMask));
    }

    //
    // Do we have permissions?
    //

    if ( (err = TsApiAccessCheck( TCP_SET_ADMIN_INFORMATION )) != NO_ERROR) {
       IF_DEBUG( DLL_RPC) {

            DBGPRINTF( ( DBG_CONTEXT,
                        " TsApiAccessCheck() Failed. Error = %u\n", err));
       }
        return(err);
    }

    //
    //  Loop through the services and set the information for each one
    //

    if ( !IIS_SERVICE::SetServiceAdminInfo(
                            1,
                            dwServerMask,
                            1,              // Instance - may be overidden with downlevel instance
                            TRUE,           // common config
                            pConfig
                            )) {

        err =  GetLastError();
        IF_DEBUG( DLL_RPC) {
            DBGPRINTF( ( DBG_CONTEXT,
                        "SetServiceAdminInfo failed. Error = %u\n",
                        err));
        }
    }

    IF_DEBUG( DLL_RPC) {
        DBGPRINTF( ( DBG_CONTEXT,
                   " Leaving R_InetInfoSetAdminInformation.  Err = %d\n",
                   err ));
    }

    return(err);

} // R_InetInfoSetAdminInformation


NET_API_STATUS
NET_API_FUNCTION
R_InetInfoGetAdminInformation(
    IN  LPWSTR                pszServer OPTIONAL,
    IN  DWORD                 dwServerMask,
    OUT LPINETA_CONFIG_INFO * ppConfig
    )
/*++

   Description

     Gets the common service admin information for the specified
     server in dwServerMask.

   Arguments:

      pszServer - unused
      dwServerMask - Bitfield of server to get the information for
      pConfig - Receives current operating values of the server

   Note:

--*/
{
    DWORD err = NO_ERROR;
    DWORD nEntries = 0;
    PCHAR buffer = NULL;
    DWORD nRead = 0;

    IF_DEBUG( DLL_RPC) {
        DBGPRINTF( ( DBG_CONTEXT,
                   " Entering R_InetInfoGetAdminInformation.\n"));
    }

    *ppConfig = NULL;

    //
    // Call the new API
    //

    IF_DEBUG( DLL_RPC) {
        DBGPRINTF( ( DBG_CONTEXT,
              " Entering R_InetInfoGetAdminInformation. Mask %x\n",
              dwServerMask));
    }

    if ( !IIS_SERVICE::GetServiceAdminInfo(
                                   1,
                                   dwServerMask,
                                   1,           // Instance - my get overidden by downlevel instance
                                   TRUE,        // common config
                                   &nRead,
                                   ppConfig
                                   )) {

        DBG_ASSERT(buffer == NULL);
        DBG_ASSERT(nRead == 0);

        err = GetLastError();
        DBG_ASSERT(err != NO_ERROR);
        IF_DEBUG( DLL_RPC) {
            DBGPRINTF( ( DBG_CONTEXT,
                        "GetServiceAdminInfo failed. Error = %u\n",
                        err));
        }
    } else {

        DBG_ASSERT(nRead == 1);
    }

    IF_DEBUG( DLL_RPC) {
        DBGPRINTF( ( DBG_CONTEXT,
                   " Leaving R_InetInfoGetAdminInformation.  Err = %d\n",
                   err ));
    }

    return(err);

} // R_InetInfoGetAdminInformation()



NET_API_STATUS
NET_API_FUNCTION
R_InetInfoGetSites(
    IN  LPWSTR                pszServer OPTIONAL,
    IN  DWORD                 dwServerMask,
    OUT LPINET_INFO_SITE_LIST * ppSites
    )
/*++

   Description

     Gets the list of instances for the specified
     server in dwServerMask.

   Arguments:

      pszServer - unused
      dwServerMask - Bitfield of server to get the information for
      ppSites - Receives current site list

   Note:

--*/
{
    BOOL    fRet = FALSE;
    DWORD   err = NO_ERROR;

    IF_DEBUG( DLL_RPC) {
        DBGPRINTF( ( DBG_CONTEXT,
                   " Entering R_InetInfoGetSites.\n"));
    }

    *ppSites = NULL;

    //
    // Call the new API
    //

    IF_DEBUG( DLL_RPC) {
        DBGPRINTF( ( DBG_CONTEXT,
              " Entering R_InetInfoGetSites. Mask %x\n",
              dwServerMask));
    }

    
    fRet = IIS_SERVICE::GetServiceSiteInfo (
                                dwServerMask,
                                ppSites
                                );
                                
    if (!fRet) {

        err = GetLastError();

        DBG_ASSERT(err != NO_ERROR);
        IF_DEBUG( DLL_RPC) {
            DBGPRINTF( ( DBG_CONTEXT,
                        "GetServiceSiteInfo failed. Error = %u\n",
                        err));
        }
    } 


    IF_DEBUG( DLL_RPC) {
        DBGPRINTF( ( DBG_CONTEXT,
                   " Leaving R_InetInfoGetSiteInformation.  Err = %d\n",
                   err ));
    }

    return(err);

} // R_InetInfoGetSiteInformation()


NET_API_STATUS
NET_API_FUNCTION
R_InetInfoQueryStatistics(
    IN  LPWSTR             pszServer OPTIONAL,
    IN  DWORD              Level,
    IN  DWORD              dwServerMask,
    LPINET_INFO_STATISTICS_INFO StatsInfo
    )
{
    DWORD err;

    err = TsApiAccessCheck( TCP_QUERY_STATISTICS );

    if ( err ) {
        return err;
    }

    switch ( Level ) {

    case 0:
        {
            INET_INFO_STATISTICS_0 * pstats0;
            ATQ_STATISTICS atqStats;

            pstats0 = (INET_INFO_STATISTICS_0 *) MIDL_user_allocate(
                                    sizeof( INET_INFO_STATISTICS_0 ));

            if ( !pstats0 ) {
                return ERROR_NOT_ENOUGH_MEMORY;
            }

#ifndef NO_AUX_PERF
            // init count of counters that are valid
            pstats0->nAuxCounters = 0;

            //
            // IF THERE ARE VALID UNNAMED COUNTERS THAT WE WISH TO TRACK
            // WE SHOULD DO SO HERE........
            // For Future Additions, this comment is added.
            // MuraliK  20-Sept-1995
            //

#endif // NO_AUX_PERF

            if ( !TsCacheQueryStatistics( Level,
                                          dwServerMask,
                                          &pstats0->CacheCtrs ) ||
                !AtqGetStatistics( &atqStats))
            {
                MIDL_user_free( pstats0 );
                err = GetLastError();
            } else {

                // copy Atq Statistics to stats
                INETA_ATQ_STATISTICS * pAtqStats = &pstats0->AtqCtrs;
                pAtqStats->TotalBlockedRequests  = atqStats.cBlockedRequests;
                pAtqStats->TotalAllowedRequests  = atqStats.cAllowedRequests;
                pAtqStats->TotalRejectedRequests = atqStats.cRejectedRequests;
                pAtqStats->CurrentBlockedRequests=
                  atqStats.cCurrentBlockedRequests;
                pAtqStats->MeasuredBandwidth = atqStats.MeasuredBandwidth;

                StatsInfo->InetStats0 = pstats0;
            }
        }
        break;

    default:
        err = ERROR_INVALID_LEVEL;
        break;
    }

    return err;
}




NET_API_STATUS
NET_API_FUNCTION
R_InetInfoClearStatistics(
    IN  LPWSTR pszServer OPTIONAL,
    IN  DWORD  dwServerMask
    )
{
    DWORD err;

    err = TsApiAccessCheck( TCP_SET_ADMIN_INFORMATION );

    if ( err == NO_ERROR) {
        if (!TsCacheClearStatistics( dwServerMask ) ||
            !AtqClearStatistics())  {

            err =  GetLastError();
        }
    }

    return err;
} // R_InetInfoClearStatistics




NET_API_STATUS
NET_API_FUNCTION
R_InetInfoFlushMemoryCache(
    IN  LPWSTR pszServer OPTIONAL,
    IN  DWORD  dwServerMask
    )
{
    DWORD err;

    err = TsApiAccessCheck( TCP_SET_ADMIN_INFORMATION );

    if ( err ) {
        return err;
    }

    if ( !TsCacheFlush( dwServerMask )) {
        return GetLastError();
    }

    return NO_ERROR;
}



BOOL
ReadRegString(
    HKEY     hkey,
    CHAR * * ppchstr,
    LPCSTR   pchValue,
    LPCSTR   pchDefault
    )
/*++

   Description

     Gets the specified string from the registry.  If *ppchstr is not NULL,
     then the value is freed.  If the registry call fails, *ppchstr is
     restored to its previous value.

   Arguments:

      hkey - Handle to open key
      ppchstr - Receives pointer of allocated memory of the new value of the
        string
      pchValue - Which registry value to retrieve
      pchDefault - Default string if value isn't found

--*/
{
    CHAR * pch = *ppchstr;

    *ppchstr = ReadRegistryString( hkey,
                                   pchValue,
                                   pchDefault,
                                   TRUE );

    if ( !*ppchstr ) {
        *ppchstr = pch;
        return FALSE;
    }

    if ( pch ) {
        TCP_FREE( pch );
    }

    return TRUE;

} // ReadRegString



BOOL
ConvertStringToRpc(
    WCHAR * * ppwch,
    LPCSTR  pch
    )
/*++

   Description

     Allocates, copies and converts pch to *ppwch

   Arguments:

     ppwch - Receives allocated destination string
     pch - ANSI string to copy from

--*/
{
    int cch;
    int iRet;

    if ( !pch ) {
        *ppwch = NULL;
        return TRUE;
    }

    cch = strlen( pch );

    if ( !(*ppwch = (WCHAR *) MIDL_user_allocate( (cch + 1) * sizeof(WCHAR))) )
    {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return FALSE;
    }

    iRet = MultiByteToWideChar( CP_ACP,
                                MB_PRECOMPOSED,
                                pch,
                                cch + 1,
                                *ppwch,
                                cch + 1 );

    if ( !iRet ) {
        MIDL_user_free( *ppwch );
        return FALSE;
    }

    return TRUE;
} // ConvertStringToRpc



VOID
FreeRpcString(
    WCHAR * pwch
    )
{
    if ( pwch ) {
        MIDL_user_free( pwch );
    }

} // FreeRpcString




DWORD
InitGlobalConfigFromReg(
                VOID
                )
/*++

  Loads the global configuration parameters from registry.
  Should be called after Atq Module is initialized.

  Returns:
    Win32 error code. NO_ERROR on success

--*/

{
    DWORD  dwError;
    HKEY   hkey = NULL;
    DWORD  dwVal;
    MB     mb( (IMDCOM*) IIS_SERVICE::QueryMDObject()  );

    dwError = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                            INET_INFO_PARAMETERS_KEY,
                            0,
                            KEY_ALL_ACCESS,
                            &hkey);

    if ( dwError == NO_ERROR) {

        DWORD       dwChangeNumber;

        // See if we need to migrate the bandwidth to the
        // metabase.

        if (!mb.GetSystemChangeNumber(&dwChangeNumber) ||
            dwChangeNumber == 0)
        {
            if (!mb.Open( "/lm",
                METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE ))
            {
                return GetLastError();
            }

            dwVal = ReadRegistryDword( hkey,
                                   INETA_BANDWIDTH_LEVEL,
                                   INETA_DEF_BANDWIDTH_LEVEL);

            mb.SetDword("", MD_MAX_BANDWIDTH, IIS_MD_UT_SERVER, dwVal);
            mb.Close();
        }

    }

    if (mb.Open("/lm", METADATA_PERMISSION_READ))
    {
        if ( mb.GetDword("", MD_MAX_BANDWIDTH_BLOCKED, IIS_MD_UT_SERVER, &dwVal ))
        {
            AtqSetInfo( AtqBandwidthThrottleMaxBlocked, (ULONG_PTR)dwVal );
        }

        if (!mb.GetDword("", MD_MAX_BANDWIDTH, IIS_MD_UT_SERVER, &dwVal))
        {
            DBGPRINTF( ( DBG_CONTEXT, "Could not read MD_MAX_BANDWIDTH\n" ) );
            dwVal = INETA_DEF_BANDWIDTH_LEVEL;
        }
    }
    else
    {
        DBGPRINTF( ( DBG_CONTEXT, "Couldn't open; error=%d\n", GetLastError() ) );
        dwVal = INETA_DEF_BANDWIDTH_LEVEL;
    }
    
    DBGPRINTF( ( DBG_CONTEXT,
               " Setting Global throttle value to %d\n", dwVal ));

    AtqSetInfo( AtqBandwidthThrottle, (ULONG_PTR)dwVal);

    if ( hkey ) {
        RegCloseKey( hkey );
    }

    return NO_ERROR;

} // InitGlobalConfigFromReg()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\log\comlog\context.cpp ===
/*++

   Copyright    (c)    1995-1996    Microsoft Corporation

   Module  Name :
      Context.cxx

   Abstract:
      The file contains the implementation of the Context object. A context
      job is an object which stored in the logging request queue.

   Author:

       Terence Kwan    ( terryk )    18-Sep-1996

   Project:

       IIS Logging 3.0

--*/

#include "precomp.hxx"
#include "comlog.hxx"
#include "iiscnfg.h"

//
// statics
//

CRITICAL_SECTION    COMLOG_CONTEXT::sm_listLock;
LIST_ENTRY          COMLOG_CONTEXT::sm_ContextListHead;


CHAR    g_pszResFromGetComputerName [MAX_PATH] ="";

VOID
COMLOG_CONTEXT::LoadPluginModules(
    VOID
    )
/*++
Routine Description:

    load all the plugin module from the metabase

Arguments:

    None.

Return Value:

    None

--*/
{

    DWORD   cb;
    MB      mb( (IMDCOM*) m_pvIMDCOM );
    PCHAR   p;
    CLSID   clsid;
    WCHAR   buf[MAX_PATH];
    BUFFER  szLoadOrder(1024);
    PCHAR   pEnd;
    DWORD   dwLogType;
    DWORD   nPlugins = 0;

    PPLUGIN_NODE    pluginNode;

    LPUNKNOWN       punk;
    ILogPluginEx    *pComponent;
    bool            fExtended;
    HRESULT         hr ;

    //
    // get the config information from the metabase
    //

    LockExclusive( );
    
    if ( !mb.Open(m_strMetabasePath.QueryStr()) ) 
    {
        DBGPRINTF((DBG_CONTEXT,"Unable to open MB path %s[err %x]\n",
                    m_strMetabasePath.QueryStr(), GetLastError()));
                    
        goto exit;
    }

    //
    // If logging disabled, bail out
    //

    if ( mb.GetDword( "", MD_LOG_TYPE, IIS_MD_UT_SERVER, &dwLogType)) 
    {

        if ( dwLogType == MD_LOG_TYPE_DISABLED ) 
        {
            DBGPRINTF((DBG_CONTEXT,"Logging disabled\n"));
            goto exit;
        }
    }

    //
    // Read the plugin order list
    //

retry:

    cb = szLoadOrder.QuerySize( );
    
    if ( !mb.GetString( "", MD_LOG_PLUGIN_ORDER, IIS_MD_UT_SERVER, (PCHAR)szLoadOrder.QueryPtr( ), &cb )) 
    {

        DWORD err = GetLastError();

        if ( err == ERROR_INSUFFICIENT_BUFFER ) 
        {

            DBGPRINTF((DBG_CONTEXT,"Buff Too Small[%d] need[%d]\n", szLoadOrder.QuerySize(), cb ));

            if ( cb > szLoadOrder.QuerySize( ) ) 
            {
                szLoadOrder.Resize( cb );
                goto retry;
            }
        }

        DBGPRINTF((DBG_CONTEXT,"Error getting pluginOrder[err %x]\n", err));

        mb.Close();
        goto exit;
    }

    mb.Close();

    //
    // Parse it
    //

    pEnd = (PCHAR)szLoadOrder.QueryPtr( );

    for ( p = pEnd;  pEnd != NULL;  p = pEnd + 1 ) 
    {
        if ( *p == '\0' ) 
        {
            break;
        }

        //
        // pEnd will point to the next entry
        //

        pEnd = strchr(p, ',');
        
        if ( pEnd != NULL ) 
        {
            *pEnd = '\0';
        }

        //
        // p points to the CLSID
        //

        DBGPRINTF((DBG_CONTEXT,"Got Logging clsid %s\n",p));
        
        if ( !TsIsNtServer() ) 
        {

            //
            // odbc not allowed
            //

            if ( _stricmp(p,ODBCLOG_CLSID) == 0 ) 
            {
                DBGPRINTF((DBG_CONTEXT,"ODBC logging not allowed for NTW\n"));
                continue;
            }
        }

        //
        // convert string to CLSID
        //

        mbstowcs( (WCHAR *)buf, p, MAX_PATH);

        hr = CLSIDFromString( buf, &clsid );
        
        if (FAILED(hr)) 
        {
            //
            // cannot convert string
            //
            
            DBGPRINTF((DBG_CONTEXT,"Cannot convert string to CLSID: %s\n",p));
            continue;
        }

        hr = CoCreateInstance( clsid, NULL, CLSCTX_INPROC_SERVER, IID_IUnknown, (void **)&punk );

        if (FAILED(hr)) 
        {
            //
            // cannot convert string
            //
            
            DBGPRINTF((DBG_CONTEXT,"Cannot create instance: %s\n",p));
            continue;
        }

        hr = punk->QueryInterface(IID_ILogPluginEx, (void **)&pComponent);

        if (SUCCEEDED(hr)) 
        {
            fExtended = true;
        }
        else
        {
            fExtended = false;

            //
            // Try getting the older interface
            //
            
            hr = punk->QueryInterface(IID_ILogPlugin, (void **)&pComponent);
        }
        
        punk->Release();

        if (FAILED(hr))
        {
            DBGPRINTF((DBG_CONTEXT,"Unable to get the Extended or the Standard Plugin Interface.\n"));
            continue;
        }

        //
        // Add the component
        //

        pluginNode = (PPLUGIN_NODE)LocalAlloc( 0, sizeof(PLUGIN_NODE) );
        
        if ( pluginNode == NULL ) 
        {
            pComponent->Release( );
            continue;
        }

        pluginNode->pComponent = pComponent;
        pluginNode->fSupportsExtendedInterface = fExtended;
        
        nPlugins++;
        InsertTailList(&m_pluginList, &pluginNode->ListEntry);

        //
        // Is this the default?
        //

        if ( _stricmp(p,EXTLOG_CLSID) == 0 ) 
        {
            m_fDefault = TRUE;
            DBGPRINTF((DBG_CONTEXT,"Logging Extended[%d]\n", m_fDefault));
        }
    }

    if ( nPlugins > 1 ) 
    {
        m_fDefault = FALSE;
    }

exit:
    Unlock( );
    return;

} // COMLOG_CONTEXT::LoadPlugInModules


VOID
COMLOG_CONTEXT::ReleasePluginModules(
    VOID
    )
{
    PLIST_ENTRY     listEntry;
    PPLUGIN_NODE  pluginModule;

    LockExclusive( );

    m_fDefault = FALSE;

    while ( !IsListEmpty(&m_pluginList) ) {

        listEntry = RemoveHeadList( &m_pluginList );
        pluginModule = (PPLUGIN_NODE)CONTAINING_RECORD(
                                                listEntry,
                                                PLUGIN_NODE,
                                                ListEntry
                                                );

        pluginModule->pComponent->Release( );
        LocalFree( pluginModule );
    }

    Unlock( );
    return;
} // COMLOG_CONTEXT::ReleasePlugInModules


COMLOG_CONTEXT::COMLOG_CONTEXT(
            LPCSTR pszInstanceName,
            LPCSTR pszMetabasePath,
            LPVOID pvIMDCOM
            )
:     m_fDefault            (FALSE),
      m_pvIMDCOM            (pvIMDCOM)

/*++

Routine Description:
    Constructor for clapi context object

Arguments:
    pszInstanceName - name of the instance

Return Value:

--*/
{
    DWORD cbComputerNameSize = sizeof(g_pszResFromGetComputerName);
    MB      mb( (IMDCOM*) m_pvIMDCOM );

    InitializeListHead( &m_pluginList );
    InitializeListHead( &m_PublicListEntry);
    
    m_strInstanceName.Copy(pszInstanceName);
    m_strMetabasePath.Copy(pszMetabasePath);


    if (g_pszResFromGetComputerName[0]==0)
    {
        if ( !GetComputerName( g_pszResFromGetComputerName, &cbComputerNameSize) ) 
        {
            strcpy(g_pszResFromGetComputerName,"<Server>");
        }
    }

    m_strComputerName.Copy(g_pszResFromGetComputerName);

    //
    // Add into the global list
    //

    EnterCriticalSection( &COMLOG_CONTEXT::sm_listLock );
    InsertTailList(
            &COMLOG_CONTEXT::sm_ContextListHead,
            &m_ContextListEntry
            );

    LeaveCriticalSection( &COMLOG_CONTEXT::sm_listLock );

    //
    // Load all the plugin modules
    //

    LoadPluginModules( );

    return;

} // COMLOG_CONTEXT::COMLOG



COMLOG_CONTEXT::~COMLOG_CONTEXT()
/*++

Routine Description:
    destructor

Arguments:

Return Value:

--*/
{
    PLIST_ENTRY     listEntry;
    PInetLogPublic  pPublic;

    EnterCriticalSection( &COMLOG_CONTEXT::sm_listLock );
    LockExclusive();
    
    RemoveEntryList(&m_ContextListEntry);
    
    ReleasePluginModules();
    
    for ( listEntry = m_PublicListEntry.Flink;
          listEntry != &m_PublicListEntry;
          listEntry = listEntry->Flink    ) 
    {

        pPublic = (PInetLogPublic)CONTAINING_RECORD(
                                        listEntry,
                                        CInetLogPublic,
                                        m_ListEntry
                                        );

       pPublic->m_pContext = NULL;
    }

    Unlock();
    LeaveCriticalSection( &COMLOG_CONTEXT::sm_listLock );

} // COMLOG_CONTEXT::~COMLOG()


VOID
COMLOG_CONTEXT::LogInformation(
            PINETLOG_INFORMATION pLogInfo
            )
{

    PLIST_ENTRY listEntry;
    PPLUGIN_NODE plugin;
    CInetLogInformation inetLog;

    LockShared();

    if ( m_pluginList.Flink != &m_pluginList )
    {
        // logging is enabled
        
        inetLog.CanonicalizeLogRecord(
                                pLogInfo,
                                m_strInstanceName.QueryStr(),
                                m_strComputerName.QueryStr(),
                                m_fDefault
                                );

        for ( listEntry = m_pluginList.Flink;
              listEntry != &m_pluginList;
              listEntry = listEntry->Flink    ) 
        {

            plugin = (PPLUGIN_NODE)CONTAINING_RECORD(
                                        listEntry,
                                        PLUGIN_NODE,
                                        ListEntry
                                        );

            plugin->pComponent->LogInformation( &inetLog );
        }
    }

    Unlock();

} // COMLOG_CONTEXT::LogInformation



VOID
COMLOG_CONTEXT::LogInformation(
            IInetLogInformation *pLogObj 
            )
{

    PLIST_ENTRY listEntry;
    PPLUGIN_NODE plugin;

    LockShared();

    if ( m_pluginList.Flink != &m_pluginList )
    {
        // logging is enabled
        
        for ( listEntry = m_pluginList.Flink;
              listEntry != &m_pluginList;
              listEntry = listEntry->Flink    ) 
        {

            plugin = (PPLUGIN_NODE)CONTAINING_RECORD(
                                        listEntry,
                                        PLUGIN_NODE,
                                        ListEntry
                                        );

            plugin->pComponent->LogInformation( pLogObj );
        }
    }

    Unlock();

} // COMLOG_CONTEXT::LogInformation


VOID
COMLOG_CONTEXT::LogCustomInformation(
            IN  DWORD               cCount, 
            IN  PCUSTOM_LOG_DATA    pCustomLogData,
            IN  LPSTR               szHeaderSuffix
            )
{

    //
    // This function is supported only if the extended interface was found on the plugin
    //
    
    PLIST_ENTRY listEntry;
    PPLUGIN_NODE plugin;

    LockShared();
    
    for ( listEntry = m_pluginList.Flink;
          listEntry != &m_pluginList;
          listEntry = listEntry->Flink    ) 
    {

        plugin = (PPLUGIN_NODE)CONTAINING_RECORD(
                                        listEntry,
                                        PLUGIN_NODE,
                                        ListEntry
                                        );

        if (plugin->fSupportsExtendedInterface)
        {
            plugin->pComponent->LogCustomInformation( cCount, pCustomLogData, szHeaderSuffix);
        }
    }

    Unlock();

} // COMLOG_CONTEXT::LogCustomInformation


VOID
COMLOG_CONTEXT::NotifyChange(
            VOID
            )
{
    TerminateLog();
    ReleasePluginModules( );

    LoadPluginModules( );
    InitializeLog(
        m_strInstanceName.QueryStr(),
        m_strMetabasePath.QueryStr(),
        (CHAR*)m_pvIMDCOM
        );

} // COMLOG_CONTEXT::NotifyChange



VOID
COMLOG_CONTEXT::GetConfig(
    IN INETLOG_CONFIGURATIONA *pConfigInfo
    )
{
    //
    // just return the first configuration information
    //

    PLIST_ENTRY listEntry;
    PPLUGIN_NODE plugin;

    LockShared( );
    listEntry = m_pluginList.Flink;

    if (listEntry != &m_pluginList){

        plugin = (PPLUGIN_NODE)CONTAINING_RECORD(
                                        listEntry,
                                        PLUGIN_NODE,
                                        ListEntry
                                        );

        plugin->pComponent->GetConfig(
                            sizeof(INETLOG_CONFIGURATIONA),
                            (BYTE *)pConfigInfo);

        Unlock( );
        return;
    }

    //
    // No Log
    //

    Unlock( );
    pConfigInfo->inetLogType = INET_LOG_DISABLED;
    return;
} // GetConfig


VOID
COMLOG_CONTEXT::SetConfig(
    IN INETLOG_CONFIGURATIONA *pConfigInfo
    )
{
    //
    // check the log type and call the proper setconfig function
    //

    MB      mb( (IMDCOM*) m_pvIMDCOM );

    //
    // NTW restrictions
    //

    if ( (pConfigInfo->inetLogType == INET_LOG_TO_SQL) &&
         !TsIsNtServer() ) {
        return;
    }

    if ( !mb.Open( m_strMetabasePath.QueryStr(),
                   METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE ))
    {
        return;
    }

    //
    // Release all
    //

    ReleasePluginModules( );

    switch (pConfigInfo->inetLogType) {

        case INET_LOG_TO_FILE:
            switch (pConfigInfo->u.logFile.ilFormat) {

            case INET_LOG_FORMAT_INTERNET_STD:

                mb.SetString("",
                             MD_LOG_PLUGIN_ORDER,
                             IIS_MD_UT_SERVER,
                             ASCLOG_CLSID );
                break;

            case INET_LOG_FORMAT_NCSA:
                mb.SetString("",
                             MD_LOG_PLUGIN_ORDER,
                             IIS_MD_UT_SERVER,
                             NCSALOG_CLSID );
                break;

            case INET_LOG_FORMAT_EXTENDED:
                mb.SetString("",
                             MD_LOG_PLUGIN_ORDER,
                             IIS_MD_UT_SERVER,
                             EXTLOG_CLSID );
                mb.SetDword( "",
                        MD_LOGEXT_FIELD_MASK,
                        IIS_MD_UT_SERVER,
                        pConfigInfo->u.logFile.dwFieldMask );
                break;

            default:
                DBGPRINTF((DBG_CONTEXT,"SetConfig: Invalid Format type %d\n",
                    pConfigInfo->inetLogType));
                goto no_log;
            }

            mb.SetDword( "",
                    MD_LOGFILE_PERIOD,
                    IIS_MD_UT_SERVER,
                    pConfigInfo->u.logFile.ilPeriod );

            if (pConfigInfo->u.logFile.ilPeriod == INET_LOG_PERIOD_NONE ) {
                mb.SetDword( "",
                    MD_LOGFILE_TRUNCATE_SIZE,
                    IIS_MD_UT_SERVER, pConfigInfo->
                    u.logFile.cbSizeForTruncation );
            }

            mb.SetString( "",
                MD_LOGFILE_DIRECTORY,
                IIS_MD_UT_SERVER,
                pConfigInfo->u.logFile.rgchLogFileDirectory );

            mb.SetDword( "",
                    MD_LOG_TYPE,
                    IIS_MD_UT_SERVER,
                    MD_LOG_TYPE_ENABLED );

            break;

        case INET_LOG_TO_SQL:

            mb.SetString("",
                         MD_LOG_PLUGIN_ORDER,
                         IIS_MD_UT_SERVER,
                         ODBCLOG_CLSID );

            mb.SetString( "",
                          MD_LOGSQL_DATA_SOURCES,
                          IIS_MD_UT_SERVER,
                          pConfigInfo->u.logSql.rgchDataSource );

            mb.SetString( "",
                          MD_LOGSQL_TABLE_NAME,
                          IIS_MD_UT_SERVER,
                          pConfigInfo->u.logSql.rgchTableName );

            mb.SetString( "",
                          MD_LOGSQL_USER_NAME,
                          IIS_MD_UT_SERVER,
                          pConfigInfo->u.logSql.rgchUserName );

            mb.SetString( "",
                          MD_LOGSQL_PASSWORD,
                          IIS_MD_UT_SERVER,
                          pConfigInfo->u.logSql.rgchPassword,
                          METADATA_INHERIT|METADATA_SECURE );

            mb.SetDword( "",
                    MD_LOG_TYPE,
                    IIS_MD_UT_SERVER,
                    MD_LOG_TYPE_ENABLED );

            break;

        case INET_LOG_DISABLED:
        default:
            goto no_log;
    }

exit:
    mb.Save();
    mb.Close();
    return;

no_log:

    mb.SetString( "",
            MD_LOG_PLUGIN_ORDER,
            IIS_MD_UT_SERVER,
            ""
            );

    mb.SetDword( "",
            MD_LOG_TYPE,
            IIS_MD_UT_SERVER,
            MD_LOG_TYPE_DISABLED );

    goto exit;

} // COMLOG_CONTEXT::SetConfig


VOID
COMLOG_CONTEXT::QueryExtraLogFields(
                PDWORD pcbSize,
                PCHAR  pszLogFields
                )
{
    PLIST_ENTRY listEntry;
    PPLUGIN_NODE plugin;

    LockShared( );
    listEntry = m_pluginList.Flink;
    if (listEntry != &m_pluginList){

        plugin = (PPLUGIN_NODE)CONTAINING_RECORD(
                                        listEntry,
                                        PLUGIN_NODE,
                                        ListEntry
                                        );

        plugin->pComponent->QueryExtraLoggingFields(
                                        pcbSize,
                                        pszLogFields
                                        );

        //
        // handle just the 1st component
        //

        Unlock( );
        return;
    }

    Unlock( );

    *pcbSize = 0;
    *pszLogFields = '\0';
    return;

} // COMLOG_CONTEXT::QueryExtraLogFields




VOID
COMLOG_CONTEXT::InitializeLog(
        LPCSTR pszInstanceName,
        LPCSTR pszMetabasePath,
        LPVOID
        )
{
    PLIST_ENTRY listEntry;
    PPLUGIN_NODE plugin;

    LockExclusive();

    for ( listEntry = m_pluginList.Flink;
          listEntry != &m_pluginList;
          listEntry = listEntry->Flink    ) {

        plugin = (PPLUGIN_NODE)CONTAINING_RECORD(
                                        listEntry,
                                        PLUGIN_NODE,
                                        ListEntry
                                        );

        plugin->pComponent->InitializeLog(
                                pszInstanceName,
                                pszMetabasePath,
                                (PCHAR)m_pvIMDCOM
                                );

        if ( m_fDefault ) {

            INETLOG_CONFIGURATIONA  config;
            m_fDefault = FALSE;
            if ( SUCCEEDED( plugin->pComponent->GetConfig(
                                    sizeof(config),
                                    (PBYTE)&config ) ) ) {

                if ( (config.u.logFile.ilFormat ==
                                INET_LOG_FORMAT_EXTENDED)
                                &&
                     (config.u.logFile.dwFieldMask ==
                                DEFAULT_EXTLOG_FIELDS) ) {

                    m_fDefault = TRUE;
                }
            }
        }

    }

    Unlock();

} // COMLOG_CONTEXT::InitializeLog


VOID
COMLOG_CONTEXT::TerminateLog(
    VOID
    )
{
    PLIST_ENTRY listEntry;
    PPLUGIN_NODE plugin;

    LockExclusive( );
    for ( listEntry = m_pluginList.Flink;
          listEntry != &m_pluginList;
          listEntry = listEntry->Flink    ) {

        plugin = (PPLUGIN_NODE)CONTAINING_RECORD(
                                        listEntry,
                                        PLUGIN_NODE,
                                        ListEntry
                                        );

        plugin->pComponent->TerminateLog( );
    }

    Unlock( );

} // COMLOG_CONTEXT::TerminateLog
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\log\comlog\comlogex.cpp ===
/*++

   Copyright    (c)    1995-1996    Microsoft Corporation

   Module  Name :
      clapiex.cpp

   Abstract:
       CLAPI external API.

   Author:

       Terence Kwan    ( terryk )    18-Sep-1996

   Project:

       IIS Logging 3.0

--*/

#include "precomp.hxx"
#include "comlog.hxx"

LONG    g_ComLogInitializeCount = -1;

PLIST_ENTRY g_listComLogContexts;

DECLARE_DEBUG_PRINTS_OBJECT();


HANDLE
ComLogInitializeLog(
    LPCSTR pszInstanceName,
    LPCSTR pszMetabasePath,
    LPVOID pvIMDCOM
    )
/*++

Routine Description:
    Initialize the Log

Arguments:
    pszInstanceName - name of instance
    lpszMetabasePath - path to metabase
    pvIMDCOM - ptr to IMDCOM

Return Value:
    handle for the context object

--*/
{
    //
    // create an handle and return it

    //
    // The constructor for COMLOG_CONTEXT will add the new context to the list of contexts.
    //

    COMLOG_CONTEXT *pContext = new COMLOG_CONTEXT(
                                    pszInstanceName,
                                    pszMetabasePath,
                                    pvIMDCOM );

    HANDLE hHandle = (HANDLE) pContext;

    if (hHandle != NULL) {

        //
        // set up the node and put it in a queue or execute it
        //

        pContext->InitializeLog(
                        pszInstanceName,
                        pszMetabasePath,
                        pvIMDCOM );

    }

    return( hHandle );
} // ComLogInitializeLog



DWORD
ComLogTerminateLog( HANDLE hHandle )
/*++

Routine Description:
    terminate the Log

Arguments:
    handle - handle for the context object

Return Value:
    error code

--*/
{
    DWORD err = NO_ERROR;

    COMLOG_CONTEXT *pContext = (COMLOG_CONTEXT*)hHandle;

    if ( pContext == NULL ) {
        err = ERROR_INVALID_HANDLE;

    } else {

        pContext->TerminateLog();
        delete pContext;
    }

    return err;
} // ComLogTerminateLog



DWORD
ComLogDllStartup(
    VOID
    )
{
    CREATE_DEBUG_PRINT_OBJECT("iscomlog.dll");
    LOAD_DEBUG_FLAGS_FROM_REG_STR("System\\CurrentControlSet\\Services\\InetInfo\\Parameters", 0);

    if ( InterlockedIncrement( &g_ComLogInitializeCount ) != 0 ) {

        DBGPRINTF((DBG_CONTEXT,
            "ComLogDllStartup [Count is %d]\n",
            g_ComLogInitializeCount));

        return(NO_ERROR);
    }

    //
    // Get platform type
    //

    INITIALIZE_PLATFORM_TYPE();
    DBG_ASSERT( IISIsValidPlatform());

    INITIALIZE_CRITICAL_SECTION(&COMLOG_CONTEXT::sm_listLock);
    InitializeListHead(&COMLOG_CONTEXT::sm_ContextListHead);

    return NO_ERROR;
} // ComLogStartup


DWORD
ComLogDllCleanUp(
    VOID
    )
/*++

Routine Description:
    Clean up the Log. It will wait until the queue is empty and then it will
    terminate the queue.

Arguments:

Return Value:
    error code

--*/
{
    PLIST_ENTRY listEntry;
    COMLOG_CONTEXT* context;

    if ( InterlockedDecrement( &g_ComLogInitializeCount ) >= 0 ) {

        DBGPRINTF((DBG_CONTEXT,
            "ComLogDllCleanUp [Count is %d]\n",
            g_ComLogInitializeCount));

        return(NO_ERROR);
    }

    //
    // If we have something on the list, then the caller did not
    // cleanup properly.  Do the partial cleanup.
    //

    EnterCriticalSection( &COMLOG_CONTEXT::sm_listLock );

    for ( listEntry = COMLOG_CONTEXT::sm_ContextListHead.Flink;
          listEntry != &COMLOG_CONTEXT::sm_ContextListHead;
          listEntry = listEntry->Flink    ) {

        context = (COMLOG_CONTEXT*)CONTAINING_RECORD(
                                        listEntry,
                                        COMLOG_CONTEXT,
                                        m_ContextListEntry
                                        );

        DBGPRINTF((DBG_CONTEXT,
            "Log context %x not terminated by server %s\n",
            context, context->m_strInstanceName.QueryStr()));

        context->TerminateLog( );
    }

    LeaveCriticalSection( &COMLOG_CONTEXT::sm_listLock );

    DeleteCriticalSection(&COMLOG_CONTEXT::sm_listLock);
    DELETE_DEBUG_PRINT_OBJECT( );
    return(NO_ERROR);
}

DWORD
ComLogNotifyChange(
    HANDLE hHandle
    )
/*++

Routine Description:
    Called to notify of any change in instance metabase config

Arguments:

Return Value:
    error code

--*/
{
    DWORD err = NO_ERROR;

    COMLOG_CONTEXT *pContext = (COMLOG_CONTEXT*)hHandle;

    if ( pContext == NULL )
    {
        err = ERROR_INVALID_HANDLE;
    }
    else
    {
        pContext->NotifyChange();
    }

    return err;
}


DWORD
ComLogLogInformation(
        IN HANDLE hHandle,
        IN INETLOG_INFORMATION *pInetLogInfo
        )
/*++

Routine Description:
    Log information to the logging module

Arguments:
    hHandle - handle for the context
    pInetLogInfo - logging object

Return Value:
    error code

--*/
{
    COMLOG_CONTEXT *pContext = (COMLOG_CONTEXT*)hHandle;

    if ( pContext != NULL ) {
        pContext->LogInformation( pInetLogInfo );
        return(NO_ERROR);
    }
    return ERROR_INVALID_HANDLE;
} // ComLogLogInformation


DWORD
ComLogGetConfig(
    HANDLE hHandle,
    INETLOG_CONFIGURATIONA *ppConfig
    )
/*++

Routine Description:
    get logging configuration information

Arguments:
    hHandle - handle for the context
    ppConfig - configuration information

Return Value:
    error code

--*/
{
    DWORD err = NO_ERROR;

    COMLOG_CONTEXT *pContext = (COMLOG_CONTEXT*)hHandle;

    if ( pContext == NULL ) {
        return(ERROR_INVALID_HANDLE);
    } else {
        pContext->GetConfig(ppConfig);
    }

    return err;
}

DWORD
ComLogQueryExtraLogFields(
        HANDLE  hHandle,
        PCHAR   pBuf,
        PDWORD  pcbBuf
        )
{
    COMLOG_CONTEXT *pContext = (COMLOG_CONTEXT*)hHandle;

    if ( pContext == NULL ) {
        return(ERROR_INVALID_HANDLE);
    } else {

        pContext->QueryExtraLogFields(pcbBuf, pBuf);
    }

    return(NO_ERROR);
} // ComLogQueryExtraLogFields


DWORD
ComLogSetConfig(
        IN HANDLE hHandle,
        IN INETLOG_CONFIGURATIONA *pConfig
        )
/*++

Routine Description:
    set logging information

Arguments:
    hHandle - handle for the context
    pConfig - configuration information

Return Value:
    error code

--*/
{
    DWORD err = NO_ERROR;

    COMLOG_CONTEXT *pContext = (COMLOG_CONTEXT*)hHandle;

    if ( pContext == NULL )
    {
        return(ERROR_INVALID_HANDLE);
    }
    else
    {
        pContext->SetConfig( pConfig );
    }

    return err;
} // ComLogSetConfig


DWORD
ComLogCustomInformation(
        IN  HANDLE              hHandle,
        IN  DWORD               cCount,
        IN  PCUSTOM_LOG_DATA    pCustomLogData,
        IN  LPSTR               szHeaderSuffix
        )
/*++

Routine Description:
    Log information to the logging module

Arguments:
    hHandle - handle for the context
    pInetLogInfo - logging object

Return Value:
    error code

--*/
{
    COMLOG_CONTEXT *pContext = (COMLOG_CONTEXT*)hHandle;

    if ( pContext != NULL )
    {
        pContext->LogCustomInformation( cCount, pCustomLogData, szHeaderSuffix);
        return(NO_ERROR);
    }
    return ERROR_INVALID_HANDLE;
} // ComLogCustomInformation
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\log\comlog\comlog.cpp ===
/*++

   Copyright    (c)    1995-1996    Microsoft Corporation

   Module  Name :
      clapi.cpp

   Abstract:
    CLAPI - Common logging layer

   Author:

       Terence Kwan    ( terryk )    18-Sep-1996

   Project:

       IIS Logging 3.0

--*/

#include "precomp.hxx"
#include "comlog.hxx"
#include <inetsvcs.h>

DECLARE_PLATFORM_TYPE();

// by exporting DllRegisterServer, you can use regsvr.exe
#define CLAPI_PROG_ID           "CLAPI.INETLOGINFORMATION"
#define CLAPI_CLSID_KEY_NAME    "CLSID"
#define CLAPI_INPROC_SERVER     "InProcServer32"
#define CLAPI_CLSID             "{A1F89741-F619-11CF-BC0F-00AA006111E0}"

/*
#define LOGPUBLIC_PROG_ID       "MSIISLOG.MSLOGPUBLIC"
#define LOGPUBLIC_CLSID         "{FB583AC4-C361-11d1-8BA4-080009DCC2FA}"
*/
extern "C" {

BOOL
WINAPI
DLLEntry(
    HINSTANCE hDll,
    DWORD     dwReason,
    LPVOID    lpvReserved
    );
}

BOOL
WINAPI
DLLEntry(
    HINSTANCE hDll,
    DWORD     dwReason,
    LPVOID
    )
/*++

Routine Description:

    DLL entrypoint.

Arguments:

    hDLL          - Instance handle.

    Reason        - The reason the entrypoint was called.
                    DLL_PROCESS_ATTACH
                    DLL_PROCESS_DETACH
                    DLL_THREAD_ATTACH
                    DLL_THREAD_DETACH

    Reserved      - Reserved.

Return Value:

    BOOL          - TRUE if the action succeeds.

--*/
{
    BOOL bReturn = TRUE;

    switch ( dwReason ) {

    case DLL_PROCESS_ATTACH:
        DisableThreadLibraryCalls(hDll);
        break;

    case DLL_PROCESS_DETACH:
        break;

    default:
        break;
    }

    return bReturn;
} // DllEntry


STDAPI
DllRegisterServer(void)
/*++

Routine Description:
    MFC register server function

Arguments:

Return Value:

--*/
{

    LONG ret = E_UNEXPECTED;
    HKEY hProgID = NULL;
    HKEY hCLSID = NULL;
    HKEY hClapi = NULL;
    HKEY hKey;
    HMODULE hModule;

    CHAR szName[MAX_PATH+1];

    //
    // CLAPI.INETLOGINFORMATION
    //

    hProgID = CreateKey(
                    HKEY_CLASSES_ROOT,
                    CLAPI_PROG_ID,
                    CLAPI_PROG_ID);

    if ( hProgID == NULL ) {
        IIS_PRINTF((buff,"Cannot set value for key %s\n", CLAPI_PROG_ID));
        goto exit;
    }

    hCLSID = CreateKey(hProgID,
                    CLAPI_CLSID_KEY_NAME,
                    CLAPI_CLSID);

    if ( hCLSID == NULL ) {
        IIS_PRINTF((buff,"Cannot set value %s for key %s\n",
            CLAPI_CLSID_KEY_NAME, CLAPI_CLSID));
        goto exit;
    }

    RegCloseKey(hCLSID);
    hCLSID = NULL;

    //
    // CLSID
    //

    if ( RegOpenKeyExA(HKEY_CLASSES_ROOT,
                    CLAPI_CLSID_KEY_NAME,
                    0,
                    KEY_ALL_ACCESS,
                    &hCLSID) != ERROR_SUCCESS ) {

        IIS_PRINTF((buff,"Cannot open CLSID key\n"));
        goto exit;
    }

    hClapi = CreateKey(hCLSID,CLAPI_CLSID,CLAPI_PROG_ID);
    if ( hClapi == NULL ) {
        goto exit;
    }

    //
    // InProcServer32
    //

    hModule=GetModuleHandleA("iscomlog.dll");
    if (hModule == NULL) {
        IIS_PRINTF((buff,"GetModuleHandle failed with %d\n",GetLastError()));
        goto exit;
    }

    if (GetModuleFileNameA(hModule, szName, sizeof(szName))==0) {

        IIS_PRINTF((buff,
            "GetModuleFileName failed with %d\n",GetLastError()));
        goto exit;
    }

    hKey = CreateKey(hClapi,CLAPI_INPROC_SERVER,szName);

    if ( hKey == NULL ) {
        goto exit;
    }

    if (RegSetValueExA(hKey,
                "ThreadingModel",
                0,
                REG_SZ,
                (LPBYTE)"Both",
                sizeof("Both")) != ERROR_SUCCESS) {

        RegCloseKey(hKey);
        hKey = NULL;
        goto exit;
    }
    
    RegCloseKey(hKey);

    /*

    //
    // Set ProgID key
    //

    hKey = CreateKey(hClapi,"ProgID",CLAPI_PROG_ID);
    if ( hKey == NULL ) {
        goto exit;
    }

    RegCloseKey(hKey);
    ret = S_OK;

    if ( hClapi != NULL ) {
        RegCloseKey(hClapi);
        hClapi = NULL;
    }

    if ( hProgID != NULL ) {
        RegCloseKey(hProgID);
        hProgID = NULL;
    }

    if ( hCLSID != NULL ) {
        RegCloseKey(hCLSID);
        hCLSID = NULL;
    }

    //
    // MSIISLOG.MSLOGPUBLIC
    //

    
    hProgID = CreateKey(
                    HKEY_CLASSES_ROOT,
                    LOGPUBLIC_PROG_ID,
                    LOGPUBLIC_PROG_ID);

    if ( hProgID == NULL ) {
        IIS_PRINTF((buff,"Cannot set value for key %s\n", LOGPUBLIC_PROG_ID));
        goto exit;
    }

    hCLSID = CreateKey(hProgID,
                    CLAPI_CLSID_KEY_NAME,
                    LOGPUBLIC_CLSID);
                    

    if ( hCLSID == NULL ) {
        IIS_PRINTF((buff,"Cannot set value %s for key %s\n",
            CLAPI_CLSID_KEY_NAME, LOGPUBLIC_CLSID));
        goto exit;
    }

    RegCloseKey(hCLSID);
    hCLSID = NULL;

    //
    // CLSID
    //

    if ( RegOpenKeyExA(HKEY_CLASSES_ROOT,
                    CLAPI_CLSID_KEY_NAME,
                    0,
                    KEY_ALL_ACCESS,
                    &hCLSID) != ERROR_SUCCESS ) {

        IIS_PRINTF((buff,"Cannot open CLSID key\n"));
        goto exit;
    }

    hClapi = CreateKey(hCLSID,LOGPUBLIC_CLSID,LOGPUBLIC_PROG_ID);
    if ( hClapi == NULL ) {
        goto exit;
    }

    //
    // InProcServer32
    //

    hModule=GetModuleHandleA("iscomlog.dll");
    if (hModule == NULL) {
        IIS_PRINTF((buff,"GetModuleHandle failed with %d\n",GetLastError()));
        goto exit;
    }

    if (GetModuleFileNameA(hModule, szName, sizeof(szName))==0) {

        IIS_PRINTF((buff,
            "GetModuleFileName failed with %d\n",GetLastError()));
        goto exit;
    }

    hKey = CreateKey(hClapi,CLAPI_INPROC_SERVER,szName);

    if ( hKey == NULL ) {
        goto exit;
    }

    if (RegSetValueExA(hKey,
                "ThreadingModel",
                0,
                REG_SZ,
                (LPBYTE)"Both",
                sizeof("Both")) != ERROR_SUCCESS) {

        RegCloseKey(hKey);
        goto exit;
    }

    RegCloseKey(hKey);

    //
    // Set ProgID key
    //

    hKey = CreateKey(hClapi,"ProgID",LOGPUBLIC_PROG_ID);
    if ( hKey == NULL ) {
        goto exit;
    }

    
    
    RegCloseKey(hKey);
    */
    
    ret = S_OK;

exit:

    if ( hClapi != NULL ) {
        RegCloseKey(hClapi);
        hClapi = NULL;
    }

    if ( hProgID != NULL ) {
        RegCloseKey(hProgID);
        hProgID = NULL;
    }

    if ( hCLSID != NULL ) {
        RegCloseKey(hCLSID);
        hCLSID = NULL;
    }

    return ret;

} // DllRegisterServer


STDAPI
DllUnregisterServer(
    VOID
    )
{
    LONG err;
    CHAR tmpBuf[MAX_PATH+1];

    //
    // delete CLASSES/CLAPI.INETLOGINFORMATION/CLSID
    //

    strcpy(tmpBuf,CLAPI_PROG_ID);
    strcat(tmpBuf,TEXT("\\"));
    strcat(tmpBuf,CLAPI_CLSID_KEY_NAME);

    err = RegDeleteKey(HKEY_CLASSES_ROOT, tmpBuf);

    //
    // delete CLASSES/CLAPI.INETLOGINFORMATION
    //

    err = RegDeleteKey(HKEY_CLASSES_ROOT, CLAPI_PROG_ID);

    //
    // delete CLASSES/CLSID/{}/InProcServer32
    //

    strcpy(tmpBuf,CLAPI_CLSID_KEY_NAME);
    strcat(tmpBuf,TEXT("\\"));
    strcat(tmpBuf,CLAPI_CLSID);
    strcat(tmpBuf,TEXT("\\"));
    strcat(tmpBuf,CLAPI_INPROC_SERVER);

    err = RegDeleteKey(HKEY_CLASSES_ROOT, tmpBuf);

    //
    // delete CLASSES/CLSID/{}/ProgID
    //

    strcpy(tmpBuf,CLAPI_CLSID_KEY_NAME);
    strcat(tmpBuf,TEXT("\\"));
    strcat(tmpBuf,CLAPI_CLSID);
    strcat(tmpBuf,TEXT("\\"));
    strcat(tmpBuf,"ProgID");

    err = RegDeleteKey(HKEY_CLASSES_ROOT, tmpBuf);

    //
    // delete CLASSES/CLSID/{}
    //

    strcpy(tmpBuf,CLAPI_CLSID_KEY_NAME);
    strcat(tmpBuf,TEXT("\\"));
    strcat(tmpBuf,CLAPI_CLSID);

    err = RegDeleteKey(HKEY_CLASSES_ROOT, tmpBuf);

    /*
    //
    // delete CLASSES/MSIISLOG.MSLOGPUBLIC/CLSID
    //

    strcpy(tmpBuf,LOGPUBLIC_PROG_ID);
    strcat(tmpBuf,TEXT("\\"));
    strcat(tmpBuf,CLAPI_CLSID_KEY_NAME);

    err = RegDeleteKey(HKEY_CLASSES_ROOT, tmpBuf);

    //
    // delete CLASSES/CLAPI.INETLOGINFORMATION
    //

    err = RegDeleteKey(HKEY_CLASSES_ROOT, LOGPUBLIC_PROG_ID);

    //
    // delete CLASSES/CLSID/{}/InProcServer32
    //

    strcpy(tmpBuf,CLAPI_CLSID_KEY_NAME);
    strcat(tmpBuf,TEXT("\\"));
    strcat(tmpBuf,LOGPUBLIC_CLSID);
    strcat(tmpBuf,TEXT("\\"));
    strcat(tmpBuf,CLAPI_INPROC_SERVER);

    err = RegDeleteKey(HKEY_CLASSES_ROOT, tmpBuf);

    //
    // delete CLASSES/CLSID/{}/ProgID
    //

    strcpy(tmpBuf,CLAPI_CLSID_KEY_NAME);
    strcat(tmpBuf,TEXT("\\"));
    strcat(tmpBuf,LOGPUBLIC_CLSID);
    strcat(tmpBuf,TEXT("\\"));
    strcat(tmpBuf,"ProgID");

    err = RegDeleteKey(HKEY_CLASSES_ROOT, tmpBuf);

    //
    // delete CLASSES/CLSID/{}
    //

    strcpy(tmpBuf,CLAPI_CLSID_KEY_NAME);
    strcat(tmpBuf,TEXT("\\"));
    strcat(tmpBuf,LOGPUBLIC_CLSID);

    err = RegDeleteKey(HKEY_CLASSES_ROOT, tmpBuf);
    */
    
    return S_OK;

} // DllUnregisterServer
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\info\server\rpccom.cxx ===
/*++
   Copyright    (c)    1996        Microsoft Corporation

   Module Name:
        rpccom.cxx

   Abstract:

        This module contains the server side service RPC admin APIs for K2


   Author:

        Johnson Apacible    (johnsona)      06-03-96


--*/

//
//  Include Headers
//

#include <tcpdllp.hxx>
#include <tsunami.hxx>

extern "C" {
#include <info_srv.h>
};

#include <atq.h>
#include "inetreg.h"
#include <iisver.h>

// forward definition

NET_API_STATUS
NET_API_FUNCTION
InitW3PerfCounters(
	OUT LPDWORD lpcbTotalRequired
	);

NET_API_STATUS
NET_API_FUNCTION
CollectW3PerfCounters( LPWSTR    lpValueName,
                       LPBYTE  * lppData,
                       LPDWORD   lpcbTotalBytes,
                       LPDWORD   lpNumObjectTypes
					 );


NET_API_STATUS
NET_API_FUNCTION
GetStatistics(
    IN DWORD    dwLevel,
    IN DWORD    dwServiceId,
    IN DWORD    dwInstance,
    OUT PCHAR * pBuffer
    )
/*++

   Description

     Common get statistics routine

   Arguments:

      dwLevel - level of the statistics to get
      dwServiceId - ID of the service to get stats from
      dwInstance - instance whose stats we are to get
      InfoStruct - Will contain the returned buffer

   Note:

--*/
{
    DWORD err = NO_ERROR;
    PCHAR buffer;
    PIIS_SERVICE  pInetSvc;

    IF_DEBUG( DLL_RPC) {

       DBGPRINTF( ( DBG_CONTEXT,
                   " Entering GetStatistics (L%d)\n", dwLevel));
    }

    //
    // Do we have permissions?
    //

    if ( (err = TsApiAccessCheck( TCP_QUERY_STATISTICS )) != NO_ERROR) {
        IF_DEBUG( DLL_RPC) {

            DBGPRINTF( ( DBG_CONTEXT,
                        " TsApiAccessCheck() Failed. Error = %u\n", err));
        }
        return(err);
    }

    pInetSvc = IIS_SERVICE::FindFromServiceInfoList( dwServiceId );
    if ( pInetSvc == NULL ) {
        return ERROR_SERVICE_NOT_ACTIVE;
    }

    //
    // Get the params
    //

    if (!pInetSvc->GetInstanceStatistics(
                                        dwInstance,
                                        dwLevel,
                                        pBuffer
                                        ) ) {

        err =  GetLastError();
        IF_DEBUG( DLL_RPC) {
            DBGPRINTF( ( DBG_CONTEXT,
                        "GetInstanceStats failed. Error = %u\n",
                        err));
        }
    }

    //
    // This was referenced in Find
    //

    pInetSvc->Dereference( );

    return err;

} // GetStatistics



NET_API_STATUS
NET_API_FUNCTION
ClearStatistics(
    IN DWORD    dwServiceId,
    IN DWORD    dwInstance
    )
/*++

   Description

     Common get statistics routine

   Arguments:

      pszServer - unused
      dwServerMask - Bitfield of servers to set the information for
      pConfig - Admin information to set

   Note:

--*/
{
    DWORD err = NO_ERROR;
    PCHAR buffer;
    PIIS_SERVICE  pInetSvc;

    IF_DEBUG( DLL_RPC) {

       DBGPRINTF( ( DBG_CONTEXT,
                   " Entering ClearStatistics (Instance %d)\n", dwInstance));
    }

    //
    // Do we have permissions?
    //

    if ( (err = TsApiAccessCheck( TCP_CLEAR_STATISTICS )) != NO_ERROR) {
        IF_DEBUG( DLL_RPC) {

            DBGPRINTF( ( DBG_CONTEXT,
                        " TsApiAccessCheck() Failed. Error = %u\n", err));
        }
        return(err);
    }

    pInetSvc = IIS_SERVICE::FindFromServiceInfoList( dwServiceId );
    if ( pInetSvc == NULL ) {
        return ERROR_SERVICE_NOT_ACTIVE;
    }

    //
    // Get the params
    //

    if (!pInetSvc->ClearInstanceStatistics(dwInstance) ) {

        err =  GetLastError();
        IF_DEBUG( DLL_RPC) {
            DBGPRINTF( ( DBG_CONTEXT,
                        "GetInstanceStats failed. Error = %u\n",
                        err));
        }
    }

    //
    // This was referenced in Find
    //

    pInetSvc->Dereference( );

    return err;

} // ClearStatistics


NET_API_STATUS
NET_API_FUNCTION
R_InitW3CounterStructure(
    IN LPWSTR   pszServer OPTIONAL,
	OUT LPDWORD lpcbTotalRequired
    )
/*++

   Description

     Initialize W3 object and counter indexes

   Arguments:

	 pszServer - unused
	 lpcbTotalRequired - size of memory needed to retrieve w3 performance data

   Note:

--*/
{

	return ERROR_NOT_SUPPORTED;

} // R_InitW3CounterStructure


NET_API_STATUS
NET_API_FUNCTION
R_CollectW3PerfData(
    IN LPWSTR        pszServer OPTIONAL,
	IN LPWSTR        lpValueName,
    OUT LPBYTE       lppData,
    IN OUT LPDWORD   lpcbTotalBytes,
    OUT LPDWORD   lpNumObjectTypes
	)
/*++

   Description

     Collect W3 perfomance data

   Arguments:

	 pszServer - unused
	 lpValueName - counter object name to be retrieved
	 lppData - will hold the returned W3 performance data
	 lpcbTotalBytes - total bytes of W3 performance data returned
	 lpNumobjectTypes - number of object types returned

   Note:

--*/
{

	return ERROR_NOT_SUPPORTED;

}


NET_API_STATUS
NET_API_FUNCTION
R_W3QueryStatistics2(
    IN LPWSTR                       pszServer OPTIONAL,
    IN DWORD                        dwLevel,
    IN DWORD                        dwInstance,
    IN DWORD                        dwReserved,
    IN LPW3_STATISTICS_STRUCT       InfoStruct
    )
/*++

   Description

     Gets the W3 specific statistics

   Arguments:

      pszServer - unused
      dwLevel - level of the statistics to get
      dwInstance - instance whose stats we are to get
      dwReserved - MBZ
      InfoStruct - Will contain the returned buffer

   Note:

--*/
{
    DWORD err;
    PCHAR buffer;

    err = GetStatistics(
                    dwLevel,
                    INET_HTTP_SVC_ID,
                    dwInstance,
                    &buffer
                    );

    if ( err == NO_ERROR ) {
        InfoStruct->StatInfo1 = (LPW3_STATISTICS_1)buffer;
    }

    return ( err);

} // W3GetStatistics



NET_API_STATUS
NET_API_FUNCTION
R_W3ClearStatistics2(
    IN LPWSTR                       pszServer OPTIONAL,
    IN DWORD                        dwInstance
    )
/*++

   Description

     Clears the W3 specific statistics

   Arguments:

      pszServer - unused
      dwInstance - instance whose stats we should clear

   Note:

--*/
{
    DWORD err;

    err = ClearStatistics(
                INET_HTTP_SVC_ID,
                dwInstance
                );

    return err;

} // W3ClearStatistics



NET_API_STATUS
NET_API_FUNCTION
R_FtpQueryStatistics2(
    IN LPWSTR                       pszServer OPTIONAL,
    IN DWORD                        dwLevel,
    IN DWORD                        dwInstance,
    IN DWORD                        dwReserved,
    IN LPFTP_STATISTICS_STRUCT       InfoStruct
    )
/*++

   Description

     Gets the Ftp specific statistics

   Arguments:

      pszServer - unused
      dwLevel - level of the statistics to get
      dwInstance - instance whose stats we are to get
      dwReserved - MBZ
      InfoStruct - Will contain the returned buffer

   Note:

--*/
{
    DWORD err;
    PCHAR buffer;

    err = GetStatistics(
                    dwLevel,
                    INET_FTP_SVC_ID,
                    dwInstance,
                    &buffer
                    );

    if ( err == NO_ERROR ) {
        InfoStruct->StatInfo0 = (LPFTP_STATISTICS_0)buffer;
    }

    return ( err);

} // FtpGetStatistics



NET_API_STATUS
NET_API_FUNCTION
R_FtpClearStatistics2(
    IN LPWSTR                       pszServer OPTIONAL,
    IN DWORD                        dwInstance
    )
/*++

   Description

     Clears the Ftp specific statistics

   Arguments:

      pszServer - unused
      dwInstance - instance whose stats we should clear

   Note:

--*/
{
    DWORD err;

    err = ClearStatistics(
                INET_FTP_SVC_ID,
                dwInstance
                );

    return err;

} // FtpClearStatistics


NET_API_STATUS
NET_API_FUNCTION
R_IISEnumerateUsers(
    IN LPWSTR                   pszServer OPTIONAL,
    IN DWORD                    dwServiceId,
    IN DWORD                    dwInstance,
    OUT LPIIS_USER_ENUM_STRUCT  InfoStruct
    )
/*++

   Description

     Enumerates the users for a given instance.

   Arguments:

      pszServer - unused
      dwServiceId - service ID
      dwInstance - instance ID
      InfoStruct - structure to get the information with.

   Note:

--*/
{
    DWORD err = NO_ERROR;
    PCHAR buffer = NULL;
    DWORD nRead = 0;
    DWORD dwLevel = InfoStruct->Level;
    PIIS_SERVICE  pInetSvc;

    IF_DEBUG( DLL_RPC) {

       DBGPRINTF( ( DBG_CONTEXT,
                   " Entering R_IISEnumerateUsers (L%d) for Service %x\n",
                    dwLevel, dwServiceId));
    }

    //
    // We only support 1
    //

    if ( dwLevel != 1 ) {
        return(ERROR_INVALID_LEVEL);
    }

    if ( ( err = TsApiAccessCheck( TCP_ENUMERATE_USERS)) != NO_ERROR) {

       IF_DEBUG( DLL_RPC) {
            DBGPRINTF( ( DBG_CONTEXT,
                        " TsApiAccessCheck() Failed. Error = %u\n", err));
       }
       return(err);
    }

    pInetSvc = IIS_SERVICE::FindFromServiceInfoList( dwServiceId );
    if ( pInetSvc == NULL ) {
        buffer = NULL;
        nRead = 0;
        return ERROR_SERVICE_NOT_ACTIVE;
    }

    //
    // Get the params
    //

    if ( !pInetSvc->EnumerateInstanceUsers(
                                dwInstance,
                                &nRead,
                                &buffer) ) {

        DBG_ASSERT(buffer == NULL);
        DBG_ASSERT(nRead == 0);
        err = GetLastError();

    } else {

        InfoStruct->ConfigInfo.Level1->Buffer =
                        (LPIIS_USER_INFO_1)buffer;
        InfoStruct->ConfigInfo.Level1->EntriesRead = nRead;
    }

    //
    // This was referenced in Find
    //

    pInetSvc->Dereference( );

    return err;

} // R_IISEnumerateUsers



NET_API_STATUS
NET_API_FUNCTION
R_IISDisconnectUser(
    IN LPWSTR                   pszServer OPTIONAL,
    IN DWORD                    dwServiceId,
    IN DWORD                    dwInstance,
    IN DWORD                    dwIdUser
    )
/*++

   Description

     Enumerates the users for a given instance.

   Arguments:

      pszServer - unused
      dwServiceId - service ID
      dwInstance - instance ID
      InfoStruct - structure to get the information with.

   Note:

--*/
{
    DWORD err = NO_ERROR;
    PIIS_SERVICE  pInetSvc;

    IF_DEBUG( DLL_RPC) {

       DBGPRINTF( ( DBG_CONTEXT,
                   " Entering R_IISDisconnectUsers for Service %x\n",
                    dwServiceId));
    }

    if ( ( err = TsApiAccessCheck( TCP_DISCONNECT_USER )) != NO_ERROR) {

       IF_DEBUG( DLL_RPC) {
            DBGPRINTF( ( DBG_CONTEXT,
                        " TsApiAccessCheck() Failed. Error = %u\n", err));
       }
       return(err);
    }

    pInetSvc = IIS_SERVICE::FindFromServiceInfoList( dwServiceId );
    if ( pInetSvc == NULL ) {
        return ERROR_SERVICE_NOT_ACTIVE;
    }

    //
    // Get the params
    //

    if ( !pInetSvc->DisconnectInstanceUser(
                                dwInstance,
                                dwIdUser) ) {

        err = GetLastError();

    }

    //
    // This was referenced in Find
    //

    pInetSvc->Dereference( );

    return ( err);

} // R_IISDisconnectUsers
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\log\comlog\logpublic.cxx ===
/*++

   Copyright    (c)    1997    Microsoft Corporation

   Module  Name :
        logpublic.cxx

   Abstract:
        Public Log COM Object

   Author:

       Saurab Nog (SaurabN)      25-March-1998


--*/

#include "precomp.hxx"
#include "comlog.hxx"

CInetLogPublic::CInetLogPublic(
    VOID
    ):
    m_pContext      ( NULL),
    m_refCount      ( 0)

{
    InitializeListHead(&m_ListEntry);
    
} // CInetLogPublic::CInetLogPublic


CInetLogPublic::~CInetLogPublic(
    VOID
    )
{

} // CInetLogPublic::~CInetLogPublic


ULONG
CInetLogPublic::AddRef(
    VOID
    )
{
    DWORD dwRefCount =  InterlockedIncrement( &m_refCount );
    return(dwRefCount);
} // CInetLogPublic::AddRef


ULONG
CInetLogPublic::Release(
    VOID
    )
{
    DWORD dwRefCount =  InterlockedDecrement( &m_refCount );
    
    if (dwRefCount == 0) 
    {
        EnterCriticalSection( &COMLOG_CONTEXT::sm_listLock );
        RemoveEntryList(&m_ListEntry);
        LeaveCriticalSection( &COMLOG_CONTEXT::sm_listLock );

        delete this;
    }
    
    return(dwRefCount);
    
} // CInetLogPublic::Release


HRESULT
CInetLogPublic::QueryInterface(
    REFIID riid,
    VOID **ppObj
    )
{
    if ( riid == IID_IUnknown ||
         riid == IID_IInetLogPublic) 
    {

        *ppObj = (CInetLogPublic *)this;
        AddRef();
        return(NO_ERROR);
    } 
    else 
    {
        return(E_NOINTERFACE);
    }
} // CInetLogPublic::QueryInterface


HRESULT  
CInetLogPublic::SetLogInstance(
    LPSTR szInstance
    )
{
    PLIST_ENTRY     listEntry;
    COMLOG_CONTEXT* pContext = NULL;
    HRESULT         hr = E_FAIL;

    //
    // Search through the context list for a matching context
    //
    
    EnterCriticalSection( &COMLOG_CONTEXT::sm_listLock );

    for ( listEntry = COMLOG_CONTEXT::sm_ContextListHead.Flink;
          listEntry != &COMLOG_CONTEXT::sm_ContextListHead;
          listEntry = listEntry->Flink    ) 
    {

        pContext = (COMLOG_CONTEXT*)CONTAINING_RECORD(
                                        listEntry,
                                        COMLOG_CONTEXT,
                                        m_ContextListEntry
                                        );

        if (0 != strcmp(pContext->m_strInstanceName.QueryStr(), szInstance))
        {
            pContext = NULL;
        }
        else
        {
            break;
        }
    }

    if ( NULL != pContext)
    {
        if (NULL != m_pContext)
        {
            RemoveEntryList(&m_ListEntry);
        }
        
        m_pContext = pContext;

        InsertTailList(
                &m_pContext->m_PublicListEntry,
                &m_ListEntry
                );
                
        hr = S_OK;
    }

    LeaveCriticalSection( &COMLOG_CONTEXT::sm_listLock );
    return hr;
}

HRESULT 
CInetLogPublic::LogInformation( 
    IInetLogInformation *pLogObj 
    )
{
    if (NULL == m_pContext)
    {
        return (E_HANDLE);
    }

    m_pContext->LogInformation(pLogObj);
    return S_OK;
}
        
HRESULT 
CInetLogPublic::LogCustomInformation( 
    IN  DWORD               cCount, 
    IN  PCUSTOM_LOG_DATA    pCustomLogData,
    IN  LPSTR               szHeaderSuffix
    )
{
    if (NULL == m_pContext)
    {
        return (E_HANDLE);
    }

    m_pContext->LogCustomInformation(cCount, pCustomLogData, szHeaderSuffix);
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\log\comlog\logobj.cxx ===
/*++

   Copyright    (c)    1997    Microsoft Corporation

   Module  Name :
        logobj.cxx

   Abstract:
        Log COM Object

   Author:

       Johnson Apacible (JohnsonA)      02-April-1997


--*/

#include "precomp.hxx"
#include "comlog.hxx"

CInetLogInformation::CInetLogInformation(
    VOID
    ):
    m_refCount              ( 0),
    m_szClientAddress       ( NULL),
    m_szServerAddress       ( NULL),
    m_szUserName            ( NULL),
    m_szOperation           ( NULL),
    m_szTarget              ( NULL),
    m_szParameters          ( NULL),
    m_szHTTPHeaders         ( NULL),
    m_szVersion             ( NULL),
    m_cbSiteName            ( 0),
    m_cbComputerName        ( 0),
    m_cbServerAddress       ( 0),
    m_cbClientAddress       ( 0),
    m_cbUserName            ( 0),
    m_cbOperation           ( 0),
    m_cbTarget              ( 0),
    m_cbParameters          ( 0),
    m_cbHTTPHeaders         ( 0),
    m_cbVersion             ( 0),
    m_dwPort                ( 0),
    m_msProcessingTime      ( 0),
    m_dwWin32Status         ( 0),
    m_dwProtocolStatus      ( 0),
    m_bytesSent             ( 0),
    m_bytesRecv             ( 0)

{
    m_szSiteName[0] = '\0';
    m_szComputerName[0] = '\0';

} // CInetLogInformation::CInetLogInformation


CInetLogInformation::~CInetLogInformation(
    VOID
    )
{

} // CInetLogInformation::~CInetLogInformation



ULONG
CInetLogInformation::AddRef(
    VOID
    )
{
    InterlockedIncrement( &m_refCount );
    return(m_refCount);
} // CInetLogInformation::AddRef


ULONG
CInetLogInformation::Release(
    VOID
    )
{
    InterlockedDecrement( &m_refCount );
    return(m_refCount);
} // CInetLogInformation::Release


HRESULT
CInetLogInformation::QueryInterface(
    REFIID riid,
    VOID **ppObj
    )
{
    if ( riid == IID_IUnknown ||
         riid == IID_IINETLOG_INFORMATION ) {

        *ppObj = (CInetLogInformation *)this;
        AddRef();
        return(NO_ERROR);
    } else {

        return(E_NOINTERFACE);
    }
} // CInetLogInformation::QueryInterface


#define RETURN_STRING_INFO( _pBuf, _pcbBuf, _pInfo, _cbInfo ) { \
    if ( (_pBuf) != NULL ) {                                    \
                                                                \
        if ( *(_pcbBuf) >= (_cbInfo) ) {                        \
            CopyMemory( _pBuf, _pInfo, _cbInfo );               \
        } else {                                                \
            *(_pcbBuf) = (_cbInfo);                             \
            return(NULL);                                       \
        }                                                       \
    }                                                           \
    *(_pcbBuf) = (_cbInfo);                                     \
    return(_pInfo);                                             \
}


LPSTR STDMETHODCALLTYPE
CInetLogInformation::GetSiteName(
    IN PCHAR    pszSiteName,
    IN PDWORD   pcbSize
    )
{
    RETURN_STRING_INFO(
            pszSiteName,
            pcbSize,
            m_szSiteName,
            m_cbSiteName);

} // GetSiteName


LPSTR STDMETHODCALLTYPE
CInetLogInformation::GetComputerName(
    IN PCHAR    pszComputerName,
    IN PDWORD   pcbSize
    )
{
    RETURN_STRING_INFO(
            pszComputerName,
            pcbSize,
            m_szComputerName,
            m_cbComputerName);

} // GetComputerName



LPSTR STDMETHODCALLTYPE
CInetLogInformation::GetClientHostName(
    IN PCHAR    pszClientHostName,
    IN PDWORD   pcbSize
    )
{
    RETURN_STRING_INFO(
            pszClientHostName,
            pcbSize,
            m_szClientAddress,
            m_cbClientAddress);

} // GetClientHostName


LPSTR STDMETHODCALLTYPE
CInetLogInformation::GetClientUserName(
    IN PCHAR    pszClientUserName,
    IN PDWORD   pcbSize
    )
{
    RETURN_STRING_INFO(
            pszClientUserName,
            pcbSize,
            m_szUserName,
            m_cbUserName);

} // GetClientUserName


LPSTR STDMETHODCALLTYPE
CInetLogInformation::GetServerAddress(
    IN PCHAR    pszServerAddress,
    IN PDWORD   pcbSize
    )
{
    RETURN_STRING_INFO(
            pszServerAddress,
            pcbSize,
            m_szServerAddress,
            m_cbServerAddress);

} // GetServerIPAddress



LPSTR STDMETHODCALLTYPE
CInetLogInformation::GetOperation(
    IN PCHAR    pszOperation,
    IN PDWORD   pcbSize
    )
{
    RETURN_STRING_INFO(
            pszOperation,
            pcbSize,
            m_szOperation,
            m_cbOperation);
} // GetOperation


LPSTR STDMETHODCALLTYPE
CInetLogInformation::GetTarget(
    IN PCHAR    pszTarget,
    IN PDWORD   pcbSize
    )
{
    RETURN_STRING_INFO(
            pszTarget,
            pcbSize,
            m_szTarget,
            m_cbTarget);

} // GetTarget


LPSTR STDMETHODCALLTYPE
CInetLogInformation::GetParameters(
    IN PCHAR    pszParameters,
    IN PDWORD   pcbSize
    )
{
    RETURN_STRING_INFO(
            pszParameters,
            pcbSize,
            m_szParameters,
            m_cbParameters);

} // GetParameters


LPSTR STDMETHODCALLTYPE
CInetLogInformation::GetExtraHTTPHeaders(
    IN PCHAR    pszHTTPHeaders,
    IN PDWORD   pcbSize
    )
{
    RETURN_STRING_INFO(
            pszHTTPHeaders,
            pcbSize,
            m_szHTTPHeaders,
            m_cbHTTPHeaders);
} // GetExtraHTTPHeaders


DWORD STDMETHODCALLTYPE
CInetLogInformation::GetTimeForProcessing(
    VOID
    )
{
    return(m_msProcessingTime);
} // GetTimeForProcessing


DWORD STDMETHODCALLTYPE
CInetLogInformation::GetPortNumber(
    VOID
    )
{
    return(m_dwPort);
} // GetPortNumber

DWORD STDMETHODCALLTYPE
CInetLogInformation::GetBytesSent(
    VOID
    )
{
    return(m_bytesSent);
} // GetBytesSent


DWORD STDMETHODCALLTYPE
CInetLogInformation::GetBytesRecvd(
    VOID
    )
{
    return(m_bytesRecv);
} // GetBytesRecvd


DWORD STDMETHODCALLTYPE
CInetLogInformation::GetWin32Status(
    VOID
    )
{
    return(m_dwWin32Status);
} // GetWin32Status

DWORD STDMETHODCALLTYPE
CInetLogInformation::GetProtocolStatus(
    VOID
    )
{
    return(m_dwProtocolStatus);
} // GetProtocolStatus


LPSTR STDMETHODCALLTYPE
CInetLogInformation::GetVersionString(
    IN PCHAR    pszVersionString,
    IN PDWORD   pcbSize
    )
{
    RETURN_STRING_INFO(
            pszVersionString,
            pcbSize,
            m_szVersion,
            m_cbVersion);

} //GetVersionString



CHAR szNULL[] = "";
CHAR szDotDot[] = "...";

VOID
CInetLogInformation::CanonicalizeLogRecord(
        IN INETLOG_INFORMATION * pInetLogRecord,
        IN LPCSTR   pszSiteName,
        IN LPCSTR   pszComputerName,
        IN BOOL     fDefault
        )
{
    m_szClientAddress = pInetLogRecord->pszClientHostName;
    if ( m_szClientAddress == NULL ) {
        m_szClientAddress = szNULL;
        m_cbClientAddress = 0;
    } else {
        m_cbClientAddress = pInetLogRecord->cbClientHostName;
    }

    m_szOperation = pInetLogRecord->pszOperation;
    if ( m_szOperation == NULL ) {
        m_szOperation = szNULL;
        m_cbOperation = 0;
    } else {
        m_cbOperation = pInetLogRecord->cbOperation;
        if ( m_cbOperation > MAX_LOG_OPERATION_FIELD_LEN ) {
            m_cbOperation = MAX_LOG_OPERATION_FIELD_LEN;
        }
    }

    m_szTarget = pInetLogRecord->pszTarget;
    if ( m_szTarget == NULL ) {
        m_szTarget = szNULL;
        m_cbTarget = 0;
    } else {
        m_cbTarget = pInetLogRecord->cbTarget;
        if ( m_cbTarget > MAX_LOG_TARGET_FIELD_LEN ) {
            m_cbTarget = MAX_LOG_TARGET_FIELD_LEN;
        }
    }

    m_dwProtocolStatus = pInetLogRecord->dwProtocolStatus;
    m_bytesSent = pInetLogRecord->dwBytesSent;
    m_bytesRecv = pInetLogRecord->dwBytesRecvd;

    if ( fDefault ) {
        return;
    }

    strcpy( m_szSiteName, pszSiteName );
    strcpy( m_szComputerName, pszComputerName );

    m_cbSiteName = (DWORD)strlen(m_szSiteName);
    m_cbComputerName = (DWORD)strlen(m_szComputerName);

    m_szUserName = pInetLogRecord->pszClientUserName;
    if ( m_szUserName == NULL ) {
        m_szUserName = szNULL;
        m_cbUserName = 0;
    } else {
        m_cbUserName = (DWORD)strlen(m_szUserName);
        if ( m_cbUserName > MAX_LOG_USER_FIELD_LEN ) {
            m_cbUserName = MAX_LOG_USER_FIELD_LEN;
        }
    }

    //
    // If server IP is empty, then set it the first time
    //

    m_szServerAddress = pInetLogRecord->pszServerAddress;
    if ( m_szServerAddress == NULL ) {
        m_szServerAddress = szNULL;
        m_cbServerAddress = 0;
    } else {
        m_cbServerAddress = (DWORD)strlen(m_szServerAddress);
    }

    if ( pInetLogRecord->pszParameters == NULL ) {
        m_szParameters = szNULL;
        m_cbParameters = 0;
    } else {
        m_szParameters = pInetLogRecord->pszParameters;
        m_cbParameters = (DWORD)strlen(m_szParameters);
        if ( m_cbParameters > MAX_LOG_PARAMETER_FIELD_LEN ) {
            m_szParameters = szDotDot;
            m_cbParameters = 3;
        }
    }

    if ( pInetLogRecord->pszHTTPHeader == NULL ) {
        m_szHTTPHeaders = szNULL;
        m_cbHTTPHeaders = 0;
    } else {
        m_szHTTPHeaders = pInetLogRecord->pszHTTPHeader;
        m_cbHTTPHeaders =  pInetLogRecord->cbHTTPHeaderSize;
    }

    if ( pInetLogRecord->pszVersion == NULL ) {
        m_szVersion = szNULL;
        m_cbVersion = 0;
    } else {
        m_szVersion = pInetLogRecord->pszVersion;
        m_cbVersion = (DWORD)strlen(m_szVersion);
    }

    m_msProcessingTime = pInetLogRecord->msTimeForProcessing;
    m_dwWin32Status = pInetLogRecord->dwWin32Status;
    m_dwPort        = pInetLogRecord->dwPort;
    return;

} // CanonicalizeLogRecord
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\log\plugin\const.h ===
#ifndef _CONST_H_
#define _CONST_H_

#include <lmcons.h>
#include "inetcom.h"

//
// Default values for Logging related registry parameters
//

#define   DEFAULT_LOG_FILE_DIRECTORY_NT             "%systemroot%\\system32\\LogFiles"
#define   DEFAULT_LOG_FILE_TRUNCATE_SIZE            NO_FILE_TRUNCATION
#define   DEFAULT_LOG_FILE_PERIOD                   INET_LOG_PERIOD_DAILY
#define   DEFAULT_LOG_SQL_DATASOURCE                "InternetDb"
#define   DEFAULT_LOG_SQL_TABLE                     "InternetLog"
#define   DEFAULT_LOG_SQL_USER_NAME                 "InternetAdmin"
#define   DEFAULT_LOG_SQL_PASSWORD                  ""

#define DEFAULT_LOG_FILE_NAME                      "inetsvcs"
#define DEFAULT_EXTENDED_LOG_FILE_NAME             "extended"
#define DEFAULT_NCSA_LOG_FILE_NAME                 "ncsa"
#define DEFAULT_LOG_FILE_EXTENSION                 "log"

#define DEFAULT_DELIMITER_CHAR_IN_LOG_RECORD        ','

#endif  // _CONST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\log\plugin\global.h ===
#ifndef _GLOBAL_H_
#define _GLOBAL_H_

#include <inetsvcs.h>

DWORD
WeekOfMonth(
    IN LPSYSTEMTIME pstNow
    );

BOOL IsBeginningOfNewPeriod(
    IN DWORD          dwPeriod,
    IN LPSYSTEMTIME   pstCurrentFile,
    IN LPSYSTEMTIME   pstNow
    );

VOID
ConvertSpacesToPlus(
    IN LPSTR    pszString
    );

extern LPEVENT_LOG    g_eventLog;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\log\plugin\filectl.cpp ===
/*++

   Copyright    (c)    1995-1996    Microsoft Corporation

   Module  Name :
      filectl.cxx

   Abstract:
      OLE control to handle file logging object

   Author:

       Terence Kwan    ( terryk )    18-Sep-1996

   Project:

       IIS Logging 3.0

--*/

#include "precomp.hxx"
#include "initguid.h"
#include <ilogobj.hxx>
#include "filectl.hxx"
#include <issched.hxx>

#include <atlimpl.cpp>

#define LOG_FILE_SLOP       512

//
// tick minute.
//

#define TICK_MINUTE         (60 * 1000)

//************************************************************************************


VOID
LogWriteEvent(
    IN LPCSTR InstanceName,
    IN BOOL   fResume
    );

//
// globals
//

LPEVENT_LOG   g_eventLog = NULL;


CLogFileCtrl::CLogFileCtrl(
    VOID
    )
:
    m_fFirstLog             ( TRUE),
    m_pLogFile              ( NULL),
    m_fDiskFullShutdown     ( FALSE),
    m_fUsingCustomHeaders   ( FALSE),
    m_sequence              ( 1),
    m_TickResumeOpen        ( 0),
    m_strLogFileName        ( ),
    m_dwSchedulerCookie     ( 0),
    m_fInTerminate          ( FALSE)
/*++

Routine Description:
    Contructor for the log file control

Arguments:

Return Value:

--*/
{
    //
    // initialize all the internal variable
    //

    ZeroMemory( &m_stCurrentFile, sizeof( m_stCurrentFile));
    INITIALIZE_CRITICAL_SECTION( &m_csLock );
}


//************************************************************************************
// CLogFileCtrl::~CLogFileCtrl - Destructor

CLogFileCtrl::~CLogFileCtrl()
/*++

Routine Description:
    destructor for the log file control

Arguments:

Return Value:

--*/
{
    TerminateLog();

    DeleteCriticalSection( &m_csLock );
}

//************************************************************************************

STDMETHODIMP
CLogFileCtrl::InitializeLog(
                LPCSTR szInstanceName,
                LPCSTR pszMetabasePath,
                CHAR* pvIMDCOM )
/*++

Routine Description:
    Initialize log

Arguments:
    cbSize - size of the service name
    RegKey - service name
    dwInstanceOf - instance number

Return Value:

--*/
{
    //
    // get the default parameters
    //

    m_strInstanceName.Copy(szInstanceName);
    m_strMetabasePath.Copy(pszMetabasePath);
    m_pvIMDCOM = (LPVOID)pvIMDCOM;

    //
    // get the registry value
    //

    (VOID)GetRegParameters(
                    pszMetabasePath,
                    pvIMDCOM );

     return 0;
}

//************************************************************************************

STDMETHODIMP
CLogFileCtrl::TerminateLog(
    VOID
    )
/*++

Routine Description:
    clean up the log

Arguments:

Return Value:

--*/
{    
    Lock( );

    m_fInTerminate = TRUE;

    if ( m_pLogFile!=NULL) {
        m_pLogFile->CloseFile( );
        delete m_pLogFile;
        m_pLogFile = NULL;
    }

    if (m_dwSchedulerCookie)
    {
        RemoveWorkItem(m_dwSchedulerCookie);
    }

    m_dwSchedulerCookie = 0;

    m_fInTerminate = FALSE;
    
    Unlock( );

    return(TRUE);
}

//************************************************************************************

STDMETHODIMP
CLogFileCtrl::LogInformation(
            IInetLogInformation * ppvDataObj
            )
/*++

Routine Description:
    log information

Arguments:
    ppvDataObj - COM Logging object

Return Value:

--*/
{
    SYSTEMTIME stNow;

    CHAR    tmpBuf[512];
    DWORD   dwSize = sizeof(tmpBuf);
    PCHAR   pBuf = tmpBuf;
    DWORD   err;

retry:

    err = NO_ERROR;
    
    if ( FormatLogBuffer(ppvDataObj,
                        pBuf,
                        &dwSize,
                        &stNow         // time is returned
                        ) 
       ) 
    {
        WriteLogInformation(stNow, pBuf, dwSize, FALSE, FALSE);
    }
    else 
    {

        err = GetLastError();
        
        IIS_PRINTF((buff,"FormatLogBuffer failed with %d\n",GetLastError()));

        if ( (err == ERROR_INSUFFICIENT_BUFFER) &&
             ( pBuf == tmpBuf ) &&
             (dwSize <= MAX_LOG_RECORD_LEN) ) 
        {
             
            pBuf = (PCHAR)LocalAlloc( 0, dwSize );
            
            if ( pBuf != NULL ) 
            {
                goto retry;
            }
        }
    }

    if ( (pBuf != tmpBuf) && (pBuf != NULL) ) 
    {
        LocalFree( pBuf );
    }
    
    return(0);

} // LogInformation

//************************************************************************************

STDMETHODIMP
CLogFileCtrl::GetConfig( DWORD, BYTE * log)
/*++

Routine Description:
    get configuration information

Arguments:
    cbSize - size of the data structure
    log - log configuration data structure

Return Value:

--*/
{
    InternalGetConfig( (PINETLOG_CONFIGURATIONA)log );
    return(0L);
}

//************************************************************************************

STDMETHODIMP
CLogFileCtrl::QueryExtraLoggingFields(
    IN PDWORD   pcbSize,
    PCHAR       pszFieldsList
    )
/*++

Routine Description:
    get configuration information

Arguments:
    cbSize - size of the data structure
    log - log configuration data structure

Return Value:

--*/
{
    InternalGetExtraLoggingFields( pcbSize, pszFieldsList );
    return(0L);
}

//************************************************************************************

STDMETHODIMP
CLogFileCtrl::LogCustomInformation( 
    IN  DWORD,
    IN  PCUSTOM_LOG_DATA,
    IN  LPSTR
    )
{
    return(0L);
}

//************************************************************************************

void
CLogFileCtrl::InternalGetExtraLoggingFields(
                            PDWORD pcbSize,
                            TCHAR *pszFieldsList
                            )
{
    pszFieldsList[0]=_T('\0');
    pszFieldsList[1]=_T('\0');
    *pcbSize = 2;
}

//************************************************************************************

VOID
CLogFileCtrl::InternalGetConfig(
    IN PINETLOG_CONFIGURATIONA pLogConfig
    )
/*++

Routine Description:
    internal; get configuration information function.

Arguments:
    log - log configuration data structure

Return Value:

--*/
{
    pLogConfig->inetLogType = INET_LOG_TO_FILE;
    strcpy(
        pLogConfig->u.logFile.rgchLogFileDirectory,
        QueryLogFileDirectory()
        );

    pLogConfig->u.logFile.cbSizeForTruncation = QuerySizeForTruncation();
    pLogConfig->u.logFile.ilPeriod = QueryPeriod();
    pLogConfig->u.logFile.ilFormat = QueryLogFormat();
}

//************************************************************************************

STDMETHODIMP
CLogFileCtrl::SetConfig(
                        DWORD,
                        BYTE * log
                        )
/*++

Routine Description:
    set the log configuration information

Arguments:
    cbSize - size of the configuration data structure
    log - log information

Return Value:

--*/
{
    //
    // write the configuration information to the registry
    //

    PINETLOG_CONFIGURATIONA pLogConfig = (PINETLOG_CONFIGURATIONA)log;
    SetSizeForTruncation( pLogConfig->u.logFile.cbSizeForTruncation );
    SetPeriod( pLogConfig->u.logFile.ilPeriod );
    SetLogFileDirectory( pLogConfig->u.logFile.rgchLogFileDirectory );
    return(0L);
} // CLogFileCtrl::SetConfig

//************************************************************************************

DWORD
CLogFileCtrl::GetRegParameters(
    IN LPCSTR pszRegKey,
    IN LPVOID
    )
/*++

Routine Description:
    get the registry value

Arguments:
    strRegKey - registry key

Return Value:

--*/
{

    DWORD err = NO_ERROR;
    MB    mb( (IMDCOM*) m_pvIMDCOM );
    DWORD dwSize;
    CHAR  szTmp[MAX_PATH+1];
    DWORD cbTmp = sizeof(szTmp);
    CHAR  buf[MAX_PATH+1];
    DWORD dwPeriod;

    if ( !mb.Open("") ) {
        err = GetLastError();
        return(err);
    }

    //
    // Get log file period
    //

    if ( mb.GetDword(
            pszRegKey,
            MD_LOGFILE_PERIOD,
            IIS_MD_UT_SERVER,
            &dwPeriod ) )
    {
        //
        // Make sure it is within bounds
        //

        if ( dwPeriod > INET_LOG_PERIOD_HOURLY ) 
        {
            IIS_PRINTF((buff,"Invalid log period %d, set to %d\n",
                dwPeriod, DEFAULT_LOG_FILE_PERIOD));

            dwPeriod = DEFAULT_LOG_FILE_PERIOD;
        }
        
    } 
    else 
    {
        dwPeriod = DEFAULT_LOG_FILE_PERIOD;
    }

    SetPeriod( dwPeriod );

    //
    //  Get truncate size
    //

    if ( dwPeriod == INET_LOG_PERIOD_NONE ) 
    {

        SetSizeForTruncation ( DEFAULT_LOG_FILE_TRUNCATE_SIZE );
        
        if ( mb.GetDword(   pszRegKey,
                            MD_LOGFILE_TRUNCATE_SIZE,
                            IIS_MD_UT_SERVER,
                            &dwSize ) ) 
        {

            if ( dwSize < MIN_FILE_TRUNCATION_SIZE ) 
            {
                dwSize = MIN_FILE_TRUNCATION_SIZE;
                IIS_PRINTF((buff,
                    "Setting truncation size to %d\n", dwSize));
            }

            SetSizeForTruncation( dwSize );
        }
    } 
    else 
    {
        SetSizeForTruncation( NO_FILE_TRUNCATION );
    }

    //
    // Get directory
    //

    if ( !mb.GetExpandString(
                    pszRegKey,
                    MD_LOGFILE_DIRECTORY,
                    IIS_MD_UT_SERVER,
                    szTmp,
                    &cbTmp ) )
    {
        lstrcpy(szTmp,
                DEFAULT_LOG_FILE_DIRECTORY_NT );
    }

    mb.Close();

    ExpandEnvironmentStrings( szTmp, buf, MAX_PATH+1 );
    SetLogFileDirectory( buf );
    
    return(err);

} // CLogFileCtrl::GetRegParameters

//************************************************************************************


BOOL
CLogFileCtrl::OpenLogFile(
    IN PSYSTEMTIME  pst
    )
/*++

Routine Description:
    internal routine to open file.

Arguments:

Return Value:

--*/
{
    BOOL fReturn = TRUE;
    BOOL bRet = FALSE;
    HANDLE hToken = NULL;
    DWORD dwError = NO_ERROR;
    CHAR  rgchPath[ MAX_PATH + 1 + 32];

    if ( m_pLogFile != NULL) {

        //
        // already a log file is open. return silently
        //

        IIS_PRINTF( ( buff,
                    " Log File %s is already open ( %p)\n",
                    m_strLogFileName.QueryStr(), m_pLogFile));

    } else {

        //
        // If this the first time we opened, get the file name
        //

        if ( m_fFirstLog || (QueryPeriod() != INET_LOG_PERIOD_NONE) ) {
            m_fFirstLog = FALSE;
            FormNewLogFileName( pst );
        }

        //
        // Append log file name to path to form the path of file to be opened.
        //

        if ( (m_strLogFileName.QueryCCH() +
                m_strLogFileDirectory.QueryCCH() >= MAX_PATH) ||
             (m_strLogFileDirectory.QueryCCH() < 3) ) {

            fReturn = FALSE;

            if ( (g_eventLog != NULL) && !m_fDiskFullShutdown) {

                const CHAR*    tmpString[1];
                tmpString[0] = rgchPath;
                g_eventLog->LogEvent(
                    LOG_EVENT_CREATE_DIR_ERROR,
                    1,
                    tmpString,
                    ERROR_BAD_PATHNAME );
            }
            SetLastError( ERROR_BAD_PATHNAME );
            goto exit;
        }

        lstrcpy( rgchPath, QueryLogFileDirectory());
//      if ( rgchPath[strlen(rgchPath)-1] != '\\' ) {

        if ( *CharPrev(rgchPath, rgchPath + strlen(rgchPath)) != '\\' ) {
            lstrcat( rgchPath, "\\");
        }
        lstrcat( rgchPath, QueryInstanceName() );

        //
        // There is a small chance that this function could be called (indirectly)
        // from an INPROC ISAPI completion thread (HSE_REQ_DONE).  In this case
        // the thread token is the impersonated user and may not have permissions
        // to open the log file (especially if the user is the IUSR_ account).  
        // To be paranoid, let's revert to LOCAL_SYSTEM anyways before opening.
        //

        if ( OpenThreadToken( GetCurrentThread(), 
                              TOKEN_ALL_ACCESS, 
                              FALSE, 
                              &hToken ) )
        {
            DBG_ASSERT( hToken != NULL );
            RevertToSelf();
        }

        // Allow logging to mapped drives
        
        bRet = IISCreateDirectory( rgchPath, TRUE );
        dwError = GetLastError();

        if ( hToken != NULL )
        {
            SetThreadToken( NULL, hToken );
            SetLastError( dwError );
        } 
    
        if ( !bRet ) {

            if ( (g_eventLog != NULL) && !m_fDiskFullShutdown) {

                const CHAR*    tmpString[1];
                tmpString[0] = rgchPath;
                g_eventLog->LogEvent(
                    LOG_EVENT_CREATE_DIR_ERROR,
                    1,
                    tmpString,
                    GetLastError()
                    );
            }

            IIS_PRINTF((buff,"IISCreateDir[%s] error %d\n",
                rgchPath, GetLastError()));
            fReturn = FALSE;
            goto exit;
        }

        lstrcat( rgchPath, "\\");
        lstrcat( rgchPath, m_strLogFileName.QueryStr());

        m_pLogFile = new ILOG_FILE( );

        if (m_pLogFile != NULL) {

            if ( m_pLogFile->Open(
                        rgchPath,
                        QuerySizeForTruncation(),
                        !m_fDiskFullShutdown
                        ) ) {

                m_pLogFile->QueryFileSize(&m_cbTotalWritten);
            } else {

                delete m_pLogFile;
                m_pLogFile = NULL;
                fReturn = FALSE;
            }

        } else {

            IIS_PRINTF((buff,"Unable to allocate ILOG_FILE[err %d]\n",
                GetLastError()));

            fReturn = FALSE;
        }
    }

exit:

    return ( fReturn);

} // CLogFileCtrl::OpenLogFile

//************************************************************************************


BOOL
CLogFileCtrl::WriteLogDirectives(
    IN DWORD Sludge
    )
/*++

Routine Description:
    virtual function for the sub class to log directives to the file.

Arguments:

    Sludge - number of additional bytes that needs to be written
        together with the directives

Return Value:

    TRUE, ok
    FALSE, not enough space to write.

--*/
{
    //
    // if we will overflow, open another file
    //

    if ( IsFileOverFlowForCB( Sludge ) ) {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        DBGPRINTF((DBG_CONTEXT,
            "Unable to write directive\n"));
        return(FALSE);
    }

    return TRUE;
} // CLogFileCtrl::WriteLogDirectives

//************************************************************************************

BOOL
CLogFileCtrl::WriteCustomLogDirectives(
    IN DWORD
    )
{
   
    return TRUE;
}

//************************************************************************************

VOID
CLogFileCtrl::I_FormNewLogFileName(
                    IN LPSYSTEMTIME pstNow,
                    IN LPCSTR       LogNamePrefix
                    )
{

    CHAR    tmpBuf[MAX_PATH+1];

    WORD wYear = ( pstNow->wYear % 100);  // retain just last 2 digits.

    switch ( QueryPeriod( ) ) {

    case INET_LOG_PERIOD_HOURLY:

        wsprintf( tmpBuf, "%.2s%02.2u%02u%02u%02u.%s",
                  LogNamePrefix,
                  wYear,
                  pstNow->wMonth,
                  pstNow->wDay,
                  pstNow->wHour,
                  DEFAULT_LOG_FILE_EXTENSION);
        break;

    case INET_LOG_PERIOD_DAILY:

        wsprintf( tmpBuf, "%.2s%02.2u%02u%02u.%s",
                  LogNamePrefix,
                  wYear,
                  pstNow->wMonth,
                  pstNow->wDay,
                  DEFAULT_LOG_FILE_EXTENSION);
        break;

    case INET_LOG_PERIOD_WEEKLY:

        wsprintf( tmpBuf, "%.2s%02.2u%02u%02u.%s",
                  LogNamePrefix,
                  wYear,
                  pstNow->wMonth,
                  WeekOfMonth(pstNow),
                  DEFAULT_LOG_FILE_EXTENSION);
        break;

    case INET_LOG_PERIOD_MONTHLY:
    
        wsprintf( tmpBuf, "%.2s%02u%02u.%s",
                  LogNamePrefix,
                  wYear,
                  pstNow->wMonth,
                  DEFAULT_LOG_FILE_EXTENSION);
        break;

    case INET_LOG_PERIOD_NONE:
    default:

        wsprintf(tmpBuf, "%.6s%u.%s",
              LogNamePrefix,
              m_sequence,
              DEFAULT_LOG_FILE_EXTENSION);

        m_sequence++;
        break;

    } // switch()

    m_strLogFileName.Copy(tmpBuf);

    return;
}

//************************************************************************************

VOID
CLogFileCtrl::SetLogFileDirectory(
        IN LPCSTR pszDir
        )
{

    STR tmpStr;
    HANDLE hFile;
    WIN32_FIND_DATA findData;
    DWORD   maxFileSize = 0;

    m_strLogFileDirectory.Copy(pszDir);

    //
    // if period is not none, then return
    //

    if ( QueryPeriod() != INET_LOG_PERIOD_NONE ) {
        return;
    }

    //
    // Get the starting sequence number
    //

    m_sequence = 1;

    //
    // Append instance name and the pattern.
    // should look like c:\winnt\system32\logfiles\w3svc1\inetsv*.log
    //

    tmpStr.Copy(pszDir);
//    if ( pszDir[tmpStr.QueryCCH()-1] != '\\' ) {
    if ( *CharPrev(pszDir, pszDir + tmpStr.QueryCCH()) != '\\' ) {
        tmpStr.Append("\\");
    }
    tmpStr.Append( QueryInstanceName() );
    tmpStr.Append( "\\" );
    tmpStr.Append( QueryNoPeriodPattern() );

    hFile = FindFirstFile( tmpStr.QueryStr(), &findData );
    if ( hFile == INVALID_HANDLE_VALUE ) {
        return;
    }

    do {

        PCHAR ptr;
        DWORD sequence = 1;

        ptr = strchr(findData.cFileName, '.');
        if (ptr != NULL ) {
            *ptr = '\0';
            ptr = findData.cFileName;

            while ( *ptr != '\0' ) {

                if ( isdigit((UCHAR)(*ptr)) ) {
                    sequence = atoi( ptr );
                    break;
                }
                ptr++;
            }

            if ( sequence > m_sequence ) {
                maxFileSize = findData.nFileSizeLow;
                m_sequence = sequence;
                DBGPRINTF((DBG_CONTEXT,
                    "Sequence start is %d[%d]\n", sequence, maxFileSize));
            }
        }

    } while ( FindNextFile( hFile, &findData ) );

    FindClose(hFile);

    if ( (maxFileSize+LOG_FILE_SLOP) > QuerySizeForTruncation() ) {
        m_sequence++;
    }

    return;

} // SetLogFileDirectory

//************************************************************************************

VOID
CLogFileCtrl::WriteLogInformation(
    IN SYSTEMTIME&     stNow, 
    IN PCHAR           pBuf, 
    IN DWORD           dwSize, 
    IN BOOL            fCustom,
    IN BOOL            fResetHeaders 
    )
/*++

Routine Description:
    write log line to file

Arguments:
    stNow           Present Time
    fResetHeaders   TRUE -> Reset headers, FALSE -> Don't reset headers
    pBuf            Pointer to Log Line
    dwSize          Number of characters in pBuf
    fCustom         TRUE -> Using custom logging, FALSE -> normal logging

Return Value:

--*/
{

    BOOL    fOpenNewFile;
    DWORD   err = NO_ERROR;
    DWORD   tickCount = 0;


    Lock ( );

    if ( m_pLogFile != NULL ) 
    {
        if ( QueryPeriod() == INET_LOG_PERIOD_DAILY ) 
        {
            fOpenNewFile = (m_stCurrentFile.wDay != stNow.wDay) ||
                           (m_stCurrentFile.wMonth != stNow.wMonth);
        } 
        else 
        {
            fOpenNewFile = IsBeginningOfNewPeriod( QueryPeriod(),
                                                   &m_stCurrentFile,
                                                   &stNow) ||
                           IsFileOverFlowForCB( dwSize);

             //
             // Reset headers if day is over. Used for weekly or unlimited files.
             //

             if ( !fOpenNewFile && !fResetHeaders)
             {
                fResetHeaders = (m_stCurrentFile.wDay != stNow.wDay) ||
                                (m_stCurrentFile.wMonth != stNow.wMonth);
             }
        }
    } 
    else 
    {
        fOpenNewFile = TRUE;
    }

    if (fOpenNewFile ) 
    {

        //
        // open a file only after every minute when we hit disk full
        //

        if ( m_TickResumeOpen != 0 ) 
        {
            tickCount = GetTickCount( );

            if ( (tickCount < m_TickResumeOpen) ||
                 ((tickCount + TICK_MINUTE) < tickCount ) )  // The Tick counter is about to wrap.
            {
                goto exit_tick;
            }
        }

retry_open:

        //
        // Close existing log
        //

        TerminateLog();

        //
        // Open new log file
        //

        if ( OpenLogFile( &stNow ) ) 
        {
            //
            // Schedule Callback for closing log file and set flag for writing directives.
            //

            ScheduleCallback(stNow);
            
            fResetHeaders = TRUE;
        }
        else
        {
            err = GetLastError();

            //
            // The file is already bigger than the truncate size
            // try another one.
            //

            if ( err == ERROR_INSUFFICIENT_BUFFER ) 
            {
                FormNewLogFileName( &stNow );
                err = NO_ERROR;
                goto retry_open;
            }

            goto exit;
        }
    }

    //
    // Reset Headers if needed
    //

    if ((fResetHeaders) || (fCustom != m_fUsingCustomHeaders))
    {
        BOOL fSucceeded;
        
        if (fCustom)
        {
            m_fUsingCustomHeaders = TRUE;
            fSucceeded = WriteCustomLogDirectives(dwSize);
        }
        else
        {
            m_fUsingCustomHeaders = FALSE;
            fSucceeded = WriteLogDirectives(dwSize);
        }
            
        if (!fSucceeded) 
        {
            err = GetLastError( );

            if ( err == ERROR_INSUFFICIENT_BUFFER ) 
            {
                FormNewLogFileName( &stNow );
                err = NO_ERROR;
                goto retry_open;
            }

            TerminateLog();
            goto exit;
        }

        //
        // record the time of opening of this new file
        //

        m_stCurrentFile = stNow;
    }

    //
    // write it to the buffer
    //

    if ( m_pLogFile->Write(pBuf, dwSize) ) 
    {
        IncrementBytesWritten(dwSize);

        //
        // If this had been shutdown, log event for reactivation
        //

        if ( m_fDiskFullShutdown ) 
        {
            m_fDiskFullShutdown = FALSE;
            m_TickResumeOpen = 0;

            LogWriteEvent( QueryInstanceName(), TRUE );
        }
    } 
    else 
    {
        err = GetLastError();
        TerminateLog( );
    }

exit:

    if ( err == ERROR_DISK_FULL ) 
    {
        if ( !m_fDiskFullShutdown ) 
        {
            m_fDiskFullShutdown = TRUE;
            LogWriteEvent( QueryInstanceName(), FALSE );
        }
        
        m_TickResumeOpen = GetTickCount();
        m_TickResumeOpen += TICK_MINUTE;
    }

exit_tick:

    Unlock( );

} // LogInformation


//************************************************************************************

DWORD
CLogFileCtrl::ScheduleCallback(SYSTEMTIME& stNow)
{
    DWORD dwTimeRemaining = 0;
    
    switch (m_dwPeriod)
    {
        case INET_LOG_PERIOD_HOURLY:
            dwTimeRemaining = 60*60 - 
                              (stNow.wMinute*60 + 
                               stNow.wSecond);
            break;
            
        case INET_LOG_PERIOD_DAILY:
            dwTimeRemaining = 24*60*60 - 
                              (stNow.wHour*60*60 + 
                               stNow.wMinute*60 + 
                               stNow.wSecond);
            break;
            
        case INET_LOG_PERIOD_WEEKLY:
            dwTimeRemaining = 7*24*60*60 -
                              (stNow.wDayOfWeek*24*60*60 + 
                               stNow.wHour*60*60 + 
                               stNow.wMinute*60 + 
                               stNow.wSecond);
            break;
            
        case INET_LOG_PERIOD_MONTHLY:
        
            DWORD   dwNumDays = 31;

            if ( (4 == stNow.wMonth) ||     // April
                 (6 == stNow.wMonth) ||     // June
                 (9 == stNow.wMonth) ||     // September
                 (11 == stNow.wMonth)       // November
               )
            {
                dwNumDays = 30;
            }

            if (2 == stNow.wMonth)          // February
            {
		if ((stNow.wYear % 4 == 0 && stNow.wYear % 100 != 0) || stNow.wYear % 400 == 0)
                {
                    //
                    // leap year.
                    //

                    dwNumDays = 29;
                }
                else
                {
                    dwNumDays = 28;
                }
            }
            
            dwTimeRemaining = dwNumDays*24*60*60 -
                              (stNow.wDay*24*60*60 + 
                               stNow.wHour*60*60 + 
                               stNow.wMinute*60 + 
                               stNow.wSecond);
            break;
    }

    //
    // Convert remaining time to millisecs
    //
    
    dwTimeRemaining = dwTimeRemaining*1000 - stNow.wMilliseconds;
    
    if (dwTimeRemaining)
    {
        m_dwSchedulerCookie =  ScheduleWorkItem(
                                    LoggingSchedulerCallback,
                                    this,
                                    dwTimeRemaining,
                                    FALSE);
    }                

    return(m_dwSchedulerCookie);
}

//************************************************************************************

CHAR * SkipWhite( CHAR * pch )
{
    while ( ISWHITEA( *pch ) )
    {
        pch++;
    }

    return pch;
}

//************************************************************************************

DWORD
FastDwToA(
    CHAR*   pBuf,
    DWORD   dwV
    )
/*++

Routine Description:
    Convert DWORD to ascii (decimal )
    returns length ( w/o trailing '\0' )

Arguments:
    pBuf - buffer where to store converted value
    dwV - value to convert

Return Value:
    length of ascii string

--*/
{
    DWORD   v;

    if ( dwV < 10 ) {
        pBuf[0] = (CHAR)('0'+dwV);
        pBuf[1] = '\0';
        return 1;
    } else if ( dwV < 100 ) {
        pBuf[0] = (CHAR)((dwV/10) + '0');
        pBuf[1] = (CHAR)((dwV%10) + '0');
        pBuf[2] = '\0';
        return 2;
    } else if ( dwV < 1000 ) {
        pBuf[0] = (CHAR)((v=dwV/100) + '0');
        dwV -= v * 100;
        pBuf[1] = (CHAR)((dwV/10) + '0');
        pBuf[2] = (CHAR)((dwV%10) + '0');
        pBuf[3] = '\0';
        return 3;
    } else if ( dwV < 10000 ) {

        pBuf[0] = (CHAR)((v=dwV/1000) + '0');
        dwV -= v * 1000;
        pBuf[1] = (CHAR)((v=dwV/100) + '0');
        dwV -= v * 100;
        pBuf[2] = (CHAR)((dwV/10) + '0');
        pBuf[3] = (CHAR)((dwV%10) + '0');
        pBuf[4] = '\0';
        return 4;
    }

    _ultoa(dwV, pBuf, 10);
    return (DWORD)strlen(pBuf);
    
} // FastDwToA

//************************************************************************************

VOID
LogWriteEvent(
    IN LPCSTR InstanceName,
    IN BOOL   fResume
    )
{
    if ( g_eventLog != NULL ) {

        const CHAR*    tmpString[1];
        tmpString[0] = InstanceName;

        g_eventLog->LogEvent(
                fResume ?
                    LOG_EVENT_RESUME_LOGGING :
                    LOG_EVENT_DISK_FULL_SHUTDOWN,
                1,
                tmpString,
                0);
    }
    return;
} // LogWriteEvent

//************************************************************************************

VOID WINAPI LoggingSchedulerCallback( PVOID pContext)
{
    CLogFileCtrl *pLog = (CLogFileCtrl *) pContext;

    //
    // There is a possibility of deadlock if another thread is inside TerminateLog
    // stuck in RemoveWorkItem, waiting for this callback thread to complete. To
    // prevent that we use the synchronization flag - m_fInTerminate.
    //
    
    pLog->m_dwSchedulerCookie = 0;

    if (!pLog->m_fInTerminate)
    {
        pLog->TerminateLog();
    }
}

//************************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\log\plugin\cofact.cxx ===
/*++

   Copyright    (c)    1997    Microsoft Corporation

   Module  Name :
        cofact.cxx

   Abstract:
        class factory

   Author:

       Johnson Apacible (JohnsonA)      02-April-1997


--*/

#include "precomp.hxx"


CComModule _Module;

STDAPI
DllGetClassObject(
    REFCLSID rclsid,
    REFIID riid,
    void** ppObject)
{
    HRESULT hr;

    hr = _Module.GetClassObject(rclsid, riid, ppObject);

    return hr;
}


STDAPI
DllCanUnloadNow(
    VOID
    )
{

	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
} // DllCanUnloadNow
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\log\plugin\extlogc.cpp ===
/*++

   Copyright    (c)    1997    Microsoft Corporation

   Module  Name :
      ExtLogC.cpp

   Abstract:
      W3C Extended LogFile Format Implementation

   Author:

       Terence Kwan    ( terryk )    18-Sep-1996

   Project:

       IIS Logging 3.0

--*/

#include "precomp.hxx"
#include <stdio.h>
#include "ilogobj.hxx"
#include "script.h"
#include "LogScript.hxx"
#include "filectl.hxx"
#include "lkrhash.h"
#include "iisver.h"
#include "iis64.h"

#include "extlogc.hxx"

const CHAR  szExtNoPeriodPattern[]  = "extend*.log";
const CHAR  G_PSZ_DELIMITER[2]      = { ' ', '\0'};

CHAR        szDotDot[]              = "...";
CHAR        szDash  []              = "-";
CHAR        szHTTPOk[]              = "200\r\n";

CCustomPropHashTable   *g_pGlobalLoggingProperties=NULL;


/* ************************************************************************************ */
/* Helper functions                                                                     */
/* ************************************************************************************ */

inline VOID
BuildHeader(
    IN OUT  STR *   strHeader,
    IN      DWORD   dwMask,
    IN      DWORD   dwField,
    IN      LPCSTR  szFieldHeader
)
{
    if (dwMask & dwField)
    {
        strHeader->Append(szFieldHeader);
        strHeader->Append(' ');
    }
}

/* ************************************************************************************ */

inline BOOL
CopyFieldToBuffer(
    IN PCHAR        Field,
    IN DWORD        FieldSize,
    IN PCHAR *      ppchOutBuffer,
    IN OUT PDWORD   SpaceNeeded,
    IN DWORD        SpaceProvided
    )
{
    if ( 0 == FieldSize ) 
    {
        Field = "-";
        FieldSize = 1;
    }

    //
    // Remove the NULL terminator
    //

    (*SpaceNeeded) += FieldSize + 1;          // +1 for trailing space

    if ( (*SpaceNeeded) <= SpaceProvided ) 
    {
        CopyMemory( (*ppchOutBuffer), Field, FieldSize );
        (*ppchOutBuffer) += FieldSize;
        (**ppchOutBuffer) = ' ';
        (*ppchOutBuffer)++;
        
        return(TRUE);
    }
    
    return FALSE;

} // CopyFieldToBuffer

/* ************************************************************************************ */

inline BOOL WriteHTTPHeader(
    IN OUT PCHAR *  ppchHeader,
    IN     PCHAR *  ppchOutBuffer,
    IN OUT PDWORD   SpaceNeeded,
    IN     DWORD    SpaceProvided
    )
{
    DWORD cbTmp = 0;                                                                              
                                                                                                    
    if ( (NULL != ppchHeader ) && ( NULL != *ppchHeader))                                                                    
    {   

        CHAR * pTmp = *ppchHeader;
        
        cbTmp       = (DWORD)strlen(pTmp);                                                               
        *ppchHeader = pTmp + cbTmp + 1;                                                           
                                                                                                    
        if ((cbTmp > MAX_LOG_TARGET_FIELD_LEN ) || 
            (((*SpaceNeeded)+cbTmp) > MAX_LOG_RECORD_LEN)
           ) 
        {                                                                                   
            pTmp  = szDotDot;                                                               
            cbTmp = 3;                                                                      
        }                                                                                   
        else
        {                                                                                   
            ConvertSpacesToPlus(pTmp);                                                      
        }                                                                                   

        return CopyFieldToBuffer( pTmp, cbTmp, ppchOutBuffer, SpaceNeeded, SpaceProvided);       
    }                                                                                       

    return FALSE;
}

/* ************************************************************************************ */
/* CCustomPropHashTable Class                                                           */
/* ************************************************************************************ */


VOID
CCustomPropHashTable::ClearTableAndStorage()
{
    
    //
    // Clear the Hash Table & free any previous LOG_PROPERTY_INFO entries
    //
    
    Clear();
    
    if (NULL != m_pLogPropArray)
    {
        delete [] m_pLogPropArray;
        m_pLogPropArray = NULL;
    }
    m_cLogPropItems = 0;
    
}



BOOL CCustomPropHashTable::InitializeFromMB (MB &mb,const char *path)
{
    BOOL retVal = TRUE;
    if (!m_fInitialized)
    {
        if (mb.Open(path))
        {
            retVal = m_fInitialized = FillHashTable(mb);
            mb.Close();
        }
        else
        {
            retVal = FALSE;
        }
    }
    return retVal;
}


BOOL
CCustomPropHashTable::PopulateHash(MB& mb, LPCSTR szPath, DWORD& cItems, bool fCountOnly)
{
    BOOL retVal = TRUE;

    //
    // Retrieve all required fields for all Custom Properties and store in the hash table.
    //

    int    index    = 0;
    
    CHAR   szChildName[256];
    CHAR   szW3CHeader[256] = "";
    
    STR    strNewPath;

    while( mb.EnumObjects(szPath, szChildName, index) )
    {
        DWORD   size;
        DWORD   dwPropertyID, dwPropertyMask, dwPropertyDataType;
        LPCSTR  szNewPath;
        

        //
        // Create the new path.
        //

        if ((NULL != szPath) && ( '\0' != *szPath))
        {
            if ( !(strNewPath.Copy(szPath) &&
                   strNewPath.Append("/") &&
                   strNewPath.Append(szChildName)) )
            {
                retVal = FALSE;
                break;
            }
        }
        else
        {
            if ( !strNewPath.Copy(szChildName) )
            {
                retVal = FALSE;
                break;
            }
        }
        
        szNewPath = strNewPath.QueryStr();
        
        //
        // Copy configuration information into internal structures 
        //

        szW3CHeader[0] = 0;
        size = 256;

        if ( mb.GetString( szNewPath, MD_LOGCUSTOM_PROPERTY_HEADER, IIS_MD_UT_SERVER, 
                                szW3CHeader, &size)     &&
             mb.GetDword( szNewPath, MD_LOGCUSTOM_PROPERTY_ID, IIS_MD_UT_SERVER, 
                                &dwPropertyID)          &&
             mb.GetDword( szNewPath, MD_LOGCUSTOM_PROPERTY_MASK, IIS_MD_UT_SERVER, 
                                &dwPropertyMask)        &&
             mb.GetDword( szNewPath, MD_LOGCUSTOM_PROPERTY_DATATYPE, IIS_MD_UT_SERVER, 
                                &dwPropertyDataType)

            )
        {
            if (! fCountOnly)
            {
                PLOG_PROPERTY_INFO pRec = &m_pLogPropArray[cItems];

                if ( ! (pRec->strKeyPath.Copy(szNewPath) &&
                        pRec->strW3CHeader.Copy(szW3CHeader)) )
                {
                    retVal = FALSE;
                    break;
                }
            
                pRec->dwPropertyID         = dwPropertyID;
                pRec->dwPropertyMask       = dwPropertyMask;
                pRec->dwPropertyDataType   = dwPropertyDataType;

                if (LK_SUCCESS != InsertRecord(pRec))
                {
                    DBGPRINTF((DBG_CONTEXT, "PopulateHash: Unable to insert Property %s\n", pRec->strKeyPath.QueryStr()));
                    retVal = FALSE;
                    break;
                }
            }

            cItems++;
        }

        //
        // Enumerate children
        //

        if (!PopulateHash(mb, szNewPath, cItems, fCountOnly))
        {
            retVal = FALSE;
            break;
        }
        index++;
    }
    return retVal;
}

/* ************************************************************************************ */

BOOL
CCustomPropHashTable::FillHashTable(MB& mb)
{
    BOOL retVal = FALSE;
    DWORD cItems = 0;

    //
    // Find out the number of items in the Custom Logging Tree
    //

    if (PopulateHash(mb, NULL, cItems, true))
    {

        ClearTableAndStorage ();
    
        if (cItems)
        {
            m_pLogPropArray = new LOG_PROPERTY_INFO[cItems];

            if ( NULL != m_pLogPropArray)
            {
                m_cLogPropItems = cItems;
                cItems = 0;
                retVal = PopulateHash(mb, NULL, cItems, false);
                if ( !retVal )
                {
                    ClearTableAndStorage ();
                }
                DBG_ASSERT(m_cLogPropItems == cItems);
            }
        }
    }
    return retVal;
}

/* ************************************************************************************ */

VOID
CCustomPropHashTable::SetPopulationState(MB& mb)
{
    CIterator   iter;
    DWORD       dwValue;
    
    LK_RETCODE  lkrc = InitializeIterator(&iter);

    while (LK_SUCCESS == lkrc)
    {
        Record* pRec = iter.Record();
        
        if ( mb.GetDword("", pRec->dwPropertyID, IIS_MD_UT_SERVER, &dwValue) &&
            (dwValue & pRec->dwPropertyMask))
        {
            pRec->fEnabled = TRUE;
        }
        else
        {
            pRec->fEnabled = FALSE;
        }
        
        lkrc = IncrementIterator(&iter);
    }

    CloseIterator(&iter);
}


BOOL
CCustomPropHashTable::InitFrom(CCustomPropHashTable& src)
{
    CIterator   iter;
    DWORD       i;
    BOOL        retVal = FALSE;

    ClearTableAndStorage ();

    if (src.m_cLogPropItems)
    {
        m_pLogPropArray = new LOG_PROPERTY_INFO[src.m_cLogPropItems];

        if ( NULL != m_pLogPropArray)
        {
            m_cLogPropItems = src.m_cLogPropItems;
            retVal = TRUE;
            for (i=0; i<m_cLogPropItems;i++)
            {
                PLOG_PROPERTY_INFO pRec = &m_pLogPropArray[i];
                PLOG_PROPERTY_INFO pRecOriginal = &src.m_pLogPropArray[i];

                if ( pRec->strKeyPath.Copy(pRecOriginal->strKeyPath) &&
                     pRec->strW3CHeader.Copy(pRecOriginal->strW3CHeader) )
                {
                    pRec->dwPropertyID         = pRecOriginal->dwPropertyID;
                    pRec->dwPropertyMask       = pRecOriginal->dwPropertyMask;
                    pRec->dwPropertyDataType   = pRecOriginal->dwPropertyDataType;

                    if (LK_SUCCESS != InsertRecord(pRec))
                    {
                        DBGPRINTF((DBG_CONTEXT, "InitFrom: Unable to insert Property %s\n", pRec->strKeyPath.QueryStr()));
                        retVal = FALSE;
                        break;
                    }
                }
                else
                {
                    retVal = FALSE;
                    break;
                }
            }
        }
    }

    return retVal;
}


/* ************************************************************************************ */
/* CEXTLOG Class                                                                        */
/* ************************************************************************************ */

CEXTLOG::CEXTLOG() :
    m_lMask                     (DEFAULT_EXTLOG_FIELDS),
    m_fHashTablePopulated       ( FALSE),
    m_fWriteHeadersInitialized  ( FALSE),
    m_cPrevCustLogItems         ( 0),
    m_pLogFields                ( NULL ),
    m_fUseLocalTimeForRollover  ( 0),
    m_pLocalTimeCache           ( NULL)
{
    if ( !g_pGlobalLoggingProperties)
    {
        g_pGlobalLoggingProperties =  new CCustomPropHashTable;
    }
    else
    {
        g_pGlobalLoggingProperties->AddRef();
    }
}

/* ************************************************************************************ */

CEXTLOG::~CEXTLOG()
{
    m_HashTable.ClearTableAndStorage ();

    if ( NULL != m_pLocalTimeCache)
    {
        delete m_pLocalTimeCache;
        m_pLocalTimeCache = NULL;
    }
    
    if (NULL != m_pLogFields)
    {
        delete [] m_pLogFields;
        m_pLogFields = NULL;
    }
    if ( g_pGlobalLoggingProperties)
    {
        if ( g_pGlobalLoggingProperties->Release () == 0)
        {
            delete g_pGlobalLoggingProperties;
            g_pGlobalLoggingProperties = NULL;
        }
    }
}


/* ************************************************************************************ */

STDMETHODIMP
CEXTLOG::InitializeLog(
                LPCSTR szInstanceName,
                LPCSTR pszMetabasePath,
                CHAR*  pvIMDCOM
                )
{
    HRESULT retVal = RETURNCODETOHRESULT ( MD_ERROR_DATA_NOT_FOUND );

    MB  mb( (IMDCOM*) pvIMDCOM );


    if ( g_pGlobalLoggingProperties )
    {
        m_fHashTablePopulated =  g_pGlobalLoggingProperties->InitializeFromMB(mb,"/LM/Logging/Custom Logging");
        if  ( m_fHashTablePopulated )
        {
            if (m_HashTable.InitFrom (*g_pGlobalLoggingProperties))
            {
                if ( mb.Open(pszMetabasePath))
                {
                    m_HashTable.SetPopulationState(mb);
                    if ( mb.Close())
                    {
                        retVal = CLogFileCtrl::InitializeLog(szInstanceName, pszMetabasePath, pvIMDCOM);
                    }
                }
                else
                {
                    retVal = HRESULTTOWIN32( GetLastError());
                }
            }
            else
            {
                retVal = RETURNCODETOHRESULT ( ERROR_OUTOFMEMORY );
            }
        }

    }
    else
    {
        DBG_ASSERT (FALSE);
        retVal = RETURNCODETOHRESULT ( ERROR_OUTOFMEMORY );
    }

    return retVal;
}

/* ************************************************************************************ */

STDMETHODIMP
CEXTLOG::TerminateLog(
    VOID
    )
{
    return CLogFileCtrl::TerminateLog();
}

/* ************************************************************************************ */

DWORD
CEXTLOG::GetRegParameters(
                    LPCSTR pszRegKey,
                    LPVOID pvIMDCOM
                    )
{
    // let the parent object get the default parameter first

    CLogFileCtrl::GetRegParameters( pszRegKey, pvIMDCOM );

    MB      mb( (IMDCOM*) pvIMDCOM );

    if ( !mb.Open("") ) {
        DBGPRINTF((DBG_CONTEXT, "Error %x on mb open\n",GetLastError()));
        goto exit;
    }

    if ( !mb.GetDword(
                pszRegKey,
                MD_LOGEXT_FIELD_MASK,
                IIS_MD_UT_SERVER,
                &m_lMask ) )
    {
        DBGPRINTF((DBG_CONTEXT, "Error %x on FieldMask GetDword\n",GetLastError()));
    }

    //
    // Get time to be used for logfile rollover
    //
    
    if ( !mb.GetDword( pszRegKey,
                        MD_LOGFILE_LOCALTIME_ROLLOVER,
                        IIS_MD_UT_SERVER,
                        &m_fUseLocalTimeForRollover
                      ) )
    {
        m_fUseLocalTimeForRollover = 0;
    }

    if (m_fUseLocalTimeForRollover && ( NULL == m_pLocalTimeCache))
    {
        m_pLocalTimeCache = new ASCLOG_DATETIME_CACHE;
    }

exit:
    return(NO_ERROR);
}

/* ************************************************************************************ */

VOID
CEXTLOG::GetFormatHeader(
    IN OUT STR * strHeader
    )
{
    strHeader->Reset();

    BuildHeader(strHeader, m_lMask, EXTLOG_DATE,             EXTLOG_DATE_ID);
    BuildHeader(strHeader, m_lMask, EXTLOG_TIME,             EXTLOG_TIME_ID);
    BuildHeader(strHeader, m_lMask, EXTLOG_CLIENT_IP,        EXTLOG_CLIENT_IP_ID);
    BuildHeader(strHeader, m_lMask, EXTLOG_USERNAME,         EXTLOG_USERNAME_ID);
    BuildHeader(strHeader, m_lMask, EXTLOG_SITE_NAME,        EXTLOG_SITE_NAME_ID);
    BuildHeader(strHeader, m_lMask, EXTLOG_COMPUTER_NAME,    EXTLOG_COMPUTER_NAME_ID);
    BuildHeader(strHeader, m_lMask, EXTLOG_SERVER_IP,        EXTLOG_SERVER_IP_ID);
    BuildHeader(strHeader, m_lMask, EXTLOG_SERVER_PORT,      EXTLOG_SERVER_PORT_ID);
    BuildHeader(strHeader, m_lMask, EXTLOG_METHOD,           EXTLOG_METHOD_ID);
    BuildHeader(strHeader, m_lMask, EXTLOG_URI_STEM,         EXTLOG_URI_STEM_ID);
    BuildHeader(strHeader, m_lMask, EXTLOG_URI_QUERY,        EXTLOG_URI_QUERY_ID);
    BuildHeader(strHeader, m_lMask, EXTLOG_HTTP_STATUS,      EXTLOG_HTTP_STATUS_ID);
    BuildHeader(strHeader, m_lMask, EXTLOG_WIN32_STATUS,     EXTLOG_WIN32_STATUS_ID);
    BuildHeader(strHeader, m_lMask, EXTLOG_BYTES_SENT,       EXTLOG_BYTES_SENT_ID);
    BuildHeader(strHeader, m_lMask, EXTLOG_BYTES_RECV,       EXTLOG_BYTES_RECV_ID);
    BuildHeader(strHeader, m_lMask, EXTLOG_TIME_TAKEN,       EXTLOG_TIME_TAKEN_ID);
    BuildHeader(strHeader, m_lMask, EXTLOG_PROTOCOL_VERSION, EXTLOG_PROTOCOL_VERSION_ID);
    BuildHeader(strHeader, m_lMask, EXTLOG_HOST,             EXTLOG_HOST_ID);
    BuildHeader(strHeader, m_lMask, EXTLOG_USER_AGENT,       EXTLOG_USER_AGENT_ID);
    BuildHeader(strHeader, m_lMask, EXTLOG_COOKIE,           EXTLOG_COOKIE_ID);
    BuildHeader(strHeader, m_lMask, EXTLOG_REFERER,          EXTLOG_REFERER_ID);

    if ( ! strHeader->IsEmpty())
    {
        //
        // Remove the trailing space
        //

        strHeader->SetLen(strHeader->QuerySize()-1);
    }
    
    return;

} // CEXTLOG::GetFormatHeader

/* ************************************************************************************ */

BOOL
CEXTLOG::WriteLogDirectives(
    IN DWORD Sludge
    )
/*++

Routine Description:
    Function to write the Extended logging directives

Arguments:

    Sludge - number of additional bytes that needs to be written
        together with the directives

Return Value:

    TRUE, ok
    FALSE, not enough space to write.

--*/
{
    BOOL  fRetVal = TRUE;
    
    if ( m_pLogFile != NULL) 
    {

        CHAR        buf[1024];
        CHAR        szDateTime[32];
        
        STACK_STR   (header,256);
        DWORD       len;

        GetFormatHeader(&header );

        (VOID)m_DateTimeCache.GetFormattedCurrentDateTime(szDateTime);

        len = wsprintf( buf,
                        "#Software: Microsoft %s %d.%d\r\n"
                        "#Version: %s\r\n"
                        "#Date: %s %s\r\n"
                        "#Fields: %s\r\n",
                        VER_IISPRODUCTNAME_STR, VER_IISMAJORVERSION, VER_IISMINORVERSION,
                        EXTLOG_VERSION, szDateTime, szDateTime+strlen(szDateTime)+1, header.QueryStr());

        DBG_ASSERT(len == strlen(buf));

        if ( !IsFileOverFlowForCB(len + Sludge))  
        {
            m_pLogFile->Write(buf, len) ? IncrementBytesWritten(len) : (fRetVal = FALSE);
        } 
        else 
        {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            DBGPRINTF((DBG_CONTEXT, "WriteLogDirectives: Unable to write directives\n"));
            fRetVal = FALSE;
        }
    }

    return(fRetVal);

} // CLogFileCtrl::WriteLogDirectives

/* ************************************************************************************ */

BOOL
CEXTLOG::FormatLogBuffer(
         IN IInetLogInformation *pLogObj,
         IN LPSTR                pBuf,
         IN DWORD                *pcbSize,
         OUT SYSTEMTIME          *pSystemTime
)
{
    PCHAR pTmp;
    DWORD cbTmp;
    DWORD nRequired;
    DWORD status;
    PCHAR pBuffer = pBuf;
    CHAR  rgchDateTime[32];

    //
    // We need system time
    //

    m_DateTimeCache.SetSystemTime( pSystemTime );
   
    //
    // if default go through fast path
    //

    if ( m_lMask != DEFAULT_EXTLOG_FIELDS ) 
    {
        BOOL fRet = NormalFormatBuffer(
                            pLogObj,
                            pBuf,
                            pcbSize,
                            pSystemTime
                            );

        if (fRet && m_fUseLocalTimeForRollover )
        {
            m_pLocalTimeCache ? m_pLocalTimeCache->SetLocalTime(pSystemTime):
                                GetLocalTime(pSystemTime);
        }

        return fRet;
    }

    //
    // Default format is:
    // Time ClientIP Operation Target HTTPStatus
    //
    // Time         8   HH:MM:SS
    // delimiters   4
    // EOL          2
    //

    nRequired = 8 + 4 + 2;

    (VOID) m_DateTimeCache.GetFormattedDateTime(pSystemTime,rgchDateTime);
    pTmp = rgchDateTime + 11;

    CopyMemory(pBuffer, pTmp, 8);
    pBuffer += 8;
    *(pBuffer++) = ' ';

    //
    // IP Address
    //

    pTmp = pLogObj->GetClientHostName( NULL, &cbTmp );
    if ( cbTmp == 0 ) 
    {
        cbTmp = 1;
        pTmp = "-";
    }

    nRequired += cbTmp;
    if ( nRequired <= *pcbSize ) 
    {
        CopyMemory(pBuffer, pTmp, cbTmp);
        pBuffer += cbTmp;
        *(pBuffer++) = ' ';
    }

    //
    // Operation
    //

    pTmp = pLogObj->GetOperation( NULL, &cbTmp );
    if ( cbTmp == 0 ) 
    {
        cbTmp = 1;
        pTmp = "-";
    }

    nRequired += cbTmp;
    if ( nRequired <= *pcbSize ) 
    {
        CopyMemory(pBuffer, pTmp, cbTmp);
        pBuffer += cbTmp;
        *(pBuffer++) = ' ';
    }

    //
    // Target
    //

    pTmp = pLogObj->GetTarget( NULL, &cbTmp );

    if ( cbTmp == 0 ) 
    {
        cbTmp = 1;
        pTmp = "-";
    }
    else if ( (cbTmp > MAX_LOG_TARGET_FIELD_LEN ) ||
              ((nRequired + cbTmp) > MAX_LOG_RECORD_LEN))
    {
        cbTmp = 3;
        pTmp  = szDotDot;
    }
         
    nRequired += cbTmp;
    if ( nRequired <= *pcbSize ) 
    {
        for (DWORD i=0; i<cbTmp;i++ ) 
        {
            if ( (*pBuffer = pTmp[i]) == ' ' ) 
            {
                *pBuffer = '+';
            }
            pBuffer++;
        }
        *(pBuffer++) = ' ';
    }

    status = pLogObj->GetProtocolStatus( );

    if ( (status == 200) && (nRequired + 5 <= *pcbSize) ) 
    {

        CopyMemory( pBuffer, szHTTPOk, 5);
        pBuffer += 5;
        nRequired += 3;
    } 
    else 
    {

        CHAR    tmpBuf[32];

        cbTmp = FastDwToA( tmpBuf, status );

        nRequired += cbTmp;
        if ( nRequired <= *pcbSize ) 
        {
            CopyMemory(pBuffer, tmpBuf, cbTmp);
            pBuffer += cbTmp;
        }

        *(pBuffer++) = '\r';
        *pBuffer = '\n';
    }

    if ( nRequired > *pcbSize ) 
    {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        *pcbSize = nRequired;
        return(FALSE);
    }

    *pcbSize = nRequired;

    //
    // To allow filenames & rollover based on either local or GMT time
    //

    if ( m_fUseLocalTimeForRollover )
    {
        m_pLocalTimeCache ? m_pLocalTimeCache->SetLocalTime(pSystemTime):
                            GetLocalTime(pSystemTime);
    }

    return TRUE;

} // CEXTLOG::FormatLogBuffer


/* ************************************************************************************ */

BOOL
CEXTLOG::NormalFormatBuffer(
        IN IInetLogInformation  *pLogObj,
        IN LPSTR                pBuf,
        IN DWORD                *pcbSize,
        IN SYSTEMTIME           *pSystemTime
        )
{

    BOOL    fSucceeded = FALSE;
    DWORD   spaceNeeded = 0;

    CHAR    tmpBuf[32];
    PCHAR   pTmp;
    DWORD   cbTmp;

    //
    // Format is:
    // Date Time ClientIP UserName Service Server ServerIP
    //      Method Target parameters httpstatus win32 bytes timetaken
    //      user-agent cookies
    //

    PCHAR outBuffer = pBuf;
    *outBuffer = 0;

    if ( m_lMask & (EXTLOG_DATE | EXTLOG_TIME) ) 
    {

        DWORD cchDateTime;
        DWORD cchDate;
        DWORD cchTime;
        CHAR  rgchDateTime[ 32];

        cchDateTime = m_DateTimeCache.GetFormattedDateTime(
                                            pSystemTime,
                                            rgchDateTime);

        cchDate = (DWORD)strlen(rgchDateTime);
        cchTime = cchDateTime - cchDate - 1;

        if (m_lMask & EXTLOG_DATE) 
        {
            // Date is in YYYY-MM-DD format (GMT)

            fSucceeded = CopyFieldToBuffer( rgchDateTime, cchDate, &outBuffer, 
                                            &spaceNeeded, *pcbSize);
        }

        if (m_lMask & EXTLOG_TIME) 
        {
            // Time in HH:MM:SS format (GMT)

            fSucceeded = CopyFieldToBuffer( rgchDateTime+cchDate+1, cchTime, &outBuffer, 
                                            &spaceNeeded, *pcbSize);
        }
    }

    //
    // Fill up the buffer
    //

    if (m_lMask & EXTLOG_CLIENT_IP ) 
    {
        pTmp = pLogObj->GetClientHostName( NULL, &cbTmp );
        fSucceeded = CopyFieldToBuffer( pTmp, cbTmp, &outBuffer, &spaceNeeded, *pcbSize);
    }

    if (m_lMask & EXTLOG_USERNAME ) 
    {
        pTmp = pLogObj->GetClientUserName( NULL, &cbTmp );
        fSucceeded = CopyFieldToBuffer( pTmp, cbTmp, &outBuffer, &spaceNeeded, *pcbSize);
    }

    if (m_lMask & EXTLOG_SITE_NAME) 
    {
        pTmp = pLogObj->GetSiteName( NULL, &cbTmp );
        fSucceeded = CopyFieldToBuffer( pTmp, cbTmp, &outBuffer, &spaceNeeded, *pcbSize);
    }

    if (m_lMask & EXTLOG_COMPUTER_NAME) 
    {
        pTmp = pLogObj->GetComputerName( NULL, &cbTmp );
        fSucceeded = CopyFieldToBuffer( pTmp, cbTmp, &outBuffer, &spaceNeeded, *pcbSize);
    }

    if (m_lMask & EXTLOG_SERVER_IP ) 
    {
        pTmp = pLogObj->GetServerAddress( NULL, &cbTmp );
        fSucceeded = CopyFieldToBuffer( pTmp, cbTmp, &outBuffer, &spaceNeeded, *pcbSize);
    }

    if (m_lMask & EXTLOG_SERVER_PORT ) 
    {
        cbTmp = FastDwToA( tmpBuf, pLogObj->GetPortNumber() );
        fSucceeded = CopyFieldToBuffer( tmpBuf, cbTmp, &outBuffer, &spaceNeeded, *pcbSize);
    }
    
    if (m_lMask & EXTLOG_METHOD ) 
    {
        pTmp = pLogObj->GetOperation( NULL, &cbTmp );
        fSucceeded = CopyFieldToBuffer( pTmp, cbTmp, &outBuffer, &spaceNeeded, *pcbSize);
    }
    
    if (m_lMask & EXTLOG_URI_STEM ) 
    {
        pTmp = pLogObj->GetTarget( NULL, &cbTmp );

        if ((cbTmp > MAX_LOG_TARGET_FIELD_LEN ) || ((spaceNeeded + cbTmp) > MAX_LOG_RECORD_LEN))
        {
            cbTmp = 3;
            pTmp  = szDotDot;
        }
        else
        {
            ConvertSpacesToPlus(pTmp);
        }
        
        fSucceeded = CopyFieldToBuffer( pTmp, cbTmp, &outBuffer, &spaceNeeded, *pcbSize);
    }

    if (m_lMask & EXTLOG_URI_QUERY ) 
    {
        pTmp = pLogObj->GetParameters( NULL, &cbTmp );

        if ((cbTmp > MAX_LOG_TARGET_FIELD_LEN ) || ((spaceNeeded + cbTmp) > MAX_LOG_RECORD_LEN))
        {
            cbTmp = 3;
            pTmp  = szDotDot;
        }
        else
        {
            ConvertSpacesToPlus(pTmp);
        }
        
        fSucceeded = CopyFieldToBuffer( pTmp, cbTmp, &outBuffer, &spaceNeeded, *pcbSize);
    }

    if (m_lMask & EXTLOG_HTTP_STATUS ) 
    {
        cbTmp = FastDwToA( tmpBuf, pLogObj->GetProtocolStatus() );
        fSucceeded = CopyFieldToBuffer( tmpBuf, cbTmp, &outBuffer, &spaceNeeded, *pcbSize);
    }

    if (m_lMask & EXTLOG_WIN32_STATUS ) 
    {
        cbTmp = FastDwToA( tmpBuf, pLogObj->GetWin32Status() );
        fSucceeded = CopyFieldToBuffer( tmpBuf, cbTmp, &outBuffer, &spaceNeeded, *pcbSize);
    }

    if (m_lMask & EXTLOG_BYTES_SENT ) 
    {
        cbTmp = FastDwToA( tmpBuf, pLogObj->GetBytesSent() );
        fSucceeded = CopyFieldToBuffer( tmpBuf, cbTmp, &outBuffer, &spaceNeeded, *pcbSize);
    }

    if (m_lMask & EXTLOG_BYTES_RECV ) 
    {
        cbTmp = FastDwToA( tmpBuf, pLogObj->GetBytesRecvd() );
        fSucceeded = CopyFieldToBuffer( tmpBuf, cbTmp, &outBuffer, &spaceNeeded, *pcbSize);
    }

    if (m_lMask & EXTLOG_TIME_TAKEN ) 
    {
        cbTmp = FastDwToA( tmpBuf, pLogObj->GetTimeForProcessing() );
        fSucceeded = CopyFieldToBuffer( tmpBuf, cbTmp, &outBuffer, &spaceNeeded, *pcbSize);
    }

    if (m_lMask & EXTLOG_PROTOCOL_VERSION ) 
    {
        pTmp = pLogObj->GetVersionString( NULL, &cbTmp );
        fSucceeded = CopyFieldToBuffer( pTmp, cbTmp, &outBuffer, &spaceNeeded, *pcbSize);
    }

    //
    // See if we need to get the extra header
    //

    if ( (m_lMask & (EXTLOG_HOST       |
                     EXTLOG_USER_AGENT |
                     EXTLOG_COOKIE     |
                     EXTLOG_REFERER )) != NULL ) 
    {

        pTmp = pLogObj->GetExtraHTTPHeaders( NULL, &cbTmp );
                   
        if ( m_lMask & EXTLOG_HOST )           
             fSucceeded = WriteHTTPHeader(&pTmp, &outBuffer, &spaceNeeded, *pcbSize);

        if ( m_lMask & EXTLOG_USER_AGENT )           
             fSucceeded = WriteHTTPHeader(&pTmp, &outBuffer, &spaceNeeded, *pcbSize);
                
        if ( m_lMask & EXTLOG_COOKIE )           
             fSucceeded = WriteHTTPHeader(&pTmp, &outBuffer, &spaceNeeded, *pcbSize);

        if ( m_lMask & EXTLOG_REFERER )           
             fSucceeded = WriteHTTPHeader(&pTmp, &outBuffer, &spaceNeeded, *pcbSize);
    }
    
    //
    // remove the trailing space
    //

    if ('\0' != *pBuf)
    {
        outBuffer--;
        spaceNeeded--;
    }

    //
    // add line terminator
    //

    spaceNeeded += 2;
    if ( spaceNeeded <= *pcbSize)
    {
        outBuffer[0] = '\r';
        outBuffer[1] = '\n';
        fSucceeded   = TRUE;
    }
    else
    {
        fSucceeded   = FALSE;
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
    }

    *pcbSize = spaceNeeded;
    return fSucceeded;

} // CEXTLOG::FormatLogBuffer

/* ************************************************************************************ */
/* Custom Logging Functions                                                             */
/* ************************************************************************************ */

BOOL
CEXTLOG::WriteCustomLogDirectives(
        IN DWORD Sludge
        )
{
    BOOL   fRetVal = TRUE;

    if ( m_pLogFile != NULL) 
    {
        CHAR        szDateTime[32];
        DWORD       dwLen;

        STACK_STR( strHeader, 512 );
        
        m_DateTimeCache.GetFormattedCurrentDateTime(szDateTime);
        
        BuildCustomLogHeader(m_cPrevCustLogItems, m_pPrevCustLogItems, szDateTime, 
                             m_strHeaderSuffix.QueryStr(), strHeader);

        dwLen = strHeader.QueryCB();

        if ( !IsFileOverFlowForCB(dwLen + Sludge) )
        {
            m_pLogFile->Write(strHeader.QueryStr(), dwLen) ? 
                                IncrementBytesWritten(dwLen) : (fRetVal = FALSE);
        } 
        else 
        {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            DBGPRINTF((DBG_CONTEXT, "WriteCustomLogDirectives: Unable to write directives\n"));
            fRetVal = FALSE;
        }
    }
    
    return fRetVal;
}

/* ************************************************************************************ */

DWORD 
CEXTLOG::ConvertDataToString(
    IN  DWORD dwPropertyType, 
    IN  PVOID pData, 
    IN  PCHAR pBuffer, 
    IN  DWORD dwBufferSize
    )
/*++

Routine Description:
    Function to convert Custom Logging data to string

Arguments:

    dwPropertyType - type information regarding the data to convert.
    pData          - pointer to data.
    pBuffer        - pointer to buffer to store the result.
    dwBufferSize   - byte count of space remaining in the buffer. If 0 or -ve
                     => buffer is full

Return Value:

    Number of bytes in the string representation of the data +1 (for space at end).
    The output buffer (pBuffer) is not NULL terminated.

--*/
{
    CHAR    szBuf[64];
    PCHAR   pChString;
    DWORD   dwLength;

    USES_CONVERSION;                        // To enable W2A

    DBG_ASSERT(NULL != pBuffer);

    if ( NULL != pData)
    {
        pChString = szBuf;
    
        switch (dwPropertyType)
        {
        
            case MD_LOGCUSTOM_DATATYPE_INT:
            {
                int i = *((int *)pData);
                _itoa(i, pChString, 10);
                dwLength = (DWORD)strlen(pChString);
                break;
            }

            case MD_LOGCUSTOM_DATATYPE_UINT:
            {
                unsigned int  ui = *((unsigned int *)pData);
                unsigned long ul = ui;
                _ultoa(ul, pChString, 10);
                dwLength = (DWORD)strlen(pChString);
                break;
            }

            case MD_LOGCUSTOM_DATATYPE_LONG:
            {
                long l = *((long *)pData);
                _ltoa(l, pChString, 10);
                dwLength = (DWORD)strlen(pChString);
                break;
            }

            case MD_LOGCUSTOM_DATATYPE_ULONG:
            {
                unsigned long ul = *((unsigned long *)pData);
                _ultoa(ul, pChString, 10);
                dwLength = (DWORD)strlen(pChString);
                break;
            }

            case MD_LOGCUSTOM_DATATYPE_FLOAT:
            {
                float f = *((float *)pData);
                dwLength = sprintf(pChString,"%f",f);
                break;
            }
        
            case MD_LOGCUSTOM_DATATYPE_DOUBLE:
            {
                double d = *((double *)pData);
                dwLength = sprintf(pChString,"%f",d);
                break;
            }
        
            case MD_LOGCUSTOM_DATATYPE_LPSTR:
            {
                pChString = (LPSTR)pData;
                dwLength = (DWORD)strlen(pChString);

                if (dwLength > MAX_LOG_TARGET_FIELD_LEN )
                {
                    pChString = szDotDot;
                    dwLength  = 3;
                }
            
                break;
            }
            
            case MD_LOGCUSTOM_DATATYPE_LPWSTR:
            {
                dwLength = (DWORD)wcslen( (LPWSTR)pData);

                if (dwLength <= MAX_LOG_TARGET_FIELD_LEN)
                {
                    pChString = W2A((LPWSTR)pData);
                }
                else
                {
                    pChString = szDotDot;
                    dwLength  = 3;
                }
            
                break;
            }
            
            default:
                dwLength = 0;
                break;
        }
    }
    else
    {
        pChString = szDash;
        dwLength = 1;
    }

    //
    // Copy over the charaters to the output buffer and append a ' '
    //
    
    if (dwLength < dwBufferSize)
    {
        CopyMemory(pBuffer, pChString, dwLength);
        pBuffer[dwLength] = ' ';
    }
    else if (dwBufferSize > 3)
    {
        //
        // Not enough memory to copy the field. Use ... instead
        //
        
        dwLength = 3;
        CopyMemory(pBuffer, szDotDot, 3);
        pBuffer[dwLength] = ' ';
    }
    else
    {
        //
        // Can't even copy ... Just punt on the remaining part of the log line
        //
        
        dwLength = (DWORD)-1;
    }
    
    return dwLength+1;
}
/* ************************************************************************************ */

DWORD 
CEXTLOG::FormatCustomLogBuffer( 
        DWORD               cItems, 
        PPLOG_PROPERTY_INFO pPropInfo,
        PPVOID              pPropData,
        LPCSTR              szDateTime, 
        LPSTR               szLogLine,
        DWORD               cchLogLine
        )
{
    DWORD       cchUsed;
    PCHAR       pCh   = szLogLine;
    
    cchLogLine -= 1;                                   // Reserve space for trailing \r\n

    //
    // Add date & time if enabled
    //

    if ( m_lMask & (EXTLOG_DATE | EXTLOG_TIME) ) 
    {

        DWORD cch = (DWORD)strlen(szDateTime);

        if (m_lMask & EXTLOG_DATE) 
        {
            memcpy(pCh, szDateTime, cch);
            *(pCh+cch) = ' ';
            pCh += cch+1;
        }
        
        if (m_lMask & EXTLOG_TIME) 
        {
            szDateTime += cch+1;
            cch = (DWORD)strlen(szDateTime);
            memcpy(pCh, szDateTime, cch);
            *(pCh+cch) = ' ';
            pCh += cch+1;
        }
    }

    cchLogLine -= (DWORD)DIFF(pCh - szLogLine);
    
    for (DWORD i=0; i< cItems; i++)
    {
        // Convert data to string

        cchUsed   = ConvertDataToString(pPropInfo[i]->dwPropertyDataType, 
                                        pPropData[i], 
                                        pCh, cchLogLine);
        pCh         += cchUsed;
        
        cchLogLine  -= cchUsed;
    }
    
    *(pCh-1)  = '\r';
    *(pCh)    = '\n';
    
    return (DWORD)DIFF(pCh+1-szLogLine);
}

/* ************************************************************************************ */

void 
CEXTLOG::BuildCustomLogHeader( 
        DWORD               cItems, 
        PPLOG_PROPERTY_INFO pPropInfo, 
        LPCSTR              szDateTime,
        LPCSTR              szHeaderSuffix,
        STR&                strHeader
        )
{
    DWORD   cchHeader;
    LPSTR   szHeader =  strHeader.QueryStr();
    
    cchHeader = wsprintf( szHeader,
                        "#Software: Microsoft %s %d.%d\r\n"
                        "#Version: %s\r\n"
                        "#Date: %s %s\r\n",
                        VER_IISPRODUCTNAME_STR, VER_IISMAJORVERSION, VER_IISMINORVERSION,
                        EXTLOG_VERSION,
                        szDateTime,
                        szDateTime+strlen(szDateTime)+1
                        );

    if ( (NULL != szHeaderSuffix) && ('\0' != *szHeaderSuffix))
    {
        DWORD   cchSuffix;

        // Make sure that the header begins with a #

        if ( *szHeaderSuffix != '#')
        {
            szHeader[cchHeader++] = '#';
        }

        cchSuffix = (DWORD)strlen(szHeaderSuffix);
        memcpy(szHeader+cchHeader, szHeaderSuffix, cchSuffix);
        cchHeader += cchSuffix;

        szHeader[cchHeader++] = '\r';
        szHeader[cchHeader++] = '\n';
    }

    memcpy(szHeader+cchHeader, "#Fields:", sizeof("#Fields:"));
    cchHeader += sizeof("#Fields:");
    strHeader.SetLen(cchHeader-1);

    //
    // Fill in W3C Headers for all fields.
    //
    if ( m_lMask & EXTLOG_DATE ) 
    {
        strHeader.Append(" date");
    }
    if (m_lMask & EXTLOG_TIME) 
    {
        strHeader.Append(" time");
    }

    for (DWORD i=0; i< cItems; i++)
    {
        // Add header to header string

        strHeader.Append(' ');
        strHeader.Append(pPropInfo[i]->strW3CHeader);
    }

    strHeader.Append("\r\n");
}

/* ************************************************************************************ */

STDMETHODIMP 
CEXTLOG::LogCustomInformation(
    IN  DWORD               cItems, 
    IN  PCUSTOM_LOG_DATA    pCustomLogData,
    IN  LPSTR               szHeaderSuffix
    )
/*++

Routine Description:
    Function to write Custom Logging information for Extended logging

Arguments:

    cItems          - number of fields to log 
                     (elements in the array pointed to by pCustomLogData)
                     
    pCustomLogData  - pointer to array of CUSTOM_LOG_DATA

Return Value:

    HRESULT indicating whether function Succeeded or Failed.

--*/
{

    SYSTEMTIME      sysTime;
    DWORD           i, j, cchLogLine;
    BOOL            fResetHeaders;
    CHAR            szDateTime[32];
    CHAR            szLogLine[MAX_LOG_RECORD_LEN+1];

    DBG_ASSERT( 0 != cItems);
    DBG_ASSERT( NULL != pCustomLogData);
    DBG_ASSERT( MAX_CUSTLOG_FIELDS >= cItems);

    PLOG_PROPERTY_INFO  pPropInfo[MAX_CUSTLOG_FIELDS];
    PVOID               pPropData[MAX_CUSTLOG_FIELDS];

    //
    // Lock Shared. Ensures that shared variables are not modified unknowst to this thread.
    //
    
    LockCustLogShared();
    
    fResetHeaders = FALSE;

    //
    // Build list of enabled keys. Simultaneously check if headr needs resetting.
    //
    
    for (i=0, j=0 ; i< cItems; i++)
    {

        if ( (LK_SUCCESS == m_HashTable.FindKey(pCustomLogData[i].szPropertyPath, pPropInfo+j)) &&
             (pPropInfo[j]->fEnabled)
           )
        {
            fResetHeaders  |=  ( pPropInfo[j] != m_pPrevCustLogItems[j] );
            pPropData[j]    =  pCustomLogData[i].pData;    
            j++;
        }
    }

    cItems = j;

    //
    // Header needs resetting if # items is different or Header Suffix has changed.
    //
    
    fResetHeaders |= (m_cPrevCustLogItems != cItems);

    if (szHeaderSuffix != NULL) 
    {
        fResetHeaders |=  ( 0 != strcmp(m_strHeaderSuffix.QueryStr(), szHeaderSuffix));
    }
    
    m_DateTimeCache.SetSystemTime( &sysTime );
    m_DateTimeCache.GetFormattedDateTime(&sysTime, szDateTime);

    cchLogLine = FormatCustomLogBuffer( cItems, 
                                        pPropInfo, 
                                        pPropData, 
                                        szDateTime, 
                                        szLogLine, 
                                        MAX_LOG_RECORD_LEN+1);
    
    if (fResetHeaders)
    {
        //
        // Convert Lock to Exclusive before setting the class wide variable.
        //
        
        LockCustLogConvertExclusive();
        
        m_cPrevCustLogItems = cItems;

        for (i=0; i <cItems; i++)
        {
            m_pPrevCustLogItems[i] = pPropInfo[i];
        }

        m_strHeaderSuffix.Copy(szHeaderSuffix);
    }    

    //
    // Write out the log to file
    //
    
    if ( m_fUseLocalTimeForRollover )
    {
        m_pLocalTimeCache ? m_pLocalTimeCache->SetLocalTime(&sysTime):
                            GetLocalTime(&sysTime);
    }

    WriteLogInformation(sysTime, szLogLine, cchLogLine, TRUE, fResetHeaders); 

    UnlockCustLog();
    
    return S_OK;
}

/* ************************************************************************************ */
/* ILogScripting Functions                                                              */
/* ************************************************************************************ */

HRESULT
CEXTLOG::ReadFileLogRecord(
    IN  FILE                *fpLogFile, 
    IN  LPINET_LOGLINE       pInetLogLine,
    IN  PCHAR                pszLogLine,
    IN  DWORD                dwLogLineSize
    )
/*++

Routine Description:
    Function to read a log line from an open log file

Arguments:

    fpLogFile       -   FILE * to open file
    pInetLogLine    -   pointer to INET_LOGLINE structure where parsed info is stored
    pszLogLine      -   buffer to store the log line
    dwLogLineSize   -   size of pszLogLine

Return Value:

    HRESULT indicating whether function Succeeded or Failed.

--*/
{
    CHAR *  pCh;
    DWORD   pos, custompos;
    CHAR *  szDateString, * szTimeString;

getnewline:

    pCh = pszLogLine;
    
    if (fgets(pCh, dwLogLineSize, fpLogFile) == NULL)
    {
        return E_FAIL;
    }

    pCh = SkipWhite(pCh);

    if (('\n' == *pCh) || ('\0' == *pCh))
    {
        // Empty line. Get Next line

        goto getnewline;
    }

    if ( '#' ==  *pCh )                             
    {

        pCh = strstr(pszLogLine, "#Date:");

        if (NULL != pCh)
        {
            //
            // Copy the date & time into member variables
            //

            pCh = strtok(pCh+6," \t\r\n");
            if (NULL == pCh)
            {
                return E_FAIL;
            }
            strcpy(m_szDate, pCh);
        
            pCh = strtok(NULL," \t\r\n");
            if (NULL == pCh)
            {
                return E_FAIL;
            }
            strcpy(m_szTime, pCh);

            goto getnewline;
        }

        //
        // Not the date line. Check if the fields are being reset
        //
        
        pCh = strstr(pszLogLine, "#Fields:");

        if (NULL != pCh)
        {
            // Headers are being defined or redefined

            dwDatePos           = 0;
            dwTimePos           = 0;
            dwClientIPPos       = 0;
            dwUserNamePos       = 0;
            dwSiteNamePos       = 0; 
            dwComputerNamePos   = 0;
            dwServerIPPos       = 0;
            dwMethodPos         = 0;
            dwURIStemPos        = 0;
            dwURIQueryPos       = 0;
            dwHTTPStatusPos     = 0;
            dwWin32StatusPos    = 0;
            dwBytesSentPos      = 0;
            dwBytesRecvPos      = 0;
            dwTimeTakenPos      = 0;
            dwServerPortPos     = 0;
            dwVersionPos        = 0;
            dwCookiePos         = 0;
            dwUserAgentPos      = 0;
            dwRefererPos        = 0;

            pInetLogLine->iCustomFieldsCount = 0;
        
            pCh = strtok(pCh+8," \t\r\n");

            for (pos = 1; pCh != NULL; pos++, pCh = strtok(NULL," \t\r\n")) 
            {
   
                if (0 == _stricmp(pCh, EXTLOG_DATE_ID))                {
                    dwDatePos = pos;
                } else if (0 == _stricmp(pCh, EXTLOG_TIME_ID))         {
                    dwTimePos = pos;
                } else if (0 == _stricmp(pCh, EXTLOG_CLIENT_IP_ID))     {
                    dwClientIPPos = pos;
                } else if (0 == _stricmp(pCh, EXTLOG_USERNAME_ID))      {
                    dwUserNamePos = pos;
                } else if (0 == _stricmp(pCh, EXTLOG_SITE_NAME_ID))     {
                    dwSiteNamePos = pos;
                } else if (0 == _stricmp(pCh, EXTLOG_COMPUTER_NAME_ID)) {
                    dwComputerNamePos = pos;
                } else if (0 == _stricmp(pCh, EXTLOG_SERVER_IP_ID))     {
                    dwServerIPPos = pos;
                } else if (0 == _stricmp(pCh, EXTLOG_METHOD_ID))        {
                    dwMethodPos = pos;
                } else if (0 == _stricmp(pCh, EXTLOG_URI_STEM_ID))      {
                    dwURIStemPos = pos;
                } else if (0 == _stricmp(pCh, EXTLOG_URI_QUERY_ID))     {
                    dwURIQueryPos = pos;
                } else if (0 == _stricmp(pCh, EXTLOG_HTTP_STATUS_ID))   {
                    dwHTTPStatusPos = pos;
                } else if (0 == _stricmp(pCh, EXTLOG_WIN32_STATUS_ID))  {
                    dwWin32StatusPos = pos;
                } else if (0 == _stricmp(pCh, EXTLOG_BYTES_SENT_ID))    {
                    dwBytesSentPos = pos;
                } else if (0 == _stricmp(pCh, EXTLOG_BYTES_RECV_ID))    {
                    dwBytesRecvPos = pos;
                } else if (0 == _stricmp(pCh, EXTLOG_TIME_TAKEN_ID))    {
                    dwTimeTakenPos = pos;
                } else if (0 == _stricmp(pCh, EXTLOG_SERVER_PORT_ID))   {
                    dwServerPortPos = pos;
                } else if (0 == _stricmp(pCh, EXTLOG_PROTOCOL_VERSION_ID)){
                    dwVersionPos = pos;
                } else if (0 == _stricmp(pCh, EXTLOG_COOKIE_ID))        {
                    dwCookiePos = pos;
                } else if (0 == _stricmp(pCh, EXTLOG_USER_AGENT_ID))        {
                    dwUserAgentPos = pos;
                } else if (0 == _stricmp(pCh, EXTLOG_REFERER_ID))        {
                    dwRefererPos = pos;
                } else if ( pInetLogLine->iCustomFieldsCount < MAX_CUSTOM_FIELDS) {

                    // Unidentified header. Add to custom header list
                    
                    strcpy(pInetLogLine->CustomFields[pInetLogLine->iCustomFieldsCount++].szHeader, pCh);
                }
            }
        }

        goto getnewline;
    }

    //
    // We have a log line. Parse it.
    //
    
    szDateString = m_szDate;
    szTimeString = m_szTime;

    pCh = strtok(pszLogLine," \t\r\n");

    for (pos = 1, custompos = 0; pCh != NULL; pos++, pCh= strtok(NULL, " \t\r\n")) 
    {
        if ( pos == dwDatePos )             {
            szDateString                    = pCh;
        } else if (pos == dwTimePos)        {
            szTimeString                    = pCh;
        } else if (pos == dwClientIPPos)    {
            pInetLogLine->pszClientHostName = pCh;
        } else if (pos == dwUserNamePos)    {
            pInetLogLine->pszClientUserName = pCh;
        } else if (pos == dwSiteNamePos)    {
            pInetLogLine->pszSiteName       = pCh;
        } else if (pos == dwComputerNamePos){
            pInetLogLine->pszComputerName   = pCh;
        } else if (pos == dwServerIPPos)    {
            pInetLogLine->pszServerAddress  = pCh;
        } else if (pos == dwMethodPos)      {
            pInetLogLine->pszOperation      = pCh;
        } else if (pos == dwURIStemPos)     {
            pInetLogLine->pszTarget         = pCh;
        } else if (pos == dwURIQueryPos)    {
            pInetLogLine->pszParameters     = pCh;
        } else if (pos == dwHTTPStatusPos)  {
            pInetLogLine->pszProtocolStatus = pCh;
        } else if (pos == dwWin32StatusPos) {
            pInetLogLine->pszWin32Status    = pCh;
        } else if (pos == dwBytesSentPos)   {
            pInetLogLine->pszBytesSent      = pCh;
        } else if (pos == dwBytesRecvPos)   {
            pInetLogLine->pszBytesRecvd     = pCh;
        } else if (pos == dwTimeTakenPos)   {
            pInetLogLine->pszTimeForProcessing= pCh;
        } else if (pos == dwServerPortPos)  {
            pInetLogLine->pszPort           = pCh;
        } else if (pos == dwVersionPos)     {
            pInetLogLine->pszVersion        = pCh;
        } else if (pos == dwCookiePos)      {
            pInetLogLine->pszCookie         = pCh;
        } else if (pos == dwUserAgentPos)   {
            pInetLogLine->pszUserAgent      = pCh;
        } else if (pos == dwRefererPos)     {
            pInetLogLine->pszReferer        = pCh;
        } else if ( custompos < (DWORD)pInetLogLine->iCustomFieldsCount) {
            pInetLogLine->CustomFields[custompos++].pchData = pCh;
        }
    }

    if ( ! ConvertW3CDateToVariantDate(szDateString, szTimeString, &(pInetLogLine->DateTime)) )
    {
        return E_FAIL;
    }

    return S_OK;

} // CEXTLOG::ReadFileLogRecord

/* ************************************************************************************ */

HRESULT
CEXTLOG::WriteFileLogRecord(
    IN  FILE            *fpLogFile, 
    IN  ILogScripting   *pILogScripting,
    IN  bool            fWriteHeader
    )
/*++

Routine Description:
    Function to write a log line to an open log file

Arguments:

    fpLogFile       -   FILE * to open file
    pILogScripting  -   ILogScripting interface for getting information to write
    fWriteHeader    -   Flag to indicate that log header must be written.

Return Value:

    HRESULT indicating whether function Succeeded or Failed.

--*/
{
    USES_CONVERSION;

    HRESULT hr = E_FAIL;
    CHAR    szLogLine[4096];  
    long    i = 0;

    VARIANT DateTime;
    VARIANT varCustomFieldsArray;

    SYSTEMTIME  sysTime; 
    CHAR        rgchDateTime[ 32];

    const int cFields = 18;
    
    //
    // Populate Headers
    //

    if (!m_fWriteHeadersInitialized)
    {
        LPSTR   szFieldNames[cFields] = { 
                                            EXTLOG_CLIENT_IP_ID, 
                                            EXTLOG_USERNAME_ID, 
                                            EXTLOG_SITE_NAME_ID,
                                            EXTLOG_COMPUTER_NAME_ID, 
                                            EXTLOG_SERVER_IP_ID, 
                                            EXTLOG_METHOD_ID, 
                                            EXTLOG_URI_STEM_ID, 
                                            EXTLOG_URI_QUERY_ID,
                                            EXTLOG_HTTP_STATUS_ID,
                                            EXTLOG_WIN32_STATUS_ID,
                                            EXTLOG_BYTES_SENT_ID, 
                                            EXTLOG_BYTES_RECV_ID, 
                                            EXTLOG_TIME_TAKEN_ID,
                                            EXTLOG_SERVER_PORT_ID,
                                            EXTLOG_PROTOCOL_VERSION_ID,
                                            EXTLOG_USER_AGENT_ID,
                                            EXTLOG_COOKIE_ID,
                                            EXTLOG_REFERER_ID
                                        };

        m_fWriteHeadersInitialized = TRUE;
        
        if ( NULL != (m_pLogFields =   new LOG_FIELDS[cFields]))
        {
            for (i =0; i < cFields; i++)
            {
                strcpy(m_pLogFields[i].szW3CHeader, szFieldNames[i]);
                m_pLogFields[i].varData.lVal = NULL;
            }
        }
    }

    if (NULL == m_pLogFields)
    {
        return E_OUTOFMEMORY;            
    }

    if (SUCCEEDED( pILogScripting->get_ClientIP       ( & m_pLogFields[0].varData) )    &&
        SUCCEEDED( pILogScripting->get_UserName       ( & m_pLogFields[1].varData) )    &&   
        SUCCEEDED( pILogScripting->get_ServiceName    ( & m_pLogFields[2].varData) )    &&
        SUCCEEDED( pILogScripting->get_ServerName     ( & m_pLogFields[3].varData) )    &&
        SUCCEEDED( pILogScripting->get_ServerIP       ( & m_pLogFields[4].varData) )    &&
        SUCCEEDED( pILogScripting->get_Method         ( & m_pLogFields[5].varData) )    &&
        SUCCEEDED( pILogScripting->get_URIStem        ( & m_pLogFields[6].varData) )    &&
        SUCCEEDED( pILogScripting->get_URIQuery       ( & m_pLogFields[7].varData) )    &&
        SUCCEEDED( pILogScripting->get_ProtocolStatus ( & m_pLogFields[8].varData) )    &&
        SUCCEEDED( pILogScripting->get_Win32Status    ( & m_pLogFields[9].varData) )    &&
        SUCCEEDED( pILogScripting->get_BytesSent      ( & m_pLogFields[10].varData) )   &&
        SUCCEEDED( pILogScripting->get_BytesReceived  ( & m_pLogFields[11].varData) )   &&
        SUCCEEDED( pILogScripting->get_TimeTaken      ( & m_pLogFields[12].varData) )   &&
        SUCCEEDED( pILogScripting->get_ServerPort     ( & m_pLogFields[13].varData) )   &&
        SUCCEEDED( pILogScripting->get_ProtocolVersion( & m_pLogFields[14].varData) )   &&
        SUCCEEDED( pILogScripting->get_UserAgent      ( & m_pLogFields[15].varData) )   &&
        SUCCEEDED( pILogScripting->get_Cookie         ( & m_pLogFields[16].varData) )   &&
        SUCCEEDED( pILogScripting->get_Referer        ( & m_pLogFields[17].varData) )   &&

        SUCCEEDED( pILogScripting->get_CustomFields   ( & varCustomFieldsArray ) )      &&
        SUCCEEDED( pILogScripting->get_DateTime       ( & DateTime) )                   &&
        VariantTimeToSystemTime                       ( DateTime.date, &sysTime)
        )
    {
        SAFEARRAY * psaCustom = NULL;
        long        cItems = 0;
        BSTR HUGEP *pbstr;

        //
        // Build Header
        //

        strcpy(szLogLine, "date time");

        for ( i = 0; i < cFields; i++)
        {
            if ( VT_NULL != m_pLogFields[i].varData.vt)
            {
                strcat(szLogLine, " ");
                strcat(szLogLine, m_pLogFields[i].szW3CHeader);
            }
        }

        if ( (VT_BSTR|VT_ARRAY) == varCustomFieldsArray.vt)
        {
            psaCustom = varCustomFieldsArray.parray;
        
            if (NULL != psaCustom)
            {
                cItems = psaCustom->rgsabound[1].cElements;
            }

            if ( SUCCEEDED(SafeArrayAccessData(psaCustom, (void HUGEP* FAR*)&pbstr)) )
            {
                for ( i = 0; i < cItems; i++)
                {
                    strcat(szLogLine, " ");
                    strcat(szLogLine, W2A(pbstr[i]));
                }

                SafeArrayUnaccessData(psaCustom);
            }
        }

        m_DateTimeCache.GetFormattedDateTime( &sysTime, rgchDateTime);

        if ( fWriteHeader || strcmp( szLogLine, m_szWriteHeader.QueryStr()) )
        {
            // Need to write headers

            m_szWriteHeader.Copy(szLogLine);

            wsprintf(szLogLine,
                        "#Software: Microsoft Internet Information Services 5.0\n"
                        "#Version: %s\n"
                        "#Date: %s %s\n"
                        "#Fields: %s\n",
                        EXTLOG_VERSION,
                        rgchDateTime,
                        rgchDateTime+strlen(rgchDateTime)+1,
                        m_szWriteHeader.QueryStr()
                    );
        }
        else
        {
            szLogLine[0] = '\0';
        }

        //
        // Write the fields to the log line
        //

        strcat(szLogLine, rgchDateTime);
        strcat(szLogLine, " ");
        strcat(szLogLine, rgchDateTime+strlen(rgchDateTime)+1);

        for ( i = 0; i < cFields; i++)
        {
            switch  (m_pLogFields[i].varData.vt)
            {
                case VT_BSTR:
                    strcat(szLogLine, " ");
                    strcat( szLogLine, W2A(GetBstrFromVariant( &m_pLogFields[i].varData)) );
                    break;

                case VT_I4:
                    strcat(szLogLine, " ");
                    GetLongFromVariant( &m_pLogFields[i].varData, szLogLine+strlen(szLogLine));
                    break;

                case VT_EMPTY:
                    strcat (szLogLine, " -");
                    break;

                default:
                    break;
            }
        }

        if ( (0 < cItems) && SUCCEEDED(SafeArrayAccessData(psaCustom, (void HUGEP* FAR*)&pbstr)) )
        {
            for ( i = 0; i < cItems; i++)
            {
                strcat(szLogLine, " ");
                strcat(szLogLine, W2A(pbstr[cItems + i]));
            }

            SafeArrayUnaccessData(psaCustom);
        }

        fprintf(fpLogFile, "%s\n", szLogLine);

        hr = S_OK;
    }

    return hr;
}

/* ************************************************************************************ */

BOOL
CEXTLOG::ConvertW3CDateToVariantDate(
    IN  PCHAR szDateString, 
    IN  PCHAR szTimeString, 
    OUT DATE * pDateTime)
/*++

Routine Description:
    Convert a Date & Time string in the W3C Format to DATE type
    
Arguments:

    szDateString    -   String representing date in format Year-Month-Day
    szTimeString    -   String representing time in format HH:MM:SS
    pDateTime       -   Output DATE

Return Value:

    TRUE  - Succeeded
    FALSE - Failed

--*/

{

    WORD        iVal;
    PCHAR       pCh;

    SYSTEMTIME  sysTime;

    //
    // Process the Date. Format is 1998-01-27 ( Year-Month-Day )
    //

    memset (&sysTime,0,sizeof(sysTime));
    pCh = szDateString;
    
    sysTime.wYear = (*pCh-'0')*1000 + ( *(pCh+1)-'0' )*100 + 
                    ( *(pCh+2)-'0')*10 + ( *(pCh+3)-'0');

    pCh += 5;

    iVal = *pCh -'0';
    if ( *(pCh+1) != '/')
    {
        iVal = iVal*10 + *(pCh+1) - '0';
        pCh++;
    }
    sysTime.wMonth = iVal;
    
    pCh+=2;

    iVal = *pCh -'0';
    if ( *(pCh+1) != '/')
    {
        iVal = iVal*10 + *(pCh+1) - '0';
    }
    sysTime.wDay = iVal;

    //
    // Process the Time. Format is 10:47:44 ( HH:MM:SS )
    //

    pCh = szTimeString;

    iVal = *pCh -'0';
    if ( *(pCh+1) != ':')
    {
        iVal = iVal*10 + *(pCh+1) - '0';
        pCh++;
    }
    sysTime.wHour = iVal;
    
    pCh += 2;

    iVal = *pCh -'0';
    if ( *(pCh+1) != ':')
    {
        iVal = iVal*10 + *(pCh+1) - '0';
        pCh++;
    }
    sysTime.wMinute = iVal;

    pCh += 2;

    iVal = *pCh -'0';
    if ( *(pCh+1) != '\0')
    {
        iVal = iVal*10 + *(pCh+1) - '0';
    }
    sysTime.wSecond = iVal;
    
    return SystemTimeToVariantTime(&sysTime, pDateTime);
}

/* ************************************************************************************ */
/* Support Functions                                                                    */
/* ************************************************************************************ */

VOID
CEXTLOG::FormNewLogFileName(
                IN LPSYSTEMTIME pstNow
                )
/*++
  This function that forms the new log file name based on
   type of periodic logging done.

  Arguments:
    pstNow     pointer to SystemTime which contains the current time.
    fBackup    flag indicating if we want to make current file a backup.

  Returns:
    TRUE on success in forming the name or FALSE if there is any error.

--*/
{

    I_FormNewLogFileName(pstNow,DEFAULT_EXTENDED_LOG_FILE_NAME);

} // INET_FILE_LOG::FormNewLogFileName()

/* ************************************************************************************ */

LPCSTR
CEXTLOG::QueryNoPeriodPattern(
    VOID
    )
{
    return szExtNoPeriodPattern;
} // CEXTLOG::QueryNoPeriodPattern

/* ************************************************************************************ */

VOID
CEXTLOG::InternalGetConfig(
        PINETLOG_CONFIGURATIONA pLogConfig
        )
{
    CLogFileCtrl::InternalGetConfig( pLogConfig );
    pLogConfig->u.logFile.dwFieldMask = m_lMask;
}

/* ************************************************************************************ */

VOID
CEXTLOG::InternalGetExtraLoggingFields(
    PDWORD pcbSize,
    PCHAR  pszFieldsList
    )
{
    TCHAR *pszTmp = pszFieldsList;
    DWORD dwSize = 0;
    DWORD dwFieldSize;

    if (m_lMask & EXTLOG_HOST ) {
        lstrcpy( pszTmp, "Host:");
        dwFieldSize = (DWORD)strlen(pszTmp)+1;
        pszTmp += dwFieldSize;
        dwSize += dwFieldSize;
    }

    if (m_lMask & EXTLOG_USER_AGENT ) {
        lstrcpy( pszTmp, "User-Agent:");
        dwFieldSize = (DWORD)strlen(pszTmp)+1;
        pszTmp += dwFieldSize;
        dwSize += dwFieldSize;
    }

    if (m_lMask & EXTLOG_COOKIE ) {
        lstrcpy( pszTmp, "Cookie:");
        dwFieldSize = (DWORD)strlen(pszTmp)+1;
        pszTmp += dwFieldSize;
        dwSize += dwFieldSize;
    }

    if (m_lMask & EXTLOG_REFERER ) {
        lstrcpy( pszTmp, "Referer:");
        dwFieldSize = (DWORD)strlen(pszTmp)+1;
        pszTmp += dwFieldSize;
        dwSize += dwFieldSize;
    }
    pszTmp[0]='\0';
    dwSize++;
    *pcbSize = dwSize;
    return;

} // CEXTLOG::InternalGetExtraLoggingFields

/* ************************************************************************************ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\log\plugin\ilogfile.cxx ===
/*++

   Copyright    (c)    1995-1996    Microsoft Corporation

   Module  Name :

       ilogfile.cxx

   Abstract:
       This module defines helper functions for File logging

   Author:

       Murali R. Krishnan    ( MuraliK )     21-FEb-1996

--*/

#include "precomp.hxx"

#define BLOCK_INC_SIZE          1

#if !defined(STATUS_DISK_FULL)
#define STATUS_DISK_FULL    0xC000007FL
#endif

ILOG_FILE::ILOG_FILE(
    VOID
    )
/*++
  This function constructs a new File object used for handling
    log files.

  The reference count is used to count the number of owners
    of this object. It starts off with 1.
    the ILOG_FILE::OpenFileForAppend() function
        inrements refcount when a new owner is given this object
    the ILOG_FILE::CloseFile() function
        derements refcount when an owner relinquishes the object

--*/
:
   m_hFile            ( INVALID_HANDLE_VALUE),
   m_pvBuffer         ( NULL),
   m_cbBufferUsed     ( 0),
   m_hMemFile         ( NULL),
   m_nGranules        ( 0),
   m_strFileName      ( )
{
    SYSTEM_INFO sysInfo;

    m_qwFilePos.QuadPart = 0;
    m_mapSize.QuadPart = 0;

    GetSystemInfo(&sysInfo);
    m_dwAllocationGranularity = sysInfo.dwAllocationGranularity;

    if ( m_dwAllocationGranularity == 0 ) {
        m_dwAllocationGranularity = 0x10000;
    }

} // ILOG_FILE::ILOG_FILE()




ILOG_FILE::~ILOG_FILE(VOID)
/*++
  This function cleans up state maintained within the object -
    freeing up the memory and closing file handle.
  It then destroys all state information maintained.

  The reference count should be zero, indicating this object is no more in use.

--*/
{
    CloseFile();

    return;
} // ILOG_FILE::~ILOG_FILE()



BOOL
ILOG_FILE::ExpandMapping(
    VOID
    )
{

    m_mapSize.QuadPart = m_mapSize.QuadPart + (ULONGLONG)(BLOCK_INC_SIZE * m_dwAllocationGranularity);
    
    /*
    //
    // This check is removed as now condition isn't true becuase we are not limited by 32 bit 
    // truncation size
    //
    if ( (newMapSize.QuadPart < m_mapSize.QuadPart) || (m_mapSize.QuadPart > m_qwTruncateSize.QuadPart) ) {
        IIS_PRINTF((buff,"Cannot expand mapping.  "
            "New size %d will exceed truncation size %d\n",
            newMapSize, m_qwTruncateSize));

        SetLastError( ERROR_DISK_FULL );
        return(FALSE);
    }
    */

    //
    // Destroy the old and create a new mapping
    //

    DestroyMapping( );

    return(CreateMapping( ));

} // ExpandMapping


BOOL
ILOG_FILE::CreateMapping(
    VOID
    )
{
    //
    // find the next file mapping window
    //
    ULARGE_INTEGER qwStart;
    ULARGE_INTEGER qwTmp;

    DWORD dwSize;


    //DWORD dwSize;

    qwStart.QuadPart = m_qwFilePos.QuadPart;
    qwStart.LowPart = qwStart.LowPart - (qwStart.LowPart % m_dwAllocationGranularity);


    m_hMemFile = CreateFileMapping(
                            m_hFile,
                            NULL,
                            PAGE_READWRITE,
                            m_mapSize.HighPart,
                            m_mapSize.LowPart,
                            NULL ) ;

    if ( m_hMemFile == NULL ) {

#if 0
        IIS_PRINTF((buff,"Error %d in CreateFileMapping[%s][size = %d]\n",
            GetLastError(), m_strFileName.QueryStr(),
            m_mapSize ));
#endif
        SetLastError( ERROR_DISK_FULL );
        return(FALSE);
    }

    qwTmp.QuadPart = m_mapSize.QuadPart - qwStart.QuadPart;
    dwSize = qwTmp.LowPart;
    

    qwTmp.QuadPart = m_qwFilePos.QuadPart - qwStart.QuadPart;
    m_cbBufferUsed = qwTmp.LowPart;


    m_pvBuffer = MapViewOfFile(
                        m_hMemFile,
                        FILE_MAP_ALL_ACCESS,
                        qwStart.HighPart,
                        qwStart.LowPart,
                        dwSize
                        );

    if ( m_pvBuffer == NULL ) {
        IIS_PRINTF((buff,"Error %d in MapViewOfFile[%s][%d:%d,%d]\n",
            GetLastError(), m_strFileName.QueryStr(),
            qwStart.HighPart,qwStart.LowPart, dwSize ));
        DestroyMapping();
        return(FALSE);
    }

    return(TRUE);
} // CreateMapping



BOOL
ILOG_FILE::Write(
    IN PCHAR pvData,
    IN DWORD cbData
    )
/*++
  This function writes the data present in the input buffer of specified
    length to the file.
  For performance reasons, the function actually buffers data in the
    internal buffers of ILOG_FILE object. Such buffered data is flushed
    to disk later on when buffer (chain) is full or when
    a flush call is made from a scheduled flush.

  Arguments:
     pvData       pointer to buffer containing data to be written
     cbData       count of characters of data to be written.

  Returns:
     TRUE on success and FALSE if there is any error.
--*/
{
    ULARGE_INTEGER oldFilePos;
    ULARGE_INTEGER newFilePos;

    BOOL  fReturn = TRUE;

    if ( m_hMemFile == NULL ) {
        SetLastError( ERROR_INVALID_PARAMETER);
        return ( FALSE);
    }

    //
    // Bug 110351: Need try-except blocks around CopyMemory for dealing
    // with compressed files
    //

    oldFilePos.QuadPart = m_qwFilePos.QuadPart;
    newFilePos.QuadPart = m_qwFilePos.QuadPart + (ULONGLONG)cbData;

    //
    // copy part of the data to the end of the buffer
    //

    if (newFilePos.QuadPart > m_mapSize.QuadPart ) {

        ULARGE_INTEGER qwSpace;
        DWORD dwSpace;

        qwSpace.QuadPart = m_mapSize.QuadPart - m_qwFilePos.QuadPart;

        dwSpace = qwSpace.LowPart;

        __try
        {
            CopyMemory(
                    (LPBYTE)m_pvBuffer + m_cbBufferUsed,
                    (PVOID)pvData,
                    dwSpace
                    );

        }
        __except( ( _exception_code() == STATUS_IN_PAGE_ERROR ||
                    _exception_code() == STATUS_DISK_FULL ) ?
                  EXCEPTION_EXECUTE_HANDLER :
                  EXCEPTION_CONTINUE_SEARCH )
        {
            SetLastError( _exception_code() );
            goto error_exit;
        }
           
        cbData -= dwSpace;
        pvData += dwSpace;
        m_cbBufferUsed += dwSpace;
        m_qwFilePos.QuadPart = m_qwFilePos.QuadPart + qwSpace.QuadPart;


        if ( !ExpandMapping( ) ) 
        {
            DWORD err = GetLastError();
            SetLastError(err);
            goto error_exit;
        }
    }

    __try
    {
       CopyMemory(
            (LPBYTE)m_pvBuffer + m_cbBufferUsed,
            pvData,
            cbData
            );
    }
    __except(( _exception_code() == STATUS_IN_PAGE_ERROR ||
                    _exception_code() == STATUS_DISK_FULL ) ?
                  EXCEPTION_EXECUTE_HANDLER :
                  EXCEPTION_CONTINUE_SEARCH )
    {
        SetLastError( _exception_code() );
        goto error_exit;
    }

    m_cbBufferUsed += cbData;

    m_qwFilePos.QuadPart = m_qwFilePos.QuadPart + (ULONGLONG)cbData;

    return ( fReturn);

error_exit:

    m_qwFilePos.QuadPart = oldFilePos.QuadPart;
    CloseFile( );
    return(FALSE);


} // ILOG_FILE::Write()



BOOL
ILOG_FILE::Open(
        IN LPCSTR pszFileName,
        IN DWORD  dwTruncationSize,
        IN BOOL   fLogEvent
        )
/*++
  This function opens up a new file for appending data.
  This function automatically sets the file pointer to be
   at the end of file to just enable append to file.

  This function should be called after locking this object

  Arguments:
    pszFileName - name of the file to open
    dwTruncationSize
    fLogEvent   - Produce an event log if Open fails.

  Returns:
    TRUE on success and FALSE if there is any failure.

--*/
{
    BOOL                fRet;
    HANDLE              hToken = NULL;

    if ( dwTruncationSize < MIN_FILE_TRUNCATION_SIZE ) {
        dwTruncationSize = MIN_FILE_TRUNCATION_SIZE;
    }

    m_qwTruncateSize.HighPart = 0;
    m_qwTruncateSize.LowPart = dwTruncationSize;

    m_nGranules = BLOCK_INC_SIZE;
    m_mapSize.QuadPart = UInt32x32To64(m_nGranules,m_dwAllocationGranularity);
    m_strFileName.Copy(pszFileName);

    //
    // There is a small chance that this function could be called (indirectly)
    // from an INPROC ISAPI completion thread (HSE_REQ_DONE).  In this case
    // the thread token is the impersonated user and may not have permissions
    // to open the log file (especially if the user is the IUSR_ account).  
    // To be paranoid, let's revert to LOCAL_SYSTEM anyways before opening.
    //
    
    if ( OpenThreadToken( GetCurrentThread(), 
                          TOKEN_ALL_ACCESS, 
                          FALSE, 
                          &hToken ) )
    {
        DBG_ASSERT( hToken != NULL );
        RevertToSelf();
    }
    
    fRet = OpenFile( pszFileName, fLogEvent);
    
    if ( hToken != NULL )
    {
        SetThreadToken( NULL, hToken );
    } 
    
    return fRet;

} // ILOG_FILE::Open


BOOL
ILOG_FILE::OpenFile(
        IN LPCSTR pszFileName,
        IN BOOL   fLogEvent
        )
{
    ULARGE_INTEGER qwTmp;
    DWORD err = NO_ERROR;


    m_qwFilePos.QuadPart = 0;
    m_pvBuffer = NULL;
    m_cbBufferUsed = 0;

    //
    // 1. Create a new file -- open a file if it already exists
    //

    m_hFile = CreateFile(pszFileName,
                          GENERIC_WRITE | GENERIC_READ,
                          FILE_SHARE_WRITE | FILE_SHARE_READ,
                          NULL,       // security attributes
                          OPEN_ALWAYS,
                          FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                          NULL);      // template file handle

    if ( m_hFile == INVALID_HANDLE_VALUE ) {

       err = GetLastError();

       
       if ( (g_eventLog != NULL) && fLogEvent) {

           const CHAR*    tmpString[1];
           tmpString[0] = pszFileName;

           g_eventLog->LogEvent(
               LOG_EVENT_CREATE_FILE_ERROR,
               1,
               tmpString,
               err
               );
        }

        IIS_PRINTF((buff,"CreateFile[%s] error %d\n",
            pszFileName, err));
        
        SetLastError(err);
        return(FALSE);
    }

    //
    // 2. Set the file pointer at the end of the file (append mode)
    //

    if ( GetLastError() == ERROR_ALREADY_EXISTS ) {

        if ( !PositionToEOF( &m_qwFilePos ) ) {
            err = GetLastError();
            goto error_exit;
        }

        qwTmp.HighPart = 0;
        qwTmp.LowPart = BLOCK_INC_SIZE * m_dwAllocationGranularity;

        while ( m_qwFilePos.QuadPart >= m_mapSize.QuadPart ) {

            m_mapSize.QuadPart  = m_mapSize.QuadPart + qwTmp.QuadPart;
            m_nGranules += BLOCK_INC_SIZE;
        }

        /*
        // not anymore a problem for 64b file possition offsets  
        if ( m_mapSize.QuadPart >= m_qwTruncateSize.QuadPart ) {
            IIS_PRINTF((buff,"[OpenFile] Truncate size[%d] exceeded[%d]\n",
                m_qwTruncateSize, m_mapSize));
            err = ERROR_INSUFFICIENT_BUFFER;
            goto error_exit;
        }
        */
    }

    if ( !CreateMapping( ) ) {
        err = GetLastError();
        goto error_exit;
    }

    return ( TRUE );

error_exit:

    CloseFile( );
    SetLastError(err);
    return(FALSE);

} // ILOG_FILE::OpenFile()


BOOL
ILOG_FILE::PositionToEOF(
    ULARGE_INTEGER  *pFilePos
    )
/*++
  Determine where to begin append operation

  This function should be called after locking this object

  Arguments:
    pFilePos - updated with position where to begin append if success

  Returns:
    TRUE on success and FALSE if there is any failure.

--*/
{
    ULARGE_INTEGER  qwFileSize;
    ULARGE_INTEGER  qwFilePos;
    BOOL    fReturn = FALSE;
    DWORD   dwRet;

    //
    // If file size multiple of BLOCK_INC_SIZE * m_dwAllocationGranularity
    // then it is likely that file has not been closed properly.
    // If this is the case we need to get the position of the last
    // zero char in the file and start logging there.
    //


    qwFileSize.QuadPart = 0;
    qwFileSize.LowPart = GetFileSize( m_hFile,&qwFileSize.HighPart);


    if (qwFileSize.LowPart != FILE_SIZE_LOW_MAX || GetLastError()==NO_ERROR)
    {
        if ( (qwFileSize.LowPart  == 0) ||
             (qwFileSize.LowPart  % m_dwAllocationGranularity) != 0 ) 
        {

            qwFilePos.QuadPart = 0;

            dwRet = SetFilePointer(m_hFile,
                                qwFilePos.LowPart,
                                (PLONG)(&qwFilePos.HighPart),
                                FILE_END);

            if (dwRet != FILE_SIZE_LOW_MAX || GetLastError()==NO_ERROR)
            {

                pFilePos->QuadPart = qwFileSize.QuadPart;
                return TRUE;
            }
            else
            {
                IIS_PRINTF((buff,"SetFilePointer[END] failed %d\n",
                    GetLastError()));
                return(FALSE);
            }

        } 
        else 
        {

            //
            // find last zero char in file
            //
            ULARGE_INTEGER    lLow;
            ULARGE_INTEGER    lHigh;
            ULARGE_INTEGER    lLast;
            ULARGE_INTEGER    lMiddle;
            CHAR    ch;
            DWORD   dwRead;

            lLow.QuadPart = 0;
            lHigh.QuadPart = qwFileSize.QuadPart - 1;
            lLast.QuadPart = qwFileSize.QuadPart;

            fReturn = TRUE;

            while ( lLow.QuadPart <= lHigh.QuadPart ) {

                lMiddle.QuadPart = lLow.QuadPart + (lHigh.QuadPart - lLow.QuadPart) / 2;

                dwRet = SetFilePointer( m_hFile,
                                        lMiddle.LowPart,
                                        (PLONG)(&lMiddle.HighPart),
                                        FILE_BEGIN);

                if  (dwRet==FILE_SIZE_LOW_MAX && GetLastError()!=NO_ERROR)
                {
                    fReturn = FALSE;
                    break;
                }

                if ( ReadFile( m_hFile, &ch, 1, &dwRead, NULL ) ) {
                    if ( ch == '\0' ) {
                        lHigh.QuadPart = lMiddle.QuadPart - 1;
                        lLast.QuadPart = lMiddle.QuadPart;
                    } else {
                        lLow.QuadPart = lMiddle.QuadPart + 1;
                    }
                } else {
                    fReturn = FALSE;
                    break;
                }
            }

            if ( fReturn ) {
                IIS_PRINTF((buff,"[ilogfile.cxx], set log pos:%I64u\n",
                    lLast.QuadPart ));

                dwRet = SetFilePointer( m_hFile,
                                        lLast.LowPart,
                                        (PLONG)(&lLast.HighPart),
                                        FILE_BEGIN );

                if (dwRet!=FILE_SIZE_LOW_MAX || GetLastError()==NO_ERROR)
                {
                    pFilePos->QuadPart = lLast.QuadPart;
                } else 
                {
                    fReturn = FALSE;
                }
            }
        }
    } else {
        IIS_PRINTF((buff,"GetFilePosition failed with %d\n",
            GetLastError()));
    }

    return fReturn;
}



BOOL
ILOG_FILE::CloseFile(VOID)
/*++
  This function closes the open file. It flushes out file data
   before closing the file.

  This function should be called after locking this object

  Arguments:
    None

  Returns:
    TRUE on success and FALSE if there is any failure.

--*/
{
    DWORD dwRet;

    DestroyMapping( );

    if ( m_hFile != INVALID_HANDLE_VALUE)  {

        //
        // set the pointer to the end of file
        //

        dwRet = SetFilePointer( m_hFile,
                                m_qwFilePos.LowPart,
                                (PLONG)(&m_qwFilePos.HighPart),
                                FILE_BEGIN);

        if ( dwRet==FILE_SIZE_LOW_MAX && GetLastError()!=NO_ERROR )
        {

            IIS_PRINTF((buff,"SetFilePointer[Pos = %I64u] failed with %d\n",
                m_qwFilePos.QuadPart, GetLastError()));

        }

        SetEndOfFile( m_hFile );
        CloseHandle( m_hFile);
        m_hFile = INVALID_HANDLE_VALUE;  // store the invalid handle
    }

    return (TRUE);
} // ILOG_FILE::CloseFile()



VOID
ILOG_FILE::DestroyMapping(
    VOID
    )
/*++
  This function closes the open file. It flushes out file data
   before closing the file.

  This function should be called after locking this object

  Arguments:
    None

  Returns:
    TRUE on success and FALSE if there is any failure.

--*/
{
    /* NKJ -- why do we need to flush?
    if ( m_hFile != INVALID_HANDLE_VALUE)  {
        FlushFileBuffers( m_hFile);
    }
    */

    if ( m_pvBuffer != NULL ) {
        /* FlushViewOfFile( m_pvBuffer, 0 ); * NKJ */
        UnmapViewOfFile( m_pvBuffer );
        m_pvBuffer = NULL;
    }

    if (m_hMemFile!=NULL) {
        CloseHandle( m_hMemFile );
        m_hMemFile = NULL;
    }
    return;
} // ILOG_FILE::DestroyMapping
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\log\plugin\odblogc.cpp ===
/*++

   Copyright    (c)    1995-1996    Microsoft Corporation

   Module  Name :
      odblogc.cpp

   Abstract:
      NCSA Logging Format implementation

   Author:

       Terence Kwan    ( terryk )    18-Sep-1996

   Project:

       IIS Logging 3.0

--*/

#include "precomp.hxx"
#include "odbcconn.hxx"
#include <ilogobj.hxx>
#include "odblogc.hxx"
#include <iadmw.h>


/************************************************************
 *    Symbolic Constants and Data
 ************************************************************/

# define MAX_SQL_FIELD_NAMES_LEN       ( 400)
# define MAX_SQL_FIELD_VALUES_LEN      ( 200)
# define MAX_SQL_IDENTIFIER_QUOTE_CHAR ( 50)

# define PSZ_UNKNOWN_FIELD_W      _T("-")
# define PSZ_UNKNOWN_FIELD_A      _T("-")

# define PSZ_GET_ERROR_FAILED_A    _T("ODBC:GetLastError() Failed")
# define LEN_PSZ_GET_ERROR_FAILED_A  sizeof(PSZ_GET_ERROR_FAILED_A)

# define PSZ_GET_ERROR_FAILED_W    _T("ODBC:GetLastError() Failed")
# define LEN_PSZ_GET_ERROR_FAILED_W  sizeof(PSZ_GET_ERROR_FAILED_W)

//
//  The template of SQL command has 3 arguments.
//   1. table name
//   2. field names
//   3. field values
// 1,2 and 3 are obained  during the first wsprintf
//

static const CHAR  sg_rgchSqlInsertCmdTemplate[] =
    _T("insert into %s ( %s) values ( %s)");

# define PSZ_SQL_INSERT_CMD_TEMPLATE    (  sg_rgchSqlInsertCmdTemplate)
# define LEN_PSZ_SQL_INSERT_CMD_TEMPLATE  \
           ( lstrlen( PSZ_SQL_INSERT_CMD_TEMPLATE))

//
// Leave %ws so that we can print the service and server name when this
//   string is used to generate an SQL statement.
//
static const CHAR sg_rgchStdLogFieldValues[] =
   _T(" ?, ?, ?, '%s', '%s', ?, ?, ?, ?, ?, ?, ?, ?, ?");

# define PSZ_INTERNET_STD_LOG_FORMAT_FIELD_NAMES  ( sg_rgchStdLogFieldNames)
# define PSZ_INTERNET_STD_LOG_FORMAT_FIELD_VALUES ( sg_rgchStdLogFieldValues)


//
// AllFieldInfo()
//  Defines all the fields required for SQL logging of the information
//   to the database using ODBC interfaces.
//  C arrays are numbered from offset 0.
//  SQL columns are numbered from 1.
//  field index values start from 0 and we adjust it when we talk of SQL col.
//  FieldInfo( symbolic-name, field-name,
//             field-index/column-number,
//             field-C-type, field-Sql-type,
//             field-precision, field-max-size, field-cb-value)
//

# define StringField( symName, fldName, fldIndex, prec)  \
FieldInfo( symName, fldName, fldIndex, SQL_C_CHAR, SQL_CHAR, \
          (prec), (prec), SQL_NTS)

# define NumericField( symName, fldName, fldIndex)  \
FieldInfo( symName, fldName, fldIndex, SQL_C_LONG, SQL_INTEGER, \
           0, sizeof( DWORD), 0)

# define TimeStampField( symName, fldName, fldIndex) \
FieldInfo( symName, fldName, fldIndex, SQL_C_TIMESTAMP, SQL_TIMESTAMP, \
          0, sizeof( TIMESTAMP_STRUCT), 0)

//
// fields that have constant value. we are interested in names of such fields.
// they have negative field indexes.
// These fields need not be generated as parameter markers.
//  ( Since they are invariants during lifetime of an INET_SQL_LOG oject)
//  Hence the field values will go into the command generated.
// Left here as a documentation aid and field-generation purposes.
//
# define ConstantValueField( synName, fldName) \
FieldInfo( synName, fldName, -1,  SQL_C_CHAR, SQL_CHAR, 0, 0, SQL_NTS)

//
// Ideally the "username" field should have MAX_USER_NAME_LEN as max size.
//  However, Access 7.0 limits varchar() size to be 255 (8 bits) :-(
//  So, we limit the size to be the least of the two ...
//
// FieldNames used are reserved. They are same as the names distributed
//   in the template log file. Do not change them at free will.
//
//

# define AllFieldInfo() \
 StringField(        CLIENT_HOST,       _T("ClientHost"),     0,   255)    \
 StringField(        USER_NAME,         _T("username"),       1,   255)    \
 TimeStampField(     REQUEST_TIME,      _T("LogTime"),        2)          \
 ConstantValueField( SERVICE_NAME,      _T("service"))                    \
 ConstantValueField( SERVER_NAME,       _T("machine"))                    \
 StringField(        SERVER_IPADDR,     _T("serverip"),       3,   50)    \
 NumericField(       PROCESSING_TIME,   _T("processingtime"), 4)          \
 NumericField(       BYTES_RECVD,       _T("bytesrecvd"),     5)          \
 NumericField(       BYTES_SENT,        _T("bytessent"),      6)          \
 NumericField(       SERVICE_STATUS,    _T("servicestatus"),  7)          \
 NumericField(       WIN32_STATUS,      _T("win32status"),    8)          \
 StringField(        SERVICE_OPERATION, _T("operation"),      9,  255)    \
 StringField(        SERVICE_TARGET,    _T("target"),        10,  255)    \
 StringField(        SERVICE_PARAMS,    _T("parameters"),    11,  255)    \


/************************************************************
 *    Type Definitions
 ************************************************************/

//
// Define the FieldInfo macro to generate a list of enumerations for
//  the indexes to be used in the array of field parameters.
//


# define FieldInfo(symName, field, index, cType, sqlType, prec, maxSz, cbVal) \
        i ## symName = (index),

enum LOGGING_VALID_COLUMNS {


    // fields run from 0 through iMaxFields
    AllFieldInfo()

    iMaxFields
}; // enum LOGGING_VALID_COLUMNS


# undef FieldInfo


# define FieldInfo(symName, field, index, cType, sqlType, prec, maxSz, cbVal) \
        fi ## symName,

enum LOGGING_FIELD_INDEXES {

    fiMinFields = -1,

    // fields run from 0 through fiMaxFields
    AllFieldInfo()

    fiMaxFields
}; // enum LOGGING_FIELD_INDEXES


# undef FieldInfo


struct FIELD_INFO {

    int     iParam;
    CHAR  * pszName;
    SWORD   paramType;
    SWORD   cType;
    SWORD   sqlType;
    UDWORD  cbColPrecision;
    SWORD   ibScale;
    SDWORD  cbMaxSize;
    SDWORD  cbValue;
}; // struct FIELD_INFO


//
// Define the FieldInfo macro to generate a list of data to be generated
//   for entering the data values in an array for parameter information.
//  Note the terminating ',' used here.
//

# define FieldInfo(symName, field, index, cType, sqlType, prec, maxSz, cbVal) \
  { ((index) + 1), field, SQL_PARAM_INPUT, cType, sqlType,  \
    ( prec), 0, ( maxSz), ( cbVal) },

/*

   The array of Fields: sg_rgFields contain the field information
    for logging to SQL database for the log-record of
    the services. The values are defined using the macros FieldInfo()
    defined above.


   If there is any need to add/delete/modify the parameters bound,
    one should modify the above table "AllFieldInfo" macro.

*/

static FIELD_INFO  sg_rgFields[] = {

    AllFieldInfo()

      //
      // The above macro after expansion terminates with a comma.
      //  Add dummy entry to complete initialization of array.
      //

      { 0, _T("dummy"), SQL_PARAM_INPUT, 0, 0, 0, 0, 0, 0}
};


# undef FieldInfo

//
// tick minute.
//

#define TICK_MINUTE         (60 * 1000)


/************************************************************
 *    Functions
 ************************************************************/

BOOL
GenerateFieldNames(IN PODBC_CONNECTION poc,
                   OUT CHAR * pchFieldNames,
                   IN DWORD    cchFieldNames);

inline BOOL
IsEmptyStr( IN LPCSTR psz)
{  return ( psz == NULL || *psz == _T('\0')); }

BOOL
CODBCLOG::PrepareStatement( VOID)
/*++
  This command forms the template SQL command used for insertion
    of log records. Then it prepares the SQL command( for later execution)
    using ODBC_CONNECTION::PrepareStatement().

  It should always be called after locking the INET_SQL_LOG object.

  Arguments:
    None

  Returns:
    TRUE on success and FALSE if there is any failure.

  Note:
     The template for insertion is:

     insert into <table name> ( field names ...) values (  ?, ?, ...)
                                                         ^^^^
                                             Field values go here

    Field names are generated on a per logging format basis.
--*/
{
    BOOL   fReturn = FALSE;
    CHAR  rgchFieldNames[ MAX_SQL_FIELD_NAMES_LEN];
    CHAR  rgchFieldValues[ MAX_SQL_FIELD_VALUES_LEN];


    //
    // Obtain field names and field values ( template) for various log formats.
    //  The order of field names should match the order of field values
    //  generated by FormatLogInformation() for the format specified.
    //

    rgchFieldNames[ 0] = rgchFieldValues[ 0] = _T('\0');

    DWORD cchFields;

    fReturn = GenerateFieldNames(m_poc,
                                 rgchFieldNames,
                                 MAX_SQL_FIELD_NAMES_LEN);

    if ( !fReturn) {

        //DBGPRINTF(( DBG_CONTEXT,
        //           " Unable to generate field names. Error = %d\n",
        //           GetLastError()));
        //break;
        return(fReturn);
    }

    cchFields = wsprintf( (CHAR *)rgchFieldValues,
                           PSZ_INTERNET_STD_LOG_FORMAT_FIELD_VALUES,
                           QueryServiceName(),
                           QueryServerName());

    fReturn = (fReturn && (cchFields < MAX_SQL_FIELD_VALUES_LEN));
    //DBG_ASSERT( cchFields <  MAX_SQL_FIELD_VALUES_LEN);

    fReturn = TRUE;

    if ( fReturn) {

        CHAR * pwszSqlCommand;
        DWORD   cchReqd;

        //
        //  The required number of chars include sql insert template command
        //   and field names and table name.
        //

        cchReqd = (DWORD)( LEN_PSZ_SQL_INSERT_CMD_TEMPLATE +
                   strlen( m_rgchTableName) +
                   strlen( rgchFieldNames)  +
                   strlen( rgchFieldValues) + 20);

        pwszSqlCommand = ( CHAR *) LocalAlloc( LPTR, cchReqd * sizeof( CHAR));
        m_poStmt = m_poc->AllocStatement();

        fReturn = ( pwszSqlCommand != NULL ) && ( m_poStmt != NULL );
        if ( fReturn ) {

            DWORD cchUsed;

            cchUsed = wsprintf( pwszSqlCommand,
                                PSZ_SQL_INSERT_CMD_TEMPLATE,
                                m_rgchTableName,
                                rgchFieldNames,
                                rgchFieldValues);
            //DBG_ASSERT( cchUsed < cchReqd);

            //IF_DEBUG(INETLOG) {
            //    DBGPRINTF( ( DBG_CONTEXT,
            //                " Sqlcommand generated is: %ws.\n",
            //                pwszSqlCommand));
            //}

            fReturn = ((cchUsed < cchReqd) &&
                       m_poStmt->PrepareStatement( pwszSqlCommand)
                       );

            LocalFree( pwszSqlCommand);         // free allocated memory
        }

    } // valid field names and filed values.


    //IF_DEBUG( INETLOG) {
    //
    //    DBGPRINTF( ( DBG_CONTEXT,
    //                "%s::PrepareStatement() returns %d.",
    //                QueryClassIdString(), fReturn));
    //}

    return ( fReturn);
} // INET_SQL_LOG::PrepareStatement()


BOOL
CODBCLOG::PrepareParameters( VOID)
/*++
  This function creates an array of ODBC_PARAMETER objects used for binding
    parameters to an already prepared statement. These ODBC_PARAMETER objects
    are then used for insertion of data values into the table specified,
    through ODBC.

  This function should always be called after locking the object.

  Arguments:
     None

  Returns:
     TRUE on success and FALSE if there is any failure.
--*/
{
    BOOL fReturn = FALSE;
    PODBC_PARAMETER * prgParams = NULL;
    DWORD cParams = 0;
    DWORD nParamsSeen = 0;

    DWORD i;

    //DBG_ASSERT( m_poStmt != NULL && m_poStmt->IsValid()  &&
    //            m_ppParams == NULL && m_cOdbcParams == 0);

    //
    // create sufficient space for iMaxFields pointers to ODBC objects.
    //
    prgParams = new PODBC_PARAMETER[ iMaxFields];


    if ( prgParams != NULL) {

        fReturn = TRUE;      // Assume everything will go on fine.
        cParams = iMaxFields;


        //
        // Create all the ODBC parameters.
        //  Walk through all field indexes and pick up the valid columns
        //
        for( nParamsSeen = 0, i =0; i < fiMaxFields; i++) {

            if ( sg_rgFields[i].iParam > 0) {

                WORD colNum = (WORD ) sg_rgFields[i].iParam;

                prgParams[nParamsSeen] =
                  new ODBC_PARAMETER(colNum,
                                     sg_rgFields[i].paramType,
                                     sg_rgFields[i].cType,
                                     sg_rgFields[i].sqlType,
                                     sg_rgFields[i].cbColPrecision
                                     );

                if ( prgParams[ nParamsSeen] == NULL) {

                    fReturn = FALSE;
                    //DBGPRINTF( ( DBG_CONTEXT,
                    //            " Failed to create Parameter[%d] %s. \n",
                    //            i, sg_rgFields[i].pszName));
                    break;
                }

                nParamsSeen++;
                //DBG_ASSERT( nParamsSeen <= cParams);
            }
        } // for creation of all ODBC parameters


        if ( fReturn) {
            //
            // Set buffers for values to be received during insertions.
            // Bind parameters to the statement using ODBC_CONNECTION object.
            //

            //DBG_ASSERT( nParamsSeen == cParams);

            for( nParamsSeen = 0, i = 0; i < fiMaxFields; i++) {

                if ( sg_rgFields[i].iParam > 0) {

                    if (!prgParams[nParamsSeen]->
                        SetValueBuffer(sg_rgFields[i].cbMaxSize,
                                       sg_rgFields[i].cbValue) ||
                        !m_poStmt->BindParameter( prgParams[nParamsSeen])
                        ) {

                        fReturn = FALSE;
                        //DBGPRINTF( ( DBG_CONTEXT,
                        //            " Binding Parameter [%u] (%08x) failed.\n",
                        //            nParamsSeen, prgParams[nParamsSeen]));
                        //DBG_CODE( prgParams[ i]->Print());
                        break;
                    }

                    nParamsSeen++;
                }
            } // for
        } // if all ODBC params were created.

        if ( !fReturn) {

            //
            // Free up the space used, since we were unsuccessful.
            //

            for( i = 0; i < iMaxFields; i++) {

                if ( prgParams[ i] != NULL) {

                    delete ( prgParams[ i]);
                    prgParams[i] = NULL;
                }
            } // for

            delete [] prgParams;
            prgParams = NULL;
            cParams = 0;
        }

    } // if array for pointers to ODBC params created successfully

    //
    // Set the values. Either invalid or valid ,depending on failure/success
    //
    m_ppParams    = prgParams;
    m_cOdbcParams = cParams;

    return ( fReturn);
} // INET_SQL_LOG::PrepareParameters()


BOOL
GenerateFieldNames(IN PODBC_CONNECTION poc,
                   OUT CHAR * pchFieldNames,
                   IN DWORD    cchFieldNames)
/*++
  This function generates the field names string from the names of the fields
   and identifier quote character for particular ODBC datasource in use.
--*/
{
    BOOL  fReturn = FALSE;
    CHAR  rgchQuote[MAX_SQL_IDENTIFIER_QUOTE_CHAR];
    DWORD cchQuote;

    //DBG_ASSERT( poc != NULL && pchFieldNames != NULL);

    pchFieldNames[0] = _T('\0');  // initialize

    //
    // Inquire and obtain the SQL identifier quote char for ODBC data source.
    //
    fReturn = poc->GetInfo(SQL_IDENTIFIER_QUOTE_CHAR,
                             rgchQuote, MAX_SQL_IDENTIFIER_QUOTE_CHAR,
                             &cchQuote);

    if ( !fReturn) {

        //DBG_CODE( {
        //    STR strError;
        //
        //    poc->GetLastErrorText( &strError);
        //
        //    DBGPRINTF(( DBG_CONTEXT,
        //           " ODBC_CONNECTION(%08x)::GetInfo(QuoteChar) failed."
        //               " Error = %s\n",
        //               poc, strError.QueryStr()));
        //});

    } else {

        DWORD i;
        DWORD cchUsed = 0;
        DWORD cchLen;

        //
        // ODBC returns " "  (blank) if there is no special character
        //  for quoting identifiers. we need to identify and string the same.
        // This needs to be done, other wise ODBC will complain when
        //  we give unwanted blanks before ","
        //

        if ( !strcmp( rgchQuote, _T(" "))) {

            rgchQuote[0] = _T('\0');  // string the quoted blank.
            cchQuote     = 0;
        } else {

            cchQuote = (DWORD)strlen( rgchQuote);
        }

        // for each column, generate the quoted literal string and concatenate.
        for( i = 0; i < fiMaxFields; i++) {

            DWORD cchLen1 =
              (DWORD)strlen(sg_rgFields[i].pszName) + 2 * cchQuote + 2;

            if ( cchUsed + cchLen1 < cchFieldNames) {

                // space available for copying the data.
                cchLen = wsprintf( pchFieldNames + cchUsed,
                                   _T(" %s%s%s,"),
                                   rgchQuote,
                                   sg_rgFields[i].pszName,
                                   rgchQuote
                                   );

                //DBG_ASSERT( cchLen == cchLen1);
            }

            cchUsed += cchLen1;
        } // for


        if ( cchUsed >= cchFieldNames) {

            // buffer exceeded. return error.
            SetLastError( ERROR_INSUFFICIENT_BUFFER);
            fReturn = FALSE;

        } else {

            //
            // Reset the last character from being a ","
            //
            cchLen = (cchUsed > 0) ? (cchUsed - 1) : 0;
            pchFieldNames[cchLen] = _T('\0');
            fReturn = TRUE;
        }
    }

    //IF_DEBUG( INETLOG) {
    //
    //    DBGPRINTF(( DBG_CONTEXT,
    //               " GenerateFieldNames() returns %d."
    //               " Fields = %S\n",
    //               fReturn, pchFieldNames));
    //}

    return (fReturn);
} // GenerateFieldNames()


CODBCLOG::CODBCLOG()
{

    INITIALIZE_CRITICAL_SECTION( &m_csLock);

    m_poc               = NULL;
    m_poStmt            = NULL;
    m_ppParams          = NULL;
    m_fEnableEventLog   = true;

    m_TickResumeOpen    = GetTickCount() + TICK_MINUTE;
}


/////////////////////////////////////////////////////////////////////////////
// CODBCLOG::~CODBCLOG - Destructor

CODBCLOG::~CODBCLOG()
{
    TerminateLog( );
    DeleteCriticalSection( &m_csLock);
}


STDMETHODIMP
CODBCLOG::InitializeLog(
            LPCSTR pszInstanceName,
            LPCSTR pszMetabasePath,
            CHAR* pMetabase )
{
    DWORD dwError = NO_ERROR;

    // load ODBC entry point
    LoadODBC();

    // get the default parameters

    DWORD   dwL = sizeof(m_rgchServerName);
    
    if ( !GetComputerName( m_rgchServerName, &dwL ) ) 
    {
        m_rgchServerName[0] = '\0';
    }

    strcpy( m_rgchServiceName, pszInstanceName);

    //
    // nntp (5x) logging sends the private IMDCOM interface while w3svc (6.0)
    // logging sends the public IMSAdminBase interface.  Find out which it is
    //
    BOOL fIsPublicInterface = (_strnicmp(pszInstanceName, "w3svc", 5) == 0);

    if (fIsPublicInterface)
    {
        dwError = GetRegParametersFromPublicInterface(pszMetabasePath,
                                                      pMetabase);
    }
    else
    {
        dwError = GetRegParameters(pszMetabasePath, pMetabase);
    }

    if (dwError == NO_ERROR )
    {

        // open database
        if ( m_poc == NULL )
        {
            Lock();

            m_poc = new ODBC_CONNECTION();

            if ( m_poc == NULL )
            {
                dwError = ERROR_NOT_ENOUGH_MEMORY;
            } else
            {
                if ( !m_poc->Open( m_rgchDataSource, m_rgchUserName, m_rgchPassword ) ||
                     !PrepareStatement() ||
                     !PrepareParameters() )
                {
                    dwError = GetLastError();
                }

            }
            Unlock();
        }
    }

    return (dwError == NO_ERROR) ? S_OK : HRESULT_FROM_WIN32(dwError);
}

STDMETHODIMP
CODBCLOG::LogInformation(
        IInetLogInformation * ppvDataObj
        )
{
    DWORD       dwError   = ERROR_SUCCESS;
    BOOL        fReturn;
    SYSTEMTIME  stNow;

    STR         strClientHostName;
    STR         strClientUserName;
    STR         strServerIpAddress;
    STR         strOperation;
    STR         strTarget;
    STR         strParameters;

    PCHAR       pTmp;
    DWORD       cbSize;
    DWORD       dwBytesSent;
    DWORD       dwBytesRecvd;
    DWORD       dwProtocolStatus;
    DWORD       dwWin32Status;
    DWORD       dwTimeForProcessing;


    if (!( 
            m_poc != NULL && m_poc->IsValid() &&
            m_poStmt != NULL && m_poStmt->IsValid() &&
            m_ppParams != NULL 
       ))
    {
        //
        // Check if it is time to retry
        //
        
        DWORD tickCount = GetTickCount( );

        if ( (tickCount < m_TickResumeOpen) ||
             ((tickCount + TICK_MINUTE) < tickCount ) )  // The Tick counter is about to wrap.
        {
            return ERROR_INVALID_PARAMETER;
        }
    } 
   
    dwBytesSent = ppvDataObj->GetBytesSent( );
    dwBytesRecvd = ppvDataObj->GetBytesRecvd( );

    dwTimeForProcessing = ppvDataObj->GetTimeForProcessing( );
    dwWin32Status = ppvDataObj->GetWin32Status( );
    dwProtocolStatus = ppvDataObj->GetProtocolStatus( );

    pTmp = ppvDataObj->GetClientHostName( NULL, &cbSize);
    if ( cbSize == 0 ) {
        pTmp = "";
    }
    strClientHostName.Copy(pTmp);

    pTmp = ppvDataObj->GetClientUserName( NULL, &cbSize);
    if ( cbSize == 0 ) {
        pTmp = "";
    }
    strClientUserName.Copy(pTmp);

    pTmp = ppvDataObj->GetServerAddress( NULL, &cbSize);
    if ( cbSize == 0 ) {
        pTmp = "";
    }
    strServerIpAddress.Copy(pTmp);

    pTmp = ppvDataObj->GetOperation( NULL, &cbSize);
    if ( cbSize == 0 ) {
        pTmp = "";
    }
    strOperation.Copy(pTmp);

    pTmp = ppvDataObj->GetTarget( NULL, &cbSize);
    if ( cbSize == 0 ) {
        pTmp = "";
    }
    strTarget.Copy(pTmp);

    pTmp = ppvDataObj->GetParameters( NULL, &cbSize);
    if ( cbSize == 0 ) {
        pTmp = "";
    }
    strParameters.Copy(pTmp);

    LPCSTR     pszUserName  = strClientUserName.QueryStr();
    LPCSTR     pszOperation = strOperation.QueryStr();
    LPCSTR     pszTarget    = strTarget.QueryStr();
    LPCSTR     pszParameters= strParameters.QueryStr();
    LPCSTR     pszServerAddr= strServerIpAddress.QueryStr();
    
    SDWORD     cbParameters;
    SDWORD     cbTarget;
    
    cbParameters = (SDWORD)strlen( pszParameters ? pszParameters : "" ) + 1;
    cbTarget     = (SDWORD)strlen( pszTarget ? pszTarget : "" ) + 1;

    //
    //  Format the Date and Time for logging.
    //

    GetLocalTime( & stNow);

    if ( IsEmptyStr(pszUserName)) { pszUserName = QueryDefaultUserName();}
    if ( IsEmptyStr(pszOperation))  { pszOperation = PSZ_UNKNOWN_FIELD_A; }
    if ( IsEmptyStr(pszParameters)) { pszParameters= PSZ_UNKNOWN_FIELD_A; }
    if ( IsEmptyStr(pszTarget))     { pszTarget    = PSZ_UNKNOWN_FIELD_A; }
    if ( IsEmptyStr(pszServerAddr)) { pszServerAddr= PSZ_UNKNOWN_FIELD_A; }

    Lock();

    //
    // Reopen if necessary.
    //

    if (!(
            m_poc != NULL && m_poc->IsValid() &&
            m_poStmt != NULL && m_poStmt->IsValid() &&
            m_ppParams != NULL 
       ))
    {
        
        TerminateLog();
        
        m_TickResumeOpen =  GetTickCount( ) + TICK_MINUTE;

        m_poc = new ODBC_CONNECTION();

        if ( m_poc == NULL )
        {
            dwError = ERROR_NOT_ENOUGH_MEMORY;
        } 
        else
        {
            //
            // Try to open a new connection but don't log the failure in the eventlog
            //
                
            if ( !m_poc->Open( m_rgchDataSource, m_rgchUserName, m_rgchPassword, FALSE) ||
                 !PrepareStatement() ||
                 !PrepareParameters() )
            {
                dwError = GetLastError();

                if ( ERROR_SUCCESS == dwError)
                {
                    //
                    // Last Error wasn't set correctly
                    //

                    dwError = ERROR_GEN_FAILURE;
                }
            }
        }
        
        if ( ERROR_SUCCESS != dwError )
        {
            Unlock();
            return dwError;
        }
    }

    DBG_ASSERT(m_poc != NULL && m_poc->IsValid());
    DBG_ASSERT(m_poStmt != NULL && m_poStmt->IsValid());
    DBG_ASSERT(m_ppParams != NULL );

    //
    //  Truncate the operation, parameters and target fields
    //


    if ( strOperation.QueryCCH() >= (DWORD)m_ppParams[ iSERVICE_OPERATION]->QueryMaxCbValue() )
    {
        strOperation.SetLen( (DWORD)m_ppParams[ iSERVICE_OPERATION]->QueryMaxCbValue() - 1 );
    }

    if ( cbTarget > m_ppParams[ iSERVICE_TARGET]->QueryMaxCbValue() )
    {
        strTarget.SetLen((DWORD)m_ppParams[ iSERVICE_TARGET]->QueryMaxCbValue()-1);
    }
    
    if ( cbParameters > m_ppParams[ iSERVICE_PARAMS]->QueryMaxCbValue() )
    {
        strParameters.SetLen((DWORD)m_ppParams[ iSERVICE_PARAMS]->QueryMaxCbValue()-1);
    }

    //
    // Copy data values into parameter markers.
    // NYI: LARGE_INTEGERS are ignored. Only lowBytes used!
    //

    fReturn =
      (
        m_ppParams[ iCLIENT_HOST]->
          CopyValue( strClientHostName.QueryStr()) &&
        m_ppParams[ iUSER_NAME]->CopyValue( pszUserName) &&
        m_ppParams[ iREQUEST_TIME]->CopyValue( &stNow) &&
        m_ppParams[ iSERVER_IPADDR]->CopyValue( pszServerAddr) &&
        m_ppParams[ iPROCESSING_TIME]->
          CopyValue( dwTimeForProcessing) &&
        m_ppParams[ iBYTES_RECVD]->
          CopyValue( dwBytesRecvd) &&
        m_ppParams[ iBYTES_SENT]->
          CopyValue( dwBytesSent) &&
        m_ppParams[ iSERVICE_STATUS]->
          CopyValue( dwProtocolStatus) &&
        m_ppParams[ iWIN32_STATUS]->CopyValue( dwWin32Status) &&
        m_ppParams[ iSERVICE_OPERATION]->CopyValue( pszOperation)  &&
        m_ppParams[ iSERVICE_TARGET]->CopyValue( pszTarget)     &&
        m_ppParams[ iSERVICE_PARAMS]->CopyValue( pszParameters)
       );

    //
    // Execute insertion if parameters got copied properly.
    //

    if (fReturn)
    {
        fReturn = m_poStmt->ExecuteStatement(); 
    }

    Unlock();

    if ( !fReturn )
    {

        //
        // Execution of SQL statement failed.
        // Pass the error as genuine failure, indicating ODBC failed
        // Obtain and store the error string in the proper return field
        //

        TerminateLog();
        
        dwError = ERROR_GEN_FAILURE;

        if ( true == m_fEnableEventLog )
        {
            //
            // We have not written an event log before. Indicate error
            //

            if ( g_eventLog != NULL ) 
            {
                const CHAR*    tmpString[1];

                tmpString[0] = m_rgchDataSource;
                
                g_eventLog->LogEvent(
                     LOG_EVENT_ODBC_LOGGING_ERROR,
                     1,
                     tmpString,
                     GetLastError()
                     );
            }

            Lock();
            
            m_fEnableEventLog = false;
            m_TickResumeOpen  = GetTickCount() + TICK_MINUTE;

            Unlock();
        }
    }
    else
    {
        //
        // Success. Re-enable event logging
        //

        if (false == m_fEnableEventLog) 
        {

            if ( g_eventLog != NULL )
            {
                const CHAR*    tmpString[1];

                tmpString[0] = m_rgchDataSource;
                
                g_eventLog->LogEvent(
                    LOG_EVENT_ODBC_LOGGING_RESUMED,
                    1,
                    tmpString
                    );
            }
            
            m_fEnableEventLog = true;
        }        
    }

    return(dwError);
}

STDMETHODIMP
CODBCLOG::TerminateLog()
{
    DWORD dwError = NO_ERROR;

    Lock();
    if (m_poStmt != NULL )
    {
        delete m_poStmt;
        m_poStmt = NULL;
    }

    if (m_poc!= NULL)
    {
        if (!m_poc->Close())
        {
            dwError = GetLastError();
        }

        delete m_poc;
        m_poc=NULL;
    }

    if (m_ppParams!=NULL)
    {
        DWORD i;

        for (i=0;i<m_cOdbcParams;i++)
        {
            if (m_ppParams[i]!=NULL)
            {
                delete m_ppParams[i];
                m_ppParams[i]=NULL;
            }
        }

        delete []m_ppParams;
        m_ppParams = NULL;
        m_cOdbcParams=0;
    }

    Unlock();

    return(dwError);
}

STDMETHODIMP
CODBCLOG::SetConfig(
                        DWORD,
                        BYTE *)
{
    return(0L);
}

STDMETHODIMP
CODBCLOG::GetConfig(
                        DWORD,
                        BYTE * log)
{
    PINETLOG_CONFIGURATIONA pLogConfig = (PINETLOG_CONFIGURATIONA)log;
    pLogConfig->inetLogType = INET_LOG_TO_SQL;
    strcpy( pLogConfig->u.logSql.rgchDataSource, m_rgchDataSource);
    strcpy( pLogConfig->u.logSql.rgchTableName, m_rgchTableName);
    strcpy( pLogConfig->u.logSql.rgchUserName, m_rgchUserName);
    strcpy( pLogConfig->u.logSql.rgchPassword, m_rgchPassword);
    return(0L);
}

DWORD
CODBCLOG::GetRegParameters(
                    LPCSTR pszRegKey,
                    LPVOID pvIMDCOM )
{
    DWORD err = NO_ERROR;

    MB      mb( (IMDCOM*) pvIMDCOM );
    DWORD   cb;

    if ( !mb.Open("") )
    {
        err = GetLastError();
        goto Exit;
    }

    cb = sizeof(m_rgchDataSource);
    if ( !mb.GetString( pszRegKey, MD_LOGSQL_DATA_SOURCES, IIS_MD_UT_SERVER, m_rgchDataSource, &cb ) )
    {
        strcpy(m_rgchDataSource,DEFAULT_LOG_SQL_DATASOURCE);
    }

    cb = sizeof(m_rgchTableName);
    if ( !mb.GetString( pszRegKey, MD_LOGSQL_TABLE_NAME, IIS_MD_UT_SERVER, m_rgchTableName, &cb ) )
    {
        strcpy(m_rgchTableName,DEFAULT_LOG_SQL_TABLE);
    }

    cb = sizeof(m_rgchUserName);
    if ( !mb.GetString( pszRegKey, MD_LOGSQL_USER_NAME, IIS_MD_UT_SERVER, m_rgchUserName, &cb ) )
    {
        strcpy(m_rgchUserName,DEFAULT_LOG_SQL_USER_NAME);
    }

    cb = sizeof(m_rgchPassword);
    if ( !mb.GetString( pszRegKey, MD_LOGSQL_PASSWORD, IIS_MD_UT_SERVER, m_rgchPassword, &cb, METADATA_INHERIT|METADATA_SECURE ) )
    {
        strcpy(m_rgchPassword,DEFAULT_LOG_SQL_PASSWORD);
    }

 Exit:
    return err;
}

inline
VOID
WCopyToA(
    const WCHAR * wszSrc,
    CHAR        * szDest
    )
{
    while( *wszSrc )
    {
        *szDest++ = (CHAR) *wszSrc++;
    }

    *szDest = '\0';
}

inline
VOID
ACopyToW(
    const CHAR * szSrc,
    WCHAR      * wszDest
    )
{
    while( *szSrc )
    {
        *wszDest++ = (WCHAR) *szSrc++;
    }

    *wszDest = L'\0';
}

DWORD
CODBCLOG::GetRegParametersFromPublicInterface(LPCSTR pszRegKey,
                                              LPVOID pMetabase)
{
    //
    // What I really want is the version of MB in iisutil.dll.  But, since I
    // cannot link to that and iisrtl.dll, I will just work with the
    // IMSAdminBase object directly
    //
    IMSAdminBase *pAdminBase = (IMSAdminBase *)pMetabase;
    METADATA_HANDLE hMBPath = NULL;
    DWORD cbRequired;
    METADATA_RECORD mdr;
    WCHAR pwszBuffer[MAX_PATH];
    WCHAR pwszRegKey[MAX_PATH];
    HRESULT hr;

    ACopyToW(pszRegKey, pwszRegKey);

    // MB::MB
    pAdminBase->AddRef();
    // MB::Open
    hr = pAdminBase->OpenKey(METADATA_MASTER_ROOT_HANDLE,
                             L"",
                             METADATA_PERMISSION_READ,
                             MB_TIMEOUT,
                             &hMBPath);
    if (FAILED(hr))
    {
        goto Exit;
    }

    // MB::GetString
    mdr.dwMDIdentifier = MD_LOGSQL_DATA_SOURCES;
    mdr.dwMDAttributes = METADATA_INHERIT;
    mdr.dwMDUserType   = IIS_MD_UT_SERVER;
    mdr.dwMDDataType   = STRING_METADATA;
    mdr.dwMDDataLen    = sizeof pwszBuffer;
    mdr.pbMDData       = (BYTE *)pwszBuffer;

    hr = pAdminBase->GetData(hMBPath, pwszRegKey, &mdr, &cbRequired);
    if (FAILED(hr) ||
        wcslen(pwszBuffer) >= sizeof m_rgchDataSource)
    {
        strcpy(m_rgchDataSource, DEFAULT_LOG_SQL_DATASOURCE);
    }
    else
    {
        WCopyToA(pwszBuffer, m_rgchDataSource);
    }

    // MB::GetString
    mdr.dwMDIdentifier = MD_LOGSQL_TABLE_NAME;
    mdr.dwMDAttributes = METADATA_INHERIT;
    mdr.dwMDUserType   = IIS_MD_UT_SERVER;
    mdr.dwMDDataType   = STRING_METADATA;
    mdr.dwMDDataLen    = sizeof pwszBuffer;
    mdr.pbMDData       = (BYTE *)pwszBuffer;

    hr = pAdminBase->GetData(hMBPath, pwszRegKey, &mdr, &cbRequired);
    if (FAILED(hr) ||
        wcslen(pwszBuffer) >= sizeof m_rgchTableName)
    {
        strcpy(m_rgchTableName, DEFAULT_LOG_SQL_TABLE);
    }
    else
    {
        WCopyToA(pwszBuffer, m_rgchTableName);
    }

    // MB::GetString
    mdr.dwMDIdentifier = MD_LOGSQL_USER_NAME;
    mdr.dwMDAttributes = METADATA_INHERIT;
    mdr.dwMDUserType   = IIS_MD_UT_SERVER;
    mdr.dwMDDataType   = STRING_METADATA;
    mdr.dwMDDataLen    = sizeof pwszBuffer;
    mdr.pbMDData       = (BYTE *)pwszBuffer;

    hr = pAdminBase->GetData(hMBPath, pwszRegKey, &mdr, &cbRequired);
    if (FAILED(hr) ||
        wcslen(pwszBuffer) >= sizeof m_rgchUserName)
    {
        strcpy(m_rgchUserName, DEFAULT_LOG_SQL_USER_NAME);
    }
    else
    {
        WCopyToA(pwszBuffer, m_rgchUserName);
    }

    // MB::GetString
    mdr.dwMDIdentifier = MD_LOGSQL_PASSWORD;
    mdr.dwMDAttributes = METADATA_INHERIT|METADATA_SECURE;
    mdr.dwMDUserType   = IIS_MD_UT_SERVER;
    mdr.dwMDDataType   = STRING_METADATA;
    mdr.dwMDDataLen    = sizeof pwszBuffer;
    mdr.pbMDData       = (BYTE *)pwszBuffer;

    hr = pAdminBase->GetData(hMBPath, pwszRegKey, &mdr, &cbRequired);
    if (FAILED(hr) ||
        wcslen(pwszBuffer) >= sizeof m_rgchPassword)
    {
        strcpy(m_rgchPassword, DEFAULT_LOG_SQL_PASSWORD);
    }
    else
    {
        WCopyToA(pwszBuffer, m_rgchPassword);
    }

    hr = S_OK;

 Exit:
    // MB::Close
    if (hMBPath)
    {
        pAdminBase->CloseKey(hMBPath);
        hMBPath = NULL;
    }
    // MB::~MB
    pAdminBase->Release();

    if (FAILED(hr))
    {
        return HRESULTTOWIN32(hr);
    }

    return NO_ERROR;
}

STDMETHODIMP
CODBCLOG::QueryExtraLoggingFields(
                    PDWORD  pcbSize,
                    TCHAR *pszFieldsList
                    )
/*++

Routine Description:
    get configuration information

Arguments:
    cbSize - size of the data structure
    log - log configuration data structure

Return Value:

--*/
{
    *pcbSize = 0;
    *pszFieldsList = '\0';
    return(0L);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\log\plugin\odbcconn.cxx ===
/*++

   Copyright    (c)    1997    Microsoft Corporation

   Module  Name :

       odbcconn.cxx

   Abstract:

       This module defines member functions for ODBC_CONNECTION object.

   Author:

       Murali R. Krishnan    ( MuraliK )     16-Feb-1995

   Functions Exported:

       ODBC_PARAMETER::CopyValue( IN LPCWSTR pwszValue);
       ODBC_PARAMETER::Bind( IN HSTMT hstmt);

       ODBC_STATEMENT::~ODBC_STATEMENT()
       ODBC_STATEMENT::PrepareStatement( IN LPCSTR  pszStatement)
       ODBC_STATEMENT::PrepareStatement( IN LPCWSTR pwszStatement)
       ODBC_STATEMENT::BindParameter( IN PODBC_PARAMETER pOdbcParam)
       ODBC_STATEMENT::ExecuteStatement( VOID)
       ODBC_STATEMENT::ExecDirect( IN LPCSTR pwszSqlCommand,  IN DWORD cch)
       ODBC_STATEMENT::ExecDirect( IN LPCWSTR pwszSqlCommand, IN DWORD cch)
       ODBC_STATEMENT::QueryColNames( OUT STR * *  apstrCols,
                                      OUT DWORD *  cCols,
                                      IN  DWORD    cchMaxFieldSize = 0 );
       ODBC_STATEMENT::QueryValuesAsStr( OUT STR * * apstrValues,
                                         OUT BOOL *  pfLast );


       ODBC_CONNECTION::~ODBC_CONNECTION();
       ODBC_CONNECTION::Open();
       ODBC_CONNECTION::Close();
       ODBC_CONNECTION::GetLastErrorCode();
       ODBC_CONNECTION::AllocStatement();


   Revision History:

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

# include "precomp.hxx"
# include "odbcconn.hxx"

LPSTR
ConvertUnicodeToAnsi(
    IN LPCWSTR  lpszUnicode
    );

//
//  Constants for display widths
//

#define MAX_NUM_PRECISION 15

//
//  Constant for all non string and non binary data.  40 is chosen to account
//  for things such as Oracle's numeric types, which can have up to 38 digits
//  of precision
//

#define MAX_NONCHAR_DATA_LEN        40

//
//  If no default maximum field size is specified, then use this value
//  as the maximum
//

#define DEFAULT_MAX_FIELD_SIZE      8192



/************************************************************
 *  Local Functions
 ************************************************************/

#if DBG
static inline VOID
CheckAndPrintErrorMessage( IN ODBC_CONNECTION * poc,
                           IN RETCODE rc)
{
    if ( !ODBC_CONNECTION::Success( rc))  {

        STR str;
        poc->GetLastErrorText( &str, NULL, rc );

        DBGPRINTF( ( DBG_CONTEXT,
                    "ODBC Error Code( %d). Text: %s\n",
                    rc,
                    str.QueryStr() ));
    }

    return;

} // CheckAndPrintErrorMessage()
# else
static VOID
CheckAndPrintErrorMessage( IN ODBC_CONNECTION *,
                           IN RETCODE)
{}
# endif // DBG



# if DBG
static inline VOID
CheckAndPrintErrorMessage( IN ODBC_STATEMENT * pos,
                           IN RETCODE rc)
{

    if ( !ODBC_CONNECTION::Success( rc))  {

        STR str;
        pos->GetLastErrorText( &str );

        DBGPRINTF( ( DBG_CONTEXT,
                    "ODBC Error Code( %d). Text: %s\n",
                    rc,
                    str.QueryStr() ));
    }

    return;

} // CheckAndPrintErrorMessage()
# else
static VOID
CheckAndPrintErrorMessage( IN ODBC_STATEMENT *,
                           IN RETCODE)
{}
# endif // DBG



/************************************************************
 *    Member Functions of ODBC_PARAMETER
 ************************************************************/


BOOL
ODBC_PARAMETER::CopyValue( IN LPCWSTR  pwszValue)
/*++
  Description:
    This function copies the given Unicode string as the value into
      current parameter marker to be used for future insertion.

  Arguments:
    pwszValue   pointer to null-terminated string containing Unicode value to
                    be copied into the parameter marker.

  Returns:
    TRUE on success and FALSE if there is any error.

  Note:
    Since ODBC does not support Unicode directly right now, we convert
      string value to be ANSI before copying the value over.
--*/
{
    BOOL fReturn = FALSE;

    CHAR * pszValue = ConvertUnicodeToAnsi( pwszValue );

    //
    // If successful then Copy ASCII value to buffer in the parameter block.
    //

    if ( pszValue != NULL) {

        fReturn = this->CopyValue( pszValue);

        LocalFree( pszValue);
    }

    return ( fReturn);
} // ODBC_PARAMETER::CopyValue()



BOOL
ODBC_PARAMETER::CopyValue( IN LPSYSTEMTIME lpst)
/*++
  Description:
    This function copies the given system time into the ODBC timestamp
     structure for the current parameter marker to be used for
     future insertion.

  Arguments:
   lpSystemTime   pointer to System Time structure containing current time.

  Returns:
    TRUE on success and FALSE if there is any error.

--*/
{
    TIMESTAMP_STRUCT * ptsOdbc;

    DBG_ASSERT( lpst != NULL);
    DBG_ASSERT( m_CType == SQL_C_TIMESTAMP);
    DBG_ASSERT( m_SqlType == SQL_TIMESTAMP);
    DBG_ASSERT( m_cbValueMax >= sizeof(TIMESTAMP_STRUCT));

    ptsOdbc = (TIMESTAMP_STRUCT * ) m_pValue;

    DBG_ASSERT( m_pValue != NULL);

    //
    // Copy the individual fields over properly
    // The types used in ODBC/Win32 are different
    //  So do a type specific copy of the values.
    //

    ptsOdbc->year   = (SWORD ) lpst->wYear;
    ptsOdbc->month  = (UWORD ) lpst->wMonth;
    ptsOdbc->day    = (UWORD ) lpst->wDay;
    ptsOdbc->hour   = (UWORD ) lpst->wHour;
    ptsOdbc->minute = (UWORD ) lpst->wMinute;
    ptsOdbc->second = (UWORD ) lpst->wSecond;
    ptsOdbc->fraction = (UDWORD ) lpst->wMilliseconds;

    return ( TRUE);
} // ODBC_PARAMETER::CopyValue()





RETCODE
ODBC_PARAMETER::Bind( IN HSTMT hStmt)
/*++
  Description:

    This functions binds the data about the parameter marker 'this'
     ( this object) represents to the statement provided.

  Arguments:
    hStmt        HANDLE for the statement to which this parameter
                  is to be bound.

  Returns:
    RETCODE value returned by SQLBindParamater().
--*/
{
    RETCODE  rc;
    DBG_ASSERT( hStmt != SQL_NULL_HSTMT);

    rc = SQLBindParameter( hStmt,              // statement
                           QueryParamNumber(),
                           QueryParamType(),
                           QueryCType(),
                           QuerySqlType(),
                           QueryPrecision(),
                           QueryScale(),
                           QueryValue(),
                           QueryMaxCbValue(),
                           &(QueryCbValueRef())
                           );

    return ( rc);
} // ODBC_STATEMENT::BindParameter()





# if DBG

VOID
ODBC_PARAMETER::Print( VOID) const
{
    DBGPRINTF( ( DBG_CONTEXT,
                "Printing ODBC_PARAMETER ( %08x).\n"
                " Num=%u; Type=%d; CType=%d; SqlType=%d; Prec=%u; Scale=%d;"
                " CbMax=%d; Cb=%d.\n",
                this,
                QueryParamNumber(),
                QueryParamType(),
                QueryCType(),
                QuerySqlType(),
                QueryPrecision(),
                QueryScale(),
                QueryMaxCbValue(),
                QueryCbValue()));

    switch ( QuerySqlType()) {

      case SQL_INTEGER:
        {
            DWORD  dwValue = *(DWORD *) QueryValue();
            DBGPRINTF( ( DBG_CONTEXT, " Integer Value = %u\n", dwValue));
            break;
        }

      case SQL_CHAR:
        {
            LPCSTR pszValue = (LPCSTR ) QueryValue();
            DBGPRINTF( ( DBG_CONTEXT, " String Value( %08x) = %s\n",
                         pszValue, pszValue));
            break;
        }

      default:
        {
            DBGPRINTF( ( DBG_CONTEXT, " Type=%d. Unknown value at %08x\n",
                        QuerySqlType(), QueryValue()));
            break;
        }

    } // switch

    return;
} // ODBC_PARAMETER::Print()


# endif // DBG



/************************************************************
 * ODBC_STATEMENT  member functions
 ************************************************************/


ODBC_STATEMENT::~ODBC_STATEMENT( VOID)
{
    //
    // Free the statement handle
    //
    if ( m_hStmt != SQL_NULL_HSTMT) {

        m_rc = SQLFreeStmt( m_hStmt, SQL_DROP);
        m_hStmt = SQL_NULL_HSTMT;

        // Ignore the error code here.
        DBG_ASSERT( ODBC_CONNECTION::Success( m_rc));

        IF_DEBUG( API_ENTRY) {

            DBGPRINTF( ( DBG_CONTEXT,
                        "SqlFreeStmt() return code %d.\n",
                        m_rc));

            CheckAndPrintErrorMessage( this, m_rc);
        }
    }

    FreeColumnMemory();

} // ODBC_STATEMENT::~ODBC_STATEMENT()





BOOL
ODBC_STATEMENT::ExecDirect(
    IN LPCSTR pszSqlCommand,
    IN DWORD cchSqlCommand)
{
    BOOL fReturn;

    IF_DEBUG( API_ENTRY) {
        DBGPRINTF( ( DBG_CONTEXT,
                    " Executing the SQL command (%d bytes) %s.\n",
                    cchSqlCommand * sizeof( CHAR),
                    pszSqlCommand));
    }

    //
    //  SQLExecDirect only likes Unsigned chars !
    //
    m_rc = SQLExecDirect( m_hStmt, (UCHAR FAR *) pszSqlCommand, cchSqlCommand);
    fReturn = ODBC_CONNECTION::Success( m_rc);

    IF_DEBUG( API_ENTRY) {

        DBGPRINTF( ( DBG_CONTEXT,
                    " SQLExecDirect() returns code %d\n",
                    m_rc));
        CheckAndPrintErrorMessage( this, m_rc);
    }

    return ( fReturn);
} // ODBC_STATEMENT::ExecDirect()


#if 0
BOOL
ODBC_STATEMENT::ExecDirect(
    IN LPCWSTR pszSqlCommand,
    IN DWORD cchSqlCommand)
{
    BOOL fReturn = FALSE;
    char * pszCommand;

    if ( ( pszCommand = ConvertUnicodeToAnsi( pszSqlCommand ))
        != NULL ) {

        fReturn = ExecDirect( pszCommand, strlen( pszCommand));

        LocalFree( pszCommand);
    }

    return ( fReturn);
} // ODBC_STATEMENT::ExecDirect()

#endif




BOOL
ODBC_STATEMENT::PrepareStatement(IN LPCSTR    pszStatement)
/*++

  This function prepares the SQL statement for future execution.

  Arguments:
     pszStatement    pointer to null terminated string containing the
                        statement.

  Returns:
     TRUE on success and FALSE if there is any failure.
--*/
{
    DBG_ASSERT( QueryErrorCode() == SQL_SUCCESS && pszStatement != NULL);

    m_rc = SQLPrepare( m_hStmt, (UCHAR FAR *) pszStatement, SQL_NTS);

    IF_DEBUG( API_ENTRY) {

        DBGPRINTF( ( DBG_CONTEXT,
                    " SQLPrepare( %s) returns ErrorCode = %d.\n",
                     pszStatement, m_rc));

        CheckAndPrintErrorMessage( this, m_rc);
    }

    return ( m_fPreparedStmt = ODBC_CONNECTION::Success( m_rc));
} // ODBC_STATEMENT::PrepareStatment()


#if 0

BOOL
ODBC_STATEMENT::PrepareStatement( IN LPCWSTR   pwszCommand)
/*++
  This function prepares an ODBC statement for execution.
  Since ODBC does not support UNICODE, we convert the statement into ANSI
   before calling the APIs.

  Arguments:
     pwszCommand      pointer to null-terminated string containing the
                       statement to be prepared.

  Returns:
     TRUE on success and FALSE if there is any failure.
--*/
{
    BOOL fReturn = FALSE;
    CHAR * pszCommand = NULL;

    DBG_ASSERT( pwszCommand != NULL);

    pszCommand = ConvertUnicodeToAnsi( pwszCommand );

    if ( pszCommand != NULL) {

        fReturn = PrepareStatement( pszCommand);

        LocalFree( pszCommand);

    } // pszCommand != NULL

    return ( fReturn);
} // ODBC_STATEMENT::PrepareStatement()
#endif




BOOL
ODBC_STATEMENT::BindParameter( IN PODBC_PARAMETER pOdbcParameter)
{

    DBG_ASSERT( ODBC_CONNECTION::Success( m_rc) && pOdbcParameter != NULL);

    m_rc = pOdbcParameter->Bind( m_hStmt);

    IF_DEBUG( API_ENTRY) {

        CheckAndPrintErrorMessage( this, m_rc);
    }

    return ( ODBC_CONNECTION::Success( m_rc));
} // ODBC_STATEMENT::BindParameter()





BOOL
ODBC_STATEMENT::ExecuteStatement( VOID)
/*++

  This function executes a prepared ODBC statement. At the end of execution,
   the transaction is also committed to ensure that the record is automatically
   written to the database.

  Arguments:
    None

  Returns:
    TRUE on success and FALSE if there is any failure.

--*/
{
    DBG_ASSERT( m_fPreparedStmt != FALSE);

    if ( !ODBC_CONNECTION::Success( QueryErrorCode()) ) {

        DBGPRINTF(( DBG_CONTEXT,
                    "!!WARNING!! - Attempting to use Invalid ODBC Connection!\n" ));
    }

    m_rc = SQLExecute( m_hStmt);

    IF_DEBUG( API_ENTRY) {

        CheckAndPrintErrorMessage( this, m_rc);
    }

    return ( ODBC_CONNECTION::Success( m_rc));
} // ODBC_STATEMENT::ExecuteStatement()

BOOL
ODBC_STATEMENT::QueryRowCount(
    OUT SQLLEN *pcRows
    )
/*++

  Calls SQLRowCount on the current result set.

  NOTE: Not all database implementations support this!!

  Arguments:

    pcRows - Receives count of rows

  Returns:
    TRUE on success and FALSE if there are any failures.

  Note:

--*/
{
    m_rc = SQLRowCount( m_hStmt,
                        pcRows );

    return ( ODBC_CONNECTION::Success( m_rc));
}


BOOL
ODBC_STATEMENT::QueryColNames(
    STR * *  pastrCols,
    DWORD  * cCols,
    DWORD    cchMaxFieldSize,
    BOOL *   pfHaveResultSet
    )
/*++

  This method returns the list of column names from the result table

  Arguments:

    pastrCols - Receives an array of STRs containing the column names
    cCols - Count of columns returned (zero for no result set)
    cchMaxFieldSize - Maximum buffer size to allocate for any data fields,
        zero means use the default value.
    pfHaveResultSet - Set to TRUE if the current query was a SELECT and thus has
        rows that can be enumerated

  Returns:
    TRUE on success and FALSE if there are any failures.

  Note:

--*/
{
    SWORD   nresultcols;
    SWORD   i;
    CHAR    achColName[64];
    SWORD   cchColName;
    SWORD   ColType;
    SQLULEN cchColLength;
    SWORD   scale;
    SWORD   nullable;

    *pastrCols       = NULL;
    *cCols           = 0;
    *pfHaveResultSet = TRUE;

    //
    //  Return the old binding info if we already have it
    //

    if ( m_astrColNames )
    {
        *pastrCols = m_astrColNames;
        *cCols = m_cCols;

        return TRUE;
    }

    //
    //  Provide a default maximum field size if none was specified
    //

    if ( !cchMaxFieldSize )
        cchMaxFieldSize = DEFAULT_MAX_FIELD_SIZE;

    //
    //  See what kind of statement it was.  If there are no result
    //  columns, the statement is not a SELECT statement.
    //

    m_rc = SQLNumResultCols( m_hStmt,
                             &nresultcols);

    if ( !ODBC_CONNECTION::Success( m_rc ))
        return FALSE;

    if ( nresultcols > 0 )
    {
        //
        //  Allocate an array of strings for the column names and the column
        //  values
        //

        m_cCols = nresultcols;
        *cCols  = m_cCols;

        m_astrColNames = new STR[m_cCols];
        m_astrValues   = new STR[m_cCols];
        m_acbValue     = new SQLLEN[m_cCols];

        if (m_astrColNames == NULL ||
            m_astrValues == NULL ||
            m_acbValue == NULL)
        {
            return FALSE;
        }

        //
        //  Otherwise, get the column names of the result set and use the
        //  display_size() function to compute the length needed by each data
        //  type.  Next, bind the columns and specify all data will be
        //  converted to char.
        //

        for (i = 0; i < m_cCols; i++)
        {
            m_rc = SQLDescribeCol( m_hStmt,
                                   i + 1,
                                   (UCHAR *) achColName,
                                   (SWORD)sizeof(achColName),
                                   &cchColName,
                                   &ColType,
                                   &cchColLength,
                                   &scale,
                                   &nullable);

            if ( !ODBC_CONNECTION::Success( m_rc ))
                return FALSE;

            //
            //  Select the buffer size for the retrieved data for this column
            //

            cchColLength = ODBC_CONNECTION::DisplaySize( ColType,
                                        min( cchColLength, cchMaxFieldSize) );

            //
            //  Copy the column name and set the column data size
            //

            if ( !m_astrColNames[i].Copy( achColName ) ||
                 !m_astrValues[i].Resize( (DWORD)cchColLength + 1 ))
            {
                return FALSE;
            }

            m_rc = SQLBindCol( m_hStmt,
                               i + 1,
                               SQL_C_CHAR,
                               m_astrValues[i].QueryPtr(),
                               cchColLength,
                               &m_acbValue[i] );

            if ( !ODBC_CONNECTION::Success( m_rc ))
                return FALSE;
        }

        *pastrCols = m_astrColNames;
        *cCols     = m_cCols;
    }
    else
    {
        *pfHaveResultSet = FALSE;
    }

    return TRUE;
}


BOOL
ODBC_STATEMENT::QueryValuesAsStr(
    STR * * pastrValues,
    BOOL *  pfLast
    )
/*++

  This method gets the data at the current position.

  Arguments:

    pastrValues - Receives a pointer to an array of strings that contains
        the alphanumeric representation of that field

    pfLast - Set to TRUE if there are no more values to retrieve

  Returns:

    TRUE on success and FALSE if there are any failures.

  Note:

--*/
{
    *pastrValues = NULL;

    //
    //  Build the bindings if we haven't already
    //

    if ( !m_astrColNames )
    {
        STR * astrCols;
        DWORD cCols;
        BOOL  fHaveResultSet;

        if ( !QueryColNames( &astrCols,
                             &cCols,
                             0,
                             &fHaveResultSet ))
        {
            return FALSE;
        }
    }

    //
    //  If there are columns to enumerate, get them now
    //

    if ( m_astrColNames )
    {
        DWORD i;

        //
        //  Zero terminate the columns as some drivers don't write anything
        //  for NULL fields
        //

        for ( i = 0; i < m_cCols; i++ )
        {
            *((CHAR *) m_astrValues[i].QueryPtr()) = '\0';
        }

        //
        //  Fill in the binding values
        //

        m_rc = SQLFetch( m_hStmt );

        if ( m_rc == SQL_NO_DATA_FOUND )
        {
            *pfLast = TRUE;
        }
        else
        {
            if ( !ODBC_CONNECTION::Success( m_rc ))
                return FALSE;

            *pfLast = FALSE;
        }

        *pastrValues = m_astrValues;
    }
    else
    {
        *pfLast = TRUE;
    }

    return TRUE;
}

BOOL
ODBC_STATEMENT::MoreResults(
    BOOL * pfMoreResults
    )
/*++

    Determines if there are any more results sets to return to the user

    pfMoreResults - Set to TRUE if there are more results in the result set

--*/
{
    *pfMoreResults = TRUE;

    m_rc = SQLMoreResults( m_hStmt );

    if ( m_rc == SQL_NO_DATA_FOUND )
    {
        *pfMoreResults = FALSE;
        return TRUE;
    }

    if ( !ODBC_CONNECTION::Success( m_rc ))
        return FALSE;

    return TRUE;
}


VOID
ODBC_STATEMENT::FreeColumnMemory(
    VOID
    )
/*++
    This method frees memory allocated by the QueryColNames and
    QueryValuesAsStr methods.

--*/
{
    if ( m_astrColNames ) delete [] m_astrColNames;
    if ( m_astrValues )   delete [] m_astrValues;
    if ( m_acbValue )     delete [] m_acbValue;

    m_astrColNames = NULL;
    m_astrValues = NULL;
    m_acbValue = NULL;

}

# if DBG


VOID
ODBC_STATEMENT::Print( VOID) const
{
    DBGPRINTF( ( DBG_CONTEXT,
                " Printing ODBC_STATEMENT( %08x)."
                " HStmt = %08x. OdbcConn=%08x. RetCode = %d\n",
                m_hStmt, m_pOdbcConnection, m_rc));

} // ODBC_STATEMENT::Print()

# endif // DBG


/**************************************************
 *  Member Functions of class ODBC_CONNECTION
 **************************************************/


ODBC_CONNECTION::~ODBC_CONNECTION( VOID)
/*++
   This function closes the odbc connection ( if open) and cleans up.

--*/
{
    DBG_REQUIRE( Close());
    return;
} // ODBC_CONNECTION::~ODBC_CONNECTION()





BOOL
ODBC_CONNECTION::Open(
    IN LPCSTR   pszDataSource,
    IN LPCSTR   pszUserName,
    IN LPCSTR   pszPassword,
    IN BOOL     fLogFailureEvent)
/*++
  This function opens a new odbc connection to given data source
    using the user name and password supplied.

  Arguments:
    pszDataSource    pointer to null-terminated string containing ODBC
                         data source name
    pszUserName      pointer to null-terminated string containing UserName
    pszPassword      pointer to null-terminated string containing Password

  Returns:

    TRUE on success and FALSE if there is an error.
--*/
{
    BOOL fReturn = FALSE;

    DBG_ASSERT( pszDataSource != NULL &&
                pszUserName != NULL &&
                pszPassword != NULL);

    //
    //  Allocate an ODBC environment
    //

    m_rc = SQLAllocEnv( &m_henv);
    fReturn = Success( m_rc);

    IF_DEBUG( API_ENTRY) {

        DBGPRINTF( ( DBG_CONTEXT,
                    "SQLAllocEnv() returned ErrorCode %d. henv = %08x\n",
                    m_rc, m_henv));

        CheckAndPrintErrorMessage( this, m_rc);
    }

    if ( fReturn) {

        //
        // Establish memory for connection handle within the environment
        //

        m_rc = SQLAllocConnect( m_henv, &m_hdbc);
        fReturn = Success( m_rc);

        IF_DEBUG( API_ENTRY) {

            DBGPRINTF( ( DBG_CONTEXT,
                        "SQLAllocConnect() returns code %d. hdbc = %08x\n",
                        m_rc, m_hdbc));

            CheckAndPrintErrorMessage( this, m_rc);
        }
    }

    if ( fReturn) {

        //
        // Use Following call to just printout the dynamic values for ODBC
        //
        // AuxOdbcFunctions( m_henv, m_hdbc);

#if 0
        {
            STR str;
            STR strOut;
            SWORD swStrOut;

            if ( !str.Append( pszDataSource )   ||
                 !str.Append( ";UID=" )         ||
                 !str.Append( pszUserName )     ||
                 !str.Append( ";PWD=" )         ||
                 !str.Append( pszPassword )     ||
                 !str.Append( ";APP=Internet Services") ||
                 !strOut.Resize( 255 ))
            {
                return FALSE;
            }

            m_rc = pSQLDriverConnect( m_hdbc,
                                      NULL,
                                      (UCHAR *) str.QueryStr(),
                                      SQL_NTS,
                                      (UCHAR *) strOut.QueryStr(),
                                      strOut.QuerySize(),
                                      &swStrOut,
                                      SQL_DRIVER_NOPROMPT );
        }
#else
        {
            m_rc = SQLConnect( m_hdbc,
                              (UCHAR FAR *) pszDataSource, SQL_NTS,
                              (UCHAR FAR *) pszUserName,   SQL_NTS,
                              (UCHAR FAR *) pszPassword,   SQL_NTS);
        }
#endif

        fReturn = Success( m_rc);

        if ( !fReturn ) {

            //
            // Log it
            //

            if ( (g_eventLog != NULL ) && fLogFailureEvent)
            {

                STR     str;
                const CHAR*    tmpString[2];

                GetLastErrorText( &str, NULL, m_rc );

                tmpString[0] = pszDataSource;
                tmpString[1] = str.QueryStr();

                g_eventLog->LogEvent(
                        LOG_EVENT_ODBC_CONNECT_ERROR,
                        2,
                        tmpString,
                        m_rc);
            }
        }

        IF_DEBUG( API_ENTRY) {

            DBGPRINTF( ( DBG_CONTEXT,
                        "SQLConnect( %s, %s, %s) returns code %d.\n",
                        pszDataSource,
                        pszUserName,
                        pszPassword,
                        m_rc));

            CheckAndPrintErrorMessage( this, m_rc);
        }
    }

    m_fValid = fReturn;

    if ( !fReturn) {
        SetLastError( ERROR_GEN_FAILURE );
    }

    return ( fReturn);
} // ODBC_CONNECTION::Open()


#if 0


BOOL
ODBC_CONNECTION::Open(
    IN LPCWSTR  pwszDataSource,
    IN LPCWSTR  pwszUserName,
    IN LPCWSTR  pwszPassword)
/*++
  This function opens a new odbc connection to given data source
    using the user name and password supplied.

  Arguments:
    pwszDataSource    pointer to null-terminated string containing ODBC
                         data source name
    pwszUserName      pointer to null-terminated string containing UserName
    pwszPassword      pointer to null-terminated string containing Password

  Returns:
    TRUE on success and FALSE if there is an error.

  Note:
     Poor me.  ODBC Does not take UNICODE strings :(. 2/15/95
     So we will explicitly convert parameters to ANSI on stack.
--*/
{
    BOOL   fReturn;
    DWORD  dwError = NO_ERROR;
    CHAR * pszDataSource;
    CHAR * pszUserName;
    CHAR * pszPassword;

    //
    // Convert all parameters from UNICODE to ANSI
    //
    pszDataSource = ConvertUnicodeToAnsi( pwszDataSource );
    pszUserName   = ConvertUnicodeToAnsi( pwszUserName );
    pszPassword   = ConvertUnicodeToAnsi( pwszPassword );

    //
    // Make an ANSI open call.
    //
    fReturn = Open( pszDataSource, pszUserName, pszPassword);

    if ( !fReturn)  {

        dwError = GetLastError();
    }

    //
    //  Freeup the space allocated.
    //
    if ( pszDataSource != NULL) {

        LocalFree( pszDataSource);
        pszDataSource = NULL;
    }

    if ( pszUserName != NULL) {

        LocalFree( pszUserName);
        pszUserName = NULL;
    }

    if ( pszPassword != NULL) {

        //
        // Zero the password for security reasons.
        //
        SecureZeroMemory( pszPassword, 0, strlen( pszPassword));

        LocalFree( pszPassword);
        pszPassword = NULL;
    }

    if ( !fReturn) {

        SetLastError( dwError);
    }

    return ( fReturn);
} // ODBC_CONNECTION::Open()
#endif



BOOL
ODBC_CONNECTION::Close( VOID)
/*++
  This function closes the connection established with the ODBC
   and frees up and dynamic memory used.

  Returns:
    TRUE on success and FALSE if there are any failures.

  Note:
    Intermediate failures are ignored. Normally they should not occur.

--*/
{
    BOOL fReturn = TRUE;


    //
    // Disconnect and free the connection.
    //
    if ( m_hdbc != SQL_NULL_HDBC) {

        m_rc = SQLDisconnect( m_hdbc );

        //
        //  Disconnect is allowed to fail w/o being fatal so don't set
        //  fReturn
        //

        IF_DEBUG( API_ENTRY) {

            DBGPRINTF( ( DBG_CONTEXT,
                        "Warning: SQLDisconnect() returns code %d.\n",
                        m_rc));
            CheckAndPrintErrorMessage( this, m_rc);
        }

        m_rc = SQLFreeConnect( m_hdbc);

        m_hdbc = SQL_NULL_HDBC;
        fReturn = fReturn && Success( m_rc);

        IF_DEBUG( API_ENTRY) {

            DBGPRINTF( ( DBG_CONTEXT,
                        "SQLFreeConnect() returns code %d.\n",
                        m_rc));

            CheckAndPrintErrorMessage( this, m_rc);
        }
    }

    //
    //  Free the ODBC environment handle.
    //
    if ( m_henv != SQL_NULL_HENV) {

        m_rc = SQLFreeEnv( m_henv);
        m_henv = SQL_NULL_HENV;
        fReturn = fReturn && Success( m_rc);

        IF_DEBUG( API_ENTRY) {

            DBGPRINTF( ( DBG_CONTEXT,
                        "SQLFreeEnv() returns code %d.\n",
                        m_rc));

            CheckAndPrintErrorMessage( this, m_rc);
        }
    }

    return ( fReturn);
} // ODBC_CONNECTION::Close()





PODBC_STATEMENT
ODBC_CONNECTION::AllocStatement( VOID)
/*++
  Description:
    This function allocates a new ODBC statement object and also calls
     SQLAllocStatement to create the state required for establishing the
     statement in the ODBC Manager.

  Arguments:
    None

  Returns:
    TRUE on success and FALSE if there is any failure.
--*/
{
    PODBC_STATEMENT pOdbcStmt = NULL;
    HSTMT   hstmt = SQL_NULL_HSTMT;

    DBG_ASSERT( Success( m_rc));

    //
    // Allocate a statement handle and associate it with the connection.
    //
    m_rc = SQLAllocStmt( m_hdbc, &hstmt);

    IF_DEBUG( API_ENTRY) {

        DBGPRINTF( ( DBG_CONTEXT,
                    "SqlAllocStmt() returns code %d."
                    " New Hstmt is : %08x\n",
                    m_rc, hstmt));
        CheckAndPrintErrorMessage( this, m_rc);
    }

    if ( ODBC_CONNECTION::Success( m_rc)) {

        pOdbcStmt = new ODBC_STATEMENT( this, hstmt);
    }

    return ( pOdbcStmt);
} // ODBC_CONNECTION::AllocStatement()


BOOL
ODBC_CONNECTION::SetConnectOption(
    IN UWORD      Option,
    IN SQLULEN    Param
    )
/*++

  Sets various options on this connection

  Arguments:

    Option - Option to set
    Param - Option value (32 bit dword or pointer to null terminated string)

  Returns:
    TRUE on success and FALSE if there are any failures.  Failures are
    considered to be soft errors as the problem may be the driver doesn't
    support the option etc.

  Note:

--*/
{
    BOOL    fReturn = TRUE;
    RETCODE rc;

    if ( m_hdbc != SQL_NULL_HDBC)
    {
        rc = SQLSetConnectOption( m_hdbc, Option, Param );

        fReturn = Success( rc);

        IF_DEBUG( API_ENTRY) {

            DBGPRINTF( ( DBG_CONTEXT,
                        "SQLSetConnectOption( %d, %d ) returns code %d.\n",
                        Option,
                        Param,
                        rc));

            CheckAndPrintErrorMessage( this, rc);
        }
    }
    else
    {
        DBGPRINTF( ( DBG_CONTEXT,
                     "[SetConnectOption] Warning: Setting option on closed connection\n" ));
    }

    return fReturn;
}



BOOL
ODBC_CONNECTION::GetLastErrorText(
    OUT STR *    pstrError,
    IN  HSTMT    hstmt,
    IN  RETCODE  rc
    ) const
/*++

  This method returns the textual representation of the last ODBC or windows
  error that occurred.  Even though the ODBC methods return FALSE on failure,
  if it was an ODBC call that failed, then GetLastError won't return the
  needed error code.  Clients of this class should call this method to get
  a descriptive text string of the failure.

  Returns:

    TRUE on success and FALSE if there are any failures.

  Note:
    If this function returns FALSE, then a client should call GetLastError
    for the error code.

--*/
{
    BOOL fReturn = TRUE;

    if ( ODBC_CONNECTION::Success( rc)) {

        fReturn = pstrError->LoadString( GetLastError());

    } else {

        CHAR     rgchMsg[ SQL_MAX_MESSAGE_LENGTH + 10];
        CHAR     achState[30];
        CHAR     rgchFullMsg[ sizeof(rgchMsg) + sizeof(achState) + 60];
        SWORD    cbMsg;
        LONG     lError;

        //
        //  If we're formatting as HTML, we bullet list the items
        //

        if ( !pstrError->Copy( (CHAR *) NULL ) )
        {
            return FALSE;
        }

        //
        //  Loop to pick up all of the errors
        //

        do {
            cbMsg = SQL_MAX_MESSAGE_LENGTH;

            rc = SQLError( m_henv,
                           m_hdbc,
                           hstmt,
                           (UCHAR *) achState,
                           &lError,
                           (UCHAR *) rgchMsg,
                           cbMsg,
                           &cbMsg );

            if ( ODBC_CONNECTION::Success( rc)) {

                wsprintf( rgchFullMsg,
                             "[State=%s][Error=%d]%s\n",
                             achState, lError, rgchMsg);

                if ( !pstrError->Append( rgchFullMsg )) {

                    fReturn = FALSE;
                    break;
                }
            } else {

                //
                //  This is indicates there are no more error strings
                //  to pick up so we should get out
                //

                if ( rc == SQL_NO_DATA_FOUND ) {

                    //
                    //  Append the end of unorder list marker
                    //

                    rc = SQL_SUCCESS;
                    break;
                }
            }

        } while ( ODBC_CONNECTION::Success( rc) );

        if ( !ODBC_CONNECTION::Success( rc) )
        {
            DBGPRINTF( ( DBG_CONTEXT,
                        "[GetLastErrorText] SqlError() returned error %d.\n",
                        rc));

            SetLastError( ERROR_GEN_FAILURE );
            fReturn = FALSE;
        }
    }

    return ( fReturn);

} // ODBC_CONNECTION::GetLastErrorText()



BOOL
ODBC_CONNECTION::GetLastErrorTextAsHtml(
    OUT STR *    pstrError,
    IN  HSTMT    hstmt,
    IN  RETCODE  rc
    ) const
/*++

  This method returns the textual representation of the last ODBC or windows
  error that occurred.  Even though the ODBC methods return FALSE on failure,
  if it was an ODBC call that failed, then GetLastError won't return the
  needed error code.  Clients of this class should call this method to get
  a descriptive text string of the failure.

  Returns:

    TRUE on success and FALSE if there are any failures.

  Note:
    If this function returns FALSE, then a client should call GetLastError
    for the error code.

--*/
{
    BOOL fReturn = TRUE;

    if ( ODBC_CONNECTION::Success( rc)) {

        fReturn = pstrError->LoadString( GetLastError());

    } else {

        CHAR     rgchMsg[ SQL_MAX_MESSAGE_LENGTH + 10];
        CHAR     achState[30];
        CHAR     rgchFullMsg[ sizeof(rgchMsg) + sizeof(achState) + 60];
        SWORD    cbMsg;
        LONG     lError;

        //
        //  If we're formatting as HTML, we bullet list the items
        //

        if ( !pstrError->Copy( "<UL>" ))
        {
            return FALSE;
        }

        //
        //  Loop to pick up all of the errors
        //

        do {
            cbMsg = SQL_MAX_MESSAGE_LENGTH;

            rc = SQLError( m_henv,
                           m_hdbc,
                           hstmt,
                           (UCHAR *) achState,
                           &lError,
                           (UCHAR *) rgchMsg,
                           cbMsg,
                           &cbMsg );

            if ( ODBC_CONNECTION::Success( rc)) {

                wsprintf( rgchFullMsg,
                          "<LI>[State=%s][Error=%d]%s\n",
                          achState, lError, rgchMsg);

                if ( !pstrError->Append( rgchFullMsg )) {

                    fReturn = FALSE;
                    break;
                }
            } else {

                //
                //  This is indicates there are no more error strings
                //  to pick up so we should get out
                //

                if ( rc == SQL_NO_DATA_FOUND ) {

                    //
                    //  Append the end of unorder list marker
                    //

                    if ( !pstrError->Append( "</UL>" )) {
                        return FALSE;
                    }

                    rc = SQL_SUCCESS;
                    break;
                }
            }

        } while ( ODBC_CONNECTION::Success( rc) );

        if ( !ODBC_CONNECTION::Success( rc) )
        {
            DBGPRINTF( ( DBG_CONTEXT,
                        "[GetLastErrorText] SqlError() returned error %d.\n",
                        rc));

            SetLastError( ERROR_GEN_FAILURE );
            fReturn = FALSE;
        }
    }

    return ( fReturn);

} // ODBC_CONNECTION::GetLastErrorTextAsHtml()



BOOL
ODBC_CONNECTION::GetInfo(IN DWORD fInfoType,
                         IN PVOID rgbInfoValue,
                         IN DWORD cbInfoValueMax,
                         IN OUT DWORD * pcbInfoValue)
/*++
  This function obtains the value of the fInfoType for a specific
   ODBC Connection. It mimicks the SQLGetInfo() and uses it to obtain
   this value. On successful return the pointer rgbInfoValue contains
   the requested value and pcbInfoValue contains the size in bytes of
   data.

  Arguments:
    fInfoType - flag containing the Information Type (name) to be fetched.
    rgbInfoValue - pointer to buffer which will contain the return data.
    cbInfoValue  - size of rgbInfoValue in bytes.
    pcbInfoValue - pointer to location that will contain the size of
                    information stored in rgbInfoValue, on successful return.
                   If buffer is insufficient, this location will contain the
                    required number of bytes.

  Returns:
    TRUE on success and FALSE if there is any failure.

--*/
{
    BOOL fReturn = FALSE;

    if ( m_hdbc != SQL_NULL_HDBC) {

        RETCODE rc;

        rc = SQLGetInfo( m_hdbc, (UWORD ) fInfoType,
                         (PTR)   rgbInfoValue,
                         (SWORD) cbInfoValueMax,
                         (SWORD FAR *) pcbInfoValue);

        fReturn = Success( rc);

        IF_DEBUG( API_ENTRY) {

            DBGPRINTF( ( DBG_CONTEXT,
                        "SQLGetInfo( %08x, %d, %08x, %d, %08x) returns %d.\n",
                        m_hdbc, fInfoType, rgbInfoValue, cbInfoValueMax,
                        pcbInfoValue, rc));

            CheckAndPrintErrorMessage( this, rc);
        }
    } else {

        DBGPRINTF( ( DBG_CONTEXT,
                    "[SQLGetInfo] Invalid Connection to ODBC\n"));
    }

    return (fReturn);
} // ODBC_CONNECTION::GetInfo()



SQLULEN
ODBC_CONNECTION::DisplaySize(
    SWORD   coltype,
    SQLULEN collen
    )
{
    SQLULEN cbSize = MAX_NONCHAR_DATA_LEN;

    //
    //  Note that we always set the size to at least four bytes.  This prevents
    //  any possible problems if the column to be bound is NULLable, which can
    //  cause a NULL to be written for the data during a fetch
    //

    switch (coltype)
    {
      case SQL_CHAR:
      case SQL_VARCHAR:
      case SQL_LONGVARCHAR:
      case SQL_BINARY:
      case SQL_VARBINARY:
      case SQL_LONGVARBINARY:
        cbSize = max(collen + sizeof(CHAR), sizeof(PVOID));
        break;

      default:
        break;
    }

    return ( cbSize);
} // ODBC_CONNECTION::DisplaySize()




# if DBG
VOID
ODBC_CONNECTION::Print( VOID) const
{
    DBGPRINTF( ( DBG_CONTEXT,
                "Printing ODBC_CONNECTION ( %08x). fValid = %d\n"
                " HENV = %08x. HDBC = %08x. ReturnCode =%d\n",
                this, m_fValid,
                m_henv, m_hdbc, m_rc));
    return;
} // ODBC_CONNECTION::Print()


# endif // DBG


LPSTR
ConvertUnicodeToAnsi(
    IN LPCWSTR  lpszUnicode
    )
/*++
    Description:
        Converts given null-terminated string into ANSI in the buffer supplied.

    Arguments:
        lpszUnicode         null-terminated string in Unicode

    Returns:
        pointer to converted ANSI string. NULL on errors.

--*/
{

    DWORD cchLen;
    DWORD nBytes;
    LPSTR lpszAlloc = NULL;

    if ( lpszUnicode == NULL) {
        return (NULL);
    }

    //
    // multiply by 2 to accomodate DBCS
    //

    cchLen = (DWORD)wcslen( lpszUnicode);
    nBytes = (cchLen+1) * sizeof(CHAR) * 2;
    lpszAlloc = (LPSTR ) LocalAlloc( 0, nBytes );

    if ( lpszAlloc != NULL) {

        cchLen = WideCharToMultiByte( CP_ACP,
                                      WC_COMPOSITECHECK,
                                      lpszUnicode,
                                      -1,
                                      lpszAlloc,
                                      nBytes,
                                      NULL,  // lpszDefaultChar
                                      NULL   // lpfDefaultUsed
                                     );

        DBG_ASSERT(cchLen == (strlen(lpszAlloc)+1) );

        if ( cchLen == 0 ) {

            //
            // There was a failure. Free up buffer if need be.
            //

            DBGPRINTF((DBG_CONTEXT,"WideCharToMultiByte failed with %d\n",
                GetLastError()));

            LocalFree( lpszAlloc);
            lpszAlloc = NULL;

        } else {

            DBG_ASSERT( cchLen <= nBytes );
            DBG_ASSERT(lpszAlloc[cchLen-1] == '\0');

            lpszAlloc[cchLen-1] = '\0';
        }
    }

    return ( lpszAlloc);

} // ConvertUnicodeToAnsi
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\log\plugin\misc.cpp ===
#include "precomp.hxx"

VOID
ConvertSpacesToPlus(
    IN LPSTR    pszString
    )
{
    if ( pszString != NULL ) {
        while ( *pszString != '\0' ) {
            if ((*pszString == ' ') ||
                (*pszString == '\t') ) {
                *pszString = '+';
            }
            pszString++;
        }
    }

    return;
}

DWORD
WeekOfMonth(
    IN LPSYSTEMTIME pstNow
    )
/*++
  Finds the ordinal number of the week of current month.
  The numbering of weeks starts from 1 and run through 5 per month (max).
  The week number changes only on sundays.

  The calculation to be use is:
     1 + ( dayOfMonth - 1)/7  + (( dayOfMonth - 1) % 7 > dayOfWeek);
     (a)     (b)                       (c)                (d)

     (a) to set the week numbers to begin from week numbered "1"
     (b) used to calculate the rough number of the week on which a given
        day falls based on the date.
     (c) calculates what is the offset from the start of week for a given
        day based on the fact that a week had 7 days.
     (d) is the raw day of week given to us.
      (c) > (d) indicates that the week is rolling forward and hence
        the week count should be offset by 1 more.

--*/
{
    DWORD dwTmp;

    dwTmp = (pstNow->wDay - 1);
    dwTmp = ( 1 + dwTmp/7 + (((dwTmp % 7) > pstNow->wDayOfWeek) ? 1 : 0));

    return ( dwTmp);
} // WeekOfMonth()


BOOL
IsBeginningOfNewPeriod(
    IN DWORD          dwPeriod,
    IN LPSYSTEMTIME   pstCurrentFile,
    IN LPSYSTEMTIME   pstNow
    )
/*++
    This function checks to see if we are beginning a new period for
    a given periodic interval type ( specified using dwPeriod).

Arguments:
    dwPeriod    INETLOG_PERIOD  specifying the periodic interval.
    pstCurrentFile  pointer to SYSTEMTIME for the current file.
    pstNow      pointer to SYSTEMTIME for the present time.

Returns:
    TRUE if a new period is beginning ( ie pstNow > pstCurrentFile).
    FALSE otherwise.
--*/
{

    BOOL fNewPeriod = FALSE;

    switch ( dwPeriod) {

    case INET_LOG_PERIOD_HOURLY:
        fNewPeriod = (pstCurrentFile->wHour != pstNow->wHour);

        //
        // Fall Through
        //

    case INET_LOG_PERIOD_DAILY:
        fNewPeriod = fNewPeriod || (pstCurrentFile->wDay != pstNow->wDay);

        //
        // Fall Through
        //

    case INET_LOG_PERIOD_MONTHLY:

        fNewPeriod = fNewPeriod || (pstCurrentFile->wMonth != pstNow->wMonth);
        break;

    case INET_LOG_PERIOD_WEEKLY:
        fNewPeriod =
            (WeekOfMonth(pstCurrentFile) != WeekOfMonth(pstNow)) ||
            (pstCurrentFile->wMonth != pstNow->wMonth);
        break;

    case INET_LOG_PERIOD_NONE:
    default:
        break;
    } // switch()

    return(fNewPeriod);
}// IsBeginningOfNewPeriod
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\log\plugin\plugin1.h ===
// plugin1.h : main header file for PLUGIN1.DLL

#if !defined( __AFXCTL_H__ )
	#error include 'afxctl.h' before including this file
#endif

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CPlugin1App : See plugin1.cpp for implementation.

class CPlugin1App : public COleControlModule
{
public:
	BOOL InitInstance();
	int ExitInstance();
};

extern const GUID CDECL _tlid;
extern const WORD _wVerMajor;
extern const WORD _wVerMinor;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\log\plugin\script_i_stub.c ===
#include "script_i.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\log\plugin\asclogc.cpp ===
/*++

   Copyright (c) 1996-1999  Microsoft Corporation

   Module  Name :
      asclogc.cpp

   Abstract:
      MS Logging Format implementation

   Author:

       Terence Kwan    ( terryk )    18-Sep-1996

   Project:

       IIS Logging 3.0

--*/

#include "precomp.hxx"
#include <stdio.h>
#include <winnls.h>
#include <script.h>
#include "LogScript.hxx"
#include <ilogobj.hxx>
#include "filectl.hxx"
#include "asclogc.hxx"

CHAR    szAsciiNoPeriodPattern[] = "inetsv*.log";

// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------

CASCLOG::CASCLOG()
{
}

// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------

CASCLOG::~CASCLOG()
{
}

// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------

LPCSTR
CASCLOG::QueryNoPeriodPattern(
    VOID
    )
{
    return szAsciiNoPeriodPattern;
} // CASCLOG::QueryNoPeriodPattern

// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------

VOID
CASCLOG::FormNewLogFileName(
                IN LPSYSTEMTIME pstNow
                )
/*++
  This function that forms the new log file name based on
   type of periodic logging done.

  Arguments:
    pstNow     pointer to SystemTime which contains the current time.
    fBackup    flag indicating if we want to make current file a backup.

  Returns:
    TRUE on success in forming the name or FALSE if there is any error.

--*/
{

    I_FormNewLogFileName(pstNow,DEFAULT_LOG_FILE_NAME);
    return;

} // INET_FILE_LOG::FormNewLogFileName()

// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------

VOID
FormatLogDwords(
    IN IInetLogInformation * pLogObj,
    IN LPSTR *pBuffer,
    IN DWORD *pcbSize,
    IN PDWORD pRequired
    )
{

    CHAR    tmpBuf[32];
    DWORD   cbTmp;

    //
    // Processing Time
    //

    cbTmp = FastDwToA( tmpBuf, pLogObj->GetTimeForProcessing() );

    *pRequired += cbTmp;
    if ( *pRequired <= *pcbSize ) {
        tmpBuf[cbTmp] = ',';
        tmpBuf[cbTmp+1] = ' ';
        CopyMemory(*pBuffer, tmpBuf, cbTmp+2);
        *pBuffer += cbTmp+2;
    }

    //
    // Bytes Received
    //

    cbTmp = FastDwToA( tmpBuf, pLogObj->GetBytesRecvd() );

    *pRequired += cbTmp;
    if ( *pRequired <= *pcbSize ) {
        tmpBuf[cbTmp] = ',';
        tmpBuf[cbTmp+1] = ' ';
        CopyMemory(*pBuffer, tmpBuf, cbTmp+2);
        *pBuffer += cbTmp+2;
    }

    //
    // Bytes Sent
    //

    cbTmp = FastDwToA( tmpBuf, pLogObj->GetBytesSent() );

    *pRequired += cbTmp;
    if ( *pRequired <= *pcbSize ) {
        tmpBuf[cbTmp] = ',';
        tmpBuf[cbTmp+1] = ' ';
        CopyMemory(*pBuffer, tmpBuf, cbTmp+2);
        *pBuffer += cbTmp+2;
    }

    //
    // HTTP Status
    //

    cbTmp = FastDwToA( tmpBuf, pLogObj->GetProtocolStatus() );

    *pRequired += cbTmp;
    if ( *pRequired <= *pcbSize ) {
        tmpBuf[cbTmp] = ',';
        tmpBuf[cbTmp+1] = ' ';
        CopyMemory(*pBuffer, tmpBuf, cbTmp+2);
        *pBuffer += cbTmp+2;
    }

    //
    // Win32 status
    //

    cbTmp = FastDwToA( tmpBuf, pLogObj->GetWin32Status() );

    *pRequired += cbTmp;
    if ( *pRequired <= *pcbSize ) {
        tmpBuf[cbTmp] = ',';
        tmpBuf[cbTmp+1] = ' ';
        CopyMemory(*pBuffer, tmpBuf, cbTmp+2);
        *pBuffer += cbTmp+2;
    }

    return;

} // FormatLogDwords

// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------

BOOL
CASCLOG::FormatLogBuffer(
         IN IInetLogInformation *pLogObj,
         IN LPSTR                pBuf,
         IN DWORD                *pcbSize,
         OUT SYSTEMTIME          *pSystemTime
    )
{

    CHAR  rgchDateTime[ 32];

    PCHAR pBuffer = pBuf;
    PCHAR pTmp;
    DWORD cbTmp;
    DWORD nRequired;

    if ( pBuf == NULL ) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Format is:
    // Host UserName Date Time Service ComputerName ServerIP
    //      msProcessingTime bytesR bytesS protocolStat Win32Stat
    //      Operation Target Parameters
    //

    //
    // Host ID
    //

    pTmp = pLogObj->GetClientHostName( NULL, &cbTmp );
    if ( cbTmp == 0 ) {
        cbTmp = 1;
        pTmp = "-";
    }

    nRequired = cbTmp + 2;  // 2 for delimiter
    if ( nRequired <= *pcbSize ) {
        CopyMemory(pBuffer, pTmp, cbTmp);
        pBuffer += cbTmp;
        *(pBuffer++) = ',';
        *(pBuffer++) = ' ';
    }

    //
    // UserName
    //

    pTmp = pLogObj->GetClientUserName( NULL, &cbTmp );
    if ( cbTmp == 0 ) {
        cbTmp = 1;
        pTmp = "-";
    }

    nRequired += cbTmp + 2;  //2 for delimiter
    if ( nRequired <= *pcbSize ) {
        CopyMemory(pBuffer, pTmp, cbTmp);
        pBuffer += cbTmp;
        *(pBuffer++) = ',';
        *(pBuffer++) = ' ';
    }

    //
    // Date/Time (already delimited)
    //

    m_DateTimeCache.SetLocalTime(pSystemTime);
    cbTmp = m_DateTimeCache.GetFormattedDateTime(pSystemTime,rgchDateTime);

    nRequired += cbTmp;
    if ( nRequired <= *pcbSize ) {
        CopyMemory(pBuffer, rgchDateTime, cbTmp);
        pBuffer += cbTmp;
    }

    //
    // Site Name
    //

    pTmp = pLogObj->GetSiteName( NULL, &cbTmp );
    if ( cbTmp == 0 ) {
        cbTmp = 1;
        pTmp = "-";
    }

    nRequired += cbTmp + 2;  // 2 for delimiter
    if ( nRequired <= *pcbSize ) {
        CopyMemory(pBuffer, pTmp, cbTmp);
        pBuffer += cbTmp;
        *(pBuffer++) = ',';
        *(pBuffer++) = ' ';
    }

    //
    // ComputerName
    //

    pTmp = pLogObj->GetComputerName( NULL, &cbTmp );
    if ( cbTmp == 0 ) {
        cbTmp = 1;
        pTmp = "-";
    }

    nRequired += cbTmp + 2;  // 2 for delimiter
    if ( nRequired <= *pcbSize ) {
        CopyMemory(pBuffer, pTmp, cbTmp);
        pBuffer += cbTmp;
        *(pBuffer++) = ',';
        *(pBuffer++) = ' ';
    }

    //
    // Server IP
    //

    pTmp = pLogObj->GetServerAddress( NULL, &cbTmp );
    if ( cbTmp == 0 ) {
        cbTmp = 1;
        pTmp = "-";
    }

    nRequired += cbTmp + 2;  // 2 for delimiter
    if ( nRequired <= *pcbSize ) {
        CopyMemory(pBuffer, pTmp, cbTmp);
        pBuffer += cbTmp;
        *(pBuffer++) = ',';
        *(pBuffer++) = ' ';
    }

    //
    // Use fast path ?
    // All numbers are < 4G (10 charaters)
    // add 2 per number for delimiters
    // so we need 10 * 5 numbers == 30 bytes
    //

    nRequired += 10;    // 10 for delimiters of 5 numbers

    if ( (nRequired + 50) <= *pcbSize ) {

        //
        // Processing Time
        //

        cbTmp = FastDwToA( pBuffer, pLogObj->GetTimeForProcessing() );
        nRequired += cbTmp;
        pBuffer += cbTmp;
        *(pBuffer++) = ',';
        *(pBuffer++) = ' ';

        //
        // Bytes Received
        //

        cbTmp = FastDwToA( pBuffer, pLogObj->GetBytesRecvd() );
        nRequired += cbTmp;
        pBuffer += cbTmp;
        *(pBuffer++) = ',';
        *(pBuffer++) = ' ';

        //
        // Bytes Sent
        //

        cbTmp = FastDwToA( pBuffer, pLogObj->GetBytesSent() );
        nRequired += cbTmp;
        pBuffer += cbTmp;
        *(pBuffer++) = ',';
        *(pBuffer++) = ' ';

        //
        // HTTP Status
        //

        cbTmp = FastDwToA( pBuffer, pLogObj->GetProtocolStatus() );
        nRequired += cbTmp;
        pBuffer += cbTmp;
        *(pBuffer++) = ',';
        *(pBuffer++) = ' ';

        //
        // Win32 status
        //

        cbTmp = FastDwToA( pBuffer, pLogObj->GetWin32Status() );
        nRequired += cbTmp;
        pBuffer += cbTmp;
        *(pBuffer++) = ',';
        *(pBuffer++) = ' ';

    } else {

        FormatLogDwords( pLogObj, &pBuffer, pcbSize, &nRequired );
    }

    //
    // Operation
    //

    pTmp = pLogObj->GetOperation( NULL, &cbTmp );
    if ( cbTmp == 0 ) {
        cbTmp = 1;
        pTmp = "-";
    }

    nRequired += cbTmp + 2; // 2 for delimiter
    if ( nRequired <= *pcbSize ) {
        CopyMemory(pBuffer, pTmp, cbTmp);
        pBuffer += cbTmp;
        *(pBuffer++) = ',';
        *(pBuffer++) = ' ';
    }

    //
    // Target
    //

    pTmp = pLogObj->GetTarget( NULL, &cbTmp );
    if ( cbTmp == 0 ) {
        cbTmp = 1;
        pTmp = "-";
    }

    nRequired += cbTmp + 2; // 2 for delimiter
    if ( nRequired <= *pcbSize ) {
        CopyMemory(pBuffer, pTmp, cbTmp);
        pBuffer += cbTmp;
        *(pBuffer++) = ',';
        *(pBuffer++) = ' ';
    }

    //
    // Parameters
    //

    pTmp = pLogObj->GetParameters( NULL, &cbTmp );
    if ( cbTmp == 0 ) {
        cbTmp = 1;
        pTmp = "-";
    }

    nRequired += cbTmp + 1 + 2; //  1 for delimiter, 2 for EOL
    if ( nRequired <= *pcbSize ) {
        CopyMemory(pBuffer, pTmp, cbTmp);
        pBuffer += cbTmp;
        
        // NOTE
        // Documentation is ambiguous about the presence of a comma
        // at the end of the log record, but the comma is required
        // for backward compatability with site server

        *(pBuffer++) = ',';
        *(pBuffer++) = '\r';
        *(pBuffer++) = '\n';
    }

    if ( nRequired > *pcbSize ) {
        *pcbSize = nRequired;
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return(FALSE);
    } else {
        *pcbSize = nRequired;
        return(TRUE);
    }
} // FormatLogBuffer

// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------

HRESULT
CASCLOG::ReadFileLogRecord(
    IN  FILE                *fpLogFile, 
    IN  LPINET_LOGLINE      pInetLogLine,
    IN  PCHAR               pszLogLine,
    IN  DWORD               dwLogLineSize
)
{

    CHAR * pCh;
    CHAR * szDateString, * szTimeString;

getnewline:

    pCh = pszLogLine;
    
    if (fgets(pCh, dwLogLineSize, fpLogFile) == NULL)
    {
        return E_FAIL;
    }

    pCh = SkipWhite(pCh);
        
    if (('\n' == *pCh) || ('\0' == *pCh))
    {
        // Empty line. Get Next line

        goto getnewline;
    }

    //
    // We have a log line. Parse it.
    //
    // Format is:
    // Host UserName Date Time Service ComputerName ServerIP
    //      msProcessingTime bytesR bytesS protocolStat Win32Stat
    //      Operation Target Parameters
    //
    
    if ( NULL == (pCh = strtok(pCh,",")) )
    {
        return E_FAIL;
    }
    while  (isspace((UCHAR)(*pCh))) pCh++;
    pInetLogLine->pszClientHostName = pCh; 

    if ( NULL == (pCh = strtok(NULL,",")) )
    {
        return E_FAIL;
    }
    while  (isspace((UCHAR)(*pCh))) pCh++;
    pInetLogLine->pszClientUserName = pCh;

    //
    // Date & Time.
    //

    if ( NULL == (pCh = strtok(NULL,",")) )
    {
        return E_FAIL;
    }
    while  (isspace((UCHAR)(*pCh))) pCh++;
    szDateString = pCh;

    if ( NULL == (pCh = strtok(NULL,",")) )
    {
        return E_FAIL;
    }
    while  (isspace((UCHAR)(*pCh))) pCh++;
    szTimeString = pCh;
    
    if ( ! ConvertASCDateToVariantDate(szDateString, szTimeString, &(pInetLogLine->DateTime)) )
    {
        return E_FAIL;
    }

    //
    // Service & Server information
    //
    
    if ( NULL == (pCh = strtok(NULL,",")) )
    {
        return E_FAIL;
    }
    while  (isspace((UCHAR)(*pCh))) pCh++;
    pInetLogLine->pszSiteName = pCh;

    if ( NULL == (pCh = strtok(NULL,",")) )
    {
        return E_FAIL;
    }
    while  (isspace((UCHAR)(*pCh))) pCh++;
    pInetLogLine->pszComputerName = pCh;

    if ( NULL == (pCh = strtok(NULL,",")) )
    {
        return E_FAIL;
    }
    while  (isspace((UCHAR)(*pCh))) pCh++;
    pInetLogLine->pszServerAddress = pCh;

    //
    // Statistics - processing time, bytes recvd, bytes sent
    //
    
    if ( NULL == (pCh = strtok(NULL,",")) )
    {
        return E_FAIL;
    }
    while  (isspace((UCHAR)(*pCh))) pCh++;
    pInetLogLine->pszTimeForProcessing = pCh;

    if ( NULL == (pCh = strtok(NULL,",")) )
    {
        return E_FAIL;
    }
    while  (isspace((UCHAR)(*pCh))) pCh++;
    pInetLogLine->pszBytesRecvd = pCh;

    if ( NULL == (pCh = strtok(NULL,",")) )
    {
        return E_FAIL;
    }
    while  (isspace((UCHAR)(*pCh))) pCh++;
    pInetLogLine->pszBytesSent = pCh;

    //
    // Status information - protocol, Win32
    //
    
    if ( NULL == (pCh = strtok(NULL,",")) )
    {
        return E_FAIL;
    }
    while  (isspace((UCHAR)(*pCh))) pCh++;
    pInetLogLine->pszProtocolStatus = pCh;

    if ( NULL == (pCh = strtok(NULL,",")) )
    {
        return E_FAIL;
    }
    while  (isspace((UCHAR)(*pCh))) pCh++;
    pInetLogLine->pszWin32Status = pCh;

    //
    // Request information - operation, target, parameters
    //

    if ( NULL == (pCh = strtok(NULL,",")) )
    {
        return E_FAIL;
    }
    while  (isspace((UCHAR)(*pCh))) pCh++;
    pInetLogLine->pszOperation = pCh;

    if ( NULL == (pCh = strtok(NULL,",")) )
    {
        return E_FAIL;
    }
    while  (isspace((UCHAR)(*pCh))) pCh++;
    pInetLogLine->pszTarget = pCh;

    if ( NULL == (pCh = strtok(NULL," ,\t\r\n")) )
    {
        return E_FAIL;
    }
    while  (isspace((UCHAR)(*pCh))) pCh++;
    pInetLogLine->pszParameters = pCh;

    return S_OK;
}

// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------

HRESULT
CASCLOG::WriteFileLogRecord(
            IN  FILE            *fpLogFile, 
            IN  ILogScripting   *pILogScripting,
            IN  bool
        )
{

    HRESULT hr = E_FAIL;
    CHAR    szLogLine[4096];  
    DWORD   dwIndex = 0;

    //
    // Format is:
    // Host, UserName, Date, Time, Service, ComputerName, ServerIP,
    //      msProcessingTime, bytesR, bytesS, protocolStat, Win32Stat,
    //      Operation, Target, Parameters,
    //

    VARIANT    szHostName, szUserName, szServiceName, szComputerName;
    VARIANT    szServerIP, szOperation, szTarget, szParameters;
    VARIANT    DateTime;
    VARIANT    lTimeForProcessing, lBytesSent, lBytesRecvd, lProtocolStatus, lWin32Status;

    SYSTEMTIME  sysTime; 
    CHAR  rgchDateTime[ 32];


    if (SUCCEEDED(pILogScripting->get_ClientIP      ( &szHostName))         &&
        SUCCEEDED(pILogScripting->get_UserName      ( &szUserName))         &&   
        SUCCEEDED(pILogScripting->get_DateTime      ( &DateTime))           &&
        SUCCEEDED(pILogScripting->get_ServiceName   ( &szServiceName))      &&
        SUCCEEDED(pILogScripting->get_ServerName    ( &szComputerName))     &&
        SUCCEEDED(pILogScripting->get_ServerIP      ( &szServerIP))         &&
        SUCCEEDED(pILogScripting->get_TimeTaken     ( &lTimeForProcessing)) &&
        SUCCEEDED(pILogScripting->get_BytesReceived ( &lBytesRecvd))        &&
        SUCCEEDED(pILogScripting->get_BytesSent     ( &lBytesSent))         &&
        SUCCEEDED(pILogScripting->get_ProtocolStatus( &lProtocolStatus))    &&
        SUCCEEDED(pILogScripting->get_Win32Status   ( &lWin32Status))       &&
        SUCCEEDED(pILogScripting->get_Method        ( &szOperation))        &&
        SUCCEEDED(pILogScripting->get_URIStem       ( &szTarget))           &&
        SUCCEEDED(pILogScripting->get_URIQuery      ( &szParameters))       &&
        VariantTimeToSystemTime( DateTime.date, &sysTime)
        )
    {

        m_DateTimeCache.GetFormattedDateTime( &sysTime, rgchDateTime);

        dwIndex = sprintf(szLogLine, "%ws, %ws, %s%ws, %ws, %ws,", 
                            GetBstrFromVariant( &szHostName), 
                            GetBstrFromVariant( &szUserName), 
                            rgchDateTime, // This guy already contains a trailing ", "
                            GetBstrFromVariant( &szServiceName), 
                            GetBstrFromVariant( &szComputerName), 
                            GetBstrFromVariant( &szServerIP)
                        );

        szLogLine[dwIndex++] = ' ';
        dwIndex += GetLongFromVariant( &lTimeForProcessing, szLogLine+dwIndex) ;

        szLogLine[dwIndex++] = ',';
        szLogLine[dwIndex++] = ' ';
        dwIndex += GetLongFromVariant( &lBytesRecvd, szLogLine+dwIndex);
        
        szLogLine[dwIndex++] = ',';
        szLogLine[dwIndex++] = ' ';
        dwIndex += GetLongFromVariant( &lBytesSent, szLogLine+dwIndex);
 
        szLogLine[dwIndex++] = ',';
        szLogLine[dwIndex++] = ' ';
        dwIndex += GetLongFromVariant( &lProtocolStatus, szLogLine+dwIndex);
        
        szLogLine[dwIndex++] = ',';
        szLogLine[dwIndex++] = ' ';
        dwIndex += GetLongFromVariant( &lWin32Status, szLogLine+dwIndex);

        sprintf( szLogLine+dwIndex ,", %ws, %ws, %ws",
                    GetBstrFromVariant( &szOperation), 
                    GetBstrFromVariant( &szTarget), 
                    GetBstrFromVariant( &szParameters)
                );

        // Include a , at the end of the log record. See NOTE in
        // FormatLogBuffer for more details on why.

        fprintf(fpLogFile, "%s,\n", szLogLine);

        hr = S_OK;
    }

    return hr;
}

// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------

BOOL 
CASCLOG::ConvertASCDateToVariantDate(PCHAR szDateString, PCHAR szTimeString, DATE * pDateTime)
{
    USES_CONVERSION;

    BOOL    fSuccess = FALSE;
    HRESULT hr;
    LCID    lcid;

    BSTR bstrDate;
    BSTR bstrTime;

    DATE dateTime;
    DATE dateDate;
    
    DECIMAL decDate;
    DECIMAL decTime;
    DECIMAL decDateTimeComposite;
    
    bstrDate = SysAllocString(A2OLE(szDateString));
    bstrTime = SysAllocString(A2OLE(szTimeString));

    if ((NULL == bstrDate) ||
        (NULL == bstrTime))
    {
        goto error_converting;
    }       

    //
    // On IIS6, http.sys writes IIS log format always in US format
    //
    lcid = MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT);

    hr = VarDateFromStr(bstrTime, lcid, LOCALE_NOUSEROVERRIDE, &dateTime);
    if (FAILED(hr))
    {
        goto error_converting;
    }

    hr = VarDateFromStr(bstrDate, lcid, LOCALE_NOUSEROVERRIDE, &dateDate);
    if (FAILED(hr))
    {
        goto error_converting;
    }

    hr = VarDecFromDate(dateDate, &decDate);
    if (FAILED(hr))
    {
        goto error_converting;
    }

    hr = VarDecFromDate(dateTime, &decTime);
    if (FAILED(hr))
    {
        goto error_converting;
    }

    hr = VarDecAdd(&decDate, &decTime, &decDateTimeComposite);
    if (FAILED(hr))
    {
        goto error_converting;
    }   

    hr = VarDateFromDec(&decDateTimeComposite, pDateTime);
    if (FAILED(hr))
    {
        goto error_converting;
    }
    fSuccess = TRUE;

error_converting:

    if (NULL != bstrDate)
    {
        SysFreeString(bstrDate);
        bstrDate = NULL;
    }

    if (NULL != bstrTime)
    {
        SysFreeString(bstrTime);
        bstrTime = NULL;
    }

    return fSuccess;
}

// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\log\plugin\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by plugin.rc
//
#define IDS_DATE                        1001
#define IDS_TIME                        1002
#define IDS_CLIENT_IP_ADDRESS           1003
#define IDS_USER_NAME                   1004
#define IDS_SERVICE_NAME                1005
#define IDS_SERVER_NAME                 1006
#define IDS_SERVER_IP                   1007
#define IDS_SERVER_PORT                 1008
#define IDS_METHOD                      1009
#define IDS_URI_STEM                    1010
#define IDS_URI_QUERY                   1011
#define IDS_HTTP_STATUS                 1012
#define IDS_WIN32_STATUS                1013
#define IDS_BYTES_SENT                  1014
#define IDS_BYTES_RECEIVED              1015
#define IDS_TIME_TAKEN                  1016
#define IDS_PROTOCOL_VERSION            1017
#define IDS_USER_AGENT                  1018
#define IDS_COOKIE                      1019
#define IDS_REFERER                     1020
#define IDS_EXTENDED_PROP               1021
#define IDS_HOST                        1022
#define IDS_HTTP_SUB_STATUS             1023

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        207
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         232
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\log\plugin\sources.inc ===
DLLDEF=..\iislog.def
TARGETPATH=obj
TARGETTYPE=DYNLINK
DLLENTRY=DLLEntry

PRECOMPILED_INCLUDE=..\precomp.hxx
PRECOMPILED_CXX=1
USE_MSVCRT=1
USE_ATL=1
USE_STL=1

MSC_WARNING_LEVEL=/W4

C_DEFINES=$(C_DEFINES) -DLKR_DEPRECATED_ITERATORS

INCLUDES=..;\
       ..\..\idl\$(O);             \
       ..\..\comlog\$(O);          \
       $(IISBASEDIR)\inc;       \
       ..\..\scripting;

SOURCES=\
        ..\cofact.cxx      \
        ..\plugin.rc       \
        ..\filectl.cpp     \
        ..\extlogc.cpp     \
        ..\ncslogc.cpp     \
        ..\ilogfile.cxx    \
        ..\misc.cpp        \
        ..\odbcconn.cxx    \
        ..\LogScript.cpp   \
        ..\script_i_stub.c

TARGETLIBS=\
       $(IISBASEDIR)\svcs\iisrtl\$(O)\iisrtl.lib     \
       $(SDK_LIB_PATH)\ole32.lib     \
       $(SDK_LIB_PATH)\kernel32.lib  \
       $(SDK_LIB_PATH)\user32.lib   \
       $(SDK_LIB_PATH)\advapi32.lib  \
       $(SDK_LIB_PATH)\oleaut32.lib  \
       $(SDK_LIB_PATH)\uuid.lib     \
       $(SDK_LIB_PATH)\odbc32.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\log\scripting\dlldatax.c ===
// wrapper for dlldata.c

#ifdef _MERGE_PROXYSTUB // merge proxy stub DLL

#define REGISTER_PROXY_DLL //DllRegisterServer, etc.

#define _WIN32_WINNT 0x0400	//for WinNT 4.0 or Win95 with DCOM
#define USE_STUBLESS_PROXY	//defined only with MIDL switch /Oicf

#pragma comment(lib, "rpcndr.lib")
#pragma comment(lib, "rpcns4.lib")
#pragma comment(lib, "rpcrt4.lib")

#define DllMain				PrxDllMain
#define DllRegisterServer	PrxDllRegisterServer
#define DllUnregisterServer PrxDllUnregisterServer
#define DllGetClassObject   PrxDllGetClassObject
#define DllCanUnloadNow     PrxDllCanUnloadNow

#include "dlldata.c"
#include "script_p.c"

#ifdef _NOPROXY //no midl generated dlldata.c

#define STRICT 1
#include <ole2.h>

BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{return TRUE;}

STDAPI PrxDllCanUnloadNow(void){return S_OK;}

STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{return CLASS_E_CLASSNOTAVAILABLE;}

STDAPI PrxDllRegisterServer(void){return S_OK;}

STDAPI PrxDllUnregisterServer(void){return S_OK;}

#endif //!PROXY_DELEGATION

#endif //_MERGE_PROXYSTUB
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\log\scripting\dlldatax.h ===
#if !defined(AFX_DLLDATAX_H__B758F307_A3D6_11D1_8B9C_080009DCC2FA__INCLUDED_)
#define AFX_DLLDATAX_H__B758F307_A3D6_11D1_8B9C_080009DCC2FA__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifdef _MERGE_PROXYSTUB

extern "C" 
{
BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, 
	LPVOID lpReserved);
STDAPI PrxDllCanUnloadNow(void);
STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
STDAPI PrxDllRegisterServer(void);
STDAPI PrxDllUnregisterServer(void);
}

#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLLDATAX_H__B758F307_A3D6_11D1_8B9C_080009DCC2FA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\log\plugin\plugin1.cpp ===
#include "precomp.hxx"
#include <stdio.h>
#include <script.h>
#include "LogScript.hxx"
#include <ilogobj.hxx>
#include "filectl.hxx"
#include "asclogc.hxx"
#include "ncslogc.hxx"
#include "lkrhash.h"
#include "extlogc.hxx"
#include "odbcconn.hxx"
#include "odblogc.hxx"

#include <initguid.h>
#include <iadmw.h>

#include "resource.h"

HINSTANCE   hDLLInstance;

BOOL
AddClsIdRegKeys(
    IN LPCSTR ControlKey,
    IN LPCSTR ClsId,
    IN LPCSTR ControlName,
    IN LPCSTR PPageClsId,
    IN LPCSTR PPageName,
    IN LPCSTR BitmapIndex
    );

BOOL
AddControlRegKeys(
    IN LPCSTR ControlKey,
    IN LPCSTR ControlName,
    IN LPCSTR ClsId,
    IN LPCSTR PPageClsId,
    IN LPCSTR PPageName,
    IN LPCSTR BitmapIndex
    );

BOOL
CreateMetabaseKeys();

HRESULT SetAdminACL(
    IMSAdminBase        *pAdminBase,
    METADATA_HANDLE     hMeta,
    LPWSTR              wszKeyName
    );

DWORD
GetPrincipalSID (
    LPTSTR              Principal,
    PSID                *Sid,
    BOOL                *pbWellKnownSID
    );

BEGIN_OBJECT_MAP(ObjectMap)
        OBJECT_ENTRY(CLSID_NCSALOG, CNCSALOG)
        OBJECT_ENTRY(CLSID_ODBCLOG, CODBCLOG)
        OBJECT_ENTRY(CLSID_EXTLOG, CEXTLOG)
        OBJECT_ENTRY(CLSID_ASCLOG, CASCLOG)
END_OBJECT_MAP()

DECLARE_DEBUG_VARIABLE();

DECLARE_DEBUG_PRINTS_OBJECT();
DECLARE_PLATFORM_TYPE();

extern "C" {

BOOL
WINAPI
DLLEntry(
    HINSTANCE hDll,
    DWORD     dwReason,
    LPVOID    lpvReserved
    );
}

BOOL
WINAPI
DLLEntry(
    HINSTANCE hDll,
    DWORD     dwReason,
    LPVOID
    )
/*++

Routine Description:

    DLL entrypoint.

Arguments:

    hDLL          - Instance handle.

    Reason        - The reason the entrypoint was called.
                    DLL_PROCESS_ATTACH
                    DLL_PROCESS_DETACH
                    DLL_THREAD_ATTACH
                    DLL_THREAD_DETACH

Return Value:

    BOOL          - TRUE if the action succeeds.

--*/
{
    hDLLInstance = hDll;

    BOOL bReturn = TRUE;

    switch ( dwReason ) {

    case DLL_PROCESS_ATTACH:
        INITIALIZE_PLATFORM_TYPE();
        CREATE_DEBUG_PRINT_OBJECT("iislog.dll");
        LOAD_DEBUG_FLAGS_FROM_REG_STR("System\\CurrentControlSet\\Services\\InetInfo\\Parameters", 0);
        _Module.Init(ObjectMap,hDll);
        g_eventLog = new EVENT_LOG(IISLOG_EVENTLOG_SOURCE);

        if ( g_eventLog == NULL ) {
            DBGPRINTF((DBG_CONTEXT,
                "Unable to create eventlog[%s] object[err %d]\n",
                IISLOG_EVENTLOG_SOURCE, GetLastError()));
        }

        (VOID)IISGetPlatformType();

        DisableThreadLibraryCalls(hDll);
        break;

    case DLL_PROCESS_DETACH:

        if ( g_eventLog != NULL ) {
            delete g_eventLog;
            g_eventLog = NULL;
        }

        _Module.Term();
        DELETE_DEBUG_PRINT_OBJECT( );
        break;

    default:
        break;
    }

    return bReturn;
} // DllEntry


//
// constants used in self registration
//

#define TYPELIB_CLSID       "{FF160650-DE82-11CF-BC0A-00AA006111E0}"

#define NCSA_CLSID          NCSALOG_CLSID   // %F
#define NCSA_KEY            "MSIISLOG.MSNCSALogCtrl.1"
#define NCSA_NAME           "MSNCSALog Control"
#define NCSA_PP_CLSID       "{FF160660-DE82-11CF-BC0A-00AA006111E0}"
#define NCSA_PP_NAME        "MSNCSALog Property Page"

#define ODBC_CLSID          ODBCLOG_CLSID   //5B
#define ODBC_KEY            "MSIISLOG.MSODBCLogCtrl.1"
#define ODBC_NAME           "MSODBCLog Control"
#define ODBC_PP_CLSID       "{FF16065C-DE82-11CF-BC0A-00AA006111E0}"
#define ODBC_PP_NAME        "MSODBCLog Property Page"

#define ASCII_CLSID         ASCLOG_CLSID    // 57
#define ASCII_KEY           "MSIISLOG.MSASCIILogCtrl.1"
#define ASCII_NAME          "MSASCIILog Control"
#define ASCII_PP_CLSID      "{FF160658-DE82-11CF-BC0A-00AA006111E0}"
#define ASCII_PP_NAME       "MSASCIILog Property Page"

#define CUSTOM_CLSID        EXTLOG_CLSID    // 63
#define CUSTOM_KEY          "MSIISLOG.MSCustomLogCtrl.1"
#define CUSTOM_NAME         "MSCustomLog Control"
#define CUSTOM_PP_CLSID     "{FF160664-DE82-11CF-BC0A-00AA006111E0}"
#define CUSTOM_PP_NAME      "MSCustomLog Property Page"

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI
DllRegisterServer(void)
{
    //
    // MS NCSA Log Support
    //

    if ( !AddControlRegKeys(
                    NCSA_KEY,
                    NCSA_NAME,
                    NCSA_CLSID,
                    NCSA_PP_CLSID,
                    NCSA_PP_NAME,
                    "4") ) {

        goto error;
    }

    //
    // MS ODBC Log Support
    //

    if ( !AddControlRegKeys(
                    ODBC_KEY,
                    ODBC_NAME,
                    ODBC_CLSID,
                    ODBC_PP_CLSID,
                    ODBC_PP_NAME,
                    "3") ) {

        goto error;
    }

    //
    // MS Ascii Log Support
    //

    if ( !AddControlRegKeys(
                    ASCII_KEY,
                    ASCII_NAME,
                    ASCII_CLSID,
                    ASCII_PP_CLSID,
                    ASCII_PP_NAME,
                    "2") ) {

        goto error;
    }

    //
    // MS Custom Log Support
    //

    if ( !AddClsIdRegKeys(
                    CUSTOM_KEY,
                    CUSTOM_CLSID,
                    CUSTOM_NAME,
                    CUSTOM_PP_CLSID,
                    CUSTOM_PP_NAME,
                    "2"
                    ) ) {
        goto error;
    }

    //
    // Metabase entries for W3C custom logging
    //

    if ( !CreateMetabaseKeys() ) {

        goto error;
    }

    return S_OK;

error:
    return E_UNEXPECTED;

} // DllRegisterServer


/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI
DllUnregisterServer(void)
{

    HKEY hCLSID;

    //
    // Delete controls
    //

    ZapRegistryKey(HKEY_CLASSES_ROOT,NCSA_KEY);
    ZapRegistryKey(HKEY_CLASSES_ROOT,ODBC_KEY);
    ZapRegistryKey(HKEY_CLASSES_ROOT,ASCII_KEY);

    //
    // Get CLSID handle
    //

    if ( RegOpenKeyExA(HKEY_CLASSES_ROOT,
                    "CLSID",
                    0,
                    KEY_ALL_ACCESS,
                    &hCLSID) != ERROR_SUCCESS ) {

        IIS_PRINTF((buff,"IISLOG: Cannot open CLSID key\n"));
        return E_UNEXPECTED;
    }

    ZapRegistryKey(hCLSID, NCSA_CLSID);
    ZapRegistryKey(hCLSID, NCSA_PP_CLSID);

    ZapRegistryKey(hCLSID, ODBC_CLSID);
    ZapRegistryKey(hCLSID, ODBC_PP_CLSID);

    ZapRegistryKey(hCLSID, ASCII_CLSID);
    ZapRegistryKey(hCLSID, ASCII_PP_CLSID);

    ZapRegistryKey(hCLSID, CUSTOM_CLSID);
    ZapRegistryKey(hCLSID, CUSTOM_PP_CLSID);

    RegCloseKey(hCLSID);

    //
    // Open the metabase path and remove Custom Logging keys
    //

    /*

    IMSAdminBase*       pMBCom = NULL;
    METADATA_HANDLE     hMeta = NULL;

    if ( SUCCEEDED( CoCreateInstance(GETAdminBaseCLSID(TRUE), NULL, CLSCTX_LOCAL_SERVER,
                            IID_IMSAdminBase, (void **)(&pMBCom) )))
    {
        if ( SUCCEEDED( pMBCom->OpenKey( METADATA_MASTER_ROOT_HANDLE, L"LM",
                     METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE, MB_TIMEOUT,
                     &hMeta))  )
        {
            pMBCom->DeleteKey(hMeta, L"Logging/Custom Logging");
            pMBCom->CloseKey(hMeta);
        }

        pMBCom->Release();
    }

    */
    return S_OK;

} // DllUnregisterServer


BOOL
AddControlRegKeys(
    IN LPCSTR ControlKey,
    IN LPCSTR ControlName,
    IN LPCSTR ControlClsId,
    IN LPCSTR PPageClsId,
    IN LPCSTR PPageName,
    IN LPCSTR BitmapIndex
    )
{

    HKEY hProgID = NULL;
    HKEY hCLSID = NULL;

    BOOL fRet = FALSE;

    //
    // Add control name
    //

    hProgID = CreateKey(HKEY_CLASSES_ROOT,ControlKey,ControlName);
    if ( hProgID == NULL ) {
        goto exit;
    }

    hCLSID = CreateKey(hProgID,"CLSID",ControlClsId);
    if ( hCLSID == NULL ) {
        goto exit;
    }

    //
    // Add CLSID keys
    //

    if ( !AddClsIdRegKeys(
                    ControlKey,
                    ControlClsId,
                    ControlName,
                    PPageClsId,
                    PPageName,
                    BitmapIndex) ) {

        goto exit;
    }

    fRet = TRUE;

exit:
    if ( hProgID != NULL ) {
        RegCloseKey(hProgID);
    }

    if ( hCLSID != NULL ) {
        RegCloseKey(hCLSID);
    }

    return(fRet);

} // AddControlRegKeys


BOOL
AddClsIdRegKeys(
    IN LPCSTR ControlKey,
    IN LPCSTR ClsId,
    IN LPCSTR ControlName,
    IN LPCSTR PPageClsId,
    IN LPCSTR PPageName,
    IN LPCSTR BitmapIndex
    )
{
    BOOL fRet = FALSE;

    HKEY hCLSID = NULL;
    HKEY hRoot = NULL;
    HKEY hKey, hKey2;

    CHAR szName[MAX_PATH+1];

    HMODULE hModule;

    //
    // open CLASSES/CLSID
    //

    if ( RegOpenKeyEx(HKEY_CLASSES_ROOT,
                    "CLSID",
                    0,
                    KEY_ALL_ACCESS,
                    &hCLSID) != ERROR_SUCCESS ) {

        IIS_PRINTF((buff,"IISLOG: Cannot open CLSID key\n"));
        goto exit;
    }

    //
    // Create the Guid and set the control name
    //

    hRoot = CreateKey(hCLSID,ClsId,ControlName);

    if ( hRoot == NULL ) {
        goto exit;
    }

    //
    // Control
    //

    hKey = CreateKey(hRoot, "Control", "");
    if ( hKey == NULL ) {
        goto exit;
    }

    RegCloseKey(hKey);

    //
    // InProcServer32
    //

    hModule=GetModuleHandleA("iislog.dll");
    if (hModule == NULL) {
        goto exit;
    }

    if (GetModuleFileName(hModule, szName, sizeof(szName)) == 0) {
        goto exit;
    }

    hKey = CreateKey(hRoot, "InProcServer32", szName);
    if ( hKey == NULL ) {
        goto exit;
    }

    if (RegSetValueExA(hKey,
                "ThreadingModel",
                NULL,
                REG_SZ,
                (LPBYTE)"Both",
                sizeof("Both")) != ERROR_SUCCESS) {

        RegCloseKey(hKey);
        goto exit;
    }

    RegCloseKey(hKey);

    //
    // Misc Status
    //

    hKey = CreateKey(hRoot,"MiscStatus","0");
    if ( hKey == NULL ) {
        goto exit;
    }

    hKey2 = CreateKey(hKey,"1","131473");
    if ( hKey2 == NULL ) {
        RegCloseKey(hKey);
        goto exit;
    }

    RegCloseKey(hKey2);
    RegCloseKey(hKey);

    //
    // ProgID
    //

    hKey = CreateKey(hRoot,"ProgID",ControlKey);
    if ( hKey == NULL ) {
        goto exit;
    }

    RegCloseKey(hKey);

    //
    // ToolboxBitmap32
    //

    {
        CHAR tmpBuf[MAX_PATH+1];
        strcpy(tmpBuf,szName);
        strcat(tmpBuf,", ");
        strcat(tmpBuf,BitmapIndex);

        hKey = CreateKey(hRoot,"ToolboxBitmap32",tmpBuf);
        if ( hKey == NULL ) {
            goto exit;
        }
        RegCloseKey(hKey);
    }

    //
    // TypeLib
    //

    hKey = CreateKey(hRoot,"TypeLib",TYPELIB_CLSID);
    if ( hKey == NULL ) {
        goto exit;
    }

    RegCloseKey(hKey);

    //
    // Version
    //

    hKey = CreateKey(hRoot,"Version","1.0");
    if ( hKey == NULL ) {
        goto exit;
    }

    RegCloseKey(hKey);

    //
    // Property page
    //

    RegCloseKey(hRoot);
    hRoot = NULL;

    hRoot = CreateKey(hCLSID, PPageClsId, PPageName);
    if ( hRoot == NULL ) {
        goto exit;
    }

    hKey = CreateKey(hRoot, "InProcServer32", szName );
    if ( hKey == NULL ) {
        goto exit;
    }

    RegCloseKey(hKey);

    fRet = TRUE;
exit:

    if ( hRoot != NULL ) {
        RegCloseKey(hRoot);
    }

    if ( hCLSID != NULL ) {
        RegCloseKey(hCLSID);
    }

    return fRet;

} // AddClsIdRegKeys


BOOL
CreateMetabaseKeys()
{
    USES_CONVERSION;

    typedef struct  _MB_PROP_
    {
        LPWSTR  wcsPath;
        DWORD   dwNameString;
        LPSTR   szHeaderName;
        DWORD   dwPropID;
        DWORD   dwPropMask;
        DWORD   dwDataType;
        DWORD   dwNodeID;
    }   MB_PROP;

    IMSAdminBase*   pMBCom;
    CHAR            szString[256];
    int             i;

    METADATA_HANDLE     hMeta = NULL;
    METADATA_RECORD     mdRecord;

    HRESULT             hr;

    MB_PROP mbProperties[] =
    {
        { L"Logging/Custom Logging/Date", IDS_DATE,
            EXTLOG_DATE_ID, MD_LOGEXT_FIELD_MASK, MD_EXTLOG_DATE, MD_LOGCUSTOM_DATATYPE_LPSTR, 1},

        { L"Logging/Custom Logging/Time", IDS_TIME,
            EXTLOG_TIME_ID, MD_LOGEXT_FIELD_MASK, MD_EXTLOG_TIME, MD_LOGCUSTOM_DATATYPE_LPSTR, 2},

        { L"Logging/Custom Logging/Extended Properties", IDS_EXTENDED_PROP,
            NULL, MD_LOGEXT_FIELD_MASK, 0, MD_LOGCUSTOM_DATATYPE_LPSTR, 3},

        { L"Logging/Custom Logging/Extended Properties/Client IP Address", IDS_CLIENT_IP_ADDRESS,
            EXTLOG_CLIENT_IP_ID, 0, MD_EXTLOG_CLIENT_IP, MD_LOGCUSTOM_DATATYPE_LPSTR, 5},

        { L"Logging/Custom Logging/Extended Properties/User Name", IDS_USER_NAME,
            EXTLOG_USERNAME_ID,  0, MD_EXTLOG_USERNAME, MD_LOGCUSTOM_DATATYPE_LPSTR, 6},

        { L"Logging/Custom Logging/Extended Properties/Service Name", IDS_SERVICE_NAME,
            EXTLOG_SITE_NAME_ID, 0, MD_EXTLOG_SITE_NAME, MD_LOGCUSTOM_DATATYPE_LPSTR, 7},

        { L"Logging/Custom Logging/Extended Properties/Server Name", IDS_SERVER_NAME,
            EXTLOG_COMPUTER_NAME_ID, 0, MD_EXTLOG_COMPUTER_NAME, MD_LOGCUSTOM_DATATYPE_LPSTR, 8},

        { L"Logging/Custom Logging/Extended Properties/Server IP", IDS_SERVER_IP,
            EXTLOG_SERVER_IP_ID, 0, MD_EXTLOG_SERVER_IP, MD_LOGCUSTOM_DATATYPE_LPSTR, 9},

        { L"Logging/Custom Logging/Extended Properties/Server Port", IDS_SERVER_PORT,
            EXTLOG_SERVER_PORT_ID, 0, MD_EXTLOG_SERVER_PORT, MD_LOGCUSTOM_DATATYPE_ULONG, 10},

        { L"Logging/Custom Logging/Extended Properties/Method", IDS_METHOD,
            EXTLOG_METHOD_ID, 0, MD_EXTLOG_METHOD, MD_LOGCUSTOM_DATATYPE_LPSTR, 11},

        { L"Logging/Custom Logging/Extended Properties/URI Stem", IDS_URI_STEM,
            EXTLOG_URI_STEM_ID, 0, MD_EXTLOG_URI_STEM, MD_LOGCUSTOM_DATATYPE_LPSTR, 12},

        { L"Logging/Custom Logging/Extended Properties/URI Query", IDS_URI_QUERY,
            EXTLOG_URI_QUERY_ID, 0, MD_EXTLOG_URI_QUERY, MD_LOGCUSTOM_DATATYPE_LPSTR, 13},

        { L"Logging/Custom Logging/Extended Properties/Protocol Status", IDS_HTTP_STATUS,
            EXTLOG_HTTP_STATUS_ID, 0, MD_EXTLOG_HTTP_STATUS, MD_LOGCUSTOM_DATATYPE_ULONG, 14},

        { L"Logging/Custom Logging/Extended Properties/Win32 Status", IDS_WIN32_STATUS,
            EXTLOG_WIN32_STATUS_ID, 0, MD_EXTLOG_WIN32_STATUS, MD_LOGCUSTOM_DATATYPE_ULONG, 15},

        { L"Logging/Custom Logging/Extended Properties/Bytes Sent", IDS_BYTES_SENT,
            EXTLOG_BYTES_SENT_ID, 0, MD_EXTLOG_BYTES_SENT, MD_LOGCUSTOM_DATATYPE_ULONG, 16},

        { L"Logging/Custom Logging/Extended Properties/Bytes Received", IDS_BYTES_RECEIVED,
            EXTLOG_BYTES_RECV_ID, 0, MD_EXTLOG_BYTES_RECV, MD_LOGCUSTOM_DATATYPE_ULONG, 17},

        { L"Logging/Custom Logging/Extended Properties/Time Taken", IDS_TIME_TAKEN,
            EXTLOG_TIME_TAKEN_ID, 0, MD_EXTLOG_TIME_TAKEN, MD_LOGCUSTOM_DATATYPE_ULONG, 18},

        { L"Logging/Custom Logging/Extended Properties/Protocol Version", IDS_PROTOCOL_VERSION,
            EXTLOG_PROTOCOL_VERSION_ID, 0, MD_EXTLOG_PROTOCOL_VERSION, MD_LOGCUSTOM_DATATYPE_LPSTR, 19},

        { L"Logging/Custom Logging/Extended Properties/Host", IDS_HOST,
            EXTLOG_HOST_ID, 0, EXTLOG_HOST, MD_LOGCUSTOM_DATATYPE_LPSTR, 20},

        { L"Logging/Custom Logging/Extended Properties/User Agent", IDS_USER_AGENT,
            EXTLOG_USER_AGENT_ID, 0, MD_EXTLOG_USER_AGENT, MD_LOGCUSTOM_DATATYPE_LPSTR, 21},

        { L"Logging/Custom Logging/Extended Properties/Cookie", IDS_COOKIE,
            EXTLOG_COOKIE_ID, 0, MD_EXTLOG_COOKIE, MD_LOGCUSTOM_DATATYPE_LPSTR, 22},

        { L"Logging/Custom Logging/Extended Properties/Referer", IDS_REFERER,
            EXTLOG_REFERER_ID, 0, MD_EXTLOG_REFERER, MD_LOGCUSTOM_DATATYPE_LPSTR, 23},

        { L"Logging/Custom Logging/Extended Properties/Protocol Substatus", IDS_HTTP_SUB_STATUS,
            EXTLOG_HTTP_SUB_STATUS_ID, 0, MD_EXTLOG_HTTP_SUB_STATUS, MD_LOGCUSTOM_DATATYPE_ULONG, 32},

        { L"\0", 0, NULL, 0, 0, 0 },
    };

    //
    // Open the metabase path
    //

    if ( FAILED( CoCreateInstance(GETAdminBaseCLSID(TRUE), NULL, CLSCTX_LOCAL_SERVER,
                            IID_IMSAdminBase, (void **)(&pMBCom) )))
    {
        return FALSE;
    }

    // Create the LM key
    if ( FAILED( pMBCom->OpenKey( METADATA_MASTER_ROOT_HANDLE, L"/",
                          METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE, MB_TIMEOUT,
                          &hMeta) ))
    {
        // Create the LM key
        pMBCom->Release();
        return FALSE;
    }

    hr = pMBCom->AddKey( hMeta, L"LM");
    if ( FAILED(hr) && (HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS) != hr))
    {
        goto cleanup;
    }
    pMBCom->CloseKey(hMeta);
    hMeta = NULL;


    if ( FAILED( pMBCom->OpenKey( METADATA_MASTER_ROOT_HANDLE, L"LM",
                            METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE, MB_TIMEOUT,
                            &hMeta) ))
    {
        pMBCom->Release();
        return FALSE;
    }

    //
    // Create the initial set of Keys.
    //

    hr = pMBCom->AddKey( hMeta, L"Logging");

    if ( FAILED(hr) && (HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS) != hr))
    {
       goto cleanup;
    }

    hr = pMBCom->AddKey( hMeta, L"Logging/Custom Logging");

    if ( FAILED(hr) && (HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS) != hr))
    {
       goto cleanup;
    }

    //
    // Set all the properties
    //

    mdRecord.dwMDUserType    = IIS_MD_UT_SERVER;

    for (i=0; 0 != mbProperties[i].wcsPath[0]; i++)
    {

        hr = pMBCom->AddKey( hMeta, mbProperties[i].wcsPath);

        if ( FAILED(hr) && (HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS) != hr))
        {
            goto cleanup;
        }

        // don't overwrite it entry already exist.
        if ( SUCCEEDED(hr) || (HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS) != hr))
        {
        // We won't get here if the key already exists.
        mdRecord.dwMDAttributes = METADATA_INHERIT;    // name and header is not inheritable.

        mdRecord.dwMDDataType   = STRING_METADATA;

        if ( (0 != mbProperties[i].dwNameString) &&
             (0 < LoadString( hDLLInstance, mbProperties[i].dwNameString, szString, sizeof(szString)) )
           )
        {
            mdRecord.dwMDIdentifier = MD_LOGCUSTOM_PROPERTY_NAME;
            mdRecord.pbMDData       = (PBYTE)A2W(szString);
            mdRecord.dwMDDataLen    = (DWORD)((sizeof(WCHAR)/sizeof(BYTE)) * (wcslen((LPWSTR) mdRecord.pbMDData)+1));

            if ( FAILED(pMBCom->SetData( hMeta, mbProperties[i].wcsPath, &mdRecord)) )
            {
                goto cleanup;
            }
        }

        if ( NULL != mbProperties[i].szHeaderName)
        {
            mdRecord.dwMDIdentifier = MD_LOGCUSTOM_PROPERTY_HEADER;
            mdRecord.pbMDData       = (PBYTE) (A2W(mbProperties[i].szHeaderName));
            mdRecord.dwMDDataLen    = (DWORD)((sizeof(WCHAR)/sizeof(BYTE)) * (wcslen((LPWSTR) mdRecord.pbMDData)+1));

            if ( FAILED(pMBCom->SetData( hMeta, mbProperties[i].wcsPath, &mdRecord)) )
            {
                goto cleanup;
            }
        }

        mdRecord.dwMDDataType   = DWORD_METADATA;
        mdRecord.dwMDDataLen    = sizeof(DWORD);

        if ( 0 != mbProperties[i].dwPropID)
        {
            mdRecord.dwMDIdentifier = MD_LOGCUSTOM_PROPERTY_ID;
            mdRecord.pbMDData       = (PBYTE) &(mbProperties[i].dwPropID);

            if ( FAILED(pMBCom->SetData( hMeta, mbProperties[i].wcsPath, &mdRecord)) )
            {
                goto cleanup;
            }
        }

        if ( 0 != mbProperties[i].dwPropMask)
        {
            mdRecord.dwMDIdentifier = MD_LOGCUSTOM_PROPERTY_MASK;
            mdRecord.pbMDData       = (PBYTE) &(mbProperties[i].dwPropMask);

            if ( FAILED(pMBCom->SetData( hMeta, mbProperties[i].wcsPath, &mdRecord)) )
            {
                goto cleanup;
            }
        }

        if ( 0 != mbProperties[i].dwNodeID)
        {
            mdRecord.dwMDIdentifier = MD_LOGCUSTOM_PROPERTY_NODE_ID;
            mdRecord.pbMDData       = (PBYTE) &(mbProperties[i].dwNodeID);

            if ( FAILED(pMBCom->SetData( hMeta, mbProperties[i].wcsPath, &mdRecord)) )
            {
                goto cleanup;
            }
        }

        mdRecord.dwMDIdentifier = MD_LOGCUSTOM_PROPERTY_DATATYPE;
        mdRecord.pbMDData       = (PBYTE) &(mbProperties[i].dwDataType);

        if ( FAILED(pMBCom->SetData( hMeta, mbProperties[i].wcsPath, &mdRecord)) )
        {
            goto cleanup;
        }

        WCHAR   wcsKeyType[] = L"IIsCustomLogModule";

        MD_SET_DATA_RECORD (    &mdRecord,
                                MD_KEY_TYPE,
                                METADATA_NO_ATTRIBUTES,
                                IIS_MD_UT_SERVER,
                                STRING_METADATA,
                                sizeof(wcsKeyType),
                                wcsKeyType
                              );

        if ( FAILED(pMBCom->SetData( hMeta, mbProperties[i].wcsPath, &mdRecord)) )
        {
          goto cleanup;
        }
        }
   }

    //
    // Set the Key Type and Services List Property
    //

    {
        WCHAR   wcsKeyType[] = L"IIsCustomLogModule";

        MD_SET_DATA_RECORD (    &mdRecord,
                                MD_KEY_TYPE,
                                METADATA_NO_ATTRIBUTES,
                                IIS_MD_UT_SERVER,
                                STRING_METADATA,
                                sizeof(wcsKeyType),
                                wcsKeyType
                              );

        if ( FAILED(pMBCom->SetData( hMeta, L"Logging/Custom Logging", &mdRecord)) )
        {
          goto cleanup;
        }

        WCHAR   wcsServices[] = L"W3SVC\0MSFTPSVC\0SMTPSVC\0NNTPSVC\0";


        MD_SET_DATA_RECORD (    &mdRecord,
                                MD_LOGCUSTOM_SERVICES_STRING,
                                METADATA_INHERIT,
                                IIS_MD_UT_SERVER,
                                MULTISZ_METADATA,
                                sizeof(wcsServices),
                                wcsServices
                            );

        if ( FAILED(pMBCom->SetData( hMeta, L"Logging/Custom Logging", &mdRecord)) )
        {
            goto cleanup;
        }

    }

    //
    // Set the Admin ACL to allow everyone to read the /LM/Logging tree. This is to allow
    // operators to effectively use the ILogScripting components.
    //

    if (FAILED(SetAdminACL(pMBCom, hMeta, L"Logging")))
    {
        goto cleanup;
    }
    if (NULL != hMeta)
    {
        pMBCom->CloseKey(hMeta);
    }
    pMBCom->Release();
    return TRUE;

cleanup:
    if (NULL != hMeta)
    {
        pMBCom->CloseKey(hMeta);
    }
    pMBCom->Release();

    return FALSE;

}

HRESULT SetAdminACL(
    IMSAdminBase *      pAdminBase,
    METADATA_HANDLE     hMeta,
    LPWSTR              wszKeyName
    )
{
    BOOL                    b = FALSE;
    DWORD                   dwLength = 0;

    PSECURITY_DESCRIPTOR    pSD = NULL;
    PSECURITY_DESCRIPTOR    outpSD = NULL;
    DWORD                   cboutpSD  = 0;
    PACL                    pACLNew = NULL;
    DWORD                   cbACL = 0;
    PSID                    pAdminsSID = NULL;
    BOOL                    bWellKnownSID = FALSE;
    METADATA_RECORD         mdr;
    HRESULT                 hr = NO_ERROR;

    // Initialize a new security descriptor
    pSD = (PSECURITY_DESCRIPTOR) LocalAlloc(LPTR, SECURITY_DESCRIPTOR_MIN_LENGTH);
    // BugFix: 57647 Whistler
    //         Prefix bug pSD being used when NULL.
    //         EBK 5/5/2000
    if (pSD == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION);

    // Get Local Admins Sid
    GetPrincipalSID (_T("Administrators"), &pAdminsSID, &bWellKnownSID);

    // Initialize a new ACL, which only contains 2 aaace
    cbACL = sizeof(ACL) +
        (sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid(pAdminsSID) - sizeof(DWORD));
    pACLNew = (PACL) LocalAlloc(LPTR, cbACL);

    // BugFix: 57646 Whistler
    //         Prefix bug pACLNew being used when NULL.
    //         EBK 5/5/2000
    if (pACLNew == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    InitializeAcl(pACLNew, cbACL, ACL_REVISION);

    AddAccessAllowedAce(
        pACLNew,
        ACL_REVISION,
        MD_ACR_READ | MD_ACR_WRITE | MD_ACR_RESTRICTED_WRITE | MD_ACR_UNSECURE_PROPS_READ | MD_ACR_ENUM_KEYS | MD_ACR_WRITE_DAC,
        pAdminsSID);

    // Add the ACL to the security descriptor
    b = SetSecurityDescriptorDacl(pSD, TRUE, pACLNew, FALSE);
    b = SetSecurityDescriptorOwner(pSD, pAdminsSID, TRUE);
    b = SetSecurityDescriptorGroup(pSD, pAdminsSID, TRUE);

    // Security descriptor blob must be self relative
    b = MakeSelfRelativeSD(pSD, outpSD, &cboutpSD);
    outpSD = (PSECURITY_DESCRIPTOR)GlobalAlloc(GPTR, cboutpSD);

    // BugFix: 57648, 57649 Whistler
    //         Prefix bug outpSD being used when NULL.
    //         EBK 5/5/2000
    if (outpSD == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    // BugFix: 57649 Whistler
    //         Prefix bug outpSD being used when not inintalized.
    //         EmilyK 2/19/2001
    if ( !MakeSelfRelativeSD( pSD, outpSD, &cboutpSD ) )
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto cleanup;
    }


    // below this modify pSD to outpSD

    // Apply the new security descriptor to the file
    dwLength = GetSecurityDescriptorLength(outpSD);

    mdr.dwMDIdentifier = MD_ADMIN_ACL;
    mdr.dwMDAttributes = METADATA_INHERIT | METADATA_REFERENCE | METADATA_SECURE;
    mdr.dwMDUserType = IIS_MD_UT_SERVER;
    mdr.dwMDDataType = BINARY_METADATA;
    mdr.dwMDDataLen = dwLength;
    mdr.pbMDData = (LPBYTE)outpSD;

    hr = pAdminBase->SetData(hMeta, wszKeyName, &mdr);

cleanup:
    // both of Administrators and Everyone are well-known SIDs, use FreeSid() to free them.
    if (outpSD)
        GlobalFree(outpSD);

    if (pAdminsSID)
        FreeSid(pAdminsSID);
    if (pSD)
        LocalFree((HLOCAL) pSD);
    if (pACLNew)
        LocalFree((HLOCAL) pACLNew);

    return (hr);
}


DWORD
GetPrincipalSID (
    LPTSTR Principal,
    PSID *Sid,
    BOOL *pbWellKnownSID
    )
{
    SID_IDENTIFIER_AUTHORITY SidIdentifierNTAuthority = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY SidIdentifierWORLDAuthority = SECURITY_WORLD_SID_AUTHORITY;
    PSID_IDENTIFIER_AUTHORITY pSidIdentifierAuthority = NULL;
    BYTE Count = 0;
    DWORD dwRID[8];

    *pbWellKnownSID = TRUE;
    memset(&(dwRID[0]), 0, 8 * sizeof(DWORD));
    if ( lstrcmp(Principal,_T("Administrators")) == 0 ) {
        // Administrators group
        pSidIdentifierAuthority = &SidIdentifierNTAuthority;
        Count = 2;
        dwRID[0] = SECURITY_BUILTIN_DOMAIN_RID;
        dwRID[1] = DOMAIN_ALIAS_RID_ADMINS;
    } else if ( lstrcmp(Principal,_T("System")) == 0) {
        // SYSTEM
        pSidIdentifierAuthority = &SidIdentifierNTAuthority;
        Count = 1;
        dwRID[0] = SECURITY_LOCAL_SYSTEM_RID;
    } else if ( lstrcmp(Principal,_T("Interactive")) == 0) {
        // INTERACTIVE
        pSidIdentifierAuthority = &SidIdentifierNTAuthority;
        Count = 1;
        dwRID[0] = SECURITY_INTERACTIVE_RID;
    } else if ( lstrcmp(Principal,_T("Everyone")) == 0) {
        // Everyone
        pSidIdentifierAuthority = &SidIdentifierWORLDAuthority;
        Count = 1;
        dwRID[0] = SECURITY_WORLD_RID;
    } else {
        *pbWellKnownSID = FALSE;
    }

    if (*pbWellKnownSID) {
        if ( !AllocateAndInitializeSid(pSidIdentifierAuthority,
                                    (BYTE)Count,
                                    dwRID[0],
                                    dwRID[1],
                                    dwRID[2],
                                    dwRID[3],
                                    dwRID[4],
                                    dwRID[5],
                                    dwRID[6],
                                    dwRID[7],
                                    Sid) )
        return GetLastError();
    } else {
        // get regular account sid
        DWORD        sidSize;
        TCHAR        refDomain [256];
        DWORD        refDomainSize;
        DWORD        returnValue;
        SID_NAME_USE snu;

        sidSize = 0;
        refDomainSize = 255;

        LookupAccountName (NULL,
                           Principal,
                           *Sid,
                           &sidSize,
                           refDomain,
                           &refDomainSize,
                           &snu);

        returnValue = GetLastError();
        if (returnValue != ERROR_INSUFFICIENT_BUFFER)
            return returnValue;

        *Sid = (PSID) malloc (sidSize);
        refDomainSize = 255;

        if (!LookupAccountName (NULL,
                                Principal,
                                *Sid,
                                &sidSize,
                                refDomain,
                                &refDomainSize,
                                &snu))
        {
            return GetLastError();
        }
    }

    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\log\scripting\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\log\plugin\ncslogc.cpp ===
/*++

   Copyright    (c)    1995-1996    Microsoft Corporation

   Module  Name :
      nsclogp.cpp

   Abstract:
      NCSA Logging Format implementation

   Author:

       Terence Kwan    ( terryk )    18-Sep-1996

   Project:

       IIS Logging 3.0

--*/


#include "precomp.hxx"
#include <stdio.h>
#include <script.h>
#include "LogScript.hxx"
#include <ilogobj.hxx>
#include "filectl.hxx"
#include "ncslogc.hxx"

CHAR    szNCSANoPeriodPattern[] = "ncsa*.log";

// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------

CNCSALOG::CNCSALOG()
{
    //
    // set the time zone offset
    //

    {
        TIME_ZONE_INFORMATION tzTimeZone;
        DWORD dwError;
        DWORD minutes;
        DWORD hours;
        LONG bias;
        CHAR szTmp[MAX_PATH];

        dwError = GetTimeZoneInformation(&tzTimeZone);

        if ( dwError == 0xffffffff ) {

            bias = 0;
        } else {

            bias = tzTimeZone.Bias;
        }

        if ( bias > 0 ) 
        {
            lstrcpyA(m_szGMTOffset,"-");
            m_GMTDateCorrection = -1;

        } 
        else 
        {
            lstrcpyA(m_szGMTOffset,"+");
            m_GMTDateCorrection = 1;
            bias *= -1;
        }

        hours = bias/60;
        minutes = bias % 60;

        //
        // set up the "+0800" or "-0800" NCSA information
        //

        wsprintfA(szTmp,"%02lu",hours);
        lstrcatA(m_szGMTOffset,szTmp);

        wsprintfA(szTmp,"%02lu",minutes);
        lstrcatA(m_szGMTOffset,szTmp);

        m_GMTDateCorrection = m_GMTDateCorrection * ( hours/24.0 + minutes/60.0 );

    }
} // CNCSALOG::CNCSALOG()

// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------

CNCSALOG::~CNCSALOG()
{
}

// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------

LPCSTR
CNCSALOG::QueryNoPeriodPattern(
    VOID
    )
{
    return szNCSANoPeriodPattern;
} // CNCSALOG::QueryNoPeriodPattern

// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------

VOID
CNCSALOG::FormNewLogFileName(
                IN LPSYSTEMTIME pstNow
                )
/*++
  This function that forms the new log file name based on
   type of periodic logging done.

  Arguments:
    pstNow     pointer to SystemTime which contains the current time.

  Returns:
    TRUE on success in forming the name or FALSE if there is any error.

--*/
{

    I_FormNewLogFileName(pstNow,DEFAULT_NCSA_LOG_FILE_NAME);
    return;

} // INET_FILE_LOG::FormNewLogFileName()

// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------

BOOL
CNCSALOG::FormatLogBuffer(
         IN IInetLogInformation *pLogObj,
         IN LPSTR                pBuf,
         IN DWORD                *pcbSize,
         OUT SYSTEMTIME          *pLocalTime
        )
{
    CHAR  rgchDateTime[32];
    PCHAR pBuffer = pBuf;
    DWORD nRequired = 0;

    PCHAR pTmp;
    DWORD cbTmp;
    BOOL  fUseBytesSent = TRUE;

    if ( pBuf == NULL ) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // We use local time
    //

    GetLocalTime(pLocalTime);

    INT cchDateTime = wsprintf( rgchDateTime,
                        _T(" [%02d/%s/%d:%02d:%02d:%02d %s] "),
                        pLocalTime->wDay,
                        Month3CharNames(pLocalTime->wMonth-1),
                        pLocalTime->wYear,
                        pLocalTime->wHour,
                        pLocalTime->wMinute,
                        pLocalTime->wSecond,
                        m_szGMTOffset
                        );

    //
    // Format is:
    // Host - UserName [date] Operation Target status bytes
    //

    //
    // HostName
    //

    pTmp = pLogObj->GetClientHostName( NULL, &cbTmp );
    if ( cbTmp == 0 ) {
        cbTmp = 1;
        pTmp = "-";
    }

    nRequired += cbTmp;
    if ( nRequired <= *pcbSize ) {
        CopyMemory(pBuffer, pTmp, cbTmp);
        pBuffer += cbTmp;
    }

    //
    // Append " - "
    //

    cbTmp = 3;
    pTmp = " - ";

    nRequired += cbTmp;
    if ( nRequired <= *pcbSize ) {
        CopyMemory(pBuffer, pTmp, cbTmp);
        pBuffer += cbTmp;
    }

    //
    // append user name
    //

    pTmp = pLogObj->GetClientUserName( NULL, &cbTmp );
    if ( cbTmp == 0 ) {
        cbTmp = 1;
        pTmp = "-";
    }

    nRequired += cbTmp;
    if ( nRequired <= *pcbSize ) {
        CopyMemory(pBuffer, pTmp, cbTmp);
        pBuffer += cbTmp;
    }

    //
    // append date time
    //

    pTmp = rgchDateTime;
    cbTmp = cchDateTime;

    nRequired += cbTmp;
    if ( nRequired <= *pcbSize ) {
        CopyMemory(pBuffer, pTmp, cbTmp);
        pBuffer += cbTmp;
    }

    //
    // Operation
    //

    pTmp = pLogObj->GetOperation( NULL, &cbTmp );
    if ( cbTmp == 0 ) {
        cbTmp = 1;
        pTmp = "-";
    } else {
        if ( (_stricmp(pTmp,"PUT") == 0) ||
             (_stricmp(pTmp,"POST") == 0) ) {
            fUseBytesSent = FALSE;
        }
    }

    nRequired += (cbTmp + 1 + 1);   // +1 for delimeter, +1 for \"
    if ( nRequired <= *pcbSize ) {

        *(pBuffer++) = '\"';
        CopyMemory(pBuffer, pTmp, cbTmp);
        pBuffer += cbTmp;

        //
        // Add space delimiter
        //

        *(pBuffer++) = ' ';
    }

    //
    // Target
    //

    pTmp = pLogObj->GetTarget( NULL, &cbTmp );
    if ( cbTmp == 0 ) {
        cbTmp = 1;
        pTmp = "-";
    }

    nRequired += cbTmp;
    if ( nRequired <= *pcbSize ) {
        CopyMemory(pBuffer, pTmp, cbTmp);
        pBuffer += cbTmp;
    }

    //
    // Parameters
    //

    pTmp = pLogObj->GetParameters( NULL, &cbTmp );
    
    if ( cbTmp != 0 ) {

        nRequired += cbTmp + 1;     // 1 for ?
        if ( nRequired <= *pcbSize ) {
            *(pBuffer++) = '?';
            CopyMemory(pBuffer, pTmp, cbTmp);
            pBuffer += cbTmp;
        }
    }
    
    //
    // close request block version + status + bytes
    //

    {
        CHAR tmpBuf[MAX_PATH];
        DWORD bytes;

        PCHAR pVersion = pLogObj->GetVersionString(NULL, &cbTmp);

        if (cbTmp ==0) {
            pVersion = "HTTP/1.0";
            cbTmp    = 8;
        }

        nRequired += cbTmp + 1 + 1 + 1;   // 1 for beginning delimiter, 1 for ", 1 for ending delimiter
        
        if ( nRequired <= *pcbSize ) {
            *(pBuffer++) = ' ';
            CopyMemory(pBuffer, pVersion, cbTmp);
            pBuffer += cbTmp;
            *(pBuffer++) = '"';
            *(pBuffer++) = ' ';
        }
        
        cbTmp = FastDwToA(tmpBuf, pLogObj->GetProtocolStatus());
        *(tmpBuf+cbTmp) = ' ';
        cbTmp++;

        bytes = fUseBytesSent ? pLogObj->GetBytesSent( ) :
                                pLogObj->GetBytesRecvd( );
        cbTmp += FastDwToA( tmpBuf+cbTmp, bytes);

        *(tmpBuf+cbTmp)   = '\r';
        *(tmpBuf+cbTmp+1) = '\n';
        cbTmp += 2;

        nRequired += cbTmp;
        if ( nRequired <= *pcbSize ) {
            CopyMemory(pBuffer, tmpBuf, cbTmp);
            pBuffer += cbTmp;
        }
    }

    if ( nRequired > *pcbSize ) {
        *pcbSize = nRequired;
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return(FALSE);
    } else {
        *pcbSize = nRequired;
        return(TRUE);
    }
} // CNCSALOG::FormatLogBuffer

// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------

HRESULT 
CNCSALOG::ReadFileLogRecord(
    IN  FILE                *fpLogFile, 
    IN  LPINET_LOGLINE       pInetLogLine,
    IN  PCHAR                pszLogLine,
    IN  DWORD                dwLogLineSize
)
{
    CHAR * pszTimeZone;
    CHAR * pCh;

    CHAR * szDateString, * szTimeString;
    double GMTCorrection;
    int    iSign = 1;

getnewline:

    pCh = pszLogLine;
    
    if (fgets(pCh, dwLogLineSize, fpLogFile) == NULL)
    {
        return E_FAIL;
    }

    pCh = SkipWhite(pCh);
    
    if (('\n' == *pCh) || ('\0' == *pCh))
    {
        // Empty line. Get Next line

        goto getnewline;
    }

    //
    // We have a log line. 
    //
    // Format is:
    // Host - UserName [date] Operation Target status bytes
    //

    if ( NULL == (pCh = strtok(pCh," \t\r\n")) )
    {
        return E_FAIL;
    }
    pInetLogLine->pszClientHostName = pCh; 

    //
    // This field is always "-"
    //
    if ( ( NULL == (pCh = strtok(NULL," \t\r\n")) )||
         ('-' != *pCh) )
    {
        return E_FAIL;
    }

    if ( NULL == (pCh = strtok(NULL," \t\r\n")) )
    {
        return E_FAIL;
    }
    pInetLogLine->pszClientUserName = pCh;

    //
    // This is the date field. It starts with a [, followed by date:time timezone]
    //

    pCh += strlen(pCh)+1;
    if (*pCh != '[') 
    {
        return E_FAIL;
    }
    pCh++;


    if ( NULL == (pCh = strtok(pCh,":")) )
    {
        return E_FAIL;
    }
    szDateString = pCh;
    

    if ( NULL == (pCh = strtok(NULL," \t\r\n")) )
    {
        return E_FAIL;
    }
    szTimeString = pCh;
    
    pCh = strtok(NULL," \t\r\n");
    if ( (NULL == pCh) || ( ']' != *(pCh+strlen(pCh)-1)) || (strlen(pCh) < 4))
    {
        return E_FAIL;
    }
    pszTimeZone = pCh;

    //
    // Time Zone is in format [+/-]HHMM. Convert this to GMT and DATE format
    //
    
    if ( ! ConvertNCSADateToVariantDate(szDateString, szTimeString, &(pInetLogLine->DateTime)) )
    {
        return E_FAIL;
    }

    if (*pCh == '-')
    {
        iSign = -1;
        pszTimeZone = pCh+1;
    }
    else if (*pCh == '+')
    {
        iSign = 1;
        pszTimeZone = pCh+1;
    }

    GMTCorrection = (pszTimeZone[0]-'0' +pszTimeZone[1]-'0')/24.0 + 
                    (pszTimeZone[2]-'0' +pszTimeZone[3]-'0')/60.0;

    pInetLogLine->DateTime -= iSign*GMTCorrection;

    //
    // The Query String. Starts with " followed by method target version"
    //

    pCh += strlen(pCh)+1;
    *(pCh-2)='\0';                      // Zero out the ] for the time zone
    if ('"' != *pCh) 
    {
        return E_FAIL;
    }

    pCh++;

    
    if ( NULL == (pCh = strtok(pCh," \t\r\n")) )
    {
        return E_FAIL;
    }
    pInetLogLine->pszOperation = pCh;

    if ( NULL == (pCh = strtok(NULL," \t\r\n")) )
    {
        return E_FAIL;
    }
    pInetLogLine->pszTarget = pCh;

    //
    // In the Target, Parameters are separated by ?
    //
    pInetLogLine->pszParameters = strchr(pCh, '?');

    if (pInetLogLine->pszParameters != NULL)
    {
        *(pInetLogLine->pszParameters)='\0';
        (pInetLogLine->pszParameters)++;
    }

    pCh = strtok(NULL," \t\r\n");
    if ( (NULL == pCh) || ('"' != *(pCh+strlen(pCh)-1)) )
    {
        return E_FAIL;
    }
    pInetLogLine->pszVersion = pCh;

    //
    // Now the status code & bytes sent
    //

    pCh += strlen(pCh)+1;
    *(pCh-2)='\0';                      // Zero out the " for the version string

    if ( NULL == (pCh = strtok(pCh," \t\r\n")) )
    {
        return E_FAIL;
    }
    pInetLogLine->pszProtocolStatus = pCh;
  
    if ( NULL == (pCh = strtok(NULL," \t\r\n")) )
    {
        return E_FAIL;
    }
    pInetLogLine->pszBytesSent = pCh;

    return S_OK;
}


// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------

HRESULT
CNCSALOG::WriteFileLogRecord(
            IN  FILE            *fpLogFile, 
            IN  ILogScripting   *pILogScripting,
            IN  bool
        )
{

    HRESULT hr = E_FAIL;
    CHAR    szLogLine[4096];  
    DWORD   dwIndex = 0;

    //
    // Format is:
    // Host - UserName [date] Operation Target status bytes
    //

    VARIANT    szHostName, szUserName, szOperation, szTarget, szParameters, szProtocolVersion;
    VARIANT    DateTime;
    VARIANT    lBytesSent, lProtocolStatus;

    SYSTEMTIME  localTime; 

    if (SUCCEEDED(pILogScripting->get_ClientIP      ( &szHostName))     &&
        SUCCEEDED(pILogScripting->get_UserName      ( &szUserName))     &&   
        SUCCEEDED(pILogScripting->get_DateTime      ( &DateTime))       &&
        SUCCEEDED(pILogScripting->get_Method        ( &szOperation))    &&
        SUCCEEDED(pILogScripting->get_URIStem       ( &szTarget))       &&
        SUCCEEDED(pILogScripting->get_URIQuery      ( &szParameters))   &&
        SUCCEEDED(pILogScripting->get_BytesSent     ( &lBytesSent))     &&
        SUCCEEDED(pILogScripting->get_ProtocolStatus( &lProtocolStatus))&&
        SUCCEEDED(pILogScripting->get_ProtocolVersion( &szProtocolVersion))&&
        VariantTimeToSystemTime( DateTime.date+m_GMTDateCorrection, &localTime)
        )
    {


        sprintf(szLogLine, "%ws - %ws [%02d/%s/%d:%02d:%02d:%02d %s] \"%ws %ws", 
                    GetBstrFromVariant( &szHostName), 
                    GetBstrFromVariant( &szUserName), 
                    localTime.wDay, 
                    Month3CharNames(localTime.wMonth-1), 
                    localTime.wYear, 
                    localTime.wHour, 
                    localTime.wMinute, 
                    localTime.wSecond,
                    m_szGMTOffset, 
                    GetBstrFromVariant( &szOperation), 
                    GetBstrFromVariant( &szTarget)
                );

        if ( ( VT_NULL != szParameters.vt) &&
             ( VT_EMPTY != szParameters.vt )
           )
        {
            sprintf(szLogLine+strlen(szLogLine), "?%ws", GetBstrFromVariant( &szParameters));
        }

        sprintf(szLogLine+strlen(szLogLine), " %ws\"", GetBstrFromVariant( &szProtocolVersion));

        dwIndex = (DWORD)strlen(szLogLine);

        szLogLine[dwIndex++] = ' ';
        dwIndex += GetLongFromVariant( &lProtocolStatus, szLogLine+dwIndex );

        szLogLine[dwIndex++] = ' ';
        dwIndex += GetLongFromVariant( &lBytesSent, szLogLine+dwIndex );
        szLogLine[dwIndex++] = '\0';

        fprintf(fpLogFile, "%s\n", szLogLine);

        hr = S_OK;
    }

    return hr;
}

// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------

BOOL
CNCSALOG::ConvertNCSADateToVariantDate(PCHAR szDateString, PCHAR szTimeString, DATE * pDateTime)
{

    PCHAR   pCh;
    WORD    iVal;
    CHAR    *szMonths[12] = {"Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"};

    SYSTEMTIME  sysTime;

    //
    // Process the Date. Format is 23/Sep/1997 ( Day/Month/Year )
    //

    pCh = szDateString;
    
    iVal = *pCh -'0';
    if ( *(pCh+1) != '/')
    {
        iVal = iVal*10 + *(pCh+1) - '0';
        pCh++;
    }
    sysTime.wDay = iVal;

    pCh += 2;

    for (WORD i=0; i<12;i++)
    {
        if ( 0 == strncmp(pCh,szMonths[i],3) )
        {
            sysTime.wMonth = i+1;
            break;
        }
    }

    pCh += 4;

    sysTime.wYear = (*pCh-'0')*1000 + ( *(pCh+1)-'0' )*100 + 
                    ( *(pCh+2)-'0')*10 + ( *(pCh+3)-'0');

    //
    // Process the Time. Format is 10:47:44 ( HH:MM:SS )
    //

    pCh = szTimeString;

    iVal = *pCh -'0';
    if ( *(pCh+1) != ':')
    {
        iVal = iVal*10 + *(pCh+1) - '0';
        pCh++;
    }
    sysTime.wHour = iVal;
    
    pCh += 2;

    iVal = *pCh -'0';
    if ( *(pCh+1) != ':')
    {
        iVal = iVal*10 + *(pCh+1) - '0';
        pCh++;
    }
    sysTime.wMinute = iVal;

    pCh += 2;

    iVal = *pCh -'0';
    if ( *(pCh+1) != '\0')
    {
        iVal = iVal*10 + *(pCh+1) - '0';
    }
    sysTime.wSecond = iVal;

    return SystemTimeToVariantTime(&sysTime, pDateTime);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\log\scripting\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by script.rc
//
#define IDS_PROJNAME                    100
#define IDR_LOGSCRIPTING                101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\log\plugin\logscript.cpp ===
/*++

   Copyright    (c)    1998    Microsoft Corporation

   Module  Name :
      logscript.cpp

   Abstract:
      Base implementation for ILogScripting - Automation compatible logging interface

   Author:

       Saurab Nog    ( saurabn )    01-Feb-1998

   Project:

       IIS Logging 5.0

--*/

#include "precomp.hxx"
#include <stdio.h>
#include <script.h>
#include <LogScript.hxx>

extern DWORD FastDwToA(CHAR*   pBuf, DWORD   dwV);


/* ************************************************************************* */
/* ************************************************************************* */

CLogScript::CLogScript( 
    VOID
)
:
    m_pInputLogFile         ( NULL),
    m_pOutputLogFile        ( NULL),
    m_strInputLogFileName   ( ),
    m_pszLogLine            ( NULL),
    m_dwLogLineSize         ( 0)
{
    INITIALIZE_CRITICAL_SECTION( &m_csLock );
    ReadInetLogLine.iCustomFieldsCount = 0;
    ResetInetLogLine(ReadInetLogLine);

    m_szEmpty = A2BSTR("-");
}

/* ************************************************************************* */
/* ************************************************************************* */

CLogScript::~CLogScript(
    VOID
)
{
    LockCS();

    if ( m_pInputLogFile!=NULL) {
        fclose(m_pInputLogFile);
        m_pInputLogFile = NULL;
    }

    if ( (m_pszLogLine != NULL) && (m_dwLogLineSize != 0))
    {
        delete [] m_pszLogLine;
    }
    
    UnlockCS();
    DeleteCriticalSection( &m_csLock );
}

/* ************************************************************************* */
/* ************************************************************************* */

void 
CLogScript::ResetInetLogLine(INET_LOGLINE& InetLogLine)
{
    InetLogLine.pszClientHostName = NULL;
    InetLogLine.pszClientUserName = NULL;
    InetLogLine.pszServerAddress  = NULL;     // input ip address for connection
    InetLogLine.pszOperation      = NULL;     //  eg: 'get'  in FTP
    InetLogLine.pszTarget         = NULL;     // target path/machine name
    InetLogLine.pszParameters     = NULL;     // string containing parameters.
    InetLogLine.pszVersion        = NULL;     // protocol version string.
    InetLogLine.pszHTTPHeader     = NULL;     // Header Information
    InetLogLine.pszBytesSent      = NULL;     // count of bytes sent
    InetLogLine.pszBytesRecvd     = NULL;     // count of bytes recvd
    InetLogLine.pszTimeForProcessing = NULL;  // time required for processing
    InetLogLine.pszWin32Status    = NULL;     // Win32 error code. 0 for success
    InetLogLine.pszProtocolStatus = NULL;     // status: whatever service wants.
    InetLogLine.pszPort           = NULL;
    InetLogLine.pszSiteName       = NULL;     // Site name (not put in https log)
    InetLogLine.pszComputerName   = NULL;     // netbios name of Server

    InetLogLine.DateTime          = 0;        // Date & Time

    InetLogLine.pszUserAgent       = NULL;    // User Agent - Browser type
    InetLogLine.pszCookie          = NULL;
    InetLogLine.pszReferer         = NULL;    // Referring URL.
    
    for ( int i = 0; i < InetLogLine.iCustomFieldsCount-1; i++)
    {
        (InetLogLine.CustomFields[i]).pchData = NULL;
    }
}

/* ************************************************************************* */
/* ************************************************************************* */

//
// ILogScripting Interface
//

/* ************************************************************************* */
/* ************************************************************************* */

STDMETHODIMP 
CLogScript::OpenLogFile(
    BSTR    szLogFileName,
    IOMode  Mode,
    BSTR,
    long,
    BSTR
)
{
    USES_CONVERSION;

    LockCS();

    if (ForReading == Mode)
    {
        if (m_pInputLogFile != NULL)
        {
            fclose(m_pInputLogFile);
            m_pInputLogFile = NULL;
        }

        m_strInputLogFileName.Copy(W2A(szLogFileName));
    
        if (m_pszLogLine == NULL)
        {
            m_dwLogLineSize = MAX_LOG_RECORD_LEN+1;
            m_pszLogLine = new CHAR[m_dwLogLineSize];

            if (m_pszLogLine == NULL)
                m_dwLogLineSize = 0;
        }
    }
    else
    {
        if (m_pOutputLogFile != NULL)
        {
            fclose(m_pOutputLogFile);
            m_pOutputLogFile = NULL;
        }

        m_strOutputLogFileName.Copy(W2A(szLogFileName));
    }

    UnlockCS();
    SysFreeString(szLogFileName);

    return(S_OK);
    
} // SetInputLogFile

/* ************************************************************************* */
/* ************************************************************************* */

STDMETHODIMP
CLogScript::CloseLogFiles(IOMode Mode)
{
    LockCS();
    
    if( ((ForReading == Mode) || (AllOpenFiles == Mode)) &&
        (m_pInputLogFile != NULL) 
      )
    {
        fclose(m_pInputLogFile);
        m_pInputLogFile = NULL;
    }

    if( ((ForWriting == Mode) || (AllOpenFiles == Mode)) &&
        (m_pOutputLogFile != NULL) 
      )
    {
        fclose(m_pOutputLogFile);
        m_pOutputLogFile = NULL;
    }
    
    UnlockCS();

    return S_OK;
}

/* ************************************************************************* */
/* ************************************************************************* */

STDMETHODIMP 
CLogScript::ReadFilter( DATE, DATE)
{
    return S_OK;
}

/* ************************************************************************* */
/* ************************************************************************* */

STDMETHODIMP
CLogScript::ReadLogRecord( VOID )
{

    HRESULT     hr = S_OK;

    LockCS();
    
    if (m_pInputLogFile == NULL)
    {
        m_pInputLogFile = fopen(m_strInputLogFileName.QueryStr(), "r");
        
        if (m_pInputLogFile == NULL)
        {
            return E_FAIL;
        }
    }

    ResetInetLogLine(ReadInetLogLine);
    
    //
    // Call the plugin to fill in the INET_LOGLINE structure
    //
    
    hr = ReadFileLogRecord(m_pInputLogFile, &ReadInetLogLine, m_pszLogLine, m_dwLogLineSize);

    if (SUCCEEDED(hr))
    {
        hr = S_OK;
    }

    UnlockCS();
     
    return(hr);
    
} // ReadLogRecord

/* ************************************************************************* */
/* ************************************************************************* */

STDMETHODIMP 
CLogScript::AtEndOfLog(VARIANT_BOOL *)
{
    return S_OK;
}

/* ************************************************************************* */
/* ************************************************************************* */

STDMETHODIMP
CLogScript::WriteLogRecord(ILogScripting * pILogScripting)
{
    HRESULT     hr = S_OK;
    bool        fWriteHeader = false;

    LockCS();
    
    if (m_pOutputLogFile == NULL)
    {
        m_pOutputLogFile = fopen(m_strOutputLogFileName.QueryStr(), "w+");
        
        if (m_pOutputLogFile == NULL)
        {
            return E_FAIL;
        }

        fWriteHeader = true;
    }

    //
    // Call the plugin to write the INET_LOGLINE structure to file
    //
    
    hr = WriteFileLogRecord(m_pOutputLogFile, pILogScripting, fWriteHeader);

    if (SUCCEEDED(hr))
    {
        hr = S_OK;
    }

    UnlockCS();
     
    return(hr);
}
/* ************************************************************************* */
/* ************************************************************************* */

STDMETHODIMP
CLogScript::get_DateTime( VARIANT * pvarDateTime)
{
    LockCS();
    pvarDateTime->vt   = VT_DATE;
    pvarDateTime->date = ReadInetLogLine.DateTime;
    UnlockCS();

    return S_OK;

}

/* ************************************************************************* */
/* ************************************************************************* */

STDMETHODIMP
CLogScript::get_ServiceName(VARIANT * pvarServiceName)
{
    LockCS();
    SetVariantToBstr(pvarServiceName, ReadInetLogLine.pszSiteName) ;
    UnlockCS();

    return S_OK;
}

/* ************************************************************************* */
/* ************************************************************************* */


STDMETHODIMP
CLogScript::get_ServerName(VARIANT * pvarServerName)
{
    LockCS();
    SetVariantToBstr(pvarServerName, ReadInetLogLine.pszComputerName);
    UnlockCS();

    return S_OK;
}

/* ************************************************************************* */
/* ************************************************************************* */


STDMETHODIMP
CLogScript::get_ClientIP(VARIANT * pvarClientIP)
{

    LockCS();
    SetVariantToBstr(pvarClientIP, ReadInetLogLine.pszClientHostName);
    UnlockCS();

    return S_OK;
}

/* ************************************************************************* */
/* ************************************************************************* */


STDMETHODIMP
CLogScript::get_UserName(VARIANT * pvarUserName)
{
    LockCS();
    SetVariantToBstr(pvarUserName, ReadInetLogLine.pszClientUserName);
    UnlockCS();
    
    return S_OK;
}

/* ************************************************************************* */
/* ************************************************************************* */


STDMETHODIMP
CLogScript::get_ServerIP(VARIANT * pvarServerIP)
{
    LockCS();
    SetVariantToBstr(pvarServerIP, ReadInetLogLine.pszServerAddress);
    UnlockCS();
    
    return S_OK;
}

/* ************************************************************************* */
/* ************************************************************************* */


STDMETHODIMP
CLogScript::get_Method(VARIANT * pvarMethod)
{
    LockCS();
    SetVariantToBstr(pvarMethod, ReadInetLogLine.pszOperation);
    UnlockCS();

    return S_OK;
}

/* ************************************************************************* */
/* ************************************************************************* */


STDMETHODIMP
CLogScript::get_URIStem(VARIANT * pvarURIStem)
{
    LockCS();
    SetVariantToBstr(pvarURIStem, ReadInetLogLine.pszTarget);
    UnlockCS();

    return S_OK;
}

/* ************************************************************************* */
/* ************************************************************************* */


STDMETHODIMP
CLogScript::get_URIQuery(VARIANT * pvarURIQuery)
{
    LockCS();
    SetVariantToBstr( pvarURIQuery, ReadInetLogLine.pszParameters);
    UnlockCS();

    return S_OK;
}

/* ************************************************************************* */
/* ************************************************************************* */

STDMETHODIMP
CLogScript::get_TimeTaken(VARIANT * pvarTimeTaken)
{
    LockCS();
    SetVariantToLong(pvarTimeTaken, ReadInetLogLine.pszTimeForProcessing);
    UnlockCS();

    return S_OK;
}

/* ************************************************************************* */
/* ************************************************************************* */


STDMETHODIMP
CLogScript::get_BytesSent( VARIANT * pvarBytesSent )
{
    LockCS();
    SetVariantToLong(pvarBytesSent, ReadInetLogLine.pszBytesSent);
    UnlockCS();

    return S_OK;
}

/* ************************************************************************* */
/* ************************************************************************* */


STDMETHODIMP
CLogScript::get_BytesReceived(VARIANT * pvarBytesReceived)
{
    LockCS();
    SetVariantToLong(pvarBytesReceived, ReadInetLogLine.pszBytesRecvd);
    UnlockCS();

    return S_OK;
}

/* ************************************************************************* */
/* ************************************************************************* */


STDMETHODIMP
CLogScript::get_Win32Status( VARIANT * pvarWin32Status )
{
    LockCS();
    SetVariantToLong(pvarWin32Status, ReadInetLogLine.pszWin32Status);
    UnlockCS();

    return S_OK;
}

/* ************************************************************************* */
/* ************************************************************************* */


STDMETHODIMP
CLogScript::get_ProtocolStatus( VARIANT * pvarProtocolStatus )
{
    LockCS();
    SetVariantToLong(pvarProtocolStatus, ReadInetLogLine.pszProtocolStatus);
    UnlockCS();

    return S_OK;
}

/* ************************************************************************* */
/* ************************************************************************* */


STDMETHODIMP
CLogScript::get_ServerPort(VARIANT * pvarServerPort)
{
    LockCS();
    SetVariantToLong(pvarServerPort, ReadInetLogLine.pszPort);
    UnlockCS();

    return S_OK;
}

/* ************************************************************************* */
/* ************************************************************************* */

STDMETHODIMP
CLogScript::get_ProtocolVersion(VARIANT * pvarProtocolVersion)
{
    LockCS();
    SetVariantToBstr(pvarProtocolVersion, ReadInetLogLine.pszVersion);
    UnlockCS();

    return S_OK;
}

/* ************************************************************************* */
/* ************************************************************************* */

STDMETHODIMP
CLogScript::get_UserAgent(VARIANT * pvarUserAgent)
{
    LockCS();
    SetVariantToBstr(pvarUserAgent, ReadInetLogLine.pszUserAgent);
    UnlockCS();

    return S_OK;
}

/* ************************************************************************* */
/* ************************************************************************* */

STDMETHODIMP
CLogScript::get_Cookie(VARIANT * pvarCookie)
{
    LockCS();
    SetVariantToBstr(pvarCookie, ReadInetLogLine.pszCookie);
    UnlockCS();
    
    return S_OK;
}

/* ************************************************************************* */
/* ************************************************************************* */

STDMETHODIMP
CLogScript::get_Referer(VARIANT * pvarReferer)
{
    LockCS();
    SetVariantToBstr(pvarReferer, ReadInetLogLine.pszReferer);
    UnlockCS();
    
    return S_OK;
}

/* ************************************************************************* */
/* ************************************************************************* */

STDMETHODIMP
CLogScript::get_CustomFields(VARIANT * pvarCustomFieldsArray)
{
    USES_CONVERSION;
    
    HRESULT hr = S_OK;
    int     cItems;

    cItems = ReadInetLogLine.iCustomFieldsCount;


    // we will leave that value in case of error
    pvarCustomFieldsArray->vt = VT_NULL;

    if ( 0 < cItems)
    {
 
        // Create 2D SafeArray & stuff with header & string pairs

        SAFEARRAYBOUND rgsabound[2];

        rgsabound[0].lLbound = rgsabound[1].lLbound = 0;

        rgsabound[0].cElements = ReadInetLogLine.iCustomFieldsCount;
        rgsabound[1].cElements = 2;
    
        SAFEARRAY * psaCustom = SafeArrayCreate(VT_VARIANT, 2, rgsabound);

        if ( NULL != psaCustom)
        {
            long i;
            long ix[2];
            VARIANT v;
            
            
            ix[1]=0;
            
            for ( i = 0; i < cItems; i++)
            {
                VariantInit(&v);
                v.vt = VT_BSTR;
                v.bstrVal = A2BSTR(ReadInetLogLine.CustomFields[i].szHeader);
                
                ix[0]=i;
                
                hr = SafeArrayPutElement( psaCustom, ix, &v );
                VariantClear(&v);
                
                if (FAILED (hr))
                {
                    goto exit_point;
                }
                
            }
            
            
            ix[1]=1;
            
            for ( i = 0; i < cItems; i++)
            {
                VariantInit(&v);
                v.vt = VT_BSTR;
                v.bstrVal = A2BSTR(ReadInetLogLine.CustomFields[i].pchData);
                
                ix[0]=i;
                
                hr = SafeArrayPutElement( psaCustom, ix, &v );
                VariantClear(&v);
                
                if (FAILED (hr))
                {
                    goto exit_point;
                }
            }
        }

        if (NULL != pvarCustomFieldsArray)
        {
            pvarCustomFieldsArray->vt = VT_ARRAY|VT_VARIANT;
            pvarCustomFieldsArray->parray = psaCustom;
        }
    }

exit_point:

    return hr;
}

/* ************************************************************************* */
/* ************************************************************************* */

VOID
CLogScript::SetVariantToBstr (VARIANT * pVar, LPSTR pCh)
{
    USES_CONVERSION;
    
    if ( NULL ==  pCh)
    {
        pVar->vt = VT_NULL;
    }
    else if ( 0 == strcmp( pCh, "-"))
    {
        pVar->vt = VT_EMPTY;
    }
    else
    {
        pVar->vt     = VT_BSTR;
        pVar->bstrVal= A2BSTR(pCh);
    }
}

/* ************************************************************************* */
/* ************************************************************************* */

VOID
CLogScript::SetVariantToLong (VARIANT * pVar, LPSTR pCh)
{
    if ( NULL ==  pCh)
    {
        pVar->vt = VT_NULL;
    }
    else if ( 0 == strcmp( pCh, "-"))
    {
        pVar->vt = VT_EMPTY;
    }
    else
    {
        pVar->vt    = VT_I4;
        pVar->lVal  = atol(pCh);
    }
}

/* ************************************************************************* */
/* ************************************************************************* */

BSTR  
CLogScript::GetBstrFromVariant (VARIANT * pVar)
{
    if ((VT_NULL == pVar->vt) || 
        (VT_EMPTY == pVar->vt)
       )
    {
        return m_szEmpty;
    }
    else
    {   
        return pVar->bstrVal;
    }
}

/* ************************************************************************* */
/* ************************************************************************* */

DWORD  
CLogScript::GetLongFromVariant (VARIANT * pVar, CHAR * pBuffer)
{
    if ((VT_NULL == pVar->vt) || 
        (VT_EMPTY == pVar->vt)
       )
    {
        pBuffer[0] = '-';
        pBuffer[1] = '\0';
        return 1;
    }
    else
    {   
        return FastDwToA(pBuffer, pVar->lVal);
    }
}

/* ************************************************************************* */
/* ************************************************************************* */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\log\scripting\logscripting.h ===
/*++

   Copyright    (c)    1998    Microsoft Corporation

   Module  Name :
      logscripting.h

   Abstract:
      LogScripting.cpp : Declaration of the CLogScripting
                         Automation compatible logging interface

   Author:

       Saurab Nog    ( saurabn )    01-Feb-1998

   Project:

       IIS Logging 5.0

--*/

#ifndef _LOGSCRIPTING_
#define _LOGSCRIPTING_

#include "resource.h"       // main symbols

#pragma warning (disable: 4786 4788)

#include <algorithm>
#include <queue>
#include <deque>
#include <functional>

#define  INVALID_PLUGIN  -1

/////////////////////////////////////////////////////////////////////////////
// CLogScripting
class ATL_NO_VTABLE CLogScripting : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CLogScripting, &CLSID_LogScripting>,
	public IDispatchImpl<ILogScripting, &IID_ILogScripting, &LIBID_IISLog>
{
public:
	CLogScripting();
    HRESULT FinalConstruct();
	void FinalRelease();

DECLARE_REGISTRY_RESOURCEID(IDR_LOGSCRIPTING)
DECLARE_PROTECT_FINAL_CONSTRUCT()
DECLARE_GET_CONTROLLING_UNKNOWN()

BEGIN_COM_MAP(CLogScripting)
	COM_INTERFACE_ENTRY(ILogScripting)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

private:
    
    struct FileListEntry
    {
        WCHAR       wcsFileName[MAX_PATH+1];
        FILETIME    ftCreationTime;

        void Copy(const WIN32_FIND_DATAW& x)
        {
            wcscpy( wcsFileName, x.cFileName);
            memcpy( &ftCreationTime, &x.ftCreationTime, sizeof(FILETIME));
        }
    };

    typedef struct FileListEntry *PFileListEntry;

    struct FileTimeCompare
    {
        //
        // We need ascending order. So bigger TimeStamp is smaller
        //

        bool operator()(const PFileListEntry x, const PFileListEntry y) const
        {
            return ( CompareFileTime(&(x->ftCreationTime), &(y->ftCreationTime)) != -1);
        }
    };

    typedef std::priority_queue<PFileListEntry, std::vector<PFileListEntry>, FileTimeCompare>    
    FileQ;

private:

    //
    // Metabase pointer
    //

    IMSAdminBase*   m_pMBCom;

    //
    // Plugin information
    //

    typedef struct
    {
        ILogScripting * pILogScripting;
        CLSID           clsid;
        WCHAR           wcsFriendlyName[256];
    }
    PLUGIN_INFO, *PPLUGIN_INFO;

    int             m_iNumPlugins, m_iReadPlugin, m_iWritePlugin;
    PPLUGIN_INFO    m_pPluginInfo;

    //
    // File Path Information
    //

    bool            m_fDirectory;
    HANDLE          m_hDirSearchHandle;
    WCHAR           m_wcsReadFileName[MAX_PATH+1], m_wcsReadDirectoryName[MAX_PATH+1];

    //
    // Log Time Information
    //
    
    DATE            m_StartDateTime;
    DATE            m_EndDateTime;

    //
    // Flag to indicate end of Records
    //

    bool            m_fEndOfReadRecords;

    //
    // Directory listing
    //

    FileQ           m_fQueue;

    //
    //  Private member functions
    //

    int     ParseLogFile();
    bool    GetNextFileName();

    int     CreateAllPlugins();
    bool    GetListOfAvailablePlugins(); 

    HRESULT InternalReadLogRecord();

public:

    //
    // ILogScripting: Copied from the header file generated by MIDL.
    //

    virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE OpenLogFile( 
        /* [in] */                          BSTR    szLogFileName,
        /* [defaultvalue][optional][in] */  IOMode  Mode                  = ForReading,
        /* [defaultvalue][optional][in] */  BSTR    szServiceName         = L"", 
        /* [defaultvalue][optional][in] */  long    iServerInstance       = 0,
        /* [defaultvalue][optional][in] */  BSTR    szOutputLogFileFormat = L"");
    
    virtual /* [helpstring][id] */          HRESULT STDMETHODCALLTYPE CloseLogFiles( 
        /* [defaultvalue][optional][in] */  IOMode  Mode = AllOpenFiles);
    
    virtual /* [helpstring][id] */          HRESULT STDMETHODCALLTYPE ReadFilter( 
        /* [defaultvalue][optional][in] */  DATE    startDateTime = 0,
        /* [defaultvalue][optional][in] */  DATE    endDateTime   = 1000000);
    
    virtual /* [helpstring][id] */          HRESULT STDMETHODCALLTYPE ReadLogRecord( void);
    
    virtual /* [helpstring][id] */          HRESULT STDMETHODCALLTYPE AtEndOfLog( 
        /* [retval][ref][out] */            VARIANT_BOOL __RPC_FAR *pfEndOfRead);
    
    virtual /* [helpstring][id] */          HRESULT STDMETHODCALLTYPE WriteLogRecord( 
        /* [in] */                          ILogScripting __RPC_FAR *pILogScripting);
    
    virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_DateTime( 
        /* [retval][ref][out] */            VARIANT __RPC_FAR *pvarDateTime);
    
    virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ServiceName( 
        /* [retval][ref][out] */            VARIANT __RPC_FAR *pvarServiceName);
    
    virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ServerName( 
        /* [retval][ref][out] */            VARIANT __RPC_FAR *pvarServerName);
    
    virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ClientIP( 
        /* [retval][ref][out] */            VARIANT __RPC_FAR *pvarClientIP);
    
    virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_UserName( 
        /* [retval][ref][out] */            VARIANT __RPC_FAR *pvarUserName);
    
    virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ServerIP( 
        /* [retval][ref][out] */            VARIANT __RPC_FAR *pvarServerIP);
    
    virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Method( 
        /* [retval][ref][out] */            VARIANT __RPC_FAR *pvarMethod);
    
    virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_URIStem( 
        /* [retval][ref][out] */            VARIANT __RPC_FAR *pvarURIStem);
    
    virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_URIQuery( 
        /* [retval][ref][out] */            VARIANT __RPC_FAR *pvarURIQuery);
    
    virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_TimeTaken( 
        /* [retval][ref][out] */            VARIANT __RPC_FAR *pvarTimeTaken);
    
    virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_BytesSent( 
        /* [retval][ref][out] */            VARIANT __RPC_FAR *pvarBytesSent);
    
    virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_BytesReceived( 
        /* [retval][ref][out] */            VARIANT __RPC_FAR *pvarBytesReceived);
    
    virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Win32Status( 
        /* [retval][ref][out] */            VARIANT __RPC_FAR *pvarWin32Status);
    
    virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ProtocolStatus( 
        /* [retval][ref][out] */            VARIANT __RPC_FAR *pvarProtocolStatus);
    
    virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ServerPort( 
        /* [retval][ref][out] */            VARIANT __RPC_FAR *pvarServerPort);
    
    virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ProtocolVersion( 
        /* [retval][ref][out] */            VARIANT __RPC_FAR *pvarProtocolVersion);

    virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_UserAgent( 
        /* [retval][ref][out] */            VARIANT __RPC_FAR *pvarUserAgent);
        
    virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Cookie( 
        /* [retval][ref][out] */            VARIANT __RPC_FAR *pvarCookie);
        
    virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Referer( 
        /* [retval][ref][out] */            VARIANT __RPC_FAR *pvarReferer);
    
    virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_CustomFields( 
        /* [retval][ref][out] */            VARIANT __RPC_FAR *pvarCustomFieldsArray);


};

#endif //_LOGSCRIPTING_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\log\scripting\logscripting.cpp ===
/*++

   Copyright    (c)    1998    Microsoft Corporation

   Module  Name :
      logscripting.cpp

   Abstract:
      LogScripting.cpp : Implementation of CLogScripting
                         Automation compatible logging interface

   Author:

       Saurab Nog    ( saurabn )    01-Feb-1998

   Project:

       IIS Logging 5.0

--*/



#include "stdafx.h"
#include "script.h"

#include <initguid.h>
#include <InetCom.h>
#include <LogType.h>
#include <ILogObj.hxx>

#include <limits.h>

#include <iadmw.h>
#include <iiscnfg.h>

#include <atlimpl.cpp>

#include "LogScripting.h"


const   int MB_TIMEOUT = 5000;

/////////////////////////////////////////////////////////////////////////////
// CLogScripting


CLogScripting::CLogScripting(VOID)
:
    m_iNumPlugins           ( -1),
    m_iReadPlugin           ( -1),
    m_iWritePlugin          ( -1),
    m_pPluginInfo           ( NULL),
    m_fDirectory            ( false),
    m_fEndOfReadRecords     ( true),
    m_StartDateTime         ( LONG_MIN),
    m_EndDateTime           ( LONG_MAX),
    m_hDirSearchHandle      ( INVALID_HANDLE_VALUE)
{
    m_wcsReadFileName[0]      = 0;
    m_wcsReadDirectoryName[0] = 0;
}

/* ************************************************************************* */
/* ************************************************************************* */

HRESULT CLogScripting::FinalConstruct()
{
    m_pMBCom        = NULL;

    ::CoCreateInstance(GETAdminBaseCLSID(TRUE), NULL, CLSCTX_LOCAL_SERVER,
                       IID_IMSAdminBase, (void **)(&m_pMBCom));

    if (m_pMBCom)
    {
        CreateAllPlugins();
    }

    return S_OK;
}

/* ************************************************************************* */
/* ************************************************************************* */

void CLogScripting::FinalRelease()
{
    if ( m_pMBCom )
    {
        m_pMBCom->Release();
        m_pMBCom = NULL;
    }

    for(int i=0; i< m_iNumPlugins; i++)
    {
        if ( NULL != m_pPluginInfo[i].pILogScripting)
        {
            m_pPluginInfo[i].pILogScripting->CloseLogFiles(AllOpenFiles);
            m_pPluginInfo[i].pILogScripting->Release();
            m_pPluginInfo[i].pILogScripting = NULL;
        }
    }
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//
//                  Private Methods of CLogScripting
//
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

int CLogScripting:: CreateAllPlugins()
{
    int         i,j = 0;
    HRESULT     hr;

    typedef     ILogScripting *pILogScripting;

    m_iNumPlugins   = 0;

    if (GetListOfAvailablePlugins() && (m_iNumPlugins > 0))
    {
        //
        // Load all the plugins
        //

        for (i=j=0; i<m_iNumPlugins; i++)
        {
            hr = ::CoCreateInstance(m_pPluginInfo[i].clsid, NULL, CLSCTX_INPROC_SERVER,
                        IID_ILogScripting, (void **)(& m_pPluginInfo[i].pILogScripting));

            if (SUCCEEDED(hr))
            {
                j++;
            }
            else
            {
                m_pPluginInfo[i].pILogScripting = NULL;
            }
        }
    }

    return j;           // Number of plugins successfully created.
}

/* ************************************************************************* */
/* ************************************************************************* */

bool CLogScripting::GetListOfAvailablePlugins()
{
    USES_CONVERSION;

    m_pPluginInfo = new PLUGIN_INFO[4];

    if( m_pPluginInfo == NULL )
    {
        return false;
    }

    wcscpy(m_pPluginInfo[0].wcsFriendlyName, L"NCSA Common Log File Format");
    CLSIDFromString(A2W(NCSALOG_CLSID), &m_pPluginInfo[0].clsid);

    wcscpy(m_pPluginInfo[1].wcsFriendlyName, L"ODBC Logging");
    CLSIDFromString(A2W(ODBCLOG_CLSID), &m_pPluginInfo[1].clsid);

    wcscpy(m_pPluginInfo[2].wcsFriendlyName, L"Microsoft IIS Log File Format");
    CLSIDFromString(A2W(ASCLOG_CLSID), &m_pPluginInfo[2].clsid);

    wcscpy(m_pPluginInfo[3].wcsFriendlyName, L"W3C Extended Log File Format");
    CLSIDFromString(A2W(EXTLOG_CLSID), &m_pPluginInfo[3].clsid);

    m_iNumPlugins = 4;

    return true;
}

/* ************************************************************************* */
/* ************************************************************************* */

bool CLogScripting::GetNextFileName()
{

   	WIN32_FIND_DATAW	stFindFileData;
    PFileListEntry      pFileInfo;

    if (NULL == m_hDirSearchHandle)
    {
        return false;
    }

    if (INVALID_HANDLE_VALUE == m_hDirSearchHandle)
    {
        //
        // This is the first/new call. Clean up file Q by removing old file information.
        //

        while(! m_fQueue.empty())
        {
            pFileInfo = m_fQueue.top();
            m_fQueue.pop();
            delete pFileInfo;
        }

        //
        // Loop till we enumerate all files in this directory
        //

        WCHAR   wcsSearchPath[MAX_PATH+1];

        wcscpy(wcsSearchPath, m_wcsReadDirectoryName);
        wcscat(wcsSearchPath, L"\\*");

        if (m_hDirSearchHandle)
        {
            FindClose(m_hDirSearchHandle);
        }

        m_hDirSearchHandle = FindFirstFileW(wcsSearchPath, &stFindFileData);

        do
        {
            if (! (stFindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
            {
                pFileInfo = new FileListEntry;

                pFileInfo->Copy(stFindFileData);
                m_fQueue.push(pFileInfo);
            }
        }
        while ( FindNextFileW(m_hDirSearchHandle, &stFindFileData) );
    }


    //
    // Pop the lowest timestamp file
    //

    pFileInfo = NULL;

    if (! m_fQueue.empty())
    {
        pFileInfo = m_fQueue.top();
        m_fQueue.pop();
    }

    if (NULL == pFileInfo)
    {
        //
        // We have run out of files or some error occured. Prevent another search.
        //

        FindClose(m_hDirSearchHandle);
        m_hDirSearchHandle = NULL;
        m_wcsReadFileName[0] = 0;
        return false;
    }
    else
    {
        wcscpy(m_wcsReadFileName, m_wcsReadDirectoryName);
        wcscat(m_wcsReadFileName, L"\\");
        wcscat(m_wcsReadFileName, pFileInfo->wcsFileName);
        delete pFileInfo;
        return true;
    }
}

/* ************************************************************************* */
/* ************************************************************************* */

int CLogScripting::ParseLogFile()
{

    if (m_wcsReadFileName[0] == 0)
    {
        return INVALID_PLUGIN;
    }

    //
    // Linear search thru all plugins
    //

    for(int i=0; i < m_iNumPlugins; i++)
    {
        if ( m_pPluginInfo[i].pILogScripting != NULL )
        {
            m_pPluginInfo[i].pILogScripting->OpenLogFile(
                                                W2BSTR(m_wcsReadFileName),
                                                ForReading,
                                                L"",
                                                0,
                                                L""
                                             );

            if ( SUCCEEDED(m_pPluginInfo[i].pILogScripting->ReadLogRecord()) )
            {
                return i;
            }

            m_pPluginInfo[i].pILogScripting->CloseLogFiles(ForReading);
        }
    }

    //
    // None of the registered plugins knows how to read the log file. Sorry !!
    //

    return INVALID_PLUGIN;
}

/* ************************************************************************* */
/* ************************************************************************* */

HRESULT CLogScripting::InternalReadLogRecord()
{
    DATE    logDateTime = 0;
    HRESULT hr          = HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS);

    if (!m_fDirectory)
    {
        //
        // Simple case. Not a directory.
        //

        if ( INVALID_PLUGIN == m_iReadPlugin )
        {
            //
            // First use. Find a plugin to read the file.
            //

            if ( (m_iReadPlugin = ParseLogFile()) != INVALID_PLUGIN)
            {
                hr = S_OK;
            }

        }
        else
        {
            //
            // Read next record
            //

            hr =  m_pPluginInfo[m_iReadPlugin].pILogScripting->ReadLogRecord();
        }
    }
    else
    {
        //
        // Directory case
        //

        if (m_iReadPlugin != INVALID_PLUGIN)
        {
            hr =  m_pPluginInfo[m_iReadPlugin].pILogScripting->ReadLogRecord();

            if (SUCCEEDED(hr))
            {
                goto returnlabel;
            }
        }

        //
        // Either this is the first use or the last read failed
        //

        while (GetNextFileName())
        {
            if ( (m_iReadPlugin = ParseLogFile()) != INVALID_PLUGIN)
            {
                hr = S_OK;
                break;
            }
        }
    }

returnlabel:

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//
//                  Methods of ILogRead
//
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CLogScripting::OpenLogFile(
    BSTR    szLogFileName,
    IOMode  Mode,
    BSTR    szServiceName,
    long    iServiceInstance,
    BSTR    szOutputLogFileFormat
)
{
    DWORD       dwFileAttrib;
    HRESULT     hr = E_INVALIDARG;
    WCHAR       szFilePath[MAX_PATH+1];

    BOOL  fHasFileName    = (( NULL != szLogFileName) && ( 0 != szLogFileName[0]));
    BOOL  fHasServiceName = (( NULL != szServiceName) && ( 0 != szServiceName[0]));

    BOOL  fHasOutputFormatName  = (( NULL != szOutputLogFileFormat) &&
                                   ( 0 != szOutputLogFileFormat[0]));

	CloseLogFiles(Mode);
	
    if (ForReading == Mode)
    {
        //
        // If the File Name isn't specified but Service Name & ID are, get
        // the appropriate log directory and use that as the log file name.
        //

        if ( (!fHasFileName) && fHasServiceName && ( 0 != iServiceInstance))
        {

            METADATA_HANDLE     hMeta   = NULL;
            METADATA_RECORD     mdRecord;
            WCHAR               szTemp[MAX_PATH+1] = L"/LM/";
            DWORD               dwRequiredLen;

            if (m_pMBCom == NULL)
            {
                hr = E_FAIL;
                goto cleanup;
            }

            if (wcslen(szServiceName) > MAX_PATH+1 - sizeof("/LM//4294967296"))
            {
                hr = E_INVALIDARG;
                goto cleanup;
            }
            wcscat(szTemp, szServiceName);
            wcscat(szTemp, L"/");
            _ltow(iServiceInstance, szTemp+wcslen(szTemp),10);

            hr = m_pMBCom->OpenKey( METADATA_MASTER_ROOT_HANDLE, szTemp,
                                    METADATA_PERMISSION_READ, MB_TIMEOUT, &hMeta);

            if ( FAILED(hr))
            {
                goto cleanup;
            }

            //
            // prepare the metadata record for reading
            //

            mdRecord.dwMDIdentifier  = MD_LOGFILE_DIRECTORY;
            mdRecord.dwMDAttributes  = METADATA_INHERIT;
            mdRecord.dwMDUserType    = IIS_MD_UT_SERVER;
            mdRecord.dwMDDataType    = EXPANDSZ_METADATA;
            mdRecord.pbMDData        = (PBYTE)szTemp;
            mdRecord.dwMDDataLen     = MAX_PATH;

            hr = m_pMBCom->GetData(hMeta, L"", &mdRecord, &dwRequiredLen);
            m_pMBCom->CloseKey(hMeta);

            if ( FAILED(hr))
            {
                goto cleanup;
            }

            //
            //  Expand system variables used in this path.
            //

            if (ExpandEnvironmentStringsW(szTemp, szFilePath, MAX_PATH+1) != 0)
            {
                if ( wcslen(szFilePath) > MAX_PATH-wcslen(szServiceName)-10 )
                {
                    hr = E_OUTOFMEMORY;
                    goto cleanup;
                }

                wcscat(szFilePath,L"\\");
                wcscat(szFilePath,szServiceName);
                _ltow(iServiceInstance, szFilePath+wcslen(szFilePath),10);
                wcscat(szFilePath,L"\\");
                szLogFileName = szFilePath;
            }
        }
    }

    //
    // At this point szLogFileName should be defined.
    //

    hr = E_INVALIDARG;

    if ( (NULL == szLogFileName ) || ( 0 == szLogFileName[0]) ||
         ((ForReading != Mode ) && (ForWriting != Mode))
       )
    {
        goto cleanup;
    }

    if (ForReading == Mode)
    {
        //
        // Reset EOF flag
        //

        m_fEndOfReadRecords = false;

		//
		// Check if this is a valid file and/or a directory
		//

		if ( 0xFFFFFFFF != (dwFileAttrib = GetFileAttributesW(szLogFileName)) )
		{
			if (dwFileAttrib & FILE_ATTRIBUTE_DIRECTORY)
			{
				// This is a directory

				m_fDirectory = true;
				wcscpy(m_wcsReadDirectoryName, szLogFileName);
			}
			else
			{
			   wcscpy(m_wcsReadFileName, szLogFileName);
			}

			hr = S_OK;
		}
		else
		{
			// couldn't get file attributes. check for error code

			hr = HRESULT_FROM_WIN32(GetLastError());
		}
    }
    else
    {
        //
        // Find the correct plugin & set the value. If user didn't specify file format use W3C
        //

        if ( ( NULL == szOutputLogFileFormat) ||
             ( 0 == *szOutputLogFileFormat)
           )
        {
            //
            // Search based on the clsid of W3C Logging
            //

            for(int i=0; i< m_iNumPlugins; i++)
            {
                if ( (CLSID_EXTLOG  == m_pPluginInfo[i].clsid) &&
                     (NULL  != m_pPluginInfo[i].pILogScripting)
                   )
                {
                    m_iWritePlugin = i;
                    break;
                }
            }
        }
        else
        {

            //
            // Search based on format name provided by the user
            //

            for(int i=0; i< m_iNumPlugins; i++)
            {
                if ( (0     == _wcsicmp(m_pPluginInfo[i].wcsFriendlyName,
                                        szOutputLogFileFormat)) &&
                     (NULL  != m_pPluginInfo[i].pILogScripting)
                   )
                {
                    m_iWritePlugin = i;
                    break;
                }
            }
        }

        if (0 <= m_iWritePlugin)
        {
            hr = m_pPluginInfo[m_iWritePlugin].pILogScripting->OpenLogFile(
                                                W2BSTR(szLogFileName),
                                                Mode,
                                                L"",
                                                0,
                                                L"");
        }
    }

cleanup:

    /*
    fix for bug 364649:
    No need to do that becuase oleaut does some thicks with mem allocation and free.
    That's true for both cscirtp and ASP, so I choose to remove these deltions. Even if
    I am wrong, and it necesasry to free somehow that string, it is better to leak ~20 bytes than
    AV or currupt memory while deleting what was not allocated by sysallocstring

    if (fHasFileName)
    {
        SysFreeString(szLogFileName);
    }
    if (fHasServiceName)
    {
        SysFreeString(szServiceName);
    }
    if (fHasOutputFormatName)
    {
        SysFreeString(szOutputLogFileFormat);
    }
    */
    return hr;
}

/* ************************************************************************* */
/* ************************************************************************* */

STDMETHODIMP
CLogScripting::CloseLogFiles(IOMode Mode)
{
    if ((ForReading == Mode) || (AllOpenFiles == Mode))
    {
        if (m_iReadPlugin != INVALID_PLUGIN)
        {
            m_pPluginInfo[m_iReadPlugin].pILogScripting->CloseLogFiles(ForReading);
        }

        m_iReadPlugin               = INVALID_PLUGIN;           // Reset Plugin in Use
        m_fDirectory                = false;
        m_hDirSearchHandle          = INVALID_HANDLE_VALUE;     // Reset Search Handle
        m_wcsReadFileName[0]        = 0;
        m_wcsReadDirectoryName[0]   = 0;
    }

    if ((ForWriting == Mode) || (AllOpenFiles == Mode))
    {
        if (m_iWritePlugin != INVALID_PLUGIN)
        {
            m_pPluginInfo[m_iWritePlugin].pILogScripting->CloseLogFiles(ForWriting);
        }

        m_iWritePlugin = INVALID_PLUGIN;                        // Reset Plugin in Use
    }

	return S_OK;
}

/* ************************************************************************* */
/* ************************************************************************* */

STDMETHODIMP
CLogScripting::ReadFilter( DATE startDateTime,  DATE endDateTime)
{
    m_StartDateTime = startDateTime;
    m_EndDateTime   = endDateTime;

    return S_OK;
}

/* ************************************************************************* */
/* ************************************************************************* */

STDMETHODIMP
CLogScripting::ReadLogRecord()
{
    HRESULT hr          = E_FAIL;
    VARIANT logDateTime = {0};

    if ( m_fEndOfReadRecords )
    {
        return S_OK;
    }

    //
    // Read the next record. Only return records between the start & end times.
    //

    while ( SUCCEEDED( hr = InternalReadLogRecord() ) )
    {
        if ( SUCCEEDED(m_pPluginInfo[m_iReadPlugin].pILogScripting->get_DateTime(&logDateTime)) )
        {
            if ( (m_StartDateTime > logDateTime.date) || (m_EndDateTime < logDateTime.date))
            {
                //
                // Read next record
                //

                continue;
            }
        }

        break;
    }

    if ( FAILED(hr))
    {
        m_fEndOfReadRecords = true;
        hr = S_OK;
    }

    return hr;
}

/* ************************************************************************* */
/* ************************************************************************* */

STDMETHODIMP
CLogScripting::AtEndOfLog(VARIANT_BOOL *pfEndOfRead)
{
    DBG_ASSERT( NULL != pfEndOfRead);

    *pfEndOfRead = m_fEndOfReadRecords;
    return S_OK;
}


/* ************************************************************************* */
/* ************************************************************************* */

STDMETHODIMP
CLogScripting::WriteLogRecord(ILogScripting * pILogScripting)
{
    HRESULT hr = E_FAIL;

    DBG_ASSERT( NULL != pILogScripting);

    if (m_iWritePlugin >= 0)
    {
        hr = m_pPluginInfo[m_iWritePlugin].pILogScripting->WriteLogRecord(pILogScripting);
    }

    return hr;
}

/* ************************************************************************* */
/* ************************************************************************* */

STDMETHODIMP
CLogScripting::get_DateTime(VARIANT * pvarDateTime)
{
    HRESULT hr = E_FAIL;

    DBG_ASSERT( NULL != pvarDateTime);

    if (m_fEndOfReadRecords)
    {
        pvarDateTime->vt = VT_NULL;
        return S_OK;
    }

    if (m_iReadPlugin >= 0)
    {
        hr = m_pPluginInfo[m_iReadPlugin].pILogScripting->get_DateTime(pvarDateTime);
    }

    return hr;
}

/* ************************************************************************* */
/* ************************************************************************* */

STDMETHODIMP
CLogScripting::get_ServiceName(VARIANT * pvarServiceName)
{

    HRESULT hr = E_FAIL;

    DBG_ASSERT( NULL != pvarServiceName);

    if (m_fEndOfReadRecords)
    {
        pvarServiceName->vt = VT_NULL;
        return S_OK;
    }

    if (m_iReadPlugin >= 0)
    {
        hr = m_pPluginInfo[m_iReadPlugin].pILogScripting->get_ServiceName(pvarServiceName);
    }

    return hr;
}

/* ************************************************************************* */
/* ************************************************************************* */

STDMETHODIMP
CLogScripting::get_ServerName(VARIANT * pvarServerName)
{
    HRESULT hr = E_FAIL;

    DBG_ASSERT( NULL != pvarServerName);

    if (m_fEndOfReadRecords)
    {
        pvarServerName->vt = VT_NULL;
        return S_OK;
    }

    if (m_iReadPlugin >= 0)
    {
        hr = m_pPluginInfo[m_iReadPlugin].pILogScripting->get_ServerName(pvarServerName);
    }

    return hr;
}

/* ************************************************************************* */
/* ************************************************************************* */

STDMETHODIMP
CLogScripting::get_ClientIP(VARIANT * pvarClientIP)
{
    HRESULT hr = E_FAIL;

    DBG_ASSERT( NULL != pvarClientIP);

    if (m_fEndOfReadRecords)
    {
        pvarClientIP->vt = VT_NULL;
        return S_OK;
    }

    if (m_iReadPlugin >= 0)
    {
        hr = m_pPluginInfo[m_iReadPlugin].pILogScripting->get_ClientIP(pvarClientIP);
    }

    return hr;
}

/* ************************************************************************* */
/* ************************************************************************* */

STDMETHODIMP
CLogScripting::get_UserName(VARIANT * pvarUserName)
{
    HRESULT hr = E_FAIL;

    DBG_ASSERT( NULL != pvarUserName);

    if (m_fEndOfReadRecords)
    {
        pvarUserName->vt = VT_NULL;
        return S_OK;
    }

    if (m_iReadPlugin >= 0)
    {
        hr = m_pPluginInfo[m_iReadPlugin].pILogScripting->get_UserName(pvarUserName);
    }

    return hr;
}

/* ************************************************************************* */
/* ************************************************************************* */

STDMETHODIMP
CLogScripting::get_ServerIP(VARIANT * pvarServerIP)
{
    HRESULT hr = E_FAIL;

    DBG_ASSERT( NULL != pvarServerIP);

    if (m_fEndOfReadRecords)
    {
        pvarServerIP->vt = VT_NULL;
        return S_OK;
    }

    if (m_iReadPlugin >= 0)
    {
        hr = m_pPluginInfo[m_iReadPlugin].pILogScripting->get_ServerIP(pvarServerIP);
    }

    return hr;
}

/* ************************************************************************* */
/* ************************************************************************* */

STDMETHODIMP
CLogScripting::get_Method(VARIANT * pvarMethod)
{
    HRESULT hr = E_FAIL;

    DBG_ASSERT( NULL != pvarMethod);

    if (m_fEndOfReadRecords)
    {
        pvarMethod->vt = VT_NULL;
        return S_OK;
    }

    if (m_iReadPlugin >= 0)
    {
        hr = m_pPluginInfo[m_iReadPlugin].pILogScripting->get_Method(pvarMethod);
    }

    return hr;
}

/* ************************************************************************* */
/* ************************************************************************* */

STDMETHODIMP
CLogScripting::get_URIStem(VARIANT * pvarURIStem)
{
    HRESULT hr = E_FAIL;

    DBG_ASSERT( NULL != pvarURIStem);

    if (m_fEndOfReadRecords)
    {
        pvarURIStem->vt = VT_NULL;
        return S_OK;
    }

    if (m_iReadPlugin >= 0)
    {
        hr = m_pPluginInfo[m_iReadPlugin].pILogScripting->get_URIStem(pvarURIStem);
    }

    return hr;
}

/* ************************************************************************* */
/* ************************************************************************* */

STDMETHODIMP
CLogScripting::get_URIQuery(VARIANT * pvarURIQuery)
{
    HRESULT hr = E_FAIL;

    DBG_ASSERT( NULL != pvarURIQuery);

    if (m_fEndOfReadRecords)
    {
        pvarURIQuery->vt = VT_NULL;
        return S_OK;
    }

    if (m_iReadPlugin >= 0)
    {
        hr = m_pPluginInfo[m_iReadPlugin].pILogScripting->get_URIQuery(pvarURIQuery);
    }

    return hr;
}

/* ************************************************************************* */
/* ************************************************************************* */

STDMETHODIMP
CLogScripting::get_TimeTaken(VARIANT * pvarTimeTaken)
{
    HRESULT hr = E_FAIL;

    DBG_ASSERT( NULL != pvarTimeTaken);

    if (m_fEndOfReadRecords)
    {
        pvarTimeTaken->vt = VT_NULL;
        return S_OK;
    }

    if (m_iReadPlugin >= 0)
    {
        hr = m_pPluginInfo[m_iReadPlugin].pILogScripting->get_TimeTaken(pvarTimeTaken);
    }
    return hr;
}

/* ************************************************************************* */
/* ************************************************************************* */

STDMETHODIMP
CLogScripting::get_BytesSent(VARIANT * pvarBytesSent)
{
    HRESULT hr = E_FAIL;

    DBG_ASSERT( NULL != pvarBytesSent);

    if (m_fEndOfReadRecords)
    {
        pvarBytesSent->vt = VT_NULL;
        return S_OK;
    }

    if (m_iReadPlugin >= 0)
    {
        hr = m_pPluginInfo[m_iReadPlugin].pILogScripting->get_BytesSent(pvarBytesSent);
    }
    return hr;
}

/* ************************************************************************* */
/* ************************************************************************* */

STDMETHODIMP
CLogScripting::get_BytesReceived(VARIANT * pvarBytesReceived)
{
    HRESULT hr = E_FAIL;

    DBG_ASSERT( NULL != pvarBytesReceived);

    if (m_fEndOfReadRecords)
    {
        pvarBytesReceived->vt = VT_NULL;
        return S_OK;
    }

    if (m_iReadPlugin >= 0)
    {
        hr = m_pPluginInfo[m_iReadPlugin].pILogScripting->get_BytesReceived(pvarBytesReceived);
    }
    return hr;
}

/* ************************************************************************* */
/* ************************************************************************* */

STDMETHODIMP
CLogScripting::get_Win32Status(VARIANT * pvarWin32Status)
{
    HRESULT hr = E_FAIL;

    DBG_ASSERT( NULL != pvarWin32Status);

    if (m_fEndOfReadRecords)
    {
        pvarWin32Status->vt = VT_NULL;
        return S_OK;
    }

    if (m_iReadPlugin >= 0)
    {
        hr = m_pPluginInfo[m_iReadPlugin].pILogScripting->get_Win32Status(pvarWin32Status);
    }
    return hr;
}

/* ************************************************************************* */
/* ************************************************************************* */

STDMETHODIMP
CLogScripting::get_ProtocolStatus(VARIANT * pvarProtocolStatus)
{
    HRESULT hr = E_FAIL;

    DBG_ASSERT( NULL != pvarProtocolStatus);

    if (m_fEndOfReadRecords)
    {
        pvarProtocolStatus->vt = VT_NULL;
        return S_OK;
    }

    if (m_iReadPlugin >= 0)
    {
        hr = m_pPluginInfo[m_iReadPlugin].pILogScripting->get_ProtocolStatus(pvarProtocolStatus);
    }
    return hr;
}

/* ************************************************************************* */
/* ************************************************************************* */

STDMETHODIMP
CLogScripting::get_ServerPort(VARIANT * pvarServerPort)
{
    HRESULT hr = E_FAIL;

    DBG_ASSERT( NULL != pvarServerPort);

    if (m_fEndOfReadRecords)
    {
        pvarServerPort->vt = VT_NULL;
        return S_OK;
    }

    if (m_iReadPlugin >= 0)
    {
        hr = m_pPluginInfo[m_iReadPlugin].pILogScripting->get_ServerPort(pvarServerPort);
    }
    return hr;
}

/* ************************************************************************* */
/* ************************************************************************* */

STDMETHODIMP
CLogScripting::get_ProtocolVersion(VARIANT * pvarProtocolVersion)
{
    HRESULT hr = E_FAIL;

    DBG_ASSERT( NULL != pvarProtocolVersion);

    if (m_fEndOfReadRecords)
    {
        pvarProtocolVersion->vt = VT_NULL;
        return S_OK;
    }

    if (m_iReadPlugin >= 0)
    {
        hr = m_pPluginInfo[m_iReadPlugin].pILogScripting->get_ProtocolVersion(pvarProtocolVersion);
    }

    return hr;
}

/* ************************************************************************* */
/* ************************************************************************* */

STDMETHODIMP
CLogScripting::get_UserAgent(VARIANT * pvarUserAgent)
{
    HRESULT hr = E_FAIL;

    DBG_ASSERT( NULL != pvarUserAgent);

    if (m_fEndOfReadRecords)
    {
        pvarUserAgent->vt = VT_NULL;
        return S_OK;
    }

    if (m_iReadPlugin >= 0)
    {
        hr = m_pPluginInfo[m_iReadPlugin].pILogScripting->get_UserAgent(pvarUserAgent);
    }

    return hr;
}

/* ************************************************************************* */
/* ************************************************************************* */

STDMETHODIMP
CLogScripting::get_Cookie(VARIANT * pvarCookie)
{
    HRESULT hr = E_FAIL;

    DBG_ASSERT( NULL != pvarCookie);

    if (m_fEndOfReadRecords)
    {
        pvarCookie->vt = VT_NULL;
        return S_OK;
    }

    if (m_iReadPlugin >= 0)
    {
        hr = m_pPluginInfo[m_iReadPlugin].pILogScripting->get_Cookie(pvarCookie);
    }

    return hr;
}

/* ************************************************************************* */
/* ************************************************************************* */

STDMETHODIMP
CLogScripting::get_Referer(VARIANT * pvarReferer)
{
    HRESULT hr = E_FAIL;

    DBG_ASSERT( NULL != pvarReferer);

    if (m_fEndOfReadRecords)
    {
        pvarReferer->vt = VT_NULL;
        return S_OK;
    }

    if (m_iReadPlugin >= 0)
    {
        hr = m_pPluginInfo[m_iReadPlugin].pILogScripting->get_Referer(pvarReferer);
    }

    return hr;
}

/* ************************************************************************* */
/* ************************************************************************* */

STDMETHODIMP
CLogScripting::get_CustomFields(VARIANT * pvarCustomFieldsArray)
{
    HRESULT hr = E_FAIL;

    DBG_ASSERT( NULL != pvarCustomFieldsArray);

    if (m_fEndOfReadRecords)
    {
        pvarCustomFieldsArray->vt = VT_NULL;
        return S_OK;
    }

    if (m_iReadPlugin >= 0)
    {
        hr = m_pPluginInfo[m_iReadPlugin].pILogScripting->get_CustomFields(pvarCustomFieldsArray);
    }

    return hr;
}

/* ************************************************************************* */
/* ************************************************************************* */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\log\scripting\script.cpp ===
// script.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//		To merge the proxy/stub code into the object DLL, add the file
//		dlldatax.c to the project.  Make sure precompiled headers
//		are turned off for this file, and add _MERGE_PROXYSTUB to the
//		defines for the project.
//
//		If you are not running WinNT4.0 or Win95 with DCOM, then you
//		need to remove the following define from dlldatax.c
//		#define _WIN32_WINNT 0x0400
//
//		Further, if you are running MIDL without /Oicf switch, you also
//		need to remove the following define from dlldatax.c.
//		#define USE_STUBLESS_PROXY
//
//		Modify the custom build rule for script.idl by adding the following
//		files to the Outputs.
//			script_p.c
//			dlldata.c
//		To build a separate proxy/stub DLL,
//		run nmake -f scriptps.mk in the project directory.

#include "stdafx.h"

#include "resource.h"
#include "script.h"
#include "dlldatax.h"

#include "script_i.c"
#include <iadmw.h>
#include "LogScripting.h"

#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif

CHAR    g_szModuleName[] = "LogScript";

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_LogScripting, CLogScripting)
END_OBJECT_MAP()

DECLARE_DEBUG_PRINTS_OBJECT( );

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
	lpReserved;
#ifdef _MERGE_PROXYSTUB
	if (!PrxDllMain(hInstance, dwReason, lpReserved))
		return FALSE;
#endif
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		_Module.Init(ObjectMap, hInstance);
		DisableThreadLibraryCalls(hInstance);

        CREATE_DEBUG_PRINT_OBJECT(g_szModuleName);
        LOAD_DEBUG_FLAGS_FROM_REG_STR("System\\CurrentControlSet\\Services\\InetInfo\\Parameters", 0);

	}
	else if (dwReason == DLL_PROCESS_DETACH)
    {
        DELETE_DEBUG_PRINT_OBJECT();
		_Module.Term();
    }
	return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
#ifdef _MERGE_PROXYSTUB
	if (PrxDllCanUnloadNow() != S_OK)
		return S_FALSE;
#endif
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
#ifdef _MERGE_PROXYSTUB
	if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
		return S_OK;
#endif
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
	HRESULT hRes = PrxDllRegisterServer();
	if (FAILED(hRes))
		return hRes;
#endif
	// registers object, typelib and all interfaces in typelib
	return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
	PrxDllUnregisterServer();
#endif
	_Module.UnregisterServer();
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\lonsi\dllmain.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    dllmain.cxx

Abstract:

    Main file for the NT LONSI(Library of Non-Standard Interfaces)

Author:

    Johnson Apacible    (johnsona)      13-Nov-1996

--*/


#include "lonsint.hxx"
#include <inetsvcs.h>

DECLARE_DEBUG_VARIABLE();
DECLARE_DEBUG_PRINTS_OBJECT();

extern CRITICAL_SECTION     Logon32Lock;

extern "C"
BOOL WINAPI
DllEntry(
    HINSTANCE hDll,
    DWORD dwReason,
    LPVOID lpvReserved
    )
{
    BOOL  fReturn = TRUE;


    switch ( dwReason ) {

    case DLL_PROCESS_ATTACH:

        CREATE_DEBUG_PRINT_OBJECT("lonsint");

        if ( !VALID_DEBUG_PRINT_OBJECT()) {
            IIS_PRINTF((buff,"Cannot create debug object\n"));
            return ( FALSE);
        }

        LOAD_DEBUG_FLAGS_FROM_REG_STR("System\\CurrentControlSet\\Services\\InetInfo\\Parameters", 0);

        DisableThreadLibraryCalls(hDll);

        INITIALIZE_CRITICAL_SECTION( &Logon32Lock );

        break;

    case DLL_PROCESS_DETACH:

        DeleteCriticalSection( &Logon32Lock );

        DELETE_DEBUG_PRINT_OBJECT();
        break;

    default:
        break ;
    }

    return ( fReturn);

} // DllEntry
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\log\scripting\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__B758F2FF_A3D6_11D1_8B9C_080009DCC2FA__INCLUDED_)
#define AFX_STDAFX_H__B758F2FF_A3D6_11D1_8B9C_080009DCC2FA__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT


#define _ATL_APARTMENT_THREADED

#define DEFAULT_TRACE_FLAGS     (DEBUG_ERROR)

#include <dbgutil.h>

#ifdef _ASSERTE
#undef _ASSERTE
#endif

#define _ASSERTE    DBG_ASSERT

#ifndef _ATL_NO_DEBUG_CRT
#define _ATL_NO_DEBUG_CRT
#endif

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__B758F2FF_A3D6_11D1_8B9C_080009DCC2FA__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\log\server\logging.cxx ===
/*++

   Copyright    (c)    1995-1996    Microsoft Corporation

   Module  Name :
      Logging.cxx

   Abstract:
      Server Side logging object
      It is just a thin layer to call COMLOG

   Author:

       Terence Kwan    ( terryk )    18-Sep-1996

   Project:

       IIS Logging 3.0

--*/

#include "server.hxx"

#define SZ_COMLOG_DLL        "iscomlog.dll"

//
// Global dll entry points
//

P_ComLogInitializeLog       LOGGING::m_ComLogInitializeLog = NULL;
P_ComLogTerminateLog        LOGGING::m_ComLogTerminateLog = NULL;
P_ComLogLogInformation      LOGGING::m_ComLogLogInformation = NULL;
P_ComLogGetConfig           LOGGING::m_ComLogGetConfig = NULL;
P_ComLogSetConfig           LOGGING::m_ComLogSetConfig = NULL;
P_ComLogQueryExtraLogFields LOGGING::m_ComLogQueryExtraLogFields = NULL;
P_ComLogNotifyChange        LOGGING::m_ComLogNotifyChange = NULL;
P_ComLogCustomInformation   LOGGING::m_ComLogCustomInformation = NULL;

//
// initialize comlog modules
//

HINSTANCE                       LOGGING::m_hComLogDLL = NULL;
P_ComLogDllStartup              LOGGING::m_ComLogDllStartup = NULL;
P_ComLogDllCleanUp              LOGGING::m_ComLogDllCleanUp = NULL;

HANDLE Dummy_ComLogInitializeLog( LPCSTR, LPCSTR, LPVOID )
{
    return(NULL);
}

DWORD
Dummy_ComLogTerminateLog(
    IN HANDLE
    )
{
    return(ERROR_PROC_NOT_FOUND);
}

DWORD
Dummy_ComLogLogInformation(
        HANDLE,
        const INETLOG_INFORMATION *
        )
{
    return(ERROR_PROC_NOT_FOUND);
}

DWORD Dummy_ComLogGetConfig( HANDLE, INETLOG_CONFIGURATIONA * )
{
    return(ERROR_PROC_NOT_FOUND);
}

DWORD Dummy_ComLogSetConfig( HANDLE, const INETLOG_CONFIGURATIONA * )
{
    return(ERROR_PROC_NOT_FOUND);
}

DWORD
Dummy_ComLogQueryExtraLogFields(
            HANDLE,
            PCHAR,
            PDWORD
            )
{
    return(ERROR_PROC_NOT_FOUND);
}

DWORD Dummy_ComLogDllCleanUp()
{
    return(ERROR_PROC_NOT_FOUND);
}

DWORD Dummy_ComLogNotifyChange( HANDLE )
{
    return(ERROR_PROC_NOT_FOUND);
}

DWORD 
Dummy_ComLogCustomInformation(
        IN  HANDLE, 
        IN  DWORD, 
        IN  PCUSTOM_LOG_DATA,
        IN  LPSTR
        )
{
    return(ERROR_PROC_NOT_FOUND);
}

/* ------------------------------------------------------------------------------ */

LOGGING::LOGGING(
        VOID
        )
/*++

Routine Description:
    Contructor for the logging object.

Arguments:
    lpszInstanceName - name of the instance. ie, w3svc
    dwInstanceId     - id of the instance

Return Value:

--*/
{
    m_Handle = NULL;
    m_fRequiredExtraLoggingFields = FALSE;
    m_szExtraLoggingFields[0] = '\0';
    m_fMetabaseModified = FALSE;
}

LOGGING::~LOGGING()
/*++

Routine Description:
    Destructor for the logging object.

Arguments:

Return Value:

--*/
{
    //
    // end of logging object
    //

    ShutdownLogging();
}

BOOL
LOGGING::ActivateLogging(
    IN LPCSTR pszServiceName,
    IN DWORD  dwInstanceId,
    IN LPCSTR pszMetabasePath,
    IN LPVOID pvIMDCOM
    )
{
    CHAR tmpBuf[MAX_PATH];

    LockExclusive();
    
    wsprintf(tmpBuf,"%s%u", pszServiceName, dwInstanceId);

    m_strInstanceName.Copy(tmpBuf);
    m_strMetabasePath.Copy(pszMetabasePath);
    m_pvIMDCOM = pvIMDCOM;

    ShutdownLogging();          // Shut down all previous handles.
    
    if ( m_ComLogInitializeLog != NULL ) {

        m_Handle = (*m_ComLogInitializeLog)(
                            m_strInstanceName.QueryStr(),
                            m_strMetabasePath.QueryStr(),
                            pvIMDCOM
                            );
    }

    if (m_Handle != NULL ) {

        DWORD cbSize = sizeof(m_szExtraLoggingFields);

        (*m_ComLogQueryExtraLogFields)(
                            m_Handle,
                            m_szExtraLoggingFields,
                            &cbSize
                            );

        m_fRequiredExtraLoggingFields =
            (m_szExtraLoggingFields[0] != '\0');
    }

    Unlock();
    
    return TRUE;
} // LOGGING::ActivateLogging


BOOL
LOGGING::ShutdownLogging()
/*++

Routine Description:
    Terminate the log configuration information.

Arguments:

Return Value:
    err - error code.
    It will return NERR_Success if no error

--*/
{
    // if we have not terminated yet, terminate it


    LockExclusive();
    
    if (m_Handle != NULL) 
    {
        (*m_ComLogTerminateLog)( m_Handle );
        m_Handle = NULL;
    }

    Unlock();
    
    return(TRUE);
}


BOOL
LOGGING::NotifyChange(
    DWORD PropertyID
    )
/*++

Routine Description:
    Notify change in the log configuration information.

Arguments:
    PropertyID - property ID, or zero to signal end of changes

Return Value:
    err - error code.
    It will return NERR_Success if no error

--*/
{
    LockExclusive();
    
    if ( ((PropertyID >= IIS_MD_LOG_BASE) && (PropertyID <= IIS_MD_LOG_LAST)) ||
         ((PropertyID >= IIS_MD_LOGCUSTOM_BASE) && (PropertyID <= IIS_MD_LOGCUSTOM_LAST))
       )
    {
        m_fMetabaseModified = TRUE;

    } 

    Unlock();
    
    return(TRUE);
}


DWORD
LOGGING::LogInformation(
            IN const INETLOG_INFORMATION * pInetLogInfo
            )
{
    DWORD   dwErr;

    if ( m_fMetabaseModified ) 
    {
        ActOnChange();
    }

    LockShared();
    
    dwErr = ((*m_ComLogLogInformation)( m_Handle, pInetLogInfo ));

    Unlock();
    
    return dwErr;
    
} // LOGGING::LogInformation


DWORD 
LOGGING::LogCustomInformation(
            IN  DWORD               cCount, 
            IN  PCUSTOM_LOG_DATA    pCustomLogData,
            IN  LPSTR               szHeaderSuffix
            )
{
    DWORD   dwErr;

    if ( m_fMetabaseModified ) 
    {
        ActOnChange();
    }

    LockShared();

    dwErr = ((*m_ComLogCustomInformation)( m_Handle, cCount, pCustomLogData, szHeaderSuffix));

    Unlock();
    
    return dwErr;
}



DWORD
LOGGING::GetConfig(
    INETLOG_CONFIGURATIONA *pLogConfig
    )
{
    DWORD   dwErr;

    if ( m_fMetabaseModified ) 
    {
        ActOnChange();
    }

    LockShared();

    dwErr = ((*m_ComLogGetConfig)( m_Handle, pLogConfig ));

    Unlock();

    return dwErr;
}

BOOL LOGGING::IsRequiredExtraLoggingFields()
{
    if ( m_fMetabaseModified )
    {
        ActOnChange();
    }

    return m_fRequiredExtraLoggingFields;
}

CHAR *LOGGING::QueryExtraLoggingFields()
{
    if ( m_fMetabaseModified )
    {
        ActOnChange();
    }

    return m_szExtraLoggingFields;
}

VOID
LOGGING::ActOnChange()
{
    LockExclusive();

    if ( m_fMetabaseModified )
    {
        if (m_ComLogNotifyChange != NULL) {

            DWORD cbSize = sizeof(m_szExtraLoggingFields);

            (*m_ComLogNotifyChange)( m_Handle );

            //
            // See if we need extra log fields
            //

            (*m_ComLogQueryExtraLogFields)(
                                m_Handle,
                                m_szExtraLoggingFields,
                                &cbSize
                                );

            m_fRequiredExtraLoggingFields =
                (m_szExtraLoggingFields[0] != '\0');
        }

        m_fMetabaseModified = FALSE;
    }

    Unlock();
}

DWORD
LOGGING::SetConfig(
        INETLOG_CONFIGURATIONA *pRpcLogConfig
        )
{
    DWORD cbSize = sizeof(m_szExtraLoggingFields);

    LockExclusive();
    
    DWORD dwReturn = (*m_ComLogSetConfig)( m_Handle, pRpcLogConfig );

    (*m_ComLogQueryExtraLogFields)(
                    m_Handle,
                    m_szExtraLoggingFields,
                    &cbSize
                    );

    m_fRequiredExtraLoggingFields =
        (m_szExtraLoggingFields[0] != '\0');

    Unlock();
    
    return(dwReturn);
}


//
// Statics
//

DWORD
LOGGING::Terminate()
/*++

Routine Description:
    Terminate the logging object and kill the waiting queue.

Arguments:

Return Value:
    always return NO_ERROR

--*/
{
    if ( m_hComLogDLL != NULL ) {

        DBGPRINTF((DBG_CONTEXT,"Terminate: Freed iscomlog.dll\n"));

        //
        // call ComLog to terminate itself
        //

        (*m_ComLogDllCleanUp)();
        FreeLibrary( m_hComLogDLL );
        m_hComLogDLL = NULL;
    }

    return(NO_ERROR);
}


DWORD
LOGGING::Initialize()
/*++

Routine Description:
    Initialize the logging object by loading the ComLog dll and
    set up all the dll entry point

Arguments:

Return Value:
    return NO_ERROR if no error
    otherwise return ERROR_DLL_NOT_FOUND or ERROR_PROC_NOT_FOUND

--*/
{
    DWORD err = NO_ERROR;

    DBG_ASSERT(m_hComLogDLL == NULL);

    m_hComLogDLL = LoadLibrary( SZ_COMLOG_DLL );
    
    if (m_hComLogDLL!=NULL)
    {
        if ((( m_ComLogInitializeLog = (P_ComLogInitializeLog)GetProcAddress( m_hComLogDLL, (const char *)"ComLogInitializeLog")) == NULL ) ||
            (( m_ComLogTerminateLog = (P_ComLogTerminateLog)GetProcAddress( m_hComLogDLL, (const char *)"ComLogTerminateLog")) == NULL ) ||
            (( m_ComLogLogInformation = (P_ComLogLogInformation)GetProcAddress( m_hComLogDLL, (const char *)"ComLogLogInformation"))== NULL ) ||
            (( m_ComLogGetConfig = (P_ComLogGetConfig)GetProcAddress( m_hComLogDLL, (const char *)"ComLogGetConfig"))== NULL ) ||
            (( m_ComLogSetConfig = (P_ComLogSetConfig)GetProcAddress( m_hComLogDLL, (const char *)"ComLogSetConfig"))== NULL ) ||
            (( m_ComLogQueryExtraLogFields = (P_ComLogQueryExtraLogFields)GetProcAddress( m_hComLogDLL, (const char *)"ComLogQueryExtraLogFields"))== NULL ) ||
            (( m_ComLogDllStartup = (P_ComLogDllStartup)GetProcAddress(m_hComLogDLL, (const char *)"ComLogDllStartup"))== NULL ) ||
            (( m_ComLogNotifyChange = (P_ComLogNotifyChange)GetProcAddress(m_hComLogDLL, (const char *)"ComLogNotifyChange"))== NULL ) ||
            (( m_ComLogDllCleanUp = (P_ComLogDllCleanUp)GetProcAddress(m_hComLogDLL, (const char *)"ComLogDllCleanUp"))== NULL ) ||
            (( m_ComLogCustomInformation = (P_ComLogCustomInformation)GetProcAddress(m_hComLogDLL, (const char *)"ComLogCustomInformation"))== NULL )
            )
        {
            DBGPRINTF((DBG_CONTEXT,"missing entry point in ComLog dll\n"));

            m_ComLogInitializeLog       = &(Dummy_ComLogInitializeLog   );
            m_ComLogTerminateLog        = &(Dummy_ComLogTerminateLog    );
            m_ComLogLogInformation      = &(Dummy_ComLogLogInformation  );
            m_ComLogGetConfig           = &(Dummy_ComLogGetConfig       );
            m_ComLogSetConfig           = &(Dummy_ComLogSetConfig       );
            m_ComLogDllCleanUp          = &(Dummy_ComLogDllCleanUp      );
            m_ComLogNotifyChange        = &(Dummy_ComLogNotifyChange    );
            m_ComLogQueryExtraLogFields = &(Dummy_ComLogQueryExtraLogFields  );
            m_ComLogCustomInformation   = &(Dummy_ComLogCustomInformation  );

            err = ERROR_PROC_NOT_FOUND;
        } else {

            //
            // Initialize ComLog
            //

            err = (*m_ComLogDllStartup)();
        }

    } else {
        DBGPRINTF((DBG_CONTEXT,"Failed to load iscomlog.dll\n"));
        err = ERROR_DLL_NOT_FOUND;
    }

    return(err);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\lonsi\logon32.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    logon32.cxx

Abstract:

    Provide a replacement for LogonUser to login a user
    as a net logon. Also support sub-authentication DLL IDs

Author:

    Philippe Choquier (phillich)    10-january-1996
    Created from base\advapi\logon32.c

--*/


#include "lonsint.hxx"

#pragma hdrstop

extern "C" {

#include <ntsam.h>
#include <ntlsa.h>
#include <ntmsv1_0.h>
#include <kerberos.h>
#include <crypt.h>
#include <logonmsv.h>
#include <inetsec.h>
#define SECURITY_WIN32
#include <sspi.h>           // Security Support Provider APIs
#include <issperr.h>
}
#include <svcloc.h>
#include <lonsi.hxx>
#include <tslogon.hxx>
#include <buffer.hxx>

#if !defined(MSV1_0_RETURN_PASSWORD_EXPIRY)
#define MSV1_0_RETURN_PASSWORD_EXPIRY 0x40
#endif


//
// We dynamically load mpr.dll (no big surprise there), in order to call
// WNetLogonNotify, as defined in private\inc\mpr.h.  This prototype matches
// it -- consult the header file for all the parameters.
//
typedef (* LOGONNOTIFYFN)(LPCWSTR, PLUID, LPCWSTR, LPVOID,
                            LPCWSTR, LPVOID, LPWSTR, LPVOID, LPWSTR *);

#define LEN_ALIGN(a,b)  (((a)+b-1)&~(b-1))

ULONG
BaseSetLastNTError(
    IN NTSTATUS Status
    )

/*++

Routine Description:

    This API sets the "last error value" and the "last error string"
    based on the value of Status. For status codes that don't have
    a corresponding error string, the string is set to null.

Arguments:

    Status - Supplies the status value to store as the last error value.

Return Value:

    The corresponding Win32 error code that was stored in the
    "last error value" thread variable.

--*/

{
    ULONG dwErrorCode;

    dwErrorCode = RtlNtStatusToDosError( Status );
    SetLastError( dwErrorCode );
    return( dwErrorCode );
}

//
// The QuotaLimits are global, because the defaults
// are always used for accounts, based on server/wksta, and no one ever
// calls lsasetaccountquota
//

HANDLE      Logon32LsaHandle = NULL;
ULONG       Logon32MsvHandle = 0xFFFFFFFF;
ULONG       Logon32KerberosHandle = 0xFFFFFFFF;
WCHAR       Logon32DomainName[16] = L"";    // NOTE:  This should be DNLEN from
                                            // lmcons.h, but that would be a
                                            // lot of including
QUOTA_LIMITS    Logon32QuotaLimits;
LOGONNOTIFYFN   Logon32LogonNotify = NULL;
HINSTANCE       Logon32MprHandle = NULL;

CRITICAL_SECTION Logon32Lock;

BOOL            fLsaInitialized = FALSE;

#define LockLogon()     EnterCriticalSection( &Logon32Lock )
#define UnlockLogon()   LeaveCriticalSection( &Logon32Lock )

SID_IDENTIFIER_AUTHORITY L32SystemSidAuthority = SECURITY_NT_AUTHORITY;
SID_IDENTIFIER_AUTHORITY L32LocalSidAuthority = SECURITY_LOCAL_SID_AUTHORITY;


#define COMMON_CREATE_SUSPENDED 0x00000001  // Suspended, do not Resume()
#define COMMON_CREATE_PROCESSSD 0x00000002  // Whack the process SD
#define COMMON_CREATE_THREADSD  0x00000004  // Whack the thread SD

BOOL
IISLogon32Initialize(
    IN PVOID    hMod,
    IN ULONG    Reason,
    IN PCONTEXT Context)
/*++

Routine Description:

    Initializes the critical section

Arguments:

    hMod -- reserved, must be NULL
    Reason -- DLL_PROCESS_ATTACH or DLL_PROCESS_DETACH
    Context -- reserved, must be NULL

Returns:

    TRUE if initialization success, else FALSE

--*/
{
    return( TRUE );
}


PSID
L32CreateLogonSid(
    PLUID LogonId OPTIONAL
    )
/*++

Routine Description:

    Creates a logon sid for a new logon.

Arguments:

    LogonId -- If non NULL, on return the LUID that is part of the logon
               sid is returned here.

Returns:

    Logon SID or NULL if error

--*/
{
    NTSTATUS Status;
    ULONG   Length;
    PSID    Sid;
    LUID    Luid;

    //
    // Generate a locally unique id to include in the logon sid
    //

    Status = NtAllocateLocallyUniqueId(&Luid);
    if (!NT_SUCCESS(Status)) {
        return(NULL);
    }


    //
    // Allocate space for the sid and fill it in.
    //

    Length = RtlLengthRequiredSid(SECURITY_LOGON_IDS_RID_COUNT);

    Sid = (PSID)LocalAlloc(LMEM_FIXED, Length);

    if (Sid != NULL) {

        RtlInitializeSid(Sid, &L32SystemSidAuthority, SECURITY_LOGON_IDS_RID_COUNT);

        ASSERT(SECURITY_LOGON_IDS_RID_COUNT == 3);

        *(RtlSubAuthoritySid(Sid, 0)) = SECURITY_LOGON_IDS_RID;
        *(RtlSubAuthoritySid(Sid, 1 )) = Luid.HighPart;
        *(RtlSubAuthoritySid(Sid, 2 )) = Luid.LowPart;
    }


    //
    // Return the logon LUID if required.
    //

    if (LogonId != NULL) {
        *LogonId = Luid;
    }

    return(Sid);
}


BOOL
L32pInitLsa(
    void
    )
/*++

Routine Description:

    Initialize connection with LSA

Arguments:

    None

Returns:

    TRUE if success, FALSE if error

--*/
{
    char    MyName[MAX_PATH];
    char *  ModuleName;
    STRING  LogonProcessName;
    STRING  PackageName;
    ULONG   dummy;
    NTSTATUS Status;
    BOOLEAN WasEnabled;

    Status = RtlAdjustPrivilege(SE_TCB_PRIVILEGE, TRUE, FALSE, &WasEnabled);
    if (!NT_SUCCESS(Status))
    {
        BaseSetLastNTError(Status);
        return(FALSE);
    }

    if (GetModuleFileNameA(NULL, MyName, MAX_PATH))
    {
        ModuleName = strrchr(MyName, '\\');
        if (!ModuleName)
        {
            ModuleName = MyName;
        }
    }
    else
    {
        BaseSetLastNTError(STATUS_OBJECT_NAME_NOT_FOUND);
        return(FALSE);
    }


    //
    // Hookup to the LSA and locate our authentication package.
    //

    RtlInitString(&LogonProcessName, ModuleName);
    Status = LsaRegisterLogonProcess(
                 &LogonProcessName,
                 &Logon32LsaHandle,
                 &dummy
                 );


    //
    // Turn off the privilege now.
    //
    if (!WasEnabled)
    {
        (VOID) RtlAdjustPrivilege(SE_TCB_PRIVILEGE, FALSE, FALSE, &WasEnabled);
    }

    if (!NT_SUCCESS(Status)) {
        BaseSetLastNTError(Status);
        return(FALSE);
    }


    //
    // Connect with the MSV1_0 authentication package
    //
    RtlInitString(&PackageName, "MICROSOFT_AUTHENTICATION_PACKAGE_V1_0");
    Status = LsaLookupAuthenticationPackage (
                Logon32LsaHandle,
                &PackageName,
                &Logon32MsvHandle
                );
    if (!NT_SUCCESS(Status)) {
        BaseSetLastNTError(Status);
        
        (VOID) LsaDeregisterLogonProcess( Logon32LsaHandle );
        Logon32LsaHandle = NULL;
        
        return(FALSE);
    }
                
    //
    // Get the kerberos package
    // 
    RtlInitString(&PackageName, MICROSOFT_KERBEROS_NAME_A);
    Status = LsaLookupAuthenticationPackage (
                Logon32LsaHandle,
                &PackageName,
                &Logon32KerberosHandle
                );

    if (!NT_SUCCESS(Status)) {
        BaseSetLastNTError(Status);
        
        (VOID) LsaDeregisterLogonProcess( Logon32LsaHandle );
        Logon32LsaHandle = NULL;
        
        Logon32MsvHandle = 0xFFFFFFFF;
        
        return(FALSE);
    }
    
    //
    // We are now initialized (duh)
    //
    
    fLsaInitialized = TRUE;

    return(TRUE);
}

//+---------------------------------------------------------------------------
//
//  Function:   L32pNotifyMpr
//
//  Synopsis:   Loads the MPR DLL and notifies the network providers (like
//              csnw) so they know about this logon session and the credentials
//
//  Arguments:  [NewLogon] -- New logon information
//              [LogonId]  -- Logon ID
//
//  History:    4-24-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
L32pNotifyMpr(
    PMSV1_0_INTERACTIVE_LOGON   NewLogon,
    PLUID                       LogonId
    )
{
    MSV1_0_INTERACTIVE_LOGON    OldLogon;
    LPWSTR                      LogonScripts;
    DWORD                       status;

    if ( Logon32MprHandle == NULL )
    {
        LockLogon();

        if ( Logon32MprHandle == NULL)
        {
            Logon32MprHandle =  LoadLibrary("mpr.dll");
            if (Logon32MprHandle != NULL) {

                Logon32LogonNotify = (LOGONNOTIFYFN) GetProcAddress(
                                        Logon32MprHandle,
                                        "WNetLogonNotify");

            }
        }

        UnlockLogon();

    }

    if ( Logon32LogonNotify != NULL )
    {


        CopyMemory(&OldLogon, NewLogon, sizeof(OldLogon));

        status = Logon32LogonNotify(
                        L"Windows NT Network Provider",
                        LogonId,
                        L"MSV1_0:Interactive",
                        (LPVOID)NewLogon,
                        L"MSV1_0:Interactive",
                        (LPVOID)&OldLogon,
                        L"SvcCtl",          // StationName
                        NULL,               // StationHandle
                        &LogonScripts);     // LogonScripts

        if (status == NO_ERROR) {
            if (LogonScripts != NULL ) {
                (void) LocalFree(LogonScripts);
            }
        }

        return( TRUE );
    }

    return( FALSE );
}


NTSTATUS
L32pLogonNetUser(
    IN HANDLE LsaHandle,
    IN ULONG AuthenticationPackage,
    IN SECURITY_LOGON_TYPE LogonType,
    IN PUNICODE_STRING UserName,
    IN PUNICODE_STRING Domain,
    IN PSTRING Password,
    IN PUNICODE_STRING Workstation,
    IN DWORD dwSubAuth,
    IN PSID LogonSid,
    OUT PLUID LogonId,
    OUT PHANDLE LogonToken,
    OUT PQUOTA_LIMITS Quotas,
    OUT PVOID *pProfileBuffer,
    OUT PULONG pProfileBufferLength,
    OUT PNTSTATUS pSubStatus
    )
/*++

Routine Description:

    Wraps up the call to LsaLogonUser

Arguments:

    LsaHandle -- handle to LSA package
    AuthenticationPackage -- ID of authentication package to use
    LogonType -- Interactive, network, ...
    UserName -- User Name
    Domain -- Domain validating the user name
    Password -- clear text password, can be empty if a sub-auth package is used
    Workstation -- workstation where the login take place, can be NULL
                   if local login
    dwSubAuth -- Sub-authentication DLL ID
    LogonSid -- Logon SID for this session
    LogonId -- created logon ID
    LogonToken -- created logon token
    Quotas -- quota info
    pProfileBuffer -- account profile
    pProfileBufferLength -- account profile length
    pSubStatus -- substatus for authentication failure

Returns:

    0 if success, else NT status

--*/
{
    NTSTATUS Status;
    STRING OriginName;
    TOKEN_SOURCE SourceContext;
    PMSV1_0_LM20_LOGON MsvAuthInfo;
    PMSV1_0_LM20_LOGON MsvNetAuthInfo;
    PMSV1_0_INTERACTIVE_LOGON MsvInterAuthInfo;
    PMSV1_0_SUBAUTH_LOGON MsvSubAuthInfo;
    PVOID AuthInfoBuf;
    ULONG AuthInfoSize;
    PTOKEN_GROUPS TokenGroups;
    PSID LocalSid;
    UNICODE_STRING UnicodePassword;
    //WCHAR ComputerName[ MAX_COMPUTERNAME_LENGTH + 1 ];
    DWORD ComputerNameLength;

    NT_RESPONSE NtResponse;
    LM_RESPONSE LmResponse;

    union {
        LUID            Luid;
        NT_CHALLENGE    NtChallenge;
    } Challenge;

    NT_OWF_PASSWORD PasswordHash;
    OEM_STRING  LmPassword;
    UCHAR       LmPasswordBuf[ LM20_PWLEN + 1 ];
    LM_OWF_PASSWORD LmPasswordHash;


#if DBG
    if (!RtlValidSid(LogonSid))
    {
        return(STATUS_INVALID_PARAMETER);
    }
#endif

    //
    // Initialize source context structure
    //

    strncpy(SourceContext.SourceName, "IIS     ", sizeof(SourceContext.SourceName)); // LATER from res file

    Status = NtAllocateLocallyUniqueId(&SourceContext.SourceIdentifier);

    if (!NT_SUCCESS(Status))
    {
        return(Status);
    }

    UnicodePassword.Buffer = NULL;

    //
    // Set logon origin
    //

    RtlInitString(&OriginName, "IIS security API");

    //
    // For network logons, do the magic.
    //

    if ( LogonType == Network )
    {
#if 0
        ComputerNameLength = MAX_COMPUTERNAME_LENGTH + 1;

        if (!GetComputerNameW( ComputerName, &ComputerNameLength ) )
        {
            return( STATUS_INVALID_PARAMETER );
        }
#else
        ComputerNameLength = wcslen( Workstation->Buffer );
#endif

        if (!RtlCreateUnicodeStringFromAsciiz( &UnicodePassword, Password->Buffer ))
        {
            return STATUS_NO_MEMORY;
        }

        AuthInfoSize = sizeof( MSV1_0_LM20_LOGON ) +
                        sizeof( WCHAR ) * ( wcslen( UserName->Buffer ) + 1 +
                                            wcslen( Domain->Buffer ) + 1 +
                                            ComputerNameLength + 1) +
                                            NT_RESPONSE_LENGTH +
                                            LM_RESPONSE_LENGTH ;

        MsvNetAuthInfo = (PMSV1_0_LM20_LOGON)
                         (AuthInfoBuf = RtlAllocateHeap( RtlProcessHeap(),
                                                        HEAP_ZERO_MEMORY,
                                                        AuthInfoSize ));

        if ( !MsvNetAuthInfo )
        {
            return( STATUS_NO_MEMORY );
        }

        //
        // Start packing in the string
        //

        MsvNetAuthInfo->MessageType = MsV1_0NetworkLogon;

        //
        // Copy the user name into the authentication buffer
        //

        MsvNetAuthInfo->UserName.Length =
                    (USHORT)sizeof(WCHAR)*wcslen(UserName->Buffer);
        MsvNetAuthInfo->UserName.MaximumLength =
                    MsvNetAuthInfo->UserName.Length + sizeof(WCHAR);

        MsvNetAuthInfo->UserName.Buffer = (PWSTR)(MsvNetAuthInfo+1);
        wcscpy(MsvNetAuthInfo->UserName.Buffer, UserName->Buffer);


        //
        // Copy the domain name into the authentication buffer
        //

        MsvNetAuthInfo->LogonDomainName.Length =
                     (USHORT)sizeof(WCHAR)*wcslen(Domain->Buffer);
        MsvNetAuthInfo->LogonDomainName.MaximumLength =
                     MsvNetAuthInfo->LogonDomainName.Length + sizeof(WCHAR);

        MsvNetAuthInfo->LogonDomainName.Buffer = (PWSTR)
                                     ((PBYTE)(MsvNetAuthInfo->UserName.Buffer) +
                                     MsvNetAuthInfo->UserName.MaximumLength);

        wcscpy(MsvNetAuthInfo->LogonDomainName.Buffer, Domain->Buffer);

        //
        // Copy the workstation name into the buffer
        //

        MsvNetAuthInfo->Workstation.Length = (USHORT)
                            (sizeof(WCHAR) * ComputerNameLength);

        MsvNetAuthInfo->Workstation.MaximumLength =
                            MsvNetAuthInfo->Workstation.Length + sizeof(WCHAR);

        MsvNetAuthInfo->Workstation.Buffer = (PWSTR)
                            ((PBYTE) (MsvNetAuthInfo->LogonDomainName.Buffer) +
                            MsvNetAuthInfo->LogonDomainName.MaximumLength );

        wcscpy( MsvNetAuthInfo->Workstation.Buffer, Workstation->Buffer );

        //
        // Now, generate the bits for the challenge
        //

        Status = NtAllocateLocallyUniqueId( &Challenge.Luid );

        if ( !NT_SUCCESS(Status) )
        {
            RtlFreeHeap( RtlProcessHeap(), 0, MsvNetAuthInfo );

            return( Status );
        }

        RtlCopyMemory(  MsvNetAuthInfo->ChallengeToClient,
                        & Challenge,
                        MSV1_0_CHALLENGE_LENGTH );

        //
        // Set up space for response
        //

        MsvNetAuthInfo->CaseSensitiveChallengeResponse.Buffer = (PCHAR)
                    ((PBYTE) (MsvNetAuthInfo->Workstation.Buffer) +
                    MsvNetAuthInfo->Workstation.MaximumLength );

        MsvNetAuthInfo->CaseSensitiveChallengeResponse.Length =
                            NT_RESPONSE_LENGTH;

        MsvNetAuthInfo->CaseSensitiveChallengeResponse.MaximumLength =
                            NT_RESPONSE_LENGTH;

        RtlCalculateNtOwfPassword(
                    & UnicodePassword,
                    & PasswordHash );

        RtlCalculateNtResponse(
                & Challenge.NtChallenge,
                & PasswordHash,
                & NtResponse );

        RtlCopyMemory(  MsvNetAuthInfo->CaseSensitiveChallengeResponse.Buffer,
                        & NtResponse,
                        NT_RESPONSE_LENGTH );

        //
        // Now do the painful LM compatible hash, so anyone who is maintaining
        // their account from a WfW machine will still have a password.
        //

        LmPassword.Buffer = (CHAR*)LmPasswordBuf;
        LmPassword.Length = LmPassword.MaximumLength = LM20_PWLEN + 1;

        Status = RtlUpcaseUnicodeStringToOemString(
                        & LmPassword,
                        & UnicodePassword,
                        FALSE );

        if ( NT_SUCCESS(Status) )
        {

            MsvNetAuthInfo->CaseInsensitiveChallengeResponse.Buffer = (PCHAR)
               ((PBYTE) (MsvNetAuthInfo->CaseSensitiveChallengeResponse.Buffer) +
               MsvNetAuthInfo->CaseSensitiveChallengeResponse.MaximumLength );

            MsvNetAuthInfo->CaseInsensitiveChallengeResponse.Length =
                            LM_RESPONSE_LENGTH;

            MsvNetAuthInfo->CaseInsensitiveChallengeResponse.MaximumLength =
                            LM_RESPONSE_LENGTH;


            RtlCalculateLmOwfPassword(
                        LmPassword.Buffer,
                        & LmPasswordHash );

            ZeroMemory( LmPassword.Buffer, LmPassword.Length );

            RtlCalculateLmResponse(
                        & Challenge.NtChallenge,
                        & LmPasswordHash,
                        & LmResponse );

            RtlCopyMemory(  MsvNetAuthInfo->CaseInsensitiveChallengeResponse.Buffer,
                            & LmResponse,
                            LM_RESPONSE_LENGTH );
        }
        else
        {
            //
            // If we're here, the NT (supplied) password is longer than the
            // limit allowed for LM passwords.  NULL out the field, so that
            // MSV knows not to worry about it.
            //

            RtlZeroMemory( &MsvNetAuthInfo->CaseInsensitiveChallengeResponse,
                           sizeof( STRING ) );
        }

        MsvNetAuthInfo->ParameterControl = MSV1_0_RETURN_PASSWORD_EXPIRY;
    }
    else if ( LogonType == (SECURITY_LOGON_TYPE)IIS_Network )
    {
        if (!RtlCreateUnicodeStringFromAsciiz( &UnicodePassword, Password->Buffer ))
        {
            return STATUS_NO_MEMORY;
        }

        //
        // Build logon structure for IIS network logons. We'll be using the subauth DLL
        // in this case
        //

        AuthInfoSize = sizeof(MSV1_0_SUBAUTH_LOGON) +
            sizeof(WCHAR)*(wcslen(UserName->Buffer) + 1 +
                           wcslen(Domain->Buffer)   + 1 +
                           wcslen(Workstation->Buffer) + 1 ) +
            sizeof(WCHAR)*wcslen(UnicodePassword.Buffer) +
            LEN_ALIGN(strlen(Password->Buffer),sizeof(WCHAR));

        AuthInfoBuf = RtlAllocateHeap( RtlProcessHeap(),
                                       HEAP_ZERO_MEMORY,
                                       AuthInfoSize);
        MsvSubAuthInfo = (PMSV1_0_SUBAUTH_LOGON)AuthInfoBuf;

        if (MsvSubAuthInfo == NULL) {
            return(STATUS_NO_MEMORY);
        }

        //
        // This authentication buffer will be used for a logon attempt
        //

        MsvSubAuthInfo->MessageType = MsV1_0SubAuthLogon;

        MsvSubAuthInfo->SubAuthPackageId = dwSubAuth;

        //
        // Copy the domain name into the authentication buffer
        //

        MsvSubAuthInfo->LogonDomainName.Length =
                     (USHORT)sizeof(WCHAR)*wcslen(Domain->Buffer);
        MsvSubAuthInfo->LogonDomainName.MaximumLength =
                     MsvSubAuthInfo->LogonDomainName.Length + sizeof(WCHAR);
        MsvSubAuthInfo->LogonDomainName.Buffer = (PWSTR)(MsvSubAuthInfo+1);

        wcscpy(MsvSubAuthInfo->LogonDomainName.Buffer, Domain->Buffer);


        //
        // Copy the user name into the authentication buffer
        //

        MsvSubAuthInfo->UserName.Length =
                    (USHORT)sizeof(WCHAR)*wcslen(UserName->Buffer);
        MsvSubAuthInfo->UserName.MaximumLength =
                    MsvSubAuthInfo->UserName.Length + sizeof(WCHAR);
        MsvSubAuthInfo->UserName.Buffer = (PWSTR)
                                     ((PBYTE)(MsvSubAuthInfo->LogonDomainName.Buffer) +
                                     MsvSubAuthInfo->LogonDomainName.MaximumLength);
        wcscpy(MsvSubAuthInfo->UserName.Buffer, UserName->Buffer);


        //
        // Copy the workstation
        //

        MsvSubAuthInfo->Workstation.Length =
                     (USHORT)sizeof(WCHAR)*wcslen(Workstation->Buffer);
        MsvSubAuthInfo->Workstation.MaximumLength =
                     MsvSubAuthInfo->Workstation.Length + sizeof(WCHAR);

        MsvSubAuthInfo->Workstation.Buffer = (PWSTR)
                                     ((PBYTE)(MsvSubAuthInfo->UserName.Buffer) +
                                     MsvSubAuthInfo->UserName.MaximumLength);
        wcscpy(MsvSubAuthInfo->Workstation.Buffer, Workstation->Buffer);


        memset( MsvSubAuthInfo->ChallengeToClient,
                '\0',
                sizeof(MsvSubAuthInfo->ChallengeToClient) );

        MsvSubAuthInfo->AuthenticationInfo1.Buffer =
                     ((PCHAR)(MsvSubAuthInfo->Workstation.Buffer) +
                     MsvSubAuthInfo->Workstation.MaximumLength);
        MsvSubAuthInfo->AuthenticationInfo1.Length = (USHORT)sizeof(WCHAR)*wcslen(UnicodePassword.Buffer);

        MsvSubAuthInfo->AuthenticationInfo1.MaximumLength
            = MsvSubAuthInfo->AuthenticationInfo1.Length;

        memcpy( MsvSubAuthInfo->AuthenticationInfo1.Buffer,
                UnicodePassword.Buffer,
                MsvSubAuthInfo->AuthenticationInfo1.Length );

        MsvSubAuthInfo->AuthenticationInfo2.Buffer =
                     ((PCHAR)(MsvSubAuthInfo->AuthenticationInfo1.Buffer) +
                     MsvSubAuthInfo->AuthenticationInfo1.MaximumLength);

        MsvSubAuthInfo->AuthenticationInfo2.Length = (USHORT)strlen(Password->Buffer);

        MsvSubAuthInfo->AuthenticationInfo2.MaximumLength
            = LEN_ALIGN(MsvSubAuthInfo->AuthenticationInfo2.Length,sizeof(WCHAR));

        memcpy( MsvSubAuthInfo->AuthenticationInfo2.Buffer,
                Password->Buffer,
                MsvSubAuthInfo->AuthenticationInfo2.Length );

        MsvSubAuthInfo->ParameterControl = (dwSubAuth << MSV1_0_SUBAUTHENTICATION_DLL_SHIFT)
                | MSV1_0_UPDATE_LOGON_STATISTICS
                | MSV1_0_DONT_TRY_GUEST_ACCOUNT
                | MSV1_0_CLEARTEXT_PASSWORD_ALLOWED
                | MSV1_0_RETURN_PASSWORD_EXPIRY
                | MSV1_0_SUBAUTHENTICATION_DLL_EX
                | MSV1_0_DISABLE_PERSONAL_FALLBACK
                ;

        LogonType = Network;
    }
    else
    {
        //
        // Build logon structure for non-network logons - service,
        // batch, interactive
        //

        if (!RtlCreateUnicodeStringFromAsciiz( &UnicodePassword, Password->Buffer ))
        {
            return STATUS_NO_MEMORY;
        }

        AuthInfoSize = sizeof(MSV1_0_INTERACTIVE_LOGON) +
            sizeof(WCHAR)*(wcslen(UserName->Buffer) + 1 +
                           wcslen(Domain->Buffer)   + 1 +
                           wcslen(UnicodePassword.Buffer) + 1 );

        AuthInfoBuf = RtlAllocateHeap( RtlProcessHeap(),
                                       HEAP_ZERO_MEMORY,
                                       AuthInfoSize);
        MsvInterAuthInfo = (PMSV1_0_INTERACTIVE_LOGON)AuthInfoBuf;

        if (MsvInterAuthInfo == NULL)
        {
            return STATUS_NO_MEMORY;
        }

        //
        // This authentication buffer will be used for a logon attempt
        //

        MsvInterAuthInfo->MessageType = MsV1_0InteractiveLogon;


        //
        // Copy the user name into the authentication buffer
        //

        MsvInterAuthInfo->UserName.Length =
                    (USHORT)sizeof(WCHAR)*wcslen(UserName->Buffer);
        MsvInterAuthInfo->UserName.MaximumLength =
                    MsvInterAuthInfo->UserName.Length + sizeof(WCHAR);

        MsvInterAuthInfo->UserName.Buffer = (PWSTR)(MsvInterAuthInfo+1);
        wcscpy(MsvInterAuthInfo->UserName.Buffer, UserName->Buffer);


        //
        // Copy the domain name into the authentication buffer
        //

        MsvInterAuthInfo->LogonDomainName.Length =
                     (USHORT)sizeof(WCHAR)*wcslen(Domain->Buffer);
        MsvInterAuthInfo->LogonDomainName.MaximumLength =
                     MsvInterAuthInfo->LogonDomainName.Length + sizeof(WCHAR);

        MsvInterAuthInfo->LogonDomainName.Buffer = (PWSTR)
                                     ((PBYTE)(MsvInterAuthInfo->UserName.Buffer) +
                                     MsvInterAuthInfo->UserName.MaximumLength);

        wcscpy(MsvInterAuthInfo->LogonDomainName.Buffer, Domain->Buffer);

        //
        // Copy the password into the authentication buffer
        // Hide it once we have copied it.  Use the same seed value
        // that we used for the original password in pGlobals.
        //


        MsvInterAuthInfo->Password.Length =
                     (USHORT)sizeof(WCHAR)*wcslen(UnicodePassword.Buffer);
        MsvInterAuthInfo->Password.MaximumLength =
                     MsvInterAuthInfo->Password.Length + sizeof(WCHAR);

        MsvInterAuthInfo->Password.Buffer = (PWSTR)
                                     ((PBYTE)(MsvInterAuthInfo->LogonDomainName.Buffer) +
                                     MsvInterAuthInfo->LogonDomainName.MaximumLength);

        wcscpy(MsvInterAuthInfo->Password.Buffer, UnicodePassword.Buffer);
    }

    //
    // Create logon token groups
    //

#define TOKEN_GROUP_COUNT   2 // We'll add the local SID and the logon SID

    TokenGroups = (PTOKEN_GROUPS) RtlAllocateHeap(RtlProcessHeap(), 0,
                                    sizeof(TOKEN_GROUPS) +
                  (TOKEN_GROUP_COUNT - ANYSIZE_ARRAY) * sizeof(SID_AND_ATTRIBUTES));

    if (TokenGroups == NULL) {
        RtlFreeHeap(RtlProcessHeap(), 0, AuthInfoBuf);
        return(STATUS_NO_MEMORY);
    }

    //
    // Fill in the logon token group list
    //

    Status = RtlAllocateAndInitializeSid(
                    &L32LocalSidAuthority,
                    1,
                    SECURITY_LOCAL_RID,
                    0, 0, 0, 0, 0, 0, 0,
                    &LocalSid
                    );


    TokenGroups->GroupCount = TOKEN_GROUP_COUNT;
    TokenGroups->Groups[0].Sid = LogonSid;
    TokenGroups->Groups[0].Attributes =
            SE_GROUP_MANDATORY | SE_GROUP_ENABLED |
            SE_GROUP_ENABLED_BY_DEFAULT | SE_GROUP_LOGON_ID;
    TokenGroups->Groups[1].Sid = LocalSid;
    TokenGroups->Groups[1].Attributes =
            SE_GROUP_MANDATORY | SE_GROUP_ENABLED |
            SE_GROUP_ENABLED_BY_DEFAULT;

    //
    // Now try to log this one on
    //

    Status = LsaLogonUser (
                 LsaHandle,
                 &OriginName,
                 LogonType,
                 AuthenticationPackage,
                 AuthInfoBuf,
                 AuthInfoSize,
                 TokenGroups,
                 &SourceContext,
                 pProfileBuffer,
                 pProfileBufferLength,
                 LogonId,
                 LogonToken,
                 Quotas,
                 pSubStatus
                 );

    //
    // Discard token group list
    //

    RtlFreeHeap(RtlProcessHeap(), 0, TokenGroups);

    //
    // Notify all the network providers, if this is a NON network logon
    //

    if ( NT_SUCCESS( Status ) &&
         LogonType != Network &&
         LogonType != IIS_Network )
    {
        L32pNotifyMpr( (PMSV1_0_INTERACTIVE_LOGON)AuthInfoBuf, LogonId );
    }

    //
    // Discard authentication buffer
    //

    RtlFreeHeap(RtlProcessHeap(), 0, AuthInfoBuf);

    if ( UnicodePassword.Buffer != NULL )
    {
        RtlFreeUnicodeString(&UnicodePassword);
    }

    RtlFreeSid(LocalSid);

    return(Status);
}


BOOL
WINAPI
IISLogonNetUserW(
    PWSTR           lpszUsername,
    PWSTR           lpszDomain,
    PSTR            lpszPassword,
    PWSTR           lpszWorkstation,
    DWORD           dwSubAuth,
    DWORD           dwLogonType,
    DWORD           dwLogonProvider,
    HANDLE *        phToken,
    LARGE_INTEGER * pExpiry
    )
/*++

Routine Description:

    Logs a user on via username and domain
    name via the LSA.

Arguments:

    lpszUsername -- user name
    lpszDomain -- domain validating the user name
    lpszPassword -- clear text password, can be empty if a sub-auth DLL
                    is used
    lpszWorkstation -- workstation requesting the login, can be NULL
                       for local workstation
    dwSubAuth -- sub-auth DLL ID
    dwLogonType -- one of LOGON32_LOGON_NETWORK, LOGON32_LOGON_IIS_NETWORK
    dwLogonProvider -- must be LOGON32_PROVIDER_DEFAULT
    phToken -- created access token
    pExpiry -- ptr to pwd expiration time

Returns:

    TRUE if success, FALSE if error

--*/
{

    NTSTATUS    Status;
    ULONG       PackageId;
    UNICODE_STRING  Username;
    UNICODE_STRING  Domain;
    STRING      Password;
    UNICODE_STRING  Workstation;
    LUID        LogonId;
    PSID        pLogonSid;
    PVOID       Profile;
    ULONG       ProfileLength;
    NTSTATUS    SubStatus;
    SECURITY_LOGON_TYPE LogonType;
    WCHAR       achComputerName[MAX_COMPUTERNAME_LENGTH+1];

    //
    // Validate the provider
    //
    if (dwLogonProvider == LOGON32_PROVIDER_DEFAULT)
    {
        dwLogonProvider = LOGON32_PROVIDER_WINNT35;
    }

    if (dwLogonProvider != LOGON32_PROVIDER_WINNT35)
    {
        BaseSetLastNTError(STATUS_INVALID_PARAMETER);
        return(FALSE);
    }

    switch (dwLogonType)
    {
        case LOGON32_LOGON_IIS_NETWORK:
            LogonType = (SECURITY_LOGON_TYPE)IIS_Network;
            break;

        case LOGON32_LOGON_NETWORK:
            LogonType = Network;
            break;

        case LOGON32_LOGON_INTERACTIVE:
            LogonType = Interactive;
            break;

        case LOGON32_LOGON_BATCH:
            LogonType = Batch;
            break;

        case LOGON32_LOGON_SERVICE:
            LogonType = Service;
            break;
            
        case LOGON32_LOGON_NETWORK_CLEARTEXT:
            LogonType = NetworkCleartext;
            break;

        default:
            BaseSetLastNTError(STATUS_INVALID_PARAMETER);
            return(FALSE);
            break;
  