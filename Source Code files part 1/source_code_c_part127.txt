NetRoot->SCAlreadyInitialized) {
        SeDeleteClientSecurity(&(DavVNetRoot->SecurityClientContext));
    }

    DavDbgTrace(DAV_TRACE_DAVNETROOT,
                ("MRxDAVFinalizeVNetRoot deref DavNetRoot %x %x %x\n",pVNetRoot->Context2,pVNetRoot->pNetRoot,pVNetRoot));
    MRxDAVDereferenceNetRootContext((PWEBDAV_NET_ROOT)pVNetRoot->Context2);
    pVNetRoot->Context2 = NULL;

    //
    // We need to make sure that the creation of this VNetRoot was successful.
    // If it was not, then we don't go to the usermode to finalize the 
    // PerUserEntry. Also, if the MiniRedir never got called during the 
    // creation of VNetRoot (possible in some failure case) then we should not
    // go to the user mode. If the MiniRedir never gets called LogonIDSet will
    // be FALSE. If the MiniRedir gets called this will be TRUE for sure.
    //
    if (DavVNetRoot->createVNetRootUnSuccessful || !DavVNetRoot->LogonIDSet) {
        DavDbgTrace(DAV_TRACE_DETAIL,
                    ("%ld: UMRxFinalizeVNetRoot. createVNetRootUnSuccessful\n",
                     PsGetCurrentThreadId()));
        goto EXIT_THE_FUNCTION;
    }

    //
    // Unfortunately, we do not have an RxContext here and hence have to create
    // one. An RxContext is required for a request to be reflected up.
    //
    RxContext = RxCreateRxContext(NULL, RxDeviceObject, 0);
    if (RxContext == NULL) {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: MRxDAVFinalizeVNetRoot/RxCreateRxContext: "
                     "NtStatus = %08lx.\n", PsGetCurrentThreadId(), NtStatus));
        goto EXIT_THE_FUNCTION;
    }
    
    //
    // We need to send the VNetRoot to the format routine and use the 
    // MRxContext[1] pointer of the RxContext structure to store it.
    //
    RxContext->MRxContext[1] = (PVOID)pVNetRoot;
    
    NtStatus = UMRxAsyncEngOuterWrapper(RxContext,
                                        SIZEOF_DAV_SPECIFIC_CONTEXT,
                                        MRxDAVFormatTheDAVContext,
                                        DAV_MINIRDR_ENTRY_FROM_FINALIZEVNETROOT,
                                        MRxDAVFinalizeVNetRootContinuation,
                                        "MRxDAVFinalizeVNetRoot");
    if (NtStatus != ERROR_SUCCESS) {
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: MRxDAVFinalizeVNetRoot/UMRxAsyncEngOuterWrapper: "
                     "NtStatus = %08lx.\n", PsGetCurrentThreadId(), NtStatus));
    }
    
EXIT_THE_FUNCTION:

    if (RxContext) {
        RxDereferenceAndDeleteRxContext(RxContext);
    }

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Leaving MRxDAVFinalizeVNetRoot with NtStatus = %08lx.\n", 
                 PsGetCurrentThreadId(), NtStatus));
    
    return NtStatus;
}


NTSTATUS
MRxDAVFinalizeVNetRootContinuation(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE
    )
/*++
                                
ORoutine Description:
                            
    This is the continuation routine which finalizes a VNetRoot.
                            
Arguments:
                            
    AsyncEngineContext - The Reflectors context.
                            
    RxContext - The RDBSS context.
                                
Return Value:
                            
    RXSTATUS - The return status for the operation
                            
--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    PAGED_CODE();

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Entering MRxDAVFinalizeVNetRootContinuation!!!!\n",
                 PsGetCurrentThreadId()));

    DavDbgTrace(DAV_TRACE_CONTEXT,
                ("%ld: MRxDAVFinalizeVNetRootContinuation: "
                 "AsyncEngineContext: %08lx, RxContext: %08lx\n", 
                 PsGetCurrentThreadId(), AsyncEngineContext, RxContext));

    //
    // Try usermode.
    //
    NtStatus = UMRxSubmitAsyncEngUserModeRequest(
                              UMRX_ASYNCENGINE_ARGUMENTS,
                              MRxDAVFormatUserModeVNetRootFinalizeRequest,
                              MRxDAVPrecompleteUserModeVNetRootFinalizeRequest
                              );

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Leaving MRxDAVFinalizeVNetRootContinuation with NtStatus"
                 " = %08lx.\n", PsGetCurrentThreadId(), NtStatus));

    return NtStatus;
}


NTSTATUS
MRxDAVFormatUserModeVNetRootFinalizeRequest(
    IN UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE,
    IN OUT PUMRX_USERMODE_WORKITEM_HEADER WorkItemHeader,
    IN ULONG WorkItemLength,
    OUT PULONG_PTR ReturnedLength
    )
/*++

Routine Description:

    This routine formats the VNetRoot finalize request being sent to the user 
    mode for processing.

Arguments:
    
    RxContext - The RDBSS context.
    
    AsyncEngineContext - The reflctor's context.
    
    WorkItem - The work item buffer.
    
    WorkItemLength - The length of the work item buffer.
    
    ReturnedLength - 
    
Return Value:

    STATUS_SUCCESS or STATUS_INSUFFICIENT_RESOURCES.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PDAV_USERMODE_WORKITEM DavWorkItem = (PDAV_USERMODE_WORKITEM)WorkItemHeader;
    PMRX_SRV_CALL SrvCall = NULL;
    PWEBDAV_SRV_CALL DavSrvCall = NULL;
    PMRX_V_NET_ROOT VNetRoot = NULL;
    PWEBDAV_V_NET_ROOT DavVNetRoot = NULL;
    PWCHAR ServerName = NULL;
    ULONG ServerNameLengthInBytes = 0;
    PBYTE SecondaryBuff = NULL;
    PDAV_USERMODE_FINALIZE_V_NET_ROOT_REQUEST DavFinalizeVNetRootRequest = NULL;

    PAGED_CODE();

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Entering MRxDAVFormatUserModeVNetRootFinalizeRequest\n",
                 PsGetCurrentThreadId()));

    DavDbgTrace(DAV_TRACE_CONTEXT,
                ("%ld: MRxDAVFormatUserModeVNetRootFinalizeRequest: "
                 "AsyncEngineContext: %08lx, RxContext: %08lx.\n",
                 PsGetCurrentThreadId(), AsyncEngineContext, RxContext));

    VNetRoot = (PMRX_V_NET_ROOT)RxContext->MRxContext[1];
    ASSERT(VNetRoot != NULL);
    DavVNetRoot = MRxDAVGetVNetRootExtension(VNetRoot);
    ASSERT(DavVNetRoot != NULL);

    SrvCall = VNetRoot->pNetRoot->pSrvCall;
    ASSERT(SrvCall != NULL);
    DavSrvCall = MRxDAVGetSrvCallExtension(SrvCall);
    ASSERT(DavSrvCall != NULL);
    
    DavWorkItem->WorkItemType = UserModeFinalizeVNetRoot;

    DavFinalizeVNetRootRequest = &(DavWorkItem->FinalizeVNetRootRequest);

    //
    // Set the ServerID.
    //
    DavFinalizeVNetRootRequest->ServerID = DavSrvCall->ServerID;

    //
    // Set the LogonID.
    //
    DavFinalizeVNetRootRequest->LogonID.LowPart = DavVNetRoot->LogonID.LowPart;
    DavFinalizeVNetRootRequest->LogonID.HighPart = DavVNetRoot->LogonID.HighPart;

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVFormatUserModeVNetRootFinalizeRequest: "
                 "LogonID.LowPart = %d, LogonID.HighPart = %d\n",
                 PsGetCurrentThreadId(), 
                 DavVNetRoot->LogonID.LowPart, DavVNetRoot->LogonID.HighPart));

    //
    // Set the Server name.
    //
    ServerName = &(SrvCall->pSrvCallName->Buffer[1]);
    ServerNameLengthInBytes = (1 + wcslen(ServerName)) * sizeof(WCHAR);
    SecondaryBuff = UMRxAllocateSecondaryBuffer(AsyncEngineContext, 
                                                ServerNameLengthInBytes);
    if (SecondaryBuff == NULL) {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("ld: MRxDAVFormatUserModeVNetRootFinalizeRequest/"
                     "UMRxAllocateSecondaryBuffer: ERROR: NtStatus = %08lx.\n",
                     PsGetCurrentThreadId(), NtStatus));
        goto EXIT_THE_FUNCTION;
    }
    
    DavFinalizeVNetRootRequest->ServerName = (PWCHAR)SecondaryBuff;
    
    wcscpy(DavFinalizeVNetRootRequest->ServerName, ServerName);

EXIT_THE_FUNCTION:
    
    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Leaving MRxDAVFormatUserModeVNetRootFinalizeRequest "
                 "with NtStatus = %08lx.\n", PsGetCurrentThreadId(), NtStatus));
    
    return NtStatus;
}


BOOL
MRxDAVPrecompleteUserModeVNetRootFinalizeRequest(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE,
    PUMRX_USERMODE_WORKITEM_HEADER WorkItemHeader,
    ULONG WorkItemLength,
    BOOL OperationCancelled
    )
/*++

Routine Description:

    The precompletion routine for the finalize VNetRoot request.

Arguments:

    RxContext - The RDBSS context.
    
    AsyncEngineContext - The reflctor's context.
    
    WorkItem - The work item buffer.
    
    WorkItemLength - The length of the work item buffer.

    OperationCancelled - TRUE if this operation was cancelled by the user.

Return Value:

    TRUE - UMRxAsyncEngineCalldownIrpCompletion is called by the function
           UMRxCompleteUserModeRequest after we return.    

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PDAV_USERMODE_WORKITEM WorkItem = (PDAV_USERMODE_WORKITEM)WorkItemHeader;
    PDAV_USERMODE_FINALIZE_V_NET_ROOT_REQUEST DavFinalizeVNetRootRequest = NULL;

    PAGED_CODE();
    
    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Entering MRxDAVPrecompleteUserModeVNetRootFinalizeRequest\n",
                 PsGetCurrentThreadId()));

    DavDbgTrace(DAV_TRACE_CONTEXT,
                ("%ld: MRxDAVPrecompleteUserModeVNetRootFinalizeRequest: "
                 "AsyncEngineContext: %08lx, RxContext: %08lx.\n",
                 PsGetCurrentThreadId(), AsyncEngineContext, RxContext));
    
     //
    // A FinalizeVNetRoot request can never by Async.
    //
    ASSERT(AsyncEngineContext->AsyncOperation == FALSE);

    //
    // If this operation was cancelled, then we don't need to do anything
    // special in the FinalizeVNetRoot case.
    //
    if (OperationCancelled) {
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: MRxDAVPrecompleteUserModeVNetRootFinalizeRequest: Operation Cancelled. "
                     "AsyncEngineContext = %08lx, RxContext = %08lx.\n",
                     PsGetCurrentThreadId(), AsyncEngineContext, RxContext));
    }

    DavFinalizeVNetRootRequest = &(WorkItem->FinalizeVNetRootRequest);
    
    //
    // We need to free up the heap we allocated in the format routine.
    //
    if (DavFinalizeVNetRootRequest->ServerName != NULL) {
        
        NtStatus = UMRxFreeSecondaryBuffer(AsyncEngineContext,
                                           (PBYTE)DavFinalizeVNetRootRequest->ServerName);
        if (NtStatus != STATUS_SUCCESS) {
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: ERROR: MRxDAVPrecompleteUserModeVNetRootFinalizeRequestt/"
                         "UMRxFreeSecondaryBuffer: NtStatus = %08lx.\n", 
                         PsGetCurrentThreadId(), NtStatus));
        }
    
    }

    if (AsyncEngineContext->Status != STATUS_SUCCESS) {
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: ERROR: MRxDAVPrecompleteUserModeVNetRootFinalizeRequest. "
                     "Finalize VNetRoot Failed!!!\n",
                     PsGetCurrentThreadId()));
    }

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Leaving MRxDAVPrecompleteUserModeVNetRootFinalizeRequest\n",
                 PsGetCurrentThreadId()));
    
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\kernel\init.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    Init.c

Abstract:

    This module implements the Driver Initialization routine for the WebDav
    miniredir.

Author:

    Joe Linn

    Rohan Kumar     [RohanK]    10-March-1999

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include "ntverp.h"
#include "netevent.h"
#include "nvisible.h"
#include "webdav.h"
#include "ntddmup.h"
#include "rxdata.h"
#include "fsctlbuf.h"
#include "tdikrnl.h"

//
// Global data declarations.
//
PEPROCESS       MRxDAVSystemProcess;
FAST_MUTEX      MRxDAVSerializationMutex;
KIRQL           MRxDAVGlobalSpinLockSavedIrql;
KSPIN_LOCK      MRxDAVGlobalSpinLock;
BOOLEAN         MRxDAVGlobalSpinLockAcquired;
BOOLEAN         MRxDAVTransportReady = FALSE;
HANDLE          MRxDAVTdiNotificationHandle = NULL;

//
// The Exchange Registry key from where we read their DeviceObject name.
//
#define DavExchangeRegistryKey L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\Lsifs\\Parameters"

//
// The exchange device name will be stored in this KEY_VALUE_PARTIAL_INFORMATION
// structure.
//
PBYTE DavExchangeDeviceName = NULL;

//
// The DavWinInetCachePath which is used in satisfying volume related queries.
//
WCHAR DavWinInetCachePath[MAX_PATH];

//
// The ProcessId of the svchost.exe process that loads the webclnt.dll.
//
ULONG DavSvcHostProcessId = 0;

//
// Name cache stuff. These values are read from the registry during init time.
//
ULONG FileInformationCacheLifeTimeInSec = 0;
ULONG FileNotFoundCacheLifeTimeInSec = 0;
ULONG NameCacheMaxEntries = 0;

#define MRXDAV_DEBUG_KEY L"\\Registry\\Machine\\SYSTEM\\CurrentControlSet\\Services\\MRxDAV\\Parameters"

#define NAME_CACHE_OBJ_GET_FILE_ATTRIB_LIFETIME L"FileInformationCacheLifeTimeInSec"
#define NAME_CACHE_OBJ_NAME_NOT_FOUND_LIFETIME L"FileNotFoundCacheLifeTimeInSec"
#define NAME_CACHE_NETROOT_MAX_ENTRIES L"NameCacheMaxEntries"

#define CREATE_REQUEST_TIMEOUT_IN_SEC L"CreateRequestTimeoutInSec"
#define CREATEVNETROOT_REQUEST_TIMEOUT_IN_SEC L"CreateVNetRootRequestTimeoutInSec"
#define QUERYDIRECTORY_REQUEST_TIMEOUT_IN_SEC L"QueryDirectoryRequestTimeoutInSec"
#define CLOSE_REQUEST_TIMEOUT_IN_SEC L"CloseRequestTimeoutInSec"
#define CREATESRVCALL_REQUEST_TIMEOUT_IN_SEC L"CreateSrvCallRequestTimeoutInSec"
#define FINALIZESRVCALL_REQUEST_TIMEOUT_IN_SEC L"FinalizeSrvCallRequestTimeoutInSec"
#define FINALIZEFOBX_REQUEST_TIMEOUT_IN_SEC L"FinalizeFobxRequestTimeoutInSec"
#define FINALIZEVNETROOT_REQUEST_TIMEOUT_IN_SEC L"FinalizeVNetRootRequestTimeoutInSec"
#define RENAME_REQUEST_TIMEOUT_IN_SEC L"ReNameRequestTimeoutInSec"
#define SETFILEINFO_REQUEST_TIMEOUT_IN_SEC L"SetFileInfoRequestTimeoutInSec"
#define QUERYFILEINFO_REQUEST_TIMEOUT_IN_SEC L"QueryFileInfoRequestTimeoutInSec"
#define QUERYVOLUMEINFO_REQUEST_TIMEOUT_IN_SEC L"QueryVolumeInfoRequestTimeoutInSec"
#define LOCKREFRESH_REQUEST_TIMEOUT_IN_SEC L"LockRefreshRequestTimeoutInSec"

#if DBG
#define MRXDAV_DEBUG_VALUE L"DAVDebugFlag"
#endif

//
// Define the size of the shared memory area that we allocate as a heap
// between user and server.
//
#define DAV_SHARED_MEMORY_SIZE (1024 * 512)

//
// The Debug vector flags that control the amount of tracing in the debugger.
//
#if DBG
ULONG MRxDavDebugVector = 0;
#endif

//
// Mini Redirector global variables.
//
struct _MINIRDR_DISPATCH  MRxDAVDispatch;
PWEBDAV_DEVICE_OBJECT MRxDAVDeviceObject; 
FAST_IO_DISPATCH MRxDAVFastIoDispatch;

#define DAV_SVCHOST_NAME_SIZE   22

UNICODE_STRING uniSvcHost = {DAV_SVCHOST_NAME_SIZE+2,DAV_SVCHOST_NAME_SIZE+2,L"svchost.exe"};

FAST_MUTEX MRxDAVFileInfoCacheLock;

//
// Mentioned below are the prototypes of functions tht are used only within
// this module (file). These functions should not be exposed outside.
//

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT  DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

VOID
MRxDAVInitUnwind(
    IN PDRIVER_OBJECT DriverObject,
    IN WEBDAV_INIT_STATES MRxDAVInitState
    );

VOID
MRxDAVUnload(
    IN PDRIVER_OBJECT DriverObject
    );

VOID
MRxDAVInitializeTables(
    VOID
    );

NTSTATUS
MRxDAVFsdDispatch (
    IN PRDBSS_DEVICE_OBJECT RxDeviceObject,
    IN PIRP Irp
    );

VOID
MRxDAVDeregisterAndCleanupDeviceObject (
    PUMRX_DEVICE_OBJECT UMRdrDeviceObject
    );

NTSTATUS
MRxDAVRegisterForPnpNotifications(
    VOID
    );

NTSTATUS
MRxDAVDeregisterForPnpNotifications(
    VOID
    );

VOID
MRxDAVPnPBindingHandler(
    IN TDI_PNP_OPCODE PnPOpcode,
    IN PUNICODE_STRING pTransportName,
    IN PWSTR BindingList
    );

VOID
MRxDAVInitializeTheTimeValues(
    VOID
    );

NTSTATUS
MRxDAVSkipIrps(
    IN PIRP Irp,
    IN PUNICODE_STRING pFileName,
    IN BOOL fCheckAny
    );

UCHAR *
PsGetProcessImageFileName(
    PEPROCESS Process
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, DriverEntry)
#pragma alloc_text(PAGE, MRxDAVInitUnwind)
#pragma alloc_text(PAGE, MRxDAVUnload)
#pragma alloc_text(PAGE, MRxDAVInitializeTables)
#pragma alloc_text(PAGE, MRxDAVFsdDispatch)
#pragma alloc_text(PAGE, MRxDAVDeregisterAndCleanupDeviceObject)
#pragma alloc_text(PAGE, MRxDAVFlush)
#pragma alloc_text(PAGE, MRxDAVPnPBindingHandler)
#pragma alloc_text(PAGE, MRxDAVRegisterForPnpNotifications)
#pragma alloc_text(PAGE, MRxDAVDeregisterForPnpNotifications)
#pragma alloc_text(PAGE, MRxDAVProbeForReadWrite)
#pragma alloc_text(PAGE, MRxDAVSkipIrps)
#pragma alloc_text(PAGE, MRxDAVInitializeTheTimeValues)
#endif

//
// Implementation of functions begins here.
//

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT  DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
/*++

Routine Description:

    This is the initialization routine for the usermode reflector.

Arguments:

    DriverObject - Pointer to driver object created by the system.

Return Value:

    RXSTATUS - The function value is the final status from the initialization
               operation.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    NTSTATUS RegNtStatus = STATUS_SUCCESS;
    WEBDAV_INIT_STATES MRxDAVInitState = 0;
    UNICODE_STRING MRxDAVMiniRedirectorName;
    PUMRX_DEVICE_OBJECT UMRefDeviceObject;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE KeyHandle = INVALID_HANDLE_VALUE;
    UNICODE_STRING UnicodeRegKeyName, UnicodeValueName;
    ULONG RequiredLength = 0;
    PKEY_VALUE_PARTIAL_INFORMATION DavKeyValuePartialInfo = NULL;

    PAGED_CODE();

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Entering DriverEntry!!!!\n", PsGetCurrentThreadId()));

    DavDbgTrace(DAV_TRACE_CONTEXT,
                ("%ld: DriverEntry: Starting MRxDAV. DriverObject: %08lx.\n", 
                 PsGetCurrentThreadId(), DriverObject));

    //
    // The first thing we do is set some globals in the driver by calling
    // MRxDAVInitializeTheTimeValues().
    //
    MRxDAVInitializeTheTimeValues();

#ifdef MONOLITHIC_MINIRDR
    
    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: DriverEntry: Calling RxDriverEntry.\n",
                 PsGetCurrentThreadId()));

    NtStatus =  RxDriverEntry(DriverObject, RegistryPath);
    
    DavDbgTrace(DAV_TRACE_DETAIL, 
                ("%ld: DriverEntry: Back from RxDriverEntry. NtStatus: %08lx.\n", 
                 PsGetCurrentThreadId(), NtStatus));
    
    if (NtStatus != STATUS_SUCCESS) {
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: ERROR: DriverEntry/RxDriverEntry: NtStatus = %08lx\n", 
                     PsGetCurrentThreadId(), NtStatus));
        return(NtStatus);
    }

#endif

    //
    // The Dav redirector needs to register for PNP notifications to handle the 
    // following scenario. The SMB redirector does not accept connections till 
    // the net is ready as indicated by a PNP event. If during this time DAV 
    // forwards the connection requests to WinInet it will in turn spin up RAS 
    // connections. By registering for PNP notifications we provide an easy 
    // mechanism for short circuiting the requests till transports are ready. 
    //
    MRxDAVRegisterForPnpNotifications();

    MRxDAVSystemProcess = RxGetRDBSSProcess();
    ExInitializeFastMutex(&MRxDAVSerializationMutex);
    KeInitializeSpinLock(&MRxDAVGlobalSpinLock);
    MRxDAVGlobalSpinLockAcquired = FALSE;

    //
    // 1. We need to initialize the TimerObject which will be used by the timer
    //    thread. 
    // 2. Set TimerThreadShutDown to FALSE. This will be set to TRUE
    //    when the system is being shutdown.
    // 3. Initialize the resource that is used to synchronize the timer thread
    //    when the service is stopped.
    // 4. Initialize the event that is signalled by the timer thread just
    //    before it terminates itself.
    //
    KeInitializeTimerEx( &(DavTimerObject), NotificationTimer );
    TimerThreadShutDown = FALSE;
    ExInitializeResourceLite( &(MRxDAVTimerThreadLock) );
    KeInitializeEvent( &(TimerThreadEvent), NotificationEvent, FALSE );

    //
    // Initialize the global LockTokenEntryList and the resource that is used
    // to synchronize access to it.
    //
    InitializeListHead( &(LockTokenEntryList) );
    ExInitializeResourceLite( &(LockTokenEntryListLock) );

    //
    // Initialize the global LockConflictEntryList and the resource that is used
    // to synchronize access to it.
    //
    InitializeListHead( &(LockConflictEntryList) );
    ExInitializeResourceLite( &(LockConflictEntryListLock) );

    //
    // If QueueLockRefreshWorkItem is TRUE, the TimerThread (which cancels all the
    // AsyncEngineContexts that haven't completed in a specified time) queues a 
    // WorkItem to refresh the locks. We initialize it to TRUE and the lock
    // which is used to synchronize it.
    //
    QueueLockRefreshWorkItem = TRUE;
    ExInitializeResourceLite( &(QueueLockRefreshWorkItemLock) );

    //
    // Zero the WinInetCachePath global. This will be initialized to the local
    // WinInetCachePath value when the MiniRedir is started.
    //
    RtlZeroMemory ( DavWinInetCachePath, MAX_PATH * sizeof(WCHAR) );
    
    try {

        MRxDAVInitState = MRxDAVINIT_START;
        
        RtlInitUnicodeString(&MRxDAVMiniRedirectorName, DD_DAV_DEVICE_NAME_U);
        
        DavDbgTrace(DAV_TRACE_DETAIL,
                    ("%ld: DriverEntry: Registering the Mini-Rdr with RDBSS.\n",
                     PsGetCurrentThreadId()));
        
        NtStatus = RxRegisterMinirdr((PRDBSS_DEVICE_OBJECT *)(&MRxDAVDeviceObject),
                                     DriverObject,
                                     &MRxDAVDispatch,
                                     RX_REGISTERMINI_FLAG_DONT_PROVIDE_MAILSLOTS,
                                     &MRxDAVMiniRedirectorName,
                                     WEBDAV_DEVICE_OBJECT_EXTENSION_SIZE,
                                     FILE_DEVICE_NETWORK_FILE_SYSTEM,
                                     FILE_REMOTE_DEVICE);
        if (NtStatus != STATUS_SUCCESS) {
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: ERROR: DriverEntry/RxRegisterMinirdr: NtStatus "
                         "= %08lx\n", PsGetCurrentThreadId(), NtStatus));
            try_return(NtStatus);
        }

        MRxDAVInitState = MRxDAVINIT_MINIRDR_REGISTERED;

        //
        // Now initialize the reflector's portion of the Device object.
        //
        UMRefDeviceObject = (PUMRX_DEVICE_OBJECT)&(MRxDAVDeviceObject->UMRefDeviceObject);
        NtStatus = UMRxInitializeDeviceObject(UMRefDeviceObject, 
                                              1024, 
                                              512,
                                              DAV_SHARED_MEMORY_SIZE);
        if (!NT_SUCCESS(NtStatus)) {
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: ERROR: DriverEntry/UMRxInitializeDeviceObject:"
                         " NtStatus = %08lx\n", PsGetCurrentThreadId(), NtStatus));
            try_return(NtStatus);
        }

        //
        // Initialize the DAV Mini-Redir specific fields of the device object.
        //
        MRxDAVDeviceObject->IsStarted = FALSE;
        MRxDAVDeviceObject->CachedRxDeviceFcb = NULL;
        MRxDAVDeviceObject->RegisteringProcess = IoGetCurrentProcess();
    
    try_exit: NOTHING;
    
    } finally {
        
        if (NtStatus != STATUS_SUCCESS) {
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: ERROR: DriverEntry: Calling MRxDAVInitUnwind.\n",
                         PsGetCurrentThreadId()));
            MRxDAVInitUnwind(DriverObject, MRxDAVInitState);
        }
    
    }

    if (NtStatus != STATUS_SUCCESS) {
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: ERROR: DriverEntry failed with NtStatus = %08lx\n", 
                     PsGetCurrentThreadId(), NtStatus));
        return(NtStatus);
    }
    
    //
    // Initialize the dispatch vector used by RDBSS.
    //
    MRxDAVInitializeTables();

    //
    // Initialize the major function dispatch vector of the Driver object.
    //
    {
        DWORD i;
        for (i = 0; i < IRP_MJ_MAXIMUM_FUNCTION; i++) {
            DriverObject->MajorFunction[i] = (PDRIVER_DISPATCH)MRxDAVFsdDispatch; 
        }
    }

    //
    // Setup Unload Routine for the Driver Object.
    //
    DriverObject->DriverUnload = MRxDAVUnload;

    //
    // Set the Driver Object's FastIoDispatch function.
    //
    DriverObject->FastIoDispatch = &(MRxDAVFastIoDispatch);
    MRxDAVFastIoDispatch.SizeOfFastIoDispatch = sizeof(MRxDAVFastIoDispatch);

    MRxDAVFastIoDispatch.FastIoDeviceControl = MRxDAVFastIoDeviceControl;
    MRxDAVFastIoDispatch.FastIoRead = MRxDAVFastIoRead;
    MRxDAVFastIoDispatch.FastIoWrite = MRxDAVFastIoWrite;

#ifdef DAV_DEBUG_READ_WRITE_CLOSE_PATH
    InitializeListHead( &(DavGlobalFileTable) );
#endif // DAV_DEBUG_READ_WRITE_CLOSE_PATH

    //
    // Since the Exchange Redir is not shipping with Whistler, we don't need 
    // to execute the code below. We can exit right away.
    //
    goto EXIT_THE_FUNCTION;

    //
    // Finally find out if the Exchange Redir is installed on this machine. If 
    // it is, get its Device Name.
    //

    RtlInitUnicodeString( &(UnicodeRegKeyName), DavExchangeRegistryKey );

    InitializeObjectAttributes(&(ObjectAttributes),
                               &(UnicodeRegKeyName),
                               OBJ_CASE_INSENSITIVE,
                               0,
                               NULL);
    
    //
    // Open a handle to the Exchange Key.
    //
    RegNtStatus = ZwOpenKey(&(KeyHandle), KEY_READ, &(ObjectAttributes));
    if (RegNtStatus != STATUS_SUCCESS) {
        KeyHandle = INVALID_HANDLE_VALUE;
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: ERROR: DriverEntry/ZwOpenKey: NtStatus = %08lx\n", 
                     PsGetCurrentThreadId(), RegNtStatus));
        goto EXIT_THE_FUNCTION;
    }

    //
    // We are looking for the DeviceName Value.
    //
    RtlInitUnicodeString( &(UnicodeValueName), L"DeviceName" );
    // RtlInitUnicodeString( &(UnicodeValueName), L"Name" );

    //
    // Find out the number of bytes needed to store this value.
    //
    RegNtStatus = ZwQueryValueKey(KeyHandle,
                                  &(UnicodeValueName),
                                  KeyValuePartialInformation,
                                  NULL,
                                  0,
                                  &(RequiredLength));
    if (RegNtStatus !=  STATUS_BUFFER_TOO_SMALL) {
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: ERROR: DriverEntry/ZwQueryValueKey(1): NtStatus = %08lx\n", 
                     PsGetCurrentThreadId(), RegNtStatus));
        goto EXIT_THE_FUNCTION;
    }

    DavExchangeDeviceName = RxAllocatePoolWithTag(PagedPool, RequiredLength, DAV_EXCHANGE_POOLTAG);
    if (DavExchangeDeviceName == NULL) {
        RegNtStatus = STATUS_INSUFFICIENT_RESOURCES;
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("ld: ERROR: DriverEntry/RxAllocatePoolWithTag. NtStatus = %08lx\n",
                     PsGetCurrentThreadId(), RegNtStatus));
        goto EXIT_THE_FUNCTION;
    }

    RtlZeroMemory(DavExchangeDeviceName, RequiredLength);
    
    DavKeyValuePartialInfo = (PKEY_VALUE_PARTIAL_INFORMATION)DavExchangeDeviceName;
    
    RegNtStatus = ZwQueryValueKey(KeyHandle,
                                  &(UnicodeValueName),
                                  KeyValuePartialInformation,
                                  (PVOID)DavKeyValuePartialInfo,
                                  RequiredLength,
                                  &(RequiredLength));
    if (RegNtStatus != STATUS_SUCCESS || DavKeyValuePartialInfo->Type != REG_SZ) {
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: ERROR: DriverEntry/ZwQueryValueKey(2): NtStatus = %08lx\n", 
                     PsGetCurrentThreadId(), RegNtStatus));
        goto EXIT_THE_FUNCTION;
    }

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: DriverEntry: ExchangeDeviceName = %ws\n", 
                 PsGetCurrentThreadId(), DavKeyValuePartialInfo->Data));

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: DriverEntry: ExchangeDeviceNameLength = %d\n", 
                 PsGetCurrentThreadId(), DavKeyValuePartialInfo->DataLength));

EXIT_THE_FUNCTION:

    //
    // We are done with the handle now, so close it.
    //
    if (KeyHandle != INVALID_HANDLE_VALUE) {
        ZwClose(KeyHandle);
    }

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Leaving DriverEntry with NtStatus = %08lx\n", 
                 PsGetCurrentThreadId(), NtStatus));

    return  NtStatus;
}


VOID
MRxDAVInitUnwind(
    IN PDRIVER_OBJECT DriverObject,
    IN WEBDAV_INIT_STATES MRxDAVInitState
    )
/*++

Routine Description:

     This routine does the common uninit work for unwinding from a bad driver entry or for unloading.

Arguments:

     RxInitState - tells how far we got into the intialization

Return Value:

     None

--*/

{
    PAGED_CODE();

    switch (MRxDAVInitState) {
    case MRxDAVINIT_MINIRDR_REGISTERED:
        RxUnregisterMinirdr(&MRxDAVDeviceObject->RxDeviceObject);
        //
        // Lack of break intentional.
        //

    case MRxDAVINIT_START:
        break;
    }
}


VOID
MRxDAVUnload(
    IN PDRIVER_OBJECT DriverObject
    )
/*++

Routine Description:

     This is the unload routine for the usermode reflector.

Arguments:

     DriverObject - pointer to the driver object for the UMRx

Return Value:

     None

--*/
{
    PUMRX_DEVICE_OBJECT UMRefDeviceObject = NULL;

    PAGED_CODE();

    UMRefDeviceObject = (PUMRX_DEVICE_OBJECT)&(MRxDAVDeviceObject->UMRefDeviceObject);
    
    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Entering MRxDAVUnload!!!!\n", PsGetCurrentThreadId()));

    DavDbgTrace(DAV_TRACE_CONTEXT,
                ("%ld: MRxDAVUnload: DriverObject = %08lx.\n", 
                 PsGetCurrentThreadId(), DriverObject));

    //
    // If we allocated memory for the exchange device name, we need to free it
    // now.
    //
    if (DavExchangeDeviceName != NULL) {
        RxFreePool(DavExchangeDeviceName);
    }
    
    //
    // Deregister the device object before calling RxUnload.
    //
    MRxDAVDeregisterAndCleanupDeviceObject(UMRefDeviceObject);

    //
    // Wait for the timer thread to finish before we delete the global locks
    // MRxDAVTimerThreadLock and the others (see below) used to synchronize
    // TimerThreadShutDown and other global variables.
    //
    KeWaitForSingleObject(&(TimerThreadEvent),
                          Executive,
                          KernelMode,
                          FALSE,
                          NULL);

    ExDeleteResourceLite( &(MRxDAVTimerThreadLock) );

    ExDeleteResourceLite( &(LockTokenEntryListLock) );

    ExDeleteResourceLite( &(LockConflictEntryListLock) );

    ExDeleteResourceLite( &(QueueLockRefreshWorkItemLock) );

    //
    // The TDI registration needs to be undone.
    //
    MRxDAVDeregisterForPnpNotifications();

#ifdef MONOLITHIC_MINIRDR
    RxUnload(DriverObject);
#endif

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Leaving MRxDAVUnload.\n", PsGetCurrentThreadId()));

    return;
}


VOID
MRxDAVInitializeTables(
    VOID
    )
/*++

Routine Description:

     This routine sets up the mini redirector dispatch vector and also calls to initialize any other tables needed.

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    PAGED_CODE();

    //
    // Local minirdr dispatch table init.
    //
    ZeroAndInitializeNodeType(&MRxDAVDispatch,
                              RDBSS_NTC_MINIRDR_DISPATCH,
                              sizeof(MINIRDR_DISPATCH));

    //
    // Reflector extension sizes and allocation policies.
    // CODE.IMPROVEMENT. Currently we do not allocate the NET_ROOT and
    // SRV_CALL extensions in the wrapper. Except for V_NET_ROOT wherein it is
    // shared across multiple instances in the wrapper all the other data
    // structure management should be left to the wrappers.
    //

    MRxDAVDispatch.MRxFlags = (RDBSS_MANAGE_FCB_EXTENSION         |
                               RDBSS_MANAGE_SRV_OPEN_EXTENSION    |
                               RDBSS_MANAGE_FOBX_EXTENSION        |
                               RDBSS_MANAGE_V_NET_ROOT_EXTENSION  |
                               RDBSS_NO_DEFERRED_CACHE_READAHEAD);
    
    MRxDAVDispatch.MRxSrvCallSize  = 0;
    MRxDAVDispatch.MRxNetRootSize  = 0;
    MRxDAVDispatch.MRxVNetRootSize = sizeof(WEBDAV_V_NET_ROOT);
    MRxDAVDispatch.MRxFcbSize      = sizeof(WEBDAV_FCB);
    MRxDAVDispatch.MRxSrvOpenSize  = sizeof(WEBDAV_SRV_OPEN);
    MRxDAVDispatch.MRxFobxSize     = sizeof(WEBDAV_FOBX); 

    //
    // Mini redirector cancel routine.
    //
    MRxDAVDispatch.MRxCancel = NULL;

    //
    // Mini redirector Start/Stop
    //
    MRxDAVDispatch.MRxStart                = MRxDAVStart;
    MRxDAVDispatch.MRxStop                 = MRxDAVStop;
    MRxDAVDispatch.MRxDevFcbXXXControlFile = MRxDAVDevFcbXXXControlFile;

    //
    // Mini redirector name resolution
    //
    MRxDAVDispatch.MRxCreateSrvCall = MRxDAVCreateSrvCall;
    MRxDAVDispatch.MRxSrvCallWinnerNotify = MRxDAVSrvCallWinnerNotify;
    MRxDAVDispatch.MRxCreateVNetRoot = MRxDAVCreateVNetRoot;
    MRxDAVDispatch.MRxUpdateNetRootState = MRxDAVUpdateNetRootState;
    MRxDAVDispatch.MRxExtractNetRootName = MRxDAVExtractNetRootName;
    MRxDAVDispatch.MRxFinalizeSrvCall = MRxDAVFinalizeSrvCall;
    MRxDAVDispatch.MRxFinalizeNetRoot = MRxDAVFinalizeNetRoot;
    MRxDAVDispatch.MRxFinalizeVNetRoot = MRxDAVFinalizeVNetRoot;

    //
    // File System Object Creation/Deletion.
    //
    MRxDAVDispatch.MRxCreate                      = MRxDAVCreate;
    MRxDAVDispatch.MRxCollapseOpen                = MRxDAVCollapseOpen;
    MRxDAVDispatch.MRxShouldTryToCollapseThisOpen = MRxDAVShouldTryToCollapseThisOpen;
    MRxDAVDispatch.MRxExtendForCache              = MRxDAVExtendForCache;
    MRxDAVDispatch.MRxExtendForNonCache           = MRxDAVExtendForNonCache;
    MRxDAVDispatch.MRxTruncate                    = MRxDAVTruncate;
    MRxDAVDispatch.MRxCleanupFobx                 = MRxDAVCleanupFobx;
    MRxDAVDispatch.MRxCloseSrvOpen                = MRxDAVCloseSrvOpen;
    MRxDAVDispatch.MRxFlush                       = MRxDAVFlush;
    MRxDAVDispatch.MRxForceClosed                 = MRxDAVForcedClose;
    MRxDAVDispatch.MRxDeallocateForFcb            = MRxDAVDeallocateForFcb;
    MRxDAVDispatch.MRxDeallocateForFobx           = MRxDAVDeallocateForFobx;
    // MRxDAVDispatch.MRxIsLockRealizable         = UMRxIsLockRealizable;

    //
    // File System Objects query/Set.
    //
    MRxDAVDispatch.MRxQueryDirectory   = MRxDAVQueryDirectory;
    MRxDAVDispatch.MRxQueryVolumeInfo  = MRxDAVQueryVolumeInformation;
    MRxDAVDispatch.MRxQueryEaInfo     = MRxDAVQueryEaInformation;
    MRxDAVDispatch.MRxSetEaInfo       = MRxDAVSetEaInformation;
    // MRxDAVDispatch.MRxQuerySdInfo     = UMRxQuerySecurityInformation;
    // MRxDAVDispatch.MRxSetSdInfo       = UMRxSetSecurityInformation;
    MRxDAVDispatch.MRxQueryFileInfo    = MRxDAVQueryFileInformation;
    MRxDAVDispatch.MRxSetFileInfo      = MRxDAVSetFileInformation;
    // MRxDAVDispatch.MRxSetFileInfoAtCleanup = UMRxSetFileInformationAtCleanup;
    MRxDAVDispatch.MRxIsValidDirectory= MRxDAVIsValidDirectory;


    //
    // Buffering state change.
    //
    MRxDAVDispatch.MRxComputeNewBufferingState = MRxDAVComputeNewBufferingState;

    //
    // File System Object I/O.
    //
    MRxDAVDispatch.MRxLowIOSubmit[LOWIO_OP_READ]               = MRxDAVRead;
    MRxDAVDispatch.MRxLowIOSubmit[LOWIO_OP_WRITE]              = MRxDAVWrite;
    // MRxDAVDispatch.MRxLowIOSubmit[LOWIO_OP_SHAREDLOCK]      = UMRxLocks;
    // MRxDAVDispatch.MRxLowIOSubmit[LOWIO_OP_EXCLUSIVELOCK]   = UMRxLocks;
    // MRxDAVDispatch.MRxLowIOSubmit[LOWIO_OP_UNLOCK]          = UMRxLocks;
    // MRxDAVDispatch.MRxLowIOSubmit[LOWIO_OP_UNLOCK_MULTIPLE] = UMRxLocks;
    MRxDAVDispatch.MRxLowIOSubmit[LOWIO_OP_FSCTL]              = MRxDAVFsCtl;
    // MRxDAVDispatch.MRxLowIOSubmit[LOWIO_OP_IOCTL]           = UMRxIoCtl;
    
    //
    // Shouldn't flush come through lowio?
    //
    // MRxDAVDispatch.MRxLowIOSubmit[LOWIO_OP_NOTIFY_CHANGE_DIRECTORY] =
    //                                              UMRxNotifyChangeDirectory;

    //
    // Miscellanous.
    //
    // MRxDAVDispatch.MRxCompleteBufferingStateChangeRequest =
    //                                 UMRxCompleteBufferingStateChangeRequest;

    // initialize the mutex which protect the file info cache expire timer
    ExInitializeFastMutex(&MRxDAVFileInfoCacheLock);

    return;
}


NTSTATUS
MRxDAVFsdDispatch(
    IN PRDBSS_DEVICE_OBJECT RxDeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine implements the FSD dispatch for the DAV miniredir.
    
Arguments:

    RxDeviceObject - Supplies the device object for the packet being processed.

    Irp - Supplies the Irp being processed.

Return Value:

    RXSTATUS - The Fsd status for the Irp

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation(Irp);
    UCHAR MajorFunctionCode  = IrpSp->MajorFunction;
    UCHAR MinorFunctionCode  = IrpSp->MinorFunction;
    PFILE_OBJECT FileObject  = IrpSp->FileObject;
    PWCHAR SaveInitialString = NULL;
    BOOL JustAServer = FALSE;
    ULONG IoControlCode = 0;
    PQUERY_PATH_REQUEST qpRequest = NULL;
    PWCHAR QueryPathBuffer = NULL;
    ULONG QueryPathBufferLength = 0; // Length in Bytes of QueryPathBuffer.
    KPROCESSOR_MODE ReqMode = 0;

    PAGED_CODE();

    //
    // Check if the PNP event indicating that the transports are ready has been
    // received. Till that time there is no point in forwarding requests to 
    // the user mode agent since this could put WinInet in a wierd state.
    //
    if (!MRxDAVTransportReady) {
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: ERROR: MRxDAVFsdDispatch. MRxDAVTransportReady == FALSE\n",
                     PsGetCurrentThreadId()));
        NtStatus = STATUS_REDIRECTOR_NOT_STARTED;
        goto COMPLETE_THE_REQUEST;
    }

    //
    // The first thing we need to check is whehter we got a DeviceIoControl
    // from MUP "IOCTL_REDIR_QUERY_PATH", to figure out if some UNC path is
    // owned by DAV or not. We need to check to see if the share supplied
    // in the path is one of the special SMB shares. These include PIPE, IPC$
    // and mailslot. If its one of these, then we reject the path at this stage
    // with a STATUS_BAD_NETOWRK_PATH response. This is better than rejecting
    // it at the creation of netroot becuase we save a network trip to the 
    // server while creating the SrvCall.
    //

    try {

        if (MajorFunctionCode == IRP_MJ_DEVICE_CONTROL) {

            ReqMode = Irp->RequestorMode;

            //
            // Get the IoControlCode from IrpSp.
            //
            IoControlCode = IrpSp->Parameters.DeviceIoControl.IoControlCode;

            //
            // If the IoControlCode is "IOCTL_REDIR_QUERY_PATH", we need to do the 
            // following. We basically check to see if the request came down for
            // any of the special SMB shares. If it did, then we return.
            //
            if (IoControlCode == IOCTL_REDIR_QUERY_PATH) {

                PWCHAR QPPtr1 = NULL;
                BOOL FirstWack = TRUE, SpecialShare = FALSE;
                UNICODE_STRING UnicodeShareName, uniFileName;
                ULONG ShareNameLengthInBytes = 0;

                //
                // This particular IOCTL should only come to us from the MUP and
                // hence the requestor mode of the IRP should always be 
                // KernelMode. If its not we return STATUS_INVALID_DEVICE_REQUEST.
                //
                if (ReqMode != KernelMode) {
                    NtStatus = STATUS_INVALID_DEVICE_REQUEST;
                    goto COMPLETE_THE_REQUEST;
                }

                qpRequest  = METHODNEITHER_OriginalInputBuffer(IrpSp);

                //
                // If the requestor mode is not Kernel, we need to probe the buffer.
                // Probe the buffer that was supplied by the caller of the IOCTL to
                // make sure that its valid. This is to prevent hacker programs from
                // using this IOCTL to pass in invalid buffers.
                //
                if (ReqMode != KernelMode) {
                    NtStatus = MRxDAVProbeForReadWrite((PBYTE)qpRequest, sizeof(QUERY_PATH_REQUEST), TRUE, FALSE);
                    if (NtStatus != STATUS_SUCCESS) {
                        DavDbgTrace(DAV_TRACE_ERROR,
                                    ("%ld: ERROR: MRxDAVFsdDispatch/MRxDAVProbeForReadWrite(1). "
                                     "NtStatus = %08lx\n", PsGetCurrentThreadId(), NtStatus));
                        goto COMPLETE_THE_REQUEST;
                    }
                }

                QueryPathBuffer = (PWCHAR)(qpRequest->FilePathName);
                ASSERT(QueryPathBuffer != NULL);
                QueryPathBufferLength = qpRequest->PathNameLength;

                //
                // If the requestor mode is not Kernel, we need to probe the buffer.
                // Probe the file name buffer (which is a part of the structure) 
                // that was supplied by the caller of the IOCTL to make sure that 
                // its valid.
                //
                if (ReqMode != KernelMode) {
                    NtStatus = MRxDAVProbeForReadWrite((PBYTE)QueryPathBuffer, QueryPathBufferLength, TRUE, FALSE);
                    if (NtStatus != STATUS_SUCCESS) {
                        DavDbgTrace(DAV_TRACE_ERROR,
                                    ("%ld: ERROR: MRxDAVFsdDispatch/MRxDAVProbeForReadWrite(2). "
                                     "NtStatus = %08lx\n", PsGetCurrentThreadId(), NtStatus));
                        goto COMPLETE_THE_REQUEST;
                    }
                }

                DavDbgTrace(DAV_TRACE_DETAIL,
                            ("%ld: MRxDAVFsdDispatch: Type3InputBuffer = %ws\n",
                             PsGetCurrentThreadId(), QueryPathBuffer));

                //
                // The Type3InputBuffer is of the form \server\share or 
                // \server\share\ or \server\share\path. We make the 
                // QueryPathBuffer point to the char after the \ character.
                //
                QueryPathBuffer += 1;
                ASSERT(QueryPathBuffer != NULL);

                //
                // We subtract ( sizeof(WCHAR) ) from the buffer length because
                // the QueryPathBuffer points starting from the server name. It 
                // skips the first WCHAR which is \.
                //
                QueryPathBufferLength -= sizeof(WCHAR);

                DavDbgTrace(DAV_TRACE_DETAIL,
                            ("%ld: MRxDAVFsdDispatch: QueryPathBufferLength = %d\n",
                             PsGetCurrentThreadId(), QueryPathBufferLength));

                //
                // If we just got a \ down from the MUP, then the value of 
                // QueryPathBufferLength will now be zero since we have already 
                // taken out 2 bytes above. We return right away in such a situation.
                //
                if (QueryPathBufferLength == 0) {
                    NtStatus = STATUS_BAD_NETWORK_PATH;
                    DavDbgTrace(DAV_TRACE_ERROR,
                                ("%ld: ERROR: MRxDAVFsdDispatch: QueryPathBufferLength == 0\n",
                                 PsGetCurrentThreadId()));
                    goto COMPLETE_THE_REQUEST;
                }

                //
                // The loop below is to set the start of the sharename and to 
                // calculate the length of the sharename in bytes.
                //
                while (TRUE) {

                    if ( *QueryPathBuffer == L'\\' ) {
                        if (FirstWack) {
                            QPPtr1 = QueryPathBuffer;
                            FirstWack = FALSE;
                        } else {
                            break;
                        }
                    }

                    if (!FirstWack) {
                        ShareNameLengthInBytes += sizeof(WCHAR);
                    }

                    QueryPathBufferLength -= sizeof(WCHAR);
                    if (QueryPathBufferLength == 0) {
                        break;
                    }

                    QueryPathBuffer++;

                }

                //
                // If only a server name was specified then QPPrt1 will be NULL or
                // QPPtr1 will not be NULL but ShareNameLengthInBytes == sizeof(WCHAR).
                // QPPtr1 == NULL ==> \server
                // ShareNameLengthInBytes == sizeof(WCHAR) ==> \server\
                //
                if ( QPPtr1 == NULL || ShareNameLengthInBytes == sizeof(WCHAR) ) {
                    NtStatus = STATUS_BAD_NETWORK_PATH;
                    if (QPPtr1 == NULL) {
                        DavDbgTrace(DAV_TRACE_ERROR,
                                    ("%ld: ERROR: MRxDAVFsdDispatch: QPPtr1 == NULL\n",
                                     PsGetCurrentThreadId()));
                    } else {
                        DavDbgTrace(DAV_TRACE_ERROR,
                                    ("%ld: ERROR: MRxDAVFsdDispatch: "
                                     "ShareNameLengthInBytes == sizeof(WCHAR)\n",
                                     PsGetCurrentThreadId()));
                    }
                    goto COMPLETE_THE_REQUEST;
                }

                DavDbgTrace(DAV_TRACE_DETAIL,
                            ("%ld: MRxDAVFsdDispatch: QPPtr1 = %ws\n",
                             PsGetCurrentThreadId(), QPPtr1));

                DavDbgTrace(DAV_TRACE_DETAIL,
                            ("%ld: MRxDAVFsdDispatch: ShareNameLengthInBytes = %d\n",
                             PsGetCurrentThreadId(), ShareNameLengthInBytes));

                //
                // Set the Unicode string. The OPPtr1 pointer points to the \ before
                // the share name. So if the path was \server\share\dir,
                // \server\share\dir
                //        ^
                //        |
                //        QPPtr1
                // Accordingly, the ShareNameLengthInBytes contains an extra 
                // sizeof(WCHAR) bytes for the \ char.
                //
                UnicodeShareName.Buffer = QPPtr1;
                UnicodeShareName.Length = (USHORT)ShareNameLengthInBytes;
                UnicodeShareName.MaximumLength = (USHORT)ShareNameLengthInBytes;

                //
                // We now take this name and see if it matches any of the special
                // SMB shares. If it does, we return STATUS_BAD_NETWORK_PATH.
                //

                SpecialShare = RtlEqualUnicodeString(&(UnicodeShareName),
                                                     &(s_PipeShareName),
                                                     TRUE);
                if (SpecialShare) {
                    NtStatus = STATUS_BAD_NETWORK_PATH;
                    DavDbgTrace(DAV_TRACE_DETAIL,
                                ("%ld: ERROR: MRxDAVFsdDispatch: PIPE == TRUE\n",
                                 PsGetCurrentThreadId()));
                    goto COMPLETE_THE_REQUEST;
                }

                SpecialShare = RtlEqualUnicodeString(&(UnicodeShareName),
                                                     &(s_MailSlotShareName),
                                                     TRUE);
                if (SpecialShare) {
                    NtStatus = STATUS_BAD_NETWORK_PATH;
                    DavDbgTrace(DAV_TRACE_DETAIL,
                                ("%ld: ERROR: MRxDAVFsdDispatch: MAILSLOT == TRUE\n",
                                 PsGetCurrentThreadId()));
                    goto COMPLETE_THE_REQUEST;
                }

                SpecialShare = RtlEqualUnicodeString(&(UnicodeShareName),
                                                     &(s_IpcShareName),
                                                     TRUE);
                if (SpecialShare) {
                    NtStatus = STATUS_BAD_NETWORK_PATH;
                    DavDbgTrace(DAV_TRACE_DETAIL,
                                ("%ld: ERROR: MRxDAVFsdDispatch: IPC$ == TRUE\n",
                                 PsGetCurrentThreadId()));
                    goto COMPLETE_THE_REQUEST;
                }

                //
                // Check whether we need to skip some files. See the explanation
                // below (in the function definition) for why IRPs are skipped.
                //
                uniFileName.Buffer=(PWCHAR)(qpRequest->FilePathName);
                uniFileName.Length = uniFileName.MaximumLength = (USHORT)(qpRequest->PathNameLength);

                if (MRxDAVSkipIrps(Irp, &uniFileName, TRUE) == STATUS_SUCCESS)
                {
                    NtStatus = STATUS_BAD_NETWORK_PATH;
                    DavDbgTrace(DAV_TRACE_DETAIL,
                                ("%ld: ERROR: MRxDAVFsdDispatch: Skipped\n",
                                 PsGetCurrentThreadId()));
                    goto COMPLETE_THE_REQUEST;
                }

            }

        }
        
        if (MajorFunctionCode == IRP_MJ_CREATE) {
            //
            // See the explanation below (in the function definition) for why
            // IRPs are skipped. Send the filename in the fileobject.
            //
            if (MRxDAVSkipIrps(Irp, &FileObject->FileName, FALSE) == STATUS_SUCCESS)
            {
                NtStatus = STATUS_BAD_NETWORK_PATH;
                DavDbgTrace(DAV_TRACE_DETAIL,
                            ("%ld: ERROR: MRxDAVFsdDispatch: Skipped\n",
                             PsGetCurrentThreadId()));
                goto COMPLETE_THE_REQUEST;
            }
        }

    } except (EXCEPTION_EXECUTE_HANDLER) {

          NtStatus = STATUS_INVALID_PARAMETER;
    
          DavDbgTrace(DAV_TRACE_ERROR,
                      ("%ld: ERROR: MRxDAVFsdDispatch: Exception!!!\n",
                       PsGetCurrentThreadId()));
          
          goto COMPLETE_THE_REQUEST;

    }

    //
    // Save the filename passed in by the I/O manager. This is freed up later.
    //
    if (FileObject) {
        SaveInitialString = FileObject->FileName.Buffer;
    }
    
    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVFsdDispatch. MajorFunction = %d, MinorFunction = %d"
                 ", FileObject = %08lx.\n", PsGetCurrentThreadId(), 
                 MajorFunctionCode, MinorFunctionCode, FileObject));

    if (SaveInitialString) {

        
        ULONG MaxNameLengthInWChars = 0;
            
        MaxNameLengthInWChars = ( FileObject->FileName.Length / sizeof(WCHAR) );
        //
        // If the first and the second chars are '\'s, then its possible that
        // the name is just a \\server. Its possible that the name is of the
        // form \;X:0\path and hence we check for the second \ as well. So,
        // only if the first two chars are \ and \ we proceed to check whether
        // the create is just for just a server.
        //
        if ( MaxNameLengthInWChars >= 2 &&
             SaveInitialString[0] == L'\\' && SaveInitialString[1] == L'\\' ) {

            PWCHAR wcPtr1 = NULL;
            
            //
            // We assume that this is of the form \\server. If its not, then
            // this value is changed to FALSE below.
            //
            JustAServer = TRUE;

            //
            // Is the FileName just a server? Its possible that the FileName is
            // of the form \\server.
            //
            wcPtr1 = &(SaveInitialString[2]);

            //
            // If we have a '\' after the first two chars and atleast a single 
            // char after that, it means that the name is not of the form
            // \\server or \\server\.
            //
            while ( (MaxNameLengthInWChars - 2) > 0 ) {
                if ( *wcPtr1 == L'\\' && *(wcPtr1 + 1) != L'\0' ) {
                    JustAServer = FALSE;
                    break;
                }
                MaxNameLengthInWChars--;
                wcPtr1++;
            }
        
        }    
    
    }

    //
    // If JustAServer is TRUE then the network path name is invalid.
    //
    if (JustAServer) {
        NtStatus = STATUS_BAD_NETWORK_PATH;
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: ERROR: MRxDAVFsdDispatch: JustAServer == TRUE. SaveInitialString = %ws\n",
                     PsGetCurrentThreadId(), SaveInitialString));
        goto COMPLETE_THE_REQUEST;
    }

    //
    // Call RxFsdDispatch.
    //
    NtStatus = RxFsdDispatch(RxDeviceObject, Irp);
    if (NtStatus != STATUS_SUCCESS && NtStatus != STATUS_PENDING) {
        DavDbgTrace(DAV_TRACE_DETAIL,
                    ("%ld: Leaving MRxDAVFsdDispatch with NtStatus(2) = %08lx,"
                     " FileObject = %08lx, MjFn = %d, MiFn = %d.\n", 
                     PsGetCurrentThreadId(), NtStatus, FileObject,
                     MajorFunctionCode, MinorFunctionCode));
    }

    goto EXIT_THE_FUNCTION;

COMPLETE_THE_REQUEST:

    //
    // We come here if we did not call into RDBSS and need to complete the 
    // IRP ourselves.
    // 
    Irp->IoStatus.Status = NtStatus;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

EXIT_THE_FUNCTION:

    return NtStatus;
}


VOID
MRxDAVDeregisterAndCleanupDeviceObject(
    PUMRX_DEVICE_OBJECT UMRefDeviceObject
    )
/*++

Routine Description:

    Note: The mutex is already acquired and we're already off the list.

Arguments:

    UMRdrDeviceObject - The device object being deregistered and cleaned.

Return Value:

    None.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    PAGED_CODE();
    
    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Entering MRxDAVDeregisterAndCleanupDeviceObject!!!!\n",
                 PsGetCurrentThreadId()));

    DavDbgTrace(DAV_TRACE_CONTEXT,
                ("%ld: MRxDAVDeregisterAndCleanupDeviceObject: "
                 "UMRefDeviceObject: %08lx.\n", 
                 PsGetCurrentThreadId(), UMRefDeviceObject));

    NtStatus = UMRxCleanUpDeviceObject(UMRefDeviceObject);
    if (!NT_SUCCESS(NtStatus)) {
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: ERROR: MRxDAVDeregisterAndCleanupDeviceObject/"
                     "UMRxCleanUpDeviceObject: NtStatus = %08lx\n", 
                     PsGetCurrentThreadId(), NtStatus));
    }

    RxUnregisterMinirdr(&UMRefDeviceObject->RxDeviceObject);

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Leaving MRxDAVDeregisterAndCleanupDeviceObject.\n",
                 PsGetCurrentThreadId()));
}


NTSTATUS
MRxDAVFlush(
    IN OUT PRX_CONTEXT RxContext
    )
/*++

Routine Description:

    This routine handles the "File Flush" requests.

Arguments:

    RxContext - The context created by RDBSS.

Return Value:

    NTSTATUS or the appropriate NT error code.

--*/
{
    PAGED_CODE();
    return STATUS_SUCCESS;
}


VOID
MRxDAVPnPBindingHandler(
    IN TDI_PNP_OPCODE PnPOpcode,
    IN PUNICODE_STRING pTransportName,
    IN PWSTR BindingList
    )
/*++

Routine Description:

    The TDI callbacks routine for binding changes.

Arguments:

    PnPOpcode - The PNP op code.

    pTransportName - The transport name.

    BindingList - The binding order.

Return Value:

    None.

--*/
{
    PAGED_CODE();

    switch (PnPOpcode) {
    
    case TDI_PNP_OP_NETREADY: {
        MRxDAVTransportReady = TRUE;
    }
    break;

    default:
        break;
    
    }

    return;
}


NTSTATUS
MRxDAVRegisterForPnpNotifications(
    VOID
    )
/*++

Routine Description:

    This routine registers with TDI for receiving transport notifications.

Arguments:

    None.

Return Value:

    The NTSTATUS code.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    PAGED_CODE();

    if ( MRxDAVTdiNotificationHandle == NULL ) {
        
        UNICODE_STRING ClientName;

        TDI_CLIENT_INTERFACE_INFO ClientInterfaceInfo;

        RtlInitUnicodeString( &(ClientName), L"WebClient");

        ClientInterfaceInfo.MajorTdiVersion = 2;
        ClientInterfaceInfo.MinorTdiVersion = 0;

        ClientInterfaceInfo.Unused = 0;
        ClientInterfaceInfo.ClientName = &ClientName;

        ClientInterfaceInfo.BindingHandler = MRxDAVPnPBindingHandler;
        ClientInterfaceInfo.AddAddressHandler = NULL;
        ClientInterfaceInfo.DelAddressHandler = NULL;
        ClientInterfaceInfo.PnPPowerHandler = NULL;

        NtStatus = TdiRegisterPnPHandlers ( &(ClientInterfaceInfo),
                                            sizeof(ClientInterfaceInfo),
                                            &(MRxDAVTdiNotificationHandle) );
    
    }

    return NtStatus;
}


NTSTATUS
MRxDAVDeregisterForPnpNotifications(
    VOID
    )
/*++

Routine Description:

    This routine deregisters the TDI notification mechanism.
    
Arguments:

    None.

Return Value:

    The NTSTATUS code.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    PAGED_CODE();

    if ( MRxDAVTdiNotificationHandle != NULL ) {
        
        NtStatus = TdiDeregisterPnPHandlers( MRxDAVTdiNotificationHandle );

        if( NT_SUCCESS( NtStatus ) ) {
            MRxDAVTdiNotificationHandle = NULL;
        }
    
    }

    return NtStatus;
}


NTSTATUS
MRxDAVProbeForReadWrite(
    IN PBYTE BufferToBeValidated,
    IN DWORD BufferSize,
    IN BOOL doProbeForRead,
    IN BOOL doProbeForWrite
    )
/*++

Routine Description:

    This function probes the buffer that is supplied by the caller for read/write
    access. This is done because the caller of an IOCTL might supply a invalid
    buffer accessing which might cause a bugcheck.

Arguments:

    BufferToBeValidated - The Buffer which has to be validated for read/write
                          access.
                          
    BufferSize - The size of the buffer being validated.
    
    doProbeForRead - If TRUE, then probe the buffer for read.

    doProbeForWrite - If TRUE, then probe the buffer for write.

Return Value:

    STATUS_SUCCESS or STATUS_INVALID_USER_BUFFER.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    PAGED_CODE();

    //
    // We call the functions ProbeForRead and ProbeForWrite in a try/except
    // loop because these functions throw an exception if the buffer supplied
    // is invalid. We catch the exception and set the appropriate NtStatus 
    // value.
    //
    try {
        if (BufferToBeValidated != NULL) {
            if (doProbeForRead) {
                ProbeForRead(BufferToBeValidated, BufferSize, 1);
            }
            if (doProbeForWrite) {
                ProbeForWrite(BufferToBeValidated, BufferSize, 1);
            }
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        NtStatus = STATUS_INVALID_USER_BUFFER;
    }

    return NtStatus;
}


NTSTATUS
MRxDAVSkipIrps(
    IN PIRP Irp,
    IN PUNICODE_STRING fileName,
    IN BOOL fCheckAny
    )
/*++

Routine Description:

    This routine skips IRPs coming to the DAV redir which may cause deadlock. 
    Webdav's user mode component uses wininet to get to DAV servers. When a 
    service which is running this server process satisfying key wininet needs
    makes a remote call we deadlock. The two such services are winsock and Sense.
    When another service in the svchost which they are running under tries to do
    a loadlibrary located on a remote machine (in our famous example of \\davis\
    tools\ifsproxy.dll), loader APIs get invoked. These APis take the loader lock
    and issue an NtQueryAttributes call. This call is translated into QUERY_PATH
    ioctl by the MUP whci it send to all redirs, including webdav. Webdav refelcts
    it up to the usermode and the webdav service issues wininet call to look for
    the server (davis in the above example). Wininet issues a call to winsock to
    makes a sockets call. This call ends up issuing an rpc to the NLA service in
    another svchost which is the same svchost process that initiated the loadlibrary
    call. The server now tries to take the loader lock and the webdav redir is now
    deadlocked.
    
    This scheme also protects us from looping back to ourselves because of
    wininet's loadlibrary calls as webdav service also runs as part of an svchost.
    
    This routine looks for the process issuing the irp to webdav and if it is an
    svchost process and it is trying to look for a dll or an exe then we return it
    as being not found. This implies that dlls and exes kept on a webdav server
    cannot be loaded from svchosts till we get away from wininet.


Arguments:

    Irp - The irp that came to webdav.
    
    filename - Name of the file if any.
    
    fCheckAny - If this is TRUE, then we reject this IRP if the process is
                svchost.exe. If this is FALSE, then we only reject the IRP if
                the filename has the extension dll or exe and the process is
                svchost.exe.

Return Value:

    STATUS_SUCCESS - Skip this IRP.
    
    STATUS_UNSUCCESSFUL - Do not skip this IRP.

--*/
{
    WCHAR ImageFileName[DAV_SVCHOST_NAME_SIZE]; //keep some reasonable stack space
    ULONG UnicodeSize = 0;
    UNICODE_STRING uniImageFileName;
    UCHAR *pchImageFileName = PsGetProcessImageFileName(PsGetCurrentProcess());
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation(Irp);

    PAGED_CODE();

    RtlZeroMemory(ImageFileName, sizeof(ImageFileName));
    
    RtlMultiByteToUnicodeN(ImageFileName, sizeof(ImageFileName), &UnicodeSize, pchImageFileName, 16);

    uniImageFileName.Buffer = ImageFileName;
    uniImageFileName.Length = uniImageFileName.MaximumLength = uniSvcHost.Length;

    //
    // Check whether the calling process is svchost.exe.
    //
    if (!RtlCompareUnicodeString(&uniImageFileName, &uniSvcHost, TRUE))
    {
        if (!fCheckAny)
        {
            UNICODE_STRING exe = { 3*sizeof(WCHAR), 3*sizeof(WCHAR), L"exe" };
            UNICODE_STRING dll = { 3*sizeof(WCHAR), 3*sizeof(WCHAR), L"dll" };
            UNICODE_STRING s;
            //
            // If the filename ends in .DLL or .exe, we return success, which will
            // end up failing the operation.
            //
            if( fileName->Length > 4 * sizeof(WCHAR) &&
                fileName->Buffer[ fileName->Length/sizeof(WCHAR) - 4 ] == L'.'){

                s.Length = s.MaximumLength = 3 * sizeof( WCHAR );
                s.Buffer = &fileName->Buffer[ (fileName->Length - s.Length)/sizeof(WCHAR) ];

                if( RtlCompareUnicodeString( &s, &exe, TRUE ) == 0 ||
                    RtlCompareUnicodeString( &s, &dll, TRUE ) == 0 ) {
            
                    return STATUS_SUCCESS;
                }
            }
        }
        else
        {
            return STATUS_SUCCESS;
        }
        
    }
    
    return STATUS_UNSUCCESSFUL;
}


VOID
MRxDAVInitializeTheTimeValues(
    VOID
    )
/*++

Routine Description:

    This routine reads some time values (various timeout values, namecache etc.)
    from the registry and initialized the corresponding global variables in the
    driver. If a particular time value is not present in the registry, then it
    is set to some default value. It also sets TimerThreadSleepTimeInSec to be
    the minimum of all the operation timeout values.

Arguments:

    None.

Return Value:

    None.

--*/
{
    NTSTATUS RegNtStatus = STATUS_SUCCESS;

    PAGED_CODE();
    
    //
    // Read the name cache related timeout values.
    //

    RegNtStatus = UMRxReadDWORDFromTheRegistry(MRXDAV_DEBUG_KEY,
                                               NAME_CACHE_OBJ_GET_FILE_ATTRIB_LIFETIME,
                                               &(FileInformationCacheLifeTimeInSec));
    if (RegNtStatus != STATUS_SUCCESS) {
        FileInformationCacheLifeTimeInSec = 60;
    }

    RegNtStatus = UMRxReadDWORDFromTheRegistry(MRXDAV_DEBUG_KEY,
                                               NAME_CACHE_OBJ_NAME_NOT_FOUND_LIFETIME,
                                               &(FileNotFoundCacheLifeTimeInSec));
    if (RegNtStatus != STATUS_SUCCESS) {
        FileNotFoundCacheLifeTimeInSec = 60;
    }

    RegNtStatus = UMRxReadDWORDFromTheRegistry(MRXDAV_DEBUG_KEY,
                                               NAME_CACHE_NETROOT_MAX_ENTRIES,
                                               &(NameCacheMaxEntries));
    if (RegNtStatus != STATUS_SUCCESS) {
        NameCacheMaxEntries = 300;
    }

    //
    // Read the timeout values for the various operations. Set the value of 
    // TimerThreadSleepTimeInSec to be the minimum of all the timeout values.
    //

    RegNtStatus = UMRxReadDWORDFromTheRegistry(MRXDAV_DEBUG_KEY,
                                               CREATE_REQUEST_TIMEOUT_IN_SEC,
                                               &(CreateRequestTimeoutValueInSec));
    if (RegNtStatus != STATUS_SUCCESS) {
        CreateRequestTimeoutValueInSec = (10 * 60);
    }

    TimerThreadSleepTimeInSec = CreateRequestTimeoutValueInSec;
    
    RegNtStatus = UMRxReadDWORDFromTheRegistry(MRXDAV_DEBUG_KEY,
                                               CREATEVNETROOT_REQUEST_TIMEOUT_IN_SEC,
                                               &(CreateVNetRootRequestTimeoutValueInSec));
    if (RegNtStatus != STATUS_SUCCESS) {
        CreateVNetRootRequestTimeoutValueInSec = 60;
    }

    if (CreateVNetRootRequestTimeoutValueInSec < TimerThreadSleepTimeInSec) {
        TimerThreadSleepTimeInSec = CreateVNetRootRequestTimeoutValueInSec;
    }
    
    RegNtStatus = UMRxReadDWORDFromTheRegistry(MRXDAV_DEBUG_KEY,
                                               QUERYDIRECTORY_REQUEST_TIMEOUT_IN_SEC,
                                               &(QueryDirectoryRequestTimeoutValueInSec));
    if (RegNtStatus != STATUS_SUCCESS) {
        QueryDirectoryRequestTimeoutValueInSec = (10 * 60);
    }
    
    if (QueryDirectoryRequestTimeoutValueInSec < TimerThreadSleepTimeInSec) {
        TimerThreadSleepTimeInSec = QueryDirectoryRequestTimeoutValueInSec;
    }
    
    RegNtStatus = UMRxReadDWORDFromTheRegistry(MRXDAV_DEBUG_KEY,
                                               CLOSE_REQUEST_TIMEOUT_IN_SEC,
                                               &(CloseRequestTimeoutValueInSec));
    if (RegNtStatus != STATUS_SUCCESS) {
        CloseRequestTimeoutValueInSec = (10 * 60);
    }
    
    if (CloseRequestTimeoutValueInSec < TimerThreadSleepTimeInSec) {
        TimerThreadSleepTimeInSec = CloseRequestTimeoutValueInSec;
    }
    
    RegNtStatus = UMRxReadDWORDFromTheRegistry(MRXDAV_DEBUG_KEY,
                                               CREATESRVCALL_REQUEST_TIMEOUT_IN_SEC,
                                               &(CreateSrvCallRequestTimeoutValueInSec));
    if (RegNtStatus != STATUS_SUCCESS) {
        CreateSrvCallRequestTimeoutValueInSec = 60;
    }
    
    if (CreateSrvCallRequestTimeoutValueInSec < TimerThreadSleepTimeInSec) {
        TimerThreadSleepTimeInSec = CreateSrvCallRequestTimeoutValueInSec;
    }

    RegNtStatus = UMRxReadDWORDFromTheRegistry(MRXDAV_DEBUG_KEY,
                                               FINALIZESRVCALL_REQUEST_TIMEOUT_IN_SEC,
                                               &(FinalizeSrvCallRequestTimeoutValueInSec));
    if (RegNtStatus != STATUS_SUCCESS) {
        FinalizeSrvCallRequestTimeoutValueInSec = (10 * 60);
    }
    
    if (FinalizeSrvCallRequestTimeoutValueInSec < TimerThreadSleepTimeInSec) {
        TimerThreadSleepTimeInSec = FinalizeSrvCallRequestTimeoutValueInSec;
    }

    RegNtStatus = UMRxReadDWORDFromTheRegistry(MRXDAV_DEBUG_KEY,
                                               FINALIZEFOBX_REQUEST_TIMEOUT_IN_SEC,
                                               &(FinalizeFobxRequestTimeoutValueInSec));
    if (RegNtStatus != STATUS_SUCCESS) {
        FinalizeFobxRequestTimeoutValueInSec = (10 * 60);
    }
    
    if (FinalizeFobxRequestTimeoutValueInSec < TimerThreadSleepTimeInSec) {
        TimerThreadSleepTimeInSec = FinalizeFobxRequestTimeoutValueInSec;
    }

    RegNtStatus = UMRxReadDWORDFromTheRegistry(MRXDAV_DEBUG_KEY,
                                               FINALIZEVNETROOT_REQUEST_TIMEOUT_IN_SEC,
                                               &(FinalizeVNetRootRequestTimeoutValueInSec));
    if (RegNtStatus != STATUS_SUCCESS) {
        FinalizeVNetRootRequestTimeoutValueInSec = (10 * 60);
    }
    
    if (FinalizeVNetRootRequestTimeoutValueInSec < TimerThreadSleepTimeInSec) {
        TimerThreadSleepTimeInSec = FinalizeVNetRootRequestTimeoutValueInSec;
    }

    RegNtStatus = UMRxReadDWORDFromTheRegistry(MRXDAV_DEBUG_KEY,
                                               RENAME_REQUEST_TIMEOUT_IN_SEC,
                                               &(ReNameRequestTimeoutValueInSec));
    if (RegNtStatus != STATUS_SUCCESS) {
        ReNameRequestTimeoutValueInSec = (10 * 60);
    }
    
    if (ReNameRequestTimeoutValueInSec < TimerThreadSleepTimeInSec) {
        TimerThreadSleepTimeInSec = ReNameRequestTimeoutValueInSec;
    }

    RegNtStatus = UMRxReadDWORDFromTheRegistry(MRXDAV_DEBUG_KEY,
                                               SETFILEINFO_REQUEST_TIMEOUT_IN_SEC,
                                               &(SetFileInfoRequestTimeoutValueInSec));
    if (RegNtStatus != STATUS_SUCCESS) {
        SetFileInfoRequestTimeoutValueInSec = (10 * 60);
    }
    
    if (SetFileInfoRequestTimeoutValueInSec < TimerThreadSleepTimeInSec) {
        TimerThreadSleepTimeInSec = SetFileInfoRequestTimeoutValueInSec;
    }

    RegNtStatus = UMRxReadDWORDFromTheRegistry(MRXDAV_DEBUG_KEY,
                                               QUERYFILEINFO_REQUEST_TIMEOUT_IN_SEC,
                                               &(QueryFileInfoRequestTimeoutValueInSec));
    if (RegNtStatus != STATUS_SUCCESS) {
        QueryFileInfoRequestTimeoutValueInSec = (10 * 60);
    }

    if (QueryFileInfoRequestTimeoutValueInSec < TimerThreadSleepTimeInSec) {
        TimerThreadSleepTimeInSec = QueryFileInfoRequestTimeoutValueInSec;
    }

    RegNtStatus = UMRxReadDWORDFromTheRegistry(MRXDAV_DEBUG_KEY,
                                               QUERYVOLUMEINFO_REQUEST_TIMEOUT_IN_SEC,
                                               &(QueryVolumeInfoRequestTimeoutValueInSec));
    if (RegNtStatus != STATUS_SUCCESS) {
        QueryVolumeInfoRequestTimeoutValueInSec = (10 * 60);
    }

    if (QueryVolumeInfoRequestTimeoutValueInSec < TimerThreadSleepTimeInSec) {
        TimerThreadSleepTimeInSec = QueryVolumeInfoRequestTimeoutValueInSec;
    }

    RegNtStatus = UMRxReadDWORDFromTheRegistry(MRXDAV_DEBUG_KEY,
                                               LOCKREFRESH_REQUEST_TIMEOUT_IN_SEC,
                                               &(LockRefreshRequestTimeoutValueInSec));
    if (RegNtStatus != STATUS_SUCCESS) {
        LockRefreshRequestTimeoutValueInSec = (10 * 60);
    }

    if (LockRefreshRequestTimeoutValueInSec < TimerThreadSleepTimeInSec) {
        TimerThreadSleepTimeInSec = LockRefreshRequestTimeoutValueInSec;
    }

    // DbgPrint("MRxDAVInitializeTheTimeValues: TimerThreadSleepTimeInSec = %d\n", TimerThreadSleepTimeInSec);

    //
    // Initialize the debug tracing for the Mini-Redir.
    //
#if DBG
    UMRxReadDWORDFromTheRegistry(MRXDAV_DEBUG_KEY, MRXDAV_DEBUG_VALUE, &(MRxDavDebugVector));
#endif

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\kernel\innerio.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    InnerIo.c

Abstract:

    This module implements the routines that handle the Query and Set File
    Information IRPs that are sent to the kernel.

Author:

    Rohan Kumar     [RohanK]    10-October-2000

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include "webdav.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, DavXxxInformation)
#endif

//
// The IrpCompletionContext structure that is used in the Query and Set File
// Information operations. All we need is an event on which we will wait till
// the underlying file system completes the request. This event gets signalled
// in the Completion routine that we specify.
//
typedef struct _DAV_IRPCOMPLETION_CONTEXT {

    //
    // The event which is signalled in the Completion routine that is passed
    // to IoCallDriver in the Query and Set File Information requests.
    //
    KEVENT Event;

} DAV_IRPCOMPLETION_CONTEXT, *PDAV_IRPCOMPLETION_CONTEXT;

NTSTATUS
DavIrpCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP CalldownIrp,
    IN PVOID Context
    );

//
// Implementation of functions begins here.
//

NTSTATUS
DavIrpCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP CalldownIrp,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine is called when the Query and Set File Information IRP that was
    sent to the underlying file system is completed.

Arguments:

    DeviceObject - The WebDav Device object.

    CalldownIrp - The IRP that was created and sent to the underlying file 
                  system.

    Context - The context that was set in the IoSetCompletionRoutine function.

Return Value:

    STATUS_MORE_PROCESSING_REQUIRED

--*/
{
    PDAV_IRPCOMPLETION_CONTEXT IrpCompletionContext = NULL;

    //
    // This is not Pageable code.
    //

    IrpCompletionContext = (PDAV_IRPCOMPLETION_CONTEXT)Context;

    //
    // If the IoCallDriver routine returned pending then it will be set in the
    // IRP's PendingReturned field. In this case we need to set the event on 
    // which the thread which issued IoCallDriver will be waiting.
    //
    if (CalldownIrp->PendingReturned){
        KeSetEvent( &(IrpCompletionContext->Event), 0, FALSE );
    }

    return(STATUS_MORE_PROCESSING_REQUIRED);
}


NTSTATUS
DavXxxInformation(
    IN const int xMajorFunction,
    IN PFILE_OBJECT FileObject,
    IN ULONG InformationClass,
    IN ULONG Length,
    OUT PVOID Information,
    OUT PULONG ReturnedLength
    )

/*++

Routine Description:

    This routine returns the requested information about a specified file
    or volume.  The information returned is determined by the class that
    is specified, and it is placed into the caller's output buffer.

Arguments:

    xMajorFunction - The Major Function (Query or Set File Information).

    FileObject - Supplies a pointer to the file object about which the 
                 requested information is returned.

    InformationClass - Specifies the type of information which should be
                       returned about the file/volume.

    Length - Supplies the length of the buffer in bytes.

    Information - Supplies a buffer to receive the requested information
                  returned about the file.  This buffer must not be pageable 
                  and must reside in system space.

    ReturnedLength - Supplies a variable that is to receive the length of the
                     information written to the buffer.

Return Value:

    The status returned is the final completion status of the operation.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PIRP Irp = NULL, TopIrp = NULL;
    PIO_STACK_LOCATION IrpSp = NULL;
    PDEVICE_OBJECT DeviceObject = NULL;
    DAV_IRPCOMPLETION_CONTEXT IrpCompletionContext;
    ULONG DummyReturnedLength = 0;

    PAGED_CODE();

    if (ReturnedLength == NULL) {
        ReturnedLength = &(DummyReturnedLength);
    }

    DeviceObject = IoGetRelatedDeviceObject(FileObject);

    //
    // Allocate and initialize the I/O Request Packet (IRP) for this operation.
    // The allocation is performed with an exception handler in case the
    // caller does not have enough quota to allocate the packet.
    //

    Irp = IoAllocateIrp(DeviceObject->StackSize, TRUE);
    if (Irp == NULL) {
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: DavXxxInformation/IoAllocateIrp\n",
                     PsGetCurrentThreadId()));
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto EXIT_THE_FUNCTION;
    }

    Irp->Tail.Overlay.OriginalFileObject = FileObject;

    Irp->Tail.Overlay.Thread = PsGetCurrentThread();

    Irp->RequestorMode = KernelMode;

    //
    // Get a pointer to the stack location for the first driver. This will be
    // used to pass the original function codes and parameters.
    //

    IrpSp = IoGetNextIrpStackLocation(Irp);

    IrpSp->MajorFunction = (UCHAR)xMajorFunction;

    IrpSp->FileObject = FileObject;

    //
    // Set the completion routine to be called everytime.
    //
    IoSetCompletionRoutine(Irp,
                           DavIrpCompletionRoutine,
                           &(IrpCompletionContext),
                           TRUE,
                           TRUE,
                           TRUE);

    Irp->AssociatedIrp.SystemBuffer = Information;

    IF_DEBUG {

        ASSERT( (IrpSp->MajorFunction == IRP_MJ_QUERY_INFORMATION) ||
                (IrpSp->MajorFunction == IRP_MJ_SET_INFORMATION)   ||
                (IrpSp->MajorFunction == IRP_MJ_QUERY_VOLUME_INFORMATION) );

        if (IrpSp->MajorFunction == IRP_MJ_SET_INFORMATION) {
            ASSERT( (InformationClass == FileAllocationInformation) || (InformationClass == FileEndOfFileInformation) );
        }

        ASSERT( &(IrpSp->Parameters.QueryFile.Length) == &(IrpSp->Parameters.SetFile.Length) );

        ASSERT( &(IrpSp->Parameters.QueryFile.Length) == &(IrpSp->Parameters.QueryVolume.Length) );

        ASSERT( &(IrpSp->Parameters.QueryFile.FileInformationClass) == &(IrpSp->Parameters.SetFile.FileInformationClass) );

        ASSERT( (PVOID)&(IrpSp->Parameters.QueryFile.FileInformationClass) == (PVOID)&(IrpSp->Parameters.QueryVolume.FsInformationClass) );

    }

    IrpSp->Parameters.QueryFile.Length = Length;

    IrpSp->Parameters.QueryFile.FileInformationClass = InformationClass;

    //
    // Initialize the event on which we will wait after we call IoCallDriver.
    // This event will be signalled in the Completion routine which will be 
    // called by the underlying file system after it completes the operation.
    //
    KeInitializeEvent(&(IrpCompletionContext.Event),
                      NotificationEvent,
                      FALSE);

    //
    // Now is the time to call the underlying file system with the Irp that we
    // just created.
    //
    try {

        //
        // Save the TopLevel Irp.
        //
        TopIrp = IoGetTopLevelIrp();

        //
        // Tell the underlying guy he's all clear.
        //
        IoSetTopLevelIrp(NULL);

        //
        // Finally, call the underlying file system to process the request.
        //
        NtStatus = IoCallDriver(DeviceObject, Irp);
    
    } finally {

        //
        // Restore my context for unwind.
        //
        IoSetTopLevelIrp(TopIrp);

    }


    if (NtStatus == STATUS_PENDING) {

        //
        // If STATUS_PENDING was returned by the underlying file system then we
        // wait here till the operation gets completed.
        //
        KeWaitForSingleObject(&(IrpCompletionContext.Event),
                               Executive,
                               KernelMode,
                               FALSE,
                               NULL);

        NtStatus = Irp->IoStatus.Status;

    }

    if (NtStatus == STATUS_SUCCESS) {
        *ReturnedLength = (ULONG)Irp->IoStatus.Information;
    }

EXIT_THE_FUNCTION:

    if (Irp != NULL) {
        IoFreeIrp(Irp);
    }

    return(NtStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\kernel\precomp.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    This includes the header files needed by everyone in this directory.

Revision History:

--*/

//
// A MiniRedir must declare its name and imports ptr.
//
#define MINIRDR__NAME MRxDAV
#define ___MINIRDR_IMPORTS_NAME (MRxDAVDeviceObject->RdbssExports)
#define RX_PRIVATE_BUILD 1

//
// Get the minirdr environment.
//
#include "rx.h"

//
// NT network file system driver include files.
//
#include "ntddnfs2.h"

//
// Reflector library's user mode header file.
//
#include "ntumrefl.h"

//
// Describes the data structures shared by the user and kernel mode
// components of the DAV miniredir.
//
#include "usrmddav.h"

#include "netevent.h"

#include "davname.h"

#include "infocach.h"


//
// Reflector library's kernel mode header file.
//
#include "umrx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\kernel\openclos.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    openclos.c

Abstract:

    This module implements the DAV miniredir call down routines pertaining to 
    opening/closing of file/directories.

Author:

    Balan Sethu Raman      [SethuR]
    
    Rohan Kumar            [rohank]      15-March-1999

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include "webdav.h"


//
// The global list of all the active LOCK tokens (one for every LOCK taken) and
// the resource that is used to synchronize access to it.
//
LIST_ENTRY LockTokenEntryList;
ERESOURCE LockTokenEntryListLock;

//
// The global list of all the LOCK conflict entries and the resource that is
// used to synchronize access to it.
//
LIST_ENTRY LockConflictEntryList;
ERESOURCE LockConflictEntryListLock;

//
// Mentioned below are the prototypes of functions tht are used only within
// this module (file). These functions should not be exposed outside.
//

NTSTATUS
MRxDAVSyncIrpCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP CalldownIrp,
    IN PVOID Context
    );

NTSTATUS
MRxDAVCreateContinuation(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE
    );

NTSTATUS
MRxDAVCloseSrvOpenContinuation(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE
    );

NTSTATUS
MRxDAVFormatUserModeCloseRequest(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE,
    PUMRX_USERMODE_WORKITEM_HEADER WorkItemHeader,
    ULONG WorkItemLength,
    PULONG_PTR ReturnedLength
    );

NTSTATUS
MRxDAVFormatUserModeCreateRequest(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE,
    PUMRX_USERMODE_WORKITEM_HEADER WorkItemHeader,
    ULONG WorkItemLength,
    PULONG_PTR ReturnedLength
    );

BOOL
MRxDAVPrecompleteUserModeCloseRequest(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE,
    PUMRX_USERMODE_WORKITEM_HEADER WorkItemHeader,
    ULONG WorkItemLength,
    BOOL OperationCancelled
    );

BOOL
MRxDAVPrecompleteUserModeCreateRequest(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE,
    PUMRX_USERMODE_WORKITEM_HEADER WorkItemHeader,
    ULONG WorkItemLength,
    BOOL OperationCancelled
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, MRxDAVSyncXxxInformation)
#pragma alloc_text(PAGE, MRxDAVShouldTryToCollapseThisOpen)
#pragma alloc_text(PAGE, MRxDAVSetLoud)
#pragma alloc_text(PAGE, MRxDAVCreate)
#pragma alloc_text(PAGE, MRxDAVFormatUserModeCreateRequest)
#pragma alloc_text(PAGE, MRxDAVPrecompleteUserModeCreateRequest)
#pragma alloc_text(PAGE, MRxDAVCreateContinuation)
#pragma alloc_text(PAGE, MRxDAVCollapseOpen)
#pragma alloc_text(PAGE, MRxDAVComputeNewBufferingState)
#pragma alloc_text(PAGE, MRxDAVTruncate)
#pragma alloc_text(PAGE, MRxDAVForcedClose)
#pragma alloc_text(PAGE, MRxDAVCloseSrvOpen)
#pragma alloc_text(PAGE, MRxDAVFormatUserModeCloseRequest)
#pragma alloc_text(PAGE, MRxDAVPrecompleteUserModeCloseRequest)
#pragma alloc_text(PAGE, MRxDAVCloseSrvOpenContinuation)
#endif

//
// The implementation of functions begins here.
//

#define MRXDAV_ENCRYPTED_DIRECTORY_KEY L"\\Registry\\Machine\\SYSTEM\\CurrentControlSet\\Services\\MRxDAV\\EncryptedDirectories"

NTSTATUS
MRxDAVSyncIrpCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP CalldownIrp,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine is called when the calldownirp is completed.

Arguments:

    DeviceObject
    
    CalldownIrp
    
    Context

Return Value:

    RXSTATUS - STATUS_MORE_PROCESSING_REQUIRED

--*/
{
    PRX_CONTEXT RxContext = (PRX_CONTEXT)Context;

    //
    // Since this is an IRP completion rotuine, this cannot be paged code.
    //

    if (CalldownIrp->PendingReturned){
        RxSignalSynchronousWaiter(RxContext);
    }
    
    return(STATUS_MORE_PROCESSING_REQUIRED);
}


ULONG_PTR DummyReturnedLengthForXxxInfo;

NTSTATUS
MRxDAVSyncXxxInformation(
    IN OUT PRX_CONTEXT RxContext,
    IN UCHAR MajorFunction,
    IN PFILE_OBJECT FileObject,
    IN ULONG InformationClass,
    IN ULONG Length,
    OUT PVOID Information,
    OUT PULONG_PTR ReturnedLength OPTIONAL
    )
/*++

Routine Description:

    This routine returns the requested information about a specified file
    or volume.  The information returned is determined by the class that
    is specified, and it is placed into the caller's output buffer.

Arguments:

    FsInformationClass - Specifies the type of information which should be
                         returned about the file/volume.

    Length - Supplies the length of the buffer in bytes.

    FsInformation - Supplies a buffer to receive the requested information
                    returned about the file.  This buffer must not be pageable 
                    and must reside in system space.

    ReturnedLength - Supplies a variable that is to receive the length of the
                     information written to the buffer.

    FileInformation - Boolean that indicates whether the information requested
                      is for a file or a volume.

Return Value:

    The status returned is the final completion status of the operation.

--*/
{
    NTSTATUS Status;
    PIRP irp,TopIrp;
    PIO_STACK_LOCATION irpSp;
    PDEVICE_OBJECT DeviceObject;

    PAGED_CODE();

    if (ReturnedLength == NULL) {
        ReturnedLength = &(DummyReturnedLengthForXxxInfo);
    }

    ASSERT (FileObject);
    DeviceObject = IoGetRelatedDeviceObject(FileObject);
    ASSERT (DeviceObject);

    //
    // Allocate and initialize the I/O Request Packet (IRP) for this operation.
    // The allocation is performed with an exception handler in case the
    // caller does not have enough quota to allocate the packet.
    //

    irp = IoAllocateIrp(DeviceObject->StackSize, TRUE);
    if (!irp) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    irp->Tail.Overlay.OriginalFileObject = FileObject;
    irp->Tail.Overlay.Thread = PsGetCurrentThread();
    irp->RequestorMode = KernelMode;

    //
    // Get a pointer to the stack location for the first driver.  This will be
    // used to pass the original function codes and parameters.
    //
    irpSp = IoGetNextIrpStackLocation(irp);
    irpSp->MajorFunction = MajorFunction;
    irpSp->FileObject = FileObject;
    IoSetCompletionRoutine(irp,
                           MRxDAVSyncIrpCompletionRoutine,
                           RxContext,
                           TRUE,
                           TRUE,
                           TRUE);


    irp->AssociatedIrp.SystemBuffer = Information;

    //
    // Copy the caller's parameters to the service-specific portion of the
    // IRP.
    //
    IF_DEBUG {
        ASSERT((irpSp->MajorFunction == IRP_MJ_QUERY_INFORMATION)
               || (irpSp->MajorFunction == IRP_MJ_SET_INFORMATION)
               || (irpSp->MajorFunction == IRP_MJ_QUERY_VOLUME_INFORMATION));

        if (irpSp->MajorFunction == IRP_MJ_SET_INFORMATION) {
            //IF_LOUD_DOWNCALLS(MiniFileObject) {
            //    SetFileInfoInfo =  ((PFILE_END_OF_FILE_INFORMATION)Information)->EndOfFile.LowPart;
            //}
        }

        ASSERT(&irpSp->Parameters.QueryFile.Length 
                                         == &irpSp->Parameters.SetFile.Length);
        ASSERT(&irpSp->Parameters.QueryFile.Length 
                                     == &irpSp->Parameters.QueryVolume.Length);
        ASSERT(&irpSp->Parameters.QueryFile.FileInformationClass
                           == &irpSp->Parameters.SetFile.FileInformationClass);
        ASSERT(&irpSp->Parameters.QueryFile.FileInformationClass
                         == &irpSp->Parameters.QueryVolume.FsInformationClass);
    }

    irpSp->Parameters.QueryFile.Length = Length;
    irpSp->Parameters.QueryFile.FileInformationClass = InformationClass;

    //
    // Now simply invoke the driver at its dispatch entry with the IRP.
    //
    KeInitializeEvent(&RxContext->SyncEvent,
                      NotificationEvent,
                      FALSE);

    try {
        TopIrp = IoGetTopLevelIrp();
        //
        // Tell the underlying guy he's all clear.
        //
        IoSetTopLevelIrp(NULL);
        Status = IoCallDriver(DeviceObject,irp);
    } finally {
        //
        // Restore my context for unwind.
        //
        IoSetTopLevelIrp(TopIrp);
    }

    if (Status == (STATUS_PENDING)) {
        RxWaitSync(RxContext);
        Status = irp->IoStatus.Status;
    }

    if (Status == STATUS_SUCCESS) {
        *ReturnedLength = irp->IoStatus.Information;
    }

    IoFreeIrp(irp);
    
    return(Status);
}


NTSTATUS
MRxDAVShouldTryToCollapseThisOpen(
    IN PRX_CONTEXT RxContext
    )
/*++

Routine Description:

   This routine determines if the mini knows of a good reason not
   to try collapsing on this open. Presently, the only reason would
   be if this were a copychunk open.

Arguments:

    RxContext - the RDBSS context

Return Value:

    NTSTATUS - The return status for the operation
        SUCCESS --> okay to try collapse
        other (MORE_PROCESSING_REQUIRED) --> dont collapse

--*/
{
    NTSTATUS Status = STATUS_MORE_PROCESSING_REQUIRED;

    PAGED_CODE();

    //
    // We do not collapse any SrvOpen. The idea is to have one SrvOpen per 
    // create. 
    //

    DavDbgTrace(DAV_TRACE_DETAIL, 
                ("%ld: Entering MRxDAVShouldTryToCollapseThisOpen!!!!\n",
                 PsGetCurrentThreadId()));
    
    return Status;
}


ULONG UMRxLoudStringTableSize = 0;
UNICODE_STRING UMRxLoudStrings[50];

VOID    
MRxDAVSetLoud(
    IN PBYTE Msg,
    IN PRX_CONTEXT RxContext,
    IN PUNICODE_STRING s
    )
{
    ULONG i;
    UNICODE_STRING temp;

    PAGED_CODE();

    for (i=0; i < UMRxLoudStringTableSize; i++) {
        PUNICODE_STRING t = &(UMRxLoudStrings[i]);
        ((PBYTE)temp.Buffer) = ((PBYTE)s->Buffer) + s->Length - t->Length;
        temp.Length = t->Length;
        if (RtlEqualUnicodeString(&temp, t, TRUE)) {
            DavDbgTrace(DAV_TRACE_DETAIL,
                        ("%ld: MRxDAVSetLoud: %s Found %wZ from %wZ.\n", 
                         PsGetCurrentThreadId(), Msg, t, s));
            RxContext->LoudCompletionString = t;
            break;
        }
    }
}


NTSTATUS
MRxDAVCreate(
    IN PRX_CONTEXT RxContext
    )
/*++

Routine Description:

   This routine handles create request for the DAV mini-redir.

Arguments:

    RxContext - The RDBSS context.

Return Value:

    RXSTATUS - The return status for the operation.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    PAGED_CODE();

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Entering MRxDAVCreate!!!!\n", PsGetCurrentThreadId()));

    DavDbgTrace(DAV_TRACE_CONTEXT,
                ("%ld: MRxDAVCreate: RxContext: %08lx\n", 
                 PsGetCurrentThreadId(), RxContext));

    NtStatus = UMRxAsyncEngOuterWrapper(RxContext,
                                        SIZEOF_DAV_SPECIFIC_CONTEXT,
                                        MRxDAVFormatTheDAVContext,
                                        DAV_MINIRDR_ENTRY_FROM_CREATE,
                                        MRxDAVCreateContinuation,
                                        "MRxDAVCreate");
    
    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Leaving MRxDAVCreate with NtStatus = %08lx\n", 
                 PsGetCurrentThreadId(), NtStatus));
    
    return(NtStatus);
}


NTSTATUS
MRxDAVFormatUserModeCreateRequest(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE,
    PUMRX_USERMODE_WORKITEM_HEADER WorkItemHeader,
    ULONG WorkItemLength,
    PULONG_PTR ReturnedLength
    )
/*++

Routine Description:

    This routine formats the arguments of the create request which is being 
    sent to the user mode for processing.

Arguments:
    
    RxContext - The RDBSS context.
    
    AsyncEngineContext - The reflctor's context.
    
    WorkItem - The work item buffer.
    
    WorkItemLength - The length of the work item buffer.
    
    ReturnedLength - 
    
Return Value:

    STATUS_SUCCESS or STATUS_INSUFFICIENT_RESOURCES.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PDAV_USERMODE_WORKITEM WorkItem = (PDAV_USERMODE_WORKITEM)WorkItemHeader;
    PMRX_SRV_OPEN SrvOpen = RxContext->pRelevantSrvOpen;
    PMRX_FCB Fcb = SrvOpen->pFcb;
    PWEBDAV_FCB DavFcb = MRxDAVGetFcbExtension(Fcb);
    PWEBDAV_CONTEXT DavContext = (PWEBDAV_CONTEXT)AsyncEngineContext;
    PNT_CREATE_PARAMETERS CreateParameters;                       
    PDAV_USERMODE_CREATE_REQUEST CreateRequest = &(WorkItem->CreateRequest);
    PDAV_USERMODE_CREATE_RESPONSE CreateResponse = &(WorkItem->CreateResponse);
    PWEBDAV_V_NET_ROOT DavVNetRoot = NULL;
    PWEBDAV_SRV_CALL DavSrvCall = NULL;
    PSECURITY_CLIENT_CONTEXT SecurityClientContext = NULL;
    PBYTE SecondaryBuff = NULL;
    PWCHAR NetRootName = NULL, AlreadyPrefixedName = NULL;
    DWORD PathLen = 0, PathLenInBytes = 0, SdLength = 0;
    BOOL didIAllocateFileNameInfo = FALSE;

    PAGED_CODE();

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Entering MRxDAVFormatUserModeCreateRequest!!!!\n",
                 PsGetCurrentThreadId()));

    DavDbgTrace(DAV_TRACE_CONTEXT,
                ("%ld: MRxDAVFormatUserModeCreateRequest: AsyncEngineContext = "
                 "%08lx, RxContext = %08lx.\n", PsGetCurrentThreadId(),  
                 AsyncEngineContext, RxContext));

    CreateParameters = &(RxContext->Create.NtCreateParameters);

    //
    // Set the SecurityClientContext which is used in impersonating. 
    //
    MRxDAVGetSecurityClientContext();

    //
    // Copy the LogonID in the CreateRequest buffer. The LogonId is in the 
    // MiniRedir's portion of the V_NET_ROOT.
    //
    CreateRequest->LogonID.LowPart = DavVNetRoot->LogonID.LowPart;
    CreateRequest->LogonID.HighPart = DavVNetRoot->LogonID.HighPart;

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVFormatUserModeCreateRequest: LogonID.LowPart = %08lx\n",
                 PsGetCurrentThreadId(), DavVNetRoot->LogonID.LowPart));

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVFormatUserModeCreateRequest: LogonID.HighPart = %08lx\n",
                 PsGetCurrentThreadId(), DavVNetRoot->LogonID.HighPart));
    
    //
    // Impersonate the client who initiated the request. If we fail to 
    // impersonate, tough luck.
    //
    if (SecurityClientContext != NULL) {
        NtStatus = UMRxImpersonateClient(SecurityClientContext, WorkItemHeader);
        if (!NT_SUCCESS(NtStatus)) {
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: ERROR: MRxDAVFormatUserModeCreateRequest/"
                         "UMRxImpersonateClient. NtStatus = %08lx.\n", 
                         PsGetCurrentThreadId(), NtStatus));
            goto EXIT_THE_FUNCTION;
        }   
    } else {
        NtStatus = STATUS_INVALID_PARAMETER;
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: ERROR: MRxDAVFormatUserModeCreateRequest: "
                     "SecurityClientContext is NULL.\n", 
                     PsGetCurrentThreadId()));
        goto EXIT_THE_FUNCTION;
    }

    NetRootName = SrvOpen->pVNetRoot->pNetRoot->pNetRootName->Buffer;
    
    AlreadyPrefixedName = SrvOpen->pAlreadyPrefixedName->Buffer;

    //
    // Allocate memory for the complete path name and copy it.
    // The CompletePathName = NetRootName + AlreadyPrefixedName. The extra two
    // bytes are for '\0' at the end.
    //
    PathLen = SrvOpen->pVNetRoot->pNetRoot->pNetRootName->Length;
    PathLen += SrvOpen->pAlreadyPrefixedName->Length;
    PathLen += sizeof(WCHAR);
    PathLenInBytes = PathLen;
    SecondaryBuff = UMRxAllocateSecondaryBuffer(AsyncEngineContext, 
                                                PathLenInBytes);
    if (SecondaryBuff == NULL) {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("ld: MRxDAVFormatUserModeCreateRequest/"
                     "UMRxAllocateSecondaryBuffer: ERROR: NtStatus = %08lx.\n",
                     PsGetCurrentThreadId(), NtStatus));
        goto EXIT_THE_FUNCTION;
    }
    
    CreateRequest->CompletePathName = (PWCHAR)SecondaryBuff;

    RtlZeroMemory(CreateRequest->CompletePathName, PathLenInBytes);

    //
    // Copy the NetRootName.
    //
    RtlCopyMemory(SecondaryBuff,
                  NetRootName, 
                  SrvOpen->pVNetRoot->pNetRoot->pNetRootName->Length);

    //
    // Copy the AlreadyPrefixedName after the NetRootName to make the complete
    // path name.
    //
    RtlCopyMemory(SecondaryBuff + SrvOpen->pVNetRoot->pNetRoot->pNetRootName->Length, 
                  AlreadyPrefixedName, 
                  SrvOpen->pAlreadyPrefixedName->Length);

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVFormatUserModeCreateRequest: CPN = %ws.\n",
                 PsGetCurrentThreadId(), CreateRequest->CompletePathName));


    //
    // If this is the first create, then we need to allocate the FileNameInfo
    // in the FCB. This is used in logging the delayed write failure.
    //
    if (DavFcb->FileNameInfoAllocated != TRUE) {
        
        DavFcb->FileNameInfo.Buffer = RxAllocatePoolWithTag(PagedPool,
                                                            PathLenInBytes,
                                                            DAV_FILEINFO_POOLTAG);
        if (DavFcb->FileNameInfo.Buffer == NULL) {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("ld: ERROR: MRxDAVFormatUserModeCreateRequest/"
                         "RxAllocatePoolWithTag: NtStatus = %08lx\n",
                         PsGetCurrentThreadId(), NtStatus));
            goto EXIT_THE_FUNCTION;
        }

        RtlZeroMemory(DavFcb->FileNameInfo.Buffer, PathLenInBytes);
    
        RtlCopyMemory(DavFcb->FileNameInfo.Buffer,
                      CreateRequest->CompletePathName,
                      PathLenInBytes);

        DavFcb->FileNameInfo.Length = (USHORT)PathLenInBytes - sizeof(WCHAR);
        DavFcb->FileNameInfo.MaximumLength = (USHORT)PathLenInBytes;

        DavFcb->FileNameInfoAllocated = TRUE;

        didIAllocateFileNameInfo = TRUE;
    
        DavDbgTrace(DAV_TRACE_DETAIL,
                    ("%ld: MRxDAVFormatUserModeCreateRequest: FileNameInfo = %wZ\n",
                     PsGetCurrentThreadId(), &(DavFcb->FileNameInfo)));

    }

    WorkItem->WorkItemType = UserModeCreate;

    //
    // Set the ServerID that was got during the CreateSrvCall operation.
    //
    ASSERT(RxContext->pRelevantSrvOpen->pVNetRoot->pNetRoot->pSrvCall->Context);
    DavSrvCall = (PWEBDAV_SRV_CALL)RxContext->pRelevantSrvOpen->pVNetRoot->
                                   pNetRoot->pSrvCall->Context;
    
    CreateRequest->ServerID = DavSrvCall->ServerID;
    
    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVFormatUserModeCreateRequest: ServerID = %d.\n",
                 PsGetCurrentThreadId(), CreateRequest->ServerID));

    CreateRequest->AllocationSize = CreateParameters->AllocationSize;
    
    CreateRequest->FileAttributes = CreateParameters->FileAttributes;
    
    CreateRequest->ShareAccess = CreateParameters->ShareAccess;
    
    CreateRequest->CreateDisposition = CreateParameters->Disposition;
    
    CreateRequest->EaBuffer = RxContext->Create.EaBuffer;
    
    CreateRequest->EaLength = RxContext->Create.EaLength;
    
    SdLength = CreateRequest->SdLength = RxContext->Create.SdLength;
    
    CreateRequest->ImpersonationLevel = CreateParameters->ImpersonationLevel;
    
    CreateRequest->SecurityFlags = 0;
    if (CreateParameters->SecurityContext != NULL) {
        
        if (CreateParameters->SecurityContext->SecurityQos != NULL) {
            
            if (CreateParameters->SecurityContext->
                    SecurityQos->ContextTrackingMode == SECURITY_DYNAMIC_TRACKING) {
                
                CreateRequest->SecurityFlags |= DAV_SECURITY_DYNAMIC_TRACKING;
            
            }
            
            if (CreateParameters->SecurityContext->SecurityQos->EffectiveOnly) {
                
                CreateRequest->SecurityFlags |= DAV_SECURITY_EFFECTIVE_ONLY;
            
            }
        
        }
    
    }
    
    CreateRequest->DesiredAccess = CreateParameters->DesiredAccess;
    
    CreateRequest->CreateOptions = CreateParameters->CreateOptions;

    if (AsyncEngineContext->FileInformationCached) {
        CreateRequest->FileInformationCached = TRUE;
        CreateResponse->BasicInformation = DavContext->CreateReturnedFileInfo->BasicInformation;
        CreateResponse->StandardInformation = DavContext->CreateReturnedFileInfo->StandardInformation;
        
        DavDbgTrace(DAV_TRACE_DETAIL,
                    ("MRxDAVFormatUserModeCreateRequest file info cached %x %x %x %x %ws\n",
                     CreateResponse->BasicInformation.FileAttributes,
                     CreateResponse->BasicInformation.CreationTime.HighPart,
                     CreateResponse->BasicInformation.CreationTime.LowPart,
                     CreateResponse->StandardInformation.EndOfFile.LowPart,
                     CreateRequest->CompletePathName));
    }

    CreateRequest->ParentDirInfomationCached = AsyncEngineContext->ParentDirInfomationCached;
    CreateRequest->ParentDirIsEncrypted = AsyncEngineContext->ParentDirIsEncrypted;

    if (AsyncEngineContext->FileNotExists) {
        CreateRequest->FileNotExists = TRUE;
    }

EXIT_THE_FUNCTION:

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Leaving MRxDAVFormatUserModeCreateRequest with NtStatus"
                 " = %08lx.\n", PsGetCurrentThreadId(), NtStatus));

    if (NtStatus != STATUS_SUCCESS) {

        if (CreateRequest->CompletePathName != NULL) {
            UMRxFreeSecondaryBuffer(AsyncEngineContext,
                                    (PBYTE)CreateRequest->CompletePathName);
            CreateRequest->CompletePathName = NULL;
        }

        //
        // Free the FileNameInfo buffer only if it was allocated in this call.
        //
        if (DavFcb->FileNameInfo.Buffer != NULL && didIAllocateFileNameInfo) {
            RxFreePool(DavFcb->FileNameInfo.Buffer);
            DavFcb->FileNameInfo.Buffer = NULL;
            DavFcb->FileNameInfo.Length = 0;
            DavFcb->FileNameInfo.MaximumLength = 0;
            DavFcb->FileNameInfoAllocated = FALSE;
        }

    }
    
    return(NtStatus);
}


BOOL
MRxDAVPrecompleteUserModeCreateRequest(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE,
    PUMRX_USERMODE_WORKITEM_HEADER WorkItemHeader,
    ULONG WorkItemLength,
    BOOL OperationCancelled
    )
/*++

Routine Description:

Arguments:

    RxContext - The RDBSS context.
    
    AsyncEngineContext - The reflctor's context.
    
    WorkItem - The work item buffer.
    
    WorkItemLength - The length of the work item buffer.

    OperationCancelled - TRUE if this operation was cancelled by the user.

Return Value:

    TRUE - UMRxAsyncEngineCalldownIrpCompletion is called by the function
           UMRxCompleteUserModeRequest after we return.    

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PDAV_USERMODE_WORKITEM WorkItem = NULL;
    PWEBDAV_CONTEXT DavContext = NULL;
    RxCaptureFcb;
    PMRX_SRV_OPEN SrvOpen = NULL;
    PWEBDAV_SRV_OPEN davSrvOpen = NULL;
    PMRX_FCB Fcb = NULL;
    PWEBDAV_FCB DavFcb = NULL;
    PDAV_USERMODE_CREATE_RESPONSE CreateResponse = NULL;
    PDAV_USERMODE_CREATE_REQUEST CreateRequest = NULL;
    HANDLE OpenHandle;
    PSECURITY_CLIENT_CONTEXT SecurityClientContext = NULL;
    PWEBDAV_V_NET_ROOT DavVNetRoot = NULL;
    PMRX_SRV_CALL SrvCall = NULL;
    PMRX_NET_ROOT NetRoot = NULL;
    PWEBDAV_SRV_CALL DavSrvCall = NULL;

    PAGED_CODE();

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Entering MRxDAVPrecompleteUserModeCreateRequest!!!!\n",
                 PsGetCurrentThreadId()));

    DavDbgTrace(DAV_TRACE_CONTEXT,
                ("%ld: MRxDAVPrecompleteUserModeCreateRequest: "
                 "AsyncEngineContext = %08lx, RxContext = %08lx.\n",
                 PsGetCurrentThreadId(), AsyncEngineContext, RxContext));

    //
    // A Create operation can never be Async.
    //
    ASSERT(AsyncEngineContext->AsyncOperation == FALSE);

    WorkItem = (PDAV_USERMODE_WORKITEM)WorkItemHeader;

    DavContext = (PWEBDAV_CONTEXT)AsyncEngineContext;

    CreateResponse = &(WorkItem->CreateResponse);
    CreateRequest = &(WorkItem->CreateRequest);

    //
    // If the operation is cancelled, then there is no guarantee that the FCB,
    // FOBX etc are still valid. All that we need to do is cleanup and bail.
    //
    if (!OperationCancelled) {
        SrvOpen = RxContext->pRelevantSrvOpen;
        davSrvOpen = MRxDAVGetSrvOpenExtension(SrvOpen);
        Fcb = SrvOpen->pFcb;
        DavFcb = MRxDAVGetFcbExtension(Fcb);
        DavVNetRoot = (PWEBDAV_V_NET_ROOT)RxContext->pRelevantSrvOpen->pVNetRoot->Context;
        SrvCall = SrvOpen->pVNetRoot->pNetRoot->pSrvCall;
        DavSrvCall = MRxDAVGetSrvCallExtension(SrvCall);
        NetRoot = SrvOpen->pFcb->pNetRoot;
    }

    NtStatus = AsyncEngineContext->Status;

    //
    // We need to free up the heap we allocated in the format routine.
    //
    if (CreateRequest->CompletePathName != NULL) {

        if (NtStatus != STATUS_SUCCESS) {
            DavDbgTrace(DAV_TRACE_DETAIL,
                        ("%ld: ERROR: MRxDAVPrecompleteUserModeCreateRequest:"
                         "Open failed for file \"%ws\" with NtStatus = %08lx.\n", 
                         PsGetCurrentThreadId(), CreateRequest->CompletePathName, 
                         NtStatus));
        }

        NtStatus = UMRxFreeSecondaryBuffer(AsyncEngineContext,
                                           (PBYTE)CreateRequest->CompletePathName);
        if (NtStatus != STATUS_SUCCESS) {
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: ERROR: MRxDAVPrecompleteUserModeCreateRequest/"
                         "UMRxFreeSecondaryBuffer: NtStatus = %08lx.\n", 
                         PsGetCurrentThreadId(), NtStatus));
        }

    }

    //
    // If the operation has been cancelled and we created a handle in the
    // usermode then we need to set callWorkItemCleanup to TRUE which will
    // land up closing this handle. In any case, if the operation has been 
    // cancelled, we can leave right away.
    //
    if (OperationCancelled) {
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: ERROR: MRxDAVPrecompleteUserModeCreateRequest: "
                     "Operation Cancelled.\n", PsGetCurrentThreadId()));
        if (CreateResponse->Handle) {
            DavDbgTrace(DAV_TRACE_DETAIL,
                        ("%ld: ERROR: MRxDAVPrecompleteUserModeCreateRequest: "
                         "callWorkItemCleanup\n", PsGetCurrentThreadId()));
            WorkItem->callWorkItemCleanup = TRUE;
        }
        goto EXIT_THE_FUNCTION;
    }

    //
    // Open didn't work. We can bail out now.
    //
    if (AsyncEngineContext->Status != STATUS_SUCCESS) {

        //
        // If the file was already locked on the server then we need to create
        // a LockConflictEntry and add it to the list. The apps can then use 
        // the FileName to query who has locked this file.
        //
        if (CreateResponse->FileWasAlreadyLocked) {

            ULONG PathLengthInBytes = 0, OwnerLengthInBytes = 0;
            PWEBDAV_LOCK_CONFLICT_ENTRY LockConflictEntry;
            PBYTE TempBuffer = NULL;
        
            LockConflictEntry = RxAllocatePoolWithTag(PagedPool,
                                                      sizeof(WEBDAV_LOCK_CONFLICT_ENTRY),
                                                      DAV_LOCKCONFLICTENTRY_POOLTAG);
            if (LockConflictEntry == NULL) {
                NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                DavDbgTrace(DAV_TRACE_ERROR,
                            ("ld: ERROR: MRxDAVPrecompleteUserModeCreateRequest/"
                             "RxAllocatePoolWithTag: NtStatus = %08lx\n",
                             PsGetCurrentThreadId(), NtStatus));
                goto EXIT_THE_FUNCTION;
            }

            RtlZeroMemory(LockConflictEntry, sizeof(WEBDAV_LOCK_CONFLICT_ENTRY));

            //
            // Set the current system time as the creation time of the entry.
            //
            KeQueryTickCount( &(LockConflictEntry->CreationTimeInTickCount) );
            
            //
            // Allocate memory for the complete path name and copy it.
            //

            PathLengthInBytes = SrvOpen->pVNetRoot->pNetRoot->pNetRootName->Length;
            PathLengthInBytes += SrvOpen->pAlreadyPrefixedName->Length;
            PathLengthInBytes += sizeof(WCHAR);
        
            TempBuffer = RxAllocatePoolWithTag(PagedPool,
                                               PathLengthInBytes,
                                               DAV_LOCKCONFLICTENTRY_POOLTAG);
            if (TempBuffer == NULL) {
                NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                DavDbgTrace(DAV_TRACE_ERROR,
                            ("ld: ERROR: MRxDAVPrecompleteUserModeCreateRequest/"
                             "RxAllocatePoolWithTag: NtStatus = %08lx\n",
                             PsGetCurrentThreadId(), NtStatus));
                goto EXIT_THE_FUNCTION;
            }

            LockConflictEntry->CompletePathName = (PWCHAR)TempBuffer;

            RtlZeroMemory(TempBuffer, PathLengthInBytes);

            //
            // Copy the NetRootName. It includes the server name and the share
            // name.
            //
            RtlCopyMemory(TempBuffer,
                          SrvOpen->pVNetRoot->pNetRoot->pNetRootName->Buffer,
                          SrvOpen->pVNetRoot->pNetRoot->pNetRootName->Length);

            //
            // Copy the AlreadyPrefixedName after the NetRootName to make the 
            // complete path name.
            //
            RtlCopyMemory((TempBuffer + SrvOpen->pVNetRoot->pNetRoot->pNetRootName->Length),
                          SrvOpen->pAlreadyPrefixedName->Buffer,
                          SrvOpen->pAlreadyPrefixedName->Length);

            //
            // Allocate memory for the OwnerName and copy it.
            //

            OwnerLengthInBytes = (1 + wcslen(CreateResponse->LockOwner)) * sizeof(WCHAR);

            LockConflictEntry->LockOwner = RxAllocatePoolWithTag(PagedPool,
                                                                 OwnerLengthInBytes,
                                                                 DAV_LOCKCONFLICTENTRY_POOLTAG);
            if (LockConflictEntry->LockOwner == NULL) {
                NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                DavDbgTrace(DAV_TRACE_ERROR,
                            ("ld: ERROR: MRxDAVPrecompleteUserModeCreateRequest/"
                             "RxAllocatePoolWithTag: NtStatus = %08lx\n",
                             PsGetCurrentThreadId(), NtStatus));
                goto EXIT_THE_FUNCTION;
            }

            RtlZeroMemory(LockConflictEntry->LockOwner, OwnerLengthInBytes);

            RtlCopyMemory(LockConflictEntry->LockOwner,
                          CreateResponse->LockOwner,
                          OwnerLengthInBytes);

            //
            // Add the newly created entry to the global LockConflictEntryList.
            //
            ExAcquireResourceExclusiveLite(&(LockConflictEntryListLock), TRUE);
            InsertHeadList(&(LockConflictEntryList), &(LockConflictEntry->listEntry));
            ExReleaseResourceLite(&(LockConflictEntryListLock));

        }

        goto EXIT_THE_FUNCTION;

    }

    //
    // We need to do the "handle to fileobject" association only if its a file.
    // If the create was for a directory, no handle would have been created in
    // the user mode.
    //
    if (!CreateResponse->StandardInformation.Directory) {

        OpenHandle = CreateResponse->Handle;

        DavDbgTrace(DAV_TRACE_DETAIL,
                    ("%ld: MRxDAVPrecompleteUserModeCreateRequest: "
                     "OpenHandle = %08lx.\n", PsGetCurrentThreadId(), 
                     OpenHandle));


        DavFcb->isDirectory = FALSE;

        if ( (OpenHandle != NULL) ) {

            NtStatus = ObReferenceObjectByHandle(OpenHandle,
                                                 0L,
                                                 NULL,
                                                 KernelMode,
                                                 (PVOID *)&(davSrvOpen->UnderlyingFileObject),
                                                 NULL);

            if (NtStatus == STATUS_SUCCESS) {

                DavDbgTrace(DAV_TRACE_DETAIL,
                            ("%ld: MRxDAVPrecompleteUserModeCreateRequest: UFO(1) = %08lx\n",
                             PsGetCurrentThreadId(), davSrvOpen->UnderlyingFileObject));

                davSrvOpen->UnderlyingHandle = OpenHandle;

                davSrvOpen->UserModeKey = CreateResponse->UserModeKey;

                davSrvOpen->UnderlyingDeviceObject = IoGetRelatedDeviceObject(davSrvOpen->UnderlyingFileObject);

                //
                // Copy the local file name into the FCB.
                //
                wcscpy(DavFcb->FileName, CreateResponse->FileName);
                wcscpy(DavFcb->Url, CreateResponse->Url);
                DavFcb->LocalFileIsEncrypted = CreateResponse->LocalFileIsEncrypted;

                MRxDAVGetSecurityClientContext();
                ASSERT(SecurityClientContext != NULL);
                RtlCopyMemory(&(DavFcb->SecurityClientContext),
                              SecurityClientContext,
                              sizeof(SECURITY_CLIENT_CONTEXT));

                DavDbgTrace(DAV_TRACE_DETAIL,
                            ("%ld: MRxDAVPrecompleteUserModeCreateRequest: "
                             "LocalFileName = %ws.\n", PsGetCurrentThreadId(), 
                             DavFcb->FileName));

                //
                // We only get/create the file/dir on the first open. On 
                // subsequent opens, we do the create in the kernel itself since 
                // the file exists in the WinInet cache. This caching is used 
                // till the FCB for the file exists.
                //

                DavFcb->isFileCached = TRUE;

            } else {

                DavDbgTrace(DAV_TRACE_ERROR,
                            ("%ld: ERROR: MRxDAVPrecompleteUserModeCreateRequest/"
                             "ObReferenceObjectByHandle: NtStatus = %08lx.\n", 
                             PsGetCurrentThreadId(), NtStatus));

                //
                // If we have a valid handle, then why should 
                // ObReferenceObjectByHandle fail?
                //
                DbgBreakPoint();

                ZwClose(OpenHandle);

                goto EXIT_THE_FUNCTION;

            }

            //
            // If "FILE_DELETE_ON_CLOSE" flag was specified as one of 
            // the CreateOptions, then we need to remember this and
            // delete this file on close.
            //
            if (CreateResponse->DeleteOnClose) {
                DavFcb->DeleteOnClose = TRUE;
            }

            //
            // If a new file has been created then we need to set the attributes
            // of this new file on close on the server.
            //
            if (CreateResponse->NewFileCreatedAndSetAttributes) {
                DavFcb->fFileAttributesChanged = TRUE;
            }

            //
            // This file exists on the server, but this create operation
            // has FILE_OVERWRITE_IF as its CreateDisposition. So, we 
            // can create this file locally overwrite the one on the 
            // server on close. We set DoNotTakeTheCurrentTimeAsLMT to
            // TRUE since the LMT has been just set on Create and we do
            // not need to set it to the current time on close.
            //
            if (CreateResponse->ExistsAndOverWriteIf) {
                InterlockedExchange(&(DavFcb->FileWasModified), 1);
                DavFcb->DoNotTakeTheCurrentTimeAsLMT = TRUE;
            }

            //
            // If a new file or directory is created, we need to PROPPATCH the
            // time values on close. This is because we use the time values from
            // the client when the name cache entry is created for this new
            // file. The same time value needs to be on the server.
            //
            if (CreateResponse->PropPatchTheTimeValues) {
                DavFcb->fCreationTimeChanged = TRUE;
                DavFcb->fLastAccessTimeChanged = TRUE;
                DavFcb->fLastModifiedTimeChanged = TRUE;
            }

        } else {

            //
            // We don't have an OpenHandle for a file. This should only happen 
            // in case where the open is for read/setting sttributes of a file
            // or deleting/renaming a file. 
            //
            if (!CreateResponse->fPsuedoOpen) {
                DavDbgTrace(DAV_TRACE_ERROR,
                            ("%ld: ERROR: MRxDAVPrecompleteUserModeCreateRequest: No OpenHandle\n"));
                DbgBreakPoint();
            }

            //
            // If "FILE_DELETE_ON_CLOSE" flag was specified as one of 
            // the CreateOptions, then we need to remember this and
            // delete this file on close.
            //
            if (CreateResponse->DeleteOnClose) {
                DavFcb->DeleteOnClose = TRUE;
            }
        
        }

        //
        // If the LOCK was taken on this Create, we need to do the following.
        // 1. Add the OpaqueLockToken to the davSrvOpen.
        // 2. Create a LockTokenEntry and add it to the list which will be
        //    used to refresh the LOCKs on the server.
        //
        if (CreateResponse->LockWasTakenOnThisCreate) {

            PWEBDAV_LOCK_TOKEN_ENTRY LockTokenEntry = NULL;
            PBYTE TempBuffer = NULL, PathName = NULL;
            ULONG LockTokenLengthInBytes = 0, ServerNameLengthInBytes = 0;
            ULONG NetRootNameLengthInBytes = 0, PathNameLengthInBytes = 0;
            PWCHAR NetRootName = NULL;

            //
            // We will be sending the OpaqueLockToken in the following format.
            //          If: (<opaquelocktoken:sdfsdfdsfgsdgdsfgd>)
            // So, we store the token in the same format.
            //
            LockTokenLengthInBytes = (1 + wcslen(CreateResponse->OpaqueLockToken)) * sizeof(WCHAR);
            LockTokenLengthInBytes += (wcslen(L"If: (<>)") * sizeof(WCHAR));

            TempBuffer = RxAllocatePoolWithTag(PagedPool,
                                               LockTokenLengthInBytes,
                                               DAV_SRVOPEN_POOLTAG);
            if (TempBuffer == NULL) {
                NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                DavDbgTrace(DAV_TRACE_ERROR,
                            ("ld: ERROR: MRxDAVPrecompleteUserModeCreateRequest/"
                             "RxAllocatePoolWithTag: NtStatus = %08lx\n",
                             PsGetCurrentThreadId(), NtStatus));
                goto EXIT_THE_FUNCTION;
            }

            davSrvOpen->OpaqueLockToken = (PWCHAR)TempBuffer;

            RtlZeroMemory(TempBuffer, LockTokenLengthInBytes);

            RtlCopyMemory(TempBuffer,
                          L"If: (<",
                          wcslen(L"If: (<") * sizeof(WCHAR));

            RtlCopyMemory(TempBuffer + (wcslen(L"If: (<") * sizeof(WCHAR)),
                          CreateResponse->OpaqueLockToken,
                          wcslen(CreateResponse->OpaqueLockToken) * sizeof(WCHAR));

            RtlCopyMemory(TempBuffer + (wcslen(L"If: (<") * sizeof(WCHAR)) + (wcslen(CreateResponse->OpaqueLockToken) * sizeof(WCHAR)),
                          L">)",
                          wcslen(L">)") * sizeof(WCHAR));

            DavDbgTrace(DAV_TRACE_DETAIL,
                        ("ld: MRxDAVPrecompleteUserModeCreateRequest. "
                         "OpaqueLockToken: %ws\n",
                         PsGetCurrentThreadId(), davSrvOpen->OpaqueLockToken));

            LockTokenEntry = RxAllocatePoolWithTag(PagedPool,
                                                   sizeof(WEBDAV_LOCK_TOKEN_ENTRY),
                                                   DAV_LOCKTOKENENTRY_POOLTAG);
            if (LockTokenEntry == NULL) {
                NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                DavDbgTrace(DAV_TRACE_ERROR,
                            ("ld: ERROR: MRxDAVPrecompleteUserModeCreateRequest/"
                             "RxAllocatePoolWithTag: NtStatus = %08lx\n",
                             PsGetCurrentThreadId(), NtStatus));
                goto EXIT_THE_FUNCTION;
            }

            RtlZeroMemory(LockTokenEntry, sizeof(WEBDAV_LOCK_TOKEN_ENTRY));
            
            //
            // Set the current system time as the creation time of the entry.
            //
            KeQueryTickCount( &(LockTokenEntry->CreationTimeInTickCount) );

            //
            // The OpaqueLockToken will be included in the request that is 
            // sent to the server.
            //
            LockTokenEntry->OpaqueLockToken = davSrvOpen->OpaqueLockToken;
        
            //
            // The SecurityClientContext will be used to impersonate this
            // client while refreshing the LOCK request.
            //
            LockTokenEntry->SecurityClientContext = &(DavVNetRoot->SecurityClientContext);

            //
            // Set the timeout value of the LOCK. This will be used to determine
            // when to send the refresh requests out.
            //
            LockTokenEntry->LockTimeOutValueInSec = CreateResponse->LockTimeout;

            LockTokenEntry->LogonID.LowPart = DavVNetRoot->LogonID.LowPart;
            LockTokenEntry->LogonID.HighPart = DavVNetRoot->LogonID.HighPart;

            LockTokenEntry->ServerID = DavSrvCall->ServerID;

            LockTokenEntry->ShouldThisEntryBeRefreshed = TRUE;

            //
            // Allocate memory for the ServerName and copy it.
            //
            ServerNameLengthInBytes = SrvCall->pSrvCallName->Length + sizeof(WCHAR);
            LockTokenEntry->ServerName = RxAllocatePoolWithTag(PagedPool,
                                                               ServerNameLengthInBytes,
                                                               DAV_LOCKTOKENENTRY_POOLTAG);
            if (LockTokenEntry->ServerName == NULL) {
                NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                DavDbgTrace(DAV_TRACE_ERROR,
                            ("ld: ERROR: MRxDAVPrecompleteUserModeCreateRequest/"
                             "RxAllocatePoolWithTag: NtStatus = %08lx\n",
                             PsGetCurrentThreadId(), NtStatus));
                goto EXIT_THE_FUNCTION;
            }

            RtlZeroMemory(LockTokenEntry->ServerName, ServerNameLengthInBytes);

            RtlCopyBytes(LockTokenEntry->ServerName,
                         SrvCall->pSrvCallName->Buffer,
                         SrvCall->pSrvCallName->Length);

            //
            // Allocate memory for the PathName and copy it.
            //

            NetRootName = &(NetRoot->pNetRootName->Buffer[1]);
            NetRootName = wcschr(NetRootName, L'\\');

            //
            // The sizeof(WCHAR) is for the final '\0' char.
            //
            NetRootNameLengthInBytes = (NetRoot->pNetRootName->Length - NetRoot->pSrvCall->pSrvCallName->Length);
            PathNameLengthInBytes = (NetRootNameLengthInBytes + sizeof(WCHAR));

            if (SrvOpen->pAlreadyPrefixedName->Length) {
                //
                // The sizeof(WCHAR) is for the backslash after the NetRootName.
                //
                PathNameLengthInBytes += (SrvOpen->pAlreadyPrefixedName->Length + sizeof(WCHAR));
            }

            PathName = RxAllocatePoolWithTag(PagedPool,
                                             PathNameLengthInBytes,
                                             DAV_LOCKTOKENENTRY_POOLTAG);
            if (PathName == NULL) {
                NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                DavDbgTrace(DAV_TRACE_ERROR,
                            ("ld: ERROR: MRxDAVPrecompleteUserModeCreateRequest/"
                             "RxAllocatePoolWithTag: NtStatus = %08lx\n",
                             PsGetCurrentThreadId(), NtStatus));
                goto EXIT_THE_FUNCTION;
            }

            LockTokenEntry->PathName = (PWCHAR)PathName;
            
            RtlZeroMemory(PathName, PathNameLengthInBytes);

            //
            // Copy the NetRootName.
            //
            RtlCopyMemory(PathName, NetRootName, NetRootNameLengthInBytes);

            //
            // We need to copy the backclash and the remaining path name only if
            // the remaining path name exists.
            //
            if (SrvOpen->pAlreadyPrefixedName->Length) {
                if (SrvOpen->pAlreadyPrefixedName->Buffer[0] != L'\\') {

                    //
                    // Copy the backslash.
                    //
                    RtlCopyMemory((PathName + NetRootNameLengthInBytes), L"\\", sizeof(WCHAR));

                    //
                    // Copy the remaining path name after the NetRootName.
                    //
                    RtlCopyMemory((PathName + NetRootNameLengthInBytes + sizeof(WCHAR)), 
                                  SrvOpen->pAlreadyPrefixedName->Buffer, 
                                  SrvOpen->pAlreadyPrefixedName->Length);
                } else {
                    //
                    // Copy the remaining path name after the NetRootName which has the leading
                    // backslash already.
                    //
                    RtlCopyMemory((PathName + NetRootNameLengthInBytes), 
                                  SrvOpen->pAlreadyPrefixedName->Buffer, 
                                  SrvOpen->pAlreadyPrefixedName->Length);
                }
            }

            //
            // Add the newly created entry to the global LockTokenEntryList.
            //
            ExAcquireResourceExclusiveLite(&(LockTokenEntryListLock), TRUE);
            InsertHeadList(&(LockTokenEntryList), &(LockTokenEntry->listEntry));
            ExReleaseResourceLite(&(LockTokenEntryListLock));

            //
            // Keep a link to this LockTokenEntry in the davSrvOpen. On close
            // of this SrvOpen, we will delete this entry.
            //
            davSrvOpen->LockTokenEntry = LockTokenEntry;

            //
            // We set this to TRUE since the file has been LOCKed on the server
            // on this Create. All the requests that modify the file on the 
            // server from now on should contain the OpaqueLockToken.
            //
            DavFcb->FileIsLockedOnTheServer = TRUE;

        }

    } else {

        //
        // This was a directory open.
        //
        DavFcb->isDirectory = TRUE;

        if (CreateResponse->DeleteOnClose) {
            DavFcb->DeleteOnClose = TRUE;
        }

        //
        // If a new directory has been created then we need to set the
        // attributes of this new file on close on the server.
        //
        if (CreateResponse->NewFileCreatedAndSetAttributes) {
            DavFcb->fFileAttributesChanged = TRUE;
        }

        //
        // If a new file or directory is created, we need to PROPPATCH the
        // time values on close. This is because we use the time values from
        // the client when the name cache entry is created for this new
        // file. The same time value needs to be on the server.
        //
        if (CreateResponse->PropPatchTheTimeValues) {
            DavFcb->fCreationTimeChanged = TRUE;
            DavFcb->fLastAccessTimeChanged = TRUE;
            DavFcb->fLastModifiedTimeChanged = TRUE;
        }

    }

    if (NtStatus == STATUS_SUCCESS) {

        RxContext->Create.ReturnedCreateInformation = (ULONG)WorkItem->Information;

        *(DavContext->CreateReturnedFileInfo) = CreateResponse->CreateReturnedFileInfo;

        capFcb->Attributes = CreateResponse->CreateReturnedFileInfo.BasicInformation.FileAttributes;

        if ((capFcb->Attributes & FILE_ATTRIBUTE_ENCRYPTED) &&
            ((RxContext->Create.ReturnedCreateInformation == FILE_CREATED) || 
             (RxContext->Create.ReturnedCreateInformation == FILE_OVERWRITTEN))) {
            //
            // The encryption user information is added to the file. This
            // information need to be sent to the server even if the file
            // itself is created empty. We set DoNotTakeTheCurrentTimeAsLMT to
            // TRUE since the LMT has been just set on Create and we do not
            // need to set it to the current time on close.
            //
            InterlockedExchange(&(DavFcb->FileWasModified), 1);
            DavFcb->DoNotTakeTheCurrentTimeAsLMT = TRUE;
            DavFcb->fFileAttributesChanged = TRUE;
            DavDbgTrace(DAV_TRACE_DETAIL,
                        ("MRxDAVPrecompleteUserModeCreateRequest: Encrypted file/dir was created %x %x %x\n",
                         DavFcb, Fcb, ((PFCB)Fcb)->Attributes));
        }

        if (capFcb->Attributes & FILE_ATTRIBUTE_DIRECTORY) {
            if (capFcb->Attributes & FILE_ATTRIBUTE_ENCRYPTED) {
                //
                // We update the registry if the directory has been encrypted
                // by someone else.
                //
                NtStatus = MRxDAVCreateEncryptedDirectoryKey(&DavFcb->FileNameInfo);
            } else {
                //
                // Query the registry to see if the directory should be encrypted.
                //
                NtStatus = MRxDAVQueryEncryptedDirectoryKey(&DavFcb->FileNameInfo);
                if (NtStatus == STATUS_SUCCESS) {
                    capFcb->Attributes |= FILE_ATTRIBUTE_ENCRYPTED;
                } else if (NtStatus == STATUS_OBJECT_NAME_NOT_FOUND) {
                    NtStatus = STATUS_SUCCESS;
                }
            }
        }

        DavDbgTrace(DAV_TRACE_DETAIL,
                    ("MRxDAVPrecompleteUserModeCreateRequest file info %x %x %x %x %x %x %ws\n",
                     capFcb->Attributes,
                     CreateResponse->BasicInformation.CreationTime.HighPart,
                     CreateResponse->BasicInformation.CreationTime.LowPart,
                     CreateResponse->StandardInformation.EndOfFile.LowPart,
                     DavFcb,
                     Fcb,
                     DavFcb->FileName));

    }

EXIT_THE_FUNCTION:

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Leaving MRxDAVPrecompleteUserModeCreateRequest with "
                 "NtStatus = %08lx.\n", PsGetCurrentThreadId(), NtStatus));
    
    return TRUE;
}


NTSTATUS
MRxDAVCreateContinuation(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE
    )
/*++

Routine Description:

    This is the continuation routine for the create operation.

Arguments:

    AsyncEngineContext - The Reflectors context.

    RxContext - The RDBSS context.
    
Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PWEBDAV_CONTEXT DavContext = (PWEBDAV_CONTEXT)AsyncEngineContext;
    RxCaptureFcb;
    PMRX_SRV_OPEN SrvOpen = RxContext->pRelevantSrvOpen;
    PWEBDAV_SRV_OPEN davSrvOpen = MRxDAVGetSrvOpenExtension(SrvOpen);
    PMRX_FCB Fcb = SrvOpen->pFcb;
    PWEBDAV_FCB DavFcb = MRxDAVGetFcbExtension(Fcb);
    PDAV_USERMODE_CREATE_RETURNED_FILEINFO CreateReturnedFileInfo = NULL;
    PNT_CREATE_PARAMETERS NtCreateParameters = NULL;
    HANDLE FileHandle = INVALID_HANDLE_VALUE;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatusBlock;
    UNICODE_STRING UnicodeFileName;
    PWCHAR NtFileName = NULL;
    BOOL isFileCached = FALSE, isVNRInitialized = FALSE, didIAllocateFcbResource = FALSE;
    PWEBDAV_V_NET_ROOT DavVNetRoot = NULL;
    ULONG Disposition = RxContext->Create.NtCreateParameters.Disposition;
    BOOLEAN CacheFound = FALSE;

    PAGED_CODE();

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Entering MRxDAVCreateContinuation!!!!\n",
                 PsGetCurrentThreadId()));

    DavDbgTrace(DAV_TRACE_CONTEXT, 
                ("%ld: MRxDAVCreateContinuation: "
                 "AsyncEngineContext: %08lx, RxContext: %08lx.\n", 
                 PsGetCurrentThreadId(), AsyncEngineContext, RxContext));
    
    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVCreateContinuation: Attempt to open: %wZ\n",
                 PsGetCurrentThreadId(), 
                 GET_ALREADY_PREFIXED_NAME(SrvOpen,capFcb)));

    NtCreateParameters = &(RxContext->Create.NtCreateParameters);

    if (MRxDAVIsFileNotFoundCached(RxContext)) {
        
        DavContext->AsyncEngineContext.FileNotExists = TRUE;

        if ( !( (Disposition==FILE_CREATE) || (Disposition==FILE_OPEN_IF) ||
                (Disposition==FILE_OVERWRITE_IF) || (Disposition==FILE_SUPERSEDE) ) ) {
            //
            // If file does not exist on the server and we're not going to
            // create it, no further operation is necessary.
            //
            DavDbgTrace(DAV_TRACE_DETAIL,
                        ("MRxDAVCreateContinuation file not found %wZ\n",GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(RxContext)));
            NtStatus = STATUS_OBJECT_NAME_NOT_FOUND;
            goto EXIT_THE_FUNCTION;
        }
    
    }
    
    DavVNetRoot = (PWEBDAV_V_NET_ROOT)RxContext->pRelevantSrvOpen->pVNetRoot->Context; 
    
    isFileCached = DavFcb->isFileCached;

    //
    // We need to initialize the resource that is used to synchronize the
    // "read-modify-write" sequence if its not been done already.
    //
    if (DavFcb->DavReadModifyWriteLock == NULL) {

        //
        // Allocate memory for the resource.
        //
        DavFcb->DavReadModifyWriteLock = RxAllocatePoolWithTag(NonPagedPool,
                                                               sizeof(ERESOURCE),
                                                               DAV_READWRITE_POOLTAG);
        if (DavFcb->DavReadModifyWriteLock == NULL) {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: MRxDAVCreateContinuation/RxAllocatePoolWithTag\n",
                         PsGetCurrentThreadId()));
            goto EXIT_THE_FUNCTION;
        }
    
        didIAllocateFcbResource = TRUE;

        //
        // Now that we have allocated memory, we need to initialize it.
        //
        ExInitializeResourceLite(DavFcb->DavReadModifyWriteLock);
    
    }

    //
    // If we have a V_NET_ROOT whose LogonID has not been initialized, we need
    // to go to the user mode to create an entry for the user, in case this
    // new V_NET_ROOT has different user credentials than the one that opened
    // this file. We need to do this even if the file is cached since the user
    // that opened the file could be different from the current user. Its 
    // possible for multiple V_NET_ROOTS to be associate with the same FCB since 
    // FCB is associated with a NET_ROOT.
    //
    isVNRInitialized = DavVNetRoot->LogonIDSet;
    
    //
    // Since we set the LogonId during the creation of the V_NET_ROOT, this
    // should always be TRUE.
    //
    ASSERT(isVNRInitialized == TRUE);

    //
    // We can look at the FCB and figure out if this file was already opened
    // and cached in the WinInet cache. If it was, then we already have the
    // local name of the cached file in the FCB. All we need to do is open
    // a handle to the file with the create options specified by the caller.
    //
    if ( !isFileCached || !isVNRInitialized ) {
        
        if ((NtCreateParameters->Disposition == FILE_CREATE) &&
            (NtCreateParameters->FileAttributes & FILE_ATTRIBUTE_SYSTEM) &&
            (NtCreateParameters->FileAttributes & FILE_ATTRIBUTE_ENCRYPTED)) {
            //
            // Remove the Encryption flag if creating a SYSTEM file.
            //
            NtCreateParameters->FileAttributes &= ~FILE_ATTRIBUTE_ENCRYPTED;
        }
        
        CreateReturnedFileInfo = RxAllocatePoolWithTag(PagedPool, 
                                                       sizeof(DAV_USERMODE_CREATE_RETURNED_FILEINFO),
                                                       DAV_FILEINFO_POOLTAG);
        if (CreateReturnedFileInfo == NULL) {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: MRxDAVCreateContinuation/RxAllocatePool: Error Val"
                         " = %08lx\n", PsGetCurrentThreadId(), NtStatus));
            goto EXIT_THE_FUNCTION;
        }

        RtlZeroMemory(CreateReturnedFileInfo, sizeof(DAV_USERMODE_CREATE_RETURNED_FILEINFO));
        DavContext->CreateReturnedFileInfo = CreateReturnedFileInfo;

        CacheFound = MRxDAVIsFileInfoCacheFound(RxContext,
                                                CreateReturnedFileInfo,
                                                &(NtStatus),
                                                NULL);

        if (CacheFound) {

            //
            // If it exists in the cache, we perform a few checks before 
            // succeeding the create.
            //

            //
            // If the FileAttributes had the READ_ONLY bit set, then these
            // cannot be TRUE.
            // 1. CreateDisposition cannot be FILE_OVERWRITE_IF or
            //    FILE_OVERWRITE or FILE_SUPERSEDE. 
            // 2. CreateDisposition cannot be FILE_DELETE_ON_CLOSE.
            // 3. DesiredAccess  cannot be GENERIC_ALL or GENERIC_WRITE or
            //    FILE_WRITE_DATA or FILE_APPEND_DATA.
            // This is because these intend to overwrite the existing file.
            //
            if ( (CreateReturnedFileInfo->BasicInformation.FileAttributes & FILE_ATTRIBUTE_READONLY) &&
                 ( (NtCreateParameters->Disposition == FILE_OVERWRITE)          ||
                   (NtCreateParameters->Disposition == FILE_OVERWRITE_IF)       ||
                   (NtCreateParameters->Disposition == FILE_SUPERSEDE)          ||
                   (NtCreateParameters->CreateOptions & (FILE_DELETE_ON_CLOSE)        ||
                   (NtCreateParameters->DesiredAccess & (GENERIC_ALL | GENERIC_WRITE | FILE_WRITE_DATA | FILE_APPEND_DATA)) ) ) ) {
                DavDbgTrace(DAV_TRACE_ERROR,
                            ("%ld: MRxDAVCreateContinuation: ReadOnly & ObjectMismatch\n",
                             PsGetCurrentThreadId()));
                NtStatus = STATUS_ACCESS_DENIED;
                goto EXIT_THE_FUNCTION;
            }

            //
            // We return failure if FILE_CREATE was specified since the file
            // already exists.
            //
            if (NtCreateParameters->Disposition == FILE_CREATE) {
                DavDbgTrace(DAV_TRACE_ERROR,
                            ("%ld: MRxDAVCreateContinuation: FILE_CREATE\n",
                             PsGetCurrentThreadId()));
                NtStatus = STATUS_OBJECT_NAME_COLLISION;
                goto EXIT_THE_FUNCTION;
            }

            //
            // If the file is a directory and the caller supplied 
            // FILE_NON_DIRECTORY_FILE as one of the CreateOptions or if the
            // file as a file and the CreateOptions has FILE_DIRECTORY_FILE
            // then we return STATUS_ACCESS_DENIED.
            //
            
            if ( (NtCreateParameters->CreateOptions & FILE_DIRECTORY_FILE) &&
                 !(CreateReturnedFileInfo->StandardInformation.Directory) )   {
                DavDbgTrace(DAV_TRACE_ERROR,
                            ("%ld: MRxDAVCreateContinuation: File & FILE_DIRECTORY_FILE\n",
                             PsGetCurrentThreadId()));
                NtStatus = STATUS_NOT_A_DIRECTORY;
                goto EXIT_THE_FUNCTION;
            }

            if ( (NtCreateParameters->CreateOptions & FILE_NON_DIRECTORY_FILE) &&
                 (CreateReturnedFileInfo->StandardInformation.Directory) )   {
                DavDbgTrace(DAV_TRACE_ERROR,
                            ("%ld: MRxDAVCreateContinuation: Directory & FILE_NON_DIRECTORY_FILE\n",
                             PsGetCurrentThreadId()));
                NtStatus = STATUS_FILE_IS_A_DIRECTORY;
                goto EXIT_THE_FUNCTION;
            }

            //
            // If the delete is for a directory and the path is of the form
            // \\server\share then we return STATUS_ACCESS_DENIED. This is
            // because we do not allow a client to delete a share on the server.
            // If the path is of the form \\server\share then the value of
            // SrvOpen->pAlreadyPrefixedName->Length is 0.
            //
            if ( (CreateReturnedFileInfo->StandardInformation.Directory) &&
                 (SrvOpen->pAlreadyPrefixedName->Length == 0) &&
                 ( (NtCreateParameters->CreateOptions & FILE_DELETE_ON_CLOSE) ||
                   (NtCreateParameters->DesiredAccess & DELETE) ) ) {
                DavDbgTrace(DAV_TRACE_ERROR,
                            ("%ld: MRxDAVCreateContinuation: ServerShareDelete\n",
                             PsGetCurrentThreadId()));
                NtStatus = STATUS_ACCESS_DENIED;
                goto EXIT_THE_FUNCTION;
            }

            if ((NtCreateParameters->DesiredAccess & DELETE ||
                 NtCreateParameters->CreateOptions & FILE_DELETE_ON_CLOSE) &&
                CreateReturnedFileInfo->BasicInformation.FileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
                //
                // If it is a open for directory deletion, we want to make sure
                // no files are under the directory before return success.
                //
                CacheFound = FALSE;
            } else {
                DavContext->AsyncEngineContext.FileInformationCached = TRUE;
            }
        
        }

        //
        // We short circuit the open in kernel under the following conditions.
        // 1. If the file is in the name cache and open is for a directory.
        // 2. The file is NOT encrypted. This is because when we short circuit
        //    the open, we do not create a local file and hence no local file
        //    handle and no underlyingdeviceobject. This is needed by some of
        //    the FSCTLs that are issued against the EFS files. Hence we skip
        //    short circuiting them.
        // 3. A file with desire access of delete or read attributes.
        //
        
        if (CacheFound &&
            ((CreateReturnedFileInfo->BasicInformation.FileAttributes & FILE_ATTRIBUTE_DIRECTORY) ||
             (NtCreateParameters->Disposition == FILE_OPEN) &&
             !(NtCreateParameters->DesiredAccess & ~(SYNCHRONIZE | DELETE | FILE_READ_ATTRIBUTES)) &&
             !(CreateReturnedFileInfo->BasicInformation.FileAttributes & FILE_ATTRIBUTE_ENCRYPTED))) {

            if (CreateReturnedFileInfo->BasicInformation.FileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
                DavFcb->isDirectory = TRUE;
            }

            //
            // If this Create was with FILE_DELETE_ON_CLOSE, we need to set this
            // information in the FCB since we'll need to DELETE this file on 
            // Close.
            //
            if (NtCreateParameters->CreateOptions & FILE_DELETE_ON_CLOSE) {
                DavFcb->DeleteOnClose = TRUE;
            }

            DavDbgTrace(DAV_TRACE_DETAIL,
                        ("%ld: MRxDAVCreateContinuation: Pseudo Open: %wZ\n",
                         PsGetCurrentThreadId(), 
                         GET_ALREADY_PREFIXED_NAME(SrvOpen,capFcb)));

        } else {

            UNICODE_STRING ParentDirName;
            SHORT i;
            FILE_BASIC_INFORMATION BasicInformation;
            PUNICODE_STRING FileName = GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(RxContext);
            
            DavDbgTrace(DAV_TRACE_DETAIL,
                        ("%ld: MRxDAVCreateContinuation: Usermode Open: %wZ\n",
                         PsGetCurrentThreadId(),
                         GET_ALREADY_PREFIXED_NAME(SrvOpen,capFcb)));

            if (FileName->Length > 0) {

                //
                // Try to get the parent directory information from cache so that we don't
                // have to query the server.
                //

                for ( i = ( (FileName->Length / sizeof(WCHAR)) - 1 ); i >= 0; i-- ) {
                    if (FileName->Buffer[i] == L'\\') {
                        break;
                    }
                }

                //
                // Only if we found a wack will i be > 0. If we did not find
                // a wack (==> i == -1), it means that the parent directory was
                // not specified in the path. Hence we do not perform the check
                // below.
                //
                if (i > 0) {

                    ParentDirName.Length = (i * sizeof(WCHAR));
                    ParentDirName.MaximumLength = (i * sizeof(WCHAR));
                    ParentDirName.Buffer = FileName->Buffer;
    
                    if (MRxDAVIsBasicFileInfoCacheFound(RxContext,&BasicInformation,&NtStatus,&ParentDirName)) {
                        
                        DavContext->AsyncEngineContext.ParentDirInfomationCached = TRUE;
                        
                        DavContext->AsyncEngineContext.ParentDirIsEncrypted = BooleanFlagOn(BasicInformation.FileAttributes,FILE_ATTRIBUTE_ENCRYPTED);
    
                        DavDbgTrace(DAV_TRACE_INFOCACHE,
                                   ("MRxDAVCreateContinuation parent dir found %d %wZ\n",
                                     DavContext->AsyncEngineContext.ParentDirIsEncrypted,
                                     &ParentDirName));
    
                    } else {
                        
                        NtStatus = MRxDAVGetFullParentDirectoryPath(RxContext, &ParentDirName);
                        if (NtStatus != STATUS_SUCCESS) {
                            goto EXIT_THE_FUNCTION;
                        }
    
                        if (ParentDirName.Buffer != NULL) {
                            NtStatus = MRxDAVQueryEncryptedDirectoryKey(&ParentDirName);
                            if (NtStatus == STATUS_SUCCESS) {
                                DavContext->AsyncEngineContext.ParentDirInfomationCached = TRUE;
                                DavContext->AsyncEngineContext.ParentDirIsEncrypted = TRUE;
                            }
                        }

                    }

                }

            }

            //
            // If the file is not in the name cache we have to send the request to the webclient
            //
            NtStatus = UMRxSubmitAsyncEngUserModeRequest(
                                             UMRX_ASYNCENGINE_ARGUMENTS,
                                             MRxDAVFormatUserModeCreateRequest,
                                             MRxDAVPrecompleteUserModeCreateRequest
                                             );

            ASSERT(NtStatus != STATUS_PENDING); 

            switch (NtStatus) {
            case  STATUS_SUCCESS:
                MRxDAVInvalidateFileNotFoundCache(RxContext);
                MRxDAVCreateFileInfoCache(RxContext,CreateReturnedFileInfo,STATUS_SUCCESS);
                break;

            case STATUS_OBJECT_NAME_NOT_FOUND:
                MRxDAVCacheFileNotFound(RxContext);
                MRxDAVInvalidateFileInfoCache(RxContext);
                break;

            default:
                //
                // Invalid the name based file not found cache if other error
                // happens.
                //
                MRxDAVInvalidateFileInfoCache(RxContext);
                MRxDAVInvalidateFileNotFoundCache(RxContext);
            }
        
        }
    
    } else {

        ULONG SizeInBytes;
        ACCESS_MASK DesiredAccess = 0;

        //
        // If the FileAttributes had the READ_ONLY bit set, then these
        // cannot be TRUE.
        // 1. CreateDisposition cannot be FILE_OVERWRITE_IF or
        //    FILE_OVERWRITE or FILE_SUPERSEDE. 
        // 2. CreateDisposition cannot be FILE_DELETE_ON_CLOSE.
        // 3. DesiredAccess  cannot be GENERIC_ALL or GENERIC_WRITE or
        //    FILE_WRITE_DATA or FILE_APPEND_DATA.
        // This is because these intend to overwrite the existing file.
        //
        if ( (Fcb->Attributes & FILE_ATTRIBUTE_READONLY) &&
             ( (NtCreateParameters->Disposition == FILE_OVERWRITE)          ||
               (NtCreateParameters->Disposition == FILE_OVERWRITE_IF)       ||
               (NtCreateParameters->Disposition == FILE_SUPERSEDE)          ||
               (NtCreateParameters->CreateOptions & (FILE_DELETE_ON_CLOSE)        ||
               (NtCreateParameters->DesiredAccess & (GENERIC_ALL | GENERIC_WRITE | FILE_WRITE_DATA | FILE_APPEND_DATA)) ) ) ) {
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: MRxDAVCreateContinuation(1): ReadOnly & ObjectMismatch\n",
                         PsGetCurrentThreadId()));
            NtStatus = STATUS_ACCESS_DENIED;
            goto EXIT_THE_FUNCTION;
        }

        //
        // We return failure if FILE_CREATE was specified since the file
        // already exists.
        //
        if (NtCreateParameters->Disposition == FILE_CREATE) {
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: MRxDAVCreateContinuation(1): FILE_CREATE\n",
                         PsGetCurrentThreadId()));
            NtStatus = STATUS_OBJECT_NAME_COLLISION;
            goto EXIT_THE_FUNCTION;
        }

        //
        // If the file is a directory and the caller supplied 
        // FILE_NON_DIRECTORY_FILE as one of the CreateOptions or if the
        // file as a file and the CreateOptions has FILE_DIRECTORY_FILE
        // then we return STATUS_ACCESS_DENIED.
        //

        if ( (NtCreateParameters->CreateOptions & FILE_DIRECTORY_FILE) &&
             !(DavFcb->isDirectory) )   {
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: MRxDAVCreateContinuation(1): File & FILE_DIRECTORY_FILE\n",
                         PsGetCurrentThreadId()));
            NtStatus = STATUS_NOT_A_DIRECTORY;
            goto EXIT_THE_FUNCTION;
        }

        if ( (NtCreateParameters->CreateOptions & FILE_NON_DIRECTORY_FILE) &&
             (DavFcb->isDirectory) )   {
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: MRxDAVCreateContinuation(1): Directory & FILE_NON_DIRECTORY_FILE\n",
                         PsGetCurrentThreadId()));
            NtStatus = STATUS_FILE_IS_A_DIRECTORY;
            goto EXIT_THE_FUNCTION;
        }

        //
        // If the delete is for a directory and the path is of the form
        // \\server\share then we return STATUS_ACCESS_DENIED. This is
        // because we do not allow a client to delete a share on the server.
        // If the path is of the form \\server\share then the value of
        // SrvOpen->pAlreadyPrefixedName->Length is 0.
        //
        if ( (DavFcb->isDirectory) &&
             (SrvOpen->pAlreadyPrefixedName->Length == 0) &&
             ( (NtCreateParameters->CreateOptions & FILE_DELETE_ON_CLOSE) ||
               (NtCreateParameters->DesiredAccess & DELETE) ) ) {
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: MRxDAVCreateContinuation(1): ServerShareDelete\n",
                         PsGetCurrentThreadId()));
            NtStatus = STATUS_ACCESS_DENIED;
            goto EXIT_THE_FUNCTION;
        }

        //
        // We need to do the create only if its a file. If we are talking about 
        // a directory, then no create is needed.
        //
        if ( !DavFcb->isDirectory ) {

            //
            // We have a cached copy of the file which hasn't been closed. All we
            // need to do is call ZwCreateFile on it.
            //

            //
            // Create an NT path name for the cached file. This is used in the 
            // ZwCreateFile call below. If c:\foo\bar is the DOA path name,
            // the NT path name is \??\c:\foo\bar. 
            //

            SizeInBytes = ( MAX_PATH + wcslen(L"\\??\\") + 1 ) * sizeof(WCHAR);
            NtFileName = RxAllocatePoolWithTag(PagedPool, SizeInBytes, DAV_FILENAME_POOLTAG);
            if (NtFileName == NULL) {
                NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                DavDbgTrace(DAV_TRACE_ERROR,
                            ("%ld: MRxDAVCreateContinuation/RxAllocatePool: Error Val"
                             " = %08lx\n", PsGetCurrentThreadId(), NtStatus));
                goto EXIT_THE_FUNCTION;
            }

            RtlZeroMemory(NtFileName, SizeInBytes);

            wcscpy( NtFileName, L"\\??\\" );
            wcscpy( &(NtFileName[4]), DavFcb->FileName );

            DavDbgTrace(DAV_TRACE_DETAIL,
                        ("%ld: MRxDAVCreateContinuation: NtFileName = %ws\n",
                         PsGetCurrentThreadId(), NtFileName));

            RtlInitUnicodeString( &(UnicodeFileName), NtFileName );

            //
            // IMPROTANT!!!
            // We use OBJ_KERNEL_HANDLE below for the following reason. While
            // firing up a word file from explorer, I noticed that the create
            // below was happening in one process (A) and the close for the handle
            // which is stored in the SrvOpen extension came down in another 
            // process (B). This could happen if the process that is closing the 
            // handle (B) duplicated the handle created by A. By using OBJ_KERNEL_HANDLE
            // the handle can be closed by any process.
            //

            InitializeObjectAttributes(&ObjectAttributes,
                                       &UnicodeFileName,
                                       (OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE),
                                       0,
                                       NULL);

            DavDbgTrace(DAV_TRACE_DETAIL,
                        ("%ld: MRxDAVCreateContinuation: DesiredAccess = %08lx,"
                         " FileAttributes = %08lx, ShareAccess = %d, Disposition"
                         " = %d, CreateOptions = %08lx\n",
                         PsGetCurrentThreadId(),
                         NtCreateParameters->DesiredAccess,
                         NtCreateParameters->FileAttributes,
                         NtCreateParameters->ShareAccess,
                         NtCreateParameters->Disposition,
                         NtCreateParameters->CreateOptions));

            //
            // We use FILE_SHARE_VALID_FLAGS for share access because RDBSS 
            // checks this for us. Moreover, we delay the close after the final 
            // close happens and this could cause problems. Consider the scenario.
            // 1. Open with NO share access.
            // 2. We create a local handle with this share access.
            // 3. The app closes the handle. We delay the close and keep the local
            //    handle.
            // 4. Another open comes with any share access. This will be 
            //    conflicting share access since the first one was done with no
            //    share access. This should succeed since the previous open has 
            //    been closed from the app and the I/O systems point of view.
            // 5. It will not if we have created the local handle with the share
            //    access which came with the first open.
            // Therefore we need to pass FILE_SHARE_VALID_FLAGS while creating
            // the local handle.
            //

            //
            // We have FILE_NO_INTERMEDIATE_BUFFERING ORed with the CreateOptions
            // the user specified, becuase we don't want the underlying file
            // system to create another cache map. This way all the I/O that comes
            // to us will directly go to the disk. BUG 128843 in the Windows RAID
            // database explains some deadlock scenarios that could happen with 
            // PagingIo if we don't do this. Also since we supply the 
            // FILE_NO_INTERMEDIATE_BUFFERING option we filter out the
            // FILE_APPEND_DATA from the DesiredAccess flags since the underlying
            // filesystem expects this.
            //

            //
            // We also always create the file with DesiredAccess ORed with
            // FILE_WRITE_DATA if either FILE_READ_DATA or FILE_EXECUTE was
            // specified because there can be situations where we get write
            // IRPs on a FILE_OBJECT which was not opened with Write Access
            // and was only opened with FILE_READ_DATA or FILE_EXECUTE. This
            // is BUG 284557. To get around the problem, we do this.
            //

            DesiredAccess = (NtCreateParameters->DesiredAccess & ~(FILE_APPEND_DATA));
            if ( DesiredAccess & (FILE_READ_DATA | FILE_EXECUTE) ) {
                DesiredAccess |= (FILE_WRITE_DATA);
            }

            NtStatus = ZwCreateFile(&(FileHandle),
                                    DesiredAccess,
                                    &(ObjectAttributes),
                                    &(IoStatusBlock),
                                    &(NtCreateParameters->AllocationSize),
                                    NtCreateParameters->FileAttributes,
                                    FILE_SHARE_VALID_FLAGS,
                                    NtCreateParameters->Disposition,
                                    (NtCreateParameters->CreateOptions | FILE_NO_INTERMEDIATE_BUFFERING),
                                    RxContext->Create.EaBuffer,
                                    RxContext->Create.EaLength);
            if (NtStatus != STATUS_SUCCESS) {
                DavDbgTrace(DAV_TRACE_ERROR,
                            ("%ld: ERROR: MRxDAVCreateContinuation/ZwCreateFile: "
                             "Error Val = %08lx\n", PsGetCurrentThreadId(), NtStatus));
                goto EXIT_THE_FUNCTION;
            }

            DavDbgTrace(DAV_TRACE_DETAIL,
                        ("%ld: MRxDAVCreateContinuation: FileHandle = %08lx, "
                         "Process = %08lx, SrvOpen = %08lx, davSrvOpen = %08lx\n",
                         PsGetCurrentThreadId(), FileHandle, PsGetCurrentProcess(),
                         SrvOpen, davSrvOpen));

            //
            // On the final close we check this to figure out where the close of the
            // handle should occur.
            //
            davSrvOpen->createdInKernel = TRUE;

            NtStatus = ObReferenceObjectByHandle(
                                  FileHandle,
                                  0L,
                                  NULL,
                                  KernelMode,
                                  (PVOID *)&(davSrvOpen->UnderlyingFileObject),
                                  NULL
                                  );
            if (NtStatus == STATUS_SUCCESS) {

                DavDbgTrace(DAV_TRACE_DETAIL,
                            ("%ld: MRxDAVCreateContinuation: UFO(2) = %08lx\n",
                             PsGetCurrentThreadId(), davSrvOpen->UnderlyingFileObject));

                davSrvOpen->UnderlyingHandle = FileHandle;

                davSrvOpen->UserModeKey = (PVOID)FileHandle;

                davSrvOpen->UnderlyingDeviceObject = 
                    IoGetRelatedDeviceObject(davSrvOpen->UnderlyingFileObject);

            } else {

                DavDbgTrace(DAV_TRACE_ERROR,
                            ("%ld: ERROR:  MRxDAVCreateContinuation/"
                             "ObReferenceObjectByHandle: NtStatus = %08lx.\n", 
                             PsGetCurrentThreadId(), NtStatus));

                ZwClose(FileHandle);

            }

        }
    
    }
    
    ASSERT(RxIsFcbAcquiredExclusive(capFcb));
    
    if ( NtStatus == STATUS_SUCCESS && ( !isFileCached || !isVNRInitialized ) ) {
        
        RX_FILE_TYPE StorageType = 0;
        
        PFILE_BASIC_INFORMATION pBasicInformation = 
                                   &(CreateReturnedFileInfo->BasicInformation);
        
        PFILE_STANDARD_INFORMATION pStandardInformation = 
                                &(CreateReturnedFileInfo->StandardInformation);
        
        FCB_INIT_PACKET InitPacket;

        // StorageType = RxInferFileType(RxContext);

        DavDbgTrace(DAV_TRACE_DETAIL,
                    ("%ld: MRxDAVCreateContinuation: Storagetype = %08lx\n", 
                     PsGetCurrentThreadId(), StorageType));

        //
        // If we have never obtained the characteristics, we have to get them.
        //
        if ((capFcb->OpenCount == 0)
            || !FlagOn(capFcb->FcbState, FCB_STATE_TIME_AND_SIZE_ALREADY_SET)) {

            if (StorageType == 0) {
                StorageType = pStandardInformation->Directory?
                                            (FileTypeDirectory):(FileTypeFile);
                DavDbgTrace(DAV_TRACE_DETAIL,
                            ("%ld: MRxDAVCreateContinuation: "
                             "ChangedStoragetype %08lx\n", 
                             PsGetCurrentThreadId(), StorageType));
            }

            DavDbgTrace(DAV_TRACE_DETAIL,
                        ("%ld: MRxDAVCreateContinuation: Name: %wZ, FileType: %d\n",
                         PsGetCurrentThreadId(), 
                         GET_ALREADY_PREFIXED_NAME(SrvOpen,capFcb), StorageType));
            
            DavDbgTrace(DAV_TRACE_DETAIL,
                        ("%ld: MRxDAVCreateContinuation: FileSize %08lx\n",
                         PsGetCurrentThreadId(), 
                         pStandardInformation->EndOfFile.LowPart));

            RxFinishFcbInitialization(capFcb,
                                      RDBSS_STORAGE_NTC(StorageType),
                                      RxFormInitPacket(
                                         InitPacket,
                                         &pBasicInformation->FileAttributes,
                                         &pStandardInformation->NumberOfLinks,
                                         &pBasicInformation->CreationTime,
                                         &pBasicInformation->LastAccessTime,
                                         &pBasicInformation->LastWriteTime,
                                         &pBasicInformation->ChangeTime,
                                         &pStandardInformation->AllocationSize,
                                         &pStandardInformation->EndOfFile,
                                         &pStandardInformation->EndOfFile));

        }

    }

    if (NtStatus == STATUS_SUCCESS) {

        RxContext->pFobx = RxCreateNetFobx(RxContext, SrvOpen);
        if ( !RxContext->pFobx ) {
            
            NTSTATUS PostedCloseStatus;
            
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: MRxDAVCreateContinuation/RxCreateNetFobx.\n",
                         PsGetCurrentThreadId()));

            if ( !davSrvOpen->createdInKernel ) {
            
                PostedCloseStatus = UMRxSubmitAsyncEngUserModeRequest(
                                          UMRX_ASYNCENGINE_ARGUMENTS,
                                          MRxDAVFormatUserModeCloseRequest,
                                          MRxDAVPrecompleteUserModeCloseRequest
                                          );
            } else {

                ZwClose(davSrvOpen->UnderlyingHandle);

                davSrvOpen->UnderlyingHandle = davSrvOpen->UserModeKey = NULL;

            }
            
            ObDereferenceObject(davSrvOpen->UnderlyingFileObject);
            
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        
        } else {
            
            //
            // Note, collapsing is enabled on fcb but not on any srvopen.
            //
            SrvOpen->BufferingFlags |= (FCB_STATE_WRITECACHING_ENABLED     |
                                        FCB_STATE_FILESIZECACHEING_ENABLED  |
                                        FCB_STATE_FILETIMECACHEING_ENABLED  |
                                        FCB_STATE_WRITEBUFFERING_ENABLED    |
                                        FCB_STATE_LOCK_BUFFERING_ENABLED    |
                                        FCB_STATE_READBUFFERING_ENABLED     |
                                        FCB_STATE_READCACHING_ENABLED);
        }
    
    }

EXIT_THE_FUNCTION:

    if (CreateReturnedFileInfo != NULL) {
        RxFreePool(CreateReturnedFileInfo);
    }

    if (NtFileName != NULL) {
        RxFreePool(NtFileName);
    }

    //
    // If we allocated the FCB resource and the create failed, we need to free 
    // up the resource.
    //
    if (NtStatus != STATUS_SUCCESS && didIAllocateFcbResource) {
        ASSERT(DavFcb->DavReadModifyWriteLock != NULL);
        ExDeleteResourceLite(DavFcb->DavReadModifyWriteLock);
        RxFreePool(DavFcb->DavReadModifyWriteLock);
        DavFcb->DavReadModifyWriteLock = NULL;
    }

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Leaving MRxDAVCreateContinuation with NtStatus = %08lx.\n", 
                 PsGetCurrentThreadId(), NtStatus));

#ifdef DAV_DEBUG_READ_WRITE_CLOSE_PATH
    if (NtStatus == STATUS_SUCCESS && (SrvOpen->pAlreadyPrefixedName->Length > 0) ) {
        DavAddEntryToGlobalList(SrvOpen->pAlreadyPrefixedName);
    }
#endif // DAV_DEBUG_READ_WRITE_CLOSE_PATH

    return(NtStatus);
}


NTSTATUS
MRxDAVCollapseOpen(
    IN OUT PRX_CONTEXT RxContext
    )
/*++

Routine Description:

   This routine collapses a open locally

Arguments:

    RxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    RxCaptureFcb;
    PMRX_SRV_OPEN SrvOpen = RxContext->pRelevantSrvOpen;
    PMRX_SRV_CALL SrvCall = RxContext->Create.pSrvCall;
    PMRX_NET_ROOT NetRoot = capFcb->pNetRoot;

    PAGED_CODE();

    DavDbgTrace(DAV_TRACE_DETAIL, 
                ("%ld: Entering MRxDAVCollapseOpen!!!!\n",
                 PsGetCurrentThreadId()));

    //
    // We should never come here since we never collapse the Open.
    //
    ASSERT(FALSE);
    
    RxContext->pFobx = (PMRX_FOBX) RxCreateNetFobx(RxContext, SrvOpen);

    if (RxContext->pFobx != NULL) {
       ASSERT(RxIsFcbAcquiredExclusive(capFcb));
       RxContext->pFobx->OffsetOfNextEaToReturn = 1;
    } else {
       Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return Status;
}


NTSTATUS
MRxDAVComputeNewBufferingState(
    IN OUT PMRX_SRV_OPEN pMRxSrvOpen,
    IN PVOID pMRxContext,
    OUT PULONG pNewBufferingState
    )
/*++

Routine Description:

   This routine computes the appropriate RDBSS buffering state flags

Arguments:

   pMRxSrvOpen - the MRX SRV_OPEN extension

   pMRxContext - the context passed to RDBSS at Oplock indication time

   pNewBufferingState - the place holder for the new buffering state

Return Value:


Notes:

--*/
{
    ULONG NewBufferingState;
    PWEBDAV_SRV_OPEN davSrvOpen = MRxDAVGetSrvOpenExtension(pMRxSrvOpen);

    PAGED_CODE();

    ASSERT(pNewBufferingState != NULL);

    NewBufferingState = 0;

    pMRxSrvOpen->BufferingFlags = NewBufferingState;
    *pNewBufferingState = pMRxSrvOpen->BufferingFlags;

    return STATUS_SUCCESS;
}


NTSTATUS
MRxDAVTruncate(
    IN PRX_CONTEXT pRxContext
    )
/*++

Routine Description:

   This routine truncates the contents of a file system object

Arguments:

    pRxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    DavDbgTrace(DAV_TRACE_DETAIL, 
                ("%ld: Entering MRxDAVTruncate.\n", PsGetCurrentThreadId()));

    PAGED_CODE();

    return STATUS_NOT_IMPLEMENTED;
}


NTSTATUS
MRxDAVForcedClose(
    IN PMRX_SRV_OPEN pSrvOpen
    )
/*++

Routine Description:

   This routine closes a file system object

Arguments:

    pSrvOpen - the instance to be closed

Return Value:

    RXSTATUS - The return status for the operation

Notes:

--*/
{
    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Entering MRxDAVForcedClose.\n", PsGetCurrentThreadId()));

    PAGED_CODE();

    return STATUS_NOT_IMPLEMENTED;
}


NTSTATUS
MRxDAVCloseSrvOpen(
    IN PRX_CONTEXT RxContext
    )
/*++

Routine Description:

   This routine handles requests to close the srvopen data structure.
   
Arguments:

    RxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    PAGED_CODE();

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Entering MRxDAVCloseSrvOpen!!!!\n",
                 PsGetCurrentThreadId()));

    DavDbgTrace(DAV_TRACE_CONTEXT,
                ("%ld: MRxDAVCloseSrvOpen: RxContext: %08lx\n", 
                 PsGetCurrentThreadId(), RxContext));

    NtStatus = UMRxAsyncEngOuterWrapper(RxContext,
                                        SIZEOF_DAV_SPECIFIC_CONTEXT,
                                        MRxDAVFormatTheDAVContext,
                                        DAV_MINIRDR_ENTRY_FROM_CLOSESRVOPEN,
                                        MRxDAVCloseSrvOpenContinuation,
                                        "MRxDAVCloseSrvOpen");
    
    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Leaving MRxDAVCloseSrvOpen with NtStatus = %08lx\n", 
                 PsGetCurrentThreadId(), NtStatus));

    return(NtStatus);
}


NTSTATUS
MRxDAVFormatUserModeCloseRequest(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE,
    PUMRX_USERMODE_WORKITEM_HEADER WorkItemHeader,
    ULONG WorkItemLength,
    PULONG_PTR ReturnedLength
    )
/*++

Routine Description:

    This routine formats the arguments of the close request which is being 
    sent to the user mode for processing.

Arguments:

    RxContext - The RDBSS context.
    
    AsyncEngineContext - The reflctor's context.
    
    WorkItem - The work item buffer.
    
    WorkItemLength - The length of the work item buffer.
    
    ReturnedLength - 

Return Value:

    STATUS_SUCCESS.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PMRX_SRV_CALL SrvCall = NULL;
    PWEBDAV_SRV_CALL DavSrvCall = NULL;
    PDAV_USERMODE_WORKITEM WorkItem = (PDAV_USERMODE_WORKITEM)WorkItemHeader;
    PMRX_SRV_OPEN SrvOpen = RxContext->pRelevantSrvOpen;
    PWEBDAV_SRV_OPEN davSrvOpen = MRxDAVGetSrvOpenExtension(SrvOpen);
    PMRX_FCB Fcb = SrvOpen->pFcb;
    PWEBDAV_FCB DavFcb = MRxDAVGetFcbExtension(Fcb);
    PDAV_USERMODE_CLOSE_REQUEST CloseRequest = &(WorkItem->CloseRequest);
    PWCHAR ServerName = NULL, PathName = NULL;
    ULONG ServerNameLengthInBytes = 0, PathNameLengthInBytes = 0;
    PWEBDAV_V_NET_ROOT DavVNetRoot = NULL;
    PSECURITY_CLIENT_CONTEXT SecurityClientContext = NULL;
    PMRX_NET_ROOT NetRoot = NULL;
    PWCHAR NetRootName = NULL, JustTheNetRootName = NULL;
    ULONG NetRootNameLengthInBytes = 0, NetRootNameLengthInWChars = 0;
    LONG FileWasModified = 0;
    RxCaptureFobx;

    PAGED_CODE();

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Entering MRxDAVFormatUserModeCloseRequest!!!!\n",
                 PsGetCurrentThreadId()));

    DavDbgTrace(DAV_TRACE_CONTEXT,
                ("%ld: MRxDAVFormatUserModeCloseRequest: "
                 "AsyncEngineContext = %08lx, RxContext = %08lx.\n",
                 PsGetCurrentThreadId(), AsyncEngineContext, RxContext));
 
    IF_DEBUG {
        ASSERT (capFobx != NULL);
        ASSERT (capFobx->pSrvOpen == RxContext->pRelevantSrvOpen);
    }

    WorkItem->WorkItemType = UserModeClose;

    SrvCall = SrvOpen->pVNetRoot->pNetRoot->pSrvCall;
    ASSERT(SrvCall != NULL);

    DavSrvCall = MRxDAVGetSrvCallExtension(SrvCall);
    ASSERT(DavSrvCall != NULL);

    //
    // Copy the local file name.
    //
    wcscpy(CloseRequest->FileName, DavFcb->FileName);
    wcscpy(CloseRequest->Url, DavFcb->Url);

    //
    // See if the underlying local file has been modified.
    //
    FileWasModified = InterlockedCompareExchange(&(DavFcb->FileWasModified), 0, 0);

    //
    // If the FileWasModified field in the DavFcb is not equal to zero, we need
    // to clear the FileWasModified field in the DavFcb since we are going to
    // PUT the data on the server. We also set FileModifiedBitReset in the 
    // DavFcb structure to TRUE. If the PUT fails in the usermode we reset the
    // FileWasModified in the DavFcb to TRUE (in the PreComplete function).
    //
    if (FileWasModified != 0) {
        InterlockedExchange(&(DavFcb->FileWasModified), 0);
        DavFcb->FileModifiedBitReset = TRUE;
    }

    //
    // We need to tell the user mode process about the following file 
    // information. 
    //
    CloseRequest->DeleteOnClose = DavFcb->DeleteOnClose;
    CloseRequest->FileWasModified = (BOOL)FileWasModified;

    //
    // If this file was modified and DeleteOnClose is not set, we need to 
    // set RaiseHardErrorIfCloseFails to TRUE. On the precomplete close call,
    // if the usermode operation failed and RaiseHardErrorIfCloseFails is TRUE,
    // we call IoRaiseInformationalHardError to notify the user (the calls pops
    // up a box) that the data could have been lost.
    //
    if ( (FileWasModified != 0) && !(DavFcb->DeleteOnClose) ) {
        davSrvOpen->RaiseHardErrorIfCloseFails = TRUE;
    } else {
        davSrvOpen->RaiseHardErrorIfCloseFails = FALSE;
    }

    if (!CloseRequest->DeleteOnClose) {

        //
        // If the file is modified, just propatch again. This is to get around
        // the docfile issue where on a PUT, the properties get cleaned up.
        //

        if (FileWasModified != 0) {

            LARGE_INTEGER CurrentTime;

            CloseRequest->fCreationTimeChanged = (((PFCB)Fcb)->CreationTime.QuadPart != 0);

            CloseRequest->fLastAccessTimeChanged = (((PFCB)Fcb)->LastAccessTime.QuadPart != 0);

            CloseRequest->fLastModifiedTimeChanged = (((PFCB)Fcb)->LastWriteTime.QuadPart != 0);

            //
            // We query the Current system time and make that the LastWrite
            // and the LastAccess time of the file. Even though RxCommonCleanup
            // modifies these time values, it only modifies them on FileObjects
            // which have FO_FILE_MODIFIED set. Consider the case where h1 and
            // h2 are two handles created. A write is issued on h2 setting
            // FO_FILE_MODIFIED in its FileObject. CloseHandle(h1) leads to the
            // file being PUT on the server since DavFcb->FileWasModified is
            // TRUE (write on h2 caused this). But since the FileObject of
            // h1 doesn't have FO_FILE_MODIFIED set, in the RxCommonCleanup
            // code the LastWrite and LastAccess time values of this FCB are
            // not modifed causing us to PROPPATCH the old values on the server.
            // To avoid this we query the current time value and set it
            // ourselves in the FCB. If "DavFcb->DoNotTakeTheCurrentTimeAsLMT"
            // is TRUE then we don't do this since the application explicitly
            // set the LastModifiedTime after all the changes were done.
            //
            if (DavFcb->DoNotTakeTheCurrentTimeAsLMT == FALSE) {
                KeQuerySystemTime( &(CurrentTime) );
                ((PFCB)Fcb)->LastAccessTime.QuadPart = CurrentTime.QuadPart;
                ((PFCB)Fcb)->LastWriteTime.QuadPart = CurrentTime.QuadPart;
            }

            //
            // If FILE_ATTRIBUTE_NORMAL was the only attribute set on the file
            // and the file was modified, then we should replace this with the
            // FILE_ATTRIBUTE_ARCHIVE attribute.
            //
            if ( ((PFCB)Fcb)->Attributes == FILE_ATTRIBUTE_NORMAL ) {
                DavDbgTrace(DAV_TRACE_DETAIL,
                            ("ld: ERROR: MRxDAVFormatUserModeCloseRequest: "
                             "FILE_ATTRIBUTE_NORMAL ===> FILE_ATTRIBUTE_ARCHIVE\n",
                             PsGetCurrentThreadId()));
                ((PFCB)Fcb)->Attributes = FILE_ATTRIBUTE_ARCHIVE;
                DavFcb->fFileAttributesChanged = TRUE;
            }

            if ((((PFCB)Fcb)->Attributes != 0) || DavFcb->fFileAttributesChanged) {
                CloseRequest->fFileAttributesChanged = TRUE;
            }

        } else {

            //
            // If any of the following times have changed, then we need to PROPPATCH
            // them to the server.
            //
            CloseRequest->fCreationTimeChanged = DavFcb->fCreationTimeChanged;
            CloseRequest->fLastAccessTimeChanged = DavFcb->fLastAccessTimeChanged;
            CloseRequest->fLastModifiedTimeChanged = DavFcb->fLastModifiedTimeChanged;
            CloseRequest->fFileAttributesChanged = DavFcb->fFileAttributesChanged;

        }

    }

    //
    // Copy the various time values.
    //
    CloseRequest->CreationTime = ((PFCB)Fcb)->CreationTime;
    CloseRequest->LastAccessTime = ((PFCB)Fcb)->LastAccessTime;
    CloseRequest->LastModifiedTime = ((PFCB)Fcb)->LastWriteTime;
    CloseRequest->dwFileAttributes = ((PFCB)Fcb)->Attributes;
    CloseRequest->FileSize = Fcb->Header.FileSize.LowPart;

    //  
    // Copy the ServerName.
    //
    ServerNameLengthInBytes = ( SrvCall->pSrvCallName->Length + sizeof(WCHAR) );
    ServerName = (PWCHAR) UMRxAllocateSecondaryBuffer(AsyncEngineContext,
                                                      ServerNameLengthInBytes);
    if (ServerName == NULL) {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("ld: ERROR: MRxDAVFormatUserModeCloseRequest/"
                     "UMRxAllocateSecondaryBuffer. NtStatus = %08lx.\n",
                     PsGetCurrentThreadId(), NtStatus));
        goto EXIT_THE_FUNCTION;
    }
    
    RtlCopyBytes(ServerName, 
                 SrvCall->pSrvCallName->Buffer, 
                 SrvCall->pSrvCallName->Length);

    ServerName[( ( (ServerNameLengthInBytes) / sizeof(WCHAR) ) - 1 )] = L'\0';
    CloseRequest->ServerName = ServerName;
    
    //
    // Copy the ServerID.
    //
    CloseRequest->ServerID = DavSrvCall->ServerID;
    
    NetRoot = SrvOpen->pFcb->pNetRoot;

    //
    // The NetRootName (pNetRootName) includes the ServerName. Hence to get the
    // NetRootNameLengthInBytes, we do the following.
    //
    NetRootNameLengthInBytes = (NetRoot->pNetRootName->Length - NetRoot->pSrvCall->pSrvCallName->Length);
    NetRootNameLengthInWChars = ( NetRootNameLengthInBytes / sizeof(WCHAR) );

    NetRootName = &(NetRoot->pNetRootName->Buffer[1]);
    JustTheNetRootName = wcschr(NetRootName, L'\\');
    
    //
    // Copy the PathName of the Directory. If the file was renamed, we need to
    // copy the new path name which is stored in the DavFcb and not the 
    // AlreadyPrefixedName of the SrvOpen.
    //
    if (DavFcb->FileWasRenamed) {
        PathNameLengthInBytes = ( NetRootNameLengthInBytes + 
                                  DavFcb->NewFileNameLength + 
                                  sizeof(WCHAR) );
    } else {
        PathNameLengthInBytes = ( NetRootNameLengthInBytes + 
                                  SrvOpen->pAlreadyPrefixedName->Length + 
                                  sizeof(WCHAR) );
    }
    
    PathName = (PWCHAR) UMRxAllocateSecondaryBuffer(AsyncEngineContext,
                                                    PathNameLengthInBytes);
    if (PathName == NULL) {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("ld: ERROR: MRxDAVFormatUserModeCloseRequest/"
                     "UMRxAllocateSecondaryBuffer. NtStatus = %08lx.\n",
                     PsGetCurrentThreadId(), NtStatus));
        goto EXIT_THE_FUNCTION;
    }

    RtlZeroMemory(PathName, PathNameLengthInBytes);

    RtlCopyBytes(PathName, JustTheNetRootName, NetRootNameLengthInBytes);
    
    if (DavFcb->FileWasRenamed) {
        RtlCopyBytes((PathName + NetRootNameLengthInWChars),
                     DavFcb->NewFileName, 
                     DavFcb->NewFileNameLength);
        DavDbgTrace(DAV_TRACE_DETAIL,
                    ("ld: MRxDAVFormatUserModeCloseRequest. ReNamed!!! NewFileName = %ws\n",
                     PsGetCurrentThreadId(), PathName));
    } else {
        RtlCopyBytes((PathName + NetRootNameLengthInWChars),
                     SrvOpen->pAlreadyPrefixedName->Buffer,
                     SrvOpen->pAlreadyPrefixedName->Length);
    }
    
    PathName[( ( (PathNameLengthInBytes) / sizeof(WCHAR) ) - 1 )] = L'\0';
    CloseRequest->PathName = PathName;
    
    DavDbgTrace(DAV_TRACE_DETAIL,
                ("ld: MRxDAVFormatUserModeCloseRequest. PathName = %ws\n",
                 PsGetCurrentThreadId(), PathName));
    
    //
    // Set the LogonID stored in the Dav V_NET_ROOT. This value is used in the
    // user mode.
    //
    DavVNetRoot = (PWEBDAV_V_NET_ROOT)SrvOpen->pVNetRoot->Context;
    ASSERT(DavVNetRoot != NULL);
    CloseRequest->LogonID.LowPart  = DavVNetRoot->LogonID.LowPart;
    CloseRequest->LogonID.HighPart = DavVNetRoot->LogonID.HighPart;

    if ( !DavFcb->isDirectory ) {
        CloseRequest->isDirectory = FALSE;
        if ( !davSrvOpen->createdInKernel ) {
            CloseRequest->Handle = davSrvOpen->UnderlyingHandle;
            CloseRequest->UserModeKey = davSrvOpen->UserModeKey;
        } else {
            CloseRequest->Handle = NULL;
            CloseRequest->UserModeKey = NULL;
            CloseRequest->createdInKernel = davSrvOpen->createdInKernel; // TRUE
        }
    } else {
        CloseRequest->isDirectory = TRUE;
    }

    //
    // If an OpaqueLockToken is associated with this SrvOpen (which means that
    // the file was LOCKed on the server) then we need to add this token to
    // the requests (PUT etc.) we send to the server.
    //
    if (davSrvOpen->OpaqueLockToken != NULL) {

        ULONG LockTokenLengthInBytes = 0;

        ASSERT(davSrvOpen->LockTokenEntry != NULL);

        LockTokenLengthInBytes = (1 + wcslen(davSrvOpen->OpaqueLockToken)) * sizeof(WCHAR);

        CloseRequest->OpaqueLockToken = (PWCHAR) UMRxAllocateSecondaryBuffer(AsyncEngineContext,
                                                                             LockTokenLengthInBytes);
        if (CloseRequest->OpaqueLockToken == NULL) {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("ld: ERROR: MRxDAVFormatUserModeCloseRequest/"
                         "UMRxAllocateSecondaryBuffer. NtStatus = %08lx.\n",
                         PsGetCurrentThreadId(), NtStatus));
            goto EXIT_THE_FUNCTION;
        }

        RtlZeroMemory(CloseRequest->OpaqueLockToken, LockTokenLengthInBytes);

        RtlCopyBytes(CloseRequest->OpaqueLockToken,
                     davSrvOpen->OpaqueLockToken,
                     (wcslen(davSrvOpen->OpaqueLockToken) * sizeof(WCHAR)));

        DavDbgTrace(DAV_TRACE_DETAIL,
                    ("%ld: MRxDAVFormatUserModeCloseRequest: CloseRequest->OpaqueLockToken = %ws\n",
                     PsGetCurrentThreadId(), CloseRequest->OpaqueLockToken));

    }

    SecurityClientContext = &(DavVNetRoot->SecurityClientContext); 

    //
    // Impersonate the client who initiated the request. If we fail to 
    // impersonate, tough luck.
    //
    if (SecurityClientContext != NULL) {
        NtStatus = UMRxImpersonateClient(SecurityClientContext, WorkItemHeader);
        if (!NT_SUCCESS(NtStatus)) {
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: ERROR: MRxDAVFormatUserModeCloseRequest/"
                         "UMRxImpersonateClient. NtStatus = %08lx.\n", 
                         PsGetCurrentThreadId(), NtStatus));
        }   
    } else {
        NtStatus = STATUS_INVALID_PARAMETER;
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: ERROR: MRxDAVFormatUserModeCloseRequest: "
                     "SecurityClientContext is NULL.\n",
                     PsGetCurrentThreadId()));
    }

EXIT_THE_FUNCTION:

#ifdef DAV_DEBUG_READ_WRITE_CLOSE_PATH
    
    //
    // If we created a LocalFileHandle, we need to close it now.
    //
    if (LocalFileHandle != INVALID_HANDLE_VALUE) {
        ZwClose(LocalFileHandle);
    }
    
    //
    // If we allocated an NtFileName to do the create, we need to free it now.
    //
    if (NtFileName) {
        RxFreePool(NtFileName);
    }

#endif // DAV_DEBUG_READ_WRITE_CLOSE_PATH
    
    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Leaving MRxDAVFormatUserModeCloseRequest with NtStatus"
                 " = %08lx.\n", PsGetCurrentThreadId(), NtStatus));
    
    return(NtStatus);
}


BOOL
MRxDAVPrecompleteUserModeCloseRequest(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE,
    PUMRX_USERMODE_WORKITEM_HEADER WorkItemHeader,
    ULONG WorkItemLength,
    BOOL OperationCancelled
    )
/*++

Routine Description:

    The precompletion routine for the CloseSrvOpen request.

Arguments:

    RxContext - The RDBSS context.
    
    AsyncEngineContext - The reflctor's context.
    
    WorkItem - The work item buffer.
    
    WorkItemLength - The length of the work item buffer.

    OperationCancelled - TRUE if this operation was cancelled by the user.

Return Value:

    TRUE - UMRxAsyncEngineCalldownIrpCompletion is called by the function
           UMRxCompleteUserModeRequest after we return.    

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PDAV_USERMODE_WORKITEM WorkItem = (PDAV_USERMODE_WORKITEM)WorkItemHeader;
    PDAV_USERMODE_CLOSE_REQUEST CloseRequest = &(WorkItem->CloseRequest);
    PMRX_SRV_OPEN SrvOpen = NULL;
    PWEBDAV_SRV_OPEN davSrvOpen = NULL;
    PMRX_FCB Fcb = NULL;
    PWEBDAV_FCB DavFcb = NULL;

    PAGED_CODE();

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Entering MRxDAVPrecompleteUserModeCloseRequest\n",
                 PsGetCurrentThreadId()));

    DavDbgTrace(DAV_TRACE_CONTEXT,
                ("%ld: MRxDAVPrecompleteUserModeCloseRequest: "
                 "AsyncEngineContext = %08lx, RxContext = %08lx.\n",
                 PsGetCurrentThreadId(), AsyncEngineContext, RxContext));

    //
    // A CloseSrvOpen request can never by Async.
    //
    ASSERT(AsyncEngineContext->AsyncOperation == FALSE);

    //
    // If this operation was cancelled, then we don't need to do anything
    // special in the CloseSrvOpen case.
    //
    if (OperationCancelled) {
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: MRxDAVPrecompleteUserModeCloseRequest: Operation Cancelled. "
                     "AsyncEngineContext = %08lx, RxContext = %08lx.\n",
                     PsGetCurrentThreadId(), AsyncEngineContext, RxContext));
    } else {
        SrvOpen = RxContext->pRelevantSrvOpen;
        davSrvOpen = MRxDAVGetSrvOpenExtension(SrvOpen);
        Fcb = SrvOpen->pFcb;
        DavFcb = MRxDAVGetFcbExtension(Fcb);
    }

    if (AsyncEngineContext->Status != STATUS_SUCCESS) {
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: MRxDAVPrecompleteUserModeCloseRequest "
                     "Close failed for file \"%ws\"\n",
                     PsGetCurrentThreadId(), CloseRequest->PathName));
        if (!OperationCancelled) {
            //
            // If we failed and had reset FileWasModified to 0 in the Format
            // function, then we need to reset it to 1.
            //
            if (DavFcb->FileModifiedBitReset) {
                InterlockedExchange(&(DavFcb->FileWasModified), 1);
                DavFcb->FileModifiedBitReset = FALSE;
            }
        }
    } else {
        if (!OperationCancelled) {
            //
            // If we were successful and FileModifiedBitReset is TRUE then we
            // reset it to FALSE now.
            //
            if (DavFcb->FileModifiedBitReset) {
                DavFcb->FileModifiedBitReset = FALSE;
            }
        }
    }

    //  
    // We need to free up the heaps, we allocated in the format routine.
    //

    if (CloseRequest->ServerName != NULL) {

        NtStatus = UMRxFreeSecondaryBuffer(AsyncEngineContext, 
                                           (PBYTE)CloseRequest->ServerName);
        if (NtStatus != STATUS_SUCCESS) {
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: ERROR: MRxDAVPrecompleteUserModeCloseRequest/"
                         "UMRxFreeSecondaryBuffer: NtStatus = %08lx.\n", 
                         PsGetCurrentThreadId(), NtStatus));
            goto EXIT_THE_FUNCTION;
        }

    }

    if (CloseRequest->PathName != NULL) {

        NtStatus = UMRxFreeSecondaryBuffer(AsyncEngineContext, 
                                           (PBYTE)CloseRequest->PathName);
        if (NtStatus != STATUS_SUCCESS) {
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: ERROR: MRxDAVPrecompleteUserModeCloseRequest/"
                         "UMRxFreeSecondaryBuffer: NtStatus = %08lx.\n", 
                         PsGetCurrentThreadId(), NtStatus));
        }

    }

    if (CloseRequest->OpaqueLockToken != NULL) {

        NtStatus = UMRxFreeSecondaryBuffer(AsyncEngineContext, 
                                           (PBYTE)CloseRequest->OpaqueLockToken);
        if (NtStatus != STATUS_SUCCESS) {
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: ERROR: MRxDAVPrecompleteUserModeCloseRequest/"
                         "UMRxFreeSecondaryBuffer: NtStatus = %08lx.\n", 
                         PsGetCurrentThreadId(), NtStatus));
        }

    }

EXIT_THE_FUNCTION:
    
    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Leaving MRxDAVPrecompleteUserModeCloseRequest with "
                 "NtStatus = %08lx.\n", PsGetCurrentThreadId(), NtStatus));
    
    return TRUE;
}


NTSTATUS
MRxDAVCloseSrvOpenContinuation(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE
    )
/*++

Routine Description:

   This routine closes a file across the network.

Arguments:

    AsyncEngineContext - The Reflectors context.

    RxContext - The RDBSS context.

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    RxCaptureFcb; 
    RxCaptureFobx;
    NODE_TYPE_CODE TypeOfOpen = NodeType(capFcb);
    PMRX_SRV_OPEN SrvOpen = RxContext->pRelevantSrvOpen;
    PUNICODE_STRING RemainingName = GET_ALREADY_PREFIXED_NAME(SrvOpen, capFcb);
    PWEBDAV_SRV_OPEN davSrvOpen = MRxDAVGetSrvOpenExtension(SrvOpen);
    PMRX_FCB Fcb = SrvOpen->pFcb;
    PWEBDAV_FCB DavFcb = MRxDAVGetFcbExtension(Fcb);
    BOOL WentToTheUserMode = FALSE;
    ULONG FileWasModified = 0;

    PAGED_CODE();

    //
    // Assert that the FCB has been exclusively acquired.
    //
    ASSERT( RxIsFcbAcquiredExclusive(Fcb) == TRUE );

    if (RxIsFcbAcquiredExclusive(Fcb) != TRUE) {
        DbgPrint("MRxDAVCloseSrvOpenContinuation: FCB NOT Exclusive\n");
        DbgBreakPoint();
    }

    IF_DEBUG {
        ASSERT (capFobx != NULL);
        ASSERT (capFobx->pSrvOpen == RxContext->pRelevantSrvOpen);
    }
    
    ASSERT(NodeTypeIsFcb(capFcb));
    ASSERT(SrvOpen->OpenCount == 0);
    ASSERT(NodeType(SrvOpen) == RDBSS_NTC_SRVOPEN);

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Entering MRxDAVCloseSrvOpenContinuation!!!!\n",
                 PsGetCurrentThreadId()));

    DavDbgTrace(DAV_TRACE_CONTEXT,
                ("%ld: MRxDAVCloseSrvOpenContinuation: "
                 "AsyncEngineContext: %08lx, RxContext: %08lx.\n", 
                 PsGetCurrentThreadId(), AsyncEngineContext, RxContext));
    
    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVCloseSrvOpenContinuation: Attempt to Close: %wZ\n",
                 PsGetCurrentThreadId(), RemainingName));

    //
    // If this SrvOpen has an OpaqueLockToken associated with it, we don't need
    // to refresh it anymore since we are going to finalize this SrvOpen.
    //
    if (davSrvOpen->OpaqueLockToken != NULL) {
        ASSERT(davSrvOpen->LockTokenEntry != NULL);
        ExAcquireResourceExclusiveLite(&(LockTokenEntryListLock), TRUE);
        davSrvOpen->LockTokenEntry->ShouldThisEntryBeRefreshed = FALSE;
        ExReleaseResourceLite(&(LockTokenEntryListLock));
    }

    FileWasModified = InterlockedCompareExchange(&(DavFcb->FileWasModified), 0, 0);

    //
    // We go to the usermode if one of the following is TRUE.
    // 1. The File was not LOCked on the server on Create, OR,
    // 2. The File was LOCked on create and this SrvOpen has the LockToken
    //    associated with the LOCK taken on the server.
    // We do not want to go to the server if the file is LOCKed and the SrvOpen
    // doesn't contain the LockToken since all the requests to modify the file
    // are going to fail (423 - File Is Locked) in such a scenario.
    //
    if ( (DavFcb->FileIsLockedOnTheServer == FALSE) ||
         (DavFcb->FileIsLockedOnTheServer == TRUE &&  davSrvOpen->OpaqueLockToken != NULL) ) {
        WentToTheUserMode = TRUE;
        NtStatus = UMRxSubmitAsyncEngUserModeRequest(
                                           UMRX_ASYNCENGINE_ARGUMENTS,
                                           MRxDAVFormatUserModeCloseRequest,
                                           MRxDAVPrecompleteUserModeCloseRequest
                                           );
        if (NtStatus != STATUS_SUCCESS) {
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: MRxDAVCloseSrvOpenContinuation/"
                         "UMRxSubmitAsyncEngUserModeRequest: NtStatus = %08lx.\n",
                         PsGetCurrentThreadId(), NtStatus));
        }
    }

    if (DavFcb->isDirectory == FALSE) {
        
        //
        // If this handle got created in the kernel, we need to close it now.
        //
        if (davSrvOpen->createdInKernel) {
            DavDbgTrace(DAV_TRACE_DETAIL,
                        ("%ld: MRxDAVCloseSrvOpenContinuation: FileHandle = %08lx,"
                         " Process = %08lx, SrvOpen = %08lx, davSrvOpen = %08lx\n", 
                         PsGetCurrentThreadId(), davSrvOpen->UnderlyingHandle, 
                         PsGetCurrentProcess(), SrvOpen, davSrvOpen));
            ZwClose(davSrvOpen->UnderlyingHandle);
            davSrvOpen->UnderlyingHandle = NULL;
            davSrvOpen->UserModeKey = NULL;
        }
    
        //      
        // Remove our reference which we would have taken on the FileObject
        // when the Create succeeded.
        //
        if (davSrvOpen->UnderlyingFileObject) {
            DavDbgTrace(DAV_TRACE_DETAIL,
                        ("%ld: MRxDAVCloseSrvOpenContinuation: Attempt to close"
                         " %wZ.\n", PsGetCurrentThreadId(), RemainingName));
            ObDereferenceObject(davSrvOpen->UnderlyingFileObject);
            davSrvOpen->UnderlyingFileObject = NULL;
        }

    }

    if (WentToTheUserMode) {

        if (DavFcb->DeleteOnClose) {
            MRxDAVInvalidateFileInfoCache(RxContext);
            MRxDAVCacheFileNotFound(RxContext);
            if ((capFcb->Attributes & FILE_ATTRIBUTE_DIRECTORY) &&
                (capFcb->Attributes & FILE_ATTRIBUTE_ENCRYPTED)) {
                //
                // Remove the directory from the registry since it has been deleted.
                //
                MRxDAVRemoveEncryptedDirectoryKey(&DavFcb->FileNameInfo);
            }
        }

        if (FileWasModified != 0) {
            // 
            // We cannot predict the size of the file on the server.
            //
            MRxDAVInvalidateFileInfoCache(RxContext);
        }

        NtStatus = AsyncEngineContext->Status;

    }

    //
    // If we succeeded in the usermode, we need to reset some values in the
    // DavFcb so that we don't do this again.
    //
    if (NtStatus == STATUS_SUCCESS && WentToTheUserMode) {
        DavFcb->fCreationTimeChanged = FALSE;
        DavFcb->fFileAttributesChanged = FALSE;
        DavFcb->fLastAccessTimeChanged = FALSE;
        DavFcb->fLastModifiedTimeChanged = FALSE;
    }

    //
    // If we have a non-NULL OpaqueLockToken then we need to free it now. Also,
    // we need to remove the LockTokenEntry associated with this token from
    // the global list and free it as well.
    //
    if (davSrvOpen->OpaqueLockToken != NULL) {

        ASSERT(WentToTheUserMode == TRUE);

        ASSERT(davSrvOpen->LockTokenEntry != NULL);

        //
        // Remove the LockTokenEntry associated with this OpaqueLockToken from
        // the global LockTokenEntryList.
        //
        ExAcquireResourceExclusiveLite(&(LockTokenEntryListLock), TRUE);
        RemoveEntryList( &(davSrvOpen->LockTokenEntry->listEntry) );
        ExReleaseResourceLite(&(LockTokenEntryListLock));

        //
        // Free the PagedPool that was allocated for the ServerName.
        //
        RxFreePool(davSrvOpen->LockTokenEntry->ServerName);
        davSrvOpen->LockTokenEntry->ServerName = NULL;

        //
        // Free the PagedPool that was allocated for the PathName.
        //
        RxFreePool(davSrvOpen->LockTokenEntry->PathName);
        davSrvOpen->LockTokenEntry->PathName = NULL;

        //
        // Free the PagedPool that was allocated for this LockTokenEntry.
        //
        RxFreePool(davSrvOpen->LockTokenEntry);
        davSrvOpen->LockTokenEntry = NULL;

        //
        // Free the PagedPool that was allocated for this OpaqueLockToken.
        //
        RxFreePool(davSrvOpen->OpaqueLockToken);
        davSrvOpen->OpaqueLockToken = NULL;

        //
        // The file has now been UnLocked on the server.
        //
        DavFcb->FileIsLockedOnTheServer = FALSE;

    }

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Leaving MRxDAVCloseSrvOpenContinuation with NtStatus = "
                 "%08lx\n", PsGetCurrentThreadId(), NtStatus));

    return(NtStatus);
}


NTSTATUS
MRxDAVGetFullParentDirectoryPath(
    PRX_CONTEXT RxContext,
    PUNICODE_STRING ParentDirName
    )
/*++

Routine Description:

   This routine returns the parent directory name of the file on the RxContext including 
   server and share.
    
   Here is an example of the FileName on a file object:
          \;Y:000000000000cdef\www.msnusers.com\dv1@usa.com\files\mydoc.doc
   We want to return the middle part of the FileName:
          \www.msnusers.com\dv1@usa.com\files
    

Arguments:

    RxContext - The RDBSS context.
    ParentDirName - The full path name of the parent directory starting from the server.

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
    USHORT i, j;
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PUNICODE_STRING FileName = &RxContext->CurrentIrpSp->FileObject->FileName;

    ParentDirName->Buffer = NULL;

    for (i = 1; i < (FileName->Length / sizeof(WCHAR)); i++) {
        if (FileName->Buffer[i] == L'\\') {
            break;
        }
    }

    if ( i < (FileName->Length / sizeof(WCHAR)) ) {
        for (j = ( (FileName->Length / sizeof(WCHAR)) - 1 ); j > i; j--) {
            if (FileName->Buffer[j] == L'\\') {
                break;
            }
        }

        if (i < j) {
            ParentDirName->Buffer = &FileName->Buffer[i];
            ParentDirName->Length = ParentDirName->MaximumLength = (j - i) * sizeof(WCHAR);
        }
    }
    
    DavDbgTrace(DAV_TRACE_DETAIL, ("MRxDAVGetFullParentDirectoryPath: ParentDirName: %wZ\n", ParentDirName));

    return NtStatus;
}


NTSTATUS
MRxDAVGetFullDirectoryPath(
    PRX_CONTEXT RxContext,
    PUNICODE_STRING FileName,
    PUNICODE_STRING DirName
    )
/*++

Routine Description:

   This routine returns the full directory name including the server and share.

Arguments:

    RxContext - The RDBSS context.
    FileName - If provided, it will be included in the returned path.
               If not provided, the file name on the file object will be returned.
    DirName - The full path name of the parent directory starting from the server.

Return Value:

    NTSTATUS - The return status for the operation
    
Note:

   If FileName is provided, the caller should free up the the UNICODE buffer.    

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    
    DirName->Buffer = NULL;
    DirName->Length = DirName->MaximumLength = 0;
    
    if (FileName == NULL) {
        
        USHORT i;

        FileName = &RxContext->CurrentIrpSp->FileObject->FileName;

        for (i = 1; i < (FileName->Length / sizeof(WCHAR)); i++) {
            if (FileName->Buffer[i] == L'\\') {
                break;
            }
        }

        if ( i < (FileName->Length / sizeof(WCHAR)) ) {
            DirName->Buffer = &FileName->Buffer[i];
            DirName->Length = DirName->MaximumLength = FileName->Length - i*sizeof(WCHAR);
        }
    
    } else {
        
        RxCaptureFcb;
        
        USHORT NameLength = 0;

        if (FileName->Length == 0) {
            goto EXIT_THE_FUNCTION;
        }

        NameLength = capFcb->pNetRoot->pNetRootName->Length + FileName->Length;

        DirName->Length = DirName->MaximumLength = NameLength;

        DirName->Buffer = RxAllocatePoolWithTag(PagedPool, 
                                                NameLength + sizeof(WCHAR),
                                                DAV_FILEINFO_POOLTAG);

        if (DirName->Buffer == NULL) {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: MRxDAVGetParentDirectory/RxAllocatePool: Error Val"
                         " = %08lx\n", PsGetCurrentThreadId(), NtStatus));
            goto EXIT_THE_FUNCTION;
        }

        RtlZeroMemory(DirName->Buffer,NameLength + sizeof(WCHAR));

        RtlCopyMemory(DirName->Buffer,
                      capFcb->pNetRoot->pNetRootName->Buffer,
                      capFcb->pNetRoot->pNetRootName->Length);

        RtlCopyMemory(&DirName->Buffer[capFcb->pNetRoot->pNetRootName->Length/sizeof(WCHAR)],
                      FileName->Buffer,
                      FileName->Length);
    
    }

EXIT_THE_FUNCTION:

    DavDbgTrace(DAV_TRACE_DETAIL, ("MRxDAVGetFullDirectoryPath: DirName: %wZ\n", DirName));

    return NtStatus;
}


NTSTATUS
MRxDAVCreateEncryptedDirectoryKey(
    PUNICODE_STRING DirName
    )
/*++

Routine Description:

   This routine creates the registry key for the encrypted directory.

Arguments:

    DirName - The full path name of the directory starting from the server.

Return Value:

    NTSTATUS - The return status for the operation
    
--*/
{
    NTSTATUS Status;
    ULONG i = 0;
    HKEY Key = NULL;
    ULONG RequiredLength = 0;
    UNICODE_STRING UnicodeRegKeyName;
    OBJECT_ATTRIBUTES ObjectAttributes;

    DavDbgTrace(DAV_TRACE_DETAIL, ("MRxDAVCreateEncryptedDirectoryKey: DirName: %wZ\n", DirName));

    RtlInitUnicodeString(&(UnicodeRegKeyName), MRXDAV_ENCRYPTED_DIRECTORY_KEY);

    InitializeObjectAttributes(&(ObjectAttributes),
                               &(UnicodeRegKeyName),
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    Status = ZwOpenKey(&Key, KEY_ALL_ACCESS, &ObjectAttributes);

    if (Status != STATUS_SUCCESS) {
        
        Status = ZwCreateKey(&Key,
                             KEY_ALL_ACCESS,
                             &ObjectAttributes,
                             0,
                             NULL,
                             0,
                             NULL);

        if (Status == STATUS_SUCCESS) {
            
            Status = ZwSetValueKey(Key,
                                   DirName,
                                   0,
                                   REG_DWORD,
                                   &i,
                                   sizeof(ULONG));

            ZwClose(Key);

        }
    
    } else {
        
        Status = ZwQueryValueKey(Key,
                                 DirName,
                                 KeyValuePartialInformation,
                                 NULL,
                                 0,
                                 &(RequiredLength));

        if (Status == STATUS_OBJECT_NAME_NOT_FOUND) {
            
            Status = ZwSetValueKey(Key,
                                   DirName,
                                   0,
                                   REG_DWORD,
                                   &i,
                                   sizeof(ULONG));
        
        } else if (Status == STATUS_BUFFER_TOO_SMALL) {

            Status = STATUS_SUCCESS;
        
        }

        ZwClose(Key);
    
    }

    if (Status != STATUS_SUCCESS) {
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: ERROR: MRxDAVCreateEncryptedDirectoryKey. NtStatus = "
                     "%08lx\n", PsGetCurrentThreadId(), Status));
    }

    return Status;
}


NTSTATUS
MRxDAVRemoveEncryptedDirectoryKey(
    PUNICODE_STRING DirName
    )
/*++

Routine Description:

   This routine deletes the registry key for the directory.

Arguments:

    DirName - The full path name of the directory starting from the server.

Return Value:

    NTSTATUS - The return status for the operation
    
--*/
{
    NTSTATUS Status;
    ULONG i = 0;
    HKEY Key = NULL;
    ULONG RequiredLength = 0;
    UNICODE_STRING UnicodeRegKeyName;
    OBJECT_ATTRIBUTES ObjectAttributes;
    
    DavDbgTrace(DAV_TRACE_DETAIL, ("MRxDAVRemoveEncryptedDirectoryKey: DirName: %wZ\n", DirName));

    RtlInitUnicodeString(&(UnicodeRegKeyName), MRXDAV_ENCRYPTED_DIRECTORY_KEY);

    InitializeObjectAttributes(&(ObjectAttributes),
                               &(UnicodeRegKeyName),
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    Status = ZwOpenKey(&Key, KEY_ALL_ACCESS, &ObjectAttributes);

    if (Status == STATUS_SUCCESS) {
        Status = ZwDeleteValueKey(Key,DirName);
        ZwClose(Key);
    }

    if (Status != STATUS_SUCCESS) {
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: ERROR: MRxDAVRemoveEncryptedDirectoryKey. NtStatus = "
                     "%08lx\n", PsGetCurrentThreadId(), Status));
    }

    return Status;
}


NTSTATUS
MRxDAVQueryEncryptedDirectoryKey(
    PUNICODE_STRING DirName
    )
/*++

Routine Description:

   This routine queries the registry key for the directory.

Arguments:

    DirName - The full path name of the directory starting from the server.

Return Value:

    NTSTATUS - The return status for the operation
    
--*/
{
    NTSTATUS Status;
    ULONG i = 0;
    HKEY Key = NULL;
    ULONG RequiredLength = 0;
    UNICODE_STRING UnicodeRegKeyName;
    OBJECT_ATTRIBUTES ObjectAttributes;

    DavDbgTrace(DAV_TRACE_DETAIL, ("MRxDAVQueryEncryptedDirectoryKey: DirName: %wZ\n", DirName));

    RtlInitUnicodeString(&(UnicodeRegKeyName), MRXDAV_ENCRYPTED_DIRECTORY_KEY);

    InitializeObjectAttributes(&(ObjectAttributes),
                               &(UnicodeRegKeyName),
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    Status = ZwOpenKey(&Key, KEY_ALL_ACCESS, &ObjectAttributes);

    if (Status == STATUS_SUCCESS) {
        
        Status = ZwQueryValueKey(Key,
                                 DirName,
                                 KeyValuePartialInformation,
                                 NULL,
                                 0,
                                 &(RequiredLength));

        if (Status == STATUS_BUFFER_TOO_SMALL) {
            Status = STATUS_SUCCESS;
        }

        ZwClose(Key);
    
    }

    if (Status != STATUS_SUCCESS) {
        DavDbgTrace(DAV_TRACE_DETAIL,
                    ("%ld: ERROR: MRxDAVQueryEncryptedDirectoryKey. NtStatus = "
                     "%08lx\n", PsGetCurrentThreadId(), Status));
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\kernel\stubs.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    stubs.c

Abstract:

    This module implements the mini redirector call down routines that are essentially
    just noops but which have to be implemented because the wrapper calls them without
    checking. In most cases, CODE.IMPROVEMENT the wrapper should either provide a stub
    to be used or check before calling.


Author:

    Joe Linn      [joelinn]      3-December-96

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//
//  The local debug trace level
//

#define Dbgg                              (0)


#if 0
NTSTATUS
UMRxTransportUpdateHandler(
    PRXCE_TRANSPORT_NOTIFICATION pTransportNotification)
/*++

Routine Description:

    This routine is the callback handler that is invoked by the RxCe when transports
    are either enabled or disabled. Since we do not use transports, we just return success.

Arguments:

    pTransportNotification - information pertaining to the transport

Return Value:

    STATUS_SUCCESS - the server transport construction has been finalized.

    Other Status codes correspond to error situations.

Notes:


--*/
{
    return STATUS_SUCCESS;
}
#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\kernel\querydir.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    querydir.c

Abstract:

    This module implements the DAV mini redirector call down routines pertaining
    to query directory.

Author:

    Joe Linn
    
    Rohan Kumar [RohanK] 20-Sept-1999

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include "webdav.h"

//
// Mentioned below are the prototypes of functions tht are used only within
// this module (file). These functions should not be exposed outside.
//

NTSTATUS
MRxDAVQueryDirectoryContinuation(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE
    );

NTSTATUS
MRxDAVFormatUserModeQueryDirectoryRequest(
    IN UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE,
    IN OUT PUMRX_USERMODE_WORKITEM_HEADER WorkItemHeader,
    IN ULONG WorkItemLength,
    OUT PULONG_PTR ReturnedLength
    );

BOOL
MRxDAVPrecompleteUserModeQueryDirectoryRequest(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE,
    PUMRX_USERMODE_WORKITEM_HEADER WorkItemHeader,
    ULONG WorkItemLength,
    BOOL OperationCancelled
    );

NTSTATUS
MRxDAVQueryDirectoryFromCache(
    IN PRX_CONTEXT RxContext,
    IN PBYTE Buffer,
    IN PFILE_BASIC_INFORMATION Basic,
    IN PFILE_STANDARD_INFORMATION Standard,
    IN ULONG FileIndex
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, MRxDAVQueryDirectory)
#pragma alloc_text(PAGE, MRxDAVQueryDirectoryFromCache)
#pragma alloc_text(PAGE, MRxDAVQueryDirectoryContinuation)
#pragma alloc_text(PAGE, MRxDAVFormatUserModeQueryDirectoryRequest)
#pragma alloc_text(PAGE, MRxDAVPrecompleteUserModeQueryDirectoryRequest)
#endif

//
// Implementation of functions begins here.
//

NTSTATUS
MRxDAVQueryDirectory(
    IN PRX_CONTEXT RxContext
    )
/*++

Routine Description:

   This routine handles querydir requests for the DAV mini--redir.

Arguments:

    RxContext - The RDBSS context.

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    RxCaptureFcb;
    RxCaptureFobx;
    UNICODE_STRING CacheName;
    PUNICODE_STRING DirectoryName = GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(RxContext);

    PAGED_CODE();

    DavDbgTrace(DAV_TRACE_ENTRYEXIT,
                ("%ld: Entering MRxDAVQueryDirectory.\n", PsGetCurrentThreadId()));
    
    DavDbgTrace(DAV_TRACE_CONTEXT,
                ("%ld: MRxDAVQueryDirectory: RxContext: %08lx\n", 
                 PsGetCurrentThreadId(), RxContext));

    CacheName.Buffer = RxAllocatePoolWithTag(PagedPool,
                                             MAX_PATH * sizeof(WCHAR),
                                             DAV_QUERYDIR_POOLTAG);

    if (CacheName.Buffer == NULL) {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto EXIT_THE_FUNCTION;
    }

    RtlZeroMemory(CacheName.Buffer, MAX_PATH * sizeof(WCHAR));
    
    RtlCopyMemory(CacheName.Buffer,DirectoryName->Buffer,DirectoryName->Length);
    
    CacheName.Buffer[DirectoryName->Length/2] = L'\\';
    
    RtlCopyMemory(&CacheName.Buffer[DirectoryName->Length/2 + 1],
                  capFobx->UnicodeQueryTemplate.Buffer,
                  capFobx->UnicodeQueryTemplate.Length);
    
    CacheName.Length =  ( DirectoryName->Length + capFobx->UnicodeQueryTemplate.Length + sizeof(WCHAR) );
    CacheName.MaximumLength = ( DirectoryName->Length + capFobx->UnicodeQueryTemplate.Length + sizeof(WCHAR) );

    if (!FsRtlDoesNameContainWildCards(&capFobx->UnicodeQueryTemplate)) {

        DAV_USERMODE_CREATE_RETURNED_FILEINFO FileInfo;
        PWEBDAV_FOBX DavFobx = MRxDAVGetFobxExtension(capFobx);

        if (DavFobx->CurrentFileIndex > 0) {
            DavFobx->NumOfFileEntries = 0;
            DavFobx->CurrentFileIndex = 0;
            NtStatus = STATUS_NO_MORE_FILES;
            goto EXIT_THE_FUNCTION;
        }

        if (MRxDAVIsFileNotFoundCachedWithName(&CacheName,capFcb->pNetRoot)) {
            DavDbgTrace(DAV_TRACE_DETAIL,
                        ("MRxDAVCreateContinuation file not found %wZ\n",&CacheName));
            NtStatus = STATUS_OBJECT_NAME_NOT_FOUND;
            goto EXIT_THE_FUNCTION;
        }

        if (MRxDAVIsFileInfoCacheFound(RxContext, &FileInfo, &NtStatus, &CacheName)) {

            PBYTE Buffer = RxContext->Info.Buffer;
            ULONG BufferLength = RxContext->Info.LengthRemaining;

            //
            // Zero the buffer supplied.
            //
            RtlZeroMemory(Buffer, BufferLength);

            NtStatus = MRxDAVQueryDirectoryFromCache(RxContext,
                                                     Buffer,
                                                     &FileInfo.BasicInformation,
                                                     &FileInfo.StandardInformation,
                                                     1);

            DavFobx->NumOfFileEntries = 1;
            DavFobx->CurrentFileIndex = 1;

            goto EXIT_THE_FUNCTION;

        }

    }

    NtStatus = UMRxAsyncEngOuterWrapper(RxContext,
                                        SIZEOF_DAV_SPECIFIC_CONTEXT,
                                        MRxDAVFormatTheDAVContext,
                                        DAV_MINIRDR_ENTRY_FROM_QUERYDIR,
                                        MRxDAVQueryDirectoryContinuation,
                                        "MRxDAVQueryDirectory");
    
    DavDbgTrace(DAV_TRACE_ENTRYEXIT,
                ("%ld: Leaving MRxDAVQueryDirectory with NtStatus = %08lx\n", 
                 PsGetCurrentThreadId(), NtStatus));

    if (NtStatus == STATUS_NO_SUCH_FILE ||
        NtStatus == STATUS_OBJECT_PATH_NOT_FOUND ||
        NtStatus == STATUS_OBJECT_NAME_NOT_FOUND) {
        MRxDAVCacheFileNotFoundWithName(&CacheName,RxContext->pFcb->pNetRoot);
        MRxDAVInvalidateFileInfoCacheWithName(&CacheName,RxContext->pFcb->pNetRoot);
    }

EXIT_THE_FUNCTION:

    if (CacheName.Buffer != NULL) {
        RxFreePool(CacheName.Buffer);
    }

    return(NtStatus);
}


NTSTATUS
MRxDAVQueryDirectoryContinuation(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE
    )
/*++

Routine Description:

    This is the continuation routine for query directory operation.

Arguments:

    AsyncEngineContext - The Reflectors context.

    RxContext - The RDBSS context.
    
Return Value:

    RXSTATUS - The return status for the operation.

--*/
{
    NTSTATUS NtStatus;
    BOOL SynchronousIo;

    PAGED_CODE();

    DavDbgTrace(DAV_TRACE_ENTRYEXIT,
                ("%ld: Entering MRxDAVQueryDirectoryContinuation!!!!\n",
                 PsGetCurrentThreadId()));

    DavDbgTrace(DAV_TRACE_CONTEXT,
                ("%ld: MRxDAVQueryDirectoryContinuation: "
                 "AsyncEngineContext: %08lx, RxContext: %08lx.\n", 
                 PsGetCurrentThreadId(), AsyncEngineContext, RxContext));

    SynchronousIo = !BooleanFlagOn(RxContext->Flags, RX_CONTEXT_FLAG_ASYNC_OPERATION);
    
    if (!SynchronousIo) {

        //
        // Set the asynchronous flag. This is done since we do not want this 
        // thread to block in the UMRxSubmitAsyncEngUserModeRequest function.
        // Also, since we need to call RxLowIoCompletion once we are done, set
        // ShouldCallLowIoCompletion in the context to TRUE.
        //
        SetFlag(AsyncEngineContext->Flags, UMRX_ASYNCENG_CTX_FLAG_ASYNC_OPERATION);
        AsyncEngineContext->ShouldCallLowIoCompletion = TRUE;

        //
        // Set the CancelRoutine on the RxContext. Since this is an Async
        // operation, it can be cancelled.
        //
        NtStatus = RxSetMinirdrCancelRoutine(RxContext, MRxDAVCancelRoutine);
        if (NtStatus != STATUS_SUCCESS) {
            ASSERT(NtStatus == STATUS_CANCELLED);
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: MRxDAVQueryDirectoryContinuation: "
                         "AsyncEngineContext: %08lx. STATUS_CANCELLED\n", 
                         PsGetCurrentThreadId(), AsyncEngineContext));
            goto EXIT_THE_FUNCTION;
        }

        //
        // Since this is an Asyncchronous operation, mark the IRP as pending.
        // Its OK if you mark an IRP pending and complete it on the same thread
        // without returning STATUS_PENDING.
        //
        IoMarkIrpPending(RxContext->CurrentIrp);

    }

    //  
    // Try usermode.
    //
    NtStatus = UMRxSubmitAsyncEngUserModeRequest(
                                 UMRX_ASYNCENGINE_ARGUMENTS,
                                 MRxDAVFormatUserModeQueryDirectoryRequest,
                                 MRxDAVPrecompleteUserModeQueryDirectoryRequest
                                 );

EXIT_THE_FUNCTION:

    DavDbgTrace(DAV_TRACE_ENTRYEXIT,
                ("%ld: Leaving MRxDAVQueryDirectoryContinuation with NtStatus "
                 "= %08lx.\n", PsGetCurrentThreadId(), NtStatus));

    return NtStatus;
}


NTSTATUS
MRxDAVFormatUserModeQueryDirectoryRequest(
    IN UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE,
    IN OUT PUMRX_USERMODE_WORKITEM_HEADER WorkItemHeader,
    IN ULONG WorkItemLength,
    OUT PULONG_PTR ReturnedLength
    )
/*++

Routine Description:

    This routine formats the QueryDirectory request being sent to the user mode 
    for processing.

Arguments:
    
    RxContext - The RDBSS context.
    
    AsyncEngineContext - The reflctor's context.
    
    WorkItem - The work item buffer.
    
    WorkItemLength - The length of the work item buffer.
    
    ReturnedLength - 
    
Return Value:

    STATUS_SUCCESS or STATUS_INSUFFICIENT_RESOURCES.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PMRX_SRV_CALL SrvCall = NULL;
    PWEBDAV_SRV_CALL DavSrvCall = NULL;
    PDAV_USERMODE_WORKITEM DavWorkItem = (PDAV_USERMODE_WORKITEM)WorkItemHeader;
    PMRX_SRV_OPEN SrvOpen = RxContext->pRelevantSrvOpen;
    PWEBDAV_V_NET_ROOT DavVNetRoot = NULL;
    PMRX_NET_ROOT NetRoot = NULL;
    PWEBDAV_SRV_OPEN davSrvOpen = MRxDAVGetSrvOpenExtension(SrvOpen);
    PWCHAR ServerName = NULL, NetRootName = NULL, JustTheNetRootName = NULL;
    PBYTE PathName = NULL;
    ULONG ServerNameLengthInBytes, PathNameLengthInBytes, NetRootNameLengthInBytes;
    PDAV_USERMODE_QUERYDIR_REQUEST QueryDirRequest = NULL;
    PSECURITY_CLIENT_CONTEXT SecurityClientContext = NULL;
    PWEBDAV_FOBX DavFobx = NULL;
    BOOLEAN ReturnVal;
    PUNICODE_STRING Template;
    RxCaptureFobx;

    PAGED_CODE();

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Entering MRxDAVFormatUserModeQueryDirectoryRequest.\n",
                 PsGetCurrentThreadId()));

    DavDbgTrace(DAV_TRACE_CONTEXT,
                ("%ld: MRxDAVFormatUserModeQueryDirectoryRequest: "
                 "AsyncEngineContext: %08lx, RxContext: %08lx.\n",
                 PsGetCurrentThreadId(), AsyncEngineContext, RxContext));
    
    IF_DEBUG {
        ASSERT (capFobx != NULL);
        ASSERT (capFobx->pSrvOpen == RxContext->pRelevantSrvOpen);
    }

    DavWorkItem->WorkItemType = UserModeQueryDirectory;
    
    QueryDirRequest = &(DavWorkItem->QueryDirRequest);

    DavFobx = MRxDAVGetFobxExtension(capFobx);
    ASSERT(DavFobx != NULL);

    NetRoot = SrvOpen->pFcb->pNetRoot;

    DavVNetRoot = (PWEBDAV_V_NET_ROOT)SrvOpen->pVNetRoot->Context;
    ASSERT(DavVNetRoot != NULL);
    
    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVFormatUserModeQueryDirectoryRequest: SrvCallName = %wZ, "
                 "SrvCallNameLength = %d\n", PsGetCurrentThreadId(), 
                 NetRoot->pSrvCall->pSrvCallName, NetRoot->pSrvCall->pSrvCallName->Length));

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVFormatUserModeQueryDirectoryRequest: NetRootName = %wZ, "
                 "NetRootNameLength = %d\n", PsGetCurrentThreadId(), 
                 NetRoot->pNetRootName, NetRoot->pNetRootName->Length));

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVFormatUserModeQueryDirectoryRequest: PathName = %wZ, "
                 "PathNameLength = %d\n", PsGetCurrentThreadId(), 
                 SrvOpen->pAlreadyPrefixedName, SrvOpen->pAlreadyPrefixedName->Length));

    //
    // Have we already created the DavFileAttributes list. If we have, then we 
    // tell the user mode process to do nothing and return. Here we do need to
    // impersonate becuase the usermode will fail otherwise. This is becuase
    // of the way the usermode code is structured.
    //
    if (DavFobx->DavFileAttributes) {
        QueryDirRequest->AlreadyDone = TRUE;
        goto IMPERSONATE_AND_EXIT;
    }
    
    QueryDirRequest->AlreadyDone = FALSE;
    
    SrvCall = SrvOpen->pVNetRoot->pNetRoot->pSrvCall;
    DavSrvCall = MRxDAVGetSrvCallExtension(SrvCall);

    //  
    // Copy the ServerName.
    //
    ServerNameLengthInBytes = ( SrvCall->pSrvCallName->Length + sizeof(WCHAR) );
    ServerName = (PWCHAR) UMRxAllocateSecondaryBuffer(AsyncEngineContext,
                                                      ServerNameLengthInBytes);
    if (ServerName == NULL) {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: ERROR: MRxDAVFormatUserModeQueryDirectoryRequest/"
                     "UMRxAllocateSecondaryBuffer. NtStatus = %08lx.\n",
                     PsGetCurrentThreadId(), NtStatus));
        goto EXIT_THE_FUNCTION;
    }
    
    RtlCopyBytes(ServerName, 
                 SrvCall->pSrvCallName->Buffer, 
                 SrvCall->pSrvCallName->Length);

    ServerName[( ( (ServerNameLengthInBytes) / sizeof(WCHAR) ) - 1 )] = L'\0';
    QueryDirRequest->ServerName = ServerName;

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVFormatUserModeQueryDirectoryRequest: ServerName: "
                 "%ws\n", PsGetCurrentThreadId(), ServerName));
    
    //
    // Copy the ServerID.
    //
    QueryDirRequest->ServerID = DavSrvCall->ServerID;

    Template = &(capFobx->UnicodeQueryTemplate);
    
    //
    // The NetRootName (pNetRootName) includes the ServerName. Hence to get the
    // NetRootNameLengthInBytes, we do the following.
    //
    NetRootNameLengthInBytes = (NetRoot->pNetRootName->Length - NetRoot->pSrvCall->pSrvCallName->Length);

    NetRootName = &(NetRoot->pNetRootName->Buffer[1]);
    JustTheNetRootName = wcschr(NetRootName, L'\\');

    //
    // Copy the PathName of the Directory. If the template does not contain any
    // wild cards, then we just need to get the attributes of this file from
    // the server. We only get the attributes of all the files, if a wild card
    // is specified in the template.
    //
    ReturnVal = FsRtlDoesNameContainWildCards(Template);

    if (ReturnVal) {
    
        //
        // The sizeof(WCHAR) is for the final '\0' char.
        //
        PathNameLengthInBytes = ( NetRootNameLengthInBytes + sizeof(WCHAR) );
        
        //
        // We need to allocate memory for the backslash and the Remaining name
        // only if the remaining name exists.
        //
        if (SrvOpen->pAlreadyPrefixedName->Length) {
            //
            // The sizeof(WCHAR) is for the backslash after the NetRootName.
            //
            PathNameLengthInBytes += ( SrvOpen->pAlreadyPrefixedName->Length + sizeof(WCHAR) );
        }

        PathName = (PBYTE) UMRxAllocateSecondaryBuffer(AsyncEngineContext, PathNameLengthInBytes);
        if (PathName == NULL) {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: ERROR: MRxDAVFormatUserModeQueryDirectoryRequest/"
                         "UMRxAllocateSecondaryBuffer. NtStatus = %08lx.\n",
                         PsGetCurrentThreadId(), NtStatus));
            goto EXIT_THE_FUNCTION;
        }
    
        QueryDirRequest->PathName = (PWCHAR)PathName;
        
        RtlZeroMemory(QueryDirRequest->PathName, PathNameLengthInBytes);
        
        //
        // Copy the NetRootName.
        //
        RtlCopyMemory(PathName, JustTheNetRootName, NetRootNameLengthInBytes);

        //
        // We need to copy the backclash and the remaining path name only if
        // the remaining path name exists.
        //
        if (SrvOpen->pAlreadyPrefixedName->Length) {
            if (SrvOpen->pAlreadyPrefixedName->Buffer[0] != L'\\') {

                //
                // Copy the backslash.
                //
                RtlCopyMemory( (PathName + NetRootNameLengthInBytes), L"\\", sizeof(WCHAR) );

                //
                // Copy the remaining path name after the NetRootName.
                //
                RtlCopyMemory( ( PathName + NetRootNameLengthInBytes + sizeof(WCHAR) ), 
                               SrvOpen->pAlreadyPrefixedName->Buffer, 
                               SrvOpen->pAlreadyPrefixedName->Length);
            } else {
                //
                // Copy the remaining path name after the NetRootName which has the leading
                // backslash already.
                //
                RtlCopyMemory( ( PathName + NetRootNameLengthInBytes ), 
                               SrvOpen->pAlreadyPrefixedName->Buffer, 
                               SrvOpen->pAlreadyPrefixedName->Length);
            }
        }
    
        QueryDirRequest->NoWildCards = FALSE;

    } else {

        //
        // The Template is just a filename without any wild card chars. We copy
        // the filaname after the pathname and send it to the user mode. First,
        // we need to figure out if the path name has a trailing '\'.
        //

        BOOL trailingSlash = FALSE;
        PWCHAR PName = SrvOpen->pAlreadyPrefixedName->Buffer;
        ULONG PLen = SrvOpen->pAlreadyPrefixedName->Length;

        if (PLen) {
            if ( PName[ ( ( PLen / sizeof(WCHAR) ) - 1 ) ] == L'\\' ) {
                trailingSlash = TRUE;
            }
        } else {
            PName = NULL;
        }

        if (trailingSlash) {
            //
            // The first sizeof(WCHAR) is for the backslash after the NetRootName.
            // The second sizeof(WCHAR) for the final \0.
            //
            PathNameLengthInBytes = ( NetRootNameLengthInBytes + 
                                      sizeof(WCHAR) +
                                      SrvOpen->pAlreadyPrefixedName->Length + 
                                      Template->Length + 
                                      sizeof(WCHAR) );
        } else {
            //
            // The first sizeof(WCHAR) is for the backslash after the NetRootName.
            // The second sizeof(WCHAR) is for the final '\0' char.
            //
            PathNameLengthInBytes = ( NetRootNameLengthInBytes +
                                      sizeof(WCHAR) +
                                      Template->Length +
                                      sizeof(WCHAR) );
            
            //
            // The sizeof(WCHAR) if for the '\\' between the pathname and the 
            // template name. We need to add this only if the remaining path
            // name exists.
            //
            if (PName) {
                PathNameLengthInBytes += ( SrvOpen->pAlreadyPrefixedName->Length +
                                           sizeof(WCHAR) );
            }
        }

        PathName = (PBYTE)UMRxAllocateSecondaryBuffer(AsyncEngineContext,
                                                      PathNameLengthInBytes);
        if (PathName == NULL) {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: ERROR: MRxDAVFormatUserModeQueryDirectoryRequest/"
                         "UMRxAllocateSecondaryBuffer. NtStatus = %08lx.\n",
                         PsGetCurrentThreadId(), NtStatus));
            goto EXIT_THE_FUNCTION;
        }

        QueryDirRequest->PathName = (PWCHAR)PathName;
        
        RtlZeroMemory(QueryDirRequest->PathName, PathNameLengthInBytes);
        
        //
        // Copy the NetRootName.
        //
        RtlCopyMemory(PathName, JustTheNetRootName, NetRootNameLengthInBytes);

        //
        // Copy the backclash.
        //
        RtlCopyMemory( (PathName + NetRootNameLengthInBytes), L"\\", sizeof(WCHAR) );
        
        //
        // If PName is not NULL, we need to copy the remaining name and then
        // the template name.
        //
        if (PName) {
            
            RtlCopyMemory( ( PathName + NetRootNameLengthInBytes + sizeof(WCHAR) ),
                           SrvOpen->pAlreadyPrefixedName->Buffer,
                           SrvOpen->pAlreadyPrefixedName->Length);
            
            if (trailingSlash) {
                RtlCopyMemory( (PathName + NetRootNameLengthInBytes + 
                                sizeof(WCHAR) + SrvOpen->pAlreadyPrefixedName->Length),
                               Template->Buffer, 
                               Template->Length );
            } else {
                RtlCopyMemory( (PathName + NetRootNameLengthInBytes + sizeof(WCHAR) 
                                + SrvOpen->pAlreadyPrefixedName->Length), 
                               L"\\", 
                               sizeof(WCHAR) );
                RtlCopyMemory( ( PathName + NetRootNameLengthInBytes + sizeof(WCHAR) 
                                 + SrvOpen->pAlreadyPrefixedName->Length + sizeof(WCHAR) ), 
                               Template->Buffer, 
                               Template->Length );
            }
        
        } else {
            //
            // A backslash has already been copied after the NetRootName.
            //
            RtlCopyMemory( ( PathName + NetRootNameLengthInBytes + sizeof(WCHAR) ), 
                           Template->Buffer, 
                           Template->Length );
        }

        QueryDirRequest->NoWildCards = TRUE;
    
    }

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVFormatUserModeQueryDirectoryRequest. PathName ="
                 " %ws\n", PsGetCurrentThreadId(), PathName));

    //
    // Set the LogonID stored in the Dav V_NET_ROOT. This value is used in the
    // user mode.
    //
    QueryDirRequest->LogonID.LowPart  = DavVNetRoot->LogonID.LowPart;
    QueryDirRequest->LogonID.HighPart = DavVNetRoot->LogonID.HighPart;

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVFormatUserModeQueryDirectoryRequest. DavVNetRoot"
                 " = %08lx\n", PsGetCurrentThreadId(), DavVNetRoot));
    
    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVFormatUserModeQueryDirectoryRequest. LogonID.LowPart"
                 " = %08lx\n", PsGetCurrentThreadId(), DavVNetRoot->LogonID.LowPart));
    
    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVFormatUserModeQueryDirectoryRequest. LogonID.HighPart"
                 " = %08lx\n", PsGetCurrentThreadId(), DavVNetRoot->LogonID.HighPart));
    
IMPERSONATE_AND_EXIT:

    SecurityClientContext = &(DavVNetRoot->SecurityClientContext); 
    
    //
    // Impersonate the client who initiated the request. If we fail to 
    // impersonate, tough luck.
    //
    if (SecurityClientContext != NULL) {
        NtStatus = UMRxImpersonateClient(SecurityClientContext, WorkItemHeader);
        if (!NT_SUCCESS(NtStatus)) {
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: ERROR: MRxDAVFormatUserModeQueryDirectoryRequest/"
                         "UMRxImpersonateClient. NtStatus = %08lx.\n", 
                         PsGetCurrentThreadId(), NtStatus));
        }   
    } else {
        NtStatus = STATUS_INVALID_PARAMETER;
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: ERROR: MRxDAVFormatUserModeQueryDirectoryRequest: "
                     "SecurityClientContext is NULL.\n", 
                     PsGetCurrentThreadId()));
    }

EXIT_THE_FUNCTION:

    DavDbgTrace(DAV_TRACE_ENTRYEXIT,
                ("%ld: Leaving MRxDAVFormatUserModeQueryDirectoryRequest with "
                 "NtStatus = %08lx.\n", PsGetCurrentThreadId(), NtStatus));

    return(NtStatus);
}


BOOL
MRxDAVPrecompleteUserModeQueryDirectoryRequest(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE,
    PUMRX_USERMODE_WORKITEM_HEADER WorkItemHeader,
    ULONG WorkItemLength,
    BOOL OperationCancelled
    )
/*++

Routine Description:

    The precompletion routine for the create SrvCall request.

Arguments:

    RxContext - The RDBSS context.
    
    AsyncEngineContext - The reflctor's context.
    
    WorkItem - The work item buffer.
    
    WorkItemLength - The length of the work item buffer.

    OperationCancelled - TRUE if this operation was cancelled by the user.

Return Value:

    TRUE - UMRxAsyncEngineCalldownIrpCompletion is called by the function
           UMRxCompleteUserModeRequest after we return.    

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PDAV_USERMODE_QUERYDIR_REQUEST QueryDirRequest = NULL;
    PDAV_USERMODE_QUERYDIR_RESPONSE QueryDirResponse = NULL;
    PDAV_USERMODE_WORKITEM DavWorkItem = NULL;
    PFILE_NAMES_INFORMATION FileNamesInfo = NULL;
    PFILE_DIRECTORY_INFORMATION FileDirInfo = NULL;
    PFILE_FULL_DIR_INFORMATION FileFullDirInfo = NULL;
    PFILE_BOTH_DIR_INFORMATION FileBothDirInfo = NULL;
    FILE_INFORMATION_CLASS FileInformationClass;
    PBYTE Buffer = NULL;
    BOOL SingleEntry, InitialQuery, IndexSpecified, EndOfBuffer = FALSE;
    BOOLEAN ReturnVal, RestartScan, NoWildCards = FALSE, AsyncOperation = FALSE;
    ULONG FileIndex, BufferLength, BufferLengthUsed = 0, NextEntryOffset = 0;
    PUNICODE_STRING Template = NULL;
    UNICODE_STRING UnicodeFileName;
    PDAV_FILE_ATTRIBUTES DavFileAttributes = NULL, TempDFA = NULL;
    PLIST_ENTRY listEntry = NULL;
    PWEBDAV_FOBX DavFobx = NULL;
    PVOID PreviousBlock = NULL;
    FILE_BASIC_INFORMATION BasicInfo;
    FILE_STANDARD_INFORMATION StandardInfo;
    UNICODE_STRING CacheName;
    PUNICODE_STRING DirectoryName = NULL;
    RxCaptureFobx;

    PAGED_CODE();

    DavDbgTrace(DAV_TRACE_ENTRYEXIT,
                ("%ld: Entering MRxDAVPrecompleteUserModeQueryDirectoryRequest.\n",
                 PsGetCurrentThreadId()));

    DavDbgTrace(DAV_TRACE_CONTEXT,
                ("%ld: MRxDAVPrecompleteUserModeQueryDirectoryRequest: "
                 "AsyncEngineContext: %08lx, RxContext: %08lx.\n",
                 PsGetCurrentThreadId(), AsyncEngineContext, RxContext));

    DavWorkItem = (PDAV_USERMODE_WORKITEM)WorkItemHeader;
    
    QueryDirRequest  = &(DavWorkItem->QueryDirRequest);
    QueryDirResponse = &(DavWorkItem->QueryDirResponse);

    CacheName.Buffer = NULL;
    CacheName.Length = 0;
    CacheName.MaximumLength = 0;

    //
    // If the operation is cancelled, then there is no guarantee that the FCB,
    // FOBX etc are still valid. All that we need to do is cleanup and bail.
    //
    if (!OperationCancelled) {
        //
        // We store the DavFileAttributes in the DAV FOBX extension. These will
        // be used on subsequent calls to the Enumerate directory call.
        //
        DirectoryName = GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(RxContext);
        DavFobx = MRxDAVGetFobxExtension(capFobx);
        ASSERT(DavFobx != NULL);
    }

    if ( QueryDirRequest->AlreadyDone == FALSE ) {
    
        //
        // If the operation is cancelled, then there is no guarantee that the FCB,
        // FOBX etc are still valid. All that we need to do is cleanup and bail.
        //
        if (!OperationCancelled) {

            //
            // Get the response items only if we succeeded in the user mode and if
            // we got the properties of all the files in the directory.
            //  
            if ( AsyncEngineContext->Status == STATUS_SUCCESS && 
                 QueryDirResponse->DavFileAttributes != NULL ) {

                DavFobx->DavFileAttributes = QueryDirResponse->DavFileAttributes;

                DavFobx->NumOfFileEntries = QueryDirResponse->NumOfFileEntries;

                DavFobx->CurrentFileIndex = 0;

                DavFobx->listEntry = &(DavFobx->DavFileAttributes->NextEntry);

                DavDbgTrace(( DAV_TRACE_DETAIL | DAV_TRACE_QUERYDIR ),
                            ("%ld: MRxDAVPrecompleteUserModeQueryDirectoryRequest: "
                             "DavFileAttributes = %08lx, NumOfFileEntries = %d.\n", 
                             PsGetCurrentThreadId(), DavFobx->DavFileAttributes,
                             DavFobx->NumOfFileEntries));

            }

        } else {

            //
            // If the operation was cancelled and we allocated the
            // DavFileAttributeList in the usermode, we need to set 
            // callWorkItemCleanup to TRUE, so that it gets cleaned up.
            //
            if ( AsyncEngineContext->Status == STATUS_SUCCESS && 
                 QueryDirResponse->DavFileAttributes != NULL ) {
                DavDbgTrace(DAV_TRACE_DETAIL,
                            ("%ld: ERROR: MRxDAVPrecompleteUserModeQueryDirectoryRequest: "
                             "callWorkItemCleanup\n", PsGetCurrentThreadId()));
                DavWorkItem->callWorkItemCleanup = TRUE;
            }

        }

        //  
        // We need to free up the heaps, we allocated in the format routine.
        //
    
        if (QueryDirRequest->ServerName != NULL) {

            NtStatus = UMRxFreeSecondaryBuffer(AsyncEngineContext, 
                                               (PBYTE)QueryDirRequest->ServerName);
            if (NtStatus != STATUS_SUCCESS) {
                DavDbgTrace(DAV_TRACE_ERROR,
                            ("%ld: ERROR: MRxDAVPrecompleteUserModeQueryDirectoryRequest/"
                             "UMRxFreeSecondaryBuffer: NtStatus = %08lx.\n", 
                             PsGetCurrentThreadId(), NtStatus));
                goto EXIT_THE_FUNCTION;
            }

        }

        if (QueryDirRequest->PathName != NULL) {
    
            NtStatus = UMRxFreeSecondaryBuffer(AsyncEngineContext, 
                                               (PBYTE)QueryDirRequest->PathName);
            if (NtStatus != STATUS_SUCCESS) {
                DavDbgTrace(DAV_TRACE_ERROR,
                            ("%ld: ERROR: MRxDAVPrecompleteUserModeQueryDirectoryRequest/"
                             "UMRxFreeSecondaryBuffer: NtStatus = %08lx.\n", 
                             PsGetCurrentThreadId(), NtStatus));
                goto EXIT_THE_FUNCTION;
            }

        }
    
    }

    //
    // Before proceeding further, we need to check the following. Its very
    // important that these checks (Async and Cancel) are done before anything
    // else is done.
    //

    AsyncOperation = FlagOn(AsyncEngineContext->Flags, UMRX_ASYNCENG_CTX_FLAG_ASYNC_OPERATION);

    if (AsyncOperation) {
        //
        // If this was an Async operation then we need to remove a reference on
        // the AsyncEngineContext which was taken before it was placed on the
        // KQueue to go to the usermode. Also, the context should have one more
        // reference.
        //
        ReturnVal = UMRxFinalizeAsyncEngineContext( &(AsyncEngineContext) );
        ASSERT(!ReturnVal);
    }

    //
    // If this operation was cancelled, then all that we need to do is finalize
    // the AsyncEngineContext, if the call was Async and return FALSE. If the
    // call was sync then we don't need to finalize.
    //
    if (OperationCancelled) {
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: ERROR: MRxDAVPrecompleteUserModeQueryDirectoryRequest: "
                     "Operation Cancelled.\n", PsGetCurrentThreadId()));
        if (AsyncOperation) {
            ReturnVal = UMRxFinalizeAsyncEngineContext( &(AsyncEngineContext) );
            ASSERT(!ReturnVal);
        }
        return FALSE;
    }

    CacheName.Buffer = RxAllocatePoolWithTag(PagedPool,
                                             MAX_PATH * sizeof(WCHAR),
                                             DAV_QUERYDIR_POOLTAG);
    if (CacheName.Buffer == NULL) {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto EXIT_THE_FUNCTION;
    }

    RtlZeroMemory(CacheName.Buffer,MAX_PATH * sizeof(WCHAR));
    RtlCopyMemory(CacheName.Buffer,DirectoryName->Buffer,DirectoryName->Length);
    CacheName.Buffer[DirectoryName->Length/2] = L'\\';
    RtlCopyMemory(&CacheName.Buffer[DirectoryName->Length/2 + 1],
                  capFobx->UnicodeQueryTemplate.Buffer,
                  capFobx->UnicodeQueryTemplate.Length);
    CacheName.Length =
    CacheName.MaximumLength = DirectoryName->Length + capFobx->UnicodeQueryTemplate.Length + sizeof(WCHAR);

    NtStatus = AsyncEngineContext->Status;

    if (NtStatus != STATUS_SUCCESS) {
        //
        // We failed in the user mode.
        //
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: ERROR: MRxDAVPrecompleteUserModeQueryDirectoryRequest:"
                     "QueryDirectory failed with NtStatus = %08lx.\n", 
                     PsGetCurrentThreadId(), NtStatus));
        
        goto EXIT_THE_FUNCTION;
    }

    ASSERT(DavFobx->DavFileAttributes != NULL);

    SingleEntry = RxContext->QueryDirectory.ReturnSingleEntry;
    InitialQuery = RxContext->QueryDirectory.InitialQuery;
    RestartScan = RxContext->QueryDirectory.RestartScan;
    IndexSpecified = RxContext->QueryDirectory.IndexSpecified;
    FileIndex = RxContext->QueryDirectory.FileIndex;
    Buffer = RxContext->Info.Buffer;
    BufferLength = RxContext->Info.LengthRemaining;
    Template = &(capFobx->UnicodeQueryTemplate);
    FileInformationClass = RxContext->Info.FileInformationClass;

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVPrecompleteUserModeQueryDirectoryRequest: "
                 "FileInformationClass = %d.\n", 
                 PsGetCurrentThreadId(), FileInformationClass));
    
    //
    // Zero the buffer supplied.
    //
    RtlZeroMemory(Buffer, BufferLength);

    //
    // See, if we need to restart from the beginning.
    //
    if (RestartScan) {
        DavFobx->CurrentFileIndex = 0;
        DavFobx->listEntry = &(DavFobx->DavFileAttributes->NextEntry);
    }

    //
    // Response has a pointer to the list of DavFileAttributes.
    //
    DavFileAttributes = DavFobx->DavFileAttributes;
    listEntry = DavFobx->listEntry;

    //
    // If we have returned all the entries, inform the user that they are no 
    // more entries to return.
    //
    if ( DavFobx->CurrentFileIndex == DavFobx->NumOfFileEntries ) {
        DavDbgTrace(( DAV_TRACE_DETAIL | DAV_TRACE_QUERYDIR ),
                    ("%ld: MRxDAVPrecompleteUserModeQueryDirectoryRequest: "
                     "No more entries to return.\n", PsGetCurrentThreadId()));
        NtStatus = STATUS_NO_MORE_FILES;
        //
        // Reset the index for the next call.
        //
        DavFobx->CurrentFileIndex = 0;
        DavFobx->listEntry = &(DavFobx->DavFileAttributes->NextEntry);
        goto EXIT_THE_FUNCTION;
    }

    DavDbgTrace(( DAV_TRACE_DETAIL | DAV_TRACE_QUERYDIR ),
                ("%ld: MRxDAVPrecompleteUserModeQueryDirectoryRequest: "
                 "TLength = %d, TMaxLength = %d, Template = %wZ.\n", 
                 PsGetCurrentThreadId(), 
                 Template->Length, Template->MaximumLength, Template));

    do {

        TempDFA = CONTAINING_RECORD(listEntry, DAV_FILE_ATTRIBUTES, NextEntry);

        //
        // If this file did not come back with a 200 OK in the PROPFIND response
        // then we need to skip it. The response of a PROPFIND is a multi-status
        // with each file/directory having its own status.
        //
        if (TempDFA->InvalidNode) {
            
            listEntry = listEntry->Flink;
            
            DavFobx->listEntry = listEntry;
            
            DavFobx->CurrentFileIndex++;
            
            continue;
        }

        //
        // Check to see if the name of this entry matches the pattern supplied 
        // by the user. If it does not, then we don't need to return it.
        //
        RtlInitUnicodeString(&(UnicodeFileName), TempDFA->FileName);

        DavDbgTrace(DAV_TRACE_DETAIL,
                    ("%ld: MRxDAVPrecompleteUserModeQueryDirectoryRequest: "
                     "FileName = %ws\n", PsGetCurrentThreadId(), TempDFA->FileName));
        
        //
        // If the template does not contain any wild cards then we need to just
        // check if the unicode strings are equal. If it does contain wild cards,
        // then upcase the characters of the template and call 
        // FsRtlIsNameInExpression.
        //
        ReturnVal = FsRtlDoesNameContainWildCards(Template);

        if (ReturnVal) {

            UNICODE_STRING UpperCaseString;

            UpperCaseString.Buffer = NULL;
            UpperCaseString.Length = UpperCaseString.MaximumLength = 0;
            
            NtStatus = RtlUpcaseUnicodeString(&(UpperCaseString), Template, TRUE);
            if (NtStatus != STATUS_SUCCESS) {
                DavDbgTrace(DAV_TRACE_ERROR,
                            ("%ld: MRxDAVPrecompleteUserModeQueryDirectoryRequest:"
                             "/RtlUpcaseUnicodeString. NtStatus = %08lx.\n",
                             PsGetCurrentThreadId(), NtStatus));
                goto EXIT_THE_FUNCTION;
            }
            
            ReturnVal = FsRtlIsNameInExpression(&(UpperCaseString),
                                                &(UnicodeFileName),
                                                TRUE,
                                                FALSE);
            
            //
            // RtlUpcaseUnicodeString allocates memory for the buffer field of 
            // the UpperCaseString. We need to free it now.
            //
            RtlFreeUnicodeString( &(UpperCaseString) );
        
        } else {

            NoWildCards = TRUE;
            
            ReturnVal = RtlEqualUnicodeString(Template,
                                              &(UnicodeFileName),
                                              TRUE);
        
        }

        if (!ReturnVal) {
            //
            // This name does not match the pattern, so ignore it. Get the 
            // next listEntry.
            //
            listEntry = listEntry->Flink;
            
            DavDbgTrace(( DAV_TRACE_DETAIL | DAV_TRACE_QUERYDIR ),
                        ("%ld: MRxDAVPrecompleteUserModeQueryDirectoryRequest: "
                         "FileName %ws does not belong to pattern.\n",
                         PsGetCurrentThreadId(), TempDFA->FileName));

            DavFobx->listEntry = listEntry;
            
            DavFobx->CurrentFileIndex++;
            
            continue;
        }

        //
        // The first entry in the DavFileAttributes list is the directory being
        // enumerated. In this case NoWildCards == FALSE. We shouldn't be 
        // including this in the list of files returned. If we did a FindFirst 
        // on a particular file, then the only entry is for the file itself. In
        // this case NoWildCards == TRUE.
        //
        if ( DavFobx->CurrentFileIndex == 0 && !NoWildCards ) {
            
            listEntry = listEntry->Flink;
            
            DavFobx->listEntry = listEntry;
            
            DavFobx->CurrentFileIndex++;
            
            continue;
        }

        //
        // If we did not get any FileAttributes for this file from the server,
        // set the attribute value to FILE_ATTRIBUTE_ARCHIVE since the apps 
        // expect this.
        //
        if (TempDFA->dwFileAttributes == 0) {
            TempDFA->dwFileAttributes = FILE_ATTRIBUTE_ARCHIVE;
        }

        RtlCopyMemory(&CacheName.Buffer[DirectoryName->Length/2+1],
                      UnicodeFileName.Buffer,
                      UnicodeFileName.Length);
        CacheName.Length =
        CacheName.MaximumLength = DirectoryName->Length + UnicodeFileName.Length + sizeof(WCHAR);

        switch (FileInformationClass) {
    
        case FileNamesInformation:
        
            DavDbgTrace(DAV_TRACE_DETAIL,
                        ("%ld: MRxDAVPrecompleteUserModeQueryDirectoryRequest: "
                         "FileInformationClass = FileNamesInformation.\n",
                         PsGetCurrentThreadId()));

            //
            // Set the offset field of the previous block.
            //
            if (PreviousBlock) {
                FileNamesInfo = (PFILE_NAMES_INFORMATION)PreviousBlock;
                FileNamesInfo->NextEntryOffset = NextEntryOffset;
            }

            NextEntryOffset = sizeof(FILE_NAMES_INFORMATION);
            NextEntryOffset += ( (TempDFA->FileNameLength + 1) * sizeof(WCHAR) );
            
            //
            // We need to round up NextEntryOffset to the next multiple of 8.
            // We do this to maintain pointer alignment.
            //
            NextEntryOffset = ( ( ( NextEntryOffset + 7 ) / 8 ) * 8 );

            //
            // Is there enough space in the user supplied buffer to store the
            // next entry ? If not, we need to return now since we cannot store
            // any more entries.
            //
            if (NextEntryOffset > BufferLength) {
                DavDbgTrace(DAV_TRACE_ERROR,
                            ("%ld: MRxDAVPrecompleteUserModeQueryDirectoryRequest: "
                             "Insufficient buffer length.\n",
                             PsGetCurrentThreadId()));
                if (PreviousBlock) {
                    FileNamesInfo = (PFILE_NAMES_INFORMATION)PreviousBlock;
                    FileNamesInfo->NextEntryOffset = 0;
                }
                EndOfBuffer = TRUE;
                break;
            }
            
            FileNamesInfo = (PFILE_NAMES_INFORMATION)Buffer;
            
            //
            // The NextEntryOffset gets set on the next cycle. This way, for 
            // the last entry it will be zero.
            //
            FileNamesInfo->NextEntryOffset = 0; 
            
            FileNamesInfo->FileIndex = TempDFA->FileIndex;
            
            FileNamesInfo->FileNameLength = ( (TempDFA->FileNameLength + 1) * sizeof(WCHAR) );
            
            wcscpy(FileNamesInfo->FileName, TempDFA->FileName);

            PreviousBlock = (PVOID)FileNamesInfo;
            
            //
            // Increment the pointer to point at the next byte.
            //
            Buffer += NextEntryOffset;

            //
            // We have written "NextEntryOffset" bytes, so decrement the number
            // of bytes available pointer.
            //
            BufferLength -= NextEntryOffset;

            //
            // Increment the total number of bytes written.
            //
            BufferLengthUsed += NextEntryOffset;

            break;

        case FileDirectoryInformation:

            DavDbgTrace(DAV_TRACE_DETAIL,
                        ("%ld: MRxDAVPrecompleteUserModeQueryDirectoryRequest: "
                         "FileInformationClass = FileDirectoryInformation.\n",
                         PsGetCurrentThreadId()));

            //
            // Set the offset field of the previous block.
            //
            if (PreviousBlock) {
                FileDirInfo = (PFILE_DIRECTORY_INFORMATION)PreviousBlock;
                FileDirInfo->NextEntryOffset = NextEntryOffset;
            }

            NextEntryOffset = sizeof(FILE_DIRECTORY_INFORMATION);
            NextEntryOffset += ( (TempDFA->FileNameLength + 1) * sizeof(WCHAR) );

            //
            // We need to round up NextEntryOffset to the next multiple of 8.
            // We do this to maintain pointer alignment.
            //
            NextEntryOffset = ( ( ( NextEntryOffset + 7 ) / 8 ) * 8 );

            if (NextEntryOffset > BufferLength) {
                DavDbgTrace(DAV_TRACE_ERROR,
                            ("%ld: MRxDAVPrecompleteUserModeQueryDirectoryRequest: "
                             "Insufficient buffer length.\n",
                             PsGetCurrentThreadId()));
                if (PreviousBlock) {
                    FileDirInfo = (PFILE_DIRECTORY_INFORMATION)PreviousBlock;
                    FileDirInfo->NextEntryOffset = 0;
                }
                EndOfBuffer = TRUE;
                break;
            }

            FileDirInfo = (PFILE_DIRECTORY_INFORMATION)Buffer;

            FileDirInfo->NextEntryOffset = 0;
            
            FileDirInfo->FileIndex = TempDFA->FileIndex;
            
            FileDirInfo->CreationTime.LowPart = TempDFA->CreationTime.LowPart;
            FileDirInfo->CreationTime.HighPart = TempDFA->CreationTime.HighPart;
            
            FileDirInfo->LastAccessTime.LowPart = TempDFA->LastModifiedTime.LowPart;
            FileDirInfo->LastAccessTime.HighPart = TempDFA->LastModifiedTime.HighPart;
            
            FileDirInfo->LastWriteTime.LowPart = TempDFA->LastModifiedTime.LowPart;
            FileDirInfo->LastWriteTime.HighPart = TempDFA->LastModifiedTime.HighPart;
            
            FileDirInfo->ChangeTime.LowPart = TempDFA->LastModifiedTime.LowPart;
            FileDirInfo->ChangeTime.HighPart = TempDFA->LastModifiedTime.HighPart;

            FileDirInfo->EndOfFile.LowPart = TempDFA->FileSize.LowPart;
            FileDirInfo->EndOfFile.HighPart = TempDFA->FileSize.HighPart;

            FileDirInfo->AllocationSize.LowPart = TempDFA->FileSize.LowPart;
            FileDirInfo->AllocationSize.HighPart = TempDFA->FileSize.HighPart;

            FileDirInfo->FileAttributes = TempDFA->dwFileAttributes;

            if (TempDFA->isCollection) {
                FileDirInfo->FileAttributes |= FILE_ATTRIBUTE_DIRECTORY;
            }
            if (TempDFA->isHidden) {
                FileDirInfo->FileAttributes |= FILE_ATTRIBUTE_HIDDEN;
            }

            FileDirInfo->FileNameLength = ( (TempDFA->FileNameLength + 1) * sizeof(WCHAR) );

            wcscpy(FileDirInfo->FileName, TempDFA->FileName);
            
            PreviousBlock = (PVOID)FileDirInfo;
            
            Buffer += NextEntryOffset;

            BufferLength -= NextEntryOffset;

            BufferLengthUsed += NextEntryOffset;
            
            if (!MRxDAVIsBasicFileInfoCacheFound(RxContext,&BasicInfo,&NtStatus,&CacheName)) {
                if (TempDFA->isCollection) {
                    UNICODE_STRING DirName;

                    NtStatus = MRxDAVGetFullDirectoryPath(RxContext,&CacheName,&DirName);

                    if (DirName.Buffer != NULL) {
                        if (FileDirInfo->FileAttributes & FILE_ATTRIBUTE_ENCRYPTED) {
                            NtStatus = MRxDAVCreateEncryptedDirectoryKey(&DirName);
                        } else {
                            NtStatus = MRxDAVQueryEncryptedDirectoryKey(&DirName);

                            if (NtStatus == STATUS_SUCCESS) {
                                FileDirInfo->FileAttributes |= FILE_ATTRIBUTE_ENCRYPTED;
                            } else if (NtStatus == STATUS_OBJECT_NAME_NOT_FOUND) {
                                NtStatus = STATUS_SUCCESS;
                            }
                        }

                        // The buffer was allocated in MRxDAVGetFullDirectoryPath
                        RxFreePool(DirName.Buffer);
                    }
                    
                    if (NtStatus != STATUS_SUCCESS) {
                        goto EXIT_THE_FUNCTION;
                    }
                }

                BasicInfo.CreationTime   = FileDirInfo->CreationTime;
                BasicInfo.LastAccessTime = FileDirInfo->LastAccessTime;
                BasicInfo.LastWriteTime  = FileDirInfo->LastWriteTime;
                BasicInfo.ChangeTime     = FileDirInfo->ChangeTime;
                BasicInfo.FileAttributes = FileDirInfo->FileAttributes;

                StandardInfo.AllocationSize = FileDirInfo->AllocationSize;
                StandardInfo.EndOfFile      = FileDirInfo->EndOfFile;
                StandardInfo.NumberOfLinks  = 1;
                StandardInfo.DeletePending  = FALSE;
                StandardInfo.Directory      = TempDFA->isCollection;


                MRxDAVCreateFileInfoCacheWithName(&CacheName,
                                                  RxContext->pFcb->pNetRoot,
                                                  &BasicInfo,
                                                  &StandardInfo,
                                                  STATUS_SUCCESS);
            } else {
                if (TempDFA->isCollection && (BasicInfo.FileAttributes & FILE_ATTRIBUTE_ENCRYPTED)) {
                    FileDirInfo->FileAttributes |= FILE_ATTRIBUTE_ENCRYPTED;
                }
            }
            
            //
            // We filter the FILE_ATTRIBUTE_TEMPORARY flag since on FAT (which
            // we emulate), FindFirstFile and FindNextFile dont return
            // FILE_ATTRIBUTE_TEMPORARY flag even though GetFileAttributes
            // returns it. Hence we only filter this in the attributes that
            // are being returned in this call and not in the attributes that
            // have been saved.
            //
            FileDirInfo->FileAttributes &= ~FILE_ATTRIBUTE_TEMPORARY;

            break;

        case FileFullDirectoryInformation:

            DavDbgTrace(DAV_TRACE_DETAIL,
                        ("%ld: MRxDAVPrecompleteUserModeQueryDirectoryRequest: "
                         "FileInformationClass = FileFullDirectoryInformation.\n",
                         PsGetCurrentThreadId()));

            //
            // Set the offset field of the previous block.
            //
            if (PreviousBlock) {
                FileFullDirInfo = (PFILE_FULL_DIR_INFORMATION)PreviousBlock;
                FileFullDirInfo->NextEntryOffset = NextEntryOffset;
            }

            NextEntryOffset = sizeof(FILE_FULL_DIR_INFORMATION);
            NextEntryOffset += ( (TempDFA->FileNameLength + 1) * sizeof(WCHAR) );

            //
            // We need to round up NextEntryOffset to the next multiple of 8.
            // We do this to maintain pointer alignment.
            //
            NextEntryOffset = ( ( ( NextEntryOffset + 7 ) / 8 ) * 8 );

            if (NextEntryOffset > BufferLength) {
                DavDbgTrace(DAV_TRACE_ERROR,
                            ("%ld: MRxDAVPrecompleteUserModeQueryDirectoryRequest: "
                             "Insufficient buffer length.\n",
                             PsGetCurrentThreadId()));
                if (PreviousBlock) {
                    FileFullDirInfo = (PFILE_FULL_DIR_INFORMATION)PreviousBlock;
                    FileFullDirInfo->NextEntryOffset = 0;
                }
                EndOfBuffer = TRUE;
                break;
            }

            FileFullDirInfo = (PFILE_FULL_DIR_INFORMATION)Buffer;

            FileFullDirInfo->NextEntryOffset = 0;
            
            FileFullDirInfo->FileIndex = TempDFA->FileIndex;
            
            FileFullDirInfo->CreationTime.LowPart = TempDFA->CreationTime.LowPart;
            FileFullDirInfo->CreationTime.HighPart = TempDFA->CreationTime.HighPart;
            
            FileFullDirInfo->LastAccessTime.LowPart = TempDFA->LastModifiedTime.LowPart;
            FileFullDirInfo->LastAccessTime.HighPart = TempDFA->LastModifiedTime.HighPart;
            
            FileFullDirInfo->LastWriteTime.LowPart = TempDFA->LastModifiedTime.LowPart;
            FileFullDirInfo->LastWriteTime.HighPart = TempDFA->LastModifiedTime.HighPart;
            
            FileFullDirInfo->ChangeTime.LowPart = TempDFA->LastModifiedTime.LowPart;
            FileFullDirInfo->ChangeTime.HighPart = TempDFA->LastModifiedTime.HighPart;

            FileFullDirInfo->EndOfFile.LowPart = TempDFA->FileSize.LowPart;
            FileFullDirInfo->EndOfFile.HighPart = TempDFA->FileSize.HighPart;

            FileFullDirInfo->AllocationSize.LowPart = TempDFA->FileSize.LowPart;
            FileFullDirInfo->AllocationSize.HighPart = TempDFA->FileSize.HighPart;

            FileFullDirInfo->FileAttributes = TempDFA->dwFileAttributes;

            if (TempDFA->isCollection) {
                FileFullDirInfo->FileAttributes |= FILE_ATTRIBUTE_DIRECTORY;
            }
            if (TempDFA->isHidden) {
                FileFullDirInfo->FileAttributes |= FILE_ATTRIBUTE_HIDDEN;
            }

            FileFullDirInfo->EaSize = 0;

            FileFullDirInfo->FileNameLength = ( (TempDFA->FileNameLength + 1) * sizeof(WCHAR) );

            wcscpy(FileFullDirInfo->FileName, TempDFA->FileName);
            
            PreviousBlock = (PVOID)FileFullDirInfo;
            
            Buffer += NextEntryOffset;

            BufferLength -= NextEntryOffset;

            BufferLengthUsed += NextEntryOffset;

            if (!MRxDAVIsBasicFileInfoCacheFound(RxContext,&BasicInfo,&NtStatus,&CacheName)) {
                if (TempDFA->isCollection) {
                    UNICODE_STRING DirName;

                    NtStatus = MRxDAVGetFullDirectoryPath(RxContext,&CacheName,&DirName);

                    if (DirName.Buffer != NULL) {
                        if (FileFullDirInfo->FileAttributes & FILE_ATTRIBUTE_ENCRYPTED) {
                            NtStatus = MRxDAVCreateEncryptedDirectoryKey(&DirName);
                        } else {
                            NtStatus = MRxDAVQueryEncryptedDirectoryKey(&DirName);

                            if (NtStatus == STATUS_SUCCESS) {
                                FileFullDirInfo->FileAttributes |= FILE_ATTRIBUTE_ENCRYPTED;
                            } else if (NtStatus == STATUS_OBJECT_NAME_NOT_FOUND) {
                                NtStatus = STATUS_SUCCESS;
                            }
                        }

                        // The buffer was allocated in MRxDAVGetFullDirectoryPath
                        RxFreePool(DirName.Buffer);
                    }
                    
                    if (NtStatus != STATUS_SUCCESS) {
                        goto EXIT_THE_FUNCTION;
                    }
                }
                
                BasicInfo.CreationTime   = FileFullDirInfo->CreationTime;
                BasicInfo.LastAccessTime = FileFullDirInfo->LastAccessTime;
                BasicInfo.LastWriteTime  = FileFullDirInfo->LastWriteTime;
                BasicInfo.ChangeTime     = FileFullDirInfo->ChangeTime;
                BasicInfo.FileAttributes = FileFullDirInfo->FileAttributes;
    
                StandardInfo.AllocationSize = FileFullDirInfo->AllocationSize;
                StandardInfo.EndOfFile      = FileFullDirInfo->EndOfFile;
                StandardInfo.NumberOfLinks  = 1;
                StandardInfo.DeletePending  = FALSE;
                StandardInfo.Directory      = TempDFA->isCollection;
    
                MRxDAVCreateFileInfoCacheWithName(&CacheName,
                                                  RxContext->pFcb->pNetRoot,
                                                  &BasicInfo,
                                                  &StandardInfo,
                                                  STATUS_SUCCESS);
            } else {
                if (TempDFA->isCollection && (BasicInfo.FileAttributes & FILE_ATTRIBUTE_ENCRYPTED)) {
                    FileFullDirInfo->FileAttributes |= FILE_ATTRIBUTE_ENCRYPTED;
                }
            }

            //
            // We filter the FILE_ATTRIBUTE_TEMPORARY flag since on FAT (which
            // we emulate), FindFirstFile and FindNextFile dont return
            // FILE_ATTRIBUTE_TEMPORARY flag even though GetFileAttributes
            // returns it. Hence we only filter this in the attributes that
            // are being returned in this call and not in the attributes that
            // have been saved.
            //
            FileFullDirInfo->FileAttributes &= ~FILE_ATTRIBUTE_TEMPORARY;

            break;

        case FileBothDirectoryInformation:

            DavDbgTrace(DAV_TRACE_DETAIL,
                        ("%ld: MRxDAVPrecompleteUserModeQueryDirectoryRequest: "
                         "FileInformationClass = FileBothDirectoryInformation.\n",
                         PsGetCurrentThreadId()));

            //
            // Set the offset field of the previous block.
            //
            if (PreviousBlock) {
                FileBothDirInfo = (PFILE_BOTH_DIR_INFORMATION)PreviousBlock;
                FileBothDirInfo->NextEntryOffset = NextEntryOffset;
            }

            NextEntryOffset = sizeof(FILE_BOTH_DIR_INFORMATION);
            NextEntryOffset += ( (TempDFA->FileNameLength + 1) * sizeof(WCHAR) );

            //
            // We need to round up NextEntryOffset to the next multiple of 8.
            // We do this to maintain pointer alignment.
            //
            NextEntryOffset = ( ( ( NextEntryOffset + 7 ) / 8 ) * 8 );

            if (NextEntryOffset > BufferLength) {
                DavDbgTrace(DAV_TRACE_ERROR,
                            ("%ld: MRxDAVPrecompleteUserModeQueryDirectoryRequest:"
                             " Insufficient buffer length.\n",
                             PsGetCurrentThreadId()));
                if (PreviousBlock) {
                    FileBothDirInfo = (PFILE_BOTH_DIR_INFORMATION)PreviousBlock;
                    FileBothDirInfo->NextEntryOffset = 0;
                }
                EndOfBuffer = TRUE;
                break;
            }

            FileBothDirInfo = (PFILE_BOTH_DIR_INFORMATION)Buffer;

            FileBothDirInfo->NextEntryOffset = 0;
            
            FileBothDirInfo->FileIndex = TempDFA->FileIndex;
            
            FileBothDirInfo->CreationTime.LowPart = TempDFA->CreationTime.LowPart;
            FileBothDirInfo->CreationTime.HighPart = TempDFA->CreationTime.HighPart;
            
            FileBothDirInfo->LastAccessTime.LowPart = TempDFA->LastModifiedTime.LowPart;
            FileBothDirInfo->LastAccessTime.HighPart = TempDFA->LastModifiedTime.HighPart;
            
            FileBothDirInfo->LastWriteTime.LowPart = TempDFA->LastModifiedTime.LowPart;
            FileBothDirInfo->LastWriteTime.HighPart = TempDFA->LastModifiedTime.HighPart;
            
            FileBothDirInfo->ChangeTime.LowPart = TempDFA->LastModifiedTime.LowPart;
            FileBothDirInfo->ChangeTime.HighPart = TempDFA->LastModifiedTime.HighPart;

            FileBothDirInfo->EndOfFile.LowPart = TempDFA->FileSize.LowPart;
            FileBothDirInfo->EndOfFile.HighPart = TempDFA->FileSize.HighPart;

            FileBothDirInfo->AllocationSize.LowPart = TempDFA->FileSize.LowPart;
            FileBothDirInfo->AllocationSize.HighPart = TempDFA->FileSize.HighPart;
            
            FileBothDirInfo->FileAttributes = TempDFA->dwFileAttributes;

            if (TempDFA->isCollection) {
                FileBothDirInfo->FileAttributes |= FILE_ATTRIBUTE_DIRECTORY;
            }
            if (TempDFA->isHidden) {
                FileBothDirInfo->FileAttributes |= FILE_ATTRIBUTE_HIDDEN;
            }

            FileBothDirInfo->EaSize = 0;

            //
            // We don't support short file names. We add L'\0' as the first
            // character in the ShortName string to make it a zero length name.
            //
            FileBothDirInfo->ShortNameLength = 0;
            FileBothDirInfo->ShortName[0] = L'\0';

            FileBothDirInfo->FileNameLength = ( (TempDFA->FileNameLength + 1) * sizeof(WCHAR) );

            wcscpy(FileBothDirInfo->FileName, TempDFA->FileName);
            
            PreviousBlock = (PVOID)FileBothDirInfo;
            
            Buffer += NextEntryOffset;

            BufferLength -= NextEntryOffset;

            BufferLengthUsed += NextEntryOffset;

            if (!MRxDAVIsBasicFileInfoCacheFound(RxContext,&BasicInfo,&NtStatus,&CacheName)) {
                if (TempDFA->isCollection) {
                    UNICODE_STRING DirName;

                    NtStatus = MRxDAVGetFullDirectoryPath(RxContext,&CacheName,&DirName);

                    if (DirName.Buffer != NULL) {
                        if (FileBothDirInfo->FileAttributes & FILE_ATTRIBUTE_ENCRYPTED) {
                            NtStatus = MRxDAVCreateEncryptedDirectoryKey(&DirName);
                        } else {
                            NtStatus = MRxDAVQueryEncryptedDirectoryKey(&DirName);

                            if (NtStatus == STATUS_SUCCESS) {
                                FileBothDirInfo->FileAttributes |= FILE_ATTRIBUTE_ENCRYPTED;
                            } else if (NtStatus == STATUS_OBJECT_NAME_NOT_FOUND) {
                                NtStatus = STATUS_SUCCESS;
                            }
                        }

                        // The buffer was allocated in MRxDAVGetFullDirectoryPath
                        RxFreePool(DirName.Buffer);
                    }

                    if (NtStatus != STATUS_SUCCESS) {
                        goto EXIT_THE_FUNCTION;
                    }
                }
                
                BasicInfo.CreationTime   = FileBothDirInfo->CreationTime;
                BasicInfo.LastAccessTime = FileBothDirInfo->LastAccessTime;
                BasicInfo.LastWriteTime  = FileBothDirInfo->LastWriteTime;
                BasicInfo.ChangeTime     = FileBothDirInfo->ChangeTime;
                BasicInfo.FileAttributes = FileBothDirInfo->FileAttributes;
    
                StandardInfo.AllocationSize = FileBothDirInfo->AllocationSize;
                StandardInfo.EndOfFile      = FileBothDirInfo->EndOfFile;
                StandardInfo.NumberOfLinks  = 1;
                StandardInfo.DeletePending  = FALSE;
                StandardInfo.Directory      = TempDFA->isCollection;
    
                MRxDAVCreateFileInfoCacheWithName(&CacheName,
                                                  RxContext->pFcb->pNetRoot,
                                                  &BasicInfo,
                                                  &StandardInfo,
                                                  STATUS_SUCCESS);
            } else {
                if (TempDFA->isCollection && (BasicInfo.FileAttributes & FILE_ATTRIBUTE_ENCRYPTED)) {
                    FileBothDirInfo->FileAttributes |= FILE_ATTRIBUTE_ENCRYPTED;
                }
            }

            //
            // We filter the FILE_ATTRIBUTE_TEMPORARY flag since on FAT (which
            // we emulate), FindFirstFile and FindNextFile dont return
            // FILE_ATTRIBUTE_TEMPORARY flag even though GetFileAttributes
            // returns it. Hence we only filter this in the attributes that
            // are being returned in this call and not in the attributes that
            // have been saved.
            //
            FileBothDirInfo->FileAttributes &= ~FILE_ATTRIBUTE_TEMPORARY;

            break;

        default:

            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: MRxDAVPrecompleteUserModeQueryDirectoryRequest: "
                         "FileInformationClass = UnKnown(%d).\n",
                         PsGetCurrentThreadId(), FileInformationClass));

            NtStatus = STATUS_NOT_SUPPORTED;
            goto EXIT_THE_FUNCTION;

            break;

        } // end of switch(FileInformationClass)

        //
        // If the user supplied buffer is not enough to store any more 
        // information, we are done. This check should be done before
        // changing the values below.
        //        
        if (EndOfBuffer) {
            NtStatus = STATUS_SUCCESS;
            break;
        }

        //
        // These values should be changed after the "EndOfBuffer" check and 
        // before the "SingleEntry" check.
        //

        listEntry = listEntry->Flink;

        DavFobx->listEntry = listEntry;

        DavFobx->CurrentFileIndex++;
    
        //
        // If the user only asked for a single entry, we are done. This check 
        // should be done, after changing the values above.
        //
        if (SingleEntry) {
            break;
        }

    } while ( listEntry != &(DavFileAttributes->NextEntry) );

    //
    // If we have gone through all the entries and the BufferLengthUsed is 0,
    // then we need to return
    //
    if ( BufferLengthUsed == 0 && listEntry == &(DavFileAttributes->NextEntry) ) {
        NtStatus = STATUS_NO_MORE_FILES;
        //
        // Reset the index for the next call.
        //
        DavFobx->CurrentFileIndex = 0;
        DavFobx->listEntry = &(DavFobx->DavFileAttributes->NextEntry);
        goto EXIT_THE_FUNCTION;
    }

    RxContext->Info.LengthRemaining -= BufferLengthUsed;
    
    DavDbgTrace(DAV_TRACE_ENTRYEXIT,
                ("%ld: Leaving MRxDAVPrecompleteUserModeQueryDirectoryRequest.\n",
                 PsGetCurrentThreadId()));
    
EXIT_THE_FUNCTION:

    AsyncEngineContext->Status = NtStatus;

    if (CacheName.Buffer != NULL) {
        RxFreePool(CacheName.Buffer);
    }

    return(TRUE);
}


NTSTATUS
MRxDAVQueryDirectoryFromCache(
    IN PRX_CONTEXT RxContext,
    IN PBYTE Buffer,
    IN PFILE_BASIC_INFORMATION BasicInfo,
    IN PFILE_STANDARD_INFORMATION StandardInfo,
    IN ULONG FileIndex
    )
/*++

Routine Description:

    The precompletion routine for the create SrvCall request.

Arguments:

    RxContext - The RDBSS context.
    
    AsyncEngineContext - The reflctor's context.
    
    WorkItem - The work item buffer.
    
    WorkItemLength - The length of the work item buffer.

Return Value:

    TRUE or FALSE.

--*/
{
    RxCaptureFobx;
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PFILE_NAMES_INFORMATION FileNamesInfo = NULL;
    PFILE_DIRECTORY_INFORMATION FileDirInfo = NULL;
    PFILE_FULL_DIR_INFORMATION FileFullDirInfo = NULL;
    PFILE_BOTH_DIR_INFORMATION FileBothDirInfo = NULL;
    ULONG BufferLength;
    PUNICODE_STRING FileName = &capFobx->UnicodeQueryTemplate;
    ULONG SpaceNeeded = 0;

    PAGED_CODE();

    BufferLength = RxContext->Info.LengthRemaining;
    SpaceNeeded = FileName->Length;
    
    switch (RxContext->Info.FileInformationClass) {
    
    case FileNamesInformation:
    
        DavDbgTrace(DAV_TRACE_DETAIL,
                    ("%ld: MRxDAVQueryDirectoryFromCache: "
                     "FileInformationClass = FileNamesInformation.\n",
                     PsGetCurrentThreadId()));

        SpaceNeeded += sizeof(FILE_NAMES_INFORMATION);
        
        //
        // Is there enough space in the user supplied buffer to store the
        // next entry ? If not, we need to return now since we cannot store
        // any more entries.
        //
        if (SpaceNeeded > BufferLength) {
            NtStatus = STATUS_BUFFER_OVERFLOW;
            goto EXIT_THE_FUNCTION;
        }

        FileNamesInfo = (PFILE_NAMES_INFORMATION)Buffer;
        
        FileNamesInfo->NextEntryOffset = 0; 
        FileNamesInfo->FileIndex = FileIndex;
        FileNamesInfo->FileNameLength = FileName->Length;
        RtlCopyMemory(FileNamesInfo->FileName,FileName->Buffer,FileName->Length);
        
        break;

    case FileDirectoryInformation:

        DavDbgTrace(DAV_TRACE_DETAIL,
                    ("%ld: MRxDAVQueryDirectoryFromCache: "
                     "FileInformationClass = FileDirectoryInformation.\n",
                     PsGetCurrentThreadId()));

        SpaceNeeded += sizeof(FILE_DIRECTORY_INFORMATION);

        if (SpaceNeeded > BufferLength) {
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: MRxDAVQueryDirectoryFromCache: "
                         "Insufficient buffer length.\n",
                         PsGetCurrentThreadId()));
            NtStatus = STATUS_BUFFER_OVERFLOW;
            goto EXIT_THE_FUNCTION;
        }

        FileDirInfo = (PFILE_DIRECTORY_INFORMATION)Buffer;
        FileDirInfo->NextEntryOffset = 0;
        FileDirInfo->FileIndex = FileIndex;
        
        FileDirInfo->CreationTime.QuadPart   = BasicInfo->CreationTime.QuadPart;
        FileDirInfo->LastAccessTime.QuadPart = BasicInfo->LastAccessTime.QuadPart;
        FileDirInfo->LastWriteTime.QuadPart  = BasicInfo->LastWriteTime.QuadPart;
        FileDirInfo->ChangeTime.QuadPart     = BasicInfo->ChangeTime.QuadPart;
        FileDirInfo->FileAttributes          = BasicInfo->FileAttributes;

        //
        // We filter the FILE_ATTRIBUTE_TEMPORARY flag since on FAT (which
        // we emulate), FindFirstFile and FindNextFile dont return
        // FILE_ATTRIBUTE_TEMPORARY flag even though GetFileAttributes
        // returns it. Hence we only filter this in the attributes that
        // are being returned in this call and not in the attributes that
        // have been saved.
        //
        FileDirInfo->FileAttributes &= ~FILE_ATTRIBUTE_TEMPORARY;

        FileDirInfo->EndOfFile.QuadPart      = StandardInfo->EndOfFile.QuadPart;
        FileDirInfo->AllocationSize.QuadPart = StandardInfo->AllocationSize.QuadPart;

        FileDirInfo->FileNameLength = FileName->Length;
        RtlCopyMemory(FileDirInfo->FileName,FileName->Buffer,FileName->Length);
        
        break;

    case FileFullDirectoryInformation:

        DavDbgTrace(DAV_TRACE_DETAIL,
                    ("%ld: MRxDAVQueryDirectoryFromCache: "
                     "FileInformationClass = FileFullDirectoryInformation.\n",
                     PsGetCurrentThreadId()));

        SpaceNeeded += sizeof(FILE_FULL_DIR_INFORMATION);

        if (SpaceNeeded > BufferLength) {
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: MRxDAVQueryDirectoryFromCache: "
                         "Insufficient buffer length.\n",
                         PsGetCurrentThreadId()));
            NtStatus = STATUS_BUFFER_OVERFLOW;
            goto EXIT_THE_FUNCTION;
        }
        

        FileFullDirInfo = (PFILE_FULL_DIR_INFORMATION)Buffer;

        FileFullDirInfo->NextEntryOffset = 0;
        FileFullDirInfo->FileIndex = FileIndex;
        
        FileFullDirInfo->CreationTime.QuadPart   = BasicInfo->CreationTime.QuadPart;
        FileFullDirInfo->LastAccessTime.QuadPart = BasicInfo->LastAccessTime.QuadPart;
        FileFullDirInfo->LastWriteTime.QuadPart  = BasicInfo->LastWriteTime.QuadPart;
        FileFullDirInfo->ChangeTime.QuadPart     = BasicInfo->ChangeTime.QuadPart;
        FileFullDirInfo->FileAttributes          = BasicInfo->FileAttributes;

        //
        // We filter the FILE_ATTRIBUTE_TEMPORARY flag since on FAT (which
        // we emulate), FindFirstFile and FindNextFile dont return
        // FILE_ATTRIBUTE_TEMPORARY flag even though GetFileAttributes
        // returns it. Hence we only filter this in the attributes that
        // are being returned in this call and not in the attributes that
        // have been saved.
        //
        FileFullDirInfo->FileAttributes &= ~FILE_ATTRIBUTE_TEMPORARY;

        FileFullDirInfo->EndOfFile.QuadPart      = StandardInfo->EndOfFile.QuadPart;
        FileFullDirInfo->AllocationSize.QuadPart = StandardInfo->AllocationSize.QuadPart;

        FileFullDirInfo->EaSize = 0;

        FileFullDirInfo->FileNameLength = FileName->Length;
        RtlCopyMemory(FileFullDirInfo->FileName,FileName->Buffer,FileName->Length);
        
        break;

    case FileBothDirectoryInformation:

        DavDbgTrace(DAV_TRACE_DETAIL,
                    ("%ld: MRxDAVQueryDirectoryFromCache: "
                     "FileInformationClass = FileBothDirectoryInformation.\n",
                     PsGetCurrentThreadId()));

        SpaceNeeded += sizeof(FILE_BOTH_DIR_INFORMATION);

        if (SpaceNeeded > BufferLength) {
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: MRxDAVQueryDirectoryFromCache: "
                         "Insufficient buffer length.\n",
                         PsGetCurrentThreadId()));
            NtStatus = STATUS_BUFFER_OVERFLOW;
            goto EXIT_THE_FUNCTION;
        }
        

        FileBothDirInfo = (PFILE_BOTH_DIR_INFORMATION)Buffer;

        FileBothDirInfo->NextEntryOffset = 0;
        FileBothDirInfo->FileIndex = FileIndex;
        
        FileBothDirInfo->CreationTime.QuadPart   = BasicInfo->CreationTime.QuadPart;
        FileBothDirInfo->LastAccessTime.QuadPart = BasicInfo->LastAccessTime.QuadPart;
        FileBothDirInfo->LastWriteTime.QuadPart  = BasicInfo->LastWriteTime.QuadPart;
        FileBothDirInfo->ChangeTime.QuadPart     = BasicInfo->ChangeTime.QuadPart;
        FileBothDirInfo->FileAttributes          = BasicInfo->FileAttributes;

        //
        // We filter the FILE_ATTRIBUTE_TEMPORARY flag since on FAT (which
        // we emulate), FindFirstFile and FindNextFile dont return
        // FILE_ATTRIBUTE_TEMPORARY flag even though GetFileAttributes
        // returns it. Hence we only filter this in the attributes that
        // are being returned in this call and not in the attributes that
        // have been saved.
        //
        FileBothDirInfo->FileAttributes &= ~FILE_ATTRIBUTE_TEMPORARY;

        FileBothDirInfo->EndOfFile.QuadPart      = StandardInfo->EndOfFile.QuadPart;
        FileBothDirInfo->AllocationSize.QuadPart = StandardInfo->AllocationSize.QuadPart;

        FileBothDirInfo->EaSize = 0;

        //
        // We don't support short file names. We add L'\0' as the first
        // character in the ShortName string to make it a zero length name.
        //
        FileBothDirInfo->ShortNameLength = 0;
        FileBothDirInfo->ShortName[0] = L'\0';
        
        FileBothDirInfo->FileNameLength = FileName->Length;
        RtlCopyMemory(FileBothDirInfo->FileName,FileName->Buffer,FileName->Length);
        
        break;

    default:

        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: MRxDAVQueryDirectoryFromCache: "
                     "FileInformationClass = UnKnown(%d).\n",
                     PsGetCurrentThreadId(), RxContext->Info.FileInformationClass));

        NtStatus = STATUS_NOT_SUPPORTED;
        goto EXIT_THE_FUNCTION;

        break;

    } // end of switch(FileInformationClass)

    RxContext->Info.LengthRemaining -= SpaceNeeded;

EXIT_THE_FUNCTION:

    return NtStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\kernel\read.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    read.c

Abstract:

    This module implements the DAV miniredir call down routines pertaining to 
    "read" of file system objects.

Author:

    Balan Sethu Raman      [SethuR]
    
    Rohan Kumar            [RohanK]     04-April-1999

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include "webdav.h"

//
// Mentioned below are the prototypes of functions tht are used only within
// this module (file). These functions should not be exposed outside.
//

NTSTATUS
MRxDAVReadContinuation(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, MRxDAVRead)
#pragma alloc_text(PAGE, MRxDAVReadContinuation)
#pragma alloc_text(PAGE, MRxDAVFastIoRead)
#pragma alloc_text(PAGE, DavReadWriteFileEx)
#endif

//
// Implementation of functions begins here.
//

NTSTATUS
MRxDAVRead(
    IN PRX_CONTEXT RxContext
    )
/*++

Routine Description:

   This routine handles network read requests.

Arguments:

    RxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    PAGED_CODE();

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Entering MRxDAVRead!!!!\n", PsGetCurrentThreadId()));

    DavDbgTrace(DAV_TRACE_CONTEXT,
                ("%ld: MRxDAVRead: RxContext: %08lx\n", 
                 PsGetCurrentThreadId(), RxContext));

    NtStatus = UMRxAsyncEngOuterWrapper(RxContext,
                                        SIZEOF_DAV_SPECIFIC_CONTEXT,
                                        MRxDAVFormatTheDAVContext,
                                        DAV_MINIRDR_ENTRY_FROM_READ,
                                        MRxDAVReadContinuation,
                                        "MRxDAVRead");

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Leaving MRxDAVRead with NtStatus = %08lx.\n", 
                 PsGetCurrentThreadId(), NtStatus));

    return(NtStatus);
}


NTSTATUS
MRxDAVReadContinuation(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE
    )
/*++

Routine Description:

    This is the continuation routine for read operation.

Arguments:

    AsyncEngineContext - The exchange to be conducted.

    RxContext - The RDBSS context.
    
Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PWEBDAV_CONTEXT DavContext = NULL;
    PLOWIO_CONTEXT LowIoContext = NULL;
    LARGE_INTEGER ByteOffset = {0,0}, AlignedOffset = {0,0};
    ULONG ByteCount = 0, ByteOffsetMisAlignment = 0, LengthRead = 0;
    ULONG TotalLengthActuallyRead = 0, BytesToCopy = 0;
    PIRP TopIrp = NULL;
    BOOLEAN  SynchronousIo = FALSE, PagingIo = FALSE, readLessThanAsked = FALSE;
    PWEBDAV_SRV_OPEN davSrvOpen = NULL;
    IO_STATUS_BLOCK IoStatusBlock;
    PBYTE AllocatedSideBuffer = NULL, UserBuffer = NULL;
    
    PAGED_CODE();    
    
    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Entering MRxDAVReadContinuation.\n", PsGetCurrentThreadId()));

    DavDbgTrace(DAV_TRACE_CONTEXT,
                ("%ld: AsyncEngineContext: %08lx, RxContext: %08lx.\n", 
                 PsGetCurrentThreadId(), AsyncEngineContext, RxContext));

    ASSERT_ASYNCENG_CONTEXT(AsyncEngineContext);

    //
    // We want to keep the AsyncEngineContext alive while we are doing this read 
    // operation. The reference is taken away when we leave this function. 
    //
    InterlockedIncrement( &(AsyncEngineContext->NodeReferenceCount) );

    DavContext = (PWEBDAV_CONTEXT)AsyncEngineContext;

    LowIoContext = &(RxContext->LowIoContext);
    ASSERT(LowIoContext != NULL);

    ByteOffset.QuadPart = LowIoContext->ParamsFor.ReadWrite.ByteOffset;

    //
    // If the bytecount is zero then we can return right away. We don't need to
    // do any further processing.
    //
    ByteCount = LowIoContext->ParamsFor.ReadWrite.ByteCount;
    
    UserBuffer = RxLowIoGetBufferAddress(RxContext);

    PagingIo = BooleanFlagOn(LowIoContext->ParamsFor.ReadWrite.Flags, LOWIO_READWRITEFLAG_PAGING_IO);
    
    SynchronousIo = !BooleanFlagOn(RxContext->Flags, RX_CONTEXT_FLAG_ASYNC_OPERATION);

    davSrvOpen = MRxDAVGetSrvOpenExtension(RxContext->pRelevantSrvOpen);
    ASSERT(davSrvOpen->UnderlyingHandle != NULL);
    ASSERT(davSrvOpen->UnderlyingFileObject != NULL);
    ASSERT(davSrvOpen->UnderlyingDeviceObject != NULL);

    if ( davSrvOpen->UnderlyingHandle == NULL      ||
         davSrvOpen->UnderlyingFileObject == NULL  ||
         davSrvOpen->UnderlyingDeviceObject == NULL ) {
        NtStatus = STATUS_INVALID_PARAMETER;
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: MRxDAVReadContinuation. Invalid davSrvOpen\n",
                     PsGetCurrentThreadId()));
        goto EXIT_THE_FUNCTION;
    }

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVReadContinuation. FileName = %wZ, PagingIo = %d, SynchronousIo = %d"
                 ", ByteOffset.HighPart = %d, ByteOffset.LowPart = %d, ByteCount = %d\n",
                 PsGetCurrentThreadId(), RxContext->pRelevantSrvOpen->pAlreadyPrefixedName,
                 PagingIo, SynchronousIo, ByteOffset.HighPart, ByteOffset.LowPart,
                 ByteCount));

    if (PagingIo) {

        ASSERT(RxContext->CurrentIrp->MdlAddress != NULL);
        if (RxContext->CurrentIrp->MdlAddress == NULL) {
            DbgPrint("%ld: MRxDAVReadContinuation: MdlAddress == NULL\n", PsGetCurrentThreadId());
            DbgBreakPoint();
        }

        BytesToCopy = ( (ByteCount >> PAGE_SHIFT) << PAGE_SHIFT );

        DavDbgTrace(DAV_TRACE_DETAIL,
                    ("%ld: MRxDAVReadContinuation(0). ByteCount = %d, BytesToCopy = %d\n",
                     PsGetCurrentThreadId(), ByteCount, BytesToCopy));

        if (BytesToCopy > 0) {

            LengthRead = DavReadWriteFileEx(DAV_MJ_READ,
                                            FALSE,
                                            TRUE,
                                            RxContext->CurrentIrp->MdlAddress,
                                            davSrvOpen->UnderlyingDeviceObject,
                                            davSrvOpen->UnderlyingFileObject,
                                            ByteOffset.QuadPart,
                                            MmGetMdlBaseVa(RxContext->CurrentIrp->MdlAddress),
                                            BytesToCopy,
                                            &(IoStatusBlock));

            NtStatus = IoStatusBlock.Status;

            if (NtStatus != STATUS_SUCCESS) {
                DavDbgTrace(DAV_TRACE_ERROR,
                            ("%ld: MRxDAVReadContinuation/DavReadWriteFileEx(0). "
                             "NtStatus = %08lx\n", PsGetCurrentThreadId(), NtStatus));
                goto EXIT_THE_FUNCTION;
            }

            //
            // Add the actual bytes read to the TotalLengthActuallyRead.
            //
            TotalLengthActuallyRead += LengthRead;

            //
            // If LengthRead < BytesToCopy, it implies that the filesize of the
            // underlying file is less than the data being read. In such a case,
            // we return right away since we have already read whatever we could.
            //
            if (LengthRead < BytesToCopy) {
                DavDbgTrace(DAV_TRACE_DETAIL,
                            ("%ld: MRxDAVReadContinuation. LengthRead < BytesToCopy\n",
                             PsGetCurrentThreadId()));
                goto EXIT_THE_FUNCTION;
            }

        }

        //
        // If we have already written out the required number of bytes (which
        // means BytesToCopy == ByteCount), then we are done and can exit now.
        //
        if (BytesToCopy == ByteCount) {
            DavDbgTrace(DAV_TRACE_DETAIL,
                        ("%ld: MRxDAVReadContinuation. BytesToCopy == ByteCount(0)\n",
                         PsGetCurrentThreadId()));
            goto EXIT_THE_FUNCTION;
        }

        //
        // Decrement the ByteCount by the number of bytes that have been copied.
        //
        ByteCount -= BytesToCopy;
        ASSERT(ByteCount < PAGE_SIZE);

        //
        // Increment the ByteOffset with the number of bytes that have been copied.
        // Since this is PagingIo, the start address was page-aligned and we 
        // have read integral number of pages so ByteOffset+BytesToCopy should 
        // be page aligned as well.
        //
        ByteOffset.QuadPart += BytesToCopy;

        //
        // Increment the UserBuffer pointer which currently points to the begenning
        // of the buffer which the user supplied by the number of bytes which have
        // been copied.
        //
        UserBuffer += BytesToCopy;

        //
        // We have read all the bytes that are multiple of pages. We now need
        // to read the remaining bytes needed from the last page. From here,
        // we go to Case 3 below.
        //

        DavDbgTrace(DAV_TRACE_DETAIL,
                    ("%ld: MRxDAVReadContinuation. Remaining ByteCount = %d\n",
                     PsGetCurrentThreadId(), ByteCount));
    
    }

    //
    // We allocate a page size buffer to be used for helping read the data 
    // which is not aligned at page boundaries.
    //
    AllocatedSideBuffer = RxAllocatePoolWithTag(NonPagedPool, PAGE_SIZE, DAV_READWRITE_POOLTAG);
    if (AllocatedSideBuffer == NULL) {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: MRxDAVReadContinuation/RxAllocatePoolWithTag\n",
                     PsGetCurrentThreadId()));
        goto EXIT_THE_FUNCTION;
    }

    //
    // When we issue a read down to the underlying file system, we need to make 
    // sure that the offset is page aligned and the bytecount is a multiple of 
    // PAGE_SIZE. This is because we created the local handle with the
    // NO_INTERMEDIATE_BUFFERING option. Since there is no cache map for this 
    // handle, all the data is read from the disk and hence the alignment issue.
    //

    //
    // Case 1: ByteOffset is not page aligned. In this case we read the page 
    // which contains the ByteOffset and copy the data from the ByteOffset to
    // the end of the page.
    //
    
    //
    // The "and" operation below does the following. If the ByteOffset is 6377
    // and the PAGE_SIZE is 4096, then the MisAlignment is 2281.
    //
    ByteOffsetMisAlignment = ( ByteOffset.LowPart & (PAGE_SIZE - 1) );

    if (ByteOffsetMisAlignment != 0) {
    
        DavDbgTrace(DAV_TRACE_DETAIL,
                    ("%ld: MRxDAVReadContinuation. Entered Case 1\n",
                     PsGetCurrentThreadId()));
        
        AlignedOffset = ByteOffset;

        //
        // The byte offset is not aligned. We need to read the page containing
        // the offset now.
        //
    
        //
        // If the PAGE_SIZE is 4096 (0x1000) then (PAGE_SIZE - 1) is 0xFFF.
        // ~(PAGE_SIZE - 1) is 0x000. The bit operation below masks the lower 3
        // bytes of the aligned offset to make it page aligned.
        //
        AlignedOffset.LowPart &= ~(PAGE_SIZE - 1);
    
        RtlZeroMemory(AllocatedSideBuffer, PAGE_SIZE);
    
        LengthRead = DavReadWriteFileEx(DAV_MJ_READ,
                                        TRUE,
                                        FALSE,
                                        NULL,
                                        davSrvOpen->UnderlyingDeviceObject,
                                        davSrvOpen->UnderlyingFileObject,
                                        AlignedOffset.QuadPart,
                                        AllocatedSideBuffer,
                                        PAGE_SIZE,
                                        &(IoStatusBlock));

        NtStatus = IoStatusBlock.Status;
    
        if (NtStatus != STATUS_SUCCESS) {
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: MRxDAVReadContinuation/DavReadWriteFileEx(1). "
                         "NtStatus = %d\n", PsGetCurrentThreadId(), NtStatus));
            goto EXIT_THE_FUNCTION;
        }

        //
        // If the length we read is less than the offset at which we have been
        // asked to read ( (LengthRead - ByteOffsetMisAlignment) <= 0 ) then
        // we return STATUS_END_OF_FILE. This is because we have been asked
        // to read beyond the current filesize.
        //
        if ( (LengthRead - ByteOffsetMisAlignment) <= 0 ) {
            NtStatus = STATUS_END_OF_FILE;
            DavDbgTrace(DAV_TRACE_DETAIL,
                        ("%ld: MRxDAVReadContinuation. (LengthRead - ByteOffsetMisAlignment) <= 0\n",
                         PsGetCurrentThreadId()));
            goto EXIT_THE_FUNCTION;
        }

        //
        // Copy the right number of bytes into the buffer.
        //
        BytesToCopy = min( ByteCount, (PAGE_SIZE - ByteOffsetMisAlignment) );

        //
        // If the data actually read is less than what BytesToCopy is from our
        // calculations above, it means that the amount of data requested is
        // more than the filesize. We only copy the right amount of data.
        //
        if ( BytesToCopy > (LengthRead - ByteOffsetMisAlignment) ) {
            BytesToCopy = (LengthRead - ByteOffsetMisAlignment);
            readLessThanAsked = TRUE;
        }

        //
        // Copy the bytes read into the user buffer starting at the correct offset.
        //
        RtlCopyMemory(UserBuffer,
                      (AllocatedSideBuffer + ByteOffsetMisAlignment),
                      BytesToCopy);

        //
        // Add the actual bytes read to the TotalLengthActuallyRead.
        //
        TotalLengthActuallyRead += BytesToCopy;

        //
        // If readLessThanAsked is TRUE, it implies that we have no more data
        // to read so we leave.
        //
        if (readLessThanAsked) {
            DavDbgTrace(DAV_TRACE_DETAIL,
                        ("%ld: MRxDAVReadContinuation. readLessThanAsked(1)\n",
                         PsGetCurrentThreadId()));
            goto EXIT_THE_FUNCTION;
        }

        //
        // If we have already written out the required number of bytes (which
        // means BytesToCopy == ByteCount), then we are done and can exit now.
        //
        if (BytesToCopy == ByteCount) {
            DavDbgTrace(DAV_TRACE_DETAIL,
                        ("%ld: MRxDAVReadContinuation. BytesToCopy == ByteCount(1)\n",
                         PsGetCurrentThreadId()));
            goto EXIT_THE_FUNCTION;
        }

        //
        // Decrement the ByteCount by the number of bytes that have been copied.
        //
        ByteCount -= BytesToCopy;

        //
        // Increment the ByteOffset with the number of bytes that have been copied.
        // If the original ByteCount was > (PAGE_SIZE - ByteOffsetMisAlignment) then
        // the ByteOffset is now page aligned.
        //
        ByteOffset.QuadPart += BytesToCopy;

        //
        // Increment the UserBuffer pointer which currently points to the begenning
        // of the buffer which the user supplied by the number of bytes which have
        // been copied.
        //
        UserBuffer += BytesToCopy;

    }

    //
    // Case 2: At this stage we have copied the bytes from the unaligned offset 
    // (if it the ByteOffset was unaligned) to the next page bouandary. Now we 
    // copy as many pages as we can.
    //
    
    //
    // If 4100 bytes are remaining, the operation below sets BytesToCopy to
    // 4096 and BytesLeftToCopy to 4.
    //
    BytesToCopy = ( (ByteCount >> PAGE_SHIFT) << PAGE_SHIFT );

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVReadContinuation. BytesToCopy = %d\n",
                 PsGetCurrentThreadId(), BytesToCopy));

    //
    // If we have any bytes (which are multiple of pages) to copy, we copy them
    // now.
    //
    if (BytesToCopy != 0) {

        DavDbgTrace(DAV_TRACE_DETAIL,
                    ("%ld: MRxDAVReadContinuation. Entered Case 2\n",
                     PsGetCurrentThreadId()));
        
        //
        // If the UserBuffer is DWORD aligned then we copy the data directly 
        // the UserBuffer. If not then we read one page at a time and copy it
        // into the UserBuffer.
        //
        if ( ( (ULONG_PTR)UserBuffer & 0x3 ) == 0 ) {

            //
            // The UserBuffer is DWORD aligned.
            //

            DavDbgTrace(DAV_TRACE_DETAIL,
                        ("%ld: MRxDAVReadContinuation. UserBuffer is DWORD Aligned\n",
                         PsGetCurrentThreadId()));

            //
            // The offset is now page aligned. Zero out the number of bytes which 
            // will be read into the UserBuffer.
            //
            RtlZeroMemory(UserBuffer, BytesToCopy);

            //
            // BytesToCopy is a multiple of pages.
            //
            LengthRead = DavReadWriteFileEx(DAV_MJ_READ,
                                            FALSE,
                                            FALSE,
                                            NULL,
                                            davSrvOpen->UnderlyingDeviceObject,
                                            davSrvOpen->UnderlyingFileObject,
                                            ByteOffset.QuadPart,
                                            UserBuffer,
                                            BytesToCopy,
                                            &(IoStatusBlock));

            NtStatus = IoStatusBlock.Status;

            if (NtStatus != STATUS_SUCCESS) {
                //
                // If NtStatus is STATUS_END_OF_FILE and TotalLengthActuallyRead
                // is > 0, it implies that the user asked for data from within
                // the file to beyond EOF. The EOF is page aligned. We just return
                // the data that we read till the EOF.
                //
                if ( (NtStatus == STATUS_END_OF_FILE) && (TotalLengthActuallyRead > 0) ) {
                    NtStatus = STATUS_SUCCESS;
                    DavDbgTrace(DAV_TRACE_DETAIL,
                                ("%ld: MRxDAVReadContinuation(1). EOF && TotalLengthActuallyRead\n",
                                 PsGetCurrentThreadId()));
                    goto EXIT_THE_FUNCTION;
                }
                DavDbgTrace(DAV_TRACE_ERROR,
                            ("%ld: MRxDAVReadContinuation/DavReadWriteFileEx(2). "
                             "NtStatus = %d\n", PsGetCurrentThreadId(), NtStatus));
                goto EXIT_THE_FUNCTION;
            }

            //
            // If the amount of data we read is less than what we asked for then
            // we only return the data that got read.
            //
            if (LengthRead < BytesToCopy) {
                BytesToCopy = LengthRead;
                readLessThanAsked = TRUE;
            }

            //
            // Add the actual bytes read to the TotalLengthActuallyRead.
            //
            TotalLengthActuallyRead += BytesToCopy;
            
            //
            // If readLessThanAsked is TRUE, it implies that we have no more data
            // to read so we leave.
            //
            if (readLessThanAsked) {
                DavDbgTrace(DAV_TRACE_DETAIL,
                            ("%ld: MRxDAVReadContinuation. readLessThanAsked(2)\n",
                             PsGetCurrentThreadId()));
                goto EXIT_THE_FUNCTION;
            }

            //
            // If we have already written out the required number of bytes (which
            // means BytesToCopy == ByteCount), then we are done and can exit now.
            //
            if (BytesToCopy == ByteCount) {
                DavDbgTrace(DAV_TRACE_DETAIL,
                            ("%ld: MRxDAVReadContinuation. BytesToCopy == ByteCount(2)\n",
                             PsGetCurrentThreadId()));
                goto EXIT_THE_FUNCTION;
            }

            //
            // Decrement the ByteCount by the number of bytes that have been copied.
            //
            ByteCount -= BytesToCopy;

            //
            // Increment the ByteOffset with the number of bytes that have been copied.
            // If the original ByteCount was > (PAGE_SIZE - ByteOffsetMisAlignment) then
            // the ByteOffset is now page aligned.
            //
            ByteOffset.QuadPart += BytesToCopy;

            //
            // Increment the UserBuffer pointer which currently points to the begenning
            // of the buffer which the user supplied by the number of bytes which have
            // been copied.
            //
            UserBuffer += BytesToCopy;

        } else {

            ULONG BytesToCopyThisIteration = 0;

            DavDbgTrace(DAV_TRACE_DETAIL,
                        ("%ld: MRxDAVReadContinuation. UserBuffer is NOT DWORD Aligned\n",
                         PsGetCurrentThreadId()));

            //
            // The UserBuffer is not DWORD aligned, but the Offset is now 
            // Page aligned. We loop and copy one page at a time. The BytesToCopy
            // value below is a multiple of pages.
            //
            while (BytesToCopy > 0) {
            
                BytesToCopyThisIteration = ( (BytesToCopy < PAGE_SIZE) ? BytesToCopy : PAGE_SIZE );
            
                //
                // Copy the memory from the UserBuffer to the AllocatedSideBuffer.
                //
                RtlZeroMemory(AllocatedSideBuffer, PAGE_SIZE);
            
                LengthRead = DavReadWriteFileEx(DAV_MJ_READ,
                                                TRUE,
                                                FALSE,
                                                NULL,
                                                davSrvOpen->UnderlyingDeviceObject,
                                                davSrvOpen->UnderlyingFileObject,
                                                ByteOffset.QuadPart,
                                                AllocatedSideBuffer,
                                                BytesToCopyThisIteration,
                                                &(IoStatusBlock));

                NtStatus = IoStatusBlock.Status;

                if (NtStatus != STATUS_SUCCESS) {
                    //
                    // If NtStatus is STATUS_END_OF_FILE and TotalLengthActuallyRead
                    // is > 0, it implies that the user asked for data from within
                    // the file to beyond EOF. The EOF is page aligned. We just
                    // return the data that we read till the EOF.
                    //
                    if ( (NtStatus == STATUS_END_OF_FILE) && (TotalLengthActuallyRead > 0) ) {
                        NtStatus = STATUS_SUCCESS;
                        DavDbgTrace(DAV_TRACE_DETAIL,
                                    ("%ld: MRxDAVReadContinuation(2). EOF && TotalLengthActuallyRead\n",
                                     PsGetCurrentThreadId()));
                        goto EXIT_THE_FUNCTION;
                    }
                    DavDbgTrace(DAV_TRACE_ERROR,
                                ("%ld: MRxDAVReadContinuation/DavReadWriteFileEx(3). "
                                 "NtStatus = %d\n", PsGetCurrentThreadId(), NtStatus));
                    goto EXIT_THE_FUNCTION;
                }

                //
                // If the amount of data we read is less than what we asked for then
                // we only return the data that got read.
                //
                if (LengthRead < BytesToCopyThisIteration) {
                    BytesToCopyThisIteration = LengthRead;
                    readLessThanAsked = TRUE;
                }

                //
                // Copy the number of bytes read into the UserBuffer.
                //
                RtlCopyMemory(UserBuffer, AllocatedSideBuffer, BytesToCopyThisIteration);

                //
                // Add the actual bytes read to the TotalLengthActuallyRead.
                //
                TotalLengthActuallyRead += BytesToCopyThisIteration;

                //
                // If readLessThanAsked is TRUE, it implies that we have no more
                // data to read so we leave.
                //
                if (readLessThanAsked) {
                    DavDbgTrace(DAV_TRACE_DETAIL,
                                ("%ld: MRxDAVReadContinuation. readLessThanAsked(3)\n",
                                 PsGetCurrentThreadId()));
                    goto EXIT_THE_FUNCTION;
                }

                //
                // Decrement the ByteCount by the number of bytes that have been copied.
                //
                ByteCount -= LengthRead;

                //
                // Increment the ByteOffset with the number of bytes that have been copied.
                // If the original ByteCount was > (PAGE_SIZE - ByteOffsetMisAlignment) then
                // the ByteOffset is now page aligned.
                //
                ByteOffset.QuadPart += LengthRead;

                //
                // Increment the UserBuffer pointer which currently points to the begenning
                // of the buffer which the user supplied by the number of bytes which have
                // been copied.
                //
                UserBuffer += LengthRead;

                //
                // Subtract the LengthWritten from the number of bytes to write.
                //
                BytesToCopy -= LengthRead;

            }

            //
            // If we have already written out the required number of bytes
            // (which means ByteCount == 0), then we are done and can exit now.
            //
            if (ByteCount == 0) {
                DavDbgTrace(DAV_TRACE_DETAIL,
                            ("%ld: MRxDAVReadContinuation. Leaving!!! ByteCount = 0\n",
                             PsGetCurrentThreadId()));
                goto EXIT_THE_FUNCTION;
            }

        }
    
    }

    //
    // Case 3. Now we copy the trailing bytes which are not page aligned. This
    // is the last step. If the inital (ByteOffset + ByteCount) ended being
    // page aligned then ByteCount would be zero now.
    //

    if (ByteCount != 0) {

        DavDbgTrace(DAV_TRACE_DETAIL,
                    ("%ld: MRxDAVReadContinuation. Entered Case 3\n",
                     PsGetCurrentThreadId()));

        DavDbgTrace(DAV_TRACE_DETAIL,
                    ("%ld: MRxDAVReadContinuation. ByteCount = %d\n",
                     PsGetCurrentThreadId(), ByteCount));

        ASSERT(ByteCount < PAGE_SIZE);

        RtlZeroMemory(AllocatedSideBuffer, PAGE_SIZE);
    
        //
        // Though we are issuing a read for PAGE_SIZE bytes, we might get less
        // less number of bytes if the EOF is reached.
        //
        LengthRead = DavReadWriteFileEx(DAV_MJ_READ,
                                        TRUE,
                                        FALSE,
                                        NULL,
                                        davSrvOpen->UnderlyingDeviceObject,
                                        davSrvOpen->UnderlyingFileObject,
                                        ByteOffset.QuadPart,
                                        AllocatedSideBuffer,
                                        PAGE_SIZE,
                                        &(IoStatusBlock));

        NtStatus = IoStatusBlock.Status;

        if (NtStatus != STATUS_SUCCESS) {
            //
            // If NtStatus is STATUS_END_OF_FILE and TotalLengthActuallyRead
            // is > 0, it implies that the user asked for data from within
            // the file to beyond EOF. The EOF is page aligned. We just return
            // the data that we read till the EOF.
            //
            if ( (NtStatus == STATUS_END_OF_FILE) && (TotalLengthActuallyRead > 0) ) {
                NtStatus = STATUS_SUCCESS;
                DavDbgTrace(DAV_TRACE_DETAIL,
                            ("%ld: MRxDAVReadContinuation(3). EOF && TotalLengthActuallyRead\n",
                             PsGetCurrentThreadId()));
                goto EXIT_THE_FUNCTION;
            }
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: MRxDAVReadContinuation/DavReadWriteFileEx(4). "
                         "NtStatus = %d\n", PsGetCurrentThreadId(), NtStatus));
            goto EXIT_THE_FUNCTION;
        }

        //
        // If the amount of data read is less than what the user asked for then
        // we only return the data that is available.
        //
        if (LengthRead < ByteCount) {
            BytesToCopy = LengthRead;
            readLessThanAsked = TRUE;
            DavDbgTrace(DAV_TRACE_DETAIL,
                        ("%ld: MRxDAVReadContinuation. readLessThanAsked(4)\n",
                         PsGetCurrentThreadId()));
        } else {
            BytesToCopy = ByteCount;
        }

        RtlCopyMemory(UserBuffer, AllocatedSideBuffer, BytesToCopy);

        //
        // Add the actual bytes read to the TotalLengthActuallyRead.
        //
        TotalLengthActuallyRead += BytesToCopy;

    }

EXIT_THE_FUNCTION:

    //
    // We allocate a page size buffer for the read and the write operations. We
    // need to free it now.
    //
    if (AllocatedSideBuffer) {
        RxFreePool(AllocatedSideBuffer);
    }

    //
    // We need to remove the reference we took at the begenning of this routine.
    //
    UMRxResumeAsyncEngineContext(RxContext);
    
    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Leaving MRxDAVReadContinuation. NtStatus = %08lx, "
                 "TotalLengthActuallyRead = %d\n", 
                 PsGetCurrentThreadId(), NtStatus, TotalLengthActuallyRead));
    
    AsyncEngineContext->Status = NtStatus;

    //
    // We need to set these values in the RxContext. There is code in RDBSS
    // which takes care of putting these values in the IRP.
    //
    RxContext->StoredStatus = NtStatus;
    RxContext->InformationToReturn = TotalLengthActuallyRead;

    return NtStatus;
}


BOOLEAN
MRxDAVFastIoRead(
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    This is the routine that handles fast I/O for read operation.

Arguments:

Return Value:

    TRUE (succeeded) or FALSE.

--*/
{
    BOOLEAN ReturnVal = FALSE;

    PAGED_CODE();

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Entered MRxDAVFastIoRead.\n", PsGetCurrentThreadId()));
    
    IoStatus->Status = STATUS_NOT_IMPLEMENTED;
    IoStatus->Information = 0;

    return (ReturnVal);
}


ULONG
DavReadWriteFileEx(
    IN USHORT Operation,
    IN BOOL NonPagedBuffer,
    IN BOOL UseOriginalIrpsMDL,
    IN PMDL OriginalIrpsMdl,
    IN PDEVICE_OBJECT DeviceObject,
    IN PFILE_OBJECT FileObject,
    IN ULONGLONG FileOffset,
    IN OUT PVOID DataBuffer,
    IN ULONG SizeInBytes,
    OUT PIO_STATUS_BLOCK IoStatusBlock
    )
/*++

Routine Description:

    This is the routine reads or writes (Operation) SizeInBytes bytes of data of 
    the file (FileObject) and copies (in case of read) it in the DataBuffer. In
    case of write the data from DataBuffer is written onto the file. The result 
    of the operation is set in the IoStatusBlock.

Arguments:

    Operation - Whether this is a Read or a Write operation.
    
    NonPagedBuffer - TRUE if the DataBuffer is from NonPagedPool which we
                     allocated in the read and write continuation routines to
                     make sure that the writes and reads that we pass down to
                     the underlying filesystem are page aligned.

    FileObject - The file object of the file in question.
    
    FileOffset - The offset at which the data is read or written.
    
    DataBuffer - The data buffer in which the data is copied in case of a read 
                 or the data is written to the file from the data buffer in
                 the write case. 
    
    SizeInBytes - Size in bytes of the DataBuffer.
    
    IoStatusBlock - The IO_STATUS_BLOCK which contains the return status.

Return Value:

    The number of bytes read or written.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    ULONG ReadWriteLength = 0, MdlLength = 0;
    LARGE_INTEGER ByteOffset = {0,0};
    ULONG MajorFunction;
    PIRP Irp = NULL, TopIrp = NULL;
    PIO_STACK_LOCATION IrpSp = NULL;
    WEBDAV_READ_WRITE_IRP_COMPLETION_CONTEXT DavIrpCompletionContext;
    LOCK_OPERATION ProbeOperation = 0;
    BOOL didProbeAndLock = FALSE;

    PAGED_CODE();

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: DavReadWriteFileEx. Operation = %d, NonPagedBuffer = %d, "
                 "FileObject = %08lx, FileOffset = %d",
                 PsGetCurrentThreadId(), Operation, 
                 NonPagedBuffer, FileObject, FileOffset));

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: DavReadWriteFileEx. SizeInBytes = %d\n", 
                 PsGetCurrentThreadId(), SizeInBytes));
    
    IoStatusBlock->Information = 0;

    if ( (DeviceObject->Flags & DO_BUFFERED_IO) ) {
        //
        // We cannot handle Buffered I/O Devices.
        //
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: DavReadWriteFileEx. DeviceObject->Flags & DO_BUFFERED_IO\n",
                     PsGetCurrentThreadId()));
        NtStatus = STATUS_INVALID_DEVICE_REQUEST;
        ReadWriteLength = -1;
        goto EXIT_THE_FUNCTION;
    }

    //
    // If we want to write the data OUT of the memory ON to the disk, we should
    // be probing with IoReadAccess. If we are reading data FROM the disk INTO
    // the memory, I should probe it with IoWriteAccess (since you the data you
    // read could be written to).
    //
    if (Operation == DAV_MJ_READ) {
        MajorFunction = IRP_MJ_READ;
        ProbeOperation = IoWriteAccess;
    } else {
        ASSERT(Operation == DAV_MJ_WRITE);
        MajorFunction = IRP_MJ_WRITE;
        ProbeOperation = IoReadAccess;
    }

    //
    // Set the Offset at which we are going to read or write.
    //
    ByteOffset.QuadPart = FileOffset;

    //
    // Allocate the new IRP that we will send down to the underlying file system.
    //
    Irp = IoAllocateIrp(DeviceObject->StackSize, FALSE);
    if (Irp == NULL) {
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: DavReadWriteFileEx/IoAllocateIrp\n",
                     PsGetCurrentThreadId()));
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        ReadWriteLength = -1;
        goto EXIT_THE_FUNCTION;
    }

    //
    // Set current thread for IoSetHardErrorOrVerifyDevice.
    //
    Irp->Tail.Overlay.Thread = PsGetCurrentThread();

    //
    // Get a pointer to the stack location of the first driver which will be
    // invoked. This is where the function codes and the parameters are set.
    //
    IrpSp = IoGetNextIrpStackLocation(Irp);

    IrpSp->MajorFunction = (UCHAR)MajorFunction;
    
    IrpSp->FileObject = FileObject;
    
    //
    // Set the completion routine to be called everytime.
    //
    IoSetCompletionRoutine(Irp,
                           DavReadWriteIrpCompletionRoutine,
                           &(DavIrpCompletionContext),
                           TRUE,
                           TRUE,
                           TRUE);

    ASSERT( &(IrpSp->Parameters.Write.Key) == &(IrpSp->Parameters.Read.Key) );
    
    ASSERT( &(IrpSp->Parameters.Write.Length) == &(IrpSp->Parameters.Read.Length) );
    
    ASSERT( &(IrpSp->Parameters.Write.ByteOffset) == &(IrpSp->Parameters.Read.ByteOffset) );
    
    //
    // Set the length to be read/written to the number of bytes supplied by the
    // caller of the function.
    //
    IrpSp->Parameters.Read.Length = MdlLength = SizeInBytes;
    
    //
    // Set the offset to the value suppiled by the caller of the function.
    //
    IrpSp->Parameters.Read.ByteOffset = ByteOffset;
    
    IrpSp->Parameters.Read.Key = 0;
    
    Irp->RequestorMode = KernelMode;
    
    //
    // Set the UserBuffer of the Irp to the DataBuffer supplied by the caller.
    //
    Irp->UserBuffer = DataBuffer;

    //
    // Also the SizeInBytes which is set to the MdlLength above is always a
    // multiple of PAGE_SIZE.
    //
    // MdlLength = (ULONG)ROUND_TO_PAGES(MdlLength);

    //
    // Allocate the MDL for this Irp.
    //
    Irp->MdlAddress = IoAllocateMdl(Irp->UserBuffer, MdlLength, FALSE, FALSE, NULL);
    if (Irp->MdlAddress == NULL) {
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: DavReadWriteFileEx/IoAllocateMdl\n",
                     PsGetCurrentThreadId()));
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        ReadWriteLength = -1;
        goto EXIT_THE_FUNCTION;
    }

    //
    // We always do IRP_NOCACHE since the create of the local file was done with
    // NO_INTERMEDIATE_BUFFERING.
    //
    Irp->Flags |= IRP_NOCACHE;

    //
    // If we got a PagingIo, we build a partial MDL using the one that come down
    // in the original (PagingIo) IRP and send it down. We do this since the MDL
    // would have been probed and locked already and we don't need to do it
    // again.
    //
    if (UseOriginalIrpsMDL) {
        ASSERT(OriginalIrpsMdl != NULL);
        IoBuildPartialMdl(OriginalIrpsMdl, Irp->MdlAddress, Irp->UserBuffer, MdlLength);
    } else {
        //
        // If the DataBuffer that was supplied (which we set to the UserBuffer in 
        // the Irp above) is the one we allocated from the nonpaged pool, then we 
        // build the MDL from non-paged pool. We don't need to call ProbeAndLock
        // since we ourselves allocated it from Non-Paged Pool in the read and
        // write continuation routines. If this is not the buffer that we allocated
        // then we call MmProbeAndLockPages. We need to Probe because we allocated
        // the MDL above and it needs to be filled in with the correct address values
        // of where the data is.
        //
        if (NonPagedBuffer) {
            MmBuildMdlForNonPagedPool(Irp->MdlAddress);
        } else {
            try {
                MmProbeAndLockPages(Irp->MdlAddress, KernelMode, ProbeOperation);
                didProbeAndLock = TRUE;
            } except(EXCEPTION_EXECUTE_HANDLER) {
                NtStatus = GetExceptionCode();
                DavDbgTrace(DAV_TRACE_ERROR,
                            ("%ld: DavReadWriteFileEx/MmProbeAndLockPages. NtStatus"
                             " = %08lx\n", PsGetCurrentThreadId(), NtStatus));
                IoFreeMdl(Irp->MdlAddress);
                Irp->MdlAddress = NULL;
                ReadWriteLength = -1;
                goto EXIT_THE_FUNCTION;
            }
        }
    }

    //
    // Initialize the event on which we will wait after we call IoCallDriver.
    // This event will be signalled in the Completion routine which will be 
    // called by the underlying file system after it completes the operation.
    //
    KeInitializeEvent(&(DavIrpCompletionContext.DavReadWriteEvent), 
                      NotificationEvent, 
                      FALSE);

    //
    // Now is the time to call the underlying file system with the Irp that we
    // just created.
    //
    try {
        
        //
        // Save the TopLevel Irp.
        //
        TopIrp = IoGetTopLevelIrp();
        
        //
        // Tell the underlying guy he's all clear.
        //
        IoSetTopLevelIrp(NULL);
        
        //
        // Finally, call the underlying file system to process the request.
        //
        NtStatus = IoCallDriver(DeviceObject, Irp);

    } finally {
        
        //
        // Restore my context for unwind.
        //
        IoSetTopLevelIrp(TopIrp); 
    
    }

    if (NtStatus == STATUS_PENDING) {
        
        //
        // If STATUS_PENDING was returned by the underlying file system then we
        // wait here till the operation gets completed.
        //
        KeWaitForSingleObject(&(DavIrpCompletionContext.DavReadWriteEvent),
                              Executive, 
                              KernelMode, 
                              FALSE, 
                              NULL);
        
        NtStatus = Irp->IoStatus.Status;
    
    }

    if (NtStatus == STATUS_SUCCESS) {
        //
        // If the IoCallDriver was successful, then Irp->IoStatus.Information
        // contains the number of bytes read or written.
        //
        ReadWriteLength = (ULONG)Irp->IoStatus.Information;
        IoStatusBlock->Information = ReadWriteLength;
    } else if (NtStatus == STATUS_END_OF_FILE) {
        ReadWriteLength = 0;
    } else {
        ReadWriteLength = -1;
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: DavReadWriteFileEx/IoCallDriver. NtStatus = %08lx\n",
                     PsGetCurrentThreadId(), NtStatus));
    }

EXIT_THE_FUNCTION:

    //
    // Free the Irp that we allocated above.
    //
    if (Irp) {
        //
        // Free the MDL only if we allocated it in the first place.
        //
        if (Irp->MdlAddress) {
            //
            // If it was not from NonPagedPool, we would have locked it. So, we
            // need to unlock before freeing.
            //
            if (didProbeAndLock) {
                MmUnlockPages(Irp->MdlAddress);
            }
            IoFreeMdl(Irp->MdlAddress);
        }
        IoFreeIrp(Irp);
    }

    IoStatusBlock->Status = NtStatus;

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: DavReadWriteFileEx. ReadWriteLength = %d\n",
                 PsGetCurrentThreadId(), ReadWriteLength));

    return ReadWriteLength;
}


NTSTATUS
DavReadWriteIrpCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP CalldownIrp,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine is called when the read/write IRP that was sent to the 
    underlying file system is completed.

Arguments:

    DeviceObject - The WebDav Device object.

    CalldownIrp - The IRP that was created and sent to the underlying file 
                  system.

    Context - The context that was set in the IoSetCompletionRoutine function.

Return Value:

    STATUS_MORE_PROCESSING_REQUIRED

--*/
{
    PWEBDAV_READ_WRITE_IRP_COMPLETION_CONTEXT DavIrpCompletionContext = NULL;

    DavIrpCompletionContext = (PWEBDAV_READ_WRITE_IRP_COMPLETION_CONTEXT)Context;

    //
    // This is not Pageable Code.
    //

    //
    // If the IoCallDriver routine returned pending then it will be set in the
    // IRP's PendingReturned field. In this case we need to set the event on 
    // which the thread which issued IoCallDriver will be waiting.
    //
    if (CalldownIrp->PendingReturned) {
        KeSetEvent( &(DavIrpCompletionContext->DavReadWriteEvent), 0 , FALSE );
    }
    
    return(STATUS_MORE_PROCESSING_REQUIRED);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\kernel\write.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    write.c

Abstract:

    This module implements the DAV miniredir call down routines pertaining to
    "write" of file system objects.

Author:

    Balan Sethu Raman      [SethuR]
    
    Rohan Kumar            [RohanK]  02-Nov-1999

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include "webdav.h"

//
// Mentioned below are the prototypes of functions tht are used only within
// this module (file). These functions should not be exposed outside.
//

NTSTATUS
MRxDAVWriteContinuation(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, MRxDAVWrite)
#pragma alloc_text(PAGE, MRxDAVWriteContinuation)
#pragma alloc_text(PAGE, MRxDAVExtendForCache)
#pragma alloc_text(PAGE, MRxDAVExtendForNonCache)
#pragma alloc_text(PAGE, MRxDAVFastIoWrite)
#endif

//
// Implementation of functions begins here.
//

NTSTATUS
MRxDAVWrite(
    IN PRX_CONTEXT RxContext
    )
/*++

Routine Description:

   This routine handles network write requests.

Arguments:

    RxContext - The RDBSS context.

Return Value:

    RXSTATUS - The return status for the operation.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    PAGED_CODE();

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Entering MRxDAVWrite!!!!\n", PsGetCurrentThreadId()));

    DavDbgTrace(DAV_TRACE_CONTEXT,
                ("%ld: MRxDAVWrite: RxContext: %08lx\n", 
                 PsGetCurrentThreadId(), RxContext));

    NtStatus = UMRxAsyncEngOuterWrapper(RxContext,
                                        SIZEOF_DAV_SPECIFIC_CONTEXT,
                                        MRxDAVFormatTheDAVContext,
                                        DAV_MINIRDR_ENTRY_FROM_WRITE,
                                        MRxDAVWriteContinuation,
                                        "MRxDAVWrite");

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Leaving MRxDAVWrite with NtStatus = %08lx.\n", 
                 PsGetCurrentThreadId(), NtStatus));

    return(NtStatus);
}


NTSTATUS
MRxDAVWriteContinuation(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE
    )
/*++

Routine Description:

    This is the continuation routine the for write operation. It uses unbuffered
    write doing prereads as necessary. We cannot use buffered write because such
    a write could be arbitrarily deferred (in CcCanIWrite) so that we deadlock.

Arguments:

    AsyncEngineContext - The exchange to be conducted.

    RxContext - The RDBSS context.
    
Notes.

    The routine does this in (potentially) 3 phases.

    1) If the starting offset is not aligned on a page boundary then,
       - Read from the earlier page boundary to the next page boundary of the 
         starting offset.
       - Merge the passed in buffer.
       - Write the whole page.

    2) 0 or more page size writes.

    3) Residual write of less than page size, similar to what is explained in 
       1) above.
       
    Non-Cached writes that do not extend the file have the FCB acquired shared.
    We have an additional resource in the WEBDAV_FCB structure to synchronize
    the "read-modify-write" routine we have here. This is because multiple threads
    can (in the non-cached non extending scenario) overwrite each others data.
    
Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PWEBDAV_CONTEXT DavContext = NULL;
    PLOWIO_CONTEXT LowIoContext = NULL;
    LARGE_INTEGER ByteOffset = {0,0}, AlignedOffset = {0,0}, EndBytePlusOne = {0,0};
    ULONG ByteCount = 0, TotalLengthActuallyWritten = 0;
    ULONG LengthRead = 0, BytesToCopy = 0, BytesToWrite = 0, LengthWritten = 0;
    ULONG ByteOffsetMisAlignment = 0, InMemoryMisAlignment = 0;
    BOOLEAN  SynchronousIo = TRUE, PagingIo = TRUE, DavFcbResourceAcquired = FALSE;
    PWEBDAV_SRV_OPEN davSrvOpen = NULL;
    PWEBDAV_FCB DavFcb = NULL;
    FILE_STANDARD_INFORMATION FileStandardInfo;
    IO_STATUS_BLOCK IoStatusBlock;
    PBYTE AllocatedSideBuffer = NULL, UserBuffer = NULL;

#ifdef DAV_DEBUG_READ_WRITE_CLOSE_PATH
    PDAV_GLOBAL_FILE_TABLE_ENTRY FileTableEntry = NULL;
    BOOL Exists = FALSE;
#endif // DAV_DEBUG_READ_WRITE_CLOSE_PATH

    PAGED_CODE();

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Entering MRxDAVWriteContinuation.\n", PsGetCurrentThreadId()));

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: AsyncEngineContext: %08lx, RxContext: %08lx.\n", 
                 PsGetCurrentThreadId(), AsyncEngineContext, RxContext));
    
    ASSERT_ASYNCENG_CONTEXT(AsyncEngineContext);

    //
    // We want to keep the AsyncEngineContext alive while we are doing this write
    // operation. The reference is taken away when we leave this function. 
    //
    InterlockedIncrement( &(AsyncEngineContext->NodeReferenceCount) );
    
    DavContext = (PWEBDAV_CONTEXT)AsyncEngineContext;
    
    LowIoContext = &(RxContext->LowIoContext);
    ASSERT(LowIoContext != NULL);
    
    ByteOffset.QuadPart = LowIoContext->ParamsFor.ReadWrite.ByteOffset;
    
    ByteCount = LowIoContext->ParamsFor.ReadWrite.ByteCount;
    
    EndBytePlusOne.QuadPart = (ByteOffset.QuadPart + ByteCount);
    
    UserBuffer = RxLowIoGetBufferAddress(RxContext);

    PagingIo = BooleanFlagOn(LowIoContext->ParamsFor.ReadWrite.Flags, LOWIO_READWRITEFLAG_PAGING_IO);
    
    SynchronousIo = !BooleanFlagOn(RxContext->Flags, RX_CONTEXT_FLAG_ASYNC_OPERATION);
    
    davSrvOpen = MRxDAVGetSrvOpenExtension(RxContext->pRelevantSrvOpen);
    ASSERT(davSrvOpen->UnderlyingHandle != NULL);
    ASSERT(davSrvOpen->UnderlyingFileObject != NULL);
    ASSERT(davSrvOpen->UnderlyingDeviceObject != NULL);

    if ( davSrvOpen->UnderlyingHandle == NULL      ||
         davSrvOpen->UnderlyingFileObject == NULL  ||
         davSrvOpen->UnderlyingDeviceObject == NULL ) {
        NtStatus = STATUS_INVALID_PARAMETER;
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: MRxDAVWriteContinuation. Invalid davSrvOpen\n",
                     PsGetCurrentThreadId()));
        goto EXIT_THE_FUNCTION;
    }

    DavFcb = MRxDAVGetFcbExtension(RxContext->pRelevantSrvOpen->pFcb);
    ASSERT(DavFcb != NULL);

    //
    // We issue an IRP to the underlying filesystem to figure out the 
    // FileStandardInformation of this file. We use the EndOfFile value
    // of the FileStandardInformation in our write logic below.
    //
    NtStatus = DavXxxInformation(IRP_MJ_QUERY_INFORMATION,
                                 davSrvOpen->UnderlyingFileObject,
                                 FileStandardInformation,
                                 sizeof(FILE_STANDARD_INFORMATION),
                                 &(FileStandardInfo),
                                 NULL);
    if (NtStatus != STATUS_SUCCESS) {
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: ERROR: MRxDAVWriteContinuation/DavXxxInformation: "
                     "NtStatus = %08lx\n", PsGetCurrentThreadId(), NtStatus));
        goto EXIT_THE_FUNCTION;
    }

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVWriteContinuation. FileName = %wZ, PagingIo = %d, SynchronousIo = %d"
                 ", ByteOffset.HighPart = %d, ByteOffset.LowPart = %d, ByteCount = %d, EndOfFile.HighPart = %d, "
                 "EndOfFile.LowPart = %d\n",
                 PsGetCurrentThreadId(), RxContext->pRelevantSrvOpen->pAlreadyPrefixedName,
                 PagingIo, SynchronousIo, ByteOffset.HighPart, ByteOffset.LowPart,
                 ByteCount, FileStandardInfo.EndOfFile.HighPart, FileStandardInfo.EndOfFile.LowPart));

#ifdef DAV_DEBUG_READ_WRITE_CLOSE_PATH
    Exists = DavDoesTheFileEntryExist(RxContext->pRelevantSrvOpen->pAlreadyPrefixedName,
                                      &(FileTableEntry));
    if (!Exists) {
        DbgBreakPoint();
    }
#endif // DAV_DEBUG_READ_WRITE_CLOSE_PATH

    if (PagingIo) {

        ASSERT(RxContext->CurrentIrp->MdlAddress != NULL);
        if (RxContext->CurrentIrp->MdlAddress == NULL) {
            DbgPrint("%ld: MRxDAVWriteContinuation: MdlAddress == NULL\n", PsGetCurrentThreadId());
            DbgBreakPoint();
        }

        BytesToWrite = ( (ByteCount >> PAGE_SHIFT) << PAGE_SHIFT );

        DavDbgTrace(DAV_TRACE_DETAIL,
                    ("%ld: MRxDAVWriteContinuation(0). ByteCount = %d, BytesToWrite = %d\n",
                     PsGetCurrentThreadId(), ByteCount, BytesToWrite));

        if (BytesToWrite > 0) {

#ifdef DAV_DEBUG_READ_WRITE_CLOSE_PATH

            PDAV_MR_PAGING_WRITE_ENTRY DavPagingWriteEntry = NULL;
            PVOID UserBuffer = NULL;

            DavPagingWriteEntry = RxAllocatePool(PagedPool, sizeof(DAV_MR_PAGING_WRITE_ENTRY));
            if (DavPagingWriteEntry == NULL) {
                DbgBreakPoint();
            }

            RtlZeroMemory(DavPagingWriteEntry, sizeof(DAV_MR_PAGING_WRITE_ENTRY));

            DavPagingWriteEntry->EntryCounter = InterlockedIncrement( &(DavTimeCount) );

#endif

            LengthWritten = DavReadWriteFileEx(DAV_MJ_WRITE,
                                               FALSE,
                                               TRUE,
                                               RxContext->CurrentIrp->MdlAddress,
                                               davSrvOpen->UnderlyingDeviceObject,
                                               davSrvOpen->UnderlyingFileObject,
                                               ByteOffset.QuadPart,
                                               MmGetMdlBaseVa(RxContext->CurrentIrp->MdlAddress),
                                               BytesToWrite,
                                               &(IoStatusBlock));

            NtStatus = IoStatusBlock.Status;

            if (NtStatus != STATUS_SUCCESS) {

                DavDbgTrace(DAV_TRACE_ERROR,
                            ("%ld: MRxDAVWriteContinuation/DavReadWriteFileEx(0). "
                             "NtStatus = %08lx\n", PsGetCurrentThreadId(), NtStatus));

                goto EXIT_THE_FUNCTION;

            } else {

#ifdef DAV_DEBUG_READ_WRITE_CLOSE_PATH

                DavPagingWriteEntry->ExitCounter = InterlockedIncrement( &(DavTimeCount) );

                DavPagingWriteEntry->ThisThreadId = PsGetCurrentThreadId();

                DavPagingWriteEntry->LocByteOffset.QuadPart = ByteOffset.QuadPart;

                DavPagingWriteEntry->LocByteCount = BytesToWrite;

                DavPagingWriteEntry->DataBuffer = RxAllocatePool(PagedPool, BytesToWrite);

                if (RxContext->CurrentIrp->MdlAddress == NULL) {
                    UserBuffer = RxContext->CurrentIrp->UserBuffer;
                } else {
                    UserBuffer = MmGetSystemAddressForMdlSafe(RxContext->CurrentIrp->MdlAddress,
                                                              NormalPagePriority);
                }

                RtlCopyMemory(DavPagingWriteEntry->DataBuffer, UserBuffer, BytesToWrite);

                wcscpy(DavPagingWriteEntry->FileName, DavFcb->FileName);

                InsertHeadList( &(FileTableEntry->DavMRPagingEntry), &(DavPagingWriteEntry->thisMPagingWriteEntry) );

#endif // DAV_DEBUG_READ_WRITE_CLOSE_PATH

            }

            if (LengthWritten != BytesToWrite) {
                DbgPrint("MRxDAVWriteContinuation(1): LengthWritten(%x) != BytesToWrite(%x)\n",
                         LengthWritten, BytesToWrite);
            }

            ASSERT(LengthWritten == BytesToWrite);

            TotalLengthActuallyWritten += BytesToWrite;

        }

        //
        // If we have already written out the required number of bytes (which
        // means BytesToWrite == ByteCount), then we are done and can exit now.
        //
        if (BytesToWrite == ByteCount) {
            DavDbgTrace(DAV_TRACE_DETAIL,
                        ("%ld: MRxDAVWriteContinuation. BytesToCopy == ByteCount(0)\n",
                         PsGetCurrentThreadId()));
            goto EXIT_THE_FUNCTION;
        }

        //
        // Decrement the ByteCount by the number of bytes that have been copied.
        //
        ByteCount -= BytesToWrite;
        ASSERT(ByteCount < PAGE_SIZE);

        //
        // Increment the ByteOffset with the number of bytes that have been copied.
        // If the original ByteCount was > (PAGE_SIZE - ByteOffsetMisAlignment) then
        // the ByteOffset is now page aligned.
        //
        ByteOffset.QuadPart += BytesToWrite;

        //
        // Increment the UserBuffer pointer which currently points to the beginning
        // of the buffer which the user supplied by the number of bytes which have
        // been copied.
        //
        UserBuffer += BytesToWrite;

        //
        // We have written all the bytes that are multiple of pages. We now 
        // need to write out the remaining bytes from the last page. From here,
        // we go to Case 3 below.
        //

        DavDbgTrace(DAV_TRACE_DETAIL,
                    ("%ld: MRxDAVWriteContinuation. Remaining ByteCount = %d\n",
                     PsGetCurrentThreadId(), ByteCount));

    }

    //
    // We allocate a page size buffer to be used for helping read the data 
    // which is not aligned at page boundaries.
    //
    AllocatedSideBuffer = RxAllocatePoolWithTag(NonPagedPool, PAGE_SIZE, DAV_READWRITE_POOLTAG);
    if (AllocatedSideBuffer == NULL) {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: MRxDAVWriteContinuation/RxAllocatePoolWithTag\n",
                     PsGetCurrentThreadId()));
        goto EXIT_THE_FUNCTION;
    }

    //
    // When we issue a write down to the underlying file system, we need to make 
    // sure that the offset is page aligned and the bytecount is a multiple of 
    // PAGE_SIZE. This is because we created the local handle with the
    // NO_INTERMEDIATE_BUFFERING option. Since there is no cache map for this 
    // handle, all the data is read from the disk and hence the alignment issue.
    //

    //
    // Case 1: ByteOffset is not page aligned. In this case we read the page
    // which contains the ByteOffset and copy the data from the ByteOffset to
    // the end of the page into the PAGE_SIZE buffer (which we allocated above)
    // and write the buffer back to the file.
    //
    
    //
    // The "and" operation below does the following. If the ByteOffset is 6377
    // and the PAGE_SIZE is 4096, then the MisAlignment is 2281.
    //
    ByteOffsetMisAlignment = ( ByteOffset.LowPart & (PAGE_SIZE - 1) );

    if (ByteOffsetMisAlignment != 0) {
        
        DavDbgTrace(DAV_TRACE_DETAIL,
                    ("%ld: MRxDAVWriteContinuation. Case 1. ByteOffsetMisAlignment = %d\n",
                     PsGetCurrentThreadId(), ByteOffsetMisAlignment));

        //
        // Acquire the DavFcb resource exclusively before proceeding further with
        // the "read-modify-write" routing.
        //
        ExAcquireResourceExclusiveLite(DavFcb->DavReadModifyWriteLock, TRUE);
        DavFcbResourceAcquired = TRUE;

        AlignedOffset = ByteOffset;

        //
        // The byte offset is not aligned. We need to read the page containing
        // the offset now.
        //
    
        //
        // If the PAGE_SIZE is 4096 (0x1000) then (PAGE_SIZE - 1) is 0xFFF.
        // ~(PAGE_SIZE - 1) is 0x000. The bit operation below masks the lower 3
        // bytes of the aligned offset to make it page aligned.
        //
        AlignedOffset.LowPart &= ~(PAGE_SIZE - 1);
    
        RtlZeroMemory(AllocatedSideBuffer, PAGE_SIZE);

        //
        // If the AliignedOffset is within the file then we read the whole page
        // containing the offset first before writing it out.
        //
        if ( (FileStandardInfo.EndOfFile.QuadPart != 0) &&
              (AlignedOffset.QuadPart < FileStandardInfo.EndOfFile.QuadPart) ) {
    
            DavDbgTrace(DAV_TRACE_DETAIL,
                        ("%ld: MRxDAVWriteContinuation. Case 1. AlignedOffset.QuadPart"
                         " < FileStandardInfo.EndOfFile.QuadPart\n",
                         PsGetCurrentThreadId()));

            LengthRead = DavReadWriteFileEx(DAV_MJ_READ,
                                            TRUE,
                                            FALSE,
                                            NULL,
                                            davSrvOpen->UnderlyingDeviceObject,
                                            davSrvOpen->UnderlyingFileObject,
                                            AlignedOffset.QuadPart,
                                            AllocatedSideBuffer,
                                            PAGE_SIZE,
                                            &(IoStatusBlock));

            NtStatus = IoStatusBlock.Status;
    
            if (NtStatus != STATUS_SUCCESS && NtStatus != STATUS_END_OF_FILE) {
                DavDbgTrace(DAV_TRACE_ERROR,
                            ("%ld: MRxDAVWriteContinuation/DavReadWriteFileEx(1). "
                             "NtStatus = %d\n", PsGetCurrentThreadId(), NtStatus));
                goto EXIT_THE_FUNCTION;
            }

        } else {

            LengthRead = 0;

        }

        //
        // Copy the right number of bytes into the buffer.
        //
        BytesToCopy = min( ByteCount, (PAGE_SIZE - ByteOffsetMisAlignment) );

        //
        // Copy the bytes to be written back from the UserBuffer into the
        // AllocatedSideBuffer.
        //
        RtlCopyMemory((AllocatedSideBuffer + ByteOffsetMisAlignment),
                      UserBuffer,
                      BytesToCopy);

        BytesToWrite = (ByteOffsetMisAlignment + BytesToCopy);

        DavDbgTrace(DAV_TRACE_DETAIL,
                    ("%ld: MRxDAVWriteContinuation. Case 1: LengthRead = %d, BytesToCopy = %d"
                     " BytesToWrite = %d\n", PsGetCurrentThreadId(), LengthRead,
                     BytesToCopy, BytesToWrite));

        //
        // If the BytesToWrite is less that LengthRead (which is one page in this
        // case) then we make BytesToWrite to be the LengthRead. This is possible
        // if the bytes to be written are contained in a Page starting at a
        // mis-aligned offset.
        //
        if (BytesToWrite < LengthRead) {
            DavDbgTrace(DAV_TRACE_DETAIL,
                        ("%ld: MRxDAVWriteContinuation. Case 1: BytesToWrite < LengthRead\n",
                         PsGetCurrentThreadId()));
            BytesToWrite = LengthRead;
        }
    
        //
        // Now we write out the entire page to the disk.
        //
        LengthWritten = DavReadWriteFileEx(DAV_MJ_WRITE,
                                           TRUE,
                                           FALSE,
                                           NULL,
                                           davSrvOpen->UnderlyingDeviceObject,
                                           davSrvOpen->UnderlyingFileObject,
                                           AlignedOffset.QuadPart,
                                           AllocatedSideBuffer,
                                           BytesToWrite,
                                           &(IoStatusBlock));
        NtStatus = IoStatusBlock.Status;

        if (NtStatus != STATUS_SUCCESS) {

            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: MRxDAVWriteContinuation/DavReadWriteFileEx(2). "
                         "NtStatus = %d\n", PsGetCurrentThreadId(), NtStatus));

            goto EXIT_THE_FUNCTION;

        } else {

#ifdef DAV_DEBUG_READ_WRITE_CLOSE_PATH

            PDAV_MR_PAGING_WRITE_ENTRY DavPagingWriteEntry = NULL;

            DavPagingWriteEntry = RxAllocatePool(PagedPool, sizeof(DAV_MR_PAGING_WRITE_ENTRY));
            if (DavPagingWriteEntry == NULL) {
                DbgBreakPoint();
            }

            RtlZeroMemory(DavPagingWriteEntry, sizeof(DAV_MR_PAGING_WRITE_ENTRY));

            DavPagingWriteEntry->ThisThreadId = PsGetCurrentThreadId();

            DavPagingWriteEntry->LocByteOffset.QuadPart = AlignedOffset.QuadPart;

            DavPagingWriteEntry->LocByteCount = BytesToWrite;

            DavPagingWriteEntry->DataBuffer = RxAllocatePool(PagedPool, BytesToWrite);

            RtlCopyMemory(DavPagingWriteEntry->DataBuffer, AllocatedSideBuffer, BytesToWrite);

            wcscpy(DavPagingWriteEntry->FileName, DavFcb->FileName);

            InsertHeadList( &(FileTableEntry->DavMRPagingEntry), &(DavPagingWriteEntry->thisMPagingWriteEntry) );

#endif // DAV_DEBUG_READ_WRITE_CLOSE_PATH

        }

        if (LengthWritten != BytesToWrite) {
            DbgPrint("MRxDAVWriteContinuation(2): LengthWritten(%x) != BytesToWrite(%x)\n",
                     LengthWritten, BytesToWrite);
        }

        //  
        // If we were successful, then we should have ready PAGE_SIZE bytes.
        //
        ASSERT(LengthWritten == BytesToWrite);

        TotalLengthActuallyWritten += BytesToCopy;

        //
        // If we have already written out the required number of bytes (which
        // means BytesToCopy == ByteCount), then we are done and can exit now.
        //
        if (BytesToCopy == ByteCount) {
            DavDbgTrace(DAV_TRACE_DETAIL,
                        ("%ld: MRxDAVWriteContinuation. BytesToCopy == ByteCount(1)\n",
                         PsGetCurrentThreadId()));
            goto EXIT_THE_FUNCTION;
        }

        //
        // Decrement the ByteCount by the number of bytes that have been copied.
        //
        ByteCount -= BytesToCopy;

        //
        // Increment the ByteOffset with the number of bytes that have been 
        // copied. The ByteOffset is now page aligned.
        //
        ByteOffset.QuadPart += BytesToCopy;

        //
        // Increment the UserBuffer pointer which currently points to the beginning
        // of the buffer which the user supplied by the number of bytes which have
        // been copied.
        //
        UserBuffer += BytesToCopy;

        //
        // If we acquired the DavFcb resource, then we need to release it since
        // we are done with this "read-modify-write" sequence.
        //
        if (DavFcbResourceAcquired) {
            ExReleaseResourceLite(DavFcb->DavReadModifyWriteLock);
            DavFcbResourceAcquired = FALSE;
        }
    
        DavDbgTrace(DAV_TRACE_DETAIL,
                    ("%ld: MRxDAVWriteContinuation. Case 1: ByteCount = %d"
                     " ByteOffSet.HighPart = %d, ByteOffSet.LowPart = %d\n",
                     PsGetCurrentThreadId(), ByteOffset.HighPart, ByteOffset.LowPart));

    }

    //
    // Case 2: At this stage we have copied the bytes from the unaligned offset 
    // (if it the ByteOffset was unaligned) to the next page bouandary. Now we 
    // write as many pages as we can without copying. If the end pointer is
    // aligned OR we cover the end of file, then we write out everything. If not,
    // we write out as many pages as we can.
    //
    
    //
    // We also have to be back to just writing full pages, if including the
    // "trailing bytes" would take us onto a new physical page of memory because 
    // we are doing this write under the original Mdl lock?? What does this
    // mean?? Copied this comment from Joe Linn's code in csc.nt5\readrite.c.
    //
    
    //
    // If 4200 bytes are remaining, the operation below sets BytesToWrite to
    // 4096.
    //
    BytesToWrite = ( (ByteCount >> PAGE_SHIFT) << PAGE_SHIFT );

    //
    // Get the ByteOffsetMisAlignment of the EndBytePlusOne position.
    //
    ByteOffsetMisAlignment = (EndBytePlusOne.LowPart & (PAGE_SIZE - 1));

    InMemoryMisAlignment = (ULONG)( ((ULONG_PTR)UserBuffer) & (PAGE_SIZE - 1) );
    
    if ( ( InMemoryMisAlignment == 0 ) &&
         ( (EndBytePlusOne.QuadPart) >= (FileStandardInfo.EndOfFile.QuadPart) ) ) {
        
        DavDbgTrace(DAV_TRACE_DETAIL,
                    ("%ld: MRxDAVWriteContinuation. Case 2: UserBuff Page Aligned\n",
                     PsGetCurrentThreadId()));
        
        BytesToWrite = ByteCount;
    
    }

    if ( (BytesToWrite != 0) && (BytesToWrite >= PAGE_SIZE) ) {
    
        DavDbgTrace(DAV_TRACE_DETAIL,
                    ("%ld: MRxDAVWriteContinuation. Entered Case 2\n",
                     PsGetCurrentThreadId()));
        
        if ( ( (ULONG_PTR)UserBuffer & 0x3 ) == 0 ) {
        
            DavDbgTrace(DAV_TRACE_DETAIL,
                        ("%ld: MRxDAVWriteContinuation. Case2. UserBuffer DWORD Aligned\n",
                         PsGetCurrentThreadId()));

            LengthWritten = DavReadWriteFileEx(DAV_MJ_WRITE,
                                               FALSE,
                                               FALSE,
                                               NULL,
                                               davSrvOpen->UnderlyingDeviceObject,
                                               davSrvOpen->UnderlyingFileObject,
                                               ByteOffset.QuadPart,
                                               UserBuffer,
                                               BytesToWrite,
                                               &(IoStatusBlock));
            NtStatus = IoStatusBlock.Status;

            if (NtStatus != STATUS_SUCCESS) {
                
                DavDbgTrace(DAV_TRACE_ERROR,
                            ("%ld: MRxDAVWriteContinuation/DavReadWriteFileEx(3). "
                             "NtStatus = %d\n", PsGetCurrentThreadId(), NtStatus));
                
                goto EXIT_THE_FUNCTION;
            
            } else {
            
#ifdef DAV_DEBUG_READ_WRITE_CLOSE_PATH
                
                PDAV_MR_PAGING_WRITE_ENTRY DavPagingWriteEntry = NULL;

                DavPagingWriteEntry = RxAllocatePool(PagedPool, sizeof(DAV_MR_PAGING_WRITE_ENTRY));
                if (DavPagingWriteEntry == NULL) {
                    DbgBreakPoint();
                }

                RtlZeroMemory(DavPagingWriteEntry, sizeof(DAV_MR_PAGING_WRITE_ENTRY));

                DavPagingWriteEntry->ThisThreadId = PsGetCurrentThreadId();

                DavPagingWriteEntry->LocByteOffset.QuadPart = ByteOffset.QuadPart;

                DavPagingWriteEntry->LocByteCount = BytesToWrite;

                DavPagingWriteEntry->DataBuffer = RxAllocatePool(PagedPool, BytesToWrite);

                RtlCopyMemory(DavPagingWriteEntry->DataBuffer, UserBuffer, BytesToWrite);

                wcscpy(DavPagingWriteEntry->FileName, DavFcb->FileName);

                InsertHeadList( &(FileTableEntry->DavMRPagingEntry), &(DavPagingWriteEntry->thisMPagingWriteEntry) );

#endif // DAV_DEBUG_READ_WRITE_CLOSE_PATH
            
            }
        
            if (LengthWritten != BytesToWrite) {
                DbgPrint("MRxDAVWriteContinuation(3): LengthWritten(%x) != BytesToWrite(%x)\n",
                         LengthWritten, BytesToWrite);
            }

            //  
            // If we were successful, then we should have ready PAGE_SIZE bytes.
            //
            ASSERT(LengthWritten == BytesToWrite);

            TotalLengthActuallyWritten += BytesToWrite;

            DavDbgTrace(DAV_TRACE_DETAIL,
                        ("%ld: MRxDAVWriteContinuation. Case2. BytesToWrite = %d, "
                         " LengthWritten = %d\n", PsGetCurrentThreadId(),
                         BytesToWrite, LengthWritten));

            //
            // If we have already written out the required number of bytes (which
            // means BytesToWrite == ByteCount), then we are done and can exit now.
            //
            if (BytesToWrite == ByteCount) {
                DavDbgTrace(DAV_TRACE_DETAIL,
                            ("%ld: MRxDAVWriteContinuation. BytesToCopy == ByteCount(2)\n",
                             PsGetCurrentThreadId()));
                goto EXIT_THE_FUNCTION;
            }

            //
            // Decrement the ByteCount by the number of bytes that have been copied.
            //
            ByteCount -= BytesToWrite;

            //
            // Increment the ByteOffset with the number of bytes that have been copied.
            // If the original ByteCount was > (PAGE_SIZE - ByteOffsetMisAlignment) then
            // the ByteOffset is now page aligned.
            //
            ByteOffset.QuadPart += BytesToWrite;

            //
            // Increment the UserBuffer pointer which currently points to the beginning
            // of the buffer which the user supplied by the number of bytes which have
            // been copied.
            //
            UserBuffer += BytesToWrite;

        } else {

            ULONG BytesToWriteThisIteration = 0;

            DavDbgTrace(DAV_TRACE_DETAIL,
                        ("%ld: MRxDAVWriteContinuation. Case2. UserBuffer NOT DWORD Aligned\n",
                         PsGetCurrentThreadId()));

            //
            // This is the case when the offsets are aligned but the user 
            // supplied buffer is not aligned. In such cases we have to resort 
            // to copying the user supplied buffer onto the local buffer 
            // allocated and then spin out the writes.
            //
            while (BytesToWrite > 0) {
            
                //
                // If the BytesToWrite is less than the PAGE_SIZE then we copy
                // the bytes left. If not, we write a PAGE.
                //
                BytesToWriteThisIteration = ( (BytesToWrite < PAGE_SIZE) ? BytesToWrite : PAGE_SIZE );

                //
                // Copy the memory from the UserBuffer to the AllocatedSideBuffer.
                //
                RtlCopyMemory(AllocatedSideBuffer, UserBuffer, BytesToWriteThisIteration);

                LengthWritten = DavReadWriteFileEx(DAV_MJ_WRITE,
                                                   TRUE,
                                                   FALSE,
                                                   NULL,
                                                   davSrvOpen->UnderlyingDeviceObject,
                                                   davSrvOpen->UnderlyingFileObject,
                                                   ByteOffset.QuadPart,
                                                   AllocatedSideBuffer,
                                                   BytesToWriteThisIteration,
                                                   &(IoStatusBlock));
                NtStatus = IoStatusBlock.Status;

                if (NtStatus != STATUS_SUCCESS) {
                    
                    DavDbgTrace(DAV_TRACE_ERROR,
                                ("%ld: MRxDAVWriteContinuation/DavReadWriteFileEx(4). "
                                 "NtStatus = %d\n", PsGetCurrentThreadId(), NtStatus));
                    
                    goto EXIT_THE_FUNCTION;
                
                } else {

#ifdef DAV_DEBUG_READ_WRITE_CLOSE_PATH

                    PDAV_MR_PAGING_WRITE_ENTRY DavPagingWriteEntry = NULL;

                    DavPagingWriteEntry = RxAllocatePool(PagedPool, sizeof(DAV_MR_PAGING_WRITE_ENTRY));
                    if (DavPagingWriteEntry == NULL) {
                        DbgBreakPoint();
                    }

                    RtlZeroMemory(DavPagingWriteEntry, sizeof(DAV_MR_PAGING_WRITE_ENTRY));

                    DavPagingWriteEntry->ThisThreadId = PsGetCurrentThreadId();

                    DavPagingWriteEntry->LocByteOffset.QuadPart = ByteOffset.QuadPart;

                    DavPagingWriteEntry->LocByteCount = BytesToWriteThisIteration;

                    DavPagingWriteEntry->DataBuffer = RxAllocatePool(PagedPool, BytesToWriteThisIteration);

                    RtlCopyMemory(DavPagingWriteEntry->DataBuffer, AllocatedSideBuffer, BytesToWriteThisIteration);

                    wcscpy(DavPagingWriteEntry->FileName, DavFcb->FileName);

                    InsertHeadList( &(FileTableEntry->DavMRPagingEntry), &(DavPagingWriteEntry->thisMPagingWriteEntry) );

#endif // DAV_DEBUG_READ_WRITE_CLOSE_PATH
                
                }

                if (LengthWritten != BytesToWriteThisIteration) {
                    DbgPrint("MRxDAVWriteContinuation(4): LengthWritten(%x) != BytesToWriteThisIteration(%x)\n",
                             LengthWritten, BytesToWriteThisIteration);
                }

                //  
                // If we were successful, then we should have ready PAGE_SIZE bytes.
                //
                ASSERT(LengthWritten == BytesToWriteThisIteration);

                DavDbgTrace(DAV_TRACE_DETAIL,
                            ("%ld: MRxDAVWriteContinuation. Case2. BytesToWriteThisIteration = %d, "
                             " LengthWritten = %d\n", PsGetCurrentThreadId(),
                             BytesToWriteThisIteration, LengthWritten));

                //
                // Decrement the ByteCount by the number of bytes that have been copied.
                //
                ByteCount -= LengthWritten;

                //
                // Increment the ByteOffset with the number of bytes that have been copied.
                // If the original ByteCount was > (PAGE_SIZE - ByteOffsetMisAlignment) then
                // the ByteOffset is now page aligned.
                //
                ByteOffset.QuadPart += LengthWritten;

                //
                // Increment the UserBuffer pointer which currently points to the beginning
                // of the buffer which the user supplied by the number of bytes which have
                // been copied.
                //
                UserBuffer += LengthWritten;

                TotalLengthActuallyWritten += LengthWritten;

                //
                // Subtract the LengthWritten from the number of bytes to write.
                //
                BytesToWrite -= LengthWritten;
            
            }

            //
            // IMPORTANT!!! Need to find out why if TotalLengthActuallyWritten == ByteCount
            // is TRUE we are done. This was as Joe Linn did for CSC. Ofcourse
            // if ByteCount is 0, it means we are done.
            //
            if ( (TotalLengthActuallyWritten == ByteCount) || (ByteCount == 0) ) {
                if ((TotalLengthActuallyWritten == ByteCount)) {
                    DavDbgTrace(DAV_TRACE_DETAIL,
                                ("%ld: MRxDAVWriteContinuation. Case2. TotalLengthActuallyWritten == ByteCount\n",
                                 PsGetCurrentThreadId()));
                } else {
                    DavDbgTrace(DAV_TRACE_DETAIL,
                                ("%ld: MRxDAVWriteContinuation. Case2. Leaving!!! ByteCount = 0\n",
                                 PsGetCurrentThreadId()));
                }
                goto EXIT_THE_FUNCTION;
            }
        
        }
    
        DavDbgTrace(DAV_TRACE_DETAIL,
                    ("%ld: MRxDAVWriteContinuation. Case 2: ByteCount = %d"
                     " ByteOffSet.HighPart = %d, ByteOffSet.LowPart = %d\n",
                     PsGetCurrentThreadId(), ByteOffset.HighPart, ByteOffset.LowPart));

    }
    
    //
    // CASE 3: We don't have the whole buffer, ByteCount is non zero and is less 
    // than PAGE_SIZE.
    //

    ASSERT(ByteCount != 0);
    ASSERT(ByteCount < PAGE_SIZE);
    
    //
    // Acquire the DavFcb resource exclusively before proceeding further with
    // the "read-modify-write" routing.
    //
    ExAcquireResourceExclusiveLite(DavFcb->DavReadModifyWriteLock, TRUE);
    DavFcbResourceAcquired = TRUE;
    
    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVWriteContinuation. Entered Case 3\n",
                 PsGetCurrentThreadId()));

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVWriteContinuation. Case3. ByteCount = %d\n",
                 PsGetCurrentThreadId(), ByteCount));

    RtlZeroMemory(AllocatedSideBuffer, PAGE_SIZE);
    
    LengthRead = DavReadWriteFileEx(DAV_MJ_READ,
                                    TRUE,
                                    FALSE,
                                    NULL,
                                    davSrvOpen->UnderlyingDeviceObject,
                                    davSrvOpen->UnderlyingFileObject,
                                    ByteOffset.QuadPart,
                                    AllocatedSideBuffer,
                                    PAGE_SIZE,
                                    &(IoStatusBlock));

    NtStatus = IoStatusBlock.Status;

    if (NtStatus != STATUS_SUCCESS && NtStatus != STATUS_END_OF_FILE) {
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: MRxDAVWriteContinuation/DavReadWriteFileEx(5). "
                     "NtStatus = %d\n", PsGetCurrentThreadId(), NtStatus));
        goto EXIT_THE_FUNCTION;
    }

    RtlCopyMemory(AllocatedSideBuffer, UserBuffer, ByteCount);
    
    BytesToWrite = ByteCount;

    //
    // Here, if the ByetsToWrite is not page/sector aligned, it gets so because 
    // LengthRead must be page/sector aligned.
    //
    if (BytesToWrite < LengthRead) {
        DavDbgTrace(DAV_TRACE_DETAIL,
                    ("%ld: MRxDAVWriteContinuation. Case3. BytesToWrite < LengthRead\n",
                     PsGetCurrentThreadId()));
        BytesToWrite = LengthRead;
    }

    if (BytesToWrite) {
        
        LengthWritten = DavReadWriteFileEx(DAV_MJ_WRITE,
                                           TRUE,
                                           FALSE,
                                           NULL,
                                           davSrvOpen->UnderlyingDeviceObject,
                                           davSrvOpen->UnderlyingFileObject,
                                           ByteOffset.QuadPart,
                                           AllocatedSideBuffer,
                                           BytesToWrite,
                                           &(IoStatusBlock));
        NtStatus = IoStatusBlock.Status;

        if (NtStatus != STATUS_SUCCESS) {
            
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: MRxDAVWriteContinuation/DavReadWriteFileEx(6). "
                         "NtStatus = %d\n", PsGetCurrentThreadId(), NtStatus));
            
            goto EXIT_THE_FUNCTION;
        
        } else {

#ifdef DAV_DEBUG_READ_WRITE_CLOSE_PATH

            PDAV_MR_PAGING_WRITE_ENTRY DavPagingWriteEntry = NULL;

            DavPagingWriteEntry = RxAllocatePool(PagedPool, sizeof(DAV_MR_PAGING_WRITE_ENTRY));
            if (DavPagingWriteEntry == NULL) {
                DbgBreakPoint();
            }

            RtlZeroMemory(DavPagingWriteEntry, sizeof(DAV_MR_PAGING_WRITE_ENTRY));

            DavPagingWriteEntry->ThisThreadId = PsGetCurrentThreadId();
    
            DavPagingWriteEntry->LocByteOffset.QuadPart = ByteOffset.QuadPart;

            DavPagingWriteEntry->LocByteCount = BytesToWrite;

            DavPagingWriteEntry->DataBuffer = RxAllocatePool(PagedPool, BytesToWrite);

            RtlCopyMemory(DavPagingWriteEntry->DataBuffer, AllocatedSideBuffer, BytesToWrite);

            wcscpy(DavPagingWriteEntry->FileName, DavFcb->FileName);

            InsertHeadList( &(FileTableEntry->DavMRPagingEntry), &(DavPagingWriteEntry->thisMPagingWriteEntry) );

#endif // DAV_DEBUG_READ_WRITE_CLOSE_PATH
        
        }

        if (LengthWritten != BytesToWrite) {
            DbgPrint("MRxDAVWriteContinuation(5): LengthWritten(%x) != BytesToWrite(%x)\n",
                     LengthWritten, BytesToWrite);
        }

        //  
        // If we were successful, then we should have ready PAGE_SIZE bytes.
        //
        ASSERT(LengthWritten == BytesToWrite);

        //
        // Even though we might have written more than ByteCount, the actual 
        // amount of User data written is ByteCount bytes.
        //
        TotalLengthActuallyWritten += ByteCount;
    
    }

    //
    // If we acquired the DavFcb resource, then we need to release it since
    // we are done with this "read-modify-write" sequence.
    //
    if (DavFcbResourceAcquired) {
        ExReleaseResourceLite(DavFcb->DavReadModifyWriteLock);
        DavFcbResourceAcquired = FALSE;
    }

EXIT_THE_FUNCTION:

    //
    // We allocate a page size buffer for the read and the write operations. We
    // need to free it now.
    //
    if (AllocatedSideBuffer) {
        RxFreePool(AllocatedSideBuffer);
    }

    //
    // If we succeeded, we do the following:
    // 1. Update the filesize in the namecache just in case we extended the file
    //    or reduced the filesize. In case when the filesize does not change,
    //    this is a no-op.
    // 2. Mark this file as being modified. When the Close happens, we check
    //    whether the file has been modified and PUT the file on the server.
    // 3. Set DoNotTakeTheCurrentTimeAsLMT to FALSE since the file has been
    //    modified, we need to take the CurrentTime as LMT (Last Modified Time).
    //
    if (NtStatus == STATUS_SUCCESS) {

        DavDbgTrace(DAV_TRACE_DETAIL,
                    ("%ld: MRxDAVWriteContinuation. NewFileSize.HighPart = %x, NewFileSize.LowPart = %x\n",
                     PsGetCurrentThreadId(),
                     RxContext->pFcb->Header.FileSize.HighPart,
                     RxContext->pFcb->Header.FileSize.LowPart));

        MRxDAVUpdateFileInfoCacheFileSize(RxContext, &(RxContext->pFcb->Header.FileSize));

        InterlockedExchange(&(DavFcb->FileWasModified), 1);

        DavFcb->DoNotTakeTheCurrentTimeAsLMT = FALSE;

    }

    //
    // If we acquired the DavFcb resource and came down through some error path,
    // and have not released the resource then we need to release it now.
    //
    if (DavFcbResourceAcquired) {
        ExReleaseResourceLite(DavFcb->DavReadModifyWriteLock);
        DavFcbResourceAcquired = FALSE;
    }

    //
    // We need to remove the reference we took at the beginning of this
    // routine.
    //
    UMRxResumeAsyncEngineContext(RxContext);

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Leaving MRxDAVWriteContinuation. NtStatus = %08lx, "
                 "TotalLengthActuallyWritten = %d\n", 
                 PsGetCurrentThreadId(), NtStatus, TotalLengthActuallyWritten));
    
    AsyncEngineContext->Status = NtStatus;

#ifdef DAV_DEBUG_READ_WRITE_CLOSE_PATH
   
    if (NtStatus == STATUS_SUCCESS) {
        
        PDAV_MR_WRITE_ENTRY DavMRWriteEntry = NULL;
        PBYTE ThisBuffer = NULL;
        
        if ( RxContext->pRelevantSrvOpen->pAlreadyPrefixedName != NULL &&
             RxContext->pRelevantSrvOpen->pAlreadyPrefixedName->Length > 0 ) {
            

            DavMRWriteEntry = RxAllocatePool(PagedPool, sizeof(DAV_MR_WRITE_ENTRY));
            if (DavMRWriteEntry == NULL) {
                DbgBreakPoint();
            }

            RtlZeroMemory(DavMRWriteEntry, sizeof(DAV_RDBSS_WRITE_ENTRY));

            DavMRWriteEntry->DataBuffer = RxAllocatePool(PagedPool, LowIoContext->ParamsFor.ReadWrite.ByteCount);
            if (DavMRWriteEntry->DataBuffer == NULL) {
                DbgBreakPoint();
            }

            ThisBuffer = RxLowIoGetBufferAddress(RxContext);

            RtlCopyMemory((PBYTE)DavMRWriteEntry->DataBuffer,
                          ThisBuffer,
                          LowIoContext->ParamsFor.ReadWrite.ByteCount);

            wcscpy(DavMRWriteEntry->FileName, DavFcb->FileName);

            DavMRWriteEntry->ThisThreadId = PsGetCurrentThreadId();

            DavMRWriteEntry->LocByteCount = LowIoContext->ParamsFor.ReadWrite.ByteCount;

            DavMRWriteEntry->LocByteOffset.QuadPart = LowIoContext->ParamsFor.ReadWrite.ByteOffset;

            InsertHeadList( &(FileTableEntry->DavMREntry), &(DavMRWriteEntry->thisMWriteEntry) );

        }
    
    }

#endif // DAV_DEBUG_READ_WRITE_CLOSE_PATH

    //
    // We need to set these values in the RxContext. There is code in RDBSS
    // which takes care of putting these values in the IRP.
    //
    RxContext->StoredStatus = NtStatus;
    RxContext->InformationToReturn = TotalLengthActuallyWritten;

    return NtStatus;
}


ULONG
MRxDAVExtendForCache(
    IN OUT PRX_CONTEXT RxContext,
    IN OUT PLARGE_INTEGER NewFileSize,
    OUT PLARGE_INTEGER NewAllocationSize
    )
/*++

Routine Description:

    This routines reserves the necessary space for a file which is being 
    extended. This reservation occurs before the actual write takes place. This
    routine handles the case for a cached file.

Arguments:

    RxContext - The RDBSS context.
    
    NewFileSize - The new file size after the write.
    
    NewAllocationSize - The allocation size reserved.
    
Return Value:

    The return status for the operation.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    PAGED_CODE();

    NewAllocationSize->QuadPart = NewFileSize->QuadPart;
    MRxDAVUpdateFileInfoCacheFileSize(RxContext, NewFileSize);

    return NtStatus;
}


ULONG
MRxDAVExtendForNonCache(
    IN OUT PRX_CONTEXT RxContext,
    IN OUT PLARGE_INTEGER NewFileSize,
    OUT PLARGE_INTEGER NewAllocationSize
    )
/*++

Routine Description:

    This routines reserves the necessary space for a file which is being 
    extended. This reservation occurs before the actual write takes place. This
    routine handles the case for a non-cached file.

Arguments:

    RxContext - The RDBSS context.
    
    NewFileSize - The new file size after the write.
    
    NewAllocationSize - The allocation size reserved.
    
Return Value:

    The return status for the operation.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    PAGED_CODE();

    NewAllocationSize->QuadPart = NewFileSize->QuadPart;
    MRxDAVUpdateFileInfoCacheFileSize(RxContext, NewFileSize);

    return NtStatus;
}


BOOLEAN
MRxDAVFastIoWrite(
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    This is the routine that handles fast I/O for write operation.

Arguments:

Return Value:

    TRUE (succeeded) or FALSE.

--*/
{
    BOOLEAN ReturnVal = FALSE;

    PAGED_CODE();

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Entered MRxDAVFastIoWrite.\n", PsGetCurrentThreadId()));
    
    IoStatus->Status = STATUS_NOT_IMPLEMENTED;
    IoStatus->Information = 0;

    return (ReturnVal);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\server\davcreat.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    davcreat.c

Abstract:

    This module implements the user mode DAV miniredir routine(s) pertaining to
    creation of files.

Author:

    Rohan Kumar      [RohanK]      30-March-1999

Revision History:

Notes:

    Webdav Service is running in Local Services group. The local cache of the 
    URL is stored in the Local Services profile directories. These directories
    have the ACLs set to allow Local Services and Local System to access. 
    
    The encryption is done on the local cache file. Since encrypted file can
    only be operated in the user context, We have to impersonate before access
    the local cache file. In order to get the access to the file that is created
    in the Local Services profile directory in the user's context, we need to
    set the ACL to the encrypted file to allow everybody to access it. It won't
    result in a security hole because the file is encrypted.

--*/

#include "pch.h"
#pragma hdrstop

#include "ntumrefl.h"
#include "usrmddav.h"
#include "global.h"
#include "nodefac.h"
#include "efsstruc.h" // For EFS Stuff.
#include "UniUtf.h"
#include <sddl.h>

#define SECURITY_WIN32 // needed by security.h
#include <security.h>
#include <secext.h>

#define FILE_SIGNATURE    L"ROBS"
#define STREAM_SIGNATURE  L"NTFS"
#define DATA_SIGNATURE    L"GURE"


BOOL
DavIsThisFileEncrypted(
    PVOID DataBuff
    );

ULONG
DavCheckSignature(
    PVOID Signature
    );

DWORD
DavRestoreEncryptedFile(
    PWCHAR ExportFile,
    PWCHAR ImportFile
    );

DWORD
DavWriteRawCallback(
    PBYTE DataBuff,
    PVOID CallbackContext,
    PULONG DataLength
    );

DWORD
DavReuseCacheFileIfNotModified(
    IN PDAV_USERMODE_WORKITEM pDavWorkItem
    );


DWORD
DavCreateUrlCacheEntry(
    IN PDAV_USERMODE_WORKITEM pDavWorkItem
    );

DWORD
DavCommitUrlCacheEntry(
    IN PDAV_USERMODE_WORKITEM pDavWorkItem
    );

DWORD
DavSetAclForEncryptedFile(
    PWCHAR FilePath
    );

DWORD
DavGetUrlCacheEntry(
    IN PDAV_USERMODE_WORKITEM pDavWorkItem
    );

DWORD
DavAddIfModifiedSinceHeader(
    IN PDAV_USERMODE_WORKITEM pDavWorkItem
    );

DWORD
DavQueryUrlCacheEntry(
    IN PDAV_USERMODE_WORKITEM pDavWorkItem
    );

DWORD
DavAsyncCreatePropFind(
    PDAV_USERMODE_WORKITEM DavWorkItem
    );

DWORD
DavAsyncCreateQueryParentDirectory(
    PDAV_USERMODE_WORKITEM DavWorkItem
    );

DWORD
DavAsyncCreateGet(
    PDAV_USERMODE_WORKITEM DavWorkItem
    );

DWORD
DavLockTheFileOnTheServer(
    IN PDAV_USERMODE_WORKITEM DavWorkItem
    );

//
// The maximum file size that is allowed by the WebDAV Redir. We keep a limit
// on the file size to avoid being attacked by a rogue server. A rogue server
// could keep on sending infinite amount of data which can cause the WebClient
// service to use 100% of the CPU.
//
ULONG DavFileSizeLimitInBytes;

//
// The maximum attributes size that is allowed by the WebDAV Redir. We keep a
// limit on this size to avoid being attacked by a rogue server. A rogue server
// could keep on sending infinite amount of data which can cause the WebClient
// service to use 100% of the CPU. This attribute limit covers all the 
// PROPFIND and PROPPATCH responses. For PROPFINDs with Depth 1 we make the
// limit a multiple of DavFileAttributesLimitInBytes (10 times).
//
ULONG DavFileAttributesLimitInBytes;

#define FileCacheExpiryInterval 600000000 // 60 seconds

CHAR   rgchIMS[] = "If-Modified-Since";

CHAR rgHttpHeader[] = "Content-Type: text/xml; charset=\"utf-8\"";
CHAR rgLockInfoHeader[] = "<?xml version=\"1.0\" encoding=\"utf-8\" ?><D:lockinfo xmlns:D=\"DAV:\">";
CHAR rgLockInfoTrailer[] = "</D:lockinfo>";
CHAR rgLockScopeHeader[] = "<D:lockscope><D:exclusive/></D:lockscope>";
CHAR rgLockTypeHeader[] = "<D:locktype><D:write/></D:locktype>";
CHAR rgOwnerHeader[] = "<D:owner><D:href>";
CHAR rgOwnerTrailer[] = "</D:href></D:owner>";

//
// Implementation of functions begins here.
//

ULONG
DavFsCreate(
    PDAV_USERMODE_WORKITEM DavWorkItem
    )
/*++

Routine Description:

    This routine handles DAV create/open requests that get reflected from the
    kernel.

Arguments:

    DavWorkItem - The buffer that contains the request parameters and options.

Return Value:

    The return status for the operation

--*/
{
    ULONG WStatus = ERROR_SUCCESS;
    HINTERNET DavConnHandle;
    PWCHAR ServerName = NULL, FileName = NULL, CanName, UrlBuffer = NULL;
    PWCHAR CompletePathName, cPtr, FileNameBuff = NULL;
    DWORD urlLength = 0, ServerLen, ServerLenInBytes, PathLen, PathLenInBytes;
    DWORD FileNameBuffBytes, i = 0, ServerID;
    ULONG_PTR CallBackContext = (ULONG_PTR)0;
    BOOL ReturnVal, CallBackContextInitialized = FALSE, EnCriSec = FALSE;
    BOOL didImpersonate = FALSE;
    URL_COMPONENTSW UrlComponents;
    PDAV_USERMODE_CREATE_REQUEST CreateRequest;
    PDAV_USERMODE_CREATE_RESPONSE CreateResponse;
    PPER_USER_ENTRY PerUserEntry = NULL;
    PHASH_SERVER_ENTRY ServerHashEntry = NULL;
    PUMRX_USERMODE_WORKITEM_HEADER UserWorkItem = NULL;
    BOOL BStatus = FALSE;

    //
    // Get the request buffer pointers from the DavWorkItem.
    //
    CreateRequest = &(DavWorkItem->CreateRequest);
    CreateResponse = &(DavWorkItem->CreateResponse);
    ServerID = CreateRequest->ServerID;

    //
    // If the complete path name is NULL, then we have nothing to create.
    //
    if (CreateRequest->CompletePathName == NULL) {
        DavPrint((DEBUG_ERRORS,
                  "DavFsCreate: ERROR: CompletePathName is NULL.\n"));
        WStatus = ERROR_INVALID_PARAMETER; // STATUS_INVALID_PARAMETER;
        goto EXIT_THE_FUNCTION;
    }

    UserWorkItem = (PUMRX_USERMODE_WORKITEM_HEADER)DavWorkItem;

    //
    // CreateRequest->CompletePathName contains the complete path name.
    //

    DavPrint((DEBUG_MISC, "DavFsCreate: DavWorkItem = %08lx\n", DavWorkItem));

    DavPrint((DEBUG_MISC, "DavFsCreate: CompletePathName: %ws\n", CreateRequest->CompletePathName));

    //
    // We need to do some name munging, if the create is because of a local
    // drive being mapped to a UNC name. The fomat in that case would be
    // \;X:0\server\share
    //
    if ( CreateRequest->CompletePathName[1] == L';') {
        CompletePathName = &(CreateRequest->CompletePathName[6]);
    } else {
        CompletePathName = &(CreateRequest->CompletePathName[1]);
    }
    
    //
    // Here, we parse the Complete path name and remove the server name and the
    // file name from it. We use these to construct the URL for the WinInet
    // calls. The complete path name is of the form \server\filename.
    // The name ends with a '\0'. Note that the filename could be of the form
    // share\foo\bar\duh.txt.
    //

    //       [\;X:0]\server\filename
    //               ^
    //               |
    //               CompletePathName(CPN)


    //              \server\filename
    //               ^     ^
    //               |     |
    //               CPN   cPtr
    cPtr = wcschr(CompletePathName, '\\');

    //
    // Length of the server name including the terminating '\0' char.
    //
    ServerLen = 1 + (((PBYTE)cPtr - (PBYTE)CompletePathName) / sizeof(WCHAR));
    ServerLenInBytes = ServerLen * sizeof(WCHAR);

    //              \server\filename
    //               ^      ^
    //               |      |
    //               CPN    cPtr
    cPtr++;

    //
    // Length of the server name including the terminating '\0' char.
    //
    PathLen = 1 + wcslen(cPtr);
    PathLenInBytes = PathLen * sizeof(WCHAR);

    //
    // Allocate the memory and fill in the server name char by char.
    //
    ServerName = (PWCHAR) LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT,
                                     ServerLenInBytes);
    if (ServerName == NULL) {
        WStatus = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavFsCreate/LocalAlloc. Error Val = %d\n",
                  WStatus));
        goto EXIT_THE_FUNCTION;
    }

    //              \server\filename
    //               ^^^^^^ ^
    //               |||||| |
    //               CPN    cPtr
    while(CompletePathName[i] != '\\') {
        ASSERT(i < ServerLen);
        ServerName[i] = CompletePathName[i];
        i++;
    }
    ASSERT((i + 1) == ServerLen);
    ServerName[i] = '\0';

    //
    // Allocate the memory and copy the file name.
    //
    FileName = (PWCHAR) LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, PathLenInBytes);
    if (FileName == NULL) {
        WStatus = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavFsCreate/LocalAlloc. Error Val = %d\n",
                  WStatus));
        goto EXIT_THE_FUNCTION;
    }

    //
    // This remaining path name is needed in Async Create Callback function.
    //
    DavWorkItem->AsyncCreate.RemPathName = FileName;

    wcscpy(FileName, cPtr);

    CanName = FileName;

    //
    // The file name can contain \ characters. Replace them by / characters.
    //
    while (*CanName) {
        if (*CanName == L'\\') {
            *CanName = L'/';
        }
        CanName++;
    }

    //
    // Check if this is a stream, if so, bailout right from here.
    //
    if(wcschr(FileName, L':')) {
        WStatus = ERROR_INVALID_NAME;
        DavPrint((DEBUG_ERRORS, "DavFsCreate: Streams Not Supported\n"));
        goto EXIT_THE_FUNCTION;
    }

    //
    // If we have a dummy share name in the FileName, we need to remove it 
    // right now before we contact the server.
    //
    DavRemoveDummyShareFromFileName(FileName);

    DavPrint((DEBUG_MISC,
             "DavFsCreate: ServerName: %ws, File Name: %ws\n",
             ServerName, FileName));

    //
    // Create the URL to be sent to the server. Initialize the UrlComponents
    // structure before making the call.
    //
    UrlComponents.dwStructSize = sizeof(URL_COMPONENTSW);
    UrlComponents.lpszScheme = NULL;
    UrlComponents.dwSchemeLength = 0;
    UrlComponents.nScheme = INTERNET_SCHEME_HTTP;
    UrlComponents.lpszHostName = ServerName;
    UrlComponents.dwHostNameLength = wcslen(ServerName);
    UrlComponents.nPort = DEFAULT_HTTP_PORT;
    UrlComponents.lpszUserName = NULL;
    UrlComponents.dwUserNameLength = 0;
    UrlComponents.lpszPassword = NULL;
    UrlComponents.dwPasswordLength = 0;
    UrlComponents.lpszUrlPath = FileName;
    UrlComponents.dwUrlPathLength = wcslen(FileName);
    UrlComponents.lpszExtraInfo = NULL;
    UrlComponents.dwExtraInfoLength = 0;
    ReturnVal = InternetCreateUrlW(&(UrlComponents),
                                   0,
                                   NULL,
                                   &(urlLength));
    if (!ReturnVal) {

        ULONG urlLengthInWChars = 0;

        WStatus = GetLastError();

        // 
        // We pre-allocate the Url buffer on the CreateResponse with the size of
        // MAX_PATH * 2. Any Url longer than that will overrun the buffer. The Url
        // will be used to update the LastAccessTime of the WinInet cache on rename 
        // and close later. Note urlLength is the number of bytes.
        //
        if (urlLength >= MAX_PATH * 4) {
            WStatus = ERROR_NO_SYSTEM_RESOURCES;
            goto EXIT_THE_FUNCTION;
        }

        if (WStatus == ERROR_INSUFFICIENT_BUFFER) {

            UrlBuffer = (PWCHAR) LocalAlloc (LMEM_FIXED | LMEM_ZEROINIT,
                                             urlLength);
            if (UrlBuffer != NULL) {

                ZeroMemory(UrlBuffer, urlLength);

                //
                // This UrlBuffer is needed in Async Create Callback function.
                // We need to supply the length (4th Parameter) in WChars.
                //
                DavWorkItem->AsyncCreate.UrlBuffer = UrlBuffer;

                urlLengthInWChars = ( urlLength/sizeof(WCHAR) );

                ReturnVal = InternetCreateUrlW(&(UrlComponents),
                                               0,
                                               UrlBuffer,
                                               &(urlLengthInWChars));
                if (!ReturnVal) {
                    WStatus = GetLastError();
                    DavPrint((DEBUG_ERRORS,
                              "DavFsCreate/InternetCreateUrl. Error Val = %d\n",
                              WStatus));
                    goto EXIT_THE_FUNCTION;
                }

            } else {

                WStatus = GetLastError();

                DavPrint((DEBUG_ERRORS,
                          "DavFsCreate/LocalAlloc. Error Val = %d\n",
                          WStatus));

                goto EXIT_THE_FUNCTION;

            }

        } else {

            DavPrint((DEBUG_ERRORS,
                      "DavFsCreate/InternetCreateUrl. Error Val = %d\n",
                      WStatus));

            goto EXIT_THE_FUNCTION;

        }

    }
    
    DavPrint((DEBUG_MISC, "URL: %ws\n", UrlBuffer));
    
    //
    // We need to call this only if "DAV_USE_WININET_ASYNCHRONOUSLY" has been
    // defined. Otherwise, if we are using WinInet synchronously, then we 
    // would have already done this in the DavWorkerThread function. This 
    // ultimately gets deleted (the impersonation token that is) in the 
    // DavAsyncCreateCompletion function.
    //
#ifdef DAV_USE_WININET_ASYNCHRONOUSLY

    //
    // Set the DavCallBackContext.
    //
    WStatus = DavFsSetTheDavCallBackContext(DavWorkItem);
    if (WStatus != ERROR_SUCCESS) {
        DavPrint((DEBUG_ERRORS,
                  "DavFsCreate/DavFsSetTheDavCallBackContext. Error Val = %d\n",
                  WStatus));
        goto EXIT_THE_FUNCTION;
    }
    CallBackContextInitialized = TRUE;

    //
    // Store the address of the DavWorkItem which serves as a callback in the
    // variable CallBackContext. This will now be used in all the async calls
    // that follow. This needs to be done only if we are calling the WinInet
    // APIs asynchronously.
    //
    CallBackContext = (ULONG_PTR)(DavWorkItem);

#endif

    //
    // Allocate memory for the INTERNET_ASYNC_RESULT structure.
    //
    DavWorkItem->AsyncResult = LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT,
                                          sizeof(INTERNET_ASYNC_RESULT));
    if (DavWorkItem->AsyncResult == NULL) {
        WStatus = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavFsCreate/LocalAlloc. Error Val = %d\n",
                  WStatus));
        goto EXIT_THE_FUNCTION;
    }

    DavPrint((DEBUG_MISC,
              "DavFsCreate: LogonId.LowPart = %d, LogonId.HighPart = %d\n",
              CreateRequest->LogonID.LowPart, CreateRequest->LogonID.HighPart));
    
    //
    // Find out whether we already have a "InternetConnect" handle to the
    // server. One could have been created during the CreateSrvCall process.
    // We can check the per user entries hanging off this server to see if an
    // entry for this user exists. If it does, use the InternetConnect handle
    // to do the HttpOpen. Otherwise, create and entry for this user and add it
    // to the list of the per user entries of the server.
    //

    //
    // Now check whether this user has an entry hanging off the server entry in
    // the hash table. Obviously, we have to take a lock before accessing the
    // server entries of the hash table.
    //
    EnterCriticalSection( &(HashServerEntryTableLock) );
    EnCriSec = TRUE;

    ReturnVal = DavDoesUserEntryExist(ServerName,
                                      ServerID,
                                      &(CreateRequest->LogonID),
                                      &PerUserEntry,
                                      &ServerHashEntry);

    //
    // If the Create request in the kernel get cancelled even before the 
    // corresponding usermode thread gets a chance to execute this code, then
    // it possible that the VNetRoot (hence the PerUserEntry) and SrvCall get
    // finalized before the thread that is handling the create comes here. This
    // could happen if this request was the only one for this share and the
    // server as well. This is why we need to check if the ServerHashEntry and
    // the PerUserEntry are valid before proceeding.
    //
    if (ReturnVal == FALSE || ServerHashEntry == NULL || PerUserEntry == NULL) {
        WStatus = ERROR_CANCELLED;
        DavPrint((DEBUG_ERRORS, "DavFsCreate: (ServerHashEntry == NULL || PerUserEntry == NULL)\n"));
        goto EXIT_THE_FUNCTION;
    }

    DavWorkItem->AsyncCreate.ServerHashEntry = ServerHashEntry;

    DavWorkItem->AsyncCreate.PerUserEntry = PerUserEntry;

    //
    // Add a reference to the user entry.
    //
    PerUserEntry->UserEntryRefCount++;

    //
    // Since a create had succeeded earlier, the entry must be good.
    //
    ASSERT(PerUserEntry->UserEntryState == UserEntryInitialized);
    ASSERT(PerUserEntry->DavConnHandle != NULL);
    DavConnHandle = PerUserEntry->DavConnHandle;
        
    //
    // And yes, we obviously have to leave the critical section
    // before returning.
    //
    LeaveCriticalSection( &(HashServerEntryTableLock) );
    EnCriSec = FALSE;

    //
    // If we are using WinInet synchronously, then we need to impersonate the
    // clients context now. We shouldn't do it before we call CreateUrlCacheEntry
    // because that call will fail if the thread is not running in the context
    // of the Web Client Service.
    //
#ifndef DAV_USE_WININET_ASYNCHRONOUSLY
    
    WStatus = UMReflectorImpersonate(UserWorkItem, DavWorkItem->ImpersonationHandle);
    if (WStatus != ERROR_SUCCESS) {
        DavPrint((DEBUG_ERRORS,
                  "DavFsCreate/UMReflectorImpersonate. Error Val = %d\n",
                  WStatus));
        goto EXIT_THE_FUNCTION;
    }
    didImpersonate = TRUE;

#endif
    
    //
    // We now call the HttpOpenRequest function and return.
    //
    DavWorkItem->DavOperation = DAV_CALLBACK_HTTP_OPEN;

    DavPrint((DEBUG_MISC, "DavFsCreate: DavConnHandle = %08lx.\n", DavConnHandle));

    DavWorkItem->AsyncCreate.AsyncCreateState = AsyncCreatePropFind;
    DavWorkItem->DavMinorOperation = DavMinorQueryInfo;
    DavWorkItem->AsyncCreate.DataBuff = NULL;
    DavWorkItem->AsyncCreate.didRead = NULL;
    DavWorkItem->AsyncCreate.Context1 = NULL;
    DavWorkItem->AsyncCreate.Context2 = NULL;

    if (CreateRequest->FileInformationCached) {
        DavPrint((DEBUG_MISC,
                 "Cached info   %x %x %x %ws\n",
                 CreateResponse->BasicInformation.FileAttributes,
                 CreateResponse->StandardInformation.AllocationSize.LowPart,
                 CreateResponse->StandardInformation.EndOfFile.LowPart,
                 DavWorkItem->AsyncCreate.UrlBuffer));
    }

    if ((CreateRequest->FileNotExists) || (CreateRequest->FileInformationCached)) {

        FILE_BASIC_INFORMATION BasicInformation = CreateResponse->BasicInformation;
        FILE_STANDARD_INFORMATION StandardInformation = CreateResponse->StandardInformation;

        RtlZeroMemory(CreateResponse, sizeof(*CreateResponse));

        //
        // Restore the file information on the create request
        //
        if (CreateRequest->FileInformationCached) {
            CreateResponse->BasicInformation = BasicInformation;
            CreateResponse->StandardInformation = StandardInformation;
            DavWorkItem->AsyncCreate.doesTheFileExist = TRUE;
        }

        if (!didImpersonate) {
            WStatus = UMReflectorImpersonate(UserWorkItem, DavWorkItem->ImpersonationHandle);
            if (WStatus != ERROR_SUCCESS) {
                DavPrint((DEBUG_ERRORS,
                          "DavFsCreate/UMReflectorImpersonate. Error Val = %d\n",
                          WStatus));
                goto EXIT_THE_FUNCTION;
            }
            didImpersonate = TRUE;
        }
        
        DavPrint((DEBUG_MISC,
                 "DavFsCreate skip PROPFIND for %x %x %ws\n", 
                 CreateRequest->FileAttributes,
                 CreateResponse->BasicInformation.FileAttributes,
                 DavWorkItem->AsyncCreate.UrlBuffer));

        WStatus = DavAsyncCreatePropFind(DavWorkItem);

    } else {

        RtlZeroMemory(CreateResponse, sizeof(*CreateResponse));

        //
        // Convert the unicode object name to UTF-8 URL format. Space and other 
        // white characters will remain untouched. These should be taken care of by 
        // the wininet calls.
        //
        BStatus = DavHttpOpenRequestW(DavConnHandle,
                                      L"PROPFIND",
                                      FileName,
                                      L"HTTP/1.1",
                                      NULL,
                                      NULL,
                                      INTERNET_FLAG_KEEP_CONNECTION |
                                      INTERNET_FLAG_RESYNCHRONIZE |
                                      INTERNET_FLAG_NO_COOKIES,
                                      CallBackContext,
                                      L"DavFsCreate",
                                      &(DavWorkItem->AsyncCreate.DavOpenHandle));
        if(BStatus == FALSE) {
            WStatus = GetLastError();
            goto EXIT_THE_FUNCTION;
        }

        if (DavWorkItem->AsyncCreate.DavOpenHandle == NULL) {
            WStatus = GetLastError();
            if (WStatus != ERROR_IO_PENDING) {
                DavPrint((DEBUG_ERRORS,
                          "DavFsCreate/HttpOpenRequestW. Error Val = %d.\n",
                          WStatus));
            }
            goto EXIT_THE_FUNCTION;
        }

        WStatus = DavAsyncCommonStates(DavWorkItem, FALSE);
        if (WStatus != ERROR_SUCCESS && WStatus != ERROR_IO_PENDING && WStatus != ERROR_FILE_NOT_FOUND) {
            DavPrint((DEBUG_ERRORS,
                      "DavFsCreate/DavAsyncCommonStates. Error Val = %08lx\n",
                      WStatus));
        }

    }

EXIT_THE_FUNCTION: // Do the necessary cleanup and return.

    //
    // We could have taken the lock and come down an error path without
    // releasing it. If thats the case, then we need to release the lock now.
    //
    if (EnCriSec) {
        LeaveCriticalSection( &(HashServerEntryTableLock) );
        EnCriSec = FALSE;
    }

    if (ServerName != NULL) {
        HLOCAL FreeHandle;
        ULONG FreeStatus;
        FreeHandle = LocalFree((HLOCAL)ServerName);
        if (FreeHandle != NULL) {
            FreeStatus = GetLastError();
            DavPrint((DEBUG_ERRORS, "DavFsCreate/LocalFree. Error Val = %d\n", FreeStatus));
        }
    }

    if (WStatus == ERROR_SUCCESS) {

        wcscpy(CreateResponse->Url, DavWorkItem->AsyncCreate.UrlBuffer);

        DavPrint((DEBUG_MISC,
                 "Returned info %x %x %x %ws\n",
                 CreateResponse->BasicInformation.FileAttributes,
                 CreateResponse->StandardInformation.AllocationSize.LowPart,
                 CreateResponse->StandardInformation.EndOfFile.LowPart,
                 DavWorkItem->AsyncCreate.UrlBuffer));

    }

    //
    // If the Create failed after taking a LOCK on the file, then we need to
    // UNLOCK the file before returning.
    //
    if (WStatus != ERROR_SUCCESS) {
        if (CreateResponse->LockWasTakenOnThisCreate) {
            ULONG UnLockStatus;
            if (!didImpersonate) {
                UnLockStatus = UMReflectorImpersonate(UserWorkItem, DavWorkItem->ImpersonationHandle);
                if (UnLockStatus != ERROR_SUCCESS) {
                    DavPrint((DEBUG_ERRORS,
                              "DavFsCreate/UMReflectorImpersonate. Error Val = %d\n",
                              UnLockStatus));
                } else {
                    didImpersonate = TRUE;
                }
            }
            UnLockStatus = DavUnLockTheFileOnTheServer(DavWorkItem);
            if (UnLockStatus != ERROR_SUCCESS) {
                DavPrint((DEBUG_ERRORS,
                          "DavFsCreate/DavUnLockTheFileOnTheServer. Error Val = %d\n",
                          UnLockStatus));
            }
            CreateResponse->LockWasTakenOnThisCreate = FALSE;
        }
    }

#ifdef DAV_USE_WININET_ASYNCHRONOUSLY

    //
    // Some resources should not be freed if we are returning ERROR_IO_PENDING
    // because they will be used in the callback functions.
    //
    if (WStatus != ERROR_IO_PENDING) {

        //
        // Set the return status of the operation. This is used by the kernel
        // mode routines to figure out the completion status of the user mode
        // request.
        //
        if (WStatus != ERROR_SUCCESS) {
            DavWorkItem->Status = DavMapErrorToNtStatus(WStatus);
        } else {
            DavWorkItem->Status = STATUS_SUCCESS;
        }
        
        DavAsyncCreateCompletion(DavWorkItem);

    } else {
        DavPrint((DEBUG_MISC, "DavFsCreate: Returning ERROR_IO_PENDING.\n"));
    }

#else

    //
    // If we are using WinInet synchronously, then we should never get back
    // ERROR_IO_PENDING from WinInet.
    //
    ASSERT(WStatus != ERROR_IO_PENDING);

    //
    // If this thread impersonated a user, we need to revert back.
    //
    if (didImpersonate) {
        RevertToSelf();
        didImpersonate = FALSE;
    }

    //
    // Set the return status of the operation. This is used by the kernel
    // mode routines to figure out the completion status of the user mode
    // request. This is done here because the async completion routine that is
    // called immediately afterwards needs the status set.
    //
    if (WStatus != ERROR_SUCCESS) {
        
        DavWorkItem->Status = DavMapErrorToNtStatus(WStatus);
        
        //
        // The error cannot map to STATUS_SUCCESS. If it does, we need to
        // break here and investigate.
        //
        if (DavWorkItem->Status == STATUS_SUCCESS) {
            DbgBreakPoint();
        }
    
    } else {
        
        PDAV_USERMODE_CREATE_RESPONSE CreateResponse;
        
        CreateResponse = &(DavWorkItem->CreateResponse);

        DavWorkItem->Status = STATUS_SUCCESS;

        //
        // If we suceeded and it was a file and the open was not a pseudo open, 
        // the handle should be set. Otherwise we screwed up. We should then 
        // break here and investigate.
        //
        if ( !(CreateResponse->StandardInformation.Directory) && 
             !(CreateResponse->fPsuedoOpen) ) {
            if (CreateResponse->Handle == NULL) {
                DbgBreakPoint();
            }
        }
    
    }
    
    DavAsyncCreateCompletion(DavWorkItem);

#endif

    return WStatus;
}


DWORD
DavAsyncCreate(
    PDAV_USERMODE_WORKITEM DavWorkItem,
    BOOLEAN CalledByCallBackThread
    )
/*++

Routine Description:

   This is the callback routine for the create operation.

Arguments:

    DavWorkItem - The DAV_USERMODE_WORKITEM value.

    CalledByCallbackThread - TRUE, if this function was called by the thread
                             which picks of the DavWorkItem from the Callback
                             function. This happens when an Async WinInet call
                             returns ERROR_IO_PENDING and completes later.

Return Value:

    ERROR_SUCCESS or the appropriate error value.

--*/
{
    ULONG WStatus = ERROR_SUCCESS;
    NTSTATUS NtStatus = STATUS_SUCCESS;
    ULONG NumOfFileEntries = 0;
    PUMRX_USERMODE_WORKITEM_HEADER UserWorkItem = NULL;
    BOOL ReturnVal, didImpersonate = FALSE, readDone = FALSE;
    BOOL doesTheFileExist = FALSE;
    HANDLE FileHandle = INVALID_HANDLE_VALUE;
    DWORD toRead = 0, didRead = 0, didWrite = 0;
    LPDWORD NumRead = NULL;
    PVOID Ctx1 = NULL, Ctx2 = NULL;
    PDAV_FILE_ATTRIBUTES DavFileAttributes;
    PCHAR DataBuff = NULL;
    DWORD DataBuffBytes;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatusBlock;
    SECURITY_QUALITY_OF_SERVICE QualityOfService;
    PDAV_USERMODE_CREATE_REQUEST CreateRequest;
    PDAV_USERMODE_CREATE_RESPONSE CreateResponse;
    ULONG_PTR CallBackContext = (ULONG_PTR)0;
    PWCHAR pEncryptedCachedFile = NULL;
    PDAV_FILE_ATTRIBUTES DavDirectoryAttributes = NULL;
    ACCESS_MASK DesiredAccess = 0;
    BOOL BStatus = FALSE, fCacheFileReused = FALSE;

    //
    // Get the request and response buffer pointers from the DavWorkItem.
    //
    CreateRequest = &(DavWorkItem->CreateRequest);
    CreateResponse = &(DavWorkItem->CreateResponse);
    CreateResponse->fPsuedoOpen = FALSE;

    UserWorkItem = (PUMRX_USERMODE_WORKITEM_HEADER)DavWorkItem;

#ifdef DAV_USE_WININET_ASYNCHRONOUSLY

    //
    // We set the CallbackContext only if we are calling the WinInet APIs
    // asynchronously.
    //
    CallBackContext = (ULONG_PTR)DavWorkItem;

    //
    // If this function was called by the thread that picked off the DavWorkItem
    // from the Callback function, we need to do a few things first. These are
    // done below.
    //
    if (CalledByCallBackThread) {

        //
        // We are running in the context of a worker thread which has different
        // credentials than the user that initiated the I/O request. Before
        // proceeding further, we should impersonate the user that initiated the
        // request.
        //
        WStatus = UMReflectorImpersonate(UserWorkItem, DavWorkItem->ImpersonationHandle);
        if (WStatus != ERROR_SUCCESS) {
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncCreate/UMReflectorImpersonate. Error Val = %d\n",
                      WStatus));
            goto EXIT_THE_FUNCTION;
        }
        didImpersonate = TRUE;

        //
        // Before proceeding further, check to see if the Async operation failed.
        // If it did, then cleanup and move on.
        //
        if ( !DavWorkItem->AsyncResult->dwResult ) {

            WStatus = DavWorkItem->AsyncResult->dwError;

            //
            // If the error we got back is ERROR_INTERNET_FORCE_RETRY, then
            // WinInet is trying to authenticate itself with the server. In
            // such a scenario this is what happens.
            //
            //          Client ----Request----->   Server
            //          Server ----AccessDenied-----> Client
            //          Client----Challenge Me-------> Server
            //          Server-----Challenge--------> Client
            //          Client-----Challenge Resp----> Server
            //
            if (WStatus == ERROR_INTERNET_FORCE_RETRY) {

                ASSERT(DavWorkItem->DavOperation == DAV_CALLBACK_HTTP_END);

                //
                // We need to repeat the HttpSend and HttpEnd request calls.
                //
                DavWorkItem->DavOperation = DAV_CALLBACK_HTTP_OPEN;

                WStatus = DavAsyncCommonStates(DavWorkItem, FALSE);
                if (WStatus != ERROR_SUCCESS && WStatus != ERROR_IO_PENDING) {
                    DavPrint((DEBUG_ERRORS,
                              "DavAsyncCreate/DavAsyncCommonStates. Error Val ="
                              " %08lx\n", WStatus));
                }

            } else if (WStatus == ERROR_HTTP_REDIRECT_NEEDS_CONFIRMATION) {

                //
                // MSN has this BUG where it returns 302 instead of 404 when
                // queried for a file (eg:Desktop.ini) which does not exist at
                // the share level.
                //
                WStatus = ERROR_FILE_NOT_FOUND;

            } else {

                DavPrint((DEBUG_ERRORS,
                          "DavAsyncCreate. AsyncFunction failed. Error Val = %d\n",
                          WStatus));

            }

            goto EXIT_THE_FUNCTION;

        }

    }

#else

    //
    // If we are using synchronous WinInet then we enter this function 
    // impersonating the client.
    //
    didImpersonate = TRUE;

    ASSERT(CalledByCallBackThread == FALSE);

#endif

    switch (DavWorkItem->DavOperation) {

    case DAV_CALLBACK_HTTP_END:
    case DAV_CALLBACK_HTTP_READ: {


        if (DavWorkItem->AsyncCreate.DataBuff == NULL) {
            //
            // Need to allocate memory for the read buffer.
            //
            DataBuffBytes = NUM_OF_BYTES_TO_READ;
            DataBuff = LocalAlloc (LMEM_FIXED | LMEM_ZEROINIT, DataBuffBytes);
            if (DataBuff == NULL) {
                WStatus = GetLastError();
                DavPrint((DEBUG_ERRORS,
                          "DavAsyncCreate/LocalAlloc. Error Val = %d\n",
                          WStatus));
                goto EXIT_THE_FUNCTION;
            }

            DavWorkItem->AsyncCreate.DataBuff = DataBuff;
        }

        if (DavWorkItem->AsyncCreate.didRead == NULL) {
            //
            // Allocate memory for the DWORD that stores the number of bytes read.
            //
            NumRead = LocalAlloc (LMEM_FIXED | LMEM_ZEROINIT, sizeof(DWORD));
            if (NumRead == NULL) {
                WStatus = GetLastError();
                DavPrint((DEBUG_ERRORS,
                          "DavAsyncCreate/LocalAlloc. Error Val = %d\n",
                          WStatus));
                goto EXIT_THE_FUNCTION;
            }

            DavWorkItem->AsyncCreate.didRead = NumRead;
        }

        DavWorkItem->DavOperation = DAV_CALLBACK_HTTP_READ;

        DavPrint((DEBUG_MISC,
                  "DavAsyncCreate: AsyncCreateState = %d\n",
                  DavWorkItem->AsyncCreate.AsyncCreateState));

        DavPrint((DEBUG_MISC,
                  "DavAsyncCreate: CalledByCallBackThread = %d\n",
                  CalledByCallBackThread));

        //
        // When we come here, we could either be doing a PROPFIND or GET on the
        // file. The PROPFIND is done to get the file attributes and the GET to
        // get the whole file from the server.
        //

        if (DavWorkItem->AsyncCreate.AsyncCreateState == AsyncCreatePropFind) {

            if (DavWorkItem->DavMinorOperation == DavMinorQueryInfo) {

                ULONG ResponseStatus;

                //
                // If the file for which the PROPFIND was done does not exist, then
                // we need to Create one or fail, depending on the create options
                // specified by the application.
                //

                //
                // Does this file exist ? If the ResponseStatus is not
                // ERROR_SUCCESS, then we are sure that the file does not
                // exist. But, if it is we cannot be sure that the file exists.
                //
                ResponseStatus = DavQueryAndParseResponse(DavWorkItem->AsyncCreate.DavOpenHandle);
                if (ResponseStatus == ERROR_SUCCESS) {
                    doesTheFileExist = TRUE;
                } else {
                    //
                    // Carry on only if http really didn't find it. Bailout if 
                    // there is some other error.
                    //
                    if (ResponseStatus == ERROR_FILE_NOT_FOUND) {
                        doesTheFileExist = FALSE;
                    } else {
                        WStatus = ResponseStatus;
                        goto EXIT_THE_FUNCTION;
                    }
                }

                DavWorkItem->AsyncCreate.doesTheFileExist = doesTheFileExist;

                DavPrint((DEBUG_MISC,
                          "DavAsyncCreate: doesTheFileExist = %d\n", doesTheFileExist));

                //
                // Since the file existed, the next thing we do is read the
                // XML response which contains the properties of the file.
                //
                DavWorkItem->DavMinorOperation = DavMinorReadData;

            }

            doesTheFileExist = DavWorkItem->AsyncCreate.doesTheFileExist;

            if (doesTheFileExist) {

                DWORD TotalDataBytesRead = 0;

                NumRead = DavWorkItem->AsyncCreate.didRead;
                DataBuff = DavWorkItem->AsyncCreate.DataBuff;
                Ctx1 = DavWorkItem->AsyncCreate.Context1;
                Ctx2 = DavWorkItem->AsyncCreate.Context2;

                do {

                    switch (DavWorkItem->DavMinorOperation) {

                    case DavMinorReadData:

                        DavWorkItem->DavMinorOperation = DavMinorPushData;

                        ReturnVal = InternetReadFile(DavWorkItem->AsyncCreate.DavOpenHandle,
                                                     (LPVOID)DataBuff,
                                                     NUM_OF_BYTES_TO_READ,
                                                     NumRead);
                        if (!ReturnVal) {
                            WStatus = GetLastError();
                            if (WStatus != ERROR_IO_PENDING) {
                                DavCloseContext(Ctx1, Ctx2);
                                DavPrint((DEBUG_ERRORS,
                                          "DavAsyncCreate/InternetReadFile. Error Val"
                                          " = %d\n", WStatus));
                            }
                            DavPrint((DEBUG_MISC,
                                      "DavAsyncCreate/InternetReadFile(1). "
                                      "ERROR_IO_PENDING.\n"));
                            goto EXIT_THE_FUNCTION;
                        }

                        //
                        // We reject files whose attributes are greater than a
                        // certain size (DavFileAttributesLimitInBytes). This
                        // is a parameter that can be set in the registry. This
                        // is done to avoid attacks by rogue servers.
                        //
                        TotalDataBytesRead += *NumRead;
                        if (TotalDataBytesRead > DavFileAttributesLimitInBytes) {
                            WStatus = ERROR_BAD_NET_RESP;
                            DavPrint((DEBUG_ERRORS, "DavAsyncCreate. FileAttributesSize > %d\n", DavFileAttributesLimitInBytes));
                            goto EXIT_THE_FUNCTION;
                        }

                        //
                        // Lack of break is intentional.
                        //

                    case DavMinorPushData:

                        DavWorkItem->DavMinorOperation = DavMinorReadData;

                        didRead = *NumRead;

                        DavPrint((DEBUG_MISC,
                                  "DavAsyncCreate(1): toRead = %d, didRead = %d.\n",
                                  NUM_OF_BYTES_TO_READ, didRead));

                        DavPrint((DEBUG_MISC,
                                  "DavAsyncCreate(1): DataBuff = %s\n", DataBuff));

                        readDone = (didRead == 0) ? TRUE : FALSE;

                        WStatus = DavPushData(DataBuff, &Ctx1, &Ctx2, didRead, readDone);
                        if (WStatus != ERROR_SUCCESS) {
                            DavPrint((DEBUG_ERRORS,
                                      "DavAsyncCreate/DavPushData. Error Val = %d\n",
                                      WStatus));
                            goto EXIT_THE_FUNCTION;
                        }

                        if (DavWorkItem->AsyncCreate.Context1 == NULL) {
                            DavWorkItem->AsyncCreate.Context1 = Ctx1;
                        }

                        if (DavWorkItem->AsyncCreate.Context2 == NULL) {
                            DavWorkItem->AsyncCreate.Context2 = Ctx2;
                        }

                        break;

                    default:

                        WStatus = ERROR_INVALID_PARAMETER;

                        DavPrint((DEBUG_ERRORS,
                                  "DavAsyncCreate. Invalid DavMinorOperation = %d.\n",
                                  DavWorkItem->DavMinorOperation));

                        goto EXIT_THE_FUNCTION;

                        break;

                    }

                    if (readDone) {
                        break;
                    }

                } while ( TRUE );

                //
                // We now need to parse the data.
                //

                DavFileAttributes = LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT,
                                                sizeof(DAV_FILE_ATTRIBUTES) );
                if (DavFileAttributes == NULL) {
                    DavCloseContext(Ctx1, Ctx2);
                    WStatus = GetLastError();
                    DavPrint((DEBUG_ERRORS,
                              "DavAsyncCreate/LocalAlloc. Error Val = %d\n", WStatus));
                    goto EXIT_THE_FUNCTION;
                }

                InitializeListHead( &(DavFileAttributes->NextEntry) );

                WStatus = DavParseData(DavFileAttributes, Ctx1, Ctx2, &NumOfFileEntries);
                if (WStatus != ERROR_SUCCESS) {
                    DavFinalizeFileAttributesList(DavFileAttributes, TRUE);
                    DavFileAttributes = NULL;
                    DavPrint((DEBUG_ERRORS,
                              "DavAsyncCreate/DavParseData. Error Val = %d\n",
                              WStatus));
                    goto EXIT_THE_FUNCTION;
                }

                //
                // Its possible to get a 207 response for the PROPFIND request
                // even if the request failed. In such a case the status value
                // in the XML response indicates the error. If this happens, 
                // set InvalidNode to TRUE.
                //
                if (DavFileAttributes->InvalidNode) {
                    WStatus = ERROR_INTERNAL_ERROR;
                    DavPrint((DEBUG_ERRORS,
                              "DavAsyncCreate. Invalid Node!! Status = %ws\n",
                              DavFileAttributes->Status));
                    DavFinalizeFileAttributesList(DavFileAttributes, TRUE);
                    DavFileAttributes = NULL;
                    goto EXIT_THE_FUNCTION;
                }

                //
                // If the file is being created for any kind of write access or
                // FILE_SHARE_WRITE is not a part of the shareaccess and the
                // file has already been locked on the server, we need to fail
                // this call with ERROR_LOCK_VIOLATION and copy the name of the
                // LockOwner in the CreateResponse buffer.
                //
                if ( (CreateRequest->DesiredAccess & (GENERIC_WRITE | DELETE | GENERIC_ALL | FILE_WRITE_DATA | FILE_APPEND_DATA)) ||
                     !(CreateRequest->ShareAccess & FILE_SHARE_WRITE) ) {
                    if (DavFileAttributes->OpaqueLockToken) {
                        ASSERT(DavFileAttributes->LockOwner != NULL);
                        WStatus = ERROR_LOCK_VIOLATION;
                        CreateResponse->FileWasAlreadyLocked = TRUE;
                        wcscpy(CreateResponse->LockOwner, DavFileAttributes->LockOwner);
                        DavPrint((DEBUG_ERRORS,
                                  "DavAsyncCreate: fileIsLocked!! LockOwner = %ws\n",
                                  CreateResponse->LockOwner));
                        DavFinalizeFileAttributesList(DavFileAttributes, TRUE);
                        DavFileAttributes = NULL;
                        goto EXIT_THE_FUNCTION;
                    }
                }

                DavPrint((DEBUG_MISC,"DavAsyncCreate: NumOfFileEntries = %d\n", NumOfFileEntries));

                //
                // If this is a directory create and the intention is to delete
                // it, we perform the following checks.
                //
                if ( (DavFileAttributes->isCollection) &&
                     (CreateRequest->DesiredAccess & DELETE ||
                      CreateRequest->CreateOptions & FILE_DELETE_ON_CLOSE)) {

                    PWCHAR CPN1 = NULL;
                    BOOL ServerShareDelete = TRUE;
                    DWORD wackCount = 0;

                    //
                    // If the delete is just for \\server\share then we return
                    // ERROR_ACCESS_DENIED. CompletePathName has the form
                    // \server\share\dir. If its \server\share or \server\share\,
                    // we return the error. This is because we do not allow
                    // a client to delete a share on the server.
                    //
                    CPN1 = CreateRequest->CompletePathName;
                    while ( *CPN1 != L'\0' ) {
                        if ( *CPN1 == L'\\' || *CPN1 == L'/' ) {
                            wackCount++;
                            if ( (wackCount > 2) && (*(CPN1 + 1) != L'\0') ) {
                                ServerShareDelete = FALSE;
                                break;
                            }
                        }
                        CPN1++;
                    }

                    if (ServerShareDelete) {
                        DavFinalizeFileAttributesList(DavFileAttributes, TRUE);
                        DavFileAttributes = NULL;
                        WStatus = ERROR_ACCESS_DENIED;
                        DavPrint((DEBUG_ERRORS, "DavAsyncCreate: ServerShareDelete & ERROR_ACCESS_DENIED\n"));
                        goto EXIT_THE_FUNCTION;
                    }

                    //
                    // If the directory is not empty, we return the following.
                    //
                    if (NumOfFileEntries > 1) {
                        DavFinalizeFileAttributesList(DavFileAttributes, TRUE);
                        DavFileAttributes = NULL;
                        WStatus = ERROR_DIR_NOT_EMPTY;
                        DavPrint((DEBUG_ERRORS, "DavAsyncCreate: ERROR_DIR_NOT_EMPTY\n"));
                        goto EXIT_THE_FUNCTION;
                    }
                
                }

                //
                // During the create call, we only query the attributes for the file
                // or the directory. Hence if the request succeeded, the number of
                // DavFileAttribute entries created should be = 1. If it failed,
                // the NumOfFileEntries == 0. The request could fail even if the
                // response was "HTTP/1.1 207 Multi-Status". The status is returned
                // in the XML response.
                //
                if (NumOfFileEntries != 1) {
                    
                    PLIST_ENTRY listEntry = &(DavFileAttributes->NextEntry);
                    PDAV_FILE_ATTRIBUTES DavFA = NULL;
                    
                    DavPrint((DEBUG_ERRORS,
                              "DavAsyncCreate. NumOfFileEntries = %d\n",
                              NumOfFileEntries));
                    
                    do {
                        DavFA = CONTAINING_RECORD(listEntry, DAV_FILE_ATTRIBUTES, NextEntry);
                        DavPrint((DEBUG_MISC,
                                  "DavAsyncCreate. FileName = %ws\n",
                                  DavFA->FileName));
                        listEntry = listEntry->Flink;
                    } while ( listEntry != &(DavFileAttributes->NextEntry) );

                    DavFinalizeFileAttributesList(DavFileAttributes, TRUE);
                    DavFileAttributes = NULL;
                    doesTheFileExist = FALSE;

                    DavWorkItem->AsyncCreate.doesTheFileExist = FALSE;
                
                }
            
            }

            if (doesTheFileExist) {
                
                //
                // Set the FILE_BASIC_INFORMATION.
                //

                CreateResponse->BasicInformation.CreationTime.HighPart =
                                       DavFileAttributes->CreationTime.HighPart;
                CreateResponse->BasicInformation.CreationTime.LowPart =
                                       DavFileAttributes->CreationTime.LowPart;

                CreateResponse->BasicInformation.LastAccessTime.HighPart =
                                       DavFileAttributes->LastModifiedTime.HighPart;
                CreateResponse->BasicInformation.LastAccessTime.LowPart =
                                       DavFileAttributes->LastModifiedTime.LowPart;

                CreateResponse->BasicInformation.LastWriteTime.HighPart =
                                       DavFileAttributes->LastModifiedTime.HighPart;
                CreateResponse->BasicInformation.LastWriteTime.LowPart =
                                       DavFileAttributes->LastModifiedTime.LowPart;

                CreateResponse->BasicInformation.ChangeTime.HighPart =
                                       DavFileAttributes->LastModifiedTime.HighPart;
                CreateResponse->BasicInformation.ChangeTime.LowPart =
                                       DavFileAttributes->LastModifiedTime.LowPart;

                CreateResponse->BasicInformation.FileAttributes = DavFileAttributes->dwFileAttributes;

                DavPrint((DEBUG_MISC,
                          "DavAsyncCreate. attributes %x %ws\n",DavFileAttributes->dwFileAttributes,DavWorkItem->AsyncCreate.RemPathName));

                if (DavFileAttributes->isHidden || 
                    (DavFileAttributes->dwFileAttributes & FILE_ATTRIBUTE_HIDDEN)) {
                    CreateResponse->BasicInformation.FileAttributes |=
                                                          FILE_ATTRIBUTE_HIDDEN;
                } else {
                    CreateResponse->BasicInformation.FileAttributes &=
                                                          ~FILE_ATTRIBUTE_HIDDEN;
                }

                if (DavFileAttributes->isCollection) {
                    CreateResponse->BasicInformation.FileAttributes |=
                                                          FILE_ATTRIBUTE_DIRECTORY;
                } else {
                    CreateResponse->BasicInformation.FileAttributes &=
                                                          ~FILE_ATTRIBUTE_DIRECTORY;
                }

                //
                // Set the FILE_STANDARD_INFORMATION.
                //

                CreateResponse->StandardInformation.AllocationSize.HighPart =
                                               DavFileAttributes->FileSize.HighPart;
                CreateResponse->StandardInformation.AllocationSize.LowPart =
                                               DavFileAttributes->FileSize.LowPart;

                CreateResponse->StandardInformation.EndOfFile.HighPart =
                                               DavFileAttributes->FileSize.HighPart;
                CreateResponse->StandardInformation.EndOfFile.LowPart =
                                               DavFileAttributes->FileSize.LowPart;

                CreateResponse->StandardInformation.NumberOfLinks = 0;

                CreateResponse->StandardInformation.DeletePending = 0;

                CreateResponse->StandardInformation.Directory =
                                                    DavFileAttributes->isCollection;
                
                //
                // We don't need the attributes list any more, so finalize it.
                //
                DavFinalizeFileAttributesList(DavFileAttributes, TRUE);
                DavFileAttributes = NULL;

                //
                // CLose the XML parser contexts.
                //
                DavCloseContext(Ctx1, Ctx2);
                DavWorkItem->AsyncCreate.Context1 = NULL;
                DavWorkItem->AsyncCreate.Context2 = NULL;
            
            }
            
            //
            // We are done with the Open handle to PROPFIND. Now we need to GET
            // the file from the server.
            //
            InternetCloseHandle(DavWorkItem->AsyncCreate.DavOpenHandle);
            DavWorkItem->AsyncCreate.DavOpenHandle = NULL;
            
            ASSERT(didImpersonate);
            WStatus = DavAsyncCreatePropFind(DavWorkItem);

        } else if (DavWorkItem->AsyncCreate.AsyncCreateState == AsyncCreateQueryParentDirectory) {
            
            ULONG ResponseStatus;
            BOOL doesTheDirectoryExist = FALSE;
            DWORD TotalDataBytesRead = 0;

            //
            // If the parent directory for which the PROPFIND was done do not have encryption flag set,
            // the file will be created normally. Otherwise, the file will be encrypted when created.
            //

            DavPrint((DEBUG_MISC, "AsyncCreateQueryParentDirectory\n"));
            
            NumRead = DavWorkItem->AsyncCreate.didRead;
            DataBuff = DavWorkItem->AsyncCreate.DataBuff;
            Ctx1 = DavWorkItem->AsyncCreate.Context1;
            Ctx2 = DavWorkItem->AsyncCreate.Context2;
            
            //
            // Does this file exist ? If the ResponseStatus is not
            // ERROR_SUCCESS, then we are sure that the file does not
            // exist. But, if it is we cannot be sure that the file exists.
            //
            ResponseStatus = DavQueryAndParseResponse(DavWorkItem->AsyncCreate.DavOpenHandle);
            if (ResponseStatus != ERROR_SUCCESS) {
                //
                // If the parent directory does not exist, return error.
                //
                WStatus = ResponseStatus;
                DavPrint((DEBUG_ERRORS,
                         "DavAsyncCreate/QueryPDirectory/DavQueryAndParseResponse %x %d\n",WStatus,WStatus));
                goto EXIT_THE_FUNCTION;
            }

            do {
                ReturnVal = InternetReadFile(DavWorkItem->AsyncCreate.DavOpenHandle,
                                             (LPVOID)DataBuff,
                                             NUM_OF_BYTES_TO_READ,
                                             NumRead);
                if (!ReturnVal) {
                    WStatus = GetLastError();
                    if (WStatus != ERROR_IO_PENDING) {
                        DavCloseContext(Ctx1, Ctx2);
                        DavPrint((DEBUG_ERRORS,
                                  "DavAsyncCreate/InternetReadFile. Error Val"
                                  " = %d\n", WStatus));
                    }
                    DavPrint((DEBUG_MISC,
                              "DavAsyncCreate/InternetReadFile(1). "
                              "ERROR_IO_PENDING.\n"));
                    goto EXIT_THE_FUNCTION;
                }

                //
                // We reject files whose attributes are greater than a
                // certain size (DavFileAttributesLimitInBytes). This
                // is a parameter that can be set in the registry. This
                // is done to avoid attacks by rogue servers.
                //
                TotalDataBytesRead += *NumRead;
                if (TotalDataBytesRead > DavFileAttributesLimitInBytes) {
                    WStatus = ERROR_BAD_NET_RESP;
                    DavPrint((DEBUG_ERRORS, "DavAsyncCreate. QueryParentAttributesSize > %d\n", DavFileAttributesLimitInBytes));
                    goto EXIT_THE_FUNCTION;
                }

                didRead = *NumRead;

                DavPrint((DEBUG_MISC,
                          "DavAsyncCreate(1): toRead = %d, didRead = %d.\n",
                          NUM_OF_BYTES_TO_READ, didRead));

                DavPrint((DEBUG_MISC,
                          "DavAsyncCreate(1): DataBuff = %s\n", DataBuff));

                readDone = (didRead == 0) ? TRUE : FALSE;

                WStatus = DavPushData(DataBuff, &Ctx1, &Ctx2, didRead, readDone);
                if (WStatus != ERROR_SUCCESS) {
                    DavPrint((DEBUG_ERRORS,
                              "DavAsyncCreate/DavPushData. Error Val = %d\n",
                              WStatus));
                    goto EXIT_THE_FUNCTION;
                }

                if (DavWorkItem->AsyncCreate.Context1 == NULL) {
                    DavWorkItem->AsyncCreate.Context1 = Ctx1;
                }

                if (DavWorkItem->AsyncCreate.Context2 == NULL) {
                    DavWorkItem->AsyncCreate.Context2 = Ctx2;
                }
            } while (!readDone);
          
            //
            // We now need to parse the data.
            //

            DavDirectoryAttributes = LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT,sizeof(DAV_FILE_ATTRIBUTES));

            if (DavDirectoryAttributes == NULL) {
                DavCloseContext(Ctx1, Ctx2);
                WStatus = GetLastError();
                DavPrint((DEBUG_ERRORS,
                          "DavAsyncCreate/LocalAlloc. Error Val = %d\n", WStatus));
                goto EXIT_THE_FUNCTION;
            }

            InitializeListHead( &(DavDirectoryAttributes->NextEntry) );
            
            WStatus = DavParseData(DavDirectoryAttributes, Ctx1, Ctx2, &NumOfFileEntries);
            if (WStatus != ERROR_SUCCESS) {
                DavPrint((DEBUG_ERRORS,
                          "DavAsyncCreate/DavParseData. Error Val = %d\n",
                          WStatus));
                goto EXIT_THE_FUNCTION;
            }

            if ((CreateRequest->FileAttributes & FILE_ATTRIBUTE_ENCRYPTED) ||
                (DavDirectoryAttributes->dwFileAttributes & FILE_ATTRIBUTE_ENCRYPTED)) {
                CreateResponse->BasicInformation.FileAttributes |= FILE_ATTRIBUTE_ENCRYPTED;
                DavPrint((DEBUG_MISC,
                          "DavAsyncCreate: ParentDirectory Is Encrypted\n"));
            } else {
                DavPrint((DEBUG_MISC,
                          "DavAsyncCreate: ParentDirectory Is Not Encrypted\n"));
            }

            DavFinalizeFileAttributesList(DavDirectoryAttributes, TRUE);
            DavDirectoryAttributes = NULL;
            
            DavCloseContext(Ctx1, Ctx2);
            DavWorkItem->AsyncCreate.Context1 = NULL;
            DavWorkItem->AsyncCreate.Context2 = NULL;

            ASSERT(didImpersonate == TRUE);
            
            WStatus = DavAsyncCreateQueryParentDirectory(DavWorkItem);
        
        } else if (DavWorkItem->AsyncCreate.AsyncCreateState == AsyncCreateGet) {

            LARGE_INTEGER ByteOffset;
            ULONG BytesToRead;
            BOOL EncryptedFile = FALSE, ZeroByteFile = FALSE;
            FILE_STANDARD_INFORMATION FileStdInfo;
            ULONG ResponseStatus;

            ResponseStatus = DavQueryAndParseResponse(DavWorkItem->AsyncCreate.DavOpenHandle);
            if (ResponseStatus != ERROR_SUCCESS) {
                WStatus = ResponseStatus;
                DavPrint((DEBUG_ERRORS,
                         "DavAsyncCreate(AsyncCreateGet)/DavQueryAndParseResponse: WStatus = %d\n",
                          WStatus));
                goto EXIT_THE_FUNCTION;
            }

            //
            // This thread is currently impersonating the client that 
            // made this request. Before we call CreateFile, we need to 
            // revert back to the context of the Web Client service.
            //
            RevertToSelf();
            didImpersonate = FALSE;            

            if (DavReuseCacheFileIfNotModified(DavWorkItem) == ERROR_SUCCESS)
            {
                fCacheFileReused = TRUE;
            }

            if (!fCacheFileReused)
            {
                //
                // Call DavCreateUrlCacheEntry to create an entry in the 
                // WinInet's cache.
                //
            
                WStatus = DavCreateUrlCacheEntry(DavWorkItem);
                if (WStatus != ERROR_SUCCESS) {
                    DavPrint((DEBUG_ERRORS,
                              "DavAsyncCreate/DavCreateUrlCacheEntry %d\n",
                              WStatus));
                    goto EXIT_THE_FUNCTION;
                }
            }
                                
            if (DavWorkItem->AsyncCreate.FileHandle == NULL) {

                //
                // Create a handle to the file whose entry was created in the
                // cache.
                //
                FileHandle = CreateFileW(DavWorkItem->AsyncCreate.FileName,
                                         (GENERIC_READ | GENERIC_WRITE),
                                         FILE_SHARE_WRITE,
                                         NULL,
                                         OPEN_EXISTING,
                                         FILE_ATTRIBUTE_NORMAL,
                                         NULL);
                
                if (FileHandle == INVALID_HANDLE_VALUE) {
                    WStatus = GetLastError();
                    DavPrint((DEBUG_ERRORS,
                              "DavAsyncCreate/CreateFile. Error Val = %d\n",
                              WStatus));
                    goto EXIT_THE_FUNCTION;
                }

                DavWorkItem->AsyncCreate.FileHandle = FileHandle;
            
                //
                // Impersonate back again, so that we are in the context of
                // the user who issued this request.
                //
                WStatus = UMReflectorImpersonate(UserWorkItem, DavWorkItem->ImpersonationHandle);
                if (WStatus != ERROR_SUCCESS) {
                    DavPrint((DEBUG_ERRORS,
                              "DavAsyncCreate/UMReflectorImpersonate. "
                          "Error Val = %d\n", WStatus));
                    goto EXIT_THE_FUNCTION;
                }
                didImpersonate = TRUE;

            }

            FileHandle = DavWorkItem->AsyncCreate.FileHandle;
            DataBuff = DavWorkItem->AsyncCreate.DataBuff;
            NumRead = DavWorkItem->AsyncCreate.didRead;

            if (!fCacheFileReused)
            {
                DWORD TotalDataBytesRead = 0;
                do {
        
                    switch (DavWorkItem->DavMinorOperation) {

                    case DavMinorReadData:
                    
                        DavWorkItem->DavMinorOperation = DavMinorWriteData;

                        ReturnVal = InternetReadFile(DavWorkItem->AsyncCreate.DavOpenHandle,
                                                     (LPVOID)DataBuff,
                                                     NUM_OF_BYTES_TO_READ,
                                                     NumRead);
                        if (!ReturnVal) {
                            WStatus = GetLastError();
                            if (WStatus != ERROR_IO_PENDING) {
                                DavPrint((DEBUG_ERRORS,
                                          "DavAsyncCreate/InternetReadFile. Error Val"
                                          " = %08lx.\n", WStatus));
                            }
                            DavPrint((DEBUG_MISC,
                                      "DavAsyncCreate/InternetReadFile(2). "
                                      "ERROR_IO_PENDING.\n"));
                            goto EXIT_THE_FUNCTION;
                        }

                        //
                        // We reject files which are greater than a certain
                        // size (DavFileSizeLimitInBytes). This is a parameter
                        // that can be set in the registry. This is done to
                        // avoid attacks by rogue servers.
                        //
                        TotalDataBytesRead += *NumRead;
                        if (TotalDataBytesRead > DavFileSizeLimitInBytes) {
                            WStatus = ERROR_BAD_NET_RESP;
                            DavPrint((DEBUG_ERRORS, "DavAsyncCreate. FileSize > %d\n", DavFileSizeLimitInBytes));
                            goto EXIT_THE_FUNCTION;
                        }

                        //
                        // Lack of break is intentional.
                        //

                    case DavMinorWriteData:

                        DavWorkItem->DavMinorOperation = DavMinorReadData;
        
                        didRead = *NumRead;

                        DavPrint((DEBUG_MISC,
                                  "DavAsyncCreate(2): toRead = %d, didRead = %d.\n",
                                  NUM_OF_BYTES_TO_READ, didRead));

                        readDone = (didRead == 0) ? TRUE : FALSE;

                        if (readDone) {
                            break;
                        }

                        //
                        // This thread is currently impersonating the client that 
                        // made this request. Before we call WriteFile, we need to 
                        // revert back to the context of the Web Client service.
                        //
                        RevertToSelf();
                        didImpersonate = FALSE;
                    
                        //
                        // Write the buffer to the file which has been cached on
                        // persistent storage.
                        //
                        ReturnVal = WriteFile(FileHandle, DataBuff, didRead, &didWrite, NULL);
                        if (!ReturnVal) {
                            WStatus = GetLastError();
                            DavPrint((DEBUG_ERRORS,
                                      "DavAsyncCreate/WriteFile. Error Val = %d\n", WStatus));
                            goto EXIT_THE_FUNCTION;
                        }

                        ASSERT(didRead == didWrite);

                        //
                        // Impersonate back again, so that we are in the context of
                        // the user who issued this request.
                        //
                        WStatus = UMReflectorImpersonate(UserWorkItem, DavWorkItem->ImpersonationHandle);
                        if (WStatus != ERROR_SUCCESS) {
                            DavPrint((DEBUG_ERRORS,
                                      "DavAsyncCreate/UMReflectorImpersonate. "
                                      "Error Val = %d\n", WStatus));
                            goto EXIT_THE_FUNCTION;
                        }
                        didImpersonate = TRUE;
                    
                        break;
        
                    default:

                        WStatus = ERROR_INVALID_PARAMETER;

                        DavPrint((DEBUG_ERRORS,
                                  "DavAsyncCreate. Invalid DavMinorOperation = %d.\n",
                                  DavWorkItem->DavMinorOperation));

                        goto EXIT_THE_FUNCTION;

                        break;

                    }

                    if (readDone) {
                        break;
                    }

                } while ( TRUE );
            }

            //
            // At this point, we have read the entire file.
            // We need to figure out if this is an encrypted file.
            // If it is, we need to RESTORE it, since it was stored as a
            // Backup stream on the server. We read the first 100 bytes of the
            // file to check for the EFS signature.
            //

            //
            // This thread could be currently impersonating the client that made 
            // this request. Before we call ReadFile, we need to revert back to 
            // the context of the Web Client service.
            //
            if (didImpersonate) {
                RevertToSelf();
                didImpersonate = FALSE;
            }

            //
            // Set the last access time on the URL Cache so that we can avoid
            // a GET on subsequent Create's if the file has not changed on the
            // server.
            //
            if (!fCacheFileReused) {
                //
                // Commit to the cache only if it is not being reused. If it
                // is being reused, it has already been committed on a previous
                // Create.
                //
                WStatus = DavCommitUrlCacheEntry(DavWorkItem);
                if (WStatus != ERROR_SUCCESS) {
                    DavPrint((DEBUG_ERRORS,
                              "DavAsyncCreate/DavCommitUrlCacheEntry(2). "
                              "WStatus = %d\n", WStatus));
                    goto EXIT_THE_FUNCTION;
                }
                if (CreateResponse->BasicInformation.FileAttributes & FILE_ATTRIBUTE_ENCRYPTED) {
                    //
                    // Set the ACLs on the file, so that it can be accessed
                    // after impersonating the user whoc is creating it.
                    //
                    WStatus = DavSetAclForEncryptedFile(DavWorkItem->AsyncCreate.FileName);
                    if (WStatus != ERROR_SUCCESS) {
                        DavPrint((DEBUG_ERRORS,
                                  "DavAsyncCreate/DavSetAclForEncryptedFile(1). Error Val = %d, FileName = %ws\n",
                                  WStatus, DavWorkItem->AsyncCreate.FileName));
                        goto EXIT_THE_FUNCTION;
                    }
                }
            }
            
            WStatus = DavQueryUrlCacheEntry(DavWorkItem);

            if (WStatus == ERROR_SUCCESS) {
                SYSTEMTIME SystemTime;

                GetSystemTime(&SystemTime);

                SystemTimeToFileTime(
                    &SystemTime,
                    &((LPINTERNET_CACHE_ENTRY_INFOW)DavWorkItem->AsyncCreate.lpCEI)->LastAccessTime);
                
                DavPrint((DEBUG_MISC,
                         "DavAsyncCreate/SetUrlCacheEntryInfo %u %ws\n",
                         ((LPINTERNET_CACHE_ENTRY_INFOW)DavWorkItem->AsyncCreate.lpCEI)->LastAccessTime.dwLowDateTime, 
                         DavWorkItem->AsyncCreate.UrlBuffer));

                SetUrlCacheEntryInfo(
                    DavWorkItem->AsyncCreate.UrlBuffer, 
                    (LPINTERNET_CACHE_ENTRY_INFOW)DavWorkItem->AsyncCreate.lpCEI, 
                    CACHE_ENTRY_ACCTIME_FC);
            }
            
            WStatus = DavAsyncCreateGet(DavWorkItem);

        } else if (DavWorkItem->AsyncCreate.AsyncCreateState == AsyncCreateMkCol) {

            WStatus = DavQueryAndParseResponse(DavWorkItem->AsyncCreate.DavOpenHandle);
            if (WStatus != ERROR_SUCCESS) {
                goto EXIT_THE_FUNCTION;
            }

            WStatus = ERROR_SUCCESS;

        } else {

            ASSERT(DavWorkItem->AsyncCreate.AsyncCreateState == AsyncCreatePut);

            WStatus = DavQueryAndParseResponse(DavWorkItem->AsyncCreate.DavOpenHandle);
            if (WStatus != ERROR_SUCCESS) {
                goto EXIT_THE_FUNCTION;
            }

            //
            // The CreateResponse structure has already been set. All we need to
            // do now is return.
            //
            WStatus = ERROR_SUCCESS;

        }

    }
        break;

    default: {
        WStatus = ERROR_INVALID_PARAMETER;
        DavPrint((DEBUG_ERRORS,
                  "DavAsyncCreate: Invalid DavWorkItem->DavOperation = %d.\n",
                  DavWorkItem->DavOperation));
    }
        break;

    } // End of switch.

EXIT_THE_FUNCTION:

    //
    // Free the pEncryptedCachedFile since we have allocated a new file name
    // for the restored encrypted file.
    //
    if (pEncryptedCachedFile) {
        LocalFree(pEncryptedCachedFile);
    }

    if (DavDirectoryAttributes) {
        DavFinalizeFileAttributesList(DavDirectoryAttributes, TRUE);
        DavDirectoryAttributes = NULL;
    }

#ifdef DAV_USE_WININET_ASYNCHRONOUSLY

    //
    // If we did impersonate, we need to revert back.
    //
    if (didImpersonate) {
        ULONG RStatus;
        RStatus = UMReflectorRevert(UserWorkItem);
        if (RStatus != ERROR_SUCCESS) {
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncCreate/UMReflectorRevert. Error Val = %d\n",
                      RStatus));
        }
    }

    //
    // Some resources should not be freed if we are returning ERROR_IO_PENDING
    // because they will be used in the callback functions.
    //
    if ( WStatus != ERROR_IO_PENDING && CalledByCallBackThread ) {

        DavPrint((DEBUG_MISC, "DavAsyncCreate: Leaving!!! WStatus = %08lx\n", WStatus));

        //
        // Set the return status of the operation. This is used by the kernel
        // mode routines to figure out the completion status of the user mode
        // request.
        //
        if (WStatus != ERROR_SUCCESS) {
            DavWorkItem->Status = DavMapErrorToNtStatus(WStatus);
        } else {
            DavWorkItem->Status = STATUS_SUCCESS;
        }

        //
        // Call the AsyncCreateCompletion routine.
        //
        DavAsyncCreateCompletion(DavWorkItem);

        //
        // This thread now needs to send the response back to the kernel. It
        // does not wait in the kernel (to get another request) after submitting
        // the response.
        //
        UMReflectorCompleteRequest(DavReflectorHandle, UserWorkItem);

    }

    if (WStatus == ERROR_IO_PENDING ) {
        DavPrint((DEBUG_MISC, "DavAsyncCreate: Returning ERROR_IO_PENDING.\n"));
    }

#else

    //
    // If we are using WinInet synchronously, we need to impersonate the client
    // if we somehow reverted in between and failed. This is because we came
    // into this function impersonating a client and the final revert happens
    // in DavFsCreate.
    //
    if ( !didImpersonate ) {
        ULONG IStatus;
        IStatus = UMReflectorImpersonate(UserWorkItem, DavWorkItem->ImpersonationHandle);
        if (IStatus != ERROR_SUCCESS) {
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncCreate/UMReflectorImpersonate. "
                      "Error Val = %d\n", IStatus));
        }
    }

#endif

    return WStatus;
}

DWORD
DavAsyncCreatePropFind(
    PDAV_USERMODE_WORKITEM DavWorkItem
    )
/*++

Routine Description:

   This routine handles the Get completion.

Arguments:

    DavWorkItem - The DAV_USERMODE_WORKITEM value.

Return Value:

    none.

--*/
{
    ULONG WStatus = ERROR_SUCCESS;
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PUMRX_USERMODE_WORKITEM_HEADER UserWorkItem = NULL;
    BOOL ReturnVal, didImpersonate = TRUE;
    BOOL doesTheFileExist = FALSE;
    HANDLE FileHandle = INVALID_HANDLE_VALUE;
    PDAV_USERMODE_CREATE_REQUEST CreateRequest;
    PDAV_USERMODE_CREATE_RESPONSE CreateResponse;
    ULONG_PTR CallBackContext = (ULONG_PTR)0;
    PWCHAR ParentDirectoryName = NULL;
    BOOL BStatus = FALSE;

    UserWorkItem = (PUMRX_USERMODE_WORKITEM_HEADER)DavWorkItem;

    //
    // Get the request and response buffer pointers from the DavWorkItem.
    //
    CreateRequest = &(DavWorkItem->CreateRequest);
    CreateResponse = &(DavWorkItem->CreateResponse);
    CreateResponse->fPsuedoOpen = FALSE;
    
    doesTheFileExist = DavWorkItem->AsyncCreate.doesTheFileExist;

    DavPrint((DEBUG_MISC,
              "DavAsyncCreatePropFind: DesiredAccess = %x, FileAttributes = %x,"
              "ShareAccess = %x, CreateDisposition = %x, CreateOptions = %x,"
              "FileName = %ws\n",
              CreateRequest->DesiredAccess, CreateRequest->FileAttributes,
              CreateRequest->ShareAccess, CreateRequest->CreateDisposition,
              CreateRequest->CreateOptions, CreateRequest->CompletePathName));

    //
    // We don't support compression of files or directories over the 
    // DAV Redir since there is no way to do this with the current status
    // of the protocol (Jan 2001) and hence we filter this flag so that
    // we never set any attributes. Also, for this version ,we are 
    // emulating FAT which doesn't support compression. Similarly we don't
    // support the Offline scenario.
    //
    CreateRequest->FileAttributes &= ~(FILE_ATTRIBUTE_COMPRESSED | FILE_ATTRIBUTE_OFFLINE);

    //
    // If this file is a new file (not a directory), then according to 
    // functionality expected from CreateFile, FILE_ATTRIBUTE_ARCHIVE 
    // should be combined with specified value of attributes.
    //
    if ( (doesTheFileExist == FALSE) && 
         !(CreateRequest->CreateOptions & (FILE_DIRECTORY_FILE)) ) {
            CreateRequest->FileAttributes |= FILE_ATTRIBUTE_ARCHIVE;
    }

    //
    // If the file exists, we need to make sure that a few things are
    // right before proceeding further.
    //
    if (doesTheFileExist) {
        
        //
        // If the dwFileAttributes had the READ_ONLY bit set, then
        // these cannot be TRUE.
        // 1. CreateDisposition cannot be FILE_OVERWRITE_IF or
        //    FILE_OVERWRITE or FILE_SUPERSEDE. 
        // 2. CreateDisposition cannot be FILE_DELETE_ON_CLOSE.
        // 3. DesiredAccess  cannot be GENERIC_ALL or GENERIC_WRITE or
        //    FILE_WRITE_DATA or FILE_APPEND_DATA.
        // This is because these intend to overwrite the existing file.
        //
        if ( (CreateResponse->BasicInformation.FileAttributes & FILE_ATTRIBUTE_READONLY) &&
             ( (CreateRequest->CreateDisposition == FILE_OVERWRITE)          ||
               (CreateRequest->CreateDisposition == FILE_OVERWRITE_IF)       ||
               (CreateRequest->CreateDisposition == FILE_SUPERSEDE)          ||
               (CreateRequest->CreateOptions & (FILE_DELETE_ON_CLOSE)        ||
               (CreateRequest->DesiredAccess & (GENERIC_ALL | GENERIC_WRITE | FILE_WRITE_DATA | FILE_APPEND_DATA)) ) ) ) {
            DavPrint((DEBUG_MISC,
                      "DavAsyncCreatePropFind: Object Mismatch!!! CreateDisposition = "
                      "%d, DesiredAccess = %x, dwFileAttributes = %x\n",
                      CreateRequest->CreateDisposition, 
                      CreateRequest->DesiredAccess, 
                      CreateResponse->BasicInformation.FileAttributes));
            WStatus = ERROR_ACCESS_DENIED; // mismatch
            goto EXIT_THE_FUNCTION;
        }

        //
        // If the file is a directory and the caller supplied 
        // FILE_NON_DIRECTORY_FILE as one of the CreateOptions or if the
        // file as a file and the CreateOptions has FILE_DIRECTORY_FILE
        // then we return error. There is no good WIN32 errors for these situations.
        // ERROR_ACCESS_DENIED will cause confusion for EFS.
        //
        if ((CreateRequest->CreateOptions & FILE_DIRECTORY_FILE) && 
            !CreateResponse->StandardInformation.Directory) {
            DavPrint((DEBUG_MISC,
                      "DavAsyncCreatePropFind: Object Mismatch!!! CreateOptions = "
                      "%x, CreateResponse = %x\n",
                      CreateRequest->CreateOptions, CreateResponse->BasicInformation.FileAttributes));
            WStatus = STATUS_NOT_A_DIRECTORY; // mismatch
            goto EXIT_THE_FUNCTION;
        }

        if ((CreateRequest->CreateOptions & FILE_NON_DIRECTORY_FILE) && 
            CreateResponse->StandardInformation.Directory) {
            DavPrint((DEBUG_MISC,
                      "DavAsyncCreatePropFind: Object Mismatch!!! CreateOptions = "
                      "%x, CreateResponse = %x\n",
                      CreateRequest->CreateOptions, CreateResponse->BasicInformation.FileAttributes));
            WStatus = STATUS_FILE_IS_A_DIRECTORY; // mismatch
            goto EXIT_THE_FUNCTION;
        }
    
    }

    //
    // We LOCK the resource if the following conditions are TRUE.
    // 1. The resource already exists on the server AND,
    // 2. The resource being opened is a file and NOT a directory AND,
    // 3. The SharedMode is 0 (exclusive) OR FILE_SHARE_READ OR the file is
    //    being opened for write access.
    //
    if (DavSupportLockingOfFiles) {
        if (doesTheFileExist && !CreateResponse->StandardInformation.Directory) {
            if ( (CreateRequest->ShareAccess == 0) || (CreateRequest->ShareAccess == FILE_SHARE_READ) ||
                 (CreateRequest->DesiredAccess & (FILE_WRITE_DATA | FILE_APPEND_DATA | GENERIC_WRITE | GENERIC_ALL)) ) {
                WStatus = DavLockTheFileOnTheServer(DavWorkItem);
                if (WStatus != ERROR_SUCCESS) {
                    DavPrint((DEBUG_ERRORS,
                              "DavAsyncCreatePropFind/DavLockTheFileOnTheServer. WStatus = %08lx\n",
                              WStatus));
                    goto EXIT_THE_FUNCTION;
                }
            }
        }
    }

    //
    // If the file exists, we need to set the information field if the 
    // CreateDisposition is one of the following. This is because the
    // CreateFile API expects these values to be set on return.
    //
    if (doesTheFileExist) {
        switch (CreateRequest->CreateDisposition) {
        case FILE_OVERWRITE:
        case FILE_OVERWRITE_IF:
            DavWorkItem->Information = FILE_OVERWRITTEN;
            break;

        case FILE_SUPERSEDE:
            DavWorkItem->Information = FILE_SUPERSEDED;
            break;

        default:
            DavWorkItem->Information = FILE_OPENED;
        }
    } else {
        DavWorkItem->Information = FILE_CREATED;
    }
    
    //
    // If the file does not exist on the server, create one locally.
    // Once its closed, we will PUT it on the server. If the file
    // exists on the server, and the CreateDisposition is equal to
    // FILE_OVERWRITE_IF, we create a copy locally and PUT it on the
    // server (overwrite) on close.
    //
    if ( ( !doesTheFileExist ) ||
         ( doesTheFileExist && CreateRequest->CreateDisposition == FILE_OVERWRITE_IF ) ) {

        DWORD NameLength = 0, i;
        BOOL BackSlashFound = FALSE;

        DavPrint((DEBUG_MISC, "DavAsyncCreatePropFind: doesTheFileExist = "
                  "%d, CreateDisposition = %d\n",
                  doesTheFileExist, CreateRequest->CreateDisposition));
        
        DavPrint((DEBUG_MISC, "DavAsyncCreatePropFind: CreateOptions = %d\n", 
                  CreateRequest->CreateOptions));

        //
        // We need to check the CreateDisposition value to figure
        // out what to do next.
        //
        switch (CreateRequest->CreateDisposition) {

        //
        // If FILE_OPEN was specified, we need to return failure
        // since the specified file does not exist.
        //
        case FILE_OPEN:

            WStatus = ERROR_FILE_NOT_FOUND; // STATUS_OBJECT_NAME_NOT_FOUND;

            DavPrint((DEBUG_MISC,
                      "DavAsyncCreatePropFind. CreateDisposition & FILE_OPEN\n"));

            goto EXIT_THE_FUNCTION;

        //
        // If FILE_OVERWRITE was specified, we need to return failure
        // since the specified file does not exist.
        //
        case FILE_OVERWRITE:

            WStatus = ERROR_FILE_NOT_FOUND; // STATUS_OBJECT_NAME_NOT_FOUND;                    

            DavPrint((DEBUG_MISC,
                      "DavAsyncCreatePropFind. CreateDisposition & FILE_OVERWRITE\n"));

            goto EXIT_THE_FUNCTION;

        default:

            break;

        }

        if (CreateRequest->ParentDirInfomationCached ||
            (CreateRequest->FileAttributes & FILE_ATTRIBUTE_ENCRYPTED)) {

            //
            // Since we already know whether to encrypt the file, we don't need
            // to query the parent directory.
            //

            if (CreateRequest->ParentDirIsEncrypted ||
                (CreateRequest->FileAttributes & FILE_ATTRIBUTE_ENCRYPTED)) {
                CreateResponse->BasicInformation.FileAttributes |= FILE_ATTRIBUTE_ENCRYPTED;
            }
            
            BStatus = DavHttpOpenRequestW(DavWorkItem->AsyncCreate.PerUserEntry->DavConnHandle,
                                          L"PROPFIND",
                                          L"",
                                          L"HTTP/1.1",
                                          NULL,
                                          NULL,
                                          INTERNET_FLAG_KEEP_CONNECTION |
                                          INTERNET_FLAG_NO_COOKIES,
                                          CallBackContext,
                                          L"DavAsyncCreatePropFind",
                                          &(DavWorkItem->AsyncCreate.DavOpenHandle));

            if(BStatus == FALSE) {
                WStatus = GetLastError();
                DavPrint((DEBUG_ERRORS,
                         "DavAsyncCreatePropFind/DavHttpOpenRequestW failed %x %d\n",WStatus,WStatus));
                goto EXIT_THE_FUNCTION;
            }

            ASSERT(didImpersonate == TRUE);

            WStatus = DavAsyncCreateQueryParentDirectory(DavWorkItem);

        } else {

            //
            // We need to query the attributes of the parent directory of this new file 
            // on the server. If it is encrypted, the new file needs to be encrypted as well.
            //
            DavPrint((DEBUG_MISC,
                      "DavAsyncCreatePropFind: Query Parent Directory for %ws\n",DavWorkItem->AsyncCreate.RemPathName));

            NameLength = wcslen(DavWorkItem->AsyncCreate.RemPathName);

            for (i=NameLength;i>0;i--) {
                if (DavWorkItem->AsyncCreate.RemPathName[i] == L'/') {
                    BackSlashFound = TRUE;
                    break;
                }
            }

            if (!BackSlashFound) {
                DavPrint((DEBUG_ERRORS,
                          "DavAsyncCreatePropFind: Invalid file path %ws\n",DavWorkItem->AsyncCreate.RemPathName));
                WStatus = ERROR_INVALID_PARAMETER;
                goto EXIT_THE_FUNCTION;
            }

            ParentDirectoryName = (PWCHAR)LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, (i+1)*sizeof(WCHAR));

            if (ParentDirectoryName == NULL) {
                WStatus = GetLastError();
                DavPrint((DEBUG_ERRORS,
                          "DavAsyncCreatePropFind/LocalAlloc. Error Val = %d\n",
                          WStatus));
                goto EXIT_THE_FUNCTION;
            }

            RtlCopyMemory(ParentDirectoryName,
                          DavWorkItem->AsyncCreate.RemPathName,
                          i*sizeof(WCHAR));

            DavPrint((DEBUG_MISC,
                     "DavAsyncCreatePropFind/ParentDirectoryName %ws\n",ParentDirectoryName));

            //
            // Set the DavOperation and AsyncCreateState values.For PUT 
            // the DavMinorOperation value is irrelavant.
            //
            DavWorkItem->DavOperation = DAV_CALLBACK_HTTP_OPEN;
            DavWorkItem->AsyncCreate.AsyncCreateState = AsyncCreateQueryParentDirectory;
            DavWorkItem->DavMinorOperation = DavMinorQueryInfo;

            //
            // Convert the unicode object name to UTF-8 URL format.
            // Space and other white characters will remain untouched. 
            // These should be taken care of by wininet calls.
            //
            BStatus = DavHttpOpenRequestW(DavWorkItem->AsyncCreate.PerUserEntry->DavConnHandle,
                                          L"PROPFIND",
                                          ParentDirectoryName,
                                          L"HTTP/1.1",
                                          NULL,
                                          NULL,
                                          INTERNET_FLAG_KEEP_CONNECTION |
                                          INTERNET_FLAG_NO_COOKIES,
                                          CallBackContext,
                                          L"DavAsyncCreate",
                                          &(DavWorkItem->AsyncCreate.DavOpenHandle));

            if(BStatus == FALSE) {
                WStatus = GetLastError();
                DavPrint((DEBUG_ERRORS,
                         "DavAsyncCreatePropFind/DavHttpOpenRequestW failed %x %d\n",WStatus,WStatus));
                goto EXIT_THE_FUNCTION;
            }

            if (DavWorkItem->AsyncCreate.DavOpenHandle == NULL) {
                WStatus = GetLastError();
                if (WStatus != ERROR_IO_PENDING) {
                    DavPrint((DEBUG_ERRORS,
                              "DavAsyncCreatePropFind/HttpOpenRequestW"
                              ". Error Val = %d\n", WStatus));
                }
                goto EXIT_THE_FUNCTION;
            }

            WStatus = DavAsyncCommonStates(DavWorkItem, FALSE);
            if (WStatus != ERROR_SUCCESS && WStatus != ERROR_IO_PENDING) {
                DavPrint((DEBUG_ERRORS,
                          "DavAsyncCreatePropFind/DavAsyncCommonStates(PUT). "
                          "Error Val = %08lx\n", WStatus));
            }
        
        }

        goto EXIT_THE_FUNCTION;

    } else {

        //
        // The file exists on the server and the value of CreateDisposition !=
        // FILE_OVERWRITE_IF.
        //

        //
        // We return failure if FILE_CREATE was specified since the
        // file already exists.
        //
        if (CreateRequest->CreateDisposition == FILE_CREATE) {

            WStatus = ERROR_ALREADY_EXISTS; // STATUS_OBJECT_NAME_COLLISION

            DavPrint((DEBUG_ERRORS,
                      "DavAsyncCreate. CreateDisposition & FILE_CREATE\n"));

            goto EXIT_THE_FUNCTION;

        }
    
    }

    //
    // If "FILE_DELETE_ON_CLOSE" flag was specified as one of
    // the CreateOptions, then we need to remember this and
    // delete this file on close.
    //
    if (CreateRequest->CreateOptions & FILE_DELETE_ON_CLOSE) {
        DavPrint((DEBUG_MISC,
                  "DavAsyncCreatePropFind: FileName: %ws. FILE_DELETE_ON_CLOSE.\n",
                  DavWorkItem->AsyncCreate.RemPathName));
        CreateResponse->DeleteOnClose = TRUE;
    }

    //
    // In some cases, we don't need to do a GET.
    //
    if (CreateResponse->StandardInformation.Directory) {

        //
        // We do not need to GET a directory.
        //
        goto EXIT_THE_FUNCTION;
    
    } else if (!(CreateResponse->BasicInformation.FileAttributes & FILE_ATTRIBUTE_ENCRYPTED) &&
               (CreateRequest->DesiredAccess & 
                ~(SYNCHRONIZE | DELETE | FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES)) == 0 ) {

        //
        // If we don't need to GET the file from the server because the
        // user doesn't intend to manipulate the data, we return right
        // now. We call such an open a Pseudo open.Set the fPsuedoOpen 
        // field to TRUE in the CreateResponse.
        //
        CreateResponse->fPsuedoOpen = TRUE;
                    
        goto EXIT_THE_FUNCTION;
    
    } else {
        
        if (didImpersonate) {
            RevertToSelf();
            didImpersonate = FALSE;
        }

        DavQueryUrlCacheEntry(DavWorkItem);

        if (DavWorkItem->AsyncCreate.lpCEI) {
            
            SYSTEMTIME SystemTime;
            FILETIME CurrentFileTime;
            FILETIME LastAccessTime;
            LARGE_INTEGER Difference;
            LPINTERNET_CACHE_ENTRY_INFOW lpCEI = (LPINTERNET_CACHE_ENTRY_INFOW)DavWorkItem->AsyncCreate.lpCEI;

            LastAccessTime = ((LPINTERNET_CACHE_ENTRY_INFOW)DavWorkItem->AsyncCreate.lpCEI)->LastAccessTime;

            GetSystemTime(&SystemTime);
            
            SystemTimeToFileTime(&SystemTime,&CurrentFileTime);

            Difference.QuadPart = *((LONGLONG *)(&CurrentFileTime)) - *((LONGLONG *)(&LastAccessTime));

            //
            // If the local cache has not timed out, we don't need to query the server
            //
            if (Difference.QuadPart < FileCacheExpiryInterval) {
                
                DavPrint((DEBUG_MISC,
                         "DavAsyncCreatePropFind/Skip GET %u %u %u %ws\n",
                         CurrentFileTime.dwLowDateTime,
                         LastAccessTime.dwLowDateTime,
                         Difference.LowPart,
                         DavWorkItem->AsyncCreate.UrlBuffer));
                
                ASSERT(DavWorkItem->AsyncCreate.FileName == NULL);
                
                DavWorkItem->AsyncCreate.FileName = LocalAlloc(LPTR, (lstrlen(lpCEI->lpszLocalFileName)+1)*sizeof(WCHAR));

                if (DavWorkItem->AsyncCreate.FileName) {
                    
                    wcscpy(DavWorkItem->CreateResponse.FileName, lpCEI->lpszLocalFileName);
                    
                    wcscpy(DavWorkItem->AsyncCreate.FileName, lpCEI->lpszLocalFileName);

                    ASSERT(DavWorkItem->AsyncCreate.FileHandle == NULL);
                    
                    //
                    // Create a handle to the file whose entry was created in
                    // the cache.
                    //
                    DavWorkItem->AsyncCreate.FileHandle = CreateFileW(DavWorkItem->AsyncCreate.FileName,
                                                                      (GENERIC_READ | GENERIC_WRITE),
                                                                      FILE_SHARE_WRITE,
                                                                      NULL,
                                                                      OPEN_EXISTING,
                                                                      FILE_ATTRIBUTE_NORMAL,
                                                                      NULL);
                    if (DavWorkItem->AsyncCreate.FileHandle == INVALID_HANDLE_VALUE) {
                        WStatus = GetLastError();
                        DavPrint((DEBUG_ERRORS,
                                  "DavAsyncCreatePropFind/CreateFile. Error Val = %d\n",
                                  WStatus));
                        goto EXIT_THE_FUNCTION;
                    }
                    
                    WStatus = DavAsyncCreateGet(DavWorkItem);
                    
                    didImpersonate = TRUE;
                    goto EXIT_THE_FUNCTION;
                
                } else {
                    
                    WStatus = GetLastError();
                    
                    DavPrint((DEBUG_ERRORS,
                              "DavAsyncCreatePropFind/CreateFile. Error Val = %d\n",
                              WStatus));
                    
                    goto EXIT_THE_FUNCTION;
                
                }
            
            }
        
        }

        WStatus = UMReflectorImpersonate(UserWorkItem, DavWorkItem->ImpersonationHandle);
        if (WStatus != ERROR_SUCCESS) {
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncCreatePropFind/UMReflectorImpersonate. Error Val = %d\n",
                      WStatus));
            goto EXIT_THE_FUNCTION;
        }
        didImpersonate = TRUE;

    }

    //
    // PROPFIND is done. Now we need to do a GET.
    //
    DavWorkItem->DavOperation = DAV_CALLBACK_HTTP_OPEN;
    DavWorkItem->AsyncCreate.AsyncCreateState = AsyncCreateGet;
    DavWorkItem->DavMinorOperation = DavMinorReadData;

    //
    // Convert the unicode object name to UTF-8 URL format.
    // Space and other white characters will remain untouched - these
    // should be taken care of by wininet calls.
    //
    BStatus = DavHttpOpenRequestW(DavWorkItem->AsyncCreate.PerUserEntry->DavConnHandle,
                                  L"GET",
                                  DavWorkItem->AsyncCreate.RemPathName,
                                  L"HTTP/1.1",
                                  NULL,
                                  NULL,
                                  INTERNET_FLAG_KEEP_CONNECTION |
                                  INTERNET_FLAG_RELOAD |
                                  INTERNET_FLAG_NO_CACHE_WRITE |
                                  INTERNET_FLAG_NO_COOKIES,
                                  CallBackContext,
                                  L"DavAsyncCreate",
                                  &(DavWorkItem->AsyncCreate.DavOpenHandle));
    if(BStatus == FALSE) {
        WStatus = GetLastError();
        goto EXIT_THE_FUNCTION;
    }

    if (DavWorkItem->AsyncCreate.DavOpenHandle == NULL) {
        WStatus = GetLastError();
        if (WStatus != ERROR_IO_PENDING) {
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncCreatePropFind/HttpOpenRequest. Error Val = %d\n",
                      WStatus));
        }
        goto EXIT_THE_FUNCTION;
    }

    ASSERT(didImpersonate);
    RevertToSelf();
    didImpersonate = FALSE;

    // try to add if-modified-since header. don't sweat it if we fail            
    DavAddIfModifiedSinceHeader(DavWorkItem);
    WStatus = UMReflectorImpersonate(UserWorkItem, DavWorkItem->ImpersonationHandle);
    if (WStatus != ERROR_SUCCESS) {
        DavPrint((DEBUG_ERRORS,
                  "DavAsyncCreate/UMReflectorImpersonate. Error Val = %d\n",
                  WStatus));
        goto EXIT_THE_FUNCTION;
    }
    didImpersonate = TRUE;
    
    WStatus = DavAsyncCommonStates(DavWorkItem, FALSE);
    if (WStatus != ERROR_SUCCESS && WStatus != ERROR_IO_PENDING) {
        DavPrint((DEBUG_ERRORS,
                  "DavAsyncCreatePropFind/DavAsyncCommonStates. "
                  "Error Val(GET) = %08lx\n", WStatus));
    }

EXIT_THE_FUNCTION:
            
    if (ParentDirectoryName) {
        LocalFree(ParentDirectoryName);
    }

    //
    // Impersonate back again, so that we are in the context of
    // the user who issued this request.
    //
    if (!didImpersonate) {
        ULONG LocalStatus;

        LocalStatus = UMReflectorImpersonate(UserWorkItem, DavWorkItem->ImpersonationHandle);
        if (LocalStatus != ERROR_SUCCESS) {
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncCreatePropFind/UMReflectorImpersonate. "
                      "Error Val = %d\n", LocalStatus));
            
            if (WStatus == ERROR_SUCCESS) {
                WStatus = LocalStatus;
            }
        }
    }

    if (WStatus != ERROR_SUCCESS && WStatus != ERROR_FILE_NOT_FOUND) {
        DavPrint((DEBUG_ERRORS,"DavAsyncCreatePropFind return %x\n", WStatus));
    }

    return WStatus;
}


DWORD
DavAsyncCreateQueryParentDirectory(
    PDAV_USERMODE_WORKITEM DavWorkItem
    )
/*++

Routine Description:

   This routine handles the Get completion.

Arguments:

    DavWorkItem - The DAV_USERMODE_WORKITEM value.

Return Value:

    none.

--*/
{
    ULONG WStatus = ERROR_SUCCESS;
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PUMRX_USERMODE_WORKITEM_HEADER UserWorkItem = NULL;
    BOOL ReturnVal, didImpersonate = TRUE;
    BOOL doesTheFileExist = FALSE;
    HANDLE FileHandle = INVALID_HANDLE_VALUE;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatusBlock;
    SECURITY_QUALITY_OF_SERVICE QualityOfService;
    PDAV_USERMODE_CREATE_REQUEST CreateRequest;
    PDAV_USERMODE_CREATE_RESPONSE CreateResponse;
    UNICODE_STRING UnicodeFileName;
    ULONG_PTR CallBackContext = (ULONG_PTR)0;
    ACCESS_MASK DesiredAccess = 0;
    BOOL BStatus = FALSE, ShouldEncrypt = FALSE;

    UserWorkItem = (PUMRX_USERMODE_WORKITEM_HEADER)DavWorkItem;

    UnicodeFileName.Buffer = NULL;
    UnicodeFileName.Length = 0;
    UnicodeFileName.MaximumLength = 0;

    //
    // Get the request and response buffer pointers from the DavWorkItem.
    //
    CreateRequest = &(DavWorkItem->CreateRequest);
    CreateResponse = &(DavWorkItem->CreateResponse);
    
    if (CreateResponse->BasicInformation.FileAttributes & FILE_ATTRIBUTE_ENCRYPTED) {
        ShouldEncrypt = TRUE;
    }

    //
    // If this is a create of a new directory, then we need to
    // send a MKCOL to the server to create this new directory.
    // If this is a create of a file, then the create
    // options will have FILE_DIRECTORY_FILE set.
    //

    if ( !(CreateRequest->CreateOptions & FILE_DIRECTORY_FILE) ) {

        //
        // This Create is for a file.
        // This thread is currently impersonating the client that 
        // made this request. Before we call DavDavCreateUrlCacheEntry,
        // we need to revert back to the context of the Web Client
        // service.
        //
        RevertToSelf();
        didImpersonate = FALSE;

        //
        // Call DavCreateUrlCacheEntry to create an entry in the 
        // WinInet's cache.
        //
        WStatus = DavCreateUrlCacheEntry(DavWorkItem);
        if (WStatus != ERROR_SUCCESS) {
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncCreate/DavCreateUrlCacheEntry(1). "
                      "WStatus = %d\n", WStatus));
            goto EXIT_THE_FUNCTION;
        }

        //
        // Call DavCommitUrlCacheEntry to commit (pin) the entry 
        // created above in the WinInet's cache.
        //
        WStatus = DavCommitUrlCacheEntry(DavWorkItem);
        if (WStatus != ERROR_SUCCESS) {
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncCreate/DavCommitUrlCacheEntry(1). "
                      "WStatus = %d\n", WStatus));
            goto EXIT_THE_FUNCTION;
        }

        if (ShouldEncrypt) {
            //
            // if the file will be encrypted, we set the ACL to allow everyone to access. This
            // is because the thread needs to be impersonated to do encrypt the file in the user's
            // context. The URL cache in created in the Local System's context which won't be
            // accessiable to the user if the ACL is not set.
            //
            WStatus = DavSetAclForEncryptedFile(DavWorkItem->AsyncCreate.FileName);
            if (WStatus != ERROR_SUCCESS) {
                DavPrint((DEBUG_ERRORS,
                          "DavAsyncCreate/DavSetAclForEncryptedFile(2). Error Val = %d, FileName = %ws\n",
                          WStatus, DavWorkItem->AsyncCreate.FileName));
                goto EXIT_THE_FUNCTION;
            }
        }

        //
        // Impersonate back again, so that we are in the context of
        // the user who issued this request.
        //
        WStatus = UMReflectorImpersonate(UserWorkItem, DavWorkItem->ImpersonationHandle);
        if (WStatus != ERROR_SUCCESS) {
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncCreate/QueryPDirectory/UMReflectorImpersonate. "
                      "Error Val = %d\n", WStatus));
            goto EXIT_THE_FUNCTION;
        }
        didImpersonate = TRUE;

        //
        // This file exists on the server, but this create operation
        // has FILE_OVERWRITE_IF as its CreateDisposition. So, we
        // can create this file locally overwrite the one on the
        // server on close.
        //
        if (CreateRequest->CreateDisposition == FILE_OVERWRITE_IF) {
            DavPrint((DEBUG_MISC,
                      "DavAsyncCreate/QueryPDirectory: FileName: %ws. ExistsAndOverWriteIf = TRUE\n",
                      DavWorkItem->AsyncCreate.FileName));
            ASSERT(CreateRequest->CreateDisposition == FILE_OVERWRITE_IF);
            CreateResponse->ExistsAndOverWriteIf = TRUE;
        }

        //
        // If "FILE_DELETE_ON_CLOSE" flag was specified as one of
        // the CreateOptions, then we need to remember this and
        // delete this file on close.
        //
        if (CreateRequest->CreateOptions & FILE_DELETE_ON_CLOSE) {
            DavPrint((DEBUG_MISC,
                      "DavAsyncCreate/QueryPDirectory: FileName: %ws. DeleteOnClose = TRUE\n",
                      DavWorkItem->AsyncCreate.FileName));
            CreateResponse->DeleteOnClose = TRUE;
        }

        //
        // Create the file handle to be returned back to the kernel.
        //

        QualityOfService.Length = sizeof(QualityOfService);
        QualityOfService.ImpersonationLevel = CreateRequest->ImpersonationLevel;
        QualityOfService.ContextTrackingMode = FALSE;
        QualityOfService.EffectiveOnly = (BOOLEAN)
        (CreateRequest->SecurityFlags & DAV_SECURITY_EFFECTIVE_ONLY);

        //
        // Create an NT path name for the cached file. This is used in the
        // NtCreateFile call below.
        //
        ReturnVal = RtlDosPathNameToNtPathName_U(DavWorkItem->AsyncCreate.FileName,
                                                 &UnicodeFileName,
                                                 NULL,
                                                 NULL);
        if (!ReturnVal) {
            WStatus = ERROR_BAD_PATHNAME;
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncCreate/QueryPDirectory/RtlDosPathNameToNtPathName. "
                      "Error Val = %d\n", WStatus));
            goto EXIT_THE_FUNCTION;
        }

        InitializeObjectAttributes(&ObjectAttributes,
                                   &UnicodeFileName,
                                   OBJ_CASE_INSENSITIVE,
                                   0,
                                   NULL);

        if (CreateRequest->SecurityDescriptor != NULL) {
            ObjectAttributes.SecurityDescriptor = CreateRequest->SecurityDescriptor;
        }
        ObjectAttributes.SecurityQualityOfService = &QualityOfService;

        //
        // If CreateRequest->CreateDisposition == FILE_CREATE, then
        // the NtCreateFile operation below will fail because we
        // have already created the file with the CreateUrlCacheEntry
        // call. So we change the value to FILE_OPEN_IF.
        //
        if (CreateRequest->CreateDisposition == FILE_CREATE) {
            CreateRequest->CreateDisposition = FILE_OPEN_IF;
        }

        if (ShouldEncrypt) {
            //
            // The file is encrypted in the user's context
            //
            BStatus = EncryptFile(DavWorkItem->AsyncCreate.FileName);
            
            if (BStatus) {
                DavPrint((DEBUG_MISC,
                         "DavAsyncCreate: Local cache is encrypted %wZ\n",
                          &UnicodeFileName));
                CreateResponse->LocalFileIsEncrypted = TRUE;
                CreateResponse->BasicInformation.FileAttributes |= FILE_ATTRIBUTE_ENCRYPTED;
            } else {
                WStatus = GetLastError();
                DavPrint((DEBUG_ERRORS,
                          "DavAsyncCreate/QueryPDirectory/EncryptFile. Error Val = %d\n",
                          WStatus));
                goto EXIT_THE_FUNCTION;
            }
        } else {
            DavPrint((DEBUG_MISC,
                     "DavAsyncCreate: Local cache is not encrypted %wZ\n",
                      &UnicodeFileName));
            //
            // This thread is currently impersonating the client that 
            // made this request. Before we call NtCreateFile, we need 
            // to revert back to the context of the Web Client service.
            //
            RevertToSelf();
            didImpersonate = FALSE;
        }
        
        //
        // We use FILE_SHARE_VALID_FLAGS for share access because RDBSS 
        // checks this for us. Moreover, we delay the close after the final 
        // close happens and this could cause problems. Consider the scenario.
        // 1. Open with NO share access.
        // 2. We create a local handle with this share access.
        // 3. The app closes the handle. We delay the close and keep the local
        //    handle.
        // 4. Another open comes with any share access. This will be 
        //    conflicting share access since the first one was done with no
        //    share access. This should succeed since the previous open has 
        //    been closed from the app and the I/O systems point of view.
        // 5. It will not if we have created the local handle with the share
        //    access which came with the first open.
        // Therefore we need to pass FILE_SHARE_VALID_FLAGS while creating
        // the local handle.
        //

        //
        // We have FILE_NO_INTERMEDIATE_BUFFERING ORed with the CreateOptions
        // the user specified, becuase we don't want the underlying file system
        // to create another cache map. This way all the I/O that comes to us
        // will directly go to the disk. BUG 128843 in the Windows RAID database
        // explains some deadlock scenarios that could happen with PagingIo if
        // we don't do this. Also since we supply the FILE_NO_INTERMEDIATE_BUFFERING
        // option we filter out the FILE_APPEND_DATA from the DesiredAccess flags
        // since the filesystem expects this.
        //
         
        //
        // We also always create the file with DesiredAccess ORed with FILE_WRITE_DATA
        // if either FILE_READ_DATA or FILE_EXECUTE was specified because there
        // can be situations where we get write IRPs on a FILE_OBJECT which was
        // not opened with Write Access and was only opened with FILE_READ_DATA
        // or FILE_EXECUTE. This is BUG 284557. To get around the problem, we do
        // this.
        //

        //
        // We filter the FILE_ATTRIBUTE_READONLY attribute during the create.
        // This is done because we store the READ_ONLY bit in the FCB and do
        // the checks at the RDBSS level before going to the local filesystem.
        // Also, since some of our creates open the file with FILE_WRITE_DATA,
        // if someone creates a read_only file and we stamp the read_only
        // attribute on the local file then all subsequent creates will fail
        // since we always ask for Write access to the underlying file as
        // explained above.
        //

        DesiredAccess = (CreateRequest->DesiredAccess & ~(FILE_APPEND_DATA));
        if ( DesiredAccess & (FILE_READ_DATA | FILE_EXECUTE) ) {
            DesiredAccess |= (FILE_WRITE_DATA);
        }

        NtStatus = NtCreateFile(&(FileHandle),
                                DesiredAccess,
                                &ObjectAttributes,
                                &IoStatusBlock,
                                &CreateRequest->AllocationSize,
                                (CreateRequest->FileAttributes & ~FILE_ATTRIBUTE_READONLY),
                                FILE_SHARE_VALID_FLAGS,
                                CreateRequest->CreateDisposition,
                                (CreateRequest->CreateOptions | FILE_NO_INTERMEDIATE_BUFFERING),
                                CreateRequest->EaBuffer,
                                CreateRequest->EaLength);

        if (NtStatus != STATUS_SUCCESS) {
            //
            // We convert the NtStatus to DOS error here. The Win32
            // error code is finally set to an NTSTATUS value in
            // the DavFsCreate function just before returning.
            //
            WStatus = RtlNtStatusToDosError(NtStatus);
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncCreate/QueryPDirectory/NtCreateFile(1). Error Val = "
                      "%08lx\n", NtStatus));
            CreateResponse->Handle = NULL;
            CreateResponse->UserModeKey = NULL;
            goto EXIT_THE_FUNCTION;
        }

        DavPrint((DEBUG_MISC, "DavAsyncCreate/QueryPDirectory: DavWorkItem = %08lx.\n",
                  DavWorkItem));

        DavPrint((DEBUG_MISC, "DavAsyncCreate/QueryPDirectory: FileHandle = %08lx.\n",
                  FileHandle));

        CreateResponse->Handle = FileHandle;
        CreateResponse->UserModeKey = (PVOID)FileHandle;

        //
        // If the file already exists on the server, then we don't
        // need to create it and are done.
        //
        if (DavWorkItem->AsyncCreate.doesTheFileExist) {
            
            DavPrint((DEBUG_MISC,
                      "DavAsyncCreate/QueryPDirectory: doesTheFileExist == TRUE\n"));
            
            WStatus = ERROR_SUCCESS;
            
            goto EXIT_THE_FUNCTION;
        
        } else {
            
            SYSTEMTIME CurrentSystemTime, NewSystemTime;
            FILETIME CurrentFileTime;
            BOOL ConvertTime = FALSE;
            LARGE_INTEGER CurrentTime;
            WCHAR chTimeBuff[INTERNET_RFC1123_BUFSIZE + 4];

            //
            // This file may have been created locally and does not exist
            // on the server. We need to remember this information and
            // set attributes on this file on the server on close.
            //
            if (CreateRequest->FileAttributes != 0) {
                CreateResponse->NewFileCreatedAndSetAttributes = TRUE;
                //
                // Copy the attributes in the CreateResponse. These 
                // will get PROPPATCHED to the server on Close.
                //
                CreateResponse->BasicInformation.FileAttributes = CreateRequest->FileAttributes;
                
                if (ShouldEncrypt) {
                    CreateResponse->BasicInformation.FileAttributes |= FILE_ATTRIBUTE_ENCRYPTED;
                }
            }

            DavPrint((DEBUG_MISC,
                     "DavAsyncCreate/QueryPDirectory NewFileCreatedAndSetAttributes %x %x %ws\n",
                      CreateRequest->FileAttributes,
                      CreateResponse->BasicInformation.FileAttributes,
                      DavWorkItem->AsyncCreate.FileName));

            //
            // We also need to set the FILE_BASIC_INFORMATION time values to 
            // the current time. We get the systemtime, convert it into the 
            // RFC1123 format and then convert the format back into systemtime.
            // We do this because on close when we PROPPATCH these times we send
            // them in the RFC1123 format. Since the least count of this format is
            // seconds, some data is lost when we convert the LARGE_INTEGER to
            // RFC1123 format and back. So, we lose this data right now to be 
            // consistent. To give an example about the loss, see below.
            // CreationTime.LowPart = 802029d0, CreationTime.HighPart = 1c0def1
            // maps to "Thu, 17 May 2001 16:50:38 GMT"
            // And "Thu, 17 May 2001 16:50:38 GMT" is what we get back when we do a
            // PROPFIND which converts back into
            // CreationTime.LowPart = 7fdc4300, CreationTime.HighPart = 1c0def1
            // Note that the LowPart is different. So, the values in the name cache
            // and the server will be different. To avoid this inconsistency we lose
            // this data by doing the conversion right away.
            //

            GetSystemTime( &(CurrentSystemTime) );

            RtlZeroMemory(chTimeBuff, sizeof(chTimeBuff));

            ConvertTime = InternetTimeFromSystemTimeW(&(CurrentSystemTime),
                                                      INTERNET_RFC1123_FORMAT,
                                                      chTimeBuff,
                                                      sizeof(chTimeBuff));
            if (ConvertTime) {
                ConvertTime = InternetTimeToSystemTimeW(chTimeBuff, &(NewSystemTime), 0);
                if (ConvertTime) {
                    ConvertTime = SystemTimeToFileTime( &(NewSystemTime), &(CurrentFileTime) );
                    if (ConvertTime) {
                        CreateResponse->PropPatchTheTimeValues = TRUE;
                        CurrentTime.LowPart = CurrentFileTime.dwLowDateTime;
                        CurrentTime.HighPart = CurrentFileTime.dwHighDateTime;
                        CreateResponse->BasicInformation.CreationTime.QuadPart = CurrentTime.QuadPart;
                        CreateResponse->BasicInformation.LastAccessTime.QuadPart = CurrentTime.QuadPart;
                        CreateResponse->BasicInformation.LastWriteTime.QuadPart = CurrentTime.QuadPart;
                        CreateResponse->BasicInformation.ChangeTime.QuadPart = CurrentTime.QuadPart;
                    }
                }
            }

            //
            // If the above conversion from systemtime to RFC1123 format and then
            // back to systemtime from RFc1123 format failed then we go ahead and
            // convert the systemtime to filetime and use that.
            //

            if (!ConvertTime) {
                ConvertTime = SystemTimeToFileTime( &(CurrentSystemTime), &(CurrentFileTime) );
                if (ConvertTime) {
                    CreateResponse->PropPatchTheTimeValues = TRUE;
                    CurrentTime.LowPart = CurrentFileTime.dwLowDateTime;
                    CurrentTime.HighPart = CurrentFileTime.dwHighDateTime;
                    CreateResponse->BasicInformation.CreationTime.QuadPart = CurrentTime.QuadPart;
                    CreateResponse->BasicInformation.LastAccessTime.QuadPart = CurrentTime.QuadPart;
                    CreateResponse->BasicInformation.LastWriteTime.QuadPart = CurrentTime.QuadPart;
                    CreateResponse->BasicInformation.ChangeTime.QuadPart = CurrentTime.QuadPart;
                } else {
                    //
                    // This is not a fatal error. We can still continie with the
                    // Create call.
                    //
                    DavPrint((DEBUG_ERRORS,
                              "DavAsyncCreateQueryParentDirectory/SystemTimeToFileTime(1): %x\n",
                              GetLastError()));
                }
            }
        
        }

        //
        // We are done with the Open handle to PROPFIND. 
        // Now we need to create the directory on the server.
        //
        if (DavWorkItem->AsyncCreate.DavOpenHandle) {
            InternetCloseHandle(DavWorkItem->AsyncCreate.DavOpenHandle);
            DavWorkItem->AsyncCreate.DavOpenHandle = NULL;
        }

        //
        // We need to "PUT" this new file on the server.
        //
        DavPrint((DEBUG_MISC, "DavAsyncCreate/QueryPDirectory: PUT New File\n"));

        //
        // If we are not currently impersonating, we need to impersonate back
        // again, so that we are in the context of the user who issued this
        // request.
        //
        if (didImpersonate == FALSE) {
            WStatus = UMReflectorImpersonate(UserWorkItem, DavWorkItem->ImpersonationHandle);
            if (WStatus != ERROR_SUCCESS) {
                DavPrint((DEBUG_ERRORS,
                          "DavAsyncCreate/QueryPDirectory/UMReflectorImpersonate. "
                          "Error Val = %d\n", WStatus));
                goto EXIT_THE_FUNCTION;
            }
            didImpersonate = TRUE;
        }
        
        //
        // Set the DavOperation and AsyncCreateState values.For PUT 
        // the DavMinorOperation value is irrelavant.
        //
        DavWorkItem->DavOperation = DAV_CALLBACK_HTTP_OPEN;
        DavWorkItem->AsyncCreate.AsyncCreateState = AsyncCreatePut;

        //
        // Convert the unicode object name to UTF-8 URL format.
        // Space and other white characters will remain untouched. 
        // These should be taken care of by wininet calls.
        //
        BStatus = DavHttpOpenRequestW(DavWorkItem->AsyncCreate.PerUserEntry->DavConnHandle,
                                      L"PUT",
                                      DavWorkItem->AsyncCreate.RemPathName,
                                      L"HTTP/1.1",
                                      NULL,
                                      NULL,
                                      INTERNET_FLAG_KEEP_CONNECTION |
                                      INTERNET_FLAG_NO_COOKIES,
                                      CallBackContext,
                                      L"QueryPDirectory",
                                      &(DavWorkItem->AsyncCreate.DavOpenHandle));

        if(BStatus == FALSE) {
            WStatus = GetLastError();
            DavPrint((DEBUG_ERRORS,"DavAsyncCreate/QueryPDirectory/DavHttpOpenRequestW error: %x\n",WStatus));
            goto EXIT_THE_FUNCTION;
        }

        if (DavWorkItem->AsyncCreate.DavOpenHandle == NULL) {
            WStatus = GetLastError();
            if (WStatus != ERROR_IO_PENDING) {
                DavPrint((DEBUG_ERRORS,
                          "DavAsyncCreate/QueryPDirectory/HttpOpenRequestW"
                          ". Error Val = %d\n", WStatus));
            }
            goto EXIT_THE_FUNCTION;
        }

        WStatus = DavAsyncCommonStates(DavWorkItem, FALSE);
        if (WStatus != ERROR_SUCCESS && WStatus != ERROR_IO_PENDING) {
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncCreate/QueryPDirectory/DavAsyncCommonStates(PUT). "
                      "Error Val = %08lx\n", WStatus));
        }

        //
        // We LOCK the resource if the following conditions are TRUE.
        // 1. The resource already exists on the server AND,
        // 2. The resource being opened is a file and NOT a directory AND,
        // 3. The SharedMode is 0 (exclusive) OR FILE_SHARE_READ OR the file is
        //    being opened for write access.
        //
        if (DavSupportLockingOfFiles) {
            if ( (CreateRequest->ShareAccess == 0) || (CreateRequest->ShareAccess == FILE_SHARE_READ) ||
                 (CreateRequest->DesiredAccess & (FILE_WRITE_DATA | FILE_APPEND_DATA | GENERIC_WRITE | GENERIC_ALL)) ) {
                WStatus = DavLockTheFileOnTheServer(DavWorkItem);
                if (WStatus != ERROR_SUCCESS) {
                    DavPrint((DEBUG_ERRORS,
                              "DavAsyncCreateQueryParentDirectory/DavLockTheFileOnTheServer. WStatus = %08lx\n",
                              WStatus));
                    goto EXIT_THE_FUNCTION;
                }
            }
        }

        goto EXIT_THE_FUNCTION;

    } else {

        SYSTEMTIME CurrentSystemTime, NewSystemTime;
        FILETIME CurrentFileTime;
        BOOL ConvertTime = FALSE;
        LARGE_INTEGER CurrentTime;
        WCHAR chTimeBuff[INTERNET_RFC1123_BUFSIZE + 4];

        //
        // We are done with the Open handle to PROPFIND. 
        // Now we need to create the directory on the server.
        //
        InternetCloseHandle(DavWorkItem->AsyncCreate.DavOpenHandle);
        DavWorkItem->AsyncCreate.DavOpenHandle = NULL;

        //
        // This Create is for a Directory. We need to send an
        // MKCOL to the server.
        //
        DavPrint((DEBUG_MISC, "DavAsyncCreate/QueryPDirectory: Create Directory\n"));

        //
        // Set the DavOperation and AsyncCreateState values.
        // For MKCOL the DavMinorOperation value is irrelavant.
        //
        DavWorkItem->DavOperation = DAV_CALLBACK_HTTP_OPEN;
        DavWorkItem->AsyncCreate.AsyncCreateState = AsyncCreateMkCol;

        //
        // The data is parsed. We now need to set the file attributes in the
        // response buffer.
        //
        CreateResponse->BasicInformation.FileAttributes = CreateRequest->FileAttributes;
        CreateResponse->BasicInformation.FileAttributes |= FILE_ATTRIBUTE_DIRECTORY;
        CreateResponse->StandardInformation.Directory = TRUE;

        //
        // Since we are creating a new directory we need to PROPPATCH the 
        // attributes on the directory that is getting created below on close.
        //
        CreateResponse->NewFileCreatedAndSetAttributes = TRUE;

        if (ShouldEncrypt) {
            DavPrint((DEBUG_MISC,
                      "DavAsyncCreate: New directory is encrypted\n"));
            CreateResponse->BasicInformation.FileAttributes |= FILE_ATTRIBUTE_ENCRYPTED;
        }
        
        //
        // We also need to set the FILE_BASIC_INFORMATION time values to 
        // the current time. We get the systemtime, convert it into the 
        // RFC1123 format and then convert the format back into systemtime.
        // We do this because on close when we PROPPATCH these times we send
        // them in the RFC1123 format. Since the least count of this format is
        // seconds, some data is lost when we convert the LARGE_INTEGER to
        // RFC1123 format and back. So, we lose this data right now to be 
        // consistent. To give an example about the loss, see below.
        // CreationTime.LowPart = 802029d0, CreationTime.HighPart = 1c0def1
        // maps to "Thu, 17 May 2001 16:50:38 GMT"
        // And "Thu, 17 May 2001 16:50:38 GMT" is what we get back when we do a
        // PROPFIND which converts back into
        // CreationTime.LowPart = 7fdc4300, CreationTime.HighPart = 1c0def1
        // Note that the LowPart is different. So, the values in the name cache
        // and the server will be different. To avoid this inconsistency we lose
        // this data by doing the conversion right away.
        //

        GetSystemTime( &(CurrentSystemTime) );

        RtlZeroMemory(chTimeBuff, sizeof(chTimeBuff));

        ConvertTime = InternetTimeFromSystemTimeW(&(CurrentSystemTime),
                                                  INTERNET_RFC1123_FORMAT,
                                                  chTimeBuff,
                                                  sizeof(chTimeBuff));
        if (ConvertTime) {
            ConvertTime = InternetTimeToSystemTimeW(chTimeBuff, &(NewSystemTime), 0);
            if (ConvertTime) {
                ConvertTime = SystemTimeToFileTime( &(NewSystemTime), &(CurrentFileTime) );
                if (ConvertTime) {
                    CreateResponse->PropPatchTheTimeValues = TRUE;
                    CurrentTime.LowPart = CurrentFileTime.dwLowDateTime;
                    CurrentTime.HighPart = CurrentFileTime.dwHighDateTime;
                    CreateResponse->BasicInformation.CreationTime.QuadPart = CurrentTime.QuadPart;
                    CreateResponse->BasicInformation.LastAccessTime.QuadPart = CurrentTime.QuadPart;
                    CreateResponse->BasicInformation.LastWriteTime.QuadPart = CurrentTime.QuadPart;
                    CreateResponse->BasicInformation.ChangeTime.QuadPart = CurrentTime.QuadPart;
                }
            }
        }

        //
        // If the above conversion from systemtime to RFC1123 format and then
        // back to systemtime from RFc1123 format failed then we go ahead and
        // convert the systemtime to filetime and use that.
        //
        
        if (!ConvertTime) {
            ConvertTime = SystemTimeToFileTime( &(CurrentSystemTime), &(CurrentFileTime) );
            if (ConvertTime) {
                CreateResponse->PropPatchTheTimeValues = TRUE;
                CurrentTime.LowPart = CurrentFileTime.dwLowDateTime;
                CurrentTime.HighPart = CurrentFileTime.dwHighDateTime;
                CreateResponse->BasicInformation.CreationTime.QuadPart = CurrentTime.QuadPart;
                CreateResponse->BasicInformation.LastAccessTime.QuadPart = CurrentTime.QuadPart;
                CreateResponse->BasicInformation.LastWriteTime.QuadPart = CurrentTime.QuadPart;
                CreateResponse->BasicInformation.ChangeTime.QuadPart = CurrentTime.QuadPart;
            } else {
                //
                // This is not a fatal error. We can still continie with the
                // Create call.
                //
                DavPrint((DEBUG_ERRORS,
                          "DavAsyncCreateQueryParentDirectory/SystemTimeToFileTime(2): %x\n",
                          GetLastError()));
            }
        }
        
        //
        // Convert the unicode object name to UTF-8 URL format.
        // Space and other white characters will remain untouched. 
        // These should be taken care of by wininet calls.
        //
        BStatus = DavHttpOpenRequestW(DavWorkItem->AsyncCreate.PerUserEntry->DavConnHandle,
                                      L"MKCOL",
                                      DavWorkItem->AsyncCreate.RemPathName,
                                      L"HTTP/1.1",
                                      NULL,
                                      NULL,
                                      INTERNET_FLAG_KEEP_CONNECTION |
                                      INTERNET_FLAG_NO_COOKIES,
                                      CallBackContext,
                                      L"QueryPDirectory",
                                      &(DavWorkItem->AsyncCreate.DavOpenHandle ));
        if(BStatus == FALSE) {
            WStatus = GetLastError();
            goto EXIT_THE_FUNCTION;
        }
        if (DavWorkItem->AsyncCreate.DavOpenHandle == NULL) {
            WStatus = GetLastError();
            if (WStatus != ERROR_IO_PENDING) {
                DavPrint((DEBUG_ERRORS,
                          "DavAsyncCreate/QueryPDirectory/HttpOpenRequestW"
                          ". Error Val = %d\n", WStatus));
            }
            goto EXIT_THE_FUNCTION;
        }

        WStatus = DavAsyncCommonStates(DavWorkItem, FALSE);
        if (WStatus != ERROR_SUCCESS && WStatus != ERROR_IO_PENDING) {
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncCreate/QueryPDirectory/DavAsyncCommonStates(MKCOL). "
                      "Error Val = %08lx\n", WStatus));
        }

        goto EXIT_THE_FUNCTION;
    }

EXIT_THE_FUNCTION:

    //
    // The function RtlDosPathNameToNtPathName_U allocates memory from the
    // processes heap. If we did, we need to free it now.
    //
    if (UnicodeFileName.Buffer != NULL) {
        RtlFreeHeap(RtlProcessHeap(), 0, UnicodeFileName.Buffer);
    }

    if (!didImpersonate) {
        ULONG LocalStatus;
        //
        // Impersonate back again, so that we are in the context of
        // the user who issued this request.
        //
        LocalStatus = UMReflectorImpersonate(UserWorkItem, DavWorkItem->ImpersonationHandle);
        if (LocalStatus != ERROR_SUCCESS) {
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncCreate/QueryPDirectory/UMReflectorImpersonate. "
                      "Error Val = %d\n", LocalStatus));
            if (WStatus == ERROR_SUCCESS) {
                WStatus = LocalStatus;
            }
        }
    }

    return WStatus;
}


DWORD
DavAsyncCreateGet(
    PDAV_USERMODE_WORKITEM DavWorkItem
    )
/*++

Routine Description:

   This routine handles the Get completion.

Arguments:

    DavWorkItem - The DAV_USERMODE_WORKITEM value.

Return Value:

    none.

--*/
{
    ULONG WStatus = ERROR_SUCCESS;
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PUMRX_USERMODE_WORKITEM_HEADER UserWorkItem = NULL;
    BOOL ReturnVal, didImpersonate = FALSE;
    HANDLE FileHandle = INVALID_HANDLE_VALUE;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatusBlock;
    SECURITY_QUALITY_OF_SERVICE QualityOfService;
    PDAV_USERMODE_CREATE_REQUEST CreateRequest;
    PDAV_USERMODE_CREATE_RESPONSE CreateResponse;
    UNICODE_STRING UnicodeFileName;
    ULONG_PTR CallBackContext = (ULONG_PTR)0;
    PWCHAR pEncryptedCachedFile = NULL;
    ACCESS_MASK DesiredAccess = 0;
    BOOL EncryptedFile = FALSE;
    FILE_STANDARD_INFORMATION FileStdInfo;

    UserWorkItem = (PUMRX_USERMODE_WORKITEM_HEADER)DavWorkItem;

    UnicodeFileName.Buffer = NULL;
    UnicodeFileName.Length = 0;
    UnicodeFileName.MaximumLength = 0;

    //
    // Get the request and response buffer pointers from the DavWorkItem.
    //
    CreateRequest = &(DavWorkItem->CreateRequest);
    CreateResponse = &(DavWorkItem->CreateResponse);
    CreateResponse->fPsuedoOpen = FALSE;
    
    if (CreateResponse->BasicInformation.FileAttributes & FILE_ATTRIBUTE_ENCRYPTED) {

        //
        // This file is encrypted. We need to restore the file. For doing this
        // we need to create another entry in the WinInet cache in which the
        // file will be restored.
        //

        DavPrint((DEBUG_MISC, "DavAsyncCreateGet: This is an Encrypted File.\n"));

        EncryptedFile = TRUE;

        //
        // Save the encrypted file name.
        //
        pEncryptedCachedFile = DavWorkItem->AsyncCreate.FileName;
        
        DavWorkItem->AsyncCreate.FileName = NULL;

        WStatus = DavCreateUrlCacheEntry(DavWorkItem);                
        if (WStatus != ERROR_SUCCESS) {
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncCreateGet/CreateUrlCacheEntry. Error Val = %d\n",
                      WStatus));
            goto EXIT_THE_FUNCTION;
        }

        DavPrint((DEBUG_MISC, "DavAsyncCreateGet: EncryptedCachedFile = %ws\n", pEncryptedCachedFile));

        DavPrint((DEBUG_MISC, "DavAsyncCreateGet: NewFileName = %ws\n", DavWorkItem->AsyncCreate.FileName));

        WStatus = DavSetAclForEncryptedFile(DavWorkItem->AsyncCreate.FileName);
        if (WStatus != ERROR_SUCCESS) {
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncCreate/DavSetAclForEncryptedFile(3). Error Val = %d, FileName = %ws\n",
                      WStatus, DavWorkItem->AsyncCreate.FileName));
            goto EXIT_THE_FUNCTION;
        }

        if (DavWorkItem->AsyncCreate.FileHandle != NULL) {
            //
            // Close the opened file handle since we don't need it anymore. We
            // close the file after setting the ACLs so that the file won't be
            // scavenged by WinInet by any chance.
            //
            ReturnVal = CloseHandle(DavWorkItem->AsyncCreate.FileHandle);
            if (!ReturnVal) {
                WStatus = GetLastError();
                DavPrint((DEBUG_ERRORS,
                          "DavAsyncCreateGet/CloseHandle. Error Val = %d\n", WStatus));
                goto EXIT_THE_FUNCTION;
            }

            DavWorkItem->AsyncCreate.FileHandle = NULL;
        }

        WStatus = UMReflectorImpersonate(UserWorkItem, DavWorkItem->ImpersonationHandle);
        if (WStatus != ERROR_SUCCESS) {
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncCreateGet/UMReflectorImpersonate. "
                      "Error Val = %d\n", WStatus));
            goto EXIT_THE_FUNCTION;
        }
        didImpersonate = TRUE;

        WStatus = DavRestoreEncryptedFile(pEncryptedCachedFile, DavWorkItem->AsyncCreate.FileName);
        if (WStatus != ERROR_SUCCESS) {
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncCreateGet/DavRestoreEncryptedFile. Error Val"
                      " = %d %x %x\n", 
                      WStatus,
                      CreateRequest->FileAttributes,
                      CreateResponse->BasicInformation.FileAttributes));
            goto EXIT_THE_FUNCTION;
        }

        //
        // Copy the "new" file name in the response buffer.
        //
        wcscpy(CreateResponse->FileName, DavWorkItem->AsyncCreate.FileName);

        CreateResponse->LocalFileIsEncrypted = TRUE;

        //
        // Don't commit the restored EFS file so that the next open will still
        // see the file in the back up format and the EFS header.
        //

    } else {

        if (DavWorkItem->AsyncCreate.FileHandle != NULL) {
            //
            // Close the opened file handle since we don't need it anymore.
            //
            ReturnVal = CloseHandle(DavWorkItem->AsyncCreate.FileHandle);
            if (!ReturnVal) {
                WStatus = GetLastError();
                DavPrint((DEBUG_ERRORS,
                          "DavAsyncCreateGet/CloseHandle. Error Val = %d\n", WStatus));
                goto EXIT_THE_FUNCTION;
            }

            DavWorkItem->AsyncCreate.FileHandle = NULL;
        }

        //
        // If the file already exists, encryption can only be taken place if the
        // CreateDisposition is not FILE_SUPERSEDE, FILE_OVERWRITE or
        // FILE_OVERWRITE_IF.
        //
        if ((CreateRequest->FileAttributes & FILE_ATTRIBUTE_ENCRYPTED) &&
            ((CreateRequest->CreateDisposition == FILE_SUPERSEDE) ||
             (CreateRequest->CreateDisposition == FILE_OVERWRITE) ||
             (CreateRequest->CreateDisposition == FILE_OVERWRITE_IF))) {

            WStatus = DavSetAclForEncryptedFile(DavWorkItem->AsyncCreate.FileName);
            if (WStatus != ERROR_SUCCESS) {
                DavPrint((DEBUG_ERRORS,
                          "DavAsyncCreate/DavSetAclForEncryptedFile(4). Error Val = %d, FileName = %ws\n",
                          WStatus, DavWorkItem->AsyncCreate.FileName));
                goto EXIT_THE_FUNCTION;
            }

            WStatus = UMReflectorImpersonate(UserWorkItem, DavWorkItem->ImpersonationHandle);
            if (WStatus != ERROR_SUCCESS) {
                DavPrint((DEBUG_ERRORS,
                          "DavAsyncCreateGet/UMReflectorImpersonate. "
                          "Error Val = %d\n", WStatus));
                goto EXIT_THE_FUNCTION;
            }
            didImpersonate = TRUE;

            //
            // The file is encrypted in the user's context
            //
            if (EncryptFile(DavWorkItem->AsyncCreate.FileName)) {
                DavPrint((DEBUG_MISC,
                         "DavAsyncCreate: Local cache is encrypted %wZ\n",
                          &UnicodeFileName));
                CreateResponse->LocalFileIsEncrypted = TRUE;
                CreateResponse->BasicInformation.FileAttributes |= FILE_ATTRIBUTE_ENCRYPTED;
            } else {
                WStatus = GetLastError();
                DavPrint((DEBUG_ERRORS,
                          "DavAsyncCreate/QueryPDirectory/EncryptFile. Error Val = %d\n",
                          WStatus));
                goto EXIT_THE_FUNCTION;
            }

            CreateRequest->FileAttributes &= ~FILE_ATTRIBUTE_ENCRYPTED;
            CreateResponse->BasicInformation.FileAttributes |= FILE_ATTRIBUTE_ENCRYPTED;
            CreateResponse->LocalFileIsEncrypted = TRUE;
        }

    }

#ifdef WEBCLIENT_SUPPORTS_BACKUP_RESTORE_FOR_EFS
    //
    // Enable the Backup/Restore privilege on the thread for the encrypted file
    // so that Backup/Restore operation can be done to the file even if the
    // the thread is not impersonated to the owner of the file.
    //
    
    if (EncryptedFile) {
        PTOKEN_PRIVILEGES pPrevPriv = NULL;
        DWORD cbPrevPriv = sizeof(TOKEN_PRIVILEGES);
        BYTE rgbNewPriv[sizeof(TOKEN_PRIVILEGES) + sizeof(LUID_AND_ATTRIBUTES)];
        PTOKEN_PRIVILEGES pNewPriv = (PTOKEN_PRIVILEGES)rgbNewPriv;
        HANDLE hToken = 0;

        for (;;) {
            if (!OpenThreadToken(GetCurrentThread(),
                                 TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                                 FALSE,
                                 &hToken)) {
                DbgPrint("OpenThreadToken failed %d\n", GetLastError());
                break;

                // need to close the hToken at the end.
            }

            // set up the new priviledge state
            memset(rgbNewPriv, 0, sizeof(rgbNewPriv));
            pNewPriv->PrivilegeCount = 1;
            if(!LookupPrivilegeValueW(NULL, SE_SECURITY_NAME,
                                      &(pNewPriv->Privileges[0].Luid))) {
                DbgPrint("LookupPrivilegeValueW failed \n");
                break;
            }

            pNewPriv->Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
            pNewPriv->Privileges[0].Luid = RtlConvertLongToLuid(SE_RESTORE_PRIVILEGE);

            // alloc for the previous state
            pPrevPriv = (PTOKEN_PRIVILEGES)LocalAlloc(LMEM_ZEROINIT,sizeof(TOKEN_PRIVILEGES));

            if (!pPrevPriv) {
                DbgPrint("LocalAlloc for Adjust token failed \n");
                break;
            }

            // adjust the priviledge and get the previous state
            if (!AdjustTokenPrivileges(hToken,
                                       FALSE,
                                       pNewPriv,
                                       cbPrevPriv,
                                       (PTOKEN_PRIVILEGES)pPrevPriv,
                                       &cbPrevPriv)) {
                DbgPrint("AdjustTokenPrivileges failed %d\n", GetLastError());
                break;
            }

            DbgPrint("AdjustTokenPrivileges succeeded\n")
            break;
        }

        if (pPrevPriv) {
            LocalFree(pPrevPriv);
        } 
    } 
#endif

    //
    // Create the file handle to be returned back to the kernel.
    //

    QualityOfService.Length = sizeof(QualityOfService);
    QualityOfService.ImpersonationLevel = CreateRequest->ImpersonationLevel;
    QualityOfService.ContextTrackingMode = FALSE;
    QualityOfService.EffectiveOnly = (BOOLEAN)(CreateRequest->SecurityFlags & DAV_SECURITY_EFFECTIVE_ONLY);

    //
    // Create an NT path name for the cached file. This is used in the
    // NtCreateFile call below.
    //
    ReturnVal = RtlDosPathNameToNtPathName_U(DavWorkItem->AsyncCreate.FileName,
                                             &UnicodeFileName,
                                             NULL,
                                             NULL);
    if (!ReturnVal) {
        WStatus = ERROR_BAD_PATHNAME;
        DavPrint((DEBUG_ERRORS,
                  "DavAsyncCreateGet/RtlDosPathNameToNtPathName. "
                  "Error Val = %d\n", WStatus));
        goto EXIT_THE_FUNCTION;
    }

    InitializeObjectAttributes(&ObjectAttributes,
                               &UnicodeFileName,
                               OBJ_CASE_INSENSITIVE,
                               0,
                               NULL);

    if (CreateRequest->SecurityDescriptor != NULL) {
        ObjectAttributes.SecurityDescriptor = CreateRequest->SecurityDescriptor;
    }
    
    ObjectAttributes.SecurityQualityOfService = &QualityOfService;

    //
    // We use FILE_SHARE_VALID_FLAGS for share access because RDBSS 
    // checks this for us. Moreover, we delay the close after the final 
    // close happens and this could cause problems. Consider the scenario.
    // 1. Open with NO share access.
    // 2. We create a local handle with this share access.
    // 3. The app closes the handle. We delay the close and keep the local
    //    handle.
    // 4. Another open comes with any share access. This will be 
    //    conflicting share access since the first one was done with no
    //    share access. This should succeed since the previous open has 
    //    been closed from the app and the I/O systems point of view.
    // 5. It will not if we have created the local handle with the share
    //    access which came with the first open.
    // Therefore we need to pass FILE_SHARE_VALID_FLAGS while creating
    // the local handle.
    //

    //
    // We have FILE_NO_INTERMEDIATE_BUFFERING ORed with the CreateOptions
    // the user specified, becuase we don't want the underlying file system
    // to create another cache map. This way all the I/O that comes to us
    // will directly go to the disk. BUG 128843 in the Windows RAID database
    // explains some deadlock scenarios that could happen with PagingIo if
    // we don't do this. Also since we supply the FILE_NO_INTERMEDIATE_BUFFERING
    // option we filter out the FILE_APPEND_DATA from the DesiredAccess flags
    // since the filesystem expects this.
    //

    //
    // We also always create the file with DesiredAccess ORed with FILE_WRITE_DATA
    // if either FILE_READ_DATA or FILE_EXECUTE was specified because there can
    // be situations where we get write IRPs on a FILE_OBJECT which was not
    // opened with Write Access and was only opened with FILE_READ_DATA or
    // FILE_EXECUTE. This is BUG 284557. To get around the problem, we do this.
    //

    //
    // We filter the FILE_ATTRIBUTE_READONLY attribute during the create.
    // This is done because we store the READ_ONLY bit in the FCB and do
    // the checks at the RDBSS level before going to the local filesystem.
    // Also, since some of our creates open the file with FILE_WRITE_DATA,
    // if someone creates a read_only file and we stamp the read_only
    // attribute on the local file then all subsequent creates will fail
    // since we always ask for Write access to the underlying file as
    // explained above.
    //

    //
    // We add to the DesiredAccess FILE_READ_ATTRIBUTES since we read the
    // attributes of this file since the file size value we got from the server
    // could be different from the GET Content-Length.
    //

    //
    // We need to remove the ACCESS_SYSTEM_SECURITY which will prevent us from
    // opening the file in the LocalService context even if the file is created
    // in LocalService context.
    //

    DesiredAccess = (CreateRequest->DesiredAccess & ~(FILE_APPEND_DATA | ACCESS_SYSTEM_SECURITY));
    DesiredAccess |= (FILE_READ_ATTRIBUTES);
    if ( DesiredAccess & (FILE_READ_DATA | FILE_EXECUTE) ) {
        DesiredAccess |= (FILE_WRITE_DATA);
    }

    NtStatus = NtCreateFile(&(FileHandle),
                            DesiredAccess,
                            &ObjectAttributes,
                            &IoStatusBlock,
                            &CreateRequest->AllocationSize,
                            (CreateRequest->FileAttributes & ~FILE_ATTRIBUTE_READONLY),
                            FILE_SHARE_VALID_FLAGS,
                            CreateRequest->CreateDisposition,
                            (CreateRequest->CreateOptions | FILE_NO_INTERMEDIATE_BUFFERING),
                            CreateRequest->EaBuffer,
                            CreateRequest->EaLength);

    if (NtStatus != STATUS_SUCCESS) {
        //
        // We convert the NtStatus to DOS error here. The Win32
        // error code is finally set to an NTSTATUS value in
        // the DavFsCreate function just before returning.
        //
        WStatus = RtlNtStatusToDosError(NtStatus);
        DavPrint((DEBUG_ERRORS,
                  "DavAsyncCreateGet/NtCreateFile(2). Error Val = "
                  "%x %x %x %x %x %x %x %x %ws\n", 
                  NtStatus, 
                  CreateRequest->ImpersonationLevel,
                  CreateRequest->SecurityFlags,
                  CreateRequest->SecurityDescriptor,
                  DesiredAccess,
                  CreateRequest->FileAttributes,
                  CreateRequest->CreateDisposition,
                  CreateRequest->CreateOptions,
                  DavWorkItem->AsyncCreate.FileName));
        CreateResponse->Handle = NULL;
        CreateResponse->UserModeKey = NULL;
        FileHandle = INVALID_HANDLE_VALUE;

        goto EXIT_THE_FUNCTION;
    }

    //
    // We don't impersonate back the client as yet since we might need 
    // to call NtQueryInformationFile next (if the file is encrypted)
    // which requires us to be in the context of the Web Client Service.
    //

    DavPrint((DEBUG_MISC, "DavAsyncCreateGet(2): FileHandle = %08lx\n", FileHandle));

    //
    // We query the StandardInformation of the file to find out if the FileSize
    // returned by PROPFIND is different from the content-length returned by GET.
    //
    NtStatus = NtQueryInformationFile(FileHandle,
                                      &(IoStatusBlock),
                                      &(FileStdInfo),
                                      sizeof(FILE_STANDARD_INFORMATION),
                                      FileStandardInformation);
    if (NtStatus != STATUS_SUCCESS) {
        //
        // We convert the NtStatus to DOS error here. The Win32
        // error code is finally set to an NTSTATUS value in
        // the DavFsCreate function just before returning.
        //
        WStatus = RtlNtStatusToDosError(NtStatus);
        NtClose(FileHandle);
        DavPrint((DEBUG_ERRORS,
                  "DavAsyncCreateGet/NtQueryInformationFile. Error Val "
                  "= %08lx\n", NtStatus));
        CreateResponse->Handle = NULL;
        CreateResponse->UserModeKey = NULL;
        FileHandle = INVALID_HANDLE_VALUE;
        goto EXIT_THE_FUNCTION;
    }

    //
    // The FileSize returned by PROPFIND is different from the the amount of
    // data that GET returned. Server screwup. We reset the filesize and the
    // allocationsize to match the underlying file. For encrypted files these
    // values will be different because PROPFIND returns the size of the backup
    // blob which is different from the size of the restored file.
    //
    if (!EncryptedFile && FileStdInfo.EndOfFile.QuadPart != CreateResponse->StandardInformation.EndOfFile.QuadPart) {
        //
        // Reset the FileSize and AllocationSize info in the response to the
        // FileSize and AllocationSize of the underlying file.
        //
        DavPrint((DEBUG_DEBUG,
                  "DavAsyncCreate: FileSizes Different!! CPN = %ws, "
                  "FileStdInfo.EndOfFile.HighPart = %x, "
                  "FileStdInfo.EndOfFile.LowPart = %x, "
                  "CreateResponse.EndOfFile.HighPart = %x, "
                  "CreateResponse.EndOfFile.LowPart = %x\n",
                  CreateRequest->CompletePathName,
                  FileStdInfo.EndOfFile.HighPart, FileStdInfo.EndOfFile.LowPart,
                  CreateResponse->StandardInformation.EndOfFile.HighPart,
                  CreateResponse->StandardInformation.EndOfFile.LowPart));
        CreateResponse->StandardInformation.EndOfFile.QuadPart = FileStdInfo.EndOfFile.QuadPart;
        CreateResponse->StandardInformation.AllocationSize.QuadPart = FileStdInfo.AllocationSize.QuadPart;
    }

    //
    // If the File was encrypted, we need to reset the file size in the response
    // buffer.
    //
    if (EncryptedFile) {
        //
        // Set the new AllocationSize and EndOfFile values.
        //
        CreateResponse->StandardInformation.AllocationSize.QuadPart = FileStdInfo.AllocationSize.QuadPart;
        CreateResponse->StandardInformation.EndOfFile.QuadPart = FileStdInfo.EndOfFile.QuadPart;
    }

    CreateResponse->Handle = FileHandle;
    CreateResponse->UserModeKey = (PVOID)FileHandle;

EXIT_THE_FUNCTION:

    //
    // The function RtlDosPathNameToNtPathName_U allocates memory from the
    // processes heap. If we did, we need to free it now.
    //
    if (UnicodeFileName.Buffer != NULL) {
        RtlFreeHeap(RtlProcessHeap(), 0, UnicodeFileName.Buffer);
    }

    //
    // Impersonate back again, so that we are in the context of
    // the user who issued this request.
    //
    if (!didImpersonate) {
        ULONG LocalStatus;
        LocalStatus = UMReflectorImpersonate(UserWorkItem, DavWorkItem->ImpersonationHandle);
        if (LocalStatus != ERROR_SUCCESS) {
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncCreateGet/UMReflectorImpersonate. "
                      "Error Val = %d\n", LocalStatus));

            if (WStatus == ERROR_SUCCESS) {
                WStatus = LocalStatus;
            }
        }
        didImpersonate = TRUE;
    }

    return WStatus;
}


VOID
DavAsyncCreateCompletion(
    PDAV_USERMODE_WORKITEM DavWorkItem
    )
/*++

Routine Description:

   This routine handles the Create completion. It basically frees up the
   resources allocated during the Create operation.

Arguments:

    DavWorkItem - The DAV_USERMODE_WORKITEM value.

Return Value:

    none.

--*/
{

    PDAV_USERMODE_CREATE_RESPONSE CreateResponse;
    
    CreateResponse = &(DavWorkItem->CreateResponse);
    
    if (DavWorkItem->AsyncCreate.RemPathName != NULL) {
        HLOCAL FreeHandle;
        ULONG FreeStatus;
        FreeHandle = LocalFree((HLOCAL)DavWorkItem->AsyncCreate.RemPathName);
        if (FreeHandle != NULL) {
            FreeStatus = GetLastError();
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncCreateCompletion/LocalFree(1). Error Val = %d\n",
                      FreeStatus));
        }
    }

    if (DavWorkItem->AsyncCreate.UrlBuffer != NULL) {
        HLOCAL FreeHandle;
        ULONG FreeStatus;
        FreeHandle = LocalFree((HLOCAL)DavWorkItem->AsyncCreate.UrlBuffer);
        if (FreeHandle != NULL) {
            FreeStatus = GetLastError();
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncCreateCompletion/LocalFree(2). Error Val = %d\n",
                      FreeStatus));
        }
    } 

    if (DavWorkItem->AsyncCreate.DataBuff != NULL) {
        HLOCAL FreeHandle;
        ULONG FreeStatus;
        FreeHandle = LocalFree((HLOCAL)DavWorkItem->AsyncCreate.DataBuff);
        if (FreeHandle != NULL) {
            FreeStatus = GetLastError();
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncCreateCompletion/LocalFree(3). Error Val = %d\n",
                      FreeStatus));
        }
    }

    if (DavWorkItem->AsyncCreate.didRead != NULL) {
        HLOCAL FreeHandle;
        ULONG FreeStatus;
        FreeHandle = LocalFree((HLOCAL)DavWorkItem->AsyncCreate.didRead);
        if (FreeHandle != NULL) {
            FreeStatus = GetLastError();
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncCreateCompletion/LocalFree(4). Error Val = %d\n",
                      FreeStatus));
        }
    }

    if (DavWorkItem->AsyncCreate.FileName != NULL) {
        HLOCAL FreeHandle;
        ULONG FreeStatus;
        FreeHandle = LocalFree((HLOCAL)DavWorkItem->AsyncCreate.FileName);
        if (FreeHandle != NULL) {
            FreeStatus = GetLastError();
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncCreateCompletion/LocalFree(5). Error Val = %d\n",
                      FreeStatus));
        }
    }

    if (DavWorkItem->AsyncCreate.FileHandle != NULL) {
        BOOL ReturnVal;
        ULONG CloseStatus;
        ReturnVal = CloseHandle(DavWorkItem->AsyncCreate.FileHandle);
        if (!ReturnVal) {
            CloseStatus = GetLastError();
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncCreateCompletion/CloseHandle. "
                      "Error Val = %d\n", CloseStatus));
        }
    }

    if (DavWorkItem->AsyncCreate.DavOpenHandle != NULL) {
        BOOL ReturnVal;
        ULONG FreeStatus;
        ReturnVal = InternetCloseHandle( DavWorkItem->AsyncCreate.DavOpenHandle );
        if (!ReturnVal) {
            FreeStatus = GetLastError();
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncCreateCompletion/InternetCloseHandle. "
                      "Error Val = %d\n", FreeStatus));
        }
    }

    if (DavWorkItem->AsyncCreate.lpCEI != NULL) {
        HLOCAL FreeHandle;
        ULONG FreeStatus;
        FreeHandle = LocalFree((HLOCAL)DavWorkItem->AsyncCreate.lpCEI);
        if (FreeHandle != NULL) {
            FreeStatus = GetLastError();
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncCreateCompletion/LocalFree(6). Error Val = %d\n",
                      FreeStatus));
        }
        DavWorkItem->AsyncCreate.lpCEI = NULL;
    } 

    if (DavWorkItem->AsyncResult != NULL) {
        HLOCAL FreeHandle;
        ULONG FreeStatus;
        FreeHandle = LocalFree((HLOCAL)DavWorkItem->AsyncResult);
        if (FreeHandle != NULL) {
            FreeStatus = GetLastError();
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncCreateCompletion/LocalFree(7). Error Val = %d\n",
                      FreeStatus));
        }
    }

    //
    // If we did not succeed, but landed up creating a handle to the local file,
    // we need to close that now.
    //
    if (DavWorkItem->Status != ERROR_SUCCESS) {
        if (CreateResponse->Handle != NULL) {
            NtClose(CreateResponse->Handle);
            CreateResponse->Handle = NULL;
            CreateResponse->UserModeKey = NULL;
        }
    }

    //
    // The callback context should not be finalized if we are returning
    // ERROR_IO_PENDING.
    //
    DavFsFinalizeTheDavCallBackContext(DavWorkItem);

    //
    // We are done with the per user entry, so finalize it.
    //
    if (DavWorkItem->AsyncCreate.PerUserEntry) {
        DavFinalizePerUserEntry( &(DavWorkItem->AsyncCreate.PerUserEntry) );
    }

    return;
}


BOOL
DavIsThisFileEncrypted(
    PVOID DataBuff
    )
/*++

Routine Description:

   This routine checks the buffer supplied to see if it matches the first few
   bytes of a BackedUp encrypted file.

Arguments:

    DataBuff - The buffer to be checked.

Return Value:

    TRUE - DataBuff matches the first few bytes of a BackedUp encrypted file.

    FALSE - It does not.

--*/
{
    if ( SIG_EFS_FILE   != DavCheckSignature((char *)DataBuff + sizeof(ULONG)) ||

         SIG_EFS_STREAM != DavCheckSignature((char *)DataBuff +
                                             sizeof(EFSEXP_FILE_HEADER) +
                                             sizeof(ULONG))                    ||

         SIG_EFS_DATA   != DavCheckSignature((char *)DataBuff +
                                             sizeof(EFSEXP_FILE_HEADER) +
                                             sizeof(EFSEXP_STREAM_HEADER) +
                                             sizeof(USHORT) +
                                             sizeof(ULONG))                    ||

         EFS_STREAM_ID  != *((USHORT *)((char *)DataBuff +
                                        sizeof(EFSEXP_FILE_HEADER) +
                                        sizeof(EFSEXP_STREAM_HEADER)))         ||

         EFS_EXP_FORMAT_CURRENT_VERSION != ((PEFSEXP_FILE_HEADER)DataBuff)->VersionID ) {

        //
        // Signature does not match.
        //
        return FALSE;

    } else {

        return TRUE;

    }
}


ULONG
DavCheckSignature(
    PVOID Signature
    )
/*++

Routine Description:

    This routine returns the signature type.

Arguments:

    Signature - Signature string.

Return Value:

    The type of signature. SIG_NO_MATCH for bogus signature.

--*/
{

    if ( !memcmp( Signature, FILE_SIGNATURE, SIG_LENGTH ) ) {

        return SIG_EFS_FILE;

    }

    if ( !memcmp( Signature, STREAM_SIGNATURE, SIG_LENGTH ) ) {

        return SIG_EFS_STREAM;

    }

    if ( !memcmp( Signature, DATA_SIGNATURE, SIG_LENGTH ) ) {

        return SIG_EFS_DATA;

    }

    return SIG_NO_MATCH;
}


DWORD
DavRestoreEncryptedFile(
    PWCHAR ExportFile,
    PWCHAR ImportFile
    )
/*++

Routine Description:

    This function performs the restoration of encrypted files. In other words
    the import operation of the exported file by calling the appropriate EFS
    APIs.

Arguments:

    ExportFile - The File containing the backup.

    ImportFile - The File with the restored data.

Return Value:

    Returned value of the EFS APIs.

--*/
{
    DWORD WStatus = ERROR_SUCCESS;
    HANDLE RawImport = INVALID_HANDLE_VALUE;
    PVOID RawContext = NULL;

    DavPrint((DEBUG_MISC,
              "DavRestoreEncryptedFile: ExportFile = %ws, ImportFile = %ws\n",
              ExportFile, ImportFile));

    RawImport = CreateFileW(ExportFile,
                            (GENERIC_WRITE | GENERIC_READ),
                            0, // Exclusive access.
                            NULL,
                            OPEN_EXISTING,
                            FILE_ATTRIBUTE_ARCHIVE,
                            NULL);
    if (RawImport == INVALID_HANDLE_VALUE) {
        WStatus = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavRestoreEncryptedFile/CreateFileW. Error Val = %d %ws\n",
                  WStatus,ExportFile));
        goto EXIT_THE_FUNCTION;
    }

    //
    // Open a raw context to the file.
    //
    WStatus = OpenEncryptedFileRawW(ImportFile, CREATE_FOR_IMPORT, &(RawContext));
    if (WStatus != ERROR_SUCCESS) {
        DavPrint((DEBUG_ERRORS,
                  "DavRestoreEncryptedFile/OpenEncryptedFileRaw. Error Val = %d %ws\n",
                  WStatus,ImportFile));
        goto EXIT_THE_FUNCTION;
    }

    WStatus = WriteEncryptedFileRaw((PFE_IMPORT_FUNC)DavWriteRawCallback,
                                    (PVOID)RawImport,
                                    RawContext);

    if (WStatus == RPC_X_PIPE_DISCIPLINE_ERROR) {
        WStatus = ERROR_ACCESS_DENIED;
    }

    if (WStatus != ERROR_SUCCESS) {
        DavPrint((DEBUG_ERRORS,
                  "DavRestoreEncryptedFile/WriteEncryptedFileRaw. Error Val = %d %ws\n",
                  WStatus,ImportFile));
    }

EXIT_THE_FUNCTION:

    if (RawImport != INVALID_HANDLE_VALUE) {
        CloseHandle(RawImport);
    }

    if (RawContext) {
        CloseEncryptedFileRaw(RawContext);
    }

    return WStatus;
}


DWORD
DavWriteRawCallback(
    PBYTE DataBuff,
    PVOID CallbackContext,
    PULONG DataLength
    )
/*++

Routine Description:

    Call-back function for WriteEncryptedFileRaw() called in Restore(). This
    function reads the backed up data from the backup file, and provides it to
    WriteEncryptedFileRaw() through this callback function which in turn
    transforms the raw data back to its original form. This call-back function
    is called until all the data content has been read.

Arguments:

    DataBuffer - Data to be read.

    CallbackContext - Handle to the Backup file.

    DataLength - Size of the DataBuffer.

Return Value:

    Returned value of the operation.

--*/
{
    DWORD WStatus = ERROR_SUCCESS;
    BOOL ReturnVal;
    DWORD BytesRead = 0;

    DavPrint((DEBUG_MISC, "DavWriteRawCallback: DataLength = %d\n", *DataLength));

    //
    // Restore the file's content with the information stored in the temporary
    // location.
    //

    ReturnVal = ReadFile((HANDLE)CallbackContext,
                         DataBuff,
                         *DataLength,
                         &(BytesRead),
                         NULL);
    if ( !ReturnVal ) {
        WStatus = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavWriteRawCallback/ReadFile. Error Val = %d\n", WStatus));
    }

    DavPrint((DEBUG_MISC, "DavWriteRawCallback: BytesRead = %d\n", BytesRead));

    *DataLength = BytesRead;

    return WStatus;
}


DWORD
DavReuseCacheFileIfNotModified(
    IN PDAV_USERMODE_WORKITEM pDavWorkItem
    )
/*++

Routine Description:

    If we get an NOT-MODIFIED response, then we just get the filename from wininet and use it

Arguments:

    pDavWorkItem - The buffer that contains the request parameters and options.

Return Value:

    ERROR_SUCCESS or the appropriate error code.

--*/
{
    DWORD dwError = ERROR_SUCCESS;
    PWCHAR pFileNameBuff = NULL;
    DWORD dwBufferSize = 0, dwStatus = 0;
    LPINTERNET_CACHE_ENTRY_INFOW lpCEI = NULL;

    lpCEI = (LPINTERNET_CACHE_ENTRY_INFOW)pDavWorkItem->AsyncCreate.lpCEI;

    if (!pDavWorkItem->AsyncCreate.lpCEI) {
        return ERROR_FILE_NOT_FOUND;        
    }

    dwBufferSize = sizeof(dwStatus);

    if (!HttpQueryInfoW(pDavWorkItem->AsyncCreate.DavOpenHandle, 
                        (HTTP_QUERY_STATUS_CODE | HTTP_QUERY_FLAG_NUMBER),
                        (LPVOID)&dwStatus,
                        &dwBufferSize,
                        NULL)) {
        return GetLastError();
    }

    if (dwStatus == HTTP_STATUS_NOT_MODIFIED) {
        pFileNameBuff = LocalAlloc(LPTR, (lstrlen(lpCEI->lpszLocalFileName) + 1) * sizeof(WCHAR));
        if (pFileNameBuff) {
            dwError = ERROR_SUCCESS;
            pDavWorkItem->AsyncCreate.FileName = pFileNameBuff;
            if (!InternetCloseHandle(pDavWorkItem->AsyncCreate.DavOpenHandle)) {
                dwError = GetLastError();
                LocalFree(pFileNameBuff);
                pFileNameBuff = NULL;
                pDavWorkItem->AsyncCreate.FileName = NULL;
            } else {
                pDavWorkItem->AsyncCreate.DavOpenHandle = NULL;
                wcscpy(pDavWorkItem->CreateResponse.FileName, lpCEI->lpszLocalFileName);
                wcscpy(pDavWorkItem->AsyncCreate.FileName, lpCEI->lpszLocalFileName);
            }
            goto EXIT_THE_FUNCTION;
        }
    } else {
        dwError = ERROR_FILE_NOT_FOUND;
    }

EXIT_THE_FUNCTION:

    return dwError;
}


DWORD
DavCreateUrlCacheEntry(
    IN PDAV_USERMODE_WORKITEM pDavWorkItem
    )
/*++

Routine Description:

    This routine creates an entry for a file in the WinInet's cache.

Arguments:

    pDavWorkItem - The buffer that contains the request parameters and options.

Return Value:

    ERROR_SUCCESS or the appropriate error code.

--*/
{
    DWORD  dwError = ERROR_SUCCESS;
    PWCHAR pFileExt = NULL;
    PWCHAR pFileNameBuff = NULL;
    BOOL ReturnVal = FALSE;

    //
    // Get the file extension. For now we assume that the extension follows the
    // last '.' char. We do a ++ after the call to wcsrchr to go past the '.'.
    // If '.' itself is the last char, the extension is NULL.
    //
    if ( *(pDavWorkItem->AsyncCreate.RemPathName) ) {
        pFileExt = ( pDavWorkItem->AsyncCreate.RemPathName + (wcslen(pDavWorkItem->AsyncCreate.RemPathName) - 1) );
        while (pFileExt != pDavWorkItem->AsyncCreate.RemPathName) {
            if ( *pFileExt == L'.' || *pFileExt == L'/' || *pFileExt == L'\\' ) {
                break;
            }
            pFileExt--;
        }
        if ( pFileExt != pDavWorkItem->AsyncCreate.RemPathName && *pFileExt == L'.' && *(pFileExt + 1) != '\0' ) {
            pFileExt++;
            DavPrint((DEBUG_MISC, "DavCreateUrlCacheEntry. FileExt: %ws\n", pFileExt));
        } else {
            pFileExt = NULL;
            DavPrint((DEBUG_MISC, "DavCreateUrlCacheEntry. No FileExt.\n"));
        }
    } else {
        pFileExt = NULL;
        DavPrint((DEBUG_MISC, "DavCreateUrlCacheEntry. No FileExt.\n"));
    }

    DavPrint((DEBUG_MISC, "DavCreateUrlCacheEntry. pFileExt: %ws\n", pFileExt));

    //
    // Allocate memory for pFileNameBuff.
    //
    pFileNameBuff = LocalAlloc (LMEM_FIXED | LMEM_ZEROINIT, MAX_PATH * sizeof(WCHAR));
    if (pFileNameBuff == NULL) {
        dwError = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavCreateUrlCacheEntry/LocalAlloc. Error Val = %d\n",
                  dwError));
        goto EXIT_THE_FUNCTION;
    }

    //
    // Create a file name for the URL in the cache.
    //
    ReturnVal = CreateUrlCacheEntryW(pDavWorkItem->AsyncCreate.UrlBuffer,
                                     0,
                                     pFileExt,
                                     pFileNameBuff,
                                     0);

    // 
    // The CreateUrlCacheEntry API call may fail with GetLastError() = 
    // ERROR_FILENAME_EXCED_RANGE for long extension names. In such a scenario
    // we make the call again with the file extension set to NULL.
    //
    if (!ReturnVal && pFileExt != NULL) {
        DavPrint((DEBUG_ERRORS,
                  "DavCreateUrlCacheEntry/CreateUrlCacheEntry(1). Error Val = %d\n",
                  GetLastError()));
        //
        // Another attempt to create a file name for the URL in the cache with 
        // no extension name.
        // 
        pFileExt = NULL;
        ReturnVal = CreateUrlCacheEntryW(pDavWorkItem->AsyncCreate.UrlBuffer,
                                         0,
                                         NULL,
                                         pFileNameBuff,
                                         0);
    }

    //
    // If we've failed the both the calls, then we return the failure.
    //
    if (!ReturnVal) {
        dwError = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavCreateUrlCacheEntry/CreateUrlCacheEntry(2). Error Val = %d %ws\n",
                  dwError, pDavWorkItem->AsyncCreate.FileName));
        goto EXIT_THE_FUNCTION;
    }
    
    pDavWorkItem->AsyncCreate.FileName = pFileNameBuff;
    
    DavPrint((DEBUG_MISC, 
              "DavCreateUrlCacheEntry: FileName = %ws\n", 
              pDavWorkItem->AsyncCreate.FileName));
    
    //
    // Copy the file name in the response buffer.
    //
    wcscpy(pDavWorkItem->CreateResponse.FileName, pDavWorkItem->AsyncCreate.FileName);
    
EXIT_THE_FUNCTION:

    //
    // If we did not succeed then we need to free up the memory allocated for 
    // pFileNameBuff (if we did allocate at all).
    //
    if (dwError != ERROR_SUCCESS) {
        if (pFileNameBuff != NULL) {
            LocalFree(pFileNameBuff);
            pDavWorkItem->AsyncCreate.FileName = NULL;
        }
        
    }

    return dwError;
}


WCHAR wszEtagHeader[] = L"ETag: ";
#define CONST_TEN_MINUTES   ((LONGLONG)10 * 60 * 10000000)

DWORD
DavCommitUrlCacheEntry(
    IN PDAV_USERMODE_WORKITEM pDavWorkItem
    )
/*++

Routine Description:

    This routine commits (pins) the entry for a file in the WinInet's cache. 
    This entry would have been created using DavCreateUrlCacheEntry.

Arguments:

    pDavWorkItem - The buffer that contains the request parameters and options.

Return Value:

    ERROR_SUCCESS or the appropriate error code.

--*/
{
    DWORD dwTemp, dwIndex;
    SYSTEMTIME sSystemTime;
    BOOL fRet= FALSE, fHasEtag = FALSE;                
    FILETIME ExTime, LmTime;
    char chEtagBuff[1024];

    dwTemp = sizeof(SYSTEMTIME);
    dwIndex = 0;

    //
    // If the expiry time is available in the OpenHandle, get it.
    //
    if( !HttpQueryInfo(pDavWorkItem->AsyncCreate.DavOpenHandle, 
                       (HTTP_QUERY_EXPIRES | HTTP_QUERY_FLAG_SYSTEMTIME), 
                       &sSystemTime, 
                       &dwTemp, 
                       &dwIndex) 

        ||

        !SystemTimeToFileTime(&sSystemTime, &ExTime) ) {

        SYSTEMTIME sSysT;

        GetSystemTime(&sSysT);

        SystemTimeToFileTime(&sSysT, &ExTime);

        *(LONGLONG *)&ExTime += CONST_TEN_MINUTES;

    }

    dwTemp = sizeof(SYSTEMTIME);
    dwIndex = 0;

    //
    // If the last modified time is available in the OpenHandle, get it.
    //
    if( !HttpQueryInfo(pDavWorkItem->AsyncCreate.DavOpenHandle, 
                       (HTTP_QUERY_LAST_MODIFIED | HTTP_QUERY_FLAG_SYSTEMTIME),
                       &sSystemTime, 
                       &dwTemp, 
                       &dwIndex) 

        ||

        !SystemTimeToFileTime(&sSystemTime, &LmTime) ) {

        LmTime.dwLowDateTime = 0;

        LmTime.dwHighDateTime = 0;

    }

#if 0
    
    dwIndex = 0;
    memcpy(chEtagBuff, wszEtagHeader, sizeof(wszEtagHeader)-2);
    dwTemp = sizeof(chEtagBuff)-(sizeof(wszEtagHeader)-2);
    
    if( HttpQueryInfo(pDavWorkItem->AsyncCreate.DavOpenHandle, 
                      HTTP_QUERY_ETAG, 
                      ( chEtagBuff + sizeof(wszEtagHeader) - 2 ),
                      &dwTemp, 
                      &dwIndex) ) {
        
        fHasEtag = TRUE;
        
        dwTemp += sizeof(wszEtagHeader)-2;
        
        DavPrint((DEBUG_ERRORS,
                  "DavCreateUrlCacheEntry/CreateUrlCacheEntry. Etag %s\n",
                  chEtagBuff));
    
    }

#endif    
    
    //
    // Close the DavOpenHandle. This needs to be done, otherwise the commit
    // below will fail with SHARING_VIOLATON as WinInet has a cached file open.
    //
    fRet = InternetCloseHandle(pDavWorkItem->AsyncCreate.DavOpenHandle);
    if (!fRet) {
        DavPrint((DEBUG_ERRORS,
                  "DavCommitUrlCacheEntry/InternetCloseHandle = %d\n", 
                  GetLastError()));
        goto bailout;
    }

    pDavWorkItem->AsyncCreate.DavOpenHandle = NULL;
    
    fRet = CommitUrlCacheEntryW(pDavWorkItem->AsyncCreate.UrlBuffer,
                                pDavWorkItem->AsyncCreate.FileName,
                                ExTime,
                                LmTime,
                                STICKY_CACHE_ENTRY,
                                (fHasEtag ? ((LPWSTR)chEtagBuff) : NULL), 
                                (fHasEtag ? dwTemp : 0),
                                NULL,
                                NULL);
    if (!fRet) {
        DavPrint((DEBUG_ERRORS,
                  "DavCommitUrlCacheEntry/CommitUrlCacheEntryW = %d\n", 
                  GetLastError()));
    }

bailout:    
    
    if (!fRet) {
        return GetLastError();
    } else {
        return ERROR_SUCCESS;
    }
}


DWORD
DavSetAclForEncryptedFile(
    PWCHAR FilePath
    )
/*++

Routine Description:

    This routine set the ACLs on the file that allows everybody to access it.

Arguments:

    FilePath - The path of the file.

Return Value:

    ERROR_SUCCESS or the appropriate error code.

--*/
{
    DWORD status = NO_ERROR;
    DWORD cb = 0;
    PSECURITY_DESCRIPTOR SecurityDescriptor = NULL;

    //
    // Initialize the Security Descriptor with the ACL allowing everybody to
    // access the file.
    //
    if (!ConvertStringSecurityDescriptorToSecurityDescriptorW(L"D:(A;;GAGRGWGX;;;WD)",
                                                              SDDL_REVISION_1,
                                                              &SecurityDescriptor,
                                                              &cb)) {
        status = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavSetAclForEncryptedFile/ConvertStringSecurityDescriptorToSecurityDescriptorW = %d\n", 
                  status));
        goto EXIT_THE_FUNCTION;
    }

    //
    // Put the DACL onto the file.
    //
    if (!SetFileSecurity(FilePath,
                         DACL_SECURITY_INFORMATION,
                         SecurityDescriptor)) {
        status = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavSetAclForEncryptedFile/SetFileSecurity = %d\n", 
                  status));
    }

EXIT_THE_FUNCTION:

    if (SecurityDescriptor) {
        LocalFree(SecurityDescriptor);
    }

    return status;
}


DWORD
DavQueryUrlCacheEntry(
    IN PDAV_USERMODE_WORKITEM pDavWorkItem
    )
/*++

Routine Description:

    This routine is called to Create a entry in the WinInet cache for the
    given URL.

Arguments:

    pDavWorkItem - The buffer that contains the request parameters and options.

Return Value:

    ERROR_SUCCESS or the appropriate error code.

--*/
{
    DWORD dwError = ERROR_SUCCESS;
    DWORD cbCEI = 0, count = 0;
    LPINTERNET_CACHE_ENTRY_INFOW lpCEI = NULL;

    if (pDavWorkItem->AsyncCreate.lpCEI != NULL) {
        return ERROR_SUCCESS;
    }
    
    cbCEI = ( sizeof(INTERNET_CACHE_ENTRY_INFOW) + (MAX_PATH * 2) );

    do {

        lpCEI = LocalAlloc(LPTR, cbCEI);
        if (!lpCEI) {
            dwError = GetLastError();
            break;
        }

        ++count;

        if ( !GetUrlCacheEntryInfo(pDavWorkItem->AsyncCreate.UrlBuffer, lpCEI, &cbCEI) ) {
            if ((dwError = GetLastError()) == ERROR_INSUFFICIENT_BUFFER) {
                LocalFree(lpCEI);
                lpCEI = NULL;
            } else {
                DavPrint((DEBUG_MISC,
                         "DavQueryUrlCacheEntry/GetUrlCacheEntryInfo: dwError = %d, UrlBuffer = %ws\n",
                          dwError, pDavWorkItem->AsyncCreate.UrlBuffer));
                break;                
            }
        } else {
            dwError = ERROR_SUCCESS;
            break;
        }

    } while (count < 2);    

    if (dwError == ERROR_SUCCESS) {
        pDavWorkItem->AsyncCreate.lpCEI = lpCEI;
    } else {
        //
        // If some error occurred in adding the header, set the correct error
        // code.
        //
        dwError = GetLastError();
        if (lpCEI) {
            LocalFree(lpCEI);
            lpCEI = NULL;
        }
    }

    return dwError;
}


DWORD
DavAddIfModifiedSinceHeader(
    IN PDAV_USERMODE_WORKITEM pDavWorkItem
    )
/*++

Routine Description:

    This routine is called to add the If-Modified-Since header to the request
    being sent to the server.

Arguments:

    pDavWorkItem - The buffer that contains the request parameters and options.

Return Value:

    ERROR_SUCCESS or the appropriate error code.

--*/
{
    DWORD dwError = ERROR_SUCCESS;
    DWORD cbCEI = 0, count = 0;
    LPINTERNET_CACHE_ENTRY_INFOW lpCEI = NULL;
    CHAR chBuff[(sizeof(rgchIMS) + INTERNET_RFC1123_BUFSIZE + 5)];
    SYSTEMTIME systemtime;

    if (pDavWorkItem->AsyncCreate.lpCEI == NULL) {
        DavQueryUrlCacheEntry(pDavWorkItem);
    }

    lpCEI = pDavWorkItem->AsyncCreate.lpCEI;        

    if ((lpCEI != NULL) &&
        ((lpCEI->LastModifiedTime.dwLowDateTime != 0) ||
         (lpCEI->LastModifiedTime.dwHighDateTime != 0)) &&
        FileTimeToSystemTime((CONST FILETIME *)&(lpCEI->LastModifiedTime), &systemtime)) {

        memcpy(chBuff, rgchIMS, (sizeof(rgchIMS) - 1));

        chBuff[((sizeof(rgchIMS)) - 1)]  = ':';

        chBuff[sizeof(rgchIMS)] = ' ';

        if (InternetTimeFromSystemTimeA((CONST SYSTEMTIME *)&systemtime,
                                        INTERNET_RFC1123_FORMAT,
                                        &chBuff[(sizeof(rgchIMS) + 1)],
                                        (sizeof(chBuff) - sizeof(rgchIMS) - 2))) {

            HttpAddRequestHeadersA(pDavWorkItem->AsyncCreate.DavOpenHandle,
                                   chBuff, 
                                   lstrlenA(chBuff),
                                   (HTTP_ADDREQ_FLAG_ADD | HTTP_ADDREQ_FLAG_REPLACE));

        }

    }

    return dwError;
}


DWORD
DavLockTheFileOnTheServer(
    IN PDAV_USERMODE_WORKITEM DavWorkItem
    )
/*++

Routine Description:

    This routine is called during the create when we need to LOCK the file on
    the server. This is done to provide consistency so that users do not
    overwrite each others data.
    
    IMPORTANT!! Its important to note that if we fail to LOCK the file on the
    server because the DAV server doesn't support LOCKs, we do not fail the 
    create call. This is because according to the DAV RFC, a server is not
    required to support LOCKs. So, if the server returns 405 (Method not 
    allowed), this function will return ERROR_SUCCESS back to the caller.

Arguments:

    DavWorkItem - The buffer that contains the request parameters and options.

Return Value:

    ERROR_SUCCESS or the appropriate error code.

--*/
{
    DWORD WStatus = ERROR_SUCCESS;
    HINTERNET DavOpenHandle = NULL;
    BOOL BStatus = FALSE, ReturnVal = FALSE, readDone = FALSE, fileIsLocked = FALSE;
    PWCHAR PassportCookie = NULL;
    PCHAR LockRequestBuffer = NULL, lpTemp = NULL, DataBuff = NULL;
    PCHAR UserNameBuffer = NULL;
    ULONG LockRequestBufferLength = 0, ResponseStatus = 0, UserNameSize = 0;
    DAV_FILE_ATTRIBUTES DavFileAttributes;
    PVOID Ctx1 = NULL, Ctx2 = NULL;
    DWORD NumRead = 0, NumOfFileEntries = 0, TotalDataBytesRead = 0;
    PDAV_USERMODE_CREATE_RESPONSE CreateResponse;

    DavPrint((DEBUG_MISC,
              "DavLockTheFileOnTheServer. Locking File: %ws\n",
              DavWorkItem->AsyncCreate.RemPathName));

    //
    // Get the UserName of the user in whose context this LOCK is being
    // issued. The first GetUserNameExA call is to get the number of chars
    // necessary to hold the UserName. The return value is ERROR_MORE_DATA
    // and not ERROR_INSUFFICIENT_BUFFER if the buffer passed in is not of
    // sufficient length.
    //

    ReturnVal = GetUserNameExA(NameSamCompatible, UserNameBuffer, &UserNameSize);
    if (!ReturnVal) {
        WStatus = GetLastError();
        if (WStatus != ERROR_MORE_DATA) {
            DavPrint((DEBUG_ERRORS,
                      "DavLockTheFileOnTheServer/GetUserNameExA(1). Error Val = %d\n",
                      WStatus));
            goto EXIT_THE_FUNCTION;
        }
    }

    UserNameBuffer = LocalAlloc(LPTR, UserNameSize * sizeof(CHAR));
    if (UserNameBuffer == NULL) {
        WStatus = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavLockTheFileOnTheServer/LocalAlloc. Error Val = %d\n",
                  WStatus));
        goto EXIT_THE_FUNCTION;
    }

    ReturnVal = GetUserNameExA(NameSamCompatible, UserNameBuffer, &UserNameSize);
    if (!ReturnVal) {
        WStatus = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavLockTheFileOnTheServer/GetUserNameExA(2). Error Val = %d\n",
                  WStatus));
        goto EXIT_THE_FUNCTION;
    }

    DavPrint((DEBUG_MISC,
              "DavLockTheFileOnTheServer. UserNameBuffer: %s\n",
              UserNameBuffer));

    //
    // Allocate the buffer big enough to hold the entire XML LOCK request
    // that has to be sent to the server.
    //

    LockRequestBufferLength = strlen(rgLockInfoHeader);
    LockRequestBufferLength += strlen(rgLockInfoTrailer);
    LockRequestBufferLength += strlen(rgLockScopeHeader);
    LockRequestBufferLength += strlen(rgLockTypeHeader);
    LockRequestBufferLength += strlen(rgOwnerHeader);
    LockRequestBufferLength += strlen(rgOwnerTrailer);
    LockRequestBufferLength += strlen(UserNameBuffer);
    LockRequestBufferLength += 1; // for the final \0 char.
    
    LockRequestBufferLength = LockRequestBufferLength * sizeof(CHAR);

    LockRequestBuffer = LocalAlloc(LPTR, LockRequestBufferLength);
    if (LockRequestBuffer == NULL) {
        WStatus = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavLockTheFileOnTheServer/DavHttpOpenRequestW. Error Val = %d\n",
                  WStatus));
        goto EXIT_THE_FUNCTION;
    }

    //
    // Format the XML LOCK request that needs to be sent to the server.
    //

    memset(LockRequestBuffer, 0, sizeof(LockRequestBuffer));

    lpTemp = LockRequestBuffer;

    memcpy(lpTemp, rgLockInfoHeader, (sizeof(rgLockInfoHeader) - 1));

    lpTemp += (sizeof(rgLockInfoHeader) - 1);

    memcpy(lpTemp, rgLockScopeHeader, (sizeof(rgLockScopeHeader) - 1));

    lpTemp += (sizeof(rgLockScopeHeader) - 1);

    memcpy(lpTemp, rgLockTypeHeader, (sizeof(rgLockTypeHeader) - 1));

    lpTemp += (sizeof(rgLockTypeHeader) - 1);

    memcpy(lpTemp, rgOwnerHeader, (sizeof(rgOwnerHeader) - 1));

    lpTemp += (sizeof(rgOwnerHeader) - 1);

    memcpy(lpTemp, UserNameBuffer, (strlen(UserNameBuffer) * sizeof(CHAR)));
    
    lpTemp += (strlen(UserNameBuffer) * sizeof(CHAR));
    
    memcpy(lpTemp, rgOwnerTrailer, (sizeof(rgOwnerTrailer) - 1));

    lpTemp += (sizeof(rgOwnerTrailer) - 1);

    memcpy(lpTemp, rgLockInfoTrailer, (sizeof(rgLockInfoTrailer) - 1));
    
    //
    // Convert the unicode object name to UTF-8 URL format.
    // Space and other white characters will remain untouched - these should
    // be taken care of by wininet calls. 
    // This has to be a W API as the name in CloseRequest is unicode.
    //
    BStatus = DavHttpOpenRequestW(DavWorkItem->AsyncCreate.PerUserEntry->DavConnHandle,
                                  L"LOCK",
                                  DavWorkItem->AsyncCreate.RemPathName,
                                  L"HTTP/1.1",
                                  NULL,
                                  NULL,
                                  INTERNET_FLAG_KEEP_CONNECTION |
                                  INTERNET_FLAG_NO_COOKIES |
                                  INTERNET_FLAG_RELOAD,
                                  0,
                                  L"DavLockTheFileOnTheServer",
                                  &DavOpenHandle);
    if(BStatus == FALSE) {
        WStatus = GetLastError();
        goto EXIT_THE_FUNCTION;
    }
    if (DavOpenHandle == NULL) {
        WStatus = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavLockTheFileOnTheServer/DavHttpOpenRequestW. Error Val = %d\n",
                  WStatus));
        goto EXIT_THE_FUNCTION;
    }

    //
    // We need to add the header "translate:f" to tell IIS that it should 
    // allow the user to excecute this VERB on the specified path which it 
    // would not allow (in some cases) otherwise. Finally, there is a special 
    // flag in the metabase to allow for uploading of "dangerous" content 
    // (anything that can be run on the server). This is the ScriptSourceAccess
    // flag in the UI or the AccessSource flag in the metabase. You will need
    // to set this bit to true as well as correct NT ACLs in order to be able
    // to upload .exes or anything executable. We set this header on all requests
    // that are sent to the server including the LOCK request.
    //
    ReturnVal = HttpAddRequestHeadersA(DavOpenHandle,
                                       "translate: f\n",
                                       -1,
                                       HTTP_ADDREQ_FLAG_ADD |
                                       HTTP_ADDREQ_FLAG_REPLACE);
    if (!ReturnVal) {
        WStatus = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavLockTheFileOnTheServer/HttpAddRequestHeadersA. Error Val = %d\n",
                  WStatus));
        goto EXIT_THE_FUNCTION;
    }

    WStatus = DavAttachPassportCookie(DavWorkItem, DavOpenHandle, &PassportCookie);
    if (WStatus != ERROR_SUCCESS) {
        DavPrint((DEBUG_ERRORS,
                  "DavLockTheFileOnTheServer/DavAttachPassportCookie. Error Val = %d\n",
                  WStatus));
        goto EXIT_THE_FUNCTION;
    }

    WStatus = DavInternetSetOption(DavWorkItem, DavOpenHandle);
    if (WStatus != ERROR_SUCCESS) {
        DavPrint((DEBUG_ERRORS,
                  "DavLockTheFileOnTheServer/DavInternetSetOption. Error Val = %d\n",
                  WStatus));
        goto EXIT_THE_FUNCTION;
    }

    //
    // Request the LOCK on this resource for an hour. We will have to refresh 
    // the LOCK request if we need to keep the LOCK request for more than an
    // hour.
    //
    ReturnVal = HttpAddRequestHeadersA(DavOpenHandle,
                                       "Timeout: Second-3600\n",
                                       -1L,
                                       HTTP_ADDREQ_FLAG_ADD |
                                       HTTP_ADDREQ_FLAG_REPLACE);
    if (!ReturnVal) {
        WStatus = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavLockTheFileOnTheServer/HttpAddRequestHeadersA. Error Val = %d\n",
                  WStatus));
        goto EXIT_THE_FUNCTION;
    }

    ReturnVal = HttpSendRequestA(DavOpenHandle,
                                 rgHttpHeader,
                                 strlen(rgHttpHeader),
                                 (LPVOID)LockRequestBuffer,
                                 strlen(LockRequestBuffer));
    if (!ReturnVal) {
        WStatus = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavLockTheFileOnTheServer/HttpSendRequestA: Error Val = %d\n",
                  WStatus));
        goto EXIT_THE_FUNCTION;
    }

    WStatus = DavQueryAndParseResponseEx(DavOpenHandle, &ResponseStatus);
    if (WStatus != ERROR_SUCCESS) {
        //
        // If the server doesn't support the LOCK operation, we do not fail the
        // create call.
        //
        if (ResponseStatus == HTTP_STATUS_NOT_SUPPORTED) {
            WStatus = ERROR_SUCCESS;
            goto EXIT_THE_FUNCTION;
        } else if (ResponseStatus == DAV_STATUS_LOCKED) {
            //
            // If the return status from the server was 423 (the file is locked
            // by someone else) then we still need to parse the XML response
            // to find out who the owner of the LOCK is. This information is
            // displayed to the user.
            //
            DavPrint((DEBUG_ERRORS,
                      "DavLockTheFileOnTheServer/DavQueryAndParseResponseEx: Error Val = %d\n", 
                      WStatus));
            fileIsLocked = TRUE;
        } else {
            SetLastError(WStatus);
            DavPrint((DEBUG_ERRORS,
                      "DavLockTheFileOnTheServer/DavQueryAndParseResponseEx: Error Val = %d\n", 
                      WStatus));
            goto EXIT_THE_FUNCTION;
        }
    }

    DataBuff = LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, NUM_OF_BYTES_TO_READ);
    if (DataBuff == NULL) {
        WStatus = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavLockTheFileOnTheServer/LocalAlloc(2): WStatus = %08lx\n",
                  WStatus));
        goto EXIT_THE_FUNCTION;
    }

    //
    // Read the response and parse it.
    //
    do {

        ReturnVal = InternetReadFile(DavOpenHandle, 
                                     (LPVOID)DataBuff,
                                     NUM_OF_BYTES_TO_READ,
                                     &(NumRead));
        if (!ReturnVal) {
            WStatus = GetLastError();
            DavPrint((DEBUG_ERRORS,
                      "DavLockTheFileOnTheServer/InternetReadFile: WStatus = "
                      "%08lx\n", WStatus));
            goto EXIT_THE_FUNCTION;
        }
    
        DavPrint((DEBUG_MISC, "DavLockTheFileOnTheServer: NumRead = %d\n", NumRead));
        
        //
        // We reject files whose attributes are greater than a
        // certain size (DavFileAttributesLimitInBytes). This
        // is a parameter that can be set in the registry. This
        // is done to avoid attacks by rogue servers.
        //
        TotalDataBytesRead += NumRead;
        if (TotalDataBytesRead > DavFileAttributesLimitInBytes) {
            WStatus = ERROR_BAD_NET_RESP;
            DavPrint((DEBUG_ERRORS, "DavLockTheFileOnTheServer. LockResponseSize > %d\n", DavFileAttributesLimitInBytes));
            goto EXIT_THE_FUNCTION;
        }

        readDone = (NumRead == 0) ? TRUE : FALSE;

        WStatus = DavPushData(DataBuff, &Ctx1, &Ctx2, NumRead, readDone);
        if (WStatus != ERROR_SUCCESS) {
            DavPrint((DEBUG_ERRORS,
                      "DavLockTheFileOnTheServer/DavPushData. WStatus = %d\n",
                      WStatus));
            goto EXIT_THE_FUNCTION;
        }

        if (readDone) {
            break;
        }

    } while ( TRUE );

    memset(&DavFileAttributes, 0, sizeof(DavFileAttributes));

    InitializeListHead( &(DavFileAttributes.NextEntry) );

    WStatus = DavParseData(&DavFileAttributes, Ctx1, Ctx2, &NumOfFileEntries);
    if (WStatus != ERROR_SUCCESS) {
        DavPrint((DEBUG_ERRORS,
                  "DavLockTheFileOnTheServer/DavParseData. WStatus = %d\n",
                  WStatus));
        DavFinalizeFileAttributesList(&DavFileAttributes, FALSE);
        goto EXIT_THE_FUNCTION;
    }

    CreateResponse = &(DavWorkItem->CreateResponse);

    //
    // Copy the LockOwner value if the file is already LOCKed on the server and
    // this LOCK request failed with 423 OR the OpaqueLockToken and LockTimeout
    // values if the LOCK was successfully taken on this file.
    //
    CreateResponse->FileWasAlreadyLocked = FALSE;
    CreateResponse->LockWasTakenOnThisCreate = FALSE;
    if (fileIsLocked) {
        WStatus = ERROR_LOCK_VIOLATION;
        //
        // If the DavFileAttributes.LockOwner is NULL, it means that the 
        // XML response from the server was bogus. In such a case, we just
        // fail the request with ERROR_LOCK_VIOLATION.
        //
        if (DavFileAttributes.LockOwner) {
            CreateResponse->FileWasAlreadyLocked = TRUE;
            if ( wcslen(DavFileAttributes.LockOwner) <= (256 + 256) ) {
                wcscpy(CreateResponse->LockOwner, DavFileAttributes.LockOwner);
                DavPrint((DEBUG_MISC,
                          "DavLockTheFileOnTheServer: fileIsLocked!! LockOwner = %ws\n",
                          CreateResponse->LockOwner));
            }
        }
    } else {
        CreateResponse->LockWasTakenOnThisCreate = TRUE;
        if ( wcslen(DavFileAttributes.OpaqueLockToken) < MAX_PATH ) {
            wcscpy(CreateResponse->OpaqueLockToken, DavFileAttributes.OpaqueLockToken);
            CreateResponse->LockTimeout = DavFileAttributes.LockTimeout;
            DavPrint((DEBUG_MISC,
                      "DavLockTheFileOnTheServer: OpaqueLockToken = %ws, LockTimeout = %dsec\n",
                      CreateResponse->OpaqueLockToken, CreateResponse->LockTimeout));
        } else {
            WStatus = ERROR_INVALID_PARAMETER;
            DavPrint((DEBUG_ERRORS,
                      "DavLockTheFileOnTheServer: OpaqueLockToken > MAX_PATH. WStatus = %d\n",
                      WStatus));
        }
    }

    DavFinalizeFileAttributesList(&DavFileAttributes, FALSE);

    DavCloseContext(Ctx1, Ctx2);

EXIT_THE_FUNCTION:

    if (DavOpenHandle != NULL) {
        InternetCloseHandle(DavOpenHandle);
        DavOpenHandle = NULL;
    }

    if (PassportCookie) {
        LocalFree(PassportCookie);
        PassportCookie = NULL;
    }

    if (LockRequestBuffer) {
        LocalFree(LockRequestBuffer);
        LockRequestBuffer = NULL;
    }

    if (DataBuff) {
        LocalFree(DataBuff);
        DataBuff = NULL;
    }

    return WStatus;
}


DWORD
DavFsLockRefresh(
    PDAV_USERMODE_WORKITEM DavWorkItem
    )
/*++

Routine Description:

    This routine handles LOCK refresh requests that get reflected from the
    kernel.

Arguments:

    DavWorkItem - The buffer that contains the request parameters and options.

Return Value:

    The return status for the operation

--*/
{
    ULONG WStatus = ERROR_SUCCESS;
    HINTERNET DavConnHandle = NULL, DavOpenHandle = NULL;
    PDAV_USERMODE_LOCKREFRESH_REQUEST LockRefreshRequest = NULL;
    PDAV_USERMODE_LOCKREFRESH_RESPONSE LockRefreshResponse = NULL;
    BOOL BStatus = FALSE, ReturnVal = FALSE, readDone = FALSE;
    PPER_USER_ENTRY PerUserEntry = NULL;
    PHASH_SERVER_ENTRY ServerHashEntry = NULL;
    PUMRX_USERMODE_WORKITEM_HEADER UserWorkItem = NULL;
    PWCHAR ServerName = NULL, PathName = NULL, CanName = NULL, PassportCookie = NULL;
    DAV_FILE_ATTRIBUTES DavFileAttributes;
    PVOID Ctx1 = NULL, Ctx2 = NULL;
    DWORD NumRead = 0, NumOfFileEntries = 0, TotalDataBytesRead = 0;
    BOOL didImpersonate = FALSE;
    BOOLEAN EnCriSec = FALSE, didITakeAPUEReference = FALSE;
    PCHAR DataBuff = NULL;

    LockRefreshRequest = &(DavWorkItem->LockRefreshRequest);
    LockRefreshResponse = &(DavWorkItem->LockRefreshResponse);

    ServerName = &(LockRefreshRequest->ServerName[1]);

    PathName = &(LockRefreshRequest->PathName[1]);

    //
    // The PathName can contain \ characters. Replace them by / characters.
    //
    CanName = PathName;
    while (*CanName) {
        if (*CanName == L'\\') {
            *CanName = L'/';
        }
        CanName++;
    }

    UserWorkItem = (PUMRX_USERMODE_WORKITEM_HEADER)DavWorkItem;

    //
    // A User Entry for this user must have been created during the create call
    // earlier. The user entry contains the handle used to send an HttpOpen
    // request.
    //

    EnterCriticalSection( &(HashServerEntryTableLock) );
    EnCriSec = TRUE;

    ReturnVal = DavDoesUserEntryExist(ServerName,
                                      LockRefreshRequest->ServerID, 
                                      &(LockRefreshRequest->LogonID),
                                      &PerUserEntry,
                                      &ServerHashEntry);
    
    //
    // If the following request in the kernel get cancelled even before the 
    // corresponding usermode thread gets a chance to execute this code, then
    // it possible that the VNetRoot (hence the PerUserEntry) and SrvCall get
    // finalized before the thread that is handling the create comes here. This
    // could happen if this request was the only one for this share and the
    // server as well. This is why we need to check if the ServerHashEntry and
    // the PerUserEntry are valid before proceeding.
    //
    if (ReturnVal == FALSE || ServerHashEntry == NULL || PerUserEntry == NULL) {
        WStatus = ERROR_CANCELLED;
        DavPrint((DEBUG_ERRORS, "DavFsLockRefresh: (ServerHashEntry == NULL || PerUserEntry == NULL)\n"));
        goto EXIT_THE_FUNCTION;
    }

    DavWorkItem->ServerUserEntry.PerUserEntry = PerUserEntry;

    //
    // Add a reference to the user entry and set didITakeAPUEReference to TRUE.
    //
    PerUserEntry->UserEntryRefCount++;

    didITakeAPUEReference = TRUE;

    //
    // Since a create had succeeded earlier, the entry must be good.
    //
    ASSERT(PerUserEntry->UserEntryState == UserEntryInitialized);
    ASSERT(PerUserEntry->DavConnHandle != NULL);

    //
    // And yes, we obviously have to leave the critical section before
    // returning.
    //
    LeaveCriticalSection( &(HashServerEntryTableLock) );
    EnCriSec = FALSE;

    WStatus = UMReflectorImpersonate(UserWorkItem, DavWorkItem->ImpersonationHandle);
    if (WStatus != ERROR_SUCCESS) {
        DavPrint((DEBUG_ERRORS,
                  "DavFsLockRefresh/UMReflectorImpersonate. Error Val = %d\n",
                  WStatus));
        goto EXIT_THE_FUNCTION;
    }
    didImpersonate = TRUE;

    //
    // Convert the unicode object name to UTF-8 URL format.
    // Space and other white characters will remain untouched - these should
    // be taken care of by wininet calls. 
    // This has to be a W API as the name in CloseRequest is unicode.
    //
    BStatus = DavHttpOpenRequestW(PerUserEntry->DavConnHandle,
                                  L"LOCK",
                                  PathName,
                                  L"HTTP/1.1",
                                  NULL,
                                  NULL,
                                  INTERNET_FLAG_KEEP_CONNECTION |
                                  INTERNET_FLAG_NO_COOKIES |
                                  INTERNET_FLAG_RELOAD,
                                  0,
                                  L"DavFsLockRefresh",
                                  &DavOpenHandle);
    if(BStatus == FALSE) {
        WStatus = GetLastError();
        goto EXIT_THE_FUNCTION;
    }
    if (DavOpenHandle == NULL) {
        WStatus = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavFsLockRefresh/DavHttpOpenRequestW. Error Val = %d\n",
                  WStatus));
        goto EXIT_THE_FUNCTION;
    }

    //
    // We need to add the header "translate:f" to tell IIS that it should 
    // allow the user to excecute this VERB on the specified path which it 
    // would not allow (in some cases) otherwise. Finally, there is a special 
    // flag in the metabase to allow for uploading of "dangerous" content 
    // (anything that can be run on the server). This is the ScriptSourceAccess
    // flag in the UI or the AccessSource flag in the metabase. You will need
    // to set this bit to true as well as correct NT ACLs in order to be able
    // to upload .exes or anything executable. We set this header on all requests
    // that are sent to the server including the LOCK request.
    //
    ReturnVal = HttpAddRequestHeadersW(DavOpenHandle,
                                       L"translate: f\n",
                                       -1,
                                       HTTP_ADDREQ_FLAG_ADD |
                                       HTTP_ADDREQ_FLAG_REPLACE);
    if (!ReturnVal) {
        WStatus = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavFsLockRefresh/HttpAddRequestHeadersW. Error Val = %d\n",
                  WStatus));
        goto EXIT_THE_FUNCTION;
    }

    WStatus = DavAttachPassportCookie(DavWorkItem, DavOpenHandle, &PassportCookie);
    if (WStatus != ERROR_SUCCESS) {
        DavPrint((DEBUG_ERRORS,
                  "DavFsLockRefresh/DavAttachPassportCookie. Error Val = %d\n",
                  WStatus));
        goto EXIT_THE_FUNCTION;
    }

    WStatus = DavInternetSetOption(DavWorkItem, DavOpenHandle);
    if (WStatus != ERROR_SUCCESS) {
        DavPrint((DEBUG_ERRORS,
                  "DavFsLockRefresh/DavInternetSetOption. Error Val = %d\n",
                  WStatus));
        goto EXIT_THE_FUNCTION;
    }

    //
    // Request the LOCK on this resource for an hour. We will have to refresh 
    // the LOCK request if we need to keep the LOCK request for more than an
    // hour.
    //
    ReturnVal = HttpAddRequestHeadersW(DavOpenHandle,
                                       L"Timeout: Second-3600\n",
                                       -1L,
                                       HTTP_ADDREQ_FLAG_ADD |
                                       HTTP_ADDREQ_FLAG_REPLACE);
    if (!ReturnVal) {
        WStatus = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavFsLockRefresh/HttpAddRequestHeadersW. Error Val = %d\n",
                  WStatus));
        goto EXIT_THE_FUNCTION;
    }

    ASSERT(LockRefreshRequest->OpaqueLockToken != NULL);

    ReturnVal = HttpAddRequestHeadersW(DavOpenHandle,
                                       LockRefreshRequest->OpaqueLockToken,
                                       -1L,
                                       HTTP_ADDREQ_FLAG_ADD |
                                       HTTP_ADDREQ_FLAG_REPLACE );
    if (!ReturnVal) {
        WStatus = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavFsLockRefresh/HttpAddRequestHeadersW. Error Val = %d\n",
                  WStatus));
        goto EXIT_THE_FUNCTION;
    }

RESEND_THE_REQUEST:

    ReturnVal = HttpSendRequestExW(DavOpenHandle, 
                                   NULL, 
                                   NULL, 
                                   HSR_SYNC,
                                   (ULONG_PTR)0);
   if (!ReturnVal) {
       WStatus = GetLastError();
       DavPrint((DEBUG_ERRORS,
                 "DavFsLockRefresh/HttpSendRequestExW. Error Val = %d\n", 
                 WStatus));
       goto EXIT_THE_FUNCTION;
   }

   ReturnVal = HttpEndRequestW(DavOpenHandle, 
                               NULL, 
                               HSR_SYNC,
                               (ULONG_PTR)0);
   if (!ReturnVal) {
       WStatus = GetLastError();
       //
       // If the error we got back is ERROR_INTERNET_FORCE_RETRY, then WinInet
       // is trying to authenticate itself with the server. If we get back
       // ERROR_HTTP_REDIRECT_NEEDS_CONFIRMATION, WinInet is expecting us to
       // confirm that the redirect needs to be followed. In these scenarios,
       // we need to repeat the HttpSend and HttpEnd request calls.
       //
       if (WStatus == ERROR_INTERNET_FORCE_RETRY || WStatus == ERROR_HTTP_REDIRECT_NEEDS_CONFIRMATION) {
           goto RESEND_THE_REQUEST;
       }
       DavPrint((DEBUG_ERRORS,
                 "DavFsLockRefresh/HttpEndRequestW. Error Val = %d\n", 
                 WStatus));
       goto EXIT_THE_FUNCTION;
   }

   WStatus = DavQueryAndParseResponse(DavOpenHandle);
   if (WStatus != ERROR_SUCCESS) {
       DavPrint((DEBUG_ERRORS,
                 "DavFsLockRefresh/DavQueryAndParseResponse. WStatus = %d\n",
                 WStatus));
   }

   DataBuff = LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, NUM_OF_BYTES_TO_READ);
   if (DataBuff == NULL) {
       WStatus = GetLastError();
       DavPrint((DEBUG_ERRORS,
                 "DavFsLockRefresh/LocalAlloc: WStatus = %08lx\n",
                 WStatus));
       goto EXIT_THE_FUNCTION;
   }

   //
   // Read the response and parse it.
   //
   do {

       ReturnVal = InternetReadFile(DavOpenHandle, 
                                    (LPVOID)DataBuff,
                                    NUM_OF_BYTES_TO_READ,
                                    &(NumRead));
       if (!ReturnVal) {
           WStatus = GetLastError();
           DavPrint((DEBUG_ERRORS,
                     "DavFsLockRefresh/InternetReadFile: WStatus = %08lx\n",
                     WStatus));
           goto EXIT_THE_FUNCTION;
       }

       DavPrint((DEBUG_MISC, "DavFsLockRefresh: NumRead = %d\n", NumRead));

       //
       // We reject files whose attributes are greater than a certain size
       // (DavFileAttributesLimitInBytes). This is a parameter that can be
       // set in the registry. This is done to avoid attacks by rogue servers.
       //
       TotalDataBytesRead += NumRead;
       if (TotalDataBytesRead > DavFileAttributesLimitInBytes) {
           WStatus = ERROR_BAD_NET_RESP;
           DavPrint((DEBUG_ERRORS, "DavFsLockRefresh. LockResponseSize > %d\n", DavFileAttributesLimitInBytes));
           goto EXIT_THE_FUNCTION;
       }

       readDone = (NumRead == 0) ? TRUE : FALSE;

       WStatus = DavPushData(DataBuff, &Ctx1, &Ctx2, NumRead, readDone);
       if (WStatus != ERROR_SUCCESS) {
           DavPrint((DEBUG_ERRORS,
                     "DavFsLockRefresh/DavPushData. WStatus = %d\n",
                     WStatus));
           goto EXIT_THE_FUNCTION;
       }

       if (readDone) {
           break;
       }

   } while ( TRUE );
   
   memset(&DavFileAttributes, 0, sizeof(DavFileAttributes));

   InitializeListHead( &(DavFileAttributes.NextEntry) );

   WStatus = DavParseData(&DavFileAttributes, Ctx1, Ctx2, &NumOfFileEntries);
   if (WStatus != ERROR_SUCCESS) {
       DavPrint((DEBUG_ERRORS,
                 "DavFsLockRefresh/DavParseData. WStatus = %d\n",
                 WStatus));
       DavFinalizeFileAttributesList(&DavFileAttributes, FALSE);
       goto EXIT_THE_FUNCTION;
   }

   //
   // Get the NewTimeoutValue returned by the server.
   //
   LockRefreshResponse->NewTimeOutInSec = DavFileAttributes.LockTimeout;
   
   DavFinalizeFileAttributesList(&DavFileAttributes, FALSE);

   DavCloseContext(Ctx1, Ctx2);

EXIT_THE_FUNCTION:

    if (DavOpenHandle != NULL) {
        InternetCloseHandle(DavOpenHandle);
        DavOpenHandle = NULL;
    }

    //
    // If didITakeAPUEReference is TRUE we need to remove the reference we 
    // took on the PerUserEntry.
    //
    if (didITakeAPUEReference) {
        DavFinalizePerUserEntry( &(DavWorkItem->ServerUserEntry.PerUserEntry) );
    }

    if (PassportCookie) {
        LocalFree(PassportCookie);
        PassportCookie = NULL;
    }

    if (DataBuff) {
        LocalFree(DataBuff);
        DataBuff = NULL;
    }

    //
    // If this thread impersonated a user, we need to revert back.
    //
    if (didImpersonate) {
        RevertToSelf();
        didImpersonate = FALSE;
    }

    return WStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\kernel\webdav.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    webdav.h

Abstract:

    This module defines the data structures and functions related to the
    WebDav protocol.

Author:

    Rohan Kumar [rohank] 17-Mar-1999

Revision History:

--*/

#ifndef _WEBDAV_H
#define _WEBDAV_H

#ifdef RX_PRIVATE_BUILD
#undef IoGetTopLevelIrp
#undef IoSetTopLevelIrp
#endif

//
// The miniredir dipatch vector used by RDBSS.
//
extern struct _MINIRDR_DISPATCH  MRxDAVDispatch;

//
// A serialization mutex used for various things.
//
extern FAST_MUTEX MRxDAVSerializationMutex;

//
// A pointer to the process that the RDBSS posts to. This is a non disappearing
// process!
//
extern PEPROCESS MRxDAVSystemProcess;

//
// The DavWinInetCachePath which is used in satisfying volume related queries.
//
extern WCHAR DavWinInetCachePath[MAX_PATH];

//
// The ProcessId of the svchost.exe process that loads the webclnt.dll.
//
extern ULONG DavSvcHostProcessId;

//
// The exchange device name will be stored in this KEY_VALUE_PARTIAL_INFORMATION
// structure.
//
extern PBYTE DavExchangeDeviceName;

//
// Name cache stuff. These values are read from the registry during init time.
//
extern ULONG FileInformationCacheLifeTimeInSec;
extern ULONG FileNotFoundCacheLifeTimeInSec;
extern ULONG NameCacheMaxEntries;

//
// The timeout values for various operations used by the MiniRedir. If an
// operation is not completed within the timeout value specified for it, is
// cancelled. The user can set the value to 0xffffffff to disable the
// timeout/cancel logic. In other words, if the timeout value is 0xffffffff,
// the requests will never timeout.
//
extern ULONG CreateRequestTimeoutValueInSec;
extern ULONG CreateVNetRootRequestTimeoutValueInSec;
extern ULONG QueryDirectoryRequestTimeoutValueInSec;
extern ULONG CloseRequestTimeoutValueInSec;
extern ULONG CreateSrvCallRequestTimeoutValueInSec;
extern ULONG FinalizeSrvCallRequestTimeoutValueInSec;
extern ULONG FinalizeFobxRequestTimeoutValueInSec;
extern ULONG FinalizeVNetRootRequestTimeoutValueInSec;
extern ULONG ReNameRequestTimeoutValueInSec;
extern ULONG SetFileInfoRequestTimeoutValueInSec;
extern ULONG QueryFileInfoRequestTimeoutValueInSec;
extern ULONG QueryVolumeInfoRequestTimeoutValueInSec;
extern ULONG LockRefreshRequestTimeoutValueInSec;

//
// The timer thread wakes up every "TimerThreadSleepTimeInSec" and cancels all
// the requests which haven't completed in their specified timeout value. This
// value is set to the min of the timeout values of all the requests mentioned
// above.
//
extern ULONG TimerThreadSleepTimeInSec;

//
// The timer object used by the timer thread that cancels the requests which
// have not completed in a specified time.
//
extern KTIMER DavTimerObject;

//
// This is used to indicate the timer thread to shutdown. When the system is
// being shutdown this is set to TRUE. MRxDAVTimerThreadLock is the resource
// used to gain access to this variable.
//
extern BOOL TimerThreadShutDown;
extern ERESOURCE MRxDAVTimerThreadLock;

//
// The handle of the timer thread that is created using PsCreateSystemThread
// is stored this global.
//
extern HANDLE TimerThreadHandle;

//
// This event is signalled by the timer thread right before its going to
// terminate itself.
//
extern KEVENT TimerThreadEvent;

//
// If QueueLockRefreshWorkItem is TRUE, the TimerThread (which cancels all the
// AsyncEngineContexts that haven't completed in a specified time) queues a 
// WorkItem to refresh the locks. After the WorkItem has been queued the value 
// of QueueLockRefreshWorkItem is set to FALSE. Once the worker thread is 
// done refreshing all the locks, it resets this value to TRUE. We have a
// corresponding lock QueueLockRefreshWorkItemLock to synchronize access to
// QueueLockRefreshWorkItem.
//
extern BOOL QueueLockRefreshWorkItem;
extern ERESOURCE QueueLockRefreshWorkItemLock;

//
// The WorkQueueItem used in the MRxDAVContextTimerThread function to refresh
// the LOCKs taken by this client.
//
extern RX_WORK_QUEUE_ITEM LockRefreshWorkQueueItem;

#define DAV_MJ_READ  0
#define DAV_MJ_WRITE 1

//
// Pool tags used by the reflector library. All the DAV MiniRedir pool tags 
// have "DV" as the first two characters.
//
#define DAV_SRVCALL_POOLTAG   ('cSVD')
#define DAV_NETROOT_POOLTAG   ('tNVD')
#define DAV_FILEINFO_POOLTAG  ('iFVD')
#define DAV_FILENAME_POOLTAG  ('nFVD')
#define DAV_EXCHANGE_POOLTAG  ('xEVD')
#define DAV_READWRITE_POOLTAG ('wRVD')
#define DAV_QUERYDIR_POOLTAG  ('dQVD')
#define DAV_SRVOPEN_POOLTAG   ('oSVD')
#define DAV_LOCKTOKENENTRY_POOLTAG ('tLVD')
#define DAV_LOCKCONFLICTENTRY_POOLTAG ('cLVD')

//
// Use the DavDbgTrace macro for logging Mini-Redir stuff in the kernel 
// debugger.
//
#if DBG
extern ULONG MRxDavDebugVector;
#define DAV_TRACE_ERROR      0x00000001
#define DAV_TRACE_DEBUG      0x00000002
#define DAV_TRACE_CONTEXT    0x00000004
#define DAV_TRACE_DETAIL     0x00000008
#define DAV_TRACE_ENTRYEXIT  0x00000010
#define DAV_TRACE_QUERYDIR   0x00000020
#define DAV_TRACE_OPENCLOSE  0x00000040
#define DAV_TRACE_READ       0x00000080
#define DAV_TRACE_WRITE      0x00000100
#define DAV_TRACE_SRVCALL    0x00000200
#define DAV_TRACE_FCBFOBX    0x00000400
#define DAV_TRACE_DAVNETROOT 0x00000800
#define DAV_TRACE_INFOCACHE  0x00001000
#define DAV_TRACE_ALL        0xffffffff
#define DavDbgTrace(_x_, _y_) {          \
        if (_x_ & MRxDavDebugVector) {   \
            DbgPrint _y_;                \
        }                                \
}
#else
#define DavDbgTrace(_x_, _y_)
#endif

//
// The initialization states of the miniredir.
//
typedef enum _WEBDAV_INIT_STATES {
    MRxDAVINIT_START,
    MRxDAVINIT_MINIRDR_REGISTERED
} WEBDAV_INIT_STATES;

//
// These are used by the entry point routines to specify what entrypoint was
// called. This facilitates common continuation routines.
//
typedef enum _WEBDAV_MINIRDR_ENTRYPOINTS {
    DAV_MINIRDR_ENTRY_FROM_CREATE = 0,
    DAV_MINIRDR_ENTRY_FROM_CLEANUPFOBX,
    DAV_MINIRDR_ENTRY_FROM_CREATESRVCALL,
    DAV_MINIRDR_ENTRY_FROM_CREATEVNETROOT,
    DAV_MINIRDR_ENTRY_FROM_FINALIZESRVCALL,
    DAV_MINIRDR_ENTRY_FROM_FINALIZEVNETROOT,
    DAV_MINIRDR_ENTRY_FROM_CLOSESRVOPEN,
    DAV_MINIRDR_ENTRY_FROM_RENAME,
    DAV_MINIRDR_ENTRY_FROM_READ,
    DAV_MINIRDR_ENTRY_FROM_WRITE,
    DAV_MINIRDR_ENTRY_FROM_QUERYDIR,
    DAV_MINIRDR_ENTRY_FROM_SETFILEINFORMATION,
    DAV_MINIRDR_ENTRY_FROM_QUERYFILEINFORMATION,
    DAV_MINIRDR_ENTRY_FROM_QUERYVOLUMEINFORMATION,
    DAV_MINIRDR_ENTRY_FROM_REFRESHTHELOCK,
    DAV_MINIRDR_ENTRY_FROM_MAXIMUM
} WEBDAV_MINIRDR_ENTRYPOINTS;

//
// The states of the I/O operation(s).
//
typedef enum _WEBDAV_INNERIO_STATE {
    MRxDAVInnerIoStates_Initial = 0,
    MRxDAVInnerIoStates_ReadyToSend,
    MRxDAVInnerIoStates_OperationOutstanding
} WEBDAV_INNERIO_STATE;

//
// The WebDav context structure that encapsulates the AsyncEngineCtx structure
// and has the miniredir specific fields.
//
typedef struct _WEBDAV_CONTEXT {

    //
    // The AsyncEngineCtx Structure used by the Reflector library.
    //
    union {
        UMRX_ASYNCENGINE_CONTEXT;
        UMRX_ASYNCENGINE_CONTEXT AsyncEngineContext;
    };

    //
    // This is used by the entry point routines to specify what entrypoint was
    // called. This facilitates common continuation routines.
    //
    WEBDAV_MINIRDR_ENTRYPOINTS EntryPoint;

    //
    // These describe the inner state of the I/O operation. These states are
    // described in the MRxDAV_INNERIO_STATE data structure.
    //
    UCHAR  OpSpecificState;

    //
    // Pointer to the information strucutre for the Create request.
    //
    PDAV_USERMODE_CREATE_RETURNED_FILEINFO CreateReturnedFileInfo;

    //
    // This is used in the Continuation functions for the read, write and
    // querydir calls. It keeps track of the number of times the Continuation
    // routine has been called.
    //
    ULONG ContinueEntryCount;

} WEBDAV_CONTEXT, *PWEBDAV_CONTEXT;

//
// While creating the AsyncEngineContext, the extra space needed for the
// miniredir specific fields is also allocated. Thus, one doesn't need to
// allocate twice.
//
#define SIZEOF_DAV_SPECIFIC_CONTEXT \
                    sizeof(WEBDAV_CONTEXT) - sizeof(UMRX_ASYNCENGINE_CONTEXT)

//
// The WebDav device object structure that encapsulates the UMRX_DEVICE_OBJECT
// structure and has the miniredir specific fields.
//
typedef struct _WEBDAV_DEVICE_OBJECT {

    //
    // The UMRX_DEVICE_OBJECT structure.
    //
    union {
        UMRX_DEVICE_OBJECT;
        UMRX_DEVICE_OBJECT UMRefDeviceObject;
    };

    //
    // TRUE => miniredir has been started.
    //
    BOOLEAN IsStarted;

    //
    // The FCB of the device object.
    //
    PVOID CachedRxDeviceFcb;

    //
    // The process registering this device object.
    //
    PEPROCESS RegisteringProcess;

} WEBDAV_DEVICE_OBJECT, *PWEBDAV_DEVICE_OBJECT;

//
// The Dav device object.
//
extern PWEBDAV_DEVICE_OBJECT MRxDAVDeviceObject;

//
// The extra number of bytes needed for the device object. This info is used
// when the device object gets created.
//
#define WEBDAV_DEVICE_OBJECT_EXTENSION_SIZE \
                   (sizeof(WEBDAV_DEVICE_OBJECT) - sizeof(RDBSS_DEVICE_OBJECT))


//
// For every LOCK that is taken for a file, the following entry is created and
// added to the global LockTokenEntryList.
//
typedef struct _WEBDAV_LOCK_TOKEN_ENTRY {

    LIST_ENTRY listEntry;

    //
    // The LockToken that was returned by the server on a successful LOCK 
    // request.
    //
    PWCHAR OpaqueLockToken;

    //
    // The server on which the file is shared.
    //
    PWCHAR ServerName;

    //
    // The path of the file on the server.
    //
    PWCHAR PathName;

    //
    // The ServerHashTable ServerId of this server.
    //
    ULONG ServerID;

    //
    // The LogonId of this user.
    //
    LUID LogonID;

    //
    // If this is set to FALSE, this LockEntry is not refreshed.
    //
    BOOL ShouldThisEntryBeRefreshed;

    //
    // The SecurityClientContext of the client in whose context the LOCK was
    // taken. This is needed to impersonate the client when refreshing the
    // LOCK.
    //
    PSECURITY_CLIENT_CONTEXT SecurityClientContext;

    //
    // The timeout value of the LOCK taken on the server. If the client wants
    // to hold the LOCK beyond this timeout then it needs to refresh the LOCK
    // before the timeout expires.
    //
    ULONG LockTimeOutValueInSec;

    //
    // The system tick count when this LOCK entry was created. This value is
    // used in sending out LOCK refresh requests.
    //
    LARGE_INTEGER CreationTimeInTickCount;

} WEBDAV_LOCK_TOKEN_ENTRY, *PWEBDAV_LOCK_TOKEN_ENTRY;

//
// The global list of all the active LOCK tokens (one for every LOCK taken) and
// the resource that is used to synchronize access to it.
//
extern LIST_ENTRY LockTokenEntryList;
extern ERESOURCE LockTokenEntryListLock;

#define WEBDAV_LOCKCONFLICTENTRY_LIFETIMEINSEC 10

//
// For every LOCK request that fails, we create an entry below and add it to
// the global LockConflictEntryList.
//
typedef struct _WEBDAV_LOCK_CONFLICT_ENTRY {

    LIST_ENTRY listEntry;

    //
    // The complete path name of the file that has already been locked on the
    // server.
    //
    PWCHAR CompletePathName;

    //
    // The owner of the LOCK on the file as returned by the server.
    //
    PWCHAR LockOwner;

    //
    // The system tick count when this entry was created. This entry is kept
    // alive for WEBDAV_LOCKCONFLICTENTRY_LIFETIMEINSEC seconds.
    //
    LARGE_INTEGER CreationTimeInTickCount;

} WEBDAV_LOCK_CONFLICT_ENTRY, *PWEBDAV_LOCK_CONFLICT_ENTRY;

//
// The global list of all the LOCK conflict entries and the resource that is
// used to synchronize access to it.
//
extern LIST_ENTRY LockConflictEntryList;
extern ERESOURCE LockConflictEntryListLock;

//
// The WEBDAV specific FOBX structure.
//
typedef struct _WEBDAV_FOBX {

    //
    // The pointer to the DavFileAttribute list for this directory. This list
    // is created on the first call to Enumerate files in the directory.
    //
    PDAV_FILE_ATTRIBUTES DavFileAttributes;

    //
    // Number of DavFileAttribute entries.
    //
    ULONG NumOfFileEntries;

    //
    // The index of the next file to be returned to the user. The file index 
    // starts from zero, hence file index = 0 => the first file entry etc.
    //
    ULONG CurrentFileIndex;

    //
    // Pointer to the next entry.
    //
    PLIST_ENTRY listEntry;

} WEBDAV_FOBX, *PWEBDAV_FOBX;

//
// A pointer to an instance of WEBDAV_SRV_OPEN is stored in the context field
// of MRX_SRV_OPEN strucutre.
//
#define MRxDAVGetFobxExtension(pFobx)  \
        (((pFobx) == NULL) ? NULL : (PWEBDAV_FOBX)((pFobx)->Context))

//
// The WEBDAV specific SRV_OPEN structure.
//
typedef struct _WEBDAV_SRV_OPEN {

    //
    // The file handle associated with this SrvOpen.
    //
    HANDLE UnderlyingHandle;

    //
    // This also is the handle got from the usermode. Its used for debugging
    // purposes.
    //
    PVOID UserModeKey;

    //
    // Pointer to the file object associated with the handle. This is set
    // after the handle is successfully created in the usermode.
    //
    PFILE_OBJECT UnderlyingFileObject;

    //
    // Pointer to the device object represented by the file object mentioned
    // above.
    //
    PDEVICE_OBJECT UnderlyingDeviceObject;

    //
    // This indicates whether we need to call IoRaiseInformationalHardError
    // when the close fails. We need to do this if the PUT or DELETE failed and
    // the operation which the user expects has succeeded actually failed.
    //
    BOOL RaiseHardErrorIfCloseFails;

    //
    // Created In Kernel.
    //
    BOOL createdInKernel;

    //
    // The OpaqueLockToken returned by the server if the file was LOCKed on
    // Create. This token has to be sent with every request that modifies the
    // data or the properties of this file.
    //
    PWCHAR OpaqueLockToken;

    //
    // The LockTokenEntry created for the OpaqueLockToken above.
    //
    PWEBDAV_LOCK_TOKEN_ENTRY LockTokenEntry;

} WEBDAV_SRV_OPEN, *PWEBDAV_SRV_OPEN;

//
// A pointer to an instance of WEBDAV_SRV_OPEN is stored in the context field
// of MRX_SRV_OPEN strucutre.
//
#define MRxDAVGetSrvOpenExtension(pSrvOpen)  \
        (((pSrvOpen) == NULL) ? NULL : (PWEBDAV_SRV_OPEN)((pSrvOpen)->Context))
        
//
// The WEBDAV specific FCB structure.
//
typedef struct _WEBDAV_FCB {

    //
    // Is this FCB for a directory ?
    //
    BOOL isDirectory;

    //
    // Does the File exist in the WinInet cache ??
    //
    BOOL isFileCached;
    
    //
    // Should this file be deleted on Close ?
    //
    BOOL DeleteOnClose;

    //
    // Was this file written to ?
    //
    ULONG FileWasModified;

    //
    // Did we reset the FileWasModified in the DavFcb to FALSE? If we did and
    // the PUT failed, we need to reset the FileWasModified field in the FCB to
    // TRUE.
    //
    BOOL FileModifiedBitReset;

    //
    // If we happen to LOCK the file on the server on Create we set this to
    // TRUE. On CloseSrvOpen we check if this value is TRUE. If it is and the
    // file has been modified, we only go to the usermode to do the PUT, DELETE,
    // PROPPATCH etc, if the SrvOpen contains the OpaqueLockToken. If it does 
    // not then any request that modifies the file is going to fail with a
    // 423.
    //
    BOOL FileIsLockedOnTheServer;

    //
    // On Close, if the file has been modified, we PROPPATCH the time values
    // as well. We take the current time as the value of the "Last Modified Time"
    // (LMT). If the SetFileInformation of the LMT happens after the file has
    // been modifed, then we should use what ever LMT is already in the FCB as
    // the LMT. For example,
    // Create, Write, Close - Use the CurrentTime in close as the LMT.
    // Create, Write, SetFileInfo(LMT), Close - Use the LMT in the FCB.
    //
    BOOL DoNotTakeTheCurrentTimeAsLMT;

    //
    // This resource is used to synchronize the "Read-Modify-Write" routine
    // in the Write path of the DAV Redir. This is because when we get non-cached
    // writes to the MiniRedir which do not extend the VaildDataLength, RDBSS,
    // acquires the FCB resource shared. This means that multiple threads could
    // be writing data to the local file (in the DAV Redir case) in which case
    // they can overwrite each others changes since we do Read-Modify-Write.
    // Hence we need to protect this code using a resource which we acqiure
    // in an exclusive fashion when we do these writes. We allocate memory for 
    // this resource and initialize it the first time we need to acquire the
    // lock. If allocated and initialized, it will be uninitialized and 
    // deallocated when the FCB is being deallocated.
    //
    PERESOURCE DavReadModifyWriteLock;

    //
    // We store the file name information on create. This is used if the delayed
    // write failed to pop up the dialogue box and write an eventlog entry.
    //
    UNICODE_STRING FileNameInfo;
    BOOL FileNameInfoAllocated;

    //
    // Changes in directory entry.
    //
    BOOLEAN fCreationTimeChanged;

    BOOLEAN fLastAccessTimeChanged;

    BOOLEAN fLastModifiedTimeChanged;    

    BOOLEAN fFileAttributesChanged;

    //
    // Was this file renamed ?
    //
    BOOL FileWasRenamed;

    BOOL LocalFileIsEncrypted;

    SECURITY_CLIENT_CONTEXT SecurityClientContext;

    //
    // If the file gets renamed, the new name is copied into this buffer.
    //
    WCHAR NewFileName[MAX_PATH];

    //
    // Length of the new file name.
    //
    ULONG NewFileNameLength;

    //
    // The file name of the local file that represents the file on the DAV
    // server which has been created.
    //
    WCHAR FileName[MAX_PATH];
    WCHAR Url[MAX_PATH * 2];

} WEBDAV_FCB, *PWEBDAV_FCB;

//
// A pointer to an instance of WEBDAV_FCB is stored in the context field
// of MRX_FCB strucutre.
//
#define MRxDAVGetFcbExtension(pFcb)  \
        (((pFcb) == NULL) ? NULL : (PWEBDAV_FCB)((pFcb)->Context))
        
//
// The WEBDAV specific V_NET_ROOT structure.
//
typedef struct _WEBDAV_V_NET_ROOT {

    //
    // The client's security context. This is set during the create call.
    //
    SECURITY_CLIENT_CONTEXT SecurityClientContext;

    //
    // Is set to true after the above context is set. This is used to avoid 
    // initialization of the SecurityContext.
    //
    BOOLEAN SCAlreadyInitialized;

    //
    // Has the LogonID of this V_NET_ROOT been set ?
    //
    BOOL LogonIDSet;

    //
    // The LogonID for this session.
    //
    LUID LogonID;

    //
    // Is this an Office Web Server share?
    //
    BOOL isOfficeShare;
    
    //
    // Is this a TAHOE share?
    //
    BOOL isTahoeShare;
    
    //
    // Is PROPATCH method allowed?
    //
    BOOL fAllowsProppatch;

    //
    // Was this VNetRoot "NOT" created successfully in the usermode? We keep this 
    // info because when a finalize VNetRoot request comes, we need to know 
    // whether need to go upto the usermode to finalize the PerUserEntry. If the
    // create failed then this BOOL is set to TRUE. If this is TRUE, then we 
    // don't go to the usermode to finalize the PerUserEntry.
    //
    BOOL createVNetRootUnSuccessful;
    

    // does he report available space?
        
    BOOL fReportsAvailableSpace;

} WEBDAV_V_NET_ROOT, *PWEBDAV_V_NET_ROOT;

//
// The WEBDAV specific V_NET_ROOT structure.
//
typedef struct _WEBDAV_NET_ROOT {
    ULONG                    RefCount;
    PMRX_NET_ROOT            pRdbssNetRoot;           // The Rdbss NetRoot it belongs to
    NAME_CACHE_CONTROL       NameCacheCtlGFABasic;    // The basic file information name cache control.
    NAME_CACHE_CONTROL       NameCacheCtlGFAStandard; // The standard file information name cache control.
    NAME_CACHE_CONTROL       NameCacheCtlFNF;         // The File not found name cache control.
} WEBDAV_NET_ROOT, *PWEBDAV_NET_ROOT;

//
// A pointer to an instance of WEBDAV_V_NET_ROOT is stored in the context field
// of MRX_V_NET_ROOT strucutre.
//
#define MRxDAVGetVNetRootExtension(pVNetRoot)      \
    (((pVNetRoot) == NULL) ? NULL : (PWEBDAV_V_NET_ROOT)((pVNetRoot)->Context))

//
// The WEBDAV specific V_NET_ROOT structure.
//
typedef struct _WEBDAV_SRV_CALL {

    //
    // The Unique ServerID.
    //
    ULONG ServerID;

    //
    // Is set to true after the above context is set. Used to check whether we
    // need to delete the SecurityClientContext when we are completing the
    // request.
    //
    BOOLEAN SCAlreadyInitialized;

} WEBDAV_SRV_CALL, *PWEBDAV_SRV_CALL;

//
// A pointer to an instance of WEBDAV_SRV_CALL is stored in the context field
// of MRX_SRV_CALL strucutre.
//
#define MRxDAVGetSrvCallExtension(pSrvCall)      \
    (((pSrvCall) == NULL) ? NULL : (PWEBDAV_SRV_CALL)((pSrvCall)->Context))

//
// Get the Security client context associated with this request.
//
#define MRxDAVGetSecurityClientContext() {                                     \
    if (RxContext != NULL && RxContext->pRelevantSrvOpen != NULL) {            \
        if (RxContext->pRelevantSrvOpen->pVNetRoot != NULL) {                  \
            if (RxContext->pRelevantSrvOpen->pVNetRoot->Context != NULL) {     \
                DavVNetRoot = (PWEBDAV_V_NET_ROOT)                             \
                              RxContext->pRelevantSrvOpen->pVNetRoot->Context; \
                SecurityClientContext = &(DavVNetRoot->SecurityClientContext); \
            }                                                                  \
        }                                                                      \
    }                                                                          \
}

//
// We turn away async operations that are not wait by posting. If we can wait
// then we turn off the sync flag so that things will just act synchronous.
//
#define TURN_BACK_ASYNCHRONOUS_OPERATIONS() {                              \
    if (FlagOn(RxContext->Flags, RX_CONTEXT_FLAG_ASYNC_OPERATION)) {       \
        if (FlagOn(RxContext->Flags, RX_CONTEXT_FLAG_WAIT)) {              \
            ClearFlag(RxContext->Flags, RX_CONTEXT_FLAG_ASYNC_OPERATION)   \
        } else {                                                           \
            RxContext->PostRequest = TRUE;                                 \
            return STATUS_PENDING;                                         \
        }                                                                  \
    }                                                                      \
}

//
// Global locking variables and macros.
//
extern RX_SPIN_LOCK   MRxDAVGlobalSpinLock;
extern KIRQL          MRxDAVGlobalSpinLockSavedIrql;
extern BOOLEAN        MRxDAVGlobalSpinLockAcquired;

#define MRxDAVAcquireGlobalSpinLock() \
        KeAcquireSpinLock(&MRxDAVGlobalSpinLock,&MRxDAVGlobalSpinLockSavedIrql); \
        MRxDAVGlobalSpinLockAcquired = TRUE

#define MRxDAVReleaseGlobalSpinLock()   \
        MRxDAVGlobalSpinLockAcquired = FALSE;  \
        KeReleaseSpinLock(&MRxDAVGlobalSpinLock,MRxDAVGlobalSpinLockSavedIrql)

#define MRxDAVGlobalSpinLockAcquired()   \
        (MRxDAVGlobalSpinLockAcquired == TRUE)

//
// The IrpCompletionContext structure that is used in the read/write operations.
// All we need is an event on which we will wait till the underlying file system
// completes the request. This event gets signalled in the Completion routine
// that we specify.
//
typedef struct _WEBDAV_READ_WRITE_IRP_COMPLETION_CONTEXT {

    //
    // The event which is signalled in the Completion routine that is passed
    // to IoCallDriver in the read and write requests.
    //
    KEVENT DavReadWriteEvent;

} WEBDAV_READ_WRITE_IRP_COMPLETION_CONTEXT, *PWEBDAV_READ_WRITE_IRP_COMPLETION_CONTEXT;

//
// The prototypes of functions defined for various I/O requests by the DAV
// miniredir are mentioned below.
//

//
// Create/Open/Cleanup/Close Request function prototypes.
//
NTSTATUS
MRxDAVCreate(
    IN PRX_CONTEXT RxContext
    );

NTSTATUS
MRxDAVCleanupFobx (
    IN OUT PRX_CONTEXT RxContext
    );

NTSTATUS
MRxDAVCloseSrvOpen (
    IN OUT PRX_CONTEXT RxContext
    );

NTSTATUS
MRxDAVCollapseOpen (
    IN OUT PRX_CONTEXT RxContext
    );

NTSTATUS
MRxDAVComputeNewBufferingState(
    IN OUT PMRX_SRV_OPEN pSrvOpen,
    IN PVOID pMRxContext,
    OUT ULONG *pNewBufferingState
    );

NTSTATUS
MRxDAVForcedClose (
    IN OUT PMRX_SRV_OPEN SrvOpen
    );

NTSTATUS
MRxDAVShouldTryToCollapseThisOpen (
    IN PRX_CONTEXT RxContext
    );

NTSTATUS
MRxDAVTruncate (
    IN OUT PRX_CONTEXT RxContext
    );

VOID
MRxDAVSetLoud(
    IN PBYTE Msg,
    IN PRX_CONTEXT RxContext,
    IN PUNICODE_STRING s
    );

NTSTATUS
MRxDAVFlush (
    IN OUT PRX_CONTEXT RxContext
    );

//
// Read prototypes.
//
NTSTATUS
MRxDAVRead (
    IN OUT PRX_CONTEXT RxContext
    );

//
// Write prototypes.
//
NTSTATUS
MRxDAVWrite(
    IN PRX_CONTEXT RxContext
    );

ULONG
MRxDAVExtendForCache(
    IN OUT PRX_CONTEXT RxContext,
    IN OUT PLARGE_INTEGER NewFileSize,
    OUT PLARGE_INTEGER NewAllocationSize
    );

ULONG
MRxDAVExtendForNonCache(
    IN OUT PRX_CONTEXT RxContext,
    IN OUT PLARGE_INTEGER NewFileSize,
    OUT PLARGE_INTEGER NewAllocationSize
    );


//
// SrvCall function prototypes.
//
NTSTATUS
MRxDAVCreateSrvCall(
    PMRX_SRV_CALL pSrvCall,
    PMRX_SRVCALL_CALLBACK_CONTEXT pCallbackContext
    );

NTSTATUS
MRxDAVFinalizeSrvCall(
    PMRX_SRV_CALL pSrvCall,
    BOOLEAN Force
    );

NTSTATUS
MRxDAVSrvCallWinnerNotify(
    IN PMRX_SRV_CALL  pSrvCall,
    IN BOOLEAN ThisMinirdrIsTheWinner,
    IN OUT PVOID pSrvCallContext
    );

//
// NetRoot/VNetRoot function prototypes.
//
NTSTATUS
MRxDAVUpdateNetRootState(
    IN OUT PMRX_NET_ROOT pNetRoot
    );

NTSTATUS
MRxDAVCreateVNetRoot(
    IN PMRX_CREATENETROOT_CONTEXT pCreateNetRootContext
    );

NTSTATUS
MRxDAVFinalizeVNetRoot(
    IN PMRX_V_NET_ROOT pVNetRoot,
    IN PBOOLEAN ForceDisconnect
    );

NTSTATUS
MRxDAVFinalizeNetRoot(
    IN PMRX_NET_ROOT pNetRoot,
    IN PBOOLEAN ForceDisconnect
    );

VOID
MRxDAVExtractNetRootName(
    IN PUNICODE_STRING FilePathName,
    IN PMRX_SRV_CALL SrvCall,
    OUT PUNICODE_STRING NetRootName,
    OUT PUNICODE_STRING RestOfName OPTIONAL
    );

//
// Query Directory prototypes.
//
NTSTATUS
MRxDAVQueryDirectory(
    IN PRX_CONTEXT RxContext
    );

//
// Query volume.
//
NTSTATUS
MRxDAVQueryVolumeInformation(
    IN PRX_CONTEXT RxContext
    );

//
// File Information.
//
NTSTATUS
MRxDAVQueryFileInformation(
    IN PRX_CONTEXT RxContext
    );

NTSTATUS
MRxDAVSetFileInformation(
    IN PRX_CONTEXT RxContext
    );

//
// DevFcb prototypes.
//
NTSTATUS
MRxDAVDevFcbXXXControlFile (
    IN OUT PRX_CONTEXT RxContext
    );

NTSTATUS
MRxDAVStart (
    IN OUT struct _RX_CONTEXT * RxContext,
    IN OUT PRDBSS_DEVICE_OBJECT RxDeviceObject
    );

NTSTATUS
MRxDAVStop (
    IN OUT struct _RX_CONTEXT * RxContext,
    IN OUT PRDBSS_DEVICE_OBJECT RxDeviceObject
    );

BOOLEAN
MRxDAVFastIoDeviceControl (
    IN struct _FILE_OBJECT *FileObject,
    IN BOOLEAN Wait,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN ULONG IoControlCode,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

BOOLEAN
MRxDAVFastIoRead(
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
MRxDAVFastIoWrite(
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

//
// Other Misc prototypes.
//
NTSTATUS
MRxDAVSyncXxxInformation(
    IN OUT PRX_CONTEXT RxContext,
    IN UCHAR MajorFunction,
    IN PFILE_OBJECT FileObject,
    IN ULONG InformationClass,
    IN ULONG Length,
    OUT PVOID Information,
    OUT PULONG_PTR ReturnedLength OPTIONAL
    );

NTSTATUS
MRxDAVDeallocateForFcb (
    IN OUT PMRX_FCB pFcb
    );

NTSTATUS
MRxDAVDeallocateForFobx (
    IN OUT PMRX_FOBX pFobx
    );

//
// The prototype of the routine that formats the DAV specific portion of the 
// context.
//
NTSTATUS
MRxDAVFormatTheDAVContext(
    PUMRX_ASYNCENGINE_CONTEXT AsyncEngineContext,
    USHORT EntryPoint
    );

NTSTATUS
DavXxxInformation(
    IN const int xMajorFunction,
    IN PFILE_OBJECT FileObject,
    IN ULONG InformationClass,
    IN ULONG Length,
    OUT PVOID Information,
    OUT PULONG ReturnedLength
    );

ULONG
DavReadWriteFileEx(
    IN USHORT Operation,
    IN BOOL NonPagedBuffer,
    IN BOOL UseOriginalIrpsMDL,
    IN PMDL OriginalIrpsMdl,
    IN PDEVICE_OBJECT DeviceObject,
    IN PFILE_OBJECT FileObject,
    IN ULONGLONG FileOffset,
    IN OUT PVOID DataBuffer,
    IN ULONG SizeInBytes,
    OUT PIO_STATUS_BLOCK IoStatusBlock
    );

NTSTATUS
DavReadWriteIrpCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP CalldownIrp,
    IN PVOID Context
    );

NTSTATUS
MRxDAVProbeForReadWrite(
    IN PBYTE BufferToBeValidated,
    IN DWORD BufferSize,
    IN BOOL doProbeForRead,
    IN BOOL doProbeForWrite
    );

NTSTATUS
MRxDAVFsCtl(
    IN OUT PRX_CONTEXT RxContext
    );

NTSTATUS
MRxDAVIsValidDirectory(
    IN OUT PRX_CONTEXT RxContext,
    IN PUNICODE_STRING DirectoryName
    );

NTSTATUS
MRxDAVCancelRoutine(
    PRX_CONTEXT RxContext
    );

VOID
MRxDAVTimeOutTheContexts(
    BOOL WindDownAllContexts
    );

VOID
MRxDAVContextTimerThread(
    PVOID DummyContext
    );

NTSTATUS
MRxDAVQueryEaInformation (
    IN OUT PRX_CONTEXT RxContext
    );
    
NTSTATUS
MRxDAVSetEaInformation (
    IN OUT PRX_CONTEXT RxContext
    );
    
NTSTATUS
MRxDAVGetFullParentDirectoryPath(
    PRX_CONTEXT RxContext,
    PUNICODE_STRING ParentDirName
    );

NTSTATUS
MRxDAVGetFullDirectoryPath(
    PRX_CONTEXT RxContext,
    PUNICODE_STRING FileName,
    PUNICODE_STRING DirName
    );

NTSTATUS
MRxDAVCreateEncryptedDirectoryKey(
    PUNICODE_STRING DirName
    );

NTSTATUS
MRxDAVRemoveEncryptedDirectoryKey(
    PUNICODE_STRING DirName
    );

NTSTATUS
MRxDAVQueryEncryptedDirectoryKey(
    PUNICODE_STRING DirName
    );

VOID
MRxDAVCleanUpTheLockConflictList(
    BOOL CleanUpAllEntries
    );

#endif //_WEBDAV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\server\davclose.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    davclose.c
    
Abstract:

    This module implements the user mode DAV MiniRedir routines pertaining to 
    closing of files.

Author:

    Rohan Kumar      [RohanK]      02-June-1999

Revision History:

--*/

#include "pch.h"
#pragma hdrstop

#include "ntumrefl.h"
#include "usrmddav.h"
#include "global.h"
#include "nodefac.h"
#include "UniUtf.h"

CHAR rgXmlHeader[] = "Content-Type: text/xml; charset=\"utf-8\"";
CHAR rgPropPatchHeader[] = "<?xml version=\"1.0\" encoding=\"utf-8\" ?><D:propertyupdate xmlns:D=\"DAV:\" xmlns:Z=\"urn:schemas-microsoft-com:\"><D:set><D:prop>";
CHAR rgPropPatchTrailer[] = "</D:prop></D:set></D:propertyupdate>";
CHAR rgCreationTimeTagHeader[] = "<Z:Win32CreationTime>";
CHAR rgCreationTimeTagTrailer[] = "</Z:Win32CreationTime>";
CHAR rgLastAccessTimeTagHeader[] = "<Z:Win32LastAccessTime>";
CHAR rgLastAccessTimeTagTrailer[] = "</Z:Win32LastAccessTime>";
CHAR rgLastModifiedTimeTagHeader[] = "<Z:Win32LastModifiedTime>";
CHAR rgLastModifiedTimeTagTrailer[] = "</Z:Win32LastModifiedTime>";
CHAR rgFileAttributesTagHeader[] = "<Z:Win32FileAttributes>";
CHAR rgFileAttributesTagTrailer[] = "</Z:Win32FileAttributes>";
CHAR rgDummyAttributes[] = "<Z:Dummy>0</Z:Dummy>";

#define MAX_DWORD 0xffffffff

//
// These two functions are used in saving an encrypted file on the server.
//

DWORD
DavReadRawCallback(
    PBYTE DataBuffer,
    PVOID CallbackContext,
    ULONG DataLength
    );


BOOL
DavConvertTimeToXml(
    IN PCHAR lpTagHeader,
    IN DWORD dwHeaderSize,
    IN PCHAR lpTagTrailer,
    IN DWORD dwTrailerSize,
    IN LARGE_INTEGER *lpTime,
    OUT PCHAR *lplpBuffer,
    IN OUT DWORD *lpdwBufferSize    
    );

DWORD
DavSetProperties(
    PDAV_USERMODE_WORKITEM DavWorkItem,
    HINTERNET hDavConnect,
    LPWSTR lpPathName,
    LPSTR lpPropertiesBuffer
    );

DWORD
DavTestProppatch(
    PDAV_USERMODE_WORKITEM DavWorkItem,
    HINTERNET hDavConnect,
    LPWSTR lpPathName
    );

extern DWORD
DavSetAclForEncryptedFile(
    PWCHAR FilePath
    );

//
// Implementation of functions begins here.
//

ULONG
DavFsClose(
    PDAV_USERMODE_WORKITEM DavWorkItem
    )
/*++

Routine Description:

    This routine handles DAV close request that get reflected from the kernel.

Arguments:

    DavWorkItem - The buffer that contains the request parameters and options.

Return Value:

    The return status for the operation

--*/
{
    ULONG WStatus = ERROR_SUCCESS;
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PWCHAR ServerName = NULL, DirectoryPath = NULL, CanName = NULL;
    PWCHAR OpenVerb = NULL;
    ULONG_PTR CallBackContext = (ULONG_PTR)0;
    BOOL EnCriSec = FALSE, ReturnVal, CallBackContextInitialized = FALSE, fSetDirectoryEntry = FALSE;
    PDAV_USERMODE_CLOSE_REQUEST CloseRequest = &(DavWorkItem->CloseRequest);
    ULONG ServerID;
    PPER_USER_ENTRY PerUserEntry = NULL;
    PHASH_SERVER_ENTRY ServerHashEntry = NULL;
    HINTERNET DavConnHandle = NULL, DavOpenHandle = NULL;
    PBYTE DataBuff = NULL;
    LARGE_INTEGER FileSize, ByteOffset;
    BY_HANDLE_FILE_INFORMATION FileInfo; 
    IO_STATUS_BLOCK IoStatusBlock;
    HANDLE FileHandle = NULL;
    UNICODE_STRING UnicodeFileName;
    OBJECT_ATTRIBUTES ObjectAttributes;
    static UINT UniqueTempId = 1;
    BOOL didImpersonate = FALSE;
    PUMRX_USERMODE_WORKITEM_HEADER UserWorkItem = NULL;
    BOOL BStatus = FALSE;

    DavPrint((DEBUG_MISC, "DavFsClose: FileName = %ws.\n", CloseRequest->FileName));
    DavPrint((DEBUG_MISC, "DavFsClose: Modified = %d.\n", CloseRequest->FileWasModified));

    UnicodeFileName.Buffer = NULL;
    UnicodeFileName.Length = 0;
    UnicodeFileName.MaximumLength = 0;
    
    //
    // If any of the time values have changed, then we need to PROPPATCH the 
    // information back to the server.
    //
    if  ( !CloseRequest->DeleteOnClose &&
          ( CloseRequest->fCreationTimeChanged     || 
            CloseRequest->fLastAccessTimeChanged   ||         
            CloseRequest->fLastModifiedTimeChanged || 
            CloseRequest->fFileAttributesChanged ) ) {
        fSetDirectoryEntry = TRUE;
    }

    DavPrint((DEBUG_MISC, "DavFsClose: fSetDirectoryEntry = %x \n", fSetDirectoryEntry));
    
    if ( CloseRequest->isDirectory    &&
         !CloseRequest->DeleteOnClose && 
         !fSetDirectoryEntry ) {
        //
        // If this is a directory close, then the only reason to contact the
        // server is when we are deleting the directory and all the files 
        // under it. If not, we can return right now.
        //
        WStatus = ERROR_SUCCESS;
        goto EXIT_THE_FUNCTION;
    }
    
    if ( !CloseRequest->isDirectory  ) {

        //
        // We need to close the handle only if it was created in the user mode.
        //
        if ( !CloseRequest->createdInKernel && CloseRequest->Handle ) {

            DavPrint((DEBUG_MISC, "DavFsClose: OpenHandle = %08lx.\n", CloseRequest->Handle));
        
            //
            // Close the handle that was opened during the Create call.
            //
            ASSERT((CloseRequest->UserModeKey) == ((PVOID)CloseRequest->Handle));

            ReturnVal = CloseHandle(CloseRequest->Handle);
            if (!ReturnVal) {
                WStatus = GetLastError();
                DavPrint((DEBUG_ERRORS,
                          "DavFsClose/CloseHandle: Return Val = %08lx.\n", WStatus));
            } else {
                CloseRequest->UserModeKey = NULL;
                CloseRequest->Handle = INVALID_HANDLE_VALUE;
            }

        }

        //
        //    DeleteOnClose    FileCreatedLocally    FileModified     Action
        //    -------------    ------------------    ------------     -------
        //         0                   0                  0           NOTHING
        //         0                   0                  1             PUT
        //         0                   1                  0             PUT
        //         0                   1                  1             PUT
        //         1                   0                  0            DELETE
        //         1                   0                  1            DELETE
        //         1                   1                  0           NOTHING 
        //         1                   1                  1           NOTHING
        //
        // The FileCreatedLocally no longer matters since we PUT the file
        // immediately as soon as we create a local copy to claim the name on
        // the server.
        //

        //
        // If this file doesn't have to be deleted, was not created locally and 
        // was not written to, or direntry not modified, or the file was not
        // LOCKed, then we are done.
        //
        if ( !(CloseRequest->DeleteOnClose)   &&
             !(CloseRequest->FileWasModified) &&
             !(fSetDirectoryEntry)            &&
             !(CloseRequest->OpaqueLockToken) ) {
            goto EXIT_THE_FUNCTION;
        }

    }

    //
    // In all other cases (or combinations of the above three booleans), we 
    // need to go to the server. So, before we procced to decide what to do
    // on the server with this file, we need to set up the parameters for the
    // WinInet calls.
    //

    //
    // The first character is a '\' which has to be stripped.
    //
    ServerName = &(CloseRequest->ServerName[1]);
    if (!ServerName) {
        DavPrint((DEBUG_ERRORS, "DavFsClose: ServerName is NULL.\n"));
        WStatus = ERROR_INVALID_PARAMETER; // STATUS_INVALID_PARAMETER;
        goto EXIT_THE_FUNCTION;
    }
    DavPrint((DEBUG_MISC, "DavFsClose: ServerName = %ws.\n", ServerName));
    
    ServerID = CloseRequest->ServerID;
    DavPrint((DEBUG_MISC, "DavFsClose: ServerID = %d.\n", ServerID));

    //
    // The first character is a '\' which has to be stripped.
    //
    DirectoryPath = &(CloseRequest->PathName[1]);
    if (!DirectoryPath) {
        DavPrint((DEBUG_ERRORS, "DavFsClose: DirectoryPath is NULL.\n"));
        WStatus = ERROR_INVALID_PARAMETER; // STATUS_INVALID_PARAMETER;
        goto EXIT_THE_FUNCTION;
    }
    DavPrint((DEBUG_MISC, "DavFsClose: DirectoryPath = %ws.\n", DirectoryPath));
    
    //
    // The DirectoryPath can contain \ characters. Replace them by / characters.
    //
    CanName = DirectoryPath;
    while (*CanName) {
        if (*CanName == L'\\') {
            *CanName = L'/';
        }
        CanName++;
    }

    UserWorkItem = (PUMRX_USERMODE_WORKITEM_HEADER)DavWorkItem;

    //
    // If we have a dummy share name in the DirectoryPath, we need to remove it 
    // right now before we contact the server.
    //
    DavRemoveDummyShareFromFileName(DirectoryPath);
    
    //
    // We need to call this only if "DAV_USE_WININET_ASYNCHRONOUSLY" has been
    // defined. Otherwise, if we are using WinInet synchronously, then we 
    // would have already done this in the DavWorkerThread function. This 
    // ultimately gets deleted (the impersonation token that is) in the 
    // DavAsyncCreateCompletion function.
    //
#ifdef DAV_USE_WININET_ASYNCHRONOUSLY
    
    //
    // Set the DavCallBackContext.
    //
    WStatus = DavFsSetTheDavCallBackContext(DavWorkItem);
    if (WStatus != ERROR_SUCCESS) {
        DavPrint((DEBUG_ERRORS,
                  "DavFsClose/DavFsSetTheDavCallBackContext. "
                  "Error Val = %d\n", WStatus));
        goto EXIT_THE_FUNCTION;
    }
    CallBackContextInitialized = TRUE;
    
    //
    // Store the address of the DavWorkItem which serves as a callback in the 
    // variable CallBackContext. This will now be used in all the async calls
    // that follow.
    //
    CallBackContext = (ULONG_PTR)(DavWorkItem);

#endif
    
    //
    // Allocate memory for the INTERNET_ASYNC_RESULT structure.
    //
    DavWorkItem->AsyncResult = LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, 
                                          sizeof(INTERNET_ASYNC_RESULT));
    if (DavWorkItem->AsyncResult == NULL) {
        WStatus = GetLastError();
        DavPrint((DEBUG_ERRORS, "DavFsClose/LocalAlloc. Error Val = %d\n",
                  WStatus));
        goto EXIT_THE_FUNCTION;
    }
    
    //
    // A User Entry for this user must have been created during the create call
    // earlier. The user entry contains the handle used to send an HttpOpen
    // request.
    //

    EnterCriticalSection( &(HashServerEntryTableLock) );
    EnCriSec = TRUE;

    ReturnVal = DavDoesUserEntryExist(ServerName,
                                      ServerID, 
                                      &(CloseRequest->LogonID),
                                      &PerUserEntry,
                                      &ServerHashEntry);

    //
    // If the following request in the kernel get cancelled even before the 
    // corresponding usermode thread gets a chance to execute this code, then
    // it possible that the VNetRoot (hence the PerUserEntry) and SrvCall get
    // finalized before the thread that is handling the create comes here. This
    // could happen if this request was the only one for this share and the
    // server as well. This is why we need to check if the ServerHashEntry and
    // the PerUserEntry are valid before proceeding.
    //
    if (ReturnVal == FALSE || ServerHashEntry == NULL || PerUserEntry == NULL) {
        WStatus = ERROR_CANCELLED;
        DavPrint((DEBUG_ERRORS, "DavFsClose: (ServerHashEntry == NULL || PerUserEntry == NULL)\n"));
        goto EXIT_THE_FUNCTION;
    }

    DavWorkItem->AsyncClose.PerUserEntry = PerUserEntry;

    DavWorkItem->AsyncClose.ServerHashEntry = ServerHashEntry;
    
    //
    // Add a reference to the user entry.
    //
    PerUserEntry->UserEntryRefCount++;

    //
    // Since a create had succeeded earlier, the entry must be good.
    //
    ASSERT(PerUserEntry->UserEntryState == UserEntryInitialized);
    ASSERT(PerUserEntry->DavConnHandle != NULL);
    DavConnHandle = PerUserEntry->DavConnHandle;

    //
    // And yes, we obviously have to leave the critical section
    // before returning.
    //
    LeaveCriticalSection( &(HashServerEntryTableLock) );
    EnCriSec = FALSE;

    if ( !CloseRequest->isDirectory ) {

        //
        // If the file has to be deleted on close, we need to send a DELETE for 
        // this file to the server. It does not matter if the file has been 
        // modified or not.
        //
        if ( (CloseRequest->DeleteOnClose) ) {

            DavWorkItem->DavMinorOperation = DavMinorDeleteFile;

            OpenVerb = L"DELETE";

            DavWorkItem->AsyncClose.DataBuff = NULL;

        } else if (CloseRequest->FileWasModified) {

            //
            // The file has been changed and needs to be PUT on the server.
            //
            DavWorkItem->DavMinorOperation = DavMinorPutFile;

            OpenVerb = L"PUT";

            //
            // We need to check if this file is encrypted. If it is, we need to 
            // BackUp the encrypted file to a temp file and send the BackedUp file
            // to the server.
            //
            if ( !( CloseRequest->dwFileAttributes & FILE_ATTRIBUTE_ENCRYPTED ) ) {

                DavPrint((DEBUG_MISC, "DavFsClose. This is NOT an Encrypted file.\n"));

                //
                // Create an NT path name for the cached file. This is used in the 
                // NtCreateFile call below.
                //
                ReturnVal = RtlDosPathNameToNtPathName_U(CloseRequest->FileName,
                                                         &(UnicodeFileName), 
                                                         NULL, 
                                                         NULL);
                if (!ReturnVal) {
                    WStatus = ERROR_BAD_PATHNAME;
                    DavPrint((DEBUG_ERRORS,
                              "DavFsClose/RtlDosPathNameToNtPathName. "
                              "Error Val = %d\n", WStatus));
                    goto EXIT_THE_FUNCTION;
                }

                InitializeObjectAttributes(&(ObjectAttributes),
                                           &(UnicodeFileName),
                                           OBJ_CASE_INSENSITIVE,  
                                           0,
                                           NULL);

                //
                // This #if 0 below was added because the NtCreateFile was failing
                // with ERROR_ACCESS_DENIED. This is because this file has been
                // created in the LocalService's %USERPROFILE% and you need to be
                // in the context of the LocalService before calling NtCreateFile.
                // By impersonating below we were getting into the context of the
                // user and hence the call failed.
                //

#if 0
                //
                // We are running in the context of the Web Client service. Before 
                // contacting the server below, we need to impersonate the client 
                // that issued this request.
                //
                WStatus = UMReflectorImpersonate(UserWorkItem, DavWorkItem->ImpersonationHandle);
                if (WStatus != ERROR_SUCCESS) {
                    DavPrint((DEBUG_ERRORS,
                              "DavFsClose/UMReflectorImpersonate(1). Error Val = %d\n",
                              WStatus));
                    goto EXIT_THE_FUNCTION;
                }
                didImpersonate = TRUE;
#endif

                //
                // Create a handle to the local file, for reading its attributes and data.
                // We read the whole file into a buffer and send it across to the server.
                //
                NtStatus = NtCreateFile(&(FileHandle),
                                        (SYNCHRONIZE | FILE_READ_ATTRIBUTES | FILE_READ_DATA),
                                        &(ObjectAttributes),
                                        &(IoStatusBlock),
                                        NULL,
                                        FILE_ATTRIBUTE_NORMAL,
                                        (FILE_SHARE_READ | FILE_SHARE_WRITE),
                                        FILE_OPEN,
                                        (FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT),
                                        NULL,
                                        0);
                if (NtStatus != STATUS_SUCCESS) {
                    //
                    // We convert the NtStatus to DOS error here. The Win32
                    // error code is finally set to an NTSTATUS value in
                    // the DavFsCreate function just before returning.
                    //
                    WStatus = RtlNtStatusToDosError(NtStatus);
                    FileHandle = NULL;
                    DavPrint((DEBUG_ERRORS,
                              "DavFsClose/NtCreateFile(1). Error Val = %08lx\n", 
                              NtStatus));
                    goto EXIT_THE_FUNCTION;
                }

                ReturnVal = GetFileInformationByHandle(FileHandle, &(FileInfo));
                if (!ReturnVal) {
                    WStatus = GetLastError();
                    DavPrint((DEBUG_ERRORS,
                              "DavFsClose/GetFileInformationByHandle: Return Val = %08lx.\n",
                              WStatus));
                    goto EXIT_THE_FUNCTION;
                }

                if (didImpersonate) {
                    RevertToSelf();
                    didImpersonate = FALSE;
                }

                FileSize.LowPart = FileInfo.nFileSizeLow;
                FileSize.HighPart = FileInfo.nFileSizeHigh;

                if ( FileSize.QuadPart > (LONGLONG)0 ) {

                    DataBuff = LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, FileSize.LowPart);
                    if (DataBuff == NULL) {
                        WStatus = GetLastError();
                        DavPrint((DEBUG_ERRORS,
                                  "DavFsClose/LocalAlloc. Error Val = %d\n", WStatus));
                        goto EXIT_THE_FUNCTION;
                    }

                    DavWorkItem->AsyncClose.DataBuff = DataBuff;

                    //
                    // Start reading at the first byte.
                    //
                    ByteOffset.LowPart = 0;
                    ByteOffset.HighPart = 0;

                    NtStatus = NtReadFile(FileHandle, 
                                          NULL,
                                          NULL,
                                          NULL,
                                          &(IoStatusBlock),
                                          DataBuff,
                                          FileSize.LowPart, 
                                          &(ByteOffset),
                                          NULL);
                    if (NtStatus != STATUS_SUCCESS) {
                        //
                        // We convert the NtStatus to DOS error here. The Win32
                        // error code is finally set to an NTSTATUS value in
                        // the DavFsCreate function just before returning.
                        //
                        WStatus = RtlNtStatusToDosError(NtStatus);
                        DavPrint((DEBUG_ERRORS,
                                  "DavFsClose/NtReadFile. Error Val = %08lx\n", 
                                  NtStatus));
                        goto EXIT_THE_FUNCTION;
                    }

                    DavWorkItem->AsyncClose.DataBuffSizeInBytes = FileSize.LowPart;

                    NtStatus = NtClose(FileHandle);
                    FileHandle = NULL;
                    if (NtStatus != STATUS_SUCCESS) {
                        //
                        // We convert the NtStatus to DOS error here. The Win32
                        // error code is finally set to an NTSTATUS value in
                        // the DavFsCreate function just before returning.
                        //
                        WStatus = RtlNtStatusToDosError(NtStatus);
                        DavPrint((DEBUG_ERRORS,
                                  "DavFsClose/NtClose. Error Val = %08lx\n", 
                                  NtStatus));
                        goto EXIT_THE_FUNCTION;
                    }

                } else {

                    DavPrint((DEBUG_MISC, "DavFsClose. Zero Byte File.\n"));

                    DavWorkItem->AsyncClose.DataBuff = NULL;

                }

            } else {

                DWORD err;
                UINT tempErr;
                BOOL copyErr;
                PVOID RawContext = NULL;

                //
                // This is an encrypted file. Create a BackUp stream, store it into
                // a temp file and PUT the temp file (BLOB) on the server.
                //
                DavPrint((DEBUG_MISC, "DavFsClose. This is an Encrypted file.\n"));

                //
                // We loop till we can come up with a FileName in the TEMP directory
                // of the user which has not been used.
                //

                DavPrint((DEBUG_MISC, 
                          "DavFsClose: FileName = %ws\n", CloseRequest->FileName));

                //
                // If the file was opened as non-encrypted, the local cache file does not have
                // the ACL allowing everyone to access. Set the ACL here before impersonating.
                //
                WStatus = DavSetAclForEncryptedFile(CloseRequest->FileName);
                if (WStatus != ERROR_SUCCESS) {
                    DavPrint((DEBUG_ERRORS,
                              "DavAsyncClose/DavSetAclForEncryptedFile. Error Val"
                              " = %d\n", WStatus));
                    goto EXIT_THE_FUNCTION;
                }
                
                //
                // We are running in the context of the Web Client service. Before contacting
                // the server below, we need to impersonate the client that issued this
                // request.
                //
                WStatus = UMReflectorImpersonate(UserWorkItem, DavWorkItem->ImpersonationHandle);
                if (WStatus != ERROR_SUCCESS) {
                    DavPrint((DEBUG_ERRORS,
                              "DavFsClose/UMReflectorImpersonate(2). Error Val = %d\n",
                              WStatus));
                    goto EXIT_THE_FUNCTION;
                }
                didImpersonate = TRUE;

                //
                // Open a Raw context to the file.
                //
                WStatus = OpenEncryptedFileRawW(CloseRequest->FileName, 0, &(RawContext));
                if (WStatus != ERROR_SUCCESS) {
                    DavPrint((DEBUG_ERRORS,
                              "DavFsClose/OpenEncryptedFileRaw. Error Val = %d %ws\n", 
                              WStatus,CloseRequest->FileName));
                    goto EXIT_THE_FUNCTION;
                }

                //
                // The extra space prepared for the EFS stream.
                //

                DavWorkItem->AsyncClose.DataBuffAllocationSize = (CloseRequest->FileSize >> 4) + 0x1000;

                if (MAX_DWORD - CloseRequest->FileSize < DavWorkItem->AsyncClose.DataBuffAllocationSize) {
                    WStatus = ERROR_NO_SYSTEM_RESOURCES;
                    DavPrint((DEBUG_ERRORS,
                              "DavFsClose/backup size exceeds MRX_DWORD!"));
                    goto EXIT_THE_FUNCTION;
                }
                
                DavWorkItem->AsyncClose.DataBuffAllocationSize += CloseRequest->FileSize;
                
                DataBuff = LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, DavWorkItem->AsyncClose.DataBuffAllocationSize);

                if (DataBuff == NULL) {
                    WStatus = GetLastError();
                    DavPrint((DEBUG_ERRORS,
                              "DavFsClose/LocalAlloc. Error Val = %d\n", WStatus));
                    
                    if (RawContext) {
                        CloseEncryptedFileRaw(RawContext);
                    }
                    goto EXIT_THE_FUNCTION;
                }

                DavWorkItem->AsyncClose.DataBuff = DataBuff;
                DavPrint((DEBUG_MISC, 
                          "DavFsClose: allocate backup buffer %x %x\n",DataBuff,DavWorkItem->AsyncClose.DataBuffAllocationSize));
                
                WStatus = ReadEncryptedFileRaw((PFE_EXPORT_FUNC)DavReadRawCallback,
                                               (PVOID)DavWorkItem,
                                               RawContext);
                
                if (RawContext) {
                    CloseEncryptedFileRaw(RawContext);
                }

                if (WStatus != ERROR_SUCCESS) {
                    DavPrint((DEBUG_ERRORS,
                              "DavFsClose/ReadEncryptedFileRaw. Error Val = %d\n", 
                              WStatus));
                    goto EXIT_THE_FUNCTION;
                }
                
                if (didImpersonate) {
                    RevertToSelf();
                    didImpersonate = FALSE;
                }

            }

        } else {

            ASSERT( (fSetDirectoryEntry == TRUE) || (CloseRequest->OpaqueLockToken != NULL) );

            //
            // If it is only an attribute change, we send the PROPPATCH. If the
            // file was LOCKed on Create, we send the UNLOCK request.
            //
            WStatus = ERROR_SUCCESS;

            goto EXIT_THE_FUNCTION;

        }

    } else {

        if (CloseRequest->DeleteOnClose) {
            //
            // This is a directory and needs to be deleted from the server.
            //
            DavWorkItem->DavMinorOperation = DavMinorDeleteFile;

            OpenVerb = L"DELETE";

            DavWorkItem->AsyncClose.DataBuff = NULL;
        } else if (fSetDirectoryEntry) {
            //
            // If this is a directory close, then the only reason to contact the
            // server is when we are deleting the directory and all the files 
            // under it. If not, we can return right now.
            //
            WStatus = ERROR_SUCCESS;
            goto EXIT_THE_FUNCTION;
        }
    }

    //
    // We are running in the context of the Web Client service. Before contacting
    // the server below, we need to impersonate the client that issued this
    // request.
    //
    WStatus = UMReflectorImpersonate(UserWorkItem, DavWorkItem->ImpersonationHandle);
    if (WStatus != ERROR_SUCCESS) {
        DavPrint((DEBUG_ERRORS,
                  "DavFsClose/UMReflectorImpersonate(3). Error Val = %d\n",
                  WStatus));
        goto EXIT_THE_FUNCTION;
    }
    didImpersonate = TRUE;

    //
    // We now call the DavHttpOpenRequest function.
    //
    DavWorkItem->DavOperation = DAV_CALLBACK_HTTP_OPEN;
    
    //
    // Convert the unicode object name to UTF-8 URL format.
    // Space and other white characters will remain untouched - these should
    // be taken care of by wininet calls.
    //
    BStatus = DavHttpOpenRequestW(DavConnHandle,
                                  OpenVerb,
                                  DirectoryPath,
                                  L"HTTP/1.1",
                                  NULL,
                                  NULL,
                                  INTERNET_FLAG_KEEP_CONNECTION |
                                  INTERNET_FLAG_NO_COOKIES,
                                  CallBackContext,
                                  L"DavFsClose",
                                  &DavOpenHandle);
    if(BStatus == FALSE) {
        WStatus = GetLastError();
        goto EXIT_THE_FUNCTION;
    }
    if (DavOpenHandle == NULL) {
        WStatus = GetLastError();
        if (WStatus != ERROR_IO_PENDING) {
            DavPrint((DEBUG_ERRORS,
                      "DavFsClose/DavHttpOpenRequestW. Error Val = %d\n",
                      WStatus));
        }
        goto EXIT_THE_FUNCTION;
    }

    //
    // Cache the DavOpenHandle in the DavWorkItem.
    //
    DavWorkItem->AsyncClose.DavOpenHandle = DavOpenHandle;

    WStatus = DavAsyncCommonStates(DavWorkItem, FALSE);
    
    if (WStatus != ERROR_SUCCESS && WStatus != ERROR_IO_PENDING) {
        DavPrint((DEBUG_ERRORS,
                  "DavFsClose/DavAsyncCommonStates. Error Val = %08lx\n",
                  WStatus));
    }

    if (WStatus == ERROR_SUCCESS) {

        INTERNET_CACHE_ENTRY_INFOW CEI;

        CEI.LastAccessTime.dwLowDateTime = 0;
        CEI.LastAccessTime.dwHighDateTime = 0;

        SetUrlCacheEntryInfo(CloseRequest->Url,&CEI,CACHE_ENTRY_ACCTIME_FC);
        
        DavPrint((DEBUG_MISC,
                  "DavFsClose Reset LastAccessTime for      %ws\n",CloseRequest->Url));
        
        if (CloseRequest->FileWasModified &&
            (CloseRequest->dwFileAttributes & FILE_ATTRIBUTE_ENCRYPTED)) {
            //
            // Reset the LastModifiedTime on URL cache of the encrypted file
            // so that the public cache will be updated on the next GET.
            //
            CEI.LastModifiedTime.dwLowDateTime = 0;
            CEI.LastModifiedTime.dwHighDateTime = 0;

            SetUrlCacheEntryInfo(CloseRequest->Url,&CEI,CACHE_ENTRY_MODTIME_FC);
            
            DavPrint((DEBUG_MISC,
                      "DavFsClose Reset LastModifiedTime %ws\n",CloseRequest->Url));
        }

    }

EXIT_THE_FUNCTION:

    if (fSetDirectoryEntry && (WStatus == ERROR_SUCCESS)) {
        
        if (!didImpersonate) {
            //
            // If we are using WinInet synchronously, then we need to impersonate the
            // clients context now. This is becuase the DavSetProperties call below
            // contacts the DAV Server and we need to be impersonating the correct 
            // client when contacting it.
            //
            WStatus = UMReflectorImpersonate(UserWorkItem, DavWorkItem->ImpersonationHandle);
            
            if (WStatus != ERROR_SUCCESS) {
                DavPrint((DEBUG_ERRORS,
                          "DavFsClose/UMReflectorImpersonate(4). Error Val = %d\n",
                          WStatus));
            } else {
                didImpersonate = TRUE;
            }
        }

        if (WStatus == ERROR_SUCCESS) {

            DavWorkItem->DavMinorOperation = DavMinorProppatchFile;

            WStatus = DavSetBasicInformation(DavWorkItem,
                                             DavConnHandle,
                                             DirectoryPath,
                                             CloseRequest->fCreationTimeChanged,
                                             CloseRequest->fLastAccessTimeChanged,
                                             CloseRequest->fLastModifiedTimeChanged,
                                             CloseRequest->fFileAttributesChanged,
                                             &CloseRequest->CreationTime,
                                             &CloseRequest->LastAccessTime,
                                             &CloseRequest->LastModifiedTime,
                                             CloseRequest->dwFileAttributes);

            if (WStatus != ERROR_SUCCESS) {

                ULONG LogStatus;

                DavPrint((DEBUG_ERRORS,
                          "DavFsClose/DavSetBasicInformation. WStatus = %d\n",
                          WStatus));
            
                LogStatus = DavFormatAndLogError(DavWorkItem, WStatus);
                if (LogStatus != ERROR_SUCCESS) {
                    DavPrint((DEBUG_ERRORS,
                              "DavFsClose/DavFomatAndLogError. LogStatus = %d\n",
                              LogStatus));
                }
            
            }

            DavPrint((DEBUG_MISC,
                      "DavFsClose set BasicInformation(2). %d %x %ws\n",
                       WStatus,CloseRequest->dwFileAttributes,DirectoryPath));

            //
            // If the PROPPATCH fails, we don't fail the close call. This is 
            // because the PUT (if one was needed) has suceeded and we reset the
            // FileWasModified flag in the FCB based on whether this call succeeds.
            // On the final close, we check to see if this flag is set to FALSE
            // and pop up a box saying that the "delayed write failed". We 
            // shouldn't be doing it if the PUT succeeds and the PROPPATCH fails.
            // We log an entry in the EventLog (under application) that the
            // PROPPATCH has failed though.
            //
            WStatus = ERROR_SUCCESS;

        }

    }

    //
    // If the file was LOCKed on the server on Create, we need to UnLock it
    // now. If the UNLOCK fails, we don't fail the close call. Also, we don't
    // need to UNLOCK the file if we have already deleted it.
    //
    if (CloseRequest->OpaqueLockToken && !CloseRequest->DeleteOnClose) {
        ULONG UnLockStatus;
        if (!didImpersonate) {
            //
            // If we are using WinInet synchronously, then we need to impersonate
            // the clients context now. This is becuase the DavUnLockFile call
            // below contacts the DAV Server and we need to be impersonating the
            // correct client when contacting it.
            //
            UnLockStatus = UMReflectorImpersonate(UserWorkItem, DavWorkItem->ImpersonationHandle);
            if (UnLockStatus != ERROR_SUCCESS) {
                DavPrint((DEBUG_ERRORS,
                          "DavFsClose/UMReflectorImpersonate(5). UnLockStatus = %d\n",
                          UnLockStatus));
            } else {
                didImpersonate = TRUE;
            }
        }
        UnLockStatus = DavUnLockTheFileOnTheServer(DavWorkItem);
        if (UnLockStatus != ERROR_SUCCESS) {
            DavPrint((DEBUG_ERRORS,
                      "DavFsClose/DavUnLockTheFileOnTheServer: UnLockStatus = %08lx\n",
                      UnLockStatus));
        }
    }

    if (EnCriSec) {
        LeaveCriticalSection( &(HashServerEntryTableLock) );
        EnCriSec = FALSE;
    }

    //
    // The function RtlDosPathNameToNtPathName_U allocates memory from the 
    // processes heap. If we did, we need to free it now.
    //
    if (UnicodeFileName.Buffer != NULL) {
        RtlFreeHeap(RtlProcessHeap(), 0, UnicodeFileName.Buffer);
    }

    //
    // If we are using WinInet synchronously, then we should never get back
    // ERROR_IO_PENDING from WinInet.
    //
    ASSERT(WStatus != ERROR_IO_PENDING);

    //
    // If this thread impersonated a user, we need to revert back.
    //
    if (didImpersonate) {
        RevertToSelf();
    }

    if (FileHandle != NULL) {
        NtClose(FileHandle);
        FileHandle = NULL;
    }

    //
    // Set the return status of the operation. This is used by the kernel
    // mode routines to figure out the completion status of the user mode
    // request. This is done here because the async completion routine that is
    // called immediately afterwards needs the status set.
    //
    if (WStatus != ERROR_SUCCESS) {
        DavWorkItem->Status = DavMapErrorToNtStatus(WStatus);
    } else {
        DavWorkItem->Status = STATUS_SUCCESS;
    }

    DavAsyncCloseCompletion(DavWorkItem);

    return WStatus;
}


DWORD 
DavAsyncClose(
    PDAV_USERMODE_WORKITEM DavWorkItem,
    BOOLEAN CalledByCallBackThread
    )
/*++

Routine Description:

   This is the callback routine for the close operation.

Arguments:

    DavWorkItem - The DAV_USERMODE_WORKITEM value.

    CalledByCallbackThread - TRUE, if this function was called by the thread
                             which picks of the DavWorkItem from the Callback
                             function. This happens when an Async WinInet call
                             returns ERROR_IO_PENDING and completes later.

Return Value:

    ERROR_SUCCESS or the appropriate error value.

--*/
{
    ULONG WStatus = ERROR_SUCCESS;
    PUMRX_USERMODE_WORKITEM_HEADER UserWorkItem;
    BOOL didImpersonate = FALSE;
    HINTERNET DavOpenHandle = NULL;
    
    UserWorkItem = (PUMRX_USERMODE_WORKITEM_HEADER)DavWorkItem;
    
    DavOpenHandle = DavWorkItem->AsyncClose.DavOpenHandle;
    
#ifdef DAV_USE_WININET_ASYNCHRONOUSLY
    
    if (CalledByCallBackThread) {

        //
        // We are running in the context of a worker thread which has different 
        // credentials than the user that initiated the I/O request. Before
        // proceeding further, we should impersonate the user that initiated the 
        // request.
        //
        WStatus = UMReflectorImpersonate(UserWorkItem, DavWorkItem->ImpersonationHandle);
        if (WStatus != ERROR_SUCCESS) {
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncClose/UMReflectorImpersonate. Error Val = %d\n", 
                      WStatus));
            goto EXIT_THE_FUNCTION;
        }
        didImpersonate = TRUE;
        
        //
        // Before proceeding further, check to see if the Async operation failed.
        // If it did, then cleanup and move on.
        //
        if ( !DavWorkItem->AsyncResult->dwResult ) {
            
            WStatus = DavWorkItem->AsyncResult->dwError;
            
            //
            // If the error we got back is ERROR_INTERNET_FORCE_RETRY, then
            // WinInet is trying to authenticate itself with the server. In 
            // such a scenario this is what happens.
            //
            //          Client ----Request----->   Server
            //          Server ----AccessDenied-----> Client
            //          Client----Challenge Me-------> Server
            //          Server-----Challenge--------> Client
            //          Client-----Challenge Resp----> Server
            //
            if (WStatus == ERROR_INTERNET_FORCE_RETRY) {

                ASSERT(DavWorkItem->DavOperation == DAV_CALLBACK_HTTP_END);

                //
                // We need to repeat the HttpSend and HttpEnd request calls.
                //
                DavWorkItem->DavOperation = DAV_CALLBACK_HTTP_OPEN;

                WStatus = DavAsyncCommonStates(DavWorkItem, FALSE);
                if (WStatus != ERROR_SUCCESS && WStatus != ERROR_IO_PENDING) {
                    DavPrint((DEBUG_ERRORS,
                              "DavAsyncClose/DavAsyncCommonStates. Error Val ="
                              " %08lx\n", WStatus));
                }

            } else {

                DavPrint((DEBUG_ERRORS,
                          "DavAsyncClose. AsyncFunction failed. Error Val = %d\n", 
                          WStatus));
            
            }
            
            goto EXIT_THE_FUNCTION;

        }

    }

#else

    ASSERT(CalledByCallBackThread == FALSE);

#endif

    //
    // We return what ever the response code from the Http server was for this
    // request.
    //
    WStatus = DavQueryAndParseResponse(DavOpenHandle);

    if (WStatus != ERROR_SUCCESS) {

        ULONG LogStatus;

        LogStatus = DavFormatAndLogError(DavWorkItem, WStatus);
        if (LogStatus != ERROR_SUCCESS) {
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncClose/DavFormatAndLogError. LogStatus = %d\n", 
                      LogStatus));
        }
    
    }

#ifdef DAV_USE_WININET_ASYNCHRONOUSLY
EXIT_THE_FUNCTION:
#endif

    //
    // If we did impersonate, we need to revert back.
    //
    if (didImpersonate) {
        ULONG RStatus;
        RStatus = UMReflectorRevert(UserWorkItem);
        if (RStatus != ERROR_SUCCESS) {
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncClose/UMReflectorRevert. Error Val = %d\n", 
                      RStatus));
        }
    }

#ifdef DAV_USE_WININET_ASYNCHRONOUSLY

    //
    // Some resources should not be freed if we are returning ERROR_IO_PENDING
    // because they will be used in the callback functions.
    //
    if ( WStatus != ERROR_IO_PENDING && CalledByCallBackThread ) {
        //
        // Set the return status of the operation. This is used by the kernel 
        // mode routines to figure out the completion status of the user mode 
        // request.
        //
        if (WStatus != ERROR_SUCCESS) {
            DavWorkItem->Status = DavMapErrorToNtStatus(WStatus);
        } else {
            DavWorkItem->Status = STATUS_SUCCESS;
        }


        //
        // Call the DavAsyncCloseCompletion routine.
        //
        DavAsyncCloseCompletion(DavWorkItem);

        //
        // This thread now needs to send the response back to the kernel. It
        // does not wait in the kernel (to get another request) after submitting
        // the response.
        //
        UMReflectorCompleteRequest(DavReflectorHandle, UserWorkItem);

    } else {
        DavPrint((DEBUG_MISC, "DavAsyncClose: Returning ERROR_IO_PENDING.\n"));
    }

#endif

    return WStatus;
}


VOID
DavAsyncCloseCompletion(
    PDAV_USERMODE_WORKITEM DavWorkItem
    )
/*++

Routine Description:

   This routine handles the Async Close completion. It basically frees up 
   the resources allocated during the Async Close operation.

Arguments:

    DavWorkItem - The DAV_USERMODE_WORKITEM value.
    
Return Value:

    none.

--*/
{
    if (DavWorkItem->AsyncClose.DavOpenHandle != NULL) {
        BOOL ReturnVal;
        ULONG FreeStatus;
        HINTERNET DavOpenHandle = DavWorkItem->AsyncClose.DavOpenHandle;
        ReturnVal = InternetCloseHandle( DavOpenHandle );
        if (!ReturnVal) {
            FreeStatus = GetLastError();
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncCloseCompletion/InternetCloseHandle. "
                      "Error Val = %d\n", FreeStatus));
        }
    }

    if (DavWorkItem->AsyncClose.DataBuff != NULL) {
        HLOCAL FreeHandle;
        ULONG FreeStatus;
        FreeHandle = LocalFree((HLOCAL)DavWorkItem->AsyncClose.DataBuff);
        if (FreeHandle != NULL) {
            FreeStatus = GetLastError();
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncCloseCompletion/LocalFree. Error Val = %d\n", 
                      FreeStatus));
        }
    }
    
    if (DavWorkItem->AsyncClose.InternetBuffers != NULL) {
        HLOCAL FreeHandle;
        ULONG FreeStatus;
        FreeHandle = LocalFree((HLOCAL)DavWorkItem->AsyncClose.InternetBuffers);
        if (FreeHandle != NULL) {
            FreeStatus = GetLastError();
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncCloseCompletion/LocalFree. Error Val = %d\n", 
                      FreeStatus));
        }
    }
    
    if (DavWorkItem->AsyncResult != NULL) {
        HLOCAL FreeHandle;
        ULONG FreeStatus;
        FreeHandle = LocalFree((HLOCAL)DavWorkItem->AsyncResult);
        if (FreeHandle != NULL) {
            FreeStatus = GetLastError();
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncCloseCompletion/LocalFree. Error Val = %d\n", 
                      FreeStatus));
        }
    }

    DavFsFinalizeTheDavCallBackContext(DavWorkItem);

    //
    // We are done with the per user entry, so finalize it.
    //
    if (DavWorkItem->AsyncClose.PerUserEntry) {
        DavFinalizePerUserEntry( &(DavWorkItem->AsyncClose.PerUserEntry) );
    }

    return;
}

DWORD
DavReadRawCallback(
    PBYTE DataBuffer,
    PVOID CallbackContext,
    ULONG DataLength
    )
/*++

Routine Description:

    Call-back function for ReadEncryptedFileRaw(). This function allocate a buffer for
    async close and writes back the data to this buffer specified on because 
    ReadEncryptedFileRaw() provides the raw data to this callback function
    which in turn stores it in a backup file. This call-back function is called 
    until there is no more data left.

Arguments:

    DataBuffer - Data to be written.

    CallbackContext - Handle to the Backup file.

    DataLength - Size of the DataBuffer.

Return Value:

    ERROR_SUCCESS or Win32 Error Code.

--*/
{
    DWORD WStatus = ERROR_SUCCESS;
    DWORD BytesWritten = 0;
    BOOL  ReturnVal;
    PBYTE PreviousBuffer = NULL;
    ULONG PreviousDataLength = 0;
    PDAV_USERMODE_WORKITEM DavWorkItem = (PDAV_USERMODE_WORKITEM)CallbackContext;

    DavPrint((DEBUG_MISC, "DavReadRawCallback: DataLength = %d\n", DataLength));
    
    if ( !DataLength ) {
        return WStatus;
    }

    ASSERT(DavWorkItem->AsyncClose.DataBuff != NULL);

    PreviousDataLength = DavWorkItem->AsyncClose.DataBuffSizeInBytes;
    
    //
    // If the backup size exceeds the pre-allocation size, we have to allocate a bigger buffer.
    //
    if (PreviousDataLength + DataLength > DavWorkItem->AsyncClose.DataBuffAllocationSize) {

        if ((MAX_DWORD - PreviousDataLength < DataLength) ||
            (MAX_DWORD - PreviousDataLength - DataLength < 0x10000)) {
            WStatus = ERROR_NO_SYSTEM_RESOURCES;
            DavPrint((DEBUG_ERRORS,
                      "DavReadRawCallback/backup size exceeds MRX_DWORD!"));
            goto EXIT_THE_FUNCTION;
        }
        
        PreviousBuffer = DavWorkItem->AsyncClose.DataBuff;
        DavWorkItem->AsyncClose.DataBuffAllocationSize = DataLength+PreviousDataLength+0x10000;

        DavWorkItem->AsyncClose.DataBuff = LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, DavWorkItem->AsyncClose.DataBuffAllocationSize);

        if (DavWorkItem->AsyncClose.DataBuff == NULL) {
            WStatus = GetLastError();
            DavPrint((DEBUG_ERRORS,
                      "DavReadRawCallback/LocalAlloc. Error Val = %d\n", WStatus));
            goto EXIT_THE_FUNCTION;
        }
        
        RtlCopyMemory(DavWorkItem->AsyncClose.DataBuff,
                      PreviousBuffer,
                      PreviousDataLength);
        
        DavPrint((DEBUG_MISC, 
                  "DavReadRawCallback: allocate a bigger buffer %x %x\n",
                  DavWorkItem->AsyncClose.DataBuff,
                  DavWorkItem->AsyncClose.DataBuffAllocationSize));
    }
    
    RtlCopyMemory((PBYTE)(DavWorkItem->AsyncClose.DataBuff + PreviousDataLength),
                  DataBuffer,
                  DataLength);

    DavWorkItem->AsyncClose.DataBuffSizeInBytes += DataLength;

    DavPrint((DEBUG_MISC, "DavReadRawCallback: Buffer %x DataLength %d\n",
              DavWorkItem->AsyncClose.DataBuff,DavWorkItem->AsyncClose.DataBuffSizeInBytes));

EXIT_THE_FUNCTION:

    if (PreviousBuffer) {
        LocalFree(PreviousBuffer);
    }

    return WStatus;
}


DWORD
DavSetBasicInformation(
    PDAV_USERMODE_WORKITEM DavWorkItem,
    HINTERNET hDavConnect,
    LPWSTR  PathName,
    BOOL fCreationTimeChanged,
    BOOL fLastAccessTimeChanged,
    BOOL fLastModifiedTimeChanged,
    BOOL fFileAttributesChanged,
    IN LARGE_INTEGER *lpCreationTime,
    IN LARGE_INTEGER *lpLastAccessTime,
    IN LARGE_INTEGER *lpLastModifiedTime,
    DWORD dwFileAttributes
    )
/*++

Routine Description:

    This routine sets DAV properties on a file or a directory. It formats an XML requests and sends it
    to the server.
    
Arguments:

    DavConnectHandle - Server connection.
    
    CloseRequest - Usemode close request corresponding to the kernelmode close.

Return Value:

    ERROR_SUCCESS or Win32 Error Code.

--*/
{
    CHAR *lpTemp = NULL, Buffer[1024];
    DWORD dwError = ERROR_SUCCESS, dwSizeRemaining, dwTemp;    
    BOOL fRet = FALSE;    
    BOOL fInfoChange = TRUE;
    DWORD dwOverrideAttribMask = (FILE_ATTRIBUTE_ARCHIVE | FILE_ATTRIBUTE_ENCRYPTED |
                                  FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_NOT_CONTENT_INDEXED |
                                  FILE_ATTRIBUTE_OFFLINE |  FILE_ATTRIBUTE_READONLY |
                                  FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_TEMPORARY |
                                  FILE_ATTRIBUTE_DIRECTORY);

    fInfoChange = (fCreationTimeChanged | fLastAccessTimeChanged | 
                   fLastModifiedTimeChanged | fFileAttributesChanged);
    
    DavPrint((DEBUG_MISC, "DavSetBasicInformation: Attributes = %x %x\n", dwFileAttributes,fInfoChange));

    //
    // We do not proceed further since there is no information to change. Also,
    // in this case we return SUCCESS back to the caller.
    //
    if(fInfoChange == FALSE) {
        fRet = TRUE;
        dwError = ERROR_SUCCESS;
        goto bailout;
    }

    //
    // If attributes have changed, then verify that the new attributes are in 
    // valid combination i.e. If either of following attributes is present:
    // FILE_ATTRIBUTE_ARCHIVE, FILE_ATTRIBUTE_ENCRYPTED, 
    // FILE_ATTRIBUTE_HIDDEN, FILE_ATTRIBUTE_NOT_CONTENT_INDEXED,
    // FILE_ATTRIBUTE_OFFLINE, FILE_ATTRIBUTE_READONLY, 
    // FILE_ATTRIBUTE_SYSTEM, FILE_ATTRIBUTE_TEMPORARY, FILE_ATTRIBUTE_DIRECTORY
    // and if FILE_ATTRIBUTE_NORMAL is present, then FILE_ATTRIBUTE_NORMAL 
    // should be filtered.
    //

    if (fFileAttributesChanged == TRUE && (dwOverrideAttribMask & dwFileAttributes)) {
        dwFileAttributes &= ~FILE_ATTRIBUTE_NORMAL;
    }

    //
    // If this is a directoy and the attributes being set include 
    // FILE_TEMPORARY_FILE then we return ERROR_INVALID_PARAMETER since a 
    // directory cannot have this attribute.
    //
    if ( (fFileAttributesChanged)                         &&
         (dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)    &&
         (dwFileAttributes & FILE_ATTRIBUTE_TEMPORARY) ) {
        fRet = FALSE;
        SetLastError(ERROR_INVALID_PARAMETER);
        goto bailout;
    }

    dwSizeRemaining = sizeof(rgPropPatchHeader) + sizeof(rgPropPatchTrailer) + 8 +
            ((fCreationTimeChanged)?(INTERNET_RFC1123_BUFSIZE+
                                                    sizeof(rgCreationTimeTagHeader)+
                                                    sizeof(rgCreationTimeTagTrailer)):0)+
            ((fLastAccessTimeChanged)?(INTERNET_RFC1123_BUFSIZE+
                                                    sizeof(rgLastAccessTimeTagHeader)+
                                                    sizeof(rgLastAccessTimeTagTrailer)):0)+
            ((fLastModifiedTimeChanged)?(INTERNET_RFC1123_BUFSIZE+
                                                    sizeof(rgLastModifiedTimeTagHeader)+
                                                    sizeof(rgLastModifiedTimeTagTrailer)):0)+
            ((fFileAttributesChanged)?(8+sizeof(rgFileAttributesTagHeader)+
                                                        sizeof(rgFileAttributesTagTrailer)):0);
                        

    if (dwSizeRemaining > sizeof(Buffer)) {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        DavPrint((DEBUG_ERRORS, "DavSetBasicInformation: Insufficient buffer %d %d\n", dwSizeRemaining, sizeof(Buffer)));
    }

    memset(Buffer, 0, sizeof(Buffer));    

    dwSizeRemaining = sizeof(Buffer);

    lpTemp = Buffer;

    memcpy(lpTemp, rgPropPatchHeader, (sizeof(rgPropPatchHeader)-1));

    lpTemp += (sizeof(rgPropPatchHeader)-1);

    dwSizeRemaining -= (sizeof(rgPropPatchHeader)-1);
    
    dwTemp = dwSizeRemaining;
    
    if (fCreationTimeChanged) {
        if (!DavConvertTimeToXml(rgCreationTimeTagHeader, (sizeof(rgCreationTimeTagHeader)-1),
                                 rgCreationTimeTagTrailer, (sizeof(rgCreationTimeTagTrailer)-1),
                                 lpCreationTime,
                                 &lpTemp,
                                 &dwTemp)) {
            DavPrint((DEBUG_ERRORS, "DavSetBasicInformation: Failed to convert creationtime\n"));
            goto bailout;
        }
    }

    if (fLastAccessTimeChanged)
    {
        if (!DavConvertTimeToXml(rgLastAccessTimeTagHeader, (sizeof(rgLastAccessTimeTagHeader)-1),
                                 rgLastAccessTimeTagTrailer, (sizeof(rgLastAccessTimeTagTrailer)-1),
                                 lpLastAccessTime,
                                 &lpTemp,
                                 &dwTemp))
        {
            DavPrint((DEBUG_ERRORS, "DavSetBasicInformation: Failed to convert lastaccesstime\n"));
            goto bailout;
        }
    }

    if (fLastModifiedTimeChanged)
    {
        if (!DavConvertTimeToXml(rgLastModifiedTimeTagHeader, (sizeof(rgLastModifiedTimeTagHeader)-1),
                                 rgLastModifiedTimeTagTrailer, (sizeof(rgLastModifiedTimeTagTrailer)-1),
                                 lpLastModifiedTime,
                                 &lpTemp,
                                 &dwTemp))
        {
            DavPrint((DEBUG_ERRORS, "DavSetBasicInformation: Failed to convert lastmodifiedtime\n"));
            goto bailout;
        }
    }

    if (fFileAttributesChanged)
    {
        memcpy(lpTemp, rgFileAttributesTagHeader, sizeof(rgFileAttributesTagHeader)-1);
        lpTemp += (sizeof(rgFileAttributesTagHeader)-1);
        
        sprintf(lpTemp, "%8.8x", dwFileAttributes);
        lpTemp += 8;
        
        memcpy(lpTemp, rgFileAttributesTagTrailer, sizeof(rgFileAttributesTagTrailer)-1);
        lpTemp += (sizeof(rgFileAttributesTagTrailer)-1);
    }

    memcpy(lpTemp, rgPropPatchTrailer, sizeof(rgPropPatchTrailer)-1);

    dwError = DavSetProperties(DavWorkItem, hDavConnect, PathName, Buffer);

    fRet = (dwError == ERROR_SUCCESS);

    if (!fRet) {
        DavPrint((DEBUG_ERRORS,
                  "DavSetBasicInformation/DavSetProperties: dwError = %d\n",
                  dwError));
        SetLastError(dwError);
    }

bailout:

    if (!fRet) {
        dwError = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavSetBasicInformation: dwError = %x\n", GetLastError()));
    }
    
    return dwError;
}


BOOL
DavConvertTimeToXml(
    IN PCHAR lpTagHeader,
    IN DWORD dwHeaderSize,
    IN PCHAR lpTagTrailer,
    IN DWORD dwTrailerSize,
    IN LARGE_INTEGER *lpTime,
    OUT PCHAR *lplpBuffer,
    IN OUT DWORD *lpdwBufferSize    
    )
/*++

Routine Description:

    Creates an xml piece for setting a time property. The format is
    <TagHeader>TimeString in RFC 1123 format<TagTrailer>
    
Arguments:

    lpTagHeader     tag beginning e.g. <Z:Win32CreationTime>
    
    dwHeaderSize    size of the above header in bytes
    
    lpTagTrailer    tag end e.g. </Z:Win32CreationTime>
    
    dwTrailerSize   size of the trailer in bytes
    
    lplpBuffer      pointer to a buffer pointer. On successful return the pointer is moved ahead.
    
    lpdwBufferSize  contains the passed in buffersize. On successful return, this value
                    is reduced by the amount of space consumed in this routine.

Return Value:

    ERROR_SUCCESS or Win32 Error Code. If the buffersize is not enough, the 
    error code is ERROR_INSUFFICIENT_BUFFER and lpdwBufferSize contains the 
    amount necessary to succeed.

--*/
{
    SYSTEMTIME  sSystemTime;
    DWORD   cbTimeSize;
    CHAR   chTimeBuff[INTERNET_RFC1123_BUFSIZE+4], *lpTemp;

                
    if(!FileTimeToSystemTime((FILETIME *)lpTime, &sSystemTime))
    {
        return FALSE;
    }

    if(!InternetTimeFromSystemTimeA(&sSystemTime, INTERNET_RFC1123_FORMAT, chTimeBuff, sizeof(chTimeBuff)))
    {
        return FALSE;
    }


    cbTimeSize = strlen(chTimeBuff);
    
    if (*lpdwBufferSize < (cbTimeSize + dwHeaderSize + dwTrailerSize))
    {
        *lpdwBufferSize =  (cbTimeSize + dwHeaderSize + dwTrailerSize);
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    }




    // all is well, start copying
    
    lpTemp = *lplpBuffer;

    // header tag eg: <Z:Win32CreationTime>
    memcpy(lpTemp, lpTagHeader, dwHeaderSize);
    
    lpTemp += dwHeaderSize;


    // Time in the RFC_1123 format    
    memcpy(lpTemp, chTimeBuff, cbTimeSize);
    
    lpTemp += cbTimeSize;
    
    // trailer tag eg: </Z:Win32CreationTime>
    memcpy(lpTemp, lpTagTrailer, dwTrailerSize);
    
    lpTemp += dwTrailerSize;
    

    // adjust the remainign size and the pointers    
    *lpdwBufferSize -=  (cbTimeSize + dwHeaderSize + dwTrailerSize);
    *lplpBuffer = lpTemp;
    
    return TRUE;
}


DWORD
DavParseXmlResponse(
    HINTERNET DavOpenHandle,
    DAV_FILE_ATTRIBUTES *pDavFileAttributesIn,
    DWORD *pNumFileEntries
    )
/*++

Routine Description:

    This routine parses the xml response. This is mainly useful for verbs which 
    may get back XML response.
    
Arguments:

    DavOpenHandle - Handle obtained from HttpOpenRequest. A send is already
                    issued on this handle.

Return Value:

    ERROR_SUCCESS or Win32 Error Code.

--*/
{
    DWORD dwError = ERROR_SUCCESS;
    BOOL ReturnVal, readDone;
    PCHAR DataBuff = NULL;
    DWORD NumRead = 0, NumOfFileEntries = 0, TotalDataBytesRead = 0;
    PVOID Ctx1 = NULL, Ctx2 = NULL;
    DAV_FILE_ATTRIBUTES DavFileAttributes, *pDavFileAttributesLocal = NULL;

    DataBuff = LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, NUM_OF_BYTES_TO_READ);
    if (DataBuff == NULL) {
        dwError = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavParseXmlResponse/LocalAlloc: dwError = %08lx\n",
                  dwError));
        goto EXIT_THE_FUNCTION;
    }

    //
    // Read the response and parse it.
    //
    do {

        ReturnVal = InternetReadFile(DavOpenHandle, 
                                     (LPVOID)DataBuff,
                                     NUM_OF_BYTES_TO_READ,
                                     &(NumRead));
        if (!ReturnVal) {
            dwError = GetLastError();
            DavPrint((DEBUG_ERRORS,
                      "DavParseXmlResponse/InternetReadFile: dwError = "
                      "%08lx\n", dwError));
            goto EXIT_THE_FUNCTION;
        }

        DavPrint((DEBUG_MISC, "DavParseXmlResponse: NumRead = %d\n", NumRead));

        //
        // We reject files whose attributes are greater than a certain size
        // (DavFileAttributesLimitInBytes). This is a parameter that can be
        // set in the registry. This is done to avoid attacks by rogue servers.
        //
        TotalDataBytesRead += NumRead;
        if (TotalDataBytesRead > DavFileAttributesLimitInBytes) {
            dwError = ERROR_BAD_NET_RESP;
            DavPrint((DEBUG_ERRORS, "DavParseXmlResponse. FileAttributesSize > %d\n", DavFileAttributesLimitInBytes));
            goto EXIT_THE_FUNCTION;
        }

        readDone = (NumRead == 0) ? TRUE : FALSE;

        dwError = DavPushData(DataBuff, &Ctx1, &Ctx2, NumRead, readDone);
        if (dwError != ERROR_SUCCESS) {
            DavPrint((DEBUG_ERRORS,
                      "DavParseXmlResponse/DavPushData."
                      " Error Val = %d\n", dwError));
            goto EXIT_THE_FUNCTION;
        }

        if (readDone) {
            break;
        }
    
    } while ( TRUE );

    if (Ctx2) {
        if (pDavFileAttributesIn) {
            pDavFileAttributesLocal = pDavFileAttributesIn;
        } else {
            pDavFileAttributesLocal = &DavFileAttributes;
        }
        memset(pDavFileAttributesLocal, 0, sizeof(DavFileAttributes));
        InitializeListHead(&(pDavFileAttributesLocal->NextEntry));
        dwError = DavParseData(pDavFileAttributesLocal, Ctx1, Ctx2, &NumOfFileEntries);
        if (dwError != ERROR_SUCCESS) {
            DavPrint((DEBUG_ERRORS,
                              "DavParseXmlResponse/DavParseData. "
                              "Error Val = %d\n", dwError));
            DavFinalizeFileAttributesList(pDavFileAttributesLocal, FALSE);
            goto EXIT_THE_FUNCTION;
        }
        if (!pDavFileAttributesIn){
            DavFinalizeFileAttributesList(pDavFileAttributesLocal, FALSE);
        }
        DavCloseContext(Ctx1, Ctx2);
    }

    if (pNumFileEntries){
        *pNumFileEntries = NumOfFileEntries;
    }
    
    dwError = ERROR_SUCCESS;

EXIT_THE_FUNCTION:

    if (DataBuff) {
        LocalFree(DataBuff);
        DataBuff = NULL;
    }
    
    return dwError; 
}


DWORD
DavSetProperties(
    PDAV_USERMODE_WORKITEM DavWorkItem,
    HINTERNET hDavConnect,
    LPWSTR lpPathName,
    LPSTR lpPropertiesBuffer
    )
/*++

Routine Description:

    This routine sets DAV properties on a file or a directory. It formats an XML requests and sends it
    to the server.
    
Arguments:

    DavConnectHandle - Server connection.
    
    CloseRequest - Usemode close request corresponding to the kernelmode close.

Return Value:

    ERROR_SUCCESS or Win32 Error Code.

--*/
{
    DWORD dwError = ERROR_SUCCESS;
    HINTERNET hRequest = NULL;
    BOOL BStatus = FALSE, ReturnVal = FALSE;
    PWCHAR PassportCookie = NULL;

    //
    // Convert the unicode object name to UTF-8 URL format.
    // Space and other white characters will remain untouched - these should
    // be taken care of by wininet calls. 
    // This has to be a W API as the name in CloseRequest is unicode.
    //
    BStatus = DavHttpOpenRequestW(hDavConnect,
                                  L"PROPPATCH",
                                  lpPathName, 
                                  L"HTTP/1.1",
                                  NULL,
                                  NULL,
                                  INTERNET_FLAG_KEEP_CONNECTION |
                                  INTERNET_FLAG_NO_COOKIES |
                                  INTERNET_FLAG_RELOAD,
                                  0,
                                  L"DavSetProperties",
                                  &hRequest);
    if(BStatus == FALSE) {
        dwError = GetLastError();
        goto EXIT_THE_FUNCTION;
    }
    if (hRequest == NULL) {
        dwError = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavSetProperties/DavHttpOpenRequestW. Error Val = %d\n",
                  dwError));
        goto EXIT_THE_FUNCTION;
    }

    //
    // If OpaqueLockToken is non-NULL, then we need to add this header
    // to the PROPPATCH request being sent out.
    //

    if (DavWorkItem->WorkItemType == UserModeClose) {

        PDAV_USERMODE_CLOSE_REQUEST CloseRequest = &(DavWorkItem->CloseRequest);

        if (CloseRequest->OpaqueLockToken != NULL) {
            ReturnVal = HttpAddRequestHeadersW(hRequest,
                                               CloseRequest->OpaqueLockToken,
                                               -1L,
                                               HTTP_ADDREQ_FLAG_ADD |
                                               HTTP_ADDREQ_FLAG_REPLACE );
            if (!ReturnVal) {
                dwError = GetLastError();
                DavPrint((DEBUG_ERRORS,
                          "DavSetProperties/HttpAddRequestHeadersW. "
                          "Error Val = %d\n", dwError));
                goto EXIT_THE_FUNCTION;
            }
        }

    } else if (DavWorkItem->WorkItemType == UserModeSetFileInformation) {

        PDAV_USERMODE_SETFILEINFORMATION_REQUEST SetFileInformationRequest = &(DavWorkItem->SetFileInformationRequest);

        if (SetFileInformationRequest->OpaqueLockToken != NULL) {
            ReturnVal = HttpAddRequestHeadersW(hRequest,
                                               SetFileInformationRequest->OpaqueLockToken,
                                               -1L,
                                               HTTP_ADDREQ_FLAG_ADD |
                                               HTTP_ADDREQ_FLAG_REPLACE );
            if (!ReturnVal) {
                dwError = GetLastError();
                DavPrint((DEBUG_ERRORS,
                          "DavSetProperties/HttpAddRequestHeadersW. "
                          "Error Val = %d\n", dwError));
                goto EXIT_THE_FUNCTION;
            }
        }

    }

    //
    // We need to add the header "translate:f" to tell IIS that it should 
    // allow the user to excecute this VERB on the specified path which it 
    // would not allow (in some cases) otherwise. Finally, there is a special 
    // flag in the metabase to allow for uploading of "dangerous" content 
    // (anything that can be run on the server). This is the ScriptSourceAccess
    // flag in the UI or the AccessSource flag in the metabase. You will need
    // to set this bit to true as well as correct NT ACLs in order to be able
    // to upload .exes or anything executable.
    //
    ReturnVal = HttpAddRequestHeadersA(hRequest,
                                       "translate: f\n",
                                       -1,
                                       HTTP_ADDREQ_FLAG_ADD |
                                       HTTP_ADDREQ_FLAG_REPLACE );
    if (!ReturnVal) {
        dwError = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavSetProperties/HttpAddRequestHeadersA. Error Val = %d\n",
                  dwError));
        goto EXIT_THE_FUNCTION;
    }

    dwError = DavAttachPassportCookie(DavWorkItem,hRequest,&PassportCookie);
    if (dwError != ERROR_SUCCESS) {
        goto EXIT_THE_FUNCTION;
    }

    dwError = DavInternetSetOption(DavWorkItem,hRequest);
    if (dwError != ERROR_SUCCESS) {
        goto EXIT_THE_FUNCTION;
    }

    ReturnVal = HttpSendRequestA(hRequest,
                                 rgXmlHeader,
                                 strlen(rgXmlHeader),
                                 (LPVOID)lpPropertiesBuffer,
                                 strlen(lpPropertiesBuffer));
    if (!ReturnVal) {
        dwError = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavSetProperties/HttpSendRequestA: Error Val = %d\n",
                  dwError));
        goto EXIT_THE_FUNCTION;
    }

    dwError = DavQueryAndParseResponse(hRequest);
    if (dwError != ERROR_SUCCESS) {
        SetLastError(dwError);                
        DavPrint((DEBUG_ERRORS, 
                  "DavSetProperties/DavQueryAndParseResponse: Error Val = %d\n", 
                  dwError));
        goto EXIT_THE_FUNCTION;
    }
    
    dwError = DavParseXmlResponse(hRequest, NULL, NULL);
    if (dwError != ERROR_SUCCESS) {
        SetLastError(dwError);
        DavPrint((DEBUG_ERRORS,
                  "DavSetProperties/DavParseXmlResponse: dwError = %d\n",
                  dwError));
        goto EXIT_THE_FUNCTION;    
    }
    
EXIT_THE_FUNCTION:
    
    if (hRequest) {
        InternetCloseHandle(hRequest);    
    }
    
    if (PassportCookie) {
        LocalFree(PassportCookie);
    }
    
    return dwError;
}


DWORD
DavTestProppatch(
    PDAV_USERMODE_WORKITEM DavWorkItem,
    HINTERNET hDavConnect,
    LPWSTR  lpPathName
)
/*++

Routine Description:

    This routine tests whether DAV properties can be set on this root directory.
    
Arguments:

    DavConnectHandle - Server connection.

Return Value:

    ERROR_SUCCESS or Win32 Error Code.

--*/
{
    CHAR *lpTemp = NULL, Buffer[1024];
    DWORD dwError = ERROR_SUCCESS, dwSizeRemaining, dwTemp;    
    
    memset(Buffer, 0, sizeof(Buffer));    
    
    dwSizeRemaining = sizeof(Buffer);
        
    lpTemp = Buffer;
    
    memcpy(lpTemp, rgPropPatchHeader, (sizeof(rgPropPatchHeader)-1));

    lpTemp += (sizeof(rgPropPatchHeader)-1);

    dwSizeRemaining -= (sizeof(rgPropPatchHeader)-1);
    
    dwTemp = dwSizeRemaining;
    
    memcpy(lpTemp, rgDummyAttributes, sizeof(rgDummyAttributes)-1);
    lpTemp += (sizeof(rgDummyAttributes)-1);
    
    memcpy(lpTemp, rgPropPatchTrailer, sizeof(rgPropPatchTrailer)-1);

    dwError = DavSetProperties(DavWorkItem, hDavConnect, lpPathName, Buffer);
    
    return dwError;
}


DWORD
DavUnLockTheFileOnTheServer(
    IN PDAV_USERMODE_WORKITEM DavWorkItem
    )
/*++

Routine Description:

    This routine is called during create or close when we need to UNLOCK the
    file on the server. We unlock the file when the handle whose create LOCKed
    the file is closed or if the Create failed after LOCKing the file.

Arguments:

    DavWorkItem - The buffer that contains the request parameters and options.

Return Value:

    ERROR_SUCCESS or the appropriate error code.

--*/
{
    DWORD WStatus = ERROR_SUCCESS;
    HINTERNET DavConnHandle = NULL, DavOpenHandle = NULL;
    PWCHAR LockTokenHeader = NULL, PassportCookie = NULL, UnLockPathName = NULL;
    PWCHAR OpaqueLockToken = NULL;
    ULONG LockTokenHeaderLengthInBytes = 0;
    BOOL BStatus = FALSE, ReturnVal = FALSE;
    PDAV_USERMODE_CLOSE_REQUEST CloseRequest = NULL;
    PDAV_USERMODE_CREATE_RESPONSE CreateResponse = NULL;

    //
    // An UNLOCK request can come from Create or Close Paths.
    // 1. If the Create call in the usermode fails after the file has been
    //    LOCKed, it is UNLOCKed before the call is completed.
    // 2. A file that was LOCKed on Create is UNLOCKed when the handle is
    //    closed.
    //

    if (DavWorkItem->WorkItemType == UserModeCreate) {
        CreateResponse = &(DavWorkItem->CreateResponse);
        DavConnHandle = DavWorkItem->AsyncCreate.PerUserEntry->DavConnHandle;
        UnLockPathName = DavWorkItem->AsyncCreate.RemPathName;
        OpaqueLockToken = CreateResponse->OpaqueLockToken;
    } else {
        CloseRequest = &(DavWorkItem->CloseRequest);
        ASSERT(DavWorkItem->WorkItemType == UserModeClose);
        ASSERT(CloseRequest->OpaqueLockToken != NULL);
        DavConnHandle = DavWorkItem->AsyncClose.PerUserEntry->DavConnHandle;
        UnLockPathName = &(CloseRequest->PathName[1]);
        OpaqueLockToken = CloseRequest->OpaqueLockToken;
    }

    //
    // Convert the unicode object name to UTF-8 URL format.
    // Space and other white characters will remain untouched - these should
    // be taken care of by wininet calls. 
    // This has to be a W API as the name in CloseRequest is unicode.
    //
    BStatus = DavHttpOpenRequestW(DavConnHandle,
                                  L"UNLOCK",
                                  UnLockPathName,
                                  L"HTTP/1.1",
                                  NULL,
                                  NULL,
                                  INTERNET_FLAG_KEEP_CONNECTION |
                                  INTERNET_FLAG_NO_COOKIES |
                                  INTERNET_FLAG_RELOAD,
                                  0,
                                  L"DavUnLockTheFileOnTheServer",
                                  &DavOpenHandle);
    if(BStatus == FALSE) {
        WStatus = GetLastError();
        goto EXIT_THE_FUNCTION;
    }
    if (DavOpenHandle == NULL) {
        WStatus = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavUnLockTheFileOnTheServer/DavHttpOpenRequestW. Error Val = %d\n",
                  WStatus));
        goto EXIT_THE_FUNCTION;
    }

    //
    // We need to add the header "translate:f" to tell IIS that it should 
    // allow the user to excecute this VERB on the specified path which it 
    // would not allow (in some cases) otherwise. Finally, there is a special 
    // flag in the metabase to allow for uploading of "dangerous" content 
    // (anything that can be run on the server). This is the ScriptSourceAccess
    // flag in the UI or the AccessSource flag in the metabase. You will need
    // to set this bit to true as well as correct NT ACLs in order to be able
    // to upload .exes or anything executable. We set this header on all requests
    // that are sent to the server including the UNLOCK request.
    //
    ReturnVal = HttpAddRequestHeadersW(DavOpenHandle,
                                       L"translate: f\n",
                                       -1,
                                       HTTP_ADDREQ_FLAG_ADD |
                                       HTTP_ADDREQ_FLAG_REPLACE);
    if (!ReturnVal) {
        WStatus = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavUnLockTheFileOnTheServer/HttpAddRequestHeadersW. Error Val = %d\n",
                  WStatus));
        goto EXIT_THE_FUNCTION;
    }

    WStatus = DavAttachPassportCookie(DavWorkItem, DavOpenHandle, &PassportCookie);
    if (WStatus != ERROR_SUCCESS) {
        DavPrint((DEBUG_ERRORS,
                  "DavUnLockTheFileOnTheServer/DavAttachPassportCookie. Error Val = %d\n",
                  WStatus));
        goto EXIT_THE_FUNCTION;
    }

    WStatus = DavInternetSetOption(DavWorkItem, DavOpenHandle);
    if (WStatus != ERROR_SUCCESS) {
        DavPrint((DEBUG_ERRORS,
                  "DavUnLockTheFileOnTheServer/DavInternetSetOption. Error Val = %d\n",
                  WStatus));
        goto EXIT_THE_FUNCTION;
    }

    LockTokenHeaderLengthInBytes = (1 + wcslen(L"Lock-Token: ")) * sizeof(WCHAR);

    if (DavWorkItem->WorkItemType == UserModeCreate) {

        //
        // CreateResponse->OpaqueLockToken has the following format.
        // <opaquelocktoken:sdfsadfsdfdsfd.....>
        // and we need to create a header of the following format.
        // Lock-Token: <opaquelocktoken:sdfsadfsdfdsfd.....>
        //

        LockTokenHeaderLengthInBytes += (wcslen(OpaqueLockToken)) * sizeof(WCHAR);

        LockTokenHeader = LocalAlloc(LPTR, LockTokenHeaderLengthInBytes);
        if (LockTokenHeader == NULL) {
            WStatus = GetLastError();
            DavPrint((DEBUG_ERRORS,
                      "DavUnLockTheFileOnTheServer/LocalAlloc. Error Val = %d\n",
                      WStatus));
            goto EXIT_THE_FUNCTION;
        }

        wcsncpy(LockTokenHeader, L"Lock-Token: ", wcslen(L"Lock-Token: "));

        wcsncpy((LockTokenHeader + wcslen(L"Lock-Token: ")),
                OpaqueLockToken,
                wcslen(OpaqueLockToken));

    } else {

        //
        // CloseRequest->OpaqueLockToken has the following format.
        // If: (<opaquelocktoken:sdfsadfsdfdsfd.....>)
        // and we need to create a header of the following format.
        // Lock-Token: <opaquelocktoken:sdfsadfsdfdsfd.....>
        //

        //
        // We don't need first 5 chars "If: (" and the last ")" char. So we subtract
        // 6 from the total length of CloseRequest->OpaqueLockToken.
        //
        LockTokenHeaderLengthInBytes += (wcslen(OpaqueLockToken) - 6) * sizeof(WCHAR);

        LockTokenHeader = LocalAlloc(LPTR, LockTokenHeaderLengthInBytes);
        if (LockTokenHeader == NULL) {
            WStatus = GetLastError();
            DavPrint((DEBUG_ERRORS,
                      "DavUnLockTheFileOnTheServer/LocalAlloc. Error Val = %d\n",
                      WStatus));
            goto EXIT_THE_FUNCTION;
        }

        wcsncpy(LockTokenHeader, L"Lock-Token: ", wcslen(L"Lock-Token: "));

        wcsncpy((LockTokenHeader + wcslen(L"Lock-Token: ")),
                (OpaqueLockToken + wcslen(L"If: (")),
                (wcslen(OpaqueLockToken) - 6));

    }

    DavPrint((DEBUG_MISC,
              "DavUnLockTheFileOnTheServer: LockTokenHeader = %ws\n",
              LockTokenHeader));

    ReturnVal = HttpAddRequestHeadersW(DavOpenHandle,
                                       LockTokenHeader,
                                       -1,
                                       HTTP_ADDREQ_FLAG_ADD |
                                       HTTP_ADDREQ_FLAG_REPLACE);
    if (!ReturnVal) {
        WStatus = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavUnLockTheFileOnTheServer/HttpAddRequestHeadersW. Error Val = %d\n",
                  WStatus));
        goto EXIT_THE_FUNCTION;
    }

RESEND_THE_REQUEST:

    ReturnVal = HttpSendRequestExW(DavOpenHandle, 
                                   NULL, 
                                   NULL, 
                                   HSR_SYNC,
                                   (ULONG_PTR)0);
   if (!ReturnVal) {
       WStatus = GetLastError();
       DavPrint((DEBUG_ERRORS,
                 "DavUnLockTheFileOnTheServer/HttpSendRequestExW. Error Val = %d\n", 
                 WStatus));
       goto EXIT_THE_FUNCTION;
   }

   ReturnVal = HttpEndRequestW(DavOpenHandle, 
                               NULL, 
                               HSR_SYNC,
                               (ULONG_PTR)0);
   if (!ReturnVal) {
       WStatus = GetLastError();
       //
       // If the error we got back is ERROR_INTERNET_FORCE_RETRY, then WinInet
       // is trying to authenticate itself with the server. If we get back
       // ERROR_HTTP_REDIRECT_NEEDS_CONFIRMATION, WinInet is expecting us to
       // confirm that the redirect needs to be followed. In these scenarios,
       // we need to repeat the HttpSend and HttpEnd request calls.
       //
       if (WStatus == ERROR_INTERNET_FORCE_RETRY || WStatus == ERROR_HTTP_REDIRECT_NEEDS_CONFIRMATION) {
           goto RESEND_THE_REQUEST;
       }
       DavPrint((DEBUG_ERRORS,
                 "DavUnLockTheFileOnTheServer/HttpEndRequestW. Error Val = %d\n", 
                 WStatus));
       goto EXIT_THE_FUNCTION;
   }

   WStatus = DavQueryAndParseResponse(DavOpenHandle);
   if (WStatus != ERROR_SUCCESS) {
       DavPrint((DEBUG_ERRORS,
                 "DavUnLockTheFileOnTheServer/DavQueryAndParseResponse. WStatus = %d\n",
                 WStatus));
   }

EXIT_THE_FUNCTION:

    if (DavOpenHandle != NULL) {
        InternetCloseHandle(DavOpenHandle);
        DavOpenHandle = NULL;
    }

    if (PassportCookie) {
        LocalFree(PassportCookie);
        PassportCookie = NULL;
    }

    if (LockTokenHeader) {
        LocalFree(LockTokenHeader);
        LockTokenHeader = NULL;
    }

    return WStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\kernel\srvcall.c ===
/*++ 

Copyright (c) 1999  Microsoft Corporation

Module Name:

    srvcall.c

Abstract:

    This module implements the routines for handling the creation/manipulation 
    of server entries in the connection engine database. 

Author:

    Balan Sethu Raman  [SethuR]
    
    Rohan Kumar        [RohanK]       04-April-1999

--*/

#include "precomp.h"
#pragma hdrstop
#include "webdav.h"

//
// Mentioned below are the prototypes of functions tht are used only within
// this module (file). These functions should not be exposed outside.
//

VOID
MRxDAVSrvCallWrapper(
    PVOID Context
    );

NTSTATUS
MRxDAVCreateSrvCallContinuation(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE
    );

NTSTATUS
MRxDAVFormatUserModeSrvCallCreateRequest(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE,
    PUMRX_USERMODE_WORKITEM_HEADER WorkItemHeader,
    ULONG WorkItemLength,
    PULONG_PTR ReturnedLength
    );

BOOL
MRxDAVPrecompleteUserModeSrvCallCreateRequest(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE,
    PUMRX_USERMODE_WORKITEM_HEADER WorkItemHeader,
    ULONG WorkItemLength,
    BOOL OperationCancelled
    );

NTSTATUS
MRxDAVFinalizeSrvCallContinuation(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE
    );

NTSTATUS
MRxDAVFormatUserModeSrvCallFinalizeRequest(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE,
    PUMRX_USERMODE_WORKITEM_HEADER WorkItemHeader,
    ULONG WorkItemLength,
    PULONG_PTR ReturnedLength
    );

BOOL
MRxDAVPrecompleteUserModeSrvCallFinalizeRequest(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE,
    PUMRX_USERMODE_WORKITEM_HEADER WorkItemHeader,
    ULONG WorkItemLength,
    BOOL OperationCancelled
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, MRxDAVCreateSrvCall)
#pragma alloc_text(PAGE, MRxDAVSrvCallWrapper)
#pragma alloc_text(PAGE, MRxDAVCreateSrvCallContinuation)
#pragma alloc_text(PAGE, MRxDAVFormatUserModeSrvCallCreateRequest)
#pragma alloc_text(PAGE, MRxDAVPrecompleteUserModeSrvCallCreateRequest)
#pragma alloc_text(PAGE, MRxDAVFinalizeSrvCall)
#pragma alloc_text(PAGE, MRxDAVFinalizeSrvCallContinuation)
#pragma alloc_text(PAGE, MRxDAVFormatUserModeSrvCallFinalizeRequest)
#pragma alloc_text(PAGE, MRxDAVPrecompleteUserModeSrvCallFinalizeRequest)
#pragma alloc_text(PAGE, MRxDAVSrvCallWinnerNotify)
#endif

//
// Implementation of functions begins here.
//

NTSTATUS
MRxDAVCreateSrvCall(
    PMRX_SRV_CALL SrvCall,
    PMRX_SRVCALL_CALLBACK_CONTEXT CallbackContext
    )
/*++

Routine Description:

   This routine handles the creation of SrvCalls.

Arguments:

    SrvCall - 

    CallBackContext  - the call back context in RDBSS for continuation.

Return Value:

    RXSTATUS - The return status for the operation

Notes:

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PMRX_SRVCALL_CALLBACK_CONTEXT SCCBC = CallbackContext;
    PMRX_SRVCALLDOWN_STRUCTURE SrvCalldownStructure = NULL;
    PRX_CONTEXT RxContext = NULL;

    PAGED_CODE();

#if 1
    
    SrvCalldownStructure = (PMRX_SRVCALLDOWN_STRUCTURE)(CallbackContext->SrvCalldownStructure);
    
    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Entering MRxDAVCreateSrvCall!!!!\n",
                 PsGetCurrentThreadId()));

    DavDbgTrace(DAV_TRACE_CONTEXT,
                ("%ld: MRxDAVCreateSrvCall: SrvCall: %08lx, CallbackContext: "
                 "%08lx.\n", PsGetCurrentThreadId(), SrvCall, CallbackContext));

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVCreateSrvCall: SrvCallName: %wZ\n",
                 PsGetCurrentThreadId(), SrvCall->pSrvCallName));

    //
    // Perform the following checks.
    //
    ASSERT(NodeType(SrvCall) == RDBSS_NTC_SRVCALL);
    ASSERT(SrvCall);
    ASSERT(SrvCall->pSrvCallName);
    ASSERT(SrvCall->pSrvCallName->Buffer);
    ASSERT(SCCBC->RxDeviceObject);

    //
    // Before delaying the final close, RDBSS looks at the number of closes that
    // have been delayed and compares it against this value.
    //
    SrvCall->MaximumNumberOfCloseDelayedFiles = 150;

    //
    // Allocate memory for the context pointer in the SrvCall structure. This is
    // for the Mini-Redirs use.
    //
    ASSERT(SrvCall->Context == NULL);
    SrvCall->Context = RxAllocatePoolWithTag(NonPagedPool,
                                             sizeof(WEBDAV_SRV_CALL),
                                             DAV_SRVCALL_POOLTAG);
    if (SrvCall->Context == NULL) {
        //
        // There was an error in dispatching the MRxDAVSrvCallWrapper method to
        // a worker thread. Complete the request and return STATUS_PENDING.
        //
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: MRxDAVCreateSrvCall/RxAllocatePoolWithTag.\n",
                     PsGetCurrentThreadId()));
        SCCBC->Status = STATUS_INSUFFICIENT_RESOURCES;
        SrvCalldownStructure->CallBack(SCCBC);
        NtStatus = STATUS_PENDING;
        return NtStatus;
    }

    RtlZeroMemory(SrvCall->Context, sizeof(WEBDAV_SRV_CALL));

    //
    // Check to see if the DAV server mentioned in the SrvCall exists. To do 
    // this, we need to go to the usermode and call GetHostByName on the name
    // mentioned in the SrvCall strucutre.
    //
    RxContext = SrvCalldownStructure->RxContext;

    //
    // We need to pass the server name to the user mode to check whether such a 
    // server actually exists. RxContext has 4 pointers that the mini-redirs 
    // can use. Here we use MRxContext[1]. We store a reference to the SCCBC
    // strucutre which contains the name of the server. MRxContext[0] is used to 
    // store a reference to the AsynEngineContext and this is done when the 
    // context gets created in the function UMRxCreateAsyncEngineContext. The
    // pointer to SCCBC is also used while calling the callback function to
    // complete the creation of the SrvCall.
    //
    RxContext->MRxContext[1] = SCCBC;

    //
    // Dispatch the request to a system thread.
    //
    NtStatus = RxDispatchToWorkerThread((PRDBSS_DEVICE_OBJECT)MRxDAVDeviceObject,
                                        DelayedWorkQueue,
                                        MRxDAVSrvCallWrapper,
                                        RxContext);
    if (NtStatus == STATUS_SUCCESS) {
        //
        // Map the return value since the wrapper expects STATUS_PENDING.
        //
        NtStatus = STATUS_PENDING;
    } else {
        //
        // There was an error in dispatching the MRxDAVSrvCallWrapper method to
        // a worker thread. Complete the request and return STATUS_PENDING.
        //
        SCCBC->Status = NtStatus;
        SrvCalldownStructure->CallBack(SCCBC);
        NtStatus = STATUS_PENDING;
    }

#else 
    
    SCCBC->Status = STATUS_SUCCESS;
    SrvCalldownStructure->CallBack(SCCBC);
    NtStatus = STATUS_PENDING;

#endif

    return(NtStatus);
}


VOID
MRxDAVSrvCallWrapper(
    PVOID Context
    )
/*++

Routine Description:

   This routine is called by the worker thread. Its a routine that wraps the 
   call to MRxDAVOuterWrapper.

Arguments:

    RxContext - The RDBSS context.

Return Value:

    RXSTATUS - The return status for the operation

Notes:

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PRX_CONTEXT RxContext = (PRX_CONTEXT)Context;
    PMRX_SRVCALL_CALLBACK_CONTEXT SCCBC = NULL;
    PMRX_SRVCALLDOWN_STRUCTURE SrvCalldownStructure = NULL;
    PMRX_SRV_CALL SrvCall = NULL;
    PWEBDAV_SRV_CALL DavSrvCall = NULL;

    PAGED_CODE();

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Entering MRxDAVSrvCallWrapper!!!!\n",
                 PsGetCurrentThreadId()));

    DavDbgTrace(DAV_TRACE_CONTEXT,
                ("%ld: MRxDAVSrvCallWrapper: RxContext: %08lx.\n", 
                 PsGetCurrentThreadId(), RxContext));

    NtStatus = UMRxAsyncEngOuterWrapper(RxContext,
                                        SIZEOF_DAV_SPECIFIC_CONTEXT,
                                        MRxDAVFormatTheDAVContext,
                                        DAV_MINIRDR_ENTRY_FROM_CREATESRVCALL,
                                        MRxDAVCreateSrvCallContinuation,
                                        "MRxDAVCreateSrvCall");

    //
    // If we failed to queue the request to be sent to the usermode, then we
    // need to do some cleanup. If NtStatus is STATUS_CANCELLED then we would
    // have already done the cleanup in the MRxDAVHandleCreateSrvCallCancellation
    // funtcion. Hence we don't need to do it now.
    //
    if (NtStatus != STATUS_SUCCESS &&  NtStatus != STATUS_PENDING &&  NtStatus != STATUS_CANCELLED) {

        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: ERROR: MRxDAVSrvCallWrapper/UMRxAsyncEngOuterWrapper: "
                     "NtStatus = %08lx\n", PsGetCurrentThreadId(), NtStatus));

        //
        // The SrvCall pointer is stored in the SCCBC structure which is
        // stored in the MRxContext[1] pointer of the RxContext structure.
        // This is done in the MRxDAVCreateSrvCall function.
        //
        ASSERT(RxContext->MRxContext[1] != NULL);
        SCCBC = (PMRX_SRVCALL_CALLBACK_CONTEXT)RxContext->MRxContext[1];

        SrvCalldownStructure = SCCBC->SrvCalldownStructure;
        ASSERT(SrvCalldownStructure != NULL);

        SrvCall = SrvCalldownStructure->SrvCall;
        ASSERT(SrvCall != NULL);

        DavSrvCall = MRxDAVGetSrvCallExtension(SrvCall);
        ASSERT(DavSrvCall != NULL);

        //
        // Free the memory that was allocatted for the SecurityClientContext in
        // the function MRxDAVFormatTheDAVContext. Before Freeing the memory, we
        // need to delete the SecurityClientContext.
        //
        if (DavSrvCall->SCAlreadyInitialized) {
            ASSERT(RxContext->MRxContext[2] != NULL);
            SeDeleteClientSecurity((PSECURITY_CLIENT_CONTEXT)RxContext->MRxContext[2]);
            RxFreePool(RxContext->MRxContext[2]);
            RxContext->MRxContext[2] = NULL;
            DavSrvCall->SCAlreadyInitialized = FALSE;
        }

        SCCBC->Status = NtStatus;
        SrvCalldownStructure->CallBack(SCCBC);

    }

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Leaving MRxDAVSrvCallWrapper with NtStatus = %08lx.\n",
                 PsGetCurrentThreadId(), NtStatus));

    return;
}


NTSTATUS
MRxDAVCreateSrvCallContinuation(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE
    )
/*++
                                
Routine Description:
                            
    This routine checks to see if the server for which a SrvCall is being
    created exists or not.
                            
Arguments:
                            
    AsyncEngineContext - The Reflectors context.
                            
    RxContext - The RDBSS context.
                                
Return Value:
                            
    RXSTATUS - The return status for the operation
                            
--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    PAGED_CODE();

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Entering MRxDAVCreateSrvCallContinuation!!!!\n",
                 PsGetCurrentThreadId()));

    DavDbgTrace(DAV_TRACE_CONTEXT,
                ("%ld: MRxDAVCreateSrvCallContinuation: "
                 "AsyncEngineContext: %08lx, RxContext: %08lx\n", 
                 PsGetCurrentThreadId(), AsyncEngineContext, RxContext));

    //
    // We are executing in the context of a worker thread. No point in holding
    // onto this thread. Set the Async flag irrespective of the nature of the
    // request. By nature we mean sync or async. Also since CreateSrvCall has 
    // its own Callback, we do not need to call RxLowIoCompletion when the
    // AsyncEngineContext is getting finalized.
    //
    SetFlag(AsyncEngineContext->Flags, UMRX_ASYNCENG_CTX_FLAG_ASYNC_OPERATION);
    AsyncEngineContext->ShouldCallLowIoCompletion = FALSE;

    //
    // Try usermode.
    //
    NtStatus = UMRxSubmitAsyncEngUserModeRequest(
                                UMRX_ASYNCENGINE_ARGUMENTS,
                                MRxDAVFormatUserModeSrvCallCreateRequest,
                                MRxDAVPrecompleteUserModeSrvCallCreateRequest
                                );

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Leaving MRxDAVCreateSrvCallContinuation with NtStatus ="
                 " %08lx.\n", PsGetCurrentThreadId(), NtStatus));

    return NtStatus;
}
    

NTSTATUS
MRxDAVFormatUserModeSrvCallCreateRequest(
    IN UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE,
    IN OUT PUMRX_USERMODE_WORKITEM_HEADER WorkItemHeader,
    IN ULONG WorkItemLength,
    OUT PULONG_PTR ReturnedLength
    )
/*++

Routine Description:

    This routine formats the SrvCall create request being sent to the user mode 
    for processing.

Arguments:
    
    RxContext - The RDBSS context.
    
    AsyncEngineContext - The reflctor's context.
    
    WorkItem - The work item buffer.
    
    WorkItemLength - The length of the work item buffer.
    
    ReturnedLength - 
    
Return Value:

    STATUS_SUCCESS or STATUS_INSUFFICIENT_RESOURCES.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PDAV_USERMODE_WORKITEM DavWorkItem = (PDAV_USERMODE_WORKITEM)WorkItemHeader;
    PMRX_SRVCALL_CALLBACK_CONTEXT SCCBC = NULL;
    PMRX_SRV_CALL SrvCall = NULL;
    PWCHAR ServerName = NULL;
    DWORD ServerNameLenInBytes = 0;
    PBYTE SecondaryBuff = NULL;
    PDAV_USERMODE_CREATE_SRVCALL_REQUEST SrvCallCreateReq = NULL;
    PSECURITY_CLIENT_CONTEXT SecurityClientContext = NULL;
    PSECURITY_SUBJECT_CONTEXT SecSubCtx = NULL;
    PNT_CREATE_PARAMETERS NtCP = &(RxContext->Create.NtCreateParameters);
    PACCESS_TOKEN AccessToken = NULL;

    PAGED_CODE();

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Entering MRxDAVFormatUserModeSrvCallCreateRequest!!!!\n",
                 PsGetCurrentThreadId()));

    DavDbgTrace(DAV_TRACE_CONTEXT,
                ("%ld: MRxDAVFormatUserModeSrvCallCreateRequest: "
                 "AsyncEngineContext: %08lx, RxContext: %08lx.\n",
                 PsGetCurrentThreadId(), AsyncEngineContext, RxContext));
    
    SrvCallCreateReq = &(DavWorkItem->CreateSrvCallRequest);
    
    //
    // Get the SecuritySubjectContext.
    //
    ASSERT(NtCP->SecurityContext->AccessState != NULL);
    SecSubCtx = &(NtCP->SecurityContext->AccessState->SubjectSecurityContext);

    //
    // Get the AccessToken.
    //
    AccessToken = SeQuerySubjectContextToken(SecSubCtx);
    
    //
    // Get the LogonID for this user/session.
    //
    if (!SeTokenIsRestricted(AccessToken)) {
        NtStatus = SeQueryAuthenticationIdToken(AccessToken, 
                                                &(SrvCallCreateReq->LogonID));
        if (NtStatus != STATUS_SUCCESS) {
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: ERROR: MRxDAVFormatUserModeCreateSrvCallRequest/"
                         "SeQueryAuthenticationIdToken. NtStatus = %08lx.\n", 
                         PsGetCurrentThreadId(), NtStatus));
            goto EXIT_THE_FUNCTION;
        }
    } else {
        NtStatus = STATUS_ACCESS_DENIED;
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: ERROR: MRxDAVFormatUserModeCreateSrvCallRequest/"
                     "SeTokenIsRestricted. NtStatus = %08lx.\n", 
                     PsGetCurrentThreadId(), NtStatus));
        goto EXIT_THE_FUNCTION;
    }
    
    //
    // Impersonate the client who initiated the request. If we fail to 
    // impersonate, tough luck. The SecurityClientContext is stored in
    // RxContext->MRxContext[2]. This was done in MRxDAVFormatTheDAVContext.
    //
    ASSERT(RxContext->MRxContext[2] != NULL);
    SecurityClientContext = (PSECURITY_CLIENT_CONTEXT)RxContext->MRxContext[2];
    if (SecurityClientContext != NULL) {
        NtStatus = UMRxImpersonateClient(SecurityClientContext, WorkItemHeader);
        if (!NT_SUCCESS(NtStatus)) {
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: ERROR: MRxDAVFormatUserModeCreateSrvCallRequest/"
                         "UMRxImpersonateClient. NtStatus = %08lx.\n", 
                         PsGetCurrentThreadId(), NtStatus));
            goto EXIT_THE_FUNCTION;
        }   
    } else {
        NtStatus = STATUS_INVALID_PARAMETER;
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: ERROR: MRxDAVFormatUserModeCreateSrvCallRequest: "
                     "SecurityClientContext is NULL.\n", 
                     PsGetCurrentThreadId()));
        goto EXIT_THE_FUNCTION;
    }

    DavWorkItem->WorkItemType = UserModeCreateSrvCall;

    SCCBC = (PMRX_SRVCALL_CALLBACK_CONTEXT)RxContext->MRxContext[1];
    SrvCall = SCCBC->SrvCalldownStructure->SrvCall;

    //
    // Set the name of the server to be verified. We need to allocate memory
    // for the UserModeInfoBuff before filling in the ServerName in it.
    //
    ASSERT(SrvCall->pSrvCallName);
    ServerName = &(SrvCall->pSrvCallName->Buffer[1]);
    ServerNameLenInBytes = (1 + wcslen(ServerName)) * sizeof(WCHAR);
    SecondaryBuff = UMRxAllocateSecondaryBuffer(AsyncEngineContext, 
                                                ServerNameLenInBytes);
    if (SecondaryBuff == NULL) {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("ld: MRxDAVFormatUserModeSrvCallCreateRequest/"
                     "UMRxAllocateSecondaryBuffer: ERROR: NtStatus = %08lx.\n",
                     PsGetCurrentThreadId(), NtStatus));
        goto EXIT_THE_FUNCTION;
    }
    
    SrvCallCreateReq->ServerName = (PWCHAR)SecondaryBuff;
    wcscpy(SrvCallCreateReq->ServerName, ServerName);

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("ld: MRxDAVFormatUserModeSrvCallCreateRequest: ServerName = %ws\n",
                 PsGetCurrentThreadId(), SrvCallCreateReq->ServerName));

    if (RxContext->Create.UserName.Length) {
        RtlCopyMemory(DavWorkItem->UserName,RxContext->Create.UserName.Buffer,RxContext->Create.UserName.Length);
    }

    if (RxContext->Create.Password.Length) {
        RtlCopyMemory(DavWorkItem->Password,RxContext->Create.Password.Buffer,RxContext->Create.Password.Length);
    }

EXIT_THE_FUNCTION:

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Leaving MRxDAVFormatUserModeSrvCallCreateRequest with "
                 "NtStatus = %08lx.\n", PsGetCurrentThreadId(), NtStatus));
    
    return NtStatus;
}


BOOL
MRxDAVPrecompleteUserModeSrvCallCreateRequest(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE,
    PUMRX_USERMODE_WORKITEM_HEADER WorkItemHeader,
    ULONG WorkItemLength,
    BOOL OperationCancelled
    )
/*++

Routine Description:

    The precompletion routine for the create SrvCall request.

Arguments:

    RxContext - The RDBSS context.
    
    AsyncEngineContext - The reflctor's context.
    
    WorkItem - The work item buffer.
    
    WorkItemLength - The length of the work item buffer.
    
    OperationCancelled - TRUE if this operation was cancelled by the user.

Return Value:

    FALSE - UMRxAsyncEngineCalldownIrpCompletion is NOT called by the function
            UMRxCompleteUserModeRequest after we return.    

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PDAV_USERMODE_WORKITEM WorkItem = (PDAV_USERMODE_WORKITEM)WorkItemHeader;
    PMRX_SRVCALL_CALLBACK_CONTEXT SCCBC = NULL;
    PMRX_SRVCALLDOWN_STRUCTURE SrvCalldownStructure = NULL;
    PMRX_SRV_CALL SrvCall = NULL;
    PDAV_USERMODE_CREATE_SRVCALL_REQUEST SrvCallCreateReq = NULL;
    PDAV_USERMODE_CREATE_SRVCALL_RESPONSE CreateSrvCallResponse = NULL; 
    BOOL didFinalize = FALSE;                                          
    PWEBDAV_SRV_CALL DavSrvCall = NULL;
    BOOL AsyncOperation = FALSE;

    PAGED_CODE();

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Entering MRxDAVPrecompleteUserModeSrvCallCreateRequest!!!!\n",
                 PsGetCurrentThreadId()));

    DavDbgTrace(DAV_TRACE_CONTEXT,
                ("%ld: MRxDAVPrecompleteUserModeSrvCallCreateRequest: "
                 "AsyncEngineContext: %08lx, RxContext: %08lx.\n",
                 PsGetCurrentThreadId(), AsyncEngineContext, RxContext));

    AsyncOperation = FlagOn(AsyncEngineContext->Flags, UMRX_ASYNCENG_CTX_FLAG_ASYNC_OPERATION);
    ASSERT(AsyncOperation == TRUE);

    //
    // We do the following only if the Operation has not been cancelled. If it
    // has been then this would have been done by the timer thread.
    //
    if (!OperationCancelled) {

        SCCBC = (PMRX_SRVCALL_CALLBACK_CONTEXT)RxContext->MRxContext[1];
        ASSERT(SCCBC != NULL);
        SrvCalldownStructure = SCCBC->SrvCalldownStructure;
        ASSERT(SrvCalldownStructure != NULL);
        SrvCall = SrvCalldownStructure->SrvCall;
        ASSERT(SrvCall != NULL);

        //
        // We allocated memory for it, so it better not be NULL.
        //
        DavSrvCall = MRxDAVGetSrvCallExtension(SrvCall);
        ASSERT(DavSrvCall != NULL);

        //
        // Free the memory that was allocatted for the SecurityClientContext in the
        // function MRxDAVFormatTheDAVContext. Before Freeing the memory, we need
        // to delete the SecurityClientContext.
        //
        ASSERT(DavSrvCall->SCAlreadyInitialized == TRUE);
        ASSERT(RxContext->MRxContext[2] != NULL);
        SeDeleteClientSecurity((PSECURITY_CLIENT_CONTEXT)RxContext->MRxContext[2]);
        RxFreePool(RxContext->MRxContext[2]);
        RxContext->MRxContext[2] = NULL;
        DavSrvCall->SCAlreadyInitialized = FALSE;

    } else {

        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: MRxDAVPrecompleteUserModeSrvCallCreateRequest: Operation Cancelled. "
                     "AsyncEngineContext = %08lx, RxContext = %08lx.\n",
                     PsGetCurrentThreadId(), AsyncEngineContext, RxContext));

    }

    SrvCallCreateReq = &(WorkItem->CreateSrvCallRequest);
    CreateSrvCallResponse = &(WorkItem->CreateSrvCallResponse);

    //
    // We need to free up the heap we allocated in the format routine.
    //
    if (SrvCallCreateReq->ServerName != NULL) {

        if (AsyncEngineContext->Status != STATUS_SUCCESS) {
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: ERROR: MRxDAVPrecompleteUserModeSrvCallCreateRequest."
                         " Server \"%ws\" is not a DAV server.\n",
                         PsGetCurrentThreadId(), SrvCallCreateReq->ServerName));
        }

        NtStatus = UMRxFreeSecondaryBuffer(AsyncEngineContext,
                                       (PBYTE)SrvCallCreateReq->ServerName);
        if (NtStatus != STATUS_SUCCESS) {
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: ERROR: MRxDAVPrecompleteUserModeSrvCallCreateRequest/"
                         "UMRxFreeSecondaryBuffer: NtStatus = %08lx.\n", 
                         PsGetCurrentThreadId(), NtStatus));
        }
    
    }

    if (!OperationCancelled) {
        
        //
        // Get this servers unique ID.
        //
        DavSrvCall->ServerID = CreateSrvCallResponse->ServerID;
        
        DavDbgTrace(DAV_TRACE_DETAIL,
                    ("%ld: MRxDAVPrecompleteUserModeSrvCallCreateRequest: "
                     "ServerID = %ld assigned to this server entry.\n", 
                     PsGetCurrentThreadId(), DavSrvCall->ServerID));

        //
        // Set the status in the callback structure.
        //
        SCCBC->Status = AsyncEngineContext->Status;

    }

    //
    // We call the first finalize here since we return STATUS_PENDING back to 
    // the continuation routine in the create srvcall case. So the reference 
    // that was made at the time of creation of the AsyncEngineContext is not 
    // removed in the wrapper routine. The second finalize is because, we do not
    // call UMRxAsyncEngineCalldownIrpCompletion.
    //
    didFinalize = UMRxFinalizeAsyncEngineContext( &(AsyncEngineContext) );
    didFinalize = UMRxFinalizeAsyncEngineContext( &(AsyncEngineContext) );

    if (!OperationCancelled) {
        //
        // Call the callback function supplied by RDBSS.
        //
        SrvCalldownStructure->CallBack(SCCBC);
    }
    
    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Leaving MRxDAVPrecompleteUserModeSrvCallCreateRequest.\n",
                 PsGetCurrentThreadId()));
    
    return FALSE;
}


NTSTATUS
MRxDAVFinalizeSrvCall(
    PMRX_SRV_CALL pSrvCall,
    BOOLEAN Force
    )
/*++

Routine Description:

   This routine destroys a given server call instance.

Arguments:

    pSrvCall  - The server call instance to be disconnected.

    Force     - TRUE if a disconnection is to be enforced immediately.

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PRX_CONTEXT RxContext = NULL;
    PRDBSS_DEVICE_OBJECT RxDeviceObject = pSrvCall->RxDeviceObject;
    PWEBDAV_SRV_CALL DavSrvCall;

    PAGED_CODE();

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Entering MRxDAVFinalizeSrvCall.\n", 
                 PsGetCurrentThreadId()));

    DavDbgTrace(DAV_TRACE_CONTEXT,
                ("%ld: MRxDAVFinalizeSrvCall: SrvCall: %08lx, Force: %d.\n",
                 PsGetCurrentThreadId(), pSrvCall, Force));
    
    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVFinalizeSrvCall: SrvCallName: %wZ\n",
                 PsGetCurrentThreadId(), pSrvCall->pSrvCallName));
    
    //
    // We allocated memory for pSrvCall->Context, so it better not be NULL.
    //
    ASSERT(pSrvCall != NULL);

    //
    // If the MiniRedir didn't get a chance to allocate a SrvCall, then we 
    // should return right away.
    //
    if (pSrvCall->Context == NULL) {
        DavDbgTrace(DAV_TRACE_DETAIL,
                    ("%ld: MRxDAVFinalizeSrvCall. pSrvCall->Context == NULL\n", 
                     PsGetCurrentThreadId()));
        return NtStatus;
    }

    ASSERT(pSrvCall->Context != NULL);

    //
    // If we did not create any server entry for this server in the user mode,
    // then we do not need to go to the user mode at all. This fact is 
    // indicated by the ServerID field in the WEBDAV_SRV_CALL strucutre. If the
    // ID value is zero, that implies that the server entry was not created.
    //
    DavSrvCall = (PWEBDAV_SRV_CALL)pSrvCall->Context;
    if (DavSrvCall->ServerID == 0) {
        DavDbgTrace(DAV_TRACE_DETAIL,
                    ("%ld: No server entry was created in the user mode.\n",
                     PsGetCurrentThreadId()));
        goto EXIT_THE_FUNCTION;
    }

    //
    // Unfortunately, we do not have an RxContext here and hence have to create
    // one. An RxContext is required for a request to be reflected up.
    //
    RxContext = RxCreateRxContext(NULL, RxDeviceObject, 0);
    if (RxContext == NULL) {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: MRxDAVFinalizeSrvCall/RxCreateRxContext: "
                     "NtStatus = %08lx.\n", PsGetCurrentThreadId(), NtStatus));
        goto EXIT_THE_FUNCTION;
    }

    //
    // We need to send the SrvCall to the format routine and use the 
    // MRxContext[1] pointer of the RxContext structure to store it.
    //
    RxContext->MRxContext[1] = (PVOID)pSrvCall;

    NtStatus = UMRxAsyncEngOuterWrapper(RxContext,
                                        SIZEOF_DAV_SPECIFIC_CONTEXT,
                                        MRxDAVFormatTheDAVContext,
                                        DAV_MINIRDR_ENTRY_FROM_FINALIZESRVCALL,
                                        MRxDAVFinalizeSrvCallContinuation,
                                        "MRxDAVFinalizeSrvCall");
    if (NtStatus != ERROR_SUCCESS) {
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: MRxDAVFinalizeSrvCall/UMRxAsyncEngOuterWrapper: "
                     "NtStatus = %08lx.\n", PsGetCurrentThreadId(), NtStatus));
    }
    
EXIT_THE_FUNCTION:

    if (RxContext) {
        RxDereferenceAndDeleteRxContext(RxContext);
    }

    //
    // Free up the memory allocated for the context pointer.
    //
    RxFreePool(pSrvCall->Context);
    pSrvCall->Context = NULL;

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Leaving MRxDAVFinalizeSrvCall with NtStatus = %08lx.\n", 
                 PsGetCurrentThreadId(), NtStatus));
    
    return NtStatus;
}


NTSTATUS
MRxDAVFinalizeSrvCallContinuation(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE
    )
/*++
                                
Routine Description:
                            
    This is the continuation routine which finalizes a SrvCall.
                            
Arguments:
                            
    AsyncEngineContext - The Reflectors context.
                            
    RxContext - The RDBSS context.
                                
Return Value:
                            
    RXSTATUS - The return status for the operation
                            
--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    PAGED_CODE();

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Entering MRxDAVFinalizeSrvCallContinuation!!!!\n",
                 PsGetCurrentThreadId()));

    DavDbgTrace(DAV_TRACE_CONTEXT,
                ("%ld: MRxDAVFinalizeSrvCallContinuation: "
                 "AsyncEngineContext: %08lx, RxContext: %08lx\n", 
                 PsGetCurrentThreadId(), AsyncEngineContext, RxContext));

    //
    // Try usermode.
    //
    NtStatus = UMRxSubmitAsyncEngUserModeRequest(
                              UMRX_ASYNCENGINE_ARGUMENTS,
                              MRxDAVFormatUserModeSrvCallFinalizeRequest,
                              MRxDAVPrecompleteUserModeSrvCallFinalizeRequest
                              );

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Leaving MRxDAVFinalizeSrvCallContinuation with NtStatus"
                 " = %08lx.\n", PsGetCurrentThreadId(), NtStatus));

    return NtStatus;
}


NTSTATUS
MRxDAVFormatUserModeSrvCallFinalizeRequest(
    IN UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE,
    IN OUT PUMRX_USERMODE_WORKITEM_HEADER WorkItemHeader,
    IN ULONG WorkItemLength,
    OUT PULONG_PTR ReturnedLength
    )
/*++

Routine Description:

    This routine formats the SrvCall finalize request being sent to the user 
    mode for processing.

Arguments:
    
    RxContext - The RDBSS context.
    
    AsyncEngineContext - The reflctor's context.
    
    WorkItem - The work item buffer.
    
    WorkItemLength - The length of the work item buffer.
    
    ReturnedLength - 
    
Return Value:

    STATUS_SUCCESS or STATUS_INSUFFICIENT_RESOURCES.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PDAV_USERMODE_WORKITEM DavWorkItem = (PDAV_USERMODE_WORKITEM)WorkItemHeader;
    PMRX_SRV_CALL SrvCall = NULL;
    PWEBDAV_SRV_CALL DavSrvCall = NULL;
    PDAV_USERMODE_FINALIZE_SRVCALL_REQUEST FinSrvCallReq = NULL;
    PWCHAR ServerName = NULL;
    ULONG ServerNameLengthInBytes = 0;
    PBYTE SecondaryBuff = NULL;

    PAGED_CODE();

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Entering MRxDAVFormatUserModeSrvCallFinalizeRequest.\n",
                 PsGetCurrentThreadId()));

    DavDbgTrace(DAV_TRACE_CONTEXT,
                ("%ld: MRxDAVFormatUserModeSrvCallFinalizeRequest: "
                 "AsyncEngineContext: %08lx, RxContext: %08lx.\n",
                 PsGetCurrentThreadId(), AsyncEngineContext, RxContext));

    //
    // SrvCall was set to MRxContext[0] in MRxDAVFinalizeSrvCall. We need it to
    // get the ServerID.
    //
    SrvCall = (PMRX_SRV_CALL)RxContext->MRxContext[1];
    DavSrvCall = MRxDAVGetSrvCallExtension(SrvCall);
    ASSERT(DavSrvCall != NULL);
    
    DavWorkItem->WorkItemType = UserModeFinalizeSrvCall;

    FinSrvCallReq = &(DavWorkItem->FinalizeSrvCallRequest);

    //
    // Set the ServerID.
    //
    FinSrvCallReq->ServerID = DavSrvCall->ServerID;
    
    //
    // Set the Server name.
    //
    ServerName = &(SrvCall->pSrvCallName->Buffer[1]);
    ServerNameLengthInBytes = (1 + wcslen(ServerName)) * sizeof(WCHAR);
    SecondaryBuff = UMRxAllocateSecondaryBuffer(AsyncEngineContext, 
                                                ServerNameLengthInBytes);
    if (SecondaryBuff == NULL) {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("ld: MRxDAVFormatUserModeSrvCallFinalizeRequest/"
                     "UMRxAllocateSecondaryBuffer: ERROR: NtStatus = %08lx.\n",
                     PsGetCurrentThreadId(), NtStatus));
        goto EXIT_THE_FUNCTION;
    }
    
    FinSrvCallReq->ServerName = (PWCHAR)SecondaryBuff;
    
    wcscpy(FinSrvCallReq->ServerName, ServerName);

EXIT_THE_FUNCTION:
    
    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Leaving MRxDAVFormatUserModeSrvCallFinalizeRequest "
                 "with NtStatus = %08lx.\n", PsGetCurrentThreadId(), NtStatus));

    return NtStatus;
}


BOOL
MRxDAVPrecompleteUserModeSrvCallFinalizeRequest(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE,
    PUMRX_USERMODE_WORKITEM_HEADER WorkItemHeader,
    ULONG WorkItemLength,
    BOOL OperationCancelled
    )
/*++

Routine Description:

    The precompletion routine for the finalize SrvCall request.

Arguments:

    RxContext - The RDBSS context.
    
    AsyncEngineContext - The reflctor's context.
    
    WorkItem - The work item buffer.
    
    WorkItemLength - The length of the work item buffer.

    OperationCancelled - TRUE if this operation was cancelled by the user.

Return Value:

    TRUE - UMRxAsyncEngineCalldownIrpCompletion is called by the function
           UMRxCompleteUserModeRequest after we return.    

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PDAV_USERMODE_WORKITEM WorkItem = (PDAV_USERMODE_WORKITEM)WorkItemHeader;
    PDAV_USERMODE_FINALIZE_SRVCALL_REQUEST FinSrvCallReq;

    PAGED_CODE();

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Entering MRxDAVPrecompleteUserModeSrvCallFinalizeRequest\n",
                 PsGetCurrentThreadId()));

    DavDbgTrace(DAV_TRACE_CONTEXT,
                ("%ld: MRxDAVPrecompleteUserModeSrvCallFinalizeRequest: "
                 "AsyncEngineContext: %08lx, RxContext: %08lx.\n",
                 PsGetCurrentThreadId(), AsyncEngineContext, RxContext));

    FinSrvCallReq = &(WorkItem->FinalizeSrvCallRequest);

    if (OperationCancelled) {
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: MRxDAVPrecompleteUserModeSrvCallFinalizeRequest: Operation Cancelled. "
                     "AsyncEngineContext = %08lx, RxContext = %08lx.\n",
                     PsGetCurrentThreadId(), AsyncEngineContext, RxContext));
    }

    //
    // We need to free up the heap we allocated in the format routine.
    //
    if (FinSrvCallReq->ServerName != NULL) {

        NtStatus = UMRxFreeSecondaryBuffer(AsyncEngineContext,
                                           (PBYTE)FinSrvCallReq->ServerName);
        if (NtStatus != STATUS_SUCCESS) {
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: ERROR: MRxDAVPrecompleteUserModeSrvCallFinalizeRequest/"
                         "UMRxFreeSecondaryBuffer: NtStatus = %08lx.\n", 
                         PsGetCurrentThreadId(), NtStatus));
        }
    
    }

    if (AsyncEngineContext->Status != STATUS_SUCCESS) {
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: ERROR: MRxDAVPrecompleteUserModeSrvCallFinalizeRequest. "
                     "Finalize SrvCall Failed!!!\n",
                     PsGetCurrentThreadId()));
    }

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Leaving MRxDAVPrecompleteUserModeSrvCallFinalizeRequest\n",
                 PsGetCurrentThreadId()));
    
    return TRUE;
}


NTSTATUS
MRxDAVSrvCallWinnerNotify(
    IN PMRX_SRV_CALL  pSrvCall,
    IN BOOLEAN        ThisMinirdrIsTheWinner,
    IN OUT PVOID      pSrvCallContext
    )
/*++

Routine Description:

   This routine finalizes the mini rdr context associated with an RDBSS Server call instance

Arguments:

    pSrvCall               - the Server Call

    ThisMinirdrIsTheWinner - TRUE if this mini rdr is the choosen one.

    pSrvCallContext  - the server call context created by the mini redirector.

Return Value:

    RXSTATUS - The return status for the operation

Notes:

    The two phase construction protocol for Server calls is required because of parallel
    initiation of a number of mini redirectors. The RDBSS finalizes the particular mini
    redirector to be used in communicating with a given server based on quality of
    service criterion.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\server\davrpc_server.c ===
#include <davrpc_s.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\server\debug.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    debug.h

Abstract:

    This file contains debugging macros for the webdav client.

Author:

    Andy Herron (andyhe)  30-Mar-1999

Environment:

    User Mode - Win32

Revision History:


--*/

#ifndef DAV_DEBUG_H
#define DAV_DEBUG_H

#if DBG

//
// Memory allocation and tracking
//
#define DEBUG_OUTPUT_BUFFER_SIZE 1024
typedef struct _MEMORYBLOCK {
    HLOCAL hlocal;
    DWORD dwBytes;
    UINT uFlags;
    LPCSTR pszFile;
    UINT uLine;
    LPCSTR pszModule;
    LPCSTR pszComment;
    struct _MEMORYBLOCK *pNext;
} MEMORYBLOCK, *LPMEMORYBLOCK;

#define DEFAULT_MAXIMUM_DEBUGFILE_SIZE  (1024 * 1024)

//
// Controls access to the memeory tracing routines. We need this since multiple
// threads could be allocating memory simultaneously.
//
EXTERN CRITICAL_SECTION g_TraceMemoryCS;

//
// List of memory blocks (see the structure defined above) being maintained for 
// tracking memory.
//
EXTERN LPVOID g_TraceMemoryTable INIT_GLOBAL(NULL);

//
// Controls access to the debug log file. We need this since multiple threads
// could be writing to it simultaneously.
//
EXTERN CRITICAL_SECTION DavGlobalDebugFileCritSect;

//
// These are used in persistent logging. They define the file handle of the
// file to which the debug o/p is written, the max file size and the path
// of the file.
//
EXTERN HANDLE DavGlobalDebugFileHandle INIT_GLOBAL(INVALID_HANDLE_VALUE);
EXTERN ULONG DavGlobalDebugFileMaxSize INIT_GLOBAL(DEFAULT_MAXIMUM_DEBUGFILE_SIZE);
EXTERN LPWSTR DavGlobalDebugSharePath;

//
// This flag (value) is used in filtering/controlling the debug messages.
//
EXTERN ULONG DavGlobalDebugFlag;

#define DEBUG_DIR           L"\\debug"
#define DEBUG_FILE          L"\\davclnt.log"
#define DEBUG_BAK_FILE      L"\\davclnt.bak"

HLOCAL
DebugAlloc(
    LPCSTR pszFile,
    UINT uLine,
    LPCSTR pszModule,
    UINT uFlags,
    DWORD dwBytes,
    LPCSTR pszComment
    );

#define DavAllocateMemory(x)  (                   \
        DebugAlloc(__FILE__,                      \
                   __LINE__,                      \
                   "DAV",                         \
                   LMEM_FIXED | LMEM_ZEROINIT,    \
                   x,                             \
                   #x)                            \
        )

HLOCAL
DebugFree(
    HLOCAL hglobal
    );

#define DavFreeMemory(x) DebugFree(x)

VOID
DebugInitialize(
    VOID
    );

VOID
DebugUninitialize(
    VOID
    );


VOID
DavAssertFailed(
    LPSTR FailedAssertion,
    LPSTR FileName,
    DWORD LineNumber,
    LPSTR Message
    );

#define DavAssert(Predicate) {                                       \
        if (!(Predicate)) {                                          \
            DavAssertFailed( #Predicate, __FILE__, __LINE__, NULL ); \
        }                                                            \
    }

#define DavAssertMsg(Predicate, Message) {                               \
    if (!(Predicate)) {                                                  \
            DavAssertFailed( #Predicate, __FILE__, __LINE__, #Message ); \
        }                                                                \
    }

#define IF_DEBUG(flag) if (DavGlobalDebugFlag & (DEBUG_ ## flag))

//
// The debug flags used. 
//
#define DEBUG_CONNECT           0x00000001  // connect events
#define DEBUG_ERRORS            0x00000002  // errors
#define DEBUG_INIT              0x00000004  // init events
#define DEBUG_SCAVENGER         0x00000008  // sacvenger error
#define DEBUG_REGISTRY          0x00000010  // Registry operation
#define DEBUG_MISC              0x00000020  // misc info.
#define DEBUG_RPC               0x00000040  // debug rpc messages
#define DEBUG_MEMORY            0x00000080  // Memory Allocation Tracking Spew
#define DEBUG_FUNC              0x00000100  // function entry/exit
#define DEBUG_STARTUP_BRK       0x00000200  // breakin debugger during startup.
#define DEBUG_LOG_IN_FILE       0x00000400  // log debug output in a file.
#define DEBUG_DEBUG             0x00000800  // scope the debugging

VOID
DavPrintRoutine(
    IN DWORD DebugFlag,
    IN LPSTR Format,
    ...
    );

#define DavPrint(_x_)   DavPrintRoutine _x_;

VOID
DebugMemoryCheck(
    VOID
    );

#else   // not DBG

#define DavAllocateMemory(x) LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT, x)
#define DavFreeMemory(x)     LocalFree(x)
#define IF_DEBUG(flag) if (FALSE)
#define DavPrint(_x_)
#define DavAssert(_x_)
#define DavAssertMsg(_x_, _y_)

#endif // DBG

VOID
DavClientEventLog(
    DWORD EventID,
    DWORD EventType,
    DWORD ErrorCode
    );

#endif // DAV_DEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\server\davsrv.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    davsrv.c

Abstract:

    This has all of our server side entry points for the DAV Mini-Redir
    RPC service interface. It also contains the helper functions for the 
    service interface.

Author:

    Rohan Kumar   [RohanK]   01-Dec-1999

Environment:

    User Mode - Win32

Revision History:

--*/

#include "pch.h"
#pragma hdrstop

#include <ntumrefl.h>
#include <ntddnfs.h>
#include <usrmddav.h>
#include <lmuseflg.h>
#include "global.h"
#include <time.h>
#include "nodefac.h"
#include "UniUtf.h"

DWORD
DavCheckLocalName (
    LPWSTR LocalName,
    PWCHAR OutputLocalDeviceBuffer
    );

DWORD
DavCheckRemoteName(
    IN LPWSTR LocalName OPTIONAL,
    IN LPWSTR RemoteName,
    OUT LPWSTR *OutputBuffer,
    OUT LPDWORD OutputBufferLength OPTIONAL
    );

DWORD
DavCreateTreeConnectName(
    IN LPWSTR UncName,
    IN LPWSTR LocalName OPTIONAL,
    IN ULONG SessionId,
    OUT PUNICODE_STRING TreeConnectStr
    );

DWORD
DavOpenCreateConnection(
    IN PUNICODE_STRING TreeConnectionName,
    IN LPWSTR UserName OPTIONAL,
    IN LPWSTR Password OPTIONAL,
    IN LPWSTR UncName,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG CreateDisposition,
    IN ULONG CreateOptions,
    IN ULONG ConnectionType,
    OUT PHANDLE TreeConnectionHandle,
    OUT PULONG_PTR Information OPTIONAL
    );

DWORD
DavImpersonateClient(
    VOID
    );

ULONG
DavImpersonateAndGetSessionId(
    PULONG pSessionId
    );

ULONG
DavImpersonateAndGetLogonId(
    PLUID pLogonId
    );

DWORD
DavCreateSymbolicLink(
    IN LPWSTR Local,
    IN LPWSTR TreeConnectStr,
    IN OUT LPWSTR *Session,
    IN OUT HANDLE *lphToken
    );

DWORD
DavDeleteSymbolicLink(
    IN LPWSTR LocalDeviceName,
    IN LPWSTR TreeConnectStr,
    IN LPWSTR SessionDeviceName,
    IN HANDLE hToken,
    IN BOOL bImpersonating
    );

ULONG
DavImpersonateAndGetUserId(
    LPWSTR UserName,
    LPDWORD UserNameMaxLen
    );

DWORD
DavRevertToSelf(
    VOID
    );

NET_API_STATUS
DavGetUserEntry(
    IN PDAV_USERS_OBJECT DavUsers,
    IN PLUID LogonId,
    OUT PULONG Index,
    IN BOOL IsAdd
    );

NET_API_STATUS
DavGrowTable(
    IN PDAV_USERS_OBJECT DavUsers
    );

LPWSTR
DavReturnSessionPath(
    IN LPWSTR LocalDeviceName
    );

NET_API_STATUS
DavAddUse(
    IN PLUID LogonId,
    IN LPWSTR Local OPTIONAL,
    IN DWORD LocalLength,
    IN LPWSTR AuthUserName OPTIONAL,
    IN LPWSTR UncName,
    IN DWORD UncNameLength,
    IN PUNICODE_STRING TreeConnectStr,
    IN HANDLE DavCreateFileHandle
    );

VOID
DavFindInsertLocation(
    IN PDAV_USE_ENTRY UseList,
    IN LPWSTR UncName,
    OUT PDAV_USE_ENTRY *MatchedPointer,
    OUT PDAV_USE_ENTRY *InsertPointer
    );

NET_API_STATUS
DavCreateNewEntry(
    OUT PDAV_USE_ENTRY *NewUse,
    IN LPWSTR Local OPTIONAL,
    IN DWORD LocalLength,
    IN LPWSTR AuthUserName OPTIONAL,
    IN LPWSTR UncName OPTIONAL,
    IN DWORD UncNameLength,
    IN PUNICODE_STRING TreeConnectStr,
    IN HANDLE DavCreateFileHandle
    );

NET_API_STATUS
DavFindUse(
    IN PLUID LogonId,
    IN PDAV_USE_ENTRY UseList,
    IN LPWSTR UseName,
    OUT PDAV_USE_ENTRY *MatchedPointer,
    OUT PDAV_USE_ENTRY *BackPointer OPTIONAL
    );

VOID
DavFindLocal(
    IN PDAV_USE_ENTRY UseList,
    IN LPTSTR Local,
    OUT PDAV_USE_ENTRY *MatchedPointer,
    OUT PDAV_USE_ENTRY *BackPointer
    );

VOID
DavFindRemote(
    IN PDAV_USE_ENTRY UseList,
    IN LPTSTR RemoteName,
    OUT PDAV_USE_ENTRY *MatchedPointer,
    OUT PDAV_USE_ENTRY *BackPointer
    );

NET_API_STATUS
DavDeleteUse(
    IN PLUID LogonId,
    IN DWORD ForceLevel,
    IN PDAV_USE_ENTRY MatchedPointer,
    IN DWORD Index
    );

VOID
DavInitializeAndInsertTheServerShareEntry(
    IN OUT PDAV_SERVER_SHARE_ENTRY ServerShareEntry,
    IN PWCHAR ServerName,
    IN ULONG EntrySize
    );

BOOL 
DavIsServerInServerShareTable(
    IN PWCHAR ServerName,
    OUT PDAV_SERVER_SHARE_ENTRY *ServerShEntry
    );

DWORD
DavGetShareListFromServer(
    PDAV_SERVER_SHARE_ENTRY ServerShEntry
    );

DWORD
DavConvertDriveLetterPathToUncPath(
    IN PWCHAR DriveLetterPath,
    OUT PWCHAR *UncPath
    );

BOOL
DavCheckTheNonDAVServerList(
    PWCHAR ServerName
    );

//
// DAV Use Table.
//
DAV_USERS_OBJECT DavUseObject;

//
// The hash table of DAV_SERVER_SHARE_TABLE entries. This is hashed on the 
// server name.
//
LIST_ENTRY ServerShareTable[SERVER_SHARE_TABLE_SIZE];

CRITICAL_SECTION ServerShareTableLock;

//
// Number of users logged on to the system. The Critical section below it
// synchronizes the acces to this variable.
//
ULONG DavNumberOfLoggedOnUsers = 0;
CRITICAL_SECTION DavLoggedOnUsersLock;

//
// Whenever we encounter a server that does not speak the DAV protocol in the
// DavrDoesServerDoDav function, we add it to the NonDAVServerList. An entry
// is kept on this list for ServerNotFoundCacheLifeTimeInSec (a global read
// from the registry during service start-up). Before going on the network
// to figure out whether a server does DAV, we look in the list to see if we
// have already seen this server (which does not do DAV) and fail the call.
//
LIST_ENTRY NonDAVServerList;
CRITICAL_SECTION NonDAVServerListLock = {0};

//
// Implementation of functions begins here.
//

DWORD
DavrCreateConnection(
    IN handle_t dav_binding_h,
    IN LPWSTR LocalName OPTIONAL,
    IN LPWSTR RemoteName,
    IN DWORD Type,
    IN LPWSTR Password OPTIONAL,
    IN LPWSTR UserName OPTIONAL
    )
/*++

Routine Description:

    This function creates a tree connection to the specified RemoteName
    (UNC name) and maps it to the LocalName (local device name), if
    it is specified.  The password and user name are the credentials
    used to create the connection, if specified; otherwise, the
    interactive logged on user's credentials are used by default.

Arguments:

    dav_binding_h - The explicit RPC binding handle.

    LocalName - Supplies the local device name to map to the created tree
                connection.  Only drive letter device names are accepted.  (No
                LPT or COM).

    RemoteName - Supplies the UNC name of the remote resource in the format
                 of Server\Volume\Directory.  It must be a disk resource.

    Type - Supplies the connection type.

    Password - Supplies the password to use to make the connection to the
               server.  The password should be encoded with DAV_ENCODE_SEED.

    UserName - Supplies the user name to use to make the connection.

Return Value:

    Should return the following values under varying conditions so the
    mapping on the provider side works :

    ERROR_UNEXP_NET_ERR -
    
    ERROR_INVALID_HANDLE - 
    
    ERROR_INVALID_PARAMETER -
    
    ERROR_ALREADY_ASSIGNED - Local DOS device name is already in use.
    
    ERROR_REM_NOT_LIST - Invalid remote resource name.
    
    ERROR_BAD_DEVICE - Invalid local DOS device name.
    
    ERROR_INVALID_PASSWORD - Invalid password.

--*/
{
    DWORD dwErr = NO_ERROR;
    ULONG SessionId;
    LUID LogonId;
    BOOLEAN createdLink = FALSE;
    HANDLE TreeConnection = INVALID_HANDLE_VALUE;
    LPWSTR Unc = NULL;
    WCHAR localDrive[3]; // For L"X:\0".
    PWCHAR LocalDriveName = NULL;
    DWORD LocalLength = 0, UncLength = 0;
    UNICODE_STRING TreeConnectStr;
    LPWSTR Session = NULL;
    LPWSTR Cookie = NULL;
    LPWSTR UserNameBuffer = NULL;
    DWORD  UserNameLength = 0;
    HANDLE hToken = INVALID_HANDLE_VALUE;

    DavPrint((DEBUG_MISC,
              "DavrCreateConnection: Entered. Local = %ws, Remote = %ws\n",
              LocalName, RemoteName));

    TreeConnectStr.Buffer = NULL;
    TreeConnectStr.Length = TreeConnectStr.MaximumLength = 0;

    if (Type != RESOURCETYPE_ANY && Type != RESOURCETYPE_DISK) {
        dwErr = ERROR_INVALID_PARAMETER;
        DavPrint((DEBUG_ERRORS, "DavrCreateConnection: Invalid Type.\n"));
        goto EXIT_THE_FUNCTION;
    }

    //
    // If a LocalName has been specified, its always of the format X: and so it
    // is 3 WCHARS long including the final '\0'.
    //
    if (LocalName) {
        
        DavPrint((DEBUG_MISC,
                  "DavrCreateConnection: Local = %ws, Remote = %ws\n",
                  LocalName, RemoteName));

        LocalLength = 3;
        
        //
        // Check the local name to ensure that it's "X:" syntax.
        //
        dwErr = DavCheckLocalName( LocalName, &localDrive[0] );
        if (dwErr != NO_ERROR) {
            DavPrint((DEBUG_ERRORS, 
                      "DavrCreateConnection/DavCheckLocalName: dwErr = %08lx\n",
                      dwErr));
            goto EXIT_THE_FUNCTION;
        }

        DavPrint((DEBUG_MISC, "DavrCreateConnection: LocalDrive = %ws\n", &localDrive[0]));

        LocalDriveName = &localDrive[0];
    
    }

    //
    // Check the remote name to ensure that has a proper syntax.
    //
    dwErr = DavCheckRemoteName(LocalDriveName, RemoteName, &Unc, NULL);
    if (dwErr != NO_ERROR) {
        DavPrint((DEBUG_ERRORS, 
                  "DavrCreateConnection/DavCheckRemoteName: dwErr = %08lx\n",
                  dwErr));
        goto EXIT_THE_FUNCTION;
    }

    UncLength = wcslen(Unc);
    DavPrint((DEBUG_MISC, "DavrCreateConnection: Unc = %ws\n", Unc));

    if (UserName != NULL) {
        
        // 
        // We want to use local copy of buffer name. We don't want to
        // alter original UserName buffer passed else constant UserName buffer
        // passed will result in exception.
        //
        UserNameLength = wcslen(UserName);
        UserNameBuffer = LocalAlloc( (LMEM_FIXED | LMEM_ZEROINIT),
                                     (UserNameLength + 1) * sizeof(WCHAR) );
        if (!UserNameBuffer) {
             dwErr = GetLastError();
             DavPrint((DEBUG_ERRORS,
                       "DavrCreateConnection/LocalAlloc. Error Val = %d\n",
                       dwErr));
             goto EXIT_THE_FUNCTION;
        }

        wcscpy(UserNameBuffer, UserName);

        // 
        // Check if the UserName passed is valid. If it is, then we will use
        // local buffer as it is for further use. Else we will copy modified
        // version of name in local buffer.
        //
        if ( !IS_VALID_USERNAME_TOKEN(UserName, UserNameLength) ) {

            DWORD BlackSlashOffset = 0;
            BOOL BackSlashFound = FALSE;

            for (BlackSlashOffset = 0; BlackSlashOffset < UserNameLength; BlackSlashOffset++) {
                if (UserName[BlackSlashOffset] == L'\\') {
                    BackSlashFound = TRUE;
                    break;
                }
            }

            if (BackSlashFound) {
                
                //
                // Replace the UserName in the form of Domain\User with the form 
                // of User@Domain, which can be accepted by WinInet.
                //

                RtlCopyMemory(UserNameBuffer,
                              &(UserName[BlackSlashOffset+1]),
                              (UserNameLength-BlackSlashOffset-1)*sizeof(WCHAR));
                
                UserNameBuffer[UserNameLength-BlackSlashOffset-1] = L'@';
                
                RtlCopyMemory(&(UserNameBuffer[UserNameLength-BlackSlashOffset]),
                              UserName,
                              BlackSlashOffset*sizeof(WCHAR));

                if (!IS_VALID_USERNAME_TOKEN(UserNameBuffer, UserNameLength)) {
                    DavPrint((DEBUG_ERRORS, "DavrCreateConnection: Invalid UserName\n"));
                    dwErr = ERROR_INVALID_PARAMETER;
                    goto EXIT_THE_FUNCTION;
                }
            
            } else {
                DavPrint((DEBUG_ERRORS, "DavrCreateConnection: Invalid UserName\n"));
                dwErr = ERROR_INVALID_PARAMETER;
                goto EXIT_THE_FUNCTION;
            }
        }
    }

    DavPrint((DEBUG_MISC, "DavrCreateConnection: UserName = %ws\n", UserNameBuffer));

    //
    // Impersonate caller and get the LogonId.
    //
    dwErr = DavImpersonateAndGetLogonId( &(LogonId) );
    if (dwErr != NO_ERROR) {
        DavPrint((DEBUG_ERRORS, 
                  "DavrCreateConnection/DavImpersonateAndGetLogonId: "
                  "dwErr = %08lx\n", dwErr));
        goto EXIT_THE_FUNCTION;
    }
    
    DavPrint((DEBUG_MISC, "DavrCreateConnection: LogonId = %d %d\n", 
              LogonId.HighPart, LogonId.LowPart));
    
    //
    // Impersonate caller and get the SessionId.
    //
    dwErr = DavImpersonateAndGetSessionId( &(SessionId) );
    if (dwErr != NO_ERROR) {
        DavPrint((DEBUG_ERRORS, 
                  "DavrCreateConnection/DavImpersonateAndGetSessionId: "
                  "dwErr = %08lx\n", dwErr));
        goto EXIT_THE_FUNCTION;
    }
    
    DavPrint((DEBUG_MISC, "DavrCreateConnection: SessionId = %d\n", SessionId));
    
    //
    // Now we create an NT-style tree connection name.
    //
    dwErr = DavCreateTreeConnectName(Unc, LocalDriveName, SessionId, &TreeConnectStr);
    if (dwErr != NO_ERROR) {
        DavPrint((DEBUG_ERRORS, 
                  "DavrCreateConnection/DavCreateTreeConnectName: dwErr = %08lx\n",
                  dwErr));
        goto EXIT_THE_FUNCTION;
    }

    DavPrint((DEBUG_MISC, "DavrCreateConnection: TreeConnectStr = %wZ.\n",
              &(TreeConnectStr)));
    
    if (LocalDriveName) {
        
        //
        // Create symbolic link for local device name. If there are multiple
        // threads trying to do this, only one will succeed.
        //
        dwErr = DavCreateSymbolicLink(LocalDriveName,
                                      TreeConnectStr.Buffer,
                                      &Session,
                                      &hToken);
        if (dwErr != NO_ERROR) {
            DavPrint((DEBUG_ERRORS,
                      "DavrCreateConnection/DavCreateSymbolicLink: dwErr = %08lx\n",
                      dwErr));
            goto EXIT_THE_FUNCTION;
        }
        
        createdLink = TRUE;
    
    }

    dwErr = DavOpenCreateConnection(&TreeConnectStr,
                                    UserNameBuffer,
                                    Password,
                                    Unc,
                                    SYNCHRONIZE,
                                    FILE_OPEN,
                                    FILE_SYNCHRONOUS_IO_NONALERT | FILE_CREATE_TREE_CONNECTION,
                                    Type,
                                    &TreeConnection,
                                    NULL);

    if (dwErr == NO_ERROR) {
        HANDLE TempTreeConnection = INVALID_HANDLE_VALUE;

        //
        // Check whether the directory really exists. This is our way of
        // avoiding to write a lot of code in the kernel to check for a deep net use case
        //
        dwErr = DavOpenCreateConnection(&TreeConnectStr,
                                        NULL,
                                        NULL,
                                        Unc,
                                        SYNCHRONIZE |FILE_READ_DATA,
                                        FILE_OPEN,
                                        FILE_SYNCHRONOUS_IO_NONALERT | FILE_DIRECTORY_FILE,
                                        Type,
                                        &TempTreeConnection,
                                        NULL);

        if (dwErr == NO_ERROR) {
            NtClose(TempTreeConnection);
        } else {
            NtClose(TreeConnection);
            TreeConnection = INVALID_HANDLE_VALUE;        
        }
    }
    
    if (dwErr != NO_ERROR) {
        DavPrint((DEBUG_ERRORS, 
                  "DavrCreateConnection/DavOpenCreateConnection: dwErr = %08lx\n",
                  dwErr));
        
        switch(dwErr) {
        case ERROR_NOT_CONNECTED:
        case ERROR_FILE_NOT_FOUND:
        case ERROR_INVALID_NAME:
            dwErr = ERROR_BAD_NETPATH;
            break;
        case ERROR_CONNECTION_INVALID:
            dwErr = WN_BAD_NETNAME;
            break;
        }

        goto EXIT_THE_FUNCTION;
    }

    //
    // Add use to the Use Table. We want to always add a user name to the
    // UserEntry. So if a user name is not given explicitly, then we will use
    // the UserId of the client.
    //
    if (UserNameBuffer == NULL) {
        DWORD UserNameMaxLen = UserNameLength = (UNLEN + 1);
        UserNameBuffer = LocalAlloc( (LMEM_FIXED | LMEM_ZEROINIT),
                                     (UserNameMaxLen + 1) * sizeof(WCHAR) );
        if (!UserNameBuffer) {
             dwErr = GetLastError();
             DavPrint((DEBUG_ERRORS,
                              "DavrCreateConnection/LocalAlloc. Error Val = %d.\n",
                              dwErr));
             goto EXIT_THE_FUNCTION;
        }
        dwErr = DavImpersonateAndGetUserId(UserNameBuffer, &UserNameMaxLen);
        if (dwErr != NO_ERROR) {
            DavPrint((DEBUG_ERRORS, 
                      "DavrCreateConnection/DavImpersonateAndGetUserId: dwErr = %x\n",
                      dwErr));
            goto EXIT_THE_FUNCTION;
        }
    }

    ASSERT(UserNameBuffer);

    dwErr = DavAddUse( &(LogonId),
                       LocalDriveName,
                       LocalLength,
                       UserNameBuffer,
                       Unc,
                       UncLength,
                       &(TreeConnectStr),
                       TreeConnection );
    if (dwErr != NO_ERROR) {
        DavPrint((DEBUG_ERRORS,
                  "DavrCreateConnection/DavAddUse: dwErr = %08lx\n",
                  dwErr));
    }

EXIT_THE_FUNCTION:

    if (createdLink && dwErr != NO_ERROR) {
        DWORD DeleteStatus;
        DeleteStatus = DavDeleteSymbolicLink(LocalDriveName,
                                             TreeConnectStr.Buffer,
                                             Session,
                                             hToken,
                                             FALSE);
    }

    if (hToken != INVALID_HANDLE_VALUE) {
        CloseHandle(hToken);
    }

    //
    // If we failed after creating a handle then we need to close the handle
    // before leaving. Otherwise, this handle is closed when the connection is
    // deleted (in DavrCancelConnection).
    //
    if (TreeConnection != INVALID_HANDLE_VALUE && dwErr != NO_ERROR) {
        NtClose(TreeConnection);
    }

    if (UserNameBuffer != NULL) {
        LocalFree((HLOCAL)UserNameBuffer);
        UserNameBuffer = NULL;
    }

    if (TreeConnectStr.Buffer != NULL) {
        LocalFree((HLOCAL)TreeConnectStr.Buffer);
    }

    if (Session != NULL) {
        LocalFree( Session );
    }

    if (Unc != NULL) {
        LocalFree( Unc );
    }

    return dwErr;
}


DWORD
DavrDeleteConnection(
    IN handle_t dav_binding_h,
    IN LPWSTR ConnectionName,
    IN DWORD UseForce
    )
/*++

Routine Description:

    This function deletes a remote connection to the network resource and 
    the symbolic link which was created between the network resource and the 
    local device.

Arguments:

    dav_binding_h - The explicit RPC binding handle.
    
    ConnectionName - Supplies the local DOS device, or the remote resource name
                     if it is a UNC connection to delete.
    
    UseForce - If TRUE, the connection should be broken even if open files
               exist.

Return Value:

    WN_SUCCESS - Successful. OR

    Should return the following values under varying conditions so the
    mapping on the provider side works :

    ERROR_UNEXP_NET_ERR
    
    ERROR_INVALID_HANDLE
    
    ERROR_INVALID_PARAMETER
    
    ERROR_OPEN_FILES - fForce is FALSE and there are opened files on the 
                       connection.
    
    ERROR_REM_NOT_LIST - Invalid remote resource name.
    
    ERROR_BAD_DEVICE - Invalid local DOS device name.
    
    ERROR_NOT_FOUND - Connection could not be found.

--*/
{
    DWORD dwErr = NO_ERROR;
    WCHAR localDrive[3]; // For L"X:\0".
    PWCHAR NameToDelete = NULL;
    DWORD ForceLevel;
    LUID LogonId; // Logon Id of user.
    ULONG Index;
    PDAV_USE_ENTRY UseList = NULL, MatchedPointer = NULL, BackPointer = NULL;
    BOOL ResAcquired = FALSE;

    DavPrint((DEBUG_MISC,
              "DavrDeleteConnection: Entered. ConnectionName = %ws\n",
              ConnectionName));

    ForceLevel = (UseForce ? USE_LOTS_OF_FORCE : USE_NOFORCE);

    //
    // Initialize the LogonId.
    //
    LogonId.LowPart = 0;
    LogonId.HighPart = 0;

    if ( (ConnectionName == NULL) || (wcslen(ConnectionName) < 2) ) {
        dwErr = ERROR_INVALID_PARAMETER;
        goto EXIT_THE_FUNCTION;
    }

    //
    // The ConnectionName could be local or remote.
    //
    if ( ConnectionName[0] != L'\\' ) {

        if(ConnectionName[1] != L':') {
            dwErr = ERROR_INVALID_PARAMETER;
            goto EXIT_THE_FUNCTION;
        }
    
        //
        // Check the local name to ensure that it's "X:" syntax.
        //
        dwErr = DavCheckLocalName( ConnectionName, &localDrive[0] );
        if (dwErr != NO_ERROR) {
            DavPrint((DEBUG_ERRORS, 
                      "DavrDeleteConnection/DavCheckLocalName: dwErr = %08lx\n",
                      dwErr));
            goto EXIT_THE_FUNCTION;
        }

        DavPrint((DEBUG_MISC, "DavrDeleteConnection: LocalDrive = %ws\n", 
                  &localDrive[0]));

        NameToDelete = &localDrive[0];

    } else {

        //
        // This is a remote name.
        //
        NameToDelete = ConnectionName;

    }
    
    //
    // Impersonate caller and get the LogonId.
    //
    dwErr = DavImpersonateAndGetLogonId( &(LogonId) );
    if (dwErr != NO_ERROR) {
        DavPrint((DEBUG_ERRORS, 
                  "DavrDeleteConnection/DavImpersonateAndGetLogonId: "
                  "dwErr = %08lx\n", dwErr));
        goto EXIT_THE_FUNCTION;
    }
    
    DavPrint((DEBUG_MISC, "DavrDeleteConnection: LogonId = %d %d\n", 
              LogonId.HighPart, LogonId.LowPart));
    
    //
    // Lock the Dav Use Table while looking for entry to delete.
    //
    if ( !RtlAcquireResourceExclusive( &(DavUseObject.TableResource), TRUE ) ) {
        DavPrint((DEBUG_ERRORS, 
                  "DavrDeleteConnection/RtlAcquireResourceExclusive.\n"));
        dwErr = NERR_InternalError;
        goto EXIT_THE_FUNCTION;
    }

    ResAcquired = TRUE;

    //
    // See if the use entry is an explicit connection.
    //
    dwErr = DavGetUserEntry( &(DavUseObject), &(LogonId), &(Index), FALSE );
    if (dwErr != NERR_Success) {
        UseList = NULL;
    } else {
        UseList = (PDAV_USE_ENTRY) DavUseObject.Table[Index].List;
    }

    dwErr = DavFindUse(&LogonId,
                       UseList,
                       NameToDelete,
                       &MatchedPointer,
                       &BackPointer);
    if (dwErr != NERR_Success) {
        DavPrint((DEBUG_ERRORS, 
                  "DavrDeleteConnection/DavFindUse: dwErr = %08lx\n", dwErr));
        goto EXIT_THE_FUNCTION;
    }

    if (MatchedPointer == NULL) {
        DavPrint((DEBUG_MISC,
                  "DavrDeleteConnection: UseName has an implicit connection.\n"));
        goto EXIT_THE_FUNCTION;
    }

    //
    // Delete tree connection and remove use entry from Dav Use Table.
    //
    dwErr = DavDeleteUse( &(LogonId), ForceLevel, MatchedPointer, Index );
    if (dwErr != NERR_Success) {
        DavPrint((DEBUG_ERRORS, 
                  "DavrDeleteConnection/DavDeleteUse: dwErr = %08lx\n", dwErr));
    }
    
EXIT_THE_FUNCTION:

    if (ResAcquired) {
        RtlReleaseResource( &(DavUseObject.TableResource) );
    }

    return dwErr;
}


DWORD
DavrConnectionExist(
    IN handle_t dav_binding_h,
    IN LPWSTR ConnectionName
    )
/*++

Routine Description:

    This function finds if given connection exists. Given connection can be a
    local DOS device name or it can be a remote UNC connection name.

Arguments:

    dav_binding_h - The explicit RPC binding handle.
    
    ConnectionName - Supplies the local DOS device, or the remote resource name.
    
Return Value:

    WN_SUCCESS - If connection exist. OR

    Should return the following values under varying conditions so the
    mapping on the provider side works :

    ERROR_UNEXP_NET_ERR
    
    ERROR_INVALID_HANDLE
    
    ERROR_INVALID_PARAMETER
    
    ERROR_REM_NOT_LIST - Invalid remote resource name.
    
    ERROR_BAD_DEVICE - Invalid local DOS device name.
    
    ERROR_NOT_FOUND - Connection could not be found.

--*/
{
    DWORD dwErr = NO_ERROR;
    WCHAR localDrive[3]; // For L"X:\0".
    PWCHAR NameToQuery = NULL;
    LUID LogonId; // Logon Id of user.
    ULONG Index = 0;
    PDAV_USE_ENTRY UseList = NULL, MatchedPointer = NULL, BackPointer = NULL;
    BOOL ResAcquired = FALSE;
    
    DavPrint((DEBUG_MISC,
              "DavrConnectionExist: Entered. ConnectionName = %ws\n",
              ConnectionName));

    //
    // Initialize the LogonId.
    //
    LogonId.LowPart = 0;
    LogonId.HighPart = 0;

    if( (ConnectionName == NULL) || (wcslen(ConnectionName) < 2) ) {
        dwErr = ERROR_INVALID_PARAMETER;
        goto EXIT_THE_FUNCTION;
    }

    //
    // The ConnectionName could be local or remote.
    //
    if ( ConnectionName[0] != L'\\' ) {

        if(ConnectionName[1] != L':') {
            dwErr = ERROR_INVALID_PARAMETER;
            goto EXIT_THE_FUNCTION;
        }
    
        //
        // Check the local name to ensure that it's "X:" syntax.
        //
        dwErr = DavCheckLocalName( ConnectionName, &(localDrive[0]) );
        if (dwErr != NO_ERROR) {
            DavPrint((DEBUG_ERRORS, 
                      "DavrConnectionExist/DavCheckLocalName: dwErr = %08lx\n",
                      dwErr));
            goto EXIT_THE_FUNCTION;
        }

        DavPrint((DEBUG_MISC,
                  "DavrConnectionExist: LocalDrive = %ws\n",
                  &(localDrive[0])));

        NameToQuery = &(localDrive[0]);

    } else {

        //
        // This is a remote name.
        //
        NameToQuery = ConnectionName;

    }
    
    //
    // Impersonate caller and get the LogonId.
    //
    dwErr = DavImpersonateAndGetLogonId( &(LogonId) );
    if (dwErr != NO_ERROR) {
        DavPrint((DEBUG_ERRORS, 
                  "DavrConnectionExist/DavImpersonateAndGetLogonId: "
                  "dwErr = %08lx\n", dwErr));
        goto EXIT_THE_FUNCTION;
    }
    
    DavPrint((DEBUG_MISC,
              "DavrConnectionExist: LogonId = %d %d\n",
              LogonId.HighPart, LogonId.LowPart));
    
    //
    // Lock the Dav Use Table while looking for entry to delete.
    //
    if ( !RtlAcquireResourceExclusive( &(DavUseObject.TableResource), TRUE ) ) {
        DavPrint((DEBUG_ERRORS, 
                  "DavrConnectionExist/RtlAcquireResourceExclusive.\n"));
        dwErr = NERR_InternalError;
        goto EXIT_THE_FUNCTION;
    }

    ResAcquired = TRUE;

    //
    // See if the use entry is an explicit connection.
    //
    dwErr = DavGetUserEntry( &(DavUseObject), &(LogonId), &(Index), FALSE );
    if (dwErr != NERR_Success) {
        UseList = NULL;
        dwErr = ERROR_NOT_FOUND;
        goto EXIT_THE_FUNCTION;
    }

    UseList = (PDAV_USE_ENTRY) DavUseObject.Table[Index].List;

    dwErr = DavFindUse(&LogonId,
                       UseList,
                       NameToQuery,
                       &MatchedPointer,
                       &BackPointer);
    if (dwErr != NERR_Success) {
        DavPrint((DEBUG_ERRORS, 
                  "DavrConnectionExist/DavFindUse: dwErr = %08lx\n", dwErr));
        dwErr = ERROR_NOT_FOUND;
        goto EXIT_THE_FUNCTION;
    }

    ASSERT(MatchedPointer != NULL);
    
    DavPrint((DEBUG_MISC, 
              "DavrConnectionExist. AuthUserName = %ws, AuthUserNameLen = %d\n", 
              MatchedPointer->AuthUserName,MatchedPointer->AuthUserNameLength));

    dwErr = WN_SUCCESS;
    goto EXIT_THE_FUNCTION;

EXIT_THE_FUNCTION:

    if (ResAcquired) {
        RtlReleaseResource( &(DavUseObject.TableResource) );
        ResAcquired = FALSE;
    }

    return dwErr;
}


DWORD
DavrGetUser(
    IN handle_t dav_binding_h,
    IN LPWSTR ConnectionName,
    OUT LPWSTR *UserName
    )
/*++

Routine Description:

    This function returns the UserName that mapped a given connection.

Arguments:

    dav_binding_h - The explicit RPC binding handle.
    
    UserNameLength - The length of the UserName buffer.
    
    ConnectionName - Supplies the local DOS device, or the remote resource name.
    
    UserName - The buffer where the UserName will be filled.

Return Value:

    WN_SUCCESS - If connection exist. OR

    Should return the following values under varying conditions so the
    mapping on the provider side works :

    ERROR_UNEXP_NET_ERR
    
    ERROR_INVALID_HANDLE
    
    ERROR_INVALID_PARAMETER
    
    ERROR_REM_NOT_LIST - Invalid remote resource name.
    
    ERROR_BAD_DEVICE - Invalid local DOS device name.
    
    ERROR_NOT_FOUND - Connection could not be found.

    NERR_UserNotFound - Connection is found, but User name not found in it.

--*/
{
    DWORD dwErr = NO_ERROR;
    WCHAR localDrive[3]; // For L"X:\0".
    PWCHAR NameToQuery = NULL;
    LUID LogonId; // Logon Id of user.
    ULONG Index = 0;
    PDAV_USE_ENTRY UseList = NULL, MatchedPointer = NULL, BackPointer = NULL;
    BOOL ResAcquired = FALSE;

    DavPrint((DEBUG_MISC, "DavrGetUser: Entered. ConnectionName = %ws\n", ConnectionName));

    //
    // Initialize the LogonId.
    //
    LogonId.LowPart = 0;
    LogonId.HighPart = 0;

    if( (ConnectionName == NULL) || (UserName == NULL) ) {
        dwErr = ERROR_INVALID_PARAMETER;
        goto EXIT_THE_FUNCTION;
    }

    if (wcslen(ConnectionName) < 2) {
        dwErr = ERROR_INVALID_PARAMETER;
        goto EXIT_THE_FUNCTION;
    }

    //
    // The ConnectionName could be local or remote.
    //
    if (ConnectionName[0] != L'\\') {

        if(ConnectionName[1] != L':') {
            dwErr = ERROR_INVALID_PARAMETER;
            goto EXIT_THE_FUNCTION;
        }
    
        //
        // Check the local name to ensure that it's "X:" syntax.
        //
        dwErr = DavCheckLocalName( ConnectionName, &localDrive[0] );
        if (dwErr != NO_ERROR) {
            DavPrint((DEBUG_ERRORS, 
                      "DavrGetUser/DavCheckLocalName: dwErr = %08lx\n",
                      dwErr));
            goto EXIT_THE_FUNCTION;
        }

        DavPrint((DEBUG_MISC, "DavrGetUser: LocalDrive = %ws\n", &localDrive[0]));

        NameToQuery = &localDrive[0];

    } else {

        //
        // This is a remote name.
        //
        NameToQuery = ConnectionName;

    }

    //
    // Impersonate caller and get the LogonId.
    //
    dwErr = DavImpersonateAndGetLogonId( &(LogonId) );
    if (dwErr != NO_ERROR) {
        DavPrint((DEBUG_ERRORS, 
                  "DavrGetUser/DavImpersonateAndGetLogonId: "
                  "dwErr = %x\n", dwErr));
        goto EXIT_THE_FUNCTION;
    }
    
    DavPrint((DEBUG_MISC,
              "DavrGetUser: LogonId = %d %d\n", 
              LogonId.HighPart, LogonId.LowPart));
    
    //
    // Lock the Dav Use Table while looking for entry to delete.
    //
    if ( !RtlAcquireResourceExclusive( &(DavUseObject.TableResource), TRUE ) ) {
        DavPrint((DEBUG_ERRORS, 
                  "DavrGetUser/RtlAcquireResourceExclusive.\n"));
        dwErr = NERR_InternalError;
        goto EXIT_THE_FUNCTION;
    }

    ResAcquired = TRUE;

    //
    // See if the use entry is an explicit connection.
    //
    dwErr = DavGetUserEntry( &(DavUseObject), &(LogonId), &(Index), FALSE );
    if (dwErr != NERR_Success) {
        UseList = NULL;
        dwErr = ERROR_NOT_FOUND;
        goto EXIT_THE_FUNCTION;
    }

    UseList = (PDAV_USE_ENTRY) DavUseObject.Table[Index].List;

    dwErr = DavFindUse(&LogonId,
                       UseList,
                       NameToQuery,
                       &MatchedPointer,
                       &BackPointer);
    if (dwErr != NERR_Success) {
        DavPrint((DEBUG_ERRORS, 
                  "DavrGetUser/DavFindUse: dwErr = %08lx\n", dwErr));
        dwErr = ERROR_NOT_FOUND;
        goto EXIT_THE_FUNCTION;
    }

    ASSERT(MatchedPointer != NULL);
    
    DavPrint((DEBUG_MISC, 
              "DavrGetUser. AuthUserName=%ws, AuthUserNameLen=%d\n", 
              MatchedPointer->AuthUserName,MatchedPointer->AuthUserNameLength));

    if (MatchedPointer->AuthUserName == NULL) {
        // 
        // We are always storing a user name when adding connection. So we should always
        // have a user name.
        //
        ASSERT(FALSE);
        dwErr = NERR_UserNotFound;
        DavPrint((DEBUG_ERRORS,
                  "DavrGetUser: MatchedPointer->AuthUserName == NULL. dwErr = %08lx\n",
                  dwErr));
        goto EXIT_THE_FUNCTION;
    }

    //
    // Allocate memory for the UserName to be sent back to the client. This will
    // be freed in the client code once the client is done.
    //
    *UserName = MIDL_user_allocate((1 + wcslen(MatchedPointer->AuthUserName)) * sizeof(WCHAR));
    if (*UserName == NULL) {
        dwErr = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavrGetUser/MIDL_user_allocate. dwErr = %d\n",
                  dwErr));
        goto EXIT_THE_FUNCTION;
    }

    wcscpy(*UserName, MatchedPointer->AuthUserName);

    dwErr = WN_SUCCESS;
    goto EXIT_THE_FUNCTION;

EXIT_THE_FUNCTION:

    if (ResAcquired) {
        RtlReleaseResource( &(DavUseObject.TableResource) );
        ResAcquired = FALSE;
    }

    return dwErr;
}


DWORD
DavrDoesServerDoDav(
    IN handle_t dav_binding_h,
    IN LPWSTR lpServerName,
    OUT PBOOLEAN DoesDav
    )
/*++

Routine Description:

    This routine checks whether the ServerName passed in is a valid DAV server.

Arguments:

    dav_binding_h - The explicit RPC binding handle.
    
    lpServerName - The name of the Server to query.
    
    DoesDav - TRUE if a the server is a DAV server, FALSE otherwise.

Return Value:

    ERROR_SUCCESS or the appropriate Win32 error code.

--*/
{
    DWORD WStatus = NO_ERROR;
    HINTERNET DavConnHandle = NULL, DavOpenHandle = NULL;
    BOOL ReturnVal = FALSE, fIsDav = FALSE;
    PWCHAR DataBuff = NULL;
    DWORD DataBuffBytes = 0;
    ULONG TahoeCustomHeaderLength = 0, OfficeCustomHeaderLength = 0;
    WCHAR DavCustomBuffer[100];
    BOOL bStatus = TRUE, revert = FALSE;

    DavPrint((DEBUG_DEBUG, "DavrDoesServerDoDav: ServerName = %ws\n", lpServerName));

    //
    // Go through the NonDAVServerList to see if we have an entry for this
    // server. If we do then we need not go on the network. We can fail this
    // call (return server does not speak DAV) right away. Before we call 
    // DavCheckTheNonDAVServerList, we need to take the lock that synchronizes
    // it (NonDAVServerListLock).
    //
    EnterCriticalSection( &(NonDAVServerListLock) );
    ReturnVal = DavCheckTheNonDAVServerList(lpServerName);
    LeaveCriticalSection( &(NonDAVServerListLock) );

    //
    // If we found an entry (implies ReturnVal == TRUE) for this ServerName in
    // the list of servers that do not speak DAV, we return from here.
    //
    if (ReturnVal) {
        WStatus = NO_ERROR;
        *DoesDav = FALSE;
        return WStatus;
    }

    WStatus = DavImpersonateClient();
    if (WStatus != NO_ERROR) {
        DavPrint((DEBUG_ERRORS, 
                  "DavrDoesServerDoDav/DavImpersonateClient: WStatus = %08lx\n",
                  WStatus));
        goto EXIT_THE_FUNCTION;
    }
    revert = TRUE;

    DavConnHandle = InternetConnectW(ISyncHandle,
                                     lpServerName,
                                     INTERNET_DEFAULT_HTTP_PORT,
                                     NULL,
                                     NULL,
                                     INTERNET_SERVICE_HTTP,
                                     0,
                                     0);
    if (DavConnHandle == NULL) {
        WStatus = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavrDoesServerDoDav/InternetConnectW. Error Val = %d.\n",
                  WStatus));
        goto EXIT_THE_FUNCTION;
    }

    bStatus = DavHttpOpenRequestW(DavConnHandle,
                                  L"OPTIONS",
                                  L"/",
                                  L"HTTP/1.1",
                                  NULL,
                                  NULL,
                                  INTERNET_FLAG_KEEP_CONNECTION |
                                  INTERNET_FLAG_NO_COOKIES,
                                  0,
                                  L"DavrDoesServerDoDav",
                                  &DavOpenHandle);
    if(bStatus == FALSE) {
        WStatus = GetLastError();
        goto EXIT_THE_FUNCTION;
    }
    if (DavOpenHandle == NULL) {
        WStatus = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavrDoesServerDoDav/HttpOpenRequestW. Error Val = %d\n", 
                  WStatus));
        goto EXIT_THE_FUNCTION;
    }

    //
    // We need to add the header "translate:f" to tell IIS that it should 
    // allow the user to excecute this VERB on the specified path which it 
    // would not allow (in some cases) otherwise. Finally, there is a special 
    // flag in the metabase to allow for uploading of "dangerous" content 
    // (anything that can be run on the server). This is the ScriptSourceAccess
    // flag in the UI or the AccessSource flag in the metabase. You will need
    // to set this bit to true as well as correct NT ACLs in order to be able
    // to upload .exes or anything executable.
    //
    ReturnVal = HttpAddRequestHeadersW(DavOpenHandle,
                                       L"translate: f\n",
                                       -1L,
                                       HTTP_ADDREQ_FLAG_ADD |
                                       HTTP_ADDREQ_FLAG_REPLACE );
    if (!ReturnVal) {
        WStatus = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavrDoesServerDoDav/HttpAddRequestHeadersW. "
                  "Error Val = %d\n", WStatus));
        goto EXIT_THE_FUNCTION;
    }

RESEND_THE_REQUEST:

    ReturnVal = HttpSendRequestExW(DavOpenHandle, NULL, NULL, HSR_SYNC, 0);
    if (!ReturnVal) {
        WStatus = GetLastError();
        //
        // If we fail with ERROR_INTERNET_NAME_NOT_RESOLVED, we make the
        // following call so that WinInet picks up the correct proxy settings
        // if they have changed. This is because we do call InternetOpen
        // (to create a global handle from which every other handle is derived)
        // when the service starts and this could be before the user logon
        // happpens. In such a case the HKCU would not have been initialized
        // and WinInet wouldn't get the correct proxy settings.
        //
        if (WStatus == ERROR_INTERNET_NAME_NOT_RESOLVED) {
            InternetSetOptionW(NULL, INTERNET_OPTION_SETTINGS_CHANGED, NULL, 0);
        }
        DavPrint((DEBUG_ERRORS,
                  "DavrDoesServerDoDav/HttpSendRequestExW. Error Val = %d\n", 
                  WStatus));
        goto EXIT_THE_FUNCTION;
    }

    ReturnVal = HttpEndRequestW(DavOpenHandle, NULL, HSR_SYNC, 0);
    if (!ReturnVal) {
        WStatus = GetLastError();
        //
        // If the error we got back is ERROR_INTERNET_FORCE_RETRY, then WinInet
        // is trying to authenticate itself with the server. If we get back
        // ERROR_HTTP_REDIRECT_NEEDS_CONFIRMATION, WinInet is expecting us to
        // confirm that the redirect needs to be followed. In these scenarios,
        // we need to repeat the HttpSend and HttpEnd request calls.
        //
        if (WStatus == ERROR_INTERNET_FORCE_RETRY || WStatus == ERROR_HTTP_REDIRECT_NEEDS_CONFIRMATION) {
            goto RESEND_THE_REQUEST;
        }
        DavPrint((DEBUG_ERRORS,
                  "DavrDoesServerDoDav/HttpEndRequestW. Error Val = %d\n", 
                  WStatus));
        goto EXIT_THE_FUNCTION;
    }

    WStatus = DavQueryAndParseResponse(DavOpenHandle);
    if (WStatus != ERROR_SUCCESS) {
        DavPrint((DEBUG_ERRORS,
                  "DavrDoesServerDoDav/DavQueryAndParseResponse: WStatus = %d\n", 
                  WStatus));
        goto EXIT_THE_FUNCTION;
    }

    //
    // We read the value of AcceptOfficeAndTahoeServers from the registry when
    // the WebClient service starts up. If this is set to 0, it means that we
    // should be rejecting OfficeWebServers, Tahoe servers and the shares on
    // these servers even though they speak DAV. We do this since WebFolders
    // needs to claim this name and Shell will only call into WebFolders if the
    // DAV Redir fails. If this value is non-zero, we accept all servers that
    // speak DAV.
    // 
    //
    if (AcceptOfficeAndTahoeServers == 0) {

        //
        // Figure out if this is an OFFICE Web Server. If it is then the response 
        // will have an entry "MicrosoftOfficeWebServer: ", in the header. 
        // If this is an OFFICE share then we should not claim it since the user 
        // actually intends to use the OFFICE specific features in Shell.
        //
    
        RtlZeroMemory(DavCustomBuffer, sizeof(DavCustomBuffer));
        wcscpy(DavCustomBuffer, DavOfficeCustomHeader);
        OfficeCustomHeaderLength = ( sizeof(DavCustomBuffer) / sizeof(WCHAR) );
    
        ReturnVal = HttpQueryInfoW(DavOpenHandle,
                                   HTTP_QUERY_CUSTOM,
                                   (PVOID)DavCustomBuffer,
                                   &(OfficeCustomHeaderLength), 
                                   NULL);
        if ( !ReturnVal ) {
            WStatus = GetLastError();
            if (WStatus != ERROR_HTTP_HEADER_NOT_FOUND) {
                NTSTATUS NtStatus;
                //
                // First, covert wininet error to NtStatus.
                //
                NtStatus = DavMapErrorToNtStatus(WStatus);
                //
                // Now, convert NtStatus to a win32 error.
                //
                WStatus = RtlNtStatusToDosError(NtStatus);
                DavPrint((DEBUG_ERRORS, 
                          "DavrDoesServerDoDav/HttpQueryInfoW(1): Error Val = %d\n",
                          WStatus));
                goto EXIT_THE_FUNCTION;
            } else {
                WStatus = ERROR_SUCCESS;
                DavPrint((DEBUG_MISC, "DavrDoesServerDoDav: NOT OFFICE Web Server\n"));
            }
        } else {
            DavPrint((DEBUG_MISC, "DavrDoesServerDoDav: OFFICE Web Server\n"));
            WStatus = ERROR_SUCCESS;
            *DoesDav = FALSE;
            goto EXIT_THE_FUNCTION;
        }
    
        //
        // Figure out if this is a TAHOE server. If it is then the response will 
        // have an entry "MicrosoftTahoeServer: ", in the header. If this is a 
        // TAHOE server then we should not claim it since the user actually 
        // intends to use the TAHOE specific features in Rosebud.
        //
    
        RtlZeroMemory(DavCustomBuffer, sizeof(DavCustomBuffer));
        wcscpy(DavCustomBuffer, DavTahoeCustomHeader);
        TahoeCustomHeaderLength = ( sizeof(DavCustomBuffer) / sizeof(WCHAR) );
    
        ReturnVal = HttpQueryInfoW(DavOpenHandle,
                                   HTTP_QUERY_CUSTOM,
                                   (PVOID)DavCustomBuffer,
                                   &(TahoeCustomHeaderLength),
                                   NULL);
        if ( !ReturnVal ) {
            WStatus = GetLastError();
            if (WStatus != ERROR_HTTP_HEADER_NOT_FOUND) {
                NTSTATUS NtStatus;
                //
                // First, covert wininet error to NtStatus.
                //
                NtStatus = DavMapErrorToNtStatus(WStatus);
                //
                // Now, convert NtStatus to a win32 error.
                //
                WStatus = RtlNtStatusToDosError(NtStatus);
                DavPrint((DEBUG_ERRORS, 
                          "DavrDoesServerDoDav/HttpQueryInfoW(2): Error Val = %d\n",
                          WStatus));
                goto EXIT_THE_FUNCTION;
            } else {
                WStatus = ERROR_SUCCESS;
                DavPrint((DEBUG_MISC, "DavrDoesServerDoDav: NOT TAHOE Server\n"));
            }
        } else {
            DavPrint((DEBUG_MISC, "DavrDoesServerDoDav: TAHOE Server\n"));
            WStatus = ERROR_SUCCESS;
            *DoesDav = FALSE;
            goto EXIT_THE_FUNCTION;
        }

    }

    //
    // This is NOT a TAHOE server nor an OFFICE Web Server. We go ahead and
    // query some other stuff from the header to make sure that this is a
    // DAV server.
    //

    ReturnVal = HttpQueryInfoW(DavOpenHandle,
                               HTTP_QUERY_RAW_HEADERS_CRLF,
                               DataBuff,
                               &(DataBuffBytes),
                               NULL);
    if (!ReturnVal) {
        WStatus = GetLastError();
        if (WStatus != ERROR_INSUFFICIENT_BUFFER) {
            DavPrint((DEBUG_ERRORS,
                      "DavrDoesServerDoDav/HttpQueryInfo(3). Error Val = "
                      "%d\n", WStatus));
            goto EXIT_THE_FUNCTION;
        } else {
            DavPrint((DEBUG_MISC,
                      "DavrDoesServerDoDav: HttpQueryInfo: Need Buff.\n"));
        }
    }

    //
    // Allocate memory for copying the header.
    //
    DataBuff = LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, DataBuffBytes);
    if (DataBuff == NULL) {
        WStatus = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavrDoesServerDoDav/LocalAlloc. Error Val = %d.\n",
                  WStatus));
        goto EXIT_THE_FUNCTION;
    }

    ReturnVal = HttpQueryInfoW(DavOpenHandle,
                               HTTP_QUERY_RAW_HEADERS_CRLF,
                               DataBuff,
                               &(DataBuffBytes),
                               NULL);
    if (!ReturnVal) {
        WStatus = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavrDoesServerDoDav/HttpQueryInfo(4). Error Val = "
                  "%d\n", WStatus));
        goto EXIT_THE_FUNCTION;
    }

    //
    // Check to see whether this server is a DAV server, Http Server etc.
    //
    DavObtainServerProperties(DataBuff, NULL, NULL, &fIsDav);

    //
    // NB!!!
    //
    *DoesDav = (BOOLEAN)fIsDav;

    WStatus = NO_ERROR;

EXIT_THE_FUNCTION:

    if (DavOpenHandle) {
        InternetCloseHandle(DavOpenHandle);
    }

    if (DavConnHandle) {
        InternetCloseHandle(DavConnHandle);
    }

    if (revert) {
        DWORD RStatus;
        RStatus = DavRevertToSelf();
        if (RStatus != NO_ERROR) {
            DavPrint((DEBUG_ERRORS, 
                      "DavrDoesServerDoDav/DavRevertToSelf: RStatus = %08lx\n",
                      RStatus));
        }
    }

    if (DataBuff) {
        LocalFree(DataBuff);
    }

    //
    // If this Server is not a DAV server then we need to add it to the
    // NonDAVServerList to enable -ve caching. If WStatus is ERROR_ACCESS_DENIED
    // or ERROR_ LOGON_FAILURE, then we failed since the credentials were not
    // correct. That doesn't mean that this server is not a DAV server and hence
    // we don't add it to the NonDAVServerList.
    //
    if ( (WStatus != ERROR_SUCCESS && WStatus != ERROR_ACCESS_DENIED && WStatus != ERROR_LOGON_FAILURE) ||
         (WStatus == ERROR_SUCCESS && *DoesDav == FALSE) ) {

        PNON_DAV_SERVER_ENTRY NonDavServerEntry = NULL;

        NonDavServerEntry = LocalAlloc(LPTR, sizeof(NON_DAV_SERVER_ENTRY));
        if (NonDavServerEntry != NULL) {
            NonDavServerEntry->ServerName = LocalAlloc( LPTR, ((1 + wcslen(lpServerName)) * sizeof(WCHAR)) );
            if (NonDavServerEntry->ServerName != NULL) {
                wcscpy(NonDavServerEntry->ServerName, lpServerName);
                NonDavServerEntry->TimeValueInSec = time(NULL);
                EnterCriticalSection( &(NonDAVServerListLock) );
                InsertHeadList( &(NonDAVServerList), &(NonDavServerEntry->listEntry) );
                LeaveCriticalSection( &(NonDAVServerListLock) );
            } else {
                LocalFree(NonDavServerEntry);
                NonDavServerEntry = NULL;
            }
        }

    }

    return WStatus;
}


DWORD
DavrIsValidShare(
    IN handle_t dav_binding_h,
    IN PWCHAR ServerName,
    IN PWCHAR ShareName,
    OUT PBOOLEAN ValidShare
    )
/*++

Routine Description:

    This routine checks whether the ShareName is a valid share of the server
    ServerName.

Arguments:

    dav_binding_h - The explicit RPC binding handle.
    
    ServerName - The name of the Server.
    
    ShareName - The share whose validity has to be checked.
    
    ValidShare - TRUE if a the share is valid, FALSE otherwise.

Return Value:

    ERROR_SUCCESS or the appropriate Win32 error code.

--*/
{
    DWORD WStatus = ERROR_SUCCESS;
    BOOL CricSec = FALSE, doesServerExist = FALSE, ReturnVal = FALSE;
    PDAV_SERVER_SHARE_ENTRY ServerShareEntry = NULL;
    DWORD TotalLength = 0;
    PLIST_ENTRY listEntry = NULL;
    PDAV_FILE_ATTRIBUTES ShareEntry = NULL;
    HINTERNET DavConnHandle = NULL, DavOpenHandle = NULL;
    BOOL EnCriSec = FALSE;
    PPER_USER_ENTRY PerUserEntry = NULL;
    PHASH_SERVER_ENTRY ServerHashEntry = NULL;
    LUID LogonId;
    BOOL bStatus = TRUE, revert = FALSE;
    WCHAR DavCustomBuffer[100];
    ULONG TahoeCustomHeaderLength = 0, OfficeCustomHeaderLength = 0;

    DavPrint((DEBUG_MISC,
              "DavrIsValidShare: ServerName = %ws, ShareName = %ws\n",
              ServerName, ShareName));

    //
    // Check the ServerShareTable to see if we have an entry for this
    // server. Need to take a lock on the table before doing the check.
    //
    EnterCriticalSection( &(ServerShareTableLock) );
    CricSec = TRUE;

    doesServerExist = DavIsServerInServerShareTable(ServerName, &(ServerShareEntry));

    if (doesServerExist) {

        DavPrint((DEBUG_MISC, "DavrIsValidShare: doesServerExist = TRUE\n"));

        if (ServerShareEntry->DavShareList) {

            //
            // We need to go to the server again since we cannot use the cached
            // sharenames. This is because we cannot do the access checks that
            // the server does to make sure that this particular user has access
            // to view these shares. The privileged users could have populated
            // this global cache for a non-privileged user to get the info from.
            //
            DavFinalizeFileAttributesList(ServerShareEntry->DavShareList, TRUE);

            ServerShareEntry->DavShareList = NULL;

        }

    }

    //
    // If we have an entry for this server and the share list is not NULL
    // then we will check thru this shares list. If we don't find the share,
    // then we will do a PROPFIND against this share name and figure out if it
    // exists on the server. This is because the server may NOT support the 
    // enumeration of shares at the root level OR a share might not exist in 
    // this list since it has been recently created on the server.
    //
    if (ServerShareEntry != NULL && ServerShareEntry->DavShareList != NULL ) {

        DavPrint((DEBUG_MISC, "DavrIsValidShare: Loop the share list\n"));
        
        //
        // We need to hold onto the critical section while looping through the
        // list of shares.
        //

        listEntry = &(ServerShareEntry->DavShareList->NextEntry);

        do {

            ShareEntry = CONTAINING_RECORD(listEntry, DAV_FILE_ATTRIBUTES, NextEntry);

            DavPrint((DEBUG_MISC, 
                      "DavrIsValidShare: FileName = %ws\n", ShareEntry->FileName));
        
            //
            // We are not interested in files.
            //
            if (ShareEntry->isCollection == FALSE) {
                listEntry = listEntry->Flink;
                continue;
            }

            //
            // This is a share. See if it is the same as the share passed in.
            // The comparison should be case insensitive.
            //
            if ( _wcsicmp(ShareEntry->FileName, ShareName) == 0 ) {
                DavPrint((DEBUG_MISC, 
                          "DavrIsValidShare: ShareName = %ws. Found!!\n", ShareName));
                *ValidShare = TRUE;
                WStatus = NO_ERROR;
                goto EXIT_THE_FUNCTION;
            }

            listEntry = listEntry->Flink;

        } while ( listEntry != &(ServerShareEntry->DavShareList->NextEntry) );
        //
        // If we come here, it implies that we are done looking at all the shares
        // and a match was not found.
        //
        *ValidShare = FALSE;
        WStatus = NO_ERROR;

    } else {
        *ValidShare = FALSE;
        WStatus = NO_ERROR;
    }

    ASSERT(*ValidShare == FALSE);
    ASSERT(WStatus == NO_ERROR);

    //
    // If we don't have an entry for this server or is the ShareList is NULL or
    // if we don't find this share in the shareList of this server, then we do
    // a PROPFIND against this share name and figure out if it exists on the
    // server.
    //
    
    //
    // We need to leave the CriticalSection now since we are going to go
    // over the network to figure out if a share by this name exists on the
    // server. Since we are finding this out, we can allow other threads
    // to come and look at the ServerShareTable.
    //
    LeaveCriticalSection( &(ServerShareTableLock) );
    CricSec = FALSE;

    if ( *ValidShare == FALSE && WStatus == NO_ERROR ) {

        DavPrint((DEBUG_MISC, "DavrIsValidShare: Send PROPFIND\n"));

        //
        // Impersonate caller and get the LogonId. We need this to figure out
        // whether we need to attach a cookie later on.
        //
        WStatus = DavImpersonateAndGetLogonId( &(LogonId) );
        if (WStatus != NOERROR) {
            DavPrint((DEBUG_ERRORS, 
                      "DavrIsValidShare/DavImpersonateAndGetLogonId: "
                      "WStatus = %d\n", WStatus));
            goto EXIT_THE_FUNCTION;
        }
        
        //
        // We need to impersonate the client since we are calling into WinInet.
        //

        WStatus = DavImpersonateClient();
        if (WStatus != NO_ERROR) {
            DavPrint((DEBUG_ERRORS, 
                      "DavrIsValidShare/DavImpersonateClient: WStatus = %08lx\n",
                      WStatus));
            goto EXIT_THE_FUNCTION;
        }
        revert = TRUE;

        DavConnHandle = InternetConnectW(ISyncHandle,
                                         ServerName,
                                         INTERNET_DEFAULT_HTTP_PORT,
                                         NULL,
                                         NULL,
                                         INTERNET_SERVICE_HTTP,
                                         0,
                                         0);
        if (DavConnHandle == NULL) {
            WStatus = GetLastError();
            DavPrint((DEBUG_ERRORS,
                      "DavrIsValidShare/InternetConnectW. Error Val = %d.\n",
                      WStatus));
            goto EXIT_THE_FUNCTION;
        }
    
        //
        // To find out if this is a valid share, we issue a PROPFIND against
        // this ShareName.
        //

        bStatus = DavHttpOpenRequestW(DavConnHandle,
                                      L"PROPFIND",
                                      ShareName,
                                      L"HTTP/1.1",
                                      NULL,
                                      NULL,
                                      INTERNET_FLAG_KEEP_CONNECTION |
                                      INTERNET_FLAG_NO_COOKIES,
                                      0,
                                      L"DavIsValidShare",
                                      &DavOpenHandle);
        if(bStatus == FALSE) {
                WStatus = GetLastError();
                goto EXIT_THE_FUNCTION;
        }
        if (DavOpenHandle == NULL) {
            WStatus = GetLastError();
            DavPrint((DEBUG_ERRORS,
                      "DavrIsValidShare/HttpOpenRequestW. Error Val = %d\n", 
                      WStatus));
            goto EXIT_THE_FUNCTION;
        }

        //
        // We need to figure out if we need to add any cookies for the MSN
        // scenario.
        //

        EnterCriticalSection( &(HashServerEntryTableLock) );
        EnCriSec = TRUE;

        ReturnVal = DavIsThisServerInTheTable(ServerName, &(ServerHashEntry));

        if (ReturnVal) {
        
            ASSERT(ServerHashEntry != NULL);
            
            ReturnVal = DavDoesUserEntryExist(ServerName,
                                              ServerHashEntry->ServerID,
                                              &(LogonId),
                                              &(PerUserEntry),
                                              &(ServerHashEntry));

            if (ReturnVal) {
            
                ASSERT(PerUserEntry != NULL);

                if (PerUserEntry->Cookie != NULL) {
                
                    DavPrint((DEBUG_MISC, "DavrIsValidShare: Adding Cookie\n"));
                    
                    ReturnVal = HttpAddRequestHeadersW(DavOpenHandle,
                                                       PerUserEntry->Cookie,
                                                       -1L,
                                                       HTTP_ADDREQ_FLAG_ADD |
                                                       HTTP_ADDREQ_FLAG_REPLACE );
                    if (!ReturnVal) {
                        WStatus = GetLastError();
                        DavPrint((DEBUG_ERRORS,
                                  "DavrIsValidShare/HttpAddRequestHeadersW: "
                                  "Error Val = %d\n", WStatus));
                        goto EXIT_THE_FUNCTION;
                    }
                
                }

            }

        }
        
        //
        // We don't need to hold this critical section any longer.
        //
        if (EnCriSec) {
            LeaveCriticalSection(&(HashServerEntryTableLock) );
            EnCriSec = FALSE;
        }

        //
        // Since all we need to do is figure out if this share exists, we set 
        // the depth header to 0.
        //
        ReturnVal = HttpAddRequestHeadersW(DavOpenHandle,
                                           L"Depth: 0\n",
                                           -1L,
                                           HTTP_ADDREQ_FLAG_ADD |
                                           HTTP_ADDREQ_FLAG_REPLACE );
        if (!ReturnVal) {
            WStatus = GetLastError();
            DavPrint((DEBUG_ERRORS,
                      "DavrIsValidShare/HttpAddRequestHeadersW. "
                      "Error Val = %d\n", WStatus));
            goto EXIT_THE_FUNCTION;
        }

        //
        // We need to add the header "translate:f" to tell IIS that it should 
        // allow the user to excecute this VERB on the specified path which it 
        // would not allow (in some cases) otherwise. Finally, there is a special 
        // flag in the metabase to allow for uploading of "dangerous" content 
        // (anything that can be run on the server). This is the ScriptSourceAccess
        // flag in the UI or the AccessSource flag in the metabase. You will need
        // to set this bit to true as well as correct NT ACLs in order to be able
        // to upload .exes or anything executable.
        //
        ReturnVal = HttpAddRequestHeadersW(DavOpenHandle,
                                           L"translate: f\n",
                                           -1L,
                                           HTTP_ADDREQ_FLAG_ADD |
                                           HTTP_ADDREQ_FLAG_REPLACE );
        if (!ReturnVal) {
            WStatus = GetLastError();
            DavPrint((DEBUG_ERRORS,
                      "DavrIsValidShare/HttpAddRequestHeadersW. "
                      "Error Val = %d\n", WStatus));
            goto EXIT_THE_FUNCTION;
        }

RESEND_THE_REQUEST:

        ReturnVal = HttpSendRequestExW(DavOpenHandle, NULL, NULL, HSR_SYNC, 0);
        if (!ReturnVal) {
            WStatus = GetLastError();
            //
            // If we fail with ERROR_INTERNET_NAME_NOT_RESOLVED, we make the
            // following call so that WinInet picks up the correct proxy settings
            // if they have changed. This is because we do call InternetOpen
            // (to create a global handle from which every other handle is derived)
            // when the service starts and this could be before the user logon
            // happpens. In such a case the HKCU would not have been initialized
            // and WinInet wouldn't get the correct proxy settings.
            //
            if (WStatus == ERROR_INTERNET_NAME_NOT_RESOLVED) {
                InternetSetOptionW(NULL, INTERNET_OPTION_SETTINGS_CHANGED, NULL, 0);
            }
            DavPrint((DEBUG_ERRORS,
                      "DavrIsValidShare/HttpSendRequestExW. Error Val = %d\n", 
                      WStatus));
            goto EXIT_THE_FUNCTION;
        }

        ReturnVal = HttpEndRequestW(DavOpenHandle, NULL, HSR_SYNC, 0);
        if (!ReturnVal) {
            WStatus = GetLastError();
            //
            // If the error we got back is ERROR_INTERNET_FORCE_RETRY, then WinInet
            // is trying to authenticate itself with the server. If we get back
            // ERROR_HTTP_REDIRECT_NEEDS_CONFIRMATION, WinInet is expecting us to
            // confirm that the redirect needs to be followed. In these scenarios,
            // we need to repeat the HttpSend and HttpEnd request calls.
            //
            if (WStatus == ERROR_INTERNET_FORCE_RETRY || WStatus == ERROR_HTTP_REDIRECT_NEEDS_CONFIRMATION) {
                goto RESEND_THE_REQUEST;
            }
            DavPrint((DEBUG_ERRORS,
                      "DavrIsValidShare/HttpEndRequestW. Error Val = %d\n",
                      WStatus));
            goto EXIT_THE_FUNCTION;
        }

        //
        // Query the response the server sent to see if this share exists. We
        // don't need to parse the XML response that gets returned for this
        // PROPFIND request since all that we are interested in is to find out 
        // if this share exists, not what its properties are.
        //
        WStatus = DavQueryAndParseResponse(DavOpenHandle);
        if (WStatus != ERROR_SUCCESS) {
            DavPrint((DEBUG_ERRORS,
                      "DavrIsValidShare/HttpEndRequestW. Error Val = %d\n",
                      WStatus));
            goto EXIT_THE_FUNCTION;
        }

        //
        // We read the value of AcceptOfficeAndTahoeServers from the registry when
        // the WebClient service starts up. If this is set to 0, it means that we
        // should be rejecting OfficeWebServers, Tahoe servers and the shares on
        // these servers even though they speak DAV. We do this since WebFolders
        // needs to claim this name and Shell will only call into WebFolders if the
        // DAV Redir fails. If this value is non-zero, we accept all servers that
        // speak DAV.
        // 
        //
        if (AcceptOfficeAndTahoeServers == 0) {

            //
            // Figure out if this is an OFFICE Web Share. If it is then the response 
            // will have an entry "MicrosoftOfficeWebServer: ", in the header. 
            // If this is an OFFICE share then we should not claim it since the user 
            // actually intends to use the OFFICE specific features in Shell.
            //
    
            RtlZeroMemory(DavCustomBuffer, sizeof(DavCustomBuffer));
            wcscpy(DavCustomBuffer, DavOfficeCustomHeader);
            OfficeCustomHeaderLength = ( sizeof(DavCustomBuffer) / sizeof(WCHAR) );
    
            ReturnVal = HttpQueryInfoW(DavOpenHandle,
                                       HTTP_QUERY_CUSTOM,
                                       (PVOID)DavCustomBuffer,
                                       &(OfficeCustomHeaderLength), 
                                       NULL);
            if ( !ReturnVal ) {
                WStatus = GetLastError();
                if (WStatus != ERROR_HTTP_HEADER_NOT_FOUND) {
                    NTSTATUS NtStatus;
                    //
                    // First, covert wininet error to NtStatus.
                    //
                    NtStatus = DavMapErrorToNtStatus(WStatus);
                    //
                    // Now, convert NtStatus to a win32 error.
                    //
                    WStatus = RtlNtStatusToDosError(NtStatus);
                    DavPrint((DEBUG_ERRORS, 
                              "DavrIsValidShare/HttpQueryInfoW(1): Error Val = %d\n",
                              WStatus));
                    goto EXIT_THE_FUNCTION;
                } else {
                    WStatus = ERROR_SUCCESS;
                    DavPrint((DEBUG_MISC, "DavrIsValidShare: NOT OFFICE Web Share\n"));
                }
            } else {
                DavPrint((DEBUG_MISC, "DavrIsValidShare: OFFICE Web Share\n"));
                WStatus = ERROR_BAD_NET_NAME;
                goto EXIT_THE_FUNCTION;
            }
    
            //
            // Figure out if this is a TAHOE share. If it is then the response will 
            // have an entry "MicrosoftTahoeServer: ", in the header. If this is a 
            // TAHOE server then we should not claim it since the user actually 
            // intends to use the TAHOE specific features in Rosebud.
            //
    
            RtlZeroMemory(DavCustomBuffer, sizeof(DavCustomBuffer));
            wcscpy(DavCustomBuffer, DavTahoeCustomHeader);
            TahoeCustomHeaderLength = ( sizeof(DavCustomBuffer) / sizeof(WCHAR) );
    
            ReturnVal = HttpQueryInfoW(DavOpenHandle,
                                       HTTP_QUERY_CUSTOM,
                                       (PVOID)DavCustomBuffer,
                                       &(TahoeCustomHeaderLength),
                                       NULL);
            if ( !ReturnVal ) {
                WStatus = GetLastError();
                if (WStatus != ERROR_HTTP_HEADER_NOT_FOUND) {
                    NTSTATUS NtStatus;
                    //
                    // First, covert wininet error to NtStatus.
                    //
                    NtStatus = DavMapErrorToNtStatus(WStatus);
                    //
                    // Now, convert NtStatus to a win32 error.
                    //
                    WStatus = RtlNtStatusToDosError(NtStatus);
                    DavPrint((DEBUG_ERRORS, 
                              "DavrIsValidShare/HttpQueryInfoW(2): Error Val = %d\n",
                              WStatus));
                    goto EXIT_THE_FUNCTION;
                } else {
                    WStatus = ERROR_SUCCESS;
                    DavPrint((DEBUG_MISC, "DavrIsValidShare: NOT TAHOE Share\n"));
                }
            } else {
                DavPrint((DEBUG_MISC, "DavrIsValidShare: TAHOE Share\n"));
                WStatus = ERROR_BAD_NET_NAME;
                goto EXIT_THE_FUNCTION;
            }

        }

        //
        // If we've come here, it implies that this share exists on the server.
        //
        DavPrint((DEBUG_MISC, "DavrIsValidShare: ShareName = %ws. Exists!!\n", ShareName));
        *ValidShare = TRUE;
        WStatus = NO_ERROR;

    }

EXIT_THE_FUNCTION:

    //
    // If we are returning failure, we set ValidShare to FALSE.
    //
    if (WStatus != NO_ERROR) {
        *ValidShare = FALSE;
    }

    if (CricSec) {
        LeaveCriticalSection( &(ServerShareTableLock) );
        CricSec = FALSE;
    }

    if (EnCriSec) {
        LeaveCriticalSection(&(HashServerEntryTableLock) );
        EnCriSec = FALSE;
    }

    if (DavOpenHandle) {
        InternetCloseHandle(DavOpenHandle);
        DavOpenHandle = NULL;
    }

    if (DavConnHandle) {
        InternetCloseHandle(DavConnHandle);
        DavConnHandle = NULL;
    }

    if (revert) {
        DWORD RStatus;
        RStatus = DavRevertToSelf();
        if (RStatus != NO_ERROR) {
            DavPrint((DEBUG_ERRORS, 
                      "DavrIsValidShare/DavRevertToSelf: RStatus = %08lx\n",
                      RStatus));
        }
    }
    
    return WStatus;
}


DWORD
DavrGetConnection(
    IN handle_t dav_binding_h,
    IN LPWSTR lpLocalName,
    OUT LPWSTR *lpRemoteName,
    OUT PBOOLEAN Connected
    )
/*++

Routine Description:

    This routine checks whether the LocalName passed in is mapped to a network
    drive. If it is, then the RemoteName buffer is filled in with the remote
    name the Local drive is mapped to.

Arguments:

    dav_binding_h - The explicit RPC binding handle.
    
    lpLocalName - The Local device name to be checked.
    
    lpRemoteName - Buffer to fill in the remote name if the local name is
                   connected.

    Connected - TRUE if a connection exists, FALSE otherwise.

Return Value:

    ERROR_SUCCESS or the appropriate Win32 error code.

--*/
{
    DWORD dwErr = NO_ERROR;
    BOOLEAN ResAcquired = FALSE;
    DWORD index = 0;
    PDAV_USE_ENTRY DavUseEntry = NULL;
    LUID LogonId; // Logon Id of user.

    DavPrint((DEBUG_MISC, "DavrGetConnection: lpLocalName = %ws\n", lpLocalName));

    //
    // Impersonate caller and get the LogonId.
    //
    dwErr = DavImpersonateAndGetLogonId( &(LogonId) );
    if (dwErr != NO_ERROR) {
        DavPrint((DEBUG_ERRORS, 
                  "DavrGetConnection/DavImpersonateAndGetLogonId: dwErr = %08lx\n",
                  dwErr));
        goto EXIT_THE_FUNCTION;
    }

    DavPrint((DEBUG_MISC, "DavrGetConnection: LogonId = %d %d\n", LogonId.HighPart, LogonId.LowPart));

    //
    // Lock the Dav Use Table while looking for entry to query.
    //
    if ( !RtlAcquireResourceExclusive( &(DavUseObject.TableResource), TRUE ) ) {
        DavPrint((DEBUG_ERRORS, 
                  "DavrGetConnection/RtlAcquireResourceExclusive.\n"));
        dwErr = NERR_InternalError;
        goto EXIT_THE_FUNCTION;
    }

    ResAcquired = TRUE;

    //
    // See if the use entry is an explicit connection.
    //
    dwErr = DavGetUserEntry( &(DavUseObject), &(LogonId), &(index), FALSE );
    if (dwErr != NERR_Success) {
        dwErr = ERROR_NOT_FOUND;
        goto EXIT_THE_FUNCTION;
    }
    
    DavUseEntry = (PDAV_USE_ENTRY) DavUseObject.Table[index].List;

    while (DavUseEntry != NULL) {

        //
        // If this connection has no local name, then we just continue.
        //
        if (DavUseEntry->Local == NULL) {
            DavUseEntry = DavUseEntry->Next;
            continue;
       }

       if ( _wcsicmp(DavUseEntry->Local, lpLocalName) == 0 ) {

           //
           // We found a remote name that is associated with a LocalName
           // on this machine. 
           //
           if(Connected != NULL) {
               *Connected = TRUE;
           }

           //
           // Allocate memory for the lpRemoteName to be sent back to the
           // client. This will be freed in the client code once the
           // client is done.
           //
           *lpRemoteName = MIDL_user_allocate((1 + wcslen((LPWSTR)DavUseEntry->Remote->UncName)) * sizeof(WCHAR));
           if (*lpRemoteName == NULL) {
               dwErr = GetLastError();
               DavPrint((DEBUG_ERRORS,
                         "DavrGetConnection/MIDL_user_allocate. dwErr = %d\n",
                         dwErr));
               goto EXIT_THE_FUNCTION;
           }
           wcscpy(*lpRemoteName, (LPWSTR)DavUseEntry->Remote->UncName);

           DavPrint((DEBUG_MISC,
                     "DavrGetConnection: FOUND!!! LocalName = %ws, RemoteName = %ws\n",
                     lpLocalName, lpRemoteName));

           dwErr = NO_ERROR;

           goto EXIT_THE_FUNCTION;

        }

        DavUseEntry = DavUseEntry->Next;

    } // end while

    // 
    // The use is not found after while loop.
    //
    dwErr = ERROR_NOT_FOUND;
    goto EXIT_THE_FUNCTION;

EXIT_THE_FUNCTION:

    if (ResAcquired) {
        RtlReleaseResource( &(DavUseObject.TableResource) );
    }

    return dwErr;
}


DWORD
DavrEnumServers(
    IN handle_t dav_binding_h,
    IN LPDWORD EntryIndex,
    OUT PWCHAR *ServerName,
    OUT PBOOLEAN Done
    )
/*++

Routine Description:

    This routine fills in the Server names on accessed on this machine. This is called by 
    NPEnumResource on the client when it is enumerating all the DAV servers. One server 
    is returned per call.

Arguments:

    dav_binding_h - The explicit RPC binding handle.
    
    EntryIndex - The index of the entry from where we start. On return this 
                 contains the index of the entry from where one begins 
                 enumerating next time if necessary.    

    Note: Do not alter value of this entry outside this function - else it may result in 
    unexpected behavior of enumeration.

    ServerName - The server being returned.
    
    Done - Are we done with all the entries.
    
Return Value:

    ERROR_SUCCESS or the appropriate Win32 error code.

--*/
{
    DWORD WStatus = NO_ERROR;
    BOOL CricSec = FALSE, fPresent = FALSE, fDone = FALSE;
    PHASH_SERVER_ENTRY SHEntry = NULL;
    DWORD IndexCount = 0;
    PLIST_ENTRY listEntry = NULL;
    PWCHAR EntryServerName = NULL;
    DWORD EntryServerNameLen = 0;
    DWORD LookFromServerHashId = 0;
    DWORD IndexOfEntryInHashList = 0;
    DWORD EntryCount = 0;

    DavPrint((DEBUG_MISC,
              "DavrEnumServers: *EntryIndex = %u, *Done = %d\n",
              *EntryIndex, *Done));

    if (EntryIndex == NULL || Done == NULL || ServerName == NULL) {
        WStatus = ERROR_INVALID_PARAMETER;
        DavPrint((DEBUG_ERRORS, "DavrEnumServers : Invalid parameters\n"));
        goto EXIT_THE_FUNCTION;
    }

    // 
    // To enumerate the servers - we have to go thru whole hash table.
    // This function can be called many time in one single enumeration operation,
    // each time with different EntryIndex to say: return next entry.
    // 
    // EntryIndex is used to indicate entry number to be returned from the whole list
    // of enumeration. It can start from 0: 0,1,2,...
    // In such case, to return any next server entry, we have to go thru all entries in 
    // hash table until the desired entry number is reached.
    //
    // To optimize here, we are using special coding of variable EntryIndex. In
    // this case it won't follow standard sequence 0,1,2,...
    // Rather:
    //        EntryIndex = SERVER_TABLE_SIZE * LookFromServerHashId + 
    //                                         IndexOfEntryInHashList
    // => Start looking from HashList of ServerHashId (LookFromServerHashId ), and return
    // entry number (IndexOfEntryInHashList) in this list. If this list don't
    // contain any entry of this number, then go to next HashList and so on...
    //
    // For first time, EntryIndex is 0 => Start from HashId = 0 in table, 
    // from first entry of it.
    //
    // Now IndexOfEntryInHashList = [0,...,MAX_NUMBER_OF_SERVER_ENTRIES_PER_HASH_ID]
    //
    // So:
    //    LookFromServerHashId = EntryIndex / MAX_NUMBER_OF_SERVER_ENTRIES_PER_HASH_ID
    //    IndexOfEntryInHashList = 
    //                           EntryIndex % MAX_NUMBER_OF_SERVER_ENTRIES_PER_HASH_ID
    //
    // We are defining:
    //     MAX_NUMBER_OF_SERVER_ENTRIES_PER_HASH_ID = Max(DWORD)/ SERVER_TABLE_SIZE
    //     Where Max(DWORD) = Maximum value of DWORD => (DWORD)(-1)
    //

    fPresent = FALSE;
    fDone = FALSE;
    *Done = FALSE;
    EntryCount = 0;

    if (ServerIDCount == 0) {
        *Done = TRUE;
        WStatus = NO_ERROR;
        DavPrint((DEBUG_MISC, "DavrEnumServers : No server entry in hash table\n"));
        goto EXIT_THE_FUNCTION;
    }


    LookFromServerHashId = (*EntryIndex) / MAX_NUMBER_OF_SERVER_ENTRIES_PER_HASH_ID;
    IndexOfEntryInHashList = (*EntryIndex) % MAX_NUMBER_OF_SERVER_ENTRIES_PER_HASH_ID;

    if (LookFromServerHashId >= SERVER_TABLE_SIZE) {
        WStatus = NO_ERROR;
        *Done = TRUE;
        DavPrint((DEBUG_MISC,
                  "DavrEnumServers : *EntryIndex OUTSIDE HashTable = %u\n",
                  *EntryIndex));
        goto EXIT_THE_FUNCTION;
    }

    EnterCriticalSection( &(HashServerEntryTableLock) );
    CricSec = TRUE;

    while (fDone == FALSE) {
        // 
        // Get Server entry of index = IndexOfEntryInHashList in the 
        // current Servers HashList.
        //
        IndexCount = 0;
        listEntry = ServerHashTable[LookFromServerHashId].Flink;
        while( listEntry != NULL && 
               listEntry != &(ServerHashTable[LookFromServerHashId]) && 
               IndexCount != IndexOfEntryInHashList ) {
            listEntry = listEntry->Flink;
            IndexCount++;
            EntryCount++;
        }
        if ( listEntry == NULL || listEntry == &(ServerHashTable[LookFromServerHashId]) ) {
            LookFromServerHashId ++;
            IndexOfEntryInHashList = 0;
            if (EntryCount >= ServerIDCount || LookFromServerHashId >= SERVER_TABLE_SIZE) {
                fDone = TRUE;
            }
        } else {
            SHEntry = CONTAINING_RECORD(listEntry, HASH_SERVER_ENTRY, ServerListEntry);
            // 
            // Check that the entry found is of DAV server.
            // If Yes, then return else move on to next entries.
            //
            if (SHEntry->isDavServer == TRUE) {
                fDone = TRUE;
                fPresent = TRUE;
            } else {
                LookFromServerHashId ++;
                IndexOfEntryInHashList = 0;
                if (LookFromServerHashId >= SERVER_TABLE_SIZE) {
                    fDone = TRUE;
                }
            }
        }
    }
    
    //
    // There could be no DAV servers accessed yet.
    //
    if (fPresent == FALSE) {
        DavPrint((DEBUG_MISC, "DavrEnumServers : No Servers found\n"));
        *Done = TRUE;
        WStatus = NO_ERROR;
        goto EXIT_THE_FUNCTION;
    }

    // 
    // Control comes here if a server of required *EntryIndex is found.
    // i.e. fPresent = TRUE.
    // 

    EntryServerName = SHEntry->ServerName;
    EntryServerNameLen = 2 + wcslen(EntryServerName) + 1; // 2 for L"\\" before name.

    //
    // Allocate memory for the ServerName to be sent back to the client. This
    // will be freed in the client code once the client is done.
    //
    *ServerName = MIDL_user_allocate(EntryServerNameLen * sizeof(WCHAR));
    if (*ServerName == NULL) {
        WStatus = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavrEnumServers/MIDL_user_allocate. WStatus = %d\n",
                  WStatus));
        goto EXIT_THE_FUNCTION;
    }

    // 
    // We have to return UNC-server name.
    //
    wcscpy(*ServerName, L"\\\\");
    wcscat(*ServerName, EntryServerName);

    //
    // We return one entry at a time.
    //
    *EntryIndex = ((LookFromServerHashId * MAX_NUMBER_OF_SERVER_ENTRIES_PER_HASH_ID) + 
                   IndexOfEntryInHashList + 
                   1); // for next entry.

    DavPrint((DEBUG_MISC,
              "DavrEnumServers: NextIndex = %u, ServerName = %ws\n",
              *EntryIndex, ServerName));

    WStatus = NO_ERROR;
    goto EXIT_THE_FUNCTION;

EXIT_THE_FUNCTION:

    if (CricSec) {
        LeaveCriticalSection( &(HashServerEntryTableLock) );
        CricSec = FALSE;
    }

    return WStatus;
}


DWORD
DavrEnumShares(
    IN handle_t dav_binding_h,
    IN LPDWORD EntryIndex,
    IN PWCHAR ServerName,
    OUT PWCHAR *ShareName,
    OUT PBOOLEAN Done
    )
/*++

Routine Description:

    This routine fills in the Share names on this server. This is called by 
    NPEnumResource on the client when it is enumerating all the DAV shares
    on the server. One share is returned per call.

Arguments:

    dav_binding_h - The explicit RPC binding handle.
    
    EntryIndex - The index of the entry from where we start. On return this 
                 contains the index of the entry from where one begins 
                 enumerating next time if necessary.    

    LocalName - The Server whose shares are being enumerated.
    
    ShareName - The share being returned.
    
    Done - Are we done with all the entries.
    
Return Value:

    ERROR_SUCCESS or the appropriate Win32 error code.

--*/
{
    DWORD WStatus = NO_ERROR;
    BOOL CricSec = FALSE, doesServerExist = FALSE;
    PDAV_SERVER_SHARE_ENTRY ServerShareEntry = NULL;
    DWORD TotalLength, IndexCount = 0;
    PLIST_ENTRY listEntry = NULL;
    PDAV_FILE_ATTRIBUTES ShareEntry;

    DavPrint((DEBUG_MISC,
              "DavrEnumShares: Index = %d, ServerName = %ws\n",
              *EntryIndex, ServerName));

    //
    // Check the ServerShareTable to see if we have an entry for this
    // server. Need to take a lock on the table before doing the check.
    //
    EnterCriticalSection( &(ServerShareTableLock) );
    CricSec = TRUE;

    //
    // If we are starting the enumeration, we need to figure out the following:
    // 1. The server exists.
    // 2. If it does, whether the DavShareList is still valid.
    //
    if ( *EntryIndex == 0 ) {
    
        doesServerExist = DavIsServerInServerShareTable(ServerName, &(ServerShareEntry));

        if ( !doesServerExist ) {

            //
            // Create a new ServerShare entry for this server.
            //
            TotalLength = ( sizeof(DAV_SERVER_SHARE_ENTRY) + 
                            ( ( wcslen(ServerName) + 1 ) * sizeof(WCHAR) ) );

            ServerShareEntry = LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, TotalLength);
            if (ServerShareEntry == NULL) {
                WStatus = GetLastError();
                DavPrint((DEBUG_ERRORS,
                          "DavrEnumShares/LocalAlloc. Error Val = %d.\n",
                          WStatus));
                goto EXIT_THE_FUNCTION;
            }

            //
            // Initialize the ServerShare entry and insert it into the global 
            // ServerShareEntry table.
            //
            DavInitializeAndInsertTheServerShareEntry(ServerShareEntry,
                                                      ServerName,
                                                      TotalLength);

    
        } else {

            //
            // We need to go to the server again since we cannot use the cached
            // sharenames. This is because we cannot do the access checks that
            // the server does to make sure that this particular user has access
            // to view these shares. The privileged users could have populated
            // this global cache for a non-privileged user to get the info from.
            //
            DavFinalizeFileAttributesList(ServerShareEntry->DavShareList, TRUE);

            ServerShareEntry->DavShareList = NULL;

        }

    } else {

        doesServerExist = DavIsServerInServerShareTable(ServerName, &(ServerShareEntry));
        if (!doesServerExist) {
            ASSERT(FALSE);
            WStatus = ERROR_INVALID_PARAMETER;
            goto EXIT_THE_FUNCTION;
        }

    }

    //
    // If we don't have a list of shares, then we need to go to the server and 
    // get them.
    //
    if ( ServerShareEntry->DavShareList == NULL ) {
        
        ASSERT(*EntryIndex == 0);
        
        WStatus = DavGetShareListFromServer(ServerShareEntry);
        if (WStatus != ERROR_SUCCESS) {
            DavPrint((DEBUG_ERRORS,
                      "DavrEnumShares/DavGetShareListFromServer. Error Val = %d.\n",
                      WStatus));
            goto EXIT_THE_FUNCTION;
        }
    
        //
        // There could be no shares exposed on the DAV server.
        //
        if (ServerShareEntry->NumOfShares == 0) {
            DavPrint((DEBUG_MISC,
                      "DavrEnumShares: ServerName = %ws. No Shares\n", ServerName));
            *Done = TRUE;
            WStatus = NO_ERROR;
            goto EXIT_THE_FUNCTION;
        }
    
    }

    listEntry = &(ServerShareEntry->DavShareList->NextEntry);

    do {

        ShareEntry = CONTAINING_RECORD(listEntry, DAV_FILE_ATTRIBUTES, NextEntry);

        //
        // We are not interested in files and the share /.
        //
        if (ShareEntry->isCollection == FALSE || 
            _wcsicmp(ShareEntry->FileName, L"/") == 0) {
            listEntry = listEntry->Flink;
            continue;
        }

        //
        // We might have already returned a few share names.
        //
        if ( IndexCount < *EntryIndex ) {
            IndexCount++;
            listEntry = listEntry->Flink;
            continue;
        }

        //
        // Allocate memory for the ShareName to be sent back to the client. This
        // will be freed in the client code once the client is done.
        //
        *ShareName = MIDL_user_allocate((1 + wcslen(ShareEntry->FileName)) * sizeof(WCHAR));
        if (*ShareName == NULL) {
            WStatus = GetLastError();
            DavPrint((DEBUG_ERRORS,
                      "DavrEnumShares/MIDL_user_allocate. Error Val = %d\n",
                      WStatus));
            goto EXIT_THE_FUNCTION;
        }

        //
        // We haven't sent this one. Copy the share name and return.
        //
        wcscpy(*ShareName, ShareEntry->FileName);

        //
        // We return one entry at a time.
        //
        WStatus = NO_ERROR;
        goto EXIT_THE_FUNCTION;

    } while ( listEntry != &(ServerShareEntry->DavShareList->NextEntry) );

    //
    // If we come here, it implies that we are done returning all the entries.
    //
    *Done = TRUE;
    WStatus = NO_ERROR;
    
EXIT_THE_FUNCTION:

    if (CricSec) {
        LeaveCriticalSection( &(ServerShareTableLock) );
    }

    return WStatus;
}


DWORD
DavrEnumNetUses(
    IN handle_t dav_binding_h,
    IN LPDWORD EntryIndex,
    OUT PWCHAR *LocalName,
    OUT PWCHAR *RemoteName,
    OUT PBOOLEAN Done
    )
/*++

Routine Description:

    This routine fills in the Local and Remote names of a net use. This is 
    called by NPEnumResource on the client when it is enumerating all the net
    uses on the machine.

Arguments:

    dav_binding_h - The explicit RPC binding handle.
    
    EntryIndex - The index of the entry from where we start. On return this 
                 contains the index of the entry from where one begins 
                 enumerating next time if necessary.    

    LocalName - The LocalName of a net use.
    
    RemoteName - The RemoteName of a net use.
    
    Done - Are we done with all the entries.
    
Return Value:

    ERROR_SUCCESS or the appropriate Win32 error code.

--*/
{
    DWORD dwErr = NO_ERROR;
    DWORD BeginIndex, IndexCount = 0, index;
    BOOLEAN ResAcquired = FALSE;
    PDAV_USE_ENTRY DavUseEntry = NULL;
    LUID LogonId;

    //
    // We start with the assumption that we're not done.
    //
    *Done = FALSE;

    BeginIndex = *EntryIndex;

    DavPrint((DEBUG_MISC, "DavrEnumNetUses: BeginIndex = %d\n", BeginIndex));

    dwErr = DavImpersonateAndGetLogonId( &(LogonId) );
    if (dwErr != NO_ERROR) {
        DavPrint((DEBUG_ERRORS, 
                  "DavrEnumNetUses/DavImpersonateAndGetLogonId: dwErr = %08lx\n",
                  dwErr));
        goto EXIT_THE_FUNCTION;
    }

    if ( !RtlAcquireResourceExclusive(&DavUseObject.TableResource, TRUE) ) {
        dwErr = NERR_InternalError;
        DavPrint((DEBUG_ERRORS,
                  "DavrEnumNetUses/RtlAcquireResourceExclusive: Internal Error.\n"));
        goto EXIT_THE_FUNCTION;
    }

    ResAcquired = TRUE;

    //
    // Go through the DAV_USE_ENTRY list of all the users.
    //
    for (index = 0; index < DavUseObject.TableSize; index++) {
    
        if ( !DavUseObject.Table[index].List ) {
            continue;
        }
        
        if (!RtlEqualLuid(&(DavUseObject.Table[index].LogonId), &LogonId)) {
            continue;
        }
        
        DavUseEntry = (PDAV_USE_ENTRY)DavUseObject.Table[index].List;

        while (DavUseEntry) {

            //
            // We could have returned a few entries already. BeginIndex gives
            // us the number of entries we have already returned. In this case, 
            // we should start from the first entry which was not returned.
            //
            if (IndexCount < BeginIndex) {
                IndexCount++;
                DavUseEntry = DavUseEntry->Next;
                continue;
            }

            if (DavUseEntry->Local) {
                //
                // Allocate memory for the LocalName to be sent back to the
                // client. This will be freed in the client code once the
                // client is done.
                //
                *LocalName = MIDL_user_allocate((1 + wcslen(DavUseEntry->Local)) * sizeof(WCHAR));
                if (*LocalName == NULL) {
                    dwErr = GetLastError();
                    DavPrint((DEBUG_ERRORS,
                              "DavrEnumNetUses/MIDL_user_allocate. dwErr = %d\n",
                              dwErr));
                    goto EXIT_THE_FUNCTION;
                }
                wcscpy(*LocalName, DavUseEntry->Local);
                DavPrint((DEBUG_MISC, "DavrEnumNetUses: Local= %ws\n", LocalName));
            }

            //
            // Allocate memory for the RemoteName to be sent back to the client.
            // This will be freed in the client code once the client is done.
            //
            *RemoteName = MIDL_user_allocate((1 + wcslen((LPWSTR)DavUseEntry->Remote->UncName)) * sizeof(WCHAR));
            if (*RemoteName == NULL) {
                dwErr = GetLastError();
                DavPrint((DEBUG_ERRORS,
                          "DavrEnumNetUses/MIDL_user_allocate. dwErr = %d\n",
                          dwErr));
                goto EXIT_THE_FUNCTION;
            }
            wcscpy(*RemoteName, (LPWSTR)DavUseEntry->Remote->UncName);
            DavPrint((DEBUG_MISC, "DavrEnumNetUses: Remote = %ws\n", RemoteName));

            //
            // We return one pair of Local and Remote names at a time.
            //
            dwErr = NO_ERROR;
            goto EXIT_THE_FUNCTION;

        } // end while

    } // end for

    //
    // If we come here, it means that we are done sending all the net uses.
    //
    dwErr = NO_ERROR;
    *Done = TRUE;

EXIT_THE_FUNCTION:

    if (ResAcquired) {
        RtlReleaseResource( &(DavUseObject.TableResource) );
    }

    return dwErr;
}


DWORD
DavCheckLocalName(
    LPWSTR LocalName,
    PWCHAR OutputLocalDeviceBuffer
    )
/*++

Routine Description:

    This only handles NULL, empty string, and L"X:" formats.

Arguments:

    LocalName - Supplies the local device name to map to the created tree
                connection.  Only drive letter device names are accepted.  (No
                LPT or COM).

    OutputLocalDeviceBuffer - The drive letter is copied into this and returned.

Return Value:

    ERROR_SUCCESS or the appropriate Win32 error code.

--*/
{
    DWORD LocalNameLength;

    if (OutputLocalDeviceBuffer == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    LocalNameLength = ( LocalName == NULL ) ? 0 : wcslen( LocalName );

    if (LocalNameLength == 0) {
        *OutputLocalDeviceBuffer = L'\0';
        return ERROR_SUCCESS;
    }

    if (LocalNameLength != 2 || !iswalpha(*LocalName) || LocalName[1] != L':') {
        return ERROR_BAD_DEVICE;
    }

    lstrcpyW( OutputLocalDeviceBuffer, LocalName );

    _wcsupr( OutputLocalDeviceBuffer );

    return ERROR_SUCCESS;
}


DWORD
DavCheckRemoteName(
    IN LPWSTR LocalName OPTIONAL,
    IN LPWSTR RemoteName,
    OUT LPWSTR *OutputBuffer,
    OUT LPDWORD OutputBufferLength OPTIONAL
    )
/*++

Routine Description:

    This routine validates and canonicalizes the supplied
    UNC name.  It can be of any length in the form of:

        \\Server\Volume\Directory\Subdirectory

Arguments:

    LocalName - Supplies the local device name.  If it is NULL or empty, then
                \\Server is an acceptable format for the UNC name.

    RemoteName - Supplies the UNC name.

    OutputBuffer - Receives a pointer to the canonicalized RemoteName.

    OutputBufferLength - Receives the length of the canonicalized name in
                         number of characters, if specified.

Return Value:

    NO_ERROR - RemoteName is valid.

    WN_BAD_NETNAME - RemoteName is invalid.

--*/
{
    DWORD RemoteNameLength;
    DWORD i;
    DWORD TokenLength;
    LPWSTR TokenPtr = NULL;
    BOOL  fFirstToken = TRUE;
    BOOL  fLocalNamePresent = FALSE;

    if (OutputBuffer == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // If a LocalName was specified, we set fLocalNamePresent to TRUE.
    //
    if (LocalName) {
        fLocalNamePresent = TRUE;
    }

    DavPrint((DEBUG_MISC, "DavCheckRemoteName: fLocalNamePresent = %d\n", 
              fLocalNamePresent));
    
    //
    // The remote name cannot be a NULL or an empty string.
    //
    if (RemoteName == NULL || *RemoteName == 0) {
        return WN_BAD_NETNAME;
    }

    RemoteNameLength = wcslen(RemoteName);

    //
    // Must be at least \\x\y if local device name is specified. Otherwise it 
    // must be at least \\x.
    //
    if ( (RemoteNameLength < 5 && fLocalNamePresent) || (RemoteNameLength < 3) ) {
        return WN_BAD_NETNAME;
    }

    //
    // First two characters must be "\\"
    //
    if (*RemoteName != L'\\' || RemoteName[1] != L'\\') {
        return WN_BAD_NETNAME;
    }

    if (!fLocalNamePresent && (IS_VALID_SERVER_TOKEN(&RemoteName[2], RemoteNameLength - 2))) {

        //
        // Return success for \\Server case.
        //
        *OutputBuffer = (PVOID) LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT,
                                           (RemoteNameLength + 1) * sizeof(WCHAR));
        if (*OutputBuffer == NULL) {
            KdPrint(("DAV: DAVCanonRemoteName LocalAlloc failed %lu\n",
                     GetLastError()));
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        wcscpy(*OutputBuffer, RemoteName);

        return NO_ERROR;
    }

    //
    // Must have at least one more backslash after the third character.
    //
    if (wcschr(&RemoteName[3], L'\\') == NULL) {
        return WN_BAD_NETNAME;
    }

    //
    // Last character cannot a backward slash.
    //
    if (RemoteName[RemoteNameLength - 1] == L'\\') {
        return WN_BAD_NETNAME;
    }

    //
    // Allocate output buffer.  Should be the size of the RemoteName and space
    // for an extra character to simplify parsing code below.
    //
    *OutputBuffer = (PVOID) LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT,
                                       (RemoteNameLength + 2) * sizeof(WCHAR));
    if (*OutputBuffer == NULL) {
        KdPrint(("DAV: DAVCanonRemoteName LocalAlloc failed %lu\n",
                 GetLastError()));
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    wcscpy(*OutputBuffer, RemoteName);

    //
    // Convert all backslashes to NULL terminator, skipping first 2 chars.
    //
    for (i = 2; i < RemoteNameLength; i++) {
        
        if ((*OutputBuffer)[i] == L'\\') {

            (*OutputBuffer)[i] = 0;

            //
            // Two consecutive forward or backslashes is bad.
            //
            if ( ( (i + 1) < RemoteNameLength ) 
                 && ( (*OutputBuffer)[i + 1] == L'\\' ) ) {

                LocalFree((HLOCAL) *OutputBuffer);
                *OutputBuffer = NULL;
                return WN_BAD_NETNAME;
            }
        }
    }

    //
    // Validate each token of the RemoteName, separated by NULL terminator.
    //
    TokenPtr = *OutputBuffer + 2;  // Skip first 2 chars

    while (*TokenPtr != 0) {

        TokenLength = wcslen(TokenPtr);

        if ( ( fFirstToken && !IS_VALID_SERVER_TOKEN(TokenPtr, TokenLength)) ||
             ( !fFirstToken && !IS_VALID_TOKEN(TokenPtr, TokenLength)) ) {

            (void) LocalFree((HLOCAL) *OutputBuffer);
            *OutputBuffer = NULL;
            return WN_BAD_NETNAME;
        }

        fFirstToken = FALSE;
        TokenPtr += TokenLength + 1;
    }

    //
    // Convert NULL separators back to backslashes.
    //
    for (i = 0; i < RemoteNameLength; i++) {
        if ((*OutputBuffer)[i] == 0) {
            (*OutputBuffer)[i] = L'\\';
        }
    }

    if (ARGUMENT_PRESENT(OutputBufferLength)) {
        *OutputBufferLength = RemoteNameLength;
    }

    return NO_ERROR;
}


DWORD
DavCreateTreeConnectName(
    IN  LPWSTR UncName,
    IN  LPWSTR LocalName OPTIONAL,
    IN ULONG SessionId,
    OUT PUNICODE_STRING TreeConnectStr
    )
/*++

Routine Description:

    This function replaces \\ with \Device\DavRdr\LocalName:\ in the
    UncName to form the NT-style tree connection name.  LocalName:\ is part
    of the tree connection name only if LocalName is specified.  A buffer
    is allocated by this function and returned as the output string.

Arguments:

    UncName - Supplies the UNC name of the shared resource.

    LocalName - Supplies the local device name for the redirection.

    SessionId - Id that uniquely identifies a Hydra session. This value is 
                always 0 for non-hydra NT and console hydra session.

    TreeConnectStr - Returns a string with a newly allocated buffer that
                     contains the NT-style tree connection name.

Return Value:

    NO_ERROR - The operation was successful.

    ERROR_NOT_ENOUGH_MEMORY - Could not allocate output buffer.

--*/
{
    DWORD UncNameLength = wcslen(UncName);
    BOOL  fLocalNamePresent = FALSE;
    WCHAR IdBuffer[18];
    UNICODE_STRING IdString;

    RtlZeroMemory(IdBuffer, sizeof(IdBuffer));

    if ( g_LUIDDeviceMapsEnabled == TRUE ) {

        LUID LogonId;
        DWORD dwErr;

        dwErr = DavImpersonateAndGetLogonId( &(LogonId) );
        if (dwErr != NO_ERROR) {
            DavPrint((DEBUG_ERRORS, 
                      "DavCreateTreeConnectName/DavImpersonateAndGetLogonId: "
                      "dwErr = %08lx\n", dwErr));
            return (dwErr);
        }

        _snwprintf( IdBuffer,
                    sizeof(IdBuffer)/sizeof(WCHAR),
                    L"%08x%08x",
                    LogonId.HighPart,
                    LogonId.LowPart );

        IdBuffer[17] = L'\0';

        RtlInitUnicodeString( &IdString, IdBuffer );

    } else {

        IdString.Length = 0;
        IdString.MaximumLength = sizeof(IdBuffer);
        IdString.Buffer = IdBuffer;

        RtlIntegerToUnicodeString(SessionId, 10, &IdString);

    }

    //
    // If a LocalName was specified, we set fLocalNamePresent to TRUE.
    //
    if (LocalName) {
        fLocalNamePresent = TRUE;
    }

    if (TreeConnectStr == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Initialize tree connect string maximum length to hold
    // "\Device\DavRdr\;LocalName:ID\Server\Volume\Path".
    // The ";Localname:ID" is done because that is what RDBSS expects. 
    // Its one of those legacy things!!!
    // If LUID DosDevice enabled, then ID = SessionId, else ID = LogonId
    //
    TreeConnectStr->MaximumLength = wcslen(DD_DAV_DEVICE_NAME_U) * sizeof(WCHAR);
    TreeConnectStr->MaximumLength += sizeof(WCHAR); // For '\'
    TreeConnectStr->MaximumLength += (ARGUMENT_PRESENT(LocalName) ? (wcslen(LocalName) * sizeof(WCHAR)) : 0);

    //
    // Includes '\' and the term char.
    //
    TreeConnectStr->MaximumLength += (USHORT) ( UncNameLength * sizeof(WCHAR) );

    //
    // For ; in ";LocalName:ID".
    //
    TreeConnectStr->MaximumLength += sizeof(WCHAR);

    //
    // For the ID in ";LocalName:ID".
    //
    TreeConnectStr->MaximumLength += IdString.Length;
    
    TreeConnectStr->Buffer = (PWSTR) LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT,
                                                TreeConnectStr->MaximumLength);
    if (TreeConnectStr->Buffer == NULL) {
        DavPrint((DEBUG_ERRORS,
                  "DavCreateTreeConnectName/LocalAlloc: WStatus = %08lx\n",
                  GetLastError()));
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Copy \Device\DavRdr.
    //
    RtlCopyMemory(TreeConnectStr->Buffer, 
                  DD_DAV_DEVICE_NAME_U, 
                  ( wcslen(DD_DAV_DEVICE_NAME_U) * sizeof(WCHAR) ));

    TreeConnectStr->Length = ( wcslen(DD_DAV_DEVICE_NAME_U) * sizeof(WCHAR) );
    
    //
    // Concatenate "\;LocalName:ID".
    //
    if (fLocalNamePresent) {
        
        wcscat(TreeConnectStr->Buffer, L"\\");
        
        TreeConnectStr->Length += sizeof(WCHAR);

        wcscat(TreeConnectStr->Buffer, L";");
        
        TreeConnectStr->Length += sizeof(WCHAR);

        wcscat(TreeConnectStr->Buffer, LocalName);

        TreeConnectStr->Length += (USHORT) (wcslen(LocalName) * sizeof(WCHAR));
    
        RtlAppendUnicodeStringToString( TreeConnectStr, &IdString );
        
    }

    //
    // Concatenate \Server\Volume\Path.
    //
    wcscat(TreeConnectStr->Buffer, &UncName[1]);
    TreeConnectStr->Length += (USHORT) ((UncNameLength - 1) * sizeof(WCHAR));

    return NO_ERROR;
}


DWORD
DavOpenCreateConnection(
    IN PUNICODE_STRING TreeConnectionName,
    IN LPWSTR UserName OPTIONAL,
    IN LPWSTR Password OPTIONAL,
    IN LPWSTR UncName,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG CreateDisposition,
    IN ULONG CreateOptions,
    IN ULONG ConnectionType,
    OUT PHANDLE TreeConnectionHandle,
    OUT PULONG_PTR Information OPTIONAL
    )
/*++

Routine Description:

    This function asks the redirector to either open an existing tree
    connection (CreateDisposition == FILE_OPEN), or create a new tree
    connection if one does not exist (CreateDisposition == FILE_CREATE).

    The password and user name passed to the redirector via the EA buffer
    in the NtCreateFile call.  The EA buffer is NULL if neither password
    or user name is specified.

    The redirector expects the EA descriptor strings to be in ANSI
    but the password and username themselves are in Unicode.
    
    We also add webdav signature string, which tells our redir that we
    are calling it

Arguments:

    TreeConnectionName - Supplies the name of the tree connection in NT-style
                         file name format: 
                         \Device\WebDavRedirector\Server\Volume\Directory

    UserName - Supplies the user name to create the tree connection with.

    Password - Supplies the password to create the tree connection with.

    DesiredAccess - Supplies the access need on the connection handle.

    CreateDisposition - Supplies the create disposition value to either
                        open or create the tree connection.

    CreateOptions - Supplies the options used when creating or opening
                    the tree connection.

    ConnectionType - Supplies the type of the connection (DISK, PRINT,
                     or ANY).

    TreeConnectionHandle - Returns the handle to the tree connection
                           created/opened by the redirector.

    Information - Returns the information field of the I/O status block.

Return Value:

    NO_ERROR or reason for failure.

--*/
{
    DWORD WStatus = NO_ERROR;
    NTSTATUS NtStatus = STATUS_SUCCESS;
    OBJECT_ATTRIBUTES UncNameAttributes;
    IO_STATUS_BLOCK IoStatusBlock;
    PFILE_FULL_EA_INFORMATION EaBuffer = NULL;
    PFILE_FULL_EA_INFORMATION Ea = NULL;
    ULONG EaBufferSize = 0;

    UCHAR EaNamePasswordSize = 
               (UCHAR) (ROUND_UP_COUNT(strlen(EA_NAME_PASSWORD) + sizeof(CHAR),
                                       ALIGN_WCHAR) - sizeof(CHAR));
    
    UCHAR EaNameUserNameSize = 
               (UCHAR) (ROUND_UP_COUNT(strlen(EA_NAME_USERNAME) + sizeof(CHAR),
                                       ALIGN_WCHAR) - sizeof(CHAR));

    UCHAR EaNameTypeSize = 
                   (UCHAR) (ROUND_UP_COUNT(strlen(EA_NAME_TYPE) + sizeof(CHAR),
                                           ALIGN_DWORD) - sizeof(CHAR));

    UCHAR EaNameWebDavSignatureSize = 
                   (UCHAR) (ROUND_UP_COUNT(strlen(EA_NAME_WEBDAV_SIGNATURE) + sizeof(CHAR),
                                           ALIGN_DWORD) - sizeof(CHAR));


    USHORT PasswordSize = 0;
    USHORT UserNameSize = 0;
    USHORT TypeSize = sizeof(ULONG);
    USHORT WebDavSignatureSize = 0;
    
    InitializeObjectAttributes(&UncNameAttributes,
                               TreeConnectionName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    //
    // Calculate the number of bytes needed for the EA buffer to put the
    // password or user name.
    //
    if (ARGUMENT_PRESENT(Password)) {

        PasswordSize = (USHORT) (wcslen(Password) * sizeof(WCHAR));

        EaBufferSize = ROUND_UP_COUNT(
                           FIELD_OFFSET(FILE_FULL_EA_INFORMATION, EaName[0]) +
                           EaNamePasswordSize + sizeof(CHAR) +
                           PasswordSize,
                           ALIGN_DWORD
                           );
    }

    if (ARGUMENT_PRESENT(UserName)) {

        UserNameSize = (USHORT) (wcslen(UserName) * sizeof(WCHAR));

        EaBufferSize += ROUND_UP_COUNT(
                            FIELD_OFFSET(FILE_FULL_EA_INFORMATION, EaName[0]) +
                            EaNameUserNameSize + sizeof(CHAR) +
                            UserNameSize,
                            ALIGN_DWORD
                            );
    }

    EaBufferSize += ROUND_UP_COUNT(
                            FIELD_OFFSET(FILE_FULL_EA_INFORMATION, EaName[0]) +
                            EaNameTypeSize + sizeof(CHAR) +
                            TypeSize,
                            ALIGN_DWORD
                        );

    // round up just so we get some slop                            
    EaBufferSize += ROUND_UP_COUNT(
                            FIELD_OFFSET(FILE_FULL_EA_INFORMATION, EaName[0]) +
                            EaNameWebDavSignatureSize + sizeof(CHAR) +
                            WebDavSignatureSize,
                            ALIGN_DWORD
                        );

    //
    // Allocate the EA buffer.
    //
    EaBuffer = (PFILE_FULL_EA_INFORMATION) LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT,
                                                      EaBufferSize);
    if (EaBuffer == NULL) {
        WStatus = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavOpenCreateConnection/LocalAlloc: WStatus = %08lx\n", 
                  WStatus));
        goto EXIT_THE_FUNCTION;
    }

    Ea = EaBuffer;

    if (ARGUMENT_PRESENT(Password)) {

        //
        // Copy the EA name into EA buffer.  EA name length does not
        // include the zero terminator.
        //
        strcpy((LPSTR) Ea->EaName, EA_NAME_PASSWORD);
        Ea->EaNameLength = EaNamePasswordSize;

        //
        // Copy the EA value into EA buffer.  EA value length does not
        // include the zero terminator.
        //
        wcscpy((LPWSTR) &(Ea->EaName[EaNamePasswordSize + sizeof(CHAR)]),
               Password);

        Ea->EaValueLength = PasswordSize;

        Ea->NextEntryOffset = ROUND_UP_COUNT(
                                  FIELD_OFFSET(FILE_FULL_EA_INFORMATION, EaName[0]) +
                                  EaNamePasswordSize + sizeof(CHAR) +
                                  PasswordSize,
                                  ALIGN_DWORD
                                  );

        Ea->Flags = 0;
        (ULONG_PTR) Ea += Ea->NextEntryOffset;
    }

    if (ARGUMENT_PRESENT(UserName)) {

        //
        // Copy the EA name into EA buffer.  EA name length does not
        // include the zero terminator.
        //
        strcpy((LPSTR) Ea->EaName, EA_NAME_USERNAME);
        Ea->EaNameLength = EaNameUserNameSize;

        //
        // Copy the EA value into EA buffer.  EA value length does not
        // include the zero terminator.
        //
        wcscpy((LPWSTR) &(Ea->EaName[EaNameUserNameSize + sizeof(CHAR)]),
               UserName);

        Ea->EaValueLength = UserNameSize;

        Ea->NextEntryOffset = ROUND_UP_COUNT(
                                  FIELD_OFFSET(FILE_FULL_EA_INFORMATION, EaName[0]) +
                                  EaNameUserNameSize + sizeof(CHAR) +
                                  UserNameSize,
                                  ALIGN_DWORD
                                  );
        Ea->Flags = 0;

        (ULONG_PTR) Ea += Ea->NextEntryOffset;

    }

    //
    // Copy the connection type name into EA buffer.  EA name length
    // does not include the zero terminator.
    //

    strcpy( (LPSTR)Ea->EaName, EA_NAME_TYPE );
    Ea->EaNameLength = EaNameTypeSize;
    
    *((PULONG) &(Ea->EaName[EaNameTypeSize + sizeof(CHAR)])) = ConnectionType;
    Ea->EaValueLength = TypeSize;
    Ea->Flags = 0;

    Ea->NextEntryOffset = ROUND_UP_COUNT(
                                  FIELD_OFFSET(FILE_FULL_EA_INFORMATION, EaName[0]) +
                                  EaNameTypeSize + sizeof(CHAR) +
                                  TypeSize,
                                  ALIGN_DWORD
                                  );


    (ULONG_PTR) Ea += Ea->NextEntryOffset;

    strcpy( (LPSTR)Ea->EaName, EA_NAME_WEBDAV_SIGNATURE );
    Ea->EaNameLength = EaNameWebDavSignatureSize;
    Ea->EaValueLength = 0;
    
    //
    // Terminate the EA.
    //
    Ea->NextEntryOffset = 0;
    Ea->Flags = 0;

    WStatus = DavImpersonateClient();
    if (WStatus != NO_ERROR) {
        DavPrint((DEBUG_ERRORS,
                  "DavOpenCreateConnection/DavImpersonateClient: WStatus = "
                  "%08lx\n", WStatus));
        goto EXIT_THE_FUNCTION;
    }

    //
    // Create or open a tree connection.
    //
    NtStatus = NtCreateFile(TreeConnectionHandle,
                            DesiredAccess,
                            &UncNameAttributes,
                            &IoStatusBlock,
                            NULL,
                            FILE_ATTRIBUTE_NORMAL,
                            FILE_SHARE_VALID_FLAGS,
                            CreateDisposition,
                            CreateOptions,
                            (PVOID) EaBuffer,
                            EaBufferSize);
    if (NtStatus != STATUS_SUCCESS) {
        
        DavPrint((DEBUG_ERRORS,
                  "DavOpenCreateConnection/NtCreateFile: NtStatus = %08lx\n", 
                  NtStatus));
        
        WStatus = DavRevertToSelf();
        if (WStatus != NO_ERROR) {
            DavPrint((DEBUG_ERRORS,
                      "DavOpenCreateConnection/DavRevertToSelf: WStatus = "
                      "%08lx\n", WStatus));
        }
        
        WStatus = WsMapStatus(NtStatus);

        goto EXIT_THE_FUNCTION;
    
    }

    WStatus = WsMapStatus(NtStatus);
    
    if (ARGUMENT_PRESENT(Information)) {
        *Information = IoStatusBlock.Information;
    }

    WStatus = DavRevertToSelf();
    if (WStatus != NO_ERROR) {
        DavPrint((DEBUG_ERRORS,
                  "DavOpenCreateConnection/DavRevertToSelf: WStatus = "
                  "%08lx\n", WStatus));
    }

EXIT_THE_FUNCTION:

    //
    // Clear the password to prevent it from making it to pagefile and free the 
    // memory.
    //
    if (EaBuffer != NULL) {
        RtlZeroMemory( EaBuffer, EaBufferSize );
        LocalFree((HLOCAL) EaBuffer);
    }

    return WStatus;
}


ULONG
DavImpersonateAndGetUserId(
    LPWSTR UserName,
    LPDWORD UserNameMaxLen
    )
/*++

Routine Description:

    This function gets the user id of the current thread.

Arguments:

    UserName - Returns the user id of the current process.

    UserNameMaxLen - Pointer to variable containing max length of UserName passed
                     to this function. It will be set to the length of name filled
                     or required.

Return Value:

    Win32 Error - ERROR_SUCCESS or reason for failure.

--*/
{
    DWORD dwError = NO_ERROR;
    BOOLEAN revert = FALSE;
    BOOL bStatus = FALSE;

    dwError = DavImpersonateClient();
    if (dwError != NO_ERROR) {
        DavPrint((DEBUG_ERRORS, 
                  "DavImpersonateAndGetUserId/DavImpersonateClient: dwError = %x\n",
                  dwError));
        goto EXIT_THE_FUNCTION;
    }
    revert = TRUE;

    if (UserName == NULL) {
        dwError = ERROR_INVALID_PARAMETER;
        goto EXIT_THE_FUNCTION;
    }

    // 
    // Get user name in the buffer passed to this function.
    //
    bStatus = GetUserName(UserName, UserNameMaxLen);
    if (bStatus != TRUE) {
        dwError = GetLastError();
        DavPrint((DEBUG_ERRORS, 
                 "DavImpersonateAndGetUserId/GetUserName: dwError = %x\n",
                  dwError));
        goto EXIT_THE_FUNCTION;
    }

EXIT_THE_FUNCTION:

    if (revert) {
        dwError = DavRevertToSelf();
        if (dwError != NO_ERROR) {
            DavPrint((DEBUG_ERRORS, 
                      "DavImpersonateAndGetUserId/DavRevertToSelf: dwError = %x\n",
                      dwError));
        }
    }

    return dwError;
}


ULONG
DavImpersonateAndGetSessionId(
    PULONG pSessionId
    )
/*++

Routine Description:

    This function gets the session id of the current thread.

Arguments:

    pSessionId - Returns the session id of the current process.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    NET_API_STATUS NetApiStatus;
    HANDLE CurrentThreadToken;
    ULONG SessionId;
    ULONG ReturnLength;
    BOOLEAN revert = FALSE;
    DWORD   dwError = NO_ERROR;
    
    dwError = DavImpersonateClient();
    if (dwError != NO_ERROR) {
        NtStatus = DavMapErrorToNtStatus(dwError);
        DavPrint((DEBUG_ERRORS, 
                  "DavImpersonateAndGetSessionId/DavImpersonateClient: "
                  "dwError = %08lx NtStatus = %08lx\n", dwError, NtStatus));
        goto EXIT_THE_FUNCTION;
    }
    
    revert = TRUE;

    NtStatus = NtOpenThreadToken(NtCurrentThread(),
                                 TOKEN_QUERY,
                                 TRUE,
                                 &(CurrentThreadToken));
    if (NtStatus != STATUS_SUCCESS) {
        DavPrint((DEBUG_ERRORS,
                  "DavpImpersonateAndGetSessionId/NtOpenThreadToken."
                   " NtStatus = %08lx\n", NtStatus));
        goto EXIT_THE_FUNCTION;
    }

    //
    // Get the Session Id of the current thread.
    //
    NtStatus = NtQueryInformationToken(CurrentThreadToken,
                                       TokenSessionId,
                                       &SessionId,
                                       sizeof(ULONG),
                                       &(ReturnLength));
    if (NtStatus != STATUS_SUCCESS) {
        DavPrint((DEBUG_ERRORS,
                  "DavpImpersonateAndGetSessionId/NtQueryInformationToken."
                   " NtStatus = %08lx\n", NtStatus));
        NtClose(CurrentThreadToken);
        goto EXIT_THE_FUNCTION;
    }

    NtClose(CurrentThreadToken);

    *pSessionId = SessionId;

EXIT_THE_FUNCTION:

    if (revert) {
        NtStatus = DavRevertToSelf();
        if (NtStatus != NO_ERROR) {
            DavPrint((DEBUG_ERRORS, 
                      "DavImpersonateAndGetSessionId/DavRevertToSelf: "
                      "NtStatus = %08lx\n", NtStatus));
        }
    }

    NetApiStatus = NetpNtStatusToApiStatus(NtStatus);

    return NetApiStatus;
}


ULONG
DavImpersonateAndGetLogonId(
    PLUID pLogonId
    )
/*++

Routine Description:

    This function gets the Logon Id of the current thread.

Arguments:

    pLogonId - Returns the Logon Id of the current thread.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    NTSTATUS NtStatus;
    NET_API_STATUS NetApiStatus;
    HANDLE CurrentThreadToken;
    TOKEN_STATISTICS TokenStats;
    ULONG ReturnLength;
    BOOLEAN revert = FALSE;

    NtStatus = DavImpersonateClient();
    if (NtStatus != NO_ERROR) {
        DavPrint((DEBUG_ERRORS, 
                  "DavImpersonateAndGetLogonId/DavImpersonateClient: "
                  "NtStatus = %08lx\n", NtStatus));
        goto EXIT_THE_FUNCTION;
    }
    revert = TRUE;

    NtStatus = NtOpenThreadToken(NtCurrentThread(),
                                  TOKEN_QUERY,
                                  TRUE,
                                  &(CurrentThreadToken));
    if (NtStatus != STATUS_SUCCESS) {
        DavPrint((DEBUG_ERRORS,
                  "DavImpersonateAndGetLogonId/NtOpenThreadToken."
                   " NtStatus = %08lx\n", NtStatus));
        goto EXIT_THE_FUNCTION;
    }

    //
    // Get the LogonId of the current thread.
    //
    NtStatus = NtQueryInformationToken(CurrentThreadToken,
                                       TokenStatistics,
                                       (PVOID) &TokenStats,
                                       sizeof(TokenStats),
                                       &ReturnLength);
    if (NtStatus != STATUS_SUCCESS) {
        DavPrint((DEBUG_ERRORS,
                  "DavImpersonateAndGetLogonId/NtQueryInformationToken."
                   " NtStatus = %08lx\n", NtStatus));
        NtClose(CurrentThreadToken);
        goto EXIT_THE_FUNCTION;
    }

    if (pLogonId == NULL) {
        NtStatus = STATUS_INVALID_PARAMETER;
        NtClose(CurrentThreadToken);
        goto EXIT_THE_FUNCTION;
    }

    RtlCopyLuid( pLogonId, &(TokenStats.AuthenticationId) );

    NtClose(CurrentThreadToken);

EXIT_THE_FUNCTION:

    if (revert) {
        NtStatus = DavRevertToSelf();
        if (NtStatus != NO_ERROR) {
            DavPrint((DEBUG_ERRORS, 
                      "DavImpersonateAndGetLogonId/DavRevertToSelf: "
                      "NtStatus = %08lx\n", NtStatus));
        }
    }

    NetApiStatus = NetpNtStatusToApiStatus(NtStatus);

    return NetApiStatus;
}


DWORD
DavCreateSymbolicLink(
    IN LPWSTR Local,
    IN LPWSTR TreeConnectStr,
    IN OUT LPWSTR *Session,
    IN OUT HANDLE *lphToken
    )
/*++

Routine Description:

    This function creates a symbolic link object for the specified local
    device name which is linked to the tree connection name that has a
    format of \Device\DavRdr\Device:\Server\Volume\Directory.

Arguments:

    Local - Supplies the local device name.

    TreeConnectStr - Supplies the tree connection name string which is the
                     link target of the symbolick link object.

    Session - The Session Path is filled into this buffer.

    lphToken - A handle to the user's token is copied into this buffer.

Return Value:

    NO_ERROR or reason for failure.

--*/
{
    DWORD dwError = NO_ERROR;
    WCHAR TempBuf[64];
    DWORD Flags;
    BOOL revert = FALSE;
    LPWSTR DeviceName = NULL;
    HANDLE hToken;

    if (g_LUIDDeviceMapsEnabled == FALSE) {

        if (Session == NULL || Local == NULL) {
            dwError = ERROR_INVALID_PARAMETER;
            goto EXIT_THE_FUNCTION;
        }

        //
        // Multiple session support for legacy Terminal Server DosDevices
        // get the session-specific Device name.
        //
        *Session = DavReturnSessionPath(Local);
        if ( *Session == NULL ) {
            dwError = GetLastError();
            DavPrint((DEBUG_ERRORS,
                      "DavCreateSymbolicLink/DavReturnSessionPath: dwError = "
                      "%08lx\n", dwError));
            goto EXIT_THE_FUNCTION;
        }

        DeviceName = *Session;

    } else {

        //
        // Per-Logon DosDevices are enabled. Make sure that we are impersonating
        // the user when querying and creating the symbolic link.  DeviceName is
        // unchanged.
        //
        dwError = DavImpersonateClient();
        if (dwError != NO_ERROR) {
            DavPrint((DEBUG_ERRORS, 
                      "DavCreateSymbolicLink/DavImpersonateClient: "
                      "dwError = %08lx\n", dwError));
            goto EXIT_THE_FUNCTION;
        }

        revert = TRUE;

        if (lphToken != NULL) {
            //
            // Get a handle to the user's token in case the client dies. In
            // such a case we use this token to impersonate the client while
            // doing the cleanup.
            //
            if (!OpenThreadToken(GetCurrentThread(),
                                 TOKEN_IMPERSONATE,
                                 TRUE,
                                 &hToken)) {
                dwError = GetLastError();
                DavPrint((DEBUG_ERRORS, 
                          "DavCreateSymbolicLink/OpenThreadToken: "
                          "dwError = %08lx\n", dwError));
                goto EXIT_THE_FUNCTION;
            }
            *lphToken = hToken;
        }

        DeviceName = Local;

    }

    DavPrint((DEBUG_MISC, "DavCreateSymbolicLink: DeviceName = %ws\n", DeviceName));

    //
    // Local device is some X:.
    //
    if ( !QueryDosDeviceW( DeviceName, TempBuf, 64 ) ) {

        if (GetLastError() != ERROR_FILE_NOT_FOUND) {
            
            //
            // Most likely failure occurred because our output
            // buffer is too small. It still means someone already
            // has an existing symbolic link for this device.
            //
            dwError = ERROR_ALREADY_ASSIGNED;
            
            DavPrint((DEBUG_ERRORS,
                      "DavCreateSymbolicLink/QueryDosDeviceW: dwError = "
                      "%08lx\n", dwError));
            
            goto EXIT_THE_FUNCTION;
        
        }
    
        //
        // ERROR_FILE_NOT_FOUND (translated from OBJECT_NAME_NOT_FOUND)
        // means it does not exist and we can redirect this device.
        //
    
    } else {
        
        //
        // QueryDosDevice successfully an existing symbolic link. Somebody is 
        // already using this device.
        //
        dwError = ERROR_ALREADY_ASSIGNED;
        
        DavPrint((DEBUG_ERRORS,
                  "DavCreateSymbolicLink/QueryDosDeviceW: Device already exists.\n"));
        
        goto EXIT_THE_FUNCTION;
    
    }

    Flags = (DDD_RAW_TARGET_PATH | DDD_NO_BROADCAST_SYSTEM);

    if (TreeConnectStr == NULL) {
        dwError = ERROR_INVALID_PARAMETER;
        goto EXIT_THE_FUNCTION;
    }

    //
    // Create a symbolic link object to the device we are redirecting.
    //
    if ( !DefineDosDeviceW( Flags, DeviceName, TreeConnectStr ) ) {

        dwError = GetLastError();

        DavPrint((DEBUG_ERRORS,
                  "DavCreateSymbolicLink/DefineDosDeviceW: dwError = "
                  "%08lx\n", dwError));

    }

EXIT_THE_FUNCTION:

    if ( revert == TRUE ) {
        DWORD   dwErrLocal;
        dwErrLocal = DavRevertToSelf();
        if (dwErrLocal != NO_ERROR) {
            DavPrint((DEBUG_ERRORS, 
                      "DavCreateSymbolicLink/DavRevertToSelf: "
                      "NtStatus = %08lx\n", dwErrLocal));
            dwError = dwErrLocal;
        }
    }

    return dwError;
}


DWORD
DavDeleteSymbolicLink(
    IN  LPWSTR LocalDeviceName,
    IN  LPWSTR TreeConnectStr,
    IN  LPWSTR SessionDeviceName,
    IN  HANDLE hToken,
    IN  BOOL   bImpersonating
    )
/*++

Routine Description:

    This function deletes the symbolic link we had created earlier for
    the device.

Arguments:

    LocalDeviceName - Supplies the local device name string of which the
                      symbolic link object is created.

    TreeConnectStr - Supplies a pointer to the Unicode string which
                     contains the link target string we want to match and 
                     delete.
                     
    SessionDeviceName - Terminal Server Addition. This parameter is required 
                        because the device created is per session.

    hToken - Handle to the user's token, used to impersonate the user.

    bImpersonating - Are we already impersonating?  If FALSE, then impersonate
                     the user when per-Logon DosDevices are enabled.

Return Value:

    Win32 Error value or NO_ERROR.

--*/
{
    DWORD WStatus = NO_ERROR;
    DWORD CallFlags = 0;
    BOOLEAN DeleteSession = FALSE;
    BOOL revert = FALSE;
    LPWSTR DeviceName = NULL;

    CallFlags = (DDD_REMOVE_DEFINITION | DDD_NO_BROADCAST_SYSTEM);

    //
    // If the Targetpath (TreeConnectStr) is specified, we need the following 
    // flags.
    //
    if (TreeConnectStr) {

        CallFlags |= ( DDD_RAW_TARGET_PATH | DDD_EXACT_MATCH_ON_REMOVE );

    }

    if (LocalDeviceName != NULL || SessionDeviceName != NULL) {

        if (g_LUIDDeviceMapsEnabled == FALSE) {
            
            //
            // LUID DosDevices are disabled, so a session-specific DeviceName
            // is needed.
            //
            if (SessionDeviceName == NULL) {
                DeviceName = DavReturnSessionPath(LocalDeviceName);
                if (DeviceName == NULL) {
                    WStatus = ERROR_INVALID_PARAMETER;
                    DavPrint((DEBUG_ERRORS,
                              "DavDeleteSymbolicLink/DavReturnSessionPath: WStatus ="
                              " %08lx\n", WStatus));
                    return WStatus;
                }
                DeleteSession = TRUE;
            } else {
                DeviceName = SessionDeviceName;
            }
        
        } else {
            
            //
            // LUID DosDevices are enabled, no device name translation is
            // needed.  Must be impersonating the user in order to delete
            // the symbolic link
            //
            DeviceName = LocalDeviceName;
            
            //
            // We would have created the symbolic link in the context of a
            // user. While deleting the symbolic link, we need to be in the 
            // context of the same user. If we are not impersonating the user
            // then we need to now.
            //
            if (bImpersonating == FALSE) {
                if (hToken != INVALID_HANDLE_VALUE) {
                    if (!SetThreadToken(NULL, hToken)) {
                        WStatus = GetLastError();
                        if (WStatus != NO_ERROR) {
                            DavPrint((DEBUG_ERRORS, 
                                     "DavDeleteSymbolicLink/SetThreadToken: "
                                     "WStatus = %08lx\n", WStatus));
                            goto EXIT_THE_FUNCTION;
                        }
                    }
                } else {
                    WStatus = DavImpersonateClient();
                    if (WStatus != NO_ERROR) {
                        DavPrint((DEBUG_ERRORS, 
                                 "DavDeleteSymbolicLink/DavImpersonateClient: "
                                 "WStatus = %08lx\n", WStatus));
                        goto EXIT_THE_FUNCTION;
                    }
                }
                revert = TRUE;
            }
        
        }

        //
        // Delete the symbolic link.
        //
        if ( !DefineDosDeviceW(CallFlags, DeviceName, TreeConnectStr) ) {
            WStatus = GetLastError();
            DavPrint((DEBUG_ERRORS,
                      "DavDeleteSymbolicLink/DefineDosDeviceW: WStatus ="
                      " %08lx\n", WStatus));
        }

    }

EXIT_THE_FUNCTION:

    if (revert == TRUE) {
        if (hToken != INVALID_HANDLE_VALUE) {
            if ( !RevertToSelf() ) {
                WStatus = GetLastError();
                if (WStatus != NO_ERROR) {
                    DavPrint((DEBUG_ERRORS, 
                              "DavCreateSymbolicLink/RevertToSelf: "
                              "WStatus = %08lx\n", WStatus));
                }
            }
        } else {
            WStatus = DavRevertToSelf();
            if (WStatus != NO_ERROR) {
                DavPrint((DEBUG_ERRORS, 
                          "DavCreateSymbolicLink/DavRevertToSelf: "
                          "WStatus = %08lx\n", WStatus));
            }
        }
    }

    if (DeviceName && DeleteSession) {
        LocalFree(DeviceName);
    }

    return WStatus;
}


DWORD
DavImpersonateClient(
    VOID
    )
/*++

Routine Description:

    This function calls RpcImpersonateClient to impersonate the current caller
    of an API.

Arguments:

    None.

Return Value:

    NO_ERROR or reason for failure.

--*/
{
    DWORD WStatus = NO_ERROR;

    WStatus = RpcImpersonateClient(NULL);
    if ( WStatus != NO_ERROR ) {
        DavPrint((DEBUG_ERRORS,
                  "DavImpersonateClient/RpcImpersonateClient: WStatus = %08lx\n",
                  WStatus));
    }

    return WStatus;
}


DWORD
DavRevertToSelf(
    VOID
    )
/*++

Routine Description:

    This function calls RpcRevertToSelf to undo an impersonation.

Arguments:

    None.

Return Value:

    NO_ERROR or reason for failure.

--*/
{
    DWORD WStatus = NO_ERROR;

    WStatus = RpcRevertToSelf();
    if ( WStatus != NO_ERROR ) {
        DavPrint((DEBUG_ERRORS,
                  "DavRevertToSelf/RpcRevertToSelf: WStatus = %08lx\n",
                  WStatus));
    }

    return WStatus;
}


NET_API_STATUS
DavGetUserEntry(
    IN  PDAV_USERS_OBJECT DavUsers,
    IN  PLUID LogonId,
    OUT PULONG Index,
    IN  BOOL IsAdd
    )
/*++

Routine Description:

    This function searches the table of user entries for one that matches the
    specified LogonId, and returns the index to the entry found.  If none is
    found, an error is returned if IsAdd is FALSE.  If IsAdd is TRUE a new
    entry in the users table is created for the user and the index to this
    new entry is returned.
        
    WARNING: This function assumes that the users table resource has been
             claimed.

Arguments:

    DavUsers - Supplies a pointer to the DavUseObject.

    LogonId - Supplies the pointer to the current user's Logon Id.

    Index - Returns the index to the users table of entry belonging to the
            current user.

    IsAdd - Supplies flag to indicate whether to add a new entry for the
            current user if none is found.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    NET_API_STATUS NetApiStatus;
    DWORD i;
    ULONG FreeEntryIndex = MAXULONG;

    for (i = 0; i < DavUsers->TableSize; i++) {
        //
        // If the LogonId matches the entry in the DavUsers Table, we've found 
        // the correct user entry.
        //
        if ( RtlEqualLuid( LogonId, &(DavUsers->Table[i].LogonId) ) ) {
            *Index = i;
            return NERR_Success;
        }
        else if (FreeEntryIndex == MAXULONG && DavUsers->Table[i].List == NULL) {
            //
            // Save away first unused entry in table.
            //
            FreeEntryIndex = i;
        }
    }

    if ( !IsAdd ) {
        //
        // Current user is not found in users table and we are told not to
        // create a new entry
        //
        return NERR_UserNotFound;
    }

    DavPrint((DEBUG_MISC,
              "DavGetUserEntry: New Entry. LogonID.Low = %d, LogonId.High = %d\n",
              LogonId->LowPart, LogonId->HighPart));

    //
    // Could not find an empty entry in the UsersTable, need to grow
    //
    if (FreeEntryIndex == MAXULONG) {
        NetApiStatus = DavGrowTable(DavUsers);
        if (NetApiStatus != NERR_Success) {
            return NetApiStatus;
        }
        FreeEntryIndex = i;
    }

    DavPrint((DEBUG_MISC, "DavGetUserEntry: FreeEntryIndex = %d\n", FreeEntryIndex));

    //
    // Create a new entry for current user
    //
    RtlCopyLuid( &(DavUsers->Table[FreeEntryIndex].LogonId), LogonId);
    *Index = FreeEntryIndex;

    return NERR_Success;
}


NET_API_STATUS
DavGrowTable(
    IN  PDAV_USERS_OBJECT DavUsers
    )
/*++

Routine Description:

    This function grows the users table to accomodate more users.

    WARNING: This function assumes that the users table resource has been
             claimed.

Arguments:

    DavUsers - Supplies a pointer to the DavUsersObject.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    NET_API_STATUS NetApiStatus = NERR_Success;
    ULONG Size;
    BOOL ReturnVal;
    HANDLE ReAllocHandle = NULL;

    DavPrint((DEBUG_MISC, "DavGrowTable: Grow the DavUsers table\n"));
    
    Size = (DavUsers->TableSize + DAV_GROW_USER_COUNT) * sizeof(DAV_PER_USER_ENTRY);
    
    if (DavUsers->TableSize > 0) {

        //
        // Unlock the Use Table virtual memory so that Win32 can move it
        // around to find a larger piece of contiguous virtual memory if
        // necessary.
        //
        ReturnVal = LocalUnlock(DavUsers->TableMemory);
        if ( !ReturnVal ) {
            NetApiStatus = GetLastError();
            if ( NetApiStatus != NO_ERROR ) {
                DavPrint((DEBUG_ERRORS,
                          "DavGrowTable/LocalUnlock. NetApiStatus = %08lx\n",
                          NetApiStatus));
                return NetApiStatus;
            }
        }

        //
        // Grow the Users Table.
        //
        ReAllocHandle = LocalReAlloc(DavUsers->TableMemory,
                                     Size,
                                     (LMEM_ZEROINIT | LMEM_MOVEABLE));
        if (ReAllocHandle == NULL) {
            NetApiStatus = GetLastError();
            //
            // Lock Use Table virtual memory so that it cannot be moved. We do
            // this even though we failed.
            //
            DavUsers->Table = (PDAV_PER_USER_ENTRY) LocalLock(DavUsers->TableMemory);
            DavPrint((DEBUG_ERRORS,
                      "DavGrowTable/LocalReAlloc. NetApiStatus = %08lx\n",
                      NetApiStatus));
            return NetApiStatus;
        }

        //
        // Set "DavUsers->TableMemory" to the newly re-allocated memory.
        //
        DavUsers->TableMemory = ReAllocHandle;

    } else {

        //
        // This is the first allocation being made for the Dav Use Table.
        //
        DavUsers->TableMemory = LocalAlloc(LMEM_ZEROINIT | LMEM_MOVEABLE, Size);
        if (DavUsers->TableMemory == NULL) {
            NetApiStatus = GetLastError();
            DavPrint((DEBUG_ERRORS,
                      "DavGrowTable/LocalAlloc. NetApiStatus = %08lx\n",
                      NetApiStatus));
            return NetApiStatus;
        }

    }

    //
    // Update new size of Use Table.
    //
    DavUsers->TableSize += DAV_GROW_USER_COUNT;

    //
    // Lock Use Table virtual memory so that it cannot be moved.
    //
    DavUsers->Table = (PDAV_PER_USER_ENTRY) LocalLock(DavUsers->TableMemory);
    if (DavUsers->Table == NULL) {
        DavPrint((DEBUG_ERRORS,
                  "DavGrowTable/LocalAlloc. NetApiStatus = %08lx\n",
                  NetApiStatus));
        return NetApiStatus;
    }

    return NetApiStatus;
}


LPWSTR
DavReturnSessionPath(
    IN LPWSTR LocalDeviceName
    )
/*++

Routine Description:

    This function returns the per session path to access the specific dos device
    for multiple session support.


Arguments:

    LocalDeviceName - Supplies the local device name specified by the API
                      caller.

Return Value:

    LPWSTR - Pointer to per session path in newly allocated memory
             by LocalAlloc().

--*/
{
    BOOL rc;
    DWORD SessionId = 0;
    CLIENT_ID ClientId;
    LPWSTR SessionDeviceName = NULL;
    NET_API_STATUS NetApiStatus;

    NetApiStatus = DavImpersonateAndGetSessionId( &(SessionId) );
    if (NetApiStatus != NERR_Success) {
        DavPrint((DEBUG_ERRORS,
                  "DavReturnSessionPath/DavImpersonateAndGetSessionId: "
                  "NetApiStatus = %08lx\n", NetApiStatus));
        return NULL;
    }

    rc = DosPathToSessionPathW(SessionId, LocalDeviceName, &SessionDeviceName);
    if( !rc ) {
        NetApiStatus = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavReturnSessionPath/DosPathToSessionPathW: "
                  "NetApiStatus = %08lx\n", NetApiStatus));
        return NULL;
    }

    return SessionDeviceName;
}


NET_API_STATUS
DavAddUse(
    IN PLUID LogonId,
    IN LPWSTR Local OPTIONAL,
    IN DWORD LocalLength,
    IN LPWSTR AuthUserName OPTIONAL,
    IN LPWSTR UncName,
    IN DWORD UncNameLength,
    IN PUNICODE_STRING TreeConnectStr,
    IN HANDLE DavCreateFileHandle
    )
/*++

Routine Description:

    This function adds a Dav "net use" entry into the DavUseTable for the user
    specified by the Logon Id. There is a linked list of uses for each user. 
    Each new use entry is inserted into the end of the linked list so that 
    enumeration of the list is resumable.

    NOTE: This function locks the DavUseTable. 

Arguments:

    LogonId - Supplies a pointer to the user's Logon Id.

    Local - Supplies the string of the local device name.

    LocalLength - Supplies the length of the local device name.

    UncName - Supplies the name of the shared resource (UNC name).

    UncNameLength - Supplies the length of the shared resource.

    TreeConnectStr - Supplies the string of UNC name in NT-style format.
    
    DavCreateFileHandle - The file handle that was created using NtCreateFile on 
                          the net use path. This is stored in the new user entry
                          structure being created and is closed when the user
                          entry gets deleted.
Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    NET_API_STATUS NetApiStatus = NERR_Success;
    DWORD Index;                          // Index to user entry in Use Table.
    PDAV_USE_ENTRY MatchedPointer = NULL; // Points to matching shared resource.
    PDAV_USE_ENTRY InsertPointer = NULL;  // Point of insertion into use list.
    PDAV_USE_ENTRY NewUse;                // Pointer to the new use entry.
    BOOLEAN ResAcquired = FALSE;
    LPWSTR UserName = NULL;

    if ( !RtlAcquireResourceExclusive(&DavUseObject.TableResource, TRUE) ) {
        NetApiStatus = NERR_InternalError;
        DavPrint((DEBUG_ERRORS,
                  "DavAddUse/RtlAcquireResourceExclusive: Internal Error.\n"));
        goto EXIT_THE_FUNCTION;
    }

    ResAcquired = TRUE;

    // 
    // We will always save the user-name for any new use entry created.
    // This user-name is either explicitly given or if NULL, is taken as
    // Logged-On user. This should be taken care OF by the caller function.
    //
    UserName = AuthUserName;
    ASSERT(UserName != NULL);

    //
    // Look for the matching LogonId in the Use Table. If none matched create a 
    // new entry.
    //
    NetApiStatus = DavGetUserEntry(&DavUseObject, LogonId, &Index, TRUE);
    if (NetApiStatus != NERR_Success) {
        DavPrint((DEBUG_ERRORS,
                  "DavAddUse/RtlAcquireResourceExclusive: NetApiStatus = "
                  "%08lx\n", NetApiStatus));
        goto EXIT_THE_FUNCTION;
    }

    if ( DavUseObject.Table[Index].List != NULL ) {

        DavPrint((DEBUG_MISC, "DavAddUse: DavUseObject.Table[Index].List != NULL\n"));

        //
        // Traverse use list to look for location to insert new use entry.
        //
        DavFindInsertLocation((PDAV_USE_ENTRY)DavUseObject.Table[Index].List,
                              UncName,
                              &(MatchedPointer),
                              &(InsertPointer));

    }

    if (MatchedPointer == NULL) {

        DavPrint((DEBUG_MISC, "DavAddUse: MatchedPointer == NULL\n"));

        //
        // No matching UNC name found.  Create a new entry with a
        // corresponding remote entry.
        //
        NetApiStatus = DavCreateNewEntry(&NewUse,
                                         Local,
                                         LocalLength,
                                         UserName,
                                         UncName,
                                         UncNameLength,
                                         TreeConnectStr,
                                         DavCreateFileHandle);
        if (NetApiStatus != NERR_Success) {
            DavPrint((DEBUG_ERRORS,
                      "DavAddUse/DavCreateNewEntry: NetApiStatus = %08lx\n", 
                      NetApiStatus));
            goto EXIT_THE_FUNCTION;
        }
    
    } else {

        //
        // Matching UNC name found.
        //

        DavPrint((DEBUG_MISC, "DavAddUse: MatchedPointer != NULL\n"));

        //
        // It may be unnecessary to create a new use entry if the use
        // we are adding has a NULL local device and a NULL local device
        // entry already exists.
        //
        if (Local == NULL) {
            
            DavPrint((DEBUG_MISC, "DavAddUse: Local == NULL\n"));
           
            if (MatchedPointer->Local == NULL) {

                DavPrint((DEBUG_MISC, "DavAddUse: MatchedPointer->Local == NULL\n"));

                //
                // We don't increment the reference count below because this is
                // the behavior SMB has. So, if a user does the following.
                // 1. net use http://server/share
                // 2. net use http://server/share
                // 3. net use http://server/share /d
                // The last delete lands up deleting the mapping even though the
                // user mapped it twice.
                // If this #if 0 is changed to #if 1, then the NtClose that is
                // being done below should not be done. This is why its included
                // in the #else clause.
                //

#if 0

                //
                // Yes, there is a NULL local device entry already.
                // Increment the use count and we are done.
                //
                MatchedPointer->UseCount++;
                MatchedPointer->Remote->TotalUseCount++;

#else 
                
                //
                // We close the file handle here, because we don't need to keep
                // it since this net use has no impact. As explained above, this
                // is because this user has already done a net use to the same
                // path with no local name and has repeated the command. This
                // should only be done if we are not taking the reference above.
                // If the above #if 0 is changed to add a reference to this 
                // entry then we need to keep this handle somewhere.
                //
                NtClose(DavCreateFileHandle);

#endif

                RtlReleaseResource( &(DavUseObject.TableResource) );
                ResAcquired = FALSE;

                return NetApiStatus;
           
            } else {
                DavPrint((DEBUG_MISC, "DavAddUse: MatchedPointer->Local != NULL\n"));
            }
        
        } else {
            DavPrint((DEBUG_MISC, "DavAddUse: Local != NULL\n"));
        }

        DavPrint((DEBUG_MISC, "DavAddUse: New Entry!!!\n"));
        
        //
        // If we get here it means we need to create a new use entry but not
        // a corresponding remote entry because a use with the same UNC
        // name already exists.
        //
        NetApiStatus = DavCreateNewEntry(&NewUse,
                                         Local,
                                         LocalLength,
                                         UserName,
                                         NULL,
                                         0,
                                         TreeConnectStr,
                                         DavCreateFileHandle);
        if (NetApiStatus != NERR_Success) {
            DavPrint((DEBUG_ERRORS,
                      "DavAddUse/DavCreateNewEntry: NetApiStatus = %08lx\n", 
                      NetApiStatus));
            goto EXIT_THE_FUNCTION;
        }

        NewUse->Remote = MatchedPointer->Remote;
        NewUse->Remote->TotalUseCount++;
    
    }

    //
    // Insert the new use entry into use list.
    //
    if (InsertPointer == NULL) {
        //
        // Inserting into the head of list
        //
        DavPrint((DEBUG_MISC, "DavAddUse: InsertPointer == NULL\n"));
        DavUseObject.Table[Index].List = (PVOID)NewUse;
    }
    else {
        DavPrint((DEBUG_MISC, "DavAddUse: InsertPointer != NULL\n"));
        InsertPointer->Next = NewUse;
    }

EXIT_THE_FUNCTION:

    if (ResAcquired) {
        RtlReleaseResource( &(DavUseObject.TableResource) );
    }

    return NetApiStatus;
}


VOID
DavFindInsertLocation(
    IN PDAV_USE_ENTRY DavUseList,
    IN LPWSTR UncName,
    OUT PDAV_USE_ENTRY *MatchedPointer,
    OUT PDAV_USE_ENTRY *InsertPointer
    )
/*++

Routine Description:

    This function searches the use list for the location to insert a new use
    entry.  The use entry is inserted to the end of the use list so the
    pointer to the last node in the use list is returned via InsertPointer.
    We also have to save a pointer to the node with the same UNC name so that
    the new use entry can be set to point to the same remote node (where the
    UNC name is stored). This pointer is returned as MatchedPointer.

    WARNING: This function assumes that the DavUseObject.TableResource has been 
             claimed.

Arguments:

    DavUseList - Supplies the pointer to the use list.

    UncName - Supplies the pointer to the shared resource.

    MatchedPointer - Returns a pointer to the node that holds the matching
                     UncName. If no matching UncName is found, this pointer is 
                     set to NULL. If there is more than one node that has the 
                     same UNC name, this pointer will point to the node with the
                     NULL local device name, if any; otherwise, if all nodes 
                     with matching UNC names have non-null local device names, 
                     the pointer to the last matching node will be returned.

    InsertPointer - Returns a pointer to the last use entry, after which the
                    new entry is to be inserted.

Return Value:

    None.

--*/
{
    BOOL IsMatchWithNullDevice = FALSE;
    
    *MatchedPointer = NULL;

    while (DavUseList != NULL) {

        //
        // Do the string comparison only if we haven't found a matching UNC
        // name with a NULL local device name.
        //
        if ( !IsMatchWithNullDevice &&
             ( _wcsicmp((LPWSTR)DavUseList->Remote->UncName, UncName) == 0 ) ) {

            //
            // Found matching entry.
            //
            *MatchedPointer = DavUseList;

            IsMatchWithNullDevice = (DavUseList->Local == NULL);
        }

        *InsertPointer = DavUseList;
        
        DavUseList = DavUseList->Next;
    
    }

    return;
}


NET_API_STATUS
DavCreateNewEntry(
    OUT PDAV_USE_ENTRY *NewUse,
    IN LPWSTR Local OPTIONAL,
    IN DWORD LocalLength,
    IN LPWSTR AuthUserName OPTIONAL,
    IN LPWSTR UncName OPTIONAL,
    IN DWORD UncNameLength,
    IN PUNICODE_STRING TreeConnectStr,
    IN HANDLE DavCreateFileHandle
    )
/*++

Routine Description:

    This function creates and initializes a new use entry.  If the UncName
    is specified, a new remote entry is created and initialized with UncName.

Arguments:

    NewUse - Returns a pointer to the newly allocated and initialized use
             entry.

    Local - Supplies the local device name string to be copied into the new
            use entry.

    LocalLength - Supplies the length of the local device name string.

    AuthUserName - Supplies the authentication user name string to be copied into the new
                   use entry.

    UncName - Supplies the UNC name string to be copied into the new use entry.

    UncNameLength - Supplies the length of the UNC name string.

    TreeConnectStr - Supplies the string of UNC name in NT-style format
    
    DavCreateFileHandle - The file handle that was created using NtCreateFile on 
                          the net use path. This is stored in the new user entry
                          structure being created and is closed when the user 
                          entry gets deleted.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    NET_API_STATUS NetApiStatus = NERR_Success;
    PUNC_NAME NewRemoteEntry = NULL;
    SIZE_T Size = 0, AlignedSize = 0;
    DWORD AuthUserNameLength = 0;
    SIZE_T BuffOffset = 0;

    //
    // The extra 1 is for last L'\0'.
    //
    AuthUserNameLength = ( ARGUMENT_PRESENT(AuthUserName) ? wcslen(AuthUserName)+1 : 0 );

    // 
    // We add TreeConnectStr only if Local is present.
    // 
    
    Size = ROUND_UP_COUNT( sizeof(DAV_USE_ENTRY), ALIGN_WCHAR);
    
    Size += ROUND_UP_COUNT(( ARGUMENT_PRESENT(Local) ? 
                             (LocalLength) * sizeof(WCHAR) : 0), ALIGN_WCHAR);
    
    Size += ROUND_UP_COUNT(( ARGUMENT_PRESENT(Local) && ARGUMENT_PRESENT(TreeConnectStr) ? 
                             TreeConnectStr->MaximumLength : 0 ), ALIGN_WCHAR);
    
    Size += ROUND_UP_COUNT(( ARGUMENT_PRESENT(AuthUserName) ? 
                             (AuthUserNameLength) * sizeof(WCHAR) : 0 ), ALIGN_WCHAR);
    
    AlignedSize = ROUND_UP_COUNT(Size, ALIGN_WCHAR);

    *NewUse = (PDAV_USE_ENTRY) LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, AlignedSize);
    if ( *NewUse == NULL ) {
        NetApiStatus = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavCreateNewEntry/LocalAlloc: NetApiStatus = %08lx\n",
                  NetApiStatus));
        return NetApiStatus;
    }

    //
    // Put the use information into the new use node.
    //
    (*NewUse)->Next = NULL;
    (*NewUse)->UseCount = 1;

    ASSERT ( Local == NULL || LocalLength == (wcslen(Local)+1));

    // 
    // Goto next free location in the buffer.
    //
    BuffOffset = ( (DWORD_PTR) *NewUse + sizeof(DAV_USE_ENTRY) );
    BuffOffset = ROUND_UP_COUNT(BuffOffset, ALIGN_WCHAR);

    //
    // Copy local device name into use entry after the LocalLength field,
    // if it is specified.
    //
    if (ARGUMENT_PRESENT(Local)) {

        
        //  
        //  Copy local device name.
        //  
        (*NewUse)->Local = (LPWSTR)BuffOffset;
        (*NewUse)->LocalLength = LocalLength;
        wcscpy((*NewUse)->Local, Local);

        BuffOffset += ((LocalLength) * sizeof(WCHAR));
        BuffOffset = ROUND_UP_COUNT(BuffOffset, ALIGN_WCHAR);

        // 
        // Copy TreeConnectStr.
        //
        if (ARGUMENT_PRESENT(TreeConnectStr)) {
            (*NewUse)->TreeConnectStr = (LPWSTR)BuffOffset;
            wcscpy((*NewUse)->TreeConnectStr, TreeConnectStr->Buffer);

            BuffOffset += (TreeConnectStr->MaximumLength);
            BuffOffset = ROUND_UP_COUNT(BuffOffset, ALIGN_WCHAR);
        }

    } else {
        
        (*NewUse)->Local = NULL;
        
        (*NewUse)->TreeConnectStr = NULL;
    }

    // 
    // Copy AuthUserName.
    //
    if (ARGUMENT_PRESENT(AuthUserName)) {
        (*NewUse)->AuthUserName = (LPWSTR)BuffOffset;
        (*NewUse)->AuthUserNameLength = AuthUserNameLength;
        wcscpy((*NewUse)->AuthUserName, AuthUserName);

        BuffOffset += ((AuthUserNameLength) * sizeof(WCHAR));
        BuffOffset = ROUND_UP_COUNT(BuffOffset, ALIGN_WCHAR);
    }

    //
    // If shared resource name is specified, create a new remote entry to hold
    // the UNC name, and total number of uses on this shared resource.
    //
    if (ARGUMENT_PRESENT(UncName)) {

        SIZE_T UncNameSize;

        UncNameSize = ( sizeof(UNC_NAME) + (UncNameLength * sizeof(WCHAR)) );

        NewRemoteEntry = (PUNC_NAME) LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT,
                                                UncNameSize);
        if (NewRemoteEntry == NULL) {
            NetApiStatus = GetLastError();
            DavPrint((DEBUG_ERRORS,
                      "DavCreateNewEntry/LocalAlloc: NetApiStatus = %08lx\n",
                      NetApiStatus));
            return NetApiStatus;
        }
    
        wcscpy((LPWSTR)NewRemoteEntry->UncName, UncName);
        NewRemoteEntry->UncNameLength = UncNameLength;
        NewRemoteEntry->TotalUseCount = 1;
        
        (*NewUse)->Remote = NewRemoteEntry;
    
    }

    //
    // Finally, store the handle that has been created in the new user entry
    // structure.
    //
    (*NewUse)->DavCreateFileHandle = DavCreateFileHandle;

    return NetApiStatus;
}


NET_API_STATUS
DavFindUse(
    IN  PLUID LogonId,
    IN  PDAV_USE_ENTRY UseList,
    IN  LPWSTR UseName,
    OUT PDAV_USE_ENTRY *MatchedPointer,
    OUT PDAV_USE_ENTRY *BackPointer OPTIONAL
    )
/*++

Routine Description:

    This function searches the Dav Use Table for the specified use connection.
    If the UseName is found in the Use Table (explicit connection), a pointer 
    to the matching use entry is returned.  Otherwise, MatchedPointer is set to 
    NULL.

    WARNING: This function assumes that the DavUseObject.TableResource is 
             claimed.

Arguments:

    LogonId - Supplies a pointer to the user's Logon Id.

    UseList - Supplies the use list of the user.

    UseName - Supplies the name of the tree connection, this is either a
              local device name or a UNC name.

    MatchedPointer - Returns the pointer to the matching use entry.  This
                     pointer is set to NULL if the specified use is an implicit
                     connection.

    BackPointer - Returns the pointer to the entry previous to the matching use 
                  entry if MatchedPointer is not NULL.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    PDAV_USE_ENTRY Back = NULL;

    //
    // Look for use entry depending on whether the local device name or UNC name 
    // is specified.
    //
    if (UseName[0] != L'\\') {
        //
        // Local device name is specified.
        //
        DavFindLocal( UseList, UseName, MatchedPointer, &(Back) );
    } else {
        //
        // A UNC name has been specified.
        //
        DavFindRemote( UseList, UseName, MatchedPointer, &(Back) );
    }

    if ( *MatchedPointer == NULL ) {
        DavPrint((DEBUG_ERRORS, "DavFindUse: %ws NOT found\n", UseName));
        return NERR_UseNotFound;
    } else {
        if (ARGUMENT_PRESENT(BackPointer)) {
            *BackPointer = Back;
        }
        return NERR_Success;
    }
}


VOID
DavFindLocal(
    IN  PDAV_USE_ENTRY UseList,
    IN  LPWSTR Local,
    OUT PDAV_USE_ENTRY *MatchedPointer,
    OUT PDAV_USE_ENTRY *BackPointer
    )
/*++

Routine Description:

    This function searches the use list for the specified local device name.

    WARNING: This function assumes that the DavUseObject.TableResource has been 
             claimed.

Arguments:

    UseList - Supplies the pointer to the use list.

    Local - Supplies the local device name.

    MatchedPointer - Returns a pointer to the use entry that holds the matching
                     local device name.  If no matching local device name is 
                     found, this pointer is set to NULL.

    BackPointer - Returns a pointer to the entry previous to the found entry.
                  If the local device name is not found, this pointer is set to 
                  NULL.

Return Value:

    None.

--*/
{
    *BackPointer = UseList;

    DavPrint((DEBUG_MISC, "DavFindLocal: LocalName = %ws\n", Local));

    while (UseList != NULL) {

        if ( (UseList->Local != NULL) && (_wcsicmp(UseList->Local, Local) == 0) ) {

            //
            // Found matching entry
            //
            *MatchedPointer = UseList;
            
            return;
        
        } else {
            
            *BackPointer = UseList;
            
            UseList = UseList->Next;
        
        }
    
    }

    DavPrint((DEBUG_ERRORS, "DavFindLocal: LocalName NOT found\n"));

    //
    // Did not find matching local device name in the entire list.
    //
    *MatchedPointer = NULL;
    *BackPointer = NULL;

    return;
}


VOID
DavFindRemote(
    IN  PDAV_USE_ENTRY UseList,
    IN  LPWSTR RemoteName,
    OUT PDAV_USE_ENTRY *MatchedPointer,
    OUT PDAV_USE_ENTRY *BackPointer
    )
/*++

Routine Description:

    This function searches the use list for the specified UNC name.

    WARNING: This function assumes that the DavUseObject.TableResource has been 
             claimed.

Arguments:

    UseList - Supplies the pointer to the use list.

    RemoteName - Supplies the UNC name.

    MatchedPointer - Returns a pointer to the use entry that holds the matching
                     UNC name.  If no matching UNC name is found, this pointer 
                     is set to NULL.

    BackPointer - Returns a pointer to the entry previous to the found entry.
                  If the UNC name is not found, this pointer is set to NULL.

Return Value:

    None.

--*/
{
    *BackPointer = UseList;

    DavPrint((DEBUG_MISC, "DavFindRemote: RemoteName = %ws\n", RemoteName));
    
    while (UseList != NULL) {

        //
        // When we are trying to delete a UNC connection, then we should make
        // sure that the one we are deleting does not have a local name 
        // associted with it. Only if "net use http://foo/bar" was done is
        // "net use http://foo/bar /d" allowed.
        //
        if ( (UseList->Local == NULL) &&
             (UseList->Remote->UncName != NULL) &&
             (_wcsicmp((LPWSTR)UseList->Remote->UncName, RemoteName) == 0) ) {

            DavPrint((DEBUG_MISC, "DavFindRemote: UncName = %ws\n", 
                      UseList->Remote->UncName));
            
            //
            // Found matching entry
            //
            *MatchedPointer = UseList;
            
            return;
        
        } else {
            
            *BackPointer = UseList;
            
            UseList = UseList->Next;
        
        }
    
    }

    DavPrint((DEBUG_ERRORS, "DavFindRemote: RemoteName NOT found\n"));

    //
    // Did not find matching local device name in the entire list.
    //
    *MatchedPointer = NULL;
    *BackPointer = NULL;

    return;
}


NET_API_STATUS
DavDeleteUse(
    IN PLUID LogonId,
    IN DWORD ForceLevel,
    IN PDAV_USE_ENTRY MatchedPointer,
    IN DWORD Index
    )
/*++

Routine Description:

    This function removes the use entry pointed by MatchedPointer and frees its 
    memory if, it is a UNC connection deleted with force, or if it is a UNC 
    connection deleted with no force and the use count is decremented to 0, or 
    it is a connection mapped to a local device.

    WARNING: This function assumes that the Use.TableResource is claimed.

Arguments:

    LogonId - Supplies a pointer to the user's Logon Id.

    ForceLevel - Supplies the level of force to delete.

    MatchedPointer - Supplies the pointer to the use entry to be deleted.

    Index - The index to the users table of entry belonging to the current user.

Return Value:

    NET_API_STATUS.

--*/
{
    NET_API_STATUS NetApiStatus = NERR_Success;
    PDAV_USE_ENTRY BackPointer = NULL;
    NTSTATUS CloseStatus = STATUS_SUCCESS;
    IO_STATUS_BLOCK IoStatusBlock;
    BOOL didImpersonate = FALSE;

    NetApiStatus = DavImpersonateClient();
    if (NetApiStatus != NO_ERROR) {
        DavPrint((DEBUG_ERRORS,
                  "DavDeleteUse/DavImpersonateClient: NetApiStatus = %08lx\n",
                  NetApiStatus));
        goto EXIT_THE_FUNCTION;
    }
    didImpersonate = TRUE;

    DavPrint((DEBUG_MISC, "DavDeleteUse: ForceLevel = %d\n", ForceLevel));

    //
    // No need to remove entry if UNC connection is deleted with USE_NOFORCE
    // level, and use count is not 0 after the deletion.
    //
    if ( ( MatchedPointer->Local == NULL ) && ( ForceLevel == USE_NOFORCE ) && 
         ( (MatchedPointer->UseCount - 1) > 0 ) ) {

        DavPrint((DEBUG_MISC, "DavDeleteUse: MatchedPointer->UseCount = %d\n",
                  MatchedPointer->UseCount));
        
        MatchedPointer->UseCount--;
            
        MatchedPointer->Remote->TotalUseCount--;
            
        ASSERT(MatchedPointer->Remote->TotalUseCount);

        goto EXIT_THE_FUNCTION;
    }

    CloseStatus = NtFsControlFile(MatchedPointer->DavCreateFileHandle,
                                  NULL,
                                  NULL,
                                  NULL,
                                  &(IoStatusBlock),
                                  FSCTL_DAV_DELETE_CONNECTION,
                                  &(ForceLevel),
                                  sizeof(ForceLevel),
                                  NULL,
                                  0);
    
    if (NT_SUCCESS(CloseStatus)) {
        CloseStatus = IoStatusBlock.Status;
    } else {
        NetApiStatus = RtlNtStatusToDosError(CloseStatus);
        goto EXIT_THE_FUNCTION;
    }

    //
    // We need to close the file handle that was created when the "net use" was
    // done. This handle is kept so that the underlying data structures in the
    // kernel (like SrvCall, VNetRoot etc.) remain valid for this connection.
    // Since we are deleting this connection now, we need to close this handle.
    // Before closing we impersonate the client that issues this request, just 
    // to be in the safe side. Hence we impersonated the client above.
    //
    DavPrint((DEBUG_MISC,
              "DavDeleteUse: Closing DavCreateFileHandle = %08lx\n",
              MatchedPointer->DavCreateFileHandle));

    CloseStatus = NtClose(MatchedPointer->DavCreateFileHandle);
    if (CloseStatus != STATUS_SUCCESS) {
        DavPrint((DEBUG_ERRORS,
                  "DavDeleteUse/NtClose: CloseStatus = %08lx\n",
                  CloseStatus));
    }

    //
    // Successfully deleted connection, and refound our entry. Delete symbolic 
    // link, if any.  Must be impersonating when deleting symbolic links.
    // Already impersonating, so DavDeleteSymbolicLink does not need to
    // impersonate the user.
    //
    NetApiStatus = DavDeleteSymbolicLink(MatchedPointer->Local,
                                         MatchedPointer->TreeConnectStr,
                                         NULL,
                                         INVALID_HANDLE_VALUE,
                                         TRUE);
    if (NetApiStatus != NO_ERROR) {
        DavPrint((DEBUG_ERRORS,
                  "DavDeleteuse/DavDeleteSymbolicLink: NetApiStatus = %08lx\n",
                  NetApiStatus));
        goto EXIT_THE_FUNCTION;
    }

    BackPointer = (PDAV_USE_ENTRY)DavUseObject.Table[Index].List;

    if (BackPointer != MatchedPointer) {
        
        while (BackPointer->Next != NULL) {
            
            if (BackPointer->Next == MatchedPointer) {
                break;
            } else {
                BackPointer = BackPointer->Next;
            }
        
        }

        ASSERT(BackPointer->Next == MatchedPointer);

        BackPointer->Next = MatchedPointer->Next;

    } else {
        
        //
        // Use entry is the first one on the use list
        //
        DavUseObject.Table[Index].List = (PVOID)MatchedPointer->Next;
    
    }

    MatchedPointer->Remote->TotalUseCount -= MatchedPointer->UseCount;

    if (MatchedPointer->Remote->TotalUseCount == 0) {
        LocalFree((HLOCAL)MatchedPointer->Remote);
    }

    // 
    // Since MatchedPointer was allocated as one-chunk, and AuthUserName
    // was stored in that chunk - so do not free AuthUserName 
    // separatly.
    //
    MatchedPointer->AuthUserName = NULL;
    MatchedPointer->AuthUserNameLength = 0;

    LocalFree((HLOCAL)MatchedPointer);

EXIT_THE_FUNCTION:

    if (didImpersonate) {
        DavRevertToSelf();
    }

    return NetApiStatus;
}


VOID
DavInitializeAndInsertTheServerShareEntry(
    IN OUT PDAV_SERVER_SHARE_ENTRY ServerShEntry,
    IN PWCHAR ServerName,
    IN ULONG EntrySize
    )
/*++

Routine Description:

    This routine initializes a newly created ServerShare entry strucutre and 
    inserts it into the global ServerShareEntry table. Note that the caller 
    should take a lock on the ServerShareEntry Table before calling this routine.
    
Arguments:

    ServerShEntry - Pointer to the ServerShare entry structure to be 
                    initialized and inserted.

    ServerName - Name of the server.
    
    EntrySize - Size of the server entry including the server name.
    
Return Value:

    none.

--*/
{
    ULONG ServerHashID;

    //
    // IMPORTANT!!!! The caller should take a lock on the global ServerShareTable 
    // before calling this routine.
    //

    ASSERT(ServerName != NULL);

    DavPrint((DEBUG_MISC,
              "DavInitializeAndInsertTheServerShareEntry: ServerName: %ws\n",
              ServerName));

    ServerShEntry->ServerName = &ServerShEntry->StrBuffer[0];
    wcscpy(ServerShEntry->ServerName, ServerName);

    ServerShEntry->TimeValueInSec = time(NULL);

    ServerShEntry->DavShareList = NULL;

    ServerShEntry->NumOfShares = 0;

    ServerHashID = DavHashTheServerName(ServerName);

    //
    // Insert the entry into the global ServerShareEntry table.
    //
    InsertHeadList( &(ServerShareTable[ServerHashID]), 
                                         &(ServerShEntry->ServerShareEntry) );
    
    return;
}


BOOL 
DavIsServerInServerShareTable(
    IN PWCHAR ServerName,
    OUT PDAV_SERVER_SHARE_ENTRY *ServerShEntry
    )
/*++

Routine Description:

    This routine checks to see if an entry for the ServerName supplied by the 
    caller exists in the global ServerShare table. If it does, the address of 
    the entry is returned in the caller supplied buffer. Note that the caller 
    should take a lock on the ServerShareTable before calling this routine.

Arguments:

    ServerName - Name of the server.
    
    ServerShEntry - Pointer to the ServerShare entry structure.

Return Value:

    TRUE - Server entry exists in the ServerShare table.
    
    FALSE - It does not. Duh.

--*/
{
    BOOL isPresent = FALSE;
    ULONG ServerHashID;
    PLIST_ENTRY listEntry;
    PDAV_SERVER_SHARE_ENTRY SSEntry;

    //
    // IMPORTANT!!!! The caller should take a lock on the global ServerShareTable 
    // before calling this routine.
    //
    
    ASSERT(ServerName != NULL);

    DavPrint((DEBUG_MISC,
              "DavIsServerInServerShareTable: ServerName = %ws\n", ServerName));
    
    //
    // Get the hash index of the server.
    //
    ServerHashID = DavHashTheServerName(ServerName);

    //
    // Search the ServerShare table at this index to see if an entry for this 
    // server exists.
    //
    listEntry = ServerShareTable[ServerHashID].Flink;
    while ( listEntry != &ServerShareTable[ServerHashID] ) {
        //
        // Get the pointer to the DAV_SERVER_SHARE_ENTRY structure.
        //
        SSEntry = CONTAINING_RECORD(listEntry,
                                    DAV_SERVER_SHARE_ENTRY,
                                    ServerShareEntry);
        //
        // Check to see if this entry is for the server in question.
        //
        if ( wcscmp(ServerName, SSEntry->ServerName) == 0 ) {
            isPresent = TRUE;
            break;
        }
        listEntry = listEntry->Flink;
    }

    if (isPresent) {
        //
        // Yes, we found the entry for this server. Return its address to the
        // caller in the supplied buffer.
        //
        *ServerShEntry = SSEntry;
        return isPresent;
    } 

    //
    // We did not find an entry for this server. Duh.
    //
    *ServerShEntry = NULL;
    
    return isPresent;
}


DWORD
DavGetShareListFromServer(
    PDAV_SERVER_SHARE_ENTRY ServerShEntry
    )
/*++

Routine Description:

    This routine gets the shares of the server in the ServerShEntry structure.

Arguments:

    ServerShEntry - Pointer to the ServerShare entry structure.

Return Value:

    ERROR_SUCESS or the Win32 error code.

--*/
{
    DWORD WStatus = ERROR_SUCCESS;
    HINTERNET DavConnHandle = NULL, DavOpenHandle = NULL;
    BOOL ReturnVal = FALSE, readDone = FALSE;
    PCHAR DataBuff = NULL;
    DWORD NumRead = 0, NumOfFileEntries = 0, TotalDataBytesRead = 0;
    PVOID Ctx1 = NULL, Ctx2 = NULL;
    PDAV_FILE_ATTRIBUTES DavFileAttributes = NULL;
    BOOL bStatus  = TRUE, revert = FALSE;
    
    DavPrint((DEBUG_MISC, 
              "DavGetShareListFromServer: ServerName = %ws\n", 
              ServerShEntry->ServerName));

    WStatus = DavImpersonateClient();
    if (WStatus != NO_ERROR) {
        DavPrint((DEBUG_ERRORS, 
                  "DavGetShareListFromServer/DavImpersonateClient: WStatus = %08lx\n",
                  WStatus));
        goto EXIT_THE_FUNCTION;
    }
    revert = TRUE;

    DavConnHandle = InternetConnectW(ISyncHandle,
                                     ServerShEntry->ServerName,
                                     INTERNET_DEFAULT_HTTP_PORT,
                                     NULL,
                                     NULL,
                                     INTERNET_SERVICE_HTTP,
                                     0,
                                     0);
    if (DavConnHandle == NULL) {
        WStatus = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavGetShareListFromServer/InternetConnectW. Error Val = %d.\n",
                  WStatus));
        goto EXIT_THE_FUNCTION;
    }

    //
    // To get the shares, we do a PROPFIND on the root directory. The Depth
    // header should be set to 1. The directory browsing should be enabled on 
    // the DAV server to enumerate the shares.
    //
    
    bStatus = DavHttpOpenRequestW(DavConnHandle,
                                     L"PROPFIND",
                                     L"/",
                                     L"HTTP/1.1",
                                     NULL,
                                     NULL,
                                     INTERNET_FLAG_KEEP_CONNECTION |
                                     INTERNET_FLAG_NO_COOKIES,
                                     0,
                                     L"DavGetSharesListFromServer",
                                     &DavOpenHandle);
    if(bStatus == FALSE) {
        WStatus = GetLastError();
        goto EXIT_THE_FUNCTION;
    }
    if (DavOpenHandle == NULL) {
        WStatus = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavGetShareListFromServer/HttpOpenRequestW. Error Val = %d\n", 
                  WStatus));
        goto EXIT_THE_FUNCTION;
    }

    ReturnVal = HttpAddRequestHeadersW(DavOpenHandle,
                                       L"Depth: 1\n",
                                       -1L,
                                       HTTP_ADDREQ_FLAG_ADD |
                                       HTTP_ADDREQ_FLAG_REPLACE );
    if (!ReturnVal) {
        WStatus = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavGetShareListFromServer/HttpAddRequestHeadersW. "
                  "Error Val = %d\n", WStatus));
        goto EXIT_THE_FUNCTION;
    }

    //
    // We need to add the header "translate:f" to tell IIS that it should 
    // allow the user to excecute this VERB on the specified path which it 
    // would not allow (in some cases) otherwise. Finally, there is a special 
    // flag in the metabase to allow for uploading of "dangerous" content 
    // (anything that can be run on the server). This is the ScriptSourceAccess
    // flag in the UI or the AccessSource flag in the metabase. You will need
    // to set this bit to true as well as correct NT ACLs in order to be able
    // to upload .exes or anything executable.
    //
    ReturnVal = HttpAddRequestHeadersW(DavOpenHandle,
                                       L"translate: f\n",
                                       -1L,
                                       HTTP_ADDREQ_FLAG_ADD |
                                       HTTP_ADDREQ_FLAG_REPLACE );
    if (!ReturnVal) {
        WStatus = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavGetShareListFromServer/HttpAddRequestHeadersW. "
                  "Error Val = %d\n", WStatus));
        goto EXIT_THE_FUNCTION;
    }

RESEND_THE_REQUEST:

    ReturnVal = HttpSendRequestExW(DavOpenHandle, NULL, NULL, HSR_SYNC, 0);
    if (!ReturnVal) {
        WStatus = GetLastError();
        //
        // If we fail with ERROR_INTERNET_NAME_NOT_RESOLVED, we make the
        // following call so that WinInet picks up the correct proxy settings
        // if they have changed. This is because we do call InternetOpen
        // (to create a global handle from which every other handle is derived)
        // when the service starts and this could be before the user logon
        // happpens. In such a case the HKCU would not have been initialized
        // and WinInet wouldn't get the correct proxy settings.
        //
        if (WStatus == ERROR_INTERNET_NAME_NOT_RESOLVED) {
            InternetSetOptionW(NULL, INTERNET_OPTION_SETTINGS_CHANGED, NULL, 0);
        }
        DavPrint((DEBUG_ERRORS,
                  "DavGetShareListFromServer/HttpSendRequestExW. Error Val = %d\n", 
                  WStatus));
        goto EXIT_THE_FUNCTION;
    }

    ReturnVal = HttpEndRequestW(DavOpenHandle, NULL, HSR_SYNC, 0);
    if (!ReturnVal) {
        WStatus = GetLastError();
        //
        // If the error we got back is ERROR_INTERNET_FORCE_RETRY, then
        // WinInet is trying to authenticate itself with the server. We need to 
        // repeat the HttpSend and HttpEnd request calls.
        //
        if (WStatus == ERROR_INTERNET_FORCE_RETRY) {
            goto RESEND_THE_REQUEST;
        }
        DavPrint((DEBUG_ERRORS,
                  "DavGetShareListFromServer/HttpEndRequestW. Error Val = %d\n", 
                  WStatus));
        goto EXIT_THE_FUNCTION;
    }

    // 
    // Check for return status. Server may have returned error. Like no-access or
    // others.
    // 
    WStatus = DavQueryAndParseResponse(DavOpenHandle);
    if (WStatus != ERROR_SUCCESS) {
        DavPrint((DEBUG_ERRORS,
                  "DavGetShareListFromServer/DavQueryAndParseResponse: WStatus = %d\n", 
                  WStatus));
        goto EXIT_THE_FUNCTION;
    }

    DataBuff = LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, NUM_OF_BYTES_TO_READ);
    if (DataBuff == NULL) {
        WStatus = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavGetShareListFromServer/LocalAlloc: WStatus = %08lx\n",
                  WStatus));
        goto EXIT_THE_FUNCTION;
    }

    //
    // Read the response and parse it.
    //
    do {

        ReturnVal = InternetReadFile(DavOpenHandle, 
                                     (LPVOID)DataBuff,
                                     NUM_OF_BYTES_TO_READ,
                                     &(NumRead));
        if (!ReturnVal) {
            WStatus = GetLastError();
            DavPrint((DEBUG_ERRORS,
                      "DavGetShareListFromServer/InternetReadFile: WStatus = "
                      "%08lx\n", WStatus));
            goto EXIT_THE_FUNCTION;
        }
    
        DavPrint((DEBUG_MISC, "DavGetShareListFromServer: NumRead = %d\n", NumRead));
        
        //
        // We reject files whose attributes are greater than a certain size
        // (DavFileAttributesLimitInBytes). This is a parameter that can be
        // set in the registry. This is done to avoid attacks by rogue servers.
        // We add a multiple of 10 since this is PROPFIND with Depth 1.
        //
        TotalDataBytesRead += NumRead;
        if (TotalDataBytesRead > (10 * DavFileAttributesLimitInBytes)) {
            WStatus = ERROR_BAD_NET_RESP;
            DavPrint((DEBUG_ERRORS, "DavGetShareListFromServer. FileAttributesSize > %d\n", DavFileAttributesLimitInBytes));
            goto EXIT_THE_FUNCTION;
        }

        readDone = (NumRead == 0) ? TRUE : FALSE;

        WStatus = DavPushData(DataBuff, &Ctx1, &Ctx2, NumRead, readDone);
        if (WStatus != ERROR_SUCCESS) {
            DavPrint((DEBUG_ERRORS,
                      "DavGetShareListFromServer/DavPushData."
                      " Error Val = %d\n", WStatus));
            goto EXIT_THE_FUNCTION;
        }

        if (readDone) {
            break;
        }
    
    } while ( TRUE );

    //
    // We now need to parse the data.
    //

    DavFileAttributes = LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT,
                                    sizeof(DAV_FILE_ATTRIBUTES) );
    if (DavFileAttributes == NULL) {
        WStatus = GetLastError();
        DavCloseContext(Ctx1, Ctx2);
        DavPrint((DEBUG_ERRORS,
                  "DavGetShareListFromServer/LocalAlloc. "
                  "Error Val = %d\n", WStatus));
        goto EXIT_THE_FUNCTION;
    }

    InitializeListHead( &(DavFileAttributes->NextEntry) );

    WStatus = DavParseData(DavFileAttributes, Ctx1, Ctx2, &NumOfFileEntries);
    if (WStatus != ERROR_SUCCESS) {
        DavFinalizeFileAttributesList(DavFileAttributes, TRUE);
        DavFileAttributes = NULL;
        DavPrint((DEBUG_ERRORS,
                  "DavGetShareListFromServer/DavParseData. "
                  "Error Val = %d\n", WStatus));
        goto EXIT_THE_FUNCTION;
    }

    ServerShEntry->NumOfShares = NumOfFileEntries;

    ServerShEntry->DavShareList = DavFileAttributes;

    DavCloseContext(Ctx1, Ctx2);
    
    WStatus = ERROR_SUCCESS;
    
EXIT_THE_FUNCTION:

    if (DavOpenHandle) {
        InternetCloseHandle(DavOpenHandle);
    }

    if (DavConnHandle) {
        InternetCloseHandle(DavConnHandle);
    }

    if (revert) {
        DWORD RStatus;
        RStatus = DavRevertToSelf();
        if (RStatus != NO_ERROR) {
            DavPrint((DEBUG_ERRORS, 
                      "DavGetShareListFromServer/DavRevertToSelf: RStatus = %08lx\n",
                      RStatus));
        }
    }

    if (DataBuff) {
        LocalFree(DataBuff);
    }

    return WStatus;
}


DWORD
DavrWinlogonLogonEvent(
    IN handle_t dav_binding_h
    )
/*++

Routine Description:

    This routine implements an RPC server function. Its called by davclnt.dll
    everytime a user logs on to the system. It increments the global variable 
    DavNumberOfLoggedOnUsers.
    
Arguments:

    dav_binding_h - The explicit RPC binding handle.
    
Return Value:

    ERROR_SUCCESS or the appropriate Win32 error code.

--*/
{
    DWORD WStatus = ERROR_SUCCESS;

    EnterCriticalSection( &(DavLoggedOnUsersLock) );

    //
    // Increment the Number of logged on users.
    //
    DavNumberOfLoggedOnUsers += 1;

    LeaveCriticalSection( &(DavLoggedOnUsersLock) );

    return WStatus;
}


DWORD
DavrWinlogonLogoffEvent(
    IN handle_t dav_binding_h
    )
/*++

Routine Description:

    This routine implements an RPC server function. Its called by davclnt.dll
    everytime a user logs off from the system. It decrements the global variable 
    DavNumberOfLoggedOnUsers.
    
Arguments:

    dav_binding_h - The explicit RPC binding handle.
    
Return Value:

    ERROR_SUCCESS or the appropriate Win32 error code.

--*/
{
    DWORD WStatus = ERROR_SUCCESS;

    EnterCriticalSection( &(DavLoggedOnUsersLock) );

    //
    // Decrement the Number of logged on users.
    //
    DavNumberOfLoggedOnUsers -= 1;

    LeaveCriticalSection( &(DavLoggedOnUsersLock) );

    return WStatus;
}


DWORD
DavrGetTheLockOwnerOfTheFile(
    IN handle_t dav_binding_h,
    IN PWCHAR FileName,
    OUT PWCHAR *LockOwnerName
    )
/*++

Routine Description:

    This routine is called by DavGetTheLockOwnerOfTheFile of davclnt.dll to
    find out who owns the LOCK on a particular file.

Arguments:

    FileName - The name of the file which is LOCKed on the server. The caller
               fills in this value. This should be a NULL terminated string. So,
               ((1 + wcslen(FileName)) * sizeof(WCHAR)) should give the length
               of the FileName (including the final L'\0' char) in bytes.

    LockOwnerName - On success, the API fills in the name of the person who owns
                    the LOCK on the file.

Returns:

    ERROR_SUCCESS - The call was successful. The LockOwnerName buffer contains
                    the name of the person who owns the lock.

    Some other Win32 error code.                                

--*/
{
    DWORD WStatus = ERROR_SUCCESS;
    NTSTATUS NtStatus = STATUS_SUCCESS;
    HANDLE DavRedirDeviceHandle = INVALID_HANDLE_VALUE;
    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING UnicodeDeviceName;
    PWCHAR DavRedirDeviceName = DD_DAV_DEVICE_NAME_U;
    PWCHAR InputBuffer = NULL, OutputBuffer = NULL;
    ULONG InputBufferLengthInBytes = 0, OutputBufferLengthInBytes = 0;
    ULONG NumberOfBytesTransferred = 0;
    BOOL SuccessfulOperation = FALSE, freeInputBuffer = FALSE;

    ASSERT(FileName != NULL);
    ASSERT(LockOwnerName != NULL);

    if (FileName == NULL || LockOwnerName == NULL) {
        WStatus = ERROR_INVALID_PARAMETER;
        goto EXIT_THE_FUNCTION;
    }

    if (wcslen(FileName) < 2) {
        WStatus = ERROR_INVALID_PARAMETER;
        goto EXIT_THE_FUNCTION;
    }

    DavPrint((DEBUG_MISC,
              "DavrGetTheLockOwnerOfTheFile: Entered. FileName = %ws\n",
              FileName));

    RtlInitUnicodeString(&(UnicodeDeviceName), DavRedirDeviceName);

    InitializeObjectAttributes(&(ObjectAttributes),
                               &(UnicodeDeviceName),
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    NtStatus = NtOpenFile(&(DavRedirDeviceHandle),
                          SYNCHRONIZE,
                          &(ObjectAttributes),
                          &(IoStatusBlock),
                          FILE_SHARE_VALID_FLAGS,
                          FILE_SYNCHRONOUS_IO_ALERT);
    if (NtStatus != STATUS_SUCCESS) {
        DavRedirDeviceHandle = INVALID_HANDLE_VALUE;
        WStatus = RtlNtStatusToDosError(NtStatus);
        DavPrint((DEBUG_ERRORS,
                  "DavrGetTheLockOwnerOfTheFile/NtOpenFile: WStatus = %08lx\n",
                  WStatus));
        goto EXIT_THE_FUNCTION;
    }

    //
    // We have this code in try-except since we are touching the buffers 
    // sent in by the user.
    //

    try {

        //
        // The FileName is either of the UNC format (\\server\share\foo.txt) or
        // a drive letter format (X:\foo.txt where X: is a drive mapped to a
        // remote share \\server\share).
        //
        if (FileName[0] == L'\\') {
            //
            // If the FileName is of the UNC format (\\server\share\foo.txt), the
            // path we need to send down is stripped off the first \. So in this
            // example the path sent down is \server\share\foo.txt.
            //
            ASSERT(FileName[1] == L'\\');
            InputBuffer = &(FileName[1]);
        } else {
            ASSERT(FileName[1] == L':');
            WStatus = DavConvertDriveLetterPathToUncPath(FileName, &(InputBuffer));
            if (WStatus != ERROR_SUCCESS) {
                DavPrint((DEBUG_ERRORS,
                          "DavrGetTheLockOwnerOfTheFile/DavConvertDriveLetterPathToUncPath:"
                          " WStatus = %08lx\n", WStatus));
                goto EXIT_THE_FUNCTION;
            }
            //
            // After a call to DavConvertDriveLetterPathToUncPath, InputBuffer
            // points to a UNC path \\server\share\foo.txt. The path we send
            // down needs to be stripped of the first \.
            //
            InputBuffer++;
            //
            // The function DavConvertLocalPathToUncPath allocates memory for
            // the InputBuffer which needs to be freed when this call
            // completes.
            //
            freeInputBuffer = TRUE;
        }

        InputBufferLengthInBytes = ( (1 + wcslen(InputBuffer)) * sizeof(WCHAR) );

        //
        // The worst case is <User>@<DnsDomain>. Maximum length of the LockOwner
        // field is (256 + 1 + 256) WCHARs.
        //
        OutputBufferLengthInBytes = ( (256 + 1 + 256) * sizeof(WCHAR) );

        //
        // Allocate memory for the LockOwnerrName to be sent back to the client.
        // This will be freed in the client code once the client is done.
        //
        *LockOwnerName = MIDL_user_allocate(OutputBufferLengthInBytes);
        if (*LockOwnerName == NULL) {
            WStatus = GetLastError();
            DavPrint((DEBUG_ERRORS,
                      "DavrGetTheLockOwnerOfTheFile/MIDL_user_allocate. WStatus = %d\n",
                      WStatus));
            goto EXIT_THE_FUNCTION;
        }

        //
        // The LockOwnerName buffer is assumed to be large enough to hold the
        // maximum size LockOwner string.
        //
        OutputBuffer = *LockOwnerName;

        //
        // Issue an IOCTL down to the DAV Mini-Redir to figure out who has
        // LOCKed this file.
        //
        SuccessfulOperation = DeviceIoControl(DavRedirDeviceHandle,
                                              IOCTL_UMRX_GET_LOCK_OWNER,
                                              InputBuffer,
                                              InputBufferLengthInBytes,
                                              OutputBuffer,
                                              OutputBufferLengthInBytes,
                                              &(NumberOfBytesTransferred),
                                              NULL);
        if (!SuccessfulOperation) {
            WStatus = GetLastError();
            ASSERT(WStatus != ERROR_INSUFFICIENT_BUFFER);
            DavPrint((DEBUG_ERRORS,
                      "DavrGetTheLockOwnerOfTheFile/DeviceIoControl: WStatus = %08lx\n",
                      WStatus));
            goto EXIT_THE_FUNCTION;
        }

        WStatus = ERROR_SUCCESS;

    } except (EXCEPTION_EXECUTE_HANDLER) {

          WStatus = GetExceptionCode();

          DavPrint((DEBUG_ERRORS,
                    "DavrGetTheLockOwnerOfTheFile: Exception!!! WStatus = %08lx\n",
                    WStatus));

          goto EXIT_THE_FUNCTION;

    }

EXIT_THE_FUNCTION:

    if (DavRedirDeviceHandle != INVALID_HANDLE_VALUE) {
        NtClose(DavRedirDeviceHandle);
        DavRedirDeviceHandle = INVALID_HANDLE_VALUE;
    }

    if (freeInputBuffer) {
        LocalFree(InputBuffer);
        InputBuffer = NULL;
    }

    return WStatus;
}


DWORD
DavConvertDriveLetterPathToUncPath(
    IN PWCHAR DriveLetterPath,
    OUT PWCHAR *UncPath
    )
/*++

Routine Description:

    This routine takes a DriveLetterPath (X:\foo.txt, where X: is a network
    drive mapped to \\server\davshare) and figures out the corresponding remote
    path. It then fills in the remote path in the UNC format into the UncPath
    buffer (\\server\share\foo.txt).

    IMPORTANT!!!    
    This routine allocates memory for the UncPath. Its the responsibility of
    the caller of this function to free this memory when its done.

Arguments:

    DriveLetterPath - A path like X:\Foo.txt, where X: is a network drive
                      mapped to \\server\davshare or \\server\davshare\folder.

    UncPath - On a successful return, this contains the remote path
              corresponding to the DriveLetterPath in the UNC format.

Returns:

    ERROR_SUCCESS or the appropriate Win32 error code.

--*/
{
    DWORD WStatus = ERROR_SUCCESS;
    PWCHAR RemPathName = NULL;
    PBYTE RemotePath = NULL;
    ULONG RemotePathLengthInBytes = 0, RemPathNameLengthInBytes = 0;
    BOOLEAN ResAcquired = FALSE, foundEntry = FALSE;
    DWORD index = 0;
    PDAV_USE_ENTRY DavUseEntry = NULL;
    LUID LogonId;
    WCHAR localDrive[3]; // For L"X:\0".

    DavPrint((DEBUG_MISC,
              "DavConvertDriveLetterPathToUncPath: DriveLetterPath = %ws\n",
              DriveLetterPath));

    if ( (DriveLetterPath == NULL) || (wcslen(DriveLetterPath) < 2) ) {
        WStatus = ERROR_INVALID_PARAMETER;
        goto EXIT_THE_FUNCTION;
    }

    if (DriveLetterPath[1] != L':') {
        WStatus = ERROR_INVALID_PARAMETER;
        goto EXIT_THE_FUNCTION;
    }

    localDrive[0] = DriveLetterPath[0];
    localDrive[1] = DriveLetterPath[1];
    localDrive[2] = L'\0';

    WStatus = DavImpersonateAndGetLogonId( &(LogonId) );
    if (WStatus != NO_ERROR) {
        DavPrint((DEBUG_ERRORS,
                  "DavConvertDriveLetterPathToUncPath/DavImpersonateAndGetLogonId: "
                  "WStatus = %08lx\n", WStatus));
        goto EXIT_THE_FUNCTION;
    }

    //
    // Lock the Dav Use Table while looking for entry to query.
    //
    if ( !RtlAcquireResourceExclusive( &(DavUseObject.TableResource), TRUE ) ) {
        DavPrint((DEBUG_ERRORS, 
                  "DavConvertDriveLetterPathToUncPath/RtlAcquireResourceExclusive.\n"));
        WStatus = NERR_InternalError;
        goto EXIT_THE_FUNCTION;
    }

    ResAcquired = TRUE;

    DavUseEntry = (PDAV_USE_ENTRY) DavUseObject.Table[index].List;

    while (DavUseEntry != NULL) {
        //
        // If this connection has no local name, then we just continue.
        //
        if (DavUseEntry->Local == NULL) {
            DavUseEntry = DavUseEntry->Next;
            continue;
       }
       if ( _wcsicmp(DavUseEntry->Local, localDrive) == 0 ) {
           //
           // We found a remote name that is associated with a LocalName
           // on this machine. 
           //
           foundEntry = TRUE;
           break;
       }
       DavUseEntry = DavUseEntry->Next;
    }

    if (foundEntry) {

        RemPathName = &(DriveLetterPath[2]);
        RemPathNameLengthInBytes = ( wcslen(RemPathName) * sizeof(WCHAR) );

        RemotePathLengthInBytes = ( (1 + DavUseEntry->Remote->UncNameLength) * sizeof(WCHAR) );
        RemotePathLengthInBytes += RemPathNameLengthInBytes;

        RemotePath = LocalAlloc(LPTR, RemotePathLengthInBytes);
        if (RemotePath == NULL) {
            WStatus = GetLastError();
            DavPrint((DEBUG_ERRORS,
                      "DavConvertDriveLetterPathToUncPath/LocalAlloc: WStatus = %08lx\n",
                      WStatus));
            goto EXIT_THE_FUNCTION;
        }

        RtlCopyMemory(RemotePath,
                      DavUseEntry->Remote->UncName,
                      (DavUseEntry->Remote->UncNameLength * sizeof(WCHAR)));

        RtlCopyMemory((RemotePath + (DavUseEntry->Remote->UncNameLength * sizeof(WCHAR))),
                      RemPathName,
                      RemPathNameLengthInBytes);

        *UncPath = (PWCHAR)RemotePath;

        DavPrint((DEBUG_MISC,
                  "DavConvertDriveLetterPathToUncPath: UncPath = %ws\n",
                  *UncPath));

        WStatus = ERROR_SUCCESS;

    } else {

        WStatus = ERROR_FILE_NOT_FOUND;

    }

EXIT_THE_FUNCTION:

    if (ResAcquired) {
        RtlReleaseResource( &(DavUseObject.TableResource) );
        ResAcquired = FALSE;
    }

    if (WStatus != ERROR_SUCCESS && RemotePath != NULL) {
        LocalFree(RemotePath);
        RemotePath = NULL;
    }

    return WStatus;
}


BOOL
DavCheckTheNonDAVServerList(
    PWCHAR ServerName
    )
/*++

Routine Description:

    This routine checks to see if the ServerName passed is in the list of
    servers that do not speak DAV (NonDAVServerList). Before we check, we go
    through the list once and free up all the old entries.

    IMPORTANT!!!    
    The caller of this routine must acquire the NonDAVServerListLock which is
    used to synchronize access to this global list.

Arguments:

    ServerName - The ServerName that needs to be checked.

Returns:

    TRUE - ServerName is a part of the NonDAVServerList.

    FALSE - ServerName is NOT a part of the NonDAVServerList.

--*/
{
    PLIST_ENTRY thisListEntry = NULL;
    PNON_DAV_SERVER_ENTRY NonDavServerEntry = NULL;
    time_t CurrentTimeInSec;
    BOOL foundEntry = FALSE;
    ULONGLONG TimeDiff; 

    DavPrint((DEBUG_DEBUG,
              "DavCheckTheNonDAVServerList: ServerName = %ws\n",
              ServerName));

    //
    // First go through the entire list and clean up the old entries.
    //

    thisListEntry = NonDAVServerList.Flink;

    while ( thisListEntry != &(NonDAVServerList) ) {

        NonDavServerEntry = CONTAINING_RECORD(thisListEntry,
                                              NON_DAV_SERVER_ENTRY,
                                              listEntry);

        thisListEntry = thisListEntry->Flink;

        CurrentTimeInSec = time(NULL);

        TimeDiff = (CurrentTimeInSec - NonDavServerEntry->TimeValueInSec);

        if (TimeDiff >= ServerNotFoundCacheLifeTimeInSec) {

            RemoveEntryList( &(NonDavServerEntry->listEntry) );

            LocalFree(NonDavServerEntry->ServerName);
            NonDavServerEntry->ServerName = NULL;

            LocalFree(NonDavServerEntry);
            NonDavServerEntry = NULL;

        }

    }

    //
    // Now that we have cleaned up all the old entries, go through the list
    // and find out the entry that matches the ServerName.
    //

    thisListEntry = NonDAVServerList.Flink;

    while ( thisListEntry != &(NonDAVServerList) ) {

        NonDavServerEntry = CONTAINING_RECORD(thisListEntry,
                                              NON_DAV_SERVER_ENTRY,
                                              listEntry);

        thisListEntry = thisListEntry->Flink;

        if ( !_wcsicmp(ServerName, NonDavServerEntry->ServerName) ) {
            foundEntry = TRUE;
            break;
        }

    }

    return foundEntry;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\server\fcbfobx.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    fcbfobx.c
    
Abstract:

    This module implements the user mode DAV miniredir routine(s) pertaining to 
    finalizition of Fobxs.

Author:

    Rohan Kumar      [RohanK]      30-Sept-1999

Revision History:

--*/

#include "pch.h"
#pragma hdrstop

#include "ntumrefl.h"
#include "usrmddav.h"
#include "global.h"
#include "nodefac.h"

//
// Implementation of functions begins here.
//

ULONG
DavFsFinalizeFobx(
    PDAV_USERMODE_WORKITEM DavWorkItem
    )
/*++

Routine Description:

    This routine handles DAV finalize Fobx requests that get reflected from the 
    kernel.

Arguments:

    DavWorkItem - The buffer that contains the request parameters and options.

Return Value:

    The return status for the operation

--*/
{
    ULONG WStatus = ERROR_SUCCESS;
    PDAV_USERMODE_FINALIZE_FOBX_REQUEST DavFinFobxReq = NULL;
    PDAV_FILE_ATTRIBUTES DavFileAttributes = NULL;

    DavFinFobxReq = &(DavWorkItem->FinalizeFobxRequest);

    DavFileAttributes = DavFinFobxReq->DavFileAttributes;

    DavPrint((DEBUG_MISC,
              "DavFsFinalizeFobx: DavFileAttributes = %08lx.\n", 
              DavFileAttributes));
    
    DavWorkItem->Status = WStatus;

    //
    // Finalize the list of DavFileAttributes.
    //
    DavFinalizeFileAttributesList(DavFileAttributes, TRUE);
    DavFileAttributes = NULL;
    
    return WStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\server\davutil.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    davutil.c
    
Abstract:

    This module implements the user mode DAV miniredir routines pertaining to 
    initialization, callbacks etc.

Author:

    Rohan Kumar      [RohanK]      07-July-1999

Revision History:

--*/

#include "pch.h"
#pragma hdrstop

#include "ntumrefl.h"
#include "usrmddav.h"
#include "global.h"
#include <time.h>
#include <objbase.h>
#include "UniUtf.h"
#include <netevent.h>
#include <wincrypt.h>

//
// Global definitions used in the DAV user mode process. These are explained
// in the header file "global.h".
//

HINTERNET IHandle = INVALID_HANDLE_VALUE;

HINTERNET ISyncHandle = INVALID_HANDLE_VALUE;

LIST_ENTRY ServerHashTable[SERVER_TABLE_SIZE];

CRITICAL_SECTION HashServerEntryTableLock = {0};
CRITICAL_SECTION DavPassportLock = {0};

//
// The BOOL is used in DavClose() to check if the critical section (see above)
// "HashServerEntryTableLock" was initialized. Since this is only used in 
// DavInit() and DavClose() functions, both os which are implemented in this
// file, this global is not exported in any header file.
//
BOOL ServerTableLockSet = FALSE;

ULONG ServerIDCount;

LIST_ENTRY ToBeFinalizedServerEntries;

BOOL didDavUseObjectInitialize = FALSE;

BOOL DavUsingWinInetSynchronously = FALSE;

//
// Mentioned below are the prototypes of functions that are used only within
// this module (file). These functions should not be exposed outside.
//

BOOL
DavFinalizeServerEntry (
    PHASH_SERVER_ENTRY ServerHashEntry
    );

//
// Implementation of functions begins here.
//

ULONG
DavInit(
    VOID
    )
/*++

Routine Description:

    This routine initializes the DAV environment.
    
Arguments:

    none.
    
Return Value:

    ERROR_SUCCESS or the appropriate error value.

--*/
{
    ULONG WStatus = ERROR_SUCCESS;
    ULONG count = 0;
    DWORD NumOfConnections = 0, ConnBuffSize = 0;
    INTERNET_STATUS_CALLBACK DavCallBack;
    BOOL ReturnVal;
    ULONG_PTR CallbackStatus;
    LPWSTR DAVUserAgent = NULL;
    OSVERSIONINFO osVersionInfo;
    WCHAR DAVUserAgentNameStr[] = L"Microsoft-WebDAV-MiniRedir";
    LONG DisableHKCUCaching = 0;

    // 
    // Get the OS version. This will be used to form WebDAV User Agent string.
    // This String is used in HttpPackects xchange.
    // 
    ZeroMemory(&osVersionInfo, sizeof(OSVERSIONINFO));
    osVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if (!GetVersionEx(&osVersionInfo)) {
        WStatus = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavInit/GetVersionEx. Error Val = %d\n", WStatus));
        goto EXIT_THE_FUNCTION;
    }

    DAVUserAgent = (LPWSTR) LocalAlloc ( LMEM_FIXED | LMEM_ZEROINIT,
                                         ( wcslen(DAVUserAgentNameStr) + // for: Microsoft-WebDAV-MiniRedir
                                           1 + // for L"/"
                                           5 + // for Major-Version
                                           1 + // for '.'
                                           5 + // for Minor-Version
                                           1 + // for '.'
                                           10  // for Build-No
                                           ) * sizeof (WCHAR));
    if (DAVUserAgent == NULL) {
        WStatus = GetLastError();
        DavPrint((DEBUG_ERRORS, "DavInit/LocalAlloc. Error Val = %d\n", WStatus));
        goto EXIT_THE_FUNCTION;
    }

    swprintf(DAVUserAgent, L"%s/%d.%d.%d",
             DAVUserAgentNameStr,
             osVersionInfo.dwMajorVersion,
             osVersionInfo.dwMinorVersion,
             osVersionInfo.dwBuildNumber);

    //
    // Set the ConnectionsPerServer limit to infinity.
    //

    NumOfConnections = 0xffffffff;
    ConnBuffSize = sizeof(DWORD);
    
    ReturnVal = InternetSetOptionW(NULL,
                                   INTERNET_OPTION_MAX_CONNS_PER_SERVER,
                                   &(NumOfConnections),
                                   ConnBuffSize);
    if ( !ReturnVal ) {
        WStatus = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavInit/InternetSetOptionW(1). Error Val = %d\n", WStatus));
        goto EXIT_THE_FUNCTION;
    }

    ReturnVal = InternetSetOptionW(NULL,
                                   INTERNET_OPTION_MAX_CONNS_PER_1_0_SERVER,
                                   &(NumOfConnections),
                                   ConnBuffSize);
    if ( !ReturnVal ) {
        WStatus = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavInit/InternetSetOptionW(2). Error Val = %d\n", WStatus));
        goto EXIT_THE_FUNCTION;
    }

    DavPrint((DEBUG_MISC, "DavInit: Using WinInet Synchronously\n"));

    DavUsingWinInetSynchronously = TRUE;

    //
    // Initialize an Internet handle for synchronous use.
    //
    IHandle = InternetOpenW((LPCWSTR)DAVUserAgent,
                            INTERNET_OPEN_TYPE_PRECONFIG,
                            NULL,
                            NULL,
                            0);
    if (IHandle == NULL) {
        IHandle = INVALID_HANDLE_VALUE;
        WStatus = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavInit/InternetOpenW(2). Error Val = %d\n", WStatus));
        goto EXIT_THE_FUNCTION;
    }

    {
        DWORD dwDisable = 0;
        if ( !InternetSetOptionW(IHandle, INTERNET_OPTION_DISABLE_AUTODIAL, &dwDisable, sizeof(DWORD)) ) {
            WStatus = GetLastError();
            DavPrint((DEBUG_ERRORS,
                  "DavInit/InternetSetOption(3). Error Val = %d\n", WStatus));
            goto EXIT_THE_FUNCTION;
        }
    }

    //
    // Initialize a synchronous Internet handle for synchronous use.
    //
    ISyncHandle = InternetOpenW((LPCWSTR)DAVUserAgent,
                                INTERNET_OPEN_TYPE_PRECONFIG,
                                NULL,
                                NULL,
                                0);
    if (ISyncHandle == NULL) {
        ISyncHandle = INVALID_HANDLE_VALUE;
        WStatus = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavInit/InternetOpenW(3). Error Val = %d\n", WStatus));
        goto EXIT_THE_FUNCTION;
    }

    {
        DWORD dwDisable = 1;
        if ( !InternetSetOptionW(ISyncHandle, INTERNET_OPTION_DISABLE_AUTODIAL, &dwDisable, sizeof(DWORD)) ) {
            WStatus = GetLastError();
            DavPrint((DEBUG_ERRORS,
                  "DavInit/InternetSetOption(3). Error Val = %d\n", WStatus));
            goto EXIT_THE_FUNCTION;
        }
    }

    //
    // Initialize the Global server hash table lock. Yes, 
    // InitializeCriticalSection can throw a STATUS_NO_MEMORY exception.
    //
    try {
        InitializeCriticalSection( &(HashServerEntryTableLock) );
        InitializeCriticalSection( &(ServerShareTableLock) );
        InitializeCriticalSection( &(DavLoggedOnUsersLock) );
        InitializeCriticalSection( &(DavPassportLock) );
        InitializeCriticalSection( &(NonDAVServerListLock) );
    } except (EXCEPTION_EXECUTE_HANDLER) {
          WStatus = GetExceptionCode();
          DavPrint((DEBUG_ERRORS,
                    "DavInit/InitializeCriticalSection: Exception Code ="
                    " = %08lx.\n", WStatus));
          goto EXIT_THE_FUNCTION;
    }
    ServerTableLockSet = TRUE;

    //
    // Initialize the hash table entries.
    //
    for (count = 0; count < SERVER_TABLE_SIZE; count++) {
        InitializeListHead( &(ServerHashTable[count]) );
    }

    //
    // Initialize the ServerShare table entries.
    //
    for (count = 0; count < SERVER_SHARE_TABLE_SIZE; count++) {
        InitializeListHead( &(ServerShareTable[count]) );
    }

    //
    // Set the ServerIDCount to zero;
    //
    ServerIDCount = 0;

    //
    // Set the number of logged on users to 0.
    //
    DavNumberOfLoggedOnUsers = 0;

    //
    // Initialize the "To Be Finalized Server Entries" list.
    //
    InitializeListHead( &(ToBeFinalizedServerEntries) );

    InitializeListHead( &(NonDAVServerList) );

    //
    // Initialize the Dav "net use" table.
    //
    DavUseObject.TableSize = 0;
    DavUseObject.Table = NULL;
    RtlInitializeResource( &(DavUseObject.TableResource) );
    didDavUseObjectInitialize = TRUE;

    //
    // WinInet needs to store the secondary DA cache in the HKCU. Even though
    // the thread that is doing this write is impersonating a different user this
    // write happens in wind up in HKEY_USERS\S-1-5-19 (LocalSystem). This is
    // because of a bug in the registry APIs. First open of the predefined handle
    // will initialize the HKCU cache and any open after that doesn't take the
    // impersonation into account. Its not quite right, but its legacy by now
    // (been there since NT4) and cannot be changed. By calling the registry API
    // RegDisablePredefinedCache, we can disable this caching process wide. The
    // DA cache will now be stored in the right HKCU. Tweener spec states that
    // the secondary DA cache be stored in the HKCU hive so that all Tweener
    // apps (IE, WPW) can benefit from this single location.
    //
    DisableHKCUCaching = RegDisablePredefinedCache();
    if (DisableHKCUCaching != ERROR_SUCCESS) {
        DavPrint((DEBUG_ERRORS,
                  "DavInit/RegDisablePredefinedCache: DisableHKCUCaching = %d\n",
                  DisableHKCUCaching));
    }

EXIT_THE_FUNCTION:

    if (WStatus != ERROR_SUCCESS) {

        if (IHandle != INVALID_HANDLE_VALUE) {
            BOOL ReturnVal;
            ReturnVal = InternetCloseHandle(IHandle);
            if (!ReturnVal) {
                ULONG CloseStatus = GetLastError();
                DavPrint((DEBUG_ERRORS,
                          "DavInit/InternetCloseHandle(1): Error Val = %d.\n", 
                          CloseStatus));
            }
            IHandle = INVALID_HANDLE_VALUE;
        }

        if (ISyncHandle != INVALID_HANDLE_VALUE) {
            BOOL ReturnVal;
            ReturnVal = InternetCloseHandle(ISyncHandle);
            if (!ReturnVal) {
                ULONG CloseStatus = GetLastError();
                DavPrint((DEBUG_ERRORS,
                          "DavInit/InternetCloseHandle(2): Error Val = %d.\n", 
                          CloseStatus));
            }
            ISyncHandle = INVALID_HANDLE_VALUE;
        }

    }

    if (DAVUserAgent != NULL) {
        LocalFree((HLOCAL)DAVUserAgent);
        DAVUserAgent = NULL;
    }

    return WStatus;
}


VOID
DavClose(
    VOID
    )
/*++

Routine Description:

    This routine frees up the resources acquired during the initialization of
    the DAV environment.
    
Arguments:

    none.
    
Return Value:

    none.

--*/
{
    //
    // Close IHandle if needed.
    //
    if (IHandle != INVALID_HANDLE_VALUE) {
        BOOL ReturnVal;
        ReturnVal = InternetCloseHandle(IHandle);
        if (!ReturnVal) {
            ULONG CloseStatus = GetLastError();
            DavPrint((DEBUG_ERRORS,
                      "DavClose/InternetCloseHandle(1): Error Val = %d.\n", 
                      CloseStatus));
        }
        IHandle = INVALID_HANDLE_VALUE;
    }

    if (ISyncHandle != INVALID_HANDLE_VALUE) {
        BOOL ReturnVal;
        ReturnVal = InternetCloseHandle(ISyncHandle);
        if (!ReturnVal) {
            ULONG CloseStatus = GetLastError();
            DavPrint((DEBUG_ERRORS,
                      "DavClose/InternetCloseHandle(2): Error Val = %d.\n", 
                      CloseStatus));
        }
        ISyncHandle = INVALID_HANDLE_VALUE;
    }
    
    //
    // Delete the critical section used for synchronizing the server hash table.
    //
    if (ServerTableLockSet) {
        DeleteCriticalSection( &(HashServerEntryTableLock) );
        DeleteCriticalSection( &(ServerShareTableLock) );
        DeleteCriticalSection( &(DavLoggedOnUsersLock) );
        DeleteCriticalSection( &(DavPassportLock) );
        DeleteCriticalSection( &(NonDAVServerListLock) );
        ServerTableLockSet = FALSE;
    }

    if (didDavUseObjectInitialize) {
        RtlDeleteResource( &(DavUseObject.TableResource) );
        didDavUseObjectInitialize = FALSE;
    }

    return;
}


ULONG
DavHashTheServerName(
    PWCHAR ServerName
    )
/*++

Routine Description:

    The hash function that takes in a string, hashes it to produce a ULONG
    which is returned to the caller.

Arguments:

    ServerName - Name to be hashed.

Return Value:

    The hashed value.

--*/
{
    ULONG HashedValue = 0, Val = 0, TotalVal = 0, shiftCount = 0;
    PWCHAR cPtr;

    if (ServerName == NULL) {
        DavPrint((DEBUG_ERRORS, "DavHashTheServerName. The ServerName is NULL.\n"));
        HashedValue = SERVER_TABLE_SIZE;
        return (HashedValue);
    }

    //
    // The for loop below forms the hashing logic. We take each character of the
    // server name, cast it to a ULONG, lshift it by shiftCount (0, 4, 8,...,28)
    // and add it to HashedValue. Once the shiftCount reaches 28, we reset it to
    // zero.
    //
    for (cPtr = ServerName; *cPtr != L'\0'; cPtr++) {
        Val = (ULONG)(*cPtr);
        Val = Val << shiftCount;
        shiftCount += 4;
        if (shiftCount == 28) {
            shiftCount = 0;
        }
        TotalVal += Val;
    }

    //
    // Finally we take the value % SERVER_TABLE_SIZE.
    //
    HashedValue = TotalVal % SERVER_TABLE_SIZE;

    DavPrint((DEBUG_MISC,
              "DavHashTheServerName. ServerName = %ws, HashValue = %d\n",
              ServerName, HashedValue));

    return (HashedValue);
}


BOOL 
DavIsThisServerInTheTable(
    IN PWCHAR ServerName,
    OUT PHASH_SERVER_ENTRY *ServerHashEntry
    )
/*++

Routine Description:

    This routine checks to see if an entry for the ServerName supplied by the 
    caller exists in the hash table. If it does, the address of the entry is
    returned in the caller supplied buffer. Note that the caller should take a
    lock on the ServerHashTable before calling this routine.

Arguments:

    ServerName - Name of the server.
    
    ServerHashEntry - Pointer to the Hash entry structure.

Return Value:

    TRUE - Server entry exists in the hash table
    
    FALSE - It does not. Duh.

--*/
{
    BOOL isPresent = FALSE;
    ULONG ServerHashID;
    PLIST_ENTRY listEntry;
    PHASH_SERVER_ENTRY HashEntry;

    //
    // IMPORTANT!!!! The caller should take a lock on the global ServerHashTable 
    // before calling this routine.
    //
    
    ASSERT(ServerName != NULL);

    DavPrint((DEBUG_MISC, 
              "DavIsThisServerInTheTable: Checking if ServerName: %ws exists "
              "in the table.\n", ServerName));
    
    //
    // Get the hash index of the server.
    //
    ServerHashID = DavHashTheServerName(ServerName);
    ASSERT(ServerHashID != SERVER_TABLE_SIZE);

    //
    // Search the hash table at this index to see if an entry for this server
    // exists.
    //
    listEntry = ServerHashTable[ServerHashID].Flink;
    while ( listEntry != &ServerHashTable[ServerHashID] ) {
        //
        // Get the pointer to the HASH_SERVER_ENTRY structure.
        //
        HashEntry = CONTAINING_RECORD(listEntry,
                                      HASH_SERVER_ENTRY,
                                      ServerListEntry);
        //
        // Check to see if this entry is for the server in question.
        //
        if ( wcscmp(ServerName, HashEntry->ServerName) == 0 ) {
            isPresent = TRUE;
            break;
        }
        listEntry = listEntry->Flink;
    }

    if (isPresent) {
        //
        // Yes, we found the entry for this server. Return its address to the
        // caller in the supplied buffer.
        //
        *ServerHashEntry = HashEntry;
        return isPresent;
    } 

    //
    // We did not find an entry for this server. Duh.
    //
    *ServerHashEntry = NULL;
    
    return isPresent;
}


BOOL 
DavIsServerInFinalizeList(
    IN PWCHAR ServerName,
    OUT PHASH_SERVER_ENTRY *ServerHashEntry,
    IN BOOL ReactivateIfExists
    )
/*++

Routine Description:

    This routine checks to see if an entry for the ServerName supplied by the 
    caller exists in the "to be finalized" list. If it does, the address of the 
    entry is returned in the caller supplied buffer. It also moves the server
    entry from the "to be finalized list" to the hash table. Note that the 
    caller should take a lock on the "ToBeFinalizedServerEntries" before calling 
    this routine.

Arguments:

    ServerName - Name of the server.
    
    ServerHashEntry - Pointer to the Hash entry structure.
    
    ReactivateIfExists - If this is TRUE, then if the ServerHashEntry exists, it
                         is reactivated. If this is FALSE, it means that the 
                         caller just wanted to know if the ServerHashEntry exists 
                         or not in the ServerHashTable and we shouldn't reactivate 
                         it.

Return Value:

    TRUE - Server entry exists in the list.
    
    FALSE - It does not. Duh.

--*/
{
    BOOL isPresent = FALSE;
    ULONG ServerHashID;
    PLIST_ENTRY listEntry;
    PHASH_SERVER_ENTRY ServerEntry;
    PPER_USER_ENTRY PerUserEntry;

    //
    // IMPORTANT!!!! The caller should take a lock on the global ServerHashTable 
    // before calling this routine.
    //

    //
    // Before we search the ToBeFinalizedList for an entry for this Server, we
    // finalize the list to remove any stale entires. Once we are done with the
    // finalization, we can proceed.
    //
    DavFinalizeToBeFinalizedList();
    
    listEntry = ToBeFinalizedServerEntries.Flink;

    while ( listEntry != &ToBeFinalizedServerEntries ) {
        
        //
        // Get the pointer to the HASH_SERVER_ENTRY structure.
        //
        ServerEntry = CONTAINING_RECORD(listEntry,
                                        HASH_SERVER_ENTRY,
                                        ServerListEntry);
        //
        // Check to see if this entry is for the server in question.
        //
        if ( wcscmp(ServerName, ServerEntry->ServerName) == 0 ) {
            isPresent = TRUE;
            break;
        }
        
        listEntry = listEntry->Flink;
    
    }
    
    if (isPresent) {

        //
        // If this entry is not for a valid DAV server, then we return TRUE, but
        // set *ServerHashEntry to NULL. This gives an indication to the caller
        // that the entry exists, but is not a valid DAV server.
        //
        if (!ServerEntry->isDavServer) {
            *ServerHashEntry = NULL;
            return isPresent;
        }

        if (ReactivateIfExists) {

            //
            // OK, its a valid DAV server. Remove it from the "to be finalized" 
            // list.
            //
            RemoveEntryList( &(ServerEntry->ServerListEntry) );

            //
            // Check to see if the worker (scavenger) thread tried finalizing it.
            // If it did, we need to unfinalize it. By that we mean, go through all
            // the user entries (they should be marked closing), add a reference
            // count (the thread would have decremented it while finalizing) and set
            // the state to initialized.
            //
            if (ServerEntry->HasItBeenScavenged) {

                listEntry = ServerEntry->PerUserEntry.Flink;

                while ( listEntry != &(ServerEntry->PerUserEntry) ) {
                    //
                    // Get the pointer to the PER_USER_ENTRY structure.
                    //
                    PerUserEntry = CONTAINING_RECORD(listEntry,
                                                     PER_USER_ENTRY,
                                                     UserEntry);
                    //
                    // The current state should be closing.
                    //
                    ASSERT(PerUserEntry->UserEntryState == UserEntryClosing);

                    //
                    // Set the state to initialized.
                    //
                    PerUserEntry->UserEntryState = UserEntryInitialized;

                    //
                    // Increment the reference count.
                    //
                    PerUserEntry->UserEntryRefCount++;

                    listEntry = listEntry->Flink;
                }

                ServerEntry->HasItBeenScavenged = FALSE;
            }

            //
            // Set its RefCount to 1.
            //
            ServerEntry->ServerEntryRefCount = 1;

            //
            // Add it to the hash table.
            //
            ServerHashID = DavHashTheServerName(ServerName);
            ASSERT(ServerHashID != SERVER_TABLE_SIZE);
            InsertHeadList( &(ServerHashTable[ServerHashID]), 
                                             &(ServerEntry->ServerListEntry) );

            ServerEntry->TimeValueInSec = DONT_EXPIRE;

        }

        //
        // Yes, we found the entry for this server. We need to move this entry 
        // to the hash table.
        //
        *ServerHashEntry = ServerEntry;

        return isPresent;

    }

    //
    // We did not find an entry for this server. Duh.
    //
    *ServerHashEntry = NULL;
    
    return isPresent;
}


VOID
DavInitializeAndInsertTheServerEntry(
    IN OUT PHASH_SERVER_ENTRY ServerHashEntry,
    IN PWCHAR ServerName,
    IN ULONG EntrySize
    )
/*++

Routine Description:

    This routine initializes a newly created server entry strucutre and inserts
    it into the global server hash table. Note that the caller should take a
    lock on the ServerHashTable before calling this routine.
    
Arguments:

    ServerHashEntry - Pointer to the Hash entry structure to be initialized and
                      inserted.

    ServerName - Name of the server.
    
    EntrySize - Size of the server entry including the server name.
    
Return Value:

    none.

--*/
{
    ULONG ServerHashID;

    //
    // IMPORTANT!!!! The caller should take a lock on the global ServerHashTable 
    // before calling this routine.
    //

    ASSERT(ServerName != NULL);

    DavPrint((DEBUG_MISC, 
              "DavInitializeAndInsertTheServerEntry: ServerName: %ws.\n",
              ServerName));
    //
    // Copy the server name to the end of the structure.
    //
    ASSERT( (EntrySize - sizeof(HASH_SERVER_ENTRY))  >= 
                                  ((wcslen(ServerName) + 1) * sizeof(WCHAR)) );
    ServerHashEntry->ServerName = &ServerHashEntry->StrBuffer[0];
    wcscpy(ServerHashEntry->ServerName, ServerName);

    ServerHashEntry->EntrySize = EntrySize;

    ServerHashEntry->TimeValueInSec = DONT_EXPIRE;

    ServerHashEntry->HasItBeenScavenged = FALSE;

    //
    // Increment the ID and assign it to the entry.
    //
    ServerIDCount++;
    ServerHashEntry->ServerID = ServerIDCount;

    //
    // Initialize the Per User list that hangs off the server entry.
    //
    InitializeListHead( &(ServerHashEntry->PerUserEntry) );

    //
    // Finally set the reference count of this entry to 1.
    //
    ServerHashEntry->ServerEntryRefCount = 1;

    //
    // Finally, get the hash ID and insert this new entry into the global server 
    // entry hash table.
    //
    ServerHashID = DavHashTheServerName(ServerName);
    ASSERT(ServerHashID != SERVER_TABLE_SIZE);
    InsertHeadList( &(ServerHashTable[ServerHashID]), &(ServerHashEntry->ServerListEntry) );

    return;
}


VOID
DavFinalizeToBeFinalizedList(
    VOID
    )
/*++

Routine Description:

    This routine walks through the list of ToBeFinalizedServerEntries and 
    finalizes those whose "to live" time has expired. When server entries 
    are added to this list, the time is saved. Periodically a worker thread
    calls this function and finalizes all the entries for whom,
    (CurrentTime - TimeSaved >= ThresholdValue).  Note that the caller should 
    take a lock on the "ToBeFinalizedServerEntries" before calling this routine.
    
Arguments:

    none.
    
Return Value:

    none.

--*/
{
    PLIST_ENTRY listEntry;
    time_t CurrentTimeInSec;
    ULONGLONG TimeDiff; 
    PHASH_SERVER_ENTRY ServerHashEntry = NULL;
    BOOL shouldFree = TRUE;

    //
    // IMPORTANT!!!! The caller should take a lock on the global ServerHashTable 
    // before calling this routine.
    //
    
    listEntry = ToBeFinalizedServerEntries.Flink;

    while ( listEntry != &ToBeFinalizedServerEntries) {

        //
        // Get the pointer to the HASH_SERVER_ENTRY structure.
        //
        ServerHashEntry = CONTAINING_RECORD(listEntry,
                                            HASH_SERVER_ENTRY,
                                            ServerListEntry);
        
        //
        // Get the next entry on the list.
        //
        listEntry = listEntry->Flink;

        //
        // If the ServerEntryRefCount is > 0 then we don't finalize this
        // ServerHashEntry since some thread is still accessing it.
        //
        if (ServerHashEntry->ServerEntryRefCount > 0) {
            continue;
        }

        CurrentTimeInSec = time(NULL);

        TimeDiff = ( CurrentTimeInSec - (ServerHashEntry->TimeValueInSec) );

        if ( TimeDiff >= ServerNotFoundCacheLifeTimeInSec ) {

            //
            // Finalize this server entry. If the return value is TRUE it means
            // that all the user entries that were hanging off this server 
            // entry have been finalized and so we can go ahead and free this
            // entry. If its FALSE, it means that the we have marked as closing
            // all the user entries, but not all of them were finalized. This
            // is because some thread still holds a reference to the user entry.
            // Finally, set the bool value that says it was scavenged to TRUE.
            //
            ServerHashEntry->HasItBeenScavenged = TRUE;
            
            shouldFree = DavFinalizeServerEntry(ServerHashEntry);
            
            if (shouldFree) {
                
                HLOCAL FreeHandle;
                ULONG FreeStatus;
                
                //
                // Remove this entry from the ToBeFinalizedList of Server 
                // entries.
                //
                RemoveEntryList( &(ServerHashEntry->ServerListEntry) );

                //
                // If the ServerEventHandle is not NULL then we close it
                // before freeing the ServerHashEntry structure.
                //
                if (ServerHashEntry->ServerEventHandle != NULL) {
                    CloseHandle(ServerHashEntry->ServerEventHandle);
                }

                FreeHandle = LocalFree((HLOCAL)ServerHashEntry);
                if (FreeHandle != NULL) {
                    FreeStatus = GetLastError();
                    DavPrint((DEBUG_ERRORS,
                              "DavFinalizeToBeFinalizedList/LocalFree. "
                              "Error Val = %d.\n", FreeStatus));
                }

            }

        }

    }

    return;
}


BOOL
DavFinalizeServerEntry (
    PHASH_SERVER_ENTRY ServerHashEntry
    )
/*++

Routine Description:

    This routine finalizes the server entry that is passed to the routine. Note
    that the caller should take a lock on the ServerHashTable before calling 
    this routine.
    
Arguments:

    ServerHashEntry - The server entry being finalized.
    
Return Value:

    none.

--*/
{
    PLIST_ENTRY listEntry;
    PPER_USER_ENTRY UserEntry;
    BOOL didFree = TRUE, didFinalize;

    //
    // IMPORTANT!!!! The caller should take a lock on the global ServerHashTable 
    // before calling this routine.
    //
    
    DavPrint((DEBUG_MISC, 
              "DavFinalizeServerEntry: ServerEntry: %08lx.\n", ServerHashEntry));

    listEntry = ServerHashEntry->PerUserEntry.Flink;
    
    //
    // Go through all the User entries, mark them closing and finalize them.
    // If we have already marked them closing then we don't need to finalize 
    // them again.
    //
    while ( listEntry != &(ServerHashEntry->PerUserEntry) ) {
        
        //
        // Get the pointer to the PER_USER_ENTRY structure.
        //
        UserEntry = CONTAINING_RECORD(listEntry, PER_USER_ENTRY, UserEntry);

        //
        // Get the next entry on the list.
        //
        listEntry = listEntry->Flink;
        
        //
        // This is the only routine that marks the state of a user entry to be
        // closing. If the first one is marked closing, then we have already 
        // through this list before and hence we just return. Some other thread(s)
        // has(ve) a reference to this and will finalizeit when they are done.
        //
        if (UserEntry->UserEntryState == UserEntryClosing) {
            ASSERT(ServerHashEntry->HasItBeenScavenged == TRUE);
            didFree = FALSE;
            break;
        }

        //
        // Mark this entry closing and then call the finalization routine. If 
        // we did not finalize, then set didFree to FALSE. Since we do not wish
        // to free the server entry even if one user entry is not finalized.
        //
        UserEntry->UserEntryState = UserEntryClosing;
            
        didFree = FALSE;

    }

    return didFree;
}


VOID
_stdcall
DavHandleAsyncResponse(
    HINTERNET IHandle,
    DWORD_PTR CallBackContext,
    DWORD InternetStatus,
    LPVOID StatusInformation,
    DWORD StatusInformationLength
    )
/*++

Routine Description:

   This is the callback routine that gets called at various times during the 
   processing of an asynchronous request. 

Arguments:

    pDavCallBackContext - The context structure to be set.
    
    DavOperation - The Dav operation that will be called with this context. 

Return Value:

    ERROR_SUCCESS or the appropriate error value.

--*/
{


    ASSERT(!"WinInet Callback should not be called");
    return;
}


DWORD 
WINAPI
DavCommonDispatch(
    LPVOID Context
    )
/*++

Routine Description:

   This is the callback routine that gets called at various times during the 
   processing of an asynchronous request. 

Arguments:

    Context - The DAV_USERMODE_WORKITEM value.

Return Value:

    ERROR_SUCCESS or the appropriate error value.

--*/
{
    DWORD WStatus = ERROR_SUCCESS;
    PDAV_USERMODE_WORKITEM DavWorkItem = (PDAV_USERMODE_WORKITEM)Context;

    DavPrint((DEBUG_MISC,
              "DavCommonDispatch: DavWorkItem = %08lx, DavOperation = %d,"
              " WorkItemType = %d\n", DavWorkItem, DavWorkItem->DavOperation,
              DavWorkItem->WorkItemType));
    
    if (DavWorkItem->DavOperation <= DAV_CALLBACK_HTTP_SEND) {

        WStatus = DavAsyncCommonStates(DavWorkItem, TRUE);
        if (WStatus != ERROR_SUCCESS && WStatus != ERROR_IO_PENDING) {
            DavPrint((DEBUG_ERRORS, 
                      "DavCommonDispatch/DavAsyncCommonStates. WStatus = "
                      "%08lx\n", WStatus));
        }

    } else {

        switch(DavWorkItem->WorkItemType) {
        
        case UserModeCreateSrvCall: {
            WStatus = DavAsyncCreateSrvCall(DavWorkItem, TRUE);
            if (WStatus != ERROR_SUCCESS && WStatus != ERROR_IO_PENDING) {
                DavPrint((DEBUG_ERRORS, 
                          "DavCommonDispatch/DavAsyncCreateSrvCall. WStatus = "
                          "%08lx.\n", WStatus));
            }
        }
            break;
        
        case UserModeCreateVNetRoot: {
            WStatus = DavAsyncCreateVNetRoot(DavWorkItem, TRUE);
            if (WStatus != ERROR_SUCCESS && WStatus != ERROR_IO_PENDING) {
                DavPrint((DEBUG_ERRORS, 
                          "DavCommonDispatch/DavAsyncCreateVNetRoot. WStatus = "
                          "%08lx.\n", WStatus));
            }
        }
            break;
        
        case UserModeCreate: {
            WStatus = DavAsyncCreate(DavWorkItem, TRUE);
            if (WStatus != ERROR_SUCCESS && WStatus != ERROR_IO_PENDING) {
                DavPrint((DEBUG_ERRORS, 
                          "DavCommonDispatch/DavAsyncCreate. WStatus = %08lx.\n", 
                          WStatus));
            }
        }
            break;
        
        case UserModeQueryDirectory: {
            WStatus = DavAsyncQueryDirectory(DavWorkItem, TRUE);
            if (WStatus != ERROR_SUCCESS && WStatus != ERROR_IO_PENDING) {
                DavPrint((DEBUG_ERRORS, 
                          "DavCommonDispatch/DavAsyncQueryDirectory. WStatus = "
                          "%08lx.\n", WStatus));
            }
        }
            break;
        
        case UserModeReName: {
            WStatus = DavAsyncReName(DavWorkItem, TRUE);
            if (WStatus != ERROR_SUCCESS && WStatus != ERROR_IO_PENDING) {
                DavPrint((DEBUG_ERRORS, 
                          "DavCommonDispatch/DavAsyncReName. WStatus = %08lx.\n", 
                          WStatus));
            }
        }
        break;
        
       case UserModeSetFileInformation: {
            ASSERT(FALSE);
        }
        break;            
        
        case UserModeClose: {
            WStatus = DavAsyncClose(DavWorkItem, TRUE);
            if (WStatus != ERROR_SUCCESS && WStatus != ERROR_IO_PENDING) {
                DavPrint((DEBUG_ERRORS, 
                          "DavCommonDispatch/DavAsyncClose. WStatus = %08lx.\n", 
                          WStatus));
            }
        }
            break;
        
        default: {
            ASSERT(!"Invalid DavWorkItem->WorkItemType");
            WStatus = ERROR_INVALID_PARAMETER;
            DavPrint((DEBUG_ERRORS,
                      "DavCommonDispatch: Invalid DavWorkItem->WorkItemType = %d.\n",
                      DavWorkItem->WorkItemType));
        }
            break;
        
        }

    }

    return WStatus;
}


DWORD 
DavAsyncCommonStates(
    PDAV_USERMODE_WORKITEM DavWorkItem,
    BOOLEAN CalledByCallBackThread
    )
/*++

Routine Description:

   This routine is called to handle the common operations during the Async 
   server calls. To avoid duplicating the code in every Async operation like
   CreateSrvCall, Create etc., the code handling the common states has been
   consolidated into this routine.

Arguments:

    DavWorkItem - The DAV_USERMODE_WORKITEM value.
    
    CalledByCallbackThread - TRUE, if this function was called by the thread
                             which picks of the DavWorkItem from the Callback
                             function. This happens when an Async WinInet call
                             returns ERROR_IO_PENDING and completes later.

Return Value:

    ERROR_SUCCESS or the appropriate error value.

--*/
{
    ULONG WStatus = ERROR_SUCCESS;
    PUMRX_USERMODE_WORKITEM_HEADER UserWorkItem;
    HINTERNET DavConnHandle = NULL, DavOpenHandle = NULL;
    ULONG_PTR CallBackContext = (ULONG_PTR)0;
    BOOL ReturnVal, didImpersonate = FALSE;
    PWCHAR HTTPVerb = NULL;
    PWCHAR ObjectName = NULL;
    LPINTERNET_BUFFERS InternetBuffers = NULL;
    DWORD SendEndRequestFlags = 0;
    BOOL BStatus = FALSE;
    PWCHAR PassportCookie = NULL;
    
    UserWorkItem = (PUMRX_USERMODE_WORKITEM_HEADER)DavWorkItem;

    //
    // If we are using WinInet synchronously, the the flag value that is passed
    // to HttpSendRequestExW and HttpEndRequestW is HSR_SYNC.
    //
    SendEndRequestFlags = HSR_SYNC;
    
    switch (DavWorkItem->DavOperation) {
    
    case DAV_CALLBACK_INTERNET_CONNECT: {
        
        BOOL setEvt;
        PPER_USER_ENTRY PerUserEntry = NULL;

        DavPrint((DEBUG_MISC, 
                  "DavAsyncCommonStates: Entering DAV_CALLBACK_INTERNET_CONNECT.\n"));

        //
        // We need to now do somethings depending on the WorkItemType.
        //
        switch(DavWorkItem->WorkItemType) {
        
        case UserModeCreateSrvCall: {

            //
            // Select the verb to be used.
            //
            HTTPVerb = L"OPTIONS";
        
            ObjectName = L"/";
        }
        break;
        
        case UserModeCreate: {
            
            PerUserEntry = (PPER_USER_ENTRY)DavWorkItem->AsyncCreate.PerUserEntry;
            
            //
            // Select the verb to be used.
            //
            HTTPVerb = L"PROPFIND";
            
            DavWorkItem->AsyncCreate.AsyncCreateState = AsyncCreatePropFind;
            DavWorkItem->DavMinorOperation = DavMinorReadData;
            DavWorkItem->AsyncCreate.DataBuff = NULL;
            DavWorkItem->AsyncCreate.didRead = NULL;
            DavWorkItem->AsyncCreate.Context1 = NULL;
            DavWorkItem->AsyncCreate.Context2 = NULL;

            ObjectName = DavWorkItem->AsyncCreate.RemPathName;
        }
        break;
        
        case UserModeCreateVNetRoot: {
            
            PDAV_USERMODE_CREATE_V_NET_ROOT_REQUEST CreateVNetRootRequest = NULL;

            PerUserEntry = (PPER_USER_ENTRY)DavWorkItem->AsyncCreateVNetRoot.PerUserEntry;
            
            //
            // Get the request buffer from the DavWorkItem.
            //
            CreateVNetRootRequest = &(DavWorkItem->CreateVNetRootRequest);
            
            //
            // Select the verb to be used.
            //
            HTTPVerb = L"PROPFIND";
            
            //
            // The first character is a '\' which has to be stripped.
            //
            ObjectName = &(CreateVNetRootRequest->ShareName[1]);
            DavPrint((DEBUG_MISC, "DavAsyncCommonStates: ObjectName = %ws\n", ObjectName));
        }
        break;

        case UserModeQueryVolumeInformation: {

            PerUserEntry = (PPER_USER_ENTRY)DavWorkItem->AsyncCreate.PerUserEntry;
            //
            // Select the verb to be used.
            //
            HTTPVerb = L"PROPFIND";
            
            //
            // The first character is a '\' which has to be stripped.
            //
            ObjectName = &(DavWorkItem->QueryVolumeInformationRequest.ShareName[1]);
            DavPrint((DEBUG_MISC, "DavAsyncCommonStates: ObjectName = %ws\n", ObjectName));
        }
        break;

        default: {
            WStatus = ERROR_INVALID_PARAMETER;
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncCommonStates: Invalid DavWorkItem->WorkItemType "
                      "= %d.\n", DavWorkItem->WorkItemType));
            goto EXIT_THE_FUNCTION;
        }
        break;

        }

        //
        // If the WorkItem type is UserModeCreateSrvCall, then we don't have
        // a PerUserEntry. In this case, the DavConnHandle is stored in the
        // DavWorkItem structure.
        //
        if ( (DavWorkItem->WorkItemType == UserModeCreate) ||
             (DavWorkItem->WorkItemType == UserModeCreateVNetRoot)||
             (DavWorkItem->WorkItemType == UserModeQueryVolumeInformation)) {
            DavConnHandle = PerUserEntry->DavConnHandle;
        } else {
            ASSERT(DavWorkItem->WorkItemType == UserModeCreateSrvCall);
            DavConnHandle = DavWorkItem->AsyncCreateSrvCall.DavConnHandle;
        }
        

        if ( (DavWorkItem->WorkItemType == UserModeCreate) ||
             (DavWorkItem->WorkItemType == UserModeCreateVNetRoot) ) {

            //
            // We are in InternetConnect callback state. We need to cache this Conn
            // handle away in the PerUserEntry of the user which hangs off the 
            // server hash entry. We need to take a lock on the table before doing
            // this.
            //
            EnterCriticalSection( &(HashServerEntryTableLock) );

            //
            // Since the handle was created successfully, we store ERROR_SUCCESS
            // in the status field of the PerUserEntry.
            //
            PerUserEntry->ErrorStatus = ERROR_SUCCESS;

            
            DavPrint((DEBUG_MISC,
                      "DavAsyncCommonStates: PerUserEntry->DavConnHandle = "
                      "%08lx.\n", PerUserEntry->DavConnHandle));

            //
            // Set the state of the user entry to initialized.
            //
            PerUserEntry->UserEntryState = UserEntryInitialized;

            //
            // Signal the event of the user entry to wake up the threads which 
            // might be waiting for this to happen.
            //
            setEvt = SetEvent(PerUserEntry->UserEventHandle);
            if (!setEvt) {
                WStatus = GetLastError();
                DavPrint((DEBUG_ERRORS,
                          "DavAsyncCommonStates/SetEvent. Error Val = %d.\n", 
                          WStatus));
                LeaveCriticalSection( &(HashServerEntryTableLock) );
                goto EXIT_THE_FUNCTION;
            }

            //
            // This was acquired above.
            //
            LeaveCriticalSection( &(HashServerEntryTableLock) );

        }

        //
        // The next async operation is http open.
        //
        DavWorkItem->DavOperation = DAV_CALLBACK_HTTP_OPEN;
        
        //
        // Convert the unicode object name to a UTF-8 URL format.
        // Space and other white characters will remain untouched - these should
        // be taken care of by wininet calls.
        //
        BStatus = DavHttpOpenRequestW(DavConnHandle,
                                      (LPWSTR)HTTPVerb,
                                      (LPWSTR)ObjectName,
                                      L"HTTP/1.1",
                                      NULL,
                                      NULL,
                                      INTERNET_FLAG_KEEP_CONNECTION |
                                      INTERNET_FLAG_NO_COOKIES |
                                      INTERNET_FLAG_NO_CACHE_WRITE |
                                      INTERNET_FLAG_RESYNCHRONIZE,
                                      CallBackContext,
                                      L"DavAsyncCommonStates",
                                      &DavOpenHandle);
        if(BStatus == FALSE) {
            WStatus = GetLastError();
            goto EXIT_THE_FUNCTION;
        }
        
        if (DavOpenHandle == NULL) {
            WStatus = GetLastError();
            if (WStatus != ERROR_IO_PENDING) {
                DavPrint((DEBUG_ERRORS,
                          "DavAsyncCommonStates/HttpOpenRequest. Error Val = %d\n", 
                          WStatus));
            }
            goto EXIT_THE_FUNCTION;
        }
   }
   //
   // Lack of break is intentional.
   //

    case DAV_CALLBACK_HTTP_OPEN: {
        
        DavPrint((DEBUG_MISC, 
                  "DavAsyncCommonStates: Entering DAV_CALLBACK_HTTP_OPEN.\n"));
        
        //
        // Get the handle from http open. If DavOpenHandle is NULL, it means 
        // that either the async request HttpOpenRequestW returned ERROR_IO_PENDING
        // and that the handle will be stored in DavWorkItem->pAsyncResult->
        // dwResult (implies CalledByCallBackThread == TRUE) or that the function
        // that called this function cached it in the DavWorkItm structure.
        //
        
        switch(DavWorkItem->WorkItemType) {
        
        case UserModeCreateSrvCall: {

            if (DavOpenHandle == NULL) {

                //
                // HttpOpen handle was cached away in the DavWorkItem by the
                // function that called this function.
                //

                DavOpenHandle = DavWorkItem->AsyncCreateSrvCall.DavOpenHandle;

            } else {

                //
                // We need to cache the DavOpenHandle in the DavWorkItem.
                //

                DavWorkItem->AsyncCreateSrvCall.DavOpenHandle = DavOpenHandle;

            }

        }
        break;

        case UserModeCreateVNetRoot: {

            if (DavOpenHandle == NULL) {

                //
                // HttpOpen handle was cached away in the DavWorkItem by the
                // function that called this function.
                //

                DavOpenHandle = DavWorkItem->AsyncCreateVNetRoot.DavOpenHandle;

            } else {

                //
                // We need to cache the DavOpenHandle in the DavWorkItem.
                //

                DavWorkItem->AsyncCreateVNetRoot.DavOpenHandle = DavOpenHandle;

            }

            //
            // Since all that we need is information about this share, set the 
            // depth header to 0. This way the PROPFIND that we send will get 
            // back the properties of just this share.
            //
            ReturnVal = HttpAddRequestHeadersW(DavOpenHandle,
                                               L"Depth: 0\n",
                                               -1L,
                                               HTTP_ADDREQ_FLAG_ADD |
                                               HTTP_ADDREQ_FLAG_REPLACE );
            if (!ReturnVal) {
                WStatus = GetLastError();
                DavPrint((DEBUG_ERRORS,
                          "DavAsyncCommonStates/HttpAddRequestHeadersW. "
                          "Error Val = %d\n", WStatus));
                goto EXIT_THE_FUNCTION;
            }

        }
        break;

        case UserModeCreate: {
            
            if (DavOpenHandle == NULL) {

                //
                // HttpOpen handle was cached away in the DavWorkItem by the
                // function that called this function.
                //

                DavOpenHandle = DavWorkItem->AsyncCreate.DavOpenHandle;

            } else {

                //
                // We need to cache the DavOpenHandle in the DavWorkItem.
                //

                DavWorkItem->AsyncCreate.DavOpenHandle = DavOpenHandle;

            }

            //
            // If this is a PROPFIND, set the depth header to 0. This matters
            // when the open is being done for a directory. We only need the 
            // properties of the directory and not the files it contains.
            //
            if (DavWorkItem->AsyncCreate.AsyncCreateState == AsyncCreatePropFind ||
                DavWorkItem->AsyncCreate.AsyncCreateState == AsyncCreateQueryParentDirectory) {
                
                PDAV_USERMODE_CREATE_REQUEST CreateRequest = &(DavWorkItem->CreateRequest);
                
                if (DavWorkItem->AsyncCreate.AsyncCreateState == AsyncCreatePropFind &&
                    CreateRequest->CreateOptions & FILE_DIRECTORY_FILE &&
                    (CreateRequest->CreateOptions & FILE_DELETE_ON_CLOSE ||
                     CreateRequest->DesiredAccess & DELETE)) {
                    ReturnVal = HttpAddRequestHeadersW(DavOpenHandle,
                                                       L"Depth: 1\n",
                                                       -1L,
                                                       HTTP_ADDREQ_FLAG_ADD |
                                                       HTTP_ADDREQ_FLAG_REPLACE );
                    if (!ReturnVal) {
                        WStatus = GetLastError();
                        DavPrint((DEBUG_ERRORS,
                                  "DavAsyncCommonStates/HttpAddRequestHeadersW. "
                                  "Error Val = %d\n", WStatus));
                        goto EXIT_THE_FUNCTION;
                    }
                } else {
                    ReturnVal = HttpAddRequestHeadersW(DavOpenHandle,
                                                       L"Depth: 0\n",
                                                       -1L,
                                                       HTTP_ADDREQ_FLAG_ADD |
                                                       HTTP_ADDREQ_FLAG_REPLACE );
                    if (!ReturnVal) {
                        WStatus = GetLastError();
                        DavPrint((DEBUG_ERRORS,
                                  "DavAsyncCommonStates/HttpAddRequestHeadersW. "
                                  "Error Val = %d\n", WStatus));
                        goto EXIT_THE_FUNCTION;
                    }
                }
            
            }
        
        }
        break;

        case UserModeQueryDirectory: {
            
            if (DavOpenHandle == NULL) {

                //
                // HttpOpen handle was cached away in the DavWorkItem by the
                // function that called this function.
                //

                DavOpenHandle = DavWorkItem->AsyncQueryDirectoryCall.DavOpenHandle;

            } else {

                //
                // We need to cache the DavOpenHandle in the DavWorkItem.
                //

                DavWorkItem->AsyncQueryDirectoryCall.DavOpenHandle = DavOpenHandle;

            }

            if (DavWorkItem->AsyncQueryDirectoryCall.NoWildCards) {
            
                //
                // If there are no wild cards, we have a filename and we set
                // the depth to 0.
                //

                ReturnVal = HttpAddRequestHeadersW(DavOpenHandle,
                                                   L"Depth: 0\n",
                                                   -1L,
                                                   HTTP_ADDREQ_FLAG_ADD |
                                                   HTTP_ADDREQ_FLAG_REPLACE );
                if (!ReturnVal) {
                    WStatus = GetLastError();
                    DavPrint((DEBUG_ERRORS,
                              "DavAsyncCommonStates/HttpAddRequestHeadersW. "
                              "Error Val = %d\n", WStatus));
                    goto EXIT_THE_FUNCTION;
                }

            } else {
            
                //
                // On a QueryDirectory, we do a PROPFIND on the directory. Since we
                // only need to get the properties of files within the first level
                // of the directory, we set the depth header of the request to 1. 
                //
                ReturnVal = HttpAddRequestHeadersW(DavOpenHandle,
                                                   L"Depth: 1\n",
                                                   -1L,
                                                   HTTP_ADDREQ_FLAG_ADD |
                                                   HTTP_ADDREQ_FLAG_REPLACE );
                if (!ReturnVal) {
                    WStatus = GetLastError();
                    DavPrint((DEBUG_ERRORS,
                              "DavAsyncCommonStates/HttpAddRequestHeadersW. "
                              "Error Val = %d\n", WStatus));
                    goto EXIT_THE_FUNCTION;
                }

            }
        
        }
        break;

        case UserModeQueryVolumeInformation: {

            //
            // Since all that we need is information about this share, set the 
            // depth header to 0. This way the PROPFIND that we send will get 
            // back the properties of just this share.
            //
            ReturnVal = HttpAddRequestHeadersW(DavOpenHandle,
                                               L"Depth: 0\n",
                                               -1L,
                                               HTTP_ADDREQ_FLAG_ADD |
                                               HTTP_ADDREQ_FLAG_REPLACE );
            if (!ReturnVal) {
                WStatus = GetLastError();
                DavPrint((DEBUG_ERRORS,
                          "DavAsyncCommonStates/HttpAddRequestHeadersW. "
                          "Error Val = %d\n", WStatus));
                goto EXIT_THE_FUNCTION;
            }

            DavWorkItem->AsyncQueryVolumeInformation.DavOpenHandle = DavOpenHandle;
        
        }
        break;
        
        case UserModeReName: {

            PDAV_USERMODE_RENAME_REQUEST DavReNameRequest = NULL;

            if (DavOpenHandle == NULL) {

                //
                // HttpOpen handle was cached away in the DavWorkItem by the
                // function that called this function.
                //

                DavOpenHandle = DavWorkItem->AsyncReName.DavOpenHandle;

            } else {

                //
                // We need to cache the DavOpenHandle in the DavWorkItem.
                //

                DavWorkItem->AsyncReName.DavOpenHandle = DavOpenHandle;

            }

            DavPrint((DEBUG_MISC,
                      "DavAsyncCommonStates: Rename!! HeaderBuff: %ws\n",
                      DavWorkItem->AsyncReName.HeaderBuff));

            //
            // We are doing a "MOVE" and hence we need to set the DAV header
            // "Destination:". This has to be the URI of the new file.
            //
            ReturnVal = HttpAddRequestHeadersW(DavOpenHandle,
                                               DavWorkItem->AsyncReName.HeaderBuff,
                                               -1L,
                                               HTTP_ADDREQ_FLAG_ADD |
                                               HTTP_ADDREQ_FLAG_REPLACE );
            if (!ReturnVal) {
                WStatus = GetLastError();
                DavPrint((DEBUG_ERRORS,
                          "DavAsyncCommonStates/HttpAddRequestHeadersW. "
                          "Error Val = %d\n", WStatus));
                goto EXIT_THE_FUNCTION;
            }

            //
            // Get the request buffer pointer from the DavWorkItem.
            //
            DavReNameRequest = &(DavWorkItem->ReNameRequest);

            DavPrint((DEBUG_MISC,
                      "DavAsyncCommonStates: Rename!! ReplaceIfExists: %d\n",
                      DavReNameRequest->ReplaceIfExists));

            //
            // We need to set the Overwrite header in this MOVE request. This
            // determines what is done if the destination file already exists.
            // If the ReplaceIfExists is set to TRUE, then we set the Overwrite
            // header to T (TRUE) else F (FALSE).
            //
            if (DavReNameRequest->ReplaceIfExists) {
                ReturnVal = HttpAddRequestHeadersW(DavOpenHandle,
                                                   L"Overwrite: T",
                                                   -1L,
                                                   HTTP_ADDREQ_FLAG_ADD |
                                                   HTTP_ADDREQ_FLAG_REPLACE );
                if (!ReturnVal) {
                    WStatus = GetLastError();
                    DavPrint((DEBUG_ERRORS,
                              "DavAsyncCommonStates/HttpAddRequestHeadersW. "
                              "Error Val = %d\n", WStatus));
                    goto EXIT_THE_FUNCTION;
                }
            } else {
                ReturnVal = HttpAddRequestHeadersW(DavOpenHandle,
                                                   L"Overwrite: F",
                                                   -1L,
                                                   HTTP_ADDREQ_FLAG_ADD |
                                                   HTTP_ADDREQ_FLAG_REPLACE );
                if (!ReturnVal) {
                    WStatus = GetLastError();
                    DavPrint((DEBUG_ERRORS,
                              "DavAsyncCommonStates/HttpAddRequestHeadersW. "
                              "Error Val = %d\n", WStatus));
                    goto EXIT_THE_FUNCTION;
                }
            }

            //
            // If OpaqueLockToken is non-NULL, then we need to add this header
            // to the request being sent out.
            //
            if (DavReNameRequest->OpaqueLockToken != NULL) {
                ReturnVal = HttpAddRequestHeadersW(DavOpenHandle,
                                                   DavReNameRequest->OpaqueLockToken,
                                                   -1L,
                                                   HTTP_ADDREQ_FLAG_ADD |
                                                   HTTP_ADDREQ_FLAG_REPLACE );
                if (!ReturnVal) {
                    WStatus = GetLastError();
                    DavPrint((DEBUG_ERRORS,
                              "DavAsyncCommonStates/HttpAddRequestHeadersW. "
                              "Error Val = %d\n", WStatus));
                    goto EXIT_THE_FUNCTION;
                }
            }

        }
        break;

        case UserModeClose: {

            PDAV_USERMODE_CLOSE_REQUEST CloseRequest = &(DavWorkItem->CloseRequest);

            if (DavOpenHandle == NULL) {

                //
                // HttpOpen handle was cached away in the DavWorkItem by the
                // function that called this function.
                //

                DavOpenHandle = DavWorkItem->AsyncClose.DavOpenHandle;

            } else {

                //
                // We need to cache the DavOpenHandle in the DavWorkItem.
                //

                DavWorkItem->AsyncClose.DavOpenHandle = DavOpenHandle;

            }

            if (DavWorkItem->AsyncClose.DataBuff != NULL) {

                ASSERT(DavWorkItem->DavMinorOperation == DavMinorPutFile);

                if (DavWorkItem->AsyncClose.InternetBuffers == NULL) {
            
                    InternetBuffers = LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT,
                                                  sizeof(INTERNET_BUFFERS) );
                    if (InternetBuffers == NULL) {
                        WStatus = GetLastError();
                        DavPrint((DEBUG_ERRORS,
                                  "DavAsyncCommonStates/LocalAlloc. Error Val = %d\n",
                                  WStatus));
                        goto EXIT_THE_FUNCTION;
                    }

                    DavWorkItem->AsyncClose.InternetBuffers = InternetBuffers;

                    InternetBuffers->dwStructSize = sizeof(INTERNET_BUFFERS);
                    InternetBuffers->Next = NULL;
                    InternetBuffers->lpcszHeader = NULL;
                    InternetBuffers->dwHeadersLength = 0;
                    InternetBuffers->dwBufferTotal = 0;
                    InternetBuffers->lpvBuffer = DavWorkItem->AsyncClose.DataBuff;
                    InternetBuffers->dwBufferLength = (DWORD)DavWorkItem->AsyncClose.DataBuffSizeInBytes;
                    InternetBuffers->dwBufferTotal = 0;
                    InternetBuffers->dwOffsetLow = 0;
                    InternetBuffers->dwOffsetHigh = 0;
                
                } else {

                    InternetBuffers = DavWorkItem->AsyncClose.InternetBuffers;

                }
            
            } else {

                DavWorkItem->AsyncClose.InternetBuffers = NULL;

            }

            //
            // If OpaqueLockToken is non-NULL, then we need to add this header
            // to the request being sent out.
            //
            if (CloseRequest->OpaqueLockToken != NULL) {
                ReturnVal = HttpAddRequestHeadersW(DavOpenHandle,
                                                   CloseRequest->OpaqueLockToken,
                                                   -1L,
                                                   HTTP_ADDREQ_FLAG_ADD |
                                                   HTTP_ADDREQ_FLAG_REPLACE );
                if (!ReturnVal) {
                    WStatus = GetLastError();
                    DavPrint((DEBUG_ERRORS,
                              "DavAsyncCommonStates/HttpAddRequestHeadersW. "
                              "Error Val = %d\n", WStatus));
                    goto EXIT_THE_FUNCTION;
                }
            }

        }
        break;

        default: {
            WStatus = ERROR_INVALID_PARAMETER;
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncCommonStates: Invalid DavWorkItem->WorkItemType "
                      "= %d.\n", DavWorkItem->WorkItemType));
            goto EXIT_THE_FUNCTION;
        }
        break;

        }
        
        DavPrint((DEBUG_MISC,
                  "DavAsyncCommonStates: DavOpenHandle = %08lx.\n", DavOpenHandle));
        
        //
        // In case of UserModeCreateSrvCall, we don't have a passport cookie yet.
        //
        if (DavWorkItem->WorkItemType != UserModeCreateSrvCall) {
            WStatus = DavAttachPassportCookie(DavWorkItem, DavOpenHandle, &PassportCookie);
            if (WStatus != ERROR_SUCCESS) {
                goto EXIT_THE_FUNCTION;
            }
        }

        //
        // We need to add the header "translate:f" to tell IIS that it should 
        // allow the user to excecute this VERB on the specified path which it 
        // would not allow (in some cases) otherwise. Finally, there is a special 
        // flag in the metabase to allow for uploading of "dangerous" content 
        // (anything that can be run on the server). This is the ScriptSourceAccess
        // flag in the UI or the AccessSource flag in the metabase. You will need
        // to set this bit to true as well as correct NT ACLs in order to be able
        // to upload .exes or anything executable.
        //
        ReturnVal = HttpAddRequestHeadersW(DavOpenHandle,
                                           L"translate: f\n",
                                           -1L,
                                           HTTP_ADDREQ_FLAG_ADD |
                                           HTTP_ADDREQ_FLAG_REPLACE );
        if (!ReturnVal) {
            WStatus = GetLastError();
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncCommonStates/HttpAddRequestHeadersW. "
                      "Error Val = %d\n", WStatus));
            goto EXIT_THE_FUNCTION;
        }

        WStatus = DavInternetSetOption(DavWorkItem, DavOpenHandle);
        if (WStatus != ERROR_SUCCESS) {
            goto EXIT_THE_FUNCTION;
        }

        //
        // Need to change the DavOperation field before submitting another
        // asynchronous request. The next async operation is http send.
        //
        DavWorkItem->DavOperation = DAV_CALLBACK_HTTP_SEND;

        //
        // We need the following symbol if we are using WinInet synchronously.
        //

RESEND_THE_REQUEST:
        
        //
        // Send the request to the server.
        //
        ReturnVal = HttpSendRequestExW(DavOpenHandle, 
                                       InternetBuffers, 
                                       NULL, 
                                       SendEndRequestFlags,
                                       CallBackContext);
        if (!ReturnVal) {
            WStatus = GetLastError();
            if (WStatus != ERROR_IO_PENDING) {
                DavPrint((DEBUG_ERRORS,
                          "DavAsyncCommonStates/HttpSendRequest. Error Val = %d\n", 
                          WStatus));
            } 
            goto EXIT_THE_FUNCTION;
        }
    
    }
    //
    // Lack of break is intentional.
    //

    case DAV_CALLBACK_HTTP_SEND: {
        
        DavPrint((DEBUG_MISC, 
                  "DavAsyncCommonStates: Entering DAV_CALLBACK_HTTP_SEND.\n"));
    
        switch(DavWorkItem->WorkItemType) {
        
        case UserModeCreateSrvCall: {
            DavOpenHandle = DavWorkItem->AsyncCreateSrvCall.DavOpenHandle;
        }
        break;

        case UserModeCreateVNetRoot: {
            DavOpenHandle = DavWorkItem->AsyncCreateVNetRoot.DavOpenHandle;
        }
            break;

        case UserModeCreate: {
            DavOpenHandle = DavWorkItem->AsyncCreate.DavOpenHandle;
        }
            break;

        case UserModeQueryDirectory: {
            DavOpenHandle = DavWorkItem->AsyncQueryDirectoryCall.DavOpenHandle;
        }
            break;
        case UserModeQueryVolumeInformation: {
            DavOpenHandle = DavWorkItem->AsyncQueryVolumeInformation.DavOpenHandle;
        }
            break;

        case UserModeReName: {
            DavOpenHandle = DavWorkItem->AsyncReName.DavOpenHandle;
        }
            break;

        case UserModeClose: {
            DavOpenHandle = DavWorkItem->AsyncClose.DavOpenHandle;
        }
            break;

        default: {
            WStatus = ERROR_INVALID_PARAMETER;
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncCommonStates: Invalid DavWorkItem->WorkItemType "
                      "= %d.\n", DavWorkItem->WorkItemType));
            goto EXIT_THE_FUNCTION;
        }
            break;
        
        }

        //
        // Need to change the DavOperation field before submitting another
        // asynchronous request. The next operation is http end.
        //
        DavWorkItem->DavOperation = DAV_CALLBACK_HTTP_END;


        //
        // Issue the End request once send request completes.
        //
        ReturnVal = HttpEndRequestW(DavOpenHandle, 
                                    NULL, 
                                    SendEndRequestFlags,
                                    CallBackContext);
        if (!ReturnVal) {

            WStatus = GetLastError();

            //
            // If the error we got back is ERROR_INTERNET_FORCE_RETRY, then WinInet
            // is trying to authenticate itself with the server. If we get back
            // ERROR_HTTP_REDIRECT_NEEDS_CONFIRMATION, WinInet is expecting us to
            // confirm that the redirect needs to be followed. In these scenarios,
            // we need to repeat the HttpSend and HttpEnd request calls.
            //
            if (WStatus == ERROR_INTERNET_FORCE_RETRY || WStatus == ERROR_HTTP_REDIRECT_NEEDS_CONFIRMATION) {
                goto RESEND_THE_REQUEST;
            }

            DavPrint((DEBUG_ERRORS,
                      "DavAsyncCommonStates/HttpEndRequestW. Error Val = %d\n",
                      WStatus));

            goto EXIT_THE_FUNCTION;

        } else {

            PWCHAR Cookie = NULL;

            DavQueryPassportCookie(DavOpenHandle,&Cookie);

            if (Cookie) {
                DavPrint((DEBUG_MISC,
                         "Passport Cookie saved for PUE %x\n",DavWorkItem->ServerUserEntry.PerUserEntry));
                //
                // Set or renew passport cookie
                //
                EnterCriticalSection(&DavPassportLock);
                
                if (DavWorkItem->ServerUserEntry.PerUserEntry) {
                    if (DavWorkItem->ServerUserEntry.PerUserEntry->Cookie) {
                        LocalFree(DavWorkItem->ServerUserEntry.PerUserEntry->Cookie);
                    }

                    DavWorkItem->ServerUserEntry.PerUserEntry->Cookie = Cookie;
                }
                
                LeaveCriticalSection(&DavPassportLock);
            }
        
        }


        //
        // Now we need to call the Async routines that handle WorkItemType
        // specific things.
        //
        switch(DavWorkItem->WorkItemType) {
        
        case UserModeCreateSrvCall: {
            WStatus = DavAsyncCreateSrvCall(DavWorkItem, CalledByCallBackThread);
            if (WStatus != ERROR_SUCCESS && WStatus != ERROR_IO_PENDING) {
                DavPrint((DEBUG_ERRORS, 
                          "DavAsyncCommonStates/DavAsyncCreateSrvCall. WStatus = "
                          "%08lx.\n", WStatus));
            }
            if (didImpersonate) {
                RevertToSelf();
            }
            return WStatus;
        }
            break;
        
        case UserModeCreateVNetRoot: {
            WStatus = DavAsyncCreateVNetRoot(DavWorkItem, CalledByCallBackThread);
            if (WStatus != ERROR_SUCCESS && WStatus != ERROR_IO_PENDING) {
                DavPrint((DEBUG_ERRORS, 
                          "DavAsyncCommonStates/DavAsyncCreateVNetRoot. WStatus = "
                          "%08lx.\n", WStatus));
            }
            if (didImpersonate) {
                RevertToSelf();
            }
            return WStatus;
        }
            break;
        
        case UserModeCreate: {
            WStatus = DavAsyncCreate(DavWorkItem, CalledByCallBackThread);
            if (WStatus != ERROR_SUCCESS && 
                WStatus != ERROR_IO_PENDING &&
                WStatus != ERROR_FILE_NOT_FOUND) {
                DavPrint((DEBUG_ERRORS, 
                          "DavAsyncCommonStates/DavAsyncCreate. WStatus = "
                          "%08lx.\n", WStatus));
            }
            if (didImpersonate) {
                RevertToSelf();
            }
            return WStatus;
        }
            break;
        
        case UserModeQueryDirectory: {
            WStatus = DavAsyncQueryDirectory(DavWorkItem, CalledByCallBackThread);
            if (WStatus != ERROR_SUCCESS && 
                WStatus != ERROR_IO_PENDING &&
                WStatus != ERROR_FILE_NOT_FOUND) {
                DavPrint((DEBUG_ERRORS, 
                          "DavAsyncCommonStates/DavAsyncQueryDirectory. WStatus = "
                          "%08lx.\n", WStatus));
            }
            if (didImpersonate) {
                RevertToSelf();
            }
            return WStatus;
        }
            break;
        case UserModeQueryVolumeInformation: {
            WStatus = DavAsyncQueryVolumeInformation(DavWorkItem, CalledByCallBackThread);
            if (WStatus != ERROR_SUCCESS && 
                WStatus != ERROR_IO_PENDING) {
                DavPrint((DEBUG_ERRORS, 
                          "DavAsyncCommonStates/DavAsyncQueryVolumeInformation. WStatus = "
                          "%08lx.\n", WStatus));
            }
            if (didImpersonate) {
                RevertToSelf();
            }
            return WStatus;
        }
            break;
        
        case UserModeReName: {
            WStatus = DavAsyncReName(DavWorkItem, CalledByCallBackThread);
            if (WStatus != ERROR_SUCCESS && WStatus != ERROR_IO_PENDING) {
                DavPrint((DEBUG_ERRORS, 
                          "DavAsyncCommonStates/DavAsyncReName. WStatus = %08lx.\n", 
                          WStatus));
            }
            if (didImpersonate) {
                RevertToSelf();
            }
            return WStatus;
        }
            break;
        
        case UserModeClose: {
            WStatus = DavAsyncClose(DavWorkItem, CalledByCallBackThread);
            if (WStatus != ERROR_SUCCESS && WStatus != ERROR_IO_PENDING) {
                DavPrint((DEBUG_ERRORS, 
                          "DavAsyncCommonStates/DavAsyncClose. WStatus = %08lx.\n", 
                          WStatus));
            }
            if (didImpersonate) {
                RevertToSelf();
            }
            return WStatus;
        }
            break;
        
        default: {
            WStatus = ERROR_INVALID_PARAMETER;
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncCommonStates: Invalid DavWorkItem->WorkItemType "
                      "= %d.\n", DavWorkItem->WorkItemType));
        }
            break;
        
        }
    
    }
        break;

    default: {
        WStatus = ERROR_INVALID_PARAMETER;
        DavPrint((DEBUG_ERRORS,
                  "DavAsyncCommonStates: Invalid DavWorkItem->DavOperation = %d.\n",
                  DavWorkItem->DavOperation));
    }
        break;
    
    } // End of switch.

EXIT_THE_FUNCTION:
    //
    // If we did impersonate, we need to revert back.
    //
    if (didImpersonate) {
        ULONG RStatus;
        RStatus = UMReflectorRevert(UserWorkItem);
        if (RStatus != ERROR_SUCCESS) {
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncCommonStates/UMReflectorRevert. Error Val = %d\n", 
                      RStatus));
        }   
    }

    if (PassportCookie) {
        LocalFree(PassportCookie);
    }


    //
    // If we are using WinInet synchronously, then we should never get back
    // ERROR_IO_PENDING from WinInet.
    //
    ASSERT(WStatus != ERROR_IO_PENDING);

    return WStatus;
}
    

ULONG
DavFsSetTheDavCallBackContext(
    IN OUT PDAV_USERMODE_WORKITEM DavWorkItem
    )
/*++

Routine Description:

   This routine sets the callback context to be sent in subsequent asynchronous
   request.

Arguments:

    DavWorkItem - The work item that came down from the kernel. This is also
                   used as the callbackcontext.

Return Value:

    ERROR_SUCCESS or the appropriate error value.

--*/
{
    BOOL ReturnVal;
    ULONG WStatus = ERROR_SUCCESS;

    //
    // Make the handles invalid to begin with.
    //
    DavWorkItem->ImpersonationHandle = INVALID_HANDLE_VALUE;
        
    //
    // Get the handle used to impersonate this thread.
    //
    ReturnVal = OpenThreadToken(GetCurrentThread(),
                                TOKEN_IMPERSONATE | TOKEN_QUERY | TOKEN_DUPLICATE,
                                FALSE,
                                &(DavWorkItem->ImpersonationHandle));
    if (!ReturnVal) {
        DavWorkItem->ImpersonationHandle = INVALID_HANDLE_VALUE;
        WStatus = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavFsSetTheDavCallBackContext/OpenThreadToken. Operation = %d"
                  ", Error Val = %d\n", DavWorkItem->WorkItemType, WStatus));
    }
    
    return WStatus;
}


VOID
DavFsFinalizeTheDavCallBackContext(
    IN PDAV_USERMODE_WORKITEM DavWorkItem
    )
/*++

Routine Description:

   This routine finalizes the callback context which was used for some 
   asynchronous request. This basically amounts to freeing up any resources
   that were acquired by the context. Its called when the request associated 
   with this context completes.

Arguments:

    DavWorkItem - The context structure to be set.
    
Return Value:

    ERROR_SUCCESS or the appropriate error value.

--*/
{
    BOOL ReturnVal;
    ULONG WStatus;

    //
    // If the Impersonation handle was initialized, close it.
    //
    if (DavWorkItem->ImpersonationHandle != INVALID_HANDLE_VALUE) {
        ReturnVal = CloseHandle(DavWorkItem->ImpersonationHandle);
        if (!ReturnVal) {
            WStatus = GetLastError();
            DavPrint((DEBUG_ERRORS,
                      "ERROR: DavFsFinalizeTheDavCallBackContext/CloseHandle."
                      "(Impersonation) Error Val = %d.\n", WStatus));
        }
    }

    return;
}


BOOL
DavDoesUserEntryExist(
    IN PWCHAR ServerName,
    IN ULONG ServerID,
    IN PLUID LogonID,
    OUT PPER_USER_ENTRY *PerUserEntry,
    OUT PHASH_SERVER_ENTRY *ServerHashEntry
    )
/*++

Routine Description:

    This routine searches for a per user entry in the list of per user entries
    of a server entry in the hash table. Note that the caller should take a
    lock on the ServerHashTable before calling this routine.

Arguments:

    ServerName - The server name whose per user entries should be searched.
    
    ServerID - The unique ID associated with this server. This ID is generated
               during the CreateSrvCall stage.
    
    LogonID - The LogonID of the user/session to be searched.
    
    PerUserEntry - The PerUserEntry of this user which hangs of the server.
    
    ServerHashEntry - The ServerHashEntry for this server. This is used to add 
                      the new user entry to its list if an entry for this user
                      does not exist.

Return Value:

    TRUE - The entry was found and FALSE otherwise.

--*/
{
    BOOL ReturnVal = FALSE;
    BOOL isPresent = FALSE;
    ULONG ServerHashID;
    PLIST_ENTRY listServerEntry, listUserEntry;
    PHASH_SERVER_ENTRY HashEntry = NULL;
    PPER_USER_ENTRY UsrEntry = NULL;
    
    //
    // IMPORTANT!!!! The caller should take a lock on the global ServerHashTable 
    // before calling this routine.
    //

    ASSERT(ServerName != NULL);

    DavPrint((DEBUG_MISC, "DavDoesUserEntryExist: ServerName: %ws, ServerID: "
              "%d.\n", ServerName, ServerID));
    
    //
    // Finally, get the hash ID and insert this new entry into the global server 
    // entry hash table.
    //
    ServerHashID = DavHashTheServerName(ServerName);
    ASSERT(ServerHashID != SERVER_TABLE_SIZE);

    //
    // Search the hash table at this index to see if an entry for this server
    // exists.
    //
    listServerEntry = ServerHashTable[ServerHashID].Flink;
    while ( listServerEntry != &(ServerHashTable[ServerHashID]) ) {
        //
        // Get the pointer to the HASH_SERVER_ENTRY structure.
        //
        HashEntry = CONTAINING_RECORD(listServerEntry,
                                      HASH_SERVER_ENTRY,
                                      ServerListEntry);
        //
        // Check to see if this entry is for the server in question.
        //
        if ( ServerID == HashEntry->ServerID ) {
            //
            // If the ID's match, the server names should match.
            //
            ASSERT( wcscmp(ServerName, HashEntry->ServerName) == 0 );
            isPresent = TRUE;
            DavPrint((DEBUG_MISC, "DavDoesUserEntryExist: ServerName: %ws found"
                      ".\n", ServerName));
            break;
        }
        listServerEntry = listServerEntry->Flink;
    }

    //
    // If the ServerHashEntry does not exist, then return FALSE;
    //
    if (!isPresent) {
        DavPrint((DEBUG_MISC, 
                  "DavDoesUserEntryExist: ServerHashEntry not found. %ws\n",
                  ServerName));
        *ServerHashEntry = NULL;
        *PerUserEntry = NULL;
        return (isPresent);
    }
    
    //
    // Return the ServerHashEntry. This will be used to add the new user
    // entry to the user list of this server.
    //
    *ServerHashEntry = HashEntry;
    DavPrint((DEBUG_MISC, "DavDoesUserEntryExist: ServerHashEntry = %08lx\n", 
              HashEntry));
    
    //
    // Now, search the "per user entries" that hang off this server entry to 
    // see if an entry for this user exists.
    //
    listUserEntry = HashEntry->PerUserEntry.Flink;
    while ( listUserEntry !=  &(HashEntry->PerUserEntry) ) {
        //
        // Get the pointer to the HASH_SERVER_ENTRY structure.
        //
        UsrEntry = CONTAINING_RECORD(listUserEntry,
                                     PER_USER_ENTRY,
                                     UserEntry);
        //
        // Check to see if this entry is for the user in question. We do this 
        // by comparing the LogonID values.
        //
        if ( (UsrEntry->LogonID.LowPart == LogonID->LowPart) &&
             (UsrEntry->LogonID.HighPart == LogonID->HighPart) ) {
            DavPrint((DEBUG_MISC, "DavDoesUserEntryExist: User found.\n"));
            ReturnVal = TRUE;
            break;
        }
        listUserEntry = listUserEntry->Flink;
    }

    if (!ReturnVal) {
        DavPrint((DEBUG_MISC, "DavDoesUserEntryExist: User not found.\n"));
        *PerUserEntry = NULL;
        return (ReturnVal);
    }

    //
    // Since the server has been found, return the PerUserEntry.
    //
    *PerUserEntry = UsrEntry;
    DavPrint((DEBUG_MISC, "DavDoesUserEntryExist: UsrEntry = %08lx\n", UsrEntry));

    return (ReturnVal);
}


BOOL
DavFinalizePerUserEntry(
    PPER_USER_ENTRY *PUE
    )
/*++

Routine Description:

    This routine decrements the reference count of the user entry by one. If 
    the count reduces to zero, the entry is freed.

Arguments:

    PUE - The per user entry to be finalized.

Return Value:

    TRUE - The user entry was finalized (freed).
    
    FALSE - Was not since the ref count was > 0.

--*/
{
    PPER_USER_ENTRY PerUserEntry = *PUE;
    BOOL retVal = TRUE;

    DavPrint((DEBUG_MISC,
              "DavFinalizePerUserEntry: Finalizing PerUserEntry: %08lx.\n",
              PerUserEntry));
    
    DavPrint((DEBUG_MISC,
              "DavFinalizePerUserEntry: UserEntryRefCount = %d, LogonId.LowPart = %d,"
              " LogonId.HighPart = %d\n", PerUserEntry->UserEntryRefCount,
              PerUserEntry->LogonID.LowPart, PerUserEntry->LogonID.HighPart));

    //
    // Before we modify the reference count, we need to take a lock.
    //
    EnterCriticalSection( &(HashServerEntryTableLock) );

    PerUserEntry->UserEntryRefCount--;

    //
    // If we had the last reference, we need to do the following :
    // 1. Remove the entry from the servers list.
    // 2. Close any open handles stored or cached in the entry.
    // 3. Free the cookie, if we allocated one for Passport Auth and,
    // 4. Free the entry.
    //
    if (PerUserEntry->UserEntryRefCount == 0) {
        
        HLOCAL FreeHandle;
        ULONG FreeStatus;
        BOOL CloseStatus;
        PHASH_SERVER_ENTRY ServerHashEntry = NULL;

        DavPrint((DEBUG_MISC,
                  "DavFinalizePerUserEntry: Finalized!!! LogonId.LowPart = %d, LogonId.HighPart = %d\n",
                  PerUserEntry->LogonID.LowPart, PerUserEntry->LogonID.HighPart));

        ServerHashEntry = PerUserEntry->ServerHashEntry;

        //
        // Remove the entry from the servers list.
        //
        RemoveEntryList( &(PerUserEntry->UserEntry) );

        //
        // When this PerUserEntry was created, we took a reference on the
        // ServerHashEntry. We need to remove it now. Also, if the reference
        // on the ServerHashEntry goes to 0, we need to put it in the list of
        // "ToBeFinalized" ServerHashEntries.
        //
        ServerHashEntry->ServerEntryRefCount -= 1;

        if (ServerHashEntry->ServerEntryRefCount == 0) {

            ServerHashEntry->TimeValueInSec = time(NULL);

            //
            // Now move this server entry from the hash table to the
            // "to be finalized" list.
            //
            RemoveEntryList( &(ServerHashEntry->ServerListEntry) );
            InsertHeadList( &(ToBeFinalizedServerEntries),
                                             &(ServerHashEntry->ServerListEntry) );

        }

        //
        // If we created the event handle, we need to close it now.
        //
        if (PerUserEntry->UserEventHandle != NULL) {
            CloseStatus = CloseHandle(PerUserEntry->UserEventHandle);
            if (!CloseStatus) {
                FreeStatus = GetLastError();
                DavPrint((DEBUG_ERRORS,
                          "DavFinalizePerUserEntry/CloseHandle. Error Val ="
                          " %d.\n", FreeStatus));
            }
        }
        
        //
        // If we created the DavConnHandle, we need to close it now.
        //
        if (PerUserEntry->DavConnHandle != NULL) {
            CloseStatus = InternetCloseHandle(PerUserEntry->DavConnHandle);
            if (!CloseStatus) {
                FreeStatus = GetLastError();
                DavPrint((DEBUG_ERRORS,
                          "DavFinalizePerUserEntry/InternetCloseHandle. "
                          "Error Val = %d.\n", FreeStatus));
            }
        }

        //
        // If we allocated memory for storing the cookies, we need to free it.
        //
        if (PerUserEntry->Cookie) {
            SecureZeroMemory(PerUserEntry->Cookie, ((wcslen(PerUserEntry->Cookie) + 1) * sizeof(WCHAR)));
            LocalFree(PerUserEntry->Cookie);
            PerUserEntry->Cookie = NULL;
        }

        if (PerUserEntry->UserName) {
            LocalFree(PerUserEntry->UserName);
            PerUserEntry->UserName = NULL;
        }

        if (PerUserEntry->Password) {
            SecureZeroMemory(PerUserEntry->Password, PerUserEntry->BlockSizeInBytes);
            LocalFree(PerUserEntry->Password);
            PerUserEntry->Password = NULL;
        }

        //
        // Finally, free the entry.
        //
        FreeHandle = LocalFree((HLOCAL)PerUserEntry);
        if (FreeHandle != NULL) {
            FreeStatus = GetLastError();
            DavPrint((DEBUG_ERRORS,
                      "DavFinalizePerUserEntry/LocalFree. Error Val = %d.\n",
                      FreeStatus));
        }

        //
        // Set the entry to NULL. Just in case !!!
        //
        *PUE = NULL;

    } else {

        DavPrint((DEBUG_MISC,
                  "DavFinalizePerUserEntry: Did not finalize %08lx. RefCount "
                  "= %d\n", PerUserEntry, PerUserEntry->UserEntryRefCount));

        retVal = FALSE;

    }

    //
    // Free the lock before leaving.
    //
    LeaveCriticalSection( &(HashServerEntryTableLock) );

    return retVal;
}


DWORD
SetupRpcServer(
    VOID
    )
/*++

Routine Description:

    This routine sets up the RPC server of the WebClient service.

Arguments:

    none.

Return Value:

    A Win32 error code.

--*/
{
    RPC_STATUS rpcErr;
    RPC_BINDING_VECTOR *BindingVector = NULL;

    rpcErr = RpcServerRegisterIf(davclntrpc_ServerIfHandle, NULL, NULL);
    if (rpcErr != RPC_S_OK) {
        DavPrint((DEBUG_ERRORS,
                  "SetupRpcServer/RpcServerRegisterIf: rpcErr = %08lx\n",
                  rpcErr));
        goto EXIT_THE_FUNCTION;
    }

    rpcErr = RpcServerUseProtseqW(L"ncalrpc",
                                  RPC_C_PROTSEQ_MAX_REQS_DEFAULT,
                                  NULL);
    if (rpcErr != RPC_S_OK) {
        DavPrint((DEBUG_ERRORS,
                  "SetupRpcServer/RpcServerUseProtseqEp: rpcErr = %08lx\n",
                  rpcErr));
        goto EXIT_THE_FUNCTION;
    }

    rpcErr = RpcServerInqBindings( &(BindingVector) );
    if (rpcErr != RPC_S_OK) {
        DavPrint((DEBUG_ERRORS,
                  "SetupRpcServer/RpcServerInqBindings: rpcErr = %08lx\n",
                  rpcErr));
        goto EXIT_THE_FUNCTION;
    }
    
    rpcErr = RpcEpRegister(davclntrpc_ServerIfHandle,
                           BindingVector,
                           NULL,
                           L"DAV RPC SERVICE");
    if (rpcErr != RPC_S_OK) {
        DavPrint((DEBUG_ERRORS,
                  "SetupRpcServer/RpcEpRegister: rpcErr = %08lx\n",
                  rpcErr));
        goto EXIT_THE_FUNCTION;
    }
    
    rpcErr = RpcServerListen(1, RPC_C_LISTEN_MAX_CALLS_DEFAULT, TRUE);
    if (rpcErr != RPC_S_OK) {
        DavPrint((DEBUG_ERRORS,
                  "SetupRpcServer/RpcServerListen: rpcErr = %08lx\n", rpcErr));
    }

EXIT_THE_FUNCTION:

    if (BindingVector) {
        RpcBindingVectorFree( &(BindingVector) );
    }

    //
    // Luckily for us, RPC errors simply map into the Win32 error space.
    // If that ever changes, we need to make the mapping a bit more complex.
    //
    return (DWORD) rpcErr;
}


DWORD
StopRpcServer(
    VOID
    )
/*++

Routine Description:

    This routine stops the RPC server of the WebClient service.

Arguments:

    none.

Return Value:

    A Win32 error code.

--*/
{
    RPC_STATUS rpcErr;

    rpcErr = RpcMgmtStopServerListening(NULL);

    if (rpcErr != RPC_S_OK) {
        DavPrint((DEBUG_RPC,
                  "WebClient received err 0x%x during "
                  "RpcMgmtStopServerListening.\n", rpcErr));
    }

    rpcErr = RpcServerUnregisterIf(davclntrpc_ServerIfHandle, 0, TRUE);

    if (rpcErr != RPC_S_OK) {
        DavPrint((DEBUG_RPC,
                  "WebClient received err 0x%x during RpcServerUnregisterIf.\n",
                  rpcErr));
    }

    return (DWORD) rpcErr;
}


ULONG
DavQueryAndParseResponse(
    HINTERNET DavOpenHandle
    )
/*++

Routine Description:

    This function calls DavQueryAndParseResponseEx to map the Http/Dav response
    to the Win32 error code.

Arguments:

    DavOpenHandle - The handle created by HttpOpenRequest on which the request
                    was sent.

Return Value:

    A Win32 error code.

--*/
{
    ULONG WStatus = ERROR_SUCCESS;
    WStatus = DavQueryAndParseResponseEx(DavOpenHandle, NULL);
    return WStatus;
}


ULONG
DavQueryAndParseResponseEx(
    IN HINTERNET DavOpenHandle,
    OUT PULONG HttpResponseStatus OPTIONAL
    )
/*++

Routine Description:

    This function queries the response header for the status value returned 
    from the server. It then maps the status to a Win32 error code and returns
    it to the caller. We added this function becuase some callers may be
    interested in special casing some of the Http/Dav responses. Before this we
    just had the DavQueryAndParseResponse function.

Arguments:

    DavOpenHandle - The handle created by HttpOpenRequest on which the request
                    was sent.
                    
    HttpResponseStatus - If this is non NULL, then the response status returned
                         by the server is filled in it. Some callers of this
                         function might need it to special case some of the 
                         Http/Dav responses.                

Return Value:

    A Win32 error code.

--*/
{
    ULONG WStatus = ERROR_SUCCESS;
    DWORD ResponseStatus = 0;
    DWORD ResponseSize = 0;
    BOOL ReturnVal = FALSE;

    //
    // Query the header for the servers response status.
    //
    ResponseSize = sizeof(ResponseStatus);
    ReturnVal = HttpQueryInfoW(DavOpenHandle,
                               HTTP_QUERY_STATUS_CODE | HTTP_QUERY_FLAG_NUMBER,
                               &(ResponseStatus),
                               &(ResponseSize),
                               NULL);
    if ( !ReturnVal ) {
        WStatus = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavQueryAndParseResponseEx/HttpQueryInfoW: Error Val = %d\n", 
                  WStatus));
        goto EXIT_THE_FUNCTION;
    }

    //
    // If the caller is interested in the Http/Dav response status, we return
    // it.
    //
    if (HttpResponseStatus) {
        *HttpResponseStatus = ResponseStatus;
    }

    //
    // Map the Http response status code to the appropriate Http error.
    //
    WStatus = DavMapHttpErrorToDosError(ResponseStatus);
    if (WStatus != ERROR_SUCCESS &&
        WStatus != ERROR_FILE_NOT_FOUND) {
        DavPrint((DEBUG_ERRORS,
                  "DavQueryAndParseResponseEx/DavMapHttpErrorToDosError: WStatus = %d"
                  ", ResponseStatus = %d\n", WStatus, ResponseStatus));
    }
    
EXIT_THE_FUNCTION:

    return WStatus;
}


ULONG
DavMapHttpErrorToDosError(
    ULONG HttpResponseStatus
    )
/*++

Routine Description:

    This function maps the response status returned by the Http/Dav server to 
    the corresponding Win32 error code.

Arguments:

    HttpResponseStatus - The http status that has to be mapped to the Win32
                         error code.

Return Value:

    A Win32 error code.

--*/
{
    //
    // Map the HTTP response to the corresponding Win32 error. These will 
    // finally get mapped to an NTSTATUS value before the request is sent down 
    // to the kernel.
    //
    switch (HttpResponseStatus) {

    //
    // 100 OK to continue with request.
    //
    case HTTP_STATUS_CONTINUE:
        return ERROR_SUCCESS; // STATUS_SUCCESS;

    //
    // 101 server has switched protocols in upgrade header.
    //
    case HTTP_STATUS_SWITCH_PROTOCOLS:
        return ERROR_IO_DEVICE; // STATUS_DEVICE_PROTOCOL_ERROR;

    //
    // 200 Request completed.
    // 201 Object created, reason = new URI.
    // 202 Async completion (TBS).
    // 203 Partial completion.
    // 204 No info to return.
    // 205 Request completed, but clear form.
    // 206 Partial GET furfilled.
    // 207 Multi status response.
    //
    case HTTP_STATUS_OK:
    case HTTP_STATUS_CREATED:
    case HTTP_STATUS_ACCEPTED:
    case HTTP_STATUS_PARTIAL:
    case HTTP_STATUS_NO_CONTENT:
    case HTTP_STATUS_RESET_CONTENT:
    case HTTP_STATUS_PARTIAL_CONTENT:
    case DAV_MULTI_STATUS:
        return ERROR_SUCCESS; // STATUS_SUCCESS;

    //
    // 300 Server couldn't decide what to return.
    //
    case HTTP_STATUS_AMBIGUOUS:
        return ERROR_GEN_FAILURE; // STATUS_UNSUCCESSFUL;

    //
    // 301 Object permanently moved.
    //
    case HTTP_STATUS_MOVED:
        return ERROR_FILE_NOT_FOUND; // STATUS_OBJECT_NAME_NOT_FOUND;

    //
    // 302 Object temporarily moved.
    //
    case HTTP_STATUS_REDIRECT:
        return ERROR_FILE_NOT_FOUND; // STATUS_OBJECT_NAME_NOT_FOUND;

    //
    // 303 Redirection w/new access method.
    //
    case HTTP_STATUS_REDIRECT_METHOD:         
        return ERROR_FILE_NOT_FOUND; // STATUS_OBJECT_NAME_NOT_FOUND;

    //
    // 304 If-modified-since was not modified.
    //
    case HTTP_STATUS_NOT_MODIFIED:            
        return ERROR_SUCCESS; // STATUS_SUCCESS;

    //
    // 305 Redirection to proxy, location header specifies proxy to use.
    //
    case HTTP_STATUS_USE_PROXY:               
        return ERROR_HOST_UNREACHABLE; // STATUS_HOST_UNREACHABLE;

    //
    // 307 HTTP/1.1: keep same verb.
    //
    case HTTP_STATUS_REDIRECT_KEEP_VERB:      
        return ERROR_SUCCESS; // STATUS_SUCCESS;

    //
    // 400 Invalid syntax.
    //
    case HTTP_STATUS_BAD_REQUEST:
        return ERROR_INVALID_PARAMETER; // STATUS_INVALID_PARAMETER;

    //
    // 401 Access denied.
    //
    case HTTP_STATUS_DENIED:
        return ERROR_ACCESS_DENIED; // STATUS_ACCESS_DENIED;

    //
    // 402 Payment required.
    //
    case HTTP_STATUS_PAYMENT_REQ:
        return ERROR_ACCESS_DENIED; // STATUS_ACCESS_DENIED;

    //
    // 403 Request forbidden.
    //
    case HTTP_STATUS_FORBIDDEN:
        return ERROR_ACCESS_DENIED; // STATUS_ACCESS_DENIED;

    //
    // 404 Object not found.
    //
    case HTTP_STATUS_NOT_FOUND:
        return ERROR_FILE_NOT_FOUND; // STATUS_OBJECT_NAME_NOT_FOUND;

    //
    // 405 Method is not allowed.
    //
    case HTTP_STATUS_BAD_METHOD:
        return ERROR_ACCESS_DENIED; // STATUS_ACCESS_DENIED;

    //
    // 406 No response acceptable to client found.
    //
    case HTTP_STATUS_NONE_ACCEPTABLE:
        return ERROR_ACCESS_DENIED; // STATUS_ACCESS_DENIED;

    //
    // 407 Proxy authentication required.
    //
    case HTTP_STATUS_PROXY_AUTH_REQ:
        return ERROR_ACCESS_DENIED; // STATUS_ACCESS_DENIED;

    //
    // 408 Server timed out waiting for request.
    //
    case HTTP_STATUS_REQUEST_TIMEOUT:
        return ERROR_SEM_TIMEOUT; // STATUS_IO_TIMEOUT;

    //
    // 409 User should resubmit with more info.
    //
    case HTTP_STATUS_CONFLICT:
        return ERROR_INVALID_PARAMETER; // STATUS_INVALID_PARAMETER;

    //
    // 410 The resource is no longer available.
    //
    case HTTP_STATUS_GONE:
        return ERROR_FILE_NOT_FOUND; // STATUS_OBJECT_NAME_NOT_FOUND;

    //
    // 411 The server refused to accept request w/o a length.
    //
    case HTTP_STATUS_LENGTH_REQUIRED:
        return ERROR_INVALID_PARAMETER; // STATUS_INVALID_PARAMETER;

    //
    // 412 Precondition given in request failed.
    //
    case HTTP_STATUS_PRECOND_FAILED:
        return ERROR_INVALID_PARAMETER; // STATUS_INVALID_PARAMETER;

    //
    // 413 Request entity was too large.
    //
    case HTTP_STATUS_REQUEST_TOO_LARGE:
        return ERROR_INVALID_PARAMETER; // STATUS_INVALID_PARAMETER;

    //
    // 414 Request URI too long.
    //
    case HTTP_STATUS_URI_TOO_LONG:
        return ERROR_INVALID_PARAMETER; // STATUS_INVALID_PARAMETER;

    //
    // 415 Unsupported media type.
    //
    case HTTP_STATUS_UNSUPPORTED_MEDIA:
        return ERROR_INVALID_PARAMETER; // STATUS_INVALID_PARAMETER;

    //
    // 449 Retry after doing the appropriate action.
    //
    case HTTP_STATUS_RETRY_WITH:
        return ERROR_RETRY; // STATUS_RETRY;

    //
    // 500 Internal server error.
    //
    case HTTP_STATUS_SERVER_ERROR:
        return ERROR_GEN_FAILURE; // STATUS_UNSUCCESSFUL;

    //
    // 501 Required not supported.
    //
    case HTTP_STATUS_NOT_SUPPORTED:
        return ERROR_NOT_SUPPORTED; // STATUS_NOT_SUPPORTED;

    //
    // 502 Error response received from gateway.
    //
    case HTTP_STATUS_BAD_GATEWAY:
        return ERROR_HOST_UNREACHABLE; // STATUS_HOST_UNREACHABLE;

    //
    // 503 Temporarily overloaded.
    //
    case HTTP_STATUS_SERVICE_UNAVAIL:
        return ERROR_GEN_FAILURE; // STATUS_UNSUCCESSFUL;

    //
    // 504 Timed out waiting for gateway.
    //
    case HTTP_STATUS_GATEWAY_TIMEOUT:
        return ERROR_HOST_UNREACHABLE; // STATUS_HOST_UNREACHABLE;

    //
    // 505 HTTP version not supported.
    //
    case HTTP_STATUS_VERSION_NOT_SUP:
        return ERROR_NOT_SUPPORTED; // STATUS_NOT_SUPPORTED;

    //
    // WebDav specific status codes.
    //

    //
    // 507.
    //
    case DAV_STATUS_INSUFFICIENT_STORAGE:
        return ERROR_NOT_ENOUGH_QUOTA; // STATUS_QUOTA_EXCEEDED;

    //
    // 422.
    //
    case DAV_STATUS_UNPROCESSABLE_ENTITY:
        return ERROR_INVALID_PARAMETER; // STATUS_INVALID_PARAMETER;

    //
    // 423.
    //
    case DAV_STATUS_LOCKED:
        return ERROR_ACCESS_DENIED; //STATUS_ACCESS_DENIED;

    //
    // 424.
    //
    case DAV_STATUS_FAILED_DEPENDENCY:
        return ERROR_INVALID_PARAMETER; // STATUS_INVALID_PARAMETER;

    //
    // This is not a valid Http error code. We return this back to the caller.
    //
    default:
        DavPrint((DEBUG_ERRORS,
                  "DavMapHttpErrorToDosError: Invalid!!! HttpResponseStatus = %d\n", 
                  HttpResponseStatus));
        return HttpResponseStatus;

    }
}


VOID
DavDumpHttpResponseHeader(
    HINTERNET OpenHandle
    )
/*++

Routine Description:

    This function dumps the response header that came back from the server.

Arguments:

    OpenHandle - The HttpOpenRequest handle on which the request was sent.

Return Value:

    None.

--*/
{
    ULONG WStatus = ERROR_SUCCESS;
    BOOL IntRes;
    PWCHAR DataBuff = NULL;
    DWORD intLen = 0;

    IntRes = HttpQueryInfoW(OpenHandle,
                            HTTP_QUERY_RAW_HEADERS_CRLF,
                            DataBuff,
                            &intLen,
                            NULL);
    if ( !IntRes ) {
         WStatus = GetLastError();
         if (WStatus != ERROR_INSUFFICIENT_BUFFER) {
             DavPrint((DEBUG_ERRORS, 
                       "DavDumpHttpResponseHeader/HttpQueryInfoW: Error Val = "
                       "%d\n", WStatus));
             goto EXIT_THE_FUNCTION;
         }
    }
        
    DataBuff = (PWCHAR) LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, intLen);
    if (DataBuff == NULL) {
        WStatus = GetLastError();
        DavPrint((DEBUG_ERRORS, 
                  "DavDumpHttpResponseHeader/LocalAlloc: Error Val = %d\n", 
                  WStatus));
        goto EXIT_THE_FUNCTION;
    }

    IntRes = HttpQueryInfoW(OpenHandle,
                            HTTP_QUERY_RAW_HEADERS_CRLF,
                            DataBuff,
                            &intLen,
                            NULL);
    if ( !IntRes ) {
         WStatus = GetLastError();
         DavPrint((DEBUG_ERRORS, 
                   "DavDumpHttpResponseHeader/HttpQueryInfoW: Error Val = "
                   "%d\n", WStatus));
         goto EXIT_THE_FUNCTION;
    }

    DavPrint((DEBUG_DEBUG, "DavDumpHttpResponseHeader:\n%ws\n", DataBuff));

EXIT_THE_FUNCTION:

    if (DataBuff) {
        LocalFree(DataBuff);
    }
    
    return;
}


VOID
DavDumpHttpResponseData(
    HINTERNET OpenHandle
    )
/*++

Routine Description:

    This function dumps the response data that came back from the server.

Arguments:

    OpenHandle - The HttpOpenRequest handle on which the request was sent.

Return Value:

    None.

--*/
{
    ULONG WStatus = ERROR_SUCCESS;
    BOOL ReadRes;
    CHAR DataBuff[4096];
    DWORD didRead = 0, TotalDataBytesRead = 0;

    DavPrint((DEBUG_DEBUG, "DavDumpHttpResponseData:\n"));
    
    //
    // Read the Data in a loop and dump it.
    //
    do {

        RtlZeroMemory(DataBuff, 4096);

        ReadRes = InternetReadFile(OpenHandle, (LPVOID)DataBuff, 4096, &didRead);
        if ( !ReadRes ) {
             WStatus = GetLastError();
             DavPrint((DEBUG_ERRORS, 
                       "DavDumpHttpResponseData/InternetReadFile: Error Val = "
                       "%d\n", WStatus));
             goto EXIT_THE_FUNCTION;
        }

        //
        // We reject files whose attributes are greater than a certain size
        // (DavFileAttributesLimitInBytes). This is a parameter that can be
        // set in the registry. This is done to avoid attacks by rogue servers.
        //
        TotalDataBytesRead += didRead;
        if (TotalDataBytesRead > DavFileAttributesLimitInBytes) {
            WStatus = ERROR_BAD_NET_RESP;
            DavPrint((DEBUG_ERRORS, "DavDumpHttpResponseData. FileAttributesSize > %d\n", DavFileAttributesLimitInBytes));
            goto EXIT_THE_FUNCTION;
        }

        if (didRead == 0) {
            break;
        }

        DavPrint((DEBUG_DEBUG, "%s", DataBuff));

    } while (TRUE);

    DavPrint((DEBUG_DEBUG, "\n"));

EXIT_THE_FUNCTION:

    return;
}


VOID
DavRemoveDummyShareFromFileName(
    PWCHAR FileName
    )
/*++

Routine Description:

    This function removes the DAV_DUMMY_SHARE from the FileName. This dummy
    share is added when a user tries to map a drive against http://server. This
    is allowed in DAV but doesn't fit well with the File system semantics. Hence
    a dummy share is added in WNetAddConnection3.

Arguments:

    FileName - The name of the file which has to be checked and modifed if 
               necessary.

Return Value:

    None.

--*/
{
    PWCHAR TempName1, TempName2 = NULL;
    ULONG i;

    TempName1 = wcsstr(FileName, DAV_DUMMY_SHARE);

    if (TempName1) {
        TempName2 = wcschr(TempName1, L'/');
        if (TempName2 != NULL) {
            TempName2++;
            for (i = 0; TempName2[i] != L'\0'; i++) {
                TempName1[i] = TempName2[i];
            }
            TempName1[i] = L'\0';
        } else {
            TempName1[0] = L'\0';
        }
    }

    return;
}


VOID
DavObtainServerProperties(
    PWCHAR DataBuff,
    BOOL *lpfIsHttpServer,
    BOOL *lpfIsIIS,
    BOOL *lpfIsDavServer
    )
/*++

Routine Description:

    This routine is used to parse the response (buffer) to the OPTIONS request 
    sent to server. This info helps to figure out if the HTTP server supports
    DAV extensions and whether it is an IIS (Microsoft's) server. The response
    buffer is split into lines and each line is sent to this routine.

Arguments:

    DataBuff - The Buffer containing the raw http response headers to be parsed.
    
    lpfIsHttpServer - Set to TRUE if this is a http server.
    
    lpfIsIIS - Set to TRUE if this is an IIS server.
    
    lpfIsDavServer - Set to TRUE if this is a DAV server.

Return Value:

    none.

--*/
{
    PWCHAR p, ParseData;

    if (lpfIsHttpServer)
    {
        *lpfIsHttpServer = FALSE;
    }

    if (lpfIsIIS)
    {
        *lpfIsIIS = FALSE;
    }

    if (lpfIsDavServer)
    {
        *lpfIsDavServer = FALSE;
    }

    //
    // Parse the DataBuff here.
    //
    ParseData = wcstok(DataBuff, L"\n");
    
    while (ParseData != NULL) {
    
        if ( ( p = wcsstr(ParseData, L"HTTP/1.1") ) != NULL ) {
            //
            // This is a HTTP server.
            //
            if (lpfIsHttpServer)
            {
                *lpfIsHttpServer = TRUE;
            }
        } else if ( ( p = wcsstr(ParseData, L"Microsoft-IIS") ) != NULL ) {
            //
            // This is a Microsoft IIS server.
            //
            if (lpfIsIIS)
            {
                *lpfIsIIS = TRUE;
            }
        } else if ( ( p = wcsstr(ParseData, L"DAV") ) != NULL ) {
            //
            // This HTTP server supports DAV extensions.
            //
            if (lpfIsDavServer)
            {
                *lpfIsDavServer = TRUE;
            }
        }
        
        ParseData = wcstok(NULL, L"\n");

    }

}


DWORD
DavReportEventInEventLog(
    DWORD EventType,
    DWORD EventId,
    DWORD NumberOfStrings,
    PWCHAR *EventStrings
    )
/*++

Routine Description:

    This routine logs a message in the EventLog under System section.

Arguments:

    EventType - Specifies the type of event being logged.
    
    EventId - Specifies the event. The event identifier specifies the message
              that goes with this event as an entry in the message file
              associated with the event source. 
    
    NumberOfStrings - Specifies the number of strings in the array pointed to by\
                      the EventStrings parameter. A value of zero indicates that
                      no strings are present. 
    
    EventStrings - Pointer to a buffer containing an array of null-terminated
                   strings which get logged in this message.

Return Value:

    ERROR_SUCCESS or the appropriate Win32 Error.    

--*/
{
    ULONG WStatus = ERROR_SUCCESS;
    HANDLE WebClientHandle = NULL;
    BOOL reportEvent = FALSE;

    WebClientHandle = RegisterEventSourceW(NULL, SERVICE_DAVCLIENT);
    if (WebClientHandle == NULL) {
        WStatus = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavReportEventInEventLog/RegisterEventSourceW: Error Val = "
                  "%d\n", WStatus));
        goto EXIT_THE_FUNCTION;
    }

    reportEvent = ReportEventW(WebClientHandle,
                               (WORD)EventType,
                               0,
                               EventId,
                               NULL,
                               (WORD)NumberOfStrings,
                               0,
                               EventStrings,
                               NULL);
    if (!reportEvent) {
        WStatus = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavReportEventInEventLog/ReportEventW: Error Val = %d\n",
                  WStatus));
        goto EXIT_THE_FUNCTION;
    }

EXIT_THE_FUNCTION:

    if (WebClientHandle != NULL) {
        BOOL deRegister;
        deRegister = DeregisterEventSource(WebClientHandle);
        if (!deRegister) {
            DavPrint((DEBUG_ERRORS,
                      "DavReportEventInEventLog/DeregisterEventSource: Error Val = "
                      "%d\n", GetLastError()));
        }
    }

    return WStatus;
}


DWORD
DavFormatAndLogError(
    PDAV_USERMODE_WORKITEM DavWorkItem,
    DWORD Win32Status
    )
/*++

Routine Description:

    This routine formats the Error Message and calls DavReportEventInEventLog
    to log it in the EventLog.

Arguments:

    DavWorkItem - The workitem for the failed request.
    
    Win32Status - The Win32 failure status.

Return Value:

    ERROR_SUCCESS or the appropriate Win32 Error.    

--*/
{
    ULONG WStatus = ERROR_SUCCESS;
    PWCHAR *EventStrings = NULL, TempName = NULL;
    PWCHAR ServerName = NULL, PathName = NULL, CompleteFileName = NULL;
    ULONG StringCount = 0, EventId = 0, SizeInBytes = 0;
    UNICODE_STRING StatusString;

    StatusString.Buffer = NULL;
    StatusString.Length = 0;
    StatusString.MaximumLength = 0;

    switch (DavWorkItem->WorkItemType) {
 
    case UserModeClose: {

        ServerName = DavWorkItem->CloseRequest.ServerName;
        PathName = DavWorkItem->CloseRequest.PathName;

        switch (DavWorkItem->DavMinorOperation) {
        
        case DavMinorPutFile: 
            EventId = EVENT_WEBCLIENT_CLOSE_PUT_FAILED;
            break;

        case DavMinorDeleteFile:
            EventId = EVENT_WEBCLIENT_CLOSE_DELETE_FAILED;
            break;

        case DavMinorProppatchFile:
            EventId = EVENT_WEBCLIENT_CLOSE_PROPPATCH_FAILED;
            break;
        
        default:
            WStatus = ERROR_INVALID_PARAMETER;
            goto EXIT_THE_FUNCTION;

        }

    }
    break;

    case UserModeSetFileInformation: {

        ServerName = DavWorkItem->SetFileInformationRequest.ServerName;
        PathName = DavWorkItem->SetFileInformationRequest.PathName;

        switch (DavWorkItem->DavMinorOperation) {
        
        case DavMinorProppatchFile:
            EventId = EVENT_WEBCLIENT_SETINFO_PROPPATCH_FAILED;
            break;
        
        default:
            WStatus = ERROR_INVALID_PARAMETER;
            goto EXIT_THE_FUNCTION;

        }

    }
    break;

    default:

        WStatus = ERROR_INVALID_PARAMETER;
        goto EXIT_THE_FUNCTION;
    
    }

    //
    // We always log 2 string in this function. One is the status value and the
    // other is the filename.
    //
    StringCount = 2;

    EventStrings = LocalAlloc(LPTR, StringCount * sizeof(PWCHAR));
    if (EventStrings == NULL) {
        WStatus = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavFormatAndLogError/LocalAlloc(1): WStatus = %d\n",
                  WStatus));
        goto EXIT_THE_FUNCTION;
    }

    //
    // Build the complete path name from the server name and the path name.
    //

    //
    // The extra 1 is for the \0 character.
    //
    SizeInBytes = ( (wcslen(ServerName) + wcslen(PathName) + 1) * sizeof(WCHAR) );

    CompleteFileName = LocalAlloc(LPTR, SizeInBytes);
    if (CompleteFileName == NULL) {
        WStatus = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavFormatAndLogError/LocalAlloc(2): WStatus = %d\n",
                  WStatus));
        goto EXIT_THE_FUNCTION;
    }

    wcsncpy( CompleteFileName, ServerName, wcslen(ServerName) );

    TempName = ( CompleteFileName + wcslen(ServerName) );

    wcsncpy( TempName, PathName, wcslen(PathName) );

    CompleteFileName[ ( (SizeInBytes / sizeof(WCHAR)) - 1 ) ] = L'\0';

    //
    // Replace all '/'s with '\'s.
    //
    for (TempName = CompleteFileName; *TempName != L'\0'; TempName++) {
        if (*TempName == L'/') {
            *TempName = L'\\';
        }
    }

    //
    // Build a string out of the WStatus. We assume that the ErrorCode will not
    // be more than 8 digits.
    //
    StatusString.Length = ( 10 * sizeof(WCHAR) );
    StatusString.MaximumLength = ( 10 * sizeof(WCHAR) );
    StatusString.Buffer = LocalAlloc(LPTR, StatusString.Length);
    if (StatusString.Buffer == NULL) {
        WStatus = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavFormatAndLogError/LocalAlloc(3): WStatus = %d\n",
                  WStatus));
        goto EXIT_THE_FUNCTION;
    }

    WStatus = RtlIntegerToUnicodeString(Win32Status, 0, &(StatusString));
    if (WStatus != STATUS_SUCCESS) {
        WStatus = RtlNtStatusToDosError(WStatus);
        DavPrint((DEBUG_ERRORS,
                  "DavFormatAndLogError/RtlIntegerToUnicodeString: WStatus = %d\n",
                  WStatus));
        goto EXIT_THE_FUNCTION;
    }

    DavPrint((DEBUG_MISC,
              "DavFormatAndLogError: CompleteFileName = %ws, ErrorString = %ws\n",
              CompleteFileName, StatusString.Buffer));

    EventStrings[0] = CompleteFileName;
    EventStrings[1] = StatusString.Buffer;

    WStatus = DavReportEventInEventLog(EVENTLOG_WARNING_TYPE,
                                       EventId,
                                       StringCount,
                                       EventStrings);
    if (WStatus != ERROR_SUCCESS) {
        DavPrint((DEBUG_ERRORS,
                  "DavFormatAndLogError/DavReportEventInEventLog: WStatus = %d\n",
                  WStatus));
        goto EXIT_THE_FUNCTION;
    }

EXIT_THE_FUNCTION:

    if (CompleteFileName) {
        LocalFree(CompleteFileName);
        CompleteFileName = NULL;
    }

    if (StatusString.Buffer) {
        LocalFree(StatusString.Buffer);
        StatusString.Buffer = NULL;
        StatusString.Length = 0;
        StatusString.MaximumLength = 0;
    }

    if (EventStrings) {
        LocalFree(EventStrings);
        EventStrings = NULL;
    }

    return WStatus;
}


DWORD
DavAttachPassportCookie(
    PDAV_USERMODE_WORKITEM DavWorkItem,
    HINTERNET DavOpenHandle,
    PWCHAR *PassportCookie
    )
/*++

Routine Description:

   This routine attaches the passport cookie to the Http request header if it
   exists.

Arguments:

    DavWorkItem - The DAV_USERMODE_WORKITEM value.

    DavOpenHandle - The Wininet request handle.

    PassportCookie - The buffer contains the cookie sent to Wininet

Return Value:

    ERROR_SUCCESS or the appropriate error value.

Note:

    The caller of this routine should free the PassportCookie at the end of the
    request.

--*/
{
    ULONG WStatus = ERROR_SUCCESS;
    BOOL ReturnVal;

    EnterCriticalSection(&DavPassportLock);

    if (DavWorkItem->ServerUserEntry.PerUserEntry->Cookie != NULL) {

        *PassportCookie = LocalAlloc((LMEM_FIXED | LMEM_ZEROINIT), 
                                    (wcslen(DavWorkItem->ServerUserEntry.PerUserEntry->Cookie) + 1) * sizeof(WCHAR));
        if (*PassportCookie == NULL) {
            WStatus = GetLastError();
            DavPrint((DEBUG_ERRORS, 
                      "DavAttachPassportCookie/LocalAlloc: Error Val = %d\n", 
                      WStatus));
            LeaveCriticalSection(&DavPassportLock);
            goto EXIT_THE_FUNCTION;
        }

        wcscpy(*PassportCookie, DavWorkItem->ServerUserEntry.PerUserEntry->Cookie);

        LeaveCriticalSection(&DavPassportLock);

        DavPrint((DEBUG_MISC,
                  "DavAttachPassportCookie: %x %d %ws\n", 
                  DavWorkItem->ServerUserEntry.PerUserEntry,
                  wcslen(*PassportCookie)*sizeof(WCHAR),
                  *PassportCookie));

        ReturnVal = HttpAddRequestHeadersW(DavOpenHandle,
                                           *PassportCookie,
                                           -1L,
                                           HTTP_ADDREQ_FLAG_ADD |
                                           HTTP_ADDREQ_FLAG_REPLACE );
        if (!ReturnVal) {
            WStatus = GetLastError();
            DavPrint((DEBUG_ERRORS,
                      "DavAttachPassportCookie/Add Cookie. "
                      "Error Val = %d\n", WStatus));
            goto EXIT_THE_FUNCTION;
        }
    
    } else {

        LeaveCriticalSection(&DavPassportLock);

    }

EXIT_THE_FUNCTION:

    return WStatus;
}


DWORD
DavInternetSetOption(
    PDAV_USERMODE_WORKITEM DavWorkItem,
    HINTERNET DavOpenHandle
    )
/*++

Routine Description:

   This routine set the user name and password to the internet handle.

Arguments:

    DavWorkItem - The DAV_USERMODE_WORKITEM value.
    
    DavOpenHandle - The Wininet request handle.
    
Return Value:

    ERROR_SUCCESS or the appropriate error value.
    
--*/
{
    ULONG WStatus = ERROR_SUCCESS;
    BOOL ReturnVal;

    //
    // In case of UserModeCreateSrvCall, we don't have a PerUserEntry yet.
    //
    if (DavWorkItem->WorkItemType == UserModeCreateSrvCall) {

        if (lstrlenW(DavWorkItem->UserName)) {
            ReturnVal = InternetSetOptionW(DavOpenHandle, 
                               INTERNET_OPTION_USERNAME, 
                               DavWorkItem->UserName, 
                               lstrlenW(DavWorkItem->UserName));
            DavPrint((DEBUG_MISC, 
                      "DavInternetSetOption: UserName = %ws\n",
                      DavWorkItem->UserName));
        } else {
            ReturnVal = InternetSetOptionW(DavOpenHandle,INTERNET_OPTION_USERNAME,L"",1);
        }

        if ( !ReturnVal ) {
            WStatus = GetLastError();
            DavPrint((DEBUG_ERRORS,
                      "DavInternetSetOption(1). Error Val = %d\n", WStatus));
            goto EXIT_THE_FUNCTION;
        }

        if (lstrlenW(DavWorkItem->Password)) {
            ReturnVal = InternetSetOptionW(DavOpenHandle, 
                                           INTERNET_OPTION_PASSWORD, 
                                           DavWorkItem->Password, 
                                           lstrlenW(DavWorkItem->Password));
            DavPrint((DEBUG_MISC,
                      "DavInternetSetOption: Password = %ws\n",
                      DavWorkItem,DavWorkItem->Password));
        } else {
            ReturnVal = InternetSetOptionW(DavOpenHandle,INTERNET_OPTION_PASSWORD,L"",1);
        }

        if ( !ReturnVal ) {
            WStatus = GetLastError();
            DavPrint((DEBUG_ERRORS,
                      "DavInternetSetOption(2). Error Val = %d\n", WStatus));
            goto EXIT_THE_FUNCTION;
        }

    } else {

        if (lstrlenW(DavWorkItem->ServerUserEntry.PerUserEntry->UserName)) {
            ReturnVal = InternetSetOptionW(DavOpenHandle, 
                                           INTERNET_OPTION_USERNAME, 
                                           DavWorkItem->ServerUserEntry.PerUserEntry->UserName, 
                                           lstrlenW(DavWorkItem->ServerUserEntry.PerUserEntry->UserName));
            DavPrint((DEBUG_MISC, 
                      "DavInternetSetOption: UserName = %ws\n",
                      DavWorkItem->ServerUserEntry.PerUserEntry->UserName));
        } else {
            ReturnVal = InternetSetOptionW(DavOpenHandle,INTERNET_OPTION_USERNAME,L"",1);
        }

        if ( !ReturnVal ) {
            WStatus = GetLastError();
            DavPrint((DEBUG_ERRORS,
                      "DavInternetSetOption(3). Error Val = %d\n", WStatus));
            goto EXIT_THE_FUNCTION;
        }

        if (DavWorkItem->ServerUserEntry.PerUserEntry->BlockSizeInBytes) {

            PWCHAR Password = NULL;
            DWORD BlockSizeInBytes = 0;

            BlockSizeInBytes = DavWorkItem->ServerUserEntry.PerUserEntry->BlockSizeInBytes;

            DavPrint((DEBUG_MISC, "DavInternetSetOption: BlockSizeInBytes = %d\n", BlockSizeInBytes));

            Password = LocalAlloc((LMEM_FIXED | LMEM_ZEROINIT), BlockSizeInBytes);
            if (Password == NULL) {
                WStatus = GetLastError();
                DavPrint((DEBUG_ERRORS,
                          "DavInternetSetOption/LocalAlloc. Error Val = %d\n",
                          WStatus));
                goto EXIT_THE_FUNCTION;
            }

            RtlCopyMemory(Password, DavWorkItem->ServerUserEntry.PerUserEntry->Password, BlockSizeInBytes);

            ReturnVal = CryptUnprotectMemory(Password, BlockSizeInBytes, CRYPTPROTECTMEMORY_SAME_PROCESS);
            if (!ReturnVal) {
                WStatus = GetLastError();
                DavPrint((DEBUG_ERRORS,
                          "DavInternetSetOption/CryptUnprotectMemory. Error Val = %d\n",
                          WStatus));
                goto EXIT_THE_FUNCTION;
            }

            DavPrint((DEBUG_MISC,
                      "DavInternetSetOption: EncryptedPassword = %ws, DecryptedPassword = %ws\n",
                      DavWorkItem->ServerUserEntry.PerUserEntry->Password, Password));

            ReturnVal = InternetSetOptionW(DavOpenHandle, 
                                           INTERNET_OPTION_PASSWORD, 
                                           Password, 
                                           lstrlenW(Password));

            SecureZeroMemory(Password, BlockSizeInBytes);

            LocalFree(Password);

        } else {

            ReturnVal = InternetSetOptionW(DavOpenHandle, INTERNET_OPTION_PASSWORD, L"", 1);

        }

        if ( !ReturnVal ) {
            WStatus = GetLastError();
            DavPrint((DEBUG_ERRORS, "DavInternetSetOption(4). Error Val = %d\n", WStatus));
            goto EXIT_THE_FUNCTION;
        }

    }

EXIT_THE_FUNCTION:
    
    return WStatus;
}


ULONG
DavQueryPassportCookie(
    IN HINTERNET RequestHandle,
    IN OUT PWCHAR *Cookie
    )
/*++

Routine Description:

    This function get the Set-Cookie strings from the HTTP response.

Arguments:

    RequestHandle - The handle from HttpOpenRequestW.

    Cookie - The pointer of the buffer that stores the pointer of the cookies

Return Value:

    NO_ERROR - Success or the appropriate Win32 error code.

Notes:

   Here are the exsample of the Set-Cookies on the PROPFIND response from a Tweener server:

   MSPProf=1AAAAAARAHWeNZdbsWxdhaoUAQ0TfwgHdg7f%2A4ShKm5kK%2AhXHJOsOdPyG27%2A8sh7cirwMRoJoIu764HkLE9lZeKQHOxHw5ZaU2Be0I4BNcxKksiv1vgKvc0Dzy7rlZrOGt6W6efmkr8f8%24; domain=.pp.test.microsoft.com; path=/
   MSPAuth=1AAAAAASAHimsAU2%2AhA9F60NUehefWQp%2AqMNG6%2AWP3f4H25EBsGW8Zo1dZGwVG5txt; domain=.pp.test.microsoft.com; path=/
   MSPProfC=; path=/; expires=Tue 1-Jan-1980 12:00:00 GMT;

   We are only interested in part of them:

   MSPProf=1AAAAAARAHWeNZdbsWxdhaoUAQ0TfwgHdg7f%2A4ShKm5kK%2AhXHJOsOdPyG27%2A8sh7cirwMRoJoIu764HkLE9lZeKQHOxHw5ZaU2Be0I4BNcxKksiv1vgKvc0Dzy7rlZrOGt6W6efmkr8f8%24;
   MSPAuth=1AAAAAASAHimsAU2%2AhA9F60NUehefWQp%2AqMNG6%2AWP3f4H25EBsGW8Zo1dZGwVG5txt;
   MSPProfC=;

   This routine allocates a buffer to save the cookie, which should be freed at
   the end of the connection.

--*/
{
    ULONG WStatus = ERROR_SUCCESS;
    BOOL ReturnVal = FALSE;
    PWCHAR SetCookies = NULL;
    DWORD TotalLength = 0;
    DWORD Current = 0;
    WCHAR CustomBuffer[30];
    ULONG CustomBufferLength = 0;
    DWORD Index = 0;

    ASSERT(*Cookie == NULL);

    RtlZeroMemory(CustomBuffer, sizeof(CustomBuffer));

    wcscpy(CustomBuffer, L"Authentication-Info:");

    CustomBufferLength = sizeof(CustomBuffer);

    ReturnVal = HttpQueryInfoW(RequestHandle,
                               HTTP_QUERY_CUSTOM,
                               (PVOID)CustomBuffer,
                               &(CustomBufferLength),
                               &Index);
    
    if ( !ReturnVal ) {
        WStatus = GetLastError();
        if (WStatus != ERROR_INSUFFICIENT_BUFFER) {
            //
            // The reponse with the valid passport cookie should always have the 
            // "Authentication-Info:" included on the header.
            //
            DavPrint((DEBUG_MISC,
                      "DavQuerySetCookie/HttpQueryInfoW(0): WStatus = %d\n",
                      WStatus));
            goto EXIT_THE_FUNCTION;
        }
    }

    RtlZeroMemory(CustomBuffer, sizeof(CustomBuffer));

    wcscpy(CustomBuffer, L"Set-Cookie:");

    Index = 0;

    for ( ; ; ) {

        //
        // Query the size of the each Set-Cookie string.
        //

        CustomBufferLength = sizeof(CustomBuffer);

        ReturnVal = HttpQueryInfoW(RequestHandle,
                                   HTTP_QUERY_CUSTOM,
                                   (PVOID)CustomBuffer,
                                   &(CustomBufferLength),
                                   &Index);
        if ( !ReturnVal ) {
            WStatus = GetLastError();
            if (WStatus != ERROR_INSUFFICIENT_BUFFER) {
                DavPrint((DEBUG_MISC, 
                          "DavQuerySetCookie/HttpQueryInfoW(1): WStatus = %d, "
                          "TotalLength = %d, Index = %d\n",
                          WStatus, TotalLength, Index));
                if (WStatus == ERROR_HTTP_HEADER_NOT_FOUND) {
                    //
                    // No more Set-Cookie strings exist.
                    //
                    break;
                } else {
                    goto EXIT_THE_FUNCTION;
                }
            }
        }

        TotalLength += CustomBufferLength;

        Index++;

        if (Index > 20) {
            break;
        }

    }

    TotalLength += ( (1 + wcslen(L"Cookie: ")) * sizeof(WCHAR) );

    DavPrint((DEBUG_MISC,
              "DavQuerySetCookie: TotalLength = %d, Index = %d\n",
              TotalLength, Index));

    if (TotalLength > 0) {

        SetCookies = LocalAlloc((LMEM_FIXED | LMEM_ZEROINIT), TotalLength);
        if (SetCookies == NULL) {
            WStatus = GetLastError();
            DavPrint((DEBUG_ERRORS, 
                      "DavQuerySetCookie/LocalAlloc: Error Val = %d\n", 
                      WStatus));
            goto EXIT_THE_FUNCTION;
        }

        RtlZeroMemory(SetCookies, TotalLength);

        wcscpy(SetCookies, L"Cookie: ");

        Current = wcslen(L"Cookie: ") * sizeof(WCHAR);

        Index = 0;

        for ( ; ; ) {

            ULONG i = 0;

            //
            // Save the Set-Cookie strings to a single buffer.
            //

            wcscpy(&SetCookies[Current/sizeof(WCHAR)], L"Set-Cookie:");
            CustomBufferLength = TotalLength - Current;

            //
            // A successful call to HttpQueryInfoW will increment the Index.
            //
            ReturnVal = HttpQueryInfoW(RequestHandle,
                                       HTTP_QUERY_CUSTOM,
                                       (PVOID)(&SetCookies[Current/sizeof(WCHAR)]),
                                       &(CustomBufferLength),
                                       &(Index));
            if ( !ReturnVal ) {
                WStatus = GetLastError();
                DavPrint((DEBUG_ERRORS, 
                          "DavQuerySetCookie/HttpQueryInfoW(2): Error Val = %d\n", 
                          WStatus));
                if (WStatus != ERROR_HTTP_HEADER_NOT_FOUND) {
                    goto EXIT_THE_FUNCTION;
                } else {
                    break;
                }
            }

            for (i = Current; i < (Current + CustomBufferLength); i += sizeof(WCHAR)) {
                if (SetCookies[ i / sizeof(WCHAR) ] == L' ') {
                    i += sizeof(WCHAR);
                    break;
                }
            }

            //
            // Only interested in the first string of the set-cookie.
            //
            Current = i;
            RtlZeroMemory( &SetCookies[ i / sizeof(WCHAR) ], (TotalLength - i) );

            DavPrint((DEBUG_MISC,
                      "DavQuerySetCookie: Current = %d, CustomBufferLength = %d, "
                      "Index = %d, SetCookies = %ws\n",
                      Current, CustomBufferLength, Index, SetCookies));

            if (Index > 20) {
                break;
            }
        }

        //
        // Get rid of the last "Set-Cookie:" used for HttpQueryInfoW.
        //
        RtlZeroMemory( &SetCookies[ Current / sizeof(WCHAR) ], (TotalLength-Current) );
        *Cookie = SetCookies;

        WStatus = ERROR_SUCCESS;  

    }

EXIT_THE_FUNCTION:

    if ((WStatus != ERROR_SUCCESS) && (SetCookies != NULL)) {
        LocalFree(SetCookies);
    }

    return WStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\server\dllmain.c ===
/*++

Copyright (c) 1991-1999  Microsoft Corporation

Module Name:

    dllmain.c

Abstract:

    This is the dll entry point for the web dav mini redir service dll.

Author:

    Andy Herron (andyhe) 29-Mar-1999

Environment:

    User Mode - Win32

Revision History:

--*/
#include "pch.h"
#pragma hdrstop

#include <ntumrefl.h>
#include <usrmddav.h>
#include "global.h"


//+---------------------------------------------------------------------------
// DLL Entry Point
//
// DllMain should do as little work as possible.
//
BOOL
WINAPI
DllMain (
    HINSTANCE   hinst,
    DWORD       dwReason,
    LPVOID      pvReserved
    )
{
    if (DLL_PROCESS_ATTACH == dwReason) {

        InitializeCriticalSection (&g_DavServiceLock);

        // Save our instance handle in a global variable to be used
        // when loading resources etc.
        //
        g_hinst = hinst;

        // DisableThreadLibraryCalls tells the loader we don't need to
        // be informed of DLL_THREAD_ATTACH and DLL_THREAD_DETACH events.
        //
        DisableThreadLibraryCalls (hinst);

    } else if (DLL_PROCESS_DETACH == dwReason) {

        DeleteCriticalSection (&g_DavServiceLock);
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\server\debug.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    debug.c

Abstract:

    This file contains debugging macros for the webdav client.

Author:

    Andy Herron (andyhe)  30-Mar-1999

Environment:

    User Mode - Win32

Revision History:


--*/

#include "pch.h"
#pragma hdrstop

#include <stdio.h>
#include <ntumrefl.h>
#include <usrmddav.h>
#include "global.h"


#if DBG

VOID
DavOpenDebugFile(
    IN BOOL ReopenFlag
    );

HLOCAL
DebugMemoryAdd(
    HLOCAL hglobal,
    LPCSTR pszFile,
    UINT uLine,
    LPCSTR pszModule,
    UINT uFlags,
    DWORD dwBytes,
    LPCSTR pszComment
    );

VOID
DebugMemoryDelete(
    HLOCAL hlocal
    );

#endif // DBG


#if DBG

VOID
DebugInitialize(
    VOID
    )
/*++

Routine Description:

    This routine initializes the DAV debug environment. Its called by the init
    function ServiveMain().

Arguments:

    none.

Return Value:

    none.

--*/
{
    DWORD dwErr;
    HKEY KeyHandle;

    //
    // We enclose the call to InitializeCriticalSection in a try-except block
    // because its possible for it to raise a  STATUS_NO_MEMORY exception.
    //
    try {
        InitializeCriticalSection( &(g_TraceMemoryCS) );
        InitializeCriticalSection( &(DavGlobalDebugFileCritSect) );
    } except(EXCEPTION_EXECUTE_HANDLER) {
          dwErr = GetExceptionCode();
          DbgPrint("%ld: ERROR: DebugInitialize/InitializeCriticalSection: "
                   "Exception Code = %08lx.\n", GetCurrentThreadId(), dwErr);
          return;
    }

    //
    // These are used in persistent logging. They define the file handle of the
    // file to which the debug o/p is written, the max file size and the path
    // of the file.
    //
    DavGlobalDebugFileHandle = NULL;
    DavGlobalDebugFileMaxSize = DEFAULT_MAXIMUM_DEBUGFILE_SIZE;
    DavGlobalDebugSharePath = NULL;

    //
    // Read DebugFlags value from the registry. If the entry exists, the global
    // filter "DavGlobalDebugFlag" is set to this value. This value is used in
    // filtering the debug messages.
    //
    dwErr = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                         DAV_PARAMETERS_KEY,
                         0,
                         KEY_QUERY_VALUE,
                         &(KeyHandle));
    if (dwErr == ERROR_SUCCESS) {
        //
        // Read the value into DavGlobalDebugFlag.
        //
        DavGlobalDebugFlag = ReadDWord(KeyHandle, DAV_DEBUG_KEY, 0);
        RegCloseKey(KeyHandle);
    }

    //
    // Break in the debugger if we are asked to do so.
    //
    if(DavGlobalDebugFlag & DEBUG_STARTUP_BRK) {
        DavPrint((DEBUG_INIT,
                  "DebugInitialize: Stopping at DebugBreak().\n" ));
        DebugBreak();
    }

    //
    // If we want to do persistent logging, open the debug log file.
    //
    if ( DavGlobalDebugFlag & DEBUG_LOG_IN_FILE ) {
        DavOpenDebugFile( FALSE );
    }

    return;
}


VOID
DebugUninitialize (
    VOID
    )
/*++

Routine Description:

    This routine uninitializes the DAV debug environment. It basically frees up
    the resources that were allocated for debugging/logging during debug
    initialization.

Arguments:

    none.

Return Value:

    none.

--*/
{
    EnterCriticalSection( &(DavGlobalDebugFileCritSect) );

    if ( DavGlobalDebugFileHandle != NULL ) {
        CloseHandle( DavGlobalDebugFileHandle );
        DavGlobalDebugFileHandle = NULL;
    }
    if( DavGlobalDebugSharePath != NULL ) {
        DavFreeMemory( DavGlobalDebugSharePath );
        DavGlobalDebugSharePath = NULL;
    }

    LeaveCriticalSection( &(DavGlobalDebugFileCritSect) );

    DeleteCriticalSection( &(DavGlobalDebugFileCritSect) );

    DeleteCriticalSection( &(g_TraceMemoryCS) );

    return;
}


VOID
DavOpenDebugFile(
    IN BOOL ReopenFlag
    )
/*++

Routine Description:

    Opens or re-opens the debug file. This file is used in persistent logging.

Arguments:

    ReopenFlag - TRUE to indicate the debug file is to be closed, renamed,
                 and recreated.

Return Value:

    None.

--*/
{
    WCHAR LogFileName[500];
    WCHAR BakFileName[500];
    DWORD FileAttributes;
    DWORD PathLength;
    DWORD WinError;

    //
    // Close the handle to the debug file, if it is currently open.
    //
    EnterCriticalSection( &(DavGlobalDebugFileCritSect) );
    if ( DavGlobalDebugFileHandle != NULL ) {
        CloseHandle( DavGlobalDebugFileHandle );
        DavGlobalDebugFileHandle = NULL;
    }
    LeaveCriticalSection( &(DavGlobalDebugFileCritSect) );

    //
    // Create the debug directory path first, if it is not made before.
    //
    if( DavGlobalDebugSharePath == NULL ) {

        UINT Val, LogFileSize;
        ULONG LogFileNameSizeInBytes;

        LogFileSize = ( sizeof(LogFileName)/sizeof(WCHAR) );
        Val = GetWindowsDirectoryW(LogFileName, LogFileSize);
        if ( Val == 0 ) {
            DavPrint((DEBUG_ERRORS,
                      "DavOpenDebugFile: Window Directory Path can't be "
                      "retrieved, %d.\n", GetLastError() ));
            goto ErrorReturn;
        }

        //
        // Check debug path length. The filename buffer needs to be of a
        // minimum size.
        //
        PathLength = (wcslen(LogFileName) * sizeof(WCHAR)) + sizeof(DEBUG_DIR)
                                            + sizeof(WCHAR);

        if( ( PathLength + sizeof(DEBUG_FILE) > sizeof(LogFileName) )  ||
            ( PathLength + sizeof(DEBUG_BAK_FILE) > sizeof(BakFileName) ) ) {
            DavPrint((DEBUG_ERRORS,
                      "DavOpenDebugFile: Debug directory path (%ws) length is "
                      "too long.\n", LogFileName));
            goto ErrorReturn;
        }

        wcscat(LogFileName, DEBUG_DIR);

        //
        // Copy debug directory name to global var.
        //
        LogFileNameSizeInBytes = ( (wcslen(LogFileName) + 1) * sizeof(WCHAR) );

        //
        // We need to make the LogFileNameSizeInBytes a multiple of 8. This is
        // because DavAllocateMemory calls DebugAlloc which does some stuff which
        // requires this. The equation below does this.
        //
        LogFileNameSizeInBytes = ( ( ( LogFileNameSizeInBytes + 7 ) / 8 ) * 8 );


        DavGlobalDebugSharePath = DavAllocateMemory( LogFileNameSizeInBytes );
        if( DavGlobalDebugSharePath == NULL ) {
            DavPrint((DEBUG_ERRORS,
                      "DavOpenDebugFile: Can't allocated memory for debug share"
                                    "(%ws).\n", LogFileName));
            goto ErrorReturn;
        }

        wcscpy(DavGlobalDebugSharePath, LogFileName);
    }
    else {
        wcscpy(LogFileName, DavGlobalDebugSharePath);
    }

    //
    // Check whether this path exists.
    //
    FileAttributes = GetFileAttributesW( LogFileName );
    if( FileAttributes == 0xFFFFFFFF ) {
        WinError = GetLastError();
        if( WinError == ERROR_FILE_NOT_FOUND ) {
            BOOL RetVal;
            //
            // Create debug directory.
            //
            RetVal = CreateDirectoryW( LogFileName, NULL );
            if( !RetVal ) {
                DavPrint((DEBUG_ERRORS,
                          "DavOpenDebugFile: Can't create Debug directory (%ws)"
                          ", %d.\n", LogFileName, GetLastError()));
                goto ErrorReturn;
            }
        }
        else {
            DavPrint((DEBUG_ERRORS,
                      "DavOpenDebugFile: Can't Get File attributes(%ws), %ld.\n",
                      LogFileName, WinError));
            goto ErrorReturn;
        }
    }
    else {
        //
        // If this is not a directory, then we fail.
        //
        if( !(FileAttributes & FILE_ATTRIBUTE_DIRECTORY) ) {
            DavPrint((DEBUG_ERRORS,
                      "DavOpenDebugFile: Debug directory path (%ws) exists "
                      "as file.\n", LogFileName));
            goto ErrorReturn;
        }
    }

    //
    // Create the name of the old and new log file names
    //
    wcscpy( BakFileName, LogFileName );
    wcscat( LogFileName, DEBUG_FILE );
    wcscat( BakFileName, DEBUG_BAK_FILE );

    //
    // If this is a re-open, delete the backup file, rename the current file to
    // the backup file.
    //
    if ( ReopenFlag ) {
        if ( !DeleteFile( BakFileName ) ) {
            WinError = GetLastError();
            if ( WinError != ERROR_FILE_NOT_FOUND ) {
                DavPrint((DEBUG_ERRORS,
                          "DavOpenDebugFile: Cannot delete %ws (%ld)\n",
                          BakFileName, WinError));
                DavPrint((DEBUG_ERRORS,
                              "DavOpenDebugFile: Try to re-open the file.\n"));
                    ReopenFlag = FALSE;
                }
            }
        }

    if ( ReopenFlag ) {
        if ( !MoveFile( LogFileName, BakFileName ) ) {
            DavPrint((DEBUG_ERRORS,
                      "DavOpenDebugFile: Cannot rename %ws to %ws (%ld)\n",
                      LogFileName, BakFileName, GetLastError()));
            DavPrint((DEBUG_ERRORS,
                      "DavopenDebugFile: Try to re-open the file.\n"));
            ReopenFlag = FALSE;
        }
    }

    //
    // Open the file.
    //
    EnterCriticalSection( &(DavGlobalDebugFileCritSect) );
    DavGlobalDebugFileHandle = CreateFileW(LogFileName,
                                           GENERIC_WRITE,
                                           FILE_SHARE_READ | FILE_SHARE_WRITE,
                                           NULL,
                                           (ReopenFlag ? CREATE_ALWAYS : OPEN_ALWAYS),
                                           FILE_ATTRIBUTE_NORMAL,
                                           NULL);


    if ( DavGlobalDebugFileHandle == INVALID_HANDLE_VALUE ) {
        DavPrint((DEBUG_ERRORS,
                  "DavOpenDebugFile: Cannot open (%ws).\n", LogFileName));
        LeaveCriticalSection( &(DavGlobalDebugFileCritSect) );
        goto ErrorReturn;
    } else {
        //
        // Position the log file at the end.
        //
        SetFilePointer( DavGlobalDebugFileHandle, 0, NULL, FILE_END );
    }

    LeaveCriticalSection( &(DavGlobalDebugFileCritSect) );

    return;

ErrorReturn:

    DavPrint((DEBUG_ERRORS,
              "DavOpenDebugFile: Debug o/p will be written to terminal.\n"));
    return;
}


VOID
DavPrintRoutine(
    IN DWORD DebugFlag,
    IN LPSTR Format,
    ...
    )
/*++

Routine Description:

    This routine prints the string passed in to the debug terminal and/or the
    persistent log file.

Arguments:

    DebugFlag - The debug flag which indicates whether thi string should be
                printed or not.

    Format - The string to be printed and its format.

Return Value:

    None.

--*/
{

#define MAX_PRINTF_LEN 8192

    va_list arglist;
    char OutputBuffer[MAX_PRINTF_LEN];
    char OutputBuffer2[MAX_PRINTF_LEN]; // this buffer will remove any % in OutputBuffer
    ULONG length = 0;
    DWORD ThreadId;
    // DWORD BytesWritten, ThreadId;
    // static BeginningOfLine = TRUE;
    // static LineCount = 0;
    // static TruncateLogFileInProgress = FALSE;
    LPSTR Text;
    DWORD PosInBuf1=0,PosInBuf2=0;

    //
    // If we aren't debugging this functionality, just return.
    //
    if ( DebugFlag == 0 || (DavGlobalDebugFlag & DebugFlag) == 0 ) {
        return;
    }

    //
    // vsprintf isn't multithreaded and we don't want to intermingle output
    // from different threads.
    //
    EnterCriticalSection( &(DavGlobalDebugFileCritSect) );
    length = 0;

    //
    // Print the ThreadId at the start.
    //
    ThreadId = GetCurrentThreadId();
    length += (ULONG) sprintf( &(OutputBuffer[length]), "%ld ", ThreadId );

    //
    // If this is an error, print the string "ERROR: " next.
    //
    if (DebugFlag & DEBUG_ERRORS) {
        Text  = "ERROR: ";
        length += (ULONG) sprintf( &(OutputBuffer[length]), "%s", Text );
    }
    //
    // Finally, print the string.
    //
    va_start(arglist, Format);
    length += (ULONG) vsprintf( &(OutputBuffer[length]), Format, arglist );
    va_end(arglist);

    DavAssert(length < MAX_PRINTF_LEN); //last one for '\0' char

    // Remove all % strings from Output buffer as this will be passed as format string 
    // to DbgPrint
    PosInBuf1=0; PosInBuf2=0;
    while(PosInBuf1<length) {
        OutputBuffer2[PosInBuf2] = OutputBuffer[PosInBuf1];
        PosInBuf2++;
        if(OutputBuffer2[PosInBuf2-1] == '%') {
            OutputBuffer2[PosInBuf2] = '%';
            PosInBuf2++;
        }
        PosInBuf1++; 
    }
    length = PosInBuf2;
    OutputBuffer2[length]='\0';

    DavAssert(length < MAX_PRINTF_LEN);

    DbgPrint( (PCH)OutputBuffer2 );

    LeaveCriticalSection( &(DavGlobalDebugFileCritSect) );

    return;

#if 0
    //
    // If the log file is getting huge, truncate it.
    //
    if ( DavGlobalDebugFileHandle != NULL && !TruncateLogFileInProgress ) {
        //
        // Only check every 50 lines,
        //
        LineCount++;
        if ( LineCount >= 50 ) {
            DWORD FileSize;
            LineCount = 0;
            //
            // Is the log file too big?
            //
            FileSize = GetFileSize( DavGlobalDebugFileHandle, NULL );
            if ( FileSize == 0xFFFFFFFF ) {
                DbgPrint("DavPrintRoutine: Cannot GetFileSize. ErrorVal = %d.\n",
                         GetLastError());
            } else if ( FileSize > DavGlobalDebugFileMaxSize ) {
                TruncateLogFileInProgress = TRUE;
                LeaveCriticalSection( &(DavGlobalDebugFileCritSect) );
                DavOpenDebugFile( TRUE );
                DavPrint((DEBUG_MISC,
                          "Logfile truncated because it was larger than %ld bytes\n",
                          DavGlobalDebugFileMaxSize));
                EnterCriticalSection( &DavGlobalDebugFileCritSect );
                TruncateLogFileInProgress = FALSE;
            }
        }
    }

    //
    // Write the debug info to the log file.
    //

    if ( !WriteFile(DavGlobalDebugFileHandle,
                    OutputBuffer,
                    lstrlenA( OutputBuffer ),
                    &BytesWritten,
                    NULL) ) {
        DbgPrint( (PCH) OutputBuffer);
    }


ExitDavPrintRoutine:
    LeaveCriticalSection( &DavGlobalDebugFileCritSect );
#endif

}


VOID
DavAssertFailed(
    LPSTR FailedAssertion,
    LPSTR FileName,
    DWORD LineNumber,
    LPSTR Message
    )
/*++

Routine Description:

    This routine is called if a DAV assertion failed.

Arguments:

    FailedAssertion : The assertion string that failed.

    FileName : The file in which this assert was called.

    LineNumber : The line on which this assert was called.

    Message : The message to be printed if the assertion failed.

Return Value:

    none.

--*/
{
    DavPrint((DEBUG_ERRORS, "DavAssertFailed: Assert: %s.\n", FailedAssertion));
    DavPrint((DEBUG_ERRORS, "DavAssertFailed: Filename: %s.\n", FileName));
    DavPrint((DEBUG_ERRORS, "DavAssertFailed: Line Num: %ld.\n", LineNumber));
    DavPrint((DEBUG_ERRORS, "DavAssertFailed: Message: %s.\n", Message));

    RtlAssert(FailedAssertion, FileName, (ULONG)LineNumber, (PCHAR)Message);

#if DBG
    DebugBreak();
#endif

    return;
}


LPSTR
dbgmakefilelinestring(
    LPSTR  pszBuf,
    LPCSTR pszFile,
    UINT    uLine
    )
/*++

Routine Description:

    Takes the filename and line number and put them into a string buffer.
    NOTE: the buffer is assumed to be of size DEBUG_OUTPUT_BUFFER_SIZE.

Arguments:

    pszBuf - The buffer to be written to.

    pszFile - The filename.

    uLine - The line in the file.

Return Value:

--*/
{
    LPVOID args[2];

    args[0] = (LPVOID) pszFile;
    args[1] = (LPVOID) ((ULONG_PTR)uLine);

    FormatMessageA(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                   "%1(%2!u!):",
                   0,                          // error code
                   0,                          // default language
                   (LPSTR) pszBuf,             // output buffer
                   DEBUG_OUTPUT_BUFFER_SIZE,   // size of buffer
                   (va_list*)&args);           // arguments

    return pszBuf;
}


HLOCAL
DebugMemoryAdd(
    HLOCAL hlocal,
    LPCSTR pszFile,
    UINT    uLine,
    LPCSTR pszModule,
    UINT    uFlags,
    DWORD   dwBytes,
    LPCSTR pszComment
    )
/*++

Routine Description:

     Adds a MEMORYBLOCK to the memory tracking list.

Arguments:

    hlocal - The handle (pointer) to the allocated memroy block.

    pszFile - The file in which this allocation took place.

    uLine - The line in which this allocation took place.

    pszModule - DAV in our case.

    uFlags - Allocation flags passed to LocalAlloc().

    dwBytes - Number of bytes to allocate.

    Comm - The allocation string (i.e argument to DavAllocateMemory).

Return Value:

    Handle (pointer) to the memory block.

--*/
{
    LPMEMORYBLOCK pmb;

    if ( hlocal ) {

        pmb = (LPMEMORYBLOCK) LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, sizeof(MEMORYBLOCK));
        if ( !pmb ) {
            LocalFree( hlocal );
            return NULL;
        }

        pmb->hlocal     = hlocal;
        pmb->dwBytes    = dwBytes;
        pmb->uFlags     = uFlags;
        pmb->pszFile    = pszFile;
        pmb->uLine      = uLine;
        pmb->pszModule  = pszModule;
        pmb->pszComment = pszComment;

        EnterCriticalSection( &(g_TraceMemoryCS) );

        //
        // Add this block to the list.
        //
        pmb->pNext = g_TraceMemoryTable;
        g_TraceMemoryTable = pmb;

        DavPrint((DEBUG_MEMORY,
                  "DebugMemoryAdd: Handle = 0x%08lx. Argument: (%s)\n",
                  hlocal, pmb->pszComment));

        LeaveCriticalSection( &(g_TraceMemoryCS) );
    }

    return hlocal;
}


HLOCAL
DebugAlloc(
    LPCSTR File,
    UINT Line,
    LPCSTR Module,
    UINT    uFlags,
    DWORD   dwBytes,
    LPCSTR Comm
    )
/*++

Routine Description:

   Allocates memory and adds the MEMORYBLOCK to the memory tracking list.

Arguments:

    File - The file in which this allocation took place.

    Line - The line in which this allocation took place.

    Module - DAV in our case.

    uFlags - Allocation flags passed to LocalAlloc().

    dwBytes - Number of bytes to allocate.

    Comm - The allocation string (i.e argument to DavAllocateMemory).

Return Value:

    Handle (pointer) to the memory block.

--*/
{
    HLOCAL hlocal;
    HLOCAL *p;
    ULONG ShouldBeZero;

    //
    // dwBytes should be a multiple of 8. This is because of the pointer math
    // that is being done below to store the value of hlocal in the memory 
    // allocated for it.
    //
    ShouldBeZero = (dwBytes & 0x7);

    DavPrint((DEBUG_MISC, "DebugAlloc: ShouldBeZero = %d\n", ShouldBeZero));

    ASSERT(ShouldBeZero == (ULONG)0);

    hlocal = LocalAlloc( uFlags, dwBytes + sizeof(HLOCAL));
    if (hlocal == NULL) {
        return NULL;
    }

    p = (HLOCAL)((LPBYTE)hlocal + dwBytes);
    
    *p = hlocal;

    return DebugMemoryAdd(hlocal, File, Line, Module, uFlags, dwBytes, Comm);
}


VOID
DebugMemoryDelete(
    HLOCAL hlocal
    )
/*++

Routine Description:

     Removes a MEMORYBLOCK to the memory tracking list.

Arguments:

    hlocal - The handle to be removed.

Return Value:

    none.

--*/
{
    LPMEMORYBLOCK pmbHead;
    LPMEMORYBLOCK pmbLast = NULL;

    if ( hlocal ) {

        EnterCriticalSection( &(g_TraceMemoryCS) );

        pmbHead = g_TraceMemoryTable;

        //
        // Search the list for the handle being freed.
        //
        while ( pmbHead && pmbHead->hlocal != hlocal ) {
            pmbLast = pmbHead;
            pmbHead = pmbLast->pNext;
        }

        if ( pmbHead ) {
            HLOCAL *p;

            if ( pmbLast ) {
                //
                // Reset the "next" pointer of the previous block.
                //
                pmbLast->pNext = pmbHead->pNext;
            } else {
                //
                // First entry is being freed.
                //
                g_TraceMemoryTable = pmbHead->pNext;
            }

            DavPrint((DEBUG_MEMORY,
                      "DebugMemoryDelete: Handle 0x%08x freed. Comm: (%s)\n",
                      hlocal, pmbHead->pszComment ));

            p = (HLOCAL)((LPBYTE)hlocal + pmbHead->dwBytes);
            if ( *p != hlocal ) {
                DavPrint(((DEBUG_ERRORS | DEBUG_MEMORY),
                          "DebugMemoryDelete: Heap check FAILED for %0x08x %u bytes (%s).\n",
                          hlocal, pmbHead->dwBytes, pmbHead->pszComment));
                DavPrint(((DEBUG_ERRORS | DEBUG_MEMORY),
                          "DebugMemoryDelete: File: %s, Line: %u.\n",
                          pmbHead->pszFile, pmbHead->uLine ));
                DavAssert( *p == hlocal );
            }

            memset( hlocal, 0xFE, pmbHead->dwBytes + sizeof(HLOCAL) );
            memset( pmbHead, 0xFD, sizeof(MEMORYBLOCK) );

            LocalFree( pmbHead );

        } else {
            DavPrint(((DEBUG_ERRORS | DEBUG_MEMORY),
                      "DebugMemoryDelete: Handle 0x%08x not found in memory "
                      "table.\n", hlocal));
            memset( hlocal, 0xFE, (int)LocalSize( hlocal ));
        }

        LeaveCriticalSection( &(g_TraceMemoryCS) );
    }

    return;
}


HLOCAL
DebugFree(
    HLOCAL hlocal
    )
/*++

Routine Description:

     Remove the MEMORYBLOCK from the memory tracking list, memsets the memory to
     0xFE and then frees the memory.

Arguments:

    hlocal - The handle to be freed.

Return Value:

    Whatever LocalFree returns.

--*/
{
    //
    // Remove it from the tracking list and free it.
    //
    DebugMemoryDelete( hlocal );
    return LocalFree( hlocal );
}


VOID
DebugMemoryCheck(
    VOID
    )
/*++

Routine Description:

    Checks the memory tracking list. If it is not empty, it will dump the
    list and break.

Arguments:

    none.

Return Value:

    none.

--*/
{
    BOOL fFoundLeak = FALSE;
    LPMEMORYBLOCK pmb;

    EnterCriticalSection( &(g_TraceMemoryCS) );

    pmb = g_TraceMemoryTable;

    while ( pmb ) {

        LPMEMORYBLOCK pTemp;
        LPVOID args[5];
        CHAR  szOutput[DEBUG_OUTPUT_BUFFER_SIZE];
        CHAR  szFileLine[DEBUG_OUTPUT_BUFFER_SIZE];

        if ( fFoundLeak == FALSE ) {
            DavPrintRoutine(DEBUG_MEMORY | DEBUG_ERRORS,
                            "************ Memory leak detected ************\n");
            fFoundLeak = TRUE;
        }

        args[0] = (LPVOID) pmb->hlocal;
        args[1] = (LPVOID) &szFileLine;
        args[2] = (LPVOID) pmb->pszComment;
        args[3] = (LPVOID) ((ULONG_PTR) pmb->dwBytes);
        args[4] = (LPVOID) pmb->pszModule;

        dbgmakefilelinestring( szFileLine, pmb->pszFile, pmb->uLine );

        if ( !!(pmb->uFlags & GMEM_MOVEABLE) ) {
            FormatMessageA(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                           "%2!-40s!  %5!-10s! H 0x%1!08x!  %4!-5u!  \"%3\"\n",
                           0,                           // error code
                           0,                           // default language
                           (LPSTR) &szOutput,           // output buffer
                           DEBUG_OUTPUT_BUFFER_SIZE,    // size of buffer
                           (va_list*) &args);           // arguments
        } else {
            FormatMessageA(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                           "%2!-40s!  %5!-10s! A 0x%1!08x!  %4!-5u!  \"%3\"\n",
                           0,                           // error code
                           0,                           // default language
                           (LPSTR) &szOutput,           // output buffer
                           DEBUG_OUTPUT_BUFFER_SIZE,    // size of buffer
                           (va_list*) &args);           // arguments
        }

        DavPrintRoutine(DEBUG_MEMORY | DEBUG_ERRORS,  szOutput);

        pTemp = pmb;

        pmb = pmb->pNext;

        memset( pTemp, 0xFD, sizeof(MEMORYBLOCK) );

        LocalFree( pTemp );
    }

    LeaveCriticalSection( &(g_TraceMemoryCS) );

    return;
}

#endif // DBG


DWORD
DavReportEventW(
    DWORD EventID,
    DWORD EventType,
    DWORD NumStrings,
    DWORD DataLength,
    LPWSTR *Strings,
    LPVOID Data
    )
/*++

Routine Description:

    This function writes the specified (EventID) log at the end of the
    eventlog.

Arguments:

    EventID - The specific event identifier. This identifies the
                message that goes with this event.

    EventType - Specifies the type of event being logged. This
                parameter can have one of the following

                values:

                    Value                       Meaning

                    EVENTLOG_ERROR_TYPE         Error event
                    EVENTLOG_WARNING_TYPE       Warning event
                    EVENTLOG_INFORMATION_TYPE   Information event

    NumStrings - Specifies the number of strings that are in the array
                    at 'Strings'. A value of zero indicates no strings
                    are present.

    DataLength - Specifies the number of bytes of event-specific raw
                    (binary) data to write to the log. If cbData is
                    zero, no event-specific data is present.

    Strings - Points to a buffer containing an array of null-terminated
                strings that are merged into the message before
                displaying to the user. This parameter must be a valid
                pointer (or NULL), even if cStrings is zero.

    Data - Buffer containing the raw data. This parameter must be a
            valid pointer (or NULL), even if cbData is zero.


Return Value:

    Returns the WIN32 extended error obtained by GetLastError().

    NOTE : This function works slow since it calls the open and close
            eventlog source everytime.

--*/
{
    HANDLE EventlogHandle;
    DWORD ReturnCode;

    //
    // Open eventlog section.
    //
    EventlogHandle = RegisterEventSourceW(NULL, SERVICE_DAVCLIENT);
    if (EventlogHandle == NULL) {
        ReturnCode = GetLastError();
        goto Cleanup;
    }

    //
    // Log the error code specified.
    //
    if( !ReportEventW(EventlogHandle,
                      (WORD)EventType,
                      0,            // event category
                      EventID,
                      NULL,
                      (WORD)NumStrings,
                      DataLength,
                      Strings,
                      Data) ) {
        ReturnCode = GetLastError();
        goto Cleanup;
    }

    ReturnCode = NO_ERROR;

Cleanup:

    if( EventlogHandle != NULL ) {
        DeregisterEventSource(EventlogHandle);
    }

    return ReturnCode;
}


DWORD
DavReportEventA(
    DWORD EventID,
    DWORD EventType,
    DWORD NumStrings,
    DWORD DataLength,
    LPSTR *Strings,
    LPVOID Data
    )
/*++

Routine Description:

    This function writes the specified (EventID) log at the end of the
    eventlog.

Arguments:

    Source - Points to a null-terminated string that specifies the name
             of the module referenced. The node must exist in the
             registration database, and the module name has the
             following format:

                \EventLog\System\Lanmanworkstation

    EventID - The specific event identifier. This identifies the
                message that goes with this event.

    EventType - Specifies the type of event being logged. This
                parameter can have one of the following

                values:

                    Value                       Meaning

                    EVENTLOG_ERROR_TYPE         Error event
                    EVENTLOG_WARNING_TYPE       Warning event
                    EVENTLOG_INFORMATION_TYPE   Information event

    NumStrings - Specifies the number of strings that are in the array
                    at 'Strings'. A value of zero indicates no strings
                    are present.

    DataLength - Specifies the number of bytes of event-specific raw
                    (binary) data to write to the log. If cbData is
                    zero, no event-specific data is present.

    Strings - Points to a buffer containing an array of null-terminated
                strings that are merged into the message before
                displaying to the user. This parameter must be a valid
                pointer (or NULL), even if cStrings is zero.

    Data - Buffer containing the raw data. This parameter must be a
            valid pointer (or NULL), even if cbData is zero.


Return Value:

    Returns the WIN32 extended error obtained by GetLastError().

    NOTE : This function works slow since it calls the open and close
            eventlog source everytime.

--*/
{
    HANDLE EventlogHandle;
    DWORD ReturnCode;

    //
    // Open eventlog section.
    //
    EventlogHandle = RegisterEventSourceW(NULL, SERVICE_DAVCLIENT);
    if (EventlogHandle == NULL) {
        ReturnCode = GetLastError();
        goto Cleanup;
    }

    //
    // Log the error code specified.
    //
    if( !ReportEventA(EventlogHandle,
                      (WORD)EventType,
                      0,            // event category
                      EventID,
                      NULL,
                      (WORD)NumStrings,
                      DataLength,
                      Strings,
                      Data) ) {
        ReturnCode = GetLastError();
        goto Cleanup;
    }

    ReturnCode = NO_ERROR;

Cleanup:

    if( EventlogHandle != NULL ) {
        DeregisterEventSource(EventlogHandle);
    }

    return ReturnCode;
}


VOID
DavClientEventLog(
    DWORD EventID,
    DWORD EventType,
    DWORD ErrorCode
    )
/*++

Routine Description:

    Logs an event in EventLog.

Arguments:

    EventID - The specific event identifier. This identifies the
                message that goes with this event.

    EventType - Specifies the type of event being logged. This
                parameter can have one of the following

                values:

                    Value                       Meaning

                    EVENTLOG_ERROR_TYPE         Error event
                    EVENTLOG_WARNING_TYPE       Warning event
                    EVENTLOG_INFORMATION_TYPE   Information event


    ErrorCode - Error Code to be Logged.

Return Value:

    None.

--*/
{
    DWORD Error;
    LPSTR Strings[1];
    CHAR ErrorCodeOemString[32 + 1];

    wsprintfA( ErrorCodeOemString, "%lu", ErrorCode );

    Strings[0] = ErrorCodeOemString;

    Error = DavReportEventA(EventID,
                            EventType,
                            1,
                            sizeof(ErrorCode),
                            Strings,
                            &ErrorCode);
    if( Error != ERROR_SUCCESS ) {
        DavPrint(( DEBUG_ERRORS, "DavReportEventA failed, %ld.\n", Error ));
    }

    return;
}


#if 1

typedef ULONG (*DBGPRINTEX)(ULONG, ULONG, PCH, va_list);

ULONG
vDbgPrintEx(
    ULONG ComponentId,
    ULONG Level,
    PCH Format,
    va_list arglist
    )
/*++

Routine Description:

    This routine has been written to help load the service on Win2K machines.
    The debug version of some libraries call vDbgPrintfEx which has been
    implemented in Whistler and hence does not exist in Win2k's ntdll.dll.
    BryanT added it to help solve this problem.

Arguments:

    ComponentId -
    
    Level -
    
    Format -
    
    arglist -

Return Value:

    ERROR_SUCCESS or the Win32 error code.

--*/
{

    DBGPRINTEX pfnDbgPrintEx = (DBGPRINTEX) GetProcAddress(GetModuleHandle(L"ntdll"), "vDbgPrintEx");
    if (pfnDbgPrintEx) {
        return (*pfnDbgPrintEx)(ComponentId, Level, Format, arglist);
    } else {
        char Buf[2048];
        RtlZeroMemory(Buf, sizeof(Buf));
        _vsnprintf(Buf, sizeof(Buf), Format, arglist);
        Buf[2047] = '\0';
        DbgPrint(Buf);
        return 0;
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\server\midluser.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    MidlUser.c

Abstract:

    This file contains common functions and utilities that the API DLLs can use
    in making remote calls. This includes the MIDL_USER_* functions.

Author:

    Dan Lafferty    danl    06-Feb-1991

Environment:

    User Mode - Win32

Revision History:

    06-Feb-1991     danl
        Created

    25-Apr-1991    JohnRo
        Split out MIDL user (allocate, free) into seperate source file, so
        linker doesn't get confused.

    03-July-1991   JimK
        Moved to a common directory so services available to more than just
        LM code.

    03-Dec-1991 JohnRo
        Added MIDL_user_reallocate and MIDL_user_size APIs.  (These are so we
        create the NetApiBufferAllocate, NetApiBufferReallocate, and
        NetApiBufferSize APIs.)
        Also check alignment of allocated data.

    10-Feb-1993     RitaW
        Copied to the NetWare tree so that the LPC transport can used for
        the local case.

--*/

#include <nt.h>
#include <ntrtl.h>              // needed for nturtl.h
#include <nturtl.h>             // needed for windows.h
#include <windows.h>            // win32 typedefs
#include <rpc.h>                // rpc prototypes

#include <align.h>              // POINTER_IS_ALIGNED(), ALIGN_WORST.
#include <winbase.h>            // LocalAlloc


PVOID
MIDL_user_allocate (
    IN unsigned int NumBytes
    )

/*++

Routine Description:

    Allocates storage for RPC transactions. The RPC stubs will either call
    MIDL_user_allocate when it needs to un-marshall data into a buffer
    that the user must free.  RPC servers will use MIDL_user_allocate to
    allocate storage that the RPC server stub will free after marshalling
    the data.

Arguments:

    NumBytes - The number of bytes to allocate.

Return Value:

    NULL or the allocated pointer.

--*/

{
    LPVOID NewPointer;

    NewPointer = (LPVOID) LocalAlloc(LPTR, NumBytes);

    ASSERT( POINTER_IS_ALIGNED(NewPointer, ALIGN_WORST) );

    return (NewPointer);
}


VOID
MIDL_user_free (
    IN void *MemPointer
    )

/*++

Routine Description:

    Frees storage used in RPC transactions. The RPC client can call this
    function to free buffer space that was allocated by the RPC client
    stub when un-marshalling data that is to be returned to the client.
    The Client calls MIDL_user_free when it is finished with the data and
    desires to free up the storage. The RPC server stub calls MIDL_user_free
    when it has completed marshalling server data that is to be passed back to
    the client.

Arguments:

    MemPointer - This points to the memory block that is to be released.

Return Value:

    None.

--*/
{
    ASSERT( POINTER_IS_ALIGNED( MemPointer, ALIGN_WORST) );
    (void) LocalFree((HLOCAL) MemPointer);
}


void *
MIDL_user_reallocate(
    IN void * OldPointer OPTIONAL,
    IN unsigned long NewByteCount
    )
{
    LPVOID NewPointer;  // may be NULL.


    ASSERT( POINTER_IS_ALIGNED( OldPointer, ALIGN_WORST) );


    // Special cases: something into nothing, or nothing into something.
    if (OldPointer == NULL) {

        NewPointer = (LPVOID) LocalAlloc(
                                  LMEM_ZEROINIT,
                                  NewByteCount
                                  );

    } else if (NewByteCount == 0) {

        (void) LocalFree((HLOCAL) OldPointer );
        NewPointer = NULL;

    } else {  // must be realloc of something to something else.

        HANDLE hOldMem;
        HANDLE hNewMem;                     // handle for new (may = old handle)

        hOldMem = LocalHandle( (LPSTR) OldPointer);
        ASSERT(hOldMem != NULL);

        hNewMem = (PVOID) LocalReAlloc(
                              hOldMem,               // old handle
                              NewByteCount,          // new size in bytes
                              LMEM_ZEROINIT |        // flags
                                  LMEM_MOVEABLE      //  (motion okay)
                              );

        if (hNewMem == NULL) {
            return (NULL);
        }

        NewPointer = (LPVOID) hNewMem;

    } // must be realloc of something to something else

    ASSERT( POINTER_IS_ALIGNED( NewPointer, ALIGN_WORST) );

    return (NewPointer);

} // MIDL_user_reallocate


ULONG_PTR
MIDL_user_size(
    IN void * Pointer
    )
{
    ULONG_PTR ByteCount;
    HANDLE hMemory;

    ASSERT( Pointer != NULL );
    ASSERT( POINTER_IS_ALIGNED( Pointer, ALIGN_WORST ) );

    hMemory = LocalHandle( (LPSTR) Pointer );
    ASSERT( hMemory != NULL );

    ByteCount = LocalSize( hMemory );

    ASSERT( ByteCount > 0 );

    return (ByteCount);

} // MIDL_user_size
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\server\nodefac.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    nodefac.cpp
    
Abstract:

    This file implements the CDavNodefactory class which is used to parse the 
    XML responses we get from the DAV server.

Author:

    Rohan Kumar      [RohanK]      14-Sept-1999

Revision History:

--*/

#include "pch.h"
#pragma hdrstop

#include <stdio.h>
#include <windows.h>
#include "usrmddav.h"
#include "nodefac.h"
#include "stdlib.h"
#include "wininet.h"
#include "UniUtf.h"

//
// WebDAV Properties - RFC 2518.
//
WCHAR rgCreationDate[]= L":creationdate";
WCHAR rgDisplayName[]= L":displayname"; // Ignored for now - href will be used to get name
WCHAR rgGetContentLanguage[]= L"getcontentlanguage"; // Ignored for now
WCHAR rgGetContentLength[] = L":getcontentlength"; 
WCHAR rgGetContentType[] = L":getcontenttype"; // Ignored for now
WCHAR rgGetETag[] = L":getetag"; // Ignored for now
WCHAR rgGetLastModified[] = L":getlastmodified";
WCHAR rgLockDiscovery[]= L":lockdiscovery"; // Ignored for now
WCHAR rgResourceType[]= L":resourcetype";  
WCHAR rgSource[]= L":source"; // Ignored for now
WCHAR rgSupportedLock[]= L":supportedlock"; // Ignored for now
WCHAR rgTimeout[] = L":timeout";
WCHAR rgLockToken[] = L":locktoken";
WCHAR rgOwner[] = L":owner";

//
// Properties which this client will set on DAV resources to improve performance.
//
WCHAR rgIsHidden[]= L":ishidden";
WCHAR rgIsCollection[]= L":iscollection";
WCHAR rgIsReadOnly[]= L":isreadonly";

WCHAR rgHref[] = L":href";
WCHAR rgStatus[] = L":status";
WCHAR rgResponse[] = L":response";

WCHAR rgWin32FileAttributes[] = L":Win32FileAttributes";
WCHAR rgWin32CreationTime[] = L":Win32CreationTime";
WCHAR rgWin32LastAccessTime[] = L":Win32LastAccessTime";
WCHAR rgWin32LastModifiedTime[] = L":Win32LastModifiedTime";

//
// MSN specific properties.
//
WCHAR rgAvailableSpace[]= L":availablespace";
WCHAR rgTotalSpace[]= L":totalspace";

DWORD
DavInternetTimeToFileTime(
    PWCHAR lpTimeString,
    FILETIME *lpft
    );

VOID
DavOverrideAttributes(
    PDAV_FILE_ATTRIBUTES pDavFileAttributes
    );


STDMETHODIMP_(ULONG) 
CDavNodeFactory::AddRef(
    VOID
    )
/*++

Routine Description:

    The AddRef function of the IUnknown class.

Arguments:

    none.

Return Value:

    The new reference count of the object.

--*/
{
    return (ULONG)InterlockedIncrement((long *)&m_ulRefCount);
}


STDMETHODIMP_(ULONG) 
CDavNodeFactory::Release(
    VOID
    )
/*++

Routine Description:

    The Release function of the IUnknown class.

Arguments:

    none.

Return Value:

    The reference count remaining on the object.

--*/
{
    ULONG   ulRefCount = InterlockedDecrement((long *)&m_ulRefCount);

    if (ulRefCount == 0) {
        delete this;
    }

    return ulRefCount;
}


STDMETHODIMP 
CDavNodeFactory::QueryInterface(
    REFIID riid, 
    LPVOID *ppvObject
    )
/*++

Routine Description:

    The QueryInterface function of the IUnknown class.

Arguments:

Return Value:

    HRESULT.

--*/
{
    HRESULT hr = E_NOINTERFACE;

    if (ppvObject == NULL)
        return E_POINTER;

    *ppvObject = NULL;

    if (IsEqualIID(riid, IID_IUnknown)) {
        *ppvObject = (LPVOID) this;
        AddRef();
        hr = NOERROR;
    } else if (IsEqualIID(riid, IID_IXMLNodeFactory)) {
        *ppvObject = (LPVOID) this;
        AddRef();
        hr = NOERROR;
    }

    return hr;
}


STDMETHODIMP
CDavNodeFactory::NotifyEvent(
    IN IXMLNodeSource* pSource,
    IN XML_NODEFACTORY_EVENT iEvt
    )
/*++

Routine Description:

    The NotifyEvent function of the NodeFactory API.

Arguments:

Return Value:

    HRESULT.

--*/
{
    // XmlDavDbgPrint(("Entered NotifyEvent. Event = %d.\n", iEvt));
    return S_OK;
}


STDMETHODIMP
CDavNodeFactory::BeginChildren(
    IN IXMLNodeSource* pSource, 
    IN XML_NODE_INFO* pNodeInfo
    )
/*++

Routine Description:

    The BeginChildren function of the NodeFactory API.

Arguments:

Return Value:

    HRESULT.

--*/
{
    // XmlDavDbgPrint(("%ld: BeginChildren: pwcText = %ws\n",
    //                 GetCurrentThreadId(), pNodeInfo->pwcText));

    // XmlDavDbgPrint(("%ld: BeginChildren: fTerminal = %d\n",
    //                 GetCurrentThreadId(), pNodeInfo->fTerminal));

    return S_OK;
}
            

STDMETHODIMP
CDavNodeFactory::EndChildren(
    IN IXMLNodeSource* pSource,
    IN BOOL fEmpty,
    IN XML_NODE_INFO* pNodeInfo
    )
/*++

Routine Description:

    The EndChildren function of the NodeFactory API.

Arguments:

Return Value:

    HRESULT.

--*/
{
    HRESULT hResult = S_OK;
    IXMLParser *Xp = NULL;
    CDavNodeFactory *NodeFac = NULL;
    PWCHAR Temp = NULL, thirdWack = NULL, firstChar = NULL, lastChar = NULL;
    BOOL isAbsoluteName = FALSE, lastCharIsWack = FALSE, rootLevel = FALSE, freeTemp = TRUE;
    DWORD wackCount = 0;
    ULONG_PTR LengthInChars = 0;
    PDAV_FILE_ATTRIBUTES DFA = NULL;
    DWORD ConvertedLength = 0;
    DWORD fullFileNameLength = 0;
    
    // XmlDavDbgPrint(("%ld: EndChildren: fEmpty = %d\n",
    //                GetCurrentThreadId(), fEmpty));

    // XmlDavDbgPrint(("%ld: EndChildren: pwcText = %ws\n",
    //                GetCurrentThreadId(), pNodeInfo->pwcText));

    // XmlDavDbgPrint(("%ld: EndChildren: fTerminal = %d\n",
    //                GetCurrentThreadId(), pNodeInfo->fTerminal));
    
    Xp = (IXMLParser *)pSource;

    hResult = Xp->GetFactory( (IXMLNodeFactory **)&(NodeFac) );
    if (!SUCCEEDED(hResult)) {
        NodeFac = NULL;
        XmlDavDbgPrint(("%ld: ERROR: EndChildren/GetFactory.\n", GetCurrentThreadId()));
        goto EXIT_THE_FUNCTION;
    }

    //
    // IMPORTANT!!!
    // If this was an empty node, then we should set the NodeFac->m_FoundEntry
    // to FALSE. This is because if we get a node like <foo>...</foo></bar><haha>...
    // then CreateNode would have been called for "bar". If we were interested
    // in the property "bar", we would have set NodeFac->m_FoundEntry to TRUE.
    // This is with the expectation that the next CreateNode will come with the
    // value of "bar". But in this case, "bar" does not have any value since its
    // empty. So, the next CreateNode will be called with pwcText == "haha" which
    // we will expect to be the value of "bar" and the parsing will screw up.
    // To avoid this we set  NodeFac->m_FoundEntry to FALSE here since between
    // the two CreateNodes, we get an EndChildren for "bar" with fEmpty set to
    // TRUE. This is the indication that we should not be looking for the value
    // of "bar" since its empty. By doing this, the parsing will continue smoothly
    // in CreateNode for the next element "haha".
    //
    if (fEmpty == TRUE) {
        NodeFac->m_FoundEntry = FALSE;
        goto EXIT_THE_FUNCTION;
    }


    // 
    // Since filename information can span over many CreateNode calls, so we collect
    // the complete filename information in CreateNode calls and then process them
    // here (EndChildren) to get the displayname.
    // Ex. <href>http://abc.com/AB&quot;123</href> has 3 CreateNode calls: 
    // 1] http://abc.com//AB
    // 2] "
    // 3] 123
    // and complete name is http://abc.com/AB"123.
    //
    if ( (NodeFac->m_FoundEntry == TRUE) && 
                    (NodeFac->m_CreateNodeAttribute == CreateNode_DisplayName) ) {

        DFA = NodeFac->m_DFAToUse;

        if(DFA->FileName == NULL || DFA->FileNameLength == 0) {
            XmlDavDbgPrint(("%ld: ERROR: EndChildren. Invalid FileName information. FileName=0x%x FileNameLength=%d.\n", 
                                    GetCurrentThreadId(), DFA->FileName, DFA->FileNameLength));
            hResult = CO_E_ERRORINAPP;
            goto EXIT_THE_FUNCTION;
        }

        //
        // Store the FullFileName Length in a local variable. This will be used to
        // find "parent DAV collection".
        //
        fullFileNameLength = DFA->FileNameLength;

        // 
        // DFA->FileName buffer has filename of length DFA->FileNameLength and a 
        // NULL character in the end.
        // 
        
        //
        // Names can be absoulte URLs or can be relative URLs. 
        // Format of absolute URLs::     scheme ":" (some path)
        // Format of relative URLs::     
        //                               "//" (some path)
        //                               "/" (some path)
        //                               (some name) ["/" (some path)]
        //
        //

        // 
        // Note : We are supporting only HTTP URLs "http://" (somepath) 
        // and relative path names
        //

        //
        // We need to parse the string NodeInfo->pwcText and get the
        // DisplayName out of it. Here are the 7 cases we handle.
        // 1. http://rohank-srv/ <===> DisplayName == NULL.
        // 2. http://rohank-srv/test <===> DisplayName == test.
        // 3. http://rohank-srv/test/ <===> DisplayName == test.
        // 4. /test/ <===> DisplayName == test
        // 5. /test <===> DisplayName == test
        // 6. /test/foo.txt <===> DisplayName == foo.txt
        // 7. / <===> DisplayName == NULL
        // In the above "test" could very well be a path like foo/bar.
        // http://rohank-srv/test/foo.txt <===> DisplayName == foo.txt.
        
            
        firstChar = (PWCHAR)(DFA->FileName);
        //
        // http://rohank-srv/test/foo.txt"
        //                               ^
        //                               |
        //                               lastChar
        //
        lastChar = (PWCHAR)(firstChar + DFA->FileNameLength);

        // 
        // Need to find if the name is Absolute name or Relative name. For this
        // if we find 'http://' in the start of name then it is a absolute name.
        //
        isAbsoluteName = FALSE;
        if((DFA->FileNameLength >= (sizeof(L"http://")/sizeof(WCHAR)-1)) &&
            (_wcsnicmp(firstChar, L"http://", (sizeof(L"http://")/sizeof(WCHAR))-1) == 0) ) {
            isAbsoluteName = TRUE;
        }

        //
        // If DFA->pwcText = http://rohank-srv/foo/bar.txt,
        // http://rohank-srv/foo/bar.txt
        //                  ^
        //                  |
        //                  thirdWack
        //
        thirdWack = firstChar;
        wackCount = 0;
        while(thirdWack < lastChar) {
            if (*thirdWack == L'/') {
                wackCount++;
                if (wackCount == 3) {
                    break;
                }
            }
            thirdWack++;
        }
        // 
        // After this loop, either thirdWack == 3rd Wack or thirdWack = lastChar.
        // 

        //
        // We need to deal with five special cases.
        // 1. http://rohank-srv/ and 
        // 2. http://rohank-srv/test/
        // 3. /
        // 4. test/
        // 5. //
        // 
        if ( *(lastChar - 1) == L'/' ) {

            lastCharIsWack = TRUE;
            
            //  
            // If URL = http://rohank-srv/, the display name should be 
            // NULL.
            // Same for URL = /  and URL = //
            //
            if ( ((lastChar - 1) == thirdWack && isAbsoluteName==TRUE) ||
                            (DFA->FileNameLength == 1) ||
                            (DFA->FileNameLength == 2 && *(lastChar-2) == L'/')) {
                rootLevel = TRUE;
            } else {
                rootLevel = FALSE;
                //
                // We subtract 2 here because of the way we do the 
                // parsing below.
                //
                lastChar -= 2;
            }

        } else {
            lastCharIsWack = FALSE;
            rootLevel = FALSE;
        }

        if (rootLevel == FALSE) {

            //
            // Becuase we check for L'/', we subtract 2 from the 
            // lastChar pointer above if the URL was of the form
            // 1. http://rohank-srv/test/.
            // 2. test/
            // We add the check lastChar != firstChar
            // in the loop below to make sure that we never go beyond the
            // begenning of the string. This could happen when pwcText is of the
            // form test/. In this case we will end at the character 't'.
            // 
            while(*lastChar != L'/' && lastChar != firstChar) {
                lastChar--;
            }
    
            //
            // As explained above the last char need not be a '/'. An example is 
            // when pwcText is test/. In this case lastChar points to 't'.
            //
            if(*lastChar == L'/') {
                lastChar++;
            }
        
            //
            // lastChar now points to the first char of the name after the
            // last backslash. The extra 1 is for the final \0 char.
            // http://rohank-srv/test/foo.txt
            //                        ^
            //                        |
            //                        lastChar
            //  
            //  Note: If last char is a wack, then it is included here.
            //
            LengthInChars = (ULONG_PTR)( (firstChar + DFA->FileNameLength + 1) - lastChar );
            if (LengthInChars <= 1) {
                XmlDavDbgPrint(("%ld: ERROR: EndChildren. Displayname length is 0.\n",
                                        GetCurrentThreadId()));
                hResult = CO_E_ERRORINAPP;
                goto EXIT_THE_FUNCTION;
            }
        } else {
            //
            // rootLevel = TRUE => FileName = L"/"
            LengthInChars = 2;
        }
         
        //
        // Allocate memory to contain Actual Display Name.
        // 

        Temp = (PWCHAR)LocalAlloc (LMEM_FIXED | LMEM_ZEROINIT, 
                                            LengthInChars * sizeof(WCHAR) );
        if(Temp == NULL) {
            ULONG WStatus;
            WStatus = GetLastError();
            XmlDavDbgPrint(("%ld: ERROR: EndChildren. LocalAlloc. Error Val = %d\n", 
                                    GetCurrentThreadId(), WStatus));
            hResult = CO_E_ERRORINAPP;
            goto EXIT_THE_FUNCTION;
        }
        freeTemp = TRUE;

        if(rootLevel == FALSE) {
            //  
            //  Copy the element. Displayname can be a unicode
            //  string, then server will send it as a UTF-8 format URL string 
            //  We need to convert such a display name to a Unicode string.
            //  Assumption: The URL is UTF-8 format encoded URL string.
            //  i.e. extended characters appear as %HH%HH... in URL string.
            //
            ConvertedLength = 0;
            hResult = UtfUrlStrToWideStr(lastChar, (DWORD)(LengthInChars-1), Temp, 
                                                            &ConvertedLength);
            if(hResult != ERROR_SUCCESS) {
                XmlDavDbgPrint(("%ld: ERROR: EndChildren/UtfUrlToWideStr = %u\n",
                                GetCurrentThreadId(), hResult));
                goto EXIT_THE_FUNCTION;
            }
    
            //
            // If the last char was a "/" like in http://rohank-srv/test/,
            // we would have copied "test/" as the name. We need to strip
            // out the last wack and the display name should be "test". ConvertedLength
            // points to the char next to the last char.
            //
            if (lastCharIsWack) {
                Temp[(ConvertedLength - 1)] = L'\0';
            }
        } else {
            //
            // The displayname is root level name - hence return L"/" for
            // actual displayname.
            //
            Temp[0] = L'/';
            Temp[1] = L'\0';
        }

        //XmlDavDbgPrint(("%ld. EndChildren. Temp=%ws, LengthInChars=%d\n", Temp, LengthInChars ));

        if ( DFA->FileName != NULL ) {
            LocalFree((HLOCAL)DFA->FileName);
            DFA->FileName = NULL;
        }
        DFA->FileNameLength = 0;
        
        NodeFac->m_DFAToUse->FileName = Temp;
        NodeFac->m_DFAToUse->FileNameLength = wcslen(Temp);
        freeTemp = FALSE;

        //
        // Files / Collections properties can come in any order in
        // a XML response. We want to have the DavFileAtrributes entry which
        // corresponds to Collection which "contains" all the other DAV resources
        // present in this XML response ("parent DAV collection").
        // 
        // NodeFac->m_CollectionDFA will point to DFA entry with smallest
        // Full-DisplayName (that comes in "<a:href>Full-DisplayName</a:href>") 
        // in the response. 
        // 
        // If XML response contains the properties of the "parent DAV collection"
        // then it will have smallest Full-DisplayName and in that case 
        // NodeFac->m_CollectionDFA will point to entry of "parent DAV 
        // collection".
        //
        // Caller of this function should know whether to expect entry for
        // "parent DAV resource" in this XML response.
        //
        if(fullFileNameLength < NodeFac->m_MinDisplayNameLength) {
            NodeFac->m_CollectionDFA = DFA;
            NodeFac->m_MinDisplayNameLength = fullFileNameLength;
        }
    }
        

EXIT_THE_FUNCTION:

    // 
    // Assumption: (this is TRUE according to our current implementation)
    // The XML_ELEMENTs which we parse to get information have atmost 1 child. 
    //
    // When we have parsed a XML_ELEMENT of our interest and has set NodeFac->m_FoundEntry
    // = TRUE, we should set NodeFac->m_FoundEntry=FALSE on "EndChildren call of either
    // this XML_ELEMENT" or the "EndChildren call of first child XML_ELEMENT".
    // 
    // NodeFac->m_FoundEntry = TRUE => We are parsing a XML_ELEMENT of our interest
    // and EndChildren is called either on ending of this XML_ELEMENT or on ending of
    // a child-element of this XML_ELEMENT.
    //
    if(NodeFac != NULL) {
        NodeFac->m_FoundEntry = FALSE;
    }

    if(freeTemp == TRUE && Temp != NULL) {
        LocalFree((HLOCAL)Temp);
        Temp = NULL;
    }

    return hResult;
}


STDMETHODIMP
CDavNodeFactory::Error(
    IN IXMLNodeSource* pSource,
    IN HRESULT hrErrorCode,
    IN USHORT cNumRecs,
    IN XML_NODE_INFO __RPC_FAR **aNodeInfo
    )
/*++

Routine Description:

    The Error function of the NodeFactory API.

Arguments:

Return Value:

    HRESULT.

--*/
{
    HRESULT hResult = S_OK;
    XML_NODE_INFO *NodeInfo = NULL;
    IXMLParser *Xp = NULL;
    BSTR ErrorStr = NULL;
    const WCHAR *LineBuffer = NULL;
    ULONG LineBuffLen = 0, ErrPos = 0, LineNumber = 0, LinePos = 0, AbsPos = 0;
    
    XmlDavDbgPrint(("%ld: Entered Error...\n", GetCurrentThreadId()));
    
    XmlDavDbgPrint(("%ld: Error: hrErrorCode = %08lx\n", GetCurrentThreadId(), hrErrorCode));

    XmlDavDbgPrint(("%ld: Error: cNumRecs = %d\n", GetCurrentThreadId(), cNumRecs));
    
    Xp = (IXMLParser *)pSource;
    
    LineNumber = Xp->GetLineNumber();
    XmlDavDbgPrint(("%ld: Error: LineNumber = %d\n", GetCurrentThreadId(), LineNumber));

    LinePos = Xp->GetLinePosition();
    XmlDavDbgPrint(("%ld: Error: LinePosition = %d\n", GetCurrentThreadId(), LinePos));

    AbsPos = Xp->GetAbsolutePosition();
    XmlDavDbgPrint(("%ld: Error: AbsPos = %d\n", GetCurrentThreadId(), AbsPos));

    hResult = Xp->GetErrorInfo( &(ErrorStr) );
    if (!SUCCEEDED(hResult)) {
        XmlDavDbgPrint(("%ld: ERROR: Error/GetErrorInfo. hResult = %08lx\n", 
                        GetCurrentThreadId(), hResult));
        goto EXIT_THE_FUNCTION;
    }

    XmlDavDbgPrint(("%ld: Error: ErrorStr = %ws\n", GetCurrentThreadId(), ErrorStr));
    
    hResult = Xp->GetLineBuffer( &(LineBuffer), &(LineBuffLen), &(ErrPos) );
    if (!SUCCEEDED(hResult)) {
        XmlDavDbgPrint(("%ld: ERROR: Error/GetErrorInfo. hResult = %08lx\n", 
                        GetCurrentThreadId(), hResult));
        goto EXIT_THE_FUNCTION;
    }

    XmlDavDbgPrint(("%ld: Error: LineBuffer = %ws\n", GetCurrentThreadId(), LineBuffer));
    XmlDavDbgPrint(("%ld: Error: LineBufferLen = %d\n", GetCurrentThreadId(), LineBuffLen));
    XmlDavDbgPrint(("%ld: Error: ErrorPos = %d\n", GetCurrentThreadId(), ErrPos));

EXIT_THE_FUNCTION:
    
    return S_OK;
}


STDMETHODIMP
CDavNodeFactory::CreateNode(
    IN IXMLNodeSource __RPC_FAR *pSource,
    IN PVOID pNodeParent,
    IN USHORT cNumRecs,
    IN XML_NODE_INFO __RPC_FAR **aNodeInfo
    )
/*++

Routine Description:

    The CreateNode function of the NodeFactory API.

Arguments:

    pSource - The XMLNodeSource pointer.
    
    pNodeParent - 
    
    cNumRecs - Number of NodeInfo pointers in the array.
    
    aNodeInfo - Array of NodeInfo pointers.

Return Value:

    HRESULT.

--*/
{
    HRESULT hResult = S_OK;
    XML_NODE_INFO *NodeInfo = NULL;
    PWCHAR Temp = NULL;
    ULONG_PTR LengthInChars = 0; 
    BOOL freeTemp = TRUE, fPassElement = FALSE, fCopyInEnd = FALSE;
    PDAV_FILE_ATTRIBUTES DavFileAttributes = NULL;
    CDavNodeFactory *NodeFac = NULL;
    IXMLParser *Xp = NULL;
    CREATE_NODE_ATTRIBUTES nextCreateNodeAttribute = CreateNode_Max;
    PWCHAR        startTag = NULL;
    ULONG_PTR     tagLength = 0;
    ULONG_PTR     tagOffset = 0;
    USHORT        i;


    Xp = (IXMLParser *)pSource;

    // XmlDavDbgPrint(("%ld: Entered CreateNode. cNumRecs = %d\n", 
    //                     GetCurrentThreadId(), cNumRecs));
    
    hResult = Xp->GetFactory( (IXMLNodeFactory **)&(NodeFac) );
    if (!SUCCEEDED(hResult)) {
        XmlDavDbgPrint(("%ld: ERROR: CreateNode/GetFactory.\n", GetCurrentThreadId()));
        goto EXIT_THE_FUNCTION;
    }

    for (i = 0; i < cNumRecs; i++) {

        NodeInfo = aNodeInfo[i];

        // XmlDavDbgPrint(("%ld: CreateNode: NodeInfo->ulLen = %d, NodeInfo->ulNsPrefixLen = %d\n", 
        //                GetCurrentThreadId(), NodeInfo->ulLen, NodeInfo->ulNsPrefixLen));

        // XmlDavDbgPrint(("%ld: CreateNode: NodeInfo->pwcText = %ws\n",
        //                GetCurrentThreadId(), NodeInfo->pwcText));

        // XmlDavDbgPrint(("%ld: CreateNode: NodeInfo->fTerminal = %d\n",
        //                GetCurrentThreadId(), NodeInfo->fTerminal));

        //
        // If the NodeInfo->dwType is XML_WHITESPACE then we ignore this node
        // since we don't care about WhiteSpaces.
        //
        if (NodeInfo->dwType == XML_WHITESPACE) {
            break;
        }

        //
        // The tags can be of types:  "a:response"   or "dp0:response".
        // In these cases NodeInfo->pwcText will point to first character ('a' or 'd')
        // Actual tag in these cases is ":response", so we need to get a pointer to
        // start of Actual-tag, and re-compute the remaining string length.
        //
        // Ex.       lp0:response
        //              ^
        //              |
        //             startTag
        //             tagOffset = NodeInfo->ulNsPrefixLen = 3
        //             NodeInfo->ulLen = 12 (don't account for L'\0')
        //             tagLength = 12 - 3 = 9  = Len(":response") (don't account for L'\0')
        // 
        tagOffset = NodeInfo->ulNsPrefixLen;
        startTag = (PWCHAR)(&(NodeInfo->pwcText[0]) + tagOffset);
        tagLength = NodeInfo->ulLen - tagOffset;
        
        //
        // If startTag == L":response", then we need a new 
        // DavFileAttributes entry. The first eNodeFac->m_CreateNodeAttributentry
        // is allocated by the caller of the parser. 
        // :response is an indication that in (multi status)
        // response that a new entry is going to begin.
        //
        // 
        // Note: use startTag which takes care of namespace prefix.
        // Length = (sizeof(rgCreationDate)/sizeof(WCHAR)) includes L'\0' (null terminator)
        // but NodeInfo->ulLen don't account for NULL terminator in NodeInfo->pwcText. So
        // add 1 to tagLength (to account for L'\0' in startTag) before comparing it
        // to Tags (rgCreationDate).
        //

        fPassElement = FALSE;

        if (NodeInfo->dwType == XML_ELEMENT) {

            if( (tagLength + 1 == (sizeof(rgResponse)/sizeof(WCHAR))) &&
                        (_wcsicmp(startTag, rgResponse) == 0) ) {
            
                //
                // m_FileIndex = No of entries for which "<a:response...>" is found 
                // in response and memory is allocated for its DAV_FILE_ATTRIBUTES
                // structure. First entry is allocated by caller of this function, and 
                // now "<a:response...>" is detected for this entry in XML response, 
                // so increase m_FileIndex by 1.
                //
                if (NodeFac->m_FileIndex == 0) {
                        NodeFac->m_FileIndex = 1;
                }
                else {
                    //
                    // Since the first DavFileAttributes entry is allocated by the 
                    // caller, we need to allocate only from the second entry.
                    //
                    NodeFac->m_CreateNewEntry = TRUE;
                }
                // 
                // Since this CreateNode call has XML_ELEMENT ":reponse", we are done
                // with this call. Rest of NodeInfo in array contains information about
                // this xml element.
                //
                break; // Out of Loop
            }
        
            if ( ( tagLength + 1 == (sizeof(rgCreationDate)/sizeof(WCHAR)) && 
                                _wcsicmp(startTag, rgCreationDate) == 0 ) ) {
                nextCreateNodeAttribute = CreateNode_CreationTime;
            } else if ( ( tagLength + 1 == (sizeof(rgGetContentLength)/sizeof(WCHAR)) && 
                               _wcsicmp(startTag, rgGetContentLength) == 0 ) ) {
                nextCreateNodeAttribute = CreateNode_ContentLength;
            } else if ( ( tagLength + 1 == (sizeof(rgGetLastModified)/sizeof(WCHAR)) && 
                               _wcsicmp(startTag, rgGetLastModified) == 0 ) ) {
                nextCreateNodeAttribute = CreateNode_LastModifiedTime;
            } else if ( ( tagLength + 1 == (sizeof(rgResourceType)/sizeof(WCHAR)) && 
                               _wcsicmp(startTag, rgResourceType) == 0 ) ) {
                nextCreateNodeAttribute = CreateNode_ResourceType;
            } else if ( ( tagLength + 1 == (sizeof(rgIsHidden)/sizeof(WCHAR)) && 
                               _wcsicmp(startTag, rgIsHidden) == 0 ) ) {
                nextCreateNodeAttribute = CreateNode_isHidden;
            } else if ( ( tagLength + 1 == (sizeof(rgIsCollection)/sizeof(WCHAR)) && 
                               _wcsicmp(startTag, rgIsCollection) == 0 ) ) {
                nextCreateNodeAttribute = CreateNode_isCollection;
            } else if ( ( tagLength + 1 == (sizeof(rgHref)/sizeof(WCHAR)) && 
                               _wcsicmp(startTag, rgHref) == 0 ) ) {
                if (NodeFac->m_FoundEntry) {
                    //
                    // If NodeFac->m_FoundEntry is TRUE it means that one of
                    // OpaqueLockToken or LockOwner strings is actually been
                    // found. Even though we came here because we encountered
                    // <a:href> we are not looking for a DisplayName. If we 
                    // come here and NodeFac->m_FoundEntry is FALSE, then we
                    // have to look for the DisplayName.
                    //
                    // XmlDavDbgPrint(("%ld: CreateNode(href). NodeFac->m_CreateNodeAttribute = %d\n",
                    //                GetCurrentThreadId(), NodeFac->m_CreateNodeAttribute));
                    break;
                }
                nextCreateNodeAttribute = CreateNode_DisplayName;
            } else if ( ( tagLength + 1 == (sizeof(rgStatus)/sizeof(WCHAR)) &&
                               _wcsicmp(startTag, rgStatus) == 0 ) ) {
                nextCreateNodeAttribute = CreateNode_Status;
            } else if ( ( tagLength + 1 == (sizeof(rgWin32FileAttributes)/sizeof(WCHAR)) && 
                               _wcsicmp(startTag, rgWin32FileAttributes) == 0 ) ) {
                nextCreateNodeAttribute = CreateNode_Win32FileAttributes;
            } else if ( ( tagLength + 1 == (sizeof(rgWin32CreationTime)/sizeof(WCHAR)) && 
                               _wcsicmp(startTag, rgWin32CreationTime) == 0 ) ) {
                nextCreateNodeAttribute = CreateNode_Win32CreationTime;
            } else if ( ( tagLength + 1 == (sizeof(rgWin32LastAccessTime)/sizeof(WCHAR)) && 
                               _wcsicmp(startTag, rgWin32LastAccessTime) == 0 ) ) {
                nextCreateNodeAttribute = CreateNode_Win32LastAccessTime;
            } else if ( ( tagLength + 1 == (sizeof(rgWin32LastModifiedTime)/sizeof(WCHAR)) && 
                               _wcsicmp(startTag, rgWin32LastModifiedTime) == 0 ) ) {
                nextCreateNodeAttribute = CreateNode_Win32LastModifiedTime;
            } else if ( ( tagLength + 1 == (sizeof(rgAvailableSpace)/sizeof(WCHAR)) && 
                               _wcsicmp(startTag, rgAvailableSpace) == 0 ) ) {
                nextCreateNodeAttribute = CreateNode_AvailableSpace;
            } else if ( ( tagLength + 1 == (sizeof(rgTotalSpace)/sizeof(WCHAR)) && 
                               _wcsicmp(startTag, rgTotalSpace) == 0 ) ) {
                nextCreateNodeAttribute = CreateNode_TotalSpace;
            } else if ( ( tagLength + 1 == (sizeof(rgOwner)/sizeof(WCHAR)) && 
                               _wcsicmp(startTag, rgOwner) == 0 ) ) {
                nextCreateNodeAttribute = CreateNode_Owner;
            } else if ( ( tagLength + 1 == (sizeof(rgTimeout)/sizeof(WCHAR)) && 
                               _wcsicmp(startTag, rgTimeout) == 0 ) ) {
                nextCreateNodeAttribute = CreateNode_Timeout;
            } else if ( ( tagLength + 1 == (sizeof(rgLockToken)/sizeof(WCHAR)) && 
                               _wcsicmp(startTag, rgLockToken) == 0 ) ) {
                nextCreateNodeAttribute = CreateNode_LockToken;
            } else {
                //
                // One CreateNode call can contain only one XML_ELEMENT information
                // and since this element is none of our concerned elements, so
                // we pass this element information downward.
                //
                fPassElement = TRUE;
            }
            
            if(fPassElement == FALSE) {

                // 
                // Control comes here only if we have found an element of our
                // interest.
                //
            
                NodeFac->m_FoundEntry = TRUE;

                //
                // If we have to create a new DavFileAttribute entry, do it now.
                // This entry should be added to the list of this CDavNodeFactory
                // structure.
                //
                if (NodeFac->m_CreateNewEntry) {

                    void *DFA = NULL;
                    
                    DavOverrideAttributes(NodeFac->m_DFAToUse);
                    
                    DFA = LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT, sizeof(DAV_FILE_ATTRIBUTES) );
                    if (DFA == NULL) {
                        ULONG WStatus;
                        WStatus = GetLastError();
                        XmlDavDbgPrint(("%ld: ERROR: CreateNode. LocalAlloc. Error Val = %d\n", 
                                        GetCurrentThreadId(), WStatus));
                        hResult = CO_E_ERRORINAPP;
                        goto EXIT_THE_FUNCTION;
                    }

                    DavFileAttributes = (PDAV_FILE_ATTRIBUTES)DFA;

                    //
                    // m_FileIndex = No of entries for which "<a:response...>" is found 
                    // in response and memory is allocated for its DAV_FILE_ATTRIBUTES
                    // structure. At this point: a new entry is allocated after 
                    // "<a:response...>" is detected in XML response, so increase
                    // m_FileIndex by 1.
                    //
                    NodeFac->m_FileIndex++;

                    //
                    // DavFileAttributes->FileIndex starts from 0, so subtract 1 from total 
                    // number of entries allocated and detected in XML response to get 
                    // FileIndex of that entry.
                    //
                    DavFileAttributes->FileIndex = NodeFac->m_FileIndex - 1;

                    InsertTailList( &(NodeFac->m_DavFileAttributes->NextEntry),
                                    &(DavFileAttributes->NextEntry) );
                
                    NodeFac->m_DFAToUse = DavFileAttributes;

                    NodeFac->m_CreateNewEntry = FALSE;
                
                }

                NodeFac->m_CreateNodeAttribute = nextCreateNodeAttribute;

                // XmlDavDbgPrint(("%ld: CreateNode. NodeFac->m_CreateNodeAttribute = %d\n",
                //                GetCurrentThreadId(), nextCreateNodeAttribute));

                break; // Out of Loop

            } // fPassElement
        
        }

        if (NodeFac->m_FoundEntry) {

            if (NodeFac->m_CreateNodeAttribute != CreateNode_DisplayName) {
                
                //
                // The extra 1 is for the final \0 char.
                //
                LengthInChars = NodeInfo->ulLen + 1;
                
                //XmlDavDbgPrint(("%ld: CreateNode. Element=%d DataLen=%d Data=%ws\n",
                //                    GetCurrentThreadId(), NodeFac->m_CreateNodeAttribute,
                //                    NodeInfo->ulLen, NodeInfo->pwcText));

                //
                // Allocate memory for copying the parsed XML response element.
                //
                Temp = (PWCHAR) LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT, 
                                            (LengthInChars) * sizeof(WCHAR) );
                if (Temp == NULL) {
                    DWORD WStatus = GetLastError();
                    XmlDavDbgPrint(("%ld: ERROR: CreateNode. LocalAlloc failed.GLE=%u\n",
                                    GetCurrentThreadId(), WStatus));
                    hResult = CO_E_ERRORINAPP;
                    goto EXIT_THE_FUNCTION;
                }

                //  
                //  Copy the element. 
                //
                wcsncpy(Temp, NodeInfo->pwcText, NodeInfo->ulLen);
                Temp[LengthInChars-1]=L'\0';

                // XmlDavDbgPrint(("%ld: CreateNode. Temp = %ws, LengthInChars=%d\n", 
                //                            GetCurrentThreadId(), Temp, LengthInChars ));

                switch (NodeFac->m_CreateNodeAttribute) {

                    case CreateNode_isHidden: {
                        NodeFac->m_DFAToUse->isHidden = (BOOL)_wtoi(Temp);
                    }
                    break;

                    case CreateNode_isCollection: {
                        NodeFac->m_DFAToUse->isCollection = (BOOL)_wtoi(Temp);
                    }
                    break;

                    case CreateNode_ContentLength: {
                        *((LONGLONG *)&NodeFac->m_DFAToUse->FileSize) = _wtoi64(Temp);
                    }
                    break;

                    case CreateNode_CreationTime: {
                        ULONG WStatus;
                        WStatus = DavInternetTimeToFileTime(Temp, (FILETIME *)&NodeFac->m_DFAToUse->DavCreationTime);
                        if (WStatus != ERROR_SUCCESS) {
                            XmlDavDbgPrint(("%ld: ERROR: CreateNode. DavInternetTimeToFileTime.\n",
                                            GetCurrentThreadId()));
                            hResult = CO_E_ERRORINAPP;
                            goto EXIT_THE_FUNCTION;
                        }
                    }
                    break;

                    case CreateNode_LastModifiedTime: {
                        DWORD   dwError;
                        dwError = DavInternetTimeToFileTime(Temp, (FILETIME *)&NodeFac->m_DFAToUse->DavLastModifiedTime);
                        if (dwError != ERROR_SUCCESS) {
                            XmlDavDbgPrint(("%ld: ERROR: CreateNode. DavInternetTimeToFileTime\n",
                                            GetCurrentThreadId()));
                            hResult = CO_E_ERRORINAPP;
                            goto EXIT_THE_FUNCTION;
                        }
                    }
                    break;

                    case CreateNode_Status: {
                        NodeFac->m_DFAToUse->Status = Temp;
                        //
                        // Don't free Temp now. This allocation will be freed
                        // when this DavFileAttribute entry gets finalized.
                        //
                        freeTemp = FALSE;
                        //
                        // If the status is not 200 then this node is invalid. The Temp
                        // is of the form "HTTP/1.1 200 OK".
                        //
                        if ( wcslen(Temp) >= 12 ) {
                            if ( Temp[9] != L'2' || Temp[10] != L'0' || Temp[11] != L'0' ) {
                                NodeFac->m_DFAToUse->InvalidNode = TRUE;
                            } else{
                                NodeFac->m_DFAToUse->InvalidNode = FALSE;
                            }
                        } else {
                            NodeFac->m_DFAToUse->InvalidNode = TRUE;
                        }
                    }
                    break;

                    case CreateNode_LockToken: {
                        NodeFac->m_DFAToUse->OpaqueLockToken = Temp;
                        //
                        // Don't free Temp now. This allocation will be freed
                        // when this DavFileAttribute entry gets finalized.
                        //
                        freeTemp = FALSE;
                        // XmlDavDbgPrint(("%ld: CreateNode. OpaqueLockToken = %ws\n", 
                        //                GetCurrentThreadId(), Temp));
                    }
                    break;
                    
                    case CreateNode_Owner: {
                        NodeFac->m_DFAToUse->LockOwner = Temp;
                        //
                        // Don't free Temp now. This allocation will be freed
                        // when this DavFileAttribute entry gets finalized.
                        //
                        freeTemp = FALSE;
                        // XmlDavDbgPrint(("%ld: CreateNode. LockOwner = %ws\n", 
                        //                GetCurrentThreadId(), Temp));
                    }
                    break;

                    case CreateNode_Timeout: {
                        //
                        // The timeout XML element in the repsonse to a LOCK
                        // request has the following format:
                        // <d:timeout>Second-604800</d:timeout>
                        //                   ^
                        //                   |
                        //                   Temp[7]
                        // The timeout value in this example is 604800.
                        //
                        NodeFac->m_DFAToUse->LockTimeout = _wtoi(&Temp[7]);
                        // XmlDavDbgPrint(("%ld: CreateNode. LockTimeout = %d\n", 
                        //                GetCurrentThreadId(), NodeFac->m_DFAToUse->LockTimeout));
                    }
                    break;

                    case CreateNode_Win32FileAttributes : {
                        DWORD dwFileAttributes = 0;
                        swscanf(Temp, L"%x", &(dwFileAttributes));
                        NodeFac->m_DFAToUse->dwFileAttributes |= dwFileAttributes;
                    }
                    break;

                    case CreateNode_Win32CreationTime : {
                        DWORD   dwError;
                        dwError = DavInternetTimeToFileTime(Temp, (FILETIME *)&NodeFac->m_DFAToUse->CreationTime);
                        if (dwError != ERROR_SUCCESS) {
                            XmlDavDbgPrint(("%ld: ERROR: CreateNode. DavInternetTimeToFileTime\n",
                                            GetCurrentThreadId()));
                            hResult = CO_E_ERRORINAPP;
                            goto EXIT_THE_FUNCTION;
                        }
                    
                    }
                    break;
                    
                    case CreateNode_Win32LastAccessTime : {
                        DWORD   dwError;
                        dwError = DavInternetTimeToFileTime(Temp, (FILETIME *)&NodeFac->m_DFAToUse->LastAccessTime);
                        if (dwError != ERROR_SUCCESS) {
                            XmlDavDbgPrint(("%ld: ERROR: CreateNode. DavInternetTimeToFileTime\n",
                                            GetCurrentThreadId()));
                            hResult = CO_E_ERRORINAPP;
                            goto EXIT_THE_FUNCTION;
                        }
                    
                    }
                    break;
                    
                    case CreateNode_Win32LastModifiedTime : {
                        DWORD   dwError;
                        dwError = DavInternetTimeToFileTime(Temp, (FILETIME *)&NodeFac->m_DFAToUse->LastModifiedTime);
                        if (dwError != ERROR_SUCCESS) {
                            XmlDavDbgPrint(("%ld: ERROR: CreateNode. DavInternetTimeToFileTime\n",
                                            GetCurrentThreadId()));
                            hResult = CO_E_ERRORINAPP;
                            goto EXIT_THE_FUNCTION;
                        }
                    
                    }
                    break;

                    case CreateNode_ResourceType : {
                            //
                            // Since data for tag=":resourceType" comes in form
                            // <d:resourcetype><lp0:collection/></d:resourcetype>, so
                            // here Temp[] = "lp0:collection". Since current NodeInfo is for 
                            // tag=<lp0:collection/>, so use namespace-prefix length i.e. 
                            // tagOffset to get Actual-tag(":collection").
                            // 
                            //XmlDavDbgPrint(("%ld:CreateNode. In resourceType. tagLength=%d, Temp=%ws.\n",
                            //                    GetCurrentThreadId(), tagLength, Temp));

                            if((wcslen(L":collection") <= tagLength) && 
                                    (_wcsnicmp(&(Temp[tagOffset]),L":collection",
                                                            wcslen(L":collection")) == 0) )
                                NodeFac->m_DFAToUse->isCollection = TRUE;
                    }
                    break;

                    case CreateNode_AvailableSpace : {
                        NodeFac->m_DFAToUse->fReportsAvailableSpace = TRUE;
                        *((LONGLONG *)&NodeFac->m_DFAToUse->AvailableSpace) = _wtoi64(Temp);
                    }
                    break;
                    
                    case CreateNode_TotalSpace : {
                        *((LONGLONG *)&NodeFac->m_DFAToUse->TotalSpace) = _wtoi64(Temp);
                    }
                    break;

                    default: {
                        XmlDavDbgPrint(("%ld: ERROR: CreateNode. CreateAttribute = %d\n",
                                        GetCurrentThreadId(), NodeFac->m_CreateNodeAttribute));
                    }
                    break;  // Out of switch

                };

                //
                // The information in this CreateNode is extracted. 
                // So we can quit this function now. After this, EndChildren should be
                // called. Since we do not expect more PCDATA to come for current ELEMENT
                // set NodeFac->m_FoundEntry to FALSE - so that our current information 
                // in NodeInfo->m_DFAToUse is not overwritten by following calls of
                // CreateNode for same XML_ELEMENT.
                //

                NodeFac->m_FoundEntry = FALSE;
                break; // Out of Loop

            } else {

                //
                // NodeFac->m_CreateNodeAttribute = CreateNode_DisplayName. Since 
                // DisplayName can span many consecutive CreateNode calls, each call
                // bring part of display name. So here we collect the parts of 
                // displayname coming in each CreateNode call and join them to form
                // complete name. 
                // After all parts are called, this EndChildren will be called. There
                // we process the name to get the actual display name.
                // 

                PDAV_FILE_ATTRIBUTES CurrentDFA = NodeFac->m_DFAToUse;
                BOOL fReAlloc = FALSE;
                DWORD TotalNameLength = NodeInfo->ulLen + 1; // 1 is for ending NULL=L'\0'.
                PWCHAR newFileName = NULL;
                BOOL fCopyInEnd = FALSE;
                DWORD AllocLength = 0;

                // XmlDavDbgPrint(("%ld: CreateNode. InDisplayName FileNameLength=%d FileName=%ws\n", 
                //                    GetCurrentThreadId(), CurrentDFA->FileNameLength, 
                //                    CurrentDFA->FileName?CurrentDFA->FileName : L"NULL"));
                                        
                if (NodeInfo->ulLen == 0) {
                    XmlDavDbgPrint(("%ld: ERROR: CreateNode. Displayname value is NULL, NodeInfo->ulLen = 0\n",
                                    GetCurrentThreadId()));
                    hResult = CO_E_ERRORINAPP;
                    goto EXIT_THE_FUNCTION;
                }

                //
                // If currentDFA has FileName = NULL, then this CreateNode call brings
                // first part of DisplayName. Allocate memory for holding this part.
                // 
                // If CurrentDFA->FileName != NULL, then current CreateNode call has 
                // next-part of the displayname. Check if the buffer allocated for 
                // old-parts is enough to contain new part also. If it is, then 
                // copy new part in the end else allocate new buffer. Copy old-parts
                // to new buffer and then copy new-part in the end of this buffer.
                //
                if (CurrentDFA->FileName != NULL) {
                    TotalNameLength += CurrentDFA->FileNameLength;
                    //XmlDavDbgPrint(("%ld: CreateNode. ReqLen=%d PresentLen=%d\n",
                    //                    GetCurrentThreadId(), TotalNameLength,
                    //               LocalSize((HLOCAL)CurrentDFA->FileName)/sizeof(WCHAR)));
                    if(TotalNameLength > LocalSize((HLOCAL)CurrentDFA->FileName)/sizeof(WCHAR)) {
                        //
                        // Buffer allocated for old-parts is not long enough to
                        // contain new part also. Have to Reallocate new buffer.
                        //
                        fReAlloc = TRUE;
                    } else {
                        //
                        // Buffer allocated for old-parts is long enough to
                        // contain new part also. Copy new-part in the end.
                        //
                        fCopyInEnd = TRUE;
                        fReAlloc = FALSE;
                    }
                } else {
                    fReAlloc = FALSE;
                }


                if (fReAlloc == TRUE) {
                    //
                    // Allocate maximum of {256 , TotalNameLength}. We want to 
                    // allocate more first time to save possibility of re-allocation.
                    // 
                    AllocLength = TotalNameLength > 256 ? TotalNameLength : 256 ;
                    //XmlDavDbgPrint(("%ld: CreateNode. AllocLen=%d\n",
                    //                                GetCurrentThreadId(), AllocLength));
                    newFileName = (PWCHAR)LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT,  
                                                        AllocLength*sizeof(WCHAR));
                    if(newFileName == NULL) {
                        DWORD WStatus = GetLastError();
                        XmlDavDbgPrint(("%ld: ERROR: CreateNode. ReAllocLen = %d. LocalAlloc failed. GLE=%u\n",
                                        GetCurrentThreadId(), AllocLength, WStatus));
                        hResult = CO_E_ERRORINAPP;
                        goto EXIT_THE_FUNCTION;
                    }

                    //  
                    //  Copy the old-parts in the new buffer.
                    //
                    wcsncpy(newFileName,CurrentDFA->FileName, CurrentDFA->FileNameLength);

                    // 
                    // Free buffer allocated for old-parts and point it to new
                    // buffer allocated here.
                    //
                    if(CurrentDFA->FileName) {
                        LocalFree((HLOCAL)CurrentDFA->FileName);
                        CurrentDFA->FileName = NULL;
                    }
                    CurrentDFA->FileName = newFileName;

                    fReAlloc = FALSE;

                    // 
                    // New buffer is allocated with enough length to contain old-parts
                    // with new part. old-parts are copied to the buffer, copy new
                    // part in the end.
                    //
                    fCopyInEnd = TRUE;
                } 
                
                if (fCopyInEnd == FALSE) {
                    
                    //
                    // Allocate maximum of {128 , TotalNameLength}. We want to 
                    // allocate more first time to save possibility of re-allocation.
                    // 
                        
                    AllocLength = TotalNameLength > 128 ? TotalNameLength : 128;
                    //XmlDavDbgPrint(("%ld: CreateNode. AllocLen=%d\n",
                    //                        GetCurrentThreadId(), AllocLength));
                    newFileName = (PWCHAR)LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, 
                                                        AllocLength*sizeof(WCHAR));
                    if(newFileName == NULL) {
                        DWORD WStatus = GetLastError();
                        XmlDavDbgPrint(("%ld: ERROR: CreateNode. AllocLen = %d LocalAlloc failed. GLE=%u\n",
                                        GetCurrentThreadId(), AllocLength, WStatus));
                        hResult = CO_E_ERRORINAPP;
                        goto EXIT_THE_FUNCTION;
                    }

                    //  
                    //  Copy the element. 
                    //
                    wcsncpy(newFileName, NodeInfo->pwcText, NodeInfo->ulLen);

                    newFileName[TotalNameLength - 1] = L'\0';
                    CurrentDFA->FileName = newFileName;
                    CurrentDFA->FileNameLength = NodeInfo->ulLen;
                } 

                if (fCopyInEnd == TRUE) {
                    //  
                    //  Copy the element in the end of the already allocated buffer.
                    //
                    wcsncpy(&(CurrentDFA->FileName[CurrentDFA->FileNameLength]),
                                    NodeInfo->pwcText, NodeInfo->ulLen);
                    
                    CurrentDFA->FileName[TotalNameLength - 1] = L'\0';
                    CurrentDFA->FileNameLength = TotalNameLength - 1;
                    fCopyInEnd = FALSE;
                }


                // 
                // We have updated the DisplayName data in current DFA. Now following
                // calls of CreateNode may contain more data for this field and same
                // XML_ELEMENT.
                // This will continue until EndChildren call is made - where
                // data will be processed to generate filename and NodeFac->m_FoundEntry
                // will be set FALSE.
                // so we quit here WITHOUT setting NodeFac->m_FoundEntry to FALSE.
                // 

                //XmlDavDbgPrint(("%ld. CreateNode. FileName=%ws, FileNameLength=%d\n", 
                //                         GetCurrentThreadId(), CurrentDFA->FileName, 
                //                         CurrentDFA->FileNameLength));
                break; // Out of Loop
            }
        }

    } // end of for loop. 
    

EXIT_THE_FUNCTION:

    // XmlDavDbgPrint(("%ld: CreateNode. Leaving!!!\n", GetCurrentThreadId()));

    if (Temp && freeTemp) {
        LocalFree(Temp);
        Temp = NULL;
    }

    return hResult;
}


ULONG
DavPushData(
    IN PCHAR DataBuff,
    IN OUT PVOID *Context1,
    IN OUT PVOID *Context2,
    IN ULONG NumOfBytes,
    IN BOOL isLast
    )
/*++

Routine Description:

    This routine pushes the XML (response) data received from the server to the
    parser.

Arguments:

    DataBuff - The data to be sent to the parser.
    
    Context1 - The address of the CDavNodefactory object. This gets created
               during the first call to this function. 
    
    Context2 - The address of the IXMLParser. This gets created during the 
               first call to this function. 
    
    NumOfBytes - Number of bytes being sent.
    
    isLast - Is this the last buffer being sent.
        
Return Value:

    ERROR_SUCCESS or ERROR_INVALID_PARAMETER.

--*/
{
    ULONG WStatus = ERROR_SUCCESS;
    HRESULT hResult;
    CDavNodeFactory *NodeFac = (CDavNodeFactory *)*Context1;
    IXMLParser *Xp = (IXMLParser *)*Context2;

    //
    // If this is the first call to push data, we need to associate a 
    // CDavNodeFactory and an XMLParser with it.
    //
    if (NodeFac == NULL) {

        NodeFac = new CDavNodeFactory();
        if (NodeFac == NULL) {
            XmlDavDbgPrint(("%ld: ERROR: DavPushData/new()\n", GetCurrentThreadId()));
            WStatus = ERROR_NO_SYSTEM_RESOURCES;
            goto EXIT_THE_FUNCTION;
        }

        NodeFac->AddRef();
        *Context1 = (PVOID)NodeFac;

        hResult = CoInitializeEx(NULL, COINIT_MULTITHREADED);
        if (!SUCCEEDED(hResult)) {
            XmlDavDbgPrint(("%ld: ERROR: DavPushData/CoInitializeEx: "
                            "hResult = %08lx\n", 
                            GetCurrentThreadId(), hResult));
            goto EXIT_THE_FUNCTION;
        }

        //
        // Call CoCreateInstance again. We should succeed this time.
        //
        hResult = CoCreateInstance(CLSID_XMLParser,
                                   NULL,
                                   CLSCTX_INPROC_SERVER,
                                   IID_IXMLParser,
                                   (void **)&Xp);
        if (!SUCCEEDED(hResult)) {
            XmlDavDbgPrint(("%ld: ERROR: DavPushData/CoCreateInstance: %08lx\n",
                            GetCurrentThreadId(), hResult));
            Xp = NULL;
            goto EXIT_THE_FUNCTION;
        }

        *Context2 = (PVOID)Xp;

        hResult = Xp->SetFactory(NodeFac);
        if (!SUCCEEDED(hResult)) {
            XmlDavDbgPrint(("%ld: ERROR: DavPushData: SetFactory.\n", GetCurrentThreadId()));
            goto EXIT_THE_FUNCTION;
        }

    }

    hResult = Xp->PushData(DataBuff, NumOfBytes, isLast);
    if (!SUCCEEDED(hResult)) {
        XmlDavDbgPrint(("%ld: ERROR: DavPushData: PushData.\n", GetCurrentThreadId()));
        goto EXIT_THE_FUNCTION;
    }

    return WStatus;

EXIT_THE_FUNCTION:

    //
    // Ok, we failed.
    //

    DavCloseContext(*Context1, *Context2);

    //
    // If the WStatus was not sent, then set it to ERROR_INVALID_PARAMETER.
    //
    if (WStatus == ERROR_SUCCESS) {
        WStatus = ERROR_INVALID_PARAMETER;
    }
    
    return WStatus;
}


ULONG
DavParseData(
    IN OUT PDAV_FILE_ATTRIBUTES DavFileAttributes,
    IN PVOID Context1,
    IN PVOID Context2,
    OUT ULONG *NumOfFileEntries
    )
/*++

Routine Description:

    This routine calls the Run function (of the IXMLParser) to parse the XML 
    data that has been sent to the parser.

Arguments:

    DavFileAttributes - The structre wherein the parsed file attributes will
                        be stored.

    Context1 - The address of the CDavNodeFactory API.
    
    Context2 - The address of the IXMLParser interface. 
    
    NumOfFileEntries - Number of dav file attribute entries created during 
                       parsing.

Return Value:

    ERROR_SUCCESS or ERROR_INVALID_PARAMETER.

--*/
{
    ULONG WStatus = ERROR_SUCCESS;
    CDavNodeFactory *NodeFac = (CDavNodeFactory *)Context1;
    IXMLParser *Xp = (IXMLParser *)Context2;
    HRESULT hResult;

    //
    // We enclose the parsing code in a try/except just in case some random
    // server response completely screws us. In such a case, we catch the 
    // exception here and return ERROR_INVALID_PARAMETER to the caller. This
    // is also here to catch the STACK_OVERFLOW exception that can be thrown
    // under low memory conditions.
    //

    __try {

        NodeFac->m_DavFileAttributes = DavFileAttributes;

        NodeFac->m_DFAToUse = DavFileAttributes;

        // 
        // m_FileIndex = No of entries for which "<a:response...>" is found in
        // XML response and memory is allocated for its DAV_FILE_ATTRIBUTES
        // structure. Right now - first entry is allocated by caller of this
        // function but no "<a:response...>" is detected yet in response - so
        // NodeInfo->m_FileIndex = 0.
        // 

        DavFileAttributes->FileIndex = NodeFac->m_FileIndex = 0;

        //
        // Call Run to parse the XML data sent.
        //
        hResult = Xp->Run(-1);
        if (!SUCCEEDED(hResult)) {
            XmlDavDbgPrint(("%ld: ERROR: DavParseData/Run: hResult = %08lx\n", 
                            GetCurrentThreadId(), hResult));
            goto EXIT_THE_FUNCTION;
        }

        //
        // We need to call this function for the last node that got created. This
        // is done becuase the DavOverrideAttributes in the CreateNode function
        // above does not cover the last node.
        //
        DavOverrideAttributes(NodeFac->m_DFAToUse);
   
        *NumOfFileEntries = NodeFac->m_FileIndex;

    } __except (1) {

          XmlDavDbgPrint(("%ld: ERROR: DavParseData: ExceptionCode = %d\n", 
                          GetCurrentThreadId(), GetExceptionCode()));

          goto EXIT_THE_FUNCTION;

    }

    return WStatus;

EXIT_THE_FUNCTION:

    DavCloseContext(Context1, Context2);

    WStatus = ERROR_INVALID_PARAMETER;
    
    return WStatus;
}


ULONG
DavParseDataEx(
    IN OUT PDAV_FILE_ATTRIBUTES DavFileAttributes,
    IN PVOID Context1,
    IN PVOID Context2,
    OUT ULONG *NumOfFileEntries,
    OUT DAV_FILE_ATTRIBUTES ** pCollectionDFA
    )
/*++

Routine Description:

    This routine calls the Run function (of the IXMLParser) to parse the XML 
    data that has been sent to the parser. In addition to calling DavParseData(...)
    it returns the pointer to parent DAV collection resource being returned in XML response.

Arguments:

    DavFileAttributes - The structre wherein the parsed file attributes will
                        be stored.

    Context1 - The address of the CDavNodeFactory API.
    
    Context2 - The address of the IXMLParser interface. 
    
    NumOfFileEntries - Number of dav file attribute entries created during 
                       parsing.
    
    pCollectionDFA - This pointer will set to DavFileAttribute that corresponds to 
                    the DAV resource which has smallest Full-DisplayName (that comes in
                    "<a:href>Full-DisplayName</a:href>") in the response. If
                    XML response contains the properties of the parent DAV collection then
                    its entry should be the entry with smallest Full-DisplayName.

Return Value:

    ERROR_SUCCESS or ERROR_INVALID_PARAMETER.

--*/
{
    ULONG WStatus = ERROR_SUCCESS;
    CDavNodeFactory *NodeFac = (CDavNodeFactory *)Context1;
    
    if (pCollectionDFA != NULL) {
        *pCollectionDFA = NULL;
    }
    
    //
    // Call DavParseData(...) to parse the XML data sent.
    //
    WStatus = DavParseData(DavFileAttributes, Context1, Context2, NumOfFileEntries);
    if (WStatus != ERROR_SUCCESS) {
        XmlDavDbgPrint(("%ld: ERROR: DavParseDataEx/Run: WStatus = %08lx\n", 
                        GetCurrentThreadId(), WStatus));
        goto EXIT_THE_FUNCTION;
    }

    //
    // Store location of DAV collection DFA in pCollectionDFA.
    // 
    if (pCollectionDFA != NULL) {
        *pCollectionDFA = NodeFac->m_CollectionDFA;
    }

    return WStatus;

EXIT_THE_FUNCTION:

    return WStatus;
}


VOID
DavCloseContext(
    PVOID Context1,
    PVOID Context2
    )
/*++

Routine Description:

    This routine closes the XML parser and the CDavNodeFactory object.

Arguments:

    Context1 - The address of the CDavNodeFactory API.
    
    Context2 - The address of the IXMLParser interface. 

Return Value:

    none.

--*/
{
    CDavNodeFactory *NodeFac = (CDavNodeFactory *)Context1;
    IXMLParser *Xp = (IXMLParser *)Context2;

    if (NodeFac != NULL) {
        NodeFac->Release();
    }

    if (Xp != NULL) {
        Xp->Release();
    }

    //
    // This is to balance the CoInitializeEx call in the DavPushData function.
    //
    CoUninitialize();

    return;
}


VOID
DavFinalizeFileAttributesList(
    PDAV_FILE_ATTRIBUTES DavFileAttributes,
    BOOL fFreeHeadDFA
    )
/*++

Routine Description:

    This routine finalizes (frees) a DavFileAttributes list.

Arguments:

    DavFileAttributes - The DavFileAttributes list to be finalized.

Return Value:

    none.

--*/
{
    PDAV_FILE_ATTRIBUTES TempDFA;
    PLIST_ENTRY listEntry, backEntry;

    //
    // If there is nothing to finalize then we return.
    //
    if (DavFileAttributes == NULL) {
        return;
    }

    TempDFA = DavFileAttributes;

    listEntry = TempDFA->NextEntry.Flink;

    //
    // Travel the list and free the resources allocated.
    //
    while ((listEntry != NULL) &&  (listEntry != &(DavFileAttributes->NextEntry)) ) {

        TempDFA = CONTAINING_RECORD(listEntry,
                                    DAV_FILE_ATTRIBUTES,
                                    NextEntry);

        backEntry = listEntry;

        listEntry = listEntry->Flink;

        RemoveEntryList(backEntry);

        //
        // Free the Status string that was allocated while parsing.
        //
        if (TempDFA->Status) {
            LocalFree((HLOCAL)TempDFA->Status);
            TempDFA->Status = NULL;
        }

        //
        // Free the filename that was allocated while parsing.
        //
        if (TempDFA->FileName) {
            LocalFree((HLOCAL)TempDFA->FileName);
            TempDFA->FileName = NULL;
        }

        //
        // Free the LockOwner string that was allocated while parsing.
        //
        if (TempDFA->LockOwner) {
            LocalFree((HLOCAL)TempDFA->LockOwner);
            TempDFA->LockOwner = NULL;
        }

        //
        // Free the OpaqueLockToken string that was allocated while parsing.
        //
        if (TempDFA->OpaqueLockToken) {
            LocalFree((HLOCAL)TempDFA->OpaqueLockToken);
            TempDFA->OpaqueLockToken = NULL;
        }

        //
        // Free the DavFileAttributes entry.
        //
        LocalFree((HLOCAL)TempDFA);
        TempDFA = NULL;
    }

    //
    // Need to free the first entry.
    //
    
    if (DavFileAttributes->Status) {
        LocalFree((HLOCAL)DavFileAttributes->Status);
        DavFileAttributes->Status = NULL;
    }

    if (DavFileAttributes->FileName) {
        LocalFree((HLOCAL)DavFileAttributes->FileName);
        DavFileAttributes->FileName = NULL;
    }

    if (DavFileAttributes->LockOwner) {
        LocalFree((HLOCAL)DavFileAttributes->LockOwner);
        DavFileAttributes->LockOwner = NULL;
    }
    
    if (DavFileAttributes->OpaqueLockToken) {
        LocalFree((HLOCAL)DavFileAttributes->OpaqueLockToken);
        DavFileAttributes->OpaqueLockToken = NULL;
    }
    
    if (fFreeHeadDFA == TRUE) {
        LocalFree((HLOCAL)DavFileAttributes);
        DavFileAttributes = NULL;
    }
    
    return;
}


DWORD
DavInternetTimeToFileTime(
    PWCHAR lpTimeString,
    FILETIME *lpft
    )
{
    SYSTEMTIME  sSystemTime;
    DWORD   dwError = ERROR_SUCCESS;
        
    if (!InternetTimeToSystemTimeW(lpTimeString, &sSystemTime, 0))
    {
        
        dwError =  GetLastError();
        if (dwError == ERROR_INVALID_PARAMETER)
        {
            dwError = DavParsedateTimetzTimeString(lpTimeString, (PLARGE_INTEGER)lpft);
        }
    }
    else
    {
        SystemTimeToFileTime(&sSystemTime, lpft);
    }
    
    return dwError;
}

ULONG
DavParsedateTimetzTimeString(
    PWCHAR TimeString,
    LARGE_INTEGER *lpFileTime
    )
/*++

Routine Description:

    This routine parses a string in the dateTime.tz time format. It then sets 
    the last modified time attribute in the file attributes structure of the 
    node factory object.  

Arguments:

    TimeString - The string that needs to be parsed.

    lpFileTime - Time to get    

Return Value:

    ERROR_SUCESS or the appropriate Win32 error code.

--*/
{
    ULONG WStatus = ERROR_SUCCESS;
    PWCHAR Head = NULL, Cp = NULL, Tail = NULL;
    TIME_FIELDS TimeFields;
    BOOL ReturnVal = FALSE;
    DWORD TimeStrLen = 0;
    WCHAR EndCharSet[]=L".+-zZ";
    WCHAR OffsetCharSet[]=L"+-zZ";
    WCHAR LastChar;

    ZeroMemory(&TimeFields, sizeof(TIME_FIELDS));

    //
    // Head->1999-03-17T00:46:24.557Z
    //                               ^
    //                               |
    //                               Tail
    //
    Head = TimeString;
    Tail = (PWCHAR)(Head + wcslen(Head));

    // XmlDavDbgPrint(("%ld: DavParsedateTimetzTimeString: TimeString = %ws.\n", 
    //                 GetCurrentThreadId(), TimeString));

    //
    // The string can be of the format "1999-03-17T00:46:24.557Z"
    // The string can be of the format "1999-03-17T00:46:24Z"
    // The string can be of the format "1999-03-17T00:46:24.557+12:02" - Ignored for now
    // The string can be of the format "1999-03-17T00:46:24.557-12:02" - Ignored for now
    // The string can be of the format "1999-03-17T00:46:24+12:02" - Ignored for now
    // The string can be of the format "1999-03-17T00:46:24-12:02" - Ignored for now
    //

    //
    // Head->1999-03-17T00:46:24.557Z
    //           ^
    //           |
    //           Cp
    //
    Cp = Head + 4;

    //
    // Head->"1999"03-17T00:46:24.557Z -- Head now points to the year.
    //            ^
    //            |
    //            Cp
    //
    
    if ((Cp > Tail) || (Cp[0] != L'-')) {
        goto bailout;
    }
    LastChar = Cp[0];
    *Cp = L'\0';

    TimeFields.Year = (short)_wtoi(Head);
    // XmlDavDbgPrint(("%ld: DavParsedateTimetzTimeString: Year = %d.\n", 
    //                 GetCurrentThreadId(), TimeFields.Year));

    //
    // Head->03-17T00:46:24.557Z
    //       ^
    //       |
    //       Cp
    //
    Cp++;
    Head = Cp;

    //
    // Head->03-17T00:46:24.557Z
    //         ^
    //         |
    //         Cp
    //
    Cp = Head + 2;

    //
    // Head->"03"17T00:46:24.557Z -- Head now points to the month.
    //          ^
    //          |
    //          Cp
    //
    if ((Cp > Tail) || (Cp[0] != L'-')) {
        goto bailout;
    }
    LastChar = Cp[0];
    *Cp = L'\0';

    TimeFields.Month = (short)_wtoi(Head);
    // XmlDavDbgPrint(("%ld: DavParsedateTimetzTimeString: Month = %d.\n", 
    //                 GetCurrentThreadId(), TimeFields.Month));

    //
    // Head->17T00:46:24.557Z
    //       ^
    //       |
    //       Cp
    //
    Cp++;
    Head = Cp;

    //
    // Head->17T00:46:24.557Z
    //         ^
    //         |
    //         Cp
    //
    Cp = Head + 2;

    //
    // Head->"17"00:46:24.557Z -- Head now points to the day.
    //          ^
    //          |
    //          Cp
    //
    if ((Cp > Tail) || (Cp[0] != L'T')) {
        goto bailout;
    }
    LastChar = Cp[0];
    *Cp = L'\0';

    TimeFields.Day = (short)_wtoi(Head);
    // XmlDavDbgPrint(("%ld: DavParsedateTimetzTimeString: Day = %d.\n", 
    //                 GetCurrentThreadId(), TimeFields.Day));

    //
    // Head->00:46:24.557Z
    //       ^
    //       |
    //       Cp
    //
    Cp++;
    Head = Cp;

    //
    // Head->00:46:24.557Z
    //         ^
    //         |
    //         Cp
    //
    Cp = Head + 2;

    //
    // Head->"00"46:24.557Z -- Head now points to the hour.
    //          ^
    //          |
    //          Cp
    //
    if ((Cp > Tail) || (Cp[0] != L':')) {
        goto bailout;
    }
    LastChar = Cp[0];
    *Cp = L'\0';

    TimeFields.Hour = (short)_wtoi(Head);
    // XmlDavDbgPrint(("%ld: DavParsedateTimetzTimeString: Hour = %d.\n", 
    //                 GetCurrentThreadId(), TimeFields.Hour));

    //
    // Head->46:24.557Z
    //       ^
    //       |
    //       Cp
    //
    Cp++;
    Head = Cp;

    //
    // Head->46:24.557Z
    //         ^
    //         |
    //         Cp
    //
    Cp = Head + 2;

    //
    // Head->"46"24.557Z -- Head now points to the minute.
    //          ^
    //          |
    //          Cp
    //
    if ((Cp > Tail) || (Cp[0] != L':')) {
        goto bailout;
    }
    LastChar = Cp[0];
    *Cp = L'\0';

    TimeFields.Minute = (short)_wtoi(Head);
    // XmlDavDbgPrint(("%ld: DavParsedateTimetzTimeString: Minute = %d.\n", 
    //                 GetCurrentThreadId(), TimeFields.Minute));

    //
    // Head->24.557Z
    //       ^
    //       |
    //       Cp
    //
    Cp++;
    Head = Cp;

    //
    // Head->24.557Z
    //         ^
    //         |
    //         Cp
    //
    Cp = Head + 2;

    //
    // Head->"24"557Z -- Head now points to the second.
    //          ^
    //          |
    //          Cp = {.,z,Z,+,-}
    //
    if ((Cp > Tail) || (wcspbrk(Cp,EndCharSet) != Cp)) {
        goto bailout;
    }
    LastChar = Cp[0];
    *Cp = L'\0';

    TimeFields.Second = (short)_wtoi(Head);
    // XmlDavDbgPrint(("%ld: DavParsedateTimetzTimeString: Seconds = %d.\n", 
    //                 GetCurrentThreadId(), TimeFields.Second));


    if(LastChar == L'.') {
        //
        // Head->557Z
        //       ^
        //       |
        //       Cp
        //
        Cp++;
        Head = Cp;
        while(Cp < Tail && Cp[0] >= L'0' && Cp[0] <= L'9')
           Cp++;
        if(Cp == Head || wcspbrk(Cp,OffsetCharSet) != Cp) {
           goto bailout;
        }
        //
        // Head->"557" -- Head now points to the Milliseconds.
        //           ^
        //           |
        //           Cp = {z,Z,+,-}
        //
        LastChar = Cp[0];
        Cp[0] = L'\0';
        TimeFields.Milliseconds = (short)_wtoi(Head);
        // XmlDavDbgPrint(("%ld: DavParsedateTimetzTimeString: Milliseconds = %d.\n", 
        //                 GetCurrentThreadId(), TimeFields.Milliseconds));
    }

    //
    // Head->"+DD:DD" or "-DD:DD" or "Z" or "z".
    //        ^
    //        |
    //        Cp = {z,Z,+,-}
    //
    if(LastChar == L'+' || LastChar == L'-') {
        //
        // Head->"+DD:DD" or "-DD:DD" -- Head now points to the Milliseconds.
        //        ^
        //        |
        //        Cp = {+,-}
        //
        // BUGBUG - Ignoring time zone adjustment settings for now
        //
    }


    //
    // We have set the time fields structure. Now its time to get the time 
    // value as a LARGE_INTEGER and store it in DavFileAttributes. The time
    // we need to set could either be the creation time or the last modified 
    // time.
    //
    ReturnVal = RtlTimeFieldsToTime(&TimeFields, lpFileTime);
bailout:    
    if (!ReturnVal) {
        XmlDavDbgPrint(("%ld: ERROR: DavParsedateTimetzTimeString/RtlTimeFieldsToTime.\n",
                        GetCurrentThreadId()));
        WStatus = ERROR_INVALID_PARAMETER;
     }

    // XmlDavDbgPrint(("%ld: DavParsedateTimetzTimeString: LastModifiedTime = %d, %d.\n",
    //                 GetCurrentThreadId(),
    //                 DavFileAttributes->CreationTime.HighPart,
    //                 DavFileAttributes->CreationTime.LowPart));

    return WStatus;
}


#if 0
ULONG
DavParseRfc1123TimeString(
    PWCHAR TimeString,
    PDAV_FILE_ATTRIBUTES DavFileAttributes,
    CREATE_NODE_ATTRIBUTES CreateNodeAttribute
    )
/*++

Routine Description:

    This routine parses a string in the RFC 1123 time format. It then sets the 
    last modified time attribute in the file attributes structure of the 
    node factory object.  

Arguments:

    TimeString - The string that needs to be parsed.
    
    DavFileAttributes - The Dav File attributes structure which contains the
                        Time Value to be set.
    
    CreateNodeAttribute - Could be either CreateNode_CreationTime_rfc1123 or
                          CreateNode_LastModifiedTime_rfc1123.                        

Return Value:

    ERROR_SUCESS or the appropriate Win32 error code.

--*/
{
    ULONG WStatus = ERROR_SUCCESS;
    PWCHAR Head, Cp;
    TIME_FIELDS TimeFields;
    BOOL ReturnVal;

    Head = TimeString;

    // XmlDavDbgPrint(("%ld: DavParseRfc1123TimeString: TimeString = %ws.\n", 
    //                 GetCurrentThreadId(), TimeString));


    //
    // The string is of the format "Tue, 06 Apr 1999 00:10:40\nGMT"
    //

    //
    // Head->Tue, 06 Apr 1999 00:10:40\nGMT
    //          ^
    //          |
    //          Cp
    //
    Cp = wcschr(Head, L',');

    //
    // Head->"Tue" 06 Apr 1999 00:10:40\nGMT -- Head points to weekday string.
    //           ^
    //           |
    //           Cp
    //
    *Cp = L'\0';

    if ( _wcsicmp(Head, L"Sun") == 0 ) {
        TimeFields.Weekday = 0;
    } else if( _wcsicmp(Head, L"Mon") == 0 ) {
        TimeFields.Weekday = 1;
    } else if( _wcsicmp(Head, L"Tue") == 0 ) {
        TimeFields.Weekday = 2;
    } else if( _wcsicmp(Head, L"Wed") == 0 ) {
        TimeFields.Weekday = 3;
    } else if( _wcsicmp(Head, L"Thu") == 0 ) {
        TimeFields.Weekday = 4;
    } else if( _wcsicmp(Head, L"Fri") == 0 ) {
        TimeFields.Weekday = 5;
    } else if( _wcsicmp(Head, L"Sat") == 0 ) {
        TimeFields.Weekday = 6;
    } else {
        XmlDavDbgPrint(("%ld: ERROR: DavParseRfc1123TimeString: WeekDay = %ws.\n", Head));
        WStatus = ERROR_INVALID_PARAMETER;
        return WStatus;
    }
    // XmlDavDbgPrint(("%ld: DavParseRfc1123TimeString: WeekDay = %d.\n", 
    //                 GetCurrentThreadId(), TimeFields.Weekday));
    
    //
    // Head->06 Apr 1999 00:10:40\nGMT
    //       ^
    //       |
    //       Cp
    //
    Cp++;
    Cp++;
    Head = Cp;

    //
    // Head->06 Apr 1999 00:10:40\nGMT
    //         ^
    //         |
    //         Cp
    //
    Cp = wcschr(Head, L' ');

    //
    // Head->"06"Apr 1999 00:10:40\nGMT -- Head points to Day string.
    //          ^
    //          |
    //          Cp
    //
    *Cp = L'\0';

    TimeFields.Day = (short)_wtoi(Head);
    // XmlDavDbgPrint(("%ld: DavParseRfc1123TimeString: Day = %d.\n", 
    //                 GetCurrentThreadId(), TimeFields.Day));

    //
    // Head->Apr 1999 00:10:40\nGMT
    //       ^
    //       |
    //       Cp
    //
    Cp++;
    Head = Cp;

    //
    // Head->Apr 1999 00:10:40\nGMT
    //          ^
    //          |
    //          Cp
    //
    Cp = wcschr(Head, L' ');

    //
    // Head->"Apr"1999 00:10:40\nGMT -- Head now points ti the month string.
    //           ^
    //           |
    //           Cp
    //
    *Cp = L'\0';

    if ( _wcsicmp(Head, L"Jan") == 0 ) {
        TimeFields.Month = 1;
    } else if( _wcsicmp(Head, L"Feb") == 0 ) {
        TimeFields.Month = 2;
    } else if( _wcsicmp(Head, L"Mar") == 0 ) {
        TimeFields.Month = 3;
    } else if( _wcsicmp(Head, L"Apr") == 0 ) {
        TimeFields.Month = 4;
    } else if( _wcsicmp(Head, L"May") == 0 ) {
        TimeFields.Month = 5;
    } else if( _wcsicmp(Head, L"Jun") == 0 ) {
        TimeFields.Month = 6;
    } else if( _wcsicmp(Head, L"Jul") == 0 ) {
        TimeFields.Month = 7;
    } else if( _wcsicmp(Head, L"Aug") == 0 ) {
        TimeFields.Month = 8;
    } else if( _wcsicmp(Head, L"Sep") == 0 ) {
        TimeFields.Month = 9;
    } else if( _wcsicmp(Head, L"Oct") == 0 ) {
        TimeFields.Month = 10;
    } else if( _wcsicmp(Head, L"Nov") == 0 ) {
        TimeFields.Month = 11;
    } else if( _wcsicmp(Head, L"Dec") == 0 ) {
        TimeFields.Month = 12;
    } else {
        XmlDavDbgPrint(("%ld: ERROR: DavParseRfc1123TimeString: Month = %ws.\n", Head));
        WStatus = ERROR_INVALID_PARAMETER;
        return WStatus;
    }
    // XmlDavDbgPrint(("%ld: DavParseRfc1123TimeString: Month = %d.\n", 
    //                 GetCurrentThreadId(), TimeFields.Month));

    //
    // Head->1999 00:10:40\nGMT
    //       ^
    //       |
    //       Cp
    //
    Cp++;
    Head = Cp;

    //
    // Head->1999 00:10:40\nGMT
    //           ^
    //           |
    //           Cp
    //
    Cp = wcschr(Head, L' ');

    //
    // Head->"1999"00:10:40\nGMT -- Head now points to the year string.
    //            ^
    //            |
    //            Cp
    //
    *Cp = L'\0';

    TimeFields.Year = (short)_wtoi(Head);
    // XmlDavDbgPrint(("%ld: DavParseRfc1123TimeString: Year = %d.\n", 
    //                 GetCurrentThreadId(), TimeFields.Year));

    //
    // Head->00:10:40\nGMT
    //       ^
    //       |
    //       Cp
    //
    Cp++;
    Head = Cp;

    //
    // Head->00:10:40\nGMT
    //         ^
    //         |
    //         Cp
    //
    Cp = wcschr(Head, L':');

    //
    // Head->"00"10:40\nGMT -- Head now points to the hour string.
    //          ^
    //          |
    //          Cp
    //
    *Cp = L'\0';

    TimeFields.Hour = (short)_wtoi(Head);
    // XmlDavDbgPrint(("%ld: DavParseRfc1123TimeString: Hour = %d.\n", 
    //                 GetCurrentThreadId(), TimeFields.Hour));

    //
    // Head->10:40\nGMT
    //       ^
    //       |
    //       Cp
    //
    Cp++;
    Head = Cp;

    //
    // Head->10:40\nGMT
    //         ^
    //         |
    //         Cp
    //
    Cp = wcschr(Head, L':');

    //
    // Head->"10"40\nGMT -- Head now points to the minute string.
    //          ^
    //          |
    //          Cp
    //
    *Cp = L'\0';

    TimeFields.Minute = (short)_wtoi(Head);
    // XmlDavDbgPrint(("%ld: DavParseRfc1123TimeString: Minute = %d.\n", 
    //                 GetCurrentThreadId(), TimeFields.Minute));

    //
    // Head->40\nGMT
    //       ^
    //       |
    //       Cp
    //
    Cp++;
    Head = Cp;

    //
    // Head->40\nGMT
    //         ^
    //         |
    //         Cp
    //
    Cp = wcschr(Head, L' ');

    //
    // Head->"40"GMT -- Head now points to the seconds string.
    //          ^
    //          |
    //          Cp
    //
    *Cp = L'\0';

    TimeFields.Second = (short)_wtoi(Head);
    // XmlDavDbgPrint(("%ld: DavParseRfc1123TimeString: Second = %d.\n", 
    //                 GetCurrentThreadId(), TimeFields.Second));

    //
    // Since we don't know the millisec value, we set it to zero.
    //
    TimeFields.Milliseconds = 0;
    // XmlDavDbgPrint(("%ld: DavParseRfc1123TimeString: MilliSec = %d.\n", 
    //                 GetCurrentThreadId(), TimeFields.Milliseconds));

    //
    // We have set the time fields structure. Now its time to get the time 
    // value as a LARGE_INTEGER and store it in DavFileAttributes. The time
    // we need to set could either be the creation time or the last modified 
    // time.
    //
    if (CreateNodeAttribute == CreateNode_LastModifiedTime_rfc1123) {
        ReturnVal = RtlTimeFieldsToTime(&(TimeFields), 
                                        &(DavFileAttributes->LastModifiedTime));
    } else {
        ReturnVal = RtlTimeFieldsToTime(&(TimeFields), 
                                        &(DavFileAttributes->CreationTime));
    }
    
    if (!ReturnVal) {
        XmlDavDbgPrint(("%ld: ERROR: DavParseRfc1123TimeString/RtlTimeFieldsToTime.\n"));
        WStatus = ERROR_INVALID_PARAMETER;
     }

    // XmlDavDbgPrint(("%ld: DavParseRfc1123TimeString: LastModifiedTime = %d, %d.\n",
    //                 GetCurrentThreadId(),
    //                 DavFileAttributes->LastModifiedTime.HighPart,
    //                 DavFileAttributes->LastModifiedTime.LowPart));

    return WStatus;
}

#endif

VOID
DavOverrideAttributes(
    PDAV_FILE_ATTRIBUTES pDavFileAttributes
    )
/*++

Routine Description:

    If win32 timestamps are not set, then set them with DAV timestamps

Arguments:

    DavFileAttributes - The Dav File attributes structure which contains the
                        Time Values
    

Return Value:

    None

--*/
{
    if (!pDavFileAttributes->CreationTime.HighPart)
    {
        pDavFileAttributes->CreationTime = pDavFileAttributes->DavCreationTime;
    }
    if (!pDavFileAttributes->LastModifiedTime.HighPart)
    {
        pDavFileAttributes->LastModifiedTime = pDavFileAttributes->DavLastModifiedTime;
    }
    if (pDavFileAttributes->isCollection)
    {
        pDavFileAttributes->dwFileAttributes |= FILE_ATTRIBUTE_DIRECTORY;
    }
    else
    {
        pDavFileAttributes->dwFileAttributes &= ~FILE_ATTRIBUTE_DIRECTORY;
    
    }
    if (!(pDavFileAttributes->dwFileAttributes & FILE_ATTRIBUTE_HIDDEN))
    {
        if (pDavFileAttributes->isHidden)
        {
            pDavFileAttributes->dwFileAttributes |= FILE_ATTRIBUTE_HIDDEN;
        }
        else
        {
            pDavFileAttributes->dwFileAttributes &= ~FILE_ATTRIBUTE_HIDDEN;
        }    
    }


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\server\main.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    main.c

Abstract:

    This is the main entry point for the service control manager for the web
    dav mini-redir service.

Author:

    Rohan Kumar        [RohanK]        08-Feb-2000

Environment:

    User Mode - Win32

Revision History:

--*/

#include "pch.h"
#pragma hdrstop

#include <ntumrefl.h>
#include <usrmddav.h>
#include <svcs.h>

//
// Allocate global data in this file.
//
#define GLOBAL_DATA_ALLOCATE
#include "global.h"

DWORD DavStop = 0;

//
// The amount of time in seconds a server entry is cached in the ServerNotFound
// cache.
//
ULONG ServerNotFoundCacheLifeTimeInSec = 0;

//
// Should we accept/claim the OfficeWebServers and TahoeWebServers?
//
ULONG AcceptOfficeAndTahoeServers = 0;

//
// Should we LOCK (using the DAV LOCK Verb) the file on the server on the
// CreateFile path when needed? To know when exactly a LOCK is sent to the
// server, look at the (LOCKing) comments in the davcreat.c file.
//
ULONG DavSupportLockingOfFiles = 1;

PSVCHOST_GLOBAL_DATA DavSvcsGlobalData;

DWORD
DavNotRunningAsAService(
    VOID
    );

DWORD 
WINAPI
DavFakeServiceController(
    LPVOID Parameter
    );

BOOL
DavCheckLUIDDeviceMapsEnabled(
    VOID
    );

VOID
DavReadRegistryValues(
    VOID
    );

VOID
WINAPI
DavServiceHandler (
    DWORD dwOpcode
    )
/*++

Routine Description:

    This function is called by the Service Controller at various times when the
    service is running.

Arguments:

    dwOpcode - Reason for calling the service handler.

Return Value:

    none.

--*/
{
    DWORD err;
    switch (dwOpcode) {

    case SERVICE_CONTROL_SHUTDOWN:

        //
        // Lack of break is intentional!
        //

    case SERVICE_CONTROL_STOP:
        
        DavPrint((DEBUG_INIT, "DavServiceHandler: WebClient service is stopping.\n"));
        
        UpdateServiceStatus(SERVICE_STOP_PENDING);
        
        if (g_WorkersActive) {
            err = DavTerminateWorkerThreads();
            if (err != ERROR_SUCCESS) {
                DavPrint((DEBUG_ERRORS,
                          "DavServiceMain/DavTerminateWorkerThreads: "
                          "Error Val = %u.\n", err));
            }
            g_WorkersActive = FALSE;
        }

        if (g_RpcActive) {
            DavSvcsGlobalData->StopRpcServer(davclntrpc_ServerIfHandle);
            g_RpcActive = FALSE;
        }

        //
        // Close and free up the DAV stuff.
        //
        DavClose();

        if (g_socketinit) {
            err = CleanupTheSocketInterface();
            if (err != ERROR_SUCCESS) {
                DavPrint((DEBUG_ERRORS,
                          "DavServiceMain/CleanupTheSocketInterface: "
                          "Error Val = %u.\n", err));
            }
            g_socketinit = FALSE;
        }

        if (DavReflectorHandle != NULL) {
            err = UMReflectorStop(DavReflectorHandle);
            if (err != ERROR_SUCCESS) {
                DavPrint((DEBUG_ERRORS,
                          "DavServiceMain/UMReflectorStop: Error Val = %u.\n", err));
            }
            err = UMReflectorUnregister(DavReflectorHandle);
            if (err != ERROR_SUCCESS) {
                DavPrint((DEBUG_ERRORS,
                          "DavServiceMain/UMReflectorUnregister: Error Val = 0x%x.\n", err));
            }
            DavReflectorHandle = NULL;
        }

        if (g_RedirLoaded) {
            err = WsUnloadRedir();
            if (err != ERROR_SUCCESS) {
                DavPrint((DEBUG_ERRORS,
                          "DavServiceMain/WsUnloadRedir: Error Val = %u.\n", err));
            }
            g_RedirLoaded = FALSE;
        }

        if (g_DavServiceLockSet) {
            DeleteCriticalSection ( &(g_DavServiceLock) );
            g_DavServiceLockSet = FALSE;
        }

        DavPrint((DEBUG_INIT, "DavServiceMain: WebClient service is stopped.\n"));

        UpdateServiceStatus(SERVICE_STOPPED);

#if DBG
        DebugUninitialize();
#endif

        break;

     case SERVICE_CONTROL_INTERROGATE:

         //
         // Refresh our status to the SCM.
         //
         SetServiceStatus(g_hStatus, &g_status);

         break;

    default:

        //
        // This may not be needed, but refresh our status to the service
        // controller.
        //
        DavPrint((DEBUG_INIT, "DavServiceHandler: WebClient service received SCM "
                  "Opcode = %08lx\n", dwOpcode));

        ASSERT (g_hStatus);

        SetServiceStatus (g_hStatus, &g_status);

        break;

    }

    return;
}

VOID
SvchostPushServiceGlobals(
    PSVCHOST_GLOBAL_DATA    pGlobals
    )
{
    DavSvcsGlobalData = pGlobals;
}

VOID
WINAPI
ServiceMain (
    DWORD dwNumServicesArgs,
    LPWSTR *lpServiceArgVectors
    )
/*++

Routine Description:

    This function is called by the Service Control Manager when starting this 
    service.

Arguments:

    dwNumServicesArgs - Number of arguments.
    
    lpServiceArgVectors - Array of arguments.

Return Value:

    None.

--*/
{
    DWORD err = ERROR_SUCCESS;
    DWORD exitErr = ERROR_SUCCESS;
    HKEY KeyHandle = NULL;
    ULONG maxThreads = 0, initialThreads = 0, RedirRegisterCount = 0;
    BOOL RunningAsAService = TRUE;

#if DBG
    DebugInitialize();
#endif

    DavReadRegistryValues();

    //
    // Make sure svchost.exe gave us the global data
    //
    ASSERT(DavSvcsGlobalData != NULL);
    
#if DBG
    {
        DWORD cbP = 0;
        WCHAR m_szProfilePath[MAX_PATH];
        cbP = GetEnvironmentVariable(L"USERPROFILE", m_szProfilePath, MAX_PATH);
        m_szProfilePath[cbP] = L'\0';
        DavPrint((DEBUG_MISC, "DavServiceMain: USERPROFILE: %ws\n", m_szProfilePath));
    }
#endif

    g_RedirLoaded = FALSE;
    
    g_WorkersActive = FALSE;
    
    g_registeredService = FALSE;

    //
    // Initialize the SERVICE_STATUS structure g_status.
    //
    ZeroMemory (&g_status, sizeof(g_status));
    
    g_status.dwServiceType = SERVICE_WIN32_OWN_PROCESS;

    g_status.dwControlsAccepted = (SERVICE_ACCEPT_STOP | SERVICE_CONTROL_SHUTDOWN);

    g_status.dwCheckPoint = 1;

    g_status.dwWaitHint = DAV_WAIT_HINT_TIME;

    DavPrint((DEBUG_MISC, 
              "DavServiceMain: lpServiceArgVectors[0] = %ws\n", lpServiceArgVectors[0]));
    
    if ( lpServiceArgVectors[0] && 
         ( wcscmp(lpServiceArgVectors[0], L"notservice") == 0 ) ) {

        DavPrint((DEBUG_MISC, "DavServiceMain: WebClient is not running as a Service.\n"));

    } else {

        DavPrint((DEBUG_MISC, "DavServiceMain: WebClient is running as a Service.\n"));

        try {
            InitializeCriticalSection ( &(g_DavServiceLock) );
        } except(EXCEPTION_EXECUTE_HANDLER) {
              err = GetExceptionCode();
              DavPrint((DEBUG_ERRORS,
                        "DavServiceMain/InitializeCriticalSection: Exception Code ="
                        " = %08lx.\n", err));
              goto exitServiceMain;
        }

        g_DavServiceLockSet = TRUE;

        //
        // Register the service control handler.
        //
        g_hStatus = RegisterServiceCtrlHandler(SERVICE_DAVCLIENT, DavServiceHandler);
        if (g_hStatus) {
            g_registeredService = TRUE;
            DavPrint((DEBUG_INIT, "DavServiceMain: WebClient service is pending start.\n"));
        } else {
            DavPrint((DEBUG_INIT, "DavServiceMain: WebClient service failed to register.\n"));
            goto exitServiceMain;
        }
    }

    UpdateServiceStatus(SERVICE_START_PENDING);

    //
    // Attempt to load the mini-redir driver.  If this fails, no point in us
    // starting up.
    //
    while (TRUE) {
    
        err = WsLoadRedir();
        if (err == ERROR_SERVICE_ALREADY_RUNNING || err == ERROR_SUCCESS) {
            DavPrint((DEBUG_MISC, "DavServiceMain/WsLoadRedir. Succeeded\n"));
            break;
        }

        //
        // If the transports are not ready, the MiniRedir returns an
        // error STATUS_REDIRECTOR_NOT_STARTED which maps to the Win32 error
        // ERROR_PATH_NOT_FOUND. In this case we sleep for 3 seconds and try 
        // again with the hope that the transports will be ready soon. Also,
        // we update the service status to inform the SCM that we are doing
        // some work. We try this 5 times (till RedirRegisterCount == 4) and 
        // if are unsuccessful, we give up.
        //
        if (err == ERROR_PATH_NOT_FOUND) {
        
            RedirRegisterCount++;

            DavPrint((DEBUG_ERRORS,
                      "DavServiceMain/WsLoadRedir. RedirRegisterCount = %d\n",
                      RedirRegisterCount));

            if (RedirRegisterCount >= 4) {
                DavPrint((DEBUG_ERRORS,
                          "DavServiceMain/WsLoadRedir(1). Error Val = %d\n",
                          err));
                goto exitServiceMain;
            }

            //
            // Sleep for 3 seconds.
            //
            Sleep(3000);

            (g_status.dwCheckPoint)++;
            UpdateServiceStatus(SERVICE_START_PENDING);

            continue;

        } else {
            DavPrint((DEBUG_ERRORS,
                      "DavServiceMain/WsLoadRedir(2). Error Val = %d\n",
                      err));
            goto exitServiceMain;
        }

    }

    g_RedirLoaded = TRUE;

    (g_status.dwCheckPoint)++;
    UpdateServiceStatus(SERVICE_START_PENDING);

    //
    // Initialize the global NT-style redirector device name string.
    //
    RtlInitUnicodeString(&RedirDeviceName, DD_DAV_DEVICE_NAME_U);

    //
    // Try to register the mini-redir.
    //
    err = UMReflectorRegister(DD_DAV_DEVICE_NAME_U,
                              UMREFLECTOR_CURRENT_VERSION,
                              &(DavReflectorHandle));
    if ((DavReflectorHandle == NULL) || (err != ERROR_SUCCESS)) {
        if (err == ERROR_SUCCESS) {
            err = ERROR_BAD_DRIVER;
        }
        DavPrint((DEBUG_ERRORS,
                  "DavServiceMain/UMReflectorRegister. Error Val = %d\n",
                  err));
        goto exitServiceMain;
    }

    (g_status.dwCheckPoint)++;
    UpdateServiceStatus(SERVICE_START_PENDING);

    //
    // Try to start the mini-redir.
    //
    err = UMReflectorStart(UMREFLECTOR_CURRENT_VERSION, DavReflectorHandle);
    if (err != ERROR_SUCCESS) {
        DavPrint((DEBUG_ERRORS,
                  "DavServiceMain/UMReflectorStart. Error Val = %u.\n", err));
        goto exitServiceMain;
    }

    (g_status.dwCheckPoint)++;
    UpdateServiceStatus(SERVICE_START_PENDING);
    
    //
    // Initialize the socket interface.
    //
    err = InitializeTheSocketInterface();
    if (err != ERROR_SUCCESS) {
        DavPrint((DEBUG_ERRORS,
                  "DavServiceMain/InitializeTheSocketInterface: Error Val = %u.\n", err));
        goto exitServiceMain;
    }

    //
    // Setup the DAV/WinInet environment.
    //
    err = DavInit();
    if (err != ERROR_SUCCESS) {
        DavPrint((DEBUG_ERRORS,
                  "DavServiceMain/DavInit: Error Val = %u.\n", err));
        goto exitServiceMain;
    }

    //
    // Start the worker thread.  This will handle completion routines queued
    // from other worker threads and from the request ioctl threads.
    //
    err = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                       DAV_PARAMETERS_KEY,
                       0,
                       KEY_QUERY_VALUE,
                       &KeyHandle);
    if (err == ERROR_SUCCESS) {
        maxThreads = ReadDWord(KeyHandle,
                               DAV_MAXTHREADS_KEY,
                               DAV_MAXTHREADCOUNT_DEFAULT);
        initialThreads = ReadDWord(KeyHandle,
                                   DAV_THREADS_KEY,
                                   DAV_THREADCOUNT_DEFAULT);
        RegCloseKey(KeyHandle);
    } else {
        maxThreads = DAV_MAXTHREADCOUNT_DEFAULT;
        initialThreads = DAV_THREADCOUNT_DEFAULT;
    }

    (g_status.dwCheckPoint)++;
    UpdateServiceStatus(SERVICE_START_PENDING);
    
    err = DavInitWorkerThreads(initialThreads, maxThreads);
    if (err != ERROR_SUCCESS) {
        DavPrint((DEBUG_ERRORS,
                  "DavServiceMain/DavInitWorkerThread: Error Val = %u.\n", err));
        goto exitServiceMain;
    }

    g_WorkersActive = TRUE;

    (g_status.dwCheckPoint)++;
    UpdateServiceStatus(SERVICE_START_PENDING);

    g_LUIDDeviceMapsEnabled = DavCheckLUIDDeviceMapsEnabled();

    //
    // Immediately report that we are running.  All non-essential initialization
    // is deferred until we are called by clients to do some work.
    //
    DavPrint((DEBUG_INIT, "DavServiceMain: WebClient service is now running.\n"));
    
    (g_status.dwCheckPoint)++;
    UpdateServiceStatus(SERVICE_START_PENDING);

    //
    // Setup RPC server for this service.
    //
    if (!g_RpcActive) {
        err = DavSvcsGlobalData->StartRpcServer(L"DAV RPC SERVICE",
                                                davclntrpc_ServerIfHandle);
        if (err == STATUS_SUCCESS) {
            g_RpcActive = TRUE;
        } else {
            DavPrint((DEBUG_ERRORS,
                      "DavServiceMain/SetupRpcServer: Error Val = %u.\n", err));
        }
    }

    UpdateServiceStatus(SERVICE_RUNNING);
    
    return;

exitServiceMain:

    if (g_WorkersActive) {
        exitErr = DavTerminateWorkerThreads();
        if (exitErr != ERROR_SUCCESS) {
            DavPrint((DEBUG_ERRORS,
                      "DavServiceMain/DavTerminateWorkerThreads: "
                      "Error Val = %u.\n", exitErr));
        }
        g_WorkersActive = FALSE;
    }

    //
    // Close and free up the DAV stuff.
    //
    DavClose();

    if (g_socketinit) {
        exitErr = CleanupTheSocketInterface();
        if (exitErr != ERROR_SUCCESS) {
            DavPrint((DEBUG_ERRORS,
                      "DavServiceMain/CleanupTheSocketInterface: "
                      "Error Val = %u.\n", exitErr));
        }
        g_socketinit = FALSE;
    }

    if (g_RpcActive) {
        DavSvcsGlobalData->StopRpcServer(davclntrpc_ServerIfHandle);
        g_RpcActive = FALSE;
    }

    if (DavReflectorHandle != NULL) {
        exitErr = UMReflectorStop(DavReflectorHandle);
        if (exitErr != ERROR_SUCCESS) {
            DavPrint((DEBUG_ERRORS,
                      "DavServiceMain/UMReflectorStop: Error Val = %u.\n", exitErr));
        }
        exitErr = UMReflectorUnregister(DavReflectorHandle);
        if (exitErr != ERROR_SUCCESS) {
            DavPrint((DEBUG_ERRORS,
                      "DavServiceMain/UMReflectorUnregister: Error Val = 0x%x.\n", exitErr));
        }
        DavReflectorHandle = NULL;
    }

    if (g_RedirLoaded) {
        exitErr = WsUnloadRedir();
        if (exitErr != ERROR_SUCCESS) {
            DavPrint((DEBUG_ERRORS,
                      "DavServiceMain/WsUnloadRedir: Error Val = %u.\n", exitErr));
        }
        g_RedirLoaded = FALSE;
    }

    if (g_DavServiceLockSet) {
        DeleteCriticalSection ( &(g_DavServiceLock) );
        g_DavServiceLockSet = FALSE;
    }

    //
    // Let the SCM know why the service did not start.
    //
    if (err != NO_ERROR) {
        g_status.dwWin32ExitCode = err;
        g_status.dwServiceSpecificExitCode = NO_ERROR;
        UpdateServiceStatus(SERVICE_STOPPED);
    }

    DavPrint((DEBUG_INIT, "DavServiceMain: WebClient service is stopped.\n"));

#if DBG
    DebugUninitialize();
#endif

    return;
}


DWORD
DavNotRunningAsAService(
    VOID
    )
/*++

Routine Description:
    
    The DavClient is not being run as a Service.

Arguments:
    
    None.

Return Value:
    
    ERROR_SUCCESS - No problems.
    
    Win32 Error Code - Something went wrong.

--*/
{
    DWORD WStatus = ERROR_SUCCESS;
    HANDLE Thread;
    DWORD  ThreadId;
    PWCHAR NotSrv = L"notservice";
    
    //
    // Create a thread for the fake service controller.
    //
    Thread = CreateThread( NULL, 0, DavFakeServiceController, 0, 0, &ThreadId );
    if (Thread == NULL) {
        WStatus = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavNotRunningAsAService/CreateThread: Error Val = %d.\n", WStatus));
        return WStatus;
    }

    //
    // Call the Sevice Main function of the DavClient service.
    //
    ServiceMain( 2, &(NotSrv) );
    
    return WStatus;
}


DWORD 
WINAPI
DavFakeServiceController(
    LPVOID Parameter
    )
/*++

Routine Description:
    
    The Fake service control for the DavClient when it is not running as a 
    service. This is used to send a STOP signal to the DavClient. 

Arguments:
    
    Parameter - Dummy parameter.

Return Value:
    
    ERROR_SUCCESS - No problems.
    
--*/
{
    while (DavStop == 0) {
        Sleep(1000);
    }

    DavServiceHandler( SERVICE_CONTROL_STOP );

    return 0;
}

BOOL
DavCheckLUIDDeviceMapsEnabled(
    VOID
    )

/*++

Routine Description:

    This function calls NtQueryInformationProcess() to determine if
    LUID device maps are enabled


Arguments:

    none

Return Value:

    TRUE - LUID device maps are enabled

    FALSE - LUID device maps are disabled

--*/

{

    NTSTATUS   Status;
    ULONG      LUIDDeviceMapsEnabled;
    BOOL       Result;

    Status = NtQueryInformationProcess( NtCurrentProcess(),
                                        ProcessLUIDDeviceMapsEnabled,
                                        &LUIDDeviceMapsEnabled,
                                        sizeof(LUIDDeviceMapsEnabled),
                                        NULL
                                      );

    if (!NT_SUCCESS( Status )) {
        Result = FALSE;
    }
    else {
        Result = (LUIDDeviceMapsEnabled != 0);
    }

    return( Result );
}


VOID
_cdecl
main (
    IN INT ArgC,
    IN PCHAR ArgV[]
    )
/*++

Routine Description:
    
    Main (DavClient) runs as either a service or an exe.

Arguments:
    
    ArgC - Number of arguments.
    
    ArgV - Array of arguments.

Return Value:
    
    ERROR_SUCCESS - No problems.
    
    Win32 Error Code - Something went wrong.

--*/
{

    BOOL RunningAsAService = TRUE;
    BOOL ReturnVal = FALSE;
    SERVICE_TABLE_ENTRYW DavServiceTableEntry[] = { 
                                                    { SERVICE_DAVCLIENT, ServiceMain },
                                                    { NULL,              NULL }
                                                  };

    //
    // Are we running as a service or an exe ?
    //
    if ( ArgV[1] != NULL ) {
        if ( strstr(ArgV[1], "notservice") != NULL) {
            RunningAsAService = FALSE;
        }
    }

    if (RunningAsAService) {

        ReturnVal = StartServiceCtrlDispatcher(DavServiceTableEntry);
        if ( !ReturnVal ) {
            DavPrint((DEBUG_ERRORS,
                      "main/StartServiceCtrlDispatcher: Error Val = %d.\n", 
                      GetLastError()));
        }

    } else {

        DWORD WStatus;

        WStatus = DavNotRunningAsAService();
        if ( WStatus != ERROR_SUCCESS ) {
            DavPrint((DEBUG_ERRORS,
                      "main/DavNotRunningAsAService: Error Val = %d.\n", 
                      WStatus));
        }

    }

    return;
}


VOID
DavReadRegistryValues(
    VOID
    )
/*++

Routine Description:
    
    This function reads some values from the registry and sets the globals in
    the WebClient service.

Arguments:
    
    None.

Return Value:
    
    None.

--*/
{
    ULONG WStatus = ERROR_SUCCESS;
    HKEY KeyHandle = NULL;
    ULONG ValueType = 0, ValueSize = 0;

    WStatus = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                            DAV_PARAMETERS_KEY,
                            0,
                            KEY_QUERY_VALUE,
                            &(KeyHandle));
    if (WStatus != ERROR_SUCCESS) {
        KeyHandle = NULL;
        ServerNotFoundCacheLifeTimeInSec = 60;
        AcceptOfficeAndTahoeServers = 0;
        WStatus = GetLastError();
        DbgPrint("ERROR: DavReadRegistryValues/RegOpenKeyExW. WStatus = %d\n", WStatus);
        goto EXIT_THE_FUNCTION;
    }

    //
    // If we fail in getting the values from the registry, set them to default
    // values.
    //
    
    ValueSize = sizeof(ServerNotFoundCacheLifeTimeInSec);

    WStatus = RegQueryValueExW(KeyHandle,
                               DAV_SERV_CACHE_VALUE,
                               0,
                               &(ValueType),
                               (LPBYTE)&(ServerNotFoundCacheLifeTimeInSec),
                               &(ValueSize));
    if (WStatus != ERROR_SUCCESS) {
        ServerNotFoundCacheLifeTimeInSec = 60;
        WStatus = GetLastError();
        DbgPrint("ERROR: DavReadRegistryValues/RegQueryValueExW(1). WStatus = %d\n", WStatus);
    }

    ValueSize = sizeof(AcceptOfficeAndTahoeServers);
    
    WStatus = RegQueryValueExW(KeyHandle,
                               DAV_ACCEPT_TAHOE_OFFICE_SERVERS,
                               0,
                               &(ValueType),
                               (LPBYTE)&(AcceptOfficeAndTahoeServers),
                               &(ValueSize));
    if (WStatus != ERROR_SUCCESS) {
        AcceptOfficeAndTahoeServers = 0;
        WStatus = GetLastError();
        DbgPrint("ERROR: DavReadRegistryValues/RegQueryValueExW(2). WStatus = %d\n", WStatus);
    }

    ValueSize = sizeof(DavSupportLockingOfFiles);
    
    WStatus = RegQueryValueExW(KeyHandle,
                               DAV_SUPPORT_LOCKING_OF_FILES,
                               0,
                               &(ValueType),
                               (LPBYTE)&(DavSupportLockingOfFiles),
                               &(ValueSize));
    if (WStatus != ERROR_SUCCESS) {
        DavSupportLockingOfFiles = 1;
        WStatus = GetLastError();
        DbgPrint("ERROR: DavReadRegistryValues/RegQueryValueExW(3). WStatus = %d\n", WStatus);
    }

    ValueSize = sizeof(DavFileSizeLimitInBytes);
    
    WStatus = RegQueryValueExW(KeyHandle,
                               DAV_FILE_SIZE_LIMIT,
                               0,
                               &(ValueType),
                               (LPBYTE)&(DavFileSizeLimitInBytes),
                               &(ValueSize));
    if (WStatus != ERROR_SUCCESS) {
        DavFileSizeLimitInBytes = 0x2faf080;
        WStatus = GetLastError();
        DbgPrint("ERROR: DavReadRegistryValues/RegQueryValueExW(4). WStatus = %d\n", WStatus);
    }

    ValueSize = sizeof(DavFileAttributesLimitInBytes);
    
    WStatus = RegQueryValueExW(KeyHandle,
                               DAV_ATTRIBUTES_SIZE_LIMIT,
                               0,
                               &(ValueType),
                               (LPBYTE)&(DavFileAttributesLimitInBytes),
                               &(ValueSize));
    if (WStatus != ERROR_SUCCESS) {
        DavFileAttributesLimitInBytes = 0xf4240;
        WStatus = GetLastError();
        DbgPrint("ERROR: DavReadRegistryValues/RegQueryValueExW(5). WStatus = %d\n", WStatus);
    }

EXIT_THE_FUNCTION:

    if (KeyHandle) {
        RegCloseKey(KeyHandle);
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\server\rename.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    rename.c
    
Abstract:

    This module implements the user mode DAV miniredir routine(s) pertaining to 
    the ReName call.

Author:

    Rohan Kumar      [RohanK]      20-Jan-2000

Revision History:

--*/

#include "pch.h"
#pragma hdrstop

#include "ntumrefl.h"
#include "usrmddav.h"
#include "global.h"
#include "UniUtf.h"
#include "nodefac.h"

VOID
DavAsyncSetFileInformationCompletion(
    PDAV_USERMODE_WORKITEM DavWorkItem
    );


ULONG
DavFsReName(
    PDAV_USERMODE_WORKITEM DavWorkItem
)
/*++

Routine Description:

    This routine handles ReName requests for the DAV Mini-Redir that get 
    reflected from the kernel.

Arguments:

    DavWorkItem - The buffer that contains the request parameters and options.

Return Value:

    The return status for the operation

--*/
{
    ULONG WStatus = ERROR_SUCCESS;
    PDAV_USERMODE_RENAME_REQUEST DavReNameRequest = NULL;
    PWCHAR ServerName = NULL, OldPathName = NULL, NewPathName = NULL;
    PWCHAR UtfServerName = NULL, UtfNewPathName = NULL;
    ULONG UtfServerNameLength = 0, UtfNewPathNameLength = 0;
    PWCHAR UrlBuffer = NULL, HeaderBuff = NULL, CanName = NULL;
    ULONG HeaderLength = 0, HeaderLengthInBytes = 0;
    ULONG_PTR CallBackContext = (ULONG_PTR)0;
    BOOL EnCriSec = FALSE, ReturnVal, CallBackContextInitialized = FALSE;
    ULONG ServerID = 0, urlLength = 0, TagLen = 0, convLen = 0;
    PPER_USER_ENTRY PerUserEntry = NULL;
    PHASH_SERVER_ENTRY ServerHashEntry = NULL;
    HINTERNET DavConnHandle = NULL, DavOpenHandle = NULL;
    URL_COMPONENTSW UrlComponents;
    BOOL didImpersonate = FALSE, BStatus = FALSE;
    PUMRX_USERMODE_WORKITEM_HEADER UserWorkItem = NULL;

    //
    // Get the request buffer pointer from the DavWorkItem.
    //
    DavReNameRequest = &(DavWorkItem->ReNameRequest);

    //
    // The first character is a '\' which has to be stripped from the 
    // ServerName.
    //
    ServerName = &(DavReNameRequest->ServerName[1]);
    if ( !ServerName && ServerName[0] != L'\0' ) {
        DavPrint((DEBUG_ERRORS, "DavFsReName: ServerName is NULL.\n"));
        WStatus = ERROR_INVALID_PARAMETER; // STATUS_INVALID_PARAMETER;
        goto EXIT_THE_FUNCTION;
    }
    DavPrint((DEBUG_MISC, "DavFsReName: ServerName = %ws.\n", ServerName));

    ServerID = DavReNameRequest->ServerID;
    DavPrint((DEBUG_MISC, "DavFsReName: ServerID = %d.\n", ServerID));

    //
    // The first character is a '\' which has to be stripped from the 
    // OldPathName.
    //
    OldPathName = &(DavReNameRequest->OldPathName[1]);
    if ( !OldPathName ) {
        DavPrint((DEBUG_ERRORS, "DavFsReName: OldPathName is NULL.\n"));
        WStatus = ERROR_INVALID_PARAMETER; // STATUS_INVALID_PARAMETER;
        goto EXIT_THE_FUNCTION;
    }
    
    //
    // The file name can contain \ characters. Replace them by / characters.
    //
    CanName = OldPathName;
    while (*CanName) {
        if (*CanName == L'\\') {
            *CanName = L'/';
        }
        CanName++;
    }
    
    DavPrint((DEBUG_MISC, "DavFsReName: OldPathName = %ws.\n", OldPathName));

    //
    // The first character is a '\' which has to be stripped from the 
    // NewPathName.
    //
    NewPathName = &(DavReNameRequest->NewPathName[1]);
    if ( !NewPathName ) {
        DavPrint((DEBUG_ERRORS, "DavFsReName: NewPathName is NULL.\n"));
        WStatus = ERROR_INVALID_PARAMETER; // STATUS_INVALID_PARAMETER;
        goto EXIT_THE_FUNCTION;
    }
    
    //
    // The file name can contain \ characters. Replace them by / characters.
    //
    CanName = NewPathName;
    while (*CanName) {
        if (*CanName == L'\\') {
            *CanName = L'/';
        }
        CanName++;
    }

    DavPrint((DEBUG_MISC, "DavFsReName: NewPathName = %ws.\n", NewPathName));
    
    UserWorkItem = (PUMRX_USERMODE_WORKITEM_HEADER)DavWorkItem;
    
    //
    // If we are using WinInet synchronously, then we need to impersonate the
    // clients context now.
    //
#ifndef DAV_USE_WININET_ASYNCHRONOUSLY
    
    WStatus = UMReflectorImpersonate(UserWorkItem, DavWorkItem->ImpersonationHandle);
    if (WStatus != ERROR_SUCCESS) {
        DavPrint((DEBUG_ERRORS,
                  "DavFsReName/UMReflectorImpersonate. Error Val = %d\n",
                  WStatus));
        goto EXIT_THE_FUNCTION;
    }
    didImpersonate = TRUE;

#endif
    
    //
    // If we have a dummy share name in the OldPathName and the NewPathName, we
    // need to remove it right now before we contact the server.
    //
    DavRemoveDummyShareFromFileName(OldPathName);
    DavRemoveDummyShareFromFileName(NewPathName);

    //
    // We need to convert the ServerName and the NewPathName into the UTF-8
    // format before we call into the InternetCreateUrlW function. This is
    // because if the localized Unicode characters are passed into this
    // function it converts them into ?. For example all the chinese unicode
    // characters will be converted into ?s.
    //

    UtfServerNameLength = WideStrToUtfUrlStr(ServerName, (wcslen(ServerName) + 1), NULL, 0);
    if (GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
        WStatus = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavFsReName/WideStrToUtfUrlStr(1). Error Val = %d\n", WStatus));
        goto EXIT_THE_FUNCTION;
    }

    UtfServerName = LocalAlloc(LPTR, UtfServerNameLength * sizeof(WCHAR));
    if (UtfServerName == NULL) {
        WStatus = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavFsReName/LocalAlloc. Error Val = %d\n", WStatus));
        goto EXIT_THE_FUNCTION;
    }
    
    UtfServerNameLength = WideStrToUtfUrlStr(ServerName, (wcslen(ServerName) + 1), UtfServerName, UtfServerNameLength);
    if (GetLastError() != ERROR_SUCCESS) {
        WStatus = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavFsReName/WideStrToUtfUrlStr(2). Error Val = %d\n", WStatus));
        goto EXIT_THE_FUNCTION;
    }

    UtfNewPathNameLength = WideStrToUtfUrlStr(NewPathName, (wcslen(NewPathName) + 1), NULL, 0);
    if (GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
        WStatus = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavFsReName/WideStrToUtfUrlStr(3). Error Val = %d\n", WStatus));
        goto EXIT_THE_FUNCTION;
    }

    UtfNewPathName = LocalAlloc(LPTR, UtfNewPathNameLength * sizeof(WCHAR));
    if (UtfNewPathName == NULL) {
        WStatus = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavFsReName/LocalAlloc. Error Val = %d\n", WStatus));
        goto EXIT_THE_FUNCTION;
    }

    UtfNewPathNameLength = WideStrToUtfUrlStr(NewPathName, (wcslen(NewPathName) + 1), UtfNewPathName, UtfNewPathNameLength);
    if (GetLastError() != ERROR_SUCCESS) {
        WStatus = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavFsReName/WideStrToUtfUrlStr(4). Error Val = %d\n", WStatus));
        goto EXIT_THE_FUNCTION;
    }

    //
    // Create the URL with the NewPathName to be sent to the server. Initialize 
    // the UrlComponents structure before making the call.
    //
    UrlComponents.dwStructSize = sizeof(URL_COMPONENTSW);
    UrlComponents.lpszScheme = NULL;
    UrlComponents.dwSchemeLength = 0;
    UrlComponents.nScheme = INTERNET_SCHEME_HTTP;
    UrlComponents.lpszHostName = UtfServerName;
    UrlComponents.dwHostNameLength = wcslen(UtfServerName); 
    UrlComponents.nPort = DEFAULT_HTTP_PORT;
    UrlComponents.lpszUserName = NULL;
    UrlComponents.dwUserNameLength = 0;
    UrlComponents.lpszPassword = NULL;
    UrlComponents.dwPasswordLength = 0;
    UrlComponents.lpszUrlPath = UtfNewPathName;
    UrlComponents.dwUrlPathLength = wcslen(UtfNewPathName);
    UrlComponents.lpszExtraInfo = NULL;
    UrlComponents.dwExtraInfoLength = 0;
    ReturnVal = InternetCreateUrlW(&(UrlComponents),
                                   0,
                                   NULL,
                                   &(urlLength));
    if (!ReturnVal) {
        
        ULONG urlLengthInWChars = 0;
        
        WStatus = GetLastError();
        
        if (WStatus == ERROR_INSUFFICIENT_BUFFER) {
            
            UrlBuffer = (PWCHAR) LocalAlloc (LMEM_FIXED | LMEM_ZEROINIT, 
                                              urlLength);
            if (UrlBuffer != NULL) {
                
                ZeroMemory(UrlBuffer, urlLength);
                
                urlLengthInWChars = ( urlLength/sizeof(WCHAR) );
                
                ReturnVal = InternetCreateUrlW(&(UrlComponents),
                                               0,
                                               UrlBuffer,
                                               &(urlLengthInWChars));
                if (!ReturnVal) {
                    
                    WStatus = GetLastError();
                    
                    DavPrint((DEBUG_ERRORS,
                              "DavFsReName/InternetCreateUrl. Error Val = %d\n",
                              WStatus));
                    
                    goto EXIT_THE_FUNCTION;

                }

            } else {

                WStatus = GetLastError();
                
                DavPrint((DEBUG_ERRORS,
                          "DavFsReName/LocalAlloc. Error Val = %d\n", WStatus));
                
                goto EXIT_THE_FUNCTION;
            
            }

        } else {

            DavPrint((DEBUG_ERRORS,
                      "DavFsReName/InternetCreateUrl. Error Val = %d\n",
                      WStatus));
            
            goto EXIT_THE_FUNCTION;

        }

    }

    DavPrint((DEBUG_MISC, "DavFsReName: URL: %ws\n", UrlBuffer));

    //
    // We now need to create the Destination header that we will add to the
    // request to be sent to the server. This header has the following format.
    // "Destination: URL"
    //

    TagLen = wcslen(L"Destination: ");
    convLen = wcslen(UrlBuffer);
    HeaderLength = TagLen + convLen;
    HeaderLengthInBytes = ( (1 + HeaderLength) * sizeof(WCHAR) );
    HeaderBuff = (PWCHAR) LocalAlloc(LPTR, HeaderLengthInBytes);
    if (HeaderBuff == NULL) {
        WStatus = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavFsReName/LocalAlloc. Error Val = %d\n", WStatus));
        goto EXIT_THE_FUNCTION;
    }

    wcscpy(HeaderBuff, L"Destination: ");
    wcscpy(&(HeaderBuff[TagLen]), UrlBuffer);

    DavWorkItem->AsyncReName.HeaderBuff = HeaderBuff;

    DavPrint((DEBUG_MISC, "DavFsReName: HeaderBuff: %ws\n", HeaderBuff));

    //
    // We need to call this only if "DAV_USE_WININET_ASYNCHRONOUSLY" has been
    // defined. Otherwise, if we are using WinInet synchronously, then we 
    // would have already done this in the DavWorkerThread function. This 
    // ultimately gets deleted (the impersonation token that is) in the 
    // DavAsyncCreateCompletion function.
    //
#ifdef DAV_USE_WININET_ASYNCHRONOUSLY

    //
    // Set the DavCallBackContext.
    //
    WStatus = DavFsSetTheDavCallBackContext(DavWorkItem);
    if (WStatus != ERROR_SUCCESS) {
        DavPrint((DEBUG_ERRORS,
                  "DavFsReName/DavFsSetTheDavCallBackContext. Error Val = %d\n",
                  WStatus));
        goto EXIT_THE_FUNCTION;
    }
    CallBackContextInitialized = TRUE;

    //
    // Store the address of the DavWorkItem which serves as a callback in the 
    // variable CallBackContext. This will now be used in all the async calls
    // that follow.
    //
    CallBackContext = (ULONG_PTR)(DavWorkItem);

#endif

    //
    // Allocate memory for the INTERNET_ASYNC_RESULT structure.
    //
    DavWorkItem->AsyncResult = LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, 
                                          sizeof(INTERNET_ASYNC_RESULT));
    if (DavWorkItem->AsyncResult == NULL) {
        WStatus = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavFsReName/LocalAlloc. Error Val = %d\n", WStatus));
        goto EXIT_THE_FUNCTION;
    }

    //
    // A User Entry for this user must have been created during the create call
    // earlier. The user entry contains the handle used to send an HttpOpen
    // request.
    //

    EnterCriticalSection( &(HashServerEntryTableLock) );
    EnCriSec = TRUE;

    ReturnVal = DavDoesUserEntryExist(ServerName,
                                      ServerID, 
                                      &(DavReNameRequest->LogonID),
                                      &PerUserEntry,
                                      &ServerHashEntry);
    
    //
    // If the following request in the kernel get cancelled even before the 
    // corresponding usermode thread gets a chance to execute this code, then
    // it possible that the VNetRoot (hence the PerUserEntry) and SrvCall get
    // finalized before the thread that is handling the create comes here. This
    // could happen if this request was the only one for this share and the
    // server as well. This is why we need to check if the ServerHashEntry and
    // the PerUserEntry are valid before proceeding.
    //
    if (ReturnVal == FALSE || ServerHashEntry == NULL || PerUserEntry == NULL) {
        WStatus = ERROR_CANCELLED;
        DavPrint((DEBUG_ERRORS, "DavFsReName: (ServerHashEntry == NULL || PerUserEntry == NULL)\n"));
        goto EXIT_THE_FUNCTION;
    }

    DavWorkItem->AsyncReName.ServerHashEntry = ServerHashEntry;

    DavWorkItem->AsyncReName.PerUserEntry = PerUserEntry;

    //
    // Add a reference to the user entry.
    //
    PerUserEntry->UserEntryRefCount++;

    //
    // Since a create had succeeded earlier, the entry must be good.
    //
    ASSERT(PerUserEntry->UserEntryState == UserEntryInitialized);
    ASSERT(PerUserEntry->DavConnHandle != NULL);
    DavConnHandle = PerUserEntry->DavConnHandle;

    //
    // And yes, we obviously have to leave the critical section
    // before returning.
    //
    LeaveCriticalSection( &(HashServerEntryTableLock) );
    EnCriSec = FALSE;
    
    //
    // We now call the HttpOpenRequest function and return.
    //
    DavWorkItem->DavOperation = DAV_CALLBACK_HTTP_OPEN;

    //
    // Convert the unicode directory path to UTF-8 URL format.
    // Space and other white characters will remain untouched - these should
    // be taken care of by wininet calls.
    //
    BStatus = DavHttpOpenRequestW(DavConnHandle,
                                  L"MOVE",
                                  OldPathName,
                                  L"HTTP/1.1",
                                  NULL,
                                  NULL,
                                  INTERNET_FLAG_KEEP_CONNECTION |
                                  INTERNET_FLAG_NO_COOKIES,
                                  CallBackContext,
                                  L"DavFsReName",
                                  &DavOpenHandle);
    if(BStatus == FALSE) {
        WStatus = GetLastError();
        goto EXIT_THE_FUNCTION;
    }
    if (DavOpenHandle == NULL) {
        WStatus = GetLastError();
        if (WStatus != ERROR_IO_PENDING) {
            DavPrint((DEBUG_ERRORS,
                      "DavFsReName/HttpOpenRequest. Error Val = %d\n", 
                      WStatus));
        }
        goto EXIT_THE_FUNCTION;
    }

    //
    // Cache the DavOpenHandle in the DavWorkItem.
    //
    DavWorkItem->AsyncReName.DavOpenHandle = DavOpenHandle;

    WStatus = DavAsyncCommonStates(DavWorkItem, FALSE);
    if (WStatus != ERROR_SUCCESS && WStatus != ERROR_IO_PENDING) {
        DavPrint((DEBUG_ERRORS,
                  "DavFsReName/DavAsyncCommonStates. Error Val = %08lx\n",
                  WStatus));
    }

EXIT_THE_FUNCTION: // Do the necessary cleanup and return.

    //
    // We could have taken the lock and come down an error path without 
    // releasing it. If thats the case, then we need to release the lock now.
    //
    if (EnCriSec) {
        LeaveCriticalSection( &(HashServerEntryTableLock) );
        EnCriSec = FALSE;
    }
    
    if (UrlBuffer != NULL) {
        HLOCAL FreeHandle;
        ULONG FreeStatus;
        FreeHandle = LocalFree((HLOCAL)UrlBuffer);
        if (FreeHandle != NULL) {
            FreeStatus = GetLastError();
            DavPrint((DEBUG_ERRORS,
                      "DavFsRename/LocalFree. Error Val = %d\n", FreeStatus));
        }
    }

    if (UtfServerName != NULL) {
        LocalFree(UtfServerName);
        UtfServerName = NULL;
    }

    if (UtfNewPathName != NULL) {
        LocalFree(UtfNewPathName);
        UtfNewPathName = NULL;
    }

#ifdef DAV_USE_WININET_ASYNCHRONOUSLY
    
    //
    // Some resources should not be freed if we are returning ERROR_IO_PENDING
    // because they will be used in the callback functions.
    //
    if (WStatus != ERROR_IO_PENDING) {
            
        //
        // Set the return status of the operation. This is used by the kernel 
        // mode routines to figure out the completion status of the user mode 
        // request.
        //
        if (WStatus != ERROR_SUCCESS) {
            DavWorkItem->Status = DavMapErrorToNtStatus(WStatus);
        } else {
            DavWorkItem->Status = STATUS_SUCCESS;
        }
    
        DavAsyncReNameCompletion(DavWorkItem);
    
    } else {
        DavPrint((DEBUG_MISC, "DavFsReName: Returning ERROR_IO_PENDING.\n"));
    }

#else

    //
    // If we are using WinInet synchronously, then we should never get back
    // ERROR_IO_PENDING from WinInet.
    //
    ASSERT(WStatus != ERROR_IO_PENDING);

    //
    // If this thread impersonated a user, we need to revert back.
    //
    if (didImpersonate) {
        RevertToSelf();
    }

    //
    // Set the return status of the operation. This is used by the kernel
    // mode routines to figure out the completion status of the user mode
    // request. This is done here because the async completion routine that is
    // called immediately afterwards needs the status set.
    //
    if (WStatus != ERROR_SUCCESS) {
        DavWorkItem->Status = DavMapErrorToNtStatus(WStatus);
    } else {
        INTERNET_CACHE_ENTRY_INFOW CEI;

        CEI.LastAccessTime.dwLowDateTime = 0;
        CEI.LastAccessTime.dwHighDateTime = 0;

        SetUrlCacheEntryInfo(DavReNameRequest->Url,&CEI,CACHE_ENTRY_ACCTIME_FC);
        
        DavPrint((DEBUG_MISC,
                  "DavFsRename Reset LastAccessTime for     %ws\n",DavReNameRequest->Url));
        
        DavWorkItem->Status = STATUS_SUCCESS;
    }
    
    DavAsyncReNameCompletion(DavWorkItem);

#endif

    return WStatus;
}


DWORD 
DavAsyncReName(
    PDAV_USERMODE_WORKITEM DavWorkItem,
    BOOLEAN CalledByCallBackThread
    )
/*++

Routine Description:

   This is the callback routine for the ReName operation.

Arguments:

    DavWorkItem - The DAV_USERMODE_WORKITEM value.

    CalledByCallbackThread - TRUE, if this function was called by the thread
                             which picks of the DavWorkItem from the Callback
                             function. This happens when an Async WinInet call
                             returns ERROR_IO_PENDING and completes later.

Return Value:

    ERROR_SUCCESS or the appropriate error value.

--*/
{
    ULONG WStatus = ERROR_SUCCESS;
    PUMRX_USERMODE_WORKITEM_HEADER UserWorkItem;
    BOOL didImpersonate = FALSE;
    HINTERNET DavOpenHandle = NULL;
    ULONG HttpResponseStatus = 0;
    PCHAR DataBuff = NULL;

    UserWorkItem = (PUMRX_USERMODE_WORKITEM_HEADER)DavWorkItem;
    
#ifdef DAV_USE_WININET_ASYNCHRONOUSLY
    
    if (CalledByCallBackThread) {

        //
        // We are running in the context of a worker thread which has different 
        // credentials than the user that initiated the I/O request. Before
        // proceeding further, we should impersonate the user that initiated the 
        // request.
        //
        WStatus = UMReflectorImpersonate(UserWorkItem, DavWorkItem->ImpersonationHandle);
        if (WStatus != ERROR_SUCCESS) {
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncReName/UMReflectorImpersonate. Error Val = %d\n", 
                      WStatus));
            goto EXIT_THE_FUNCTION;
        }
        didImpersonate = TRUE;
        
        //
        // Before proceeding further, check to see if the Async operation failed.
        // If it did, then cleanup and move on.
        //
        if ( !DavWorkItem->AsyncResult->dwResult ) {
            
            WStatus = DavWorkItem->AsyncResult->dwError;
            
            //
            // If the error we got back is ERROR_INTERNET_FORCE_RETRY, then
            // WinInet is trying to authenticate itself with the server. In 
            // such a scenario this is what happens.
            //
            //          Client ----Request----->   Server
            //          Server ----AccessDenied-----> Client
            //          Client----Challenge Me-------> Server
            //          Server-----Challenge--------> Client
            //          Client-----Challenge Resp----> Server
            //
            if (WStatus == ERROR_INTERNET_FORCE_RETRY) {

                ASSERT(DavWorkItem->DavOperation == DAV_CALLBACK_HTTP_END);

                //
                // We need to repeat the HttpSend and HttpEnd request calls.
                //
                DavWorkItem->DavOperation = DAV_CALLBACK_HTTP_OPEN;

                WStatus = DavAsyncCommonStates(DavWorkItem, FALSE);
                if (WStatus != ERROR_SUCCESS && WStatus != ERROR_IO_PENDING) {
                    DavPrint((DEBUG_ERRORS,
                              "DavAsyncReName/DavAsyncCommonStates. Error Val ="
                              " %08lx\n", WStatus));
                }

            } else {

                DavPrint((DEBUG_ERRORS,
                          "DavAsyncReName. AsyncFunction failed. Error Val = %d\n", 
                          WStatus));
            
            }
            
            goto EXIT_THE_FUNCTION;

        }

    }

#else

    ASSERT(CalledByCallBackThread == FALSE);

#endif

    DavOpenHandle = DavWorkItem->AsyncReName.DavOpenHandle;
    WStatus = DavQueryAndParseResponseEx(DavOpenHandle, &(HttpResponseStatus));
    if (WStatus != ERROR_SUCCESS) {
        //
        // The MOVE request that was sent to the server failed.
        // If the response status is HTTP_STATUS_PRECOND_FAILED then it means
        // that we tried to rename a file to a file which already exists and
        // ReplaceIfExists (sent by the caller) was FALSE. In such a case we 
        // return ERROR_ALREADY_EXISTS.
        //
        if (HttpResponseStatus == HTTP_STATUS_PRECOND_FAILED) {
            WStatus = ERROR_ALREADY_EXISTS;
        } else {
            WStatus = ERROR_UNABLE_TO_MOVE_REPLACEMENT;
        }
        DavPrint((DEBUG_ERRORS,
                  "DavAsyncReName/DavQueryAndParseResponse. WStatus = %d, HttpResponseStatus = %d\n", 
                  WStatus, HttpResponseStatus));
    }

    //
    // If we get back a 207 (DAV_MULTI_STATUS) as the response, we need to
    // parse the returned XML and see if the status code was 200. If it
    // wasn't it means that the MOVE failed.
    //
    if (HttpResponseStatus == DAV_MULTI_STATUS) {

        DWORD NumRead = 0, NumOfFileEntries = 0, TotalDataBytesRead = 0;
        BOOL ReturnVal = FALSE, readDone = FALSE;
        DAV_FILE_ATTRIBUTES DavFileAttributes;
        PVOID Ctx1 = NULL, Ctx2 = NULL;

        DataBuff = LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, NUM_OF_BYTES_TO_READ);
        if (DataBuff == NULL) {
            WStatus = GetLastError();
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncReName/LocalAlloc: WStatus = %08lx\n",
                      WStatus));
            goto EXIT_THE_FUNCTION;
        }

        //
        // Read the response and parse it.
        //
        do {

            ReturnVal = InternetReadFile(DavOpenHandle, 
                                         (LPVOID)DataBuff,
                                         NUM_OF_BYTES_TO_READ,
                                         &(NumRead));
            if (!ReturnVal) {
                WStatus = GetLastError();
                DavPrint((DEBUG_ERRORS,
                          "DavAsyncReName/InternetReadFile: WStatus = %08lx\n",
                          WStatus));
                goto EXIT_THE_FUNCTION;
            }

            DavPrint((DEBUG_MISC, "DavAsyncReName: NumRead = %d\n", NumRead));

            //
            // We reject files whose attributes are greater than a
            // certain size (DavFileAttributesLimitInBytes). This
            // is a parameter that can be set in the registry. This
            // is done to avoid attacks by rogue servers.
            //
            TotalDataBytesRead += NumRead;
            if (TotalDataBytesRead > DavFileAttributesLimitInBytes) {
                WStatus = ERROR_BAD_NET_RESP;
                DavPrint((DEBUG_ERRORS, "DavAsyncReName. FileAttributesSize > %d\n", DavFileAttributesLimitInBytes));
                goto EXIT_THE_FUNCTION;
            }

            readDone = (NumRead == 0) ? TRUE : FALSE;

            WStatus = DavPushData(DataBuff, &Ctx1, &Ctx2, NumRead, readDone);
            if (WStatus != ERROR_SUCCESS) {
                DavPrint((DEBUG_ERRORS,
                          "DavAsyncReName/DavPushData. WStatus = %d\n",
                          WStatus));
                goto EXIT_THE_FUNCTION;
            }

            if (readDone) {
                break;
            }

        } while ( TRUE );

        memset(&DavFileAttributes, 0, sizeof(DavFileAttributes));

        InitializeListHead( &(DavFileAttributes.NextEntry) );

        WStatus = DavParseData(&DavFileAttributes, Ctx1, Ctx2, &NumOfFileEntries);
        if (WStatus != ERROR_SUCCESS) {
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncReName/DavParseData. WStatus = %d\n",
                      WStatus));
            DavFinalizeFileAttributesList(&DavFileAttributes, FALSE);
            goto EXIT_THE_FUNCTION;
        }

        if (DavFileAttributes.InvalidNode) {
            WStatus = ERROR_SHARING_VIOLATION;
        }

        DavFinalizeFileAttributesList(&DavFileAttributes, FALSE);

        DavCloseContext(Ctx1, Ctx2);

    }

EXIT_THE_FUNCTION:

    //
    // If we did impersonate, we need to revert back.
    //
    if (didImpersonate) {
        ULONG RStatus;
        RStatus = UMReflectorRevert(UserWorkItem);
        if (RStatus != ERROR_SUCCESS) {
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncReName/UMReflectorRevert. Error Val = %d\n", 
                      RStatus));
        }
    }

    if (DataBuff != NULL) {
        LocalFree(DataBuff);
        DataBuff = NULL;
    }

#ifdef DAV_USE_WININET_ASYNCHRONOUSLY

    //
    // Some resources should not be freed if we are returning ERROR_IO_PENDING
    // because they will be used in the callback functions.
    //
    if ( WStatus != ERROR_IO_PENDING && CalledByCallBackThread ) {
        
        //
        // Set the return status of the operation. This is used by the kernel 
        // mode routines to figure out the completion status of the user mode 
        // request.
        //
        if (WStatus != ERROR_SUCCESS) {
            DavWorkItem->Status = DavMapErrorToNtStatus(WStatus);
        } else {
            DavWorkItem->Status = STATUS_SUCCESS;
        }

        //
        // Call the DavAsyncReNameCompletion routine.
        //
        DavAsyncReNameCompletion(DavWorkItem);

        //
        // This thread now needs to send the response back to the kernel. It 
        // does not wait in the kernel (to get another request) after submitting
        // the response.
        //
        UMReflectorCompleteRequest(DavReflectorHandle, UserWorkItem);

    } else {
        DavPrint((DEBUG_MISC, "DavAsyncReName: Returning ERROR_IO_PENDING.\n"));
    }

#endif

    return WStatus;
}


VOID
DavAsyncReNameCompletion(
    PDAV_USERMODE_WORKITEM DavWorkItem
    )
/*++

Routine Description:

   This routine handles the ReName completion. It basically frees up the 
   resources allocated during the ReName operation.

Arguments:

    DavWorkItem - The DAV_USERMODE_WORKITEM value.
    
Return Value:

    none.

--*/
{
    if (DavWorkItem->AsyncReName.DavOpenHandle != NULL) {
        BOOL ReturnVal;
        ULONG FreeStatus;
        HINTERNET DavOpenHandle = DavWorkItem->AsyncReName.DavOpenHandle;
        ReturnVal = InternetCloseHandle( DavOpenHandle );
        if (!ReturnVal) {
            FreeStatus = GetLastError();
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncReNameCompletion/InternetCloseHandle. Error Val "
                      "= %d\n", FreeStatus));
        }
    }

    if (DavWorkItem->AsyncReName.HeaderBuff != NULL) {
        HLOCAL FreeHandle;
        ULONG FreeStatus;
        FreeHandle = LocalFree((HLOCAL)DavWorkItem->AsyncReName.HeaderBuff);
        if (FreeHandle != NULL) {
            FreeStatus = GetLastError();
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncReNameCompletion/LocalFree. Error Val = %d\n", 
                      FreeStatus));
        }
    }
    
    if (DavWorkItem->AsyncResult != NULL) {
        HLOCAL FreeHandle;
        ULONG FreeStatus;
        FreeHandle = LocalFree((HLOCAL)DavWorkItem->AsyncResult);
        if (FreeHandle != NULL) {
            FreeStatus = GetLastError();
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncReNameCompletion/LocalFree. Error Val = %d\n", 
                      FreeStatus));
        }
    }

    DavFsFinalizeTheDavCallBackContext(DavWorkItem);

    //
    // We are done with the per user entry, so finalize it.
    //
    if (DavWorkItem->AsyncReName.PerUserEntry) {
        DavFinalizePerUserEntry( &(DavWorkItem->AsyncReName.PerUserEntry) );
    }

    return;
}


ULONG
DavFsSetFileInformation(
    PDAV_USERMODE_WORKITEM DavWorkItem
    )
/*++

Routine Description:

    This routine handles SetFileInformation requests for the DAV Mini-Redir that get 
    reflected from the kernel.

Arguments:

    DavWorkItem - The buffer that contains the request parameters and options.

Return Value:

    The return status for the operation

--*/
{
    ULONG WStatus = ERROR_SUCCESS;
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PWCHAR ServerName = NULL, DirectoryPath = NULL, CanName = NULL;
    PWCHAR OpenVerb = NULL;
    ULONG_PTR CallBackContext = (ULONG_PTR)0;
    BOOL EnCriSec = FALSE, ReturnVal, CallBackContextInitialized = FALSE, fSetDirectoryEntry = FALSE;
    PDAV_USERMODE_SETFILEINFORMATION_REQUEST SetFileInformationRequest = &(DavWorkItem->SetFileInformationRequest);
    ULONG ServerID;
    PPER_USER_ENTRY PerUserEntry = NULL;
    PHASH_SERVER_ENTRY ServerHashEntry = NULL;
    HINTERNET DavConnHandle, DavOpenHandle;
    PBYTE DataBuff = NULL;
    LARGE_INTEGER FileSize, ByteOffset;
    BY_HANDLE_FILE_INFORMATION FileInfo; 
    IO_STATUS_BLOCK IoStatusBlock;
    HANDLE FileHandle;
    OBJECT_ATTRIBUTES ObjectAttributes;
    static UINT UniqueTempId = 1;
    BOOL didImpersonate = FALSE;
    PUMRX_USERMODE_WORKITEM_HEADER UserWorkItem = NULL;
    BOOLEAN didITakeAPUEReference = FALSE;

    //
    // The first character is a '\' which has to be stripped.
    //
    ServerName = &(SetFileInformationRequest->ServerName[1]);
    
    if (!ServerName) {
        DavPrint((DEBUG_ERRORS, "DavFsSetFileInformation: ServerName is NULL.\n"));
        WStatus = ERROR_INVALID_PARAMETER; // STATUS_INVALID_PARAMETER;
        goto EXIT_THE_FUNCTION;
    }
    
    DavPrint((DEBUG_MISC, "DavFsSetFileInformation: ServerName = %ws.\n", ServerName));
    
    ServerID = SetFileInformationRequest->ServerID;
    DavPrint((DEBUG_MISC, "DavFsSetFileInformation: ServerID = %d.\n", ServerID));

    //
    // The first character is a '\' which has to be stripped.
    //
    DirectoryPath = &(SetFileInformationRequest->PathName[1]);
    if (!DirectoryPath) {
        DavPrint((DEBUG_ERRORS, "DavFsSetFileInformation: DirectoryPath is NULL.\n"));
        WStatus = ERROR_INVALID_PARAMETER; // STATUS_INVALID_PARAMETER;
        goto EXIT_THE_FUNCTION;
    }
    DavPrint((DEBUG_MISC, "DavFsSetFileInformation: DirectoryPath = %ws.\n", DirectoryPath));
    
    //
    // The DirectoryPath can contain \ characters. Replace them by / characters.
    //
    CanName = DirectoryPath;
    while (*CanName) {
        if (*CanName == L'\\') {
            *CanName = L'/';
        }
        CanName++;
    }

    UserWorkItem = (PUMRX_USERMODE_WORKITEM_HEADER)DavWorkItem;

    //
    // If we have a dummy share name in the DirectoryPath, we need to remove it 
    // right now before we contact the server.
    //
    DavRemoveDummyShareFromFileName(DirectoryPath);
    
    
    //
    // A User Entry for this user must have been created during the create call
    // earlier. The user entry contains the handle used to send an HttpOpen
    // request.
    //

    EnterCriticalSection( &(HashServerEntryTableLock) );
    EnCriSec = TRUE;

    ReturnVal = DavDoesUserEntryExist(ServerName,
                                      ServerID, 
                                      &(SetFileInformationRequest->LogonID),
                                      &PerUserEntry,
                                      &ServerHashEntry);
    
    //
    // If the following request in the kernel get cancelled even before the 
    // corresponding usermode thread gets a chance to execute this code, then
    // it possible that the VNetRoot (hence the PerUserEntry) and SrvCall get
    // finalized before the thread that is handling the create comes here. This
    // could happen if this request was the only one for this share and the
    // server as well. This is why we need to check if the ServerHashEntry and
    // the PerUserEntry are valid before proceeding.
    //
    if (ReturnVal == FALSE || ServerHashEntry == NULL || PerUserEntry == NULL) {
        WStatus = ERROR_CANCELLED;
        DavPrint((DEBUG_ERRORS, "DavFsSetFileInformation: (ServerHashEntry == NULL || PerUserEntry == NULL)\n"));
        goto EXIT_THE_FUNCTION;
    }

    DavWorkItem->ServerUserEntry.PerUserEntry = PerUserEntry;

    //
    // Add a reference to the user entry and set didITakeAPUEReference to TRUE.
    //
    PerUserEntry->UserEntryRefCount++;

    didITakeAPUEReference = TRUE;

    //
    // Since a create had succeeded earlier, the entry must be good.
    //
    ASSERT(PerUserEntry->UserEntryState == UserEntryInitialized);
    ASSERT(PerUserEntry->DavConnHandle != NULL);

    //
    // And yes, we obviously have to leave the critical section
    // before returning.
    //
    LeaveCriticalSection( &(HashServerEntryTableLock) );
    EnCriSec = FALSE;

    WStatus = UMReflectorImpersonate(UserWorkItem, DavWorkItem->ImpersonationHandle);
    if (WStatus != ERROR_SUCCESS) {
        DavPrint((DEBUG_ERRORS,
                  "DavFsSetFileInformation/UMReflectorImpersonate. Error Val = %d\n",
                  WStatus));
        goto EXIT_THE_FUNCTION;
    }
    didImpersonate = TRUE;

    DavWorkItem->DavMinorOperation = DavMinorProppatchFile;

    WStatus = DavSetBasicInformation(DavWorkItem,
                                     PerUserEntry->DavConnHandle, 
                                     DirectoryPath,
                                     SetFileInformationRequest->fCreationTimeChanged,
                                     SetFileInformationRequest->fLastAccessTimeChanged,
                                     SetFileInformationRequest->fLastModifiedTimeChanged,
                                     SetFileInformationRequest->fFileAttributesChanged,
                                     &SetFileInformationRequest->FileBasicInformation.CreationTime,
                                     &SetFileInformationRequest->FileBasicInformation.LastAccessTime,
                                     &SetFileInformationRequest->FileBasicInformation.LastWriteTime,
                                     SetFileInformationRequest->FileBasicInformation.FileAttributes);
    if (WStatus != ERROR_SUCCESS) {

        ULONG LogStatus;

        DavPrint((DEBUG_ERRORS,
                  "DavFsSetFileInformation/DavSetBasicInformation. WStatus = %d\n",
                  WStatus));
        
        LogStatus = DavFormatAndLogError(DavWorkItem, WStatus);
        if (LogStatus != ERROR_SUCCESS) {
            DavPrint((DEBUG_ERRORS,
                      "DavFsSetFileInformation/DavFormatAndLogError. LogStatus = %d\n",
                      LogStatus));
        }
    
    }

    RevertToSelf();
    didImpersonate = FALSE;


EXIT_THE_FUNCTION:

    if (EnCriSec) {
        LeaveCriticalSection( &(HashServerEntryTableLock) );
        EnCriSec = FALSE;
    }

    //
    // If didITakeAPUEReference is TRUE we need to remove the reference we 
    // took on the PerUserEntry.
    //
    if (didITakeAPUEReference) {
        DavFinalizePerUserEntry( &(DavWorkItem->ServerUserEntry.PerUserEntry) );
    }

    //
    // If we are using WinInet synchronously, then we should never get back
    // ERROR_IO_PENDING from WinInet.
    //
    ASSERT(WStatus != ERROR_IO_PENDING);

    //
    // If this thread impersonated a user, we need to revert back.
    //
    if (didImpersonate) {
        RevertToSelf();
    }

    //
    // Set the return status of the operation. This is used by the kernel
    // mode routines to figure out the completion status of the user mode
    // request. This is done here because the async completion routine that is
    // called immediately afterwards needs the status set.
    //
    if (WStatus != ERROR_SUCCESS) {
        DavWorkItem->Status = DavMapErrorToNtStatus(WStatus);
    } else {
        DavWorkItem->Status = STATUS_SUCCESS;
    }
    
    DavFsFinalizeTheDavCallBackContext(DavWorkItem);

    return WStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\server\querydir.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    querydir.c
    
Abstract:

    This module implements the user mode DAV miniredir routine(s) pertaining to 
    the QueryDirectory call.

Author:

    Rohan Kumar      [RohanK]      20-Sept-1999

Revision History:

--*/

#include "pch.h"
#pragma hdrstop

#include "ntumrefl.h"
#include "usrmddav.h"
#include "global.h"
#include "nodefac.h"
#include "UniUtf.h"

#define MSN_SPACE_FAKE_DELTA    52428800    // 50 MB


ULONG
DavFsQueryDirectory(
    PDAV_USERMODE_WORKITEM DavWorkItem
)
/*++

Routine Description:

    This routine handles QueryDirectory requests for the DAV Mini-Redir that 
    get reflected from the kernel.

Arguments:

    DavWorkItem - The buffer that contains the request parameters and options.

Return Value:

    The return status for the operation

--*/
{
    ULONG WStatus = ERROR_SUCCESS;
    PDAV_USERMODE_QUERYDIR_REQUEST QueryDirRequest;
    PWCHAR ServerName = NULL, DirectoryPath = NULL, CanName = NULL;
    ULONG_PTR CallBackContext = (ULONG_PTR)0;
    BOOL EnCriSec = FALSE, ReturnVal, CallBackContextInitialized = FALSE;
    ULONG ServerID;
    PPER_USER_ENTRY PerUserEntry = NULL;
    PHASH_SERVER_ENTRY ServerHashEntry = NULL;
    HINTERNET DavConnHandle, DavOpenHandle;
    BOOL didImpersonate = FALSE;
    PUMRX_USERMODE_WORKITEM_HEADER UserWorkItem = NULL;
    BOOL BStatus = FALSE;

    //
    // Get the request and response buffer pointers from the DavWorkItem.
    //
    QueryDirRequest = &(DavWorkItem->QueryDirRequest);

    //
    // Check to see if we have already created the DavFileAttributes list. If
    // we have, we are already done and just need to return.
    //
    if (QueryDirRequest->AlreadyDone) {
        DavPrint((DEBUG_MISC, 
                  "DavFsQueryDirectory: DavFileAttributes already created.\n"));
        WStatus = ERROR_SUCCESS;
        goto EXIT_THE_FUNCTION;
    }
    
    //
    // The first character is a '\' which has to be stripped.
    //
    ServerName = &(QueryDirRequest->ServerName[1]);
    if (!ServerName) {
        DavPrint((DEBUG_ERRORS, "DavFsQueryDirectory: ServerName is NULL.\n"));
        WStatus = ERROR_INVALID_PARAMETER; // STATUS_INVALID_PARAMETER;
        goto EXIT_THE_FUNCTION;
    }
    DavPrint((DEBUG_MISC, 
              "DavFsQueryDirectory: ServerName = %ws.\n", ServerName));

    ServerID = QueryDirRequest->ServerID;
    DavPrint((DEBUG_MISC, "DavFsQueryDirectory: ServerID = %d.\n", ServerID));

    //
    // The first character is a '\' which has to be stripped.
    //
    DirectoryPath = &(QueryDirRequest->PathName[1]);
    if (!DirectoryPath) {
        DavPrint((DEBUG_ERRORS, "DavFsQueryDirectory: DirectoryPath is NULL.\n"));
        WStatus = ERROR_INVALID_PARAMETER; // STATUS_INVALID_PARAMETER;
        goto EXIT_THE_FUNCTION;
    }
    DavPrint((DEBUG_MISC,
              "DavFsQueryDirectory: DirectoryPath = %ws.\n", DirectoryPath));

    //
    // The DirectoryPath can contain \ characters. Replace them by / characters.
    //
    CanName = DirectoryPath;
    while (*CanName) {
        if (*CanName == L'\\') {
            *CanName = L'/';
        }
        CanName++;
    }

    //
    // If we have a dummy share name in the DirectoryPath, we need to remove it 
    // right now before we contact the server.
    //
    DavRemoveDummyShareFromFileName(DirectoryPath);
    
    //
    // If there are no wild cards, we set the depth of the DAV request to 0,
    // otherwise, we set the depth to 1.
    //
    DavWorkItem->AsyncQueryDirectoryCall.NoWildCards = QueryDirRequest->NoWildCards;
    DavPrint((DEBUG_MISC, 
              "DavFsQueryDirectory: NoWildCards = %d.\n", QueryDirRequest->NoWildCards));

    DavPrint((DEBUG_MISC,
              "DavFsQueryDirectory: LogonId.LowPart = %08lx.\n", 
              QueryDirRequest->LogonID.LowPart));
    
    DavPrint((DEBUG_MISC,
              "DavFsQueryDirectory: LogonId.HighPart = %08lx.\n", 
              QueryDirRequest->LogonID.HighPart));
    

    UserWorkItem = (PUMRX_USERMODE_WORKITEM_HEADER)DavWorkItem;

    //
    // If we are using WinInet synchronously, then we need to impersonate the
    // clients context now.
    //
    
    WStatus = UMReflectorImpersonate(UserWorkItem, DavWorkItem->ImpersonationHandle);
    if (WStatus != ERROR_SUCCESS) {
        DavPrint((DEBUG_ERRORS,
                  "DavFsQueryDirectory/UMReflectorImpersonate. Error Val = %d\n",
                  WStatus));
        goto EXIT_THE_FUNCTION;
    }
    didImpersonate = TRUE;



    //
    // Allocate memory for the INTERNET_ASYNC_RESULT structure.
    //
    DavWorkItem->AsyncResult = LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, 
                                          sizeof(INTERNET_ASYNC_RESULT));
    if (DavWorkItem->AsyncResult == NULL) {
        WStatus = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavFsQueryDirectory/LocalAlloc. Error Val = %d\n",
                  WStatus));
        goto EXIT_THE_FUNCTION;
    }

    //
    // A User Entry for this user must have been created during the create call
    // earlier. The user entry contains the handle used to send an HttpOpen
    // request.
    //

    EnterCriticalSection( &(HashServerEntryTableLock) );
    EnCriSec = TRUE;

    ReturnVal = DavDoesUserEntryExist(ServerName,
                                      ServerID, 
                                      &(QueryDirRequest->LogonID),
                                      &PerUserEntry,
                                      &ServerHashEntry);

    //
    // If the following request in the kernel get cancelled even before the 
    // corresponding usermode thread gets a chance to execute this code, then
    // it possible that the VNetRoot (hence the PerUserEntry) and SrvCall get
    // finalized before the thread that is handling the create comes here. This
    // could happen if this request was the only one for this share and the
    // server as well. This is why we need to check if the ServerHashEntry and
    // the PerUserEntry are valid before proceeding.
    //
    if (ReturnVal == FALSE || ServerHashEntry == NULL || PerUserEntry == NULL) {
        WStatus = ERROR_CANCELLED;
        DavPrint((DEBUG_ERRORS, "DavFsQueryDirectory: (ServerHashEntry == NULL || PerUserEntry == NULL)\n"));
        goto EXIT_THE_FUNCTION;
    }

    DavWorkItem->AsyncQueryDirectoryCall.ServerHashEntry = ServerHashEntry;

    DavWorkItem->AsyncQueryDirectoryCall.PerUserEntry = PerUserEntry;

    DavPrint((DEBUG_MISC,
              "DavFsQueryDirectory: PerUserEntry = %08lx.\n", 
              PerUserEntry));
    
    //
    // Add a reference to the user entry.
    //
    PerUserEntry->UserEntryRefCount++;

    //
    // Since a create had succeeded earlier, the entry must be good.
    //
    ASSERT(PerUserEntry->UserEntryState == UserEntryInitialized);
    ASSERT(PerUserEntry->DavConnHandle != NULL);
    DavConnHandle = PerUserEntry->DavConnHandle;

    //
    // And yes, we obviously have to leave the critical section
    // before returning.
    //
    LeaveCriticalSection( &(HashServerEntryTableLock) );
    EnCriSec = FALSE;
        
    //
    // We now call the HttpOpenRequest function and return.
    //
    DavWorkItem->DavOperation = DAV_CALLBACK_HTTP_OPEN;
    DavWorkItem->DavMinorOperation = DavMinorReadData;
    DavWorkItem->AsyncQueryDirectoryCall.DataBuff = NULL;
    DavWorkItem->AsyncQueryDirectoryCall.didRead = NULL;
    DavWorkItem->AsyncQueryDirectoryCall.Context1 = NULL;
    DavWorkItem->AsyncQueryDirectoryCall.Context2 = NULL;

    // convert the unicode directory path to UTF-8 URL format
    // space and other white characters will remain untouched - these should
    // be taken care of by wininet calls

    BStatus = DavHttpOpenRequestW(DavConnHandle,
                                     L"PROPFIND",
                                     DirectoryPath,
                                     L"HTTP/1.1",
                                     NULL,
                                     NULL,
                                     INTERNET_FLAG_KEEP_CONNECTION |
                                     INTERNET_FLAG_NO_COOKIES,
                                     CallBackContext,
                                     L"DavFsQueryDirectory",
                                     &DavOpenHandle);
    if(BStatus == FALSE) {
        WStatus = GetLastError();
        goto EXIT_THE_FUNCTION;
    }
    if (DavOpenHandle == NULL) {
        WStatus = GetLastError();
        if (WStatus != ERROR_IO_PENDING) {
            DavPrint((DEBUG_ERRORS,
                      "DavFsQueryDirectory/HttpOpenRequest. Error Val = %d\n", 
                      WStatus));
        }
        goto EXIT_THE_FUNCTION;
    }

    //
    // Cache the DavOpenHandle in the DavWorkItem.
    //
    DavWorkItem->AsyncQueryDirectoryCall.DavOpenHandle = DavOpenHandle;

    WStatus = DavAsyncCommonStates(DavWorkItem, FALSE);
    if (WStatus != ERROR_SUCCESS && WStatus != ERROR_IO_PENDING) {
        DavPrint((DEBUG_ERRORS,
                  "DavFsQueryDirectory/DavAsyncCommonStates. Error Val = %08lx\n",
                  WStatus));
    }

EXIT_THE_FUNCTION:

    if (EnCriSec) {
        LeaveCriticalSection( &(HashServerEntryTableLock) );
        EnCriSec = FALSE;
    }


    //
    // If we are using WinInet synchronously, then we should never get back
    // ERROR_IO_PENDING from WinInet.
    //
    ASSERT(WStatus != ERROR_IO_PENDING);

    //
    // If this thread impersonated a user, we need to revert back.
    //
    if (didImpersonate) {
        RevertToSelf();
    }

    //
    // Set the return status of the operation. This is used by the kernel
    // mode routines to figure out the completion status of the user mode
    // request. This is done here because the async completion routine that is
    // called immediately afterwards needs the status set.
    //
    if (WStatus != ERROR_SUCCESS) {
        DavWorkItem->Status = DavMapErrorToNtStatus(WStatus);
    } else {
        DavWorkItem->Status = STATUS_SUCCESS;
    }
    
    DavAsyncQueryDirectoryCompletion(DavWorkItem);

    return WStatus;
}


DWORD 
DavAsyncQueryDirectory(
    PDAV_USERMODE_WORKITEM DavWorkItem,
    BOOLEAN CalledByCallBackThread
    )
/*++

Routine Description:

   This is the callback routine for the query directory operation.

Arguments:

    DavWorkItem - The DAV_USERMODE_WORKITEM value.

    CalledByCallbackThread - TRUE, if this function was called by the thread
                             which picks of the DavWorkItem from the Callback
                             function. This happens when an Async WinInet call
                             returns ERROR_IO_PENDING and completes later.

Return Value:

    ERROR_SUCCESS or the appropriate error value.

--*/
{
    ULONG WStatus = ERROR_SUCCESS;
    ULONG NumOfFileEntries = 0;
    PUMRX_USERMODE_WORKITEM_HEADER UserWorkItem = NULL;
    BOOL didImpersonate = FALSE, ReturnVal, readDone = FALSE;
    HINTERNET DavOpenHandle = NULL;
    DWORD didRead, DataBuffBytes, TotalDataBytesRead = 0;
    PCHAR DataBuff = NULL;
    LPDWORD NumRead = NULL;
    PDAV_FILE_ATTRIBUTES DavFileAttributes = NULL;
    PVOID Ctx1 = NULL, Ctx2 = NULL;
    PDAV_USERMODE_QUERYDIR_RESPONSE QueryDirResponse = NULL;
    PDAV_FILE_ATTRIBUTES DFA1 = NULL, DFA2 = NULL, TempDFA = NULL;
    BOOL fFreeDFAs = TRUE;
    PDAV_FILE_ATTRIBUTES parentDFA = NULL;

    UserWorkItem = (PUMRX_USERMODE_WORKITEM_HEADER)DavWorkItem;
    

    ASSERT(CalledByCallBackThread == FALSE);


    switch (DavWorkItem->DavOperation) {
    
    case DAV_CALLBACK_HTTP_END: {
        
        DavOpenHandle = DavWorkItem->AsyncQueryDirectoryCall.DavOpenHandle;

        //
        // If the file for which the PROPFIND was done does not exist, then
        // we need to fail right away.
        //

        WStatus = DavQueryAndParseResponse(DavOpenHandle);
        if (WStatus != ERROR_SUCCESS) {
            //
            // The file/directory for which the PROPFIND was done, does not
            // exist.
            //
            
            if (WStatus != ERROR_FILE_NOT_FOUND) {
                DavPrint((DEBUG_ERRORS,
                          "DavAsyncQueryDirectory/DavQueryAndParseResponse. "
                          "WStatus = %d\n", WStatus));
            }

            WStatus = ERROR_FILE_NOT_FOUND; // STATUS_OBJECT_NAME_NOT_FOUND;
            goto EXIT_THE_FUNCTION;
        }
    
        //
        // The file exists. The next thing we do is read the properties
        // of the file (or files in the directory).
        //
        DavWorkItem->DavOperation = DAV_CALLBACK_HTTP_READ;
    
    }
    //
    // Lack of break is intentional.
    //

    case DAV_CALLBACK_HTTP_READ: {
            
        DavOpenHandle = DavWorkItem->AsyncQueryDirectoryCall.DavOpenHandle;

        if (DavWorkItem->AsyncQueryDirectoryCall.DataBuff == NULL) {
            //
            // Need to allocate memory for the read buffer.
            //
            DataBuffBytes = NUM_OF_BYTES_TO_READ;
            DataBuff = LocalAlloc (LMEM_FIXED | LMEM_ZEROINIT, DataBuffBytes);
            if (DataBuff == NULL) {
                WStatus = GetLastError();
                DavPrint((DEBUG_ERRORS,
                          "DavAsyncQueryDirectory/LocalAlloc. Error Val = %d\n",
                          WStatus));
                goto EXIT_THE_FUNCTION;
            }

            DavWorkItem->AsyncQueryDirectoryCall.DataBuff = DataBuff;
        }

        if (DavWorkItem->AsyncQueryDirectoryCall.didRead == NULL) {
            //
            // Allocate memory for the DWORD that stores the number of bytes 
            // read.
            //
            NumRead = LocalAlloc (LMEM_FIXED | LMEM_ZEROINIT, sizeof(DWORD));
            if (NumRead == NULL) {
                WStatus = GetLastError();
                DavPrint((DEBUG_ERRORS,
                          "DavAsyncQueryDirectory/LocalAlloc. Error Val = %d\n",
                          WStatus));
                goto EXIT_THE_FUNCTION;
            }

            DavWorkItem->AsyncQueryDirectoryCall.didRead = NumRead;
        }

        DavWorkItem->DavOperation = DAV_CALLBACK_HTTP_READ;
        
        NumRead = DavWorkItem->AsyncQueryDirectoryCall.didRead;
        DataBuff = DavWorkItem->AsyncQueryDirectoryCall.DataBuff;
        Ctx1 = DavWorkItem->AsyncQueryDirectoryCall.Context1;
        Ctx2 = DavWorkItem->AsyncQueryDirectoryCall.Context2;
        
        do {
            
            switch (DavWorkItem->DavMinorOperation) {
            
            case DavMinorReadData:
            
                DavWorkItem->DavMinorOperation = DavMinorPushData;

                ReturnVal = InternetReadFile(DavOpenHandle, 
                                             (LPVOID)DataBuff,
                                             NUM_OF_BYTES_TO_READ,
                                             NumRead);
                if (!ReturnVal) {
                    WStatus = GetLastError();
                    if (WStatus != ERROR_IO_PENDING) {
                        DavCloseContext(Ctx1, Ctx2);
                        DavPrint((DEBUG_ERRORS,
                                  "DavAsyncQueryDirectory/InternetReadFile. "
                                  "Error Val = %d\n", WStatus));
                    }
                    DavPrint((DEBUG_MISC,
                              "DavAsyncQueryDirectory/InternetReadFile. "
                              "ERROR_IO_PENDING.\n"));
                    goto EXIT_THE_FUNCTION;
                }

                //
                // We reject files whose attributes are greater than a
                // certain size (DavFileAttributesLimitInBytes). This
                // is a parameter that can be set in the registry. This
                // is done to avoid attacks by rogue servers. For PROPFIND
                // with depth 1, we add a multiple of 10.
                //
                TotalDataBytesRead += *NumRead;
                if (DavWorkItem->AsyncQueryDirectoryCall.NoWildCards) {
                    if (TotalDataBytesRead > DavFileAttributesLimitInBytes) {
                        WStatus = ERROR_BAD_NET_RESP;
                        DavPrint((DEBUG_ERRORS, "DavAsyncQueryDirectory. FileAttributesSize > %d\n", DavFileAttributesLimitInBytes));
                        goto EXIT_THE_FUNCTION;
                    }
                } else {
                    if (TotalDataBytesRead > (10 * DavFileAttributesLimitInBytes)) {
                        WStatus = ERROR_BAD_NET_RESP;
                        DavPrint((DEBUG_ERRORS, "DavAsyncQueryDirectory. FileAttributesSize > %d\n", (10 * DavFileAttributesLimitInBytes)));
                        goto EXIT_THE_FUNCTION;
                    }
                }

                //
                // Lack of break is intentional.
                //

            case DavMinorPushData:

                DavWorkItem->DavMinorOperation = DavMinorReadData;

                didRead = *NumRead;

                readDone = (didRead == 0) ? TRUE : FALSE;

                WStatus = DavPushData(DataBuff, &Ctx1, &Ctx2, didRead, readDone);
                if (WStatus != ERROR_SUCCESS) {
                    DavPrint((DEBUG_ERRORS,
                              "DavAsyncQueryDirectory/DavPushData."
                              " Error Val = %d\n", WStatus));
                    goto EXIT_THE_FUNCTION;
                }

                if (DavWorkItem->AsyncQueryDirectoryCall.Context1 == NULL) {
                    DavWorkItem->AsyncQueryDirectoryCall.Context1 = Ctx1;
                }
                
                if (DavWorkItem->AsyncQueryDirectoryCall.Context2 == NULL) {
                    DavWorkItem->AsyncQueryDirectoryCall.Context2 = Ctx2;
                }

                break;

            default:

                WStatus = ERROR_INVALID_PARAMETER;

                DavPrint((DEBUG_ERRORS,
                          "DavAsyncQueryDirectory. Invalid DavMinorOperation ="
                          " %d.\n", DavWorkItem->DavMinorOperation));

                goto EXIT_THE_FUNCTION;

                break;

            }
            
            if (readDone) {
                break;
            }
            
        } while ( TRUE );

        //
        // We now need to parse the data.
        //

        DavFileAttributes = LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT,
                                        sizeof(DAV_FILE_ATTRIBUTES) );
        if (DavFileAttributes == NULL) {
            WStatus = GetLastError();
            DavCloseContext(Ctx1, Ctx2);
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncQueryDirectory/LocalAlloc. "
                      "Error Val = %d\n", WStatus));
            goto EXIT_THE_FUNCTION;
        }

        InitializeListHead( &(DavFileAttributes->NextEntry) );

        WStatus = DavParseDataEx(DavFileAttributes, Ctx1, Ctx2, &NumOfFileEntries, &parentDFA);
        if (WStatus != ERROR_SUCCESS) {
            DavFinalizeFileAttributesList(DavFileAttributes, TRUE);
            DavFileAttributes = NULL;
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncQueryDirectory/DavParseDataEx. "
                      "Error Val = %d\n", WStatus));
            goto EXIT_THE_FUNCTION;
        }

        QueryDirResponse = &(DavWorkItem->QueryDirResponse);
        
        //
        // If we queried the server for a file which did not exist, it may 
        // return 200 OK with no files in the XML response.
        //
        if (DavWorkItem->AsyncQueryDirectoryCall.NoWildCards) {
            
            if (NumOfFileEntries != 1) {
                
                PLIST_ENTRY listEntry = &(DavFileAttributes->NextEntry);
                PDAV_FILE_ATTRIBUTES DavFA = NULL;
                
                DavPrint((DEBUG_MISC,
                          "DavAsyncQueryDirectory. NumOfFileEntries = %d\n",
                          NumOfFileEntries));
                
                do {
                    DavFA = CONTAINING_RECORD(listEntry, DAV_FILE_ATTRIBUTES, NextEntry);
                    DavPrint((DEBUG_MISC,
                              "DavAsyncQueryDirectory. FileName = %ws\n",
                              DavFA->FileName));
                    listEntry = listEntry->Flink;
                } while ( listEntry != &(DavFileAttributes->NextEntry) );
                
                ASSERT(NumOfFileEntries == 0);
                
                DavCloseContext(Ctx1, Ctx2);
                
                DavFinalizeFileAttributesList(DavFileAttributes, TRUE);
                DavFileAttributes = NULL;
                
                WStatus = ERROR_FILE_NOT_FOUND; // STATUS_OBJECT_NAME_NOT_FOUND;
                
                goto EXIT_THE_FUNCTION;
            
            }
        } else {
            //
            // This Query is done for a Directory or for a collection of files 
            // (ex. dir Z:\ab*).
            //

            // In the DFA list (DavFileAttributes) returned by DavParseDataEx(...), 
            // we want to have DFA of the "directory being queried" at the head 
            // of the list.
            // List (DavFileAttributes) returned by DavParseDataEx(...) may not 
            // necessarily have this TRUE.
            // Since DavFileAttributes is a cyclic linked list (all entries are allocated
            // and are to be freed by this function), we will set DavFileAttributes to 
            // point to DFA pointed by parentDFA (points to DFA of "directory being
            // queried").
            //
            // Note: DavFileAttributes->FileIndex which is set in an increasing order
            // starting from 0 in DavParseDataEx(...), may no longer remain in this valid
            // order after re-pointing of DavFileAttributes pointer. We will set them
            // in valid order again here.
            //
            if (parentDFA != NULL && parentDFA != DavFileAttributes) {
                PLIST_ENTRY listEntry = NULL;
                PDAV_FILE_ATTRIBUTES TempDFA = NULL;
                ULONG Count = DavFileAttributes->FileIndex;
                
                DavPrint((DEBUG_DEBUG, "DavAsyncQueryDirectory. CollectionDFA=0x%x",
                                        parentDFA));
                                
                DavFileAttributes = parentDFA;

                //
                // We start the Count with first value DavParseDataEx (value of Head
                // entry in the List) is setting in DavFileAttributes List.
                //

                listEntry = DavFileAttributes->NextEntry.Flink;

                //
                // Set the file indices.
                //
                DavFileAttributes->FileIndex = Count;
                Count++;
                while ( listEntry != &(DavFileAttributes->NextEntry) ) {
            
                    TempDFA = CONTAINING_RECORD(listEntry, DAV_FILE_ATTRIBUTES, NextEntry);

                    listEntry = listEntry->Flink;
            
                    TempDFA->FileIndex = Count;

                    Count++;
            
                }
            }
        }
                        

        //
        // If this was a query for all the files under the directory, then we
        // need to add the files . (current directory) and .. (parent directory)
        // since these are not returned by the server.
        //
        if ( !(DavWorkItem->AsyncQueryDirectoryCall.NoWildCards) ) {
            
            PLIST_ENTRY listEntry = NULL;
            PLIST_ENTRY TempEntry = NULL;
            ULONG Count = 0;


            //
            // We first create the two entires and copy the file names in them.
            //

            DFA1 = LocalAlloc(LPTR, sizeof(DAV_FILE_ATTRIBUTES));
            if (DFA1 == NULL) {
                WStatus = GetLastError();
                DavPrint((DEBUG_ERRORS,
                          "DavAsyncQueryDirectory/LocalAlloc. "
                          "Error Val = %d\n", WStatus));
                DavCloseContext(Ctx1, Ctx2);
                DavFinalizeFileAttributesList(DavFileAttributes, TRUE);
                DavFileAttributes = NULL;
                goto EXIT_THE_FUNCTION;
            }
            InitializeListHead( &(DFA1->NextEntry) );

            //
            // Since the file name is ".", the amount of memory required to hold
            // this name is 2 * sizeof(WCHAR). The extra 1 is for the final L'\0'.
            //
            DFA1->FileName = LocalAlloc(LPTR, (2 * sizeof(WCHAR)));
            if (DFA1->FileName == NULL) {
                WStatus = GetLastError();
                DavPrint((DEBUG_ERRORS,
                          "DavAsyncQueryDirectory/LocalAlloc. "
                          "Error Val = %d\n", WStatus));
                DavCloseContext(Ctx1, Ctx2);
                DavFinalizeFileAttributesList(DavFileAttributes, TRUE);
                DavFileAttributes = NULL;
                goto EXIT_THE_FUNCTION;
            }
            wcscpy(DFA1->FileName, L".");
            DFA1->FileNameLength = 1;


            DFA2 = LocalAlloc(LPTR, sizeof(DAV_FILE_ATTRIBUTES));
            if (DFA2 == NULL) {
                WStatus = GetLastError();
                DavPrint((DEBUG_ERRORS,
                          "DavAsyncQueryDirectory/LocalAlloc. "
                          "Error Val = %d\n", WStatus));
                DavCloseContext(Ctx1, Ctx2);
                DavFinalizeFileAttributesList(DavFileAttributes, TRUE);
                DavFileAttributes = NULL;
                goto EXIT_THE_FUNCTION;
            }
            InitializeListHead( &(DFA2->NextEntry) );

            //
            // Since the file name is "..", the amount of memory required to hold
            // this name is 3 * sizeof(WCHAR). The extra 1 is for the final L'\0'.
            //
            DFA2->FileName = LocalAlloc(LPTR, (3 * sizeof(WCHAR)));
            if (DFA2->FileName == NULL) {
                WStatus = GetLastError();
                DavPrint((DEBUG_ERRORS,
                          "DavAsyncQueryDirectory/LocalAlloc. "
                          "Error Val = %d\n", WStatus));
                DavCloseContext(Ctx1, Ctx2);
                DavFinalizeFileAttributesList(DavFileAttributes, TRUE);
                DavFileAttributes = NULL;
                goto EXIT_THE_FUNCTION;
            }
            wcscpy(DFA2->FileName, L"..");
            DFA2->FileNameLength = 2;


            //
            // Both these are collections ofcourse.
            //
            DFA1->isCollection = DFA2->isCollection = TRUE;

            //
            // We set the following time values of the new entries to the value 
            // of the first entry in the DavFileAttributes list which is the 
            // directory being enumerated.
            //

            DFA1->CreationTime.HighPart = DFA2->CreationTime.HighPart = DavFileAttributes->CreationTime.HighPart;
            DFA1->CreationTime.LowPart = DFA2->CreationTime.LowPart = DavFileAttributes->CreationTime.LowPart;

            DFA1->DavCreationTime.HighPart = DFA2->DavCreationTime.HighPart = DavFileAttributes->DavCreationTime.HighPart;
            DFA1->DavCreationTime.LowPart = DFA2->DavCreationTime.LowPart = DavFileAttributes->DavCreationTime.LowPart;

            DFA1->LastModifiedTime.HighPart = DFA2->LastModifiedTime.HighPart = DavFileAttributes->LastModifiedTime.HighPart;
            DFA1->LastModifiedTime.LowPart = DFA2->LastModifiedTime.LowPart = DavFileAttributes->LastModifiedTime.LowPart;

            DFA1->DavLastModifiedTime.HighPart = DFA2->DavLastModifiedTime.HighPart = DavFileAttributes->DavLastModifiedTime.HighPart;
            DFA1->DavLastModifiedTime.LowPart = DFA2->DavLastModifiedTime.LowPart = DavFileAttributes->DavLastModifiedTime.LowPart;
            
            DFA1->LastAccessTime.HighPart = DFA2->LastAccessTime.HighPart = DavFileAttributes->LastAccessTime.HighPart;
            DFA1->LastAccessTime.LowPart = DFA2->LastAccessTime.LowPart = DavFileAttributes->LastAccessTime.LowPart;

            //
            // We need to add these two after the first entry. This is because
            // the first entry is always ignored when dealing with WildCard
            // queries in the kernel. This is done because the first entry is
            // the directory being enumerated and we don't need to show that.
            // So, if we had 1->2->3->....->n->1 (cyclic list), we need to insert 
            // DFA1 and DFA2 in the following manner.
            //                 1->DFA1->DFA2->2->3->......->n->1 (cyclic list)
            //                                ^
            //                                |
            //                                TempEntry
            // where DFA1 = L"." and DFA2 = L".."
            // We do this insertion below.
            //

            TempEntry = DavFileAttributes->NextEntry.Flink;
            InsertTailList(TempEntry, &(DFA1->NextEntry));
            InsertTailList(TempEntry, &(DFA2->NextEntry));
            TempEntry = NULL;
            fFreeDFAs = FALSE;

            //
            // We need to increment the number of file entries by 2 to take into
            // account the two new entries we added above.
            //
            NumOfFileEntries += 2;

            listEntry = DavFileAttributes->NextEntry.Flink;

            //
            // We start the Count with first value DavParseDataEx (value of Head
            // entry in the List) is setting in DavFileAttributes List.
            //
            Count = DavFileAttributes->FileIndex;

            //
            // Set the file indices.
            //
            DavFileAttributes->FileIndex = Count;
            Count++;
            while ( listEntry != &(DavFileAttributes->NextEntry) ) {
            
                TempDFA = CONTAINING_RECORD(listEntry, DAV_FILE_ATTRIBUTES, NextEntry);

                listEntry = listEntry->Flink;
            
                TempDFA->FileIndex = Count;

                Count++;
            
            }

            DavPrint((DEBUG_MISC,
                      "DavAsyncQueryDirectory: NumOfFileEntries = %d, Count = %d\n", 
                      NumOfFileEntries, Count));
        
        }

        //
        // Set the response to be sent down to the kernel. We send the pointer
        // to the head of the list that was allocated during parsing.
        //
        QueryDirResponse->DavFileAttributes = DavFileAttributes;
        QueryDirResponse->NumOfFileEntries = NumOfFileEntries;

        DavCloseContext(Ctx1, Ctx2);

        DavPrint((DEBUG_MISC,
                  "DavAsyncQueryDirectory: DavFileAttributes = %08lx.\n", 
                  DavFileAttributes));

    }
        break;

    default:

        WStatus = ERROR_INVALID_PARAMETER;
        
        DavPrint((DEBUG_ERRORS,
                  "DavAsyncQueryDirectory: Invalid DavOperation = %d.\n",
                  DavWorkItem->DavOperation));

        break;

    }

EXIT_THE_FUNCTION:

    
    if(fFreeDFAs == TRUE) {
        if(DFA1 != NULL) {
            DavFinalizeFileAttributesList(DFA1, TRUE);
            DFA1 = NULL;
        }
        if(DFA2 != NULL) {
            DavFinalizeFileAttributesList(DFA2, TRUE);
            DFA2 = NULL;
        }
        fFreeDFAs = FALSE;
    }
    
    //
    // If we did impersonate, we need to revert back.
    //
    if (didImpersonate) {
        ULONG RStatus;
        RStatus = UMReflectorRevert(UserWorkItem);
        if (RStatus != ERROR_SUCCESS) {
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncQueryDirectory/UMReflectorRevert. Error Val"
                      " = %d\n", RStatus));
        }
    }
    

    return WStatus;
}


VOID
DavAsyncQueryDirectoryCompletion(
    PDAV_USERMODE_WORKITEM DavWorkItem
    )
/*++

Routine Description:

   This routine handles the QueryDirectory completion. It basically frees up 
   the resources allocated during the QueryDirectory operation.

Arguments:

    DavWorkItem - The DAV_USERMODE_WORKITEM value.
    
Return Value:

    none.

--*/
{
    if (DavWorkItem->AsyncQueryDirectoryCall.DavOpenHandle != NULL) {
        BOOL ReturnVal;
        ULONG FreeStatus;
        HINTERNET DavOpenHandle = DavWorkItem->AsyncQueryDirectoryCall.DavOpenHandle;
        ReturnVal = InternetCloseHandle( DavOpenHandle );
        if (!ReturnVal) {
            FreeStatus = GetLastError();
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncQueryDirectoryCompletion/InternetCloseHandle. "
                      "Error Val = %d\n", FreeStatus));
        }
    }

    if (DavWorkItem->AsyncQueryDirectoryCall.DataBuff != NULL) {
        HLOCAL FreeHandle;
        ULONG FreeStatus;
        FreeHandle = LocalFree((HLOCAL)DavWorkItem->AsyncQueryDirectoryCall.DataBuff);
        if (FreeHandle != NULL) {
            FreeStatus = GetLastError();
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncQueryDirectoryCompletion/LocalFree. Error Val = %d\n", 
                      FreeStatus));
        }
    }
    
    if (DavWorkItem->AsyncQueryDirectoryCall.didRead != NULL) {
        HLOCAL FreeHandle;
        ULONG FreeStatus;
        FreeHandle = LocalFree((HLOCAL)DavWorkItem->AsyncQueryDirectoryCall.didRead);
        if (FreeHandle != NULL) {
            FreeStatus = GetLastError();
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncQueryDirectoryCompletion/LocalFree. Error Val = %d\n", 
                      FreeStatus));
        }
    }
    
    if (DavWorkItem->AsyncResult != NULL) {
        HLOCAL FreeHandle;
        ULONG FreeStatus;
        FreeHandle = LocalFree((HLOCAL)DavWorkItem->AsyncResult);
        if (FreeHandle != NULL) {
            FreeStatus = GetLastError();
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncQueryDirectoryCompletion/LocalFree. Error Val ="
                      " %d\n", FreeStatus));
        }
    }
    
    //
    // The callback context should not be finalized if we are returning
    // ERROR_IO_PENDING.
    //
    DavFsFinalizeTheDavCallBackContext(DavWorkItem);

    //
    // We are done with the per user entry, so finalize it.
    //
    if (DavWorkItem->AsyncQueryDirectoryCall.PerUserEntry) {
        DavFinalizePerUserEntry( &(DavWorkItem->AsyncQueryDirectoryCall.PerUserEntry) );
    }

    return;
}


ULONG
DavFsQueryVolumeInformation(
    PDAV_USERMODE_WORKITEM DavWorkItem
)
/*++

Routine Description:

    This routine handles QueryVolumeInformationRequest requests for the DAV Mini-Redir that 
    get reflected from the kernel.

Arguments:

    DavWorkItem - The buffer that contains the request parameters and options.

Return Value:

    The return status for the operation

--*/
{
    ULONG WStatus = ERROR_SUCCESS;
    PDAV_USERMODE_QUERYVOLUMEINFORMATION_REQUEST QueryVolumeInformationRequest;
    PWCHAR ServerName = NULL, ShareName = NULL;
    BOOL EnCriSec = FALSE, ReturnVal, CallBackContextInitialized = FALSE;
    ULONG ServerID;
    PPER_USER_ENTRY PerUserEntry = NULL;
    PHASH_SERVER_ENTRY ServerHashEntry = NULL;
    HINTERNET DavConnHandle, DavOpenHandle;
    BOOL didImpersonate = FALSE;
    PUMRX_USERMODE_WORKITEM_HEADER UserWorkItem = NULL;
    BOOL BStatus = FALSE;


    UserWorkItem = (PUMRX_USERMODE_WORKITEM_HEADER)DavWorkItem;

    //
    // Get the request buffer from the DavWorkItem.
    //
    QueryVolumeInformationRequest = &(DavWorkItem->QueryVolumeInformationRequest);

    //
    // The first character is a '\' which has to be stripped.
    //
    ServerName = &(QueryVolumeInformationRequest->ServerName[1]);
    if (!ServerName) {
        DavPrint((DEBUG_ERRORS, "DavFsQueryVolumeInformation: ServerName is NULL.\n"));
        WStatus = ERROR_INVALID_PARAMETER; // STATUS_INVALID_PARAMETER;
        goto EXIT_THE_FUNCTION;
    }
    DavPrint((DEBUG_MISC, "DavFsQueryVolumeInformation: ServerName = %ws.\n", ServerName));

    ServerID = QueryVolumeInformationRequest->ServerID;
    DavPrint((DEBUG_MISC, "DavFsQueryVolumeInformation: ServerID = %d.\n", ServerID));

    //
    // The first character is a '\' which has to be stripped.
    //
    ShareName = &(QueryVolumeInformationRequest->ShareName[1]);
    if (!ServerName) {
        DavPrint((DEBUG_ERRORS, "DavFsQueryVolumeInformation: ShareName is NULL.\n"));
        WStatus = ERROR_INVALID_PARAMETER; // STATUS_INVALID_PARAMETER;
        goto EXIT_THE_FUNCTION;
    }
    DavPrint((DEBUG_MISC, "DavFsQueryVolumeInformation: ShareName = %ws.\n", ShareName));

    //
    // If ShareName is a dummy share, we need to remove it right now before we 
    // contact the server.
    //
    DavRemoveDummyShareFromFileName(ShareName);

    DavPrint((DEBUG_MISC,
              "DavFsQueryVolumeInformation: LogonId.LowPart = %d, LogonId.HighPart = %d\n", 
              QueryVolumeInformationRequest->LogonID.LowPart,
              QueryVolumeInformationRequest->LogonID.HighPart));
              
    WStatus = UMReflectorImpersonate(UserWorkItem, DavWorkItem->ImpersonationHandle);
    if (WStatus != ERROR_SUCCESS) {
        DavPrint((DEBUG_ERRORS,
                  "DavFsCreateVNetRoot/UMReflectorImpersonate. Error Val = %d\n",
                  WStatus));
        goto EXIT_THE_FUNCTION;
    }
    didImpersonate = TRUE;
    //
    // Allocate memory for the INTERNET_ASYNC_RESULT structure.
    //
    DavWorkItem->AsyncResult = LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, 
                                          sizeof(INTERNET_ASYNC_RESULT));
    if (DavWorkItem->AsyncResult == NULL) {
        WStatus = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavFsQueryVolumeInformation/LocalAlloc. Error Val = %d\n",
                  WStatus));
        goto EXIT_THE_FUNCTION;
    }

    //
    // A User Entry for this user must have been created during the create call
    // earlier. The user entry contains the handle used to send an HttpOpen
    // request.
    //

    EnterCriticalSection( &(HashServerEntryTableLock) );
    EnCriSec = TRUE;

    ReturnVal = DavDoesUserEntryExist(ServerName,
                                      ServerID, 
                                      &(QueryVolumeInformationRequest->LogonID),
                                      &PerUserEntry,
                                      &ServerHashEntry);
    
    //
    // If the following request in the kernel get cancelled even before the 
    // corresponding usermode thread gets a chance to execute this code, then
    // it possible that the VNetRoot (hence the PerUserEntry) and SrvCall get
    // finalized before the thread that is handling the create comes here. This
    // could happen if this request was the only one for this share and the
    // server as well. This is why we need to check if the ServerHashEntry and
    // the PerUserEntry are valid before proceeding.
    //
    if (ReturnVal == FALSE || ServerHashEntry == NULL || PerUserEntry == NULL) {
        WStatus = ERROR_CANCELLED;
        DavPrint((DEBUG_ERRORS, "DavFsQueryVolumeInformation: (ServerHashEntry == NULL || PerUserEntry == NULL)\n"));
        goto EXIT_THE_FUNCTION;
    }

    DavWorkItem->AsyncQueryVolumeInformation.ServerHashEntry = ServerHashEntry;
    DavWorkItem->AsyncQueryVolumeInformation.PerUserEntry = PerUserEntry;

    DavPrint((DEBUG_MISC,
              "DavFsQueryVolumeInformation: PerUserEntry = %08lx.\n", 
              PerUserEntry));
    
    //
    // Add a reference to the user entry.
    //
    PerUserEntry->UserEntryRefCount++;

    //
    // Since a create had succeeded earlier, the entry must be good.
    //
    ASSERT(PerUserEntry->UserEntryState == UserEntryInitialized);
    ASSERT(PerUserEntry->DavConnHandle != NULL);

    //
    // And yes, we obviously have to leave the critical section
    // before returning.
    //
    LeaveCriticalSection( &(HashServerEntryTableLock) );
    EnCriSec = FALSE;
        
    //
    // We now call the HttpOpenRequest function and return.
    //
    DavWorkItem->DavOperation = DAV_CALLBACK_INTERNET_CONNECT;
    DavWorkItem->DavMinorOperation = DavMinorReadData;
    DavWorkItem->AsyncQueryVolumeInformation.PerUserEntry = PerUserEntry;

    WStatus = DavAsyncCommonStates(DavWorkItem, FALSE);

EXIT_THE_FUNCTION:

    if (EnCriSec) {
        LeaveCriticalSection( &(HashServerEntryTableLock) );
        EnCriSec = FALSE;
    }


    //
    // If we are using WinInet synchronously, then we should never get back
    // ERROR_IO_PENDING from WinInet.
    //
    ASSERT(WStatus != ERROR_IO_PENDING);

    //
    // If this thread impersonated a user, we need to revert back.
    //
    if (didImpersonate) {
        RevertToSelf();
    }

    //
    // Set the return status of the operation. This is used by the kernel
    // mode routines to figure out the completion status of the user mode
    // request. This is done here because the async completion routine that is
    // called immediately afterwards needs the status set.
    //
    if (WStatus != ERROR_SUCCESS) {
        DavWorkItem->Status = DavMapErrorToNtStatus(WStatus);
    } else {
        DavWorkItem->Status = STATUS_SUCCESS;
    }
    
    DavAsyncQueryVolumeInformationCompletion(DavWorkItem);

    return WStatus;
}


DWORD 
DavAsyncQueryVolumeInformation(
    PDAV_USERMODE_WORKITEM DavWorkItem,
    BOOLEAN CalledByCallBackThread
    )
/*++

Routine Description:

   This is the callback routine for the query directory operation.

Arguments:

    DavWorkItem - The DAV_USERMODE_WORKITEM value.

    CalledByCallbackThread - TRUE, if this function was called by the thread
                             which picks of the DavWorkItem from the Callback
                             function. This happens when an Async WinInet call
                             returns ERROR_IO_PENDING and completes later.

Return Value:

    ERROR_SUCCESS or the appropriate error value.

--*/
{
    ULONG WStatus = ERROR_SUCCESS;
    DAV_FILE_ATTRIBUTES DavFileAttributes;

    WStatus = DavParseXmlResponse(DavWorkItem->AsyncQueryVolumeInformation.DavOpenHandle, &DavFileAttributes, NULL);
    if (WStatus == ERROR_SUCCESS)
    {
        DavWorkItem->QueryVolumeInformationResponse.TotalSpace = 
        DavFileAttributes.TotalSpace;
        
        DavWorkItem->QueryVolumeInformationResponse.AvailableSpace = 
        DavFileAttributes.AvailableSpace;
        
        if (!*(LONGLONG *)&(DavWorkItem->QueryVolumeInformationResponse.TotalSpace))
        {
            *(LONGLONG *)&(DavWorkItem->QueryVolumeInformationResponse.TotalSpace) =             
            *(LONGLONG *)&(DavWorkItem->QueryVolumeInformationResponse.AvailableSpace)+MSN_SPACE_FAKE_DELTA;
        }
        
        DavFinalizeFileAttributesList(&DavFileAttributes, FALSE);
    }

    return WStatus;
}



VOID
DavAsyncQueryVolumeInformationCompletion(
    PDAV_USERMODE_WORKITEM DavWorkItem
    )
/*++

Routine Description:

   This routine handles the QueryVolumeInformation completion. It basically frees up 
   the resources allocated during the QueryVolumeInformation operation.

Arguments:

    DavWorkItem - The DAV_USERMODE_WORKITEM value.
    
Return Value:

    none.

--*/
{
    if (DavWorkItem->AsyncQueryVolumeInformation.DavOpenHandle != NULL) {
        BOOL ReturnVal;
        ULONG FreeStatus;
        ReturnVal = InternetCloseHandle(DavWorkItem->AsyncQueryVolumeInformation.DavOpenHandle);
        if (!ReturnVal) {
            FreeStatus = GetLastError();
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncQueryVolumeInformationCompletion/InternetCloseHandle. "
                      "Error Val = %d\n", FreeStatus));
        }
    }

    
    if (DavWorkItem->AsyncResult != NULL) {
        HLOCAL FreeHandle;
        ULONG FreeStatus;
        FreeHandle = LocalFree((HLOCAL)DavWorkItem->AsyncResult);
        if (FreeHandle != NULL) {
            FreeStatus = GetLastError();
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncQueryVolumeInformationCompletion/LocalFree. Error Val ="
                      " %d\n", FreeStatus));
        }
    }
    
    //
    // The callback context should not be finalized if we are returning
    // ERROR_IO_PENDING.
    //
    DavFsFinalizeTheDavCallBackContext(DavWorkItem);

    //
    // We are done with the per user entry, so finalize it.
    //
    if (DavWorkItem->AsyncQueryVolumeInformation.PerUserEntry) {
        DavFinalizePerUserEntry( &(DavWorkItem->AsyncQueryVolumeInformation.PerUserEntry) );
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\server\global.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    global.h

Abstract:

    This file contains globals and prototypes for user mode webdav client.

Author:

    Andy Herron (andyhe)  30-Mar-1999
    
    Rohan Kumar [RohanK]  01-Sept-1999

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _DAVGLOBAL_H
#define _DAVGLOBAL_H

#pragma once

#include <winsock2.h>
#include <align.h>
#include <winbasep.h>
#include "validc.h"

//
// If the following line is commented, the WinInet calls that are made will be
// synchronous and we use the Win32 thread pool to do the management. If its
// not commented, then we use WinInet asynchronously.
//
// #define DAV_USE_WININET_ASYNCHRONOUSLY 1

//
// svcmain.c will #include this file with GLOBAL_DATA_ALLOCATE defined.
// That will cause each of these variables to be allocated.
//
#ifdef  GLOBAL_DATA_ALLOCATE
#undef EXTERN
#define EXTERN
#define GLOBAL_DATA_ALLOCATED
#undef INIT_GLOBAL
#define INIT_GLOBAL(v) =v
#else
#define EXTERN extern
#define INIT_GLOBAL(v)
#endif

#define DAV_MAXTHREADCOUNT_DEFAULT 6
#define DAV_THREADCOUNT_DEFAULT 2

//
// Define all global variables here.
//
EXTERN HANDLE DavRedirDeviceHandle INIT_GLOBAL(INVALID_HANDLE_VALUE);

EXTERN CRITICAL_SECTION g_DavServiceLock;
EXTERN BOOLEAN g_DavServiceLockSet INIT_GLOBAL(FALSE);

EXTERN HINSTANCE g_hinst;

EXTERN BOOL g_RpcActive INIT_GLOBAL(FALSE);
EXTERN BOOL g_RedirLoaded INIT_GLOBAL(FALSE);
EXTERN BOOL g_registeredService INIT_GLOBAL(FALSE);

EXTERN BOOL g_WorkersActive INIT_GLOBAL(FALSE);

EXTERN SERVICE_STATUS_HANDLE g_hStatus;
EXTERN SERVICE_STATUS g_status;

EXTERN ULONG DavInitialThreadCount;
EXTERN ULONG DavMaxThreadCount;

EXTERN PUMRX_USERMODE_REFLECT_BLOCK DavReflectorHandle INIT_GLOBAL(NULL);

EXTERN WSADATA g_wsaData;
EXTERN BOOLEAN g_socketinit;

EXTERN BOOL g_LUIDDeviceMapsEnabled;

EXTERN UNICODE_STRING RedirDeviceName;

//
// This handle is set using InternetOpen function. The process passes this
// handle to subsequent functions like InternetConnect. Its maintained as a
// global to avoid creating such a handle on every call which goes to the
// server.
//
extern HINTERNET IHandle;

//
// A synchronous version of the Internet handle. This is used to satisfy some
// if the NP APIs without going to the kernel.
//
extern HINTERNET ISyncHandle;

//
// Dav Use Table. This table stores the "net use" connections made by the users
// per LogonId.
//
extern DAV_USERS_OBJECT DavUseObject;

//
// Number of users logged on to the system. The Critical section below it
// synchronizes the acces to this variable.
//
extern ULONG DavNumberOfLoggedOnUsers;
extern CRITICAL_SECTION DavLoggedOnUsersLock;
extern CRITICAL_SECTION DavPassportLock;

//
// The "wait hint time" told to the service control manager when the DAV
// service is starting.
//
#define DAV_WAIT_HINT_TIME 60000 // 60 Seconds

//
// Error codes special to DAV. Defined in RFC 2518 (Section 10). Its interesting
// to note that the value DAV_STATUS_INSUFFICIENT_STORAGE (below) has a higher
// value than HTTP_STATUS_LAST defined in WinInet.h. So, this value (507)
// becomes the highest possible return status from a Http/Dav server.
//
#define DAV_MULTI_STATUS                  207
#define DAV_STATUS_UNPROCESSABLE_ENTITY   422
#define DAV_STATUS_LOCKED                 423
#define DAV_STATUS_FAILED_DEPENDENCY      424
#define DAV_STATUS_INSUFFICIENT_STORAGE   507

//
// The dummy share that is added when a user does a "net use * http://server". 
// We allow this since this implies mapping a drive to the root of the DAV
// server.
//
#define DAV_DUMMY_SHARE L"DavWWWRoot"

//
// The different states of a server entry.
//
typedef enum _SERVER_ENTRY_STATES {

    //
    // Some thread is currently initializing this server entry.
    //
    ServerEntryInitializing = 0,

    //
    // The initialization was unsuccessful and this server is not being
    // considered a DAV server.
    //
    ServerEntryInitializationError,

    //
    // The server entry has been initializeed and is ready to use.
    //
    ServerEntryInitialized

} SERVER_ENTRY_STATES;

//
// The Server Hash Table entry.
//
typedef struct _HASH_SERVER_ENTRY {

    //
    // Name.
    //
    PWCHAR ServerName;

    //
    // Server ID. This ID is sent up by the kernel and is unique per server.
    //
    ULONG ServerID;

    //
    // The state of the server entry.
    //
    SERVER_ENTRY_STATES ServerEntryState;

    //
    // This event is set by the thread which creates and initializes a server
    // after it has initialized it. This is to wake up any threads which could
    // have been waiting for the initialization to finish.
    //
    HANDLE ServerEventHandle;
    
    //
    // If the initialization was unsuccessful, the error status is filled in
    // this varriable.
    //
    ULONG ErrorStatus;

    //
    // Is it a HTTP server ?
    //
    BOOL isHttpServer;

    //
    // Does it support the DAV extensions ?
    //
    BOOL isDavServer;

    //
    // Is it the Microsoft IIS ?
    //
    BOOL isMSIIS;

    //
    // Is it an Office Web Server?
    //
    BOOL isOfficeServer;
    
    //
    // Is it a TAHOE Server?
    //
    BOOL isTahoeServer;
    
    //
    // Does it support PROPPATCH ?
    //
    BOOL fSupportsProppatch;

    //
    // If the creation of the SrvCall failed because the credentials were not
    // correct (in other words, the user was not authorized) then we set this
    // to TRUE.
    //
    BOOL credentialFailure;
    
    //
    // Pointer to the per user list.
    //
    LIST_ENTRY PerUserEntry;

    //
    // The next entry.
    //
    LIST_ENTRY ServerListEntry;

    //
    // We need to keep a reference count on this ServerEntry.
    //
    ULONG ServerEntryRefCount;

    //
    // Size of this entry including the server name.
    //
    ULONG EntrySize;

    //
    // The timer value used in the delayed SrvCall finalization.
    //
    time_t TimeValueInSec;

    //
    // This is set to TRUE if the worker thread tried to finalize this server
    // hash entry. If this server entry is moved from "to be finalized" list
    // to the hash table, this value is checked. If its TRUE, it implies that
    // the reference counts on the user entries were decremented by the worker
    // thread and have to be incremented back again. It also implies that the
    // state of the user entry was set to closing and has to be reset.
    //
    BOOL HasItBeenScavenged;
    BOOL CookieIsNotUsed;

    //
    // This should be the last field.
    //
    WCHAR StrBuffer[1];

} HASH_SERVER_ENTRY, *PHASH_SERVER_ENTRY;

//
// TimeValueInSec is set to this value if it should not be removed from the
// Server hash table.
//
#define DONT_EXPIRE -1

//
// Whenever we encounter a server that does not speak the DAV protocol in the
// DavrDoesServerDoDav function, we add it to the NonDAVServerList. An entry
// is kept on this list for ServerNotFoundCacheLifeTimeInSec (a global read
// from the registry during service start-up). Before going on the network
// to figure out whether a server does DAV, we look in the list to see if we
// have already seen this server (which does not do DAV) and fail the call.
//
extern LIST_ENTRY NonDAVServerList;
extern CRITICAL_SECTION NonDAVServerListLock;

//
// The ServerEntry that is created and added to the NonDAVServerList each time
// we encounter a server that does not speak the DAV protocol in the 
// 
//
typedef struct _NON_DAV_SERVER_ENTRY {

    LIST_ENTRY listEntry;

    //
    // The name of the server which does not speak WebDAV.
    //
    PWCHAR ServerName;

    //
    // The time of creation of this entry.
    //
    time_t TimeValueInSec;

} NON_DAV_SERVER_ENTRY, *PNON_DAV_SERVER_ENTRY;

//
// The delay in sec that the user mode adds (to the finalization of the SrvCall)
// after the kernel mode does the finalization of the SrvCall.
//
#define DAV_SERV_CACHE_VALUE L"ServerNotFoundCacheLifeTimeInSec"
extern ULONG ServerNotFoundCacheLifeTimeInSec;

//
// Should we accept/claim the OfficeWebServers and TahoeWebServers?
//
#define DAV_ACCEPT_TAHOE_OFFICE_SERVERS L"AcceptOfficeAndTahoeServers"
extern ULONG AcceptOfficeAndTahoeServers;

//
// Should we LOCK (using the DAV LOCK Verb) the file on the server on the
// CreateFile path when needed? To know when exactly a LOCK is sent to the
// server, look at the (LOCKing) comments in the davcreat.c file.
//
#define DAV_SUPPORT_LOCKING_OF_FILES L"SupportLocking"
extern ULONG DavSupportLockingOfFiles;

//
// The maximum file size that is allowed by the WebDAV Redir. We keep a limit
// on the file size to avoid being attacked by a rogue server. A rogue server
// could keep on sending infinite amount of data which can cause the WebClient
// service to use 100% of the CPU.
//
#define DAV_FILE_SIZE_LIMIT L"FileSizeLimitInBytes"
extern ULONG DavFileSizeLimitInBytes;

//
// The maximum attributes size that is allowed by the WebDAV Redir. We keep a
// limit on this size to avoid being attacked by a rogue server. A rogue server
// could keep on sending infinite amount of data which can cause the WebClient
// service to use 100% of the CPU. This attribute limit covers all the 
// PROPFIND and PROPPATCH responses. For PROPFINDs with Depth 1 we make the
// limit a multiple of DavFileAttributesLimitInBytes (10 times).
//
#define DAV_ATTRIBUTES_SIZE_LIMIT L"FileAttributesLimitInBytes"
extern ULONG DavFileAttributesLimitInBytes;

//
// The Global HashTable containing the HashServerEntries and the lock used while
// accessing it. The server table has 512 entries because each entry is 8 bytes
// and so the table size is 4096 bytes (1 page).
//
#define SERVER_TABLE_SIZE  512
#define MAX_NUMBER_OF_SERVER_ENTRIES_PER_HASH_ID (((DWORD)(-1))/SERVER_TABLE_SIZE)

//
// The hash table containing server entries. When a CreateSrvCall requests comes
// up, this table is checked to see if the server entry exists. if it does not
// a new entry is created and added to the list.
//
extern LIST_ENTRY ServerHashTable[SERVER_TABLE_SIZE];

//
// This critical section synchronizes access to the ServerHashTable.
//
extern CRITICAL_SECTION HashServerEntryTableLock;

//
// This is a counter that gets incremented everytime a new server entry is
// created in the hash table. This defines the unique server id for the entry.
// The id values are never reused.
//
extern ULONG ServerIDCount;

//
// Mentioned below are the custom OFFICE and TAHOE headers which will be 
// returned in the response to a PROPFIND request.
//
extern WCHAR *DavTahoeCustomHeader;
extern WCHAR *DavOfficeCustomHeader;

//
// This list contains the following types of server entries:
// 1. The server entires for whom the SrvCall finalization has been received
//    from the kernel mode.
// 2. Server entries which failed during the Creation of SrvCall (after the
//    memory was allocated for the entry) and,
// This list is maintained for two reasons:
// 1. To delay the finalization of the SrvCall in user mode.  Instead of
//    finalizing these entries right away (after receiving the request from the
//    kernel), we keep them around for a certain time (say t sec). If a request
//    for creating a SrvCall for this server comes up again in these t sec, then
//    we just move this entry back to the ServerHashTable. This helps us in
//    avoiding network calls and,
// 2. To do negative caching. If a machine (for which the CreateSrvCall request
//    came up) is not a DAV server, we maintain this info for a while (t sec).
//    If another SrvCall request for the same server comes up in this t sec,
//    we can return error without going to the net. This is what we mean by
//    negative caching.
// A worker thread periodically goes over the list and checks the time each
// entry has spent in the list. If the time exceeds a certain threshold (t sec
// as defined above), it is removed from the list and finalized. The lock used
// to synchronize access to this list is the same one used to aceess the
// ServerHashEntry table.
//
extern LIST_ENTRY ToBeFinalizedServerEntries;

//
// The different states of a user entry.
//
typedef enum _USER_ENTRY_STATES {

    //
    // This user entry has been created, but not initialized.
    //
    UserEntryAllocated = 0,

    //
    // Some thread is currently initializing this entry.
    //
    UserEntryInitializing,

    //
    // The initialization was unsuccessful.
    //
    UserEntryInitializationError,

    //
    // The entry has been initialized and is ready to use.
    //
    UserEntryInitialized,

    //
    // The entry is going to be freed soon. If the entry is in this state,
    // no one should be using it.
    //
    UserEntryClosing

} USER_ENTRY_STATES;

//
// The "Per User Entry" data structure. A list of such entries is maintained
// per server entry in the server hash table (see below).
//
typedef struct _PER_USER_ENTRY {

    //
    // Unique logon/user ID for this session.
    //
    LUID LogonID;

    //
    // The server hash entry off which this user entry is hanging.
    //
    PHASH_SERVER_ENTRY ServerHashEntry;

    //
    // Pointer to the next "per user entry" for this server.
    //
    LIST_ENTRY UserEntry;

    //
    // The InternetConnect handle.
    //
    HINTERNET DavConnHandle;

    //
    // The state of this user entry. The thread that creates this user entry
    // sets its state to "UserEntryInitializing" before it initializes it.
    // This is done so that any other thread that comes in looking for this
    // entry when its in the middle of its initialization process can wait.
    //
    USER_ENTRY_STATES UserEntryState;

    //
    // This event is set by the thread which creates and initializes a user
    // after it has initialized it. This is to wake up any threads which could
    // have been waiting for the initialization to finish.
    //
    HANDLE UserEventHandle;

    //
    // The reference count value of this entry. This value is used in managing
    // the resource.
    //
    ULONG UserEntryRefCount;

    //
    // If the initialization was unsuccessful, the error status is filled in
    // this varriable.
    //
    ULONG ErrorStatus;

    //
    // The passport cookie for the this user/server pair.
    //
    PWCHAR Cookie;

    PWCHAR UserName;
    
    PWCHAR Password;

    DWORD BlockSizeInBytes;

} PER_USER_ENTRY, *PPER_USER_ENTRY;

#define PASSWORD_SEED 0x25

#include <davrpc.h>
#include "debug.h"

//
// Function prototypes go here.
//

DWORD
ReadDWord(
    HKEY KeyHandle,
    LPTSTR lpValueName,
    DWORD DefaultValue
    );

DWORD
SetupRpcServer(
    VOID
    );

DWORD
StopRpcServer(
    VOID
    );

VOID
UpdateServiceStatus (
    DWORD dwState
    );

NET_API_STATUS
WsLoadDriver(
    IN LPWSTR DriverNameString
    );

NET_API_STATUS
WsMapStatus(
    IN NTSTATUS NtStatus
    );

DWORD
DavReportEventW(
    DWORD EventID,
    DWORD EventType,
    DWORD NumStrings,
    DWORD DataLength,
    LPWSTR *Strings,
    LPVOID Data
    );

NET_API_STATUS
WsLoadRedir(
    VOID
    );

NET_API_STATUS
WsUnloadRedir(
    VOID
    );

DWORD
DavInitWorkerThreads(
    IN  ULONG  InitialThreadCount,
    IN  ULONG  MaxThreadCount
    );

DWORD
DavTerminateWorkerThreads(
    VOID
    );

ULONG
DavInit(
    VOID
    );

VOID
DavClose(
    VOID
    );

ULONG
DavHashTheServerName(
    PWCHAR ServerName
    );

BOOL
DavIsThisServerInTheTable(
    IN PWCHAR ServerName,
    OUT PHASH_SERVER_ENTRY *ServerHashEntry
    );

BOOL 
DavIsServerInFinalizeList(
    IN PWCHAR ServerName,
    OUT PHASH_SERVER_ENTRY *ServerHashEntry,
    IN BOOL ReactivateIfExists
    );

VOID
DavInitializeAndInsertTheServerEntry(
    IN OUT PHASH_SERVER_ENTRY ServerHashEntry,
    IN PWCHAR ServerName,
    IN ULONG EntrySize
    );

VOID
DavFinalizeToBeFinalizedList(
    VOID
    );

DWORD
DavPostWorkItem(
    LPTHREAD_START_ROUTINE Function,
    PDAV_USERMODE_WORKITEM DavContext
    );

ULONG
InitializeTheSocketInterface(
    VOID
    );

NTSTATUS
CleanupTheSocketInterface(
    VOID
    );

DWORD
DavAsyncCreateSrvCall(
    PDAV_USERMODE_WORKITEM DavWorkItem,
    BOOLEAN CalledByCallBackThread
    );

VOID
DavAsyncCreateSrvCallCompletion(
    PDAV_USERMODE_WORKITEM DavWorkItem
    );

DWORD 
DavAsyncCreate(
    PDAV_USERMODE_WORKITEM DavWorkItem,
    BOOLEAN CalledByCallBackThread
    );

VOID
DavAsyncCreateCompletion(
    PDAV_USERMODE_WORKITEM DavWorkItem
    );

DWORD 
DavAsyncQueryDirectory(
    PDAV_USERMODE_WORKITEM DavWorkItem,
    BOOLEAN CalledByCallBackThread
    );

VOID
DavAsyncQueryDirectoryCompletion(
    PDAV_USERMODE_WORKITEM DavWorkItem
    );

DWORD 
DavAsyncCreateVNetRoot(
    PDAV_USERMODE_WORKITEM DavWorkItem,
    BOOLEAN CalledByCallBackThread
    );

VOID
DavAsyncCreateVNetRootCompletion(
    PDAV_USERMODE_WORKITEM DavWorkItem
    );

DWORD
DavAsyncReName(
    PDAV_USERMODE_WORKITEM DavWorkItem,
    BOOLEAN CalledByCallBackThread
    );

VOID
DavAsyncReNameCompletion(
    PDAV_USERMODE_WORKITEM DavWorkItem
    );


DWORD
DavAsyncSetFileInformation(
    PDAV_USERMODE_WORKITEM DavWorkItem,
    BOOLEAN CalledByCallBackThread
    );

VOID
DavAsyncSetFileInformationCompletion(
    PDAV_USERMODE_WORKITEM DavWorkItem
    );

DWORD 
DavAsyncClose(
    PDAV_USERMODE_WORKITEM DavWorkItem,
    BOOLEAN CalledByCallBackThread
    );

VOID
DavAsyncCloseCompletion(
    PDAV_USERMODE_WORKITEM DavWorkItem
    );

ULONG
DavQueryPassportCookie(
    IN HINTERNET RequestHandle,
    IN OUT PWCHAR *Cookie
    );

VOID
DavDumpHttpResponseHeader(
    HINTERNET OpenHandle
    );

VOID
DavDumpHttpResponseData(
    HINTERNET OpenHandle
    );

ULONG
DavQueryAndParseResponse(
    HINTERNET DavOpenHandle
    );

ULONG
DavQueryAndParseResponseEx(
    IN HINTERNET DavOpenHandle,
    OUT PULONG HttpResponseStatus OPTIONAL
    );

VOID
DavRemoveDummyShareFromFileName(
    PWCHAR FileName
    );

ULONG
DavMapHttpErrorToDosError(
    ULONG HttpResponseStatus
    );

//
// The callback function used in asynchronous requests.
//
VOID
_stdcall
DavHandleAsyncResponse(
    HINTERNET IHandle,
    DWORD_PTR CallBackContext,
    DWORD InternetStatus,
    LPVOID StatusInformation,
    DWORD StatusInformationLength
    );

DWORD
WINAPI
DavCommonDispatch(
    LPVOID Context
    );

DWORD 
DavAsyncCommonStates(
    PDAV_USERMODE_WORKITEM DavWorkItem,
    BOOLEAN CalledByCallBackThread
    );

BOOL
DavDoesUserEntryExist(
    IN PWCHAR ServerName,
    IN ULONG ServerID,
    IN PLUID LogonID,
    OUT PPER_USER_ENTRY *PerUserEntry,
    OUT PHASH_SERVER_ENTRY *ServerHashEntry
    );

BOOL
DavFinalizePerUserEntry(
    PPER_USER_ENTRY *PUE
    );

ULONG
DavFsSetTheDavCallBackContext(
    IN OUT PDAV_USERMODE_WORKITEM pDavWorkItem
    );

VOID
DavFsFinalizeTheDavCallBackContext(
    IN PDAV_USERMODE_WORKITEM pDavWorkItem
    );

DWORD
DavUnLockTheFileOnTheServer(
    IN PDAV_USERMODE_WORKITEM DavWorkItem
    );

//
// Functions exposed to the usermode reflector library.
//
ULONG
DavFsCreate(
    PDAV_USERMODE_WORKITEM DavWorkItem
    );

ULONG
DavFsCreateSrvCall(
    PDAV_USERMODE_WORKITEM DavWorkItem
    );

ULONG
DavFsCreateVNetRoot(
    PDAV_USERMODE_WORKITEM DavWorkItem
    );

ULONG
DavFsFinalizeSrvCall(
    PDAV_USERMODE_WORKITEM DavWorkItem
    );

ULONG
DavFsFinalizeVNetRoot(
    PDAV_USERMODE_WORKITEM DavWorkItem
    );

ULONG
DavFsFinalizeFobx(
    PDAV_USERMODE_WORKITEM DavWorkItem
    );

ULONG
DavFsQueryDirectory(
    PDAV_USERMODE_WORKITEM DavWorkItem
    );

ULONG
DavFsQueryVolumeInformation(
    PDAV_USERMODE_WORKITEM DavWorkItem
    );

DWORD 
DavAsyncQueryVolumeInformation(
    PDAV_USERMODE_WORKITEM DavWorkItem,
    BOOLEAN CalledByCallBackThread
    );

VOID
DavAsyncQueryVolumeInformationCompletion(
    PDAV_USERMODE_WORKITEM DavWorkItem
    );
    
ULONG
DavFsReName(
    PDAV_USERMODE_WORKITEM DavWorkItem
    );


ULONG
DavFsSetFileInformation(
    PDAV_USERMODE_WORKITEM DavWorkItem
    );
    
ULONG
DavFsClose(
    PDAV_USERMODE_WORKITEM DavWorkItem
    );

ULONG
DavFsLockRefresh(
    PDAV_USERMODE_WORKITEM DavWorkItem
    );

NTSTATUS
DavMapErrorToNtStatus(
    DWORD dwWininetError
    );

NTSTATUS
DavDosErrorToNtStatus(
    DWORD dwError
    );
VOID
DavObtainServerProperties(
    PWCHAR lpInParseData, 
    BOOL    *lpfIsHttpServer,
    BOOL    *lpfIsIIs,
    BOOL    *lpfIsDavServer
    );

DWORD
DavTestProppatch(
    PDAV_USERMODE_WORKITEM DavWorkItem,
    HINTERNET hDavConnect,
    LPWSTR  lpPathName
    );

DWORD
DavSetBasicInformation(
    PDAV_USERMODE_WORKITEM DavWorkItem,
    HINTERNET hDavConnect,
    LPWSTR  PathName,
    BOOL fCreationTimeChanged,
    BOOL fLastAccessTimeChanged,
    BOOL fLastModifiedTimeChanged,
    BOOL fFileAttributesChanged,
    IN LARGE_INTEGER *lpCreationTime,
    IN LARGE_INTEGER *lpLastAccessTime,
    IN LARGE_INTEGER *lpLastModifiedTime,
    DWORD   dwFileAttributes
    );

DWORD
DavReportEventInEventLog(
    DWORD EventType,
    DWORD EventId,
    DWORD NumberOfStrings,
    PWCHAR *EventStrings
    );

DWORD
DavFormatAndLogError(
    PDAV_USERMODE_WORKITEM DavWorkItem,
    DWORD Win32Status
    );


DWORD
DavParseXmlResponse(
    HINTERNET DavOpenHandle,
    DAV_FILE_ATTRIBUTES *pDavFileAttributesIn,
    DWORD               *pNumFileEntries
    );

DWORD
DavAttachPassportCookie(
    PDAV_USERMODE_WORKITEM DavWorkItem,
    HINTERNET DavOpenHandle,
    PWCHAR *PassportCookie
    );

DWORD
DavInternetSetOption(
    PDAV_USERMODE_WORKITEM DavWorkItem,
    HINTERNET DavOpenHandle
    );

#endif // DAVGLOBAL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\server\nodefac.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    nodefac.h
    
Abstract:

    This module defines the CDavnodefactory class, which implements the 
    NodeFactory API, used to parse XML. It also exports the wrapper functions
    that the C code uses to parse XML data. We need wrapper functions around the
    C++ API.

Author:

    Rohan Kumar      [RohanK]      14-Sept-1999

Revision History:

--*/

#ifndef _NODE_FACTORY_
#define _NODE_FACTORY_

#include <stdio.h>
#include <windows.h>

#ifdef __cplusplus

#include <objbase.h>
#include "xmlparser.h"

#if DBG
#define XmlDavDbgPrint(_x_) DbgPrint _x_
#else
#define XmlDavDbgPrint(_x_)
#endif

typedef enum _CREATE_NODE_ATTRIBUTES {
    CreateNode_isHidden = 0,
    CreateNode_isCollection,
    CreateNode_ContentLength,
    CreateNode_CreationTime,
    CreateNode_DisplayName,
    CreateNode_LastModifiedTime,
    CreateNode_Status,
    CreateNode_Win32FileAttributes,
    CreateNode_Win32CreationTime,
    CreateNode_Win32LastAccessTime,
    CreateNode_Win32LastModifiedTime,
    CreateNode_ResourceType,
    CreateNode_AvailableSpace,
    CreateNode_TotalSpace,
    CreateNode_Owner,
    CreateNode_Timeout,
    CreateNode_LockToken,
    CreateNode_Max
} CREATE_NODE_ATTRIBUTES;

//
// IMPORTANT!!! The next two typedefs have been copied from standard files. 
// This was done because including the standard header files was causing many 
// compilation errors. This should be changed at some point.
//
typedef short CSHORT;
typedef struct _TIME_FIELDS {
    CSHORT Year;        // range [1601...]
    CSHORT Month;       // range [1..12]
    CSHORT Day;         // range [1..31]
    CSHORT Hour;        // range [0..23]
    CSHORT Minute;      // range [0..59]
    CSHORT Second;      // range [0..59]
    CSHORT Milliseconds;// range [0..999]
    CSHORT Weekday;     // range [0..6] == [Sunday..Saturday]
} TIME_FIELDS, *PTIME_FIELDS;

//
// Copied from a standard header file. Must be fixed.
//

#define InsertTailList(ListHead, Entry) { \
    PLIST_ENTRY _EX_Blink;                \
    PLIST_ENTRY _EX_ListHead;             \
    _EX_ListHead = (ListHead);            \
    _EX_Blink = _EX_ListHead->Blink;      \
    (Entry)->Flink = _EX_ListHead;        \
    (Entry)->Blink = _EX_Blink;           \
    _EX_Blink->Flink = (Entry);           \
    _EX_ListHead->Blink = (Entry);        \
}

#define RemoveEntryList(Entry) {          \
    PLIST_ENTRY _EX_Blink;                \
    PLIST_ENTRY _EX_Flink;                \
    _EX_Flink = (Entry)->Flink;           \
    _EX_Blink = (Entry)->Blink;           \
    _EX_Blink->Flink = _EX_Flink;         \
    _EX_Flink->Blink = _EX_Blink;         \
}

//
// The CDavNodeFactory class which implements the NodeFactory API for parsing 
// the XML responses from the DAV server. 
//
class CDavNodeFactory : public IXMLNodeFactory {

public:
        
    ULONG m_ulRefCount;
    PDAV_FILE_ATTRIBUTES m_DavFileAttributes;

    //
    // These are used in the CreateNode function to parse the XML responses.
    //
    BOOL m_FoundEntry, m_CreateNewEntry;
    ULONG m_FileIndex;
    CREATE_NODE_ATTRIBUTES m_CreateNodeAttribute;
    PDAV_FILE_ATTRIBUTES m_DFAToUse;
    PDAV_FILE_ATTRIBUTES m_CollectionDFA;
    DWORD m_MinDisplayNameLength;

    CDavNodeFactory() : m_ulRefCount(0), m_DavFileAttributes(NULL), 
                        m_FoundEntry(FALSE), m_FileIndex(0), m_DFAToUse(NULL), 
                        m_CollectionDFA(NULL), m_MinDisplayNameLength((DWORD)-1),
                        m_CreateNewEntry(FALSE), 
                        m_CreateNodeAttribute(CreateNode_Max)
    {}

    //
    // IUnknown interface methods.
    //
    
    virtual STDMETHODIMP_(ULONG) 
    AddRef(
        VOID
        );
    
    virtual STDMETHODIMP_(ULONG) 
    Release(
        VOID
        );

    virtual STDMETHODIMP 
    QueryInterface(
        REFIID riid, 
        LPVOID *ppvObject
        );

    //
    // IXMLNodeFactory interface methods.
    //
    
    virtual HRESULT STDMETHODCALLTYPE 
    NotifyEvent( 
        IXMLNodeSource __RPC_FAR *pSource,
        XML_NODEFACTORY_EVENT iEvt
        ); 
    
    virtual HRESULT STDMETHODCALLTYPE 
    BeginChildren(
        IXMLNodeSource __RPC_FAR * pSource,
        XML_NODE_INFO __RPC_FAR * pNodeInfo
        );

    virtual HRESULT STDMETHODCALLTYPE 
    EndChildren(
        IXMLNodeSource __RPC_FAR * pSource,
        BOOL fEmptyNode,
        XML_NODE_INFO __RPC_FAR * pNodeInfo
        );
    
    virtual HRESULT STDMETHODCALLTYPE 
    Error( 
        IXMLNodeSource __RPC_FAR *pSource,
        HRESULT hrErrorCode,
        USHORT cNumRecs,
        XML_NODE_INFO __RPC_FAR *__RPC_FAR *apNodeInfo
        );
    
    virtual HRESULT STDMETHODCALLTYPE 
    CreateNode(
        IN IXMLNodeSource __RPC_FAR *pSource,
        IN PVOID pNodeParent,
        IN USHORT cNumRecs,
        IN XML_NODE_INFO __RPC_FAR **aNodeInfo
        );
    
};

extern "C" {

ULONG
DavPushData(
    IN PCHAR DataBuff,
    IN OUT PVOID *Context1,
    IN OUT PVOID *Context2,
    IN ULONG NumOfBytes,
    IN BOOL isLast
    );

ULONG
DavParseData(
    PDAV_FILE_ATTRIBUTES DavFileAttributes,
    PVOID Context1,
    PVOID Conttext2,
    ULONG *NumOfFileEntries
    );

ULONG
DavParseDataEx(
    IN OUT PDAV_FILE_ATTRIBUTES DavFileAttributes,
    IN PVOID Context1,
    IN PVOID Context2,
    OUT ULONG *NumOfFileEntries,
    OUT DAV_FILE_ATTRIBUTES ** pCollectionDFA
    );

VOID
DavFinalizeFileAttributesList(
    PDAV_FILE_ATTRIBUTES DavFileAttributes,
    BOOL fFreeHeadDFA
    );

VOID
DavCloseContext(
    PVOID Context1,
    PVOID Context2
    );

//
// IMPORTANT!!! The next prototype has been copied from a standard ".h" file. 
// This was done because including the standard header file was causing many 
// compilation errors. This should be changed at some point.
//
NTSYSAPI
BOOLEAN
NTAPI
RtlTimeFieldsToTime (
    PTIME_FIELDS TimeFields,
    PLARGE_INTEGER Time
    );

ULONG
DbgPrint(
    PSTR Format,
    ...
    );

}

ULONG
DavParsedateTimetzTimeString(
    PWCHAR TimeString,
    PLARGE_INTEGER lpft
    );

ULONG
DavParseRfc1123TimeString(
    PWCHAR TimeString,
    PDAV_FILE_ATTRIBUTES DavFileAttributes,
    CREATE_NODE_ATTRIBUTES CreateNodeAttribute
    );

#else

//
// These calls are wrapper routines used by the C code to parse XML using the
// NodeFactory C++ API that we are implementing.
//

ULONG
DavPushData(
    IN PCHAR DataBuff,
    IN OUT PVOID *Context1,
    IN OUT PVOID *Context2,
    IN ULONG NumOfBytes,
    IN BOOL isLast
    );

ULONG
DavParseData(
    PDAV_FILE_ATTRIBUTES DavFileAttributes,
    PVOID Context1,
    PVOID Conttext2,
    ULONG *NumOfFileEntries
    );

ULONG
DavParseDataEx(
    IN OUT PDAV_FILE_ATTRIBUTES DavFileAttributes,
    IN PVOID Context1,
    IN PVOID Context2,
    OUT ULONG *NumOfFileEntries,
    OUT DAV_FILE_ATTRIBUTES ** pCollectionDFA
    );

VOID
DavFinalizeFileAttributesList(
    PDAV_FILE_ATTRIBUTES DavFileAttributes, 
    BOOL fFreeHeadDFA
    );

VOID
DavCloseContext(
    PVOID Context1,
    PVOID Context2
    );

#endif // __cplusplus


#endif  // _NODE_FACTORY_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\server\netroot.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    netroot.c
    
Abstract:

    This module implements the user mode DAV miniredir routine(s) pertaining to 
    the CreateVNetRoot call.

Author:

    Rohan Kumar      [RohanK]      1-Sept-2000

Revision History:

--*/

#include "pch.h"
#pragma hdrstop

#include "ntumrefl.h"
#include "usrmddav.h"
#include "global.h"
#include "nodefac.h"
#include "UniUtf.h"
#include <wincrypt.h>


//
// Mentioned below are the custom OFFICE and TAHOE headers which will be 
// returned in the response to a PROPFIND request.
//
WCHAR *DavTahoeCustomHeader = L"MicrosoftTahoeServer";
WCHAR *DavOfficeCustomHeader = L"MicrosoftOfficeWebServer";

ULONG
DavFsCreateVNetRoot(
    PDAV_USERMODE_WORKITEM DavWorkItem
    )
/*++

Routine Description:

    This routine handles CreateVNetRoot requests for the DAV Mini-Redir that 
    get reflected from the kernel.

Arguments:

    DavWorkItem - The buffer that contains the request parameters and options.

Return Value:

    The return status for the operation

--*/
{
    ULONG WStatus = ERROR_SUCCESS;
    PWCHAR ServerName = NULL, ShareName = NULL, CanName = NULL;
    ULONG_PTR CallBackContext = (ULONG_PTR)0;
    BOOL EnCriSec = FALSE, CallBackContextInitialized = FALSE;
    BOOL didICreateUserEntry = FALSE;
    ULONG ServerID = 0;
    PPER_USER_ENTRY PerUserEntry = NULL;
    PHASH_SERVER_ENTRY ServerHashEntry = NULL;
    HINTERNET DavConnHandle, DavOpenHandle;
    PDAV_USERMODE_CREATE_V_NET_ROOT_REQUEST CreateVNetRootRequest = NULL;
    BOOL didImpersonate = FALSE;
    PUMRX_USERMODE_WORKITEM_HEADER UserWorkItem = NULL;
    BOOL BStatus = FALSE;
    BOOL UserEntryExists = FALSE;

    //
    // Get the request buffer from the DavWorkItem.
    //
    CreateVNetRootRequest = &(DavWorkItem->CreateVNetRootRequest);

    //
    // The first character is a '\' which has to be stripped.
    //
    ServerName = &(CreateVNetRootRequest->ServerName[1]);
    if (!ServerName) {
        DavPrint((DEBUG_ERRORS, "DavFsCreateVNetRoot: ServerName is NULL.\n"));
        WStatus = ERROR_INVALID_PARAMETER; // STATUS_INVALID_PARAMETER;
        goto EXIT_THE_FUNCTION;
    }
    DavPrint((DEBUG_MISC, "DavFsCreateVNetRoot: ServerName = %ws.\n", ServerName));

    ServerID = CreateVNetRootRequest->ServerID;
    DavPrint((DEBUG_MISC, "DavFsCreateVNetRoot: ServerID = %d.\n", ServerID));

    //
    // The first character is a '\' which has to be stripped.
    //
    ShareName = &(CreateVNetRootRequest->ShareName[1]);
    if (!ShareName) {
        DavPrint((DEBUG_ERRORS, "DavFsCreateVNetRoot: ShareName is NULL.\n"));
        WStatus = ERROR_INVALID_PARAMETER; // STATUS_INVALID_PARAMETER;
        goto EXIT_THE_FUNCTION;
    }
    DavPrint((DEBUG_MISC, "DavFsCreateVNetRoot: ShareName = %ws.\n", ShareName));

    //
    // If ShareName is a dummy share, we need to remove it right now before we 
    // contact the server.
    //
    DavRemoveDummyShareFromFileName(ShareName);

    DavPrint((DEBUG_MISC,
              "DavFsCreateVNetRoot: LogonId.LowPart = %d, LogonId.HighPart = %d\n", 
              CreateVNetRootRequest->LogonID.LowPart,
              CreateVNetRootRequest->LogonID.HighPart));

    UserWorkItem = (PUMRX_USERMODE_WORKITEM_HEADER)DavWorkItem;

    //
    // If we are using WinInet synchronously, then we need to impersonate the
    // clients context now.
    //
#ifndef DAV_USE_WININET_ASYNCHRONOUSLY
    
    WStatus = UMReflectorImpersonate(UserWorkItem, DavWorkItem->ImpersonationHandle);
    if (WStatus != ERROR_SUCCESS) {
        DavPrint((DEBUG_ERRORS,
                  "DavFsCreateVNetRoot/UMReflectorImpersonate. Error Val = %d\n",
                  WStatus));
        goto EXIT_THE_FUNCTION;
    }
    didImpersonate = TRUE;

#endif

    //
    // We need to call this only if "DAV_USE_WININET_ASYNCHRONOUSLY" has been
    // defined. Otherwise, if we are using WinInet synchronously, then we 
    // would have already done this in the DavWorkerThread function. This 
    // ultimately gets deleted (the impersonation token that is) in the 
    // DavAsyncCreateCompletion function.
    //
#ifdef DAV_USE_WININET_ASYNCHRONOUSLY
    
    //
    // Set the DavCallBackContext.
    //
    WStatus = DavFsSetTheDavCallBackContext(DavWorkItem);
    if (WStatus != ERROR_SUCCESS) {
        DavPrint((DEBUG_ERRORS,
                  "DavFsCreateVNetRoot/DavFsSetTheDavCallBackContext. "
                  "Error Val = %d\n", WStatus));
        goto EXIT_THE_FUNCTION;
    }
    CallBackContextInitialized = TRUE;

    //
    // Store the address of the DavWorkItem which serves as a callback in the 
    // variable CallBackContext. This will now be used in all the async calls
    // that follow.
    //
    CallBackContext = (ULONG_PTR)(DavWorkItem);

#endif

    //
    // Allocate memory for the INTERNET_ASYNC_RESULT structure.
    //
    DavWorkItem->AsyncResult = LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, 
                                          sizeof(INTERNET_ASYNC_RESULT));
    if (DavWorkItem->AsyncResult == NULL) {
        WStatus = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavFsCreateVNetRoot/LocalAlloc. Error Val = %d\n",
                  WStatus));
        goto EXIT_THE_FUNCTION;
    }

    //
    // Find out whether we already have a "InternetConnect" handle to the
    // server. One could have been created during the CreateSrvCall process.
    // We can check the per user entries hanging off this server to see if an
    // entry for this user exists. If it does, use the InternetConnect handle
    // to do the HttpOpen. Otherwise, create and entry for this user and add it
    // to the list of the per user entries of the server.
    //

    //
    // Now check whether this user has an entry hanging off the server entry in
    // the hash table. Obviously, we have to take a lock before accessing the
    // server entries of the hash table.
    //
    EnterCriticalSection( &(HashServerEntryTableLock) );
    EnCriSec = TRUE;

    UserEntryExists = DavDoesUserEntryExist(ServerName,
                                            ServerID, 
                                            &(CreateVNetRootRequest->LogonID),
                                            &PerUserEntry,
                                            &ServerHashEntry);

    //
    // If the CreateVNetRoot gets cancelled in the kernel after the CreateSrvCall
    // succeeds, then you could get the FinalizeSrvCall go through if the thread
    // that picks up the CreateVNetRoot request gets preempted. This removes the
    // entry from the ServerHashList. We need to check for the value of
    // ServerHashEntry being NULL before proceeding further while Creating the
    // PerUserEntry below. Since this condition can only arise if the operation
    // has been cancelled we return ERROR_CANCELLED. Actually the return value
    // doesn't matter since the kernel request has already been cancelled.
    //
    if (ServerHashEntry == NULL) {
        WStatus = ERROR_CANCELLED;
        DavPrint((DEBUG_ERRORS, "DavFsCreateVNetRoot: ServerHashEntry == NULL\n"));
        goto EXIT_THE_FUNCTION;
    }

    DavWorkItem->AsyncCreateVNetRoot.ServerHashEntry = ServerHashEntry;

    if (!UserEntryExists) {
        
        //
        // The user entry was not found, so we need to create one.
        //
        DavPrint((DEBUG_MISC, "DavFsCreateVNetRoot: UserEntryNotFound. Calling InternetConnect\n"));

        PerUserEntry = LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, sizeof(PER_USER_ENTRY));
        if (PerUserEntry == NULL) {
            WStatus = GetLastError();
            DavPrint((DEBUG_ERRORS,
                      "DavFsCreateVNetRoot/LocalAlloc. Error Val = %d.\n", WStatus));
            goto EXIT_THE_FUNCTION;
        }

        //
        // Yes, I created this UserEntry. If I fail now, I need to finalize twice.
        // This is because, we don't want to keep this entry if we fail.
        //
        didICreateUserEntry = TRUE;

        //
        // Add the user entry to the per user list of the server.
        //
        InsertHeadList(&(ServerHashEntry->PerUserEntry), &(PerUserEntry->UserEntry));

        //
        // Take a reference on the ServerHashEntry. This ServerHashEntry needs
        // to be valid as long as this PerUserEntry is in use. With the logic
        // of cancellation that has been added to the kernel mode this can no
        // longer be guaranteed by the RDBSS logic. As an example, you can
        // get a FinalizeSrvCall while a usermode thread is creating a NetRoot,
        // because the CreateVNetRoot in the kernel got cancelled since the
        // usermode thread that was handling the CreateVNetRoot call took a
        // long time. You want the ServerHashEntry to hang around till all the
        // PerUserEntries associated with it are in use.
        //
        ServerHashEntry->ServerEntryRefCount++;

        //
        // Back pointer to the Server hash entry.
        //
        PerUserEntry->ServerHashEntry = ServerHashEntry;

        PerUserEntry->UserEntryState = UserEntryInitializing;

        //
        // Set the value of Reference count to 1. This value is decremented 
        // when the finalization of this VNetRoot happens.
        //
        PerUserEntry->UserEntryRefCount = 1;

        //
        // We keep track of the fact that we took a reference on this 
        // PerUserEntry.
        //
        DavWorkItem->AsyncCreateVNetRoot.didITakeReference = TRUE;

        //
        // Copy the LogonID.
        //
        PerUserEntry->LogonID.LowPart = CreateVNetRootRequest->LogonID.LowPart;
        PerUserEntry->LogonID.HighPart = CreateVNetRootRequest->LogonID.HighPart;

        //
        // Create a event which has to be manually set to non-signalled state and
        // set it to "not signalled".
        //
        PerUserEntry->UserEventHandle = CreateEvent(NULL, TRUE, FALSE, NULL);
        if (PerUserEntry->UserEventHandle == NULL) {
            //
            // Set the state of the entry to error in initialization.
            //
            PerUserEntry->UserEntryState = UserEntryInitializationError;
            WStatus = GetLastError();
            PerUserEntry->ErrorStatus = WStatus;
            DavPrint((DEBUG_ERRORS,
                      "DavFsCreateVNetRoot/CreateEvent. Error Val = %d\n", WStatus));
            goto EXIT_THE_FUNCTION;
        }
    
        if (wcslen(DavWorkItem->UserName)) {

            PerUserEntry->UserName = LocalAlloc((LMEM_FIXED | LMEM_ZEROINIT), 
                                                (wcslen(DavWorkItem->UserName) + 1) * sizeof(WCHAR));
            if (PerUserEntry->UserName == NULL) {
                WStatus = GetLastError();
                DavPrint((DEBUG_ERRORS, 
                          "DavFsCreateVNetRoot/LocalAlloc: Error Val = %d\n", 
                          WStatus));
                goto EXIT_THE_FUNCTION;
            }

            wcscpy(PerUserEntry->UserName, DavWorkItem->UserName);
        
        }

        if (wcslen(DavWorkItem->Password)) {

            DWORD NumOfBlocks = 0, BlockSizeInBytes = 0, PasswordLenInBytes = 0;
            BOOL ReturnVal = FALSE;

            PasswordLenInBytes = ( (wcslen(DavWorkItem->Password) + 1) * sizeof(WCHAR) );

            NumOfBlocks = ( (PasswordLenInBytes / CRYPTPROTECTMEMORY_BLOCK_SIZE) + 1 );

            BlockSizeInBytes = (NumOfBlocks * CRYPTPROTECTMEMORY_BLOCK_SIZE);

            PerUserEntry->Password = LocalAlloc((LMEM_FIXED | LMEM_ZEROINIT), BlockSizeInBytes); 
            if (PerUserEntry->Password == NULL) {
                WStatus = GetLastError();
                DavPrint((DEBUG_ERRORS, 
                          "DavFsCreateVNetRoot/LocalAlloc: Error Val = %d\n", 
                          WStatus));
                goto EXIT_THE_FUNCTION;
            }

            wcscpy(PerUserEntry->Password, DavWorkItem->Password);

            ReturnVal = CryptProtectMemory(PerUserEntry->Password, BlockSizeInBytes, CRYPTPROTECTMEMORY_SAME_PROCESS);
            if (!ReturnVal) {
                WStatus = GetLastError();
                DavPrint((DEBUG_ERRORS, 
                          "DavFsCreateVNetRoot/CryptProtectMemory: Error Val = %d\n", 
                          WStatus));
                goto EXIT_THE_FUNCTION;
            }

            PerUserEntry->BlockSizeInBytes = BlockSizeInBytes;

            DavPrint((DEBUG_MISC, "DavFsCreateVNetRoot: NumOfBlocks = %d\n", NumOfBlocks));

            DavPrint((DEBUG_MISC, "DavFsCreateVNetRoot: BlockSizeInBytes = %d\n", BlockSizeInBytes));

            DavPrint((DEBUG_MISC,
                      "DavFsCreateVNetRoot: PlainPassword = %ws, EncryptedPassword = %ws\n",
                      DavWorkItem->Password, PerUserEntry->Password));

        } else {

            PerUserEntry->BlockSizeInBytes = 0;

        }

    } else {

        if ( PerUserEntry->UserName && wcslen(DavWorkItem->UserName) ) {

            if (wcscmp(PerUserEntry->UserName, DavWorkItem->UserName) != 0) {

                WStatus = ERROR_SESSION_CREDENTIAL_CONFLICT;

                goto EXIT_THE_FUNCTION;

            }

        }

    }

    //
    // If the user entry did not exist, we would have created one by now.
    //
    ASSERT(PerUserEntry != NULL);
    
    DavWorkItem->AsyncCreateVNetRoot.PerUserEntry = PerUserEntry;

    //
    // We enter the following if under two conditions.
    // 1. If the DavConnHandle is not NULL. This means that some other thread
    //    is either in the process of completing the VNetRoot create or that the
    //    VNetRoot create has already completed and we have a DavConnHandle 
    //    which can be used to issue the Http query. If the handle is in the 
    //    process if being created then we wait since the thread that is 
    //    creating the handle will finally signal when its done.
    // 2. DavConnHandle is NULL, but the UserEntryState is UserEntryInitializing 
    //    and this thread did not create this user entry. This means that some
    //    other thread which created the user entry or which took the created 
    //    user entry in UserEntryAllocated state is in the process of completing 
    //    the VNetRoot create. Once this is done the DavConnHandle will be 
    //    available to issue the Http queries. 
    //
    if ( ( PerUserEntry->DavConnHandle != NULL ||
           ( PerUserEntry->UserEntryState == UserEntryInitializing &&
             didICreateUserEntry == FALSE ) ) ) {

        DavPrint((DEBUG_MISC, "DavFsCreateVNetRoot: PerUserEntry->DavConnHandle != NULL\n"));
        
        //
        // If the code comes here, it imples that this thread did not create
        // the PerUserEntry. This is because, if we created the PerUserEntry
        // above, PerUserEntry->DavConnHandle will be NULL and no one would have
        // changed it since we are still holding the CriticalSection lock.
        //
        ASSERT(didICreateUserEntry == FALSE);

        //
        // We need to increment the reference count on the PerUserEntry since
        // this VNetRoot create is for a different share than the one for which
        // a thread is currently creating or has already created the WinInet
        // InternetConnect handle.
        //
        PerUserEntry->UserEntryRefCount++;

        //
        // We keep track of the fact that we took a reference on this 
        // PerUserEntry.
        //
        DavWorkItem->AsyncCreateVNetRoot.didITakeReference = TRUE;
        
        //
        // An entry does exist. But, we need to take the next step depending
        // upon the state of this entry.
        //

        //
        // If its initializing, then I need to free the lock and wait on the
        // event.
        //
        if (PerUserEntry->UserEntryState == UserEntryInitializing) {
            
            DWORD WaitStatus;

            LeaveCriticalSection( &(HashServerEntryTableLock) );
            EnCriSec = FALSE;

            WaitStatus = WaitForSingleObject(PerUserEntry->UserEventHandle, INFINITE);
            if (WaitStatus == WAIT_FAILED) {
                WStatus = GetLastError();
                DavPrint((DEBUG_ERRORS,
                          "DavFsCreateVNetRoot/WaitForSingleObject. Error Val = %d.\n",
                           WStatus));
                goto EXIT_THE_FUNCTION;
            }
            
            ASSERT(WaitStatus == WAIT_OBJECT_0);
        
        }

        //
        // We could have left the lock while waiting on an event. If we have,
        // then we need to acquire it back before proceeding further.
        //
        if (!EnCriSec) {
            EnterCriticalSection( &(HashServerEntryTableLock) );
            EnCriSec = TRUE;
        }

        if (PerUserEntry->UserEntryState == UserEntryClosing) {
            DavPrint((DEBUG_ERRORS, "DavFsCreateVNetRoot: UserEntryClosing.\n"));
            WStatus = ERROR_INVALID_PARAMETER;
            LeaveCriticalSection( &(HashServerEntryTableLock) );
            EnCriSec = FALSE;
            goto EXIT_THE_FUNCTION;
        }

        if (PerUserEntry->UserEntryState == UserEntryInitializationError) {
            DavPrint((DEBUG_ERRORS, "DavFsCreateVNetRoot: UserEntryInitializationError\n"));
            WStatus = PerUserEntry->ErrorStatus;
            LeaveCriticalSection( &(HashServerEntryTableLock) );
            EnCriSec = FALSE;
            goto EXIT_THE_FUNCTION;
        }

        ASSERT(PerUserEntry->UserEntryState == UserEntryInitialized);

        //
        // Since its initialized, the DavConnHandle should be OK.
        //
        ASSERT(PerUserEntry->DavConnHandle != NULL);
        DavConnHandle = PerUserEntry->DavConnHandle;

        //
        // And yes, we obviously have to leave the critical section
        // before returning.
        //
        LeaveCriticalSection( &(HashServerEntryTableLock) );
        EnCriSec = FALSE;
        
    } else {
        
        //
        // If we come here, it means that the PerUserEntry has been created, but
        // the InternetConnect handle has not. We could have created the user
        // entry above or it could have been created in the Passport Auth code
        // which creates PerUserEnrty to store cookies, but does not do the 
        // InternetConnect.
        //

        if (PerUserEntry->UserEntryState == UserEntryInitializing) {
            
            DavPrint((DEBUG_MISC, "DavFsCreateVNetRoot: PerUserEntry->UserEntryState == UserEntryInitializing\n"));
            
            ASSERT(didICreateUserEntry == TRUE);
        
        } else {
            
            //
            // This entry was created to store the Passport cookies and was not
            // created above. We need to add a reference to the PerUserEntry here
            // since this user entry was created in the DavAddEntriesForPassportCookies
            // routine. This reference count will be decremented when the 
            // finalization of this VNetRoot happens.
            //
            PerUserEntry->UserEntryRefCount++;
            
            //
            // We keep track of the fact that we took a reference on this 
            // PerUserEntry.
            //
            DavWorkItem->AsyncCreateVNetRoot.didITakeReference = TRUE;

            DavPrint((DEBUG_MISC, "DavFsCreateVNetRoot: PerUserEntry->UserEntryState != UserEntryInitializing\n"));
            
            ASSERT(PerUserEntry->UserEntryState == UserEntryAllocated);
            
            PerUserEntry->UserEntryState = UserEntryInitializing;
        
        }

        //
        // We don't need to hold the CriticalSection anymore.
        //
        LeaveCriticalSection( &(HashServerEntryTableLock) );
        EnCriSec = FALSE;

        //
        // Need to set the DavOperation field before submitting the asynchronous
        // request. This is a internet connect operation.
        //
        DavWorkItem->DavOperation = DAV_CALLBACK_INTERNET_CONNECT;

        //
        // Create a handle to connect to a HTTP/DAV server.
        //
        DavConnHandle = InternetConnectW(IHandle,
                                         (LPCWSTR)ServerName,
                                         INTERNET_DEFAULT_HTTP_PORT,
                                         NULL,
                                         NULL,
                                         INTERNET_SERVICE_HTTP,
                                         0,
                                         CallBackContext);
        if (DavConnHandle == NULL) {

            WStatus = GetLastError();

            if (WStatus != ERROR_IO_PENDING) {

                //
                // Set the state of the entry to error in initialization.
                //

                EnterCriticalSection( &(HashServerEntryTableLock) );

                PerUserEntry->UserEntryState = UserEntryInitializationError;

                PerUserEntry->ErrorStatus = WStatus;

                SetEvent(PerUserEntry->UserEventHandle);

                LeaveCriticalSection( &(HashServerEntryTableLock) );

                DavPrint((DEBUG_ERRORS,
                          "DavFsCreateVNetRoot/InternetConnect. Error Val = %d\n", WStatus));

            }

            goto EXIT_THE_FUNCTION;

        }

        //
        // Cache the InternetConnect handle in the PerUserEntry struct.
        //
        PerUserEntry->DavConnHandle = DavConnHandle;

        //
        // If we fail after this stage, we can keep the PerUserEntry since the
        // InternetConnect handle has already been stored successfully.
        //
        didICreateUserEntry = FALSE;

    }

    WStatus = DavAsyncCommonStates(DavWorkItem, FALSE);
    if (WStatus != ERROR_SUCCESS && WStatus != ERROR_IO_PENDING) {
        DavPrint((DEBUG_ERRORS,
                  "DavFsCreateVNetRoot/DavAsyncCommonStates. Error Val = %08lx\n",
                  WStatus));
    }

EXIT_THE_FUNCTION:

    if (EnCriSec) {
        LeaveCriticalSection( &(HashServerEntryTableLock) );
        EnCriSec = FALSE;
    }

#ifdef DAV_USE_WININET_ASYNCHRONOUSLY
    
    //
    // Some resources should not be freed if we are returning ERROR_IO_PENDING
    // because they will be used in the callback functions.
    //
    if (WStatus != ERROR_IO_PENDING) {
            
        //
        // Set the return status of the operation. This is used by the kernel 
        // mode routines to figure out the completion status of the user mode 
        // request.
        //
        if (WStatus != ERROR_SUCCESS) {
            DavWorkItem->Status = DavMapErrorToNtStatus(WStatus);
        } else {
            DavWorkItem->Status = STATUS_SUCCESS;
        }

        DavAsyncCreateVNetRootCompletion(DavWorkItem);
    
    } else {
        
        DavPrint((DEBUG_MISC, "DavFsCreateVNetRoot: Returning ERROR_IO_PENDING.\n"));
    
    }

#else

    //
    // If we are using WinInet synchronously, then we should never get back
    // ERROR_IO_PENDING from WinInet.
    //
    ASSERT(WStatus != ERROR_IO_PENDING);

    //
    // If this thread impersonated a user, we need to revert back.
    //
    if (didImpersonate) {
        RevertToSelf();
    }

    //
    // Set the return status of the operation. This is used by the kernel
    // mode routines to figure out the completion status of the user mode
    // request. This is done here because the async completion routine that is
    // called immediately afterwards needs the status set.
    //
    if (WStatus != ERROR_SUCCESS) {
        DavWorkItem->Status = DavMapErrorToNtStatus(WStatus);
    } else {
        DavWorkItem->Status = STATUS_SUCCESS;
    }

    DavAsyncCreateVNetRootCompletion(DavWorkItem);

#endif
        
    return WStatus;
}


DWORD 
DavAsyncCreateVNetRoot(
    PDAV_USERMODE_WORKITEM DavWorkItem,
    BOOLEAN CalledByCallBackThread
    )
/*++

Routine Description:

   This is the callback routine for the CreateVNetRoot operation.

Arguments:

    DavWorkItem - The DAV_USERMODE_WORKITEM value.

    CalledByCallbackThread - TRUE, if this function was called by the thread
                             which picks of the DavWorkItem from the Callback
                             function. This happens when an Async WinInet call
                             returns ERROR_IO_PENDING and completes later.

Return Value:

    ERROR_SUCCESS or the appropriate error value.

--*/
{
    ULONG WStatus = ERROR_SUCCESS;
    PUMRX_USERMODE_WORKITEM_HEADER UserWorkItem = NULL;
    BOOL didImpersonate = FALSE;
    HINTERNET DavOpenHandle = NULL;
    BOOL ReturnVal = FALSE;
    ULONG TahoeCustomHeaderLength = 0, OfficeCustomHeaderLength = 0;
    PDAV_USERMODE_CREATE_V_NET_ROOT_RESPONSE CreateVNetRootResponse = NULL;
    WCHAR DavCustomBuffer[100];
    DAV_FILE_ATTRIBUTES DavFileAttributes;
    
    UserWorkItem = (PUMRX_USERMODE_WORKITEM_HEADER)DavWorkItem;

    CreateVNetRootResponse = &(DavWorkItem->CreateVNetRootResponse);
    
#ifdef DAV_USE_WININET_ASYNCHRONOUSLY
    
    if (CalledByCallBackThread) {

        //
        // We are running in the context of a worker thread which has different 
        // credentials than the user that initiated the I/O request. Before
        // proceeding further, we should impersonate the user that initiated the 
        // request.
        //
        WStatus = UMReflectorImpersonate(UserWorkItem, DavWorkItem->ImpersonationHandle);
        if (WStatus != ERROR_SUCCESS) {
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncCreateVNetRoot/UMReflectorImpersonate. "
                      "Error Val = %d\n", 
                      WStatus));
            goto EXIT_THE_FUNCTION;
        }
        didImpersonate = TRUE;
        
        //
        // Before proceeding further, check to see if the Async operation failed.
        // If it did, then cleanup and move on.
        //
        if ( !DavWorkItem->AsyncResult->dwResult ) {
            
            WStatus = DavWorkItem->AsyncResult->dwError;
            
            //
            // If the error we got back is ERROR_INTERNET_FORCE_RETRY, then
            // WinInet is trying to authenticate itself with the server. In 
            // such a scenario this is what happens.
            //
            //          Client ----Request----->   Server
            //          Server ----AccessDenied-----> Client
            //          Client----Challenge Me-------> Server
            //          Server-----Challenge--------> Client
            //          Client-----Challenge Resp----> Server
            //
            if (WStatus == ERROR_INTERNET_FORCE_RETRY) {

                ASSERT(DavWorkItem->DavOperation == DAV_CALLBACK_HTTP_END);

                //
                // We need to repeat the HttpSend and HttpEnd request calls.
                //
                DavWorkItem->DavOperation = DAV_CALLBACK_HTTP_OPEN;

                WStatus = DavAsyncCommonStates(DavWorkItem, FALSE);
                if (WStatus != ERROR_SUCCESS && WStatus != ERROR_IO_PENDING) {
                    DavPrint((DEBUG_ERRORS,
                              "DavAsyncCreateVNetRoot/DavAsyncCommonStates. "
                              "Error Val = %08lx\n", WStatus));
                }

            } else {

                DavPrint((DEBUG_ERRORS,
                          "DavAsyncCreateVNetRoot. AsyncFunction failed. "
                          "Error Val = %d\n", WStatus));
            
            }
            
            goto EXIT_THE_FUNCTION;

        }

    }

#else

    ASSERT(CalledByCallBackThread == FALSE);

#endif

    DavOpenHandle = DavWorkItem->AsyncCreateVNetRoot.DavOpenHandle;
    WStatus = DavQueryAndParseResponse(DavOpenHandle);
    
    if (WStatus != ERROR_SUCCESS) {
        //
        // The PROPFIND request that was sent to the server failed.
        //
        DavPrint((DEBUG_ERRORS,
                  "DavAsyncCreateVNetRoot/DavQueryAndParseResponse. "
                  "WStatus = %d\n", WStatus));
        goto EXIT_THE_FUNCTION;
    }

    //
    // We read the value of AcceptOfficeAndTahoeServers from the registry when
    // the WebClient service starts up. If this is set to 0, it means that we
    // should be rejecting OfficeWebServers, Tahoe servers and the shares on
    // these servers even though they speak DAV. We do this since WebFolders
    // needs to claim this name and Shell will only call into WebFolders if the
    // DAV Redir fails. If this value is non-zero, we accept all servers that
    // speak DAV.
    // 
    //
    if (AcceptOfficeAndTahoeServers == 0) {

        //
        // Figure out if this is an OFFICE Web Server share. If it is then the 
        // response will have an entry "MicrosoftOfficeWebServer: ", in the header. 
        // If this is an OFFICE share then we should not claim it since the user 
        // actually intends to use the OFFICE specific features in Shell.
        //
    
        RtlZeroMemory(DavCustomBuffer, sizeof(DavCustomBuffer));
        wcscpy(DavCustomBuffer, DavOfficeCustomHeader);
        OfficeCustomHeaderLength = ( sizeof(DavCustomBuffer) / sizeof(WCHAR) );
    
        ReturnVal = HttpQueryInfoW(DavOpenHandle,
                                   HTTP_QUERY_CUSTOM,
                                   (PVOID)DavCustomBuffer,
                                   &(OfficeCustomHeaderLength), 
                                   NULL);
        if ( !ReturnVal ) {
            WStatus = GetLastError();
            if (WStatus != ERROR_HTTP_HEADER_NOT_FOUND) {
                DavPrint((DEBUG_ERRORS, 
                          "DavAsyncCreateVNetRoot/HttpQueryInfoW: Error Val = %d\n",
                          WStatus));
                goto EXIT_THE_FUNCTION;
            } else {
                WStatus = ERROR_SUCCESS;
                DavPrint((DEBUG_MISC, "DavAsyncCreateVNetRoot: NOT OFFICE Share\n"));
                CreateVNetRootResponse->isOfficeShare = FALSE;
            }
        } else {
            DavPrint((DEBUG_MISC, "DavAsyncCreateVNetRoot: OFFICE Share\n"));
            CreateVNetRootResponse->isOfficeShare = TRUE;
        }
        
        //
        // Figure out if this is a TAHOE share. If it is then the response will have 
        // an entry "MicrosoftTahoeServer: ", in the header. If this is a TAHOE share 
        // then we should not claim it since the user actually intends to use the
        // TAHOE specific features in Rosebud.
        //
    
        RtlZeroMemory(DavCustomBuffer, sizeof(DavCustomBuffer));
        wcscpy(DavCustomBuffer, DavTahoeCustomHeader);
        TahoeCustomHeaderLength = ( sizeof(DavCustomBuffer) / sizeof(WCHAR) );
    
        ReturnVal = HttpQueryInfoW(DavOpenHandle,
                                   HTTP_QUERY_CUSTOM,
                                   (PVOID)DavCustomBuffer,
                                   &(TahoeCustomHeaderLength),
                                   NULL);
        if ( !ReturnVal ) {
            WStatus = GetLastError();
            if (WStatus != ERROR_HTTP_HEADER_NOT_FOUND) {
                DavPrint((DEBUG_ERRORS, 
                          "DavAsyncCreateVNetRoot/HttpQueryInfoW: Error Val = %d\n",
                          WStatus));
                goto EXIT_THE_FUNCTION;
            } else {
                WStatus = ERROR_SUCCESS;
                DavPrint((DEBUG_MISC, "DavAsyncCreateVNetRoot: NOT TAHOE Share\n"));
                CreateVNetRootResponse->isTahoeShare = FALSE;
            }
        } else {
            DavPrint((DEBUG_MISC, "DavAsyncCreateVNetRoot: TAHOE Share\n"));
            CreateVNetRootResponse->isTahoeShare = TRUE;
        }

    }

    CreateVNetRootResponse->fAllowsProppatch = TRUE;

#if 0
    WStatus = DavTestProppatch(DavWorkItem,
                               DavWorkItem->AsyncCreateVNetRoot.PerUserEntry->DavConnHandle,
                               DavWorkItem->CreateVNetRootRequest.ShareName)
    if (WStatus != NO_ERROR) {
        DavPrint((DEBUG_ERRORS, 
                  "DavAsyncCreateVNetRoot/DavTestPropatch. WStatus = %d \n", 
                  WStatus));
        if (WStatus == HTTP_STATUS_BAD_METHOD) {
            CreateVNetRootResponse->fAllowsProppatch = FALSE;
        }
        WStatus = STATUS_SUCCESS;
    }
#endif

    WStatus = DavParseXmlResponse(DavOpenHandle, &DavFileAttributes, NULL);
    if (WStatus == ERROR_SUCCESS) {
        CreateVNetRootResponse->fReportsAvailableSpace = DavFileAttributes.fReportsAvailableSpace;
        DavFinalizeFileAttributesList(&DavFileAttributes, FALSE);
    }

EXIT_THE_FUNCTION:

    //
    // If we did impersonate, we need to revert back.
    //
    if (didImpersonate) {
        ULONG RStatus;
        RStatus = UMReflectorRevert(UserWorkItem);
        if (RStatus != ERROR_SUCCESS) {
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncCreateVNetRoot/UMReflectorRevert. Error Val = %d\n", 
                      RStatus));
        }
    }

#ifdef DAV_USE_WININET_ASYNCHRONOUSLY

    //
    // Some resources should not be freed if we are returning ERROR_IO_PENDING
    // because they will be used in the callback functions.
    //
    if ( WStatus != ERROR_IO_PENDING && CalledByCallBackThread ) {
        
        //
        // Set the return status of the operation. This is used by the kernel 
        // mode routines to figure out the completion status of the user mode 
        // request.
        //
        if (WStatus != ERROR_SUCCESS) {
            DavWorkItem->Status = DavMapErrorToNtStatus(WStatus);
        } else {
            DavWorkItem->Status = STATUS_SUCCESS;
        }

        //
        // Call the DavAsyncCreateVNetRootCompletion routine.
        //
        DavAsyncCreateVNetRootCompletion(DavWorkItem);

        //
        // This thread now needs to send the response back to the kernel. It 
        // does not wait in the kernel (to get another request) after submitting
        // the response.
        //
        UMReflectorCompleteRequest(DavReflectorHandle, UserWorkItem);

    } else {
        DavPrint((DEBUG_MISC, "DavAsyncCreateVNetRoot: Returning ERROR_IO_PENDING.\n"));
    }

#endif

    return WStatus;
}


VOID
DavAsyncCreateVNetRootCompletion(
    PDAV_USERMODE_WORKITEM DavWorkItem
    )
/*++

Routine Description:

   This routine handles the CreateVNetRoot completion. It basically frees up the 
   resources allocated during the operation.

Arguments:

    DavWorkItem - The DAV_USERMODE_WORKITEM value.
    
Return Value:

    none.

--*/
{
    if (DavWorkItem->AsyncCreateVNetRoot.DavOpenHandle != NULL) {
        BOOL ReturnVal;
        ULONG FreeStatus;
        HINTERNET DavOpenHandle = DavWorkItem->AsyncCreateVNetRoot.DavOpenHandle;
        ReturnVal = InternetCloseHandle( DavOpenHandle );
        if (!ReturnVal) {
            FreeStatus = GetLastError();
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncCreateVNetRootCompletion/InternetCloseHandle. Error Val "
                      "= %d\n", FreeStatus));
        }
    }

    if (DavWorkItem->AsyncResult != NULL) {
        HLOCAL FreeHandle;
        ULONG FreeStatus;
        FreeHandle = LocalFree((HLOCAL)DavWorkItem->AsyncResult);
        if (FreeHandle != NULL) {
            FreeStatus = GetLastError();
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncCreateVNetRootCompletion/LocalFree. Error Val = %d\n", 
                      FreeStatus));
        }
    }

    DavFsFinalizeTheDavCallBackContext(DavWorkItem);

    //
    // If we did not succeed, then we need to finalize this PerUserEntry. Also,
    // we only do this if we took a reference on this in the first place.
    //
    if (DavWorkItem->Status != STATUS_SUCCESS) {
        if ( (DavWorkItem->AsyncCreateVNetRoot.PerUserEntry) &&
             (DavWorkItem->AsyncCreateVNetRoot.didITakeReference) ) {
            DavFinalizePerUserEntry( &(DavWorkItem->AsyncCreateVNetRoot.PerUserEntry) );
        }
    }

    return;
}


ULONG
DavFsFinalizeVNetRoot(
    PDAV_USERMODE_WORKITEM DavWorkItem
    )
/*++

Routine Description:

    This routine handles FinalizeVNetRoot requests for the DAV Mini-Redir that 
    get reflected from the kernel.

Arguments:

    DavWorkItem - The buffer that contains the request parameters and options.

Return Value:

    The return status for the operation

--*/
{
    ULONG WStatus = ERROR_SUCCESS;
    PDAV_USERMODE_FINALIZE_V_NET_ROOT_REQUEST DavFinalizeVNetRootRequest = NULL;
    PPER_USER_ENTRY PerUserEntry = NULL;
    PHASH_SERVER_ENTRY ServerHashEntry = NULL;
    PWCHAR ServerName = NULL;
    BOOL ReturnVal = FALSE;

    DavFinalizeVNetRootRequest = &(DavWorkItem->FinalizeVNetRootRequest);

    ServerName = DavFinalizeVNetRootRequest->ServerName;

    //
    // If the server name is NULL, return.
    //
    if (ServerName == NULL) {
        DavPrint((DEBUG_ERRORS, "DavFsFinalizeVNetRoot: ServerName == NULL\n"));
        WStatus = ERROR_INVALID_PARAMETER;
        goto EXIT_THE_FUNCTION;
    }

    DavPrint((DEBUG_MISC, "DavFsFinalizeVNetRoot: ServerName: %ws.\n", ServerName));

    DavPrint((DEBUG_MISC,
              "DavFsFinalizeVNetRoot: LogonId.LowPart = %d, LogonId.HighPart = %d\n", 
              DavFinalizeVNetRootRequest->LogonID.LowPart,
              DavFinalizeVNetRootRequest->LogonID.HighPart));
    
    //
    // Now check whether this user has an entry hanging off the server entry in
    // the hash table. Obviously, we have to take a lock before accessing the
    // server entries of the hash table.
    //
    EnterCriticalSection( &(HashServerEntryTableLock) );
    
    ReturnVal = DavDoesUserEntryExist(ServerName,
                                      DavFinalizeVNetRootRequest->ServerID,
                                      &(DavFinalizeVNetRootRequest->LogonID),
                                      &(PerUserEntry),
                                      &(ServerHashEntry));

    //
    // Since we are finalizing the PerUserEntry, its important that this entry
    // exists. This means that the following ASSERTs are TRUE. This is because
    // till a VNetRoot for this server exists for this user in the kernel, we
    // keep the PerUserEntry alive.
    //

    ASSERT(ReturnVal == TRUE);
    ASSERT(ServerHashEntry != NULL);
    ASSERT(PerUserEntry != NULL);
    
    //
    // Finalize the PerUserEntry. The function below will free the PerUserEntry
    // if the reference count goes to zero.
    //
    DavFinalizePerUserEntry( &(PerUserEntry) );

    //
    // We are done finalizing the entry so we can leave the critical section
    // now.
    //
    LeaveCriticalSection( &(HashServerEntryTableLock) );

EXIT_THE_FUNCTION:

    //
    // Set the return status of the operation. This is used by the kernel
    // mode routines to figure out the completion status of the user mode
    // request. This is done here because the async completion routine that is
    // called immediately afterwards needs the status set.
    //
    if (WStatus != ERROR_SUCCESS) {
        DavWorkItem->Status = DavMapErrorToNtStatus(WStatus);
    } else {
        DavWorkItem->Status = STATUS_SUCCESS;
    }
    
    return WStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\server\version.h ===
#pragma once

#include <ntverp.h>
#include <winver.h>

#define VER_FILETYPE                    VFT_APP
#define VER_FILESUBTYPE                 VFT2_UNKNOWN
#define VER_FILEDESCRIPTION_STR         "Web DAV Service DLL"
#define VER_INTERNALNAME_STR            "davsvc.dll"

#include <common.ver>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\server\socket.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    socket.c
    
Abstract:

    This module implements the user mode DAV miniredir routines pertaining to 
    initialization and closing of the socket data structures.

Author:

    Rohan Kumar      [RohanK]      27-May-1999

Revision History:

--*/

#include "pch.h"
#pragma hdrstop

#include "ntumrefl.h"
#include "usrmddav.h"
#include "global.h"

//
// Implementation of functions begins here.
//

//
// Data structure that is to receive details of the WinSock implementation.
//
WSADATA g_wsaData;
BOOLEAN g_socketinit = FALSE;

ULONG
InitializeTheSocketInterface(
    VOID
    )
/*++

Routine Description:

    This routine initializes the socket interface. This has to be done before
    any WinSock calls can be made.

Arguments:

    none.

Return Value:

    The return status for the operation

--*/
{
    ULONG WStatus = ERROR_SUCCESS;
    int err;
    WORD VersionRequested;

    //
    // Request version 2.0.
    //
    VersionRequested = MAKEWORD(2, 0);

    //
    // The WSAStartup function must be the first Windows Sockets function 
    // called. 
    //
    err = WSAStartup(VersionRequested, &g_wsaData);
    if (err != 0) {
        //
        // We could not find a suitable Winsock lib.
        //
        DavPrint((DEBUG_ERRORS,
                  "InitializeTheSocketInterface/WSAStartup: Error Val = %d.\n", 
                  err));
        WStatus = (ULONG)err;
        goto EXIT_THE_FUNCTION;
    }

    //
    // Confirm that the lib supports version 2.0. Only Winsock versions 1.1 or
    // higher support the GetHostByName call.
    //
    if (LOBYTE(g_wsaData.wVersion) != 2 || HIBYTE(g_wsaData.wVersion) != 0) {
        DavPrint((DEBUG_ERRORS,
                  "InitializeTheSocketInterface/WSAStartup: Ver not supported.\n"));
        //
        // Cleanup and return error.
        //
        err = WSACleanup();
        if (err == SOCKET_ERROR) {
            WStatus = (ULONG)WSAGetLastError();
            DavPrint((DEBUG_ERRORS,
                      "InitializeTheSocketInterface/WSACleanup: Error Val = "
                      "%08lx.\n", WStatus));
        }
        WStatus = ERROR_NOT_SUPPORTED;
        goto EXIT_THE_FUNCTION;
    }

EXIT_THE_FUNCTION:

    if (WStatus == ERROR_SUCCESS) {
        g_socketinit = TRUE;
    }

    return WStatus;
}


NTSTATUS
CleanupTheSocketInterface(
    VOID
    )
/*++

Routine Description:

    This routine cleansup the data structures created during the initialization
    of the socket interface.

Arguments:

    none.

Return Value:

    The return status for the operation

--*/
{
    ULONG WStatus = ERROR_SUCCESS;
    int err;
    
    err = WSACleanup();
    if (err == SOCKET_ERROR) {
        WStatus = (ULONG)WSAGetLastError();
        DavPrint((DEBUG_ERRORS,
                  "CleanupTheSocketInterface/WSACleanup: Error Val = "
                  "%08lx.\n", WStatus));
    }

    return WStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\server\validc.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    validc.h

Abstract:

    Strings of valid/invalid characters for canonicalization.

--*/

#ifndef _VALIDC_H_
#define _VALIDC_H_

//
// Disallowed control characters (not including \0).
//
#define CTRL_CHARS_0   L"\001\002\003\004\005\006\007"
#define CTRL_CHARS_1   L"\010\011\012\013\014\015\016\017"
#define CTRL_CHARS_2   L"\020\021\022\023\024\025\026\027"
#define CTRL_CHARS_3   L"\030\031\032\033\034\035\036\037"
#define CTRL_CHARS_STR CTRL_CHARS_0 CTRL_CHARS_1 CTRL_CHARS_2 CTRL_CHARS_3

//
// Character subsets.
//
#define NON_COMPONENT_CHARS L"\\/:"
#define ILLEGAL_CHARS_STR   L"\"<>|"
#define SPACE_STR           L" "
#define PATH_SEPARATORS     L"\\/"

//
// Combinations of the above.
//
#define ILLEGAL_CHARS       CTRL_CHARS_STR ILLEGAL_CHARS_STR
#define ILLEGAL_NAME_CHARS_STR  L"\"/\\:|<>?" CTRL_CHARS_STR
#define STANDARD_ILLEGAL_CHARS  ILLEGAL_NAME_CHARS_STR L"*"
#define SERVER_ILLEGAL_CHARS    STANDARD_ILLEGAL_CHARS SPACE_STR L"[]+;,"
#define USERNAME_ILLEGAL_CHARS  L"\"/:|<>?" CTRL_CHARS_STR

//
// Characters which may not appear in a canonicalized FAT filename are:
//  0x00 - 0x1f " * + , / : ; < = > ? [ \ ] |      
//
#define ILLEGAL_FAT_CHARS   CTRL_CHARS_STR L"\"*+,/:;<=>?[\\]|"

//
// Characters which may not appear in a canonicalized HPFS filename are:
//  0x00 - 0x1f " * / : < > ? \ |
//
#define ILLEGAL_HPFS_CHARS  CTRL_CHARS_STR L"\"*/:<>?\\|"


//
// Checks if the token contains all valid characters
//
#define IS_VALID_TOKEN(_Str, _StrLen) \
        ((BOOL) (wcscspn((_Str), STANDARD_ILLEGAL_CHARS) == (_StrLen)))

//
// Checks if the server name contains all valid characters for the server name
//
#define IS_VALID_SERVER_TOKEN(_Str, _StrLen) \
        ((BOOL) (wcscspn((_Str), SERVER_ILLEGAL_CHARS) == (_StrLen)))
        
//
// Checks if the token contains all valid characters
//
#define IS_VALID_USERNAME_TOKEN(_Str, _StrLen) \
        ((BOOL) (wcscspn((_Str), USERNAME_ILLEGAL_CHARS) == (_StrLen)))

//
// A remote entry for every unique shared resource name (\\server\share)
// of explicit connections.
//
typedef struct _UNC_NAME {
    
    DWORD TotalUseCount;
    
    DWORD UncNameLength;
    
    LPWSTR UncName[1];

} UNC_NAME, *PUNC_NAME;

//
// A DAV use entry in the linked list of connections.
//
typedef struct _DAV_USE_ENTRY {
    
    struct _DAV_USE_ENTRY *Next;

    BOOL isPassport;
    
    PUNC_NAME Remote;
    
    LPWSTR Local;
    
    DWORD LocalLength;
    
    DWORD UseCount;

    HANDLE DavCreateFileHandle;
    
    LPWSTR TreeConnectStr;

    LPWSTR AuthUserName;

    DWORD AuthUserNameLength;

} DAV_USE_ENTRY, *PDAV_USE_ENTRY;
    
typedef struct _DAV_PER_USER_ENTRY {

    //
    // Pointer to linked list of user data.
    //
    PVOID List;             

    //
    // Logon Id of user.
    //
    LUID LogonId;

} DAV_PER_USER_ENTRY, *PDAV_PER_USER_ENTRY;

typedef struct _DAV_USERS_OBJECT {
    
    //
    // Table of users.
    //
    PDAV_PER_USER_ENTRY Table;
    
    //
    // To serialize access to Table.
    //
    RTL_RESOURCE TableResource;
    
    //
    // Relocatable Table memory.
    //
    HANDLE TableMemory;
    
    //
    // Size of Table.
    //
    DWORD TableSize;

} DAV_USERS_OBJECT, *PDAV_USERS_OBJECT;

#define DAV_GROW_USER_COUNT   3

//
// The structure that contains a list of shares of a DAV server.
//
typedef struct _DAV_SERVER_SHARE_ENTRY {

    //
    // Name of the server.
    //
    PWCHAR ServerName;

    //
    // The list of structures containing the Dav shares.
    //
    PDAV_FILE_ATTRIBUTES DavShareList;

    //
    // Number of shares.
    //
    ULONG NumOfShares;

    //
    // The next entry.
    //
    LIST_ENTRY ServerShareEntry;

    //
    // The timer value used in the checking if we need to go to the server
    // again to get the list of shares.
    //
    time_t TimeValueInSec;

    //
    // This should be the last field.
    //
    WCHAR StrBuffer[1];

} DAV_SERVER_SHARE_ENTRY, *PDAV_SERVER_SHARE_ENTRY;

#define SERVER_SHARE_TABLE_SIZE 512

extern LIST_ENTRY ServerShareTable[SERVER_SHARE_TABLE_SIZE];

//
// This critical section synchronizes access to the ServerHashTable.
//
extern CRITICAL_SECTION ServerShareTableLock;

#endif // _VALIDC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\server\utils.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    utils.c

Abstract:

    Grab bag of functions used by the web dav mini-redir client service.

Author:

    Andy Herron (andyhe) 29-Mar-1999

Environment:

    User Mode - Win32

Revision History:

--*/

#include "pch.h"
#pragma hdrstop

#include <ntumrefl.h>
#include <usrmddav.h>
#include "global.h"

//
// These tables translate wininet codes to the closest ntstatus codes. There are 
// two because there are some errors in wininet which come from ftp and gopher 
// which are not relevant to us.
//
typedef struct tagHTTP_TO_NTSTATUS_MAPPING {
    DWORD dwHttpError;
    NTSTATUS Status;
} HTTP_TO_NTSTATUS_MAPPING;

typedef struct tagWIN32_TO_NTSTATUS_MAPPING {
    DWORD dwWin32Error;
    NTSTATUS NtStatus;
} WIN32_TO_NTSTATUS_MAPPING;

HTTP_TO_NTSTATUS_MAPPING rgHttpToNtstatus1[] = {
     ERROR_INTERNET_OUT_OF_HANDLES           ,STATUS_INSUFFICIENT_RESOURCES     // (INTERNET_ERROR_BASE + 1) 
    ,ERROR_INTERNET_TIMEOUT                  ,STATUS_BAD_NETWORK_PATH           // (INTERNET_ERROR_BASE + 2) 
    ,ERROR_INTERNET_EXTENDED_ERROR           ,STATUS_UNSUCCESSFUL               // (INTERNET_ERROR_BASE + 3) 
    ,ERROR_INTERNET_INTERNAL_ERROR           ,STATUS_INTERNAL_ERROR             // (INTERNET_ERROR_BASE + 4) 
    ,ERROR_INTERNET_INVALID_URL              ,STATUS_OBJECT_NAME_INVALID        // (INTERNET_ERROR_BASE + 5) 
    ,ERROR_INTERNET_UNRECOGNIZED_SCHEME      ,STATUS_OBJECT_NAME_INVALID        // (INTERNET_ERROR_BASE + 6) 
    ,ERROR_INTERNET_NAME_NOT_RESOLVED        ,STATUS_BAD_NETWORK_PATH           // (INTERNET_ERROR_BASE + 7) 
    ,ERROR_INTERNET_PROTOCOL_NOT_FOUND       ,STATUS_OBJECT_TYPE_MISMATCH       // (INTERNET_ERROR_BASE + 8) 
    ,ERROR_INTERNET_INVALID_OPTION           ,STATUS_INVALID_PARAMETER          // (INTERNET_ERROR_BASE + 9) 
    ,ERROR_INTERNET_BAD_OPTION_LENGTH        ,STATUS_INVALID_PARAMETER          // (INTERNET_ERROR_BASE + 10)
    ,ERROR_INTERNET_OPTION_NOT_SETTABLE      ,STATUS_INVALID_PARAMETER          // (INTERNET_ERROR_BASE + 11)
    ,ERROR_INTERNET_SHUTDOWN                 ,STATUS_UNSUCCESSFUL               // (INTERNET_ERROR_BASE + 12)
    ,ERROR_INTERNET_INCORRECT_USER_NAME      ,STATUS_LOGON_FAILURE              // (INTERNET_ERROR_BASE + 13)
    ,ERROR_INTERNET_INCORRECT_PASSWORD       ,STATUS_LOGON_FAILURE              // (INTERNET_ERROR_BASE + 14)
    ,ERROR_INTERNET_LOGIN_FAILURE            ,STATUS_LOGON_FAILURE              // (INTERNET_ERROR_BASE + 15)
    ,ERROR_INTERNET_INVALID_OPERATION        ,STATUS_INVALID_DEVICE_REQUEST     // (INTERNET_ERROR_BASE + 16)
    ,ERROR_INTERNET_OPERATION_CANCELLED      ,STATUS_CANCELLED                  // (INTERNET_ERROR_BASE + 17)
    ,ERROR_INTERNET_INCORRECT_HANDLE_TYPE    ,STATUS_INVALID_HANDLE             // (INTERNET_ERROR_BASE + 18)
    ,ERROR_INTERNET_INCORRECT_HANDLE_STATE   ,STATUS_INVALID_HANDLE             // (INTERNET_ERROR_BASE + 19)
    ,ERROR_INTERNET_NOT_PROXY_REQUEST        ,STATUS_INVALID_PARAMETER          // (INTERNET_ERROR_BASE + 20)
    ,ERROR_INTERNET_REGISTRY_VALUE_NOT_FOUND ,STATUS_OBJECT_NAME_NOT_FOUND      // (INTERNET_ERROR_BASE + 21)
    ,ERROR_INTERNET_BAD_REGISTRY_PARAMETER   ,STATUS_INVALID_PARAMETER          // (INTERNET_ERROR_BASE + 22)
    ,ERROR_INTERNET_NO_DIRECT_ACCESS         ,STATUS_UNSUCCESSFUL               // (INTERNET_ERROR_BASE + 23)
    ,ERROR_INTERNET_NO_CONTEXT               ,STATUS_UNSUCCESSFUL               // (INTERNET_ERROR_BASE + 24)
    ,ERROR_INTERNET_NO_CALLBACK              ,STATUS_UNSUCCESSFUL               // (INTERNET_ERROR_BASE + 25)
    ,ERROR_INTERNET_REQUEST_PENDING          ,STATUS_PENDING                    // (INTERNET_ERROR_BASE + 26)
    ,ERROR_INTERNET_INCORRECT_FORMAT         ,STATUS_INVALID_NETWORK_RESPONSE   // (INTERNET_ERROR_BASE + 27)
    ,ERROR_INTERNET_ITEM_NOT_FOUND           ,STATUS_OBJECT_PATH_NOT_FOUND      // (INTERNET_ERROR_BASE + 28)
    ,ERROR_INTERNET_CANNOT_CONNECT           ,STATUS_BAD_NETWORK_PATH           // (INTERNET_ERROR_BASE + 29)
    ,ERROR_INTERNET_CONNECTION_ABORTED       ,STATUS_REQUEST_ABORTED            // (INTERNET_ERROR_BASE + 30)
    ,ERROR_INTERNET_CONNECTION_RESET         ,STATUS_CONNECTION_RESET           // (INTERNET_ERROR_BASE + 31)
    ,ERROR_INTERNET_FORCE_RETRY              ,STATUS_RETRY                      // (INTERNET_ERROR_BASE + 32)
    ,ERROR_INTERNET_INVALID_PROXY_REQUEST    ,STATUS_INVALID_PARAMETER          // (INTERNET_ERROR_BASE + 33)
    ,ERROR_INTERNET_NEED_UI                  ,STATUS_ACCESS_DENIED              // (INTERNET_ERROR_BASE + 34)
    };
    
HTTP_TO_NTSTATUS_MAPPING rgHttpToNtstatus2[] = {
     ERROR_HTTP_HEADER_NOT_FOUND             ,STATUS_INVALID_NETWORK_RESPONSE   // (INTERNET_ERROR_BASE + 150)
    ,ERROR_HTTP_DOWNLEVEL_SERVER             ,STATUS_INVALID_NETWORK_RESPONSE   // (INTERNET_ERROR_BASE + 151)
    ,ERROR_HTTP_INVALID_SERVER_RESPONSE      ,STATUS_INVALID_NETWORK_RESPONSE   // (INTERNET_ERROR_BASE + 152)
    ,ERROR_HTTP_INVALID_HEADER               ,STATUS_INVALID_NETWORK_RESPONSE   // (INTERNET_ERROR_BASE + 153)
    ,ERROR_HTTP_INVALID_QUERY_REQUEST        ,STATUS_INVALID_PARAMETER          // (INTERNET_ERROR_BASE + 154)
    ,ERROR_HTTP_HEADER_ALREADY_EXISTS        ,STATUS_INVALID_PARAMETER          // (INTERNET_ERROR_BASE + 155)
    ,ERROR_HTTP_REDIRECT_FAILED              ,STATUS_HOST_UNREACHABLE           // (INTERNET_ERROR_BASE + 156)
    ,ERROR_INTERNET_SECURITY_CHANNEL_ERROR   ,STATUS_INTERNAL_ERROR             // (INTERNET_ERROR_BASE + 157)
    ,ERROR_INTERNET_UNABLE_TO_CACHE_FILE     ,STATUS_INTERNAL_ERROR             // (INTERNET_ERROR_BASE + 158)
    ,ERROR_INTERNET_TCPIP_NOT_INSTALLED      ,STATUS_INTERNAL_ERROR             // (INTERNET_ERROR_BASE + 159)
    ,ERROR_HTTP_NOT_REDIRECTED               ,STATUS_INTERNAL_ERROR             // (INTERNET_ERROR_BASE + 160)
    ,ERROR_HTTP_COOKIE_NEEDS_CONFIRMATION    ,STATUS_INTERNAL_ERROR             // (INTERNET_ERROR_BASE + 161)
    ,ERROR_HTTP_COOKIE_DECLINED              ,STATUS_INTERNAL_ERROR             // (INTERNET_ERROR_BASE + 162)
    ,ERROR_INTERNET_DISCONNECTED             ,STATUS_CONNECTION_DISCONNECTED    // (INTERNET_ERROR_BASE + 163)
    ,ERROR_INTERNET_SERVER_UNREACHABLE       ,STATUS_HOST_UNREACHABLE           // (INTERNET_ERROR_BASE + 164)
    ,ERROR_INTERNET_PROXY_SERVER_UNREACHABLE ,STATUS_HOST_UNREACHABLE           // (INTERNET_ERROR_BASE + 165)
    ,ERROR_INTERNET_BAD_AUTO_PROXY_SCRIPT     ,STATUS_DEVICE_CONFIGURATION_ERROR// (INTERNET_ERROR_BASE + 166)
    ,ERROR_INTERNET_UNABLE_TO_DOWNLOAD_SCRIPT ,STATUS_INTERNAL_ERROR            // (INTERNET_ERROR_BASE + 167)
    ,ERROR_HTTP_REDIRECT_NEEDS_CONFIRMATION   ,STATUS_NETWORK_SESSION_EXPIRED   // (INTERNET_ERROR_BASE + 168)
    ,ERROR_INTERNET_SEC_INVALID_CERT          ,STATUS_ACCESS_DENIED             // (INTERNET_ERROR_BASE + 169)
    ,ERROR_INTERNET_SEC_CERT_REVOKED          ,STATUS_ACCESS_DENIED             // (INTERNET_ERROR_BASE + 170)
    };

WIN32_TO_NTSTATUS_MAPPING rgWin32ToNtStatus [] = {

    ERROR_SUCCESS, STATUS_SUCCESS                            // 0L

    ,ERROR_INVALID_FUNCTION, STATUS_NOT_IMPLEMENTED          // 1L

    ,ERROR_FILE_NOT_FOUND, STATUS_OBJECT_NAME_NOT_FOUND      // 2L

    ,ERROR_PATH_NOT_FOUND, STATUS_OBJECT_PATH_NOT_FOUND      // 3L

    ,ERROR_TOO_MANY_OPEN_FILES, STATUS_TOO_MANY_OPENED_FILES // 4L

    ,ERROR_ACCESS_DENIED, STATUS_ACCESS_DENIED               // 5L

    ,ERROR_INVALID_HANDLE, STATUS_INVALID_HANDLE             // 6L

    ,ERROR_ARENA_TRASHED, STATUS_UNSUCCESSFUL                // 7L

    ,ERROR_NOT_ENOUGH_MEMORY, STATUS_INSUFFICIENT_RESOURCES  // 8L

    ,ERROR_INVALID_BLOCK, STATUS_UNSUCCESSFUL                // 9L

    ,ERROR_BAD_ENVIRONMENT, STATUS_UNSUCCESSFUL              // 10L

    ,ERROR_BAD_FORMAT, STATUS_UNSUCCESSFUL                   // 11L

    ,ERROR_INVALID_ACCESS, STATUS_UNSUCCESSFUL               // 12L

    ,ERROR_INVALID_DATA, STATUS_UNSUCCESSFUL                 // 13L

    ,ERROR_OUTOFMEMORY, STATUS_UNSUCCESSFUL                  // 14L

    ,ERROR_INVALID_DRIVE, STATUS_UNSUCCESSFUL                // 15L

    ,ERROR_CURRENT_DIRECTORY, STATUS_UNSUCCESSFUL            // 16L

    ,ERROR_NOT_SAME_DEVICE, STATUS_UNSUCCESSFUL              // 17L

    ,ERROR_NO_MORE_FILES, STATUS_UNSUCCESSFUL                // 18L

    ,ERROR_WRITE_PROTECT, STATUS_UNSUCCESSFUL                // 19L

    ,ERROR_BAD_UNIT, STATUS_UNSUCCESSFUL                     // 20L

    ,ERROR_NOT_READY, STATUS_UNSUCCESSFUL                    // 21L

    ,ERROR_BAD_COMMAND, STATUS_UNSUCCESSFUL                  // 22L

    ,ERROR_CRC, STATUS_UNSUCCESSFUL                          // 23L

    ,ERROR_BAD_LENGTH, STATUS_UNSUCCESSFUL                   // 24L

    ,ERROR_SEEK, STATUS_UNSUCCESSFUL                         // 25L

    ,ERROR_NOT_DOS_DISK, STATUS_UNSUCCESSFUL                 // 26L

    ,ERROR_SECTOR_NOT_FOUND, STATUS_UNSUCCESSFUL             // 27L

    ,ERROR_OUT_OF_PAPER, STATUS_UNSUCCESSFUL                 // 28L

    ,ERROR_WRITE_FAULT, STATUS_UNSUCCESSFUL                  // 29L

    ,ERROR_READ_FAULT, STATUS_UNSUCCESSFUL                   // 30L

    ,ERROR_GEN_FAILURE, STATUS_UNSUCCESSFUL                  // 31L

    ,ERROR_SHARING_VIOLATION, STATUS_SHARING_VIOLATION       // 32L

    ,ERROR_LOCK_VIOLATION, STATUS_LOCK_NOT_GRANTED           // 33L

    ,ERROR_WRONG_DISK, STATUS_UNSUCCESSFUL                   // 34L
    
    ,0,0                                                     // 35L
    
    ,ERROR_SHARING_BUFFER_EXCEEDED, STATUS_UNSUCCESSFUL      // 36L
         
    ,0,0                                                     // 37L
    
    ,ERROR_HANDLE_EOF, STATUS_END_OF_FILE                    // 38L

    ,ERROR_HANDLE_DISK_FULL, STATUS_UNSUCCESSFUL             // 39L

};

//
// Implementation of functions begins here.
//

DWORD
ReadDWord(
    HKEY KeyHandle,
    LPTSTR lpValueName,
    DWORD DefaultValue
    )
/*++

Routine Description:

    Read a DWORD value from the registry. If there is a problem then
    return the default value.
    
Arguments:

    KeyHandle - Handle of the key (value) being read.
    
    lpValueName - The value name.
    
    DefaultValue - The default value to return, if the name does not exists as
                   a value of the key handle.
                   
Return Value:                   

    Win32 error status.

--*/
{
    DWORD Value;
    DWORD ValueSize = sizeof(Value);
    DWORD ValueType;

    if ((KeyHandle) &&
        (RegQueryValueEx(KeyHandle,
                         lpValueName,
                         0,
                         &ValueType,
                         (PUCHAR)&Value,
                         &ValueSize ) == ERROR_SUCCESS )) {

        return Value;
    } else {
        return DefaultValue;
    }
}


VOID
UpdateServiceStatus (
    DWORD dwState
    )
/*++

Routine Description:

    This routines updates the service status.

Arguments:

    dwState - The state the service has to be updated to.

Return Value:

    none.

--*/
{
    if (g_registeredService) {
        ASSERT (g_hStatus);
        g_status.dwCurrentState = dwState;
        SetServiceStatus(g_hStatus, &g_status);
    } else {
        g_status.dwCurrentState = dwState;
    }
}


NET_API_STATUS
WsLoadRedir(
    VOID
    )
/*++

Routine Description:

    This loads, starts, and configures the kernel mini-redir.  If the redir
    is already loaded or started, it is not a fatal error.

Arguments:

    none.

Return Value:

    Win32 error status.

--*/
{
    NET_API_STATUS err = ERROR_SUCCESS;
    NTSTATUS NtStatus = STATUS_SUCCESS;
    UNICODE_STRING DeviceName;
    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES ObjectAttributes;
    BOOL driverAlreadyLoaded = FALSE;

    err = WsLoadDriver(DAVCLIENT_DRIVER);
    if (err == ERROR_SERVICE_ALREADY_RUNNING) {
        driverAlreadyLoaded = TRUE;
        err = ERROR_SUCCESS;
    }

    if (err != ERROR_SUCCESS) {
        DavPrint((DEBUG_ERRORS,
                  "WsLoadRedir/WsLoadDriver: Error Val = %08lx.\n", err));
        return err;
    }

    //
    // Open the redirector device.
    //
    RtlInitUnicodeString(&(DeviceName), DD_DAV_DEVICE_NAME_U);

    InitializeObjectAttributes(&(ObjectAttributes),
                               &(DeviceName),
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    NtStatus = NtOpenFile(&(DavRedirDeviceHandle),
                          SYNCHRONIZE,
                          &(ObjectAttributes),
                          &(IoStatusBlock),
                          FILE_SHARE_VALID_FLAGS,
                          FILE_SYNCHRONOUS_IO_NONALERT);
    if (NtStatus != STATUS_SUCCESS) {
        DavPrint((DEBUG_ERRORS, "WsLoadRedir/NtOpenFile: Error Val = %08lx\n", NtStatus));
        DavRedirDeviceHandle = INVALID_HANDLE_VALUE;
        return RtlNtStatusToDosError(NtStatus);
    }

    return ERROR_SUCCESS;
}


NET_API_STATUS
WsUnloadRedir(
    VOID
    )
/*++

Routine Description:

    This routine unloads the DAV driver. Calls the NtUnloadDriver function.

Arguments:

    none.

Return Value:

    Win32 error status.

--*/
{
    LPWSTR DriverRegistryName;
    ULONG Privileges[1], DriverRegistryNameLength;
    UNICODE_STRING DriverRegistryString;
    NET_API_STATUS Status;
    NTSTATUS ntstatus = STATUS_SUCCESS;

    DriverRegistryNameLength = sizeof(SERVICE_REGISTRY_KEY);
    DriverRegistryNameLength += sizeof(DAVCLIENT_DRIVER);
    
    //
    // We need to make the DriverRegistryNameLength a multiple of 8. This is 
    // because DavAllocateMemory calls DebugAlloc which does some stuff which 
    // requires this. The equation below does this.
    //
    DriverRegistryNameLength = ( ( ( DriverRegistryNameLength + 7 ) / 8 ) * 8 );
    
    DriverRegistryName = (LPWSTR) DavAllocateMemory(DriverRegistryNameLength);
    if (DriverRegistryName == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    Privileges[0] = SE_LOAD_DRIVER_PRIVILEGE;

    Status = NetpGetPrivilege(1, Privileges);
    if (Status != NERR_Success) {
        DavFreeMemory(DriverRegistryName);
        return Status;
    }

    if (DavRedirDeviceHandle != INVALID_HANDLE_VALUE) {
        NtClose(DavRedirDeviceHandle);
        DavRedirDeviceHandle = INVALID_HANDLE_VALUE;
    }

    wcscpy(DriverRegistryName, SERVICE_REGISTRY_KEY);
    wcscat(DriverRegistryName, DAVCLIENT_DRIVER);

    RtlInitUnicodeString(&(DriverRegistryString), DriverRegistryName);

    // Webclient should not unload the MRxDAV if it does not load it.

    DavFreeMemory(DriverRegistryName);

    NetpReleasePrivilege();

    return(WsMapStatus(ntstatus));
}


NET_API_STATUS
WsLoadDriver(
    IN LPWSTR DriverNameString
    )
/*++

Routine Description:

    This routine loads the DAV driver. Calls the NtLoadDriver function.

Arguments:

    none.

Return Value:

    Win32 error status.

--*/
{
    LPWSTR DriverRegistryName;
    ULONG Privileges[1], DriverRegistryNameLength;
    UNICODE_STRING DriverRegistryString;
    NET_API_STATUS Status;
    NTSTATUS ntstatus = STATUS_SUCCESS;

    DriverRegistryNameLength = sizeof(SERVICE_REGISTRY_KEY);
    DriverRegistryNameLength += ( wcslen(DriverNameString) * sizeof(WCHAR) );
    
    //
    // We need to make the DriverRegistryNameLength a multiple of 8. This is 
    // because DavAllocateMemory calls DebugAlloc which does some stuff which 
    // requires this. The equation below does this.
    //
    DriverRegistryNameLength = ( ( ( DriverRegistryNameLength + 7 ) / 8 ) * 8 );
    
    DriverRegistryName = (LPWSTR) DavAllocateMemory(DriverRegistryNameLength);
    if (DriverRegistryName == NULL) {
        DavPrint((DEBUG_ERRORS, "WsLoadDriver/DavAllocateMemory.\n"));
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    Privileges[0] = SE_LOAD_DRIVER_PRIVILEGE;

    Status = NetpGetPrivilege(1, Privileges);
    if (Status != NERR_Success) {
        DavPrint((DEBUG_ERRORS, "WsLoadDriver/NetpGetPrivilege.\n"));
        DavFreeMemory(DriverRegistryName);
        return Status;
    }

    wcscpy(DriverRegistryName, SERVICE_REGISTRY_KEY);
    wcscat(DriverRegistryName, DriverNameString);

    RtlInitUnicodeString(&(DriverRegistryString), DriverRegistryName);

    //
    // Webclient becomes a LocalService and can no longer load the MRxDAV. 
    // We make MRxDAV as a depend service of Webclient. Svchost will load it.
    //

    NetpReleasePrivilege();

    DavFreeMemory(DriverRegistryName);

    if (ntstatus != STATUS_SUCCESS && ntstatus != STATUS_IMAGE_ALREADY_LOADED) {
        
        LPWSTR  subString[1];
        subString[0] = DriverNameString;
        
        DavPrint((DEBUG_ERRORS, 
                  "WsLoadDriver/NtLoadDriver. NtStatus = %08lx\n", ntstatus));

#if 0
        DavReportEventW(NELOG_DriverNotLoaded,
                        EVENTLOG_ERROR_TYPE,
                        1,
                        sizeof(NTSTATUS),
                        subString,
                        &ntstatus);
#endif
    
    }

    return(WsMapStatus(ntstatus));
}


NET_API_STATUS
WsMapStatus(
    IN  NTSTATUS NtStatus
    )
/*++

Routine Description:

    This function takes an NT status code and maps it to the appropriate
    error code expected from calling a LAN Man API.

Arguments:

    NtStatus - Supplies the NT status.

Return Value:

    Returns the appropriate LAN Man error code for the NT status.

--*/
{
    //
    // A small optimization for the most common case.
    //
    if (NtStatus == STATUS_SUCCESS) {
        return NERR_Success;
    }

    switch (NtStatus) {
        
    case STATUS_OBJECT_NAME_COLLISION:
        return ERROR_ALREADY_ASSIGNED;

    case STATUS_ACCESS_DENIED:
        return ERROR_ACCESS_DENIED;

    case STATUS_OBJECT_NAME_NOT_FOUND:
        return NERR_UseNotFound;

    case STATUS_IMAGE_ALREADY_LOADED:
    case STATUS_REDIRECTOR_STARTED:
        return ERROR_SERVICE_ALREADY_RUNNING;

    case STATUS_REDIRECTOR_HAS_OPEN_HANDLES:
        return ERROR_REDIRECTOR_HAS_OPEN_HANDLES;

    default:
        return NetpNtStatusToApiStatus(NtStatus);
    
    }

}


NTSTATUS
DavMapErrorToNtStatus(
    DWORD dwWin32Error
    )
/*++

Routine Description:

    This function takes an errorcode which is either a WinInet error code or
    a or a Win32 error code and converts it into an NTSTATUS value. It does the 
    following in the order mentioned below:
    
    1. Checks to see if the error code is a WinInet error code and if it is
       maps that to an NTSTATUS value. If not,
       
    2. Assumes that this is a Win32 error code and maps that to an NTSTATUS
       value.

Arguments:

    dwWin32Error - The win32 or wininet error code.
    
Return Value:

    Returns the most appropriate NtStatus value.

--*/
{
    int indexLast;

    DavPrint((DEBUG_MISC,
              "DavMapErrorToNtstatus. dwWin32Error = %08lx\n", dwWin32Error));
    
    //
    // Check if its a WinInet error.
    //
    if (dwWin32Error > INTERNET_ERROR_BASE && dwWin32Error <= INTERNET_ERROR_LAST) {
        
        indexLast = ( ( sizeof(rgHttpToNtstatus1) / sizeof(HTTP_TO_NTSTATUS_MAPPING) ) - 1 );
    
        if (dwWin32Error >= rgHttpToNtstatus1[0].dwHttpError && 
            dwWin32Error <= rgHttpToNtstatus1[indexLast].dwHttpError) {
            return rgHttpToNtstatus1[dwWin32Error-rgHttpToNtstatus1[0].dwHttpError].Status;
        }

        indexLast = ( ( sizeof(rgHttpToNtstatus2) / sizeof(HTTP_TO_NTSTATUS_MAPPING) ) - 1 );

        if (dwWin32Error >= rgHttpToNtstatus2[0].dwHttpError && 
            dwWin32Error <= rgHttpToNtstatus2[indexLast].dwHttpError) {
            return rgHttpToNtstatus2[dwWin32Error-rgHttpToNtstatus2[0].dwHttpError].Status;
        }
        
    } else if (dwWin32Error >= (DWORD)HTTP_STATUS_FIRST && dwWin32Error <= (DWORD)HTTP_STATUS_LAST) {

#if 0

        //
        // IMPORTANT!!!
        // We don't check for Http error codes here. This mapping is done in 
        // the DavMapHttpErrorToDosError function. The functions expecting a
        // Http response should call DavQueryAndParseResponse function.
        //

        //
        // Check if its a HTTP error code.
        //
        
        switch (dwWin32Error) {
            
        case HTTP_STATUS_CONTINUE:              // 100 OK to continue with request
                return STATUS_SUCCESS;               
                
        case HTTP_STATUS_SWITCH_PROTOCOLS:      // 101 server has switched protocols in upgrade header
            return STATUS_DEVICE_PROTOCOL_ERROR;
                
        case HTTP_STATUS_OK:                    // 200 // request completed
        case HTTP_STATUS_CREATED:               // 201 // object created, reason = new URI
        case HTTP_STATUS_ACCEPTED:              // 202 // async completion (TBS)
        case HTTP_STATUS_PARTIAL:               // 203 // partial completion
        case HTTP_STATUS_NO_CONTENT:            // 204 // no info to return
        case HTTP_STATUS_RESET_CONTENT:         // 205 // request completed, but clear form
        case HTTP_STATUS_PARTIAL_CONTENT:       // 206 // partial GET furfilled
        case DAV_MULTI_STATUS:                  // 207 // multi status response
            return STATUS_SUCCESS;



        case HTTP_STATUS_AMBIGUOUS:                 // 300 // server couldn't decide what to return
            return STATUS_UNSUCCESSFUL;

        case HTTP_STATUS_MOVED:                     // 301 // object permanently moved
            return STATUS_OBJECT_NAME_NOT_FOUND;

        case HTTP_STATUS_REDIRECT:
            return STATUS_OBJECT_NAME_NOT_FOUND;    // 302 // object temporarily moved

        case HTTP_STATUS_REDIRECT_METHOD:         
            return STATUS_OBJECT_NAME_NOT_FOUND;     // 303 // redirection w/ new access method

        case HTTP_STATUS_NOT_MODIFIED:            
            return STATUS_SUCCESS;                  // 304 // if-modified-since was not modified

        case HTTP_STATUS_USE_PROXY:               
            return STATUS_HOST_UNREACHABLE;         // 305 // redirection to proxy, location header specifies proxy to use

        case HTTP_STATUS_REDIRECT_KEEP_VERB:      
            return STATUS_SUCCESS;                  // 307 // HTTP/1.1: keep same verb

        case HTTP_STATUS_BAD_REQUEST:               // 400 // invalid syntax
            return STATUS_INVALID_PARAMETER;

        case HTTP_STATUS_DENIED:                    // 401 // access denied
            return STATUS_ACCESS_DENIED;

        case HTTP_STATUS_PAYMENT_REQ:               // 402 // payment required
            return STATUS_ACCESS_DENIED;

        case HTTP_STATUS_FORBIDDEN:                 // 403 // request forbidden
            return STATUS_ACCESS_DENIED;

        case HTTP_STATUS_NOT_FOUND:                 // 404 // object not found
            return STATUS_OBJECT_NAME_NOT_FOUND;

        case HTTP_STATUS_BAD_METHOD:                // 405 // method is not allowed
            return STATUS_ACCESS_DENIED;

        case HTTP_STATUS_NONE_ACCEPTABLE:           // 406 // no response acceptable to client found
            return STATUS_ACCESS_DENIED;

        case HTTP_STATUS_PROXY_AUTH_REQ:            // 407 // proxy authentication required
            return STATUS_ACCESS_DENIED;

        case HTTP_STATUS_REQUEST_TIMEOUT:           // 408 // server timed out waiting for request
            return STATUS_IO_TIMEOUT;

        case HTTP_STATUS_CONFLICT:                  // 409 // user should resubmit with more info
            return STATUS_INVALID_PARAMETER;

        case HTTP_STATUS_GONE:                      // 410 // the resource is no longer available
            return STATUS_OBJECT_NAME_NOT_FOUND;

        case HTTP_STATUS_LENGTH_REQUIRED:           // 411 // the server refused to accept request w/o a length
            return STATUS_INVALID_PARAMETER;

        case HTTP_STATUS_PRECOND_FAILED:            // 412 // precondition given in request failed
            return STATUS_INVALID_PARAMETER;

        case HTTP_STATUS_REQUEST_TOO_LARGE:         // 413 // request entity was too large
            return STATUS_INVALID_PARAMETER;

        case HTTP_STATUS_URI_TOO_LONG:              // 414 // request URI too long
            return STATUS_INVALID_PARAMETER;

        case HTTP_STATUS_UNSUPPORTED_MEDIA:         // 415 // unsupported media type
            return STATUS_INVALID_PARAMETER;

        case HTTP_STATUS_RETRY_WITH:              // 449 // retry after doing the appropriate action.
            return STATUS_RETRY;

        case HTTP_STATUS_SERVER_ERROR:        // 500 // internal server error
            return STATUS_UNSUCCESSFUL;

        case HTTP_STATUS_NOT_SUPPORTED:         // 501 // required not supported
            return STATUS_NOT_SUPPORTED;

        case HTTP_STATUS_BAD_GATEWAY:           // 502 // error response received from gateway
            return STATUS_HOST_UNREACHABLE;

        case HTTP_STATUS_SERVICE_UNAVAIL:           // 503 // temporarily overloaded
            return STATUS_UNSUCCESSFUL;

        case HTTP_STATUS_GATEWAY_TIMEOUT:           // 504 // timed out waiting for gateway
            return STATUS_HOST_UNREACHABLE;

        case HTTP_STATUS_VERSION_NOT_SUP:           // 505 // HTTP version not supported
            return STATUS_NOT_SUPPORTED;

        //
        // WebDav specific status codes.
        //
        case DAV_STATUS_INSUFFICIENT_STORAGE:       // 507
            return STATUS_DISK_FULL;
        
        case DAV_STATUS_UNPROCESSABLE_ENTITY:       // 422
            return STATUS_INVALID_PARAMETER;

        case DAV_STATUS_LOCKED:                     // 423
            return STATUS_ACCESS_DENIED;
            
        case DAV_STATUS_FAILED_DEPENDENCY:          // 424
            return STATUS_INVALID_PARAMETER;
            
        default:
            break;                

        }

#endif
    
    }

    //
    // If none of the above match call this function which takes a Win32 error
    // and maps it to an NTSTATUS value.
    //
    return DavDosErrorToNtStatus(dwWin32Error);
}


NTSTATUS
DavDosErrorToNtStatus(
    DWORD dwError
    )
/*++

Routine Description:

    This function takes a win32 error code and converts to the closes NTSTATUS.
    As NTSTATUS->Win32Error is many to one mapping, there is a possible loss of 
    precision in this method of error reporting.

Arguments:

    dwError - The win32 error code.
    
Return Value:

    Returns the most appropriate NTSTATUS

--*/
{

    if (dwError < sizeof(rgWin32ToNtStatus)/sizeof(WIN32_TO_NTSTATUS_MAPPING)) {
        
        return rgWin32ToNtStatus[dwError].NtStatus;
    
    } else {
        
        switch (dwError) {
            
        case ERROR_BUFFER_OVERFLOW:
            return STATUS_BUFFER_OVERFLOW;

        case ERROR_NOT_SUPPORTED:
            return STATUS_NOT_SUPPORTED;

        case ERROR_DISK_FULL:
            return STATUS_DISK_FULL;

        case ERROR_FILE_EXISTS:
            return STATUS_OBJECT_NAME_EXISTS; 

        case ERROR_INVALID_PASSWORD:
            return STATUS_WRONG_PASSWORD;

        case ERROR_INVALID_PARAMETER:
            return STATUS_INVALID_PARAMETER;

        case ERROR_BAD_NETPATH:
            return STATUS_BAD_NETWORK_PATH;

        case ERROR_CALL_NOT_IMPLEMENTED:
            return STATUS_NOT_IMPLEMENTED;

        case ERROR_SEM_TIMEOUT:
            return STATUS_IO_TIMEOUT;

        case ERROR_INSUFFICIENT_BUFFER:
            return STATUS_BUFFER_TOO_SMALL;

        case ERROR_INVALID_NAME:
            return STATUS_OBJECT_NAME_INVALID;

        case ERROR_DIR_NOT_EMPTY:
            return STATUS_DIRECTORY_NOT_EMPTY;

        case ERROR_BUSY:
            return STATUS_DEVICE_BUSY;

        case ERROR_ALREADY_EXISTS:
            return STATUS_OBJECT_NAME_COLLISION;

        case ERROR_DIRECTORY:
            return STATUS_NOT_A_DIRECTORY;

        case ERROR_OPERATION_ABORTED:
            return STATUS_CANCELLED;

        case ERROR_IO_PENDING:
            return STATUS_PENDING;

        case ERROR_NOACCESS:
            return ERROR_ACCESS_DENIED;

        case ERROR_NOT_FOUND:
            return STATUS_OBJECT_NAME_NOT_FOUND;

        case ERROR_NO_MATCH:
            return STATUS_OBJECT_NAME_NOT_FOUND;

        case ERROR_CANCELLED:
            return STATUS_CANCELLED;

        case ERROR_RETRY:
            return STATUS_RETRY;

        case STATUS_NOT_A_DIRECTORY:
            return STATUS_NOT_A_DIRECTORY;

        case STATUS_FILE_IS_A_DIRECTORY:
            return STATUS_FILE_IS_A_DIRECTORY;

        case ERROR_NOT_ENOUGH_QUOTA:
            return STATUS_QUOTA_EXCEEDED;

        case ERROR_SESSION_CREDENTIAL_CONFLICT:
            return STATUS_NETWORK_CREDENTIAL_CONFLICT;

        default:
            DavPrint((DEBUG_ERRORS, "DavDosErrorToNtStatus: dwError = %d\n", dwError));
            return STATUS_UNSUCCESSFUL;
        
        }                
    
    }

}

// #define FIND_FLAGS_RETRIEVE_ONLY_STRUCT_INFO    0x2

DWORD
DavrGetDiskSpaceUsage(
    IN handle_t dav_binding_h,
    LPWSTR      lptzLocation,
    LONG       lLenIn,
    LONG       *lplReturnLen,
    ULARGE_INTEGER   *lpMaxSpace,
    ULARGE_INTEGER   *lpUsedSpace
    )
/*++

Routine Description:

    Finds out the amount of disk being consumed by wininet urlcache due to Webdav

Arguments:

    dav_binding_h - The explicit RPC binding handle.

    dwSize     -  Size of the cache location buffer. On return this will contain the actual size of the 
                    location string. 
                    
    lptzLocation  - Buffer to return Cache location string. As much of the location string as can fit
                    in the buffer is returned
                    
    lpdwReturnSize                    
    
    lpMaxSpace   -  Size of disk Quota set for webdav

    lpUsedSpace -   Size of disk consumed by the urlcache used by webdav
    
Return Value:

    Win32 error code

--*/
{
    // iterate through the cache to discover the actual size.
    INTERNET_CACHE_CONFIG_INFOW sConfigW;
    DWORD dwSize = sizeof(sConfigW), dwError = ERROR_SUCCESS;
    BOOL fResult = FALSE;

    // should atleass have enough space for a drive letter
    if (lLenIn < 3)
    {
        return   ERROR_INVALID_PARAMETER;
    }
    try
    {
    
        sConfigW.dwContainer = 0;
        sConfigW.dwStructSize = sizeof(sConfigW);
        
        if (GetUrlCacheConfigInfoW(&sConfigW, &dwSize,  CACHE_CONFIG_DISK_CACHE_PATHS_FC |
                                                        CACHE_CONFIG_QUOTA_FC |
                                                        CACHE_CONFIG_CONTENT_USAGE_FC |
                                                        CACHE_CONFIG_STICKY_CONTENT_USAGE_FC))
        {
            *(ULONGLONG *)lpMaxSpace = (ULONGLONG)(sConfigW.dwQuota) * 1024;        
            *(ULONGLONG *)lpUsedSpace = (ULONGLONG)(sConfigW.dwNormalUsage+sConfigW.dwExemptUsage) * 1024;

            memset(lptzLocation, 0, lLenIn * sizeof(WCHAR));

            *lplReturnLen = wcslen(sConfigW.CachePath);

            if (*lplReturnLen < lLenIn)
            {
                // We have enough buffer
                memcpy(lptzLocation, sConfigW.CachePath,  *lplReturnLen * sizeof(WCHAR));
            }
            else
            {
                // We don't have enough buffer, we copy as much as we can
                memcpy(lptzLocation, sConfigW.CachePath,  lLenIn * sizeof(WCHAR));
            }
        }
        else
        {
            dwError = GetLastError();
        }
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        dwError = ERROR_INVALID_PARAMETER;    
    }
    
    return dwError;
}

DWORD
DavrFreeUsedDiskSpace(
    IN handle_t dav_binding_h,
    DWORD   dwPercent
    )
/*++

Routine Description:

    Frees up dwPercent of the urlcache used by webdav


Arguments:

    dav_binding_h - The explicit RPC binding handle.
    
    dwPercent   - % of used space to be freed
    
Return Value:

    Win32 error code

--*/
{
    DWORD   dwError = ERROR_SUCCESS;

    if (dwPercent <= 100)
    {
        if (!FreeUrlCacheSpaceA(NULL, dwPercent, 0))
        {
            dwError = GetLastError();
        }
    }
    else
    {
        dwError = ERROR_INVALID_PARAMETER;
    }

    return dwError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\server\uniutf.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    UniUtf.cpp
    
Abstract:

    This file implements the Unicode object name to/from Utf8-URL coversion

Author:

    Mukul Gupta        [Mukgup]      20-Dec-2000

Revision History:

--*/

#include "pch.h"
#pragma hdrstop

#include "ntumrefl.h"
#include "usrmddav.h"
#include "global.h"
#include "UniUtf.h"

/*++
 * UTF8-URL  format and UNICODE Conversion Information:
 * 
    UTF8-URL is expected to have printable ASCII characters only (0-127 value characters)
    For extended characters (>127), they are converted into PrecentageStreams which will
    contain printable ASCII chars only. Sometimes special printable ASCII characters also
    converted to percentage streams to escape their special meanings (like 'Space')

    Percentage Streams: Every extended char can be converted to a type of printable ASCII 
    characters stream using UTF-8 encoding. These streams are of either of 3 formats:

    1. %HH (only for special chars <= 127)
    2. %HH%HH (for chars >127, <= 2047)
    3. %HH%HH%HH (for chars > 2048, <= 65535)
        H=A hexa-digit in {0-9,a-f,A-F}
            
    Any "%HH" is just a representation of a byte HH
        
    So a bytevalue = 32 base10 = 0001 0000 base2 = 0x20 = "%20" in UTF8-URL = Space

    For example:
        Space=%20
        =%C3%87
    
    Conversion scheme:
            UNICODE                            UTF-8(Byte Stream)        (UTF-8 URL)
        1. 0000000000000000..0000000001111111: 0xxxxxxx                    =>"%HH"
        2. 0000000010000000..0000011111111111: 110xxxxx 10xxxxxx           =>"%HH%HH"
        3. 0000100000000000..1111111111111111: 1110xxxx 10xxxxxx 10xxxxxx  =>"%HH%HH%HH"
    
        To know the format number of a percentage stream, check first 'H' after first '%'.

    If it is of format 0xxx (0-7), then stream is of format 1, bytelength = 1
    If it is of format 10xx (8-11), then stream is invalid
    If it is of format 110x (12-13), then stream is of format 2, bytelength = 2
    If it is of format 1110 (14), then stream is of format 3, bytelength = 3
    If it is of format 1111 (15), then stream is invalid

    Bits placement scheme: when converting between Unicode and UTf-8 ByteStream
    0xxx xxxx <=> 0000 0000 0xxx xxxx
    110x xxxx 10xx xxxx <=> 0000 0xxx xxxx xxxx
    1110 xxxx 10xx xxxx 10xx xxxx <=> xxxx xxxx xxxx xxxx
    
++*/

//
// This array maps special characters in printable ASCII char set to their equivalent 
// Percent strings in UTF-8 encoding. 
// URL don't allow many of the printable ASCII special characters so any such character
// in unicode filename string need to be converted to equvialent percent string.
// This table is used to speed up the conversion job else it will be very slow.
// 
WCHAR    EquivPercentStrings[128][4]={
    // Special character=NULL character
    L"", 
    // Special characters from 1-44
    L"%01", L"%02", L"%03", L"%04", L"%05", L"%06", L"%07", L"%08", L"%09",
    L"%0A", L"%0B", L"%0C", L"%0D", L"%0E", L"%0F", L"%10", L"%11", L"%12", L"%13",
    L"%14", L"%15", L"%16", L"%17", L"%18", L"%19", L"%1A", L"%1B", L"%1C", L"%1D",
    L"%1E", L"%1F", L"%20", L"%21", L"%22", L"%23", L"%24", L"%25", L"%26", L"%27",
    L"%28", L"%29", L"*", L"%2B", L"%2C", 
    // Valid printable characters from 45-57 
    L"-", L".", L"/", 
    L"0", L"1", L"2", L"3", L"4", L"5", L"6", L"7", L"8", L"9", 
    // Special characters from 58-64
    L":", L"%3B", L"%3C", L"%3D", L"%3E", L"%3F", L"%40", 
    // Valid printable characters from 65-90 ('A'-'Z')
    L"A", L"B", L"C", L"D", L"E", L"F", L"G", L"H", L"I", L"J", L"K", L"L", L"M", 
    L"N", L"O", L"P", L"Q", L"R", L"S", L"T", L"U", L"V", L"W", L"X", L"Y", L"Z", 
    // Special character 91
    L"%5B",
    // Valid Printable character 92
    L"\\", 
    // Special characters 93-94
    L"%5D", L"%5E", 
    // Valid Printable character 95
    L"_", 
    // Special character 96
    L"%60", 
    // Valid printable Characters from 97-122 ('a'-'z')
    L"a", L"b", L"c", L"d", L"e", L"f", L"g", L"h", L"i", L"j", L"k", L"l", L"m", 
    L"n", L"o", L"p", L"q", L"r", L"s", L"t", L"u", L"v", L"w", L"x", L"y", L"z", 
    // Special characters from 123-127
    L"%7B", L"%7C", L"%7D", L"%7E", L"%7F"
};

// 
// Table To map HexaChars to HexaValue
// First 'H' after '%' (in URL) will be mapped to equivalent hexa-digit using this array
// If 'H' is not a valid hexa-digit, then it will be mapped to 0x10
// which can be used to indicate Invalid-HexaDigit.
//
BYTE    WCharToByte[128] = {
    0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,
    0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,
    0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,
    0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,
    0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,   // 0 - 47
    0,1,2,3,4,5,6,7,8,9, // 48-57  '0'-'9'   //HEXA CHARS
    0x10,0x10,0x10,0x10,0x10,0x10,0x10, //58-64
    0x0A,0x0B,0x0C,0x0D,0x0E,0x0F, //65-70  'a'-'f' // HEXA-CHARS
    0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,
    0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,
    0x10,0x10,0x10,0x10,0x10,0x10, // 71-96
    0x0A,0x0B,0x0C,0x0D,0x0E,0x0F, //97-102  'A'-'F' // HEXA-CHARS
    0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,
    0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,
    0x10,0x10,0x10,0x10,0x10 // 103-127
};


HRESULT
UtfUrlStrToWideStr(
    IN LPWSTR UtfStr, 
    IN DWORD UtfStrLen, 
    OUT LPWSTR WideStr, 
    OUT LPDWORD pWideStrLen
    )
/*++
Routine Description:

    Convert a URL in UTF-8 format to UNICODE characters:

Arguments:

    UtfStr - Input string- UTF-8 format URL

    UtfStrLen - Length of UtfStr to convert
    
    WideStr - pointer to buffer which will receive output=converted unicode string

    pWideStrLen - pointer to receive number of WIDE CHARS in output
                  This can be NULL

Returns:
    It Returns the WIN32 error
    and ERROR_SUCCESS on success.

Assumption: 
    The length of output buffer (WideStr) is enough to hold output string 
    Help: It is always <= UtfStrlen

Algorithm:
    (first go thru information about UTF-8 URL <-> UNICODE conversion given above)

    Go character by character through UTF-8 URL
        If character is not '%', then it is printable ASCII char, copy it to output
        and move to next char in input buffer
        else
        It is starting of a new PercentageStream
        Convert first 'H' to equivalent hexa-digit. From first-hexa digit, findout
        what is format type of percentage-stream and what will be its length. 
        Now parse the expected length of percentage stream in input buffer and 
        convert them into unicode format (using conversion scheme told above).
        Move to first char after last character of percentage stream
++*/
{
    // 
    // Table To find percentage stream byte length using first hexa-digit of 
    // percentage stream. This hexa-digit is returned by mapping array WCharToByte.
    //
    BYTE        PercentStreamByteLen[17]={
        1,1,1,1,1,1,1,1,  // 0***  => %HH
        0, 0, 0, 0, // 10**        => Invalid Percentage stream
        2, 2, // 110*              => %HH%HH
        3, // 1110                 => %HH%HH%HH
        0, //1111                  => Invalid Percentage stream
        0}; //0x10                 => Invalid Percentage stream

    DWORD       PosInInpBuf = 0, PosInOutBuf = 0;
    BYTE        ByteValue = 0;
    DWORD       WStatus = ERROR_SUCCESS;
 
    //
    // Check for invalid parameters.
    // 
    if(WideStr == NULL || UtfStr == NULL || UtfStrLen <=0) {
        WStatus = ERROR_INVALID_PARAMETER;
        DavPrint((DEBUG_ERRORS, "UtfUrlStrToWideStr. Invalid parameters. ErrorVal=%u",
                WStatus));
        return WStatus;
    }

    //
    // Go thru every character in the input buffer.
    // 
    while(PosInInpBuf<UtfStrLen) {

        // 
        // If it is not %, then it is a printable ASCII char, copy it to output
        // buffer as it is.
        // 
        if(UtfStr[PosInInpBuf] != L'%') {
            WideStr[PosInOutBuf] = UtfStr[PosInInpBuf];
            PosInOutBuf++;
            PosInInpBuf++;
            continue;
        }

        //
        // It is start of new percentage stream.
        // 
        if(PosInInpBuf+1 == UtfStrLen) {
            //
            // Error in string (unexpected end)- bad string.
            // 
            WStatus = ERROR_NO_UNICODE_TRANSLATION;
            DavPrint((DEBUG_ERRORS, "UtfUrlStrToWideStr:1: No unicode translation. ErrorVal=%u",
                    WStatus));
            return WStatus;
        }

        //
        // Verify input string for various bad forms but 
        // Not verifying whether the characters in UtfStr after '%' are 
        // printable ASCII set (0-127) characters only (assuming they are!). 
        // Using a crash-safe approach=>(char & 0x7F) will return value in (0-127) only.
        //
        ByteValue = WCharToByte[UtfStr[PosInInpBuf+1]&0x7F];
        
        switch(PercentStreamByteLen[ByteValue]) {
            case 1:

                //
                // One byte UTF-8 (%HH). %20 = blanks fall in this category.
                // Check for string length.
                // 
                if(PosInInpBuf+2 >= UtfStrLen) {
                    // 
                    // Error in string (unexpected end) - bad string.
                    // 
                    WStatus = ERROR_NO_UNICODE_TRANSLATION;
                    DavPrint((DEBUG_ERRORS, "UtfUrlStrToWideStr:2: No unicode translation. ErrorVal=%d",
                             WStatus));
                    return WStatus;
                }

                WideStr[PosInOutBuf] = 
                (WCHAR)(WCharToByte[UtfStr[PosInInpBuf+1]&0x7F]&0x0007)<<4 | 
                        (WCharToByte[UtfStr[PosInInpBuf+2]&0x7F]&0x000F);
        
                PosInOutBuf++;
                PosInInpBuf+=3;
                break;
            case 2:

                // 
                // Two byte UTF-8 (most common) (%HH%HH).
                // Check string length.
                // 
                if(PosInInpBuf+5 >= UtfStrLen || UtfStr[PosInInpBuf+3] != L'%') {
                    // 
                    // Error in string - bad string.
                    // 
                    WStatus = ERROR_NO_UNICODE_TRANSLATION;
                    DavPrint((DEBUG_ERRORS, "UtfUrlStrToWideStr:3: No unicode translation. ErrorVal=%d",
                              WStatus));
                    return WStatus;
                }
    
                WideStr[PosInOutBuf] = 
                (WCHAR)(WCharToByte[UtfStr[PosInInpBuf+1]&0x7F]&0x0001)<<10 | 
                        (WCharToByte[UtfStr[PosInInpBuf+2]&0x7F]&0x000F)<<6 | 
                        (WCharToByte[UtfStr[PosInInpBuf+4]&0x7F]&0x0003)<<4 |
                        (WCharToByte[UtfStr[PosInInpBuf+5]&0x7F]&0x000F);

                PosInOutBuf++;
                PosInInpBuf+=6;
                break;
            case 3:

                // 
                // Three byte UTF-8 (less common) (%HH%HH%HH).
                // Check for string length.
                // 
                if(PosInInpBuf+8 >= UtfStrLen || 
                        UtfStr[PosInInpBuf+3] != L'%' ||
                        UtfStr[PosInInpBuf+6] != L'%') {
                    // 
                    // Error in string - bad string.
                    // 
                    WStatus = ERROR_NO_UNICODE_TRANSLATION;
                    DavPrint((DEBUG_ERRORS, "UtfUrlStrToWideStr:4: No unicode translation. ErrorVal=%d",
                            WStatus));
                    return WStatus;
                }

                WideStr[PosInOutBuf] = 
                    (WCHAR)(WCharToByte[UtfStr[PosInInpBuf+2]&0x7F]&0x000F)<<12 | 
                        (WCharToByte[UtfStr[PosInInpBuf+4]&0x7F]&0x0003)<<10 | 
                        (WCharToByte[UtfStr[PosInInpBuf+5]&0x7F]&0x000F)<<6 |
                        (WCharToByte[UtfStr[PosInInpBuf+7]&0x7F]&0x0003)<<4 |
                        (WCharToByte[UtfStr[PosInInpBuf+8]&0x7F]&0x000F);

                PosInOutBuf++;
                PosInInpBuf+=9;
                break;
            default: 

                // 
                // PercentageStreamByteLen = 0 comes here.
                // Error in string - bad string.
                // 
                WStatus = ERROR_NO_UNICODE_TRANSLATION;
                DavPrint((DEBUG_ERRORS, "UtfUrlStrToWideStr:5: No unicode translation. ErrorVal=%d",
                        WStatus));
                return WStatus;
            };
    }

    if(pWideStrLen) {
        *pWideStrLen = PosInOutBuf;
    }

    WStatus = ERROR_SUCCESS;
    return WStatus;
}


DWORD
WideStrToUtfUrlStr(
    IN LPWSTR WideStr, 
    IN DWORD WideStrLen, 
    IN OUT LPWSTR InOutBuf,
    IN DWORD InOutBufLen
    )
/*++

Routine Description:

    Convert a string of UNICODE characters to UTF-8 URL:

Arguments:

    WideStr - pointer to input wide-character string

    WideStrLen - number of WIDE CHARS in input string

    InOutBuf - Converted string will be copied to this buffer if, this is not null,
               and InOutBufLen >= required length for converted string.
    
    InOutBufLen - Length of InOutBuf in WIDE CHARS
    
           If InOutBuf is not sufficient to contain converted string - Only
           the length of the converted string will be returned, and LastError is set to
           ERROR_INSUFFICIENT_BUFFER

Returns:

    It returns the Length of converted string in WCHARS
    In case of error - it returns 0, check GetLastError()
    If buffer is small for converted string then GetLastError is set to 
    ERROR_INSUFFICIENT_BUFFER

Algorithm:

    (first go thru information about UTF-8 URL <-> UNICODE conversion given above)

    Go thru each char in input buffer:
    If it is printable ASCII char, then 
        If it is special character, then copy its equivalent percent string
    else
    copy the character as it is
    else
        Find out to which percentage stream format it will convert to.
    Convert it using conversion scheme given above

Note: 

++*/
{
    DWORD WStatus = ERROR_SUCCESS;
    LPWSTR UtfUrlStr = NULL;
    DWORD UrlLen = 0;
    WCHAR HexDigit[17] = L"0123456789ABCDEF";
    WCHAR WCharValue = 0;
    DWORD PosInInpBuf = 0;

    WStatus = ERROR_SUCCESS;
    SetLastError(WStatus);

    // 
    // Check for valid parameters.
    // 
    if (WideStr == NULL || WideStrLen <= 0) {
        WStatus = ERROR_INVALID_PARAMETER;
        SetLastError(WStatus);
        DavPrint((DEBUG_ERRORS,
                  "WideStrToUtfUrlStr. Invalid parameters. ErrorVal = %d",
                  WStatus));
        return 0;
    }

    DavPrint((DEBUG_MISC,
              "WideStrToUtfUrlStr: WideStr = %ws, WideStrLen = %d\n", 
              WideStr, WideStrLen));

    // 
    // Calculate required length in WCHARS for storing converted string
    // Check from every unicode char - to which PercentageStream format it 
    // will convert to.
    // 
    for (PosInInpBuf = 0; PosInInpBuf < WideStrLen; PosInInpBuf++) {
        if (WideStr[PosInInpBuf] < 0x80) {
            // 
            // (0-127) => Printable ASCII char. Special characters in this range need
            // to be converted to equivalent percent strings
            // 
            // 
            // If character is NULL, then its equivalent string is L"". wcslen returns
            // 0 for this string so add 1 to UrlLen to account for this NULL character
            // 
            if (WideStr[PosInInpBuf] == 0) {
               UrlLen += 1;
            } else {
                UrlLen += wcslen(&EquivPercentStrings[(DWORD)WideStr[PosInInpBuf]][0]);
            }
        } else {
            if (WideStr[PosInInpBuf] < 0x0800) {
                //
                // ( >127, <=2047) => "%HH%HH".
                //
                UrlLen += 6; 
            } else {
                //
                //( >2047, <=65535) => "%HH%HH%HH%HH".
                //
                UrlLen += 9; 
            }
        }
    }

    // 
    // If InOutBuf is not sufficient to contain the converted string then
    // required length of converted string is returned
    // 
    if (InOutBuf == NULL || InOutBufLen < UrlLen) {
        // 
        // Only converted string length is returned.
        // 
        WStatus = ERROR_INSUFFICIENT_BUFFER;
        SetLastError(WStatus);
        return UrlLen;
    }

    //
    // InOutBuf is sufficiently long enough to contain converted string, use it.
    //
    ASSERT(InOutBuf != NULL);
    ASSERT(InOutBufLen >= UrlLen);

    //
    // InOutBuf is long enough to contain converted string
    //
    UtfUrlStr = InOutBuf;

    // 
    // Check from every unicode char - to which PercentageStream format it 
    // will convert to.
    // 
    UrlLen = 0;
    for (PosInInpBuf = 0; PosInInpBuf < WideStrLen; PosInInpBuf++) {
        if (WideStr[PosInInpBuf] < 0x80) {
            // 
            // (0-127) => Printable ASCII char. Special characters in this range need
            // to be converted to equivalent percent strings
            // 
            wcscpy(&UtfUrlStr[UrlLen], &EquivPercentStrings[(DWORD)WideStr[PosInInpBuf]][0]); 
            // 
            // If character is NULL, then its equivalent string is L"". wcslen returns
            // 0 for this string so add 1 to UrlLen to account for this NULL character
            // 
            if (WideStr[PosInInpBuf] == 0) {
                UrlLen += 1;
            } else {
                UrlLen += wcslen(&EquivPercentStrings[(DWORD)WideStr[PosInInpBuf]][0]); 
            }
        } else {
            if (WideStr[PosInInpBuf] < 0x0800) {
                // 
                // ( >127, <=2047) => "%HH%HH".
                // First %HH.
                // 
                UtfUrlStr[UrlLen++] = L'%';
                WCharValue = 0x00C0 |             // 1100 0000
                    ((WideStr[PosInInpBuf] & 0x07C0)>>6); // Top 5 bits if UniChar
                    UtfUrlStr[UrlLen++] = HexDigit[(WCharValue&0x00F0)>>4];    //H1
                    UtfUrlStr[UrlLen++] = HexDigit[(WCharValue&0x000F)];       //H2
                //
                // Second %HH.
                // 
                UtfUrlStr[UrlLen++] = L'%';
                WCharValue = 0x0080 |                // 1000 0000 
                    (WideStr[PosInInpBuf] & 0x003F); // Last 6 bits of UniChar
                    UtfUrlStr[UrlLen++] = HexDigit[(WCharValue&0x00F0)>>4];    //H1
                    UtfUrlStr[UrlLen++] = HexDigit[(WCharValue&0x000F)];       //H2
            } else {
                // 
                // ( >2047, <=65535) => "%HH%HH%HH%HH".
                // First %HH.
                // 
                UtfUrlStr[UrlLen++] = L'%';
                WCharValue = 0x00E0 |              // 1110 0000
                    ((WideStr[PosInInpBuf] & 0xF000)>>12); // Top 4 bits of UniChar
                    UtfUrlStr[UrlLen++] = HexDigit[(WCharValue&0x00F0)>>4]; //H1
                    UtfUrlStr[UrlLen++] = HexDigit[(WCharValue&0x000F)];    //H2
                //
                // Second %HH.
                // 
                UtfUrlStr[UrlLen++] = L'%';
                WCharValue = 0x0080 | // 1000 0000
                    ((WideStr[PosInInpBuf] & 0x0FC0)>>6); // Next 6 bits of UniChar
                    UtfUrlStr[UrlLen++] = HexDigit[(WCharValue&0x00F0)>>4]; //H1
                    UtfUrlStr[UrlLen++] = HexDigit[(WCharValue&0x000F)];    //H2
                // 
                // Third %HH.
                // 
                UtfUrlStr[UrlLen++] = L'%';
                WCharValue = 0x0080 | // 1000 0000
                    (WideStr[PosInInpBuf] & 0x003F);    // Last 6 bits of UniChar
                    UtfUrlStr[UrlLen++] = HexDigit[(WCharValue&0x00F0)>>4]; //H1
                    UtfUrlStr[UrlLen++] = HexDigit[(WCharValue&0x000F)];    //H2
            }
        }
    }

    DavPrint((DEBUG_MISC,
              "WideStrToUtfUrlStr: WideStr = %ws, WideStrLen = %d, UtfUrlStr = %ws, UrlLen = %d\n",
              WideStr, WideStrLen, UtfUrlStr, UrlLen));

    //
    // The converted string is stored in InOutBuf
    //

    WStatus = ERROR_SUCCESS;
    SetLastError(WStatus);
    return UrlLen;
}


BOOL
DavHttpOpenRequestW(
    IN HINTERNET hConnect,
    IN LPWSTR lpszVerb,
    IN LPWSTR lpszObjectName,
    IN LPWSTR lpszVersion,
    IN LPWSTR lpszReferer,
    IN LPWSTR FAR * lpszAcceptTypes,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext,
    IN LPWSTR ErrMsgTag,
    OUT HINTERNET * phInternet
    )
/*++
Routine Description:

    Convert a URL in UNICODE characters, to UTF-8 URL encoded format and use it in
    call to HttpOpenRequestW

Arguments:
    hConnect:
    lpszVerb:
    lpszVersion:
    lpszReferer:
    lpszAcceptTypes:
    dwFlags:
    dwContext:
                These parameters are to be passed to HttpOpenRequestW as it is.

    lpszObjectName: This parameter is the URL in unicode charaters - which will
                    be converted to UTF-8 URL format. Then converted format will 
                    be passed to HttpOpenRequestW
        
    ErrMsgTag: Any message tag to be printed along with debug messages.
    phInternet: Pointer that will receive the Handle returned by HttpOpenRequestW. If this
                parameter is NULL, then it will not be set

Returns:

    TRUE if HttpOpenRequestW is called. Check GetLastError() for error status from call.

    FALSE, if it could not call HttpOpenRequestW. Check GetLastError() for error.

Note: It don't process return status of HttpOpenRequestW. Check GetLastError() for error
      set by HttpOpenRequestW.

++*/
{
    DWORD WStatus = ERROR_SUCCESS;
    LPWSTR AllocUrlPath = NULL;
    HINTERNET hInternet = NULL;
    BOOL rval = FALSE;
    DWORD convLen = 0;
    DWORD ObjNameLen = 0;
    WCHAR LocalUrlPath[128] = L"";
    LPWSTR UrlPath = NULL;
    WCHAR EmptyStrW[1] = L"";

    //
    // This error msg tag is just a string which a calling function might want to print 
    // along with the error messages printed inside this function
    //
    // Ex. Suppose FunctionA calls this function, then it can pass L"FunctionA" to print
    // along with error messages. Looking at the error mesg, a user can know that this 
    // function was called in FunctionA
    // 
    if (ErrMsgTag == NULL) {
        ErrMsgTag = EmptyStrW;
    }

    // 
    // Convert the unicode objectname to UTF-8 URL format
    // space and other white (special) characters will remain untouched - these should
    // be taken care of by wininet calls.
    //
    UrlPath = NULL;
    AllocUrlPath = NULL;
    ObjNameLen = (wcslen(lpszObjectName) + 1); // To take care of NULL char add 1 to length
    
    convLen = WideStrToUtfUrlStr(lpszObjectName, 
                                 ObjNameLen, 
                                 LocalUrlPath, 
                                 sizeof(LocalUrlPath)/sizeof(WCHAR));
    WStatus = GetLastError();

    if (WStatus == ERROR_INSUFFICIENT_BUFFER) {
        
        ASSERT(convLen > 0);
        // 
        // Buffer passed to function WideStrToUtfUrlStr is small, need to allocate
        // new buffer of required length. The required length is returned by this function.
        // 
        AllocUrlPath = (LPWSTR)LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, 
                                            convLen*sizeof(WCHAR));
        if (AllocUrlPath == NULL) {
            // 
            // LocalAlloc sets Last error.
            // 
            WStatus = GetLastError();
            rval = FALSE;
            DavPrint((DEBUG_ERRORS, "%ws.DavHttpOpenRequestW/LocalAlloc failed. ErrorVal=%d",
                    ErrMsgTag, WStatus));
            goto EXIT_THE_FUNCTION;
        }

        // 
        // Call the function WideStrToUtfUrlStr with new allocated buffer (this buffer should
        // be sufficient to contain output coverted string
        //
        convLen = WideStrToUtfUrlStr(lpszObjectName, 
                                     ObjNameLen, 
                                     AllocUrlPath, 
                                     convLen);
        WStatus = GetLastError();

    }

    if(WStatus != ERROR_SUCCESS) {
        rval = FALSE;
        DavPrint((DEBUG_ERRORS,
                  "%ws.DavHttpOpenRequest/WideStrToUtfUrlStr. Error Val = %d\n", 
                  ErrMsgTag, WStatus));
        goto EXIT_THE_FUNCTION;
    }

    //
    // If converted string is stored in allocated buffer, then set UrlPath to point to 
    // buffer allocated else output string is stored in local buffer, so point UrlPath to it.
    //
    if (AllocUrlPath != NULL) {
        UrlPath = AllocUrlPath;
    } else {
        UrlPath = LocalUrlPath;
    }

    //
    // Call to HttpOpenRequestW with converted URL.
    //
    try {
        hInternet = HttpOpenRequestW(hConnect,
                                     lpszVerb,
                                     UrlPath,
                                     lpszVersion,
                                     lpszReferer,
                                     lpszAcceptTypes,
                                     dwFlags,
                                     dwContext);
    } except (GetExceptionCode() == STATUS_NO_MEMORY) {
          rval = FALSE;
          WStatus = ERROR_NOT_ENOUGH_MEMORY;
          DavPrint((DEBUG_ERRORS,
                    "DavHttpOpenRequest/HttpOpenRequestW. Error Val = %d\n", 
                    ErrMsgTag, WStatus));
          goto EXIT_THE_FUNCTION;
    }

    rval = TRUE;
    WStatus = GetLastError();

EXIT_THE_FUNCTION:

    //
    // Free UrlPath allocated in successful call to function WideStrToUtfUrlStr.
    //
    if (AllocUrlPath != NULL) {
        LocalFree((HANDLE)AllocUrlPath);
        AllocUrlPath = NULL;
        UrlPath = NULL;
    }

    if (phInternet) {
        *phInternet = hInternet;
    }

    //
    // We set the last error here because the caller of this function is expected
    // call GetLastError() to get the error status.
    //
    SetLastError(WStatus);

    return rval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\server\uniutf.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    UniUtf.h
    
Abstract:

    This file declares the functions used for Unicode object name to/from Utf8-URL coversion

Author:

    Mukul Gupta        [Mukgup]      20-Dec-2000

Revision History:

--*/

#ifndef _UNICODE_UTF8_
#define _UNICODE_UTF8_

#include <stdio.h>

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

HRESULT 
UtfUrlStrToWideStr(
    IN LPWSTR UtfStr, 
    IN DWORD UtfStrLen, 
    OUT LPWSTR WideStr, 
    OUT LPDWORD pWideStrLen
    );

DWORD 
WideStrToUtfUrlStr(
    IN LPWSTR WideStr, 
    IN DWORD WideStrLen, 
    IN OUT LPWSTR InOutBuf,
    IN DWORD InOutBufLen
    );

BOOL 
DavHttpOpenRequestW(
    IN HINTERNET hConnect,
    IN LPWSTR lpszVerb,
    IN LPWSTR lpszObjectName,
    IN LPWSTR lpszVersion,
    IN LPWSTR lpszReferer,
    IN LPWSTR FAR * lpszAcceptTypes,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext,
    IN LPWSTR ErrMsgTag,
    OUT HINTERNET * phInternet
    );

    
#ifdef __cplusplus
}
#endif // __cplusplus


#endif  // _UNICODE_UTF8_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\server\srvcall.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    srvcall.c

Abstract:

    This module implements the user mode DAV miniredir routines pertaining to
    creation of srvcalls.

Author:

    Rohan Kumar      [RohanK]      25-May-1999

Revision History:

--*/

#include "pch.h"
#pragma hdrstop

#include "ntumrefl.h"
#include "usrmddav.h"
#include "global.h"
#include "winsock2.h"
#include <time.h>

//
// Mentioned below are the prototypes of functions tht are used only within
// this module (file). These functions should not be exposed outside.
//

VOID
DavParseOPTIONSLine(
    PWCHAR ParseData, 
    PDAV_USERMODE_WORKITEM DavWorkItem
    );

//
// Implementation of functions begins here.
//

ULONG
DavFsCreateSrvCall(
    PDAV_USERMODE_WORKITEM DavWorkItem
    )
/*++

Routine Description:

    This routine verifies if the server for which a srvcall is being created in
    the kernel exists or not.

Arguments:

    DavWorkItem - The buffer that contains the server name.

Return Value:

    The return status for the operation

--*/
{
    ULONG WStatus = ERROR_SUCCESS;
    PHASH_SERVER_ENTRY ServerHashEntry = NULL;
    PWCHAR ServerName = NULL;
    HINTERNET DavConnHandle = NULL;
    ULONG_PTR CallBackContext = (ULONG_PTR)0;
    BOOL CallBackContextInitialized = FALSE, isPresent = FALSE, CricSec = FALSE;
    PDAV_USERMODE_CREATE_SRVCALL_REQUEST CreateSrvCallRequest;
    PDAV_USERMODE_CREATE_SRVCALL_RESPONSE CreateSrvCallResponse;
    ULONG ServerNameLengthInBytes, TotalLength;
    BOOL didImpersonate = FALSE;
    PUMRX_USERMODE_WORKITEM_HEADER UserWorkItem = NULL;

    CreateSrvCallRequest = &(DavWorkItem->CreateSrvCallRequest);
    CreateSrvCallResponse = &(DavWorkItem->CreateSrvCallResponse);

    ServerName = CreateSrvCallRequest->ServerName;

    //
    // If the server name is NULL, return.
    //
    if (!ServerName) {
        DavPrint((DEBUG_ERRORS, "DavFsCreateSrvCall: ServerName == NULL\n"));
        //
        // Set the ServerID in the response to zero. This will help the
        // kernel mode realize that the ServerHashEntry was never created.
        // So, when finalize happens immediately after we fail from here,
        // the request is not sent to the user mode. The number 0 works
        // because the ID can never be zero in the normal case. The first
        // assigned ID number is 1.
        //
        CreateSrvCallResponse->ServerID = 0;
        WStatus = ERROR_INVALID_PARAMETER; // STATUS_INVALID_PARAMETER;
        goto EXIT_THE_FUNCTION;
    }

    DavPrint((DEBUG_MISC, "DavFsCreateSrvCall: ServerName: %ws.\n", ServerName));

    //
    // Check the ServerHashTable and/or the "to be finalized list" to see if we 
    // have an entry for this server. Need to take a lock on the table before 
    // doing the check.
    //
    EnterCriticalSection( &(HashServerEntryTableLock) );
    CricSec = TRUE;

    //
    // These will already be set to FALSE since the DavWorkItem is always zeroed
    // before its resued but set them to FALSE anyway.
    //
    CreateSrvCallRequest->didICreateThisSrvCall = FALSE;
    CreateSrvCallRequest->didIWaitAndTakeReference = FALSE;
    
    //
    // The entry is either in the ServerHashTable or in the "to be finalized" 
    // list, or we need to create a new entry for it.
    //

    //
    // We check the ServerHashTable first.
    //
    isPresent = DavIsThisServerInTheTable(ServerName, &ServerHashEntry);
    
    if (isPresent) {
        
        DavPrint((DEBUG_MISC,
                  "DavFsCreateSrvCall: ServerName: %ws does exist in"
                  " the \"ServerHashTable\"\n", ServerName));

        ASSERT(ServerHashEntry != NULL);

        //
        // Increment the Reference count of the ServerEntry by 1.
        //
        ServerHashEntry->ServerEntryRefCount += 1;

        //
        // Note that we are a thread that will wait for some other thread that
        // is initializing this ServerHashEntry and that we have taken a 
        // reference on this entry.
        //
        CreateSrvCallRequest->didIWaitAndTakeReference = TRUE;

        //
        // Set the ServerHashEntry in the DavWorkItem structure. We might need
        // this in DavAsyncCreateSrvCallCompletion.
        //
        DavWorkItem->AsyncCreateSrvCall.ServerHashEntry = ServerHashEntry;

        //
        // If its initializing, then I need to free the lock and wait on the
        // event.
        //
        if (ServerHashEntry->ServerEntryState == ServerEntryInitializing) {

            DWORD WaitStatus;

            LeaveCriticalSection( &(HashServerEntryTableLock) );
            CricSec = FALSE;

            WaitStatus = WaitForSingleObject(ServerHashEntry->ServerEventHandle, INFINITE);
            if (WaitStatus == WAIT_FAILED) {
                WStatus = GetLastError();
                DavPrint((DEBUG_ERRORS,
                          "DavFsCreateSrvCall/WaitForSingleObject. Error Val = %d\n",
                           WStatus));
                goto EXIT_THE_FUNCTION;
            }

            ASSERT(WaitStatus == WAIT_OBJECT_0);

        }

        //
        // We could have left the lock while waiting on an event. If we have,
        // then we need to acquire it back before proceeding further.
        //
        if (!CricSec) {
            EnterCriticalSection( &(HashServerEntryTableLock) );
            CricSec = TRUE;
        }

        //
        // If the initialization failed then the error is stored in the 
        // ErrorStatus field.
        //
        if (ServerHashEntry->ServerEntryState == ServerEntryInitializationError) {
            DavPrint((DEBUG_ERRORS, "DavFsCreateSrvCall: ServerEntryInitializationError\n"));
            WStatus = ServerHashEntry->ErrorStatus;
            LeaveCriticalSection( &(HashServerEntryTableLock) );
            CricSec = FALSE;
            goto EXIT_THE_FUNCTION;
        }

        ASSERT(ServerHashEntry->ServerEntryState == ServerEntryInitialized);

        //
        // We got a Server that is valid. Set the ServerID and return.
        //
        WStatus = ERROR_SUCCESS;
        DavWorkItem->Status = WStatus;
        CreateSrvCallResponse->ServerID = ServerHashEntry->ServerID;

        LeaveCriticalSection( &(HashServerEntryTableLock) );
        CricSec = FALSE;

        goto EXIT_THE_FUNCTION;

    }

    DavPrint((DEBUG_MISC,
              "DavFsCreateSrvCall: ServerName: %ws does not exist in"
              " the \"ServerHashTable\"\n", ServerName));

    //
    // We need to find out if an entry for this server exists. Check the
    // "to be finalized" list of server entries. If the server entry exists
    // in the "to be finalized" list and is a valid DAV server, the rouitne
    // below, moves it to the hash table to reactivate it.
    //
    isPresent = DavIsServerInFinalizeList(ServerName, &ServerHashEntry, TRUE);
    
    if (isPresent) {

        DavPrint((DEBUG_MISC,
                  "DavFsCreateSrvCall: ServerName: %ws does exist in"
                  " the \"to be finalized\" list\n", ServerName));

        if (ServerHashEntry != NULL) {

            DavPrint((DEBUG_MISC,
                      "DavFsCreateSrvCall: ServerName: %ws is a valid "
                      " DAV server\n", ServerName));

            //
            // We got a Server that is valid. Set the ServerID and return.
            //
            WStatus = ERROR_SUCCESS;
            DavWorkItem->Status = WStatus;
            CreateSrvCallResponse->ServerID = ServerHashEntry->ServerID;

        } else {

            DavPrint((DEBUG_MISC,
                      "DavFsCreateSrvCall: ServerName: %ws is NOT a valid "
                      " DAV server\n", ServerName));

            //
            // The entry is a not valid DAV server.
            //
            WStatus = ERROR_BAD_NETPATH; // STATUS_BAD_NETWORK_PATH;
            DavWorkItem->Status = WStatus;
            CreateSrvCallResponse->ServerID = 0;

        }

        LeaveCriticalSection( &(HashServerEntryTableLock) );
        CricSec = FALSE;

        goto EXIT_THE_FUNCTION;

    }

    UserWorkItem = (PUMRX_USERMODE_WORKITEM_HEADER)DavWorkItem;

    //
    // If we are using WinInet synchronously, then we need to impersonate the
    // clients context now.
    //
#ifndef DAV_USE_WININET_ASYNCHRONOUSLY
    
    WStatus = UMReflectorImpersonate(UserWorkItem, DavWorkItem->ImpersonationHandle);
    if (WStatus != ERROR_SUCCESS) {
        DavPrint((DEBUG_ERRORS,
                  "DavFsCreateSrvCall/UMReflectorImpersonate. Error Val = %d\n",
                  WStatus));
        goto EXIT_THE_FUNCTION;
    }
    didImpersonate = TRUE;

#endif

    //
    // The entry does not exist in the "to be finalized" list. We need to
    // create a new one.
    //

    DavPrint((DEBUG_MISC,
              "DavFsCreateSrvCall: ServerName: %ws doesn't exist in the"
              " \"to be finalized\" list\n", ServerName));

    ASSERT(ServerHashEntry == NULL);
    ServerNameLengthInBytes = (1 + wcslen(ServerName)) * sizeof(WCHAR);
    TotalLength = ServerNameLengthInBytes + sizeof(HASH_SERVER_ENTRY);

    ServerHashEntry = LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, TotalLength);
    if (ServerHashEntry == NULL) {
        WStatus = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavFsCreateSrvCall/LocalAlloc. Error Val = %d.\n",
                  WStatus));
        goto EXIT_THE_FUNCTION;
    }

    //
    // Mark in the request that we are creating this SrvCall. This will be used
    // during SrvCallCompletion.
    //
    CreateSrvCallRequest->didICreateThisSrvCall = TRUE;

    //
    // Set the entry in the workitem which gets passed around in Async
    // calls.
    //
    DavWorkItem->AsyncCreateSrvCall.ServerHashEntry = ServerHashEntry;

    //
    // Initialize the entry and insert it into the global hash table.
    //
    DavInitializeAndInsertTheServerEntry(ServerHashEntry,
                                         ServerName,
                                         TotalLength);

    ServerHashEntry->ServerEntryState = ServerEntryInitializing;

    //
    // Create a event which has to be manually set to non-signalled state and
    // set it to "not signalled".
    //
    ServerHashEntry->ServerEventHandle = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (ServerHashEntry->ServerEventHandle == NULL) {
        WStatus = GetLastError();
        ServerHashEntry->ServerEntryState = ServerEntryInitializationError;
        ServerHashEntry->ErrorStatus = WStatus;
        DavPrint((DEBUG_ERRORS,
                  "DavFsCreateSrvCall/CreateEvent. Error Val = %d\n", WStatus));
        goto EXIT_THE_FUNCTION;
    }

    //
    // Set the ServerID in the response.
    //
    CreateSrvCallResponse->ServerID = ServerHashEntry->ServerID;

    //
    // Now, we need to figure out if this is a HTTP/DAV server or not.
    //

    //
    // IMPORTANT TO UNDERSTAND THIS!!!!!
    // This is a special case of user entry creation/initialization which is
    // done without holding a lock on the ServerHashTable. This is because
    // during CreateSrvCall, we are guaranteed that no other thread will ever
    // come up for this server till this request has been completed. All other
    // threads that carry "create" requests for files on this server are
    // blocked inside of RDBSS.
    //

    LeaveCriticalSection( &(HashServerEntryTableLock) );
    CricSec = FALSE;

    //
    // We need to call this only if "DAV_USE_WININET_ASYNCHRONOUSLY" has been
    // defined. Otherwise, if we are using WinInet synchronously, then we 
    // would have already done this in the DavWorkerThread function. This 
    // ultimately gets deleted (the impersonation token that is) in the 
    // DavAsyncCreateCompletion function.
    //
#ifdef DAV_USE_WININET_ASYNCHRONOUSLY
    
    //
    // Set the DavCallBackContext.
    //
    WStatus = DavFsSetTheDavCallBackContext(DavWorkItem);
    if (WStatus != ERROR_SUCCESS) {
        DavPrint((DEBUG_ERRORS,
                  "DavFsCreateSrvCall/DavFsSetTheDavCallBackContext. Error Val"
                  " = %d\n", WStatus));
        goto EXIT_THE_FUNCTION;
    }
    CallBackContextInitialized = TRUE;

    //
    // Store the address of the DavWorkItem which serves as a callback in the
    // variable CallBackContext. This will now be used in all the async calls
    // that follow. This needs to be done only if we are calling the WinInet
    // APIs asynchronously.
    //
    CallBackContext = (ULONG_PTR)(DavWorkItem);

#endif

    //
    // Allocate memory for the INTERNET_ASYNC_RESULT structure.
    //
    DavWorkItem->AsyncResult = LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT,
                                          sizeof(INTERNET_ASYNC_RESULT));
    if (DavWorkItem->AsyncResult == NULL) {
        WStatus = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavFsCreateSrvCall/LocalAlloc. Error Val = %d.\n",
                  WStatus));
        goto EXIT_THE_FUNCTION;
    }

    //
    // Need to set the DavOperation field before submitting the asynchronous
    // request. This is a internet connect operation.
    //
    DavWorkItem->DavOperation = DAV_CALLBACK_INTERNET_CONNECT;

    //
    // Create a handle to connect to a HTTP/DAV server.
    //
    DavConnHandle = InternetConnectW(IHandle,
                                     (LPCWSTR)ServerName,
                                     INTERNET_DEFAULT_HTTP_PORT,
                                     NULL,
                                     NULL,
                                     INTERNET_SERVICE_HTTP,
                                     0,
                                     CallBackContext);
    if (DavConnHandle == NULL) {
        WStatus = GetLastError();
        if (WStatus != ERROR_IO_PENDING) {
            DavPrint((DEBUG_ERRORS,
                      "DavFsCreateSrvCall/InternetConnect. Error Val = %d.\n",
                      WStatus));
        }
        goto EXIT_THE_FUNCTION;
    }

    //
    // Cache the InternetConnect handle in the DavWorkItem.
    //
    DavWorkItem->AsyncCreateSrvCall.DavConnHandle = DavConnHandle;

    WStatus = DavAsyncCommonStates(DavWorkItem, FALSE);

    if (WStatus != ERROR_SUCCESS && WStatus != ERROR_IO_PENDING) {

        DavPrint((DEBUG_ERRORS,
                  "DavFsCreateSrvCall/DavAsyncCommonStates. Error Val = %08lx\n",
                  WStatus));

        //
        // If we fail with ERROR_INTERNET_NAME_NOT_RESOLVED, we make the
        // following call so that WinInet picks up the correct proxy settings
        // if they have changed. This is because we do call InternetOpen
        // (to create a global handle from which every other handle is derived)
        // when the service starts and this could be before the user logon
        // happpens. In such a case the HKCU would not have been initialized
        // and WinInet wouldn't get the correct proxy settings.
        //
        if (WStatus == ERROR_INTERNET_NAME_NOT_RESOLVED) {
            InternetSetOptionW(NULL, INTERNET_OPTION_SETTINGS_CHANGED, NULL, 0);
        }

    }

EXIT_THE_FUNCTION:

    //
    // If we came along a path without freeing the lock, now is the  time to
    // free it.
    //
    if (CricSec) {
        LeaveCriticalSection( &(HashServerEntryTableLock) );
        CricSec = FALSE;
    }

#ifdef DAV_USE_WININET_ASYNCHRONOUSLY
    
    //
    // Some resources should not be freed if we are returning ERROR_IO_PENDING
    // because they will be used in the callback functions.
    //
    if ( WStatus != ERROR_IO_PENDING ) {

        //
        // Set the return status of the operation. This is used by the kernel
        // mode routines to figure out the completion status of the user mode
        // request.
        //
        if (WStatus != ERROR_SUCCESS) {
            DavWorkItem->Status = DavMapErrorToNtStatus(WStatus);
        } else {
            DavWorkItem->Status = STATUS_SUCCESS;
        }
        
        //
        // Free up the resources that were allocated for the SrvCall creation.
        //
        DavAsyncCreateSrvCallCompletion(DavWorkItem);

    }

#else 
    
    //
    // If we are using WinInet synchronously, then we should never get back
    // ERROR_IO_PENDING from WinInet.
    //
    ASSERT(WStatus != ERROR_IO_PENDING);

    //
    // If this thread impersonated a user, we need to revert back.
    //
    if (didImpersonate) {
        RevertToSelf();
    }

    //
    // Set the return status of the operation. This is used by the kernel
    // mode routines to figure out the completion status of the user mode
    // request. This is done here because the async completion routine that is
    // called immediately afterwards needs the status set.
    //
    if (WStatus != ERROR_SUCCESS) {
        DavWorkItem->Status = DavMapErrorToNtStatus(WStatus);
    } else {
        DavWorkItem->Status = STATUS_SUCCESS;
    }
    
    //
    // Free up the resources that were allocated for the SrvCall creation.
    //
    DavAsyncCreateSrvCallCompletion(DavWorkItem);

#endif

    return WStatus;
}


DWORD
DavAsyncCreateSrvCall(
    PDAV_USERMODE_WORKITEM DavWorkItem,
    BOOLEAN CalledByCallBackThread
    )
/*++

Routine Description:

   This is the callback routine for the create srvcall operation.

Arguments:

    DavWorkItem - The DAV_USERMODE_WORKITEM value.

    CalledByCallbackThread - TRUE, if this function was called by the thread
                             which picks of the DavWorkItem from the Callback
                             function. This happens when an Async WinInet call
                             returns ERROR_IO_PENDING and completes later.

Return Value:

    ERROR_SUCCESS or the appropriate error value.

--*/
{
    ULONG WStatus = ERROR_SUCCESS;
    PUMRX_USERMODE_WORKITEM_HEADER UserWorkItem;
    HINTERNET DavOpenHandle = NULL;
    BOOL ReturnVal, didImpersonate = FALSE;
    PWCHAR DataBuff = NULL, ParseData = NULL;
    DWORD DataBuffBytes = 0;

    UserWorkItem = (PUMRX_USERMODE_WORKITEM_HEADER)DavWorkItem;
    
#ifdef DAV_USE_WININET_ASYNCHRONOUSLY
    
    //
    // If this function was called by the thread that picked off the DavWorkItem
    // from the Callback function, we need to do a few things first. These are
    // done below.
    //
    if (CalledByCallBackThread) {
    
        //
        // We are running in the context of a worker thread which has different
        // credentials than the user that initiated the I/O request. Before
        // proceeding further, we should impersonate the user that initiated the
        // request.
        //
        WStatus = UMReflectorImpersonate(UserWorkItem, DavWorkItem->ImpersonationHandle);
        if (WStatus != ERROR_SUCCESS) {
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncCreateSrvCall/UMReflectorImpersonate. Error Val = "
                      "%d\n", WStatus));
            goto EXIT_THE_FUNCTION;
        }
        didImpersonate = TRUE;

        //
        // Before proceeding further, check to see if the Async operation failed.
        // If it did, then cleanup and move on.
        //
        if ( !DavWorkItem->AsyncResult->dwResult ) {
            
            WStatus = DavWorkItem->AsyncResult->dwError;
            
            //
            // If the error we got back is ERROR_INTERNET_FORCE_RETRY, then
            // WinInet is trying to authenticate itself with the server. In 
            // such a scenario this is what happens.
            //
            //          Client ----Request----->   Server
            //          Server ----AccessDenied-----> Client
            //          Client----Challenge Me-------> Server
            //          Server-----Challenge--------> Client
            //          Client-----Challenge Resp----> Server
            //
            if (WStatus == ERROR_INTERNET_FORCE_RETRY) {

                ASSERT(DavWorkItem->DavOperation == DAV_CALLBACK_HTTP_END);

                //
                // We need to repeat the HttpSend and HttpEnd request calls.
                //
                DavWorkItem->DavOperation = DAV_CALLBACK_HTTP_OPEN;

                WStatus = DavAsyncCommonStates(DavWorkItem, FALSE);
                if (WStatus != ERROR_SUCCESS && WStatus != ERROR_IO_PENDING) {
                    DavPrint((DEBUG_ERRORS,
                              "DavAsyncCreateSrvCall/DavAsyncCommonStates. "
                              "Error Val = %08lx\n", WStatus));
                }

            } else {
            
                DavPrint((DEBUG_ERRORS,
                          "DavAsyncCreateSrvCall. AsyncFunction failed. Error Val"
                          " = %d\n", WStatus));
            }

            goto EXIT_THE_FUNCTION;
        
        }
    
    }

#else 

    ASSERT(CalledByCallBackThread == FALSE);

#endif

    switch (DavWorkItem->DavOperation) {

    case DAV_CALLBACK_HTTP_END: {

        ULONG TahoeCustomHeaderLength = 0, OfficeCustomHeaderLength = 0;
        WCHAR DavCustomBuffer[100];
        
        DavPrint((DEBUG_MISC,
                  "DavAsyncCreateSrvCall: Entering DAV_CALLBACK_HTTP_END.\n"));

        DavOpenHandle = DavWorkItem->AsyncCreateSrvCall.DavOpenHandle;

        //
        // First figure out if the OPTIONS response which was sent succeeded in 
        // the first place. If this failed then we bail right now.
        //
        WStatus = DavQueryAndParseResponse(DavOpenHandle);
        if (WStatus != ERROR_SUCCESS) {
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncCreateSrvCall/DavQueryAndParseResponse. "
                      "WStatus = %d\n", WStatus));
            goto EXIT_THE_FUNCTION;
        }
        
        //
        // We read the value of AcceptOfficeAndTahoeServers from the registry when
        // the WebClient service starts up. If this is set to 0, it means that we
        // should be rejecting OfficeWebServers, Tahoe servers and the shares on
        // these servers even though they speak DAV. We do this since WebFolders
        // needs to claim this name and Shell will only call into WebFolders if the
        // DAV Redir fails. If this value is non-zero, we accept all servers that
        // speak DAV.
        // 
        //
        if (AcceptOfficeAndTahoeServers == 0) {
    
            //
            // Figure out if this is an OFFICE Web Server. If it is then the response 
            // will have an entry "MicrosoftOfficeWebServer: ", in the header. 
            // If this is an OFFICE server then we should not claim it since the 
            // user actually intends to use the OFFICE specific features in Shell.
            //
    
            RtlZeroMemory(DavCustomBuffer, sizeof(DavCustomBuffer));
            wcscpy(DavCustomBuffer, DavOfficeCustomHeader);
            OfficeCustomHeaderLength = ( sizeof(DavCustomBuffer) / sizeof(WCHAR) );
    
            ReturnVal = HttpQueryInfoW(DavOpenHandle,
                                       HTTP_QUERY_CUSTOM,
                                       (PVOID)DavCustomBuffer,
                                       &(OfficeCustomHeaderLength), 
                                       NULL);
            if ( !ReturnVal ) {
                WStatus = GetLastError();
                if (WStatus != ERROR_HTTP_HEADER_NOT_FOUND) {
                    DavPrint((DEBUG_ERRORS, 
                              "DavAsyncCreateSrvCall/HttpQueryInfoW(1): Error Val = %d\n",
                              WStatus));
                    goto EXIT_THE_FUNCTION;
                } else {
                    WStatus = ERROR_SUCCESS;
                    DavPrint((DEBUG_MISC, "DavAsyncCreateSrvCall: NOT OFFICE Web Server\n"));
                    DavWorkItem->AsyncCreateSrvCall.ServerHashEntry->isOfficeServer = FALSE;
                }
            } else {
                DavPrint((DEBUG_MISC, "DavAsyncCreateSrvCall: OFFICE Web Server\n"));
                DavWorkItem->AsyncCreateSrvCall.ServerHashEntry->isOfficeServer = TRUE;
            }
    
            //
            // Figure out if this is a TAHOE server. If it is then the response will 
            // have an entry "MicrosoftTahoeServer: ", in the header. If this is a 
            // TAHOE server then we should not claim it since the user actually 
            // intends to use the TAHOE specific features in Rosebud.
            //
    
            RtlZeroMemory(DavCustomBuffer, sizeof(DavCustomBuffer));
            wcscpy(DavCustomBuffer, DavTahoeCustomHeader);
            TahoeCustomHeaderLength = ( sizeof(DavCustomBuffer) / sizeof(WCHAR) );
    
            ReturnVal = HttpQueryInfoW(DavOpenHandle,
                                       HTTP_QUERY_CUSTOM,
                                       (PVOID)DavCustomBuffer,
                                       &(TahoeCustomHeaderLength),
                                       NULL);
            if ( !ReturnVal ) {
                WStatus = GetLastError();
                if (WStatus != ERROR_HTTP_HEADER_NOT_FOUND) {
                    DavPrint((DEBUG_ERRORS, 
                              "DavAsyncCreateSrvCall/HttpQueryInfoW(2): Error Val = %d\n",
                              WStatus));
                    goto EXIT_THE_FUNCTION;
                } else {
                    WStatus = ERROR_SUCCESS;
                    DavPrint((DEBUG_MISC, "DavAsyncCreateSrvCall: NOT TAHOE Server\n"));
                    DavWorkItem->AsyncCreateSrvCall.ServerHashEntry->isTahoeServer = FALSE;
                }
            } else {
                DavPrint((DEBUG_MISC, "DavAsyncCreateSrvCall: TAHOE Server\n"));
                DavWorkItem->AsyncCreateSrvCall.ServerHashEntry->isTahoeServer = TRUE;
            }
            
            //
            // If its either an Office Web Server or a TAHOE server, then we reject
            // this server and fail. As far as the DAV Redir is concerned, this is
            // NOT a valid DAV server (even though TAHOE and Office Severs are built
            // on IIS and are DAV servers by default).
            //
            if ( DavWorkItem->AsyncCreateSrvCall.ServerHashEntry->isOfficeServer ||
                 DavWorkItem->AsyncCreateSrvCall.ServerHashEntry->isTahoeServer ) {
                DavWorkItem->AsyncCreateSrvCall.ServerHashEntry->isDavServer = FALSE;
                WStatus = ERROR_BAD_NETPATH;
                goto EXIT_THE_FUNCTION;
            }
    
        }

        //
        // This is NOT a TAHOE server nor an OFFICE Web Server. We go ahead and
        // query some other stuff from the header to make sure that this is a
        // DAV server.
        //

        //
        // Query the header for the servers response. This query is done to get
        // the size of the header to be copied.
        //
        ReturnVal = HttpQueryInfoW(DavOpenHandle,
                                   HTTP_QUERY_RAW_HEADERS_CRLF,
                                   DataBuff,
                                   &(DataBuffBytes),
                                   NULL);
        if (!ReturnVal) {
            WStatus = GetLastError();
            if (WStatus != ERROR_INSUFFICIENT_BUFFER) {
                DavPrint((DEBUG_ERRORS,
                          "DavAsyncCreateSrvCall/HttpQueryInfoW(3). Error Val = "
                          "%d\n", WStatus));
                goto EXIT_THE_FUNCTION;
            } else {
                DavPrint((DEBUG_MISC,
                          "DavAsyncCreateSrvCall: HttpQueryInfo: Need Buff.\n"));
            }
        }

        //
        // Allocate memory for copying the header.
        //
        DataBuff = LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, DataBuffBytes);
        if (DataBuff == NULL) {
            WStatus = GetLastError();
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncCreateSrvCall/LocalAlloc. Error Val = %d.\n",
                      WStatus));
            goto EXIT_THE_FUNCTION;
        }

        ReturnVal = HttpQueryInfoW(DavOpenHandle,
                                   HTTP_QUERY_RAW_HEADERS_CRLF,
                                   DataBuff,
                                   &(DataBuffBytes),
                                   NULL);
        if (!ReturnVal) {
            WStatus = GetLastError();
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncCreateSrvCall/HttpQueryInfoW(4). Error Val = "
                      "%d\n", WStatus));
            goto EXIT_THE_FUNCTION;
        }

        //
        // Check to see whether this server is a DAV server, Http Server etc.
        //
        DavObtainServerProperties(DataBuff, 
                                  &(DavWorkItem->AsyncCreateSrvCall.ServerHashEntry->isHttpServer),
                                  &(DavWorkItem->AsyncCreateSrvCall.ServerHashEntry->isMSIIS),
                                  &(DavWorkItem->AsyncCreateSrvCall.ServerHashEntry->isDavServer));

        WStatus = ERROR_SUCCESS;

    }
        break;

    default: {
        WStatus = ERROR_INVALID_PARAMETER;
        DavPrint((DEBUG_ERRORS,
                  "DavAsyncCreateSrvCall: Invalid DavWorkItem->DavOperation = %d.\n",
                  DavWorkItem->DavOperation));
    }
        break;
    
    }

EXIT_THE_FUNCTION:

    //
    // If we did impersonate, we need to revert back.
    //
    if (didImpersonate) {
        ULONG RStatus;
        RStatus = UMReflectorRevert(UserWorkItem);
        if (RStatus != ERROR_SUCCESS) {
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncCreate/UMReflectorRevert. Error Val = %d\n",
                      RStatus));
        }
    }

    //
    // Free the DataBuff if we allocated one.
    //
    if (DataBuff != NULL) {
        HLOCAL FreeHandle;
        ULONG FreeStatus;
        FreeHandle = LocalFree((HLOCAL)DataBuff);
        if (FreeHandle != NULL) {
            FreeStatus = GetLastError();
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncCreateSrvCall/LocalFree. Error Val = %d\n",
                      FreeStatus));
        }
    }

#ifdef DAV_USE_WININET_ASYNCHRONOUSLY

    //
    // We need to do the following only if we are running in the context of the
    // worker thread that picked up the DavWorkItem from the Callback function.
    //
    if ( WStatus != ERROR_IO_PENDING && CalledByCallBackThread ) {

        //
        // Set the return status of the operation. This is used by the kernel
        // mode routines to figure out the completion status of the user mode
        // request.
        //
        if (WStatus != ERROR_SUCCESS) {
            DavWorkItem->Status = DavMapErrorToNtStatus(WStatus);
        } else {
            DavWorkItem->Status = STATUS_SUCCESS;
        }

        //
        // Call the AsyncCreateCompletion routine.
        //
        DavAsyncCreateSrvCallCompletion(DavWorkItem);

        //
        // This thread now needs to send the response back to the kernel. It
        // does not wait in the kernel (to get another request) after submitting
        // the response.
        //
        UMReflectorCompleteRequest(DavReflectorHandle, UserWorkItem);

    }

#endif

    return WStatus;
}


VOID
DavParseOPTIONSLine(
    PWCHAR ParseData, 
    PDAV_USERMODE_WORKITEM DavWorkItem
    )
/*++

Routine Description:

    This routine is used to parse the response (buffer) to the OPTIONS request 
    sent to server. This info helps to figure out if the HTTP server supports
    DAV extensions and whether it is an IIS (Microsoft's) server. The response
    buffer is split into lines and each line is sent to this routine.

Arguments:

    ParseData - The line to be parsed.
    
    DavWorkItem - The DAV_USERMODE_WORKITEM value.

Return Value:

    none.

--*/
{
    PWCHAR p;

    //
    // IMPORTANT!!! We do not need to take a lock here since this is the
    // only thread which will be accessing this server structure. This is
    // because RDBSS holds up all the threads for this server till this
    // completes.
    //

    // DavPrint((DEBUG_MISC, "DavParseOPTIONSLine: ParseLine = %ws\n", ParseData));

    if ( ( p = wcsstr(ParseData, L"HTTP/1.1") ) != NULL ) {
        //
        // This is a HTTP server.
        //
        DavWorkItem->AsyncCreateSrvCall.ServerHashEntry->isHttpServer = TRUE;
    } else if ( ( p = wcsstr(ParseData, L"Microsoft-IIS") ) != NULL ) {
        //
        // This is a Microsoft server.
        //
        DavWorkItem->AsyncCreateSrvCall.ServerHashEntry->isMSIIS = TRUE;
    } else if ( ( p = wcsstr(ParseData, L"DAV") ) != NULL ) {
        //
        // This HTTP server supports DAV extensions.
        //
        DavWorkItem->AsyncCreateSrvCall.ServerHashEntry->isDavServer = TRUE;
    }

    return;
}


VOID
DavAsyncCreateSrvCallCompletion(
    PDAV_USERMODE_WORKITEM DavWorkItem
    )
/*++

Routine Description:

   This routine handles the CreateSrvCall completion. It basically frees up the
   resources allocated during the CreateSrvCall operation.

Arguments:

    DavWorkItem - The DAV_USERMODE_WORKITEM value.

Return Value:

    none.

--*/
{
    PDAV_USERMODE_CREATE_SRVCALL_REQUEST CreateSrvCallRequest = NULL;
    PDAV_USERMODE_CREATE_SRVCALL_RESPONSE CreateSrvCallResponse = NULL;
    PHASH_SERVER_ENTRY ServerHashEntry = NULL;
    HINTERNET DavConnHandle = NULL;

    CreateSrvCallRequest = &(DavWorkItem->CreateSrvCallRequest);
    CreateSrvCallResponse = &(DavWorkItem->CreateSrvCallResponse);
    ServerHashEntry = DavWorkItem->AsyncCreateSrvCall.ServerHashEntry;

    if (DavWorkItem->AsyncCreateSrvCall.DavOpenHandle != NULL) {
        BOOL ReturnVal;
        ULONG FreeStatus;
        HINTERNET DavOpenHandle = DavWorkItem->AsyncCreateSrvCall.DavOpenHandle;
        ReturnVal = InternetCloseHandle( DavOpenHandle );
        if (!ReturnVal) {
            FreeStatus = GetLastError();
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncCreateSrvCallCompletion/InternetCloseHandle"
                      "(0). Error Val = %d\n", FreeStatus));
        }
    }

    if (DavWorkItem->AsyncCreateSrvCall.DavConnHandle != NULL) {
        BOOL ReturnVal;
        ULONG FreeStatus;
        HINTERNET DavConnHandle = DavWorkItem->AsyncCreateSrvCall.DavConnHandle;
        ReturnVal = InternetCloseHandle( DavConnHandle );
        if (!ReturnVal) {
            FreeStatus = GetLastError();
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncCreateSrvCallCompletion/InternetCloseHandle"
                      "(1). Error Val = %d\n", FreeStatus));
        }
    }

    if (DavWorkItem->AsyncResult != NULL) {
        HLOCAL FreeHandle;
        ULONG FreeStatus;
        FreeHandle = LocalFree((HLOCAL)DavWorkItem->AsyncResult);
        if (FreeHandle != NULL) {
            FreeStatus = GetLastError();
            DavPrint((DEBUG_ERRORS,
                      "DavAsyncCreateSrvCallCompletion/LocalFree. Error Val = %d\n",
                      FreeStatus));
        }
    }

    //
    // If we were the thread that worked on the creation and initialization
    // of this SrvCall then we need to do somethings before we proceed further.
    // Its very important that we do this before we do the next step.
    //
    if (CreateSrvCallRequest->didICreateThisSrvCall) {

        BOOL setEvt = FALSE;

        ASSERT(CreateSrvCallRequest->didIWaitAndTakeReference == FALSE);

        if (ServerHashEntry != NULL) {

            EnterCriticalSection( &(HashServerEntryTableLock) );

            //
            // Depending on whether we succeeded or not, we mark the ServerHashEntry
            // as initialized or failed. Also, DavWorkItem->Status has an NTSTATUS
            // value at this stage so we use RtlNtStatusToDosError to convert it
            // back to the Win32 error.
            //
            if (DavWorkItem->Status != STATUS_SUCCESS) {
                ServerHashEntry->ErrorStatus = RtlNtStatusToDosError(DavWorkItem->Status);
                ServerHashEntry->ServerEntryState = ServerEntryInitializationError;
            } else {
                ServerHashEntry->ErrorStatus = ERROR_SUCCESS;
                ServerHashEntry->ServerEntryState = ServerEntryInitialized;
            }

            //
            // Signal the event of the server entry to wake up the threads which 
            // might be waiting for this to happen.
            //
            setEvt = SetEvent(ServerHashEntry->ServerEventHandle);
            if (!setEvt) {
                DavPrint((DEBUG_ERRORS,
                          "DavAsyncCreateSrvCallCompletion/SetEvent. Error Val = %d\n", 
                          GetLastError()));
            }

            LeaveCriticalSection( &(HashServerEntryTableLock) );

        }

    }

    //
    // Some resources should not be freed if we succeeded. Also, if we failed
    // we do different things depending upon whether or not we were the thread
    // that worked in creating and initializing this ServerHashEntry.
    //
    if (DavWorkItem->Status != STATUS_SUCCESS) {

        //
        // Set the ServerID to zero, so that the finalize never comes
        // to the user mode.
        //
        CreateSrvCallResponse->ServerID = 0;

        if (CreateSrvCallRequest->didICreateThisSrvCall) {

            ASSERT(CreateSrvCallRequest->didIWaitAndTakeReference == FALSE);

            if (ServerHashEntry != NULL) {

                EnterCriticalSection( &(HashServerEntryTableLock) );

                //
                // This is not a DAV server.
                //
                ServerHashEntry->isHttpServer = FALSE;
                ServerHashEntry->isDavServer = FALSE;
                ServerHashEntry->isMSIIS = FALSE;

                //
                // Since we are moving to the "to be finalized list", we need to
                // set the TimeValueInSec to the current time.
                //
                ServerHashEntry->TimeValueInSec = time(NULL);

                //
                // Remove the reference that we would have taken when we created
                // this ServerHashEntry.
                //
                ServerHashEntry->ServerEntryRefCount -= 1;

                //
                // Remove the ServerHashEntry from the HashTable. When we created
                // it, we added it to the HashTable. If the ErrorStatus is not
                // STATUS_ACCESS_DENIED or STATUS_LOGON_FAILURE, then we move the
                // ServerHashEntry to the "to be finalized" list. This is done to
                // enable -ve caching. If its STATUS_ACCESS_DENIED or LOGON_FAILURE,
                // then we failed since the credentials were not correct. That
                // doesn't mean that this server is not a DAV server and hence we
                // don't put it in the "to be finalized" list.
                //
                
                RemoveEntryList( &(ServerHashEntry->ServerListEntry) );
    
                if (DavWorkItem->Status == STATUS_ACCESS_DENIED || DavWorkItem->Status == STATUS_LOGON_FAILURE) {

                    //
                    // Set "ServerHashEntry->credentialFailure" to TRUE to
                    // indicate that the creation of this SrvCall failed
                    // because the credentials were not correct. Some servers
                    // can fail an OPTIONS request if the user does not have
                    // the right credentials.
                    //
                    ServerHashEntry->credentialFailure = TRUE;

                    //
                    // We only free the ServerHashEntry if the reference count
                    // is 0. If its not, it means that some other thread is
                    // trying to create a SrvCall for the same server and is
                    // waiting for this thread to finish.
                    //
                    if (ServerHashEntry->ServerEntryRefCount == 0) {
                        //
                        // If the ServerEventHandle is not NULL then we close it
                        // before freeing the ServerHashEntry structure.
                        //
                        if (ServerHashEntry->ServerEventHandle != NULL) {
                            CloseHandle(ServerHashEntry->ServerEventHandle);
                        }
                        LocalFree(ServerHashEntry);
                        ServerHashEntry = NULL;
                    }

                } else {

                    InsertHeadList( &(ToBeFinalizedServerEntries), &(ServerHashEntry->ServerListEntry) );

                }

                LeaveCriticalSection( &(HashServerEntryTableLock) );

            }

        } else {

            //
            // If we were the thread that waited for some other thread to
            // create and initialize the ServerHashEntry then we need to take
            // our reference out now.
            //
            if (CreateSrvCallRequest->didIWaitAndTakeReference) {

                ASSERT(CreateSrvCallRequest->didICreateThisSrvCall == FALSE);

                EnterCriticalSection( &(HashServerEntryTableLock) );

                ServerHashEntry->ServerEntryRefCount -= 1;

                //
                // If "ServerHashEntry->credentialFailure" is TRUE, it means
                // that this SrvCall create failed because the credentials
                // were not correct. In such a situation we wouldn't have added
                // this entry to the "to be finalized" list. If we were the last
                // reference on this ServerHashEntry, we need to free it now.
                //
                if (ServerHashEntry->credentialFailure) {
                    if (ServerHashEntry->ServerEntryRefCount == 0) {
                        //
                        // If the ServerEventHandle is not NULL then we close it
                        // before freeing the ServerHashEntry structure.
                        //
                        if (ServerHashEntry->ServerEventHandle != NULL) {
                            CloseHandle(ServerHashEntry->ServerEventHandle);
                        }
                        LocalFree(ServerHashEntry);
                        ServerHashEntry = NULL;
                    }
                }

                LeaveCriticalSection( &(HashServerEntryTableLock) );

            }

        }

    }

    DavFsFinalizeTheDavCallBackContext(DavWorkItem);

    return;
}


ULONG
DavFsFinalizeSrvCall(
    PDAV_USERMODE_WORKITEM DavWorkItem
    )
/*++

Routine Description:

    This routine finalizes a Server entry in the hash table. If the Ref count on
    the entry is 1, this basically amounts setting the timer in the entry to the 
    current time. The scavenger thread which periodically goes through all the 
    entries looks at the time elapsed after the server entry was finalized and 
    if this value exceeds a specified limit, it deletes the entry from the 
    table.

Arguments:

    DavWorkItem - The buffer that contains the server name.

Return Value:

    The return status for the operation

--*/
{
    ULONG WStatus = ERROR_SUCCESS;
    PDAV_USERMODE_FINALIZE_SRVCALL_REQUEST DavFinSrvCallReq;
    PWCHAR ServerName;
    BOOL isPresent = FALSE;
    PHASH_SERVER_ENTRY ServerHashEntry = NULL;

    DavFinSrvCallReq = &(DavWorkItem->FinalizeSrvCallRequest);

    //
    // If we are finalizing a server, it better not be NULL.
    //
    ASSERT(DavFinSrvCallReq->ServerName);
    ServerName = DavFinSrvCallReq->ServerName;

    DavPrint((DEBUG_MISC,
              "DavFsFinalizeSrvCall: ServerName = %ws.\n", ServerName));

    EnterCriticalSection( &(HashServerEntryTableLock) );

    isPresent = DavIsThisServerInTheTable(ServerName, &ServerHashEntry);
    if (!isPresent) {
        WStatus = ERROR_INVALID_PARAMETER; // STATUS_INVALID_PARAMETER
        DavPrint((DEBUG_ERRORS,
                  "DavFsFinalizeSrvCall/DavIsThisServerInTheTable.\n"));
        LeaveCriticalSection( &(HashServerEntryTableLock) );
        goto EXIT_THE_FUNCTION;
    }

    //
    // Found the entry. Set the timer.
    //
    ASSERT(ServerHashEntry != NULL);
    ASSERT(ServerHashEntry->ServerID == DavFinSrvCallReq->ServerID);

    //
    // Decrement the reference count on the ServerHashEntry by 1.
    //
    ServerHashEntry->ServerEntryRefCount -= 1;

    //
    // If the value of ServerHashEntry->ServerEntryRefCount is zero, we finalize
    // the entry.
    //
    if (ServerHashEntry->ServerEntryRefCount == 0) {

        ServerHashEntry->TimeValueInSec = time(NULL);

        //
        // Now move this server entry from the hash table to the "to be finalized"
        // list.
        //
        RemoveEntryList( &(ServerHashEntry->ServerListEntry) );
        InsertHeadList( &(ToBeFinalizedServerEntries),
                                         &(ServerHashEntry->ServerListEntry) );
    
    }

    LeaveCriticalSection( &(HashServerEntryTableLock) );

EXIT_THE_FUNCTION:

    //
    // Set the return status of the operation. This is used by the kernel
    // mode routines to figure out the completion status of the user mode
    // request. This is done here because the async completion routine that is
    // called immediately afterwards needs the status set.
    //
    if (WStatus != ERROR_SUCCESS) {
        DavWorkItem->Status = DavMapErrorToNtStatus(WStatus);
    } else {
        DavWorkItem->Status = STATUS_SUCCESS;
    }
    
    return WStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\ifskit.mrx\nulmrx\dll\dllmain.c ===
/*++

Copyright (c) 1989-1999  Microsoft Corporation

Module Name:

    dllmain.c

Abstract:

    This module implements the initialization routines for network
    provider interface

Notes:

    This module has been built and tested only in UNICODE environment

--*/

#include <windows.h>
#include <process.h>


// NOTE:
//
// Function:	DllMain
//
// Return:	TRUE  => Success
//		FALSE => Failure

BOOL WINAPI DllMain(HINSTANCE hDLLInst, DWORD fdwReason, LPVOID lpvReserved)
{
    BOOL	bStatus = TRUE;
    WORD	wVersionRequested;

    switch (fdwReason) {
    case DLL_PROCESS_ATTACH:
        break;

    case DLL_PROCESS_DETACH:
        break;

    case DLL_THREAD_ATTACH:
        break;

    case DLL_THREAD_DETACH:
        break;

    default:
        break;
    }

    return(bStatus);
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\ifskit.mrx\nulmrx\dll\nulmrxnp.h ===
/*++

Copyright (c) 1989-1999  Microsoft Corporation

Module Name:

    nulmrxnp.h

Abstract:

    This module includes all network provider router interface related
    definitions for the sample

Notes:

    This module has been built and tested only in UNICODE environment

--*/

#ifndef _NULMRXNP_H_
#define _NULMRXNP_H_

#define NULMRXNP_DEBUG_CALL     0x1
#define NULMRXNP_DEBUG_ERROR    0x2
#define NULMRXNP_DEBUG_INFO     0x4

extern DWORD NulMRxNpDebugLevel;

#define TRACE_CALL(Args)    \
            if (NulMRxNpDebugLevel & NULMRXNP_DEBUG_CALL) {    \
                DbgPrint##Args;                 \
            }

#define TRACE_ERROR(Args)    \
            if (NulMRxNpDebugLevel & NULMRXNP_DEBUG_ERROR) {    \
                DbgPrint##Args;                 \
            }

#define TRACE_INFO(Args)    \
            if (NulMRxNpDebugLevel & NULMRXNP_DEBUG_INFO) {    \
                DbgPrint##Args;                 \
            }

typedef struct _NULMRXNP_ENUMERATION_HANDLE_ {
    INT  LastIndex;
} NULMRXNP_ENUMERATION_HANDLE,
  *PNULMRXNP_ENUMERATION_HANDLE;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\server\worker.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    worker.c

Abstract:

    Workter threads used by the web dav mini-redir client service.

Author:

    Andy Herron (andyhe) 15-Apr-1999

    Rohan Kumar [RohanK] 05-May-1999

Environment:

    User Mode - Win32

Revision History:

--*/
#include "pch.h"
#pragma hdrstop

#include <ntumrefl.h>
#include <usrmddav.h>
#include "global.h"
#include "nodefac.h"

#define DAV_WORKITEM_ALLOC_FAIL_COUNT   10
#define DAV_WORKITEM_ALLOC_FAIL_WAIT    250
#define DAV_WORKITEM_FAIL_REQUEST       10
#define DAV_WORKITEM_FAIL_REQUEST_WAIT  100

LONG DavOutstandingWorkerRequests;

typedef struct _UMFS_WORKER_THREAD {
    struct _UMFS_THREAD_CONSTELLATION *Constellation;
    HANDLE ThisThreadHandle;
    ULONG  ThisThreadId;
    PDAV_USERMODE_WORKITEM pCurrentWorkItem;
    union {
        PVOID  Context1;
        ULONG  Context1u;
    };
    union {
        PVOID  Context2;
        ULONG  Context2u;
    };
} UMFS_WORKER_THREAD, *PUMFS_WORKER_THREAD;

typedef struct _UMFS_THREAD_CONSTELLATION {
    HANDLE DeviceObjectHandle;
    ULONG  MaximumNumberOfWorkers;
    ULONG  InitialNumberOfWorkers;
    BOOLEAN Terminating;
    UMFS_WORKER_THREAD WorkerThreads[1];
} UMFS_THREAD_CONSTELLATION, *PUMFS_THREAD_CONSTELLATION;

PUMFS_THREAD_CONSTELLATION DavThreadConstellation = NULL;

//
// Mentioned below are the prototypes of functions that are used only within
// this module (file). These functions should not be exposed outside.
//

DWORD
WINAPI
DavRestartContext(
    LPVOID Context
    );

DWORD
DavPostWorkItem(
    LPTHREAD_START_ROUTINE Function,
    PDAV_USERMODE_WORKITEM DavContext
    );

DWORD
DavWorkerThread (
    PUMFS_WORKER_THREAD Worker
    );

//
// Implementation of functions begins here.
//

DWORD
DavInitWorkerThreads(
    IN ULONG InitialThreadCount,
    IN ULONG MaxThreadCount
    )
/*++

Routine Description:

    This routines creates the threads to be sent down to the kernel.

Arguments:

    InitialThreadCount - Initial number of threads sent down to get requests.

    MaxThreadCount - Max number of threads to be sent down to get requests.

Return Value:

    The return status for the operation

--*/
{
    DWORD WStatus;
    ULONG ConstellationSize;
    ULONG i;

    DavOutstandingWorkerRequests = 0;

    //
    // We need to allocate MaxThread number of UMFS_WORKER_THREAD strucutres +
    // the UMFS_THREAD_CONSTELLATION. Since the UMFS_THREAD_CONSTELLATION
    // structure already contains one UMFS_WORKER_THREAD field, we allocate
    // memory for (MaxThreadCount - 1) UMFS_WORKER_THREAD strucutres +
    // UMFS_THREAD_CONSTELLATION.
    //
    ConstellationSize = sizeof(UMFS_THREAD_CONSTELLATION);
    ConstellationSize += ( (MaxThreadCount - 1) * sizeof(UMFS_WORKER_THREAD) );

    //
    // We need to make the ConstellationSize a multiple of 8. This is because
    // DavAllocateMemory calls DebugAlloc which does some stuff which requires
    // this. The equation below does this.
    //
    ConstellationSize = ( ( ( ConstellationSize + 7 ) / 8 ) * 8 );

    DavThreadConstellation = (PUMFS_THREAD_CONSTELLATION)
                                          DavAllocateMemory(ConstellationSize);

    if (DavThreadConstellation == NULL) {
        WStatus = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavInitWorkerThreads/DavAllocateMemory. Error Val = %d.\n",
                  WStatus));
        return WStatus;
    }

    DavThreadConstellation->Terminating = FALSE;
    DavThreadConstellation->InitialNumberOfWorkers = InitialThreadCount;
    DavThreadConstellation->MaximumNumberOfWorkers = MaxThreadCount;
    DavThreadConstellation->DeviceObjectHandle = DavRedirDeviceHandle;

    DavPrint((DEBUG_MISC,
              "DavInitWorkerThreads: Dav Thread Constellation allocated at "
              "0x%x\n", DavThreadConstellation));

    //
    // Just spin up initial threads and ignore the max.
    //
    for (i = 0; i < InitialThreadCount; i++) {
        PUMFS_WORKER_THREAD Worker = &(DavThreadConstellation->WorkerThreads[i]);
        Worker->Constellation = DavThreadConstellation;
        Worker->ThisThreadHandle = CreateThread(
                                        NULL,
                                        0,
                                        (LPTHREAD_START_ROUTINE)DavWorkerThread,
                                        (LPVOID)Worker,
                                        0,
                                        &Worker->ThisThreadId);
        if (Worker->ThisThreadHandle == NULL) {
            WStatus = GetLastError();
            DavPrint((DEBUG_ERRORS,
                      "DavInitWorkerThreads/CreateThread: Return Val is NULL. "
                      "Error Val = %08lx.\n", WStatus));
        } else {
            DavPrint((DEBUG_MISC, "DavInitWorkerThreads: Dav Thread %u has "
                      "ThreadId 0x%x and Handle 0x%x\n",
                      i, Worker->ThisThreadId, Worker->ThisThreadHandle));
        }
    }

    return STATUS_SUCCESS;
}


DWORD
DavTerminateWorkerThreads(
    VOID
    )
/*++

Routine Description:

    This routines terminates the threads sent down to the kernel.

Arguments:

    none.

Return Value:

    The return status for the operation

--*/
{
    DWORD WStatus = ERROR_SUCCESS;
    ULONG i = 0;
    OVERLAPPED OverLapped;

    if (DavThreadConstellation != NULL) {
        DavThreadConstellation->Terminating = TRUE;
        //
        // First we complete all pending IRPs waiting down in kernel so that we
        // can kill these threads.
        //
        WStatus = UMReflectorReleaseThreads(DavReflectorHandle);
        if (WStatus != ERROR_SUCCESS) {
            DavPrint((DEBUG_ERRORS,
                      "DavTerminateWorkerThreads/UMReflectorReleaseThreads: "
                      "Error value returned = %u.\n", WStatus));
        }
    }

    //
    // We ensure all worker threads have completed before we close the ioctl
    // threads.
    //
    while (DavOutstandingWorkerRequests) {
        //
        // Wait for a 250 milliseconds to check again for all threads to have
        // completed.
        //
        Sleep(250);
    }

    if (DavThreadConstellation != NULL) {
        for ( i = 0; i < DavThreadConstellation->MaximumNumberOfWorkers; i++) {
            HANDLE ThreadHandle =
                     DavThreadConstellation->WorkerThreads[i].ThisThreadHandle;
            if (ThreadHandle != NULL) {
                DavPrint((DEBUG_MISC,
                          "DavTerminateWorkerThread: Waiting for ThreadId 0x%x"
                          ", ThreadHandle 0x%x.\n",
                          DavThreadConstellation->WorkerThreads[i].ThisThreadId,
                          ThreadHandle));
                WaitForSingleObject(ThreadHandle, INFINITE);
                NtClose(ThreadHandle);
            }
        }

        //
        // Now that we're done with the constellation, we free it.
        //
        DavFreeMemory(DavThreadConstellation);
        DavThreadConstellation = NULL;
    }

    return STATUS_SUCCESS;
}


DWORD
WINAPI
DavRestartContext(
    LPVOID Context
    )
/*++

Routine Description:

    This function gets called when a worker thread initiates work on one
    of our contexts.  We'll call off to the restart routine and then
    decrement the count of active work contexts. The argument passed to the
    restart routine is the context itself.

Arguments:

    Context - The context which contains the function to be called.

Return Value:

    ERROR_SUCCESS or the appropriate error value.

--*/
{
    DWORD err;
    PUMRX_USERMODE_WORKITEM_HEADER UserWorkItem = NULL;
    PDAV_USERMODE_WORKITEM davContext = NULL;
    LPTHREAD_START_ROUTINE routine = NULL;

    davContext = (PDAV_USERMODE_WORKITEM) Context;
    routine = (LPTHREAD_START_ROUTINE) davContext->RestartRoutine;
    UserWorkItem = (PUMRX_USERMODE_WORKITEM_HEADER)davContext;

    //
    // We store the ThreadId in the DAV_USERMODE_WORKITEM structure for 
    // debugging purposes.
    //
    davContext->ThisThreadId = GetCurrentThreadId();

    DavPrint((DEBUG_MISC,
              "DavRestartContext: DavWorkItem = %08lx, ThisThreadId = %x\n",
              davContext, davContext->ThisThreadId));

    //
    // Invoke the function.
    //
    err = routine( (LPVOID)davContext );
    if (err != ERROR_SUCCESS && err != ERROR_IO_PENDING) {
        DavPrint((DEBUG_MISC,
                  "DavRestartContext: Routine at address %08lx returned error of"
                  " %08lx for context %08lx.\n", routine, err, davContext));
    }

    //
    // If we are using WinInet synchronously, then we need to finally complete
    // the request.
    //
#ifndef DAV_USE_WININET_ASYNCHRONOUSLY

    //
    // This thread now needs to send the response back to the kernel. It
    // does not wait in the kernel (to get another request) after submitting
    // the response.
    //
    UMReflectorCompleteRequest(DavReflectorHandle, UserWorkItem);

#endif

    //
    // Decrement the number of requests posted.
    //
    InterlockedDecrement( &(DavOutstandingWorkerRequests) );

    return err;
}


VOID
DavCleanupWorkItem(
    PUMRX_USERMODE_WORKITEM_HEADER UserWorkItem
    )
/*++

Routine Description:

    This function gets called when a kernelmode requests gets cancelled and we
    need to do some cleanup to free up the resources allocated for the response
    of this request. For example, in QueryDirectory, we allocate a list of
    DavFileAttributes for every file in the directory. Since the request has
    been cancelled in the kernel, we don't need this list anymore.

Arguments:

    UserWorkItem - The WorkItem that needs to be cleaned.

Return Value:

    None.

--*/
{
    PDAV_USERMODE_WORKITEM davContext = NULL;
    PDAV_USERMODE_QUERYDIR_RESPONSE QueryDirResponse = NULL;
    PDAV_USERMODE_CREATE_RESPONSE CreateResponse = NULL;

    davContext = (PDAV_USERMODE_WORKITEM)UserWorkItem;

    switch (davContext->WorkItemType) {

    case UserModeQueryDirectory: {
        QueryDirResponse = &(davContext->QueryDirResponse);
        DavFinalizeFileAttributesList(QueryDirResponse->DavFileAttributes, TRUE);
        QueryDirResponse->DavFileAttributes = NULL;
    }
    break;

    case UserModeCreate: {
        CreateResponse = &(davContext->CreateResponse);
        NtClose(CreateResponse->Handle);
        CreateResponse->Handle = NULL;
    }
    break;

    }

    return;
}


DWORD
DavPostWorkItem(
    LPTHREAD_START_ROUTINE Function,
    PDAV_USERMODE_WORKITEM DavContext
    )
/*++

Routine Description:

    This function should be called to post a dav work context to a worker
    thread. We track the number of outstanding requests we have.

Arguments:

    Function - The Functon to be called by the worker thread.

    DavContext - The context to be passed to the function.

Return Value:

    ERROR_SUCCESS or the appropriate error value.

--*/
{
    DWORD err = ERROR_SUCCESS;
    BOOL qResult;

    DavContext->RestartRoutine = (LPVOID)Function;

    //
    // Increment the number of requests posted.
    //
    InterlockedIncrement( &(DavOutstandingWorkerRequests) );

    //
    // Queue the workitem context.
    //
    qResult = QueueUserWorkItem(DavRestartContext, (LPVOID)DavContext, 0);
    if (!qResult) {
        //
        // Decrement the number of requests posted.
        //
        InterlockedDecrement( &(DavOutstandingWorkerRequests) );
        err = GetLastError();
        DavPrint((DEBUG_ERRORS,
                  "DavPostWorkItem/QueueUserWorkItem: WStatus = %08lx.\n", err));
    }

    return err;
}


DWORD
DavWorkerThread (
    PUMFS_WORKER_THREAD Worker
    )
/*++

Routine Description:

    This is the routine that gets kicked off by the worker thread. It issues
    synchronous IOCTL's to the user mode reflctor. Whenever a request comes
    down to the reflector, it uses these IOCTL's to pass the request back to the
    user mode. On return, the output buffers contain the request that came down
    to the reflctor. The routine looks at the request type and appropriately
    handles it. The results are sent back to the reflctor in a similar fashion.

Arguments:

    Worker - The worker thread's data structure.

Return Value:

    None.

--*/
{
    DWORD err = ERROR_SUCCESS;
    PDAV_USERMODE_WORKITEM WorkItemToUse = NULL;
    PUMRX_USERMODE_WORKITEM_HEADER WorkItemToSendBack = NULL;
    PUMFS_THREAD_CONSTELLATION Constellation = Worker->Constellation;
    ULONG NumberOfBytesTransferred;
    DWORD CompletionKey;
    ULONG failedMallocCount = 0;
    ULONG failedGetRequest = 0;
    PUMRX_USERMODE_WORKER_INSTANCE davWorkerHandle = NULL;
    BOOL didCreateImpersonationToken = FALSE, revertAlreadyDone = FALSE;

    Worker->Context1u = (ULONG)(Worker - &Constellation->WorkerThreads[0]);

    DavPrint((DEBUG_MISC,
              "DavWorkerThread: DavClient Thread (handle = %08lx and id = %08lx)"
              "starting...\n", Worker->ThisThreadHandle, Worker->ThisThreadId));

    err = UMReflectorOpenWorker(DavReflectorHandle, &davWorkerHandle);

    if (err != ERROR_SUCCESS || davWorkerHandle == NULL) {
        if (err == ERROR_SUCCESS) {
            err = ERROR_INTERNAL_ERROR;
        }
        DavPrint((DEBUG_ERRORS,
                  "DavWorkerThread: DavClient thread %08lx error %u on OpenWorker.\n",
                   Worker->ThisThreadId, err));
        goto ExitWorker;
    }

    //
    // Continue servicing requests till the thread constellation is active.
    //
    while (Constellation->Terminating == FALSE) {

        //
        // If there is no WorkItem associated with this thread, then get one
        // for it.
        //
        if (WorkItemToUse == NULL) {

            WorkItemToUse = (PDAV_USERMODE_WORKITEM)
                             UMReflectorAllocateWorkItem(
                                      davWorkerHandle,
                                      (sizeof(DAV_USERMODE_WORKITEM) -
                                       sizeof(UMRX_USERMODE_WORKITEM_HEADER)) +
                                       sizeof(ULONG));
            if (WorkItemToUse == NULL) {
                DavPrint((DEBUG_ERRORS,
                          "DavWorkerThread: DavClient Thread %08lx couldn't "
                          "allocate workitem. Retry %u\n", Worker->ThisThreadId,
                          DAV_WORKITEM_ALLOC_FAIL_COUNT - failedMallocCount));

                failedMallocCount++;

                if (failedMallocCount >= DAV_WORKITEM_ALLOC_FAIL_COUNT) {
                    err = GetLastError();
                    goto ExitWorker;
                }

                Sleep(DAV_WORKITEM_ALLOC_FAIL_WAIT);

                continue;
            }

            failedMallocCount = 0;

        }

        err = UMReflectorGetRequest(davWorkerHandle,
                                    WorkItemToSendBack,
                                    (PUMRX_USERMODE_WORKITEM_HEADER)WorkItemToUse,
                                    revertAlreadyDone);

        if (WorkItemToSendBack) {
            UMReflectorCompleteWorkItem(davWorkerHandle, WorkItemToSendBack);
            WorkItemToSendBack = NULL;
        }

        if (err != ERROR_SUCCESS) {

            DavPrint((DEBUG_ERRORS,
                      "DavWorkerThread/UMReflectorGetRequest: Thread: %08lx, "
                      "Error: %08lx,. Retry: %d\n", Worker->ThisThreadId, err,
                      DAV_WORKITEM_FAIL_REQUEST - failedGetRequest));

            failedGetRequest++;

            if ((failedGetRequest >= DAV_WORKITEM_FAIL_REQUEST) ||
                (Constellation->Terminating == TRUE)) {
                goto ExitWorker;
            }

            DavPrint((DEBUG_MISC,
                      "DavWorkerThread: DavClient thread %08lx waiting for small time\n",
                      Worker->ThisThreadId ));

            Sleep(DAV_WORKITEM_FAIL_REQUEST_WAIT);

            continue;

        }

        failedGetRequest = 0;

        //
        // If we are using WinInet synchronously, then we need to set the
        // impersonation token before we post this request to the Win32 thread
        // pool. We dont do this in the case of finalizesrvcall or finalizefobx
        // becuase these requests don't go over the network.
        //
        switch (WorkItemToUse->WorkItemType) {

        case UserModeCreate:
#ifdef DAV_USE_WININET_ASYNCHRONOUSLY
            err = DavFsCreate(WorkItemToUse);
#else
            err = DavFsSetTheDavCallBackContext(WorkItemToUse);
            if (err == ERROR_SUCCESS) {

                //
                // We need to Revert before calling the DavPostWorkItem function
                // below to post this workitem to a Win32 thread. Otherwise the
                // worker thread will not able to to impersonate the user later.
                //
                RevertToSelf();

                //
                // Set this to TRUE since we don't need to revert back in the
                // kernel any more.
                //
                revertAlreadyDone = TRUE;

                didCreateImpersonationToken = TRUE;

                err = DavPostWorkItem(DavFsCreate, WorkItemToUse);

            }
#endif
            break;

        case UserModeCreateSrvCall:
#ifdef DAV_USE_WININET_ASYNCHRONOUSLY
            err = DavFsCreateSrvCall(WorkItemToUse);
#else
            err = DavFsSetTheDavCallBackContext(WorkItemToUse);
            if (err == ERROR_SUCCESS) {

                RevertToSelf();

                revertAlreadyDone = TRUE;

                didCreateImpersonationToken = TRUE;

                err = DavPostWorkItem(DavFsCreateSrvCall, WorkItemToUse);

            }
#endif
            break;

        case UserModeCreateVNetRoot:
#ifdef DAV_USE_WININET_ASYNCHRONOUSLY
            err = DavFsCreateVNetRoot(WorkItemToUse);
#else
            err = DavFsSetTheDavCallBackContext(WorkItemToUse);
            if (err == ERROR_SUCCESS) {

                RevertToSelf();

                revertAlreadyDone = TRUE;

                didCreateImpersonationToken = TRUE;

                err = DavPostWorkItem(DavFsCreateVNetRoot, WorkItemToUse);

            }
#endif
            break;

        case UserModeFinalizeSrvCall:
#ifdef DAV_USE_WININET_ASYNCHRONOUSLY
            err = DavFsFinalizeSrvCall(WorkItemToUse);
#else
            err = DavPostWorkItem(DavFsFinalizeSrvCall, WorkItemToUse);
#endif
            break;

        case UserModeFinalizeVNetRoot:
#ifdef DAV_USE_WININET_ASYNCHRONOUSLY
            err = DavFsFinalizeVNetRoot(WorkItemToUse);
#else
            err = DavPostWorkItem(DavFsFinalizeVNetRoot, WorkItemToUse);
#endif
            break;

        case UserModeFinalizeFobx:
#ifdef DAV_USE_WININET_ASYNCHRONOUSLY
            err = DavFsFinalizeFobx(WorkItemToUse);
#else
            err = DavPostWorkItem(DavFsFinalizeFobx, WorkItemToUse);
#endif
            break;

            //
            // Check to see if we have already created the DavFileAttributes
            // list. If we have, we are already done and just need to return.
            // If we have not, then we post the request.
            //
        case UserModeQueryDirectory:
#ifdef DAV_USE_WININET_ASYNCHRONOUSLY
            err = DavFsQueryDirectory(WorkItemToUse);
#else
            err = DavFsSetTheDavCallBackContext(WorkItemToUse);
            if (err == ERROR_SUCCESS) {

                RevertToSelf();

                revertAlreadyDone = TRUE;

                didCreateImpersonationToken = TRUE;

                err = DavPostWorkItem(DavFsQueryDirectory, WorkItemToUse);

            }
#endif
            break;

        case UserModeQueryVolumeInformation:
#ifdef DAV_USE_WININET_ASYNCHRONOUSLY
            err = DavFsQueryVolumeInformation(WorkItemToUse);
#else
            err = DavFsSetTheDavCallBackContext(WorkItemToUse);
            if (err == ERROR_SUCCESS) {

                RevertToSelf();

                revertAlreadyDone = TRUE;

                didCreateImpersonationToken = TRUE;

                err = DavPostWorkItem(DavFsQueryVolumeInformation, WorkItemToUse);

            }
#endif
            break;


        case UserModeReName:
#ifdef DAV_USE_WININET_ASYNCHRONOUSLY
            err = DavFsReName(WorkItemToUse);
#else
            err = DavFsSetTheDavCallBackContext(WorkItemToUse);
            if (err == ERROR_SUCCESS) {

                RevertToSelf();

                revertAlreadyDone = TRUE;

                didCreateImpersonationToken = TRUE;

                err = DavPostWorkItem(DavFsReName, WorkItemToUse);

            }
#endif
            break;

        case UserModeClose:
#ifdef DAV_USE_WININET_ASYNCHRONOUSLY
            err = DavFsClose(WorkItemToUse);
#else
            err = DavFsSetTheDavCallBackContext(WorkItemToUse);
            if (err == ERROR_SUCCESS) {

                RevertToSelf();

                revertAlreadyDone = TRUE;

                didCreateImpersonationToken = TRUE;

                err = DavPostWorkItem(DavFsClose, WorkItemToUse);

            }
#endif
            break;

        case UserModeSetFileInformation:

            err = DavFsSetTheDavCallBackContext(WorkItemToUse);

            if (err == ERROR_SUCCESS) {

                RevertToSelf();

                revertAlreadyDone = TRUE;

                didCreateImpersonationToken = TRUE;

                err = DavPostWorkItem(DavFsSetFileInformation, WorkItemToUse);

            }

            break;

        case UserModeLockRefresh:

            err = DavFsSetTheDavCallBackContext(WorkItemToUse);

            if (err == ERROR_SUCCESS) {

                RevertToSelf();

                revertAlreadyDone = TRUE;

                didCreateImpersonationToken = TRUE;

                err = DavPostWorkItem(DavFsLockRefresh, WorkItemToUse);

            }

            break;

        default:
            DavPrint((DEBUG_ERRORS,
                      "DavWorkerThread: Invalid WorkItemType = %d.\n",
                      WorkItemToUse->WorkItemType));
            break;

        }

#ifdef DAV_USE_WININET_ASYNCHRONOUSLY

        //
        // If ERROR_IO_PENDING has been returned by the function that is
        // handling this request, it means that the request will be completed
        // in the context of some worker thread. So, this thread is done with
        // the workitem and should discard (not worry) about (completing) it.
        //
        if (err == ERROR_IO_PENDING) {
            WorkItemToUse = NULL;
        }
#else

        //
        // If we are using WinInet synchronously, we would have posted the
        // request to the Win32 thread pool. If the request was successfully
        // queued, then the worker thread that picks it up will ultimately
        // complete it.
        //
        if (err == ERROR_SUCCESS) {

            WorkItemToUse = NULL;

        } else {

            DavPrint((DEBUG_ERRORS, "DavWorkerThread/DavPostWorkItem: err = %d\n", err));

            //
            // If we created the impersonation token, we need to close it now
            // since we falied to post the request.
            //
            if (didCreateImpersonationToken) {
                DavFsFinalizeTheDavCallBackContext(WorkItemToUse);
            }

            WorkItemToUse->Status = DavDosErrorToNtStatus(err);

            //
            // The error cannot map to STATUS_SUCCESS. If it does, we need to
            // break here and investigate.
            //
            if (WorkItemToUse->Status == STATUS_SUCCESS) {
                DbgBreakPoint();
            }

        }

#endif

        //
        // If ERROR_IO_PENDING has been returned, there is nothing to send
        // back now. The above "if" takes care of this.
        //
        WorkItemToSendBack = (PUMRX_USERMODE_WORKITEM_HEADER)WorkItemToUse;

        //
        // This is set to NULL to pick up another workitem.
        //
        WorkItemToUse = NULL;

    }

ExitWorker:

    if (WorkItemToSendBack) {
        ULONG SendStatus;
        SendStatus =  UMReflectorSendResponse(davWorkerHandle, WorkItemToSendBack);
        if (SendStatus != ERROR_SUCCESS) {
            DavPrint((DEBUG_ERRORS,
                      "DavWorkerThread/UMReflectorSendResponse: SendStatus = "
                      "%08lx.\n", SendStatus));
        }
        UMReflectorCompleteWorkItem(davWorkerHandle, WorkItemToSendBack);
    }

    if (WorkItemToUse) {
        UMReflectorCompleteWorkItem(davWorkerHandle,
                                    (PUMRX_USERMODE_WORKITEM_HEADER)WorkItemToUse);
    }

    if (davWorkerHandle) {
        UMReflectorCloseWorker(davWorkerHandle);
    }

    DavPrint((DEBUG_MISC,
              "DavWorkerThread: DavClient thread %08lx exiting with error %u\n",
              Worker->ThisThreadId, err));

    //
    // This return, exits the thread.
    //
    return err;
}

//  worker.c eof
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\util\credavsrv.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    credavsrv.c

Abstract:

    This is the module that helps install the DAV service in a SCM database.

Author:

    Rohan Kumar    [RohanK]     08-Feb-2000

Environment:

    User Mode - Win32

Revision History:

--*/

#include <stdio.h>
#include <windows.h>
#include <winsvc.h>
#include <string.h>

#define UNICODE
#define _UNICODE

VOID
_cdecl
main(
    IN INT      ArgC,
    IN PCHAR    ArgV[]
    )
/*++

Routine Description:
    
    Main function that installs the service.

Arguments:
    
    ArgC - Number of arguments.
    
    ArgV - Array of arguments.

Return Value:
    
    None.
    
--*/
{
    ULONG WStatus = ERROR_SUCCESS;
    SC_HANDLE SCMHandle = NULL;
    SC_HANDLE DavServiceHandle = NULL;
    WCHAR PathName[MAX_PATH];

    //
    // Open the service control manager database of the local machine.
    //
    SCMHandle = OpenSCManagerW(NULL, NULL, SC_MANAGER_CREATE_SERVICE);
    if (SCMHandle == NULL) {
        WStatus = GetLastError();
        printf("ERROR: OpenSCManager: WStatus = %d\n", WStatus);
        goto EXIT_THE_FUNCTION;
    }

    WStatus = GetEnvironmentVariableW(L"SystemRoot", PathName, MAX_PATH);
    if (WStatus == 0) {
        printf("ERROR: GetEnvironmentVariableW: WStatus = %d\n", WStatus);
        goto EXIT_THE_FUNCTION;
    }

    wcscat(PathName, L"\\System32\\davclient.exe");

    DavServiceHandle = CreateServiceW(SCMHandle,
                                      L"WebClient",
                                      L"Web Client Network",
                                      SERVICE_ALL_ACCESS,
                                      SERVICE_WIN32_OWN_PROCESS,
                                      SERVICE_DEMAND_START,
                                      SERVICE_ERROR_NORMAL,
                                      PathName,
                                      NULL,
                                      NULL,
                                      NULL,
                                      NULL,
                                      NULL);
    if (DavServiceHandle == NULL) {
        WStatus = GetLastError();
        printf("ERROR: CreateServiceW: WStatus = %d\n", WStatus);
        goto EXIT_THE_FUNCTION;
    }

EXIT_THE_FUNCTION:

    if (SCMHandle) {
        CloseServiceHandle(SCMHandle);
    }

    if (DavServiceHandle) {
        CloseServiceHandle(DavServiceHandle);
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\ifskit.mrx\nulmrx\sys\devctrl.c ===
/*++

Copyright (c) 1989 - 1999   Microsoft Corporation

Module Name:

    devctrl.c

Abstract:

    This module implements DeviceIoControl operations.

--*/

#include "precomp.h"
#pragma hdrstop

//
//  The local debug trace level
//

RXDT_DefineCategory(DEVCTRL);

#define Dbg                              (DEBUG_TRACE_DEVCTRL)


//
//  forwards & code allocation pragmas
//
#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NulMRxIoCtl)
#endif

   
NTSTATUS
NulMRxIoCtl(
      IN OUT PRX_CONTEXT RxContext)
/*++

Routine Description:

   This routine performs an IOCTL operation.
   
Arguments:

    RxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS Status = STATUS_INVALID_DEVICE_REQUEST;
    RxCaptureFcb;
    RxCaptureFobx;
    PMRX_SRV_OPEN pSrvOpen = capFobx->pSrvOpen;
    NulMRxGetFcbExtension(capFcb,pFcbExtension);
    PMRX_NET_ROOT pNetRoot = capFcb->pNetRoot;
    PMRX_SRV_CALL pSrvCall = pNetRoot->pSrvCall;
    UNICODE_STRING RootName;
    NulMRxGetDeviceExtension(RxContext,pDeviceExtension);
    PLOWIO_CONTEXT LowIoContext  = &RxContext->LowIoContext;
    ULONG IoControlCode = LowIoContext->ParamsFor.FsCtl.FsControlCode;
    PUNICODE_STRING RemainingName = pSrvOpen->pAlreadyPrefixedName;
    UNICODE_STRING  StatsFile;
    NulMRxGetNetRootExtension(pNetRoot,pNetRootExtension);
    
    RxTraceEnter("NulMRxIoCtl");
    PAGED_CODE();
 
    switch (IoControlCode) {

        default:        
        //ASSERT(!"unimplemented major function");
		break;
    }

    RxTraceLeave(Status);
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\ifskit.mrx\nulmrx\sys\devfcb.c ===
/*++

Copyright (c) 1989 - 1999 Microsoft Corporation

Module Name:

    devfcb.c

Abstract:

    This module implements the mechanism for deleting an established connection

--*/

#include "precomp.h"
#pragma hdrstop
#include "fsctlbuf.h"

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_DEVFCB)

#define FIXED_CONNECT_NAME L"\\;0:\\nulsvr\\share"


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NulMRxDevFcbXXXControlFile)
#endif

NTSTATUS
NulMRxDevFcbXXXControlFile (
    IN OUT PRX_CONTEXT RxContext
    )
/*++

Routine Description:

    This routine handles all the device FCB related FSCTL's in the mini rdr

Arguments:

    RxContext - Describes the Fsctl and Context.

Return Value:

    a valid NTSTATUS code.

Notes:

--*/
{
    NTSTATUS Status;
    RxCaptureFobx;
    UCHAR MajorFunctionCode  = RxContext->MajorFunction;
    NulMRxGetDeviceExtension(RxContext,pDeviceExtension);
    PLOWIO_CONTEXT LowIoContext  = &RxContext->LowIoContext;
    ULONG ControlCode = 0;

    DbgPrint("NulMRxDevFcb\n");

    switch (MajorFunctionCode)
    {
        case IRP_MJ_FILE_SYSTEM_CONTROL:
        {
            switch (LowIoContext->ParamsFor.FsCtl.MinorFunction)
            {
                case IRP_MN_USER_FS_REQUEST:
                    switch (ControlCode) {
                        default:
                        Status = STATUS_INVALID_DEVICE_REQUEST;
                    }
                    break;
                default :  //minor function != IRP_MN_USER_FS_REQUEST
                Status = STATUS_INVALID_DEVICE_REQUEST;
            }
        } // FSCTL case
        break;

        case IRP_MJ_DEVICE_CONTROL:
        {

            ControlCode = LowIoContext->ParamsFor.IoCtl.IoControlCode;

            switch (ControlCode) {

                case IOCTL_NULMRX_ADDCONN:
                {
                    Status = NulMRxCreateConnection( RxContext, &RxContext->PostRequest );
                }
                break;

                case IOCTL_NULMRX_DELCONN:
                    Status = NulMRxDeleteConnection( RxContext, &RxContext->PostRequest );
                    break;

                case IOCTL_NULMRX_GETLIST:
                {
                    ULONG   cbOut = LowIoContext->ParamsFor.IoCtl.OutputBufferLength;
                    PVOID   pbOut = LowIoContext->ParamsFor.IoCtl.pOutputBuffer;

                    if ( cbOut >= 26 )
                    {
                        BOOLEAN GotMutex;

                        GotMutex = ExTryToAcquireFastMutex( &pDeviceExtension->LCMutex );
                        RtlCopyMemory( pbOut, pDeviceExtension->LocalConnections, 26 );
                        if ( GotMutex )
                        {
                            ExReleaseFastMutex( &pDeviceExtension->LCMutex );
                        }
                        RxContext->InformationToReturn = 26;
                    }
                    else
                    {
                        RxContext->InformationToReturn = 0;
                    }

                    Status = STATUS_SUCCESS;
                }
                break;

                case IOCTL_NULMRX_GETCONN:
                {
                    UNICODE_STRING      LookupName;
                    UNICODE_STRING      RemainingName;
                    LOCK_HOLDING_STATE  LockHoldingState;
                    PVOID               Container;
                    ULONG               ReturnedSize = 0;

                    ULONG   ConnectNameLen  = LowIoContext->ParamsFor.IoCtl.InputBufferLength;
                    PWCHAR  ConnectName     = LowIoContext->ParamsFor.IoCtl.pInputBuffer;
                    ULONG   RemoteNameLen   = LowIoContext->ParamsFor.IoCtl.OutputBufferLength;
                    PULONG  RemoteName      = LowIoContext->ParamsFor.IoCtl.pOutputBuffer;

                    PRX_PREFIX_TABLE  pRxNetNameTable
                                       = RxContext->RxDeviceObject->pRxNetNameTable;


                    // insert the local connection name
                    if ( ConnectNameLen > sizeof( WCHAR ) )
                    {
                        PWCHAR pLookupName = ExAllocatePool( PagedPool, sizeof(FIXED_CONNECT_NAME) );

                        RtlCopyMemory( pLookupName, FIXED_CONNECT_NAME, sizeof( FIXED_CONNECT_NAME ) );
                        pLookupName[2] = ConnectName[0];
                        LookupName.Buffer        = pLookupName;
                        LookupName.Length        = sizeof(FIXED_CONNECT_NAME);
                        LookupName.MaximumLength = sizeof(FIXED_CONNECT_NAME);
                        if ( LookupName.Buffer )
                        {
                            LockHoldingState = LHS_SharedLockHeld;

                            RxAcquirePrefixTableLockShared(pRxNetNameTable, TRUE);
                            Container = RxPrefixTableLookupName(pRxNetNameTable,
                                                      &LookupName, &RemainingName, NULL);
                            if (Container)
                            {
                                switch (NodeType(Container))
                                {
                                    case RDBSS_NTC_V_NETROOT:
                                    {
                                        PMRX_NET_ROOT pNetRoot = ((PV_NET_ROOT)Container)->pNetRoot;
                                        RtlCopyMemory( RemoteName, pNetRoot->pNetRootName->Buffer, pNetRoot->pNetRootName->Length );
                                        ReturnedSize = pNetRoot->pNetRootName->Length;
                                        RxDereferenceVNetRoot((PV_NET_ROOT)Container, LockHoldingState);
                                    }
                                    break;
                                    
                                    case RDBSS_NTC_NETROOT:
                                    {
                                        PNET_ROOT pNetRoot = (PNET_ROOT) Container;
                                        RtlCopyMemory( RemoteName, pNetRoot->pNetRootName->Buffer, pNetRoot->pNetRootName->Length );
                                        ReturnedSize = pNetRoot->pNetRootName->Length;
                                        RxDereferenceNetRoot((PNET_ROOT)Container, LockHoldingState);
                                    }
                                    break;

                                    case RDBSS_NTC_SRVCALL:
                                        RxDereferenceSrvCall((PSRV_CALL)Container, LockHoldingState);
                                        ReturnedSize = 0;
                                        break;
                                    default:
                                        RxDereference((PVOID)Container,LockHoldingState);
                                        ReturnedSize = 0;
                                        break;
                                }
                            }

                            RxReleasePrefixTableLock(pRxNetNameTable);
                            ExFreePool( LookupName.Buffer );
                        }
                    }
                    if ( ReturnedSize )
                    {
                        Status = STATUS_SUCCESS;
                    }
                    else
                    {
                        Status = STATUS_BAD_NETWORK_NAME;
                    }
                    RxContext->InformationToReturn = ReturnedSize;
                }
                break;

                default :
                    Status = STATUS_INVALID_DEVICE_REQUEST;
            }
        }
        break;

        case IRP_MJ_INTERNAL_DEVICE_CONTROL:
        {
            switch (ControlCode) {
            default :
                Status = STATUS_INVALID_DEVICE_REQUEST;
            }
        }
        break;

        default:
        ASSERT(!"unimplemented major function");
        Status = STATUS_INVALID_DEVICE_REQUEST;
    }

    DbgPrint("NulMRxDevFcb st,info=%08lx,%08lx\n",
                            Status,RxContext->InformationToReturn);
    return(Status);
}


HANDLE
GetConnectionHandle(
    IN PUNICODE_STRING  ConnectionName
    )
{

    NTSTATUS            Status;
    HANDLE              Handle;
    IO_STATUS_BLOCK     IoStatusBlock;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    UNICODE_STRING      FileName;

    // Connection name should get checked to be certain our device is in the path

    InitializeObjectAttributes(
        &ObjectAttributes,
        ConnectionName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL);


    Status = ZwCreateFile(
        &Handle,
        SYNCHRONIZE,
        &ObjectAttributes,
        &IoStatusBlock,
        NULL,           // Allocation size
        FILE_ATTRIBUTE_NORMAL,
        FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
        FILE_OPEN_IF,
        FILE_CREATE_TREE_CONNECTION | FILE_SYNCHRONOUS_IO_NONALERT,
        NULL,           // Ptr to EA Buffer
        0);         // Length of EA buffer

    DbgPrint("ZwCreateFile returned %lx\n",Status);

    if ( (STATUS_SUCCESS == Status) && (INVALID_HANDLE_VALUE != Handle) ) {
        DbgPrint("ZwCreateFile returned success\n");
    }
    else
        Handle = INVALID_HANDLE_VALUE;

    return  Handle;
}


NTSTATUS
DoCreateConnection(
    IN PRX_CONTEXT RxContext,
    ULONG   CreateDisposition
    )
{

    NTSTATUS Status = STATUS_SUCCESS;
    HANDLE          Handle;
    PLOWIO_CONTEXT  LowIoContext       = &RxContext->LowIoContext;
    ULONG           ConnectNameLen     = LowIoContext->ParamsFor.IoCtl.InputBufferLength;
    PWCHAR          ConnectName        = LowIoContext->ParamsFor.IoCtl.pInputBuffer;
    UNICODE_STRING  FileName;
    NulMRxGetDeviceExtension(RxContext,pDeviceExtension);

    // The sample code passes in only the filename in the Ioctl data buffer.
    //  An actual implementation could pass in stuff like EAs, security
    // credentials, etc

    RxDbgTrace(0, Dbg,("DoCreateConnection"));

    FileName.Buffer        = ConnectName;
    FileName.Length        = (USHORT) ConnectNameLen;
    FileName.MaximumLength = (USHORT) ConnectNameLen;

    Handle = GetConnectionHandle(&FileName);

    if ( INVALID_HANDLE_VALUE != Handle )
    {
        PWCHAR pwcLC;
        ULONG i;

        DbgPrint("GetConnectionHandle returned success\n");
        ZwClose(Handle);

        for ( i = 0, pwcLC = (PWCHAR) ConnectName; i < ConnectNameLen && *pwcLC!= L':'; i+=sizeof(WCHAR), pwcLC++ );

        if ( i >= sizeof(WCHAR) && i < ConnectNameLen )
        {
            pwcLC--;
            if ( *pwcLC >= L'A' && *pwcLC <= L'Z' )
            {
                ExAcquireFastMutex( &pDeviceExtension->LCMutex );
                pDeviceExtension->LocalConnections[*pwcLC - L'A'] = TRUE;
                ExReleaseFastMutex( &pDeviceExtension->LCMutex );
            }
        }
    }
    else
    {
        DbgPrint("GetConnectionHandle returned failure\n");
        Status = STATUS_BAD_NETWORK_NAME;
    }

    return(Status);
}


NTSTATUS
NulMRxCreateConnection (
    IN PRX_CONTEXT RxContext,
    OUT PBOOLEAN PostToFsp
    )
/*++

Routine Description:


Arguments:

    IN PRX_CONTEXT RxContext - Describes the Fsctl and Context....for later when i need the buffers

Return Value:

RXSTATUS

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    BOOLEAN Wait   = BooleanFlagOn(RxContext->Flags, RX_CONTEXT_FLAG_WAIT);
    BOOLEAN InFSD  = !BooleanFlagOn(RxContext->Flags, RX_CONTEXT_FLAG_IN_FSP);

    PAGED_CODE();

    DbgPrint("NulMrxCreateConnection called\n");
    RxDbgTrace(+1, Dbg, ("NulMRxCreateConnection \n"));

    if (!Wait) {
        //just post right now!
        *PostToFsp = TRUE;
        return STATUS_PENDING;
    }

    Status = DoCreateConnection(RxContext, (ULONG)FILE_OPEN_IF);

    return Status;
}


NTSTATUS
DoDeleteConnection(
    PUNICODE_STRING FileName
    )
{
    HANDLE          Handle;
    NTSTATUS        Status = STATUS_INVALID_HANDLE;
    PFILE_OBJECT    pFileObject;
    PNET_ROOT       NetRoot;
    PV_NET_ROOT     VNetRoot;
    PFOBX           Fobx;

    Handle = GetConnectionHandle(FileName);

    if ( INVALID_HANDLE_VALUE != Handle ) {
        DbgPrint("GetConnectionHandle returned success\n");

        Status = ObReferenceObjectByHandle(
                Handle,
                0L,
                NULL,
                KernelMode,
                (PVOID *)&pFileObject,
                NULL);

        DbgPrint("ObReferenceObjectByHandle worked ok\n");
        if ( NT_SUCCESS(Status) ) {

            // Got the FileObject. Now get an Fobx
            Fobx = pFileObject->FsContext2;
            if (NodeType(Fobx)==RDBSS_NTC_V_NETROOT) {
                VNetRoot = (PV_NET_ROOT)(Fobx);
                NetRoot = (PNET_ROOT)VNetRoot->NetRoot;
                DbgPrint("Calling RxFinalizeConnection\n");
                Status = RxFinalizeConnection(NetRoot,VNetRoot,TRUE);
            } else {
                ASSERT(FALSE);
                Status = STATUS_INVALID_DEVICE_REQUEST;
            }

            ObDereferenceObject(pFileObject);
        }

        ZwClose(Handle);
    }

    return Status;
}


NTSTATUS
NulMRxDeleteConnection (
    IN PRX_CONTEXT RxContext,
    OUT PBOOLEAN PostToFsp
    )
/*++

Routine Description:

    This routine deletes a single vnetroot.

Arguments:

    IN PRX_CONTEXT RxContext - Describes the Fsctl and Context....for later when i need the buffers

Return Value:

RXSTATUS

--*/
{
    NTSTATUS        Status;
    UNICODE_STRING  FileName;
    BOOLEAN         Wait              = BooleanFlagOn(RxContext->Flags, RX_CONTEXT_FLAG_WAIT);
    PLOWIO_CONTEXT  LowIoContext      = &RxContext->LowIoContext;
    PWCHAR          ConnectName       = LowIoContext->ParamsFor.IoCtl.pInputBuffer;
    ULONG           ConnectNameLen    = LowIoContext->ParamsFor.IoCtl.InputBufferLength;
    NulMRxGetDeviceExtension(RxContext,pDeviceExtension);

    PAGED_CODE();

    //RxDbgTrace(+1, Dbg, ("NulMRxDeleteConnection Fobx %08lx\n", capFobx));

    if (!Wait) {
        //just post right now!
        *PostToFsp = TRUE;
        return(STATUS_PENDING);
    }

    FileName.Buffer        = ConnectName;
    FileName.Length        = (USHORT) ConnectNameLen;
    FileName.MaximumLength = (USHORT) ConnectNameLen;

    Status = DoDeleteConnection(&FileName);

    if ( NT_SUCCESS(Status) ) {
        PWCHAR pwcLC;
        ULONG i;

        for ( i = 0, pwcLC = ConnectName; i < ConnectNameLen && *pwcLC!= L':';
              i+=sizeof(WCHAR), pwcLC++ );
        if ( i >= sizeof(WCHAR) && i < ConnectNameLen )
        {
            pwcLC--;
            if ( *pwcLC >= L'A' && *pwcLC <= L'Z' )
            {
                ExAcquireFastMutex( &pDeviceExtension->LCMutex );
                pDeviceExtension->LocalConnections[*pwcLC - L'A'] = FALSE;
                ExReleaseFastMutex( &pDeviceExtension->LCMutex );
            }
        }
    }

    return Status;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\ifskit.mrx\nulmrx\dll\nulmrxnp.c ===
/*++

Copyright (c) 1989-1999  Microsoft Corporation

Module Name:

    ifsmrxnp.c

Abstract:

    This module implements the routines required for interaction with network
    provider router interface in NT

Notes:

    This module has been built and tested only in UNICODE environment

--*/


#include <windows.h>
#include <windef.h>
#include <winbase.h>
#include <winsvc.h>
#include <winnetwk.h>
#include <npapi.h>
#include <devioctl.h>

#include "nulmrx.h"


#ifdef DBG
#define DbgP(_x_) WideDbgPrint _x_
#else
#define DbgP(_x_)
#endif

ULONG _cdecl WideDbgPrint( PWCHAR Format, ... );

#define TRACE_TAG   L"NULMRXNP:    "


#define WNNC_DRIVER( major, minor ) ( major * 0x00010000 + minor )



DWORD APIENTRY
NPGetCaps(
    DWORD nIndex )
/*++

Routine Description:

    This routine returns the capaboilities of the Null Mini redirector
    network provider implementation

Arguments:

    nIndex - category of capabilities desired

Return Value:

    the appropriate capabilities

--*/
{
    DWORD rc = 0;

    DbgP(( L"GetNetCaps .....\n" ));
    switch ( nIndex )
    {
        case WNNC_SPEC_VERSION:
            rc = WNNC_SPEC_VERSION51;
            break;

        case WNNC_NET_TYPE:
            rc = WNNC_NET_RDR2SAMPLE;
            break;

        case WNNC_DRIVER_VERSION:
            rc = WNNC_DRIVER(1, 0);
            break;

        case WNNC_CONNECTION:
            rc = WNNC_CON_GETCONNECTIONS |
                 WNNC_CON_CANCELCONNECTION |
                 WNNC_CON_ADDCONNECTION |
                 WNNC_CON_ADDCONNECTION3;
            break;

        case WNNC_ENUMERATION:
            rc = WNNC_ENUM_LOCAL;
            break;

        case WNNC_START:
            rc = 1;
            break;

        case WNNC_USER:
        case WNNC_DIALOG:
        case WNNC_ADMIN:
        default:
            rc = 0;
            break;
    }
    
    return rc;
}


DWORD APIENTRY
NPLogonNotify(
    PLUID   lpLogonId,
    LPCWSTR lpAuthentInfoType,
    LPVOID  lpAuthentInfo,
    LPCWSTR lpPreviousAuthentInfoType,
    LPVOID  lpPreviousAuthentInfo,
    LPWSTR  lpStationName,
    LPVOID  StationHandle,
    LPWSTR  *lpLogonScript)
/*++

Routine Description:

    This routine handles the logon notifications

Arguments:

    lpLogonId -- the associated LUID

    lpAuthenInfoType - the authentication information type

    lpAuthenInfo  - the authentication Information

    lpPreviousAuthentInfoType - the previous aunthentication information type

    lpPreviousAuthentInfo - the previous authentication information

    lpStationName - the logon station name

    LPVOID - logon station handle

    lpLogonScript - the logon script to be executed.

Return Value:

    WN_SUCCESS

Notes:

    This capability has not been implemented in the sample.

--*/
{
    *lpLogonScript = NULL;

    return WN_SUCCESS;
}


DWORD APIENTRY
NPPasswordChangeNotify (
    LPCWSTR lpAuthentInfoType,
    LPVOID  lpAuthentInfo,
    LPCWSTR lpPreviousAuthentInfoType,
    LPVOID  lpPreviousAuthentInfo,
    LPWSTR  lpStationName,
    LPVOID  StationHandle,
    DWORD   dwChangeInfo )
/*++

Routine Description:

    This routine handles the password change notifications

Arguments:

    lpAuthenInfoType - the authentication information type

    lpAuthenInfo  - the authentication Information

    lpPreviousAuthentInfoType - the previous aunthentication information type

    lpPreviousAuthentInfo - the previous authentication information

    lpStationName - the logon station name

    LPVOID - logon station handle

    dwChangeInfo - the password change information.

Return Value:

    WN_NOT_SUPPORTED

Notes:

    This capability has not been implemented in the sample.

--*/
{
    SetLastError( WN_NOT_SUPPORTED );

    return WN_NOT_SUPPORTED;
}


ULONG
SendToMiniRdr(
    IN ULONG            IoctlCode,
    IN PVOID            InputDataBuf,
    IN ULONG            InputDataLen,
    IN PVOID            OutputDataBuf,
    IN PULONG           pOutputDataLen)
/*++

Routine Description:

    This routine sends a device ioctl to the Mini Rdr.

Arguments:

    IoctlCode       - Function code for the Mini Rdr driver

    InputDataBuf    - Input buffer pointer

    InputDataLen    - Lenth of the input buffer

    OutputDataBuf   - Output buffer pointer

    pOutputDataLen  - Pointer to the length of the output buffer

Return Value:

    WN_SUCCESS if successful, otherwise the appropriate error

Notes:

--*/
{
    HANDLE  DeviceHandle;       // The mini rdr device handle
    ULONG   BytesRet;
    BOOL    rc;
    ULONG   Status;

    Status = WN_SUCCESS;

    // Grab a handle to the redirector device object

    DeviceHandle = CreateFile(
        DD_NULMRX_USERMODE_DEV_NAME_U,
        GENERIC_READ | GENERIC_WRITE,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        (LPSECURITY_ATTRIBUTES)NULL,
        OPEN_EXISTING,
        0,
        (HANDLE) NULL );

    if ( INVALID_HANDLE_VALUE != DeviceHandle )
    {
        rc = DeviceIoControl(
            DeviceHandle,
            IoctlCode,
            InputDataBuf,
            InputDataLen,
            OutputDataBuf,
            *pOutputDataLen,
            pOutputDataLen,
            NULL );

            if ( !rc )
            {
                DbgP(( L"SendToMiniRdr: returning error from DeviceIoctl\n" ));
                Status = GetLastError( );
            }
            else
            {
                DbgP(( L"SendToMiniRdr: The DeviceIoctl call succeded\n" ));
            }
            CloseHandle(DeviceHandle);
    }
    else
    {
        Status = GetLastError( );
        DbgP(( L"SendToMiniRdr: error %lx opening device \n", Status ));
    }

    return Status;
}


DWORD APIENTRY
NPAddConnection(
    LPNETRESOURCE   lpNetResource,
    LPWSTR          lpPassword,
    LPWSTR          lpUserName )
/*++

Routine Description:

    This routine adds a connection to the list of connections associated
    with this network provider

Arguments:

    lpNetResource - the NETRESOURCE struct

    lpPassword  - the password

    lpUserName - the user name

Return Value:

    WN_SUCCESS if successful, otherwise the appropriate error

Notes:

--*/
{
    DbgP(( L"NPAddConnection....\n" ));

    return NPAddConnection3( NULL, lpNetResource, lpPassword, lpUserName, 0 );
}


DWORD APIENTRY
NPAddConnection3(
    HWND            hwndOwner,
    LPNETRESOURCE   lpNetResource,
    LPWSTR          lpPassword,
    LPWSTR          lpUserName,
    DWORD           dwFlags )
/*++

Routine Description:

    This routine adds a connection to the list of connections associated
    with this network provider

Arguments:

    hwndOwner - the owner handle

    lpNetResource - the NETRESOURCE struct

    lpPassword  - the password

    lpUserName - the user name

    dwFlags - flags for the connection

Return Value:

    WN_SUCCESS if successful, otherwise the appropriate error

--*/
{
    DWORD   Status;
    WCHAR   ConnectionName[128];
    WCHAR   wszScratch[128];
    WCHAR   LocalName[3];
    DWORD   CopyBytes = 0;

    DbgP(( L"NPAddConnection3....\n" ));

    DbgP(( L"Local Name:  %s\n", lpNetResource->lpLocalName ));
    DbgP(( L"Remote Name: %s\n", lpNetResource->lpRemoteName ));

    Status = WN_SUCCESS;

    //  \device\miniredirector\;<DriveLetter>:\Server\Share

    if ( lstrlen( lpNetResource->lpLocalName ) > 1 )
    {
        if ( lpNetResource->lpLocalName[1] == L':' )
        {
            // LocalName[0] = (WCHAR) CharUpper( (PWCHAR) MAKELONG( (USHORT) lpNetResource->lpLocalName[0], 0 ) );
            LocalName[0] = (WCHAR) toupper(lpNetResource->lpLocalName[0]);
            LocalName[1] = L':';
            LocalName[2] = L'\0';
            lstrcpyn( ConnectionName, DD_NULMRX_FS_DEVICE_NAME_U, 126 );
            wcsncat(ConnectionName, L"\\;", 3 );
            wcsncat(ConnectionName, LocalName, 128-wcslen(ConnectionName));
        }
        else
        {
            Status = WN_BAD_LOCALNAME;
        }
    }
    else
    {
        Status = WN_BAD_LOCALNAME;
    }

    if (Status == WN_SUCCESS)
    {
        if(lpNetResource->lpRemoteName[0] == L'\0')
        {
            Status = WN_BAD_NETNAME;
        }
        // format proper server name
        else if ( lpNetResource->lpRemoteName[0] == L'\\' && lpNetResource->lpRemoteName[1] == L'\\' )
        {
            wcsncat( ConnectionName, lpNetResource->lpRemoteName + 1 , 128-wcslen(ConnectionName));
            DbgP(( L"Full Connect Name: %s\n", ConnectionName ));
            DbgP(( L"Full Connect Name Length: %d\n", ( wcslen( ConnectionName ) + 1 ) * sizeof( WCHAR ) ));
        }
        else
        {
            Status = WN_BAD_NETNAME;
        }
    }



    if ( Status == WN_SUCCESS )
    {
        if ( QueryDosDevice( LocalName, wszScratch, 128 ) )
        {
            Status = WN_ALREADY_CONNECTED;
        }
        else if ( GetLastError( ) == ERROR_FILE_NOT_FOUND )
        {
            HANDLE hFile;

            Status = SendToMiniRdr( IOCTL_NULMRX_ADDCONN, ConnectionName,
                          ( lstrlen( ConnectionName ) + 1 ) * sizeof( WCHAR ),
                          NULL, &CopyBytes );
            if ( Status == WN_SUCCESS )
            {
                if ( !DefineDosDevice( DDD_RAW_TARGET_PATH |
                                       DDD_NO_BROADCAST_SYSTEM,
                                       lpNetResource->lpLocalName,
                                       ConnectionName ) )
                {
                    Status = GetLastError( );
                }
            }
            else
            {
                    Status = WN_BAD_NETNAME;
            }
        }
        else
        {
            Status = WN_ALREADY_CONNECTED;
        }
    }
    
    return Status;
}


DWORD APIENTRY
NPCancelConnection(
    LPWSTR  lpName,
    BOOL    fForce )
/*++

Routine Description:

    This routine cancels ( deletes ) a connection from the list of connections
    associated with this network provider

Arguments:

    lpName - name of the connection

    fForce - forcefully delete the connection

Return Value:

    WN_SUCCESS if successful, otherwise the appropriate error

Notes:

--*/

{
    WCHAR   LocalName[3];
    WCHAR   RemoteName[128];
    WCHAR   ConnectionName[128];
    ULONG   CopyBytes;
    DWORD   DisconnectResult;
    DWORD   Status = WN_NOT_CONNECTED;

    if(lpName == NULL)
        return Status;

    if ( lstrlen( lpName ) > 1 )
    {
        if ( lpName[1] == L':' )
        {
            // LocalName[0] = (WCHAR) CharUpper( (PWCHAR) MAKELONG( (USHORT) lpName[0], 0 ) );
            LocalName[0] = (WCHAR) toupper(lpName[0]);
            LocalName[1] = L':';
            LocalName[2] = L'\0';

            CopyBytes = 128 * sizeof(WCHAR);
            Status = SendToMiniRdr( IOCTL_NULMRX_GETCONN, LocalName, 3 * sizeof( WCHAR ),
                                    (PVOID) RemoteName, &CopyBytes );
            if ( Status == WN_SUCCESS && CopyBytes > 0 && CopyBytes < 128 * sizeof(WCHAR) )
            {
                RemoteName[CopyBytes/sizeof(WCHAR)] = L'\0';
                lstrcpyn( ConnectionName, DD_NULMRX_FS_DEVICE_NAME_U, 126 );
                wcsncat( ConnectionName, L"\\;", 3);
                wcsncat( ConnectionName, LocalName, 128-wcslen(ConnectionName) );
                wcsncat( ConnectionName, RemoteName, 128-wcslen(ConnectionName) );
                ConnectionName[127] = L'\0';

                CopyBytes = 0;
                Status = SendToMiniRdr( IOCTL_NULMRX_DELCONN, ConnectionName,
                              ( wcslen( ConnectionName ) + 1 ) * sizeof( WCHAR ),
                              NULL, &CopyBytes );
                if ( Status == WN_SUCCESS )
                {
                    if ( !DefineDosDevice( DDD_REMOVE_DEFINITION | DDD_RAW_TARGET_PATH | DDD_EXACT_MATCH_ON_REMOVE,
                                        LocalName,
                                        ConnectionName ) )
                    {
                        Status = GetLastError( );
                    }
                }
            }
            else
            {
                Status = WN_NOT_CONNECTED;
            }
        }
    }

    return Status;
}


DWORD APIENTRY
NPGetConnection(
    LPWSTR  lpLocalName,
    LPWSTR  lpRemoteName,
    LPDWORD lpBufferSize )
/*++

Routine Description:

    This routine returns the information associated with a connection

Arguments:

    lpLocalName - local name associated with the connection

    lpRemoteName - the remote name associated with the connection

    lpBufferSize - the remote name buffer size

Return Value:

    WN_SUCCESS if successful, otherwise the appropriate error

Notes:

--*/
{
    DWORD   Status, len, i;
    ULONG   CopyBytes;
    WCHAR   RemoteName[128];
    WCHAR   LocalName[3];
    
    Status = WN_NOT_CONNECTED;

    DbgP(( L"NPGetConnection....\n" ));

    if(lpLocalName == NULL)
        return Status;

    if ( wcslen( lpLocalName ) > 1 )
    {
        if ( lpLocalName[1] == L':' )
        {
            CopyBytes = 128*sizeof(WCHAR);
            // LocalName[0] = (WCHAR) CharUpper( (PWCHAR) MAKELONG( (USHORT) lpLocalName[0], 0 ) );
            LocalName[0] = (WCHAR) toupper(lpLocalName[0]);
            LocalName[1] = L':';
            LocalName[2] = L'\0';
            Status = SendToMiniRdr( IOCTL_NULMRX_GETCONN, LocalName, 3 * sizeof( WCHAR ),
                                    (PVOID) RemoteName, &CopyBytes );
        }
    }
    if ( Status == WN_SUCCESS )
    {
        len = CopyBytes + sizeof(WCHAR);
        if ( *lpBufferSize > len )
        {
            *lpRemoteName++ = L'\\';
            CopyMemory( lpRemoteName, RemoteName, CopyBytes );
            lpRemoteName[CopyBytes/sizeof(WCHAR)] = L'\0';
        }
        else
        {
            Status = WN_MORE_DATA;
            *lpBufferSize = len;
        }
    }

    return Status;
}




DWORD APIENTRY
NPOpenEnum(
    DWORD          dwScope,
    DWORD          dwType,
    DWORD          dwUsage,
    LPNETRESOURCE  lpNetResource,
    LPHANDLE       lphEnum )
/*++

Routine Description:

    This routine opens a handle for enumeration of resources. The only capability
    implemented in the sample is for enumerating connected shares

Arguments:

    dwScope - the scope of enumeration

    dwType  - the type of resources to be enumerated

    dwUsage - the usage parameter

    lpNetResource - a pointer to the desired NETRESOURCE struct.

    lphEnum - aptr. for passing nack the enumeration handle

Return Value:

    WN_SUCCESS if successful, otherwise the appropriate error

Notes:

    The sample only supports the notion of enumerating connected shares

    The handle passed back is merely the index of the last entry returned

--*/
{
    DWORD   Status;

    DbgP((L"NPOpenEnum\n"));

    *lphEnum = NULL;

    switch ( dwScope )
    {
        case RESOURCE_CONNECTED:
        {
            *lphEnum = HeapAlloc( GetProcessHeap( ), HEAP_ZERO_MEMORY, sizeof( ULONG ) );

            if (*lphEnum )
            {
                Status = WN_SUCCESS;
            }
            else
            {
                Status = WN_OUT_OF_MEMORY;
            }
            break;
        }
        break;

        case RESOURCE_CONTEXT:
        default:
            Status  = WN_NOT_SUPPORTED;
            break;
    }


    DbgP((L"NPOpenEnum returning Status %lx\n",Status));

    return(Status);
}


DWORD APIENTRY
NPEnumResource(
    HANDLE  hEnum,
    LPDWORD lpcCount,
    LPVOID  lpBuffer,
    LPDWORD lpBufferSize)
/*++

Routine Description:

    This routine uses the handle obtained by a call to NPOpenEnum for
    enuerating the connected shares

Arguments:

    hEnum  - the enumeration handle

    lpcCount - the number of resources returned

    lpBuffer - the buffere for passing back the entries

    lpBufferSize - the size of the buffer

Return Value:

    WN_SUCCESS if successful, otherwise the appropriate error

    WN_NO_MORE_ENTRIES - if the enumeration has exhausted the entries

    WN_MORE_DATA - if nmore data is available

Notes:

    The sample only supports the notion of enumerating connected shares

    The handle passed back is merely the index of the last entry returned

--*/
{
    DWORD           Status = WN_SUCCESS;
    BYTE            ConnectionList[26];
    ULONG           CopyBytes;
    ULONG           EntriesCopied;
    ULONG           i;
    LPNETRESOURCE   pNetResource;
    ULONG           SpaceNeeded;
    ULONG           SpaceAvailable;
    WCHAR           LocalName[3];
    WCHAR           RemoteName[128];
    PWCHAR          StringZone;

    DbgP((L"NPEnumResource\n"));

    DbgP((L"NPEnumResource Count Requested %d\n", *lpcCount));

    pNetResource = (LPNETRESOURCE) lpBuffer;
    SpaceAvailable = *lpBufferSize;
    EntriesCopied = 0;
    StringZone = (PWCHAR) ((PBYTE)lpBuffer + *lpBufferSize);
    
    CopyBytes = 26;
    Status = SendToMiniRdr( IOCTL_NULMRX_GETLIST, NULL, 0,
                            (PVOID) ConnectionList, &CopyBytes );
    i = *((PULONG)hEnum);
    if ( Status == WN_SUCCESS)
    {
        for ( i = *((PULONG) hEnum); EntriesCopied < *lpcCount && i < 26; i++ )
        {
            if ( ConnectionList[i] )
            {
                CopyBytes = 128*sizeof(WCHAR);
                LocalName[0] = L'A' + (WCHAR) i;
                LocalName[1] = L':';
                LocalName[2] = L'\0';
                Status = SendToMiniRdr( IOCTL_NULMRX_GETCONN, LocalName, 3 * sizeof(WCHAR),
                                        (PVOID) RemoteName, &CopyBytes );

                // if something strange happended then just say there are no more entries
                if ( Status != WN_SUCCESS || CopyBytes == 0 )
                {
                    Status = WN_NO_MORE_ENTRIES;
                    break;
                }
                // Determine the space needed for this entry...

                SpaceNeeded  = sizeof( NETRESOURCE );           // resource struct
                SpaceNeeded += 3 * sizeof(WCHAR);               // local name
                SpaceNeeded += 2 * sizeof(WCHAR) + CopyBytes;   // remote name
                SpaceNeeded += 5 * sizeof(WCHAR);               // comment
                SpaceNeeded += sizeof(NULMRX_PROVIDER_NAME_U);  // provider name

                if ( SpaceNeeded > SpaceAvailable )
                {
                    break;
                }
                else
                {
                    SpaceAvailable -= SpaceNeeded;

                    pNetResource->dwScope       = RESOURCE_CONNECTED;
                    pNetResource->dwType        = RESOURCETYPE_DISK;
                    pNetResource->dwDisplayType = RESOURCEDISPLAYTYPE_SHARE;
                    pNetResource->dwUsage       = 0;

                    // setup string area at opposite end of buffer
                    SpaceNeeded -= sizeof( NETRESOURCE );
                    StringZone = (PWCHAR)( (PBYTE) StringZone - SpaceNeeded );
                    // copy local name
                    pNetResource->lpLocalName = StringZone;
                    *StringZone++ = L'A' + (WCHAR) i;
                    *StringZone++ = L':';
                    *StringZone++ = L'\0';
                    // copy remote name                 
                    pNetResource->lpRemoteName = StringZone;
                    *StringZone++ = L'\\';
                    CopyMemory( StringZone, RemoteName, CopyBytes );
                    StringZone += CopyBytes / sizeof(WCHAR);
                    *StringZone++ = L'\0';
                    // copy comment
                    pNetResource->lpComment = StringZone;
                    *StringZone++ = L'A';
                    *StringZone++ = L'_';
                    *StringZone++ = L'O';
                    *StringZone++ = L'K';
                    *StringZone++ = L'\0';
                    // copy provider name
                    pNetResource->lpProvider = StringZone;
                    lstrcpyn( StringZone, NULMRX_PROVIDER_NAME_U, sizeof(NULMRX_PROVIDER_NAME_U)/sizeof(WCHAR) );

                    EntriesCopied++;
                    // set new bottom of string zone
                    StringZone = (PWCHAR)( (PBYTE) StringZone - SpaceNeeded );
                }
                pNetResource++;
            }
        }
    }
    else
    {
        Status = WN_NO_MORE_ENTRIES;
    }

    *lpcCount = EntriesCopied;
    if ( EntriesCopied == 0 && Status == WN_SUCCESS )
    {
        if ( i > 25 )
        {
            Status = WN_NO_MORE_ENTRIES;
        }
        else
        {
            DbgP((L"NPEnumResource More Data Needed - %d\n", SpaceNeeded));
            Status = WN_MORE_DATA;
            *lpBufferSize = SpaceNeeded;
        }
    }
    // update entry index
    *(PULONG) hEnum = i;

    DbgP((L"NPEnumResource Entries returned - %d\n", EntriesCopied));

    return Status;
}




DWORD APIENTRY
NPCloseEnum(
    HANDLE hEnum )
/*++

Routine Description:

    This routine closes the handle for enumeration of resources.

Arguments:

    hEnum  - the enumeration handle

Return Value:

    WN_SUCCESS if successful, otherwise the appropriate error

Notes:

    The sample only supports the notion of enumerating connected shares

--*/
{
    DbgP((L"NPCloseEnum\n"));

    HeapFree( GetProcessHeap( ), 0, (PVOID) hEnum );

    return WN_SUCCESS;
}


DWORD APIENTRY
NPGetResourceParent(
    LPNETRESOURCE   lpNetResource,
    LPVOID  lpBuffer,
    LPDWORD lpBufferSize )
/*++

Routine Description:

    This routine returns the information about net resource parent

Arguments:

    lpNetResource - the NETRESOURCE struct

    lpBuffer - the buffer for passing back the parent information

    lpBufferSize - the buffer size

Return Value:

Notes:

--*/
{
    DbgP(( L"NPGetResourceParent: WN_NOT_SUPPORTED\n" ));

    return WN_NOT_SUPPORTED;
}


DWORD APIENTRY
NPGetResourceInformation(
    LPNETRESOURCE   lpNetResource,
    LPVOID  lpBuffer,
    LPDWORD lpBufferSize,
    LPWSTR  *lplpSystem )
/*++

Routine Description:

    This routine returns the information associated net resource

Arguments:

    lpNetResource - the NETRESOURCE struct

    lpBuffer - the buffer for passing back the parent information

    lpBufferSize - the buffer size

    lplpSystem -

Return Value:

Notes:

--*/
{
    DbgP(( L"NPGetResourceInformation: WN_NOT_SUPPORTED\n" ));

    return WN_NOT_SUPPORTED;
}

DWORD APIENTRY
NPGetUniversalName(
    LPCWSTR lpLocalPath,
    DWORD   dwInfoLevel,
    LPVOID  lpBuffer,
    LPDWORD lpBufferSize )
/*++

Routine Description:

    This routine returns the information associated net resource

Arguments:

    lpLocalPath - the local path name

    dwInfoLevel  - the desired info level

    lpBuffer - the buffer for the univeral name

    lpBufferSize - the buffer size

Return Value:

    WN_SUCCESS if successful

Notes:

--*/
{
    DbgP(( L"NPGetUniversalName: WN_NOT_SUPPORTED\n" ));

    return WN_NOT_SUPPORTED;
}


int _cdecl _vsnwprintf( wchar_t *buffer, size_t count, wchar_t *format, va_list arg_ptr);

// Format and write debug information to OutputDebugString
ULONG _cdecl WideDbgPrint( LPTSTR Format, ... )
{   
    ULONG rc = 0;
    TCHAR szbuffer[256];

    va_list marker;
    va_start( marker, Format );
    {
         rc = _vsnwprintf( szbuffer, 254, Format, marker );
		 szbuffer[255] = (TCHAR)0;
         OutputDebugString( TRACE_TAG );
         OutputDebugString( szbuffer );
    }

    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\ifskit.mrx\nulmrx\sys\downlvli.c ===
/*++

Copyright (c) 1989 - 1999 Microsoft Corporation

Module Name:

    DownLvlI.c

Abstract:

    This module implements downlevel fileinfo, volinfo, and dirctrl.

--*/

#include "precomp.h"
#pragma hdrstop

//
//  The local debug trace level
//

RXDT_DefineCategory(DOWNLVLI);
#define Dbg                 (DEBUG_TRACE_DOWNLVLI)

NTSTATUS
NulMRxTruncateFile(
    IN OUT struct _RX_CONTEXT * RxContext,
    IN OUT PLARGE_INTEGER   pNewFileSize,
    OUT PLARGE_INTEGER   pNewAllocationSize
    )
/*++

Routine Description:

   This routine handles requests to truncate the file

Arguments:

    RxContext - the RDBSS context

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    RxCaptureFcb;
    NulMRxGetFcbExtension(capFcb,pFcbExtension);
    PMRX_NET_ROOT pNetRoot = capFcb->pNetRoot;
    NulMRxGetNetRootExtension(pNetRoot,pNetRootExtension);

    RxTraceEnter("NulMRxTruncateFile");
    RxDbgTrace(0,  Dbg, ("NewFileSize is %d\n", pNewFileSize->LowPart));

    RxTraceLeave(Status);
    return Status;
}

NTSTATUS
NulMRxExtendFile(
    IN OUT struct _RX_CONTEXT * RxContext,
    IN OUT PLARGE_INTEGER   pNewFileSize,
    OUT PLARGE_INTEGER   pNewAllocationSize
    )
/*++

Routine Description:

   This routine handles requests to extend the file for cached IO.

Arguments:

    RxContext - the RDBSS context

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    RxCaptureFcb;
    NulMRxGetFcbExtension(capFcb,pFcbExtension);
    PMRX_NET_ROOT pNetRoot = capFcb->pNetRoot;
    NulMRxGetNetRootExtension(pNetRoot,pNetRootExtension);

    RxTraceEnter("NulMRxExtendFile");
    RxDbgTrace(0,  Dbg, ("NewFileSize is %d\n", pNewFileSize->LowPart));

    RxTraceLeave(Status);
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\ifskit.mrx\nulmrx\sys\fileinfo.c ===
/*++

Copyright (c) 1989 - 1999 Microsoft Corporation

Module Name:

    fileinfo.c

Abstract:

    This module implements the mini redirector call down routines pertaining to retrieval/
    update of file/directory/volume information.

--*/

#include "precomp.h"
#pragma hdrstop
#pragma warning(error:4101)   // Unreferenced local variable

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_FILEINFO)

NTSTATUS
NulMRxQueryDirectory(
    IN OUT PRX_CONTEXT            RxContext
    )
/*++

Routine Description:

   This routine does a directory query. Only the NT-->NT path is implemented.

Arguments:

    RxContext - the RDBSS context

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_INVALID_PARAMETER;
    FILE_INFORMATION_CLASS FileInformationClass;
    PVOID   Buffer;
    PULONG  pLengthRemaining;
    ULONG   CopySize;

    FileInformationClass = RxContext->Info.FileInformationClass;
    Buffer = RxContext->Info.Buffer;
    pLengthRemaining = &RxContext->Info.LengthRemaining;

    switch (FileInformationClass)
    {
        case FileDirectoryInformation:
        {
            PFILE_DIRECTORY_INFORMATION pDirInfo = (PFILE_DIRECTORY_INFORMATION) Buffer;
            CopySize = sizeof( FILE_DIRECTORY_INFORMATION );
            if ( *pLengthRemaining >= CopySize )
            {
                RtlZeroMemory( pDirInfo, CopySize );
                pDirInfo->FileAttributes = FILE_ATTRIBUTE_DIRECTORY;
                pDirInfo->FileNameLength = sizeof( WCHAR );
                pDirInfo->FileName[0] = L'.';
                *pLengthRemaining -= CopySize;
                Status = RxContext->QueryDirectory.InitialQuery ?
                             STATUS_SUCCESS : STATUS_NO_MORE_FILES;
            }
        }
        break;

        case FileFullDirectoryInformation:
        {
            PFILE_FULL_DIR_INFORMATION pFullDirInfo = (PFILE_FULL_DIR_INFORMATION) Buffer;
            CopySize = sizeof( FILE_FULL_DIR_INFORMATION );
            if ( *pLengthRemaining >= CopySize )
            {
                RtlZeroMemory( pFullDirInfo, CopySize );
                pFullDirInfo->FileAttributes = FILE_ATTRIBUTE_DIRECTORY;
                pFullDirInfo->FileNameLength = sizeof( WCHAR );
                pFullDirInfo->FileName[0] = L'.';
                *pLengthRemaining -= CopySize;
                Status = RxContext->QueryDirectory.InitialQuery ?
                             STATUS_SUCCESS : STATUS_NO_MORE_FILES;
            }
        }
        break;

        case FileBothDirectoryInformation:
        {
            PFILE_BOTH_DIR_INFORMATION pBothDirInfo = (PFILE_BOTH_DIR_INFORMATION) Buffer;
            CopySize = sizeof( FILE_BOTH_DIR_INFORMATION );
            if ( *pLengthRemaining >= CopySize )
            {
                RtlZeroMemory( pBothDirInfo, CopySize );
                pBothDirInfo->FileAttributes = FILE_ATTRIBUTE_DIRECTORY;
                pBothDirInfo->FileNameLength = sizeof( WCHAR );
                pBothDirInfo->FileName[0] = L'.';
                pBothDirInfo->ShortNameLength = sizeof( WCHAR );
                pBothDirInfo->ShortName[0] = L'.';
                *pLengthRemaining -= CopySize;
                Status = RxContext->QueryDirectory.InitialQuery ?
                             STATUS_SUCCESS : STATUS_NO_MORE_FILES;
            }
        }
        break;

        case FileNamesInformation:
        {
            PFILE_NAMES_INFORMATION pNamesDirInfo = (PFILE_NAMES_INFORMATION) Buffer;
            CopySize = sizeof( FILE_NAMES_INFORMATION );
            if ( *pLengthRemaining >= CopySize )
            {
                RtlZeroMemory( pNamesDirInfo, CopySize );
                pNamesDirInfo->FileNameLength = sizeof( WCHAR );
                pNamesDirInfo->FileName[0] = L'.';
                *pLengthRemaining -= CopySize;
                Status = RxContext->QueryDirectory.InitialQuery ?
                             STATUS_SUCCESS : STATUS_NO_MORE_FILES;
            }
        }
        break;

        default:
            RxDbgTrace( 0, Dbg, ("NulMRxQueryDirectory: Invalid FS information class\n"));
            Status = STATUS_INVALID_PARAMETER;
            break;
    }

    DbgPrint("NulMRxQueryDirectory \n");
    return(Status);
}


NTSTATUS
NulMRxQueryVolumeInformation(
      IN OUT PRX_CONTEXT          RxContext
      )
/*++

Routine Description:

   This routine queries the volume information

Arguments:

    pRxContext         - the RDBSS context

    FsInformationClass - the kind of Fs information desired.

    pBuffer            - the buffer for copying the information

    pBufferLength      - the buffer length ( set to buffer length on input and set
                         to the remaining length on output)

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_INVALID_PARAMETER;
    RxCaptureFcb;

    ULONG    RemainingLength = RxContext->Info.LengthRemaining;
    FS_INFORMATION_CLASS FsInformationClass = RxContext->Info.FsInformationClass;
    PVOID OriginalBuffer = RxContext->Info.Buffer;
    UNICODE_STRING ustrVolume;
    ULONG BytesToCopy;

    RxTraceEnter("NulMRxQueryVolumeInformation");

    switch( FsInformationClass ) {
        case FileFsVolumeInformation:
        {
            PFILE_FS_VOLUME_INFORMATION pVolInfo = (PFILE_FS_VOLUME_INFORMATION) OriginalBuffer;

            if(RemainingLength < sizeof(FILE_FS_VOLUME_INFORMATION))
            {
                break;
            }
            RtlZeroMemory( pVolInfo, sizeof(FILE_FS_VOLUME_INFORMATION) );
            pVolInfo->VolumeCreationTime.QuadPart = 0;
            pVolInfo->VolumeSerialNumber = 0xBABAFACE;
            pVolInfo->SupportsObjects = FALSE;
            RtlInitUnicodeString( &ustrVolume, L"NULMRX" );

            RemainingLength -= FIELD_OFFSET(FILE_FS_VOLUME_INFORMATION, VolumeLabel[0]);

            if (RemainingLength >= (ULONG)ustrVolume.Length) {
                BytesToCopy = ustrVolume.Length;
            } else {
                BytesToCopy = RemainingLength;
            }

            RtlCopyMemory( &pVolInfo->VolumeLabel[0], (PVOID)ustrVolume.Buffer, BytesToCopy );
            
            RemainingLength -= BytesToCopy;
            pVolInfo->VolumeLabelLength = BytesToCopy;

            RxContext->Info.LengthRemaining = RemainingLength;
           
            Status = STATUS_SUCCESS;            
            DbgPrint("FileFsVolumeInformation\n");
        }
        break;
    
        case FileFsLabelInformation:
            DbgPrint("FileFsLabelInformation\n");
            break;
        
        case FileFsSizeInformation:
            DbgPrint("FileFsSizeInformation\n");
            break;
    
        case FileFsDeviceInformation:
            DbgPrint("FileFsDeviceInformation\n");
            break;
    
        case FileFsAttributeInformation:
        {
            PFILE_FS_ATTRIBUTE_INFORMATION pAttribInfo =
                (PFILE_FS_ATTRIBUTE_INFORMATION) OriginalBuffer;

            if(RemainingLength < sizeof(FILE_FS_ATTRIBUTE_INFORMATION))
            {
                break;
            }

            RtlZeroMemory(pAttribInfo, sizeof(FILE_FS_ATTRIBUTE_INFORMATION));

            pAttribInfo->FileSystemAttributes = 0;
            pAttribInfo->MaximumComponentNameLength = 32;

            RemainingLength -= FIELD_OFFSET(FILE_FS_ATTRIBUTE_INFORMATION, FileSystemName[0]);
            
            RtlInitUnicodeString( &ustrVolume, L"SampleFS" );

            BytesToCopy = RemainingLength;
            if(RemainingLength >= ustrVolume.Length)
            {
                BytesToCopy = ustrVolume.Length;
            }

            pAttribInfo->FileSystemNameLength = BytesToCopy;

            RtlCopyMemory( pAttribInfo->FileSystemName, (PVOID)ustrVolume.Buffer, BytesToCopy );
            RemainingLength -= BytesToCopy;
            
            RxContext->Info.LengthRemaining = RemainingLength;
           
            Status = STATUS_SUCCESS;            
            
            DbgPrint("FileFsAttributeInformation\n");
        }
        break;
    
        case FileFsControlInformation:
            DbgPrint("FileFsControlInformation\n");
            break;
    
        case FileFsFullSizeInformation:
            DbgPrint("FileFsFullSizeInformation\n");
            break;
    
        case FileFsObjectIdInformation:
            DbgPrint("FileFsObjectIdInformation\n");
            break;
    
        case FileFsMaximumInformation:
            DbgPrint("FileFsMaximumInformation\n");
            break;
    
        default:
            break;
    }

    RxTraceLeave(Status);
    return(Status);
}

NTSTATUS
NulMRxSetVolumeInformation(
      IN OUT PRX_CONTEXT              pRxContext
      )
/*++

Routine Description:

   This routine sets the volume information

Arguments:

    pRxContext - the RDBSS context

    FsInformationClass - the kind of Fs information desired.

    pBuffer            - the buffer for copying the information

    BufferLength       - the buffer length

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_NOT_IMPLEMENTED;

    DbgPrint("NulMRxSetVolumeInformation \n");
    return(Status);
}


NTSTATUS
NulMRxQueryFileInformation(
      IN PRX_CONTEXT            RxContext
      )
/*++

Routine Description:

   This routine does a query file info. Only the NT-->NT path is implemented.

   The NT-->NT path works by just remoting the call basically without further ado.

Arguments:

    RxContext - the RDBSS context

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_INVALID_PARAMETER;
    ULONG RemainingLength = RxContext->Info.LengthRemaining;
    RxCaptureFcb;
    FILE_INFORMATION_CLASS FunctionalityRequested = 
            RxContext->Info.FileInformationClass;
    PFILE_STANDARD_INFORMATION pFileStdInfo = 
            (PFILE_STANDARD_INFORMATION) RxContext->Info.Buffer;

    RxTraceEnter("NulMRxQueryFileInformation");

    switch( FunctionalityRequested ) {
        case FileBasicInformation:
            if(RemainingLength < sizeof(FILE_BASIC_INFORMATION)) {
                break;
            }
            RemainingLength -= sizeof(FILE_BASIC_INFORMATION);
            Status = STATUS_SUCCESS;
            break;
    
        case FileInternalInformation:
            if(RemainingLength < sizeof(FILE_INTERNAL_INFORMATION)) {
                break;
            }
            RemainingLength -= sizeof(FILE_INTERNAL_INFORMATION);
            Status = STATUS_SUCCESS;
            break;
            
        case FileEaInformation:
            if(RemainingLength < sizeof(FILE_EA_INFORMATION)) {
                break;
            }
            RemainingLength -= sizeof(FILE_EA_INFORMATION);
            Status = STATUS_SUCCESS;
            break;
            
        case FileStandardInformation:

            if(RemainingLength < sizeof(FILE_STANDARD_INFORMATION)) {
                break;
            }
            
            RxDbgTrace(0, Dbg, ("FileSize is %d AllocationSize is %d\n",
                pFileStdInfo->EndOfFile.LowPart,pFileStdInfo->AllocationSize.LowPart));
            //(RxContext->CurrentIrp)->IoStatus.Information = sizeof(FILE_STANDARD_INFORMATION);
            RemainingLength -= sizeof(FILE_STANDARD_INFORMATION);
            Status = STATUS_SUCCESS;
            break;
        
        default:
            break;
    }

    RxContext->Info.LengthRemaining = RemainingLength;
    
    RxTraceLeave(Status);
    return(Status);
}

NTSTATUS
NulMRxSetFileInformation(
      IN PRX_CONTEXT            RxContext
      )
/*++

Routine Description:

   This routine does a set file info. Only the NT-->NT path is implemented.

   The NT-->NT path works by just remoting the call basically without further ado.

Arguments:

    RxContext - the RDBSS context

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_INVALID_PARAMETER;
    RxCaptureFcb;
    ULONG BufferLength = RxContext->Info.Length;
    FILE_INFORMATION_CLASS FunctionalityRequested = 
            RxContext->Info.FileInformationClass;
    PFILE_END_OF_FILE_INFORMATION pEndOfFileInfo = 
            (PFILE_END_OF_FILE_INFORMATION) RxContext->Info.Buffer;
    LARGE_INTEGER NewAllocationSize;

    RxTraceEnter("NulMRxSetFileInformation");

    switch( FunctionalityRequested ) {
    case FileBasicInformation:
            
        RxDbgTrace(0, Dbg, ("FileBasicInformation\n"));
        
        if(BufferLength < sizeof(FILE_BASIC_INFORMATION)) 
        {
            break;
        }
        Status = STATUS_SUCCESS;
        break;
    
        
    case FileDispositionInformation:
        
        RxDbgTrace(0, Dbg, ("FileDispositionInformation\n"));
        
        if(BufferLength < sizeof(FILE_DISPOSITION_INFORMATION)) 
        {
            break;
        }
        Status = STATUS_SUCCESS;
        break;
    
        
    case FilePositionInformation:
        
        RxDbgTrace(0, Dbg, ("FilePositionInformation\n"));
        
        if(BufferLength < sizeof(FILE_POSITION_INFORMATION)) 
        {
            break;
        }
        Status = STATUS_SUCCESS;
        break;
    
        
    case FileAllocationInformation:
        
        RxDbgTrace(0, Dbg, ("FileAllocationInformation\n"));
        RxDbgTrace(0, Dbg, ("AllocSize is %d AllocSizeHigh is %d\n",
            pEndOfFileInfo->EndOfFile.LowPart,pEndOfFileInfo->EndOfFile.HighPart));
        
        if(BufferLength < sizeof(FILE_ALLOCATION_INFORMATION)) 
        {
            break;
        }
        
        Status = STATUS_SUCCESS;
        break;
    
    case FileEndOfFileInformation:

        RxDbgTrace(0, Dbg, ("FileSize is %d FileSizeHigh is %d\n",
            capFcb->Header.AllocationSize.LowPart,capFcb->Header.AllocationSize.HighPart));
        if(BufferLength < sizeof(FILE_END_OF_FILE_INFORMATION)) 
        {
            break;
        }

        if( pEndOfFileInfo->EndOfFile.QuadPart > 
               capFcb->Header.AllocationSize.QuadPart ) {
            
            Status = NulMRxExtendFile(
                            RxContext,
                            &pEndOfFileInfo->EndOfFile,
                            &NewAllocationSize
                            );

            RxDbgTrace(0, Dbg, ("AllocSize is %d AllocSizeHigh is %d\n",
                       NewAllocationSize.LowPart,NewAllocationSize.HighPart));

            //
            //  Change the file allocation
            //
            capFcb->Header.AllocationSize.QuadPart = NewAllocationSize.QuadPart;
        } else {
            Status = NulMRxTruncateFile(
                            RxContext,
                            &pEndOfFileInfo->EndOfFile,
                            &NewAllocationSize
                            );
        }

        break;
    
        
    case FileRenameInformation:
        
        RxDbgTrace(0, Dbg, ("FileRenameInformation\n"));
        if(BufferLength < sizeof(FILE_RENAME_INFORMATION)) 
        {
            break;
        }
        Status = STATUS_SUCCESS;
        break;
    
    default:
        break;
    }
    
    RxTraceLeave(Status);
    return Status;
}

NTSTATUS
NulMRxSetFileInformationAtCleanup(
      IN PRX_CONTEXT            RxContext
      )
/*++

Routine Description:

   This routine sets the file information on cleanup. the old rdr just swallows this operation (i.e.
   it doesn't generate it). we are doing the same..........

Arguments:

    pRxContext           - the RDBSS context

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_NOT_IMPLEMENTED;

    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\ifskit.mrx\nulmrx\sys\init.c ===
/*++

Copyright (c) 1989 - 1999 Microsoft Corporation

Module Name:

    Init.c

Abstract:

    This module implements the DRIVER_INITIALIZATION routine for 
    the null mini rdr.

--*/

#include "precomp.h"
#pragma  hdrstop

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_INIT)

#include "ntverp.h"
#include "nulmrx.h"


//
// Global data declarations.
//

NULMRX_STATE NulMRxState = NULMRX_STARTABLE;

//
//  Mini Redirector global variables.
//

//
//  LogRate
//
ULONG   LogRate = 0;

//
//  NULMRX version
//
ULONG   NulMRxVersion = VER_PRODUCTBUILD;

//
//  This is the minirdr dispatch table. It is initialized by 
//  NulMRxInitializeTables. This table will be used by the wrapper to call 
//  into this minirdr
//

struct _MINIRDR_DISPATCH  NulMRxDispatch;

//
// Pointer to the device Object for this minirdr. Since the device object is 
// created by the wrapper when this minirdr registers, this pointer is 
// initialized in the DriverEntry routine below (see RxRegisterMinirdr)
//

PRDBSS_DEVICE_OBJECT      NulMRxDeviceObject;

//
// declare the shadow debugtrace controlpoints
//

RXDT_DefineCategory(CREATE);
RXDT_DefineCategory(CLEANUP);
RXDT_DefineCategory(CLOSE);
RXDT_DefineCategory(READ);
RXDT_DefineCategory(WRITE);
RXDT_DefineCategory(LOCKCTRL);
RXDT_DefineCategory(FLUSH);
RXDT_DefineCategory(PREFIX);
RXDT_DefineCategory(FCBSTRUCTS);
RXDT_DefineCategory(DISPATCH);
RXDT_DefineCategory(EA);
RXDT_DefineCategory(DEVFCB);
RXDT_DefineCategory(INIT);

//
// The following enumerated values signify the current state of the minirdr
// initialization. With the aid of this state information, it is possible
// to determine which resources to deallocate, whether deallocation comes
// as a result of a normal stop/unload, or as the result of an exception
//

typedef enum _NULMRX_INIT_STATES {
    NULMRXINIT_ALL_INITIALIZATION_COMPLETED,
    NULMRXINIT_MINIRDR_REGISTERED,
    NULMRXINIT_START
} NULMRX_INIT_STATES;

//
// function prototypes
//

NTSTATUS
NulMRxInitializeTables(
          void
    );

VOID
NulMRxUnload(
    IN PDRIVER_OBJECT DriverObject
    );

VOID
NulMRxInitUnwind(
    IN PDRIVER_OBJECT DriverObject,
    IN NULMRX_INIT_STATES NulMRxInitState
    );


NTSTATUS
NulMRxFsdDispatch (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
NulMRxReadRegistryParameters();

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT  DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
/*++

Routine Description:

    This is the initialization routine for the mini redirector

Arguments:

    DriverObject - Pointer to driver object created by the system.

Return Value:

    RXSTATUS - The function value is the final status from the initialization
        operation.

--*/
{
    NTSTATUS        	Status;
    PRX_CONTEXT     	RxContext = NULL;
    ULONG           	Controls = 0;
    NULMRX_INIT_STATES	NulMRxInitState = 0;
    UNICODE_STRING		NulMRxName;
    UNICODE_STRING		UserModeDeviceName;
    PNULMRX_DEVICE_EXTENSION pDeviceExtension;
    ULONG i;

    DbgPrint("+++ NULMRX Driver %08lx Loaded +++\n", DriverObject);
    Status =  RxDriverEntry(DriverObject, RegistryPath);
    if (Status != STATUS_SUCCESS) {
        DbgPrint("Wrapper failed to initialize. Status = %08lx\n",Status);
        return(Status);
    }

    try {
        NulMRxInitState = NULMRXINIT_START;

        //
        //  Register this minirdr with the connection engine. Registration makes the connection
        //  engine aware of the device name, driver object, and other characteristics.
        //  If registration is successful, a new device object is returned
        //
        //


        RtlInitUnicodeString(&NulMRxName, DD_NULMRX_FS_DEVICE_NAME_U);
        SetFlag(Controls,RX_REGISTERMINI_FLAG_DONT_PROVIDE_UNCS);
        SetFlag(Controls,RX_REGISTERMINI_FLAG_DONT_PROVIDE_MAILSLOTS);
        
        Status = RxRegisterMinirdr(
                     &NulMRxDeviceObject,				// where the new device object goes
                     DriverObject,						// the Driver Object to register
                     &NulMRxDispatch,					// the dispatch table for this driver
                     Controls,							// dont register with unc and for mailslots
                     &NulMRxName,						// the device name for this minirdr
                     sizeof(NULMRX_DEVICE_EXTENSION),	// IN ULONG DeviceExtensionSize,
                     FILE_DEVICE_NETWORK_FILE_SYSTEM,	// IN ULONG DeviceType - disk ?
                     FILE_REMOTE_DEVICE					// IN  ULONG DeviceCharacteristics
                     );

        if (Status!=STATUS_SUCCESS) {
            DbgPrint("NulMRxDriverEntry failed: %08lx\n", Status );
            try_return(Status);
        }

        //
        //  Init the device extension data
        //  NOTE: the device extension actually points to fields
        //  in the RDBSS_DEVICE_OBJECT. Our space is past the end
        //  of this struct !!
        //

        pDeviceExtension = (PNULMRX_DEVICE_EXTENSION)
            ((PBYTE)(NulMRxDeviceObject) + sizeof(RDBSS_DEVICE_OBJECT));

        RxDefineNode(pDeviceExtension,NULMRX_DEVICE_EXTENSION);
        pDeviceExtension->DeviceObject = NulMRxDeviceObject;

		// initialize local connection list
        for (i = 0; i < 26; i++)
		{
			pDeviceExtension->LocalConnections[i] = FALSE;
		}
		// Mutex for synchronizining our connection list
		ExInitializeFastMutex( &pDeviceExtension->LCMutex );

        // The device object has been created. Need to setup a symbolic
        // link so that the device may be accessed from a Win32 user mode
        // application.

        RtlInitUnicodeString(&UserModeDeviceName, DD_NULMRX_USERMODE_SHADOW_DEV_NAME_U);
        Status = IoCreateSymbolicLink( &UserModeDeviceName, &NulMRxName);
        if (Status!=STATUS_SUCCESS) {
            DbgPrint("NulMRxDriverEntry failed: %08lx\n", Status );
            try_return(Status);
        }

        NulMRxInitState = NULMRXINIT_MINIRDR_REGISTERED;

        //
        // Build the dispatch tables for the minirdr
        //

        Status = NulMRxInitializeTables();

        if (!NT_SUCCESS( Status )) {
            try_return(Status);
        }

        //
        // Get information from the registry
        //
        NulMRxReadRegistryParameters();

  try_exit: NOTHING;
    } finally {
        if (Status != STATUS_SUCCESS) {

            NulMRxInitUnwind(DriverObject,NulMRxInitState);
        }
    }

    if (Status != STATUS_SUCCESS) {

        DbgPrint("NulMRx failed to start with %08lx %08lx\n",Status,NulMRxInitState);
        return(Status);
    }


    //
    //  Setup Unload Routine
    //

    DriverObject->DriverUnload = NulMRxUnload;

    //
    //setup the driver dispatch for people who come in here directly....like the browser
    //

    for (i = 0; i < IRP_MJ_MAXIMUM_FUNCTION; i++)
    {
        DriverObject->MajorFunction[i] = (PDRIVER_DISPATCH)NulMRxFsdDispatch;
    }
  
    //
    //  Start the mini-rdr (used to be a START IOCTL)
    //
    RxContext = RxCreateRxContext(
                    NULL,
                    NulMRxDeviceObject,
                    RX_CONTEXT_FLAG_IN_FSP);

    if (RxContext != NULL) {
        Status = RxStartMinirdr(
                             RxContext,
                             &RxContext->PostRequest);

        if (Status == STATUS_SUCCESS) {
            NULMRX_STATE State;

            State = (NULMRX_STATE)InterlockedCompareExchange(
                                                 (LONG *)&NulMRxState,
                                                 NULMRX_STARTED,
                                                 NULMRX_STARTABLE);
                    
            if (State != NULMRX_STARTABLE) {
                Status = STATUS_REDIRECTOR_STARTED;
                DbgPrint("Status is STATUS_REDIR_STARTED\n");
            }

            //
            //  Chance to get resources in context
            //  of system process.....!!!
            //
  
        } else if(Status == STATUS_PENDING ) {
    
        }
        
        RxDereferenceAndDeleteRxContext(RxContext);
    } else {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }
              
    return  STATUS_SUCCESS;
}

VOID
NulMRxInitUnwind(
    IN PDRIVER_OBJECT DriverObject,
    IN NULMRX_INIT_STATES NulMRxInitState
    )
/*++

Routine Description:

     This routine does the common uninit work for unwinding from a bad driver entry or for unloading.

Arguments:

     NulMRxInitState - tells how far we got into the intialization

Return Value:

     None

--*/

{
    PAGED_CODE();

    switch (NulMRxInitState) {
    case NULMRXINIT_ALL_INITIALIZATION_COMPLETED:

        //Nothing extra to do...this is just so that the constant in RxUnload doesn't change.......
        //lack of break intentional

    case NULMRXINIT_MINIRDR_REGISTERED:
        RxUnregisterMinirdr(NulMRxDeviceObject);

        //lack of break intentional

    case NULMRXINIT_START:
        break;
    }

}

VOID
NulMRxUnload(
    IN PDRIVER_OBJECT DriverObject
    )
/*++

Routine Description:

     This is the unload routine for the Exchange mini redirector.

Arguments:

     DriverObject - pointer to the driver object for the NulMRx

Return Value:

     None

--*/

{
    PRX_CONTEXT RxContext;
    NTSTATUS    Status;
    UNICODE_STRING  UserModeDeviceName;

    PAGED_CODE();

    NulMRxInitUnwind(DriverObject,NULMRXINIT_ALL_INITIALIZATION_COMPLETED);
    RxContext = RxCreateRxContext(
                    NULL,
                    NulMRxDeviceObject,
                    RX_CONTEXT_FLAG_IN_FSP);

    if (RxContext != NULL) {
        Status = RxStopMinirdr(
                     RxContext,
                     &RxContext->PostRequest);


        if (Status == STATUS_SUCCESS) {
            NULMRX_STATE State;

            State = (NULMRX_STATE)InterlockedCompareExchange(
                         (LONG *)&NulMRxState,
                         NULMRX_STARTABLE,
                         NULMRX_STARTED);

            if (State != NULMRX_STARTABLE) {
                Status = STATUS_REDIRECTOR_STARTED;
            }
        }

        RxDereferenceAndDeleteRxContext(RxContext);
    } else {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlInitUnicodeString(&UserModeDeviceName, DD_NULMRX_USERMODE_SHADOW_DEV_NAME_U);
    Status = IoDeleteSymbolicLink( &UserModeDeviceName);
    if (Status!=STATUS_SUCCESS) {
        DbgPrint("NulMRx: Could not delete Symbolic Link\n");
    }

    RxUnload(DriverObject);
    DbgPrint("+++ NULMRX Driver %08lx Unoaded +++\n", DriverObject);
}


NTSTATUS
NulMRxInitializeTables(
          void
    )
/*++

Routine Description:

     This routine sets up the mini redirector dispatch vector and also calls
     to initialize any other tables needed.

Return Value:

    RXSTATUS - The return status for the operation

--*/
{

    //
    // Ensure that the Exchange mini redirector context satisfies the size constraints
    //
    //ASSERT(sizeof(NULMRX_RX_CONTEXT) <= MRX_CONTEXT_SIZE);

    //
    // Build the local minirdr dispatch table and initialize
    //

    ZeroAndInitializeNodeType( &NulMRxDispatch, RDBSS_NTC_MINIRDR_DISPATCH, sizeof(MINIRDR_DISPATCH));

    //
    // null mini redirector extension sizes and allocation policies.
    //


    NulMRxDispatch.MRxFlags = (RDBSS_MANAGE_NET_ROOT_EXTENSION |
                               RDBSS_MANAGE_FCB_EXTENSION);

    NulMRxDispatch.MRxSrvCallSize  = 0; // srvcall extension is not handled in rdbss
    NulMRxDispatch.MRxNetRootSize  = sizeof(NULMRX_NETROOT_EXTENSION);
    NulMRxDispatch.MRxVNetRootSize = 0;
    NulMRxDispatch.MRxFcbSize      = sizeof(NULMRX_FCB_EXTENSION);
    NulMRxDispatch.MRxSrvOpenSize  = 0;
    NulMRxDispatch.MRxFobxSize     = 0;

    // Mini redirector cancel routine ..
    
    NulMRxDispatch.MRxCancel = NULL;

    //
    // Mini redirector Start/Stop. Each mini-rdr can be started or stopped
    // while the others continue to operate.
    //

    NulMRxDispatch.MRxStart                = NulMRxStart;
    NulMRxDispatch.MRxStop                 = NulMRxStop;
    NulMRxDispatch.MRxDevFcbXXXControlFile = NulMRxDevFcbXXXControlFile;

    //
    // Mini redirector name resolution.
    //

    NulMRxDispatch.MRxCreateSrvCall       = NulMRxCreateSrvCall;
    NulMRxDispatch.MRxSrvCallWinnerNotify = NulMRxSrvCallWinnerNotify;
    NulMRxDispatch.MRxCreateVNetRoot      = NulMRxCreateVNetRoot;
    NulMRxDispatch.MRxUpdateNetRootState  = NulMRxUpdateNetRootState;
    NulMRxDispatch.MRxExtractNetRootName  = NulMRxExtractNetRootName;
    NulMRxDispatch.MRxFinalizeSrvCall     = NulMRxFinalizeSrvCall;
    NulMRxDispatch.MRxFinalizeNetRoot     = NulMRxFinalizeNetRoot;
    NulMRxDispatch.MRxFinalizeVNetRoot    = NulMRxFinalizeVNetRoot;

    //
    // File System Object Creation/Deletion.
    //

    NulMRxDispatch.MRxCreate            = NulMRxCreate;
    NulMRxDispatch.MRxCollapseOpen      = NulMRxCollapseOpen;
    NulMRxDispatch.MRxShouldTryToCollapseThisOpen = NulMRxShouldTryToCollapseThisOpen;
    NulMRxDispatch.MRxExtendForCache    = NulMRxExtendFile;
    NulMRxDispatch.MRxExtendForNonCache = NulMRxExtendFile;
    NulMRxDispatch.MRxTruncate          = NulMRxTruncate;
    NulMRxDispatch.MRxCleanupFobx       = NulMRxCleanupFobx;
    NulMRxDispatch.MRxCloseSrvOpen      = NulMRxCloseSrvOpen;
    NulMRxDispatch.MRxFlush             = NulMRxFlush;
    NulMRxDispatch.MRxForceClosed       = NulMRxForcedClose;
    NulMRxDispatch.MRxDeallocateForFcb  = NulMRxDeallocateForFcb;
    NulMRxDispatch.MRxDeallocateForFobx = NulMRxDeallocateForFobx;

    //
    // File System Objects query/Set
    //

    NulMRxDispatch.MRxQueryDirectory       = NulMRxQueryDirectory;
    NulMRxDispatch.MRxQueryVolumeInfo      = NulMRxQueryVolumeInformation;
    NulMRxDispatch.MRxQueryEaInfo          = NulMRxQueryEaInformation;
    NulMRxDispatch.MRxSetEaInfo            = NulMRxSetEaInformation;
    NulMRxDispatch.MRxQuerySdInfo          = NulMRxQuerySecurityInformation;
    NulMRxDispatch.MRxSetSdInfo            = NulMRxSetSecurityInformation;
    NulMRxDispatch.MRxQueryFileInfo        = NulMRxQueryFileInformation;
    NulMRxDispatch.MRxSetFileInfo          = NulMRxSetFileInformation;
    NulMRxDispatch.MRxSetFileInfoAtCleanup = NulMRxSetFileInformationAtCleanup;

    //
    // Buffering state change
    //

    NulMRxDispatch.MRxComputeNewBufferingState = NulMRxComputeNewBufferingState;

    //
    // File System Object I/O
    //

    NulMRxDispatch.MRxLowIOSubmit[LOWIO_OP_READ]            = NulMRxRead;
    NulMRxDispatch.MRxLowIOSubmit[LOWIO_OP_WRITE]           = NulMRxWrite;
    NulMRxDispatch.MRxLowIOSubmit[LOWIO_OP_SHAREDLOCK]      = NulMRxLocks;
    NulMRxDispatch.MRxLowIOSubmit[LOWIO_OP_EXCLUSIVELOCK]   = NulMRxLocks;
    NulMRxDispatch.MRxLowIOSubmit[LOWIO_OP_UNLOCK]          = NulMRxLocks;
    NulMRxDispatch.MRxLowIOSubmit[LOWIO_OP_UNLOCK_MULTIPLE] = NulMRxLocks;
    NulMRxDispatch.MRxLowIOSubmit[LOWIO_OP_FSCTL]           = NulMRxFsCtl;
    NulMRxDispatch.MRxLowIOSubmit[LOWIO_OP_IOCTL]           = NulMRxIoCtl;

    NulMRxDispatch.MRxLowIOSubmit[LOWIO_OP_NOTIFY_CHANGE_DIRECTORY] = NulMRxNotifyChangeDirectory;

    //
    // Miscellanous
    //

    NulMRxDispatch.MRxCompleteBufferingStateChangeRequest = NulMRxCompleteBufferingStateChangeRequest;

    return(STATUS_SUCCESS);
}




NTSTATUS
NulMRxStart(
    PRX_CONTEXT RxContext,
    IN OUT PRDBSS_DEVICE_OBJECT RxDeviceObject
    )
/*++

Routine Description:

     This routine completes the initialization of the mini redirector fromn the
     RDBSS perspective. Note that this is different from the initialization done
     in DriverEntry. Any initialization that depends on RDBSS should be done as
     part of this routine while the initialization that is independent of RDBSS
     should be done in the DriverEntry routine.

Arguments:

    RxContext - Supplies the Irp that was used to startup the rdbss

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    return Status;
}





NTSTATUS
NulMRxStop(
    PRX_CONTEXT RxContext,
    IN OUT PRDBSS_DEVICE_OBJECT RxDeviceObject
    )
/*++

Routine Description:

    This routine is used to activate the mini redirector from the RDBSS perspective

Arguments:

    RxContext - the context that was used to start the mini redirector

    pContext  - the null mini rdr context passed in at registration time.

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status;

    //DbgPrint("Entering NulMRxStop \n");

    return(STATUS_SUCCESS);
}



NTSTATUS
NulMRxFsdDispatch (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the FSD dispatch for the mini DRIVER object. 

Arguments:

    DeviceObject - Supplies the device object for the packet being processed.

    Irp - Supplies the Irp being processed

Return Value:

    RXSTATUS - The Fsd status for the Irp

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    ASSERT(DeviceObject==(PDEVICE_OBJECT)NulMRxDeviceObject);
    if (DeviceObject!=(PDEVICE_OBJECT)NulMRxDeviceObject) {
        Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
        Irp->IoStatus.Information = 0;
        IoCompleteRequest(Irp, IO_NO_INCREMENT );
        return (STATUS_INVALID_DEVICE_REQUEST);
    }

    Status = RxFsdDispatch((PRDBSS_DEVICE_OBJECT)NulMRxDeviceObject,Irp);
    return Status;
}

NTSTATUS
NulMRxGetUlongRegistryParameter(
    HANDLE ParametersHandle,
    PWCHAR ParameterName,
    PULONG ParamUlong,
    BOOLEAN LogFailure
    )
/*++

Routine Description:

    This routine is called to read a ULONG param from t he registry.

Arguments:

    ParametersHandle - the handle of the containing registry "folder"
    ParameterName    - name of the parameter to be read
    ParamUlong       - where to store the value, if successful
    LogFailure       - if TRUE and the registry stuff fails, log an error

Return Value:

    RXSTATUS - STATUS_SUCCESS

--*/
{
    ULONG Storage[16];
    PKEY_VALUE_PARTIAL_INFORMATION Value;
    ULONG ValueSize;
    UNICODE_STRING UnicodeString;
    NTSTATUS Status;
    ULONG BytesRead;

    PAGED_CODE(); //INIT

    Value = (PKEY_VALUE_PARTIAL_INFORMATION)Storage;
    ValueSize = sizeof(Storage);

    RtlInitUnicodeString(&UnicodeString, ParameterName);

    Status = ZwQueryValueKey(ParametersHandle,
                        &UnicodeString,
                        KeyValuePartialInformation,
                        Value,
                        ValueSize,
                        &BytesRead);


    if (NT_SUCCESS(Status)) {
        if (Value->Type == REG_DWORD) {
            PULONG ConfigValue = (PULONG)&Value->Data[0];
            *ParamUlong = *((PULONG)ConfigValue);
            DbgPrint("readRegistryvalue %wZ = %08lx\n",&UnicodeString,*ParamUlong);
            return(STATUS_SUCCESS);
        } else {
            Status = STATUS_INVALID_PARAMETER;
        }
     }

     if (LogFailure)
     {
     	// log the failure...
     }

     return Status;
}

VOID
NulMRxReadRegistryParameters()
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING ParametersRegistryKeyName;
    HANDLE ParametersHandle;
    ULONG Temp = 0;

    RtlInitUnicodeString(&ParametersRegistryKeyName, NULL_MINIRDR_PARAMETERS);
    InitializeObjectAttributes(
        &ObjectAttributes,
        &ParametersRegistryKeyName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    Status = ZwOpenKey (&ParametersHandle, KEY_READ, &ObjectAttributes);
    if (NT_SUCCESS(Status)) {
	    Status = NulMRxGetUlongRegistryParameter(ParametersHandle,
	                              L"LogRate",
	                              (PULONG)&Temp,
	                              FALSE
	                              );
    }
    if (NT_SUCCESS(Status)) {
		LogRate = Temp;
		
		// Check for bogus parameters.
		if(LogRate > 10) {
			LogRate = 10;
		}
	}
    
    ZwClose(ParametersHandle);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\ifskit.mrx\nulmrx\sys\ea.c ===
/*++

Copyright (c) 1989 - 1999 Microsoft Corporation

Module Name:

    ea.c

Abstract:

    This module implements 'extended attributes' on a file handle

--*/

#include "precomp.h"
#pragma hdrstop

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_EA)

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NulMRxQueryEaInformation)
#endif

//
//  Extended Attributes (EA) functionality
//

NTSTATUS
NulMRxQueryEaInformation (
    IN OUT PRX_CONTEXT RxContext
    )
/*++

Routine Description:

   This routine queries IFS for extended attributes like 
   scatter-gather list and filename for an IFS handle.
   
Arguments:

    RxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    RxCaptureFcb;
    RxCaptureFobx;
    RxCaptureParamBlock;

    PMRX_SRV_OPEN pSrvOpen = capFobx->pSrvOpen;
    PFILE_FULL_EA_INFORMATION pEaInfo = (PFILE_FULL_EA_INFORMATION) RxContext->Info.Buffer;
    ULONG BufferLength = RxContext->Info.LengthRemaining;
    ULONG UserEaListLength = RxContext->QueryEa.UserEaListLength;
    PUCHAR UserEaList = RxContext->QueryEa.UserEaList;
    PFILE_GET_EA_INFORMATION pGetEaInfo = (PFILE_GET_EA_INFORMATION) UserEaList;
    NulMRxGetFcbExtension(capFcb,pFcbExtension);
    PMRX_NET_ROOT pNetRoot = capFcb->pNetRoot;
    NulMRxGetNetRootExtension(pNetRoot,pNetRootExtension);

    RxTraceEnter("NulMRxQueryEaInformation");
    PAGED_CODE();

    RxDbgTrace(0, Dbg, ("Ea buffer len remaining is %d\n", RxContext->Info.LengthRemaining));

    RxTraceLeave(Status);
    return(Status);
}

NTSTATUS
NulMRxSetEaInformation (
    IN OUT PRX_CONTEXT  RxContext
    )
/*++

Routine Description:

   This routine sets the EA information for this FCB
   
Arguments:

    RxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

Notes:


--*/
{
    PAGED_CODE();

    UNREFERENCED_PARAMETER(RxContext);

    DbgPrint("NulMRxSetEaInformation");
    return STATUS_NOT_IMPLEMENTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\ifskit.mrx\nulmrx\sys\mrxprocs.h ===
/*++

Copyright (c) 1989 - 1999 Microsoft Corporation

Module Name:

    mrxprocs.h

Abstract:

    The module contains the prototype definitions for all cross referenced
    routines.

--*/

#ifndef _MRXPROCS_H_
#define _MRXPROCS_H_

//cross-referenced internal routines

//from rename.c
NulMRxRename(
      IN PRX_CONTEXT            RxContext,
      IN FILE_INFORMATION_CLASS FileInformationClass,
      IN PVOID                  pBuffer,
      IN ULONG                  BufferLength);

// from usrcnnct.c
extern NTSTATUS
NulMRxDeleteConnection (
    IN PRX_CONTEXT RxContext,
    OUT PBOOLEAN PostToFsp
    );

NTSTATUS
NulMRxCreateConnection (
    IN PRX_CONTEXT RxContext,
    OUT PBOOLEAN PostToFsp
    );

NTSTATUS
NulMRxDoConnection(
    IN PRX_CONTEXT RxContext,
    ULONG   CreateDisposition
    );

#endif   // _MRXPROCS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\ifskit.mrx\nulmrx\sys\mrxglobs.h ===
/*++

Copyright (c) 1989 - 1999 Microsoft Corporation

Module Name:

    mrxglobs.h

Abstract:

    The global include file for NULMRX mini-redirector

--*/

#ifndef _MRXGLOBS_H_
#define _MRXGLOBS_H_

extern PRDBSS_DEVICE_OBJECT NulMRxDeviceObject;
#define RxNetNameTable (*(*___MINIRDR_IMPORTS_NAME).pRxNetNameTable)

// The following enum type defines the various states associated with the null
// mini redirector. This is used during initialization

typedef enum _NULMRX_STATE_ {
   NULMRX_STARTABLE,
   NULMRX_START_IN_PROGRESS,
   NULMRX_STARTED
} NULMRX_STATE,*PNULMRX_STATE;

extern NULMRX_STATE NulMRxState;
extern ULONG        LogRate;
extern ULONG        NulMRxVersion;

//
//  Reg keys
//
#define NULL_MINIRDR_PARAMETERS \
    L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\NulMRx\\Parameters"

//
//  Use the RxDefineObj and RxCheckObj macros
//  to enforce signed structs.
//

#define RxDefineObj( type, var )            \
        var.Signature = type##_SIGNATURE;

#define RxCheckObj( type, var )             \
        ASSERT( (var).Signature == type##_SIGNATURE );

//
//  Use the RxDefineNode and RxCheckNode macros
//  to enforce node signatures and sizes.
//

#define RxDefineNode( node, type )          \
        node->NodeTypeCode = NTC_##type;    \
        node->NodeByteSize = sizeof(type);

#define RxCheckNode( node, type )           \
        ASSERT( NodeType(node) == NTC_##type );

//
// struct node types - start from 0xFF00
//
typedef enum _NULMRX_STORAGE_TYPE_CODES {
    NTC_NULMRX_DEVICE_EXTENSION      =   (NODE_TYPE_CODE)0xFF00,
    NTC_NULMRX_SRVCALL_EXTENSION     =   (NODE_TYPE_CODE)0xFF01,
    NTC_NULMRX_NETROOT_EXTENSION     =   (NODE_TYPE_CODE)0xFF02,
    NTC_NULMRX_FCB_EXTENSION         =   (NODE_TYPE_CODE)0xFF03
    
} NULMRX_STORAGE_TYPE_CODES;

//
// typedef our device extension - stores state global to the driver
//
typedef struct _NULMRX_DEVICE_EXTENSION {
    //
    //  Node type code and size
    //
    NODE_TYPE_CODE          NodeTypeCode;
    NODE_BYTE_SIZE          NodeByteSize;
    
    //
    //  Back-pointer to owning device object
    //
    PRDBSS_DEVICE_OBJECT    DeviceObject;

    //
    //  Count of active nodes
    //  Driver can be unloaded iff ActiveNodes == 0
    //
    ULONG                   ActiveNodes;
	
	//	Keep a list of local connections used
	CHAR					LocalConnections[26];
	FAST_MUTEX				LCMutex;

} NULMRX_DEVICE_EXTENSION, *PNULMRX_DEVICE_EXTENSION;

//
// typedef our srv-call extension - stores state global to a node
// NYI since wrapper does not allocate space for this..........!
//
typedef struct _NULMRX_SRVCALL_EXTENSION {
    //
    //  Node type code and size
    //
    NODE_TYPE_CODE          NodeTypeCode;
    NODE_BYTE_SIZE          NodeByteSize;
    
} NULMRX_SRVCALL_EXTENSION, *PNULMRX_SRVCALL_EXTENSION;

//
// NET_ROOT extension - stores state global to a root
//
typedef struct _NULMRX_NETROOT_EXTENSION {
    //
    //  Node type code and size
    //
    NODE_TYPE_CODE          NodeTypeCode;
    NODE_BYTE_SIZE          NodeByteSize;

} NULMRX_NETROOT_EXTENSION, *PNULMRX_NETROOT_EXTENSION;

//
//  reinitialize netroot data
//

#define     RxResetNetRootExtension(pNetRootExtension)                          \
            RxDefineNode(pNetRootExtension,NULMRX_NETROOT_EXTENSION);          

//
//  typedef our FCB extension
//  the FCB uniquely represents an IFS stream
//  NOTE: Since we are not a paging file, this mem is paged !!!
//

typedef struct _NULMRX_FCB_EXTENSION_ {
    //
    //  Node type code and size
    //
    NODE_TYPE_CODE          NodeTypeCode;
    NODE_BYTE_SIZE          NodeByteSize;
    
} NULMRX_FCB_EXTENSION, *PNULMRX_FCB_EXTENSION;

//
//  Macros to get & validate extensions
//

#define NulMRxGetDeviceExtension(RxContext,pExt)        \
        PNULMRX_DEVICE_EXTENSION pExt = (PNULMRX_DEVICE_EXTENSION)((PBYTE)(RxContext->RxDeviceObject) + sizeof(RDBSS_DEVICE_OBJECT))

#define NulMRxGetSrvCallExtension(pSrvCall, pExt)       \
        PNULMRX_SRVCALL_EXTENSION pExt = (((pSrvCall) == NULL) ? NULL : (PNULMRX_SRVCALL_EXTENSION)((pSrvCall)->Context))

#define NulMRxGetNetRootExtension(pNetRoot,pExt)        \
        PNULMRX_NETROOT_EXTENSION pExt = (((pNetRoot) == NULL) ? NULL : (PNULMRX_NETROOT_EXTENSION)((pNetRoot)->Context))

#define NulMRxGetFcbExtension(pFcb,pExt)                \
        PNULMRX_FCB_EXTENSION pExt = (((pFcb) == NULL) ? NULL : (PNULMRX_FCB_EXTENSION)((pFcb)->Context))

//
// forward declarations for all dispatch vector methods.
//

extern NTSTATUS
NulMRxStart (
    IN OUT struct _RX_CONTEXT * RxContext,
    IN OUT PRDBSS_DEVICE_OBJECT RxDeviceObject
    );

extern NTSTATUS
NulMRxStop (
    IN OUT struct _RX_CONTEXT * RxContext,
    IN OUT PRDBSS_DEVICE_OBJECT RxDeviceObject
    );

extern NTSTATUS
NulMRxMinirdrControl (
    IN OUT PRX_CONTEXT RxContext,
    IN OUT PVOID pContext,
    IN OUT PUCHAR SharedBuffer,
    IN     ULONG InputBufferLength,
    IN     ULONG OutputBufferLength,
    OUT PULONG CopyBackLength
    );

extern NTSTATUS
NulMRxDevFcb (
    IN OUT PRX_CONTEXT RxContext
    );

extern NTSTATUS
NulMRxDevFcbXXXControlFile (
    IN OUT PRX_CONTEXT RxContext
    );

extern NTSTATUS
NulMRxCreate (
    IN OUT PRX_CONTEXT RxContext
    );

extern NTSTATUS
NulMRxCollapseOpen (
    IN OUT PRX_CONTEXT RxContext
    );

extern NTSTATUS
NulMRxShouldTryToCollapseThisOpen (
    IN OUT PRX_CONTEXT RxContext
    );

extern NTSTATUS
NulMRxRead (
    IN OUT PRX_CONTEXT RxContext
    );

extern NTSTATUS
NulMRxWrite (
    IN OUT PRX_CONTEXT RxContext
    );

extern NTSTATUS
NulMRxLocks(
    IN OUT PRX_CONTEXT RxContext
    );

extern NTSTATUS
NulMRxFlush(
    IN OUT PRX_CONTEXT RxContext
    );

extern NTSTATUS
NulMRxFsCtl(
    IN OUT PRX_CONTEXT RxContext
    );

NTSTATUS
NulMRxIoCtl(
    IN OUT PRX_CONTEXT RxContext
    );

extern NTSTATUS
NulMRxNotifyChangeDirectory(
    IN OUT PRX_CONTEXT RxContext
    );

extern NTSTATUS
NulMRxComputeNewBufferingState(
    IN OUT PMRX_SRV_OPEN pSrvOpen,
    IN     PVOID         pMRxContext,
       OUT ULONG         *pNewBufferingState);

extern NTSTATUS
NulMRxFlush (
    IN OUT PRX_CONTEXT RxContext
    );

extern NTSTATUS
NulMRxCloseWithDelete (
    IN OUT PRX_CONTEXT RxContext
    );

extern NTSTATUS
NulMRxZeroExtend (
    IN OUT PRX_CONTEXT RxContext
    );

extern NTSTATUS
NulMRxTruncate (
    IN OUT PRX_CONTEXT RxContext
    );

extern NTSTATUS
NulMRxCleanupFobx (
    IN OUT PRX_CONTEXT RxContext
    );

extern NTSTATUS
NulMRxCloseSrvOpen (
    IN OUT PRX_CONTEXT RxContext
    );

extern NTSTATUS
NulMRxClosedSrvOpenTimeOut (
    IN OUT PRX_CONTEXT RxContext
    );

extern NTSTATUS
NulMRxQueryDirectory (
    IN OUT PRX_CONTEXT RxContext
    );

extern NTSTATUS
NulMRxQueryEaInformation (
    IN OUT PRX_CONTEXT RxContext
    );

extern NTSTATUS
NulMRxSetEaInformation (
    IN OUT struct _RX_CONTEXT * RxContext
    );

extern NTSTATUS
NulMRxQuerySecurityInformation (
    IN OUT PRX_CONTEXT RxContext
    );

extern NTSTATUS
NulMRxSetSecurityInformation (
    IN OUT struct _RX_CONTEXT * RxContext
    );

extern NTSTATUS
NulMRxQueryVolumeInformation (
    IN OUT PRX_CONTEXT RxContext
    );

extern NTSTATUS
NulMRxSetVolumeInformation (
    IN OUT PRX_CONTEXT RxContext
    );

extern NTSTATUS
NulMRxLowIOSubmit (
    IN OUT PRX_CONTEXT RxContext
    );

extern NTSTATUS
NulMRxCreateVNetRoot(
    IN OUT PMRX_CREATENETROOT_CONTEXT pContext
    );

extern NTSTATUS
NulMRxFinalizeVNetRoot(
    IN OUT PMRX_V_NET_ROOT pVirtualNetRoot,
    IN     PBOOLEAN    ForceDisconnect);

extern NTSTATUS
NulMRxFinalizeNetRoot(
    IN OUT PMRX_NET_ROOT pNetRoot,
    IN     PBOOLEAN      ForceDisconnect);

extern NTSTATUS
NulMRxUpdateNetRootState(
    IN  PMRX_NET_ROOT pNetRoot);

VOID
NulMRxExtractNetRootName(
    IN PUNICODE_STRING FilePathName,
    IN PMRX_SRV_CALL   SrvCall,
    OUT PUNICODE_STRING NetRootName,
    OUT PUNICODE_STRING RestOfName OPTIONAL
    );

extern NTSTATUS
NulMRxCreateSrvCall(
      PMRX_SRV_CALL                      pSrvCall,
      PMRX_SRVCALL_CALLBACK_CONTEXT  pCallbackContext);

extern NTSTATUS
NulMRxFinalizeSrvCall(
      PMRX_SRV_CALL    pSrvCall,
      BOOLEAN    Force);

extern NTSTATUS
NulMRxSrvCallWinnerNotify(
      IN OUT PMRX_SRV_CALL      pSrvCall,
      IN     BOOLEAN        ThisMinirdrIsTheWinner,
      IN OUT PVOID          pSrvCallContext);


extern NTSTATUS
NulMRxQueryFileInformation (
    IN OUT PRX_CONTEXT            RxContext
    );

extern NTSTATUS
NulMRxQueryNamedPipeInformation (
    IN OUT PRX_CONTEXT            RxContext,
    IN     FILE_INFORMATION_CLASS FileInformationClass,
    IN OUT PVOID              Buffer,
    IN OUT PULONG             pLengthRemaining
    );

extern NTSTATUS
NulMRxSetFileInformation (
    IN OUT PRX_CONTEXT            RxContext
    );

extern NTSTATUS
NulMRxSetNamedPipeInformation (
    IN OUT PRX_CONTEXT            RxContext,
    IN     FILE_INFORMATION_CLASS FileInformationClass,
    IN     PVOID              pBuffer,
    IN     ULONG              BufferLength
    );

NTSTATUS
NulMRxSetFileInformationAtCleanup(
      IN OUT PRX_CONTEXT            RxContext
      );

NTSTATUS
NulMRxDeallocateForFcb (
    IN OUT PMRX_FCB pFcb
    );

NTSTATUS
NulMRxDeallocateForFobx (
    IN OUT PMRX_FOBX pFobx
    );

extern NTSTATUS
NulMRxForcedClose (
    IN OUT PMRX_SRV_OPEN SrvOpen
    );

extern NTSTATUS
NulMRxExtendFile (
    IN OUT struct _RX_CONTEXT * RxContext,
    IN OUT PLARGE_INTEGER   pNewFileSize,
       OUT PLARGE_INTEGER   pNewAllocationSize
    );

extern NTSTATUS
NulMRxTruncateFile (
    IN OUT struct _RX_CONTEXT * RxContext,
    IN OUT PLARGE_INTEGER   pNewFileSize,
       OUT PLARGE_INTEGER   pNewAllocationSize
    );

extern NTSTATUS
NulMRxCompleteBufferingStateChangeRequest (
    IN OUT PRX_CONTEXT RxContext,
    IN OUT PMRX_SRV_OPEN   SrvOpen,
    IN     PVOID       pContext
    );


extern NTSTATUS
NulMRxExtendForCache (
    IN OUT PRX_CONTEXT RxContext,
    IN OUT PFCB Fcb,
    OUT    PLONGLONG pNewFileSize
    );


extern
NTSTATUS
NulMRxInitializeTransport(VOID);

extern
NTSTATUS
NulMRxUninitializeTransport(VOID);

#define NulMRxMakeSrvOpenKey(Tid,Fid) \
        (PVOID)(((ULONG)(Tid) << 16) | (ULONG)(Fid))

#include "mrxprocs.h"   // crossreferenced routines

#endif _MRXGLOBS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\ifskit.mrx\nulmrx\sys\locks.c ===
/*++

Copyright (c) 1989 - 1999 Microsoft Corporation

Module Name:

    locks.c

Abstract:

    This module implements the mini redirector call down routines pertaining to locks
    of file system objects.

--*/

#include "precomp.h"
#pragma hdrstop

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_LOCKS)

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NulMRxLocks)
#pragma alloc_text(PAGE, NulMRxCompleteBufferingStateChangeRequest)
#pragma alloc_text(PAGE, NulMRxFlush)
#endif

NTSTATUS
NulMRxLocks(
    IN PRX_CONTEXT RxContext)
/*++

Routine Description:

   This routine handles network requests for filelocks

Arguments:

    RxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_NOT_IMPLEMENTED;

    //DbgPrint("NulMRxLocks \n");
    return(Status);
}

NTSTATUS
NulMRxCompleteBufferingStateChangeRequest(
    IN OUT PRX_CONTEXT RxContext,
    IN OUT PMRX_SRV_OPEN   SrvOpen,
    IN     PVOID       pContext
    )
/*++

Routine Description:

    This routine is called to assert the locks that the wrapper has buffered. currently, it is synchronous!


Arguments:

    RxContext - the open instance
    SrvOpen   - tells which fcb is to be used.
    LockEnumerator - the routine to call to get the locks

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_NOT_IMPLEMENTED;

    DbgPrint("NulMRxCompleteBufferingStateChangeRequest \n");
    return(Status);
}

NTSTATUS
NulMRxFlush(
      IN PRX_CONTEXT RxContext)
/*++

Routine Description:

   This routine handles network requests for file flush

Arguments:

    RxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_NOT_IMPLEMENTED;

    DbgPrint("NulMRxFlush \n");
    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\ifskit.mrx\nulmrx\sys\minip.h ===
/*++

Copyright (c) 1989 - 1999 Microsoft Corporation

Module Name:

    minip.h

Abstract:

    Macros and definitions private to the null mini driver.

Notes:

    This module has been built and tested only in UNICODE environment

--*/

#ifndef _NULLMINIP_H_
#define _NULLMINIP_H_

NTHALAPI
VOID
KeStallExecutionProcessor (
    IN ULONG MicroSeconds
    );

#ifndef min
#define min(a, b)       ((a) > (b) ? (b) : (a))
#endif

#if DBG

#ifdef SUPPRESS_WRAPPER_TRACE
#define RxTraceEnter(func)                                                  \
        PCHAR __pszFunction = func;                                         \
        BOOLEAN fEnable = FALSE;                                            \
        if( RxNextGlobalTraceSuppress ) {                                   \
            RxNextGlobalTraceSuppress = RxGlobalTraceSuppress = FALSE;      \
            fEnable = TRUE;                                                 \
        }                                                                   \
        RxDbgTrace(0,Dbg,("Entering %s\n",__pszFunction));

#define RxTraceLeave(status)                                                \
        if( fEnable ) {                                                     \
            RxNextGlobalTraceSuppress = RxGlobalTraceSuppress = TRUE;       \
        }                                                                   \
        RxDbgTrace(0,Dbg,("Leaving %s Status -> %08lx\n",__pszFunction,status));
#else
#define RxTraceEnter(func)                                                  \
        PCHAR __pszFunction = func;                                         \
        RxDbgTrace(0,Dbg,("Entering %s\n",__pszFunction));

#define RxTraceLeave(status)                                                \
        RxDbgTrace(0,Dbg,("Leaving %s Status -> %08lx\n",__pszFunction,status));
#endif

#else

#define RxTraceEnter(func)
#define RxTraceLeave(status)

#endif

#define RX_VERIFY( f )  if( (f) ) ; else ASSERT( 1==0 )

//
//  Set or Validate equal
//
#define SetOrValidate(x,y,f)                                \
        if( f ) (x) = (y); else ASSERT( (x) == (y) )
        
//
//  RXCONTEXT data - mini-rdr context stored for async completions
//  NOTE: sizeof this struct should be == MRX_CONTEXT_SIZE !!
//

typedef struct _NULMRX_COMPLETION_CONTEXT {
    //
    //  IoStatus.Information
    //
    ULONG       Information;

    //
    //  IoStatus.Status
    //
    NTSTATUS    Status;
    
    //
    //  Outstanding I/Os
    //
    ULONG       OutstandingIOs;

    //
    //  I/O type
    //
    ULONG       IoType;

} NULMRX_COMPLETION_CONTEXT, *PNULMRX_COMPLETION_CONTEXT;

#define IO_TYPE_SYNCHRONOUS     0x00000001
#define IO_TYPE_ASYNC           0x00000010

#define NulMRxGetMinirdrContext(pRxContext)     \
        ((PNULMRX_COMPLETION_CONTEXT)(&(pRxContext)->MRxContext[0]))

#endif // _NULLMINIP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\ifskit.mrx\nulmrx\sys\notimpl.c ===
/*++

Copyright (c) 1989 - 1999 Microsoft Corporation

Module Name:

    notimpl.c

Abstract:

    This module includes prototypes of the functionality that has not been
    implemented in the null mini rdr.

--*/

#include "precomp.h"
#pragma hdrstop

//
// File System Control funcitonality
//


NTSTATUS
NulMRxFsCtl(
      IN OUT PRX_CONTEXT RxContext)
/*++

Routine Description:

   This routine performs an FSCTL operation (remote) on a file across the network

Arguments:

    RxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation


--*/
{
    NTSTATUS Status = STATUS_INVALID_DEVICE_REQUEST;

    DbgPrint("NulMRxFsCtl -> %08lx\n", Status);
    return Status;
}




NTSTATUS
NulMRxNotifyChangeDirectoryCancellation(
   PRX_CONTEXT RxContext)
/*++

Routine Description:

   This routine is invoked when a directory change notification operation is cancelled.
   This example doesn't support it.


Arguments:

    RxContext - the RDBSS context

Return Value:

    NTSTATUS - The return status for the operation

--*/
{

   UNREFERENCED_PARAMETER(RxContext);

   return STATUS_SUCCESS;
}



NTSTATUS
NulMRxNotifyChangeDirectory(
      IN OUT PRX_CONTEXT RxContext)
/*++

Routine Description:

   This routine performs a directory change notification operation.
   This example doesn't support it.

Arguments:

    RxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation [not implemented]

--*/
{

   UNREFERENCED_PARAMETER(RxContext);

   return STATUS_NOT_IMPLEMENTED;
}

NTSTATUS
NulMRxQuerySecurityInformation (
    IN OUT PRX_CONTEXT RxContext
    )
{
   return STATUS_NOT_IMPLEMENTED;
}



NTSTATUS
NulMRxSetSecurityInformation (
    IN OUT struct _RX_CONTEXT * RxContext
    )
{
   return STATUS_NOT_IMPLEMENTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\ifskit.mrx\nulmrx\sys\precomp.h ===
/*++

Copyright (c) 1989 - 1999 Microsoft Corporation


--*/



#define MINIRDR__NAME NulMRx
#define ___MINIRDR_IMPORTS_NAME (NulMRxDeviceObject->RdbssExports)

#include <ntifs.h>

#include "rx.h"

#include "nodetype.h"
#include "netevent.h"

#include <windef.h>

#include "nulmrx.h"
#include "minip.h"
#include <lmcons.h>     // from the Win32 SDK
#include "mrxglobs.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\ifskit.mrx\nulmrx\sys\nulmrx.h ===
/*++

Copyright (c) 1989 - 1999 Microsoft Corporation

Module Name:

    nulmrx.h

Abstract:

    This header exports all symbols and definitions shared between
    user-mode clients of nulmrx and the driver itself.

Notes:

    This module has been built and tested only in UNICODE environment

--*/

#ifndef _NULMRX_H_
#define _NULMRX_H_

// Device name for this driver
#define NULMRX_DEVICE_NAME_A "NullMiniRdr"
#define NULMRX_DEVICE_NAME_U L"NullMiniRdr"

// Provider name for this driver
#define NULMRX_PROVIDER_NAME_A "Sample Network"
#define NULMRX_PROVIDER_NAME_U L"Sample Network"

// The following constant defines the length of the above name.
#define NULMRX_DEVICE_NAME_A_LENGTH (15)

// The following constant defines the path in the ob namespace
#define DD_NULMRX_FS_DEVICE_NAME_U L"\\Device\\NullMiniRdr"

#ifndef NULMRX_DEVICE_NAME
#define NULMRX_DEVICE_NAME

//
//  The Devicename string required to access the nullmini device 
//  from User-Mode. Clients should use DD_NULMRX_USERMODE_DEV_NAME_U.
//
//  WARNING The next two strings must be kept in sync. Change one and you must 
//  change the other. These strings have been chosen such that they are 
//  unlikely to coincide with names of other drivers.
//
#define DD_NULMRX_USERMODE_SHADOW_DEV_NAME_U     L"\\??\\NullMiniRdrDN"
#define DD_NULMRX_USERMODE_DEV_NAME_U            L"\\\\.\\NullMiniRdrDN"

//
//  Prefix needed for disk filesystems
//
#define DD_NULMRX_MINIRDR_PREFIX                 L"\\;E:"

#endif // NULMRX_DEVICE_NAME

//
// BEGIN WARNING WARNING WARNING WARNING
//  The following are from the ddk include files and cannot be changed

#define FILE_DEVICE_NETWORK_FILE_SYSTEM 0x00000014 // from ddk\inc\ntddk.h
#define METHOD_BUFFERED 0
#define FILE_ANY_ACCESS 0

// END WARNING WARNING WARNING WARNING

#define IOCTL_NULMRX_BASE FILE_DEVICE_NETWORK_FILE_SYSTEM

#define _NULMRX_CONTROL_CODE(request, method, access) \
                CTL_CODE(IOCTL_NULMRX_BASE, request, method, access)

//
//  IOCTL codes supported by NullMini Device.
//

#define IOCTL_CODE_ADDCONN          100
#define IOCTL_CODE_GETCONN          101
#define IOCTL_CODE_DELCONN          102
#define IOCTL_CODE_GETLIST			103

//
//  Following is the IOCTL definition and associated structs.
//  for IOCTL_CODE_SAMPLE1
//
#define IOCTL_NULMRX_ADDCONN     _NULMRX_CONTROL_CODE(IOCTL_CODE_ADDCONN, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_NULMRX_GETCONN     _NULMRX_CONTROL_CODE(IOCTL_CODE_GETCONN, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_NULMRX_DELCONN     _NULMRX_CONTROL_CODE(IOCTL_CODE_DELCONN, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_NULMRX_GETLIST     _NULMRX_CONTROL_CODE(IOCTL_CODE_GETLIST, METHOD_BUFFERED, FILE_ANY_ACCESS)


#endif // _NULMRX_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\ifskit.mrx\nulmrx\sys\netroot.c ===
/*++

Copyright (c) 1989 - 1999 Microsoft Corporation

Module Name:

    netroot.c

Abstract:

    This module implements the routines for creating the net root.

--*/

#include "precomp.h"
#pragma hdrstop

//
//  The local debug trace level
//

RXDT_DefineCategory(NETROOT);
#define Dbg                 (DEBUG_TRACE_NETROOT)

//
// Forward declarations ...
//

NTSTATUS
NullMiniInitializeNetRootEntry(
    IN PMRX_NET_ROOT pNetRoot
    );

NTSTATUS
NulMRxUpdateNetRootState(
    IN OUT PMRX_NET_ROOT pNetRoot)
/*++

Routine Description:

   This routine updates the mini redirector state associated with a net root.

Arguments:

    pNetRoot - the net root instance.

Return Value:

    NTSTATUS - The return status for the operation

Notes:

    By diffrentiating the mini redirector state from the net root condition it is possible
    to permit a variety of reconnect strategies. It is conceivable that the RDBSS considers
    a net root to be good while the underlying mini redirector might mark it as invalid
    and reconnect on the fly.

--*/
{
    NTSTATUS Status = STATUS_NOT_IMPLEMENTED;

    RxDbgTrace(0, Dbg, ("NulMRxUpdateNetRootState \n"));
    return(Status);
}

NTSTATUS
NulMRxInitializeNetRootEntry(
    IN PMRX_NET_ROOT pNetRoot
    )
/*++

Routine Description:

    This routine initializes a new net root.
    It also validates rootnames. Eg: attempts to create a
    file in a root that has not been created will fail.

Arguments:

    pNetRoot - the net root
    
Return Value:

    NTSTATUS - The return status for the operation

Notes:

--*/
{
    NTSTATUS  Status = STATUS_SUCCESS;
    PMRX_SRV_CALL pSrvCall = pNetRoot->pSrvCall;
    UNICODE_STRING RootName;
    PNULMRX_NETROOT_EXTENSION pNetRootExtension = 
        (PNULMRX_NETROOT_EXTENSION)pNetRoot->Context;

    //
    //  A valid new NetRoot is being created
    //
    RxResetNetRootExtension(pNetRootExtension);
    return Status;
}

NTSTATUS
NulMRxCreateVNetRoot(
    IN PMRX_CREATENETROOT_CONTEXT pCreateNetRootContext
    )
/*++

Routine Description:

   This routine patches the RDBSS created net root instance with the information required
   by the mini redirector.

Arguments:

    pVNetRoot - the virtual net root instance.

    pCreateNetRootContext - the net root context for calling back

Return Value:

    NTSTATUS - The return status for the operation

Notes:

--*/
{
    NTSTATUS        Status;
    PRX_CONTEXT     pRxContext = pCreateNetRootContext->RxContext;
    PMRX_V_NET_ROOT pVNetRoot = (PMRX_V_NET_ROOT)pCreateNetRootContext->pVNetRoot;
    
    PMRX_SRV_CALL   pSrvCall;
    PMRX_NET_ROOT   pNetRoot;

	BOOLEAN Verifyer = FALSE;
    BOOLEAN  fTreeConnectOpen = TRUE; // RxContext->Create.ThisIsATreeConnectOpen;
    BOOLEAN  fInitializeNetRoot;

    RxDbgTrace(0, Dbg, ("NulMRxCreateVNetRoot\n"));
   
    pNetRoot = pVNetRoot->pNetRoot;
    pSrvCall = pNetRoot->pSrvCall;

    // The V_NET_ROOT is associated with a NET_ROOT. The two cases of interest are as
    // follows
    // 1) the V_NET_ROOT and the associated NET_ROOT are being newly created.   
    // 2) a new V_NET_ROOT associated with an existing NET_ROOT is being created.
    //
    // These two cases can be distinguished by checking if the context associated with
    // NET_ROOT is NULL. Since the construction of NET_ROOT's/V_NET_ROOT's are serialized
    // by the wrapper this is a safe check.
    // ( The wrapper cannot have more then one thread tryingto initialize the same
    // NET_ROOT).
    //
    // The above is not really true in our case. Since we have asked the wrapper,
    // to manage our netroot extension, the netroot context will always be non-NULL.
    // We will distinguish the cases by checking our root state in the context...
    //

    if(pNetRoot->Context == NULL) {
        fInitializeNetRoot = TRUE;
    } else {
        {NulMRxGetNetRootExtension(pNetRoot,pNetRootExtension);
         fInitializeNetRoot = TRUE;
        }
    }

    ASSERT((NodeType(pNetRoot) == RDBSS_NTC_NETROOT) &&
        (NodeType(pNetRoot->pSrvCall) == RDBSS_NTC_SRVCALL));

    Status = STATUS_SUCCESS;

    // update the net root state to be good.

    if (fInitializeNetRoot) {
		PWCHAR		pRootName;
		ULONG		RootNameLength;

		pNetRoot->MRxNetRootState = MRX_NET_ROOT_STATE_GOOD;

		// validate the fixed netroot name

		RootNameLength = pNetRoot->pNetRootName->Length - pSrvCall->pSrvCallName->Length;

		if ( RootNameLength >= 12 )
		{
			pRootName = (PWCHAR) (pNetRoot->pNetRootName->Buffer +
			                      (pSrvCall->pSrvCallName->Length / sizeof(WCHAR)));
		
			Verifyer  = ( pRootName[0] == L'\\' );
			Verifyer &= ( pRootName[1] == L'S' )  || ( pRootName[1] == L's' );
			Verifyer &= ( pRootName[2] == L'H' )  || ( pRootName[2] == L'h' );
			Verifyer &= ( pRootName[3] == L'A' )  || ( pRootName[3] == L'a' );
			Verifyer &= ( pRootName[4] == L'R' )  || ( pRootName[4] == L'r' );
			Verifyer &= ( pRootName[5] == L'E' )  || ( pRootName[5] == L'e' );
			Verifyer &= ( pRootName[6] == L'\\' ) || ( pRootName[6] == L'\0' );
		}
		if ( !Verifyer )
		{
			Status = STATUS_BAD_NETWORK_NAME;
		}

    } else {
        DbgPrint("Creating V_NET_ROOT on existing NET_ROOT\n");
    }

    if( (Status == STATUS_SUCCESS) && fInitializeNetRoot )
    {  
        //
        //  A new NET_ROOT and associated V_NET_ROOT are being created !
        //
        Status = NulMRxInitializeNetRootEntry(pNetRoot);
        RxDbgTrace(0, Dbg, ("NulMRXInitializeNetRootEntry %lx\n",Status));
    }

    if (Status != STATUS_PENDING) {
        pCreateNetRootContext->VirtualNetRootStatus = Status;
        if (fInitializeNetRoot) {
            pCreateNetRootContext->NetRootStatus = Status;
        } else {
            pCreateNetRootContext->NetRootStatus = Status;
        }

        // Callback the RDBSS for resumption.
        pCreateNetRootContext->Callback(pCreateNetRootContext);

        // Map the error code to STATUS_PENDING since this triggers 
        // the synchronization mechanism in the RDBSS.
        Status = STATUS_PENDING;
   }

   return Status;
}

NTSTATUS
NulMRxFinalizeVNetRoot(
    IN PMRX_V_NET_ROOT pVNetRoot,
    IN PBOOLEAN        ForceDisconnect)
/*++

Routine Description:


Arguments:

    pVNetRoot - the virtual net root

    ForceDisconnect - disconnect is forced

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
   RxDbgTrace(0, Dbg, ("NulMRxFinalizeVNetRoot %lx\n",pVNetRoot));
   return STATUS_SUCCESS;
}


NTSTATUS
NulMRxFinalizeNetRoot(
    IN PMRX_NET_ROOT   pNetRoot,
    IN PBOOLEAN        ForceDisconnect)
/*++

Routine Description:


Arguments:

    pVirtualNetRoot - the virtual net root

    ForceDisconnect - disconnect is forced

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    NulMRxGetNetRootExtension(pNetRoot,pNetRootExtension);

    RxDbgTrace(0, Dbg, ("NulMRxFinalizeNetRoot \n"));

    //
    //  This is called when all outstanding handles on this
    //  root have been cleaned up ! We can now zap the netroot
    //  extension...
    //

    return(Status);
}

VOID
NulMRxExtractNetRootName(
    IN PUNICODE_STRING FilePathName,
    IN PMRX_SRV_CALL   SrvCall,
    OUT PUNICODE_STRING NetRootName,
    OUT PUNICODE_STRING RestOfName OPTIONAL
    )
/*++

Routine Description:

    This routine parses the input name into srv, netroot, and the
    rest.

Arguments:


--*/
{
    UNICODE_STRING xRestOfName;

    ULONG length = FilePathName->Length;
    PWCH w = FilePathName->Buffer;
    PWCH wlimit = (PWCH)(((PCHAR)w)+length);
    PWCH wlow;

    RxDbgTrace(0, Dbg, ("NulMRxExtractNetRootName \n"));
    
    w += (SrvCall->pSrvCallName->Length/sizeof(WCHAR));
    NetRootName->Buffer = wlow = w;
    for (;;) {
        if (w>=wlimit) break;
        if ( (*w == OBJ_NAME_PATH_SEPARATOR) && (w!=wlow) ){
            break;
        }
        w++;
    }
    
    NetRootName->Length = NetRootName->MaximumLength
                = (USHORT)((PCHAR)w - (PCHAR)wlow);
                
    //w = FilePathName->Buffer;
    //NetRootName->Buffer = w++;

    if (!RestOfName) RestOfName = &xRestOfName;
    RestOfName->Buffer = w;
    RestOfName->Length = (USHORT)RestOfName->MaximumLength
                       = (USHORT)((PCHAR)wlimit - (PCHAR)w);

    RxDbgTrace(0, Dbg, ("  NulMRxExtractNetRootName FilePath=%wZ\n",FilePathName));
    RxDbgTrace(0, Dbg, ("         Srv=%wZ,Root=%wZ,Rest=%wZ\n",
                        SrvCall->pSrvCallName,NetRootName,RestOfName));

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\ifskit.mrx\nulmrx\sys\rename.c ===
/*++

Copyright (c) 1989 - 1999 Microsoft Corporation

Module Name:

    rename.c

Abstract:

    This module implements rename in the null minirdr.

--*/

#include "precomp.h"
#pragma hdrstop

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_FILEINFO)


NulMRxRename(
      IN PRX_CONTEXT            RxContext,
      IN FILE_INFORMATION_CLASS FileInformationClass,
      IN PVOID                  pBuffer,
      IN ULONG                  BufferLength)
/*++

Routine Description:

   This routine does a rename. since the real NT-->NT path is not implemented at the server end,
   we implement just the downlevel path.

Arguments:

    RxContext - the RDBSS context
    FILE_INFO_CLASS - must be rename....shouldn't really pass this
    pBuffer - pointer to the new name
    bufferlength - and the size

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_NOT_IMPLEMENTED;
    UNREFERENCED_PARAMETER(RxContext);

    DbgPrint("NulMRxRename \n");
    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\ifskit.mrx\nulmrx\sys\wmlkm.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    wmlkm.h

Abstract:

    Kernel mode definitions for an easy wmi tracing.

Author:

    gorn

Revision History:

Comments:

    Needs to be moved to wmilib\inc when DCR is approved

--*/
#ifndef WMLKM_H
#define WMLKM_H 1

#pragma warning(disable: 4201) // error C4201: nonstandard extension used : nameless struct/union
#include <wmistr.h>
#include <evntrace.h>

#include "wmlmacro.h"
#ifdef __cplusplus
extern "C" {
#endif

#define MAX_TRACE_GUIDS_PER_CONTROL  3

typedef struct _WML_CONTROL_GUID_REG {
    GUID        Guid;
    GUID        TraceGuids[MAX_TRACE_GUIDS_PER_CONTROL];
    ULONG       EnableFlags;
    ULONG       EnableLevel;
    TRACEHANDLE LoggerHandle;
} WML_CONTROL_GUID_REG, *PWML_CONTROL_GUID_REG;

typedef struct _WML_TINY_INFO {
    PWML_CONTROL_GUID_REG    ControlGuids;
    ULONG                    GuidCount;
    PDEVICE_OBJECT           LowerDeviceObject;
    PUNICODE_STRING          DriverRegPath;
} WML_TINY_INFO, *PWML_TINY_INFO;


NTSTATUS
WmlTinySystemControl(
    IN OUT PWML_TINY_INFO WmiLibInfo,
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

ULONG
WmlTrace(
    IN ULONG Type,
    IN LPCGUID TraceGuid,
    IN TRACEHANDLE LoggerHandle,
    ... // Pairs: Address, Length
    );

ULONG
WmlPrintf(
    IN ULONG Type,
    IN LPCGUID TraceGuid,
    IN TRACEHANDLE LoggerHandle,
    IN PCHAR FormatString,
    ... // var args
    );



#ifdef __cplusplus
};
#endif

#endif // WMLKM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\ifskit.mrx\nulmrx\sys\read.c ===
/*++

Copyright (c) 1989 - 1999 Microsoft Corporation

Module Name:

    read.c

Abstract:

    This module implements the mini redirector call down routines pertaining to read
    of file system objects.

--*/

#include "precomp.h"
#pragma hdrstop

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_READ)

NTSTATUS
NulMRxRead(
    IN PRX_CONTEXT RxContext
    )
/*++

Routine Description:

   This routine handles network read requests.

Arguments:

    RxContext - the RDBSS context

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    RxCaptureFcb;
    PLOWIO_CONTEXT LowIoContext  = &RxContext->LowIoContext;
    PVOID pbUserBuffer = NULL;
    ULONG ByteCount = (LowIoContext->ParamsFor).ReadWrite.ByteCount;
    RXVBO ByteOffset = (LowIoContext->ParamsFor).ReadWrite.ByteOffset;
    LONGLONG FileSize = 0;
    NulMRxGetFcbExtension(capFcb,pFcbExtension);
    PMRX_NET_ROOT pNetRoot = capFcb->pNetRoot;
    PNULMRX_NETROOT_EXTENSION pNetRootExtension = pNetRoot->Context;
    BOOLEAN SynchronousIo = !BooleanFlagOn(RxContext->Flags,RX_CONTEXT_FLAG_ASYNC_OPERATION);
    PNULMRX_COMPLETION_CONTEXT pIoCompContext = NulMRxGetMinirdrContext(RxContext);
    PDEVICE_OBJECT deviceObject;

    RxTraceEnter("NulMRxRead");
    RxDbgTrace(0, Dbg, ("NetRoot is 0x%x Fcb is 0x%x\n", pNetRoot, capFcb));

    RxGetFileSizeWithLock((PFCB)capFcb,&FileSize);

    //
    //  NB: This should be done by the wrapper ! It does this
    //  only if READCACHEING is enabled on the FCB !!
    //
    if (!FlagOn(capFcb->FcbState,FCB_STATE_READCACHING_ENABLED)) {

        //
        // If the read starts beyond End of File, return EOF.
        //

        if (ByteOffset >= FileSize) {
            RxDbgTrace( 0, Dbg, ("End of File\n", 0 ));
            Status = STATUS_END_OF_FILE;
            goto Exit;
        }

        //
        //  If the read extends beyond EOF, truncate the read
        //

        if (ByteCount > FileSize - ByteOffset) {
            ByteCount = (ULONG)(FileSize - ByteOffset);
        }
    }
    
    RxDbgTrace(0, Dbg, ("UserBuffer is 0x%x\n", pbUserBuffer ));
    RxDbgTrace(0, Dbg, ("ByteCount is %x ByteOffset is %x\n", ByteCount, ByteOffset ));

    //
    //  Initialize the completion context in the RxContext
    //
    ASSERT( sizeof(*pIoCompContext) == MRX_CONTEXT_SIZE );
    RtlZeroMemory( pIoCompContext, sizeof(*pIoCompContext) );
    
    if( SynchronousIo ) {
        RxDbgTrace(0, Dbg, ("This I/O is sync\n"));
        pIoCompContext->IoType = IO_TYPE_SYNCHRONOUS;
    } else {
        RxDbgTrace(0, Dbg, ("This I/O is async\n"));
        pIoCompContext->IoType = IO_TYPE_ASYNC;
    }

    RxDbgTrace(0, Dbg, ("Status = %x Info = %x\n",RxContext->IoStatusBlock.Status,RxContext->IoStatusBlock.Information));

Exit:

    RxTraceLeave(Status);
    return(Status);
} // NulMRxRead
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\ifskit.mrx\nulmrx\sys\openclos.c ===
/*++

Copyright (c) 1989 - 1999 Microsoft Corporation

Module Name:

    openclos.c

Abstract:

    This module implements the mini redirector call down routines pertaining to opening/
    closing of file/directories.

--*/

#include "precomp.h"
#pragma hdrstop

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_CREATE)

//
//  forwards & pragmas
//

NTSTATUS
NulMRxProcessCreate( 
                IN PNULMRX_FCB_EXTENSION pFcbExtension,
                IN PVOID EaBuffer,
                IN ULONG EaLength,
                OUT PLONGLONG pEndOfFile,
                OUT PLONGLONG pAllocationSize
                );

NTSTATUS
NulMRxCreateFileSuccessTail (
    PRX_CONTEXT     RxContext,
    PBOOLEAN        MustRegainExclusiveResource,
    RX_FILE_TYPE    StorageType,
    ULONG           CreateAction,
    FILE_BASIC_INFORMATION*     pFileBasicInfo,
    FILE_STANDARD_INFORMATION*  pFileStandardInfo
    );

VOID
NulMRxSetSrvOpenFlags (
    PRX_CONTEXT     RxContext,
    RX_FILE_TYPE    StorageType,
    PMRX_SRV_OPEN   SrvOpen
    );
  
#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NulMRxCreate)
#pragma alloc_text(PAGE, NulMRxShouldTryToCollapseThisOpen)
#pragma alloc_text(PAGE, NulMRxProcessCreate)
#pragma alloc_text(PAGE, NulMRxCreateFileSuccessTail)
#pragma alloc_text(PAGE, NulMRxSetSrvOpenFlags)
#endif

NTSTATUS
NulMRxShouldTryToCollapseThisOpen (
    IN PRX_CONTEXT RxContext
    )
/*++

Routine Description:

   This routine determines if the mini knows of a good reason not
   to try collapsing on this open. Presently, the only reason would
   be if this were a copychunk open.

Arguments:

    RxContext - the RDBSS context

Return Value:

    NTSTATUS - The return status for the operation
        SUCCESS --> okay to try collapse
        other (MORE_PROCESSING_REQUIRED) --> dont collapse

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    RxCaptureFcb;

    PAGED_CODE();

    return Status;
}

NTSTATUS
NulMRxCreate(
      IN OUT PRX_CONTEXT RxContext
      )
/*++

Routine Description:

   This routine opens a file across the network

Arguments:

    RxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    BOOLEAN fMustRegainExclusiveResource = FALSE;
    RX_FILE_TYPE StorageType = FileTypeFile;
    ULONG CreateAction = FILE_CREATED;
    LARGE_INTEGER liSystemTime;
    LONGLONG EndOfFile = 0, AllocationSize = 0;
    FILE_BASIC_INFORMATION FileBasicInfo;
    FILE_STANDARD_INFORMATION FileStandardInfo;
    RxCaptureFcb;
    NulMRxGetFcbExtension(capFcb,pFcbExtension);
    RX_BLOCK_CONDITION FinalSrvOpenCondition;
    PMRX_SRV_OPEN SrvOpen = RxContext->pRelevantSrvOpen;
    PMRX_SRV_CALL SrvCall = RxContext->Create.pSrvCall;
    PMRX_NET_ROOT NetRoot = capFcb->pNetRoot;
    PUNICODE_STRING RemainingName = SrvOpen->pAlreadyPrefixedName;
    PVOID EaBuffer = RxContext->Create.EaBuffer;
    ULONG EaLength = RxContext->Create.EaLength;
    ACCESS_MASK DesiredAccess = RxContext->Create.NtCreateParameters.DesiredAccess;
    NulMRxGetNetRootExtension(NetRoot,pNetRootExtension);

    RxTraceEnter("NulMRxCreate");
    PAGED_CODE();
    
    RxDbgTrace(0, Dbg, ("     Attempt to open %wZ Len is %d\n", RemainingName, RemainingName->Length ));
    
    if( NetRoot->Type == NET_ROOT_DISK && NT_SUCCESS(Status) ) {
        RxDbgTrace(0, Dbg, ("NulMRxCreate: Type supported \n"));
            //
            //  Squirrel away the scatter list in the FCB extension.
            //  This is done only for data files.
            //
            Status = NulMRxProcessCreate( 
                                        pFcbExtension,
                                        EaBuffer,
                                        EaLength,
                                        &EndOfFile,
                                        &AllocationSize
                                        );
            if( Status != STATUS_SUCCESS ) {
                //
                //  error..
                //
                RxDbgTrace(0, Dbg, ("Failed to initialize scatter list\n"));
                goto Exit;
            }

        //
        //  Complete CreateFile contract
        //
        RxDbgTrace(0,Dbg,("EOF is %d AllocSize is %d\n",(ULONG)EndOfFile,(ULONG)AllocationSize));
        FileBasicInfo.FileAttributes = FILE_ATTRIBUTE_NORMAL;
        KeQuerySystemTime(&liSystemTime);
        FileBasicInfo.CreationTime = liSystemTime;
        FileBasicInfo.LastAccessTime = liSystemTime;
        FileBasicInfo.LastWriteTime = liSystemTime;
        FileBasicInfo.ChangeTime = liSystemTime;
        FileStandardInfo.AllocationSize.QuadPart = AllocationSize;
        FileStandardInfo.EndOfFile.QuadPart = EndOfFile;
        FileStandardInfo.NumberOfLinks = 0;

        Status = NulMRxCreateFileSuccessTail (    
                                    RxContext,
                                    &fMustRegainExclusiveResource,
                                    StorageType,
                                    CreateAction,
                                    &FileBasicInfo,
                                    &FileStandardInfo
                                    );

        if( Status != STATUS_SUCCESS ) {
            //
            //  alloc error..
            //
            RxDbgTrace(0, Dbg, ("Failed to allocate Fobx \n"));
            goto Exit;
        }
                                    
        if (!RxIsFcbAcquiredExclusive(capFcb)) {
           ASSERT(!RxIsFcbAcquiredShared(capFcb));
           RxAcquireExclusiveFcbResourceInMRx( capFcb );
        }

    } else {
        RxDbgTrace(0, Dbg, ("NulMRxCreate: Type not supported or invalid open\n"));
        Status = STATUS_NOT_IMPLEMENTED;
    }

    ASSERT(Status != (STATUS_PENDING));
    ASSERT(RxIsFcbAcquiredExclusive( capFcb ));

    RxDbgTrace(0, Dbg, ("NetRoot is 0x%x Fcb is 0x%x SrvOpen is 0x%x Fobx is 0x%x\n", 
                    NetRoot,capFcb, SrvOpen,RxContext->pFobx));
    RxDbgTrace(0, Dbg, ("NulMRxCreate exit with status=%08lx\n", Status ));

Exit:

    RxTraceLeave(Status);
    return(Status);
}

NTSTATUS
NulMRxProcessCreate( 
                IN PNULMRX_FCB_EXTENSION pFcbExtension,
                IN PVOID EaBuffer,
                IN ULONG EaLength,
                OUT PLONGLONG pEndOfFile,
                OUT PLONGLONG pAllocationSize
                )
/*++

Routine Description:

    This routine processes a create calldown.
    
Arguments:

    pFcbExtension   -   ptr to the FCB extension
    EaBuffer        -   ptr to the EA param buffer
    EaLength        -   len of EaBuffer
    pEndOfFile      -   return end of file value
    pAllocationSize -   return allocation size (which maybe > EOF)

Notes:

    It is possible to create a file with no EAs
    
Return Value:

    None

--*/
{
    NTSTATUS            Status = STATUS_SUCCESS;
    RxDbgTrace(0, Dbg, ("NulMRxInitializeFcbExtension\n"));

    *pAllocationSize = *pEndOfFile = 0;
    return Status;
}

VOID
NulMRxSetSrvOpenFlags (
    PRX_CONTEXT  RxContext,
    RX_FILE_TYPE StorageType,
    PMRX_SRV_OPEN SrvOpen
    )
{
    PMRX_SRV_CALL SrvCall = (PMRX_SRV_CALL)RxContext->Create.pSrvCall;

    //
    //  set this only if cache manager will be used for mini-rdr handles !
    //
    SrvOpen->BufferingFlags |= (FCB_STATE_WRITECACHING_ENABLED  |
                                FCB_STATE_FILESIZECACHEING_ENABLED |
                                FCB_STATE_FILETIMECACHEING_ENABLED |
                                FCB_STATE_WRITEBUFFERING_ENABLED |
                                FCB_STATE_LOCK_BUFFERING_ENABLED |
                                FCB_STATE_READBUFFERING_ENABLED  |
                                FCB_STATE_READCACHING_ENABLED);
}

NTSTATUS
NulMRxCreateFileSuccessTail (
    PRX_CONTEXT  RxContext,
    PBOOLEAN MustRegainExclusiveResource,
    RX_FILE_TYPE StorageType,
    ULONG CreateAction,
    FILE_BASIC_INFORMATION* pFileBasicInfo,
    FILE_STANDARD_INFORMATION* pFileStandardInfo
    )
/*++

Routine Description:

    This routine finishes the initialization of the fcb and srvopen for a 
successful open.

Arguments:


Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    RxCaptureFcb;
    PMRX_SRV_OPEN SrvOpen = RxContext->pRelevantSrvOpen;

    FCB_INIT_PACKET InitPacket;

    RxDbgTrace(0, Dbg, ("MRxExCreateFileSuccessTail\n"));
    PAGED_CODE();

    ASSERT( NodeType(SrvOpen) == RDBSS_NTC_SRVOPEN );
    ASSERT( NodeType(RxContext) == RDBSS_NTC_RX_CONTEXT );

    if (*MustRegainExclusiveResource) {        //this is required because of oplock breaks
        RxAcquireExclusiveFcbResourceInMRx( capFcb );
        *MustRegainExclusiveResource = FALSE;
    }

    // This Fobx should be cleaned up by the wrapper
    RxContext->pFobx = RxCreateNetFobx( RxContext, SrvOpen);
    if( RxContext->pFobx == NULL ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    
    ASSERT  ( RxIsFcbAcquiredExclusive ( capFcb )  );
    RxDbgTrace(0, Dbg, ("Storagetype %08lx/Action %08lx\n", StorageType, CreateAction ));

    RxContext->Create.ReturnedCreateInformation = CreateAction;

    RxFormInitPacket(
        InitPacket,
        &pFileBasicInfo->FileAttributes,
        &pFileStandardInfo->NumberOfLinks,
        &pFileBasicInfo->CreationTime,
        &pFileBasicInfo->LastAccessTime,
        &pFileBasicInfo->LastWriteTime,
        &pFileBasicInfo->ChangeTime,
        &pFileStandardInfo->AllocationSize,
        &pFileStandardInfo->EndOfFile,
        &pFileStandardInfo->EndOfFile);

    if (capFcb->OpenCount == 0) {
        RxFinishFcbInitialization( capFcb,
                                   RDBSS_STORAGE_NTC(StorageType),
                                   &InitPacket
                                 );
    } else {

        ASSERT( StorageType == 0 || NodeType(capFcb) ==  RDBSS_STORAGE_NTC(StorageType));

    }

    NulMRxSetSrvOpenFlags(RxContext,StorageType,SrvOpen);

    RxContext->pFobx->OffsetOfNextEaToReturn = 1;
    //transition happens later

    return Status;
}

NTSTATUS
NulMRxCollapseOpen(
      IN OUT PRX_CONTEXT RxContext
      )
/*++

Routine Description:

   This routine collapses a open locally

Arguments:

    RxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status;

    RxCaptureFcb;
    RxCaptureRequestPacket;

    PMRX_SRV_OPEN SrvOpen = RxContext->pRelevantSrvOpen;
    PMRX_SRV_CALL SrvCall = RxContext->Create.pSrvCall;
    PMRX_NET_ROOT NetRoot = capFcb->pNetRoot;

    RxTraceEnter("NulMRxCollapseOpen");
    RxContext->pFobx = (PMRX_FOBX)RxCreateNetFobx( RxContext, SrvOpen);

    if (RxContext->pFobx != NULL) {
       ASSERT  ( RxIsFcbAcquiredExclusive ( capFcb )  );
       RxContext->pFobx->OffsetOfNextEaToReturn = 1;
       capReqPacket->IoStatus.Information = FILE_OPENED;
       Status = STATUS_SUCCESS;
    } else {
       Status = (STATUS_INSUFFICIENT_RESOURCES);
       DbgBreakPoint();
    }

    RxTraceLeave(Status);
    return Status;
}

NTSTATUS
NulMRxComputeNewBufferingState(
   IN OUT PMRX_SRV_OPEN   pMRxSrvOpen,
   IN     PVOID           pMRxContext,
      OUT PULONG          pNewBufferingState)
/*++

Routine Description:

   This routine maps specific oplock levels into the appropriate RDBSS
   buffering state flags

Arguments:

   pMRxSrvOpen - the MRX SRV_OPEN extension

   pMRxContext - the context passed to RDBSS at Oplock indication time

   pNewBufferingState - the place holder for the new buffering state

Return Value:


Notes:

--*/
{
    NTSTATUS Status = STATUS_NOT_IMPLEMENTED;

    DbgPrint("NulMRxComputeNewBufferingState \n");
    return(Status);
}

NTSTATUS
NulMRxDeallocateForFcb (
    IN OUT PMRX_FCB pFcb
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    NulMRxGetFcbExtension(pFcb,pFcbExtension);
    PMRX_NET_ROOT         pNetRoot = pFcb->pNetRoot;
    NulMRxGetNetRootExtension(pNetRoot,pNetRootExtension);

    RxTraceEnter("NulMRxDeallocateForFcb\n");

    RxTraceLeave(Status);
    return(Status);
}

NTSTATUS
NulMRxTruncate(
      IN PRX_CONTEXT pRxContext)
/*++

Routine Description:

   This routine truncates the contents of a file system object

Arguments:

    pRxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
   ASSERT(!"Found a truncate");
   return STATUS_NOT_IMPLEMENTED;
}

NTSTATUS
NulMRxCleanupFobx(
      IN PRX_CONTEXT RxContext)
/*++

Routine Description:

   This routine cleansup a file system object...normally a noop. unless it's a pipe in which case
   we do the close at cleanup time and mark the file as being not open.

Arguments:

    pRxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PUNICODE_STRING RemainingName;
    RxCaptureFcb; RxCaptureFobx;

    NODE_TYPE_CODE TypeOfOpen = NodeType(capFcb);

    PMRX_SRV_OPEN SrvOpen = capFobx->pSrvOpen;

    BOOLEAN SearchHandleOpen = FALSE;

    PAGED_CODE();

    ASSERT( NodeType(SrvOpen) == RDBSS_NTC_SRVOPEN );
    ASSERT ( NodeTypeIsFcb(capFcb) );

    RxDbgTrace( 0, Dbg, ("NulMRxCleanupFobx\n"));

    if (FlagOn(capFcb->FcbState,FCB_STATE_ORPHANED)) {
       RxDbgTrace( 0, Dbg, ("File orphaned\n"));
       return (STATUS_SUCCESS);
    }

    if ((capFcb->pNetRoot->Type != NET_ROOT_PIPE) && !SearchHandleOpen) {
       RxDbgTrace( 0, Dbg, ("File not for closing at cleanup\n"));
       return (STATUS_SUCCESS);
    }

    RxDbgTrace( 0, Dbg, ("NulMRxCleanup  exit with status=%08lx\n", Status ));

    return(Status);
}

NTSTATUS
NulMRxForcedClose(
      IN PMRX_SRV_OPEN pSrvOpen)
/*++

Routine Description:

   This routine closes a file system object

Arguments:

    pSrvOpen - the instance to be closed

Return Value:

    RXSTATUS - The return status for the operation

Notes:



--*/
{
    RxDbgTrace( 0, Dbg, ("NulMRxForcedClose\n"));
    return STATUS_SUCCESS;
}

//
//  The local debug trace level
//

#undef  Dbg
#define Dbg                              (DEBUG_TRACE_CLOSE)

NTSTATUS
NulMRxCloseSrvOpen(
      IN     PRX_CONTEXT   RxContext
      )
/*++

Routine Description:

   This routine closes a file across the network

Arguments:

    RxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    
    RxCaptureFcb;
    RxCaptureFobx;

    PMRX_SRV_OPEN   pSrvOpen = capFobx->pSrvOpen;
    PUNICODE_STRING RemainingName = pSrvOpen->pAlreadyPrefixedName;
    PMRX_SRV_OPEN   SrvOpen;
    NODE_TYPE_CODE  TypeOfOpen = NodeType(capFcb);
    PMRX_NET_ROOT   pNetRoot = capFcb->pNetRoot;
    NulMRxGetNetRootExtension(pNetRoot,pNetRootExtension);

    RxDbgTrace( 0, Dbg, ("NulMRxCloseSrvOpen \n"));
    SrvOpen    = capFobx->pSrvOpen;

    return(Status);
}

NTSTATUS
NulMRxDeallocateForFobx (
    IN OUT PMRX_FOBX pFobx
    )
{
    RxDbgTrace( 0, Dbg, ("NulMRxDeallocateForFobx\n"));
    return(STATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\ifskit.mrx\nulmrx\sys\sources.inc ===
!IF 0

Copyright (c) 1989 - 1999 Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.



!ENDIF

!INCLUDE .\master.src

TARGETNAME=nulmrx
TARGETPATH=obj
TARGETTYPE=EXPORT_DRIVER

SYNCHRONIZE_DRAIN=1

INCLUDES=$(INCLUDES); \
    	 $(IFSKIT_INC_PATH);

# @@BEGIN_DDKSPLIT
!IF 0
# @@END_DDKSPLIT

TARGETLIBS=$(DDK_LIB_PATH)\ksecdd.lib	\
           $(DDK_LIB_PATH)\rdbsslib.lib


# @@BEGIN_DDKSPLIT
!ENDIF

RDR2=$(PROJECT_ROOT)\fs\rdr2

INCLUDES=$(INCLUDES); \
    	 $(RDR2)\inc;

TARGETLIBS=$(RDR2)\rdbss\monolithic\obj\*\rdbsslib.lib	\
           $(DDK_LIB_PATH)\ksecdd.lib

# @@END_DDKSPLIT

#NTLAYGO=1

MSC_WARNING_LEVEL=/W3 /WX
C_DEFINES= $(C_DEFINES) -DEXPLODE_POOLTAGS
!IF $(MONOLITHIC_MINIRDR)
C_DEFINES=$(C_DEFINES) -DMONOLITHIC_MINIRDR
!ENDIF

MOST_SOURCES=  \
    devfcb.c   \
    fileinfo.c \
    init.c     \
    locks.c    \
    netroot.c  \
    ea.c       \
    devctrl.c  \
    notimpl.c  \
    openclos.c \
    read.c     \
    rename.c   \
    srvcall.c  \
    write.c    \
    downlvli.c \
    wmlkm.c

PRECOMPILED_INCLUDE=precomp.h
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj

DLLDEF=$(_OBJ_DIR)\*\nulmrx.def



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\ifskit.mrx\nulmrx\sys\transprt.c ===
/*++

Copyright (c) 1989 - 1999 Microsoft Corporation

Module Name:

    transport.c

Abstract:

    This module implements all transport related functions in the SMB connection engine

--*/

#include "precomp.h"
#pragma hdrstop


NTSTATUS
NulMRxInitializeTransport()
/*++

Routine Description:

    This routine initializes the transport related data structures

Returns:

    STATUS_SUCCESS if the transport data structures was successfully initialized

Notes:

--*/
{
   return STATUS_SUCCESS;
}


NTSTATUS
NulMRxUninitializeTransport()
/*++

Routine Description:

    This routine uninitializes the transport related data structures

Notes:

--*/
{
   return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\ifskit.mrx\smbmrx\dll\dllmain.c ===
/*++

Copyright (c) 1989-1997  Microsoft Corporation

Module Name:

    dllmain.c

Abstract:

    This module implements the initialization routines for network
    provider interface

Notes:

    This module has been builkt and tested only in UNICODE environment

--*/

#include <windows.h>


// NOTE:
//
// Function:    DllMain
//
// Return:  TRUE  => Success
//      FALSE => Failure

BOOL WINAPI DllMain(HINSTANCE hDLLInst, DWORD fdwReason, LPVOID lpvReserved)
{
    BOOL    bStatus = TRUE;
    WORD    wVersionRequested;

    switch (fdwReason) {
    case DLL_PROCESS_ATTACH:
        break;

    case DLL_PROCESS_DETACH:
        break;

    case DLL_THREAD_ATTACH:
        break;

    case DLL_THREAD_DETACH:
        break;

    default:
        break;
    }

    return(bStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\ifskit.mrx\smbmrx\dll\smbmrxnp.h ===
/*++

Copyright (c) 1989-1997  Microsoft Corporation

Module Name:

    ifsmrxnp.h

Abstract:

    This module includes all network provider router interface related
    definitions for the sample

Notes:

    This module has been built and tested only in UNICODE environment

--*/

#ifndef _IFSMRXNP_H_
#define _IFSMRXNP_H_

#define IFSMRXNP_DEBUG_CALL     0x1
#define IFSMRXNP_DEBUG_ERROR    0x2
#define IFSMRXNP_DEBUG_INFO     0x4

extern DWORD IfsMRxNpDebugLevel;

#define TRACE_CALL(Args)    \
            if (IfsMRxNpDebugLevel & IFSMRXNP_DEBUG_CALL) {    \
                DbgPrint##Args;                 \
            }

#define TRACE_ERROR(Args)    \
            if (IfsMRxNpDebugLevel & IFSMRXNP_DEBUG_ERROR) {    \
                DbgPrint##Args;                 \
            }

#define TRACE_INFO(Args)    \
            if (IfsMRxNpDebugLevel & IFSMRXNP_DEBUG_INFO) {    \
                DbgPrint##Args;                 \
            }

typedef struct _IFSMRXNP_ENUMERATION_HANDLE_ {
    INT  LastIndex;
} IFSMRXNP_ENUMERATION_HANDLE,
  *PIFSMRXNP_ENUMERATION_HANDLE;

extern BOOL InitializeSharedMemory();
extern VOID UninitializeSharedMemory();

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\ifskit.mrx\smbmrx\exe\resource.h ===
// Used by smbrdr.rc
//
#define IDD_SMBRDR                      101
#define IDD_STATISTICS                  102
#define IDD_PROVIDER                    103
#define IDI_SMBRDR                      104
#define IDR_OPMENU                      105

#define IDC_DRVLOAD                     1000
#define IDC_DRVUNLOAD                   1001
#define IDC_RDRSTART                    1002
#define IDC_RDRSTOP                     1003
#define IDC_BUTTON1                     1004
#define IDC_PROVIDER                    1004
#define IDC_BUTTON2                     1005
#define IDC_STATISTICS                  1005
#define IDC_EDIT1                       1006
#define IDC_EDIT2                       1007
#define IDC_EDIT3                       1008
#define IDC_EDIT4                       1009
#define IDC_EDIT5                       1010
#define IDC_EDIT6                       1011
#define IDC_ORDERLIST                   1012
#define IDC_SETORDER					1013
#define IDC_EDIT7                       1015
#define IDC_EDIT8                       1016
#define IDC_DRVCONTROLTEXT				1017
#define IDC_RDRCONTROLTEXT				1018
#define IDC_SETTINGSTEXT				1019
#define IDC_LOADSTATUS					1020
#define IDC_STARTSTATUS					1021
#define IDC_STARTTIME					1022
#define IDC_HIDE						1023
#define IDC_BUSY						1024
#define IDC_MOVEUP						1025
#define IDC_MOVEDN						1026


#define IDM_OPEN						101
#define	IDM_CLOSE						102
#define	IDM_START						103
#define	IDM_STOP						104
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\ifskit.mrx\smbmrx\dll\smbmrxnp.c ===
/*++

Copyright (c) 1989-1999  Microsoft Corporation

Module Name:

    smbmrxnp.c

Abstract:

    This module implements the routines required for interaction with network
    provider router interface in NT

Notes:

    This module has been builkt and tested only in UNICODE environment

--*/


#include <windows.h>
#include <windef.h>
#include <winbase.h>
#include <winsvc.h>
#include <winnetwk.h>
#include <npapi.h>

#include <lmwksta.h>
#include <devioctl.h>
// include files from the smb inc directory

#include <smbmrx.h>

#ifndef UNICODE_STRING
typedef struct _UNICODE_STRING {
    USHORT Length;
    USHORT MaximumLength;
    PWSTR  Buffer;
} UNICODE_STRING;
typedef UNICODE_STRING *PUNICODE_STRING;
#endif

#ifndef FILE_FULL_EA_INFORMATION
typedef struct _FILE_FULL_EA_INFORMATION {
    ULONG NextEntryOffset;
    UCHAR Flags;
    UCHAR EaNameLength;
    USHORT EaValueLength;
    CHAR EaName[1];
} FILE_FULL_EA_INFORMATION, *PFILE_FULL_EA_INFORMATION;
#endif

#define MAX_EA_NAME_LEN     sizeof("UserName\0")
#define MAX_CONNECT_INFO_SIZE \
                            3 * sizeof(FILE_FULL_EA_INFORMATION) + \
                            sizeof(SMBMRX_CONNECTINFO) + \
                            4 * MAX_PATH + \
                            3 * MAX_EA_NAME_LEN

typedef struct _SMBMRXNP_ENUMERATION_HANDLE_ {
    INT  LastIndex;
} SMBMRXNP_ENUMERATION_HANDLE,
  *PSMBMRXNP_ENUMERATION_HANDLE;

#ifdef DBG
#define DbgP(_x_) DbgPrint _x_
#else
#define DbgP(_x_)
#endif

ULONG _cdecl DbgPrint( LPTSTR Format, ... );

#define TRACE_TAG   L"SMBMRXNP:    "


// The debug level for this module



// the SMB mini redirector and provider name. The original constants
// are defined in smbmrx.h

UNICODE_STRING SmbMRxDeviceName = {
    sizeof(DD_SMBMRX_FS_DEVICE_NAME_U),
    sizeof(DD_SMBMRX_FS_DEVICE_NAME_U),
    DD_SMBMRX_FS_DEVICE_NAME_U
                                  };

UNICODE_STRING SmbMrxProviderName = {
    sizeof(SMBMRX_PROVIDER_NAME_U),
    sizeof(SMBMRX_PROVIDER_NAME_U),
    SMBMRX_PROVIDER_NAME_U
                                    };


DWORD
OpenSharedMemory(
    PHANDLE phMutex,
    PHANDLE phMemory,
    PVOID   *pMemory
)
/*++

Routine Description:

    This routine opens the shared memory for exclusive manipulation

Arguments:

    phMutex - the mutex handle

    phMemory - the memory handle

    pMemory - a ptr. to the shared memory which is set if successful

Return Value:

    WN_SUCCESS -- if successful

--*/
{
    DWORD   dwStatus;

    DbgP((TEXT("OpenSharedMemory\n")));

    *phMutex = 0;
    *phMemory = 0;
    *pMemory = NULL;

    *phMutex = OpenMutex(SYNCHRONIZE,
                         FALSE,
                         SMBMRXNP_MUTEX_NAME);

    if (*phMutex == NULL)
    {
        dwStatus = GetLastError();
        DbgP((TEXT("OpenSharedMemory:  OpenMutex failed\n")));
        goto OpenSharedMemoryAbort1;
    }

    DbgP((TEXT("OpenSharedMemory:  Calling WaitForSingleObject\n")));
    WaitForSingleObject(*phMutex, INFINITE);

    *phMemory = OpenFileMapping(FILE_MAP_WRITE,
                                FALSE,
                                SMBMRXNP_SHARED_MEMORY_NAME);

    if (*phMemory == NULL)
    {
        dwStatus = GetLastError();
        DbgP((TEXT("OpenSharedMemory:  OpenFileMapping failed\n")));
        goto OpenSharedMemoryAbort2;
    }

    *pMemory = MapViewOfFile(*phMemory, FILE_MAP_WRITE, 0, 0, 0);
    if (*pMemory == NULL)
    {
        dwStatus = GetLastError();
        DbgP((TEXT("OpenSharedMemory:  MapViewOfFile failed\n")));
        goto OpenSharedMemoryAbort3;
    }

    DbgP((TEXT("OpenSharedMemory: return ERROR_SUCCESS\n")));

    return ERROR_SUCCESS;

OpenSharedMemoryAbort3:
    CloseHandle(*phMemory);

OpenSharedMemoryAbort2:
    ReleaseMutex(*phMutex);
    CloseHandle(*phMutex);
    *phMutex = NULL;

OpenSharedMemoryAbort1:
    DbgP((TEXT("OpenSharedMemory: return dwStatus: %d\n"), dwStatus));

    return dwStatus;
}


VOID
CloseSharedMemory(
    PHANDLE  hMutex,
    PHANDLE  hMemory,
    PVOID   *pMemory )
/*++

Routine Description:

    This routine relinquishes control of the shared memory after exclusive
    manipulation

Arguments:

    hMutex - the mutex handle

    hMemory  - the memory handle

    pMemory - a ptr. to the shared memory which is set if successful

Return Value:

--*/
{
    DbgP((TEXT("CloseSharedMemory\n")));
    if (*pMemory)
    {
        UnmapViewOfFile(*pMemory);
        *pMemory = NULL;
    }
    if (*hMemory)
    {
        CloseHandle(*hMemory);
        *hMemory = 0;
    }
    if (*hMutex)
    {
        if (ReleaseMutex(*hMutex) == FALSE)
        {
            DbgP((TEXT("CloseSharedMemory: ReleaseMutex error: %d\n"), GetLastError()));
        }
        CloseHandle(*hMutex);
        *hMutex = 0;
    }
    DbgP((TEXT("CloseSharedMemory: Return\n")));
}


DWORD APIENTRY
NPGetCaps(
    DWORD nIndex )
/*++

Routine Description:

    This routine returns the capabilities of the SMB Mini redirector
    network provider implementation

Arguments:

    nIndex - category of capabilities desired

Return Value:

    the appropriate capabilities

--*/
{
    switch (nIndex)
    {
        case WNNC_SPEC_VERSION:
            return WNNC_SPEC_VERSION51;

        case WNNC_NET_TYPE:
            return WNNC_NET_RDR2_SAMPLE;

        case WNNC_DRIVER_VERSION:
#define WNNC_DRIVER(major,minor) (major*0x00010000 + minor)
            return WNNC_DRIVER(1, 0);


        case WNNC_CONNECTION:
            return WNNC_CON_GETCONNECTIONS | WNNC_CON_CANCELCONNECTION |
                   WNNC_CON_ADDCONNECTION | WNNC_CON_ADDCONNECTION3;

        case WNNC_ENUMERATION:
            return WNNC_ENUM_LOCAL;

        case WNNC_START:
        case WNNC_USER:
        case WNNC_DIALOG:
        case WNNC_ADMIN:
        default:
            return 0;
    }
}

DWORD APIENTRY
NPLogonNotify(
    PLUID   lpLogonId,
    LPCWSTR lpAuthentInfoType,
    LPVOID  lpAuthentInfo,
    LPCWSTR lpPreviousAuthentInfoType,
    LPVOID  lpPreviousAuthentInfo,
    LPWSTR  lpStationName,
    LPVOID  StationHandle,
    LPWSTR  *lpLogonScript)
/*++

Routine Description:

    This routine handles the logon notifications

Arguments:

    lpLogonId -- the associated LUID

    lpAuthenInfoType - the authentication information type

    lpAuthenInfo  - the authentication Information

    lpPreviousAuthentInfoType - the previous aunthentication information type

    lpPreviousAuthentInfo - the previous authentication information

    lpStationName - the logon station name

    LPVOID - logon station handle

    lpLogonScript - the logon script to be executed.

Return Value:

    WN_SUCCESS

Notes:

    This capability has not been implemented in the sample.

--*/
{
    *lpLogonScript = NULL;

    return WN_SUCCESS;
}

DWORD APIENTRY
NPPasswordChangeNotify (
    LPCWSTR lpAuthentInfoType,
    LPVOID  lpAuthentInfo,
    LPCWSTR lpPreviousAuthentInfoType,
    LPVOID  lpPreviousAuthentInfo,
    LPWSTR  lpStationName,
    LPVOID  StationHandle,
    DWORD   dwChangeInfo )
/*++

Routine Description:

    This routine handles the password change notifications

Arguments:

    lpAuthenInfoType - the authentication information type

    lpAuthenInfo  - the authentication Information

    lpPreviousAuthentInfoType - the previous aunthentication information type

    lpPreviousAuthentInfo - the previous authentication information

    lpStationName - the logon station name

    LPVOID - logon station handle

    dwChangeInfo - the password change information.

Return Value:

    WN_NOT_SUPPORTED

Notes:

    This capability has not been implemented in the sample.

--*/
{
    SetLastError(WN_NOT_SUPPORTED);
    return WN_NOT_SUPPORTED;
}

DWORD APIENTRY
NPOpenEnum(
    DWORD          dwScope,
    DWORD          dwType,
    DWORD          dwUsage,
    LPNETRESOURCE  lpNetResource,
    LPHANDLE       lphEnum )
/*++

Routine Description:

    This routine opens a handle for enumeration of resources. The only capability
    implemented in the sample is for enumerating connected shares

Arguments:

    dwScope - the scope of enumeration

    dwType  - the type of resources to be enumerated

    dwUsage - the usage parameter

    lpNetResource - a pointer to the desired NETRESOURCE struct.

    lphEnum - aptr. for passing nack the enumeration handle

Return Value:

    WN_SUCCESS if successful, otherwise the appropriate error

Notes:

    The sample only supports the notion of enumerating connected shares

    The handle passed back is merely the index of the last entry returned

--*/
{
    DWORD   Status = 0;

    DbgP((TEXT("NPOpenEnum\n")));

    *lphEnum = NULL;

    switch (dwScope)
    {
        case RESOURCE_CONNECTED:
        {
            *lphEnum = LocalAlloc(
                            LMEM_ZEROINIT,
                            sizeof(SMBMRXNP_ENUMERATION_HANDLE));

            if (*lphEnum != NULL)
            {
                Status = WN_SUCCESS;
            }
            else
            {
                Status = WN_OUT_OF_MEMORY;
            }
            break;
        }
        break;
        
        case RESOURCE_CONTEXT:
        default:
            Status  = WN_NOT_SUPPORTED;
            break;
    }


    DbgP((TEXT("NPOpenEnum returning Status %lx\n"),Status));

    return(Status);
}

DWORD APIENTRY
NPEnumResource(
    HANDLE  hEnum,
    LPDWORD lpcCount,
    LPVOID  lpBuffer,
    LPDWORD lpBufferSize)
/*++

Routine Description:

    This routine uses the handle obtained by a call to NPOpenEnum for
    enuerating the connected shares

Arguments:

    hEnum  - the enumeration handle

    lpcCount - the number of resources returned

    lpBuffer - the buffere for passing back the entries

    lpBufferSize - the size of the buffer

Return Value:

    WN_SUCCESS if successful, otherwise the appropriate error

    WN_NO_MORE_ENTRIES - if the enumeration has exhausted the entries

    WN_MORE_DATA - if nmore data is available

Notes:

    The sample only supports the notion of enumerating connected shares

    The handle passed back is merely the index of the last entry returned

--*/
{
    DWORD           Status = WN_SUCCESS;
    LPNETRESOURCEW  pBufferResource;
    DWORD           StringOffset;
    DWORD           AvailableBufferSize;
    HANDLE          hMutex, hMemory;

    PSMBMRXNP_ENUMERATION_HANDLE    pEnumHandle;
    PSMBMRXNP_SHARED_MEMORY         pSharedMemory;

    DbgP((TEXT("NPEnumResource\n")));

    DbgP((TEXT("NPEnumResource Count Requested %d\n"),*lpcCount));

    AvailableBufferSize = *lpBufferSize;
    StringOffset        = *lpBufferSize;
    pBufferResource     = (LPNETRESOURCEW)lpBuffer;

    pEnumHandle = (PSMBMRXNP_ENUMERATION_HANDLE)hEnum;

    *lpcCount = 0;

    if (pEnumHandle->LastIndex >= SMBMRXNP_MAX_DEVICES)
    {
        return WN_NO_MORE_ENTRIES;
    }

    Status = OpenSharedMemory(
                &hMutex,
                &hMemory,
                (PVOID)&pSharedMemory);

    if (Status == WN_SUCCESS)
    {
        INT  Index;
        PSMBMRXNP_NETRESOURCE pNetResource;

        DbgP((TEXT("NPEnumResource: Highest Index %d Number Of resources %d\n"),
                    pSharedMemory->HighestIndexInUse,pSharedMemory->NumberOfResourcesInUse));

        for (Index = pEnumHandle->LastIndex; Index <= pSharedMemory->HighestIndexInUse; Index++) {
            pNetResource = &pSharedMemory->NetResources[Index];

            DbgP((TEXT("NPEnumResource: Examining Index %d\n"),Index));

            if (pNetResource->InUse)
            {
                DWORD ResourceSize;

                ResourceSize = sizeof(NETRESOURCE) +
                               pNetResource->LocalNameLength + sizeof(WCHAR) +
                               pNetResource->RemoteNameLength + sizeof(WCHAR) +
                               SmbMrxProviderName.Length + sizeof(WCHAR);

                if (AvailableBufferSize >= ResourceSize)
                {
                    *lpcCount =  *lpcCount + 1;
                    AvailableBufferSize -= ResourceSize;

                    pBufferResource->dwScope       = RESOURCE_CONNECTED;
                    pBufferResource->dwType        = pNetResource->dwType;
                    pBufferResource->dwDisplayType = pNetResource->dwDisplayType;
                    pBufferResource->dwUsage       = pNetResource->dwUsage;

                    DbgP((TEXT("NPEnumResource: Copying local name Index %d\n"),Index));

                    // set up the strings in the resource
                    StringOffset -= (pNetResource->LocalNameLength + sizeof(WCHAR));
                    pBufferResource->lpLocalName =  (PWCHAR)((PBYTE)lpBuffer + StringOffset);

                    CopyMemory(pBufferResource->lpLocalName,
                               pNetResource->LocalName,
                               pNetResource->LocalNameLength);

                    pBufferResource->lpLocalName[
                        pNetResource->LocalNameLength/sizeof(WCHAR)] = L'\0';

                    DbgP((TEXT("NPEnumResource: Copying remote name Index %d\n"),Index));

                    StringOffset -= (pNetResource->RemoteNameLength + sizeof(WCHAR));
                    pBufferResource->lpRemoteName =  (PWCHAR)((PBYTE)lpBuffer + StringOffset);

                    CopyMemory(pBufferResource->lpRemoteName,
                               pNetResource->RemoteName,
                               pNetResource->RemoteNameLength);

                    pBufferResource->lpRemoteName[
                        pNetResource->RemoteNameLength/sizeof(WCHAR)] = L'\0';

                    DbgP((TEXT("NPEnumResource: Copying provider name Index %d\n"),Index));

                    StringOffset -= (SmbMrxProviderName.Length + sizeof(WCHAR));
                    pBufferResource->lpProvider =  (PWCHAR)((PBYTE)lpBuffer + StringOffset);

                    CopyMemory(pBufferResource->lpProvider,
                               SmbMrxProviderName.Buffer,
                               SmbMrxProviderName.Length);

                    pBufferResource->lpProvider[
                        SmbMrxProviderName.Length/sizeof(WCHAR)] = L'\0';

                    pBufferResource->lpComment = NULL;

                    pBufferResource++;
                }
                else
                {
                    DbgP((TEXT("NPEnumResource: Buffer Overflow Index %d\n"),Index));
                    Status = WN_MORE_DATA;
                    break;
                }
            }
        }

        pEnumHandle->LastIndex = Index;

        if ((Status == WN_SUCCESS) &&
            (pEnumHandle->LastIndex > pSharedMemory->HighestIndexInUse) &&
            (*lpcCount == 0))
        {
            Status = WN_NO_MORE_ENTRIES;
        }

        CloseSharedMemory(
            &hMutex,
            &hMemory,
            (PVOID)&pSharedMemory);
    }

    DbgP((TEXT("NPEnumResource returning Count %d\n"),*lpcCount));

    DbgP((TEXT("NPEnumResource returning Status %lx\n"),Status));

    return Status;
}

DWORD APIENTRY
NPCloseEnum(
    HANDLE hEnum )
/*++

Routine Description:

    This routine closes the handle for enumeration of resources.

Arguments:

    hEnum  - the enumeration handle

Return Value:

    WN_SUCCESS if successful, otherwise the appropriate error

Notes:

    The sample only supports the notion of enumerating connected shares

--*/
{
    DbgP((TEXT("NPCloseEnum\n")));

    LocalFree(hEnum);

    return WN_SUCCESS;
}


ULONG
SendToMiniRdr(
    IN ULONG            IoctlCode,
    IN PVOID            InputDataBuf,
    IN ULONG            InputDataLen,
    IN PVOID            OutputDataBuf,
    IN PULONG           pOutputDataLen)
/*++

Routine Description:

    This routine sends a device ioctl to the Mini Rdr.

Arguments:

    IoctlCode       - Function code for the Mini Rdr driver

    InputDataBuf    - Input buffer pointer

    InputDataLen    - Lenth of the input buffer

    OutputDataBuf   - Output buffer pointer

    pOutputDataLen  - Pointer to the length of the output buffer

Return Value:

    WN_SUCCESS if successful, otherwise the appropriate error

Notes:

--*/
{
    HANDLE  DeviceHandle;       // The mini rdr device handle
    ULONG   BytesRet;
    BOOL    rc;
    ULONG   Status;

    Status = WN_SUCCESS;

    // Grab a handle to the redirector device object

    DeviceHandle = CreateFile(
        DD_SMBMRX_USERMODE_DEV_NAME,
        GENERIC_READ | GENERIC_WRITE,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        (LPSECURITY_ATTRIBUTES)NULL,
        OPEN_EXISTING,
        0,
        (HANDLE) NULL );

    if ( INVALID_HANDLE_VALUE != DeviceHandle )
    {
        rc = DeviceIoControl( DeviceHandle,
                              IoctlCode,
                              InputDataBuf,
                              InputDataLen,
                              OutputDataBuf,
                              *pOutputDataLen,
                              pOutputDataLen,
                              NULL );

            if ( !rc )
            {
                DbgP(( L"SendToMiniRdr - returning error from DeviceIoctl\n" ));
                Status = GetLastError( );
            }
            else
            {
                DbgP(( L"SendToMiniRdr - The DeviceIoctl call succeded\n" ));
            }
            CloseHandle(DeviceHandle);
    }
    else
    {
        Status = GetLastError( );
        DbgP(( L"SendToMiniRdr - error %lx opening device \n", Status ));
    }

    return Status;
}


ULONG FillInEaBuffer( LPTSTR pUserName, LPTSTR pPassword, PBYTE pEaData )
{
    PFILE_FULL_EA_INFORMATION thisEa = (PFILE_FULL_EA_INFORMATION) pEaData;

    PBYTE               valuePtr = pEaData;
    PWKSTA_INFO_100     WkStaInfo;
    ULONG               status;
    PWCHAR              pDomain;

    // get the domain that this workstation is a member of
    status = NetWkstaGetInfo( NULL, 100, (PBYTE *) &WkStaInfo );
    if ( status == ERROR_SUCCESS )
    {
        pDomain = WkStaInfo->wki100_langroup;
    }
    else
    {
        pDomain = NULL;
    }


    DbgP((L"FillInEaBuffer - domain name=%s\n", pDomain));

    thisEa->EaValueLength   = 0;
    thisEa->NextEntryOffset = 0;

    // Set the user name EA
    if ( pUserName )
    {
        thisEa->Flags = 0;
        thisEa->EaNameLength = sizeof("UserName");
        CopyMemory( thisEa->EaName, "UserName\0", thisEa->EaNameLength + 1 );
        valuePtr = (PBYTE) thisEa->EaName + thisEa->EaNameLength + 1;
        thisEa->EaValueLength = (USHORT)( *pUserName ? lstrlenW( pUserName ) : 1 ) * sizeof( WCHAR );
        CopyMemory( valuePtr, pUserName, thisEa->EaValueLength );
        thisEa->NextEntryOffset = (ULONG)(((PBYTE) valuePtr + thisEa->EaValueLength ) -
                                   (PBYTE) thisEa);
        thisEa->NextEntryOffset = ((thisEa->NextEntryOffset + 3) / sizeof(LONG)) * sizeof(LONG);
    }

    // Set the password EA.
    if ( pPassword )
    {
        thisEa = (PFILE_FULL_EA_INFORMATION) ((PBYTE) thisEa + thisEa->NextEntryOffset);

        thisEa->Flags = 0;
        thisEa->EaNameLength = sizeof("Password");
        CopyMemory( thisEa->EaName, "Password\0", thisEa->EaNameLength + 1 );
        valuePtr = (PBYTE) thisEa->EaName + thisEa->EaNameLength + 1;
        thisEa->EaValueLength = (USHORT)( *pPassword ? lstrlenW( pPassword ) : 1 ) * sizeof( WCHAR );
        CopyMemory( valuePtr, pPassword, thisEa->EaValueLength );
        thisEa->NextEntryOffset = (ULONG)(((PBYTE) valuePtr + thisEa->EaValueLength ) -
                                   (PBYTE) thisEa);
        thisEa->NextEntryOffset = ((thisEa->NextEntryOffset + 3) / sizeof(LONG)) * sizeof(LONG);
    }

    // Set the domain EA
    if ( pDomain )
    {
        thisEa = (PFILE_FULL_EA_INFORMATION) ((PBYTE) thisEa + thisEa->NextEntryOffset);

        thisEa->Flags = 0;
        thisEa->EaNameLength = sizeof("Domain");
        RtlCopyMemory( thisEa->EaName, "Domain\0", thisEa->EaNameLength + 1 );
        valuePtr = (PBYTE) thisEa->EaName + thisEa->EaNameLength + 1;
        thisEa->EaValueLength = (USHORT)( *pDomain ? lstrlenW( pDomain ) : 1 ) * sizeof( WCHAR );
        RtlCopyMemory( valuePtr, pDomain, thisEa->EaValueLength );
        thisEa->NextEntryOffset = 0;
    }

    thisEa->NextEntryOffset = 0;

    return (ULONG)(((PBYTE) valuePtr + thisEa->EaValueLength) - (PBYTE) pEaData);
}


DWORD APIENTRY
NPAddConnection(
    LPNETRESOURCE   lpNetResource,
    LPWSTR          lpPassword,
    LPWSTR          lpUserName )
/*++

Routine Description:

    This routine adds a connection to the list of connections associated
    with this network provider

Arguments:

    lpNetResource - the NETRESOURCE struct

    lpPassword  - the password

    lpUserName - the user name

Return Value:

    WN_SUCCESS if successful, otherwise the appropriate error

Notes:

--*/
{
    return NPAddConnection3(NULL, lpNetResource, lpPassword, lpUserName, 0);
}


DWORD APIENTRY
NPAddConnection3(
    HWND            hwndOwner,
    LPNETRESOURCE   lpNetResource,
    LPWSTR          lpPassword,
    LPWSTR          lpUserName,
    DWORD           dwFlags )
/*++

Routine Description:

    This routine adds a connection to the list of connections associated
    with this network provider

Arguments:

    hwndOwner - the owner handle

    lpNetResource - the NETRESOURCE struct

    lpPassword  - the password

    lpUserName - the user name

    dwFlags - flags for the connection

Return Value:

    WN_SUCCESS if successful, otherwise the appropriate error

Notes:

    The current sample does not handle explicitly passesd in credentials. Normally
    the credential information is passed in as EA parameters to the associated
    mini redirector for further manipulation

--*/
{
    DWORD   Status = 0;

    UNICODE_STRING      ConnectionName;

    PWCHAR  pLocalName,pRemoteName;
    USHORT  LocalNameLength,RemoteNameLength;
    HANDLE  hConnection;
    ULONG   TransferBytes;
    WCHAR   NullStr[] = L"\0\0";
    PWCHAR  pUserName;
    PWCHAR  pPassword;
    PWKSTA_USER_INFO_0  WkStaUserInfo;
    PSMBMRX_CONNECTINFO ConnectInfo;
    

    DbgP((TEXT("NPAddConnection3: Incoming UserName - %s, Password - %s\n"),
                lpUserName, lpPassword ));

    // if no user specified, get the current logged on user
    if ( lpUserName == NULL )
    {
        Status = NetWkstaUserGetInfo( NULL, 0, (PBYTE *)&WkStaUserInfo );
        if ( Status == ERROR_SUCCESS )
        {
            pUserName = WkStaUserInfo->wkui0_username;
        }
        else
        {
            pUserName = NullStr;
        }
    }
    else
    {
        pUserName = lpUserName;
    }

    if ( lpPassword == NULL )
    {
        pPassword = NullStr;    // use default password
        pPassword[1] = '\0';    // reset empty flag
    }
    else if ( *lpPassword == L'\0' )
    {
        pPassword = NullStr;
        pPassword[1] = '1';     // flag the password as "Empty"
    }
    else
    {
        pPassword = lpPassword;
    }
    Status = ERROR_SUCCESS;

    DbgP((TEXT("NPAddConnection3: Outgoing UserName - %s, Password - %s\n"),
                lpUserName, lpPassword ));

    // The SMB mini supports only DISK type resources. The other resources
    // are not supported.

    if ((lpNetResource->lpRemoteName == NULL) ||
        (lpNetResource->lpRemoteName[0] != L'\\') ||
        (lpNetResource->lpRemoteName[1] != L'\\') ||
        (lpNetResource->dwType != RESOURCETYPE_DISK))
    {
        return WN_BAD_NETNAME;
    }

    //
    // The remote name is in the UNC format \\Server\Share.  This name
    // needs to be translated to an appropriate NT name in order to
    // issue the request to the underlying mini redirector to create the
    // connection.
    //
    // The NT style name is of the form
    //
    //  \device\smbminiredirector\;<DriveLetter>:\Server\Share
    //
    // The additional ; is required by the new RDR for extensibility.
    //

    pLocalName  = lpNetResource->lpLocalName;
    pRemoteName = lpNetResource->lpRemoteName;

    // skip past the first back slash since the name to be appended for the
    // NT name does not require this.
    pRemoteName++;

    if (pLocalName != NULL) {
        LocalNameLength = wcslen(pLocalName) * sizeof(WCHAR);
    } else {
        LocalNameLength = 0;
    }

    RemoteNameLength = (wcslen(pRemoteName) - 1) * sizeof(WCHAR);

    ConnectionName.MaximumLength = (USHORT)(SmbMRxDeviceName.Length +
                                   (USHORT)RemoteNameLength +
                                   ((pLocalName != NULL)
                                   ? (LocalNameLength + sizeof(WCHAR)) : 0) + // space for ;
                                   sizeof(WCHAR));

    ConnectionName.Length = ConnectionName.MaximumLength;

    ConnectionName.Buffer = LocalAlloc( LMEM_ZEROINIT,
                                        ConnectionName.Length + sizeof(WCHAR));

    if (ConnectionName.Buffer == NULL)
    {
        return GetLastError();
    }

    // Copy the name into the buffer

    CopyMemory( ConnectionName.Buffer,
                SmbMRxDeviceName.Buffer,
                SmbMRxDeviceName.Length);

    wcscat(ConnectionName.Buffer, L"\\");
    wcscat(ConnectionName.Buffer, L";");
    if (pLocalName != NULL)
    {
        wcscat(ConnectionName.Buffer, pLocalName);
    }

    wcscat(ConnectionName.Buffer, pRemoteName);

    ConnectInfo = (PSMBMRX_CONNECTINFO) LocalAlloc( LMEM_ZEROINIT, MAX_CONNECT_INFO_SIZE );
    if ( ConnectInfo )
    {
        ConnectInfo->ConnectionNameOffset = 0;
        ConnectInfo->ConnectionNameLength = ConnectionName.Length;
        CopyMemory( ConnectInfo->InfoArea, ConnectionName.Buffer, ConnectionName.Length );

        ConnectInfo->EaDataOffset = ConnectInfo->ConnectionNameOffset +
                                    ConnectInfo->ConnectionNameLength;
        // check for the "no password" flag
        if ( pPassword[0] == L'\0' && pPassword[1] == L'1' )
        {
            pPassword = NULL;
        }
        ConnectInfo->EaDataLength = FillInEaBuffer( pUserName,
                                                    pPassword,
                                                    (PBYTE) ConnectInfo->InfoArea +
                                                    ConnectInfo->EaDataOffset );
        TransferBytes = 0;

        Status = SendToMiniRdr( IOCTL_SMBMRX_ADDCONN,
                                ConnectInfo,
                                MAX_CONNECT_INFO_SIZE,
                                NULL,
                                &TransferBytes );
        LocalFree( ConnectInfo );
    }
    else
    {
        Status = WN_OUT_OF_MEMORY;
    }

    if ((Status == WN_SUCCESS) && (pLocalName != NULL))
    {
        WCHAR TempBuf[64];

        if (!QueryDosDeviceW(
                pLocalName,
                TempBuf,
                64))
        {
            if (GetLastError() != ERROR_FILE_NOT_FOUND)
            {
                //
                // Most likely failure occurred because our output
                // buffer is too small.  It still means someone already
                // has an existing symbolic link for this device.
                //

                Status = ERROR_ALREADY_ASSIGNED;
            }
            else
            {
                //
                // ERROR_FILE_NOT_FOUND (translated from OBJECT_NAME_NOT_FOUND)
                // means it does not exist and we can redirect this device.
                //
                // Create a symbolic link object to the device we are redirecting
                //
                if (!DefineDosDeviceW(
                        DDD_RAW_TARGET_PATH |
                        DDD_NO_BROADCAST_SYSTEM,
                        pLocalName,
                        ConnectionName.Buffer))
                {
                    Status = GetLastError();
                }
                else
                {
                    Status = WN_SUCCESS;
                }
            }
        }
        else
        {
            //
            // QueryDosDevice successfully an existing symbolic link--
            // somebody is already using this device.
            //
            Status = ERROR_ALREADY_ASSIGNED;
        }
    }
    else
    {
        DbgP((TEXT("SendToMiniRdr returned %lx\n"),Status));
    }

    if (Status == WN_SUCCESS)
    {
        INT     Index;
        HANDLE  hMutex, hMemory;
        BOOLEAN FreeEntryFound = FALSE;

        PSMBMRXNP_SHARED_MEMORY  pSharedMemory;

        // The connection was established and the local device mapping
        // added. Include this in the list of mapped devices.

        Status = OpenSharedMemory(
                    &hMutex,
                    &hMemory,
                    (PVOID)&pSharedMemory);

        if (Status == WN_SUCCESS)
        {
            DbgP((TEXT("NPAddConnection3: Highest Index %d Number Of resources %d\n"),
                        pSharedMemory->HighestIndexInUse,pSharedMemory->NumberOfResourcesInUse));

            Index = 0;

            while (Index < pSharedMemory->HighestIndexInUse)
            {
                if (!pSharedMemory->NetResources[Index].InUse)
                {
                    FreeEntryFound = TRUE;
                    break;
                }

                Index++;
            }

            if (!FreeEntryFound &&
                (pSharedMemory->HighestIndexInUse < SMBMRXNP_MAX_DEVICES))
            {
                pSharedMemory->HighestIndexInUse += 1;
                Index = pSharedMemory->HighestIndexInUse;
                FreeEntryFound = TRUE;
            }

            if (FreeEntryFound)
            {
                PSMBMRXNP_NETRESOURCE pSmbMrxNetResource;

                pSharedMemory->NumberOfResourcesInUse += 1;

                pSmbMrxNetResource = &pSharedMemory->NetResources[Index];

                pSmbMrxNetResource->InUse                = TRUE;
                pSmbMrxNetResource->dwScope              = lpNetResource->dwScope;
                pSmbMrxNetResource->dwType               = lpNetResource->dwType;
                pSmbMrxNetResource->dwDisplayType        = lpNetResource->dwDisplayType;
                pSmbMrxNetResource->dwUsage              = RESOURCEUSAGE_CONNECTABLE;
                pSmbMrxNetResource->LocalNameLength      = LocalNameLength;
                pSmbMrxNetResource->RemoteNameLength     = wcslen(lpNetResource->lpRemoteName) * sizeof(WCHAR);
                pSmbMrxNetResource->ConnectionNameLength = ConnectionName.Length;

                // Copy the local name
                CopyMemory( pSmbMrxNetResource->LocalName,
                            lpNetResource->lpLocalName,
                            pSmbMrxNetResource->LocalNameLength);

                // Copy the remote name
                CopyMemory( pSmbMrxNetResource->RemoteName,
                            lpNetResource->lpRemoteName,
                            pSmbMrxNetResource->RemoteNameLength);

                // Copy the connection name
                CopyMemory( pSmbMrxNetResource->ConnectionName,
                            ConnectionName.Buffer,
                            pSmbMrxNetResource->ConnectionNameLength);


                //
                // Copy the Auth info
                //
                // WARNING : security hole using shared memory..Developers must use alternate methods to maintain use table.
                //

                lstrcpyn( pSmbMrxNetResource->UserName, pUserName, MAX_PATH);
                if ( *pPassword )
                {
                    lstrcpyn( pSmbMrxNetResource->Password, pPassword, MAX_PATH);
                }
                else
                {
                    CopyMemory( pSmbMrxNetResource->Password, pPassword, 3 * sizeof(WCHAR) );
                }
            }
            else
            {
                Status = WN_NO_MORE_DEVICES;
            }

            CloseSharedMemory( &hMutex,
                               &hMemory,
                               (PVOID)&pSharedMemory);
        }
        else
        {
            DbgP((TEXT("NpAddConnection3: OpenSharedMemory returned %lx\n"),Status));
        }
    }

    return Status;
}


DWORD APIENTRY
NPCancelConnection(
    LPWSTR  lpName,
    BOOL    fForce )
/*++

Routine Description:

    This routine cancels ( deletes ) a connection from the list of connections
    associated with this network provider

Arguments:

    lpName - name of the connection

    fForce - forcefully delete the connection

Return Value:

    WN_SUCCESS if successful, otherwise the appropriate error

Notes:

--*/

{
    BOOL    bLocalName = TRUE;
    DWORD   Status = 0;

    UNICODE_STRING Name;

    HANDLE  hMutex, hMemory;
    PSMBMRXNP_SHARED_MEMORY  pSharedMemory;

    if (*lpName == L'\\' && *(lpName + 1) == L'\\')
    {
        bLocalName = FALSE;
    }

    DbgP((TEXT("NPCancelConnection\n")));
    DbgP((TEXT("NPCancelConnection: ConnectionName: %S\n"), lpName));

    Name.MaximumLength = Name.Length = wcslen(lpName) * sizeof(WCHAR);
    Name.Buffer = lpName;

    Status = OpenSharedMemory( &hMutex,
                               &hMemory,
                               (PVOID)&pSharedMemory);

    if (Status == WN_SUCCESS)
    {
        INT  Index;
        BOOL EntryFound = FALSE;
        PSMBMRXNP_NETRESOURCE pNetResource;

        DbgP((TEXT("NPCancelConnection: Highest Index %d Number Of resources %d\n"),
                    pSharedMemory->HighestIndexInUse,pSharedMemory->NumberOfResourcesInUse));

        for (Index = 0; Index <= pSharedMemory->HighestIndexInUse; Index++)
        {
            pNetResource = &pSharedMemory->NetResources[Index];

            if (pNetResource->InUse)
            {
                UNICODE_STRING EntryName;

                if (bLocalName)
                {
                    EntryName.MaximumLength = pNetResource->LocalNameLength;
                    EntryName.Length        = EntryName.MaximumLength;
                    EntryName.Buffer        = pNetResource->LocalName;
                }
                else
                {
                    EntryName.MaximumLength = pNetResource->RemoteNameLength;
                    EntryName.Length        = EntryName.MaximumLength;
                    EntryName.Buffer        = pNetResource->RemoteName;
                }

                DbgP((TEXT("NPCancelConnection: Name %S EntryName %S\n"),
                            lpName,EntryName.Buffer));
                DbgP((TEXT("NPCancelConnection: Name Length %d Entry Name Length %d\n"),
                           Name.Length,EntryName.Length));

                if (Name.Length == EntryName.Length)
                {
                    if ( _wcsnicmp(Name.Buffer, EntryName.Buffer, Name.Length) == 0 )
                    {
                        EntryFound = TRUE;
                        break;
                    }
                }
            }
        }

        if (EntryFound)
        {
            PWCHAR  pUserName;
            PWCHAR  pPassword;
            PSMBMRX_CONNECTINFO ConnectInfo;
            UNICODE_STRING ConnectionName;
            ULONG TransferBytes;

            DbgP((TEXT("NPCancelConnection: Connection Found:\n")));

            ConnectionName.Length        = pNetResource->ConnectionNameLength;
            ConnectionName.MaximumLength = ConnectionName.Length;
            ConnectionName.Buffer        = pNetResource->ConnectionName;
            pUserName                    = pNetResource->UserName;
            pPassword                    = pNetResource->Password;

            ConnectInfo = (PSMBMRX_CONNECTINFO) LocalAlloc( LMEM_ZEROINIT, MAX_CONNECT_INFO_SIZE );
            if ( ConnectInfo )
            {
                ConnectInfo->ConnectionNameOffset = 0;
                ConnectInfo->ConnectionNameLength = ConnectionName.Length;
                CopyMemory( ConnectInfo->InfoArea, ConnectionName.Buffer, ConnectionName.Length );

                ConnectInfo->EaDataOffset = ConnectInfo->ConnectionNameOffset +
                                            ConnectInfo->ConnectionNameLength;
                // check for the "no password" flag
                if ( pPassword[0] == L'\0' && pPassword[1] == L'1' )
                {
                    pPassword = NULL;
                }
                ConnectInfo->EaDataLength = FillInEaBuffer( pUserName,
                                                            pPassword,
                                                            (PBYTE) ConnectInfo->InfoArea +
                                                            ConnectInfo->EaDataOffset );
                TransferBytes = 0;

                Status = SendToMiniRdr( IOCTL_SMBMRX_DELCONN,
                                        ConnectInfo,
                                        MAX_CONNECT_INFO_SIZE,
                                        NULL,
                                        &TransferBytes );
                LocalFree( ConnectInfo );
            }
            else
            {
                Status = WN_OUT_OF_MEMORY;
            }

            DbgP((TEXT("NPCancelConnection: SendToMiniRdr returned Status %lx\n"),Status));

            if ( bLocalName )
            {
                if (DefineDosDevice(DDD_REMOVE_DEFINITION | DDD_RAW_TARGET_PATH | DDD_EXACT_MATCH_ON_REMOVE,
                                    lpName,
                                    pNetResource->ConnectionName) == FALSE)
                {
                    DbgP((TEXT("RemoveDosDevice:  DefineDosDevice error: %d\n"), GetLastError()));
                    Status = GetLastError();
                }
                else
                {
                    pNetResource->InUse = FALSE;

                    if (Index == pSharedMemory->HighestIndexInUse)
                    {
                        pSharedMemory->HighestIndexInUse      -= 1;
                        pSharedMemory->NumberOfResourcesInUse -= 1;
                    }
                }
            }
        }

        CloseSharedMemory( &hMutex,
                           &hMemory,
                          (PVOID)&pSharedMemory);
    }

    return Status;
}


DWORD APIENTRY
NPGetConnection(
    LPWSTR  lpLocalName,
    LPWSTR  lpRemoteName,
    LPDWORD lpBufferSize )
/*++

Routine Description:

    This routine returns the information associated with a connection

Arguments:

    lpLocalName - local name associated with the connection

    lpRemoteName - the remote name associated with the connection

    lpBufferSize - the remote name buffer size

Return Value:

    WN_SUCCESS if successful, otherwise the appropriate error

Notes:

--*/
{
    DWORD   Status = 0;

    UNICODE_STRING Name;

    HANDLE  hMutex, hMemory;
    PSMBMRXNP_SHARED_MEMORY  pSharedMemory;

    Name.MaximumLength = Name.Length = wcslen(lpLocalName) * sizeof(WCHAR);
    Name.Buffer        = lpLocalName;

    Status = OpenSharedMemory( &hMutex,
                               &hMemory,
                               (PVOID)&pSharedMemory);

    if (Status == WN_SUCCESS)
    {
        INT  Index;
        BOOL EntryFound = FALSE;
        PSMBMRXNP_NETRESOURCE pNetResource;

        for (Index = 0; Index <= pSharedMemory->HighestIndexInUse; Index++)
        {
            pNetResource = &pSharedMemory->NetResources[Index];

            if (pNetResource->InUse)
            {
                UNICODE_STRING EntryName;

                EntryName.MaximumLength = pNetResource->LocalNameLength;
                EntryName.Length        = EntryName.MaximumLength;
                EntryName.Buffer        = pNetResource->LocalName;

                if (Name.Length == EntryName.Length)
                {
                    if ( wcsncmp( Name.Buffer, EntryName.Buffer, Name.Length/sizeof(WCHAR)) == 0 )
                    {
                        EntryFound = TRUE;
                        break;
                    }
                }
            }
        }

        if (EntryFound)
        {
            if (*lpBufferSize < pNetResource->RemoteNameLength)
            {
                *lpBufferSize = pNetResource->RemoteNameLength;
                Status = ERROR_BUFFER_OVERFLOW;
            }
            else
            {
                *lpBufferSize = pNetResource->RemoteNameLength;
                CopyMemory( lpRemoteName,
                            pNetResource->RemoteName,
                            pNetResource->RemoteNameLength);
                Status = WN_SUCCESS;
            }
        }
        else
        {
            Status = ERROR_NO_NET_OR_BAD_PATH;
        }

        CloseSharedMemory( &hMutex, &hMemory, (PVOID)&pSharedMemory);
    }

    return Status;
}


DWORD APIENTRY
NPGetResourceParent(
    LPNETRESOURCE   lpNetResource,
    LPVOID  lpBuffer,
    LPDWORD lpBufferSize )
/*++

Routine Description:

    This routine returns the parent of a given resource

Arguments:

    lpNetResource - the NETRESOURCE struct

    lpBuffer - the buffer for passing back the parent information

    lpBufferSize - the buffer size

Return Value:

    WN_NOT_SUPPORTED

Notes:

    The current sample does not handle this call.

--*/
{
    return WN_NOT_SUPPORTED;
}

DWORD APIENTRY
NPGetResourceInformation(
    LPNETRESOURCE   lpNetResource,
    LPVOID  lpBuffer,
    LPDWORD lpBufferSize,
    LPWSTR  *lplpSystem )
/*++

Routine Description:

    This routine returns the information associated net resource

Arguments:

    lpNetResource - the NETRESOURCE struct

    lpBuffer - the buffer for passing back the parent information

    lpBufferSize - the buffer size

    lplpSystem -

Return Value:

Notes:

--*/
{
    DWORD dwStatus = 0;
    LPNETRESOURCE   pOutNetResource;
    DbgP((TEXT("NPGetResourceInformation\n")));

    return dwStatus;
}


DWORD APIENTRY
NPGetUniversalName(
    LPCWSTR lpLocalPath,
    DWORD   dwInfoLevel,
    LPVOID  lpBuffer,
    LPDWORD lpBufferSize )
/*++

Routine Description:

    This routine returns the information associated net resource

Arguments:

    lpLocalPath - the local path name

    dwInfoLevel  - the desired info level

    lpBuffer - the buffer for the univeral name

    lpBufferSize - the buffer size

Return Value:

    WN_SUCCESS if successful

Notes:

--*/
{
    DWORD   dwStatus;

    DWORD   BufferRequired      = 0;
    DWORD   UniversalNameLength = 0;
    DWORD   RemoteNameLength    = 0;
    DWORD   RemainingPathLength = 0;

    LPWSTR  pDriveLetter,
            pRemainingPath,
            SourceStrings[3];

    WCHAR   RemoteName[MAX_PATH],
            LocalPath[MAX_PATH],
            UniversalName[MAX_PATH],
            ReplacedChar;

    DbgP((TEXT("NPGetUniversalName: lpLocalPath: %S  InfoLevel: %d\n"), lpLocalPath, dwInfoLevel));

    if (dwInfoLevel != UNIVERSAL_NAME_INFO_LEVEL &&
        dwInfoLevel != REMOTE_NAME_INFO_LEVEL)
    {
        DbgP((TEXT("NPGetUniversalName:  bad dwInfoLevel value: %d\n"), dwInfoLevel));
        return WN_BAD_LEVEL;
    }

    lstrcpynW(LocalPath, lpLocalPath, MAX_PATH);

    pDriveLetter = LocalPath;
    if (pRemainingPath = wcschr(pDriveLetter, L':'))
    {
        ReplacedChar = *(++pRemainingPath);
        *pRemainingPath = L'\0';

    }


    RemoteNameLength = MAX_PATH;
    if ((dwStatus = NPGetConnection(pDriveLetter, RemoteName, &RemoteNameLength)) != WN_SUCCESS)
    {
        DbgP((TEXT("NPGetUniversalName:  NPGetConnection return dwStatus: %d\n"), dwStatus));
        return dwStatus;
    }

    if (pRemainingPath)
    {
        *pRemainingPath = ReplacedChar;
    }

    DbgP((TEXT("NPGetUniversalName: pRemainingPath: %S  RemoteName: %S\n"), pRemainingPath, RemoteName));

    lstrcpynW(UniversalName, RemoteName, MAX_PATH);

    if (pRemainingPath)
    {
        wcsncat(UniversalName, pRemainingPath, MAX_PATH - RemoteNameLength/sizeof(WCHAR) - 1);
        UniversalName[MAX_PATH-1] = L'\0';
    }

    DbgP((TEXT("NPGetUniversalName: UniversalName: %S\n"), UniversalName));

    // Determine if the provided buffer is large enough.
    UniversalNameLength = (wcslen(UniversalName) + 1) * sizeof(WCHAR);
    BufferRequired = UniversalNameLength;

    if (dwInfoLevel == UNIVERSAL_NAME_INFO_LEVEL)
    {
        BufferRequired += sizeof(UNIVERSAL_NAME_INFO);
    }
    else
    {
        RemoteNameLength = (wcslen(RemoteName) + 1) * sizeof(WCHAR);
        BufferRequired += sizeof(REMOTE_NAME_INFO) + RemoteNameLength;
        if (pRemainingPath)
        {
            RemainingPathLength = (wcslen(pRemainingPath) + 1) * sizeof(WCHAR);
            BufferRequired += RemainingPathLength;
        }
    }

    if (*lpBufferSize < BufferRequired)
    {
        DbgP((TEXT("NPGetUniversalName: WN_MORE_DATA BufferRequired: %d\n"), BufferRequired));
        *lpBufferSize = BufferRequired;
        return WN_MORE_DATA;
    }

    if (dwInfoLevel == UNIVERSAL_NAME_INFO_LEVEL)
    {
        LPUNIVERSAL_NAME_INFOW pUniversalNameInfo;

        pUniversalNameInfo = (LPUNIVERSAL_NAME_INFOW)lpBuffer;

        pUniversalNameInfo->lpUniversalName = (PWCHAR)((PBYTE)lpBuffer + sizeof(UNIVERSAL_NAME_INFOW));

        CopyMemory( pUniversalNameInfo->lpUniversalName,
                    UniversalName,
                    UniversalNameLength);
    }
    else
    {
        LPREMOTE_NAME_INFOW pRemoteNameInfo;

        pRemoteNameInfo = (LPREMOTE_NAME_INFOW)lpBuffer;

        pRemoteNameInfo->lpUniversalName  = (PWCHAR)((PBYTE)lpBuffer + sizeof(REMOTE_NAME_INFOW));
        pRemoteNameInfo->lpConnectionName = pRemoteNameInfo->lpUniversalName + UniversalNameLength;
        pRemoteNameInfo->lpRemainingPath  = pRemoteNameInfo->lpConnectionName + RemoteNameLength;

        CopyMemory( pRemoteNameInfo->lpUniversalName,
                    UniversalName,
                    UniversalNameLength);

        CopyMemory( pRemoteNameInfo->lpConnectionName,
                    RemoteName,
                    RemoteNameLength);

        CopyMemory( pRemoteNameInfo->lpRemainingPath,
                    pRemainingPath,
                    RemainingPathLength);
    }

    DbgP((TEXT("NPGetUniversalName: WN_SUCCESS\n")));

    return WN_SUCCESS;
}


int _cdecl _vsnwprintf( wchar_t *buffer, size_t count, wchar_t *format, va_list arg_ptr);

// Format and write debug information to OutputDebugString
ULONG
_cdecl
DbgPrint(
    LPTSTR Format,
    ...
    )
{   
    ULONG rc = 0;
    TCHAR szbuffer[256];

    va_list marker;
    va_start( marker, Format );
    {
         rc = _vsnwprintf( szbuffer, 254, Format, marker );
         szbuffer[255] = (TCHAR)0;
         OutputDebugString( TRACE_TAG );
         OutputDebugString( szbuffer );
    }

    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\ifskit.mrx\nulmrx\sys\wmlkm.c ===
/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

    cldskwmi.c

Abstract:

    km wmi tracing code. 
    
    Will be shared between our drivers.

Authors:

    GorN     10-Aug-1999

Environment:

    kernel mode only

Notes:

Revision History:

Comments:

        This code is a quick hack to enable WMI tracing in cluster drivers.
        It should eventually go away.

        WmlTinySystemControl will be replaced with WmilibSystemControl from wmilib.sys .

        WmlTrace or equivalent will be added to the kernel in addition to IoWMIWriteEvent(&TraceBuffer);

--*/
#include "precomp.h"
#pragma hdrstop

//#include <ntos.h>
//#include <ntrtl.h>
//#include <nturtl.h>


// #include <wmistr.h>
// #include <evntrace.h>

// #include "wmlkm.h"

BOOLEAN
WmlpFindGuid(
    IN PVOID GuidList,
    IN ULONG GuidCount,
    IN LPVOID Guid,
    OUT PULONG GuidIndex
    )
/*++

Routine Description:

    This routine will search the list of guids registered and return
    the index for the one that was registered.

Arguments:

    GuidList is the list of guids to search

    GuidCount is the count of guids in the list

    Guid is the guid being searched for

    *GuidIndex returns the index to the guid
        
Return Value:

    TRUE if guid is found else FALSE

--*/
{

    return(FALSE);
}


NTSTATUS
WmlTinySystemControl(
    IN OUT PVOID WmiLibInfo,
    IN PVOID DeviceObject,
    IN PVOID Irp
    )
/*++

Routine Description:

    Dispatch routine for IRP_MJ_SYSTEM_CONTROL. This routine will process
    all wmi requests received, forwarding them if they are not for this
    driver or determining if the guid is valid and if so passing it to
    the driver specific function for handing wmi requests.

Arguments:

    WmiLibInfo has the WMI information control block

    DeviceObject - Supplies a pointer to the device object for this request.

    Irp - Supplies the Irp making the request.

Return Value:

    status

--*/

{
    return(STATUS_WMI_GUID_NOT_FOUND);
}

ULONG
WmlTrace(
    IN ULONG Type,
    IN LPVOID TraceGuid,
    IN ULONG64 LoggerHandle,
    ... // Pairs: Address, Length
    )
{
    return STATUS_SUCCESS;
}


ULONG
WmlPrintf(
    IN ULONG Type,
    IN LPCGUID TraceGuid,
    IN ULONG64 LoggerHandle,
    IN PCHAR FormatString,
    ... // printf var args
    )
{
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\ifskit.mrx\nulmrx\sys\srvcall.c ===
/*

Copyright (c) 1989 - 1999 Microsoft Corporation

Module Name:

    srvcall.c

Abstract:

    This module implements the routines for handling the creation/manipulation of
    server entries in the connection engine database. It also contains the routines
    for parsing the negotiate response from  the server.

--*/

#include "precomp.h"
#pragma hdrstop

//
//  The local debug trace level
//

RXDT_DefineCategory(SRVCALL);
#define Dbg                     (DEBUG_TRACE_SRVCALL)

NTSTATUS
ExecuteCreateSrvCall(
      PMRX_SRVCALL_CALLBACK_CONTEXT  pCallbackContext)
/*++

Routine Description:

   This routine patches the RDBSS created srv call instance with the
   information required by the mini redirector.

Arguments:

    CallBackContext  - the call back context in RDBSS for continuation.

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS	Status;
	PWCHAR		pSrvName;
	BOOLEAN		Verifyer;

    PMRX_SRVCALL_CALLBACK_CONTEXT SCCBC = pCallbackContext;
    PMRX_SRV_CALL pSrvCall;
    PMRX_SRVCALLDOWN_STRUCTURE SrvCalldownStructure =
        (PMRX_SRVCALLDOWN_STRUCTURE)(SCCBC->SrvCalldownStructure);

    pSrvCall = SrvCalldownStructure->SrvCall;

    ASSERT( pSrvCall );
    ASSERT( NodeType(pSrvCall) == RDBSS_NTC_SRVCALL );

	// validate the server name with the test name of 'nulsvr'
	DbgPrint("NulMRx - SrvCall: Connection Name Length: %d\n",  pSrvCall->pSrvCallName->Length );

	if ( pSrvCall->pSrvCallName->Length >= 14 )
	{
		pSrvName = pSrvCall->pSrvCallName->Buffer;
	
		Verifyer  = ( pSrvName[0] == L'\\' );
		Verifyer &= ( pSrvName[1] == L'N' ) || ( pSrvName[1] == L'n' );
		Verifyer &= ( pSrvName[2] == L'U' ) || ( pSrvName[2] == L'u' );
		Verifyer &= ( pSrvName[3] == L'L' ) || ( pSrvName[3] == L'l' );
		Verifyer &= ( pSrvName[4] == L'S' ) || ( pSrvName[4] == L's' );
		Verifyer &= ( pSrvName[5] == L'V' ) || ( pSrvName[5] == L'v' );
		Verifyer &= ( pSrvName[6] == L'R' ) || ( pSrvName[6] == L'r' );
		Verifyer &= ( pSrvName[7] == L'\\' ) || ( pSrvName[7] == L'\0' );
	}
	else
	{
		Verifyer = FALSE;
	}

	if ( Verifyer )
	{
        RxDbgTrace( 0, Dbg, ("Verifier Succeeded!!!!!!!!!\n"));
    	Status = STATUS_SUCCESS;
	}
	else
	{
        RxDbgTrace( 0, Dbg, ("Verifier Failed!!!!!!!!!\n"));
    	Status = STATUS_BAD_NETWORK_PATH;
	}

    SCCBC->Status = Status;
    SrvCalldownStructure->CallBack(SCCBC);

   return Status;
}


NTSTATUS
NulMRxCreateSrvCall(
      PMRX_SRV_CALL                  pSrvCall,
      PMRX_SRVCALL_CALLBACK_CONTEXT  pCallbackContext)
/*++

Routine Description:

   This routine patches the RDBSS created srv call instance with the information required
   by the mini redirector.

Arguments:

    RxContext        - Supplies the context of the original create/ioctl

    CallBackContext  - the call back context in RDBSS for continuation.

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status;
    UNICODE_STRING ServerName;

    PMRX_SRVCALLDOWN_STRUCTURE SrvCalldownStructure =
        (PMRX_SRVCALLDOWN_STRUCTURE)(pCallbackContext->SrvCalldownStructure);

    ASSERT( pSrvCall );
    ASSERT( NodeType(pSrvCall) == RDBSS_NTC_SRVCALL );

    //
    // If this request was made on behalf of the RDBSS, do ExecuteCreatSrvCall
    // immediately. If the request was made from somewhere else, create a work item
    // and place it on a queue for a worker thread to process later. This distinction
    // is made to simplify transport handle management.
    //

    if (IoGetCurrentProcess() == RxGetRDBSSProcess())
    {
        RxDbgTrace( 0, Dbg, ("Called in context of RDBSS process\n"));

        //
        // Peform the processing immediately because RDBSS is the initiator of this
        // request
        //

        Status = ExecuteCreateSrvCall(pCallbackContext);
    }
    else
    {
        RxDbgTrace( 0, Dbg, ("Dispatching to worker thread\n"));

       //
       // Dispatch the request to a worker thread because the redirected drive
       // buffering sub-system (RDBSS) was not the initiator
       //

       Status = RxDispatchToWorkerThread(
                  NulMRxDeviceObject,
                  DelayedWorkQueue,
                  ExecuteCreateSrvCall,
                  pCallbackContext);

       if (Status == STATUS_SUCCESS)
       {
            //
            // Map the return value since the wrapper expects PENDING.
            //

            Status = STATUS_PENDING;
       }
    }

    return Status;
}


NTSTATUS
NulMRxFinalizeSrvCall(
      PMRX_SRV_CALL pSrvCall,
      BOOLEAN       Force)
/*++

Routine Description:

   This routine destroys a given server call instance

Arguments:

    pSrvCall  - the server call instance to be disconnected.

    Force     - TRUE if a disconnection is to be enforced immediately.

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    RxDbgTrace( 0, Dbg, ("NulMRxFinalizeSrvCall \n"));
    pSrvCall->Context = NULL;

    return(Status);
}

NTSTATUS
NulMRxSrvCallWinnerNotify(
      IN PMRX_SRV_CALL  pSrvCall,
      IN BOOLEAN        ThisMinirdrIsTheWinner,
      IN OUT PVOID      pSrvCallContext
      )
/*++

Routine Description:

   This routine finalizes the mini rdr context associated with an RDBSS Server call instance

Arguments:

    pSrvCall               - the Server Call

    ThisMinirdrIsTheWinner - TRUE if this mini rdr is the choosen one.

    pSrvCallContext  - the server call context created by the mini redirector.

Return Value:

    RXSTATUS - The return status for the operation

Notes:

    The two phase construction protocol for Server calls is required because of parallel
    initiation of a number of mini redirectors. The RDBSS finalizes the particular mini
    redirector to be used in communicating with a given server based on quality of
    service criterion.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    RxDbgTrace( 0, Dbg, ("NulMRxSrvCallWinnerNotify \n"));
    if( ThisMinirdrIsTheWinner ) {
        RxDbgTrace(0, Dbg, ("This minirdr is the winner \n"));
    }

    pSrvCall->Context = (PVOID)0xDEADBEEFDEADBEEF;

    return(Status);
}




=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\ifskit.mrx\nulmrx\sys\write.c ===
/*++

Copyright (c) 1989 - 1999 Microsoft Corporation

Module Name:

    write.c

Abstract:

    This module implements the mini redirector call down routines pertaining
    to write of file system objects.

--*/

#include "precomp.h"
#pragma hdrstop

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_WRITE)

NTSTATUS
NulMRxWrite (
      IN PRX_CONTEXT RxContext)

/*++

Routine Description:

   This routine opens a file across the network.

Arguments:

    RxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    RxCaptureFcb;
    PLOWIO_CONTEXT LowIoContext  = &RxContext->LowIoContext;
    PVOID pbUserBuffer = NULL;
    ULONG ByteCount = (LowIoContext->ParamsFor).ReadWrite.ByteCount;
    RXVBO ByteOffset = (LowIoContext->ParamsFor).ReadWrite.ByteOffset;
    LONGLONG FileSize = 0;
    NulMRxGetFcbExtension(capFcb,pFcbExtension);
    PMRX_NET_ROOT pNetRoot = capFcb->pNetRoot;
    NulMRxGetNetRootExtension(pNetRoot,pNetRootExtension);
    BOOLEAN SynchronousIo = !BooleanFlagOn(RxContext->Flags,RX_CONTEXT_FLAG_ASYNC_OPERATION);
    PNULMRX_COMPLETION_CONTEXT pIoCompContext = NulMRxGetMinirdrContext(RxContext);
    PDEVICE_OBJECT deviceObject;

    RxTraceEnter("NulMRxWrite");
    RxDbgTrace(0, Dbg, ("NetRoot is 0x%x Fcb is 0x%x\n", pNetRoot, capFcb));
    
    //
    //  Lengths that are not sector aligned will be rounded up to
    //  the next sector boundary. The rounded up length should be
    //  < AllocationSize.
    //
    RxGetFileSizeWithLock((PFCB)capFcb,&FileSize);
    
    RxDbgTrace(0, Dbg, ("UserBuffer is0x%x\n", pbUserBuffer ));
    RxDbgTrace(0, Dbg, ("ByteCount is %d ByteOffset is %d\n", ByteCount, ByteOffset ));

    //
    //  Initialize the completion context in the RxContext
    //
    ASSERT( sizeof(*pIoCompContext) == MRX_CONTEXT_SIZE );
    RtlZeroMemory( pIoCompContext, sizeof(*pIoCompContext) );
    
    if( SynchronousIo ) {
        RxDbgTrace(0, Dbg, ("This I/O is sync\n"));
        pIoCompContext->IoType = IO_TYPE_SYNCHRONOUS;
    } else {
        RxDbgTrace(0, Dbg, ("This I/O is async\n"));
        pIoCompContext->IoType = IO_TYPE_ASYNC;
    }
  
    RxDbgTrace(0, Dbg, ("Status = %x Info = %x\n",RxContext->IoStatusBlock.Status,RxContext->IoStatusBlock.Information));

    RxTraceLeave(Status);
    return(Status);
} // NulMRxWrite
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\ifskit.mrx\smbmrx\sys\devfcb.c ===
/*++

Copyright (c) 1989 - 1999  Microsoft Corporation

Module Name:

    devfcb.c

Abstract:

    This module implements all the passthru stuff from the wrapper. currently
    there is only one such function:
         statistics


--*/

#include "precomp.h"
#pragma hdrstop
#include "smbmrx.h"


//
// Forward declarations.
//

NTSTATUS
MRxSmbCreateConnection (
    IN PRX_CONTEXT RxContext,
    OUT PBOOLEAN PostToFsp
    );

NTSTATUS
MRxSmbDeleteConnection (
    IN PRX_CONTEXT RxContext,
    OUT PBOOLEAN PostToFsp
    );


#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, MRxSmbGetStatistics)
#pragma alloc_text(PAGE, MRxSmbDevFcbXXXControlFile)
#endif

//
//  The local trace mask for this part of the module
//

#define Dbg (DEBUG_TRACE_DEVFCB)

MRX_SMB_STATISTICS MRxSmbStatistics;

NTSTATUS
MRxSmbGetStatistics(
    IN OUT PRX_CONTEXT RxContext
    )
/*++

Routine Description:

    This routine gathers the statistics from the mini redirector

Arguments:

    RxContext - Describes the Fsctl and Context.

Return Value:

    STATUS_SUCCESS -- the Startup sequence was successfully completed.

    any other value indicates the appropriate error.

Notes:

--*/
{
   PLOWIO_CONTEXT LowIoContext  = &RxContext->LowIoContext;

   PMRX_SMB_STATISTICS pStatistics;
   ULONG BufferLength = LowIoContext->ParamsFor.FsCtl.OutputBufferLength;

   PAGED_CODE();

   pStatistics = (PMRX_SMB_STATISTICS)(LowIoContext->ParamsFor.FsCtl.pOutputBuffer);

   if (BufferLength < sizeof(MRX_SMB_STATISTICS)) {
      return STATUS_INVALID_PARAMETER;
   }

   RxContext->InformationToReturn = sizeof(MRX_SMB_STATISTICS);
   MRxSmbStatistics.SmbsReceived.QuadPart++;

   //some stuff we have to copy from the device object......
   MRxSmbStatistics.PagingReadBytesRequested     = MRxSmbDeviceObject->PagingReadBytesRequested;
   MRxSmbStatistics.NonPagingReadBytesRequested  = MRxSmbDeviceObject->NonPagingReadBytesRequested;
   MRxSmbStatistics.CacheReadBytesRequested      = MRxSmbDeviceObject->CacheReadBytesRequested;
   MRxSmbStatistics.NetworkReadBytesRequested    = MRxSmbDeviceObject->NetworkReadBytesRequested;
   MRxSmbStatistics.PagingWriteBytesRequested    = MRxSmbDeviceObject->PagingWriteBytesRequested;
   MRxSmbStatistics.NonPagingWriteBytesRequested = MRxSmbDeviceObject->NonPagingWriteBytesRequested;
   MRxSmbStatistics.CacheWriteBytesRequested     = MRxSmbDeviceObject->CacheWriteBytesRequested;
   MRxSmbStatistics.NetworkWriteBytesRequested   = MRxSmbDeviceObject->NetworkWriteBytesRequested;
   MRxSmbStatistics.ReadOperations               = MRxSmbDeviceObject->ReadOperations;
   MRxSmbStatistics.RandomReadOperations         = MRxSmbDeviceObject->RandomReadOperations;
   MRxSmbStatistics.WriteOperations              = MRxSmbDeviceObject->WriteOperations;
   MRxSmbStatistics.RandomWriteOperations        = MRxSmbDeviceObject->RandomWriteOperations;

   MRxSmbStatistics.LargeReadSmbs                = MRxSmbStatistics.ReadSmbs - MRxSmbStatistics.SmallReadSmbs;
   MRxSmbStatistics.LargeWriteSmbs               = MRxSmbStatistics.WriteSmbs - MRxSmbStatistics.SmallWriteSmbs;

   MRxSmbStatistics.CurrentCommands              = SmbCeStartStopContext.ActiveExchanges;

   *pStatistics = MRxSmbStatistics;

   return STATUS_SUCCESS;
}

NTSTATUS
MRxSmbDevFcbXXXControlFile (
    IN OUT PRX_CONTEXT RxContext
    )
/*++

Routine Description:

    This routine handles all the device FCB related FSCTL's in the mini rdr

Arguments:

    RxContext - Describes the Fsctl and Context.

Return Value:

    STATUS_SUCCESS -- the Startup sequence was successfully completed.

    any other value indicates the appropriate error in the startup sequence.

--*/
{
    NTSTATUS Status;
    RxCaptureFobx;
    UCHAR MajorFunctionCode  = RxContext->MajorFunction;
    PLOWIO_CONTEXT LowIoContext  = &RxContext->LowIoContext;
    ULONG ControlCode = LowIoContext->ParamsFor.FsCtl.FsControlCode;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbDevFcb\n"));
    switch (MajorFunctionCode) {
    case IRP_MJ_FILE_SYSTEM_CONTROL:
        {
            switch (LowIoContext->ParamsFor.FsCtl.MinorFunction) {
            case IRP_MN_USER_FS_REQUEST:
            {
                    RxDbgTrace(-1, Dbg, ("RxCommonDevFCBFsCtl -> unimplemented fsctl\n"));
                    Status = STATUS_INVALID_DEVICE_REQUEST;
            }
            break;

            default :  //minor function != IRP_MN_USER_FS_REQUEST
                Status = STATUS_INVALID_DEVICE_REQUEST;
            } // end of switch
        } // end of FSCTL case
        break;

    case IRP_MJ_DEVICE_CONTROL:
    case IRP_MJ_INTERNAL_DEVICE_CONTROL:
        {
            switch (ControlCode) {

            case IOCTL_SMBMRX_ADDCONN:
                DbgPrint("Processing Create Connection IOCTL\n");
                Status = MRxSmbCreateConnection( RxContext, &RxContext->PostRequest );
                break;

            case IOCTL_SMBMRX_DELCONN:
                DbgPrint("Processing Delete Connection IOCTL\n");
                Status = MRxSmbDeleteConnection( RxContext, &RxContext->PostRequest );
                break;

            case IOCTL_SMBMRX_GETSTATE:
            {
                ULONG   OutBufferLength  = LowIoContext->ParamsFor.IoCtl.OutputBufferLength;
                PBYTE   OutBuffer        = LowIoContext->ParamsFor.IoCtl.pOutputBuffer;
                ULONG   CurrentState     = RDR_NULL_STATE;

                if ( OutBufferLength >= sizeof(ULONG) )
                {
                    // map the states to control app's equivalents
                    switch ( MRxSmbState )
                    {
                        case MRXSMB_STARTABLE:
                        case MRXSMB_STOPPED:
                            CurrentState = RDR_STOPPED;
                            break;
                        case MRXSMB_START_IN_PROGRESS:
                            CurrentState = RDR_STARTING;
                            break;
                        case MRXSMB_STARTED:
                            CurrentState = RDR_STARTED;
                            break;
                    }
                    *(ULONG *)OutBuffer = CurrentState;
                    RxContext->InformationToReturn = sizeof(ULONG);
                    Status = STATUS_SUCCESS;
                }
                else
                {
                    Status = STATUS_INVALID_PARAMETER;
                }
            }
            break;

            case IOCTL_SMBMRX_START:
                switch (MRxSmbState) {

                case MRXSMB_STARTABLE:
                    // The correct sequence of start events issued by the workstation
                    // service would have avoided this. We can recover from this
                    // by actually invoking RxStartMiniRdr.
                    
                    if (capFobx) {
                        Status = STATUS_INVALID_DEVICE_REQUEST;
                        goto FINALLY;
                    }

                    (MRXSMB_STATE)InterlockedCompareExchange(
                              (PLONG)&MRxSmbState,
                              MRXSMB_START_IN_PROGRESS,
                              MRXSMB_STARTABLE);
                    //lack of break is intentional

                case MRXSMB_START_IN_PROGRESS:
                    {
                        Status = RxStartMinirdr(RxContext,&RxContext->PostRequest);

                        if (Status == STATUS_REDIRECTOR_STARTED) {
                            Status = STATUS_SUCCESS;
                        }
                        else if ( Status == STATUS_PENDING && RxContext->PostRequest == TRUE )
                        {
                            Status = STATUS_MORE_PROCESSING_REQUIRED;
                        }
                    }
                    break;

                case MRXSMB_STARTED:
                    Status = STATUS_SUCCESS;
                    break;

                default:
                    Status = STATUS_INVALID_PARAMETER;

                    break;
                }

                break;

            case IOCTL_SMBMRX_STOP:
                if (capFobx) {
                    Status = STATUS_INVALID_DEVICE_REQUEST;
                    goto FINALLY;
                }
                

                    if (RxContext->RxDeviceObject->NumberOfActiveFcbs > 0) {
                        return STATUS_REDIRECTOR_HAS_OPEN_HANDLES;
                    } else {
                        MRXSMB_STATE CurrentState;

                        CurrentState = (MRXSMB_STATE)
                                        InterlockedCompareExchange(
                                            (PLONG)&MRxSmbState,
                                            MRXSMB_STARTABLE,
                                            MRXSMB_STARTED);

                        Status = RxStopMinirdr(
                                     RxContext,
                                     &RxContext->PostRequest );
                        if ( Status == STATUS_PENDING && RxContext->PostRequest == TRUE )
                        {
                            Status = STATUS_MORE_PROCESSING_REQUIRED;
                        }
                    }
                    break;

            default :
                Status = STATUS_INVALID_DEVICE_REQUEST;

            } // end of switch
        } //end of IOCTL cases
        break;
    default:
        ASSERT(!"unimplemented major function");
        Status = STATUS_INVALID_DEVICE_REQUEST;

    }

FINALLY:    
    RxDbgTrace(
        -1,
        Dbg,
        ("MRxSmbDevFcb st,info=%08lx,%08lx\n",
         Status,
         RxContext->InformationToReturn));
    return(Status);

}


#if 0
// for ea testing
ULONG BuildCustomEAData( PVOID EaPtr )
{
    PFILE_FULL_EA_INFORMATION thisEa = (PFILE_FULL_EA_INFORMATION) EaPtr;
    PBYTE valuePtr;

    // Set the user name EA
    thisEa->Flags = 0;
    thisEa->EaNameLength = sizeof("UserName");
    RtlCopyMemory( thisEa->EaName, "UserName\0", thisEa->EaNameLength + 1 );
    valuePtr = (PBYTE) thisEa->EaName + thisEa->EaNameLength + 1;
    //thisEa->EaNameLength--;       // don't include the null in the EaName length
    thisEa->EaValueLength = sizeof(L"TestUser");
    RtlCopyMemory( valuePtr, L"TestUser", thisEa->EaValueLength );
    thisEa->NextEntryOffset = ((PBYTE) valuePtr + thisEa->EaValueLength ) -
                               (PBYTE) thisEa;

    // Set the password EA
    thisEa = (PFILE_FULL_EA_INFORMATION) ((PBYTE) thisEa + thisEa->NextEntryOffset);

    thisEa->Flags = 0;
    thisEa->EaNameLength = sizeof("Password");
    RtlCopyMemory( thisEa->EaName, "Password\0", thisEa->EaNameLength + 1 );
    valuePtr = (PBYTE) thisEa->EaName + thisEa->EaNameLength + 1;
    //thisEa->EaNameLength--;       // don't include the null in the EaName length
    thisEa->EaValueLength = sizeof(WCHAR);
    RtlCopyMemory( valuePtr, L"\0", thisEa->EaValueLength );
    thisEa->NextEntryOffset = ((PBYTE) valuePtr + thisEa->EaValueLength ) -
                               (PBYTE) thisEa;

    // Set the domain EA
    thisEa = (PFILE_FULL_EA_INFORMATION) ((PBYTE) thisEa + thisEa->NextEntryOffset);

    thisEa->Flags = 0;
    thisEa->EaNameLength = sizeof("Domain");
    RtlCopyMemory( thisEa->EaName, "Domain\0", thisEa->EaNameLength + 1 );
    valuePtr = (PBYTE) thisEa->EaName + thisEa->EaNameLength + 1;
    //thisEa->EaNameLength--;       // don't include the null in the EaName length
    thisEa->EaValueLength = sizeof(L"WORKGROUP");
    RtlCopyMemory( valuePtr, L"WORKGROUP", thisEa->EaValueLength );
    thisEa->NextEntryOffset = 0;

    return ((PBYTE) valuePtr + thisEa->EaValueLength) - (PBYTE) EaPtr;
}
#endif

NTSTATUS
GetConnectionHandle(
    IN PUNICODE_STRING  ConnectionName,
    PVOID EaBuffer,
    ULONG EaLength,
    PHANDLE Handle )
{

    NTSTATUS            Status;
    IO_STATUS_BLOCK     IoStatusBlock;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    UNICODE_STRING      FileName;

    InitializeObjectAttributes(
        &ObjectAttributes,
        ConnectionName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL);

    Status = ZwCreateFile(
        Handle,
        SYNCHRONIZE,
        &ObjectAttributes,
        &IoStatusBlock,
        NULL,
        FILE_ATTRIBUTE_NORMAL,
        FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
        FILE_OPEN_IF,
        FILE_CREATE_TREE_CONNECTION | FILE_SYNCHRONOUS_IO_NONALERT,
        EaBuffer,
        EaLength);

    DbgPrint("ZwCreateFile returned %lx\n",Status);

    if ( Status == STATUS_SUCCESS )
    {
        if ( *Handle != INVALID_HANDLE_VALUE ){
            DbgPrint("ZwCreateFile returned success\n");
        } else {
            DbgPrint("ZwCreateFile failed\n");
        }
    }

    return Status;
}

NTSTATUS
MRxSmbCreateConnection (
    IN PRX_CONTEXT RxContext,
    OUT PBOOLEAN PostToFsp
    )
/*++

Routine Description:


Arguments:

    IN PRX_CONTEXT RxContext - Describes the Fsctl and Context

Return Value:

RXSTATUS

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    PLOWIO_CONTEXT LowIoContext  = &RxContext->LowIoContext;

    ULONG   InBufferLength  = LowIoContext->ParamsFor.IoCtl.InputBufferLength;
    PBYTE   InBuffer        = LowIoContext->ParamsFor.IoCtl.pInputBuffer;

    BOOLEAN Wait   = BooleanFlagOn(RxContext->Flags, RX_CONTEXT_FLAG_WAIT);
    BOOLEAN InFSD  = !BooleanFlagOn(RxContext->Flags, RX_CONTEXT_FLAG_IN_FSP);

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbCreateConnection - entry\n"));

    if (!Wait) {
        //just post right now!
        *PostToFsp = TRUE;
        return(STATUS_PENDING);
    }

    Status = STATUS_INVALID_PARAMETER;

    try {
        PSMBMRX_CONNECTINFO ConnectInfo;
        UNICODE_STRING      ConnectionName;
        PBYTE               EaBuffer;
        ULONG               EaLength;
        ULONG               Validator;
        ULONG               CompareLength;
        HANDLE              Handle;

        if ( InBufferLength >= sizeof( PSMBMRX_CONNECTINFO ) )
        {
            ConnectInfo = (PSMBMRX_CONNECTINFO) InBuffer;
            if (((ULONG)(FIELD_OFFSET(SMBMRX_CONNECTINFO, InfoArea)) + (USHORT)ConnectInfo->ConnectionNameOffset + 
                    (USHORT)ConnectInfo->ConnectionNameLength <= InBufferLength) &&
                ((ULONG)(FIELD_OFFSET(SMBMRX_CONNECTINFO, InfoArea)) + (USHORT)ConnectInfo->EaDataOffset +
                    (USHORT)ConnectInfo->EaDataLength <= InBufferLength))
            {
                ConnectionName.Buffer        = (PWCHAR) ((PBYTE) ConnectInfo->InfoArea +
                                                ConnectInfo->ConnectionNameOffset);
                ConnectionName.Length        = (USHORT) ConnectInfo->ConnectionNameLength;
                ConnectionName.MaximumLength = (USHORT) ConnectInfo->ConnectionNameLength;

                EaLength = ConnectInfo->EaDataLength;               
                EaBuffer = ( EaLength > 0 ) ?
                            ConnectInfo->InfoArea + ConnectInfo->EaDataOffset : NULL;
                // Validate the connection name.  The name must start with our device name.
                // We can't allow a create on some rogue pathname outside our device
                CompareLength = sizeof(DD_SMBMRX_FS_DEVICE_NAME_U);
                CompareLength -= ( CompareLength > 0 ) ? sizeof(WCHAR) : 0;
                CompareLength = min( CompareLength, ConnectionName.Length );
                Validator = (ULONG) RtlCompareMemory( ConnectionName.Buffer, DD_SMBMRX_FS_DEVICE_NAME_U,
                                              CompareLength );

                if ( Validator == CompareLength )
                {
                    Status = GetConnectionHandle( &ConnectionName, EaBuffer, EaLength, &Handle );
                    if ( Status == STATUS_SUCCESS )
                    {
                        if ( Handle != INVALID_HANDLE_VALUE )
                        {
                            ZwClose( Handle );
                        }
                        else
                        {
                            Status = STATUS_BAD_NETWORK_NAME;
                        }
                    }
                }
                else
                {
                    Status = STATUS_OBJECT_PATH_NOT_FOUND;
                }
            }
        }

        try_return(Status);

try_exit:NOTHING;

    } finally {
        RxDbgTrace(0, Dbg, ("MRxSmbCreateConnection - exit Status = %08lx\n", Status));
        RxDbgTraceUnIndent(-1,Dbg);
    }

    return Status;
}

NTSTATUS
MRxSmbDeleteConnection (
    IN PRX_CONTEXT RxContext,
    OUT PBOOLEAN PostToFsp
    )
/*++

Routine Description:


Arguments:

    IN PRX_CONTEXT RxContext - Describes the Fsctl and Context

Return Value:

RXSTATUS

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    PLOWIO_CONTEXT LowIoContext  = &RxContext->LowIoContext;

    ULONG   InBufferLength  = LowIoContext->ParamsFor.IoCtl.InputBufferLength;
    PBYTE   InBuffer        = LowIoContext->ParamsFor.IoCtl.pInputBuffer;

    BOOLEAN Wait   = BooleanFlagOn(RxContext->Flags, RX_CONTEXT_FLAG_WAIT);
    BOOLEAN InFSD  = !BooleanFlagOn(RxContext->Flags, RX_CONTEXT_FLAG_IN_FSP);

    PV_NET_ROOT     VNetRoot;
    PFILE_OBJECT    pFileObject;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbDeleteConnection - entry\n"));

    if (!Wait) {
        //just post right now!
        *PostToFsp = TRUE;
        return(STATUS_PENDING);
    }

    Status = STATUS_INVALID_PARAMETER;

    try {
        PSMBMRX_CONNECTINFO ConnectInfo;
        UNICODE_STRING      ConnectionName;
        PBYTE               EaBuffer;
        ULONG               EaLength;
        ULONG               Validator;
        ULONG               CompareLength;
        HANDLE              Handle;

        if ( InBufferLength >= sizeof( PSMBMRX_CONNECTINFO ) )
        {
            ConnectInfo = (PSMBMRX_CONNECTINFO) InBuffer;
            
            if (((ULONG)(FIELD_OFFSET(SMBMRX_CONNECTINFO, InfoArea)) + (USHORT)ConnectInfo->ConnectionNameOffset + 
                    (USHORT)ConnectInfo->ConnectionNameLength <= InBufferLength) &&
                ((ULONG)(FIELD_OFFSET(SMBMRX_CONNECTINFO, InfoArea)) + (USHORT)ConnectInfo->EaDataOffset +
                    (USHORT)ConnectInfo->EaDataLength <= InBufferLength))
            {
                ConnectionName.Buffer        = (PWCHAR) ((PBYTE) ConnectInfo->InfoArea +
                                                ConnectInfo->ConnectionNameOffset);
                ConnectionName.Length        = (USHORT) ConnectInfo->ConnectionNameLength;
                ConnectionName.MaximumLength = (USHORT) ConnectInfo->ConnectionNameLength;

                EaLength = ConnectInfo->EaDataLength;               
                EaBuffer = ( EaLength > 0 ) ?
                            ConnectInfo->InfoArea + ConnectInfo->EaDataOffset : NULL;
                // Validate the connection name.  The name must start with our device name.
                // We can't allow a create on some rogue pathname outside our device
                CompareLength = sizeof(DD_SMBMRX_FS_DEVICE_NAME_U);
                CompareLength -= ( CompareLength > 0 ) ? sizeof(WCHAR) : 0;
                CompareLength = min( CompareLength, ConnectionName.Length );
                Validator = (ULONG) RtlCompareMemory( ConnectionName.Buffer, DD_SMBMRX_FS_DEVICE_NAME_U,
                                              CompareLength );

                if ( Validator == CompareLength )
                {
                    Status = GetConnectionHandle( &ConnectionName, EaBuffer, EaLength, &Handle );
                    if ( Status == STATUS_SUCCESS )
                    {
                        if ( Handle != INVALID_HANDLE_VALUE )
                        {
                            Status = ObReferenceObjectByHandle( Handle,
                                                                0L,
                                                                NULL,
                                                                KernelMode,
                                                                (PVOID *)&pFileObject,
                                                                NULL );
                            if ( NT_SUCCESS(Status) )
                            {
                                // VNetRoot exists as FOBx in the FsContext2
                                VNetRoot = (PV_NET_ROOT) pFileObject->FsContext2;
                                // make sure the node looks right
                                if (NodeType(VNetRoot) == RDBSS_NTC_V_NETROOT)
                                {
                                    RxDbgTrace(-1, Dbg, ("MRxSmbDeleteConnection - Calling RxFinalizeConnection"));
                                    Status = RxFinalizeConnection(VNetRoot->NetRoot, VNetRoot, TRUE);
                                }
                                else
                                {
                                    Status = STATUS_BAD_NETWORK_NAME;
                                }
                                ObDereferenceObject(pFileObject);
                            }
                            ZwClose(Handle);
                        }
                        else
                        {
                            Status = STATUS_BAD_NETWORK_NAME;
                        }
                    }
                }
                else
                {
                    Status =STATUS_OBJECT_PATH_NOT_FOUND;
                }
            }
        }

        try_return(Status);

try_exit:NOTHING;

    } finally {
        RxDbgTrace(0, Dbg, ("MRxSmbDeleteConnection - exit Status = %08lx\n", Status));
        RxDbgTraceUnIndent(-1,Dbg);
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\ifskit.mrx\smbmrx\exe\smbrdr.c ===
// SMBRDR.C

#ifndef UNICODE
#define UNICODE
#endif

#include <windows.h>
#include <shellapi.h>
#include <stdlib.h>
#include "srfunc.h"
#include "resource.h"


int WINAPI WinMain(
  HINSTANCE hInstance,  // handle to current instance
  HINSTANCE hPrevInstance,  // handle to previous instance
  LPSTR lpCmdLine,      // pointer to command line
  int nCmdShow          // show state of window
);

INT_PTR CALLBACK SmbRdrDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK ProviderDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK StatisticsDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);


#define APP_TITLE       TEXT("SMB MiniRDR")
#define INSTALL_NOTICE  TEXT("Mini Redirector is not completely installed.\n") \
                        TEXT("Do you wish to complete this now?")
#define INSTALL_REPLY   TEXT("Sorry, the install must finish before using the SMB MiniRDR.")
#define INSTALL_FAIL    APP_TITLE TEXT(" installation failed to complete.")
#define INSTALL_FILES   APP_TITLE TEXT(" necessary files aren't present.")
#define INSTALL_OTHER   APP_TITLE TEXT(" not properly installed.")
#define NOSTATS         TEXT("Statistics display is unimplemented at this time.\n") \
                        TEXT("Please check back with the next version.")
#define OPERROR         TEXT("Error attempting operation.")

#define TASK_TIP        APP_TITLE TEXT(" Control")

#define WM_SHNOTIFY         WM_USER + 100
#define WM_RDRSTATECHANGE   WM_USER + 200

#define TIMER_ID    54321

typedef struct _DLGDATASTRUCT
{
    HWND hDlg;
    ULONG_PTR RdrState;
    HBRUSH    hRedBrush;
    HBRUSH    hGrnBrush;
    HBRUSH    hBluBrush;
    HBRUSH    hWhtBrush;
    HBRUSH    hYelBrush;
    HINSTANCE hInstance;
    ULONG_PTR ElapsedStartTime;
    ULONG_PTR Action;
    HANDLE    hActionThread;
    HANDLE    hBusyThread;
    HANDLE    hBusySignal;

} DLGDATASTRUCT, *PDLGDATASTRUCT;

VOID InitiateAction( PDLGDATASTRUCT pdds );
DWORD ActionProc( PDLGDATASTRUCT pdds );
VOID IndicateWait( PDLGDATASTRUCT pdds );
VOID UnindicateWait( PDLGDATASTRUCT pdds );
DWORD BusyProc( PDLGDATASTRUCT pdds );

#define GetDDS( _x_ )   (PDLGDATASTRUCT) GetWindowLongPtr( _x_, DWLP_USER )

int WINAPI WinMain(
  HINSTANCE hInstance,
  HINSTANCE hPrevInstance,
  LPSTR lpCmdLine,
  int nCmdShow)
{
    MSG msg;
    HANDLE hSingleInstance;

    msg.wParam = 1;

    hSingleInstance = CreateMutex( NULL, 0, APP_TITLE TEXT(" MUTEX") );

    if ( GetLastError( ) != ERROR_ALREADY_EXISTS )
    {
        BOOL RdrIsInstalled;
        ULONG_PTR SetupStatus;

        SetupStatus = RdrInstallCheck( );
        RdrIsInstalled = ( SetupStatus == SETUP_COMPLETE );

        if ( !RdrIsInstalled )
        {
            int answer;

            if ( SetupStatus == SETUP_INCOMPLETE )
            {
                answer = MessageBox( NULL, INSTALL_NOTICE, APP_TITLE, MB_YESNOCANCEL | MB_DEFBUTTON1 | MB_ICONEXCLAMATION );
                if ( answer == IDYES )
                {
                    if ( !( RdrIsInstalled = RdrCompleteSetup( ) ) )
                    {
                        MessageBox( NULL, INSTALL_FAIL, APP_TITLE, MB_OK | MB_ICONERROR );
                    }
                }
                else if ( answer == IDNO )
                {
                    MessageBox( NULL, INSTALL_REPLY, APP_TITLE, MB_OK | MB_ICONINFORMATION );
                }
            }
            else if ( SetupStatus == SETUP_MISSING_FILE )
            {
                MessageBox( NULL, INSTALL_FILES, APP_TITLE, MB_OK | MB_ICONERROR );
            }
            else
            {
                MessageBox( NULL, INSTALL_OTHER, APP_TITLE, MB_OK | MB_ICONERROR );
            }
        }

        if ( RdrIsInstalled )
        {
            HWND hDlg;

            DLGDATASTRUCT dds;

            dds.hRedBrush        = CreateSolidBrush( RGB( 255, 0, 0 ) );
            dds.hGrnBrush        = CreateSolidBrush( RGB( 0, 255, 0 ) );
            dds.hBluBrush        = CreateSolidBrush( RGB( 0, 0, 255 ) );
            dds.hWhtBrush        = CreateSolidBrush( RGB( 255, 255, 255 ) );
            dds.hYelBrush        = CreateSolidBrush( RGB( 255, 255, 127 ) );
            dds.hInstance        = hInstance;
            dds.ElapsedStartTime = 0;
            dds.Action           = 0;
            dds.hActionThread    = NULL;
            dds.hBusyThread      = NULL;
            dds.hBusySignal      = NULL;
            dds.hDlg             = NULL;

            dds.RdrState = RDR_NULL_STATE;

            hDlg = CreateDialogParam( hInstance, MAKEINTRESOURCE(IDD_SMBRDR), NULL, SmbRdrDlgProc, (LPARAM) &dds );
            if ( hDlg )
            {
                NOTIFYICONDATA nid;

                dds.hDlg = hDlg;

                nid.cbSize = sizeof( NOTIFYICONDATA );
                nid.hWnd = hDlg;
                nid.uFlags = NIF_ICON | NIF_TIP | NIF_MESSAGE; 
                nid.uID = IDI_SMBRDR;
                nid.uCallbackMessage = WM_SHNOTIFY;
                nid.hIcon = LoadIcon( hInstance, MAKEINTRESOURCE(IDI_SMBRDR ) );
                lstrcpy( nid.szTip, TASK_TIP );

                Shell_NotifyIcon( NIM_ADD, &nid );  
                PostMessage( hDlg, WM_SETICON, ICON_SMALL, (LPARAM) nid.hIcon );
                PostMessage( hDlg, WM_SETICON, ICON_BIG, (LPARAM) nid.hIcon );

                while ( GetMessage( &msg, NULL, 0, 0 ) ) 
                { 
                    if ( !IsWindow( hDlg ) || !IsDialogMessage( hDlg, &msg ) ) 
                    { 
                        TranslateMessage( &msg );
                        DispatchMessage( &msg );
                    } 
                }
                Shell_NotifyIcon( NIM_DELETE, &nid );   
                if ( nid.hIcon )
                {
                    DestroyIcon( nid.hIcon );
                }
            }

            DeleteObject( dds.hRedBrush );
            DeleteObject( dds.hGrnBrush );
            DeleteObject( dds.hBluBrush );
            DeleteObject( dds.hWhtBrush );
            DeleteObject( dds.hYelBrush );
            if ( dds.hActionThread )
            {
                WaitForSingleObject( dds.hActionThread, INFINITE );
                CloseHandle( dds.hActionThread );
                dds.hActionThread = NULL;
            }
        }
    }
    else
    {
        HWND hDlg = FindWindow( NULL, APP_TITLE );

        SetForegroundWindow( hDlg );
        if ( !IsWindowVisible( hDlg ) )
        {
            ShowWindow( hDlg, SW_SHOWNORMAL );
        }
    }

    CloseHandle( hSingleInstance );

    return (int) msg.wParam;
}


INT_PTR CALLBACK SmbRdrDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch ( message )
    {
    case WM_INITDIALOG:
        {
            PDLGDATASTRUCT pdds = (PDLGDATASTRUCT) lParam;
            RECT rect;
            ULONG_PTR CurrentState;

            SetWindowLongPtr(hDlg, DWLP_USER, lParam);

            CurrentState = RdrGetInitialState( );

            CheckRadioButton( hDlg, IDC_DRVLOAD, IDC_DRVUNLOAD,
                        CurrentState > RDR_UNLOADING ? IDC_DRVLOAD : IDC_DRVUNLOAD );
            CheckRadioButton( hDlg, IDC_RDRSTART, IDC_RDRSTOP,
                        CurrentState > RDR_STOPPING ? IDC_RDRSTART : IDC_RDRSTOP );
            pdds->Action = ACTION_NONE;
            PostMessage( hDlg, WM_RDRSTATECHANGE, 0, CurrentState );

            SetDlgItemText( hDlg, IDC_STARTTIME, TEXT( "00:00" ) );
            SetTimer( hDlg, TIMER_ID, 1000, NULL );

            GetWindowRect( hDlg, &rect );
            rect.right -= rect.left;
            rect.bottom -= rect.top;
            rect.left = ( GetSystemMetrics( SM_CXSCREEN ) - rect.right ) / 2;
            rect.top  = ( GetSystemMetrics( SM_CYSCREEN ) - rect.bottom ) / 3;
            MoveWindow( hDlg,
                        rect.left,
                        rect.top,
                        rect.right,
                        rect.bottom,
                        FALSE );
        }
        break;

    case WM_COMMAND:
    {
        PDLGDATASTRUCT pdds = GetDDS( hDlg );

        switch ( LOWORD( wParam ) )
        {
            case IDC_DRVLOAD:
            case IDC_DRVUNLOAD:
            {
                if ( HIWORD( wParam ) == BN_CLICKED )
                {
                    ULONG_PTR NewState, action;

                    action = ( IsDlgButtonChecked( hDlg, IDC_DRVLOAD ) == BST_CHECKED ) ?
                                ACTION_LOAD : ACTION_UNLOAD;
                    NewState = RdrGetNextState( action, pdds->RdrState );
                    if ( NewState != RDR_NULL_STATE )
                    {                       
                        pdds->Action = action;
                        PostMessage( hDlg, WM_RDRSTATECHANGE, 0, NewState );
                    }
                }
            }
            break;

            case IDC_RDRSTART:
            case IDC_RDRSTOP:
            {
                if ( HIWORD( wParam ) == BN_CLICKED )
                {
                    ULONG_PTR NewState, action;

                    action = ( IsDlgButtonChecked( hDlg, IDC_RDRSTART ) == BST_CHECKED ) ?
                                ACTION_START : ACTION_STOP;
                    NewState = RdrGetNextState( action, pdds->RdrState );
                    if ( NewState != RDR_NULL_STATE )
                    {                       
                        pdds->Action = action;
                        PostMessage( hDlg, WM_RDRSTATECHANGE, 0, NewState );
                    }
                }
            }
            break;

            case IDC_STATISTICS:
                MessageBox( hDlg, NOSTATS, APP_TITLE, MB_OK | MB_ICONINFORMATION );
                //DialogBox( pdds->hInstance, MAKEINTRESOURCE(IDD_STATISTICS), hDlg, StatisticsDlgProc );
                break;

            case IDC_PROVIDER:
                DialogBox( pdds->hInstance, MAKEINTRESOURCE(IDD_PROVIDER), hDlg, ProviderDlgProc );
                break;

            case IDC_HIDE:
            {
                PostMessage( hDlg, WM_SYSCOMMAND, SC_MINIMIZE, -1 );
            }
            break;
        }
    }
    break;

    case WM_RDRSTATECHANGE:
    {
        //Enter();
        PDLGDATASTRUCT pdds = GetDDS( hDlg );

        // must be a transitional state

        if ( (ULONG_PTR) lParam != pdds->RdrState )
        {
            pdds->RdrState = (ULONG_PTR) lParam;
            EnableWindow( GetDlgItem( hDlg, IDC_DRVLOAD ),
                    ( pdds->RdrState == RDR_UNLOADED )|| ( pdds->RdrState == RDR_LOADED ) || ( pdds->RdrState == RDR_STOPPED ));
            EnableWindow( GetDlgItem( hDlg, IDC_DRVUNLOAD ),
                    ( pdds->RdrState == RDR_UNLOADED )|| ( pdds->RdrState == RDR_LOADED ) || ( pdds->RdrState == RDR_STOPPED ));

            EnableWindow( GetDlgItem( hDlg, IDC_RDRSTART ),
                    (pdds->RdrState == RDR_LOADED )||(pdds->RdrState == RDR_STOPPED) || (pdds->RdrState == RDR_STARTED ) );
            EnableWindow( GetDlgItem( hDlg, IDC_RDRSTOP ),
                    (pdds->RdrState == RDR_LOADED )||(pdds->RdrState == RDR_STOPPED) || (pdds->RdrState == RDR_STARTED ) );

            switch ( lParam )
            {
                case RDR_UNLOADED:
                    SetDlgItemText( hDlg, IDC_LOADSTATUS, TEXT("Driver Unloaded" ) );
                    break;

                case RDR_UNLOADING:
                    SetDlgItemText( hDlg, IDC_LOADSTATUS, TEXT("Driver Unloading" ) );
                    InitiateAction( pdds );
                    break;

                case RDR_LOADING:
                    SetDlgItemText( hDlg, IDC_LOADSTATUS, TEXT("Driver Loading" ) );
                    InitiateAction( pdds );
                    break;
                case RDR_LOADED:
                    SetDlgItemText( hDlg, IDC_LOADSTATUS, TEXT("Driver Loaded" ) );
                    break;

                case RDR_STOPPING:
                    SetDlgItemText( hDlg, IDC_STARTSTATUS, TEXT("RDR Stopping" ) );
                    InitiateAction( pdds );
                    break;

                case RDR_STOPPED:
                    SetDlgItemText( hDlg, IDC_STARTSTATUS, TEXT("RDR Stopped" ) );
                    pdds->ElapsedStartTime = 0;
                    SetDlgItemText( hDlg, IDC_STARTTIME, TEXT( "00:00" ) );
                    break;

                case RDR_STARTING:
                    SetDlgItemText( hDlg, IDC_STARTSTATUS, TEXT("RDR Starting" ) );
                    InitiateAction( pdds );
                    break;

                case RDR_STARTED:
                    SetDlgItemText( hDlg, IDC_STARTSTATUS, TEXT("RDR Started" ) );
                    break;

                default:
                    break;
            }
        }
        if ( pdds->Action == ACTION_ERROR )
        {
            MessageBox( hDlg, OPERROR, APP_TITLE, MB_OK | MB_ICONERROR );
        }
//Leave();
    }
    break;

    case WM_TIMER:
    {
        TCHAR timestring[8];

        PDLGDATASTRUCT pdds = GetDDS( hDlg );
        if ( wParam == TIMER_ID && pdds->RdrState > RDR_STOPPED )
        {
            pdds->ElapsedStartTime++;
            wsprintf( timestring, TEXT("%02d:%02d"), pdds->ElapsedStartTime / 60,
                        pdds->ElapsedStartTime % 60 );
            SetDlgItemText( hDlg, IDC_STARTTIME, timestring );
        }
    }
    break;

    case WM_CTLCOLORSTATIC:
    {
        PDLGDATASTRUCT pdds = GetDDS( hDlg );
        HBRUSH hBkBrush;

        switch ( GetWindowLongPtr( (HWND) lParam, GWL_ID ) )
        {
            case IDC_DRVCONTROLTEXT:
            case IDC_RDRCONTROLTEXT:
            case IDC_SETTINGSTEXT:
                SetBkMode( (HDC) wParam, TRANSPARENT );
                hBkBrush = pdds->hWhtBrush;
                break;

            case IDC_LOADSTATUS:
            {
                SetBkMode( (HDC) wParam, TRANSPARENT );
                if ( pdds->RdrState < RDR_UNLOADING )
                {
                    hBkBrush = pdds->hRedBrush;
                }
                else if (  pdds->RdrState < RDR_LOADED )
                {
                    hBkBrush = pdds->hYelBrush;
                }
                else
                {
                    hBkBrush = pdds->hGrnBrush;
                }
            }
            break;

            case IDC_STARTSTATUS:
            {
                SetBkMode( (HDC) wParam, TRANSPARENT );
                if ( pdds->RdrState < RDR_STOPPING )
                {
                    hBkBrush = pdds->hRedBrush;
                }
                else if (  pdds->RdrState < RDR_STARTED )
                {
                    hBkBrush = pdds->hYelBrush;
                }
                else
                {
                    hBkBrush = pdds->hGrnBrush;
                }
            }
            break;

            case IDC_BUSY:
            default:
                hBkBrush = (HBRUSH) FALSE;
                break;
        }

        return (INT_PTR) hBkBrush;
    }
    break;


    case WM_SETICON:
    {
        // catch it on the second pass so it has the previous icon to now draw
        if ( wParam == ICON_BIG )
        {
            ShowWindow( hDlg, SW_SHOWNORMAL );
        }
    }
    break;

    case WM_SHNOTIFY:
    {
        if ( wParam == IDI_SMBRDR )
        {
            if ( lParam == WM_LBUTTONDBLCLK )
            {
                if ( IsWindowVisible( hDlg ) )
                {
                    SetForegroundWindow( hDlg );
                }
                else
                {
                    ShowWindow( hDlg, SW_RESTORE );
                }
            }
            else if ( lParam == WM_RBUTTONDOWN && !IsWindowVisible( hDlg ) )
            {
                HMENU hPopup = CreatePopupMenu( );
                POINT cursorpos;
                HWND hfgrd;
                ULONG_PTR popselect;
                                                
                GetCursorPos( &cursorpos );

                if ( hPopup )
                {
                    PDLGDATASTRUCT pdds = GetDDS( hDlg );
                    MENUITEMINFO mii;
                    
                    ZeroMemory( &mii, sizeof( MENUITEMINFO ) );
                    mii.cbSize = sizeof( MENUITEMINFO );
                    mii.fMask = MIIM_DATA | MIIM_ID | MIIM_TYPE;
                    mii.fType = MFT_STRING;

                    mii.wID = IDM_OPEN;
                    mii.fState = MFS_DEFAULT;
                    mii.fMask |= MIIM_STATE;
                    mii.dwTypeData = TEXT("Open ") APP_TITLE TEXT(" Control");
                    InsertMenuItem( hPopup, 0, TRUE, &mii );

                    mii.wID = IDM_CLOSE;
                    mii.fMask &= ~MIIM_STATE;
                    mii.fState &= ~MFS_DEFAULT;
                    mii.dwTypeData = TEXT("Exit");
                    InsertMenuItem( hPopup, 1, TRUE, &mii );

                    if ( ( pdds->RdrState == RDR_STOPPED ) ||
                            (pdds->RdrState == RDR_STARTED ) ||
                            (pdds->RdrState == RDR_LOADED ) )
                    {
                        mii.wID = 0;
                        mii.fMask = MIIM_TYPE;
                        mii.dwTypeData = NULL;
                        mii.fType = MFT_SEPARATOR;
                        InsertMenuItem( hPopup, 2, TRUE, &mii );

                        mii.fType = MFT_STRING;
                        mii.fMask = MIIM_DATA | MIIM_ID | MIIM_TYPE;
                        if ( ( pdds->RdrState == RDR_STOPPED ) ||
                                (pdds->RdrState == RDR_LOADED ) )
                        {
                            mii.wID = IDM_START;
                            mii.dwTypeData = TEXT( "Start the RDR" );
                            InsertMenuItem( hPopup, 3, TRUE, &mii );
                        }
                        else if ( pdds->RdrState == RDR_STARTED )
                        {
                            mii.wID = IDM_STOP;
                            mii.dwTypeData = TEXT( "Stop the RDR" );
                            InsertMenuItem( hPopup, 3, TRUE, &mii );
                        }
                    }

                    SetActiveWindow( hDlg );

                    popselect = TrackPopupMenu( hPopup,
                                      TPM_LEFTBUTTON | TPM_RIGHTALIGN | TPM_BOTTOMALIGN |
                                      TPM_NONOTIFY | TPM_RETURNCMD,
                                      cursorpos.x,
                                      cursorpos.y,
                                      0,
                                      hDlg,
                                      NULL );
                    DestroyMenu( hPopup );

                    switch ( popselect )
                    {
                        case IDM_OPEN:
                        {
                            ShowWindow( hDlg, SW_SHOWNORMAL );
                        }
                        break;

                        case IDM_CLOSE:
                        {
                            PostMessage( hDlg, WM_CLOSE, 0, 0 );
                        }
                        break;

                        case IDM_START:
                        {
                            CheckRadioButton( hDlg, IDC_RDRSTART, IDC_RDRSTOP, IDC_RDRSTART );
                            PostMessage( hDlg, WM_COMMAND, MAKELONG(IDC_RDRSTART, BN_CLICKED),
                                        (LPARAM) GetDlgItem( hDlg, IDC_RDRSTART) );
                        }
                        break;

                        case IDM_STOP:
                        {
                            CheckRadioButton( hDlg, IDC_RDRSTART, IDC_RDRSTOP, IDC_RDRSTOP );
                            PostMessage( hDlg, WM_COMMAND, MAKELONG(IDC_RDRSTOP, BN_CLICKED),
                                        (LPARAM) GetDlgItem( hDlg, IDC_RDRSTOP) );
                        }
                        break;

                        default:
                            break;
                    }
                }
            }
        }
    }
    break;

    case WM_SYSCOMMAND:
    {
        if ( wParam == SC_MINIMIZE )
        {
            ShowWindow( hDlg, SW_HIDE );
            return TRUE;            
        }   
    }
    break;

    case WM_CLOSE:
    {
        PDLGDATASTRUCT pdds = GetDDS( hDlg );

        if ( pdds->hActionThread )
        {
            if ( WaitForSingleObject( pdds->hActionThread, 0 ) != WAIT_OBJECT_0 )
            {
                return TRUE;
            }
        }
        if ( pdds->RdrState == RDR_STARTED )
        {
            return TRUE;
        }
        DestroyWindow( hDlg );
    }
    break;

    case WM_DESTROY:
        KillTimer( hDlg, TIMER_ID );
        PostQuitMessage( 0 );
        break;
    }

    return 0;
}


INT_PTR CALLBACK ProviderDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {

        case WM_INITDIALOG:
        {
            ULONG_PTR count, len, nIndex;
            LPTSTR OrderString = NULL, marker, ptr;

#if 0 // #ifdef UNICODE
            TCHAR btntext[10];

            btntext[0] = 0x25b2;    // up arrow in unicode char set
            lstrcpy( &btntext[1], TEXT(" Move Up" ));
            SetDlgItemText( hDlg, IDC_MOVEUP, btntext );
            btntext[0] = 0x25bc;    // down arrow in unicode char set
            lstrcpy( &btntext[1], TEXT(" Move Dn" ));
            SetDlgItemText( hDlg, IDC_MOVEDN, btntext );
#endif

            len = RdrGetProviderOrderString( &OrderString );
            marker = OrderString;

            for ( count = 0, ptr = OrderString; ptr && count <= len; count++, ptr++ )
            {
                switch ( *ptr )
                {
                    case TEXT(','):
                    {
                        if ( count > 0 && ptr > marker )
                        {
                            *ptr = TEXT('\0');
                            SendDlgItemMessage( hDlg, IDC_ORDERLIST, LB_ADDSTRING, 0, (LPARAM) marker );
                            *ptr = TEXT(',');
                        }
                        marker = ptr + 1;
                    }
                    break;

                    case TEXT('\0'):
                    {
                        if ( count > 0 && ptr > marker )
                        {
                            SendDlgItemMessage( hDlg, IDC_ORDERLIST, LB_ADDSTRING, 0, (LPARAM) marker );
                        }
                    }
                    break;

                    case TEXT(' '):
                        marker = ptr + 1;
                        break;

                    default:
                        break;
                }
            }
            if ( OrderString )
            {
                free( OrderString );
            }
            nIndex = SendDlgItemMessage( hDlg, IDC_ORDERLIST, LB_FINDSTRING,
                        (WPARAM) -1, (LPARAM) PROVIDER_NAME );
            SetWindowLongPtr( hDlg, DWLP_USER, nIndex );
            if ( nIndex == LB_ERR)
            {
                nIndex = 0;
                EnableWindow( GetDlgItem( hDlg, IDC_MOVEUP ), FALSE );
                EnableWindow( GetDlgItem( hDlg, IDC_MOVEDN ), FALSE );
            }
            SendDlgItemMessage( hDlg, IDC_ORDERLIST, LB_SETCURSEL,
                            (WPARAM) nIndex, 0 );
            
        }
        break;

        case WM_COMMAND:
        {
            switch ( LOWORD( wParam ) )
            {
                case IDC_ORDERLIST:
                {
                    if ( HIWORD( wParam ) == LBN_SELCHANGE )
                    {
                        ULONG_PTR staticsel, cursel;

                        staticsel = GetWindowLongPtr( hDlg, DWLP_USER );
                        cursel = SendDlgItemMessage( hDlg, IDC_ORDERLIST, LB_GETCURSEL, 0, 0 );
                        if ( staticsel != cursel && staticsel != LB_ERR )
                        {
                            SendDlgItemMessage( hDlg, IDC_ORDERLIST, LB_SETCURSEL,
                                            (WPARAM) staticsel, 0 );

                        }
                    }
                }
                break;

                case IDC_MOVEUP:
                case IDC_MOVEDN:
                {
                        ULONG_PTR staticsel, items, len;
                        LPTSTR pstr;

                        staticsel = GetWindowLongPtr( hDlg, DWLP_USER );
                        items = SendDlgItemMessage( hDlg, IDC_ORDERLIST, LB_GETCOUNT,0 ,0 );
                        if ( staticsel != LB_ERR && items != LB_ERR )
                        {
                            len = SendDlgItemMessage( hDlg, IDC_ORDERLIST, LB_GETTEXTLEN, staticsel, 0 );
                            pstr = malloc( (len + 1 ) * sizeof(TCHAR) );
                            if ( pstr )
                            {
                                if ( LOWORD( wParam ) == IDC_MOVEUP && staticsel > 0 )
                                {
                                     SendDlgItemMessage( hDlg, IDC_ORDERLIST, LB_GETTEXT, staticsel, (LPARAM) pstr );
                                     SendDlgItemMessage( hDlg, IDC_ORDERLIST, LB_DELETESTRING, staticsel, 0 );
                                     SendDlgItemMessage( hDlg, IDC_ORDERLIST, LB_INSERTSTRING, --staticsel, (LPARAM) pstr );
                                }
                                else if ( (LOWORD( wParam ) == IDC_MOVEDN) && (items > 0) && (staticsel < (items - 1) ) )
                                {
                                     SendDlgItemMessage( hDlg, IDC_ORDERLIST, LB_GETTEXT, staticsel, (LPARAM) pstr );
                                     SendDlgItemMessage( hDlg, IDC_ORDERLIST, LB_DELETESTRING, staticsel, 0 );
                                     SendDlgItemMessage( hDlg, IDC_ORDERLIST, LB_INSERTSTRING, ++staticsel, (LPARAM) pstr );
                                }
                                free( pstr );
                                SetWindowLongPtr( hDlg, DWLP_USER, staticsel );
                                SendDlgItemMessage( hDlg, IDC_ORDERLIST, LB_SETCURSEL, staticsel, 0 );
                            }
                        }
                }
                break;

                case IDOK:
                {
                    LPTSTR OrderString, pstr;
                    ULONG_PTR items, len = 0, index;

                    items = SendDlgItemMessage( hDlg, IDC_ORDERLIST, LB_GETCOUNT,0 ,0 );
                    if ( items != LB_ERR )
                    {
                        for ( index = 0; items > 0 && index < items; index++ )
                        {
                            len += SendDlgItemMessage( hDlg, IDC_ORDERLIST, LB_GETTEXTLEN, index, 0 );
                        }
                        len += items;   //commas and ending null
                        OrderString = pstr = malloc( len * sizeof( TCHAR ) );
                        if ( OrderString )
                        {
                            for ( index = 0; items > 0 && index < items; index++ )
                            {
                                len = SendDlgItemMessage( hDlg, IDC_ORDERLIST, LB_GETTEXT, index, (LPARAM) pstr );
                                pstr += len;
                                *pstr++ = ( index < ( items - 1 ) ) ? TEXT(',') : TEXT('\0');
                            }
                            RdrSetProviderOrderString( OrderString );
                            free( OrderString );
                        }
                    }
                }

                case IDCANCEL:
                    PostMessage( hDlg, WM_CLOSE, 0, 0 );
                    break;
            }
        }
        break;
                
        case WM_CLOSE:
            EndDialog( hDlg, 0 );
            break;
    }

    return FALSE;
}

INT_PTR CALLBACK StatisticsDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
        case WM_COMMAND:
        {
            switch ( LOWORD( wParam ) )
            {
                case IDOK:
                    PostMessage( hDlg, WM_CLOSE, 0, 0 );
                    break;
            }
        }
        break;

        case WM_CLOSE:
            EndDialog( hDlg, 0 );
            break;
    }

    return FALSE;
}

VOID IndicateWait( PDLGDATASTRUCT pdds )
{
    pdds->hBusySignal = CreateEvent( NULL, FALSE, FALSE, NULL );                    
    pdds->hBusyThread = CreateThread( NULL, 0, (LPTHREAD_START_ROUTINE) BusyProc, pdds, 0, NULL );
}

VOID UnindicateWait( PDLGDATASTRUCT pdds )
{
    SetEvent( pdds->hBusySignal );
    WaitForSingleObject( pdds->hBusyThread, 1000 );
    CloseHandle( pdds->hBusyThread );
    CloseHandle( pdds->hBusySignal );
    pdds->hBusyThread = NULL;
    pdds->hBusySignal = NULL;
}

VOID InitiateAction( PDLGDATASTRUCT pdds )
{
    if ( pdds->hActionThread )
    {
        WaitForSingleObject( pdds->hActionThread, INFINITE );
        CloseHandle( pdds->hActionThread );
        pdds->hActionThread = NULL;
    }
    //pdds->Action = ACTION_TRANS;
    pdds->hActionThread = CreateThread( NULL, 0, (LPTHREAD_START_ROUTINE) ActionProc, pdds, 0, NULL );
}

DWORD ActionProc( PDLGDATASTRUCT pdds )
{
    ULONG_PTR newstate;
    BOOL success;

    IndicateWait( pdds );
    success = RdrDoAction( pdds->Action );
    UnindicateWait( pdds );

    pdds->Action = success ? ACTION_TRANS : ACTION_ERROR;
    newstate = RdrGetNextState( pdds->Action, pdds->RdrState );
    PostMessage( pdds->hDlg, WM_RDRSTATECHANGE, 0, newstate );

    return 0;
}


DWORD BusyProc( PDLGDATASTRUCT pdds )
{
    HDC hDC;
    HWND hBusyWnd = GetDlgItem( pdds->hDlg, IDC_BUSY );
    ULONG pos = 0, width;
    RECT clRect, mRect;

    GetClientRect( hBusyWnd, &clRect );

    mRect.left   = clRect.left;
    mRect.top    = clRect.top + clRect.bottom / 6;
    mRect.right  = width = clRect.right / 8;
    mRect.bottom = clRect.bottom - clRect.bottom / 6;

    while ( WaitForSingleObject( pdds->hBusySignal, 100 ) == WAIT_TIMEOUT )
    {
        hDC = GetDC( hBusyWnd );
        FillRect( hDC, &clRect, pdds->hWhtBrush );
        FillRect( hDC, &mRect, pdds->hBluBrush );
        mRect.left += width;
        mRect.right += width;           

        if ( mRect.right > clRect.right )
        {
            mRect.left = 0;
            mRect.right = width;            
        }
        ReleaseDC( hBusyWnd, hDC );
    }
    InvalidateRect( hBusyWnd, NULL, TRUE );

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\ifskit.mrx\smbmrx\sys\3connect.c ===
/*++
Copyright (c) 1987-1999  Microsoft Corporation

Module Name:

    3connect.c

Abstract:

    This module implements the tree connect SMB related routines. It also implements the
    three flavours of this routine ( user level and share level non NT server tree connect
    SMB construction and the tree connect SMB construction for SMB servers)

--*/

#include "precomp.h"
#pragma hdrstop

//
// The order of these names should match the order in which the enumerated type
// NET_ROOT_TYPE is defined. This facilitates easy access of share type names
//

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, BuildCanonicalNetRootInformation)
#pragma alloc_text(PAGE, CoreBuildTreeConnectSmb)
#pragma alloc_text(PAGE, LmBuildTreeConnectSmb)
#pragma alloc_text(PAGE, NtBuildTreeConnectSmb)
#endif

PCHAR s_NetRootTypeName[] = {
                              SHARE_TYPE_NAME_DISK,
                              SHARE_TYPE_NAME_PIPE,
                              SHARE_TYPE_NAME_COMM,
                              SHARE_TYPE_NAME_PRINT,
                              SHARE_TYPE_NAME_WILD
                            };

extern NTSTATUS
BuildTreeConnectSecurityInformation(
    PSMB_EXCHANGE  pExchange,
    PBYTE          pBuffer,
    PBYTE          pPasswordLength,
    PULONG         pSmbBufferSize);

NTSTATUS
BuildCanonicalNetRootInformation(
    PUNICODE_STRING     pServerName,
    PUNICODE_STRING     pNetRootName,
    NET_ROOT_TYPE       NetRootType,
    BOOLEAN             fUnicode,
    BOOLEAN             fPostPendServiceString,
    PBYTE               *pBufferPointer,
    PULONG              pBufferSize)
/*++

Routine Description:

   This routine builds the desired net root information for a tree connect SMB

Arguments:

    pServerName    - the server name

    pNetRootName   - the net root name

    NetRootType    - the net root type ( print,pipe,disk etc.,)

    fUnicode       - TRUE if it is to be built in UNICODE

    pBufferPointer - the SMB buffer

    pBufferSize    - the size on input. modified to the remaining size on output

Return Value:

    RXSTATUS - The return status for the operation

Notes:

    This routine relies upon the names being in certain formats to ensure that a
    valid UNC name can be formulated.
    1) The RDBSS netroot names start with a \ and also include the server name as
    part of the net root name. This is mandated by the prefix table search requirements
    in RDBSS.

--*/
{
   NTSTATUS Status;

   PAGED_CODE();

   if (fUnicode) {
      // Align the buffer and adjust the size accordingly.
      PBYTE    pBuffer = *pBufferPointer;
      RxDbgTrace( 0, (DEBUG_TRACE_CREATE),
                     ("BuildCanonicalNetRootInformation -- tcstring as unicode %wZ\n", pNetRootName));
      pBuffer = ALIGN_SMB_WSTR(pBuffer);

      if(sizeof(WCHAR) + (ULONG)(pBuffer - *pBufferPointer) > *pBufferSize) {
          return STATUS_BUFFER_OVERFLOW;
      }
      *pBufferSize -= (ULONG)(pBuffer - *pBufferPointer) + sizeof(WCHAR);
      
      *((PWCHAR)pBuffer) = L'\\';
      pBuffer += sizeof(WCHAR);
      *pBufferPointer = pBuffer;
      Status = SmbPutUnicodeStringAndUpcase(pBufferPointer,pNetRootName,pBufferSize);
   
   } else {
      RxDbgTrace( 0, (DEBUG_TRACE_CREATE), ("BuildCanonicalNetRootInformation -- tcstring as ascii\n"));
      if(sizeof(CHAR) > *pBufferSize) {
          return STATUS_BUFFER_OVERFLOW;
      }
      *((PCHAR)*pBufferPointer) = '\\';
      *pBufferPointer += sizeof(CHAR);
      *pBufferSize -= sizeof(CHAR);
      Status = SmbPutUnicodeStringAsOemStringAndUpcase(pBufferPointer,pNetRootName,pBufferSize);
   }

   if (NT_SUCCESS(Status) && fPostPendServiceString) {
      // Put the desired service name in ASCII ( always )
      ULONG Length = strlen(s_NetRootTypeName[NetRootType]) + 1;
      if (*pBufferSize >= Length) {
         RtlCopyMemory(*pBufferPointer,s_NetRootTypeName[NetRootType],Length);
         *pBufferSize -= Length;
      } else {
         Status = STATUS_BUFFER_OVERFLOW;
      }
   }

   return Status;
}


NTSTATUS
CoreBuildTreeConnectSmb(
    PSMB_EXCHANGE     pExchange,
    PGENERIC_ANDX     pAndXSmb,
    PULONG            pAndXSmbBufferSize)
/*++

Routine Description:

   This routine builds the tree connect SMB for a pre NT server

Arguments:

    pExchange          -  the exchange instance

    pAndXSmb           - the tree connect to be filled in...it's not really a andX

    pAndXSmbBufferSize - the SMB buffer size on input modified to remaining size on
                         output.

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status;
    USHORT   PasswordLength;

    PMRX_NET_ROOT NetRoot;

    UNICODE_STRING ServerName;
    UNICODE_STRING NetRootName;

    PSMBCE_SERVER  pServer;

    PREQ_TREE_CONNECT      pTreeConnect = (PREQ_TREE_CONNECT)pAndXSmb;

    ULONG OriginalBufferSize = *pAndXSmbBufferSize;

    BOOLEAN   AppendServiceString;
    PBYTE pBuffer;
    PCHAR ServiceName;
    ULONG Length;

    PAGED_CODE();

    NetRoot = pExchange->SmbCeContext.pVNetRoot->pNetRoot;

    RxDbgTrace( 0, (DEBUG_TRACE_ALWAYS),
        ("CoreBuildTreeConnectSmb buffer,remptr %08lx %08lx, nrt=%08lx\n",
         pAndXSmb,
         pAndXSmbBufferSize,
         NetRoot->Type));

    pServer = SmbCeGetExchangeServer(pExchange);
    SmbCeGetServerName(NetRoot->pSrvCall,&ServerName);
    SmbCeGetNetRootName(NetRoot,&NetRootName);
    ServiceName = s_NetRootTypeName[NetRoot->Type];
    Length = strlen(ServiceName) + 1;

    pTreeConnect->WordCount = 0;
    AppendServiceString     = FALSE;

    if(*pAndXSmbBufferSize < FIELD_OFFSET(REQ_TREE_CONNECT,Buffer)+1) {
        return STATUS_BUFFER_OVERFLOW;
    }

    pBuffer = (PBYTE)pTreeConnect + FIELD_OFFSET(REQ_TREE_CONNECT,Buffer);
    *pBuffer = 0x04;
    pBuffer++;
    *pAndXSmbBufferSize -= (FIELD_OFFSET(REQ_TREE_CONNECT,Buffer)+1);

    // put in the netname

    //RxDbgTrace( 0, (DEBUG_TRACE_ALWAYS), ("CoreBuildTreeConnectSmb before bcnri buffer,rem %08lx %08lx\n",pBuffer,*pAndXSmbBufferSize));
    Status = BuildCanonicalNetRootInformation(
                 &ServerName,
                 &NetRootName,
                 pExchange->SmbCeContext.pVNetRoot->pNetRoot->Type,
                 (BOOLEAN)(pServer->Dialect >= NTLANMAN_DIALECT),
                 AppendServiceString,
                 &pBuffer,
                 pAndXSmbBufferSize);

    if (!NT_SUCCESS(Status))
        return Status;

    if(*pAndXSmbBufferSize < 1) {
        return STATUS_BUFFER_OVERFLOW;
    }
    
    // put in the password
    pBuffer = (PBYTE)pTreeConnect + OriginalBufferSize - *pAndXSmbBufferSize;
    //RxDbgTrace( 0, (DEBUG_TRACE_ALWAYS), ("CoreBuildTreeConnectSmb88 buffer,rem %08lx %08lx\n",pBuffer,*pAndXSmbBufferSize));

    *pBuffer = 0x04;
    pBuffer++;
    *pAndXSmbBufferSize -= 1;

    if (pServer->SecurityMode == SECURITY_MODE_SHARE_LEVEL) {
        // The password information needs to be sent as part of the tree connect
        // SMB for share level servers.

        //RxDbgTrace( 0, (DEBUG_TRACE_ALWAYS), ("CoreBuildTreeConnectSmb before btcsi buffer,rem %08lx %08lx\n",pBuffer,*pAndXSmbBufferSize));
        Status = BuildTreeConnectSecurityInformation(
                     pExchange,
                     pBuffer,
                     (PBYTE)&PasswordLength,
                     pAndXSmbBufferSize);
    }

    if (!NT_SUCCESS(Status))
        return Status;
    
    if(*pAndXSmbBufferSize < 1) {
        return STATUS_BUFFER_OVERFLOW;
    }
    // string in the service string based on the netroot type

    //RxDbgTrace( 0, (DEBUG_TRACE_ALWAYS), ("CoreBuildTreeConnectSmb beforesscopy buffer,rem %08lx %08lx\n",pBuffer,*pAndXSmbBufferSize));
    
    
    pBuffer = (PBYTE)pTreeConnect + OriginalBufferSize - *pAndXSmbBufferSize;
    *pBuffer = 0x04;
    pBuffer++;
    *pAndXSmbBufferSize -= 1;
    
    if (*pAndXSmbBufferSize >= Length) {
        RtlCopyMemory(pBuffer,ServiceName,Length);
        *pAndXSmbBufferSize -= Length;
    } else {
        Status = STATUS_BUFFER_OVERFLOW;
    }

    //RxDbgTrace( 0, (DEBUG_TRACE_ALWAYS), ("CoreBuildTreeConnectSmb beforesscopy buffer,rem %08lx %08lx\n",pBuffer,*pAndXSmbBufferSize));
    SmbPutUshort(
        &pTreeConnect->ByteCount,
        (USHORT)(OriginalBufferSize
                 - *pAndXSmbBufferSize
                 - FIELD_OFFSET(REQ_TREE_CONNECT,Buffer)
                )
        );

    RxDbgTrace( 0, (DEBUG_TRACE_ALWAYS), ("CoreBuildTreeConnectSmb end buffer,rem %08lx %08lx\n",pBuffer,*pAndXSmbBufferSize));
    return Status;
}


NTSTATUS
LmBuildTreeConnectSmb(
    PSMB_EXCHANGE     pExchange,
    PGENERIC_ANDX     pAndXSmb,
    PULONG            pAndXSmbBufferSize)
/*++

Routine Description:

   This routine builds the tree connect SMB for a pre NT server

Arguments:

    pExchange          -  the exchange instance

    pAndXSmb           - the tree connect to be filled in...it's not really a andX

    pAndXSmbBufferSize - the SMB buffer size on input modified to remaining size on
                         output.

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status;
    USHORT   PasswordLength;

    PMRX_NET_ROOT NetRoot;

    UNICODE_STRING ServerName;
    UNICODE_STRING NetRootName;

    PSMBCE_SERVER  pServer;

    PREQ_TREE_CONNECT_ANDX pTreeConnectAndX = (PREQ_TREE_CONNECT_ANDX)pAndXSmb;

    ULONG OriginalBufferSize = *pAndXSmbBufferSize;

    BOOLEAN   AppendServiceString;
    PBYTE pBuffer;
    PCHAR ServiceName;
    ULONG Length;

    PAGED_CODE();

    NetRoot = pExchange->SmbCeContext.pVNetRoot->pNetRoot;
    RxDbgTrace( 0, (DEBUG_TRACE_ALWAYS),
        ("LmBuildTreeConnectSmb buffer,remptr %08lx %08lx, nrt=%08lx\n",
          pAndXSmb,
          pAndXSmbBufferSize,
          NetRoot->Type));

    if(OriginalBufferSize < FIELD_OFFSET(REQ_TREE_CONNECT_ANDX,Buffer)) {
        return STATUS_BUFFER_OVERFLOW;
    }

    pServer = SmbCeGetExchangeServer(pExchange);
    SmbCeGetServerName(NetRoot->pSrvCall,&ServerName);
    SmbCeGetNetRootName(NetRoot,&NetRootName);
    ServiceName = s_NetRootTypeName[NetRoot->Type];
    Length = strlen(ServiceName) + 1;

    AppendServiceString         = TRUE;
    pTreeConnectAndX->WordCount = 4;
    SmbPutUshort(&pTreeConnectAndX->AndXReserved,0);
    SmbPutUshort(
        &pTreeConnectAndX->Flags,0);
    pBuffer = (PBYTE)pTreeConnectAndX + FIELD_OFFSET(REQ_TREE_CONNECT_ANDX,Buffer);
    *pAndXSmbBufferSize -= (FIELD_OFFSET(REQ_TREE_CONNECT_ANDX,Buffer));

    if (pServer->SecurityMode == SECURITY_MODE_SHARE_LEVEL) {
        // The password information needs to be sent as part of the tree connect
        // SMB for share level servers.

        //RxDbgTrace( 0, (DEBUG_TRACE_ALWAYS), ("LmBuildTreeConnectSmb before btcsi buffer,rem %08lx %08lx\n",pBuffer,*pAndXSmbBufferSize));
        Status = BuildTreeConnectSecurityInformation(
                     pExchange,
                     pBuffer,
                     (PBYTE)&PasswordLength,
                     pAndXSmbBufferSize);

        if (Status == STATUS_SUCCESS) {
            pBuffer += PasswordLength;
            SmbPutUshort(&pTreeConnectAndX->PasswordLength,PasswordLength);
        }
    } else {

        if(*pAndXSmbBufferSize < sizeof(CHAR)) {
            return STATUS_BUFFER_OVERFLOW;
        }
        
        // No password is required for user level security servers as part of tree
        // connect
        SmbPutUshort(&pTreeConnectAndX->PasswordLength,0x1);
        *((PCHAR)pBuffer) = '\0';
        pBuffer    += sizeof(CHAR);
        *pAndXSmbBufferSize -= sizeof(CHAR);
        Status = STATUS_SUCCESS;
    }

    if (Status == STATUS_SUCCESS) {
        Status = BuildCanonicalNetRootInformation(
                     &ServerName,
                     &NetRootName,
                     pExchange->SmbCeContext.pVNetRoot->pNetRoot->Type,
                     (BOOLEAN)(pServer->Dialect >= NTLANMAN_DIALECT),
                     AppendServiceString,
                     &pBuffer,
                     pAndXSmbBufferSize);

      //RxDbgTrace( 0, (DEBUG_TRACE_ALWAYS), ("LmBuildTreeConnectSmb beforesscopy buffer,rem %08lx %08lx\n",pBuffer,*pAndXSmbBufferSize));

        if (Status == STATUS_SUCCESS) {
            SmbPutUshort(
                &pTreeConnectAndX->ByteCount,
                (USHORT)(OriginalBufferSize
                         - *pAndXSmbBufferSize
                         - FIELD_OFFSET(REQ_TREE_CONNECT_ANDX,Buffer)
                        )
                );
        }

        RxDbgTrace( 0, (DEBUG_TRACE_ALWAYS),
            ("LmBuildTreeConnectSmb end buffer,rem %08lx %08lx\n",
             pBuffer,
             *pAndXSmbBufferSize));
    }

    return Status;
}

NTSTATUS
NtBuildTreeConnectSmb(
    PSMB_EXCHANGE     pExchange,
    PGENERIC_ANDX     pAndXSmb,
    PULONG            pAndXSmbBufferSize)
/*++

Routine Description:

   This routine builds the tree connect SMB for a pre NT server

Arguments:

    pExchange  - the exchange instance

    pAndXSmb - the session setup to be filled in

    pAndXSmbBufferSize - the SMB buffer size on input modified to remaining size on
                         output.

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    UNICODE_STRING ServerName;
    UNICODE_STRING NetRootName;

    PSMBCE_SERVER  pServer;

    PREQ_TREE_CONNECT_ANDX pTreeConnect = (PREQ_TREE_CONNECT_ANDX)pAndXSmb;

    ULONG OriginalBufferSize = *pAndXSmbBufferSize;
    PBYTE pBuffer;
    ULONG BufferSize;

    PAGED_CODE();

    BufferSize = OriginalBufferSize;

    if(BufferSize < FIELD_OFFSET(REQ_TREE_CONNECT_ANDX,Buffer) + 1) {
        return STATUS_BUFFER_OVERFLOW;
    }

    pServer = SmbCeGetExchangeServer(pExchange);

    SmbCeGetServerName(pExchange->SmbCeContext.pVNetRoot->pNetRoot->pSrvCall,&ServerName);
    SmbCeGetNetRootName(pExchange->SmbCeContext.pVNetRoot->pNetRoot,&NetRootName);

    pTreeConnect->AndXCommand = 0xff;   // No ANDX
    pTreeConnect->AndXReserved = 0x00;  // Reserved (MBZ)

    SmbPutUshort(&pTreeConnect->AndXOffset, 0x0000); // No AndX as of yet.

    pTreeConnect->WordCount = 4;

    SmbPutUshort( &pTreeConnect->Flags, 0 );

    pBuffer = (PBYTE)pTreeConnect + FIELD_OFFSET(REQ_TREE_CONNECT_ANDX,Buffer);
    BufferSize -=  FIELD_OFFSET(REQ_TREE_CONNECT_ANDX,Buffer);

    if(pServer->SecurityMode == SECURITY_MODE_USER_LEVEL){
        // No password information is required as part of tree connect for user level
        // security servers. Therefore send a null string as the password.
        SmbPutUshort(&pTreeConnect->PasswordLength,0x1);

        *((PCHAR)pBuffer) = '\0';
        pBuffer    += sizeof(CHAR);
        BufferSize -= sizeof(CHAR);
    } else {
        USHORT PasswordLength;
        //plug in the password for this server.....qweee
        Status = BuildTreeConnectSecurityInformation(
                     pExchange,
                     pBuffer,
                     (PBYTE)&PasswordLength,
                     &BufferSize);

        if (Status == STATUS_SUCCESS ) {
            pBuffer += PasswordLength;
            SmbPutUshort(&pTreeConnect->PasswordLength,PasswordLength);
        }
    }

    if (NT_SUCCESS(Status)) {
        Status = BuildCanonicalNetRootInformation(
                     &ServerName,
                     &NetRootName,
                     NET_ROOT_WILD, //let the server tell us!  pNetRoot->Type,
                     BooleanFlagOn(pServer->DialectFlags,DF_UNICODE),
                     TRUE, //postpend the service string
                     &pBuffer,
                     &BufferSize);
    }

    if (NT_SUCCESS(Status)) {
        SmbPutUshort(
            &pTreeConnect->ByteCount,
            (USHORT)(OriginalBufferSize -
             FIELD_OFFSET(REQ_TREE_CONNECT_ANDX,Buffer) -
             BufferSize));
    }

    // update the buffer size to reflect the amount consumed.
    *pAndXSmbBufferSize = BufferSize;

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\ifskit.mrx\smbmrx\exe\srfunc.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    smbrdr.c

Abstract:

    This module implements the functios to load and unload the
    smb monolithic minirdr. Also explicit start/stop control is
    provided

    This module also populates the registry entries for the
    driver, and the network provider.

--*/
//#ifndef UNICODE
//#define UNICODE
//#endif

#include <windows.h>
#include <devioctl.h>
#include <stdlib.h>

#include "srfunc.h"


#ifdef DBG
#define DbgP(_x_) DbgPrint _x_
#else
#define DbgP(_x_)
#endif

ULONG _cdecl DbgPrint( LPTSTR Format, ... );

#define TRACE_TAG   L"SMBRDR:    "



TCHAR* SmbMrxDriverName = TEXT("SmbMRx");


// load action states

ULONG_PTR LoadActionStates[] =
{
    RDR_NULL_STATE,
    RDR_LOADING,
    RDR_NULL_STATE,
    RDR_NULL_STATE,
    RDR_NULL_STATE,
    RDR_NULL_STATE,
    RDR_NULL_STATE,
    RDR_NULL_STATE,
    RDR_NULL_STATE
};

// unload action states
ULONG_PTR UnloadActionStates[] =
{
    RDR_NULL_STATE,
    RDR_NULL_STATE,
    RDR_NULL_STATE,
    RDR_NULL_STATE,
    RDR_UNLOADING,
    RDR_UNLOADING,
    RDR_NULL_STATE,
    RDR_NULL_STATE,
    RDR_NULL_STATE
};

// Start action states
ULONG_PTR StartActionStates[] =
{
    RDR_NULL_STATE,
    RDR_NULL_STATE,
    RDR_NULL_STATE,
    RDR_NULL_STATE,
    RDR_STARTING,
    RDR_STARTING,
    RDR_NULL_STATE,
    RDR_NULL_STATE,
    RDR_NULL_STATE
};

// Stop action states
ULONG_PTR StopActionStates[] =
{
    RDR_NULL_STATE,
    RDR_NULL_STATE,
    RDR_NULL_STATE,
    RDR_NULL_STATE,
    RDR_NULL_STATE,
    RDR_NULL_STATE,
    RDR_NULL_STATE,
    RDR_NULL_STATE,
    RDR_STOPPING
};

ULONG_PTR TransitionActionStates[] =
{
    RDR_NULL_STATE,
    RDR_NULL_STATE,
    RDR_UNLOADED,
    RDR_LOADED,
    RDR_NULL_STATE,
    RDR_NULL_STATE,
    RDR_STOPPED,
    RDR_STARTED,
    RDR_NULL_STATE
};

ULONG_PTR ErrorActionStates[] =
{
    RDR_NULL_STATE,
    RDR_NULL_STATE,
    RDR_LOADED,
    RDR_UNLOADED,
    RDR_NULL_STATE,
    RDR_NULL_STATE,
    RDR_STARTED,
    RDR_STOPPED,
    RDR_NULL_STATE
};

ULONG_PTR NoneActionStates[] =
{
    RDR_NULL_STATE,
    RDR_UNLOADED,
    RDR_UNLOADING,
    RDR_LOADING,
    RDR_LOADED,
    RDR_STOPPED,
    RDR_STOPPING,
    RDR_STARTING,
    RDR_STARTED
};


ULONG_PTR *ActionsStatesArray[] =
{
    LoadActionStates,
    UnloadActionStates,
    StartActionStates,
    StopActionStates,
    TransitionActionStates,
    ErrorActionStates,
    NoneActionStates
};

ACTIONVECTOR ActionProcs[] =
{
    RdrLoad,
    RdrUnload,
    RdrStart,
    RdrStop,
    RdrDoNothing,
    RdrDoNothing,
    RdrDoNothing
};


typedef enum _INSTALLCHECKS
{
    installcheck_start,
    installcheck_driverfile,
    installcheck_providerfile,
    installcheck_serviceentry,
    installcheck_providerorder,
    installcheck_stop,
    installcheck_done
};


ULONG_PTR RdrInstallCheck( void )
{
    TCHAR tszTestPath[_MAX_PATH];
    ULONG_PTR teststep;
    ULONG len = 0;
    ULONG_PTR tc = SETUP_COMPLETE;
    HANDLE  th;

    for ( teststep = installcheck_start; teststep < installcheck_done; teststep++ )
    {
        switch ( teststep )
        {
            case installcheck_start:
            {
                len = GetWindowsDirectory( tszTestPath, _MAX_PATH );
            }
            break;

            case installcheck_driverfile:
            {
                lstrcpyn( &tszTestPath[len], DRIVER_FILE_PATH, _MAX_PATH - len );
                th = CreateFile( tszTestPath, 0, 0, NULL, OPEN_EXISTING, 0, NULL );
                if ( th == INVALID_HANDLE_VALUE )
                {
                    tc = SETUP_MISSING_FILE;
                    teststep = installcheck_stop;
                }
                else
                {
                    CloseHandle( th );
                }
            }
            break;

            case installcheck_providerfile:
            {
                lstrcpyn( &tszTestPath[len], PROVIDER_FILE_PATH, _MAX_PATH - len );
                th = CreateFile( tszTestPath, 0, 0, NULL, OPEN_EXISTING, 0, NULL );
                if ( th == INVALID_HANDLE_VALUE )
                {
                    tc = SETUP_MISSING_FILE;
                    teststep = installcheck_stop;
                }
                else
                {
                    CloseHandle( th );
                }
            }
            break;

            case installcheck_serviceentry:
            {
                HKEY hTestKey;

                if ( OpenKey( RDRSERVICE_KEY, &hTestKey ) )
                {
                    RegCloseKey( hTestKey );
                }
                else
                {
                    tc = SETUP_INCOMPLETE;
                    teststep = installcheck_stop;
                }
            }
            break;

            case installcheck_providerorder:
            {
                LPTSTR pOrder;

                RdrGetProviderOrderString( &pOrder );
                if ( pOrder )
                {
                    if ( !RdrFindProviderInOrder( pOrder, PROVIDER_NAME ) )
                    {
                        tc = SETUP_INCOMPLETE;
                        teststep = installcheck_stop;
                    }
                    free( pOrder );
                }
            }
            break;

            case installcheck_stop:
                break;
        }
    }

    return tc;
}

BOOL RdrCompleteSetup( void )
{
    return RdrSetupServiceEntry( ) && RdrSetupProviderOrder( );
}

// These handles are retained

HANDLE hSharedMemory;
HANDLE hMutex;


BOOL RdrStart(void)
/*++

Routine Description:

    This routine starts the SMB sample mini redirector.

Notes:

    The start is distinguished from Load. During this phase the appropriate FSCTL
    is issued and the shared memory/mutex data structures required for the Network
    provider DLL are initialized.

--*/
{

    HANDLE  DeviceHandle;       // The mini rdr device handle
    DWORD   BytesRet;
    BOOL    started = FALSE;

    // Grab a handle to the redirector device object

    DbgP((TEXT("Opening Rdr Device Object for Start Ioctl\n")));
    DeviceHandle = CreateFile( DD_SMBMRX_USERMODE_DEV_NAME,
                               GENERIC_READ | GENERIC_WRITE,
                               FILE_SHARE_READ | FILE_SHARE_WRITE,
                               NULL,
                               OPEN_EXISTING,
                               0,
                               NULL );

    DbgP((TEXT("returned from rdr device open\n")));

    if ( DeviceHandle != INVALID_HANDLE_VALUE )
    {
        DbgP(( TEXT("Issueing Rdr Start Ioctl\n") ));
        started = DeviceIoControl( DeviceHandle,
                                   IOCTL_SMBMRX_START,
                                   NULL,
                                   0,
                                   NULL,
                                   0,
                                   &BytesRet,
                                   NULL );

        // Create a section of shared memory to serve as the connection database
        if ( started )
        {
            DWORD  Status;

            hSharedMemory = CreateFileMapping( INVALID_HANDLE_VALUE,
                                               NULL,
                                               PAGE_READWRITE,
                                               0,
                                               sizeof(SMBMRXNP_SHARED_MEMORY),
                                               SMBMRXNP_SHARED_MEMORY_NAME);

            if (hSharedMemory == NULL)
            {
                Status = GetLastError();

                DbgP((TEXT("SMB MRx Net Provider shared memory Creation status %lx\n"),Status));
            }
            else
            {
                PSMBMRXNP_SHARED_MEMORY pSharedMemory;

                pSharedMemory = MapViewOfFile(hSharedMemory, FILE_MAP_WRITE, 0, 0, 0);

                if (pSharedMemory != NULL)
                {
                      pSharedMemory->HighestIndexInUse      = -1;
                      pSharedMemory->NumberOfResourcesInUse =  0;
                }

                UnmapViewOfFile(pSharedMemory);
            }

            hMutex = CreateMutex( NULL,
                                  FALSE,
                                  SMBMRXNP_MUTEX_NAME);

            if (hMutex == NULL)
            {
                Status = GetLastError();
                DbgP(( TEXT("SMB MRx Net Provider Mutex Creation status %lx\n"), Status));
            }
        }
        else
        {
            DbgP(( TEXT("The DeviceIoctl for Starting Redirector returned %lx\n"), GetLastError() ));
        }

    }
    else
    {
        DbgP(( TEXT("The CreateFile for opening device failed with error 0x%lx\n"), GetLastError() ));
        DbgP(( TEXT("Device is %s\n"),DD_SMBMRX_USERMODE_DEV_NAME ));
    }

    //DbgP((TEXT("SMB MRx sample mini redirector start status %lx\n"),ntstatus));

    CloseHandle(DeviceHandle);

    return started;


}

BOOL RdrStop( void )
/*++

Routine Description:

    This routine stops the SMB sample mini redirector.

Notes:

    The stop is distinguished from unload. During this phase the appropriate FSCTL
    is issued and the shared memory/mutex data structures required for the Network
    provider DLL are torn down.

--*/
{
    HANDLE  DeviceHandle;       // The mini rdr device handle
    DWORD   BytesRet;
    BOOL    stopped = FALSE;

    // Grab a handle to the redirector device object

    DeviceHandle = CreateFile( DD_SMBMRX_USERMODE_DEV_NAME,
                               GENERIC_READ | GENERIC_WRITE,
                               FILE_SHARE_READ | FILE_SHARE_WRITE,
                               NULL,
                               OPEN_EXISTING,
                               0,
                               NULL );

    DbgP((TEXT("Doing Stop DeviceIoControl\n")));
    if ( DeviceHandle != INVALID_HANDLE_VALUE )
    {
        stopped = DeviceIoControl( DeviceHandle,
                                   IOCTL_SMBMRX_STOP,
                                   NULL,
                                   0,
                                   NULL,
                                   0,
                                   &BytesRet,
                                   NULL );

        CloseHandle( DeviceHandle );
    }
    else
    {
        DbgP(( TEXT("The CreateFile for opening device failed\n") ));
    }

    CloseHandle(hMutex);
    CloseHandle(hSharedMemory);

//    DbgP(( TEXT("SMB MRx sample mini redirector start status %lx\n"),ntstatus ));

    return stopped;
}


BOOL RdrLoad( void )
{
    SC_HANDLE sch, service;
    BOOL loaded = FALSE;

    DbgP((TEXT("Loading SMB sample minirdr.......\n")));

    sch = OpenSCManager( NULL, NULL, GENERIC_EXECUTE );
    if ( sch )
    {
        service = OpenService( sch, RDRSERVICE, GENERIC_EXECUTE );
        if ( service )
        {
            loaded = StartService( service, 0, NULL );
            CloseServiceHandle( service );
        }
        CloseServiceHandle( sch );
    }

    return loaded;
}


BOOL RdrUnload( void )
{
    SC_HANDLE sch, service;
    BOOL unloaded = FALSE;

    DbgP((TEXT("Unloading SMB sample minirdr.......\n")));

    sch = OpenSCManager( NULL, NULL, GENERIC_EXECUTE );
    if ( sch )
    {
        service = OpenService( sch, RDRSERVICE, GENERIC_EXECUTE );
        if ( service )
        {
            SERVICE_STATUS ss;

            unloaded = ControlService( service, SERVICE_CONTROL_STOP, &ss );
            CloseServiceHandle( service );
        }
        CloseServiceHandle( sch );
    }

    return unloaded;
}


BOOL RdrDoNothing( void )
{
    return TRUE;
}


BOOL RdrDoAction( ULONG_PTR action )
{
    return (*ActionProcs[action])( );
}


ULONG_PTR RdrGetInitialState(void)
{
    ULONG_PTR state = RDR_UNLOADED;
    SC_HANDLE sch, service;

    sch = OpenSCManager( NULL, NULL, GENERIC_READ );
    if ( sch )
    {
        service = OpenService( sch, RDRSERVICE, GENERIC_READ );
        if ( service )
        {
            SERVICE_STATUS ss;

            if ( QueryServiceStatus( service, &ss ) )
            {
                switch ( ss.dwCurrentState )
                {
                    case SERVICE_STOPPED:
                        state = RDR_UNLOADED;
                        break;
                    case SERVICE_START_PENDING:
                        state = RDR_LOADING;
                        break;
                    case SERVICE_STOP_PENDING:
                        state = RDR_UNLOADING;
                        break;
                    case SERVICE_RUNNING:
                        state = RDR_LOADED;
                        break;
                    case SERVICE_CONTINUE_PENDING:
                    case SERVICE_PAUSE_PENDING:
                    case SERVICE_PAUSED:
                    default:
                        state = RDR_UNLOADED;
                        break;

                }
#if 0	//just check for load/unload state for now

                // go check the start/stop state
                if ( state == RDR_LOADED )
                {
                    BOOL IsOk;
                    HANDLE  DeviceHandle;
                    DWORD   BytesRet;
                    ULONG_PTR RdrStateValue;

                    DeviceHandle = CreateFile( DD_SMBMRX_USERMODE_DEV_NAME,
                                               GENERIC_READ | GENERIC_WRITE,
                                               FILE_SHARE_READ | FILE_SHARE_WRITE,
                                               NULL,
                                               OPEN_EXISTING,
                                               0,
                                               NULL );

                    if ( DeviceHandle != INVALID_HANDLE_VALUE )
                    {
                        DbgP((TEXT("Doing Get State DeviceIoControl\n")));
                        IsOk = DeviceIoControl( DeviceHandle,
                                                IOCTL_SMBMRX_GETSTATE,
                                                NULL,
                                                0,
                                                &RdrStateValue,
                                                sizeof(ULONG),
                                                &BytesRet,
                                                NULL );
                        CloseHandle( DeviceHandle );
                    }
                    if ( IsOk )
                    {
                        state = RdrStateValue;
                    }
                }
#endif
            }
            CloseServiceHandle( service );
        }
        CloseServiceHandle( sch );
    }

    return state;
}


ULONG_PTR RdrGetNextState( ULONG_PTR Action, ULONG_PTR CurrentState )
{
    return ActionsStatesArray[Action][CurrentState];
}


REGENTRY LinkageKeyValues[] =
{
    { TEXT("Bind"),     REG_MULTI_SZ,  0,   0 },
    { TEXT("Export"),   REG_MULTI_SZ,  0,   0 },
    { TEXT("Route"),    REG_MULTI_SZ,  0,   0 }
};

REGENTRY LinkageDisabledKeyValues[] =
{
    { TEXT("Bind"),     REG_MULTI_SZ,  0,   0 },
    { TEXT("Export"),   REG_MULTI_SZ,  0,   0 },
    { TEXT("Route"),    REG_MULTI_SZ,  0,   0 }
};


REGENTRY NetworkProviderKeyValues[] =
{
    {
        TEXT("Devicename"),
        REG_SZ,
        sizeof(SMBMRX_DEVICE_NAME),
        SMBMRX_DEVICE_NAME
    },
    {
        TEXT("ProviderPath"),
        REG_EXPAND_SZ,
        sizeof(PROVIDER_PATH),
        PROVIDER_PATH
    },
    {
        TEXT("Name"),
        REG_SZ,
        sizeof(SMBMRX_PROVIDER_NAME),
        SMBMRX_PROVIDER_NAME
    }
};


REGENTRY ProviderOrderKeyValues[] =
{
    { TEXT("ProviderOrder"), REG_SZ, 0,   0 }
};

BOOL RdrSetupServiceEntry( void )
/*++

Routine Description:

    This routine initializes the registry entries for the smbmrx
    minirdr. This only needs to be done once.

Arguments:

    None

Return Value:

   None

--*/
{
    HKEY hCurrentKey;
    SC_HANDLE sch, service;
    BOOL success = TRUE;

    DbgP(( TEXT( "Setting up ") RDRSERVICE TEXT(" registry Entries\n" ) ));
    sch = OpenSCManager( NULL, NULL, GENERIC_WRITE );
    if ( sch )
    {
        service = CreateService( sch,
                                 RDRSERVICE,
                                 RDRSERVICE,
                                 SERVICE_ALL_ACCESS,
                                 SERVICE_FILE_SYSTEM_DRIVER,
                                 SERVICE_DEMAND_START,
                                 SERVICE_ERROR_NORMAL,
                                 TEXT("System32\\DRIVERS\\") RDRSERVICE TEXT(".sys"),
                                 TEXT("Network"),
                                 NULL,
                                 NULL,
                                 NULL,
                                 NULL );


        if ( service )
        {
            CloseServiceHandle( service );
        }
        else if ( GetLastError( ) != ERROR_SERVICE_EXISTS )
        {
            success = FALSE;
        }
        CloseServiceHandle( sch );
    }
    else
    {
        success = FALSE;
    }


    // Read the linkage values associated with the Lanman workstation service.
    // This contains all the transports and the order in which they need to be used
    if ( success && OpenKey( WKSSERVICE_KEY TEXT("\\Linkage"), &hCurrentKey ) )
    {
        ULONG i;

        ReadRegistryKeyValues( hCurrentKey,
                               sizeof(LinkageKeyValues) / sizeof(REGENTRY),
                               LinkageKeyValues);
        RegCloseKey(hCurrentKey);
        // Update the SMB MRx linkage values
        if ( CreateKey( RDRSERVICE_KEY TEXT("\\Linkage"), &hCurrentKey ) )
        {
            WriteRegistryKeyValues( hCurrentKey,
                                    sizeof(LinkageKeyValues) / sizeof(REGENTRY),
                                    LinkageKeyValues);
            RegCloseKey(hCurrentKey);
        }
        else
        {
            success = FALSE;
        }
        for ( i = 0; i < ( sizeof(LinkageKeyValues) / sizeof(REGENTRY) ); i++ )
        {
            if (  LinkageKeyValues[i].pvValue )
            {
                free( LinkageKeyValues[i].pvValue );
                LinkageKeyValues[i].pvValue = NULL;
            }
        }
    }
    else
    {
        success = FALSE;
    }

    //if ( OpenKey( WKSSERVICE_KEY TEXT("\\Linkage\\Disabled",&hCurrentKey))
    //{
    //    ReadRegistryKeyValues( hCurrentKey,
    //                           sizeof(LinkageDisabledKeyValues) / sizeof(REGENTRY),
    //                           LinkageDisabledKeyValues);
    //    RegCloseKey(hCurrentKey);
    //}
    //else
    //{
    //    DbgP(( TEXT("Error Opening Key %s Status %d\n"),WKSSERVICE_KEY TEXT("\\Linkage\\Disabled"),GetLastError() ));
    //    return;
    //}

    // Update the SMB MRx linkage disabled values
    //if ( CreateKey( RDRSERVICE_KEY TEXT("\\Linkage\\Disabled") ,&hCurrentKey))
    //{
    //    WriteRegistryKeyValues( hCurrentKey,
    //                            sizeof(LinkageDisabledKeyValues)/sizeof(REGENTRY),
    //                            LinkageDisabledKeyValues );
    //    RegCloseKey(hCurrentKey);
    //}
    //else
    //{
    //    DbgP(( TEXT("Error Creating Key %s Status %d\n"),RDRSERVICE_KEY TEXT("\\linkage\\disabled",GetLastError() ));
    //    return;
    //}

    // Update the SMBmrx network provider section
    if ( success && CreateKey( RDRSERVICE_KEY TEXT("\\NetworkProvider"), &hCurrentKey ) )
    {
        WriteRegistryKeyValues( hCurrentKey,
                                sizeof(NetworkProviderKeyValues)/sizeof(REGENTRY),
                                NetworkProviderKeyValues);
        RegCloseKey(hCurrentKey);
    }
    else
    {
        success = FALSE;
    }


    if ( success && CreateKey( RDRSERVICE_KEY TEXT("\\Parameters"), &hCurrentKey ) )
    {
        RegCloseKey( hCurrentKey );
    }
    else
    {
        success = FALSE;
    }

    return success;
}

BOOL RdrSetupProviderOrder( void )
{
    LPTSTR pOrderString = NULL;
    ULONG_PTR len;
    BOOL success = TRUE;

    len = RdrGetProviderOrderString( &pOrderString ) * sizeof(TCHAR);
    if ( len > 0 && pOrderString )
    {
        if ( !RdrFindProviderInOrder( pOrderString, PROVIDER_NAME ) )
        {
            LPTSTR pNewOrderString;

            len += sizeof( PROVIDER_NAME ) + (2 * sizeof(TCHAR)); // add 2 for comma delimeter and null
            pNewOrderString = malloc( len );
            if ( pNewOrderString )
            {
                lstrcpy( pNewOrderString, pOrderString );
                lstrcat( pNewOrderString, TEXT(",") );
                lstrcat( pNewOrderString, PROVIDER_NAME );
                success = RdrSetProviderOrderString( pNewOrderString );
                free( pNewOrderString );
            }
        }
    }
    else
    {
        success = RdrSetProviderOrderString( PROVIDER_NAME );
    }
    if ( pOrderString )
    {
        free( pOrderString );
    }

    return success;
}


ULONG_PTR RdrGetProviderOrderString( LPTSTR *OrderString )
{
    HKEY hOrderKey;
    ULONG_PTR len = 0;

    if ( OpenKey( PROVIDER_ORDER_KEY, &hOrderKey ) )
    {
        ReadRegistryKeyValues( hOrderKey,
                               sizeof(ProviderOrderKeyValues) / sizeof(REGENTRY),
                               ProviderOrderKeyValues);

        RegCloseKey(hOrderKey);
        len = ProviderOrderKeyValues[0].dwLength / sizeof( TCHAR ) - 1;
        *OrderString = (LPTSTR) ProviderOrderKeyValues[0].pvValue;
    }

    return len;
}


BOOL RdrSetProviderOrderString( LPTSTR OrderString )
{
    HKEY hOrderKey;
    ULONG len = 0;
    BOOL rc = FALSE;

    if ( CreateKey( PROVIDER_ORDER_KEY, &hOrderKey ) )
    {
        ProviderOrderKeyValues[0].dwLength = ( lstrlen( OrderString ) + 1 ) * sizeof( TCHAR );
        ProviderOrderKeyValues[0].pvValue = OrderString;
        WriteRegistryKeyValues( hOrderKey,
                                sizeof(ProviderOrderKeyValues) / sizeof(REGENTRY),
                                ProviderOrderKeyValues);
        RegCloseKey(hOrderKey);

        rc = TRUE;
    }

    return rc;
}


BOOL RdrFindProviderInOrder( LPTSTR OrderString, LPTSTR Provider )
{
    LPTSTR pCompare;
    BOOL match = FALSE;

    if ( OrderString && Provider && *Provider )
    {
        pCompare = Provider;

        while ( *OrderString )
        {
            if ( toupper(*OrderString++) != toupper(*pCompare++) )
            {
                pCompare = Provider;
            }
            if ( *pCompare == TEXT('\0') )
            {
                if ( ( *OrderString == TEXT(',') ) || ( *OrderString == TEXT('\0') ) )
                {
                    match = TRUE;
                    break;
                }
                else    // hmm, it's a substring of another provider name
                {
                    while ( ( *OrderString != TEXT(',') ) && ( *OrderString != TEXT('\0') ) )
                    {
                        OrderString++;
                    }
                    pCompare = Provider;
                }
            }

        }
    }

    return match;
}



void
ReadRegistryKeyValues(
    HKEY       hCurrentKey,
    DWORD      NumberOfValues,
    PREGENTRY pValues)
/*++

Routine Description:

    This routine reads a bunch of values associated with a given key.

Arguments:

    hCurrentKey - the key

    NumberOfValues - the number of values

    pValues - the array of values

Return Value:

   None

--*/
{
    //
    // Iterate through table reading the values along the way
    //

    DWORD  i;

    for (i = 0; i < NumberOfValues; i++)
    {
        DWORD dwType;
        LPTSTR pszKey;

        dwType  = pValues[i].dwType;
        pszKey  = pValues[i].pszKey;

        switch (dwType)
        {
        case REG_SZ:
            GetRegsz(hCurrentKey, pszKey, &pValues[i].pvValue,
                     &pValues[i].dwLength);
            break;

        case REG_DWORD:
            GetRegdw(hCurrentKey, pszKey,  &pValues[i].pvValue,
                     &pValues[i].dwLength);
            break;

        case REG_EXPAND_SZ:
            GetRegesz(hCurrentKey, pszKey, &pValues[i].pvValue,
                      &pValues[i].dwLength);
            break;

        case REG_MULTI_SZ:
            GetRegmsz(hCurrentKey, pszKey, &pValues[i].pvValue,
                      &pValues[i].dwLength);
            break;

        case REG_BINARY:
            DbgP(( TEXT("%s is a REG_BINARY and won't be duplicated\n"), pszKey ));
            break;

        default:
            DbgP(( TEXT("%s is an unknown type; %d (decimal)\n"), pszKey, dwType ));
            break;

        }
    }
}

//
// Get a REG_SZ value and stick it in the table entry, along with the
// length
//

BOOL GetRegsz(HKEY hKey, LPTSTR pszKey, PVOID * ppvValue, DWORD *pdwLength)
{
    BYTE  achValue[1024];

    DWORD dwLength;
    LONG  Status;
    DWORD dwType   = REG_SZ;
    PBYTE pszValue = NULL;



    if ( (NULL == pszKey) || (NULL == ppvValue) ||
         (NULL == hKey)   || (NULL == pdwLength))
    {
        return FALSE;
    }

#ifdef _DEBUG
    FillMemory(achValue, sizeof(achValue), 0xcd);
#endif

    dwLength = sizeof(achValue);


    Status = RegQueryValueEx( hKey,
                               pszKey,
                               NULL,
                               &dwType,
                               (PUCHAR) &achValue[0],
                               &dwLength);

    if ((ERROR_SUCCESS != Status) || (REG_SZ != dwType) )
    {
        return FALSE;
    }

    pszValue = malloc(dwLength);

    if (NULL == pszValue)
    {
        return FALSE;
    }


    CopyMemory(pszValue, achValue, dwLength);

    *ppvValue  = pszValue;
    *pdwLength = dwLength;

    return TRUE;
}

//
// Get the value of a REG_EXPAND_SZ and its length
//

BOOL GetRegesz(HKEY hKey, LPTSTR pszKey, PVOID * ppvValue, DWORD * pdwLength)
{
    BYTE  achValue[1024];

    DWORD dwLength;
    LONG  Status;
    DWORD dwType   = REG_EXPAND_SZ;
    PBYTE pszValue = NULL;


    if ( (NULL == pszKey) || (NULL == ppvValue) ||
         (NULL == hKey)   || (NULL == pdwLength))
    {
        return FALSE;
    }

#ifdef _DEBUG
    FillMemory(achValue, sizeof(achValue), 0xcd);
#endif

    dwLength = sizeof(achValue);

    Status = RegQueryValueEx( hKey,
                               pszKey,
                               NULL,
                               &dwType,
                               (PUCHAR) &achValue[0],
                               &dwLength);

    if ((ERROR_SUCCESS != Status) || (REG_EXPAND_SZ != dwType))
    {
        return FALSE;
    }

    pszValue = malloc(dwLength);

    if (NULL == pszValue)
    {
        return FALSE;
    }

    CopyMemory(pszValue, achValue, dwLength);

    *ppvValue  = pszValue;
    *pdwLength = dwLength;

    return TRUE;
}


//
// Get value and length of REG_MULTI_SZ
//

BOOL GetRegmsz(HKEY hKey, LPTSTR pszKey, PVOID * ppvValue, DWORD * pdwLength)
{
    //BYTE  achValue[1024];
    BYTE  achValue[2048];	// careful, some of these strings are quite long

    DWORD dwLength;
    LONG  Status;
    DWORD dwType   = REG_MULTI_SZ;
    PBYTE pszValue = NULL;


    if ( (NULL == pszKey) || (NULL == ppvValue) ||
        (NULL == hKey)    || (NULL == pdwLength))
    {
        return FALSE;
    }

#ifdef _DEBUG
    FillMemory(achValue, sizeof(achValue), 0xcd);
#endif


    dwLength = sizeof(achValue);


    Status = RegQueryValueEx( hKey,
                               pszKey,
                               NULL,
                               &dwType,
                               (PUCHAR) &achValue[0],
                               &dwLength);

    if ((ERROR_SUCCESS != Status) || (REG_MULTI_SZ != dwType))
    {
        return FALSE;
    }

    pszValue = malloc(dwLength);

    if (NULL == pszValue)
    {
        return FALSE;
    }

    CopyMemory(pszValue, achValue, dwLength);

    *ppvValue  = pszValue;
    *pdwLength = dwLength;

    return TRUE;
}


//
// Get value and length of REG_DWORD
//


BOOL GetRegdw(HKEY hKey, LPTSTR pszKey, PVOID * ppvValue, DWORD * pdwLength)
{
    DWORD dwValue = 0;

    DWORD dwLength;
    LONG  Status;
    DWORD dwType   = REG_DWORD;



    if ( (NULL == pszKey) || (NULL == ppvValue) ||
         (NULL == hKey)   || (NULL == pdwLength) )
    {
        return FALSE;
    }

    dwLength = sizeof(dwValue);


    Status = RegQueryValueEx( hKey,
                               pszKey,
                               NULL,
                               &dwType,
                               (PUCHAR) &dwValue,
                               &dwLength);

    if ((ERROR_SUCCESS != Status) || (REG_DWORD != dwType))
    {
        return FALSE;
    }

    *ppvValue  = (PVOID) (ULONG_PTR) dwValue;
    *pdwLength = dwLength;

    return TRUE;
}



void
WriteRegistryKeyValues(
    HKEY        hCurrentKey,
    DWORD       NumberOfValues,
    PREGENTRY  pValues)
/*++

Routine Description:

    This routine reads a bunch of values associated with a given key.

Arguments:

    hCurrentKey - the key

    NumberOfValues - the number of values

    pValues - the array of values

Return Value:

   None

--*/
{
    DWORD i;


    for (i = 0; i < NumberOfValues; i++)
    {
        DWORD dwType;
        PVOID pvValue;
        DWORD dwLength;
        LPTSTR pszKey;

        pszKey   = pValues[i].pszKey;
        dwType   = pValues[i].dwType;
        dwLength = pValues[i].dwLength;
        pvValue  = pValues[i].pvValue;

        switch (dwType)
        {
        case REG_SZ:
            AddValue(hCurrentKey, pszKey, dwType, dwLength, pvValue);
            break;

        case REG_DWORD:
            AddValue(hCurrentKey, pszKey, dwType, dwLength, &pvValue);
            break;

        case REG_EXPAND_SZ:
            AddValue(hCurrentKey, pszKey, dwType, dwLength, pvValue);
            break;

        case REG_MULTI_SZ:
            AddValue(hCurrentKey, pszKey, dwType, dwLength, pvValue);
            break;

        case REG_BINARY:
            //
            // There are no binary values we need to copy. If we did, we'd
            // put something here
            //

            break;

        default:
            DbgP(( TEXT("%s is an unknown type; %d (decimal)\n"), pszKey, dwType ));
            break;

        }
    }
}

//
// Open a key so we can read the values
//


BOOL OpenKey(
    LPTSTR pszKey,
    PHKEY phKey)
/*++

Routine Description:

    This routine opens a registry key.

Arguments:

    pszKey - the name of the key relative to HKEY_LOCAL_MACHINE

    phKey - the key handlle

Return Value:

    TRUE if successful, otherwise FALSE

--*/
{
    HKEY  hNewKey = 0;
    DWORD Status;

    Status = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                            pszKey,
                            0,
                            KEY_QUERY_VALUE,
                            &hNewKey);

    if (ERROR_SUCCESS != Status)
    {
        *phKey = NULL;
        return FALSE;
    }
    else
    {
        *phKey = hNewKey;
        return TRUE;
    }
}


BOOL CreateKey(LPTSTR pszKey, PHKEY phKey)
/*++

Routine Description:

    This routine creates a registry key.

Arguments:

    pszKey - the name of the key relative to HKEY_LOCAL_MACHINE

    phKey - the key handlle

Return Value:

    TRUE if successful, otherwise FALSE

--*/
{
    LONG   Status;
    DWORD  Disposition;

    Status =  RegCreateKeyEx( HKEY_LOCAL_MACHINE,
                               pszKey,
                               0,
                               REG_NONE,
                               REG_OPTION_NON_VOLATILE,
                               KEY_ALL_ACCESS,
                               NULL,
                               phKey,
                               &Disposition);

    if ( ERROR_SUCCESS == Status)
    {
        return TRUE;
    }
    else
    {
        DbgP(( TEXT("error creating key %s Status %d\n"), pszKey, Status ));
        return FALSE;
    }
}


//
// Add a value to the registry
//


BOOL AddValue(HKEY hKey, LPTSTR pszKey, DWORD dwType, DWORD dwLength, PVOID pvValue)
{

    BOOL fSuccess = TRUE;
    LONG Status   = ERROR_SUCCESS;
    HANDLE th;

    Status = RegSetValueEx( hKey,
                             pszKey,
                             0,
                             dwType,
                             pvValue,
                             dwLength);


    if (Status != ERROR_SUCCESS)
    {
        fSuccess = FALSE;
        //RegCloseKey(hKey);
    }

    return fSuccess;
}


int _cdecl _vsnwprintf( wchar_t *buffer, size_t count, wchar_t *format, va_list arg_ptr);

// Format and write debug information to OutputDebugString
ULONG
_cdecl
DbgPrint(
    LPTSTR Format,
    ...
    )
{   
    ULONG rc = 0;
    TCHAR szbuffer[256];

    va_list marker;
    va_start( marker, Format );
    {
         rc = _vsnwprintf( szbuffer, 254, Format, marker );
		 szbuffer[255] = (TCHAR)0;
         OutputDebugString( TRACE_TAG );
         OutputDebugString( szbuffer );
    }

    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\ifskit.mrx\smbmrx\sys\ea.c ===
/*++

Copyright (c) 1989 - 1999  Microsoft Corporation

Module Name:

    ea.c

Abstract:

    This module implements the mini redirector call down routines pertaining to query/set ea/security.

--*/

#include "precomp.h"
#pragma hdrstop

//
// Forward declarations.
//



#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, MRxSmbQueryEaInformation)
#pragma alloc_text(PAGE, MRxSmbSetEaInformation)
#pragma alloc_text(PAGE, MRxSmbQuerySecurityInformation)
#pragma alloc_text(PAGE, MRxSmbSetSecurityInformation)
#pragma alloc_text(PAGE, MRxSmbLoadEaList)
#pragma alloc_text(PAGE, MRxSmbNtGeaListToOs2)
#pragma alloc_text(PAGE, MRxSmbNtGetEaToOs2)
#pragma alloc_text(PAGE, MRxSmbQueryEasFromServer)
#pragma alloc_text(PAGE, MRxSmbNtFullEaSizeToOs2)
#pragma alloc_text(PAGE, MRxSmbNtFullListToOs2)
#pragma alloc_text(PAGE, MRxSmbNtFullEaToOs2)
#pragma alloc_text(PAGE, MRxSmbSetEaList)
#endif

////
////  The Bug check file id for this module
////
//
//#define BugCheckFileId                   (RDBSS_BUG_CHECK_LOCAL_CREATE)

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_EA)

//this is the largest EAs that could ever be returned! oh my god!
//this is used to simulate the nt resumable queryEA using the downlevel call
//sigh!
#define EA_QUERY_SIZE 0x0000ffff


//for QueryEA
NTSTATUS
MRxSmbLoadEaList(
    IN PRX_CONTEXT RxContext,
    IN PUCHAR  UserEaList,
    IN ULONG   UserEaListLength,
    OUT PFEALIST *ServerEaList
    );

NTSTATUS
MRxSmbQueryEasFromServer(
    IN PRX_CONTEXT RxContext,
    IN PFEALIST ServerEaList,
    IN PVOID Buffer,
    IN OUT PULONG BufferLengthRemaining,
    IN BOOLEAN ReturnSingleEntry,
    IN BOOLEAN UserEaListSupplied
    );

//for SetEA
NTSTATUS
MRxSmbSetEaList(
//    IN PICB Icb,
//    IN PIRP Irp,
    IN PRX_CONTEXT RxContext,
    IN PFEALIST ServerEaList
    );

VOID MRxSmbExtraEaRoutine(LONG i){
    RxDbgTrace( 0, Dbg, ("MRxSmbExtraEaRoutine i=%08lx\n", i ));
}

NTSTATUS
MRxSmbQueryEaInformation (
    IN OUT PRX_CONTEXT RxContext
    )
{
    NTSTATUS Status;
    RxCaptureFcb;
    RxCaptureFobx;

    PSMBCEDB_SERVER_ENTRY pServerEntry;

    PVOID Buffer = RxContext->Info.Buffer;
    PLONG pLengthRemaining = &RxContext->Info.LengthRemaining;
    PUCHAR  UserEaList = RxContext->QueryEa.UserEaList;
    ULONG   UserEaListLength = RxContext->QueryEa.UserEaListLength;
    ULONG   UserEaIndex = RxContext->QueryEa.UserEaIndex;
    BOOLEAN RestartScan = RxContext->QueryEa.RestartScan;
    BOOLEAN ReturnSingleEntry = RxContext->QueryEa.ReturnSingleEntry;
    BOOLEAN IndexSpecified = RxContext->QueryEa.IndexSpecified;

    PFEALIST ServerEaList = NULL;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbQueryEaInformation\n"));

    pServerEntry = SmbCeGetAssociatedServerEntry(capFcb->pNetRoot->pSrvCall);

    //get rid of nonEA guys right now
    if (!FlagOn(pServerEntry->Server.DialectFlags,DF_SUPPORTEA)) {
        RxDbgTrace(-1, Dbg, ("EAs w/o EA support!\n"));
        return((STATUS_NOT_SUPPORTED));
    }

    Status = MRxSmbDeferredCreate(RxContext);
    if (Status!=STATUS_SUCCESS) {
        goto FINALLY;
    }

    Status = MRxSmbLoadEaList( RxContext, UserEaList, UserEaListLength, &ServerEaList );

    if (( !NT_SUCCESS( Status ) )||
        ( ServerEaList == NULL )) {
        goto FINALLY;
    }

    if (IndexSpecified) {

        capFobx->OffsetOfNextEaToReturn = UserEaIndex;
        Status = MRxSmbQueryEasFromServer(
                    RxContext,
                    ServerEaList,
                    Buffer,
                    pLengthRemaining,
                    ReturnSingleEntry,
                    (BOOLEAN)(UserEaList != NULL) );

        //
        //  if there are no Ea's on the file, and the user supplied an EA
        //  index, we want to map the error to STATUS_NONEXISTANT_EA_ENTRY.
        //

        if ( Status == STATUS_NO_EAS_ON_FILE ) {
            Status = STATUS_NONEXISTENT_EA_ENTRY;
        }
    } else {

        if ( ( RestartScan == TRUE ) || (UserEaList != NULL) ){

            //
            // Ea Indices start at 1, not 0....
            //

            capFobx->OffsetOfNextEaToReturn = 1;
        }

        Status = MRxSmbQueryEasFromServer(  //it is offensive to have two identical calls but oh, well.....
                    RxContext,
                    ServerEaList,
                    Buffer,
                    pLengthRemaining,
                    ReturnSingleEntry,
                    (BOOLEAN)(UserEaList != NULL) );
    }

FINALLY:

    if ( ServerEaList != NULL) {
        RxFreePool(ServerEaList);
    }

    RxDbgTrace(-1, Dbg, ("MRxSmbQueryEaInformation st=%08lx\n",Status));
    return Status;

}

NTSTATUS
MRxSmbSetEaInformation (
    IN OUT struct _RX_CONTEXT * RxContext
    )
{
    NTSTATUS Status;
    RxCaptureFcb; RxCaptureFobx;
    PSMBCEDB_SERVER_ENTRY pServerEntry;

    PVOID Buffer = RxContext->Info.Buffer;
    ULONG Length = RxContext->Info.Length;

    PFEALIST ServerEaList = NULL;
    ULONG Size;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbSetEaInformation\n"));

    pServerEntry = SmbCeGetAssociatedServerEntry(capFcb->pNetRoot->pSrvCall);

    //get rid of nonEA guys right now
    if (!FlagOn(pServerEntry->Server.DialectFlags,DF_SUPPORTEA)) {
        RxDbgTrace(-1, Dbg, ("EAs w/o EA support!\n"));
        return((STATUS_NOT_SUPPORTED));
    }

    Status = MRxSmbDeferredCreate(RxContext);
    if (Status!=STATUS_SUCCESS) {
        goto FINALLY;
    }

    //
    //  Convert Nt format FEALIST to OS/2 format
    //
    Size = MRxSmbNtFullEaSizeToOs2 ( Buffer );
    if ( Size > 0x0000ffff ) {
        Status = STATUS_EA_TOO_LARGE;
        goto FINALLY;
    }

    ServerEaList = RxAllocatePool ( PagedPool, EA_QUERY_SIZE );
    if ( ServerEaList == NULL ) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto FINALLY;
    }

    MRxSmbNtFullListToOs2 ( Buffer, ServerEaList );

    //
    //  Set EAs on the file/directory; if the error is EA_ERROR then SetEaList
    //     sets iostatus.information to the offset of the offender
    //

    Status = MRxSmbSetEaList( RxContext, ServerEaList);

FINALLY:

    if ( ServerEaList != NULL) {
        RxFreePool(ServerEaList);
    }

    RxDbgTrace(-1, Dbg, ("MRxSmbSetEaInformation st=%08lx\n",Status));
    return Status;

}


NTSTATUS
MRxSmbQuerySecurityInformation (
    IN OUT PRX_CONTEXT RxContext
    )
/*++

Routine Description:

    This routine implements the NtQuerySecurityFile api.


Arguments:



Return Value:

    Status - Result of the operation.


--*/

{
   RxCaptureFcb;
   RxCaptureFobx;
   PVOID Buffer = RxContext->Info.Buffer;
   PLONG pLengthRemaining = &RxContext->Info.LengthRemaining;
   PMRX_SMB_SRV_OPEN smbSrvOpen;
   PSMBCEDB_SERVER_ENTRY pServerEntry;

   NTSTATUS Status;

   REQ_QUERY_SECURITY_DESCRIPTOR QuerySecurityRequest;
   RESP_QUERY_SECURITY_DESCRIPTOR QuerySecurityResponse;

   PBYTE  pInputParamBuffer       = NULL;
   PBYTE  pOutputParamBuffer      = NULL;
   PBYTE  pInputDataBuffer        = NULL;
   PBYTE  pOutputDataBuffer       = NULL;

   ULONG  InputParamBufferLength  = 0;
   ULONG  OutputParamBufferLength = 0;
   ULONG  InputDataBufferLength   = 0;
   ULONG  OutputDataBufferLength  = 0;

   PAGED_CODE();

   RxDbgTrace(+1, Dbg, ("MRxSmbQuerySecurityInformation...\n"));

   // Turn away this call from those servers which do not support the NT SMBs

   pServerEntry = SmbCeGetAssociatedServerEntry(capFcb->pNetRoot->pSrvCall);

   if (!FlagOn(pServerEntry->Server.DialectFlags,DF_NT_SMBS)) {
       RxDbgTrace(-1, Dbg, ("QuerySecurityDescriptor not supported!\n"));
       return((STATUS_NOT_SUPPORTED));
   }

   Status = MRxSmbDeferredCreate(RxContext);
   if (Status!=STATUS_SUCCESS) {
       goto FINALLY;
   }

   Status = STATUS_MORE_PROCESSING_REQUIRED;

   smbSrvOpen = MRxSmbGetSrvOpenExtension(capFobx->pSrvOpen);
   ASSERT (!FlagOn(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_NOT_REALLY_OPEN));

   if (Status == STATUS_MORE_PROCESSING_REQUIRED) {
       SMB_TRANSACTION_OPTIONS             TransactionOptions = RxDefaultTransactionOptions;
       SMB_TRANSACTION_RESUMPTION_CONTEXT  ResumptionContext;
       //BOOLEAN printflag;

       TransactionOptions.NtTransactFunction = NT_TRANSACT_QUERY_SECURITY_DESC;
       //TransactionOptions.Flags |= SMB_XACT_FLAGS_COPY_ON_ERROR;

       QuerySecurityRequest.Fid = smbSrvOpen->Fid;
       QuerySecurityRequest.Reserved = 0;
       QuerySecurityRequest.SecurityInformation = RxContext->QuerySecurity.SecurityInformation;

       QuerySecurityResponse.LengthNeeded = 0xbaadbaad;

       //printflag = RxDbgTraceDisableGlobally();//this is debug code anyway!
       //RxDbgTraceEnableGlobally(FALSE);

       Status = SmbCeTransact(
                     RxContext,                    // the RXContext for the transaction
                     &TransactionOptions,          // transaction options
                     NULL,                         // the setup buffer
                     0,                            // input setup buffer length
                     NULL,                         // output setup buffer
                     0,                            // output setup buffer length
                     &QuerySecurityRequest,        // Input Param Buffer
                     sizeof(QuerySecurityRequest), // Input param buffer length
                     &QuerySecurityResponse,       // Output param buffer
                     sizeof(QuerySecurityResponse),// output param buffer length
                     NULL,                         // Input data buffer
                     0,                            // Input data buffer length
                     Buffer,                       // output data buffer
                     *pLengthRemaining,            // output data buffer length
                     &ResumptionContext            // the resumption context
                     );

        //DbgPrint("QSR.len=%x\n", QuerySecurityResponse.LengthNeeded);


        if (NT_SUCCESS(Status) || (Status == STATUS_BUFFER_TOO_SMALL)) {
            ULONG ReturnedDataCount = ResumptionContext.DataBytesReceived;

            RxContext->InformationToReturn = QuerySecurityResponse.LengthNeeded;
            RxDbgTrace(0, Dbg, ("MRxSmbQuerySecurityInformation...ReturnedDataCount=%08lx\n",ReturnedDataCount));
            ASSERT(ResumptionContext.ParameterBytesReceived == sizeof(RESP_QUERY_SECURITY_DESCRIPTOR));

            if (((LONG)(QuerySecurityResponse.LengthNeeded)) > *pLengthRemaining) {
                Status = STATUS_BUFFER_OVERFLOW;
            }

        }

        //RxDbgTraceEnableGlobally(printflag);
    }


FINALLY:

    RxDbgTrace(-1, Dbg, ("MRxSmbQuerySecurityInformation...exit, st=%08lx,info=%08lx\n",
                               Status, RxContext->InformationToReturn));
    return Status;


}

NTSTATUS
MRxSmbSetSecurityInformation (
    IN OUT struct _RX_CONTEXT * RxContext
    )
{
    RxCaptureFcb;
    RxCaptureFobx;

    PMRX_SMB_SRV_OPEN     smbSrvOpen;
    PSMBCEDB_SERVER_ENTRY pServerEntry;

    NTSTATUS Status;

    REQ_SET_SECURITY_DESCRIPTOR SetSecurityRequest;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbSetSecurityInformation...\n"));

    pServerEntry = SmbCeGetAssociatedServerEntry(capFcb->pNetRoot->pSrvCall);

    if (!FlagOn(pServerEntry->Server.DialectFlags,DF_NT_SMBS)) {
        RxDbgTrace(-1, Dbg, ("Set Security Descriptor not supported!\n"));

        return((STATUS_NOT_SUPPORTED));

    }

    Status = MRxSmbDeferredCreate(RxContext);
    if (Status!=STATUS_SUCCESS) {
        goto FINALLY;
    }

    Status = STATUS_MORE_PROCESSING_REQUIRED;

    smbSrvOpen = MRxSmbGetSrvOpenExtension(capFobx->pSrvOpen);

    if (Status == STATUS_MORE_PROCESSING_REQUIRED) {
        SMB_TRANSACTION_OPTIONS             TransactionOptions = RxDefaultTransactionOptions;
        SMB_TRANSACTION_RESUMPTION_CONTEXT  ResumptionContext;
        ULONG SdLength = RtlLengthSecurityDescriptor(RxContext->SetSecurity.SecurityDescriptor);

        TransactionOptions.NtTransactFunction = NT_TRANSACT_SET_SECURITY_DESC;

        SetSecurityRequest.Fid = smbSrvOpen->Fid;
        SetSecurityRequest.Reserved = 0;
        SetSecurityRequest.SecurityInformation = RxContext->SetSecurity.SecurityInformation;

        Status = SmbCeTransact(
                     RxContext,                    // the RXContext for the transaction
                     &TransactionOptions,          // transaction options
                     NULL,                         // the input setup buffer
                     0,                            // input setup buffer length
                     NULL,                         // the output setup buffer
                     0,                            // output setup buffer length
                     &SetSecurityRequest,          // Input Param Buffer
                     sizeof(SetSecurityRequest),   // Input param buffer length
                     NULL,                         // Output param buffer
                     0,                            // output param buffer length
                     RxContext->SetSecurity.SecurityDescriptor,  // Input data buffer
                     SdLength,                     // Input data buffer length
                     NULL,                         // output data buffer
                     0,                            // output data buffer length
                     &ResumptionContext            // the resumption context
                     );

        //the old rdr doesn't return any info...................
        //RxContext->InformationToReturn = SetSecurityResponse.LengthNeeded;

        if ( NT_SUCCESS(Status) ) {
            ULONG ReturnedDataCount = ResumptionContext.DataBytesReceived;

            RxDbgTrace(0, Dbg, ("MRxSmbSetSecurityInformation...ReturnedDataCount=%08lx\n",ReturnedDataCount));
            ASSERT(ResumptionContext.ParameterBytesReceived == 0);
            ASSERT(ResumptionContext.SetupBytesReceived == 0);
            ASSERT(ResumptionContext.DataBytesReceived == 0);
        }
    }


FINALLY:

    RxDbgTrace(-1, Dbg, ("MRxSmbSetSecurityInformation...exit, st=%08lx,info=%08lx\n",
                               Status, RxContext->InformationToReturn));
    return Status;
}


NTSTATUS
MRxSmbLoadEaList(
    IN PRX_CONTEXT RxContext,
    IN PUCHAR  UserEaList,
    IN ULONG   UserEaListLength,
    OUT PFEALIST *ServerEaList
    )

/*++

Routine Description:

    This routine implements the NtQueryEaFile api.
    It returns the following information:


Arguments:


    IN PUCHAR  UserEaList;  - Supplies the Ea names required.
    IN ULONG   UserEaListLength;

    OUT PFEALIST *ServerEaList - Eas returned by the server. Caller is responsible for
                        freeing memory.

Return Value:

    Status - Result of the operation.


--*/

{
   RxCaptureFobx;

   PMRX_SMB_SRV_OPEN smbSrvOpen;


   NTSTATUS Status;
   USHORT Setup = TRANS2_QUERY_FILE_INFORMATION;

   REQ_QUERY_FILE_INFORMATION QueryFileInfoRequest;
   RESP_QUERY_FILE_INFORMATION QueryFileInfoResponse;

   PBYTE  pInputParamBuffer       = NULL;
   PBYTE  pOutputParamBuffer      = NULL;
   PBYTE  pInputDataBuffer        = NULL;
   PBYTE  pOutputDataBuffer       = NULL;

   ULONG  InputParamBufferLength  = 0;
   ULONG  OutputParamBufferLength = 0;
   ULONG  InputDataBufferLength   = 0;
   ULONG  OutputDataBufferLength  = 0;

   CLONG OutDataCount = EA_QUERY_SIZE;

   CLONG OutSetupCount = 0;

   PFEALIST Buffer;

   PGEALIST ServerQueryEaList = NULL;
   CLONG InDataCount;

   PAGED_CODE();

   RxDbgTrace(+1, Dbg, ("MRxSmbLoadEaList...\n"));

   Status = STATUS_MORE_PROCESSING_REQUIRED;

   smbSrvOpen = MRxSmbGetSrvOpenExtension(capFobx->pSrvOpen);

    //
    //  Convert the supplied UserEaList to a GEALIST. The server will return just the Eas
    //  requested by the application.
    //
    //
    //  If the application specified a subset of EaNames then convert to OS/2 1.2 format and
    //  pass that to the server. ie. Use the server to filter out the names.
    //

    Buffer = RxAllocatePool ( PagedPool, OutDataCount );

    if ( Buffer == NULL ) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto FINALLY;
    }

    if ( UserEaList != NULL) {

        //
        //  OS/2 format is always a little less than or equal to the NT UserEaList size.
        //  This code relies on the I/O system verifying the EaList is valid.
        //

        ServerQueryEaList = RxAllocatePool ( PagedPool, UserEaListLength );
        if ( ServerQueryEaList == NULL ) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto FINALLY;
        };

        MRxSmbNtGeaListToOs2((PFILE_GET_EA_INFORMATION )UserEaList, UserEaListLength, ServerQueryEaList );
        InDataCount = (CLONG)ServerQueryEaList->cbList;

    } else {
        InDataCount = 0;
    }

   if (Status == STATUS_MORE_PROCESSING_REQUIRED) {
       PSMB_TRANSACTION_OPTIONS            pTransactionOptions = &RxDefaultTransactionOptions;
       SMB_TRANSACTION_RESUMPTION_CONTEXT  ResumptionContext;

       QueryFileInfoRequest.Fid = smbSrvOpen->Fid;

       if ( UserEaList != NULL) {
           QueryFileInfoRequest.InformationLevel = SMB_INFO_QUERY_EAS_FROM_LIST;
       } else {
           QueryFileInfoRequest.InformationLevel = SMB_INFO_QUERY_ALL_EAS;
       }

       Status = SmbCeTransact(
                     RxContext,                    // the RXContext for the transaction
                     pTransactionOptions,          // transaction options
                     &Setup,                       // the setup buffer
                     sizeof(Setup),                // setup buffer length
                     NULL,                         // the output setup buffer
                     0,                            // output setup buffer length
                     &QueryFileInfoRequest,        // Input Param Buffer
                     sizeof(QueryFileInfoRequest), // Input param buffer length
                     &QueryFileInfoResponse,       // Output param buffer
                     sizeof(QueryFileInfoResponse),// output param buffer length
                     ServerQueryEaList,            // Input data buffer
                     InDataCount,                  // Input data buffer length
                     Buffer,                       // output data buffer
                     OutDataCount,                 // output data buffer length
                     &ResumptionContext            // the resumption context
                     );

        if ( NT_SUCCESS(Status) ) {
            ULONG ReturnedDataCount = ResumptionContext.DataBytesReceived;

            RxDbgTrace(0, Dbg, ("MRxSmbLoadEaList...ReturnedDataCount=%08lx\n",ReturnedDataCount));
            ASSERT(ResumptionContext.ParameterBytesReceived == sizeof(RESP_QUERY_FILE_INFORMATION));

            if ( SmbGetUlong( &((PFEALIST)Buffer)->cbList) != ReturnedDataCount ){
                Status = STATUS_EA_CORRUPT_ERROR;
            }

            if ( ReturnedDataCount == 0 ) {
                Status = STATUS_NO_EAS_ON_FILE;
            }

        }
    }


FINALLY:
    if ( NT_SUCCESS(Status) ) {
        *ServerEaList = Buffer;
    } else {
        if (Buffer != NULL) {
            RxFreePool(Buffer);
        }
    }

    if ( ServerQueryEaList != NULL) {
        RxFreePool(ServerQueryEaList);
    }

    RxDbgTrace(-1, Dbg, ("MRxSmbLoadEaList...exit, st=%08lx\n",Status));
    return Status;

}


VOID
MRxSmbNtGeaListToOs2 (
    IN PFILE_GET_EA_INFORMATION NtGetEaList,
    IN ULONG GeaListLength,
    IN PGEALIST GeaList
    )
/*++

Routine Description:

    Converts a single NT GET EA list to OS/2 GEALIST style.  The GEALIST
    need not have any particular alignment.

Arguments:

    NtGetEaList - An NT style get EA list to be converted to OS/2 format.

    GeaListLength - the maximum possible length of the GeaList.

    GeaList - Where to place the OS/2 1.2 style GEALIST.

Return Value:

    none.

--*/
{

    PGEA gea = GeaList->list;

    PFILE_GET_EA_INFORMATION ntGetEa = NtGetEaList;

    PAGED_CODE();

    //
    // Copy the Eas up until the last one
    //

    while ( ntGetEa->NextEntryOffset != 0 ) {
        //
        // Copy the NT format EA to OS/2 1.2 format and set the gea
        // pointer for the next iteration.
        //

        gea = MRxSmbNtGetEaToOs2( gea, ntGetEa );

        ASSERT( (ULONG_PTR)gea <= (ULONG_PTR)GeaList + GeaListLength );

        ntGetEa = (PFILE_GET_EA_INFORMATION)((PCHAR)ntGetEa + ntGetEa->NextEntryOffset);
    }

    //  Now copy the last entry.

    gea = MRxSmbNtGetEaToOs2( gea, ntGetEa );

    ASSERT( (ULONG_PTR)gea <= (ULONG_PTR)GeaList + GeaListLength );



    //
    // Set the number of bytes in the GEALIST.
    //

    SmbPutUlong(
        &GeaList->cbList,
        (ULONG)((PCHAR)gea - (PCHAR)GeaList)
        );

    UNREFERENCED_PARAMETER( GeaListLength );
}


PGEA
MRxSmbNtGetEaToOs2 (
    OUT PGEA Gea,
    IN PFILE_GET_EA_INFORMATION NtGetEa
    )

/*++

Routine Description:

    Converts a single NT Get EA entry to OS/2 GEA style.  The GEA need not have
    any particular alignment.  This routine makes no checks on buffer
    overrunning--this is the responsibility of the calling routine.

Arguments:

    Gea - a pointer to the location where the OS/2 GEA is to be written.

    NtGetEa - a pointer to the NT Get EA.

Return Value:

    A pointer to the location after the last byte written.

--*/

{
    PCHAR ptr;

    PAGED_CODE();

    Gea->cbName = NtGetEa->EaNameLength;

    ptr = (PCHAR)(Gea) + 1;
    RtlCopyMemory( ptr, NtGetEa->EaName, NtGetEa->EaNameLength );

    ptr += NtGetEa->EaNameLength;
    *ptr++ = '\0';

    return ( (PGEA)ptr );

}


NTSTATUS
MRxSmbQueryEasFromServer(
    IN PRX_CONTEXT RxContext,
    IN PFEALIST ServerEaList,
    IN PVOID Buffer,
    IN OUT PULONG BufferLengthRemaining,
    IN BOOLEAN ReturnSingleEntry,
    IN BOOLEAN UserEaListSupplied
    )

/*++

Routine Description:

    This routine copies the required number of Eas from the ServerEaList
    starting from the offset indicated in the Icb. The Icb is also updated
    to show the last Ea returned.

Arguments:

    IN PFEALIST ServerEaList - Supplies the Ea List in OS/2 format.
    IN PVOID Buffer - Supplies where to put the NT format EAs
    IN OUT PULONG BufferLengthRemaining - Supplies the user buffer space.
    IN BOOLEAN ReturnSingleEntry
    IN BOOLEAN UserEaListSupplied - ServerEaList is a subset of the Eas


Return Value:

    NTSTATUS - The status for the Irp.

--*/

{
    RxCaptureFobx;
    ULONG EaIndex = capFobx->OffsetOfNextEaToReturn;
    ULONG Index = 1;
    ULONG Size;
    ULONG OriginalLengthRemaining = *BufferLengthRemaining;
    BOOLEAN Overflow = FALSE;
    PFEA LastFeaStartLocation;
    PFEA Fea = NULL;
    PFEA LastFea = NULL;
    PFILE_FULL_EA_INFORMATION NtFullEa = Buffer;
    PFILE_FULL_EA_INFORMATION LastNtFullEa = Buffer;

    PAGED_CODE();

    RxDbgTrace(0, Dbg, ("MRxSmbQueryEasFromServer...EaIndex/Buffer/Remaining=%08lx/%08lx/%08lx\n",
                                       EaIndex,Buffer,((BufferLengthRemaining)?*BufferLengthRemaining:0xbadbad)
                       ));

    //
    //  If there are no Ea's present in the list, return the appropriate
    //  error.
    //
    //  Os/2 servers indicate that a list is null if cbList==4.
    //

    if ( SmbGetUlong(&ServerEaList->cbList) == FIELD_OFFSET(FEALIST, list) ) {
        return STATUS_NO_EAS_ON_FILE;
    }

    //
    //  Find the last location at which an FEA can start.
    //

    LastFeaStartLocation = (PFEA)( (PCHAR)ServerEaList +
                               SmbGetUlong( &ServerEaList->cbList ) -
                               sizeof(FEA) - 1 );

    //
    //  Go through the ServerEaList until we find the entry corresponding to EaIndex
    //

    for ( Fea = ServerEaList->list;
          (Fea <= LastFeaStartLocation) && (Index < EaIndex);
          Index+= 1,
          Fea = (PFEA)( (PCHAR)Fea + sizeof(FEA) +
                        Fea->cbName + 1 + SmbGetUshort( &Fea->cbValue ) ) ) {
        NOTHING;
    }

    if ( Index != EaIndex ) {

        if ( Index == EaIndex+1 ) {
            return STATUS_NO_MORE_EAS;
        }

        //
        //  No such index
        //

        return STATUS_NONEXISTENT_EA_ENTRY;
    }

    //
    // Go through the rest of the FEA list, converting from OS/2 1.2 format to NT
    // until we pass the last possible location in which an FEA can start.
    //

    for ( ;
          Fea <= LastFeaStartLocation;
          Fea = (PFEA)( (PCHAR)Fea + sizeof(FEA) +
                        Fea->cbName + 1 + SmbGetUshort( &Fea->cbValue ) ) ) {

        PCHAR ptr;

        //
        //  Calculate the size of this Fea when converted to an NT EA structure.
        //
        //  The last field shouldn't be padded.
        //

        if ((PFEA)((PCHAR)Fea+sizeof(FEA)+Fea->cbName+1+SmbGetUshort(&Fea->cbValue)) < LastFeaStartLocation) {
            Size = SmbGetNtSizeOfFea( Fea );
        } else {
            Size = FIELD_OFFSET(FILE_FULL_EA_INFORMATION, EaName[0]) +
                    Fea->cbName + 1 + SmbGetUshort(&Fea->cbValue);
        }

        //
        //  Will the next Ea fit?
        //

        if ( *BufferLengthRemaining < Size ) {

            if ( LastNtFullEa != NtFullEa ) {

                if ( UserEaListSupplied == TRUE ) {
                    *BufferLengthRemaining = OriginalLengthRemaining;
                    return STATUS_BUFFER_OVERFLOW;
                }

                Overflow = TRUE;

                break;

            } else {

                //  Not even room for a single EA!

                return STATUS_BUFFER_OVERFLOW;
            }
        } else {
            *BufferLengthRemaining -= Size;
        }

        //
        //  We are comitted to copy the Os2 Fea to Nt format in the users buffer
        //

        LastNtFullEa = NtFullEa;
        LastFea = Fea;
        EaIndex++;

        //  Create new Nt Ea

        NtFullEa->Flags = Fea->fEA;
        NtFullEa->EaNameLength = Fea->cbName;
        NtFullEa->EaValueLength = SmbGetUshort( &Fea->cbValue );

        ptr = NtFullEa->EaName;
        RtlCopyMemory( ptr, (PCHAR)(Fea+1), Fea->cbName );

        ptr += NtFullEa->EaNameLength;
        *ptr++ = '\0';

        //
        // Copy the EA value to the NT full EA.
        //

        RtlCopyMemory(
            ptr,
            (PCHAR)(Fea+1) + NtFullEa->EaNameLength + 1,
            NtFullEa->EaValueLength
            );

        ptr += NtFullEa->EaValueLength;

        //
        // Longword-align ptr to determine the offset to the next location
        // for an NT full EA.
        //

        ptr = (PCHAR)( ((ULONG_PTR)ptr + 3) & ~3 );

        NtFullEa->NextEntryOffset = (ULONG)( ptr - (PCHAR)NtFullEa );

        NtFullEa = (PFILE_FULL_EA_INFORMATION)ptr;

        if ( ReturnSingleEntry == TRUE ) {
            break;
        }
    }

    //
    // Set the NextEntryOffset field of the last full EA to 0 to indicate
    // the end of the list.
    //

    LastNtFullEa->NextEntryOffset = 0;

    //
    //  Record position the default start position for the next query
    //

    capFobx->OffsetOfNextEaToReturn = EaIndex;

    if ( Overflow == FALSE ) {
        return STATUS_SUCCESS;
    } else {
        return STATUS_BUFFER_OVERFLOW;
    }

}


ULONG
MRxSmbNtFullEaSizeToOs2 (
    IN PFILE_FULL_EA_INFORMATION NtFullEa
    )

/*++

Routine Description:

    Get the number of bytes that would be required to represent the
    NT full EA list in OS/2 1.2 style.  This routine assumes that
    at least one EA is present in the buffer.

Arguments:

    NtFullEa - a pointer to the list of NT EAs.

Return Value:

    ULONG - number of bytes required to hold the EAs in OS/2 1.2 format.

--*/

{
    ULONG size;

    PAGED_CODE();

    //
    // Walk through the EAs, adding up the total size required to
    // hold them in OS/2 format.
    //

    for ( size = FIELD_OFFSET(FEALIST, list[0]);
          NtFullEa->NextEntryOffset != 0;
          NtFullEa = (PFILE_FULL_EA_INFORMATION)(
                         (PCHAR)NtFullEa + NtFullEa->NextEntryOffset ) ) {

        size += SmbGetOs2SizeOfNtFullEa( NtFullEa );
    }

    size += SmbGetOs2SizeOfNtFullEa( NtFullEa );

    return size;

}


VOID
MRxSmbNtFullListToOs2 (
    IN PFILE_FULL_EA_INFORMATION NtEaList,
    IN PFEALIST FeaList
    )
/*++

Routine Description:

    Converts a single NT FULL EA list to OS/2 FEALIST style.  The FEALIST
    need not have any particular alignment.

    It is the callers responsibility to ensure that FeaList is large enough.

Arguments:

    NtEaList - An NT style get EA list to be converted to OS/2 format.

    FeaList - Where to place the OS/2 1.2 style FEALIST.

Return Value:

    none.

--*/
{

    PFEA fea = FeaList->list;

    PFILE_FULL_EA_INFORMATION ntFullEa = NtEaList;

    PAGED_CODE();

    //
    // Copy the Eas up until the last one
    //

    while ( ntFullEa->NextEntryOffset != 0 ) {
        //
        // Copy the NT format EA to OS/2 1.2 format and set the fea
        // pointer for the next iteration.
        //

        fea = MRxSmbNtFullEaToOs2( fea, ntFullEa );

        ntFullEa = (PFILE_FULL_EA_INFORMATION)((PCHAR)ntFullEa + ntFullEa->NextEntryOffset);
    }

    //  Now copy the last entry.

    fea = MRxSmbNtFullEaToOs2( fea, ntFullEa );


    //
    // Set the number of bytes in the FEALIST.
    //

    SmbPutUlong(
        &FeaList->cbList,
        (ULONG)((PCHAR)fea - (PCHAR)FeaList)
        );

}


PVOID
MRxSmbNtFullEaToOs2 (
    OUT PFEA Fea,
    IN PFILE_FULL_EA_INFORMATION NtFullEa
    )

/*++

Routine Description:

    Converts a single NT full EA to OS/2 FEA style.  The FEA need not have
    any particular alignment.  This routine makes no checks on buffer
    overrunning--this is the responsibility of the calling routine.

Arguments:

    Fea - a pointer to the location where the OS/2 FEA is to be written.

    NtFullEa - a pointer to the NT full EA.

Return Value:

    A pointer to the location after the last byte written.

--*/

{
    PCHAR ptr;

    PAGED_CODE();

    Fea->fEA = (UCHAR)NtFullEa->Flags;
    Fea->cbName = NtFullEa->EaNameLength;
    SmbPutUshort( &Fea->cbValue, NtFullEa->EaValueLength );

    ptr = (PCHAR)(Fea + 1);
    RtlCopyMemory( ptr, NtFullEa->EaName, NtFullEa->EaNameLength );

    ptr += NtFullEa->EaNameLength;
    *ptr++ = '\0';

    RtlCopyMemory(
        ptr,
        NtFullEa->EaName + NtFullEa->EaNameLength + 1,
        NtFullEa->EaValueLength
        );

    return (ptr + NtFullEa->EaValueLength);

}


NTSTATUS
MRxSmbSetEaList(
    IN PRX_CONTEXT RxContext,
    IN PFEALIST ServerEaList
    )

/*++

Routine Description:

    This routine implements the NtQueryEaFile api.
    It returns the following information:


Arguments:

    IN PFEALIST ServerEaList - Eas to be sent to the server.

Return Value:

    Status - Result of the operation.


--*/

{
   RxCaptureFobx;

   PMRX_SMB_SRV_OPEN smbSrvOpen;


   NTSTATUS Status;
   USHORT Setup = TRANS2_SET_FILE_INFORMATION;

   REQ_SET_FILE_INFORMATION SetFileInfoRequest;
   RESP_SET_FILE_INFORMATION SetFileInfoResponse;

   PBYTE  pInputParamBuffer       = NULL;
   PBYTE  pOutputParamBuffer      = NULL;
   PBYTE  pInputDataBuffer        = NULL;
   PBYTE  pOutputDataBuffer       = NULL;

   ULONG  InputParamBufferLength  = 0;
   ULONG  OutputParamBufferLength = 0;
   ULONG  InputDataBufferLength   = 0;
   ULONG  OutputDataBufferLength  = 0;

   PAGED_CODE();

   RxDbgTrace(+1, Dbg, ("MRxSmbSetEaList...\n"));

   Status = STATUS_MORE_PROCESSING_REQUIRED;
   SetFileInfoResponse.EaErrorOffset = 0;

   smbSrvOpen = MRxSmbGetSrvOpenExtension(capFobx->pSrvOpen);

   if (Status == STATUS_MORE_PROCESSING_REQUIRED) {
      PSMB_TRANSACTION_OPTIONS            pTransactionOptions = &RxDefaultTransactionOptions;
      SMB_TRANSACTION_RESUMPTION_CONTEXT  ResumptionContext;

      SetFileInfoRequest.Fid = smbSrvOpen->Fid;
      SetFileInfoRequest.InformationLevel = SMB_INFO_SET_EAS;
      SetFileInfoRequest.Flags = 0;

      Status = SmbCeTransact(
                     RxContext,                    // the RXContext for the transaction
                     pTransactionOptions,          // transaction options
                     &Setup,                        // the setup buffer
                     sizeof(Setup),                // setup buffer length
                     NULL,                         // the output setup buffer
                     0,                            // output setup buffer length
                     &SetFileInfoRequest,          // Input Param Buffer
                     sizeof(SetFileInfoRequest),   // Input param buffer length
                     &SetFileInfoResponse,         // Output param buffer
                     sizeof(SetFileInfoResponse),  // output param buffer length
                     ServerEaList,                 // Input data buffer
                     SmbGetUlong(&ServerEaList->cbList), // Input data buffer length
                     NULL,                         // output data buffer
                     0,                            // output data buffer length
                     &ResumptionContext            // the resumption context
                     );

   }

   if (!NT_SUCCESS(Status)) {
      USHORT EaErrorOffset = SetFileInfoResponse.EaErrorOffset;
      RxDbgTrace( 0, Dbg, ("MRxSmbSetEaList: Failed .. returning %lx/%lx\n",Status,EaErrorOffset));
      RxContext->InformationToReturn = (EaErrorOffset);
   }

   RxDbgTrace(-1, Dbg, ("MRxSmbSetEaList...exit\n"));
   return Status;
}

NTSTATUS
MRxSmbQueryQuotaInformation(
    IN OUT PRX_CONTEXT RxContext)
{
    RxCaptureFobx;

    PMRX_SMB_SRV_OPEN smbSrvOpen;

    NTSTATUS Status;
    USHORT   Setup = NT_TRANSACT_QUERY_QUOTA;

    PSID   StartSid;
    ULONG  StartSidLength;

    REQ_NT_QUERY_FS_QUOTA_INFO  QueryQuotaInfoRequest;
    RESP_NT_QUERY_FS_QUOTA_INFO  QueryQuotaInfoResponse;

    PBYTE  pInputParamBuffer       = NULL;
    PBYTE  pOutputParamBuffer      = NULL;
    PBYTE  pInputDataBuffer        = NULL;
    PBYTE  pOutputDataBuffer       = NULL;

    ULONG  InputParamBufferLength  = 0;
    ULONG  OutputParamBufferLength = 0;
    ULONG  InputDataBufferLength   = 0;
    ULONG  OutputDataBufferLength  = 0;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbQueryQuotaInformation...\n"));

    Status = STATUS_MORE_PROCESSING_REQUIRED;

    if (capFobx != NULL) {
        smbSrvOpen = MRxSmbGetSrvOpenExtension(capFobx->pSrvOpen);
    }

    if ((capFobx == NULL) ||
        (smbSrvOpen == NULL)) {
        Status = STATUS_INVALID_PARAMETER;
    }

    if (Status == STATUS_MORE_PROCESSING_REQUIRED) {

        StartSid       = RxContext->QueryQuota.StartSid;

        if (StartSid != NULL) {
            StartSidLength = RtlLengthRequiredSid(((PISID)StartSid)->SubAuthorityCount);
        } else {
            StartSidLength = 0;
        }

        QueryQuotaInfoRequest.Fid = smbSrvOpen->Fid;

        QueryQuotaInfoRequest.ReturnSingleEntry = RxContext->QueryQuota.ReturnSingleEntry;
        QueryQuotaInfoRequest.RestartScan       = RxContext->QueryQuota.RestartScan;

        QueryQuotaInfoRequest.SidListLength = RxContext->QueryQuota.SidListLength;
        QueryQuotaInfoRequest.StartSidOffset =  ROUND_UP_COUNT(
                                                    RxContext->QueryQuota.SidListLength,
                                                    sizeof(ULONG));
        QueryQuotaInfoRequest.StartSidLength = StartSidLength;


        // The input data buffer to be supplied to the server consists of two pieces
        // of information the start sid and the sid list. Currently the I/O
        // subsystem allocates them in contigous memory. In such cases we avoid
        // another allocation by reusing the same buffer. If this condition is
        // not satisfied we allocate a buffer large enough for both the
        // components and copy them over.

        InputDataBufferLength = ROUND_UP_COUNT(
                                    RxContext->QueryQuota.SidListLength,
                                    sizeof(ULONG)) +
                                StartSidLength;

        QueryQuotaInfoRequest.StartSidLength = StartSidLength;

        if (((PBYTE)RxContext->QueryQuota.SidList +
             ROUND_UP_COUNT(RxContext->QueryQuota.SidListLength,sizeof(ULONG))) !=
            RxContext->QueryQuota.StartSid) {
            pInputDataBuffer = RxAllocatePoolWithTag(
                                   PagedPool,
                                   InputDataBufferLength,
                                   MRXSMB_MISC_POOLTAG);

            if (pInputDataBuffer != NULL) {
                RtlCopyMemory(
                    pInputDataBuffer ,
                    RxContext->QueryQuota.SidList,
                    RxContext->QueryQuota.SidListLength);

                RtlCopyMemory(
                    pInputDataBuffer + QueryQuotaInfoRequest.StartSidOffset,
                    StartSid,
                    StartSidLength);
            } else {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
        } else {
            pInputDataBuffer = (PBYTE)RxContext->QueryQuota.SidList;
        }


        if (Status == STATUS_MORE_PROCESSING_REQUIRED) {
           SMB_TRANSACTION_OPTIONS            TransactionOptions = RxDefaultTransactionOptions;
           SMB_TRANSACTION_RESUMPTION_CONTEXT  ResumptionContext;

           TransactionOptions.NtTransactFunction = NT_TRANSACT_QUERY_QUOTA;

           pOutputDataBuffer      = RxContext->Info.Buffer;
           OutputDataBufferLength = RxContext->Info.LengthRemaining;

           Status = SmbCeTransact(
                        RxContext,                       // the RXContext for the transaction
                        &TransactionOptions,             // transaction options
                        &Setup,                          // the setup buffer
                        sizeof(Setup),                   // setup buffer length
                        NULL,                            // the output setup buffer
                        0,                               // output setup buffer length
                        &QueryQuotaInfoRequest,          // Input Param Buffer
                        sizeof(QueryQuotaInfoRequest),   // Input param buffer length
                        &QueryQuotaInfoResponse,         // Output param buffer
                        sizeof(QueryQuotaInfoResponse),  // output param buffer length
                        pInputDataBuffer,                // Input data buffer
                        InputDataBufferLength,           // Input data buffer length
                        pOutputDataBuffer,               // output data buffer
                        OutputDataBufferLength,          // output data buffer length
                        &ResumptionContext               // the resumption context
                        );
        }

        if ((pInputDataBuffer != NULL) &&
            (pInputDataBuffer != (PBYTE)RxContext->QueryQuota.SidList)) {
            RxFreePool(pInputDataBuffer);
        }
    }

    if (!NT_SUCCESS(Status)) {
        RxContext->InformationToReturn = 0;
    } else {
        RxContext->InformationToReturn = QueryQuotaInfoResponse.Length;
    }

    RxDbgTrace(-1, Dbg, ("MRxSmbQueryQuotaInformation...exit\n"));

    return Status;
}

NTSTATUS
MRxSmbSetQuotaInformation(
    IN OUT PRX_CONTEXT RxContext)
{

    RxCaptureFobx;

    PMRX_SMB_SRV_OPEN smbSrvOpen;

    NTSTATUS Status;
    USHORT Setup = NT_TRANSACT_SET_QUOTA;

    REQ_NT_SET_FS_QUOTA_INFO  SetQuotaInfoRequest;

    PBYTE  pInputParamBuffer       = NULL;
    PBYTE  pOutputParamBuffer      = NULL;
    PBYTE  pInputDataBuffer        = NULL;
    PBYTE  pOutputDataBuffer       = NULL;

    ULONG  InputParamBufferLength  = 0;
    ULONG  OutputParamBufferLength = 0;
    ULONG  InputDataBufferLength   = 0;
    ULONG  OutputDataBufferLength  = 0;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbSetQuotaInformation...\n"));

    Status = STATUS_MORE_PROCESSING_REQUIRED;

    if (capFobx != NULL) {
        smbSrvOpen = MRxSmbGetSrvOpenExtension(capFobx->pSrvOpen);
    }

    if ((capFobx == NULL) ||
        (smbSrvOpen == NULL)) {
        Status = STATUS_INVALID_PARAMETER;
    }

    if (Status == STATUS_MORE_PROCESSING_REQUIRED) {
        SMB_TRANSACTION_OPTIONS             TransactionOptions = RxDefaultTransactionOptions;
        SMB_TRANSACTION_RESUMPTION_CONTEXT  ResumptionContext;

        TransactionOptions.NtTransactFunction = NT_TRANSACT_SET_QUOTA;

        SetQuotaInfoRequest.Fid = smbSrvOpen->Fid;

        pInputDataBuffer      = RxContext->Info.Buffer;
        InputDataBufferLength = RxContext->Info.LengthRemaining;

        Status = SmbCeTransact(
                     RxContext,                       // the RXContext for the transaction
                     &TransactionOptions,             // transaction options
                     &Setup,                          // the setup buffer
                     sizeof(Setup),                   // setup buffer length
                     NULL,                            // the output setup buffer
                     0,                               // output setup buffer length
                     &SetQuotaInfoRequest,            // Input Param Buffer
                     sizeof(SetQuotaInfoRequest),     // Input param buffer length
                     pOutputParamBuffer,              // Output param buffer
                     OutputParamBufferLength,         // output param buffer length
                     pInputDataBuffer,                // Input data buffer
                     InputDataBufferLength,           // Input data buffer length
                     pOutputDataBuffer,               // output data buffer
                     OutputDataBufferLength,          // output data buffer length
                     &ResumptionContext               // the resumption context
                     );
    }

    RxDbgTrace(-1, Dbg, ("MRxSmbSetQuotaInformation...exit\n"));

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\ifskit.mrx\smbmrx\exe\srfunc.h ===
/*++

Copyright (c) 1997 - 1999  Microsoft Corporation

Module Name:

    srfunc.h

Abstract:

--*/

#include "smbmrx.h"

typedef struct {
    LPTSTR pszKey;
    DWORD  dwType;
    DWORD  dwLength;
    PVOID  pvValue;
} REGENTRY, *PREGENTRY;

void
ReadRegistryKeyValues(
    HKEY hKey,
    DWORD Count,
    PREGENTRY pValues);

void
WriteRegistryKeyValues(
    HKEY hKey,
    DWORD Count,
    PREGENTRY pValues);


//
// routines for manipulating registry key values
//

BOOL  GetRegsz ( HKEY hKey, LPTSTR pszKey, PVOID * ppvValue, DWORD *pdwLength );
BOOL  GetRegesz( HKEY hKey, LPTSTR pszKey, PVOID * ppvValue, DWORD *pdwLength );
BOOL  GetRegmsz( HKEY hKey, LPTSTR pszKey, PVOID * ppvValue, DWORD *pdwLength );
BOOL  GetRegdw ( HKEY hKey, LPTSTR pszKey, PVOID * ppvValue, DWORD *pdwLength );

//
// routines for manipulating registry keys
//

BOOL  OpenKey(LPTSTR pszKey, PHKEY phKey);
BOOL  CreateKey(LPTSTR pszKey, PHKEY phKey);
BOOL  AddValue(HKEY hKey, LPTSTR pszKey, DWORD dwType, DWORD dwLength, PVOID pvValue);

ULONG_PTR RdrInstallCheck( void );
BOOL      RdrCompleteSetup( void );


BOOL      RdrInitGlobalContext( void );
BOOL      RdrUninitGlobalContext( void );

BOOL      RdrStart( void );
BOOL      RdrStop( void );
BOOL      RdrLoad( void );
BOOL      RdrUnload( void );
BOOL      RdrDoNothing( void );
BOOL      RdrDoAction( ULONG_PTR action );

ULONG_PTR RdrGetInitialState(void);
ULONG_PTR RdrGetNextState( ULONG_PTR Action, ULONG_PTR CurrentState );

BOOL      RdrSetupServiceEntry( void );
BOOL      RdrSetupProviderOrder( void );

ULONG_PTR RdrGetProviderOrderString( LPTSTR *OrderString );
BOOL      RdrSetProviderOrderString( LPTSTR OrderString );
BOOL      RdrFindProviderInOrder( LPTSTR OrderString, LPTSTR Provider );


typedef BOOL (*ACTIONVECTOR) ( void );

#define RDRSERVICE          TEXT("SmbMRx")
#define PROVIDER_NAME       RDRSERVICE
#define PROVIDER_PATH       TEXT("%SystemRoot%\\System32\\SmbMrxNp.dll")

#define PROVIDER_FILE_PATH  TEXT("\\System32\\SmbMrxNp.dll")
#define DRIVER_FILE_PATH    TEXT("\\System32\\Drivers\\SmbMrx.sys")

#define PROVIDER_ORDER_KEY  TEXT("System\\CurrentControlSet\\Control\\NetworkProvider\\Order")
#define RDRSERVICE_KEY      TEXT("System\\CurrentControlSet\\Services\\") RDRSERVICE
#define WKSSERVICE_KEY      TEXT("System\\CurrentControlSet\\Services\\LanmanWorkstation")


#define SETUP_COMPLETE      0
#define SETUP_MISSING_FILE  1
#define SETUP_INCOMPLETE    2



#define ACTION_LOAD     0
#define ACTION_UNLOAD   1
#define ACTION_START    2
#define ACTION_STOP     3
#define ACTION_TRANS    4
#define ACTION_ERROR    5
#define ACTION_NONE     6
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\ifskit.mrx\smbmrx\sys\downlvlo.c ===
/*++

Copyright (c) 1989 - 1999  Microsoft Corporation

Module Name:

    DownLvlO.c

Abstract:

    This module implements downlevel opens.

--*/

#include "precomp.h"
#pragma hdrstop
////
////  The Bug check file id for this module
////
//
//#define BugCheckFileId                   (RDBSS_BUG_CHECK_LOCAL_CREATE)

//
//  The debug trace level
//

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, MRxSmbGetFileAttributes)
#pragma alloc_text(PAGE, MRxSmbCoreDeleteForSupercedeOrClose)
#pragma alloc_text(PAGE, MRxSmbCoreCheckPath)
#pragma alloc_text(PAGE, MRxSmbCoreOpen)
#pragma alloc_text(PAGE, MRxSmbSetFileAttributes)
#pragma alloc_text(PAGE, MRxSmbCoreCreateDirectory)
#pragma alloc_text(PAGE, MRxSmbCoreCreate)
#pragma alloc_text(PAGE, MRxSmbCloseAfterCoreCreate)
#pragma alloc_text(PAGE, MRxSmbCoreTruncate)
#pragma alloc_text(PAGE, MRxSmbDownlevelCreate)
#pragma alloc_text(PAGE, MRxSmbFinishGFA)
#pragma alloc_text(PAGE, MRxSmbFinishCoreCreate)
#pragma alloc_text(PAGE, MRxSmbPopulateFileInfoInOE)
#pragma alloc_text(PAGE, MRxSmbFinishCoreOpen)
#pragma alloc_text(PAGE, MRxSmbPseudoOpenTailFromCoreCreateDirectory)
#pragma alloc_text(PAGE, MRxSmbPseudoOpenTailFromFakeGFAResponse)
#pragma alloc_text(PAGE, MRxSmbPseudoOpenTailFromGFAResponse)
#pragma alloc_text(PAGE, MRxSmbConvertSmbTimeToTime)
#pragma alloc_text(PAGE, MRxSmbConvertTimeToSmbTime)
#pragma alloc_text(PAGE, MRxSmbTimeToSecondsSince1970)
#pragma alloc_text(PAGE, MRxSmbSecondsSince1970ToTime)
#pragma alloc_text(PAGE, MRxSmbMapSmbAttributes)
#pragma alloc_text(PAGE, MRxSmbMapDisposition)
#pragma alloc_text(PAGE, MRxSmbUnmapDisposition)
#pragma alloc_text(PAGE, MRxSmbMapDesiredAccess)
#pragma alloc_text(PAGE, MRxSmbMapShareAccess)
#pragma alloc_text(PAGE, MRxSmbMapFileAttributes)
#endif

#define Dbg                              (DEBUG_TRACE_CREATE)

#pragma warning(error:4101)   // Unreferenced local variable

VOID
MRxSmbPopulateFileInfoInOE(
    PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
    USHORT FileAttributes,
    ULONG LastWriteTimeInSeconds,
    ULONG FileSize
    );

PVOID
MRxSmbPopulateFcbInitPacketForCore(void);


NTSTATUS
MRxSmbPseudoOpenTailFromGFAResponse (
      PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange
      );
NTSTATUS
MRxSmbPseudoOpenTailFromFakeGFAResponse (
      PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
      RX_FILE_TYPE StorageType
      );
NTSTATUS
MRxSmbPseudoOpenTailFromCoreCreateDirectory (
      PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
      USHORT Attributes
      );

NTSTATUS
MRxSmbGetFileAttributes(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    )
/*++

Routine Description:

   This routine does a GetFileAttributes and remembers the reponse. This routine also
   does the cache for the file information.

Arguments:

    OrdinaryExchange  - an exchange to be used for conducting this open.

Return Value:

    RXSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS Status;

    RxCaptureFcb;
    RxCaptureFobx;

    PMRX_SRV_OPEN     SrvOpen    = NULL;
    PMRX_SMB_SRV_OPEN smbSrvOpen = NULL;

    PUNICODE_STRING RemainingName = GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(RxContext);

    PSMB_EXCHANGE Exchange = (PSMB_EXCHANGE) OrdinaryExchange;
    PSMBCEDB_SERVER_ENTRY pServerEntry = SmbCeGetExchangeServerEntry(Exchange);

    PSMBSTUFFER_BUFFER_STATE StufferState;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbSynchronousGetFileAttributes entering.......OE=%08lx\n",OrdinaryExchange));

    if (FsRtlDoesNameContainWildCards(RemainingName)) {
        Status = STATUS_OBJECT_NAME_INVALID;
        goto FINALLY;
    }

    // If the file has already been opened a QUERY_INFORMATION2 can be issued while
    // QUERY_INFORMATION can only be issued against pseudo opened and not yet
    // opened files.

    if (capFobx != NULL) {
        SrvOpen = capFobx->pSrvOpen;
        if (SrvOpen != NULL)
            smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);
    }

    StufferState = &OrdinaryExchange->AssociatedStufferState;

    if (pServerEntry->Server.Dialect > PCNET1_DIALECT &&
        (smbSrvOpen != NULL) &&
        (!FlagOn(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_NOT_REALLY_OPEN) &&
         !FlagOn(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_DEFERRED_OPEN)   &&
         (NodeType(capFcb) == RDBSS_NTC_STORAGE_TYPE_FILE))) {
        COVERED_CALL(
            MRxSmbStartSMBCommand(
                StufferState,
                SetInitialSMB_ForReuse,
                SMB_COM_QUERY_INFORMATION2,
                SMB_REQUEST_SIZE(QUERY_INFORMATION2),
                NO_EXTRA_DATA,
                SMB_BEST_ALIGNMENT(1,0),
                RESPONSE_HEADER_SIZE_NOT_SPECIFIED,
                0,0,0,0 STUFFERTRACE(Dbg,'FC'))
            );

        MRxSmbDumpStufferState (1100,"SMB w/ GFA before stuffing",StufferState);

        MRxSmbStuffSMB (
            StufferState,
            "0wB!",
                                        //  0         UCHAR WordCount;
            smbSrvOpen->Fid,            //  w         _USHORT(Fid);
            SMB_WCT_CHECK(1)  0         //  B         _USHORT( ByteCount );               // Count of data bytes; min = 2
                                        //            UCHAR Buffer[1];                    // Buffer containing:
            );

        MRxSmbDumpStufferState (700,"SMB w/ GFA after stuffing",StufferState);
    } else {
        COVERED_CALL(
            MRxSmbStartSMBCommand(
                StufferState,
                SetInitialSMB_ForReuse,
                SMB_COM_QUERY_INFORMATION,
                SMB_REQUEST_SIZE(QUERY_INFORMATION),
                NO_EXTRA_DATA,
                SMB_BEST_ALIGNMENT(1,0),
                RESPONSE_HEADER_SIZE_NOT_SPECIFIED,
                0,0,0,0 STUFFERTRACE(Dbg,'FC'))
            );

        MRxSmbDumpStufferState (1100,"SMB w/ GFA before stuffing",StufferState);

        MRxSmbStuffSMB (
            StufferState,
            "0B4!",
                                        //  0         UCHAR WordCount;                    // Count of parameter words = 0
            SMB_WCT_CHECK(0)            //  B         _USHORT( ByteCount );               // Count of data bytes; min = 2
                                        //            UCHAR Buffer[1];                    // Buffer containing:
            RemainingName
                                        //  4         //UCHAR BufferFormat;               //  0x04 -- ASCII
                                        //            //UCHAR FileName[];                 //  File name
            );

        MRxSmbDumpStufferState (700,"SMB w/ GFA after stuffing",StufferState);
    }

    Status = SmbPseOrdinaryExchange(
                 SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                 SMBPSE_OETYPE_GFA
                 );

FINALLY:

    if (NT_SUCCESS(Status)) {
        OrdinaryExchange->Create.StorageTypeFromGFA =
            OrdinaryExchange->Create.FileInfo.Standard.Directory ?
            FileTypeDirectory : FileTypeFile;
    }

    RxDbgTrace(-1, Dbg, ("MRxSmbSynchronousGetFileAttributes exiting.......OE=%08lx, st=%08lx\n",OrdinaryExchange,Status));
    return(Status);
}


NTSTATUS
MRxSmbCoreDeleteForSupercedeOrClose(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE,
    BOOLEAN DeleteDirectory
    )
/*++

Routine Description:

   This routine does a GetFileAttributes and remembers the reponse.

Arguments:

    OrdinaryExchange  - an exchange to be used for conducting this open.

Return Value:

    RXSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS Status;
    RxCaptureFcb;
    RxCaptureFobx;

    PSMB_EXCHANGE Exchange = (PSMB_EXCHANGE) OrdinaryExchange;

    PSMBSTUFFER_BUFFER_STATE StufferState;

    PMRX_SRV_OPEN     SrvOpen    = capFobx->pSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbCoreDeleteForSupercede entering.......OE=%08lx\n",OrdinaryExchange));

    StufferState = &OrdinaryExchange->AssociatedStufferState;

    ASSERT( StufferState );
    ASSERT( OrdinaryExchange->pPathArgument1 != NULL );

    //
    if (!DeleteDirectory) {
        ULONG SearchAttributes = SMB_FILE_ATTRIBUTE_SYSTEM | SMB_FILE_ATTRIBUTE_HIDDEN;  // a la rdr1

        COVERED_CALL(MRxSmbStartSMBCommand (StufferState,SetInitialSMB_ForReuse,SMB_COM_DELETE,
                                    SMB_REQUEST_SIZE(DELETE),
                                    NO_EXTRA_DATA,SMB_BEST_ALIGNMENT(1,0),RESPONSE_HEADER_SIZE_NOT_SPECIFIED,
                                    0,0,0,0 STUFFERTRACE(Dbg,'FC'))
                     );

        MRxSmbDumpStufferState (1100,"SMB w/ del before stuffing",StufferState);

        MRxSmbStuffSMB (StufferState,
             "0wB4!",
                                        //  0         UCHAR WordCount;                    // Count of parameter words = 1
                    SearchAttributes,   //  w         _USHORT( SearchAttributes );
                    SMB_WCT_CHECK(1)    //  B         _USHORT( ByteCount );               // Count of data bytes; min = 2
                                        //            UCHAR Buffer[1];                    // Buffer containing:
                    OrdinaryExchange->pPathArgument1
                                        //  4         //UCHAR BufferFormat;               //  0x04 -- ASCII
                                        //            //UCHAR FileName[];                 //  File name
                 );
    } else {


        COVERED_CALL(MRxSmbStartSMBCommand (StufferState,SetInitialSMB_ForReuse,SMB_COM_DELETE_DIRECTORY,
                                    SMB_REQUEST_SIZE(DELETE_DIRECTORY),
                                    NO_EXTRA_DATA,SMB_BEST_ALIGNMENT(1,0),RESPONSE_HEADER_SIZE_NOT_SPECIFIED,
                                    0,0,0,0 STUFFERTRACE(Dbg,'FC'))
                     );

        MRxSmbDumpStufferState (1100,"SMB w/ rmdir before stuffing",StufferState);

        MRxSmbStuffSMB (StufferState,
             "0B4!",
                                        //  0         UCHAR WordCount;                    // Count of parameter words = 0
                    SMB_WCT_CHECK(0)    //  B         _USHORT( ByteCount );               // Count of data bytes; min = 2
                                        //            UCHAR Buffer[1];                    // Buffer containing:
                    OrdinaryExchange->pPathArgument1
                                        //  4         //UCHAR BufferFormat;               //  0x04 -- ASCII
                                        //            //UCHAR FileName[];                 //  File name
                 );
    }


    MRxSmbDumpStufferState (700,"SMB w/ del/rmdir after stuffing",StufferState);

    Status = SmbPseOrdinaryExchange(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                    SMBPSE_OETYPE_DELETEFORSUPERSEDEORCLOSE
                                    );

    if (Status == STATUS_SUCCESS) {
        SetFlag(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_FILE_DELETED);
    } else {
        RxLog(("Delete File: %x %wZ\n",Status,OrdinaryExchange->pPathArgument1));
    }

FINALLY:
    RxDbgTrace(-1, Dbg, ("MRxSmbCoreDeleteForSupercede exiting.......OE=%08lx, st=%08lx\n",OrdinaryExchange,Status));
    return(Status);
}

NTSTATUS
MRxSmbCoreCheckPath(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    )
/*++

Routine Description:

   This routine does a GetFileAttributes and remembers the reponse.

Arguments:

    OrdinaryExchange  - an exchange to be used for conducting this open.

Return Value:

    RXSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS Status;

    PSMB_EXCHANGE Exchange = (PSMB_EXCHANGE) OrdinaryExchange;

    PSMBSTUFFER_BUFFER_STATE StufferState;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbCoreCheckPath entering.......OE=%08lx\n",
                                                            OrdinaryExchange));
    
    StufferState = &OrdinaryExchange->AssociatedStufferState;

    ASSERT( StufferState );


    COVERED_CALL(MRxSmbStartSMBCommand
                                (StufferState,SetInitialSMB_ForReuse,
                                SMB_COM_CHECK_DIRECTORY,
                                SMB_REQUEST_SIZE(CHECK_DIRECTORY),
                                NO_EXTRA_DATA,SMB_BEST_ALIGNMENT(1,0),
                                RESPONSE_HEADER_SIZE_NOT_SPECIFIED,
                                0,0,0,0 STUFFERTRACE(Dbg,'FC'))
                 );

    MRxSmbDumpStufferState (1100,"SMB w/ chkdir before stuffing",StufferState);

    MRxSmbStuffSMB (StufferState,
         "0B4!",
         //         UCHAR WordCount;       // Count of parameter words = 0
         SMB_WCT_CHECK(0)
         //  B    _USHORT( ByteCount );    // Count of data bytes; min = 2
         //       UCHAR Buffer[1];         // Buffer containing:
         OrdinaryExchange->pPathArgument1
         //  4    UCHAR BufferFormat;      //  0x04 -- ASCII
         //       UCHAR FileName[];        //  File name
    );


    MRxSmbDumpStufferState (700,"SMB w/ chkdir after stuffing",StufferState);

    Status = SmbPseOrdinaryExchange(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                    SMBPSE_OETYPE_CORECHECKDIRECTORY
                                    );

FINALLY:
    RxDbgTrace(-1, Dbg,
                ("MRxSmbCoreCheckPath exiting.......OE=%08lx, st=%08lx\n",
                 OrdinaryExchange,Status)
              );
    return(Status);
}

NTSTATUS
MRxSmbCoreOpen(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE,
    ULONG    OpenShareMode,
    ULONG    Attribute
    )
/*++

Routine Description:

   This routine does a core open.

Arguments:

    OrdinaryExchange  - an exchange to be used for conducting this open.

Return Value:

    RXSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    RxCaptureFcb; //RxCaptureFobx;
    PMRX_SRV_OPEN SrvOpen = RxContext->pRelevantSrvOpen;
    PUNICODE_STRING RemainingName = GET_ALREADY_PREFIXED_NAME(SrvOpen,capFcb);

    PSMB_EXCHANGE Exchange = (PSMB_EXCHANGE) OrdinaryExchange;
    PSMBCE_SERVER pServer = SmbCeGetExchangeServer(Exchange);

    PSMBSTUFFER_BUFFER_STATE StufferState;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbCoreOpen entering.......OE=%08lx\n",OrdinaryExchange));

    StufferState = &OrdinaryExchange->AssociatedStufferState;

    ASSERT( StufferState );
    ASSERT( NodeType(SrvOpen) == RDBSS_NTC_SRVOPEN );
    ASSERT( RxContext->MajorFunction == IRP_MJ_CREATE );

    COVERED_CALL(MRxSmbStartSMBCommand (StufferState,SetInitialSMB_ForReuse,SMB_COM_OPEN,
                                SMB_REQUEST_SIZE(OPEN),
                                NO_EXTRA_DATA,SMB_BEST_ALIGNMENT(1,0),RESPONSE_HEADER_SIZE_NOT_SPECIFIED,
                                0,0,0,0 STUFFERTRACE(Dbg,'FC'))
                 );

    MRxSmbDumpStufferState (1100,"SMB w/ coreopen before stuffing",StufferState);

    MRxSmbStuffSMB (StufferState,
         "0wwB4!",
                                    //  0         UCHAR WordCount;                    // Count of parameter words = 2
                OpenShareMode,      //  w         _USHORT( DesiredAccess );           // Mode - read/write/share
                Attribute,          //  w         _USHORT( SearchAttributes );
                SMB_WCT_CHECK(2)    //  B         _USHORT( ByteCount );               // Count of data bytes; min = 2
                                    //            UCHAR Buffer[1];                    // Buffer containing:
                RemainingName
                                    //  4         //UCHAR BufferFormat;               //  0x04 -- ASCII
                                    //            //UCHAR FileName[];                 //  File name
             );


    MRxSmbDumpStufferState (700,"SMB w/ coreopen after stuffing",StufferState);
    //ASSERT(!"Now it's stuffed");

    Status = SmbPseOrdinaryExchange(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                    SMBPSE_OETYPE_COREOPEN
                                    );

FINALLY:
    RxDbgTrace(-1, Dbg, ("MRxSmbCoreOpen exiting.......OE=%08lx, st=%08lx\n",OrdinaryExchange,Status));
    return(Status);
}

NTSTATUS
MRxSmbSetFileAttributes(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE,
    ULONG SmbAttributes
    )
/*++

Routine Description:

   This routine does a core create directory.....

Arguments:

    OrdinaryExchange  - an exchange to be used for conducting this open.

Return Value:

    RXSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    RxCaptureFcb;
    RxCaptureFobx;
    PMRX_SRV_OPEN     SrvOpen     = NULL;
    PMRX_SMB_SRV_OPEN smbSrvOpen  = NULL;
    PUNICODE_STRING RemainingName = GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(RxContext);

    PSMB_EXCHANGE Exchange = (PSMB_EXCHANGE) OrdinaryExchange;

    ULONG LastWriteTime = 0;
    ULONG FileAttributes = 0;
    PLARGE_INTEGER pCreationTime = NULL;
    PLARGE_INTEGER pLastWriteTime = NULL;
    PLARGE_INTEGER pLastAccessTime = NULL;
    SMB_TIME SmbCreationTime;
    SMB_DATE SmbCreationDate;
    SMB_TIME SmbLastWriteTime;
    SMB_DATE SmbLastWriteDate;
    SMB_TIME SmbLastAccessTime;
    SMB_DATE SmbLastAccessDate;
    
    PSMBSTUFFER_BUFFER_STATE StufferState;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbSetFileAttributes entering.......OE=%08lx\n",OrdinaryExchange));
    StufferState = &OrdinaryExchange->AssociatedStufferState;

    ASSERT( StufferState );

    if (capFobx != NULL) {
        SrvOpen = capFobx->pSrvOpen;
        if (SrvOpen != NULL)
            smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);
    }

    SmbCreationTime.Ushort = 0;
    SmbCreationDate.Ushort = 0;
    SmbLastWriteTime.Ushort = 0;
    SmbLastWriteDate.Ushort = 0;
    SmbLastAccessTime.Ushort = 0;
    SmbLastAccessDate.Ushort = 0;

    if (RxContext->MajorFunction == IRP_MJ_SET_INFORMATION) {
        BOOLEAN GoodTime;
        
        FileAttributes = ((PFILE_BASIC_INFORMATION)OrdinaryExchange->Info.Buffer)->FileAttributes;
        pCreationTime = &((PFILE_BASIC_INFORMATION)OrdinaryExchange->Info.Buffer)->CreationTime;
        pLastWriteTime = &((PFILE_BASIC_INFORMATION)OrdinaryExchange->Info.Buffer)->LastWriteTime;
        pLastAccessTime = &((PFILE_BASIC_INFORMATION)OrdinaryExchange->Info.Buffer)->LastAccessTime;

        if (pLastWriteTime->QuadPart != 0) {
            GoodTime = MRxSmbTimeToSecondsSince1970(
                           pLastWriteTime,
                           SmbCeGetExchangeServer(OrdinaryExchange),
                           &LastWriteTime);

            if (!GoodTime) {
                Status = STATUS_INVALID_PARAMETER;
                goto FINALLY;
            }

            GoodTime = MRxSmbConvertTimeToSmbTime(pLastWriteTime,
                                       (PSMB_EXCHANGE)OrdinaryExchange,
                                       &SmbLastWriteTime,
                                       &SmbLastWriteDate);
        
            if (!GoodTime) {
                Status = STATUS_INVALID_PARAMETER;
                goto FINALLY;
            }
        }
    
        if (pLastAccessTime->QuadPart != 0) {
            GoodTime = MRxSmbConvertTimeToSmbTime(pLastAccessTime,
                                       (PSMB_EXCHANGE)OrdinaryExchange,
                                       &SmbLastAccessTime,
                                       &SmbLastAccessDate);
            
            if (!GoodTime) {
                Status = STATUS_INVALID_PARAMETER;
                goto FINALLY;
            }
        }
    
        if (pCreationTime->QuadPart != 0) {
            GoodTime = MRxSmbConvertTimeToSmbTime(pCreationTime,
                                       (PSMB_EXCHANGE)OrdinaryExchange,
                                       &SmbCreationTime,
                                       &SmbCreationDate);
            
            if (!GoodTime) {
                Status = STATUS_INVALID_PARAMETER;
                goto FINALLY;
            }
        }
    }

    if (smbSrvOpen == NULL ||
        FileAttributes != 0 ||
        RxContext->MajorFunction != IRP_MJ_SET_INFORMATION ||
        FlagOn(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_DEFERRED_OPEN) ||
        FlagOn(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_NOT_REALLY_OPEN) ||
        (pLastWriteTime->QuadPart == 0 && pLastAccessTime->QuadPart == 0 && pCreationTime->QuadPart == 0)) {
        
        COVERED_CALL(MRxSmbStartSMBCommand (StufferState,SetInitialSMB_ForReuse,
                                    SMB_COM_SET_INFORMATION,
                                    SMB_REQUEST_SIZE(SET_INFORMATION),
                                    NO_EXTRA_DATA,SMB_BEST_ALIGNMENT(1,0),RESPONSE_HEADER_SIZE_NOT_SPECIFIED,
                                    0,0,0,0 STUFFERTRACE(Dbg,'FC')));

        MRxSmbDumpStufferState (1100,"SMB w/ sfa before stuffing",StufferState);

        MRxSmbStuffSMB (StufferState,
             "0wdwwwwwB4!",
                                        //  0         UCHAR WordCount;                    // Count of parameter words = 8
                    SmbAttributes,      //  w         _USHORT( FileAttributes );
                    LastWriteTime,      //  d         _ULONG( LastWriteTimeInSeconds );
                    0,0,0,0,0,          //  5*w       _USHORT( Reserved )[5];             // Reserved (must be 0)
                    SMB_WCT_CHECK(8)    //  B         _USHORT( ByteCount );               // Count of data bytes; min = 2
                                        //            UCHAR Buffer[1];                    // Buffer containing:
                    RemainingName
                                        //  4         //UCHAR BufferFormat;               //  0x04 -- ASCII
                                        //            //UCHAR FileName[];                 //  File name
                 );


        MRxSmbDumpStufferState (700,"SMB w/ sfa after stuffing",StufferState);
        //ASSERT(!"Now it's stuffed");

        Status = SmbPseOrdinaryExchange(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                        SMBPSE_OETYPE_SFA);
    } else {
        COVERED_CALL(MRxSmbStartSMBCommand (StufferState,SetInitialSMB_ForReuse,
                                    SMB_COM_SET_INFORMATION2,
                                    SMB_REQUEST_SIZE(SET_INFORMATION2),
                                    NO_EXTRA_DATA,SMB_BEST_ALIGNMENT(1,0),RESPONSE_HEADER_SIZE_NOT_SPECIFIED,
                                    0,0,0,0 STUFFERTRACE(Dbg,'FC')));

        MRxSmbDumpStufferState (1100,"SMB w/ sfa 2 before stuffing",StufferState);

        MRxSmbStuffSMB (StufferState,
             "0wwwwwwwB!",
                                               //  0         UCHAR WordCount;                    // Count of parameter words = 8
             smbSrvOpen->Fid,                  //  w         _USHORT( Fid );                     // File handle
             SmbCreationDate.Ushort,           //  w         SMB_TIME CreationDate;
             SmbCreationTime.Ushort,           //  w         SMB_TIME CreationTime;
             SmbLastAccessDate.Ushort,         //  w         SMB_TIME LastAccessDate;
             SmbLastAccessTime.Ushort,         //  w         SMB_TIME LastAccessTime;
             SmbLastWriteDate.Ushort,          //  w         SMB_TIME LastWriteDate;
             SmbLastWriteTime.Ushort,          //  w         SMB_TIME LastWriteTime;
             SMB_WCT_CHECK(7) 0                //            _USHORT( ByteCount );               // Count of data bytes; min = 0
                                               //            UCHAR Buffer[1];                    // Reserved buffer
             );


        MRxSmbDumpStufferState (700,"SMB w/ sfa 2 after stuffing",StufferState);
        //ASSERT(!"Now it's stuffed");

        Status = SmbPseOrdinaryExchange(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                        SMBPSE_OETYPE_SFA2);
    }

FINALLY:
    RxDbgTrace(-1, Dbg, ("MRxSmbSFAAfterCreateDirectory exiting.......OE=%08lx, st=%08lx\n",OrdinaryExchange,Status));
    return(Status);
}


NTSTATUS
MRxSmbCoreCreateDirectory(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    )
/*++

Routine Description:

   This routine does a core create directory.....

Arguments:

    OrdinaryExchange  - an exchange to be used for conducting this open.

Return Value:

    RXSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS Status;
    RxCaptureFcb; //RxCaptureFobx;
    PMRX_SRV_OPEN SrvOpen = RxContext->pRelevantSrvOpen;
    PUNICODE_STRING RemainingName = GET_ALREADY_PREFIXED_NAME(SrvOpen,capFcb);

    PSMB_EXCHANGE Exchange = (PSMB_EXCHANGE) OrdinaryExchange;

    PSMBSTUFFER_BUFFER_STATE StufferState;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbCoreCreateDirectory entering.......OE=%08lx\n",OrdinaryExchange));
    StufferState = &OrdinaryExchange->AssociatedStufferState;

    ASSERT( StufferState );
    ASSERT( NodeType(SrvOpen) == RDBSS_NTC_SRVOPEN );
    ASSERT( RxContext->MajorFunction == IRP_MJ_CREATE );

    COVERED_CALL(MRxSmbStartSMBCommand (StufferState, SetInitialSMB_ForReuse,
                                SMB_COM_CREATE_DIRECTORY,
                                SMB_REQUEST_SIZE(CREATE_DIRECTORY),
                                NO_EXTRA_DATA,SMB_BEST_ALIGNMENT(1,0),RESPONSE_HEADER_SIZE_NOT_SPECIFIED,
                                0,0,0,0 STUFFERTRACE(Dbg,'FC'))
                 );

    MRxSmbDumpStufferState (1100,"SMB w/ corecreatedir before stuffing",StufferState);

    MRxSmbStuffSMB (StufferState,
         "0B4!",
                                    //  0         UCHAR WordCount;                    // Count of parameter words = 0
                SMB_WCT_CHECK(0)    //  B         _USHORT( ByteCount );               // Count of data bytes; min = 2
                                    //            UCHAR Buffer[1];                    // Buffer containing:
                RemainingName
                                    //  4         //UCHAR BufferFormat;               //  0x04 -- ASCII
                                    //            //UCHAR FileName[];                 //  File name
             );


    MRxSmbDumpStufferState (700,"SMB w/ corecreatedir after stuffing",StufferState);
    //ASSERT(!"Now it's stuffed");

    Status = SmbPseOrdinaryExchange(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                    SMBPSE_OETYPE_CORECREATEDIRECTORY
                                    );

FINALLY:
    RxDbgTrace(-1, Dbg, ("MRxSmbCoreCreateDirectory exiting.......OE=%08lx, st=%08lx\n",OrdinaryExchange,Status));
    return(Status);
}


NTSTATUS
MRxSmbCoreCreate(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE,
    ULONG    Attribute,
    BOOLEAN CreateNew
    )
/*++

Routine Description:

   This routine does a core create.....if the flag is set we use create new.

Arguments:

    OrdinaryExchange  - an exchange to be used for conducting this open.

Return Value:

    RXSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS Status;
    RxCaptureFcb; //RxCaptureFobx;
    PMRX_SRV_OPEN SrvOpen = RxContext->pRelevantSrvOpen;
    PUNICODE_STRING RemainingName = GET_ALREADY_PREFIXED_NAME(SrvOpen,capFcb);

    PSMB_EXCHANGE Exchange = (PSMB_EXCHANGE) OrdinaryExchange;

    PSMBSTUFFER_BUFFER_STATE StufferState;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbCoreCreate entering.......OE=%08lx\n",OrdinaryExchange));
    StufferState = &OrdinaryExchange->AssociatedStufferState;

    ASSERT( StufferState );
    ASSERT( NodeType(SrvOpen) == RDBSS_NTC_SRVOPEN );
    ASSERT( RxContext->MajorFunction == IRP_MJ_CREATE );

    COVERED_CALL(MRxSmbStartSMBCommand (StufferState, SetInitialSMB_ForReuse,
                                (UCHAR)(CreateNew?SMB_COM_CREATE_NEW:SMB_COM_CREATE),
                                SMB_REQUEST_SIZE(CREATE),
                                NO_EXTRA_DATA,SMB_BEST_ALIGNMENT(1,0),RESPONSE_HEADER_SIZE_NOT_SPECIFIED,
                                0,0,0,0 STUFFERTRACE(Dbg,'FC'))
                 );

    MRxSmbDumpStufferState (1100,"SMB w/ coreopen before stuffing",StufferState);

    MRxSmbStuffSMB (StufferState,
         "0wdB4!",
                                    //  0         UCHAR WordCount;                    // Count of parameter words = 3
                Attribute,          //  w         _USHORT( FileAttributes );          // New file attributes
                0,                  //  d         _ULONG( CreationTimeInSeconds );        // Creation time
                SMB_WCT_CHECK(3)    //  B         _USHORT( ByteCount );               // Count of data bytes; min = 2
                                    //            UCHAR Buffer[1];                    // Buffer containing:
                RemainingName
                                    //  4         //UCHAR BufferFormat;               //  0x04 -- ASCII
                                    //            //UCHAR FileName[];                 //  File name
             );


    MRxSmbDumpStufferState (700,"SMB w/ corecreate after stuffing",StufferState);
    //ASSERT(!"Now it's stuffed");

    Status = SmbPseOrdinaryExchange(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                    SMBPSE_OETYPE_CORECREATE
                                    );

FINALLY:
    RxDbgTrace(-1, Dbg, ("MRxSmbCoreCreate exiting.......OE=%08lx, st=%08lx\n",OrdinaryExchange,Status));
    return(Status);
}


NTSTATUS
MRxSmbCloseAfterCoreCreate(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    )
/*++

Routine Description:

   This routine does a close.....

Arguments:

    OrdinaryExchange  - an exchange to be used for conducting this open.

Return Value:

    RXSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS Status;
    RxCaptureFcb; RxCaptureFobx;

    PSMB_EXCHANGE Exchange = (PSMB_EXCHANGE) OrdinaryExchange;

    PSMBSTUFFER_BUFFER_STATE StufferState;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbCloseAfterCoreCreate entering.......OE=%08lx\n",OrdinaryExchange));
    StufferState = &OrdinaryExchange->AssociatedStufferState;

    ASSERT( StufferState );

    COVERED_CALL(MRxSmbStartSMBCommand (StufferState, SetInitialSMB_ForReuse,
                                SMB_COM_CLOSE,
                                SMB_REQUEST_SIZE(CLOSE),
                                NO_EXTRA_DATA,SMB_BEST_ALIGNMENT(1,0),RESPONSE_HEADER_SIZE_NOT_SPECIFIED,
                                0,0,0,0 STUFFERTRACE(Dbg,'FC'))
                 );

    MRxSmbDumpStufferState (1100,"SMB w/ closeaftercorecreate before stuffing",StufferState);

    MRxSmbStuffSMB (StufferState,
         "0wdB!",
                                    //  0         UCHAR WordCount;                    // Count of parameter words = 3
                                    //  w         _USHORT( Fid );                     // File handle
             OrdinaryExchange->Create.FidReturnedFromCreate,
             0,                     //  d         _ULONG( LastWriteTimeInSeconds );   // Time of last write, low and high
             SMB_WCT_CHECK(3) 0     //  B         _USHORT( ByteCount );               // Count of data bytes = 0
                                    //            UCHAR Buffer[1];                    // empty
             );


    MRxSmbDumpStufferState (700,"SMB w/ closeaftercorecreate after stuffing",StufferState);
    //ASSERT(!"Now it's stuffed");

    Status = SmbPseOrdinaryExchange(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                    SMBPSE_OETYPE_CLOSEAFTERCORECREATE
                                    );

FINALLY:
    RxDbgTrace(-1, Dbg, ("MRxSmbCloseAfterCoreCreate exiting.......OE=%08lx, st=%08lx\n",OrdinaryExchange,Status));
    return(Status);
}


NTSTATUS
MRxSmbCoreTruncate(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE,
    ULONG Fid,
    ULONG FileTruncationPoint
    )
/*++

Routine Description:

   This routine does a truncate to implement FILE_OVERWRITE and FILE_OVERWRITE_IF.....
   it is also used in the "extend-for-cached-write" path.

Arguments:

    OrdinaryExchange  - an exchange to be used for conducting this open.

Return Value:

    RXSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS Status;
    RxCaptureFcb; RxCaptureFobx;

    PSMB_EXCHANGE Exchange = (PSMB_EXCHANGE) OrdinaryExchange;

    PSMBSTUFFER_BUFFER_STATE StufferState;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbCoreTruncate entering.......OE=%08lx\n",OrdinaryExchange));
    StufferState = &OrdinaryExchange->AssociatedStufferState;

    ASSERT( StufferState );

    COVERED_CALL(MRxSmbStartSMBCommand (StufferState, SetInitialSMB_ForReuse,
                                SMB_COM_WRITE,
                                SMB_REQUEST_SIZE(WRITE),
                                NO_EXTRA_DATA,SMB_BEST_ALIGNMENT(1,0),RESPONSE_HEADER_SIZE_NOT_SPECIFIED,
                                0,0,0,0  STUFFERTRACE(Dbg,'FC'))
                 )

    MRxSmbDumpStufferState (1100,"SMB w/ coretruncate before stuffing",StufferState);

    MRxSmbStuffSMB (StufferState,
         "0wwdwByw!",
                                    //  0   UCHAR WordCount;                    // Count of parameter words = 5
             Fid,                   //  w   _USHORT( Fid );                     // File handle
             0,                     //  w   _USHORT( Count );                   // Number of bytes to be written
             FileTruncationPoint,   //  d   _ULONG( Offset );                   // Offset in file to begin write
             0,                     //  w   _USHORT( Remaining );               // Bytes remaining to satisfy request
             SMB_WCT_CHECK(5)       //  B   _USHORT( ByteCount );               // Count of data bytes
                                    //      //UCHAR Buffer[1];                  // Buffer containing:
             0x01,                  //  y     UCHAR BufferFormat;               //  0x01 -- Data block
             0                      //  w     _USHORT( DataLength );            //  Length of data
                                    //        ULONG Buffer[1];                  //  Data
             );


    MRxSmbDumpStufferState (700,"SMB w/ coretruncate after stuffing",StufferState);
    //ASSERT(!"Now it's stuffed");

    Status = SmbPseOrdinaryExchange(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                    SMBPSE_OETYPE_CORETRUNCATE
                                    );

    if (Status == STATUS_SUCCESS) {
        LARGE_INTEGER FileSize;

        FileSize.HighPart = 0;
        FileSize.LowPart = FileTruncationPoint;
    }

FINALLY:
    RxDbgTrace(-1, Dbg, ("MRxSmbCoreTruncate exiting.......OE=%08lx, st=%08lx\n",OrdinaryExchange,Status));
    return(Status);
}


NTSTATUS
MRxSmbDownlevelCreate(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    )
/*++

Routine Description:

   This routine implements downlevel creates.

Arguments:

    OrdinaryExchange  - an exchange to be used for conducting this open.

Return Value:

    RXSTATUS - The return status for the operation

Notes:

    For core, in particular, this is pretty painful because a different smb must be used
    for different dispositions. In addition, we cannot really open a directory.

    By in large, we will follow a strategy similar to rdr1. If the openmode maps into something that
    a downlevel server won't understand then we don't really open the file.....we just do a GFA to ensure
    that it's there and hope that we can do path-based ops for the duration.

--*/
{
    NTSTATUS Status = STATUS_NOT_IMPLEMENTED;

    RxCaptureFcb; //RxCaptureFobx;
    PMRX_SRV_OPEN SrvOpen = RxContext->pRelevantSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);
    PUNICODE_STRING PathName = GET_ALREADY_PREFIXED_NAME(SrvOpen,capFcb);
    PNT_CREATE_PARAMETERS cp = &RxContext->Create.NtCreateParameters;

    ULONG CreateOptions = cp->CreateOptions;
    ULONG FileAttributes =  cp->FileAttributes;
    ACCESS_MASK   DesiredAccess = cp->DesiredAccess;
    USHORT        ShareAccess = (USHORT)(cp->ShareAccess);
    ULONG         Disposition = cp->Disposition;

    USHORT mappedDisposition = MRxSmbMapDisposition(Disposition);
    USHORT mappedSharingMode = MRxSmbMapShareAccess(ShareAccess);
    USHORT mappedAttributes  = MRxSmbMapFileAttributes(FileAttributes);
    USHORT mappedOpenMode    = MRxSmbMapDesiredAccess(DesiredAccess);

    LARGE_INTEGER AllocationSize = cp->AllocationSize;

    PMRXSMB_RX_CONTEXT pMRxSmbContext = MRxSmbGetMinirdrContext(RxContext);

    PSMB_EXCHANGE Exchange = (PSMB_EXCHANGE) OrdinaryExchange;
    PSMBCE_SERVER pServer = SmbCeGetExchangeServer(Exchange);

    PSMBSTUFFER_BUFFER_STATE StufferState;

    BOOLEAN MustBeAFile = (MustBeFile(CreateOptions)!=0);
    BOOLEAN MustBeADirectory = (MustBeDirectory(CreateOptions)!=0)
                                    || BooleanFlagOn(RxContext->Create.Flags,RX_CONTEXT_CREATE_FLAG_STRIPPED_TRAILING_BACKSLASH);
    BOOLEAN ItsADirectory = FALSE;
    BOOLEAN ItsTheShareRoot = FALSE;

    PAGED_CODE();
    
    // Down level protocols don't have the execute mode.
    if (mappedOpenMode == (USHORT)SMB_DA_ACCESS_EXECUTE)
        mappedOpenMode = (USHORT)SMB_DA_ACCESS_READ;

    RxDbgTrace(+1, Dbg, ("MRxSmbDownlevelCreate entering.......OE=%08lx\n",OrdinaryExchange));
    RxDbgTrace( 0, Dbg, ("mapAtt,Shr,Disp,OM %04lx,%04lx,%04lx,%04lx\n",
                                  mappedAttributes,mappedSharingMode,mappedDisposition,mappedOpenMode));

    SmbPseOEAssertConsistentLinkageFromOE("Downlevel Create:");

    StufferState = &OrdinaryExchange->AssociatedStufferState;

    if (OrdinaryExchange->Create.CreateWithEasSidsOrLongName) {
        Status = STATUS_NOT_SUPPORTED;
        goto FINALLY;
    }

    if (AllocationSize.HighPart != 0) {
        Status = STATUS_INVALID_PARAMETER;
        goto FINALLY;
    }


    ASSERT( NodeType(SrvOpen) == RDBSS_NTC_SRVOPEN );
    OrdinaryExchange->Create.smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);
    OrdinaryExchange->pPathArgument1 = PathName;

    //
    // we know that the root a share exists and that it's a directory....the catch is that GetFileAttributes
    // will return a NO_SUCH_FILE error for the root if it's really a root on the server. record this and use it
    // to our advantage later.
    if ((PathName->Length == 0)
           || ((PathName->Length == sizeof(WCHAR)) && (PathName->Buffer[0] == OBJ_NAME_PATH_SEPARATOR))  ) {
        //if must be a file, it's an error.........
        if (MustBeAFile) {
            Status = STATUS_FILE_IS_A_DIRECTORY;
            goto FINALLY;
        }

        //
        //if it's the right kind of open, i can just finish up now. these opens are common for GetFSInfo

        if ((Disposition == FILE_OPEN) || (Disposition == FILE_OPEN_IF)) {
            Status = MRxSmbPseudoOpenTailFromFakeGFAResponse ( OrdinaryExchange, FileTypeDirectory );
            goto FINALLY;
        }
        MustBeADirectory = TRUE;   // we know it's a directory!
        ItsTheShareRoot = TRUE;
    }

    //// if all the user wants is attributes and it's a FILE_OPEN, don't do the open now....
    //// rather, we'll send pathbased ops later (or do a deferred open if necessary)...
    
    if (Disposition == FILE_OPEN && 
        (MustBeADirectory || 
         !(cp->DesiredAccess & ~(SYNCHRONIZE | DELETE | FILE_READ_ATTRIBUTES)))) {
        Status = MRxSmbPseudoOpenTailFromFakeGFAResponse(OrdinaryExchange, MustBeADirectory?FileTypeDirectory:FileTypeFile);
        
        if (Status == STATUS_SUCCESS) {
            Status = MRxSmbQueryFileInformationFromPseudoOpen(
                         SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS);

            if (Status == STATUS_SUCCESS) {
                if (MustBeADirectory && 
                    !OrdinaryExchange->Create.FileInfo.Standard.Directory) {
                    Status = STATUS_NOT_A_DIRECTORY;
                }

                if (MustBeAFile &&
                    OrdinaryExchange->Create.FileInfo.Standard.Directory) {
                    Status = STATUS_FILE_IS_A_DIRECTORY;
                }
            }

            if (Status != STATUS_SUCCESS) {
                RxFreePool(smbSrvOpen->DeferredOpenContext);
            }
        }

        goto FINALLY;
    }

    if ( (mappedOpenMode == ((USHORT)-1)) ||
         (Disposition == FILE_SUPERSEDE) ||
         (!MustBeAFile)
       ) {

        //
        // go find out what's there.......

        Status = MRxSmbGetFileAttributes(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS);

        if (Status == STATUS_SUCCESS && 
            MustBeADirectory &&
            !OrdinaryExchange->Create.FileInfo.Standard.Directory) {
            Status = STATUS_NOT_A_DIRECTORY;
            goto FINALLY;
        }
        
        RxDbgTrace(0, Dbg, ("MRxSmbDownlevelCreate GFAorCPstatus=%08lx\n",Status));

        if (NT_SUCCESS(Status)) {
            ULONG Attributes = SmbGetUshort(&OrdinaryExchange->Create.FileInfo.Basic.FileAttributes);
            ItsADirectory = BooleanFlagOn(Attributes,SMB_FILE_ATTRIBUTE_DIRECTORY);
            RxDbgTrace(0, Dbg, ("MRxSmbDownlevelCreate attributes=%08lx\n",Attributes));
            if ((Disposition==FILE_CREATE)) {
                Status = STATUS_OBJECT_NAME_COLLISION;
                goto FINALLY;
            }
            if (MustBeADirectory && !ItsADirectory && (Disposition!=FILE_SUPERSEDE)) {
                if (Disposition == FILE_OPEN) {
                    // This fix is required for the DFS driver which seems to handle
                    // STATUS_OBJECT_TYPE_MISMATCH in a special way.
                    // DFS should be fixed.
                    Status = STATUS_OBJECT_NAME_COLLISION;
                } else {
                    Status = STATUS_OBJECT_TYPE_MISMATCH;
                }
                goto FINALLY;
            }
            if (MustBeAFile && ItsADirectory && (Disposition!=FILE_SUPERSEDE)) {
                if (Disposition == FILE_OPEN) {
                    // This fix is required for the DFS driver which seems to handle
                    // STATUS_OBJECT_TYPE_MISMATCH in a special way.
                    // DFS should be fixed.
                    Status = STATUS_FILE_IS_A_DIRECTORY;
                } else {
                    Status = STATUS_OBJECT_TYPE_MISMATCH;
                }
                goto FINALLY;
            }
            //if (!MustBeAFile && ItsADirectory && (Disposition==FILE_OPEN)){
            if (Disposition==FILE_OPEN || Disposition==FILE_OPEN_IF){
                //we're done except to finish AND to set the flags in the srvopen
                MRxSmbPseudoOpenTailFromGFAResponse ( OrdinaryExchange );
                goto FINALLY;
            }
        } else if ( (Status!=STATUS_NO_SUCH_FILE)
                           && (Status!=STATUS_OBJECT_PATH_NOT_FOUND) ) {
            goto FINALLY;
        } else if ((Disposition==FILE_CREATE)
                     || (Disposition==FILE_OPEN_IF)
                     || (Disposition==FILE_OVERWRITE_IF)
                     || (Disposition==FILE_SUPERSEDE)) {
            NOTHING;
        } else if (ItsTheShareRoot) {
            SrvOpen = RxContext->pRelevantSrvOpen;
            smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);
            //here we have run into a true root....so we can't get attributes. fill in a fake
            //response and finish. also, flip the bit that says we can't gfa this guy.
            Status = MRxSmbPseudoOpenTailFromFakeGFAResponse ( OrdinaryExchange, FileTypeDirectory );
            smbSrvOpen->Flags |= SMB_SRVOPEN_FLAG_CANT_GETATTRIBS;
            goto FINALLY;
        } else {
            goto FINALLY;
        }
    }


    SmbCeResetExchange(&OrdinaryExchange->Exchange);  //must reset!

    if (NT_SUCCESS(Status) &&(Disposition == FILE_SUPERSEDE)) {
        //
        //we have to get rid of the existing entity...using a delete or a rmdir as appropriate
        Status = MRxSmbCoreDeleteForSupercedeOrClose(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                                      OrdinaryExchange->Create.FileInfo.Standard.Directory
                                                     );
        if (!NT_SUCCESS(Status)) {
            RxDbgTrace(0, Dbg, ("MRxSmbDownlevelCreate could notsupersede st=%08lx\n",Status));
            goto FINALLY;
        }
        SmbCeResetExchange(&OrdinaryExchange->Exchange);  //must reset!
    }

    if (MustBeADirectory || (ItsADirectory &&(Disposition == FILE_SUPERSEDE)) ) {

        ASSERT (Disposition!=FILE_OPEN);
        Status = MRxSmbCoreCreateDirectory(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS);
        if (!NT_SUCCESS(Status)) {
            RxDbgTrace(0, Dbg, ("MRxSmbDownlevelCreate couldn't mkdir st=%08lx\n",Status));
            goto FINALLY;
        }

        if ((mappedAttributes &
             (SMB_FILE_ATTRIBUTE_READONLY |
              SMB_FILE_ATTRIBUTE_HIDDEN   |
              SMB_FILE_ATTRIBUTE_SYSTEM   |
              SMB_FILE_ATTRIBUTE_ARCHIVE)) != 0) {
            //
            //we have to set the attributes
            Status = MRxSmbSetFileAttributes(
                         SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                         mappedAttributes);

            if (!NT_SUCCESS(Status)) {
                RxDbgTrace(0, Dbg, ("MRxSmbDownlevelCreate couldn't sfa st=%08lx\n",Status));
            }
        }

        MRxSmbPseudoOpenTailFromCoreCreateDirectory( OrdinaryExchange, mappedAttributes );

        goto FINALLY;
    }


    //if ( (mappedOpenMode != -1) && !MustBeADirectory) {
    //no pseudoOpens yet
    if ( TRUE ) {

        ULONG workingDisposition = Disposition;
        ULONG iterationcount;
        BOOLEAN MayNeedATruncate = FALSE;

       //
       // we use the disposition as a state and case out.....some are hard and some are easy
       //     for example, if it's CREATE then we use the CREATE_NEW to create the file but
       //                  the resulting open is no good so we close it and open it again using the
       //                  open. for OPEN_IF  we assume that the file will be there
       //                  and drop into create if it's not.

       for (iterationcount=0;;iterationcount++) {
           switch (workingDisposition) {
           case FILE_OVERWRITE:
           case FILE_OVERWRITE_IF:
               MayNeedATruncate = TRUE;
               //lack of break intentional
           case FILE_OPEN_IF:
           case FILE_OPEN:
               Status = MRxSmbCoreOpen(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                           mappedOpenMode|mappedSharingMode,
                                           mappedAttributes);
               //if (Status==RxStatus(NO_SUCH_FILE)) {
               //    DbgPrint("%08lx %08lx %08lx\n",Status,workingDisposition,iterationcount);
               //    DbgBreakPoint();
               //}
               if (!((workingDisposition == FILE_OPEN_IF) || (workingDisposition == FILE_OVERWRITE_IF))
                    || (Status!=STATUS_NO_SUCH_FILE)
                    || (iterationcount>6)
                    )break;
               SmbCeResetExchange(&OrdinaryExchange->Exchange);  //must reset!
           case FILE_SUPERSEDE:
           case FILE_CREATE:
               Status = MRxSmbCoreCreate(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                           mappedAttributes,TRUE); //(workingDisposition==FILE_CREATE));
               if (!NT_SUCCESS(Status)) {
                    RxDbgTrace(-1, Dbg, ("MRxSmbDownlevelCreate exiting.......createnew failed st=%08lx\n",Status));
                    break;
               }

               //now, we have a network handle. BUT, it's a compatibility-mode open. since we don't want that we
               //     need to close and reopen with the parameters specified. there is a window here! what can i do??

               Status = MRxSmbCloseAfterCoreCreate(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS);
               if (!NT_SUCCESS(Status)) {
                    RxDbgTrace(-1, Dbg, ("MRxSmbDownlevelCreate exiting.......closeaftercreatenew failed st=%08lx\n",Status));
                    break;
               }

               workingDisposition = FILE_OPEN_IF;
               continue;     // this wraps back to the switch with a new disposition
               //break;
           //case FILE_SUPERSEDE:
           //    Status = RxStatus(NOT_SUPPORTED);
           //    break;
           default :
               ASSERT(!"Bad Disposition");
               Status = STATUS_INVALID_PARAMETER;
           }
           break; //exit the loop
       }
       if (!NT_SUCCESS(Status))goto FINALLY;
       //we may need a truncate....this is different from rdr1.
       if (MayNeedATruncate
                 && !OrdinaryExchange->Create.FileWasCreated
                 && (OrdinaryExchange->Create.FileSizeReturnedFromOpen!=0)  ) {
           Status = MRxSmbCoreTruncate(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                       OrdinaryExchange->Create.FidReturnedFromOpen,
                                       0
           );
       }

       goto FINALLY;
    }

FINALLY:
    RxDbgTrace(-1, Dbg, ("MRxSmbDownlevelCreate exiting.......OE=%08lx, st=%08lx\n",OrdinaryExchange,Status));
    return(Status);
}

NTSTATUS
MRxSmbFinishGFA (
      PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
      PBYTE                       Response
      )
/*++

Routine Description:

    This routine copies the response to the GetFileAttributes SMB. But, it must be called synchronously.

Arguments:

    OrdinaryExchange - the exchange instance
    Response - the response

Return Value:

    RXSTATUS - The return status for the operation

Notes:

    what we do here is to put the data into the ordinary exchange...it's locked down do
    we could do this at DPC level

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PFILE_BASIC_INFORMATION BasicInformation = &OrdinaryExchange->Create.FileInfo.Basic;
    PFILE_STANDARD_INFORMATION StandardInformation = &OrdinaryExchange->Create.FileInfo.Standard;

    PSMB_PARAMS pSmbParams = (PSMB_PARAMS)Response;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbFinishGFA\n", 0 ));
    SmbPseOEAssertConsistentLinkageFromOE("MRxSmbFinishGFA:");

    if (pSmbParams->WordCount == 10) {
        PRESP_QUERY_INFORMATION pQueryInformationResponse;

        pQueryInformationResponse = (PRESP_QUERY_INFORMATION)Response;

        //what we do here is to put the data into the ordinary exchange...it's locked down do
        //we wcould do this at DPC level

        MRxSmbPopulateFileInfoInOE(
            OrdinaryExchange,
            SmbGetUshort(&pQueryInformationResponse->FileAttributes),
            SmbGetUlong(&pQueryInformationResponse->LastWriteTimeInSeconds),
            SmbGetUlong(&pQueryInformationResponse->FileSize)
            );

    } else if (pSmbParams->WordCount == 11) {
        PRESP_QUERY_INFORMATION2 pQueryInformation2Response;
        SMB_TIME                 LastWriteSmbTime;
        SMB_DATE                 LastWriteSmbDate;
        LARGE_INTEGER            LastWriteTime;
        ULONG                    LastWriteTimeInSeconds;

        pQueryInformation2Response = (PRESP_QUERY_INFORMATION2)Response;

        RtlCopyMemory(
            &LastWriteSmbTime,
            &pQueryInformation2Response->LastWriteTime,
            sizeof(SMB_TIME));

        RtlCopyMemory(
            &LastWriteSmbDate,
            &pQueryInformation2Response->LastWriteDate,
            sizeof(SMB_DATE));

        LastWriteTime = MRxSmbConvertSmbTimeToTime(NULL,LastWriteSmbTime,LastWriteSmbDate);

        MRxSmbTimeToSecondsSince1970(
            &LastWriteTime,
            NULL,
            &LastWriteTimeInSeconds);

        MRxSmbPopulateFileInfoInOE(
            OrdinaryExchange,
            SmbGetUshort(&pQueryInformation2Response->FileAttributes),
            LastWriteTimeInSeconds,
            SmbGetUlong(&pQueryInformation2Response->FileDataSize)
            );
    }

    RxDbgTrace(-1, Dbg, ("MRxSmbFinishGFA   returning %08lx\n", Status ));
    return Status;
}

NTSTATUS
MRxSmbCreateFileSuccessTail (
    PRX_CONTEXT  RxContext,
    PBOOLEAN MustRegainExclusiveResource,
    RX_FILE_TYPE StorageType,
    SMB_FILE_ID Fid,
    ULONG ServerVersion,
    UCHAR OplockLevel,
    ULONG CreateAction,
    PSMBPSE_FILEINFO_BUNDLE FileInfo
    );

NTSTATUS
MRxSmbFinishCoreCreate (
      PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
      PRESP_CREATE                Response
      )
/*++

Routine Description:

    This routine copies the fid from a core create response. it does not finish the fcb......if a compatibility
    mode open is acceptable then it could.

Arguments:

    OrdinaryExchange - the exchange instance
    Response - the response

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbFinishCoreCreate\n", 0 ));
    SmbPseOEAssertConsistentLinkageFromOE("MRxSmbFinishCoreCreate:");

    if (Response->WordCount != 1 ||
        SmbGetUshort(&Response->ByteCount) != 0) {
        Status = STATUS_INVALID_NETWORK_RESPONSE;
        OrdinaryExchange->Status = STATUS_INVALID_NETWORK_RESPONSE;
    } else {
        OrdinaryExchange->Create.FidReturnedFromCreate = SmbGetUshort(&Response->Fid);
        OrdinaryExchange->Create.FileWasCreated = TRUE;
        //notice that we didn't finish here! we should IFF a compatibilty-mode open is okay
    }

    RxDbgTrace(-1, Dbg, ("MRxSmbFinishCoreCreate   returning %08lx\n", Status ));
    return Status;
}

#define JUST_USE_THE_STUFF_IN_THE_OE (0xfbad)
VOID
MRxSmbPopulateFileInfoInOE(
    PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
    USHORT FileAttributes,
    ULONG LastWriteTimeInSeconds,
    ULONG FileSize
    )
{
    PFILE_BASIC_INFORMATION BasicInformation = &OrdinaryExchange->Create.FileInfo.Basic;
    PFILE_STANDARD_INFORMATION StandardInformation = &OrdinaryExchange->Create.FileInfo.Standard;

    BasicInformation->FileAttributes = MRxSmbMapSmbAttributes(FileAttributes);
    StandardInformation->NumberOfLinks = 1;
    BasicInformation->CreationTime.QuadPart = 0;
    BasicInformation->LastAccessTime.QuadPart = 0;
    MRxSmbSecondsSince1970ToTime(LastWriteTimeInSeconds,
                                 SmbCeGetExchangeServer(OrdinaryExchange),
                                 &BasicInformation->LastWriteTime);
    BasicInformation->ChangeTime.QuadPart = 0;
    StandardInformation->AllocationSize.QuadPart = FileSize; //rdr1 actually rounds up based of svr disk attribs
    StandardInformation->EndOfFile.QuadPart = FileSize;
    StandardInformation->Directory = BooleanFlagOn(BasicInformation->FileAttributes,FILE_ATTRIBUTE_DIRECTORY);
}


NTSTATUS
MRxSmbFinishCoreOpen (
      PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
      PRESP_OPEN                  Response
      )
/*++

Routine Description:

    This routine finishes a core open.

Arguments:

    OrdinaryExchange - the exchange instance
    Response - the response

Return Value:

    RXSTATUS - The return status for the operation

--*/
{

    NTSTATUS Status = STATUS_SUCCESS;
    PRX_CONTEXT RxContext = OrdinaryExchange->RxContext;
    PMRX_SRV_OPEN        SrvOpen = RxContext->pRelevantSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);
    PSMBPSE_FILEINFO_BUNDLE pFileInfo = &smbSrvOpen->FileInfo;

    RX_FILE_TYPE StorageType;
    SMB_FILE_ID Fid;
    ULONG CreateAction;

    ULONG FileSize;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbFinishCoreOpen\n", 0 ));
    SmbPseOEAssertConsistentLinkageFromOE("MRxSmbFinishCoreOpen:");

    if (Response->WordCount != 7 ||
        SmbGetUshort(&Response->ByteCount) != 0) {
        Status = STATUS_INVALID_NETWORK_RESPONSE;
        OrdinaryExchange->Status = STATUS_INVALID_NETWORK_RESPONSE;
        goto FINALLY;
    }

    StorageType = FileTypeFile;
    Fid = SmbGetUshort(&Response->Fid);
    OrdinaryExchange->Create.FidReturnedFromOpen = Fid;
    FileSize = OrdinaryExchange->Create.FileSizeReturnedFromOpen = SmbGetUlong(&Response->DataSize);

    CreateAction = (OrdinaryExchange->Create.FileWasCreated)?FILE_CREATED
                        : (OrdinaryExchange->Create.FileWasTruncated)?FILE_OVERWRITTEN
                        :FILE_OPENED;

    MRxSmbPopulateFileInfoInOE(
        OrdinaryExchange,
        SmbGetUshort(&Response->FileAttributes),
        SmbGetUlong(&Response->LastWriteTimeInSeconds),
        FileSize
        );

    pFileInfo->Basic.FileAttributes    = OrdinaryExchange->Create.FileInfo.Basic.FileAttributes;
    pFileInfo->Basic.CreationTime      = OrdinaryExchange->Create.FileInfo.Basic.CreationTime;
    pFileInfo->Basic.LastAccessTime    = OrdinaryExchange->Create.FileInfo.Basic.LastAccessTime;
    pFileInfo->Basic.LastWriteTime     = OrdinaryExchange->Create.FileInfo.Basic.LastWriteTime;
    pFileInfo->Basic.ChangeTime        = OrdinaryExchange->Create.FileInfo.Basic.ChangeTime;
    pFileInfo->Standard.NumberOfLinks  = OrdinaryExchange->Create.FileInfo.Standard.NumberOfLinks;
    pFileInfo->Standard.AllocationSize = OrdinaryExchange->Create.FileInfo.Standard.AllocationSize;
    pFileInfo->Standard.EndOfFile      = OrdinaryExchange->Create.FileInfo.Standard.EndOfFile;
    pFileInfo->Standard.Directory      = FALSE;

    MRxSmbCreateFileSuccessTail (   RxContext,
                                    &OrdinaryExchange->Create.MustRegainExclusiveResource,
                                    StorageType,
                                    Fid,
                                    OrdinaryExchange->ServerVersion,
                                    SMB_OPLOCK_LEVEL_NONE,
                                    CreateAction,
                                    pFileInfo);

FINALLY:
    IF_DEBUG{
        RxCaptureFcb;
        RxDbgTrace(-1, Dbg, ("MRxSmbFinishCoreOpen   returning %08lx, fcbstate =%08lx\n", Status, capFcb->FcbState ));
    }
    return Status;
}

NTSTATUS
MRxSmbPseudoOpenTailFromCoreCreateDirectory (
      PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
      USHORT Attributes
      )
/*++

Routine Description:

    This routine finishes a core create directory. but, it is not called from the receive routine......

Arguments:

    OrdinaryExchange - the exchange instance

Return Value:

    RXSTATUS - The return status for the operation

--*/
{

    NTSTATUS Status = STATUS_SUCCESS;
    PRX_CONTEXT RxContext = OrdinaryExchange->RxContext;
    RxCaptureFobx;
    PMRX_SRV_OPEN SrvOpen = RxContext->pRelevantSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);
    PSMBPSE_FILEINFO_BUNDLE pFileInfo = &smbSrvOpen->FileInfo;

    RX_FILE_TYPE StorageType;
    SMB_FILE_ID Fid;
    ULONG CreateAction;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbFinishCoreCreateDirectory\n", 0 ));
    SmbPseOEAssertConsistentLinkageFromOE("MRxSmbFinishCoreCreateDirectory:");

    StorageType = FileTypeDirectory;
    Fid = 0xbadd;

    CreateAction = FILE_CREATED;
    MRxSmbPopulateFileInfoInOE(
        OrdinaryExchange,
        Attributes,
        0,
        0
        );

    pFileInfo->Basic.FileAttributes    = OrdinaryExchange->Create.FileInfo.Basic.FileAttributes;
    pFileInfo->Basic.CreationTime      = OrdinaryExchange->Create.FileInfo.Basic.CreationTime;
    pFileInfo->Basic.LastAccessTime    = OrdinaryExchange->Create.FileInfo.Basic.LastAccessTime;
    pFileInfo->Basic.LastWriteTime     = OrdinaryExchange->Create.FileInfo.Basic.LastWriteTime;
    pFileInfo->Basic.ChangeTime        = OrdinaryExchange->Create.FileInfo.Basic.ChangeTime;
    pFileInfo->Standard.NumberOfLinks  = OrdinaryExchange->Create.FileInfo.Standard.NumberOfLinks;
    pFileInfo->Standard.AllocationSize = OrdinaryExchange->Create.FileInfo.Standard.AllocationSize;
    pFileInfo->Standard.EndOfFile      = OrdinaryExchange->Create.FileInfo.Standard.EndOfFile;
    pFileInfo->Standard.Directory      = TRUE;

    smbSrvOpen->Flags |=  SMB_SRVOPEN_FLAG_NOT_REALLY_OPEN;  //this indicates a pseudoopen to success tail
    MRxSmbCreateFileSuccessTail (   RxContext,
                                    &OrdinaryExchange->Create.MustRegainExclusiveResource,
                                    StorageType,
                                    Fid,
                                    OrdinaryExchange->ServerVersion,
                                    SMB_OPLOCK_LEVEL_NONE,
                                    CreateAction,
                                    pFileInfo);

    IF_DEBUG{
        RxCaptureFcb;
        RxDbgTrace(-1, Dbg, ("MRxSmbFinishCoreCreateDirectory   returning %08lx, fcbstate =%08lx\n", Status, capFcb->FcbState ));
    }
    return Status;
}

NTSTATUS
MRxSmbPseudoOpenTailFromFakeGFAResponse (
      PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
      RX_FILE_TYPE StorageType
      )
/*++

Routine Description:

    This routine finishes a pseudoopen from faked up information. Basically, we fill in
    the information that would have been obtained on a GET_FILE_ATTRIBUTES smb and then call
    the PseudoOpenFromGFA routine

Arguments:

    OrdinaryExchange - the exchange instance
    StorageType - the type of thing that this is supposed to be. If it's supposed to be
                  a directory then we set the attributes bit in the GFA info.

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    USHORT Attributes = 0;

    PAGED_CODE();

    RtlZeroMemory(
        &OrdinaryExchange->Create.FileInfo,
        sizeof(OrdinaryExchange->Create.FileInfo));

    if (StorageType == FileTypeDirectory) {
        Attributes = SMB_FILE_ATTRIBUTE_DIRECTORY;
    }

    MRxSmbPopulateFileInfoInOE(OrdinaryExchange,Attributes,0,0);
    OrdinaryExchange->Create.StorageTypeFromGFA = StorageType;

    return( MRxSmbPseudoOpenTailFromGFAResponse (OrdinaryExchange) );
}


NTSTATUS
MRxSmbPseudoOpenTailFromGFAResponse (
      PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange
      )
/*++

Routine Description:

    This routine finishes a pseudoopen from the information obtained on a
    GET_FILE_ATTRIBUTES smb.

Arguments:

    OrdinaryExchange - the exchange instance

Return Value:

    RXSTATUS - The return status for the operation

--*/
{

    NTSTATUS Status = STATUS_SUCCESS;
    PRX_CONTEXT RxContext = OrdinaryExchange->RxContext;
    PMRX_SRV_OPEN SrvOpen = RxContext->pRelevantSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);
    PSMBPSE_FILEINFO_BUNDLE pFileInfo = &smbSrvOpen->FileInfo;

    SMB_FILE_ID Fid;
    ULONG CreateAction;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbFinishPseudoOpenFromGFAResponse\n"));
    SmbPseOEAssertConsistentLinkageFromOE("MRxSmbFinishPseudoOpenFromGFAResponse:");

    Fid = 0xbadd;

    CreateAction = FILE_OPENED;

    pFileInfo->Basic.FileAttributes    = OrdinaryExchange->Create.FileInfo.Basic.FileAttributes;
    pFileInfo->Basic.CreationTime      = OrdinaryExchange->Create.FileInfo.Basic.CreationTime;
    pFileInfo->Basic.LastAccessTime    = OrdinaryExchange->Create.FileInfo.Basic.LastAccessTime;
    pFileInfo->Basic.LastWriteTime     = OrdinaryExchange->Create.FileInfo.Basic.LastWriteTime;
    pFileInfo->Basic.ChangeTime        = OrdinaryExchange->Create.FileInfo.Basic.ChangeTime;
    pFileInfo->Standard.NumberOfLinks  = OrdinaryExchange->Create.FileInfo.Standard.NumberOfLinks;
    pFileInfo->Standard.AllocationSize = OrdinaryExchange->Create.FileInfo.Standard.AllocationSize;
    pFileInfo->Standard.EndOfFile      = OrdinaryExchange->Create.FileInfo.Standard.EndOfFile;
    pFileInfo->Standard.Directory      = (OrdinaryExchange->Create.StorageTypeFromGFA == FileTypeDirectory);

    smbSrvOpen->Flags |=  SMB_SRVOPEN_FLAG_NOT_REALLY_OPEN;  //this indicates a pseudoopen to success tail
    MRxSmbCreateFileSuccessTail (   RxContext,
                                    &OrdinaryExchange->Create.MustRegainExclusiveResource,
                                    OrdinaryExchange->Create.StorageTypeFromGFA,
                                    Fid,
                                    OrdinaryExchange->ServerVersion,
                                    SMB_OPLOCK_LEVEL_NONE,
                                    CreateAction,
                                    pFileInfo);

    if (smbSrvOpen->DeferredOpenContext == NULL) {
        // Already has a deferred open context created on MRxSmbCreateFileSuccessTail
        Status = MRxSmbConstructDeferredOpenContext(RxContext);
    } else {
        // The flag has been cleared when a deferred open context was created.
        SetFlag(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_DEFERRED_OPEN);
    }

    if (Status!=STATUS_SUCCESS) {
        RxDbgTrace(-1, Dbg, ("MRxSmbFinishPseudoOpenFromGFAResponse construct dfo failed %08lx \n",Status));
    }

    IF_DEBUG{
        RxCaptureFcb;
        RxDbgTrace(-1, Dbg, ("MRxSmbFinishPseudoOpenFromGFAResponse   returning %08lx, fcbstate =%08lx\n", Status, capFcb->FcbState ));
    }
    return Status;
}

LARGE_INTEGER
MRxSmbConvertSmbTimeToTime (
    //IN PSMB_EXCHANGE Exchange OPTIONAL,
    IN PSMBCE_SERVER Server OPTIONAL,
    IN SMB_TIME Time,
    IN SMB_DATE Date
    )

/*++

Routine Description:

    This routine converts an SMB time to an NT time structure.

Arguments:

    IN SMB_TIME Time - Supplies the time of day to convert
    IN SMB_DATE Date - Supplies the day of the year to convert
    IN supplies the server for tz bias.

Return Value:

    LARGE_INTEGER - Time structure describing input time.


--*/

{
    TIME_FIELDS TimeFields;
    LARGE_INTEGER OutputTime;

    PAGED_CODE();

    //
    // This routine cannot be paged because it is called from both the
    // MRxSmbFileDiscardableSection and the MRxSmbVCDiscardableSection.
    //

    if (SmbIsTimeZero(&Date) && SmbIsTimeZero(&Time)) {
        OutputTime.LowPart = OutputTime.HighPart = 0;
    } else {
        TimeFields.Year = Date.Struct.Year + (USHORT )1980;
        TimeFields.Month = Date.Struct.Month;
        TimeFields.Day = Date.Struct.Day;

        TimeFields.Hour = Time.Struct.Hours;
        TimeFields.Minute = Time.Struct.Minutes;
        TimeFields.Second = Time.Struct.TwoSeconds*(USHORT )2;
        TimeFields.Milliseconds = 0;

        //
        //  Make sure that the times specified in the SMB are reasonable
        //  before converting them.
        //

        if (TimeFields.Year < 1601) {
            TimeFields.Year = 1601;
        }

        if (TimeFields.Month > 12) {
            TimeFields.Month = 12;
        }

        if (TimeFields.Hour >= 24) {
            TimeFields.Hour = 23;
        }
        if (TimeFields.Minute >= 60) {
            TimeFields.Minute = 59;
        }
        if (TimeFields.Second >= 60) {
            TimeFields.Second = 59;

        }

        if (!RtlTimeFieldsToTime(&TimeFields, &OutputTime)) {
            OutputTime.HighPart = 0;
            OutputTime.LowPart = 0;

            return OutputTime;
        }

#ifndef WIN9X
        if (ARGUMENT_PRESENT(Server)) {
            OutputTime.QuadPart = OutputTime.QuadPart + Server->TimeZoneBias.QuadPart;
        }

        ExLocalTimeToSystemTime(&OutputTime, &OutputTime);
#else
        OutputTime.HighPart = 0;
        OutputTime.LowPart = 0;
#endif

    }

    return OutputTime;

}

BOOLEAN
MRxSmbConvertTimeToSmbTime (
    IN PLARGE_INTEGER InputTime,
    IN PSMB_EXCHANGE Exchange OPTIONAL,
    OUT PSMB_TIME Time,
    OUT PSMB_DATE Date
    )

/*++

Routine Description:

    This routine converts an NT time structure to an SMB time.

Arguments:

    IN LARGE_INTEGER InputTime - Supplies the time to convert.
    OUT PSMB_TIME Time - Returns the converted time of day.
    OUT PSMB_DATE Date - Returns the converted day of the year.


Return Value:

    BOOLEAN - TRUE if input time could be converted.


--*/

{
    TIME_FIELDS TimeFields;

    PAGED_CODE();

    if (InputTime->LowPart == 0 && InputTime->HighPart == 0) {
        Time->Ushort = Date->Ushort = 0;
    } else {
        LARGE_INTEGER LocalTime;

        ExSystemTimeToLocalTime(InputTime, &LocalTime);

        if (ARGUMENT_PRESENT(Exchange)) {
            PSMBCE_SERVER Server = SmbCeGetExchangeServer(Exchange);
            LocalTime.QuadPart -= Server->TimeZoneBias.QuadPart;
        }

        RtlTimeToTimeFields(&LocalTime, &TimeFields);

        if (TimeFields.Year < 1980) {
            return FALSE;
        }

        Date->Struct.Year = (USHORT )(TimeFields.Year - 1980);
        Date->Struct.Month = TimeFields.Month;
        Date->Struct.Day = TimeFields.Day;

        Time->Struct.Hours = TimeFields.Hour;
        Time->Struct.Minutes = TimeFields.Minute;

        //
        //  When converting from a higher granularity time to a lesser
        //  granularity time (seconds to 2 seconds), always round up
        //  the time, don't round down.
        //

        Time->Struct.TwoSeconds = (TimeFields.Second + (USHORT)1) / (USHORT )2;

    }

    return TRUE;
}


BOOLEAN
MRxSmbTimeToSecondsSince1970 (
    IN PLARGE_INTEGER CurrentTime,
    IN PSMBCE_SERVER Server OPTIONAL,
    OUT PULONG SecondsSince1970
    )
/*++

Routine Description:

    This routine returns the CurrentTime in UTC and returns the
    equivalent current time in the servers timezone.


Arguments:

    IN PLARGE_INTEGER CurrentTime - Supplies the current system time in UTC.

    IN PSMBCE_SERVER Server       - Supplies the difference in timezones between
                                    the server and the workstation. If not supplied
                                    then the assumption is that they are in the
                                    same timezone.

    OUT PULONG SecondsSince1970   - Returns the # of seconds since 1970 in
                                    the servers timezone or MAXULONG if conversion
                                    fails.

Return Value:

    BOOLEAN - TRUE if the time could be converted.

--*/
{
    LARGE_INTEGER ServerTime;
    LARGE_INTEGER TempTime;
    BOOLEAN ReturnValue;

    PAGED_CODE();

    if (ARGUMENT_PRESENT(Server) &&
        ((*CurrentTime).QuadPart != 0)) {

        TempTime.QuadPart = (*CurrentTime).QuadPart - Server->TimeZoneBias.QuadPart;

        ExSystemTimeToLocalTime(&TempTime, &ServerTime);
    } else {
        ExSystemTimeToLocalTime(CurrentTime, &ServerTime);
    }

    ReturnValue = RtlTimeToSecondsSince1970(&ServerTime, SecondsSince1970);

    if ( ReturnValue == FALSE ) {
        //
        //  We can't represent the time legally, peg it at
        //  the max legal time.
        //

        *SecondsSince1970 = MAXULONG;
    }

    return ReturnValue;
}

VOID
MRxSmbSecondsSince1970ToTime (
    IN ULONG SecondsSince1970,
    //IN PSMB_EXCHANGE Exchange OPTIONAL,
    IN PSMBCE_SERVER Server,
    OUT PLARGE_INTEGER CurrentTime
    )
/*++

Routine Description:

    This routine returns the Local system time derived from a time
    in seconds in the servers timezone.


Arguments:

    IN ULONG SecondsSince1970 - Supplies the # of seconds since 1970 in
                                servers timezone.

    IN PSMB_EXCHANGE Exchange - Supplies the difference in timezones between
                                the server and the workstation. If not supplied
                                then the assumption is that they are in the
                                same timezone.

    OUT PLARGE_INTEGER CurrentTime - Returns the current system time in UTC.

Return Value:

    None.


--*/

{
    LARGE_INTEGER LocalTime;

    PAGED_CODE();

    RtlSecondsSince1970ToTime (SecondsSince1970, &LocalTime);

    ExLocalTimeToSystemTime(&LocalTime, CurrentTime);

    if (ARGUMENT_PRESENT(Server)) {
        (*CurrentTime).QuadPart = (*CurrentTime).QuadPart + Server->TimeZoneBias.QuadPart;
    }

    return;

}

ULONG
MRxSmbMapSmbAttributes (
    IN USHORT SmbAttribs
    )

/*++

Routine Description:

    This routine maps an SMB (DOS/OS2) file attribute into an NT
    file attribute.


Arguments:

    IN USHORT SmbAttribs - Supplies the SMB attribute to map.


Return Value:

    ULONG - NT Attribute mapping SMB attribute


--*/

{
    ULONG Attributes = 0;

    PAGED_CODE();

    if (SmbAttribs==0) {
        Attributes = FILE_ATTRIBUTE_NORMAL;
    } else {

        ASSERT (SMB_FILE_ATTRIBUTE_READONLY == FILE_ATTRIBUTE_READONLY);
        ASSERT (SMB_FILE_ATTRIBUTE_HIDDEN == FILE_ATTRIBUTE_HIDDEN);
        ASSERT (SMB_FILE_ATTRIBUTE_SYSTEM == FILE_ATTRIBUTE_SYSTEM);
        ASSERT (SMB_FILE_ATTRIBUTE_ARCHIVE == FILE_ATTRIBUTE_ARCHIVE);
        ASSERT (SMB_FILE_ATTRIBUTE_DIRECTORY == FILE_ATTRIBUTE_DIRECTORY);

        Attributes = SmbAttribs & FILE_ATTRIBUTE_VALID_FLAGS;
    }
    return Attributes;
}

USHORT
MRxSmbMapDisposition (
    IN ULONG Disposition
    )

/*++

Routine Description:

    This routine takes an NT disposition, and maps it into an OS/2
    CreateAction to be put into an SMB.


Arguments:

    IN ULONG Disposition - Supplies the NT disposition to map.


Return Value:

    USHORT - OS/2 Access mapping that maps NT access

--*/

{
    PAGED_CODE();

    switch (Disposition) {
    case FILE_OVERWRITE_IF:
    case FILE_SUPERSEDE:
        return SMB_OFUN_OPEN_TRUNCATE | SMB_OFUN_CREATE_CREATE;
        break;

    case FILE_CREATE:
        return SMB_OFUN_OPEN_FAIL | SMB_OFUN_CREATE_CREATE;
        break;

    case FILE_OVERWRITE:
        return SMB_OFUN_OPEN_TRUNCATE | SMB_OFUN_CREATE_FAIL;
        break;

    case FILE_OPEN:
        return SMB_OFUN_OPEN_OPEN | SMB_OFUN_CREATE_FAIL;
        break;

    case FILE_OPEN_IF:
        return SMB_OFUN_OPEN_OPEN | SMB_OFUN_CREATE_CREATE;
        break;

    default:
        //InternalError(("Unknown disposition passed to MRxSmbMapDisposition"));
        //MRxSmbInternalError(EVENT_RDR_DISPOSITION);
        return 0;
        break;
    }
}


ULONG
MRxSmbUnmapDisposition (
    IN USHORT SmbDisposition,
    ULONG     Disposition
    )

/*++

Routine Description:

    This routine takes an OS/2 disposition and maps it into an NT
    disposition.

Arguments:

    IN USHORT SmbDisposition - Supplies the OS/2 disposition to map.

Return Value:

    ULONG - NT disposition mapping OS/2 disposition

--*/

{
    ULONG MapDisposition;

    PAGED_CODE();

    //
    //  Mask off oplocked bit.
    //

    switch (SmbDisposition & 0x7fff) {

    case SMB_OACT_OPENED:
        MapDisposition = FILE_OPENED;
        break;

    case SMB_OACT_CREATED:
        MapDisposition = FILE_CREATED;
        break;

    case SMB_OACT_TRUNCATED:
        MapDisposition = FILE_OVERWRITTEN;
        break;

    default:
        MapDisposition = Disposition;
    }

    return MapDisposition;
}


USHORT
MRxSmbMapDesiredAccess (
    IN ULONG DesiredAccess
    )

/*++

Routine Description:

    This routine takes an NT DesiredAccess value and converts it
    to an OS/2 access mode.


Arguments:

    IN ULONG DesiredAccess - Supplies the NT desired access to map.

Return Value:

    USHORT - The mapped OS/2 access mode that compares to the NT code
        specified.  If there is no mapping for the NT code, we return
        -1 as the access mode.

--*/

{
    PAGED_CODE();

    //
    //  If the user asked for both read and write access, return read/write.
    //

    if ((DesiredAccess & FILE_READ_DATA)&&(DesiredAccess & FILE_WRITE_DATA)) {
        return SMB_DA_ACCESS_READ_WRITE;
    }

    //
    //  If the user requested WRITE_DATA, return write.
    //

    if (DesiredAccess & FILE_WRITE_DATA) {
        return SMB_DA_ACCESS_WRITE;
    }

    //
    //  If the user requested READ_DATA, return read.
    //
    if (DesiredAccess & FILE_READ_DATA) {
        return SMB_DA_ACCESS_READ;
    }

    //
    //  If the user requested ONLY execute access, then request execute
    //  access.  Execute access is the "weakest" of the possible desired
    //  accesses, so it takes least precedence.
    //

    if (DesiredAccess & FILE_EXECUTE) {
        return  SMB_DA_ACCESS_EXECUTE;
    }

    //
    //  If we couldn't figure out what we were doing, return -1
    //
    //  Among the attributes that we do not map are:
    //
    //          FILE_READ_ATTRIBUTES
    //          FILE_WRITE_ATTRIBUTES
    //          FILE_READ_EAS
    //          FILE_WRITE_EAS
    //

//    dprintf(DPRT_ERROR, ("Could not map DesiredAccess of %08lx\n", DesiredAccess));

    return (USHORT)0;
}

USHORT
MRxSmbMapShareAccess (
    IN USHORT ShareAccess
    )

/*++

Routine Description:

    This routine takes an NT ShareAccess value and converts it to an
    OS/2 sharing mode.


Arguments:

    IN USHORT ShareAccess - Supplies the OS/2 share access to map.

Return Value:

    USHORT - The mapped OS/2 sharing mode that compares to the NT code
        specified

--*/

{
    USHORT ShareMode =  SMB_DA_SHARE_EXCLUSIVE;

    PAGED_CODE();

    if ((ShareAccess & (FILE_SHARE_READ | FILE_SHARE_WRITE)) ==
                       (FILE_SHARE_READ | FILE_SHARE_WRITE)) {
        ShareMode = SMB_DA_SHARE_DENY_NONE;
    } else if (ShareAccess & FILE_SHARE_READ) {
        ShareMode = SMB_DA_SHARE_DENY_WRITE;
    } else if (ShareAccess & FILE_SHARE_WRITE) {
        ShareMode = SMB_DA_SHARE_DENY_READ;
    }

//    else if (ShareAccess & FILE_SHARE_DELETE) {
//      InternalError(("Support for FILE_SHARE_DELETE NYI\n"));
//    }

    return ShareMode;

}

USHORT
MRxSmbMapFileAttributes (
    IN ULONG FileAttributes
    )

/*++

Routine Description:

    This routine takes an NT file attribute mapping and converts it into
    an OS/2 file attribute definition.


Arguments:

    IN ULONG FileAttributes - Supplies the file attributes to map.


Return Value:

USHORT

--*/

{
    USHORT ResultingAttributes = 0;

    PAGED_CODE();

    if (FileAttributes==FILE_ATTRIBUTE_NORMAL) {
        return ResultingAttributes;
    }

    if (FileAttributes & FILE_ATTRIBUTE_READONLY) {
        ResultingAttributes |= SMB_FILE_ATTRIBUTE_READONLY;
    }

    if (FileAttributes & FILE_ATTRIBUTE_HIDDEN) {
        ResultingAttributes |= SMB_FILE_ATTRIBUTE_HIDDEN;
    }

    if (FileAttributes & FILE_ATTRIBUTE_SYSTEM) {
        ResultingAttributes |= SMB_FILE_ATTRIBUTE_SYSTEM;
    }
    if (FileAttributes & FILE_ATTRIBUTE_ARCHIVE) {
        ResultingAttributes |= SMB_FILE_ATTRIBUTE_ARCHIVE;
    }
    return ResultingAttributes;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\ifskit.mrx\smbmrx\sys\downlvli.c ===
/*++

Copyright (c) 1989 - 1999  Microsoft Corporation

Module Name:

    DownLvlI.c

Abstract:

    This module implements downlevel fileinfo, volinfo, and dirctrl.

--*/

#include "precomp.h"
#pragma hdrstop

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, MRxSmbFabricateAttributesOnNetRoot)
#pragma alloc_text(PAGE, MRxSmbCoreInformation)
#pragma alloc_text(PAGE, MRxSmbLoadCoreFileSearchBuffer)
#pragma alloc_text(PAGE, MRxSmbCoreFileSearch)
#pragma alloc_text(PAGE, MrxSmbOemVolumeInfoToUnicode)
#pragma alloc_text(PAGE, MrxSmbCoreQueryFsVolumeInfo)
#pragma alloc_text(PAGE, MrxSmbQueryFsVolumeInfo)
#pragma alloc_text(PAGE, MrxSmbCoreQueryDiskAttributes)
#pragma alloc_text(PAGE, MrxSmbCoreQueryDiskAttributes)
#pragma alloc_text(PAGE, SmbPseExchangeStart_CoreInfo)
#pragma alloc_text(PAGE, MRxSmbFinishSearch)
#pragma alloc_text(PAGE, MRxSmbFinishQueryDiskInfo)
#pragma alloc_text(PAGE, MRxSmbExtendForCache)
#pragma alloc_text(PAGE, MRxSmbExtendForNonCache)
#pragma alloc_text(PAGE, MRxSmbGetNtAllocationInfo)
#pragma alloc_text(PAGE, __MRxSmbSimpleSyncTransact2)
#pragma alloc_text(PAGE, MRxSmbFinishTransaction2)
#endif

#define Dbg        (DEBUG_TRACE_VOLINFO)

//#define FORCE_CORE_GETATTRIBUTES
#ifndef FORCE_CORE_GETATTRIBUTES
#define MRxSmbForceCoreGetAttributes FALSE
#else
BOOLEAN MRxSmbForceCoreGetAttributes = TRUE;
#endif

NTSTATUS
SmbPseExchangeStart_CoreInfo(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    );

//these structures are used for t2_query_fs_info
typedef
struct _QFS_INFO {
    ULONG ulVSN;
    UCHAR cch;
    CHAR szVolLabel[12];   //not unicode
} QFS_INFO, *PQFS_INFO;
#define ACTUAL_QFS_INFO_LENGTH (FIELD_OFFSET(QFS_INFO,szVolLabel[12]))

typedef
struct _QFS_ALLOCATE {
    ULONG ulReserved;
    ULONG cSectorUnit;
    ULONG cUnit;
    ULONG cUnitAvail;
    USHORT cbSector;
} QFS_ALLOCATE, *PQFS_ALLOCATE;
#define ACTUAL_QFS_ALLOCATE_LENGTH (FIELD_OFFSET(QFS_ALLOCATE,cbSector)+sizeof(((PQFS_ALLOCATE)0)->cbSector))

//++
//
// VOID
// NAME_LENGTH(
//     OUT ULONG Length,
//     IN PUCHAR Ptr
//     )
//
// Routine Description:
//
//  Determines the length of a Core filename returned by search. This
//  is normally a NULL terminated string less than MAXIMUM_COMPONENT_CORE.
//  In some cases this is Non-null teminated and space filled.
//
// Arguments:
//
//     Length   -   Returns the string length
//     Ptr      -   The filename to be measured
//
// Return Value:
//
//     None.
//
//--
#define NAME_LENGTH( Length, Ptr, Max ) {                         \
    Length = 0;                                                   \
    while( ((PCHAR)Ptr)[Length] != '\0' ) {                       \
         Length++;                                                \
         if ( Length == Max ) {                                   \
             break;                                               \
         }                                                        \
    }                                                             \
    while( ((PCHAR)Ptr)[Length-1] == ' ' && Length ) {            \
        Length--;                                                 \
    }                                                             \
}
MRxSmbSetDeleteDisposition(
      IN PRX_CONTEXT            RxContext
      );

typedef struct __NativeFs_Name_Entry {
    UCHAR Last;
    UCHAR MaximumComponentNameLength;
    UCHAR FileSystemAttributes;   //this may overflow someday.....
    UCHAR NameLength;
    PWCHAR  Name;
};
struct __NativeFs_Name_Entry NativeFsNameTable[] = {
    {0,12,0,sizeof(L"FAT")-sizeof(WCHAR),L"FAT"},
    {0,254,FILE_CASE_PRESERVED_NAMES,sizeof(L"HPFS")-sizeof(WCHAR),L"HPFS"},
    {1,254,FILE_CASE_PRESERVED_NAMES,sizeof(L"HPFS386")-sizeof(WCHAR),L"HPFS386"}
    };

NTSTATUS
MRxSmbFabricateAttributesOnNetRoot(
    IN OUT  PSMBCE_NET_ROOT psmbNetRoot,
    IN      PSMBCE_SERVER   pServer
    )
/*++

Routine Description:

   This routine uses information stored in the netroot structure to hallucinate the attributes
   of the netroot. it may be that the ascii representation of the filesystem name has already been
   stored in the netroot. If so, expeand it out.....otherwise, it must be FAT.

Arguments:


Return Value:

    RXSTATUS - STATUS_SUCCESS

--*/
{
    NTSTATUS StringStatus;
    WCHAR FileSystemNameBuffer[SMB_MAXIMUM_SUPPORTED_VOLUME_LABEL+1]; //must leave room for the null
    UNICODE_STRING FileSystemNameU;
    OEM_STRING FileSystemNameA;
    UCHAR FileSystemNameALength;

    PAGED_CODE();

    // ASSERT (psmbNetRoot->MaximumComponentNameLength==0);

    FileSystemNameALength = psmbNetRoot->FileSystemNameALength;

    if (FileSystemNameALength == 0) {
        if (pServer->Dialect <= WFW10_DIALECT)
        {
            //must be Fat!
            FileSystemNameALength = 3;
            psmbNetRoot->FileSystemNameA[0] = 'F';
            psmbNetRoot->FileSystemNameA[1] = 'A';
            psmbNetRoot->FileSystemNameA[2] = 'T';
        }
        else
        {
            FileSystemNameALength = 7;
            psmbNetRoot->FileSystemNameA[0] = 'U';
            psmbNetRoot->FileSystemNameA[1] = 'N';
            psmbNetRoot->FileSystemNameA[2] = 'K';
            psmbNetRoot->FileSystemNameA[3] = 'N';
            psmbNetRoot->FileSystemNameA[4] = 'O';
            psmbNetRoot->FileSystemNameA[5] = 'W';
            psmbNetRoot->FileSystemNameA[6] = 'N';
        }
    }

    //now, translate the name to Unicode.......

    FileSystemNameA.Length = FileSystemNameALength;
    FileSystemNameA.MaximumLength = FileSystemNameALength;
    FileSystemNameA.Buffer = &psmbNetRoot->FileSystemNameA[0];
    FileSystemNameU.Length = 0;
    FileSystemNameU.MaximumLength = (USHORT)sizeof(FileSystemNameBuffer);
    FileSystemNameU.Buffer = &FileSystemNameBuffer[0];
    StringStatus = RtlOemStringToUnicodeString(&FileSystemNameU, &FileSystemNameA, FALSE);
    ASSERT(StringStatus==STATUS_SUCCESS);

    //copy back the name

    RtlCopyMemory(&psmbNetRoot->FileSystemName[0],FileSystemNameU.Buffer,FileSystemNameU.Length);
    psmbNetRoot->FileSystemNameLength = FileSystemNameU.Length;
    if (FALSE) DbgPrint("NativeFs in unicode %wZ (%d/%d) on netroot %08lx\n",
               &FileSystemNameU,FileSystemNameU.Length,FileSystemNameU.MaximumLength,psmbNetRoot);
    {   struct __NativeFs_Name_Entry *i;
       for (i=NativeFsNameTable;;i++) {
           UCHAR NameLength = i->NameLength;
           if (RtlCompareMemory(&FileSystemNameBuffer[0],
                                i->Name,
                                NameLength) == NameLength) {
              psmbNetRoot->MaximumComponentNameLength = i->MaximumComponentNameLength;
              psmbNetRoot->FileSystemAttributes = i->FileSystemAttributes;
              if (FALSE) {
                  UNICODE_STRING u;
                  u.Buffer = i->Name;
                  u.Length = i->NameLength;
                  DbgPrint("FoundNativeFsStrng %wZ len %d for %d %d\n",&u,i->NameLength,
                                       i->MaximumComponentNameLength,i->FileSystemAttributes);
              }
              break;
           }
           if (i->Last) {
               //ASSERT(!"Valid Share Type returned in TREE COnnect And X response");
               psmbNetRoot->MaximumComponentNameLength = 255;
               psmbNetRoot->FileSystemAttributes = 0;
               break;
           }
       }
    }

    return(STATUS_SUCCESS); //could be a VOID routine.....
}

NTSTATUS
MRxSmbGetFsAttributesFromNetRoot(
    IN OUT PRX_CONTEXT RxContext
    )
/*++

Routine Description:

   This routine uses information stored in the netroot structure to fill in a FILE
   FileFsAttributeInformation structure.

Arguments:


Return Value:

    RXSTATUS - STATUS_SUCCESS

--*/
{
    RxCaptureFcb;
    ULONG FileSystemNameLength,LengthNeeded;
    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry;
    PSMBCE_NET_ROOT psmbNetRoot;
    //FILE_INFORMATION_CLASS FileInformationClass;
    PBYTE   pBuffer;
    PULONG  pBufferLength;

    //DbgPrint("yeppp!!\n");
    pNetRootEntry = SmbCeGetAssociatedNetRootEntry(capFcb->pNetRoot);
    if (pNetRootEntry == NULL) {
        return (STATUS_INVALID_PARAMETER);
    }

    ASSERT(RxContext->MajorFunction==IRP_MJ_QUERY_VOLUME_INFORMATION);
    //FileInformationClass = RxContext->Info.FileInformationClass;
    ASSERT(RxContext->Info.FileInformationClass==FileFsAttributeInformation);
    pBuffer = RxContext->Info.Buffer;
    pBufferLength = &RxContext->Info.LengthRemaining;

    psmbNetRoot = &pNetRootEntry->NetRoot;

    if (psmbNetRoot->MaximumComponentNameLength==0) {
        MRxSmbFabricateAttributesOnNetRoot(psmbNetRoot, &pNetRootEntry->pServerEntry->Server);
    }

    FileSystemNameLength = psmbNetRoot->FileSystemNameLength;
    LengthNeeded = FIELD_OFFSET(FILE_FS_ATTRIBUTE_INFORMATION, FileSystemName)+FileSystemNameLength;

    if (*pBufferLength < LengthNeeded) {
        return (STATUS_BUFFER_OVERFLOW);
    }

    {
        PFILE_FS_ATTRIBUTE_INFORMATION pTypedBuffer = (PFILE_FS_ATTRIBUTE_INFORMATION)pBuffer;

        pTypedBuffer->MaximumComponentNameLength = psmbNetRoot->MaximumComponentNameLength;
        pTypedBuffer->FileSystemAttributes = psmbNetRoot->FileSystemAttributes;
        pTypedBuffer->FileSystemNameLength = FileSystemNameLength;

        RtlCopyMemory(pTypedBuffer->FileSystemName, psmbNetRoot->FileSystemName, FileSystemNameLength);
        *pBufferLength -= LengthNeeded;
    }
    return(STATUS_SUCCESS);
}

NTSTATUS
MRxSmbCoreInformation(
      IN OUT PRX_CONTEXT          RxContext,
      IN     ULONG                InformationClass,
      IN OUT PVOID                pBuffer,
      IN OUT PULONG               pBufferLength,
      IN     SMB_PSE_ORDINARY_EXCHANGE_ENTRYPOINTS EntryPoint
      )
/*++

Routine Description:

   This routine does a core level getinfo (vol or fileinfo) a file across the network

Arguments:

    RxContext - the RDBSS context
    InformationClass - a class variable that is specific to the call. sometimes it's a SMB class; sometimes
                       an NT class.
    pBuffer - pointer to the user's buffer
    pBufferLength - a pointer to a ulong containing the bufferlength that is updated as we go;
                    if it's a setinfo then we deref and place the actual bufferlength in the OE.

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = (STATUS_SUCCESS);
    PUNICODE_STRING RemainingName;
    RxCaptureFcb; RxCaptureFobx;
    PMRX_SRV_OPEN SrvOpen = capFobx->pSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);

    PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange;

    PAGED_CODE();

    RxDbgTrace(0, Dbg, ("MRxSmbDownLevelQueryInformation\n", 0 ));  //0 instead of +1.....the general entrypoint already inc'd

    ASSERT( NodeType(SrvOpen) == RDBSS_NTC_SRVOPEN );

    //some stuff is early out............catch them here even before we initialize the stufferstate
    switch (EntryPoint) {
    case SMBPSE_OE_FROM_QUERYVOLUMEINFO:
        switch (InformationClass) {
        case FileFsVolumeInformation:
        case FileFsSizeInformation:
            break; //these are actually implemented on the wire
        case FileFsAttributeInformation: {
            Status = MRxSmbGetFsAttributesFromNetRoot(RxContext);
            goto FINALLY;
            }
            //no break needed because of gotofinally

        case FileFsDeviceInformation:
            ASSERT(!"this should have been turned away");
            //no break;
        default:
            Status = STATUS_NOT_IMPLEMENTED;
            goto FINALLY;
        }
        break;
    case SMBPSE_OE_FROM_QUERYFILEINFO:
        //notice that the designators are smb_query_info types
        switch (InformationClass) {
        case SMB_QUERY_FILE_BASIC_INFO:
        case SMB_QUERY_FILE_STANDARD_INFO:
            // go thru to the wire or get it from file information cache
            break;
        case SMB_QUERY_FILE_EA_INFO:
            //downlevel guys have no EAs....turn this backright here
            ((PFILE_EA_INFORMATION)pBuffer)->EaSize = 0;
            *pBufferLength -= sizeof(FILE_EA_INFORMATION);
            goto FINALLY;
        //case SMB_QUERY_FILE_ALLOCATION_INFO:
        //case SMB_QUERY_FILE_END_OF_FILEINFO:
        //case SMB_QUERY_FILE_ALT_NAME_INFO:
        //case SMB_QUERY_FILE_STREAM_INFO:
        default:
            Status = STATUS_NOT_IMPLEMENTED;
            goto FINALLY;
        }
        break;
    case SMBPSE_OE_FROM_SETFILEINFO:
        switch (InformationClass) {
        case FileBasicInformation:
        case FileEndOfFileInformation:
            //these go thru to the wire
            break;
        case FileDispositionInformation:
            if (FlagOn(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_FILE_DELETED) ||
                !FlagOn(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_NOT_REALLY_OPEN)) {
                // if it is a pseudo open, we send the delete file request to get the result;
                // otherwise, we delay the delete until close.
                goto FINALLY;
            }
            break;
        case FileRenameInformation:
            Status = MRxSmbRename(RxContext);
            goto FINALLY;
        case FileAllocationInformation:
            Status = STATUS_SUCCESS;
            goto FINALLY;
        default:
            Status = STATUS_NOT_IMPLEMENTED;
            goto FINALLY;
        }
        break;
    case SMBPSE_OE_FROM_EXTENDFILEFORCACHEING:
    case SMBPSE_OE_FROM_QUERYDIRECTORY:
        break;
    }

    Status = SmbPseCreateOrdinaryExchange(RxContext,
                                          SrvOpen->pVNetRoot,
                                          EntryPoint,
                                          SmbPseExchangeStart_CoreInfo,
                                          &OrdinaryExchange
                                          );
    if (Status != STATUS_SUCCESS) {
        RxDbgTrace(-1, Dbg, ("Couldn't get the smb buf!\n"));
        goto FINALLY;
    }

    OrdinaryExchange->Info.Buffer = pBuffer;
    OrdinaryExchange->Info.pBufferLength = pBufferLength;
    OrdinaryExchange->Info.InfoClass = InformationClass;

    Status = SmbPseInitiateOrdinaryExchange(OrdinaryExchange);

    ASSERT (Status != (STATUS_PENDING)); //async was turned away at the top level

    SmbPseFinalizeOrdinaryExchange(OrdinaryExchange);

FINALLY:
    RxDbgTrace(-1, Dbg, ("MRxSmbDownLevelQueryInformation  exit with status=%08lx\n", Status ));
    return(Status);
}

UNICODE_STRING MRxSmbAll8dot3Files = {sizeof(L"????????.???")-sizeof(WCHAR),sizeof(L"????????.???"),L"????????.???"};

#if 0
#include "stdarg.h"
#include "stdio.h"
#include "string.h"
VOID
MRxSmbDumpResumeKey(
    PSZ             text,
    PSMB_RESUME_KEY ResumeKey
    )
{
    PBYTE rk = (PBYTE)ResumeKey;
    CHAR Buffer[80];
    PCHAR b;
    ULONG i;

    PAGED_CODE();

    for (i=0,b=Buffer;i<sizeof(SMB_RESUME_KEY);i++,b+=2) {
        RxSprintf(b,"%02lx  ",rk[i]);
        if (i==0) b+=2;
        if (i==11) b+=2;
        if (i==16) b+=2;
    }

    RxDbgTrace(0, Dbg, ("%s  rk(%08lx)=%s\n", text, ResumeKey, Buffer));
}
#else
#define MRxSmbDumpResumeKey(x,y)
#endif


NTSTATUS
MRxSmbLoadCoreFileSearchBuffer(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    )
/*++

Routine Description:

   This routine does a CORE_SMB_SEARCH and leaves the result in the SMBbuf.

Arguments:

    OrdinaryExchange  - an exchange to be used for conducting this open.

Return Value:

    RXSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS Status = (STATUS_NOT_IMPLEMENTED);
    RxCaptureFcb; RxCaptureFobx;
    PMRX_SMB_FOBX smbFobx = MRxSmbGetFileObjectExtension(capFobx);

    PSMB_EXCHANGE Exchange = (PSMB_EXCHANGE) OrdinaryExchange;

    PSMBSTUFFER_BUFFER_STATE StufferState;
    PSMB_HEADER SmbHeader;

    //PUNICODE_STRING DirectoryName;
    //PUNICODE_STRING Template;
    BOOLEAN FindFirst;
    UNICODE_STRING FindFirstPattern;
    USHORT ResumeKeyLength;
    ULONG ReturnCount;
    BOOLEAN EndOfSearchReached;
    // SearchAttributes is hardcoded to the magic number 0x16
    ULONG SearchAttributes =
            (SMB_FILE_ATTRIBUTE_DIRECTORY
                | SMB_FILE_ATTRIBUTE_SYSTEM | SMB_FILE_ATTRIBUTE_HIDDEN);
    PULONG pCountRemainingInSmbbuf = &OrdinaryExchange->Info.CoreSearch.CountRemainingInSmbbuf;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbLoadCoreFileSearchBuffer entering.......OE=%08lx\n",OrdinaryExchange));
    RxDbgTrace( 0, Dbg, (".......smbFobx/resumekey=%08lx/%08lx\n",smbFobx,smbFobx->Enumeration.CoreResumeKey));

    if (!FlagOn(smbFobx->Enumeration.Flags,SMBFOBX_ENUMFLAG_SEARCH_NOT_THE_FIRST)) {

        PUNICODE_STRING DirectoryName = GET_ALREADY_PREFIXED_NAME(capFobx->pSrvOpen,capFcb);
        PUNICODE_STRING Template = &capFobx->UnicodeQueryTemplate;
        ULONG DirectoryNameLength,TemplateLength,AllocationLength;
        PBYTE SmbFileName;

        //this is the first time thru....the stuffer cannot handle the intricate logic here so we
        //will have to preallocate for the name

        if (smbFobx->Enumeration.WildCardsFound = FsRtlDoesNameContainWildCards(Template)){
            // we will need to have an upcased template for compares; we do this in place
            RtlUpcaseUnicodeString( Template, Template, FALSE );

            Template = &MRxSmbAll8dot3Files; //we will have to filter on this side
        }
        DirectoryNameLength = DirectoryName->Length;
        TemplateLength = Template->Length;
        AllocationLength = sizeof(WCHAR)  // backslash separator
                            +DirectoryNameLength
                            +TemplateLength;
        RxDbgTrace(0, Dbg, ("  --> d/t/dl/tl/al <%wZ><%wZ>%08lx/%08lx/%08lx!\n",
                      DirectoryName,Template,
                      DirectoryNameLength,TemplateLength,AllocationLength));

        FindFirstPattern.Buffer = (PWCHAR)RxAllocatePoolWithTag( PagedPool,AllocationLength,'0SxR');
        if (FindFirstPattern.Buffer==NULL) {
            RxDbgTrace(0, Dbg, ("  --> Couldn't get the findfind pattern buffer!\n"));
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto FINALLY;
        }

        SmbFileName = (PBYTE)FindFirstPattern.Buffer;
        RtlCopyMemory(SmbFileName,DirectoryName->Buffer,DirectoryNameLength);
        SmbFileName += DirectoryNameLength;
        if (*((PWCHAR)(SmbFileName-sizeof(WCHAR))) != L'\\') {
            *((PWCHAR)SmbFileName) = L'\\'; SmbFileName+= sizeof(WCHAR);
        }
        RtlCopyMemory(SmbFileName,Template->Buffer,TemplateLength);
        SmbFileName += TemplateLength;
        if ((TemplateLength == sizeof(WCHAR)) && (Template->Buffer[0]==DOS_STAR)) {
            ASSERT(FALSE); //this should never happen
            *((PWCHAR)SmbFileName) = L'.'; SmbFileName+= sizeof(WCHAR);
            *((PWCHAR)SmbFileName) = L'*'; SmbFileName+= sizeof(WCHAR);
        }
        FindFirstPattern.Length = (USHORT)(SmbFileName - (PBYTE)FindFirstPattern.Buffer);
        RxDbgTrace(0, Dbg, ("  --> find1stpattern <%wZ>!\n",&FindFirstPattern));
        FindFirst = TRUE;
        ResumeKeyLength = 0;

    } else {

        RxDbgTrace(0, Dbg, ("-->FINDNEXT\n"));
        FindFirstPattern.Buffer = NULL;
        if (!FlagOn(smbFobx->Enumeration.Flags,SMBFOBX_ENUMFLAG_CORE_SEARCH_IN_PROGRESS)) {
            Status = smbFobx->Enumeration.ErrorStatus;
            RxDbgTrace(0, Dbg, ("-->ERROR EARLY OUT\n"));
            goto FINALLY;
        }
        FindFirst = FALSE;
        FindFirstPattern.Length = 0;
        ResumeKeyLength = sizeof(SMB_RESUME_KEY);
        MRxSmbDumpResumeKey("FindNext:",smbFobx->Enumeration.CoreResumeKey);

    }

    //get the correct return count. there are three factors: countremaining from the OE,
    //     how many could fit the the user's buffer, and how many could fit in a negotiated buffer.
    //     we pick the smallest of the three except that we never go for less than 10 unless 10 won't
    //     fit in the smbbuf.
    ReturnCount = OrdinaryExchange->Info.CoreSearch.CountRemaining;

    { ULONG t = (*OrdinaryExchange->Info.pBufferLength) / smbFobx->Enumeration.FileNameOffset;
        if (t<ReturnCount) { ReturnCount = t; }
    }

    if (ReturnCount<10) { ReturnCount = 10; }

    {
        PSMBCE_SERVER         pServer;
        ULONG                 AvailableBufferSize,t;

        pServer = SmbCeGetExchangeServer(OrdinaryExchange);
        AvailableBufferSize = pServer->MaximumBufferSize -
                                      (sizeof(SMB_HEADER) +
                                         FIELD_OFFSET(RESP_SEARCH,Buffer[0])
                                         +sizeof(UCHAR)+sizeof(USHORT)       //bufferformat,datalength fields
                                      );
        t = AvailableBufferSize / sizeof(SMB_DIRECTORY_INFORMATION);
        if (t<ReturnCount) { ReturnCount = t; }
    }
    RxDbgTrace( 0, Dbg, ("-------->count=%08lx\n",ReturnCount));
    if (ReturnCount==0) {
        Status = (STATUS_MORE_PROCESSING_REQUIRED);
        RxDbgTrace(0, Dbg, ("-->Count==0 EARLY OUT\n"));
        goto FINALLY;
    }

    StufferState = &OrdinaryExchange->AssociatedStufferState;
    ASSERT( StufferState );

    *pCountRemainingInSmbbuf = 0;
    OrdinaryExchange->Info.CoreSearch.NextDirInfo = NULL;

    COVERED_CALL(MRxSmbStartSMBCommand (StufferState,SetInitialSMB_ForReuse,
                                          SMB_COM_SEARCH, SMB_REQUEST_SIZE(SEARCH),
                                          NO_EXTRA_DATA,SMB_BEST_ALIGNMENT(1,0),RESPONSE_HEADER_SIZE_NOT_SPECIFIED,
                                          0,0,0,0 STUFFERTRACE(Dbg,'FC'))
                 );

    RxDbgTrace(0, Dbg,("core search command initial status = %lu\n",Status));
    MRxSmbDumpStufferState (1100,"SMB w/ core search before stuffing",StufferState);

    MRxSmbStuffSMB (StufferState,
         "0wwB4ywc!",
                                    //  0         UCHAR WordCount;                    // Count of parameter words = 2
               ReturnCount,         //  w         _USHORT( MaxCount );                // Number of dir. entries to return
               SearchAttributes,    //  w         _USHORT( SearchAttributes );
               SMB_WCT_CHECK(2)     //  B         _USHORT( ByteCount );               // Count of data bytes; min = 5
                                    //            UCHAR Buffer[1];                    // Buffer containing:
               &FindFirstPattern,   //  4        //UCHAR BufferFormat1;              //  0x04 -- ASCII
                                    //            //UCHAR FileName[];                 //  File name, may be null
               0x05,                //  y         //UCHAR BufferFormat2;              //  0x05 -- Variable block
               ResumeKeyLength,     //  w         //USHORT ResumeKeyLength;           //  Length of resume key, may be 0
                                    //  c         //UCHAR SearchStatus[];             //  Resume key
               ResumeKeyLength,smbFobx->Enumeration.CoreResumeKey
             );


    MRxSmbDumpStufferState (700,"SMB w/ core search after stuffing",StufferState);

    Status = SmbPseOrdinaryExchange(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                    SMBPSE_OETYPE_CORESEARCH
                                    );

    if (!NT_SUCCESS(Status)) goto FINALLY;

    smbFobx->Enumeration.Flags |= SMBFOBX_ENUMFLAG_SEARCH_NOT_THE_FIRST|SMBFOBX_ENUMFLAG_CORE_SEARCH_IN_PROGRESS;
    if (Status==(STATUS_SUCCESS) && *pCountRemainingInSmbbuf==0) {
         RxDbgTrace( 0, Dbg, ("MRxSmbLoadCoreFileSearchBuffer: no files returned...switch status\n"));
         EndOfSearchReached = TRUE;
         Status = (STATUS_NO_MORE_FILES);
    } else {
         EndOfSearchReached = FALSE;
    }
    if (EndOfSearchReached) {
        RxDbgTrace( 0, Dbg, ("MRxSmbLoadCoreFileSearchBuffer: no longer in progress...EOS\n"));
        smbFobx->Enumeration.Flags &= ~SMBFOBX_ENUMFLAG_CORE_SEARCH_IN_PROGRESS;
        smbFobx->Enumeration.ErrorStatus = (STATUS_NO_MORE_FILES);
    }
    //we dont save a resume key here since each individual copy operation will have to do that


FINALLY:
    if (FindFirstPattern.Buffer != NULL) {
        RxFreePool(FindFirstPattern.Buffer);
    }
    if (!NT_SUCCESS(Status)&&(Status!=(STATUS_MORE_PROCESSING_REQUIRED))) {
        RxDbgTrace( 0, Dbg, ("MRxSmbCoreFileSearch: Failed .. returning %lx\n",Status));
        smbFobx->Enumeration.Flags &= ~SMBFOBX_ENUMFLAG_CORE_SEARCH_IN_PROGRESS;
        smbFobx->Enumeration.ErrorStatus = Status;  //keep returning this
    }

    RxDbgTrace(-1, Dbg, ("MRxSmbLoadCoreFileSearchBuffer exiting.......OE=%08lx, st=%08lx\n",OrdinaryExchange,Status));

    return(Status);
}

#define ASSERT_SAME_FIELD(__field,__t1,__t2) { \
      ASSERT(FIELD_OFFSET(__t1,__field)==FIELD_OFFSET(__t2,__field)); \
      }

#define ASSERT_SAME_DIRINFO_FIELDS(__t1,__t2) {\
      ASSERT_SAME_FIELD(LastWriteTime,__t1,__t2); \
      ASSERT_SAME_FIELD(EndOfFile,__t1,__t2); \
      ASSERT_SAME_FIELD(AllocationSize,__t1,__t2); \
      ASSERT_SAME_FIELD(FileAttributes,__t1,__t2); \
      }
#if DBG
VOID MRxSmbCoreFileSeach_AssertFields(void){
    //just move this out of the main execution path so that we don't have to look at it while
    //we Uing the code
    ASSERT_SAME_DIRINFO_FIELDS(FILE_DIRECTORY_INFORMATION,FILE_FULL_DIR_INFORMATION);
    ASSERT_SAME_DIRINFO_FIELDS(FILE_DIRECTORY_INFORMATION,FILE_BOTH_DIR_INFORMATION);
}
#else
#define MRxSmbCoreFileSeach_AssertFields()
#endif

NTSTATUS
MRxSmbCoreFileSearch(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    )
/*++

Routine Description:

   This routine does a GetFileAttributes and remembers the reponse.

Arguments:

    OrdinaryExchange  - an exchange to be used for conducting this open.

Return Value:

    RXSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS Status = (STATUS_NOT_IMPLEMENTED);
    RxCaptureFcb; RxCaptureFobx;
    PMRX_SMB_FOBX smbFobx = MRxSmbGetFileObjectExtension(capFobx);

    PBYTE pBuffer = OrdinaryExchange->Info.Buffer;
    PULONG pLengthRemaining = OrdinaryExchange->Info.pBufferLength;
    ULONG InformationClass = OrdinaryExchange->Info.InfoClass;

    PFILE_DIRECTORY_INFORMATION pPreviousBuffer = NULL;

    PSMB_EXCHANGE Exchange = (PSMB_EXCHANGE) OrdinaryExchange;

    ULONG SuccessCount = 0;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbCoreFileSearch entering.......OE=%08lx\n",OrdinaryExchange));
    MRxSmbCoreFileSeach_AssertFields();

    OrdinaryExchange->Info.CoreSearch.CountRemaining =
              RxContext->QueryDirectory.ReturnSingleEntry?1:0x7ffffff;

    if ( (smbFobx->Enumeration.CoreResumeKey ==NULL )
             && ((smbFobx->Enumeration.CoreResumeKey = RxAllocatePoolWithTag(PagedPool,sizeof(SMB_RESUME_KEY),'rbms'))==NULL) ){
        RxDbgTrace(0, Dbg, ("...couldn't allocate resume key\n"));
        Status = (STATUS_INSUFFICIENT_RESOURCES);
        goto FINALLY;
    }
    RxDbgTrace( 0, Dbg, (".......smbFobx/resumekey=%08lx/%08lx\n",smbFobx,smbFobx->Enumeration.CoreResumeKey));

    Status = MRxSmbLoadCoreFileSearchBuffer( SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS );

    for (;;) {
        BOOLEAN BufferOverflow = FALSE;
        PSMB_DIRECTORY_INFORMATION NextDirInfo;
        UNICODE_STRING FileNameU;
        OEM_STRING FileNameA;
        WCHAR FileNameU_buffer[14];
        ULONG NameLength;
        PBYTE NextFileName;
        BOOLEAN Match,BufferOverFlow;

        if (!NT_SUCCESS(Status)) {
            if (Status == (STATUS_NO_MORE_FILES)) {
                if (SuccessCount > 0) {
                    Status = (STATUS_SUCCESS);
                }
            } else if (Status == (STATUS_MORE_PROCESSING_REQUIRED)) {
                if (SuccessCount > 0) {
                    Status = (STATUS_SUCCESS);
                } else {
                    Status = (STATUS_BUFFER_OVERFLOW);
                }
            }

            goto FINALLY;
        }
        ASSERT ( OrdinaryExchange->Info.CoreSearch.CountRemaining>0 );
        ASSERT ( OrdinaryExchange->Info.CoreSearch.CountRemainingInSmbbuf>0 );
        RxDbgTrace(0, Dbg, ("MRxSmbCoreFileSearch looptopcheck counts=%08lx,%08lx\n",
                    OrdinaryExchange->Info.CoreSearch.CountRemaining,
                    OrdinaryExchange->Info.CoreSearch.CountRemainingInSmbbuf
                    ));

        //next issue: does the next dirinfo match the criteria?!?

        NextDirInfo = OrdinaryExchange->Info.CoreSearch.NextDirInfo;
        NextFileName = &NextDirInfo->FileName[0];

        // According to colinw, some core servers do not remember to insert the null at the end of the name...
        // but the namelength macro handles this correctly. some servers (Xenix, apparently) pad the
        // names with spaces. again, the macro handles it....
        //

        NAME_LENGTH(NameLength, NextFileName,sizeof(NextDirInfo->FileName));

        FileNameA.Length = (USHORT)NameLength;
        FileNameA.MaximumLength = (USHORT)NameLength;
        FileNameA.Buffer = NextFileName;
        FileNameU.Length = sizeof(FileNameU_buffer);
        FileNameU.MaximumLength = sizeof(FileNameU_buffer);
        FileNameU.Buffer = &FileNameU_buffer[0];

        Status = RtlOemStringToUnicodeString(&FileNameU, &FileNameA, TRUE);
        RxDbgTrace(0, Dbg, ("MRxSmbCoreFileSearch considering.......filename=%wZ, template=%wZ\n",
                                    &FileNameU,&capFobx->UnicodeQueryTemplate));

        ASSERT(Status==(STATUS_SUCCESS));

        // we deal with a conversion failure by skipping this guy
        Match = (Status==(STATUS_SUCCESS));
        if (Match && smbFobx->Enumeration.WildCardsFound ) {
            //DbgBreakPoint();
            Match = FsRtlIsNameInExpression( &capFobx->UnicodeQueryTemplate,
                                                      &FileNameU, TRUE, NULL );
        }

        //next issue: will the next dirinfo fit in the user's buffer?!?
        if (Match) {
            ULONG SpaceNeeded;
            PBYTE pRememberBuffer = pBuffer;
            //QuadAlign!! pBuffer = (PBYTE)LongAlign(pBuffer); //assume that this will fit
            if (SuccessCount != 0) {
                pBuffer = (PBYTE)QuadAlignPtr(pBuffer); //assume that this will fit
            }
            SpaceNeeded = smbFobx->Enumeration.FileNameOffset+FileNameU.Length;
            if (pBuffer+SpaceNeeded > pRememberBuffer+*pLengthRemaining) {
                BufferOverflow = TRUE;
                pBuffer = pRememberBuffer; //rollback
            } else {
                PSMBCEDB_SERVER_ENTRY pServerEntry;
                PFILE_DIRECTORY_INFORMATION pThisBuffer = (PFILE_DIRECTORY_INFORMATION)pBuffer;
                SMB_TIME Time;
                SMB_DATE Date;
                PSMBCE_SERVER Server;

                Server = SmbCeGetExchangeServer(Exchange);
                BufferOverflow = FALSE;
                if (pPreviousBuffer != NULL) {
                    pPreviousBuffer->NextEntryOffset =
                        (ULONG)(((PBYTE)pThisBuffer)-((PBYTE)pPreviousBuffer));
                }
                pPreviousBuffer = pThisBuffer;
                RtlZeroMemory(pBuffer,smbFobx->Enumeration.FileNameOffset);
                RtlCopyMemory(pBuffer+smbFobx->Enumeration.FileNameOffset, FileNameU.Buffer,FileNameU.Length);
                *((PULONG)(pBuffer+smbFobx->Enumeration.FileNameLengthOffset)) = FileNameU.Length;
                //hallucinate the record based on specific return type
                switch (InformationClass) {
                case SMB_FIND_FILE_NAMES_INFO:
                    break;
                case SMB_FIND_FILE_DIRECTORY_INFO:
                case SMB_FIND_FILE_FULL_DIRECTORY_INFO:
                case SMB_FIND_FILE_BOTH_DIRECTORY_INFO:
                    //just fill what we have...we do not go to a lot of trouble on allocinfo as rdr1 did.
                    //     actually, rdr1 didn't do that here...only on getfielinfo.......
                    SmbMoveTime (&Time, &NextDirInfo->LastWriteTime);
                    SmbMoveDate (&Date, &NextDirInfo->LastWriteDate);
                    pThisBuffer->LastWriteTime = MRxSmbConvertSmbTimeToTime(Server, Time, Date);
                    pThisBuffer->EndOfFile.LowPart = SmbGetUlong(&NextDirInfo->FileSize);
                    pThisBuffer->FileAttributes = MRxSmbMapSmbAttributes (NextDirInfo->FileAttributes);
                    break;
                default:
                   RxDbgTrace( 0, Dbg, ("MRxSmbCoreFileSearch: Invalid FS information class\n"));
                   ASSERT(!"this can't happen");
                   Status = STATUS_INVALID_PARAMETER;
                   goto FINALLY;
                }
                pBuffer += SpaceNeeded;
                *pLengthRemaining -= (ULONG)(pBuffer-pRememberBuffer);
                OrdinaryExchange->Info.CoreSearch.CountRemaining--;
                SuccessCount++;
            }
        }

        //
        // if no match or no overflow, move up in the buffer. this means not only juggling the
        // pointers but also saving the resume key

        if (!Match || !BufferOverflow) {
            MRxSmbDumpResumeKey("BufferKey:",&NextDirInfo->ResumeKey);
            *(smbFobx->Enumeration.CoreResumeKey) = NextDirInfo->ResumeKey;
            MRxSmbDumpResumeKey("SaveKey:  ",smbFobx->Enumeration.CoreResumeKey);
            OrdinaryExchange->Info.CoreSearch.NextDirInfo = NextDirInfo + 1;
            OrdinaryExchange->Info.CoreSearch.CountRemainingInSmbbuf--;
        }

        if (OrdinaryExchange->Info.CoreSearch.CountRemaining==0) {
            Status = (STATUS_SUCCESS);
            goto FINALLY;
        }

        if (BufferOverflow) {
            Status = (SuccessCount==0)?(STATUS_BUFFER_OVERFLOW):(STATUS_SUCCESS);
            goto FINALLY;
        }

        if (OrdinaryExchange->Info.CoreSearch.CountRemainingInSmbbuf==0) {

            Status = MRxSmbLoadCoreFileSearchBuffer( SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS );

        }

    }


FINALLY:
    RxDbgTrace(-1, Dbg, ("MRxSmbCoreFileSearch exiting.......OE=%08lx, st=%08lx\n",OrdinaryExchange,Status));

    return(Status);
}

NTSTATUS
MrxSmbOemVolumeInfoToUnicode(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE,
    ULONG *VolumeLabelLengthReturned
    )
/*++

Routine Description:

   This routine does a GetFileAttributes and remembers the reponse.

Arguments:


Return Value:

    RXSTATUS - The return status for the operation
    also VolumeLabelLengthReturned is the number of bytes of the label that were stored, if any.

Notes:


--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    UNICODE_STRING VolumeLabelU;
    OEM_STRING VolumeLabelA;
    SMB_DIRECTORY_INFORMATION Buffer;
    ULONG NameLength;
    ULONG BytesToCopy;
    PBYTE VolumeLabel = &OrdinaryExchange->Info.QFSVolInfo.CoreLabel[0];

    PAGED_CODE();

    NAME_LENGTH(NameLength, VolumeLabel,
               sizeof(OrdinaryExchange->Info.QFSVolInfo.CoreLabel));

    VolumeLabelA.Length = (USHORT)NameLength;
    VolumeLabelA.MaximumLength = (USHORT)NameLength;
    VolumeLabelA.Buffer = VolumeLabel;

    //some core servers put a '.' in the labelname.....if it's there then remove it
    if ((NameLength>8)&& (VolumeLabel[8]=='.') ) {
        ULONG i;
        for (i=8;i<NameLength;i++) {
            VolumeLabel[i] = VolumeLabel[i+1];
        }
    }

    Status = RtlOemStringToUnicodeString(&VolumeLabelU, &VolumeLabelA, TRUE);

    if (NT_SUCCESS(Status)) {

        PULONG pBufferLength = OrdinaryExchange->Info.pBufferLength;
        PFILE_FS_VOLUME_INFORMATION pBuffer = OrdinaryExchange->Info.Buffer;
        BytesToCopy = min((ULONG)VolumeLabelU.Length, (*pBufferLength-sizeof(FILE_FS_VOLUME_INFORMATION)));

        RtlCopyMemory(&pBuffer->VolumeLabel[0],
                      VolumeLabelU.Buffer,
                      BytesToCopy);

        *VolumeLabelLengthReturned = BytesToCopy;
        pBuffer->VolumeLabelLength = VolumeLabelU.Length;
        IF_DEBUG {
            UNICODE_STRING FinalLabel;
            FinalLabel.Buffer = &pBuffer->VolumeLabel[0];
            FinalLabel.Length = (USHORT)BytesToCopy;
            RxDbgTrace(0, Dbg, ("MrxSmbOemVolumeInfoToUnicode vollabel=%wZ\n",&FinalLabel));
        }

        RtlFreeUnicodeString(&VolumeLabelU);
    }

    return(Status);
}




MrxSmbCoreQueryFsVolumeInfo(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    )
/*++

Routine Description:

   This routine does a GetFileAttributes and remembers the reponse.

Arguments:

    OrdinaryExchange  - an exchange to be used for conducting this open.

Return Value:

    RXSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS Status = (STATUS_NOT_IMPLEMENTED);

    PSMBSTUFFER_BUFFER_STATE StufferState;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MrxSmbCoreQueryFsVolumeInfo entering.......OE=%08lx\n",OrdinaryExchange));

    StufferState = &OrdinaryExchange->AssociatedStufferState;

    ASSERT( StufferState );

    COVERED_CALL(MRxSmbStartSMBCommand (StufferState,SetInitialSMB_ForReuse,SMB_COM_SEARCH,
                                SMB_REQUEST_SIZE(SEARCH),
                                NO_EXTRA_DATA,SMB_BEST_ALIGNMENT(1,0),RESPONSE_HEADER_SIZE_NOT_SPECIFIED,
                                0,0,0,0 STUFFERTRACE(Dbg,'FC'))
                 );

    MRxSmbDumpStufferState (1100,"SMB w/ searchvolumelabel before stuffing",StufferState);

    MRxSmbStuffSMB (StufferState,
         "0wwB4yw!",
                                    //  0         UCHAR WordCount;                    // Count of parameter words = 2
               1,                   //  w         _USHORT( MaxCount );                // Number of dir. entries to return
                                    //  w         _USHORT( SearchAttributes );
               SMB_FILE_ATTRIBUTE_VOLUME,
               SMB_WCT_CHECK(2)     //  B         _USHORT( ByteCount );               // Count of data bytes; min = 5
                                    //            UCHAR Buffer[1];                    // Buffer containing:
               &MRxSmbAll8dot3Files,//  4         //UCHAR BufferFormat1;              //  0x04 -- ASCII
                                    //           //UCHAR FileName[];                 //  File name, may be null
               0x05,                //  y         //UCHAR BufferFormat2;              //  0x05 -- Variable block
               0                    //  w         //USHORT ResumeKeyLength;           //  Length of resume key, may be 0
                                    //            //UCHAR SearchStatus[];             //  Resume key
             );


    MRxSmbDumpStufferState (700,"SMB w/ searchvolumelabel after stuffing",StufferState);
    //ASSERT(!"Now it's stuffed");

    Status = SmbPseOrdinaryExchange(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                    SMBPSE_OETYPE_COREQUERYLABEL
                                    );

    //Status = RxStatus(NOT_IMPLEMENTED);

FINALLY:
    RxDbgTrace(-1, Dbg, ("MrxSmbCoreQueryFsVolumeInfo exiting.......OE=%08lx, st=%08lx\n",OrdinaryExchange,Status));
    return(Status);
}

NTSTATUS
MrxSmbQueryFsVolumeInfo(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    )
/*++

Routine Description:

   This routine does a downlevel getvolumeinfo/FS_VOLUME_INFORMATION.

Arguments:

    OrdinaryExchange  - duh!

Return Value:

    RXSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS Status;
    RxCaptureFcb;
    RxCaptureFobx;

    PSMBCE_SERVER  pServer;
    BOOLEAN        UseTransactVersion;

    REQ_QUERY_FS_INFORMATION VolInfo;

    PFILE_FS_VOLUME_INFORMATION pBuffer = OrdinaryExchange->Info.Buffer;
    PULONG pBufferLength = OrdinaryExchange->Info.pBufferLength;

    ULONG VolumeLabelLengthReturned = 0;

    PAGED_CODE();

    ASSERT(pBuffer!=NULL);
    pServer = SmbCeGetExchangeServer(OrdinaryExchange);
    UseTransactVersion = BooleanFlagOn(pServer->DialectFlags,DF_LANMAN20);

    RxDbgTrace(+1, Dbg, ("MrxSmbQueryFsVolumeInfo entering.......OE=%08lx\n",OrdinaryExchange));

    pBuffer->SupportsObjects = FALSE;
    pBuffer->VolumeCreationTime.LowPart = 0;
    pBuffer->VolumeCreationTime.HighPart = 0;
    pBuffer->VolumeSerialNumber = 0;
    pBuffer->VolumeLabelLength = 0;

    OrdinaryExchange->Info.QFSVolInfo.CoreLabel[0] = 0; //no label

    if (!UseTransactVersion) {
        Status =  MrxSmbCoreQueryFsVolumeInfo(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS);
    } else {
        VolInfo.InformationLevel = SMB_INFO_VOLUME;

        Status = MRxSmbSimpleSyncTransact2(
                        SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                        SMBPSE_OETYPE_T2_FOR_LANMAN_VOLUMELABEL_INFO,
                        TRANS2_QUERY_FS_INFORMATION,
                        &VolInfo,sizeof(VolInfo),
                        NULL,0
                        );
    }

    ASSERT ( *pBufferLength>=sizeof(FILE_FS_VOLUME_INFORMATION));
    RxDbgTrace(0, Dbg, ("MrxSmbQueryFsVolumeInfo OEstatus=%08lx\n",Status));
    //DbgBreakPoint();

    if ( (Status==STATUS_SUCCESS) &&
         (OrdinaryExchange->Info.QFSVolInfo.CoreLabel[0] != 0) ) {

        Status = MrxSmbOemVolumeInfoToUnicode(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,&VolumeLabelLengthReturned);

    } else if ( (Status == STATUS_NO_SUCH_FILE)
                   || (Status == STATUS_NO_MORE_FILES) ) {
        //
        //  these statuses indicate that there's no volume label
        //  the remote volume.  Return success with no data.
        //

        Status = (STATUS_SUCCESS);

    }

    if (NT_SUCCESS(Status)) {
        *pBufferLength -= FIELD_OFFSET(FILE_FS_VOLUME_INFORMATION,VolumeLabel);
        *pBufferLength -= VolumeLabelLengthReturned;
    }


    RxDbgTrace(-1, Dbg, ("MrxSmbQueryFsVolumeInfo exiting.......OE=%08lx, st=%08lx\n",OrdinaryExchange,Status));
    return(Status);
}


NTSTATUS
MrxSmbCoreQueryDiskAttributes(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    )
/*++

Routine Description:

   This routine does a GetDiskAttributes and remembers the reponse in a buffer pointed to
   by the exchange. this is called from the downlevel queryvolumeinfo AND ALSO from
   extend-for-cached-write.

Arguments:

    OrdinaryExchange  - duh!

Return Value:

    RXSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS Status;
    RxCaptureFcb; RxCaptureFobx;

    PSMBSTUFFER_BUFFER_STATE StufferState;

    PAGED_CODE();

    ASSERT(OrdinaryExchange->Info.Buffer!=NULL);

    RxDbgTrace(+1, Dbg, ("MrxSmbCoreQueryDiskAttributes entering.......OE=%08lx\n",OrdinaryExchange));

    StufferState = &OrdinaryExchange->AssociatedStufferState;

    ASSERT( StufferState );
    COVERED_CALL(MRxSmbStartSMBCommand (StufferState,SetInitialSMB_ForReuse,SMB_COM_QUERY_INFORMATION_DISK,
                                SMB_REQUEST_SIZE(QUERY_INFORMATION_DISK),
                                NO_EXTRA_DATA,SMB_BEST_ALIGNMENT(1,0),RESPONSE_HEADER_SIZE_NOT_SPECIFIED,
                                0,0,0,0 STUFFERTRACE(Dbg,'FC'))
                 );

    RxDbgTrace(0, Dbg,("querydiskattribs command initial status = %lu\n",Status));
    MRxSmbDumpStufferState (1100,"SMB w/ querydiskattribs before stuffing",StufferState);

    MRxSmbStuffSMB (StufferState,
         "0B!",
                                    //  0         UCHAR WordCount;                    // Count of parameter words = 0
               SMB_WCT_CHECK(0) 0   //  B         _USHORT( ByteCount );               // Count of data bytes = 0
                                    //            UCHAR Buffer[1];                    // empty
             );

    MRxSmbDumpStufferState (700,"SMB w/ querydiskattribs after stuffing",StufferState);

    Status = SmbPseOrdinaryExchange(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                    SMBPSE_OETYPE_COREQUERYDISKATTRIBUTES
                                    );
FINALLY:
    RxDbgTrace(-1, Dbg, ("MrxSmbCoreQueryDiskAttributes exiting.......OE=%08lx, st=%08lx\n",OrdinaryExchange,Status));
    return(Status);
}

NTSTATUS
MrxSmbQueryDiskAttributes(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    )
/*++

Routine Description:

   This routine does a GetDiskAttributes and remembers the reponse in a buffer pointed to
   by the exchange. this is called from the downlevel queryvolumeinfo AND ALSO from
   extend-for-cached-write.

Arguments:

    OrdinaryExchange  - duh!

Return Value:

    RXSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS Status;

    RxCaptureFcb;
    RxCaptureFobx;

    PSMBCE_SERVER pServer;
    BOOLEAN UseTransactVersion;

    REQ_QUERY_FS_INFORMATION VolInfo;

    PAGED_CODE();

    ASSERT(OrdinaryExchange->Info.Buffer!=NULL);

    pServer = SmbCeGetExchangeServer(OrdinaryExchange);
    UseTransactVersion = BooleanFlagOn(pServer->DialectFlags,DF_LANMAN20) &&
                         !MRxSmbForceCoreGetAttributes;
    if (!UseTransactVersion) {
        return MrxSmbCoreQueryDiskAttributes(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS);
    }

    RxDbgTrace(+1, Dbg, ("MrxSmbQueryDiskAttributes entering.......OE=%08lx\n",OrdinaryExchange));

    VolInfo.InformationLevel = SMB_INFO_ALLOCATION;

    Status = MRxSmbSimpleSyncTransact2(
                    SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                    SMBPSE_OETYPE_T2_FOR_LANMAN_DISKATTRIBUTES_INFO,
                    TRANS2_QUERY_FS_INFORMATION,
                    &VolInfo,sizeof(VolInfo),
                    NULL,0
                    );

    RxDbgTrace(-1, Dbg, ("MrxSmbQueryDiskAttributes exiting.......OE=%08lx, st=%08lx\n",OrdinaryExchange,Status));
    return(Status);
}

NTSTATUS
MRxSmbGetNtAllocationInfo (
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    );

NTSTATUS
SmbPseExchangeStart_CoreInfo(
      SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
      )
/*++

Routine Description:

    This is the start routine for VOLINFO.

Arguments:

    pExchange - the exchange instance

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = (STATUS_NOT_IMPLEMENTED);
    PSMBSTUFFER_BUFFER_STATE StufferState = &OrdinaryExchange->AssociatedStufferState;

    ULONG InformationClass = OrdinaryExchange->Info.InfoClass;
    PBYTE pBuffer = (PBYTE)OrdinaryExchange->Info.Buffer;
    PULONG pBufferLength = OrdinaryExchange->Info.pBufferLength;

    RxCaptureFcb; RxCaptureFobx;
    PMRX_SRV_OPEN SrvOpen = capFobx->pSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);
    PSMBCEDB_SERVER_ENTRY pServerEntry = SmbCeGetAssociatedServerEntry(capFcb->pNetRoot->pSrvCall);

    PAGED_CODE();
    RxDbgTrace(+1, Dbg, ("SmbPseExchangeStart_CoreInfo\n", 0 ));

    ASSERT_ORDINARY_EXCHANGE(OrdinaryExchange);

    MRxSmbSetInitialSMB(StufferState STUFFERTRACE(Dbg,'FC'));

    //ASSERT (StufferState->CurrentCommand == SMB_COM_NO_ANDX_COMMAND);

    switch (OrdinaryExchange->EntryPoint) {
    case SMBPSE_OE_FROM_QUERYVOLUMEINFO:
        switch (InformationClass) {
        case FileFsVolumeInformation:
            Status = MrxSmbQueryFsVolumeInfo(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS);
            goto FINALLY;
        case FileFsSizeInformation:
            Status = MrxSmbQueryDiskAttributes(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS);
            goto FINALLY;
        default:
            ASSERT(!"this should have been turned away");
            goto FINALLY;
         }
         ASSERT(!"shouldn't get here1");
         goto FINALLY;
    case SMBPSE_OE_FROM_QUERYFILEINFO:
        Status = MRxSmbGetFileAttributes(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS);
        if (!NT_SUCCESS(Status)) goto FINALLY;
        switch (InformationClass) {
        case SMB_QUERY_FILE_BASIC_INFO:
            *((PFILE_BASIC_INFORMATION)pBuffer) = OrdinaryExchange->Create.FileInfo.Basic;
            *pBufferLength -= sizeof(FILE_BASIC_INFORMATION);
            goto FINALLY;
        case SMB_QUERY_FILE_STANDARD_INFO:
            *((PFILE_STANDARD_INFORMATION)pBuffer) = OrdinaryExchange->Create.FileInfo.Standard;
            *pBufferLength -= sizeof(FILE_STANDARD_INFORMATION);
            goto FINALLY;
        default:
            ASSERT(!"this should have been turned away");
            goto FINALLY;
         }
        ASSERT(!"shouldn't get here2");
        goto FINALLY;
    case SMBPSE_OE_FROM_SETFILEINFO:
        switch (InformationClass) {
        case FileBasicInformation:
            {
                ULONG SmbAttributes = MRxSmbMapFileAttributes(((PFILE_BASIC_INFORMATION)pBuffer)->FileAttributes);
                PFILE_BASIC_INFORMATION BasicInfo = (PFILE_BASIC_INFORMATION)pBuffer;

                if (SmbAttributes != 0 ||
                    (BasicInfo->CreationTime.QuadPart == 0 &&
                     BasicInfo->LastWriteTime.QuadPart == 0 &&
                     BasicInfo->LastAccessTime.QuadPart == 0)) {
                    Status = MRxSmbSetFileAttributes(
                                SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                SmbAttributes);
                }

                if (BasicInfo->LastWriteTime.QuadPart == 0 &&
                    FlagOn(pServerEntry->Server.DialectFlags,DF_W95)) {
                    // Win9x server only takes last write time.
                    Status = STATUS_SUCCESS;
                    goto FINALLY;
                }

                if (BasicInfo->CreationTime.QuadPart != 0 ||
                    BasicInfo->LastWriteTime.QuadPart != 0 ||
                    BasicInfo->LastAccessTime.QuadPart != 0) {

                    Status = MRxSmbDeferredCreate(RxContext);
            
                    if (Status == STATUS_SUCCESS) {
                        Status = MRxSmbSetFileAttributes(
                                    SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                    SmbAttributes);
                    }
                }

            }
            goto FINALLY;

        case FileEndOfFileInformation:
            if (((PFILE_END_OF_FILE_INFORMATION)pBuffer)->EndOfFile.HighPart) {
                Status = (STATUS_INVALID_PARAMETER);
            } else {
                Status = MRxSmbCoreTruncate(
                                  SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                  smbSrvOpen->Fid,
                                  ((PFILE_END_OF_FILE_INFORMATION)pBuffer)->EndOfFile.LowPart);
            }

            goto FINALLY;

        case FileDispositionInformation:
            OrdinaryExchange->pPathArgument1 = GET_ALREADY_PREFIXED_NAME(SrvOpen,capFcb);
            Status = MRxSmbCoreDeleteForSupercedeOrClose(
                         SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                         ((BOOLEAN)( NodeType(capFcb)==RDBSS_NTC_STORAGE_TYPE_DIRECTORY )));

            goto FINALLY;

        default:
            ASSERT(!"this should have been turned away");
            goto FINALLY;
        }

        ASSERT(!"shouldn't get here3");
        goto FINALLY;

    case SMBPSE_OE_FROM_QUERYDIRECTORY:
        Status = MRxSmbCoreFileSearch(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS);
        goto FINALLY;

    case SMBPSE_OE_FROM_EXTENDFILEFORCACHEING:
        {
            PSMBCE_NET_ROOT psmbNetRoot = SmbCeGetExchangeNetRoot(OrdinaryExchange);
            PMRX_V_NET_ROOT pVNetRoot = SmbCeGetExchangeVNetRoot(OrdinaryExchange);
            PMRX_NET_ROOT pNetRoot = pVNetRoot->pNetRoot;
            PSMBCE_SERVER psmbServer = SmbCeGetExchangeServer(OrdinaryExchange);
            ULONG ClusterSize;
            PLARGE_INTEGER pFileSize = (PLARGE_INTEGER)(OrdinaryExchange->Info.Buffer);
            PLARGE_INTEGER pAllocationSize = (PLARGE_INTEGER)(OrdinaryExchange->Info.pBufferLength);

            //we will need the cluster size
            if (OrdinaryExchange->ServerVersion==pNetRoot->ParameterValidationStamp) {

                ClusterSize=pNetRoot->DiskParameters.ClusterSize;

            } else {

                RxSynchronizeBlockingOperations( RxContext, (PFCB)RxContext->pFcb, &psmbNetRoot->ClusterSizeSerializationQueue );
                if (OrdinaryExchange->ServerVersion!=pNetRoot->ParameterValidationStamp) {

                    //
                    //here we have to go find out the clustersize

                    NTSTATUS LocalStatus;
                    FILE_FS_SIZE_INFORMATION UsersBuffer;
                    ULONG BufferLength = sizeof(FILE_FS_SIZE_INFORMATION);
                    //fill in the exchange params so that we can get the params we need
                    OrdinaryExchange->Info.Buffer = &UsersBuffer;
                    OrdinaryExchange->Info.pBufferLength = &BufferLength;
                    LocalStatus = MrxSmbQueryDiskAttributes(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS);
                    if (LocalStatus == STATUS_SUCCESS) {
                        ClusterSize = UsersBuffer.BytesPerSector * UsersBuffer.SectorsPerAllocationUnit;
                        pNetRoot->ParameterValidationStamp =OrdinaryExchange->ServerVersion;
                    } else {
                        ClusterSize = 0;
                    }
                    if (ClusterSize==0) {
                        ClusterSize = 1;
                    }
                    pNetRoot->DiskParameters.ClusterSize = ClusterSize;
                    RxDbgTrace(0, Dbg, ("clustersize set to %08lx\n", ClusterSize ));
                    RxLog(("clustersize rx/n/cs %lx %lx %lx\n",
                              OrdinaryExchange->RxContext,pNetRoot,ClusterSize ));
                } else {

                    // someone else went and got the value while i was asleep...just use it

                    ClusterSize=pNetRoot->DiskParameters.ClusterSize;

                }

                RxResumeBlockedOperations_Serially(RxContext,&psmbNetRoot->ClusterSizeSerializationQueue);
            }

            ASSERT (ClusterSize != 0);

            if (FlagOn(psmbServer->DialectFlags,DF_NT_SMBS)) {
                //i'm using this to identify a server that supports 64bit offsets
                //for these guys, we write a zero at the eof....since the filesystems
                //extend on writes this will be much better than a set-end-of-file
                LARGE_INTEGER ByteOffset,AllocationSize,ClusterSizeAsLI;
                ULONG Buffer = 0;
                UCHAR WriteCommand;
                PSMBCE_SERVER pServer = SmbCeGetExchangeServer(OrdinaryExchange);

                if (FlagOn(pServer->DialectFlags,DF_LARGE_FILES)) {
                    WriteCommand = SMB_COM_WRITE_ANDX;
                } else {
                    WriteCommand = SMB_COM_WRITE;
                }

                ByteOffset.QuadPart = pFileSize->QuadPart - 1;

                MRxSmbSetInitialSMB(StufferState STUFFERTRACE(Dbg,0));
                COVERED_CALL(MRxSmbBuildWriteRequest(
                                    OrdinaryExchange,
                                    TRUE, // IsPagingIo
                                    WriteCommand,
                                    1,
                                    &ByteOffset,
                                    (PBYTE)&Buffer,
                                    NULL //BufferAsMdl,
                                    ));
                COVERED_CALL(SmbPseOrdinaryExchange(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                            SMBPSE_OETYPE_EXTEND_WRITE
                                            ));

                //this is what you do if you can't do better
                ClusterSizeAsLI.QuadPart = ClusterSize;
                AllocationSize.QuadPart =
                    (pFileSize->QuadPart+ ClusterSizeAsLI.QuadPart)  &
                    ~(ClusterSizeAsLI.QuadPart - 1);

                *pAllocationSize = AllocationSize; //64bit!

                Status = MRxSmbGetNtAllocationInfo(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS);

                if ( (NT_SUCCESS(Status)) &&
                     (OrdinaryExchange->Transact2.AllocationSize.QuadPart > AllocationSize.QuadPart)) {
                    *pAllocationSize = OrdinaryExchange->Transact2.AllocationSize; //64bit!
                    RxDbgTrace(0, Dbg, ("alocatedsiz222e set to %08lx\n", pAllocationSize->LowPart ));
                }
            }

            if ( (!FlagOn(psmbServer->DialectFlags,DF_NT_SMBS)) || (!NT_SUCCESS(Status)) ) {
                ULONG FileSize,AllocationSize;
                FileSize = pFileSize->LowPart;
                COVERED_CALL(MRxSmbCoreTruncate(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                            smbSrvOpen->Fid, FileSize
                                            ));
                //this is what you do if you can't do better
                AllocationSize = (FileSize+ClusterSize)&~(ClusterSize-1);
                pAllocationSize->QuadPart = AllocationSize; //64bit!
                RxDbgTrace(0, Dbg, ("alocatedsize set to %08lx\n", pAllocationSize->LowPart ));
                //if we care a lot about downlevel performance, we could do the same as ntgetallocation
                //except that we would use a 32bit smb.........like query_information2
            }


        }
        goto FINALLY;
    }


FINALLY:

    RxDbgTrace(-1, Dbg, ("SmbPseExchangeStart_CoreInfo exit w %08lx\n", Status ));
    return Status;
}

NTSTATUS
MRxSmbFinishSearch (
      PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
      PRESP_SEARCH                Response
      )
/*++

Routine Description:

    This routine actually gets the stuff out of the VolInfo response and finishes the close.

Arguments:

    OrdinaryExchange - the exchange instance
    Response - the response

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = (STATUS_SUCCESS);
    PRX_CONTEXT RxContext = OrdinaryExchange->RxContext;
    RxCaptureFobx;
    PMRX_SRV_OPEN SrvOpen = capFobx->pSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);


    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbFinishSearch\n" ));
    SmbPseOEAssertConsistentLinkageFromOE("MRxSmbFinishSearch:");

    if (Response->WordCount != 1) {
        Status = STATUS_INVALID_NETWORK_RESPONSE;
        OrdinaryExchange->Status = STATUS_INVALID_NETWORK_RESPONSE;
        goto FINALLY;
    }

    if (OrdinaryExchange->OEType == SMBPSE_OETYPE_COREQUERYLABEL) {
        //here, all we do is to copy the label to wherever is pointed to by
        if (SmbGetUshort(&Response->Count)>0) {
            PBYTE smbDirInfotmp = &Response->Buffer[0]
                                        +sizeof(UCHAR) //bufferformat
                                        +sizeof(USHORT); //datalength
            PSMB_DIRECTORY_INFORMATION smbDirInfo = (PSMB_DIRECTORY_INFORMATION)smbDirInfotmp;
            RxDbgTrace(+1, Dbg, ("MRxSmbFinishSearch corelabl=%s,size=%d\n",
                                     smbDirInfo->FileName, sizeof(smbDirInfo->FileName) ));
            
            if (sizeof(smbDirInfo->FileName) != 13) { //straightfrom the spec
                Status = STATUS_INVALID_NETWORK_RESPONSE;
                OrdinaryExchange->Status = STATUS_INVALID_NETWORK_RESPONSE;
                goto FINALLY;
            }


            RtlCopyMemory(OrdinaryExchange->Info.QFSVolInfo.CoreLabel,
                          smbDirInfo->FileName, sizeof(smbDirInfo->FileName)
                         );
        } else {
            OrdinaryExchange->Info.QFSVolInfo.CoreLabel[0] = 0; //no label
        }
    } else if (OrdinaryExchange->OEType == SMBPSE_OETYPE_CORESEARCHFORCHECKEMPTY) {
        //here, we 're doing a search SMB to see if the directory is empty. we have to read thru the
        // entries returned (if successful). if we encounter ones that are neither '.' or '..',  set
        // resumekey to null since that will tell the guy above that the directory is nonempty
        ULONG Count = SmbGetUshort(&Response->Count);
        PSMB_DIRECTORY_INFORMATION NextDirInfo =
               (PSMB_DIRECTORY_INFORMATION)(&Response->Buffer[0]+sizeof(UCHAR)+sizeof(USHORT));

        for (;Count>0;Count--,NextDirInfo++) {
            RxDbgTrace(0, Dbg, ("--->emptydirchk: file=%s\n",&NextDirInfo->FileName[0]));
            /*
            // Since the DOS Server returns the file name ".           " instead of ".", and so does the
            // "..          ", the following if {...} statements are always past through with no action.
            // But those statements make the RMDIR not working on OS2 Server  since  it  returns the "."
            // and ".." without following blanks.  After the if {...} statements were removed, the RMDIR
            // workes on OS2 Server and no impact has been found to access the DOS Server.
            if (NextDirInfo->FileName[0]=='.') {
                CHAR c1;
                if ((c1=NextDirInfo->FileName[1])==0) {
                    continue; //skip past "."
                } else if ((c1=='.')&&(NextDirInfo->FileName[2]==0)) {
                    continue; //skip past ".."
                } else {
                    NOTHING;
                }
            }
            */
            // here we have found a bad one...make sure there's no resume key and change the status
            Status = (STATUS_NO_MORE_FILES);
            OrdinaryExchange->Info.CoreSearch.EmptyCheckResumeKey = NULL;
        }
        //if we get here with success, set up the resume key and buffer
        if (Status == (STATUS_SUCCESS)) {
            NextDirInfo--;
            OrdinaryExchange->Info.CoreSearch.EmptyCheckResumeKeyBuffer =
                                    NextDirInfo->ResumeKey;
            OrdinaryExchange->Info.CoreSearch.EmptyCheckResumeKey =
                                    &OrdinaryExchange->Info.CoreSearch.EmptyCheckResumeKeyBuffer;
        }
    } else {
        //all that we do here is to setup the nextdirptr and the count in the OE
        ASSERT(OrdinaryExchange->OEType == SMBPSE_OETYPE_CORESEARCH);
        OrdinaryExchange->Info.CoreSearch.CountRemainingInSmbbuf = SmbGetUshort(&Response->Count);
        OrdinaryExchange->Info.CoreSearch.NextDirInfo =
               (PSMB_DIRECTORY_INFORMATION)(&Response->Buffer[0]+sizeof(UCHAR)+sizeof(USHORT));
        IF_DEBUG {
            ULONG tcount = OrdinaryExchange->Info.CoreSearch.CountRemainingInSmbbuf;
            PSMB_DIRECTORY_INFORMATION ndi = OrdinaryExchange->Info.CoreSearch.NextDirInfo;
            RxDbgTrace(0, Dbg, ("--->coresearch: count/ndi=%08lx/%08lx\n",tcount,ndi));
            if (tcount) {
                //DbgBreakPoint();
                RxDbgTrace(0, Dbg, ("--->coresearch: firstfile=%s\n",&ndi->FileName[0]));
            }
        }
    }

FINALLY:
    RxDbgTrace(-1, Dbg, ("MRxSmbFinishSearch   returning %08lx\n", Status ));
    return Status;
}

NTSTATUS
MRxSmbFinishQueryDiskInfo (
      PSMB_PSE_ORDINARY_EXCHANGE   OrdinaryExchange,
      PRESP_QUERY_INFORMATION_DISK Response
      )
/*++

Routine Description:

    This routine actually gets the stuff out of the VolInfo response and finishes the close.

Arguments:

    OrdinaryExchange - the exchange instance
    Response - the response

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = (STATUS_SUCCESS);
    PFILE_FS_SIZE_INFORMATION UsersBuffer = OrdinaryExchange->Info.Buffer;
    PULONG BufferLength = OrdinaryExchange->Info.pBufferLength;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbFinishQueryDiskInfo\n" ));
    SmbPseOEAssertConsistentLinkageFromOE("MRxSmbFinishQueryDiskInfo:");

    IF_DEBUG{
        PRX_CONTEXT RxContext = OrdinaryExchange->RxContext;
        RxCaptureFobx;
        PMRX_SRV_OPEN SrvOpen = capFobx->pSrvOpen;
        PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);
        ASSERT( NodeType(SrvOpen) == RDBSS_NTC_SRVOPEN );
    }

    if (Response->WordCount != 5 ||
        SmbGetUshort(&Response->ByteCount) != 0) {
        Status = STATUS_INVALID_NETWORK_RESPONSE;
        OrdinaryExchange->Status = STATUS_INVALID_NETWORK_RESPONSE;
        goto FINALLY;
    }

    UsersBuffer->TotalAllocationUnits.QuadPart = SmbGetUshort(&Response->TotalUnits);
    UsersBuffer->AvailableAllocationUnits.QuadPart = SmbGetUshort(&Response->FreeUnits);
    UsersBuffer->SectorsPerAllocationUnit = SmbGetUshort(&Response->BlocksPerUnit);
    UsersBuffer->BytesPerSector = SmbGetUshort(&Response->BlockSize);

    *BufferLength -= sizeof(FILE_FS_SIZE_INFORMATION);

FINALLY:
    RxDbgTrace(-1, Dbg, ("MRxSmbFinishQueryDiskInfo   returning %08lx\n", Status ));
    return Status;
}

NTSTATUS
MRxSmbExtendForCache (
    IN OUT struct _RX_CONTEXT * RxContext,
    IN     PLARGE_INTEGER   pNewFileSize,
       OUT PLARGE_INTEGER   pNewAllocationSize
    )
/*++

Routine Description:

   This routine handles network requests to extend the file for cached IO. we just share the
   core_info skeleton.

Arguments:

    RxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status;
    RxCaptureFcb; RxCaptureFobx;

    PMRX_SRV_OPEN SrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen;

    PMRXSMB_RX_CONTEXT pMRxSmbContext = MRxSmbGetMinirdrContext(RxContext);

    PSMB_EXCHANGE Exchange;

    PAGED_CODE();

    if (capFcb->Attributes & FILE_ATTRIBUTE_COMPRESSED) {
        //here, we just get out since disk reservations don't do us any good....
        pNewAllocationSize->QuadPart = (pNewFileSize->QuadPart)<<2;
        return(STATUS_SUCCESS);
    }

    RxDbgTrace(+1, Dbg, ("MRxSmbExtendForCache %08lx %08lx %08lx %08lx\n",
                     capFcb->Header.FileSize.LowPart,
                     capFcb->Header.AllocationSize.LowPart,
                     pNewFileSize->LowPart,
                     pNewAllocationSize->LowPart
               ));

    ASSERT( NodeType(capFobx->pSrvOpen) == RDBSS_NTC_SRVOPEN );
    SrvOpen = capFobx->pSrvOpen;
    smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);

    if (FALSE) {
        DbgPrint("Extend top  %08lx %08lx %08lx %08lx\n",
                     capFcb->Header.FileSize.LowPart,
                     capFcb->Header.AllocationSize.LowPart,
                     pNewFileSize->LowPart,
                     pNewAllocationSize->LowPart);
    }

    //we just pass in our info into MRxSmbCoreInformation thru the existing pointers....
    //we have two pointers.....the first two params are ptrs......
    Status = MRxSmbCoreInformation(RxContext,0,
                                   (PVOID)pNewFileSize,
                                   (PULONG)pNewAllocationSize,
                                   SMBPSE_OE_FROM_EXTENDFILEFORCACHEING
                                   );
    if (FALSE) {
        DbgPrint("Extend exit Status %lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
                     Status,
                     capFcb->Header.FileSize.HighPart,
                     capFcb->Header.FileSize.LowPart,
                     capFcb->Header.AllocationSize.HighPart,
                     capFcb->Header.AllocationSize.LowPart,
                     pNewFileSize->HighPart,
                     pNewFileSize->LowPart,
                     pNewAllocationSize->HighPart,
                     pNewAllocationSize->LowPart);
    }

    RxLog(("Extend exit %lx %lx %lx %lx %lx\n",
                     RxContext,
                     capFcb->Header.FileSize.LowPart,
                     capFcb->Header.AllocationSize.LowPart,
                     pNewFileSize->LowPart,
                     pNewAllocationSize->LowPart));

    RxDbgTrace(-1, Dbg, ("MRxSmbExtendForCache  exit with status=%08lx %08lx %08lx\n",
                          Status, pNewFileSize->LowPart, pNewAllocationSize->LowPart));
    return(Status);

}

NTSTATUS
MRxSmbExtendForNonCache(
    IN OUT struct _RX_CONTEXT * RxContext,
    IN     PLARGE_INTEGER   pNewFileSize,
       OUT PLARGE_INTEGER   pNewAllocationSize
    )
/*++

Routine Description:

   This routine handles network requests to extend the file for noncached IO. since the write
   itself will extend the file, we can pretty much just get out quickly.

Arguments:

    RxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    //RxCaptureFcb; RxCaptureFobx;

    //PMRXSMB_RX_CONTEXT pMRxSmbContext = MRxSmbGetMinirdrContext(RxContext);

    //PSMB_EXCHANGE Exchange;

    PAGED_CODE();

    pNewAllocationSize->QuadPart = pNewFileSize->QuadPart;

    return(Status);
}

NTSTATUS
MRxSmbGetNtAllocationInfo (
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    )
/*++

Routine Description:

   gets the nt allocation information by doing a simple transact........

Arguments:

    OrdinaryExchange  - an exchange to be used for conducting this open.

Return Value:

    RXSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS Status;
    RxCaptureFcb; RxCaptureFobx;
    PMRX_SRV_OPEN SrvOpen = capFobx->pSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);

    REQ_QUERY_FILE_INFORMATION FileInfo;

    PAGED_CODE();

    FileInfo.Fid = smbSrvOpen->Fid;
    FileInfo.InformationLevel = SMB_QUERY_FILE_STANDARD_INFO;

    Status = MRxSmbSimpleSyncTransact2(
                    SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                    SMBPSE_OETYPE_T2_FOR_NT_FILE_ALLOCATION_INFO,
                    TRANS2_QUERY_FILE_INFORMATION,
                    &FileInfo,sizeof(FileInfo),
                    NULL,0
                    );

    return(Status);
}

NTSTATUS
__MRxSmbSimpleSyncTransact2(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE,
    IN SMB_PSE_ORDINARY_EXCHANGE_TYPE OEType,
    IN ULONG TransactSetupCode,
    IN PVOID Params,
    IN ULONG ParamsLength,
    IN PVOID Data,
    IN ULONG DataLength,
    IN PSMB_PSE_OE_T2_FIXUP_ROUTINE FixupRoutine
    )
/*++

Routine Description:

   This routine does a simple 1-in-1out transact2

Arguments:

    OrdinaryExchange  - an exchange to be used for conducting this open.

Return Value:

    RXSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS Status;
    RxCaptureFcb; RxCaptureFobx;

    PSMB_EXCHANGE Exchange = (PSMB_EXCHANGE) OrdinaryExchange;

    PSMBSTUFFER_BUFFER_STATE StufferState;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbSimpleSyncTransact2 entering.......OE=%08lx\n",OrdinaryExchange));

    StufferState = &OrdinaryExchange->AssociatedStufferState;

    ASSERT( StufferState );
    COVERED_CALL(MRxSmbStartSMBCommand (StufferState,SetInitialSMB_ForReuse,SMB_COM_TRANSACTION2,
                                SMB_REQUEST_SIZE(TRANSACTION),
                                NO_EXTRA_DATA,SMB_BEST_ALIGNMENT(1,0),RESPONSE_HEADER_SIZE_NOT_SPECIFIED,
                                0,0,0,0 STUFFERTRACE(Dbg,'FC'))
                 );

    MRxSmbDumpStufferState (1100,"SMB w/ pseT2 before stuffing",StufferState);

    //the return sizes of 100 and 800 are chosen arbitrarily.

    MRxSmbStuffSMB (StufferState,
       "0wwwwdD",
                                    //  0         UCHAR WordCount;                    // Count of parameter words; value = (14 + SetupCount)
           ParamsLength,            //  w         _USHORT( TotalParameterCount );     // Total parameter bytes being sent
           DataLength,              //  w         _USHORT( TotalDataCount );          // Total data bytes being sent
           100,                     //  w         _USHORT( MaxParameterCount );       // Max parameter bytes to return
           800,                     //  w         _USHORT( MaxDataCount );            // Max data bytes to return
           0,                       //  d   .     UCHAR MaxSetupCount;                // Max setup words to return
                                    //      .     UCHAR Reserved;
                                    //      .     _USHORT( Flags );                   // Additional information:
                                    //                                                //  bit 0 - also disconnect TID in Tid
                                    //                                                //  bit 1 - one-way transacion (no resp)
                                    //  D         _ULONG( Timeout );
          SMB_OFFSET_CHECK(TRANSACTION,Timeout) 0,
       STUFFER_CTL_NORMAL, "wwpwQyyw",
          0,                        //  w         _USHORT( Reserved2 );
          ParamsLength,             //  w         _USHORT( ParameterCount );          // Parameter bytes sent this buffer
                                    //  p         _USHORT( ParameterOffset );         // Offset (from header start) to params
          DataLength,               //  w         _USHORT( DataCount );               // Data bytes sent this buffer
                                    //  Q         _USHORT( DataOffset );              // Offset (from header start) to data
          SMB_OFFSET_CHECK(TRANSACTION,DataOffset)
          1,                        //  y         UCHAR SetupCount;                   // Count of setup words
          0,                        //  y         UCHAR Reserved3;                    // Reserved (pad above to word)
                                    //            UCHAR Buffer[1];                    // Buffer containing:
          TransactSetupCode,        //  w         //USHORT Setup[];                   //  Setup words (# = SetupWordCount)
       STUFFER_CTL_NORMAL, "ByS6cS5c!",
           SMB_WCT_CHECK(15)        //  B         //USHORT ByteCount;                 //  Count of data bytes
           0,                       //  y         //UCHAR Name[];                     //  Name of transaction (NULL if Transact2)
                                    //  S         //UCHAR Pad[];                      //  Pad to SHORT or LONG
                                    //  6c        //UCHAR Parameters[];               //  Parameter bytes (# = ParameterCount)
           ParamsLength,Params,
                                    //  S         //UCHAR Pad1[];                     //  Pad to SHORT or LONG
                                    //  5c        //UCHAR Data[];                     //  Data bytes (# = DataCount)
           DataLength,Data
             );


    MRxSmbDumpStufferState (700,"SMB w/ pseT2 after stuffing",StufferState);
    //ASSERT(!"Now it's stuffed");

    if (FixupRoutine) {
        Status = FixupRoutine(OrdinaryExchange);
        if (Status!=STATUS_SUCCESS) {
            goto FINALLY;
        }
    }
    Status = SmbPseOrdinaryExchange(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                    OEType
                                    );


FINALLY:
    RxDbgTrace(-1, Dbg, ("MRxSmbSimpleSyncTransact2 exiting.......OE=%08lx, st=%08lx\n",OrdinaryExchange,Status));
    return(Status);
}

NTSTATUS
MRxSmbFinishTransaction2 (
      IN OUT PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
      IN     PRESP_TRANSACTION           Response
      )
/*++

Routine Description:

    This routine finishes a transact2. what it does depends on the OE_TYPE.

Arguments:

    OrdinaryExchange - the exchange instance
    Response - the response

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = (STATUS_SUCCESS);
    PSMBSTUFFER_BUFFER_STATE StufferState = &OrdinaryExchange->AssociatedStufferState;

    PAGED_CODE();  //could actually be nonpaged

    RxDbgTrace(+1, Dbg, ("MRxSmbFinishTransaction2\n", 0 ));
    SmbPseOEAssertConsistentLinkageFromOE("MRxSmbFinishTransaction2:");

    switch (OrdinaryExchange->OEType) {
    case SMBPSE_OETYPE_T2_FOR_NT_FILE_ALLOCATION_INFO:{
        PFILE_STANDARD_INFORMATION StandardInfo;
        if (   (Response->WordCount!=10)
            || (SmbGetUshort(&Response->TotalParameterCount)!=2)
            || (SmbGetUshort(&Response->ParameterCount)!=2)
            || (SmbGetUshort(&Response->ParameterDisplacement)!=0)
            || (SmbGetUshort(&Response->TotalDataCount)!=24)
            || (SmbGetUshort(&Response->DataCount)!=24)
            || (SmbGetUshort(&Response->DataDisplacement)!=0)) {
            Status = STATUS_INVALID_NETWORK_RESPONSE;
            RxDbgTrace(+1, Dbg, ("Invalid parameter(s) received.\n", 0 ));
            break;
        }

        StandardInfo = (PFILE_STANDARD_INFORMATION)
                          (StufferState->BufferBase+SmbGetUshort(&Response->DataOffset));
        OrdinaryExchange->Transact2.AllocationSize.LowPart
                     =  SmbGetUlong(&StandardInfo->AllocationSize.LowPart);
        OrdinaryExchange->Transact2.AllocationSize.HighPart
                     =  SmbGetUlong(&StandardInfo->AllocationSize.HighPart);

        RxDbgTrace(0, Dbg, ("MRxSmbFinishTransaction2   nt allocation %08lx\n",
                               OrdinaryExchange->Transact2.AllocationSize.LowPart ));
        }break;

    case SMBPSE_OETYPE_T2_FOR_LANMAN_DISKATTRIBUTES_INFO:{
        PFILE_FS_SIZE_INFORMATION UsersBuffer = OrdinaryExchange->Info.Buffer;
        PULONG BufferLength = OrdinaryExchange->Info.pBufferLength;
        PQFS_ALLOCATE QfsInfo;

        if (Response->WordCount != 10 ||
            SmbGetUshort(&Response->DataDisplacement) != 0 ||
            SmbGetUshort(&Response->DataCount) != ACTUAL_QFS_ALLOCATE_LENGTH ||
            SmbGetUshort(&Response->TotalDataCount) != ACTUAL_QFS_ALLOCATE_LENGTH ||
            SmbGetUshort(&Response->TotalParameterCount) != SmbGetUshort(&Response->ParameterCount)) {
            
            Status = STATUS_INVALID_NETWORK_RESPONSE;
            RxDbgTrace(+1, Dbg, ("Invalid parameter(s) received.\n", 0 ));
            break;
        }
        
        QfsInfo = (PQFS_ALLOCATE)(StufferState->BufferBase+SmbGetUshort(&Response->DataOffset));

        UsersBuffer->TotalAllocationUnits.QuadPart = SmbGetUlong(&QfsInfo->cUnit);
        UsersBuffer->AvailableAllocationUnits.QuadPart = SmbGetUlong(&QfsInfo->cUnitAvail);
        UsersBuffer->SectorsPerAllocationUnit = SmbGetUlong(&QfsInfo->cSectorUnit);
        UsersBuffer->BytesPerSector = SmbGetUshort(&QfsInfo->cbSector);

        *BufferLength -= sizeof(FILE_FS_SIZE_INFORMATION);

        RxDbgTrace(0, Dbg, ("MRxSmbFinishTransaction2   allocation %08lx\n",
                               OrdinaryExchange->Transact2.AllocationSize.LowPart ));
        }break;
    case SMBPSE_OETYPE_T2_FOR_LANMAN_VOLUMELABEL_INFO:{
        PFILE_FS_VOLUME_INFORMATION UsersBuffer = OrdinaryExchange->Info.Buffer;
        PULONG BufferLength = OrdinaryExchange->Info.pBufferLength;
        PQFS_INFO QfsInfo;
        ULONG LabelLength;
        PBYTE VolumeLabel = &OrdinaryExchange->Info.QFSVolInfo.CoreLabel[0];

        if (Response->WordCount != 10 ||
            SmbGetUshort(&Response->DataDisplacement) != 0 ||
            SmbGetUshort(&Response->TotalParameterCount) != SmbGetUshort(&Response->ParameterCount)) {
            
            Status = STATUS_INVALID_NETWORK_RESPONSE;
            RxDbgTrace(+1, Dbg, ("Invalid parameter(s) received.\n", 0 ));
            break;
        }

        QfsInfo = (PQFS_INFO)(StufferState->BufferBase+SmbGetUshort(&Response->DataOffset));

        UsersBuffer->VolumeSerialNumber = SmbGetUlong(&QfsInfo->ulVSN);

        //copy the volumelabel to the right place in the OE where it can UNICODE-ized by the routine above

        LabelLength  = min(QfsInfo->cch,12);
        RtlCopyMemory(VolumeLabel,&QfsInfo->szVolLabel[0],LabelLength);
        VolumeLabel[LabelLength] = 0;


        RxDbgTrace(0, Dbg, ("MRxSmbFinishTransaction2   volinfo serialnum= %08lx\n",
                               UsersBuffer->VolumeSerialNumber ));
        }break;
    case SMBPSE_OETYPE_T2_FOR_ONE_FILE_DIRCTRL:{
        //do nothing here....everything is done back in the caller with the
        //whole buffer having been copied.....
        RxDbgTrace(0, Dbg, ("MRxSmbFinishTransaction2   one file \n"));
        }break;
    default:
        Status = STATUS_INVALID_NETWORK_RESPONSE;
    }

    RxDbgTrace(-1, Dbg, ("MRxSmbFinishTransaction2   returning %08lx\n", Status ));
    return Status;
}





=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\ifskit.mrx\smbmrx\sys\fsctl.c ===
/*++

Copyright (c) 1989 - 1999  Microsoft Corporation

Module Name:

    fsctl.c

Abstract:

    This module implements the mini redirector call down routines pertaining to
    file system control(FSCTL) and Io Device Control (IOCTL) operations on file
    system objects.

--*/

#include "precomp.h"
#pragma hdrstop

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, MRxSmbFsCtl)
#pragma alloc_text(PAGE, MRxSmbNotifyChangeDirectory)
#pragma alloc_text(PAGE, MRxSmbIoCtl)
#endif

//
//  The local debug trace level
//


RXDT_DefineCategory(FSCTRL);
#define Dbg (DEBUG_TRACE_FSCTRL)

NTSTATUS
MRxSmbCoreIoCtl(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE);


NTSTATUS
MRxSmbFsCtl(
      IN OUT PRX_CONTEXT RxContext)
/*++

Routine Description:

   This routine performs an FSCTL operation (remote) on a file across the network

Arguments:

    RxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

Notes:

    The FSCTL's handled by a mini rdr can be classified into one of two categories.
    In the first category are those FSCTL's whose implementation are shared between
    RDBSS and the mini rdr's and in the second category are those FSCTL's which
    are totally implemented by the mini rdr's. To this a third category can be
    added, i.e., those FSCTL's which should never be seen by the mini rdr's. The
    third category is solely intended as a debugging aid.

    The FSCTL's handled by a mini rdr can be classified based on functionality

--*/
{
    RxCaptureFobx;
    RxCaptureFcb;

    NTSTATUS Status = STATUS_INVALID_DEVICE_REQUEST;

    PLOWIO_CONTEXT pLowIoContext = &RxContext->LowIoContext;
    ULONG          FsControlCode = pLowIoContext->ParamsFor.FsCtl.FsControlCode;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbFsCtl...\n", 0));
    RxDbgTrace( 0, Dbg, ("MRxSmbFsCtl = %08lx\n", FsControlCode));
    RxDbgTrace(-1, Dbg, ("MRxSmbFsCtl -> %08lx\n", Status ));

    return Status;
}


NTSTATUS
MRxSmbNotifyChangeDirectory(
      IN OUT PRX_CONTEXT RxContext)
/*++

Routine Description:

   This routine performs a directory change notification operation

Arguments:

    RxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

Notes:

    A directory change notification opertaion is an asychronous operation. It
    consists of sending a SMB requesting change notification whose response is
    obtained when the desired change is affected on the server.

--*/
{
    NTSTATUS Status = STATUS_NOT_IMPLEMENTED;

    RxDbgTrace(+1, Dbg, ("MRxNotifyChangeDirectory...Entry\n", 0));

    RxDbgTrace(-1, Dbg, ("MRxSmbNotifyChangeDirectory -> %08lx\n", Status ));

    return Status;
}



NTSTATUS
MRxSmbIoCtl(
      IN OUT PRX_CONTEXT RxContext)
/*++

Routine Description:

   This routine performs an IOCTL operation. Currently, no calls are remoted; in
   fact, the only call accepted is for debugging.

Arguments:

    RxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS Status = STATUS_INVALID_DEVICE_REQUEST;

    PLOWIO_CONTEXT pLowIoContext = &RxContext->LowIoContext;
    ULONG          IoControlCode = pLowIoContext->ParamsFor.IoCtl.IoControlCode;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbIoCtl...\n", 0));
    RxDbgTrace( 0, Dbg, ("MRxSmbIoCtl IOCTL: = %08lx\n", IoControlCode));
    RxDbgTrace(-1, Dbg, ("MRxSmbIoCtl Status -> %08lx\n", Status ));

    return Status;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\ifskit.mrx\smbmrx\sys\fileinfo.c ===
/*++

Copyright (c) 1989 - 1999  Microsoft Corporation

Module Name:

    fileinfo.c

Abstract:

    This module implements the mini redirector call down routines pertaining to retrieval/
    update of file/directory/volume information.

--*/

#include "precomp.h"
#pragma hdrstop
#pragma warning(error:4101)   // Unreferenced local variable

RXDT_DefineCategory(DIRCTRL);
#define Dbg        (DEBUG_TRACE_DIRCTRL)

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, __MRxSmbAllocateSideBuffer)
#pragma alloc_text(PAGE, MRxSmbDeallocateSideBuffer)
#pragma alloc_text(PAGE, MRxSmbTranslateLanManFindBuffer)
#pragma alloc_text(PAGE, MrxSmbUnalignedDirEntryCopyTail)
#pragma alloc_text(PAGE, MRxSmbQueryDirectory)
#pragma alloc_text(PAGE, MRxSmbQueryVolumeInformation)
#pragma alloc_text(PAGE, MRxSmbQueryVolumeInformationWithFullBuffer)
#pragma alloc_text(PAGE, MRxSmbSetVolumeInformation)
#pragma alloc_text(PAGE, MRxSmbQueryFileInformation)
#pragma alloc_text(PAGE, MRxSmbSetFileInformation)
#pragma alloc_text(PAGE, MRxSmbSetFileInformationAtCleanup)
#pragma alloc_text(PAGE, MRxSmbIsValidDirectory)
#pragma alloc_text(PAGE, MRxSmbQueryFileInformationFromPseudoOpen)
#endif

#define MRxSmbForceCoreInfo FALSE
//#define FORCECOREINFO
#if DBG
#ifdef FORCECOREINFO
#undef MRxSmbForceCoreInfo
BOOLEAN MRxSmbForceCoreInfo = TRUE;
#endif
#endif

BOOLEAN MRxSmbBypassDownLevelRename = FALSE;
//BOOLEAN MRxSmbBypassDownLevelRename = TRUE;

ULONG UnalignedDirEntrySideBufferSize = 16384;

//
//  All T2Find requests to the remote server request the 32 bit resume key
//  so SMB_RFIND_BUFFER2 is used instead of SMB_FIND_BUFFER2.
//

typedef struct _SMB_FIND_BUFFER2_WITH_RESUME {
    _ULONG( ResumeKey );
    SMB_FIND_BUFFER2;
} SMB_FIND_BUFFER2_WITH_RESUME;
typedef SMB_FIND_BUFFER2_WITH_RESUME SMB_UNALIGNED *PSMB_FIND_BUFFER2_WITH_RESUME;

LIST_ENTRY MRxSmbSideBuffersList = {NULL,NULL};
ULONG MRxSmbSideBuffersSpinLock = 0;
ULONG MRxSmbSideBuffersCount = 0;
ULONG MRxSmbSideBuffersSerialNumber = 0;
BOOLEAN MRxSmbLoudSideBuffers = FALSE;


typedef struct _SIDE_BUFFER {
    ULONG      Signature;
    LIST_ENTRY ListEntry;
    PMRX_FCB Fcb;
    PMRX_FOBX Fobx;
    PMRX_SMB_FOBX smbFobx;
    ULONG SerialNumber;
    BYTE Buffer;
} SIDE_BUFFER, *PSIDE_BUFFER;

#if DBG
#define MRxSmbAllocateSideBuffer(a,b,c,d) __MRxSmbAllocateSideBuffer(a,b,c,d)
#else
#define MRxSmbAllocateSideBuffer(a,b,c,d) __MRxSmbAllocateSideBuffer(a,b,c)
#endif

NTSTATUS
MRxSmbCoreCheckPath(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    );

VOID
__MRxSmbAllocateSideBuffer(
    IN OUT PRX_CONTEXT     RxContext,
    IN OUT PMRX_SMB_FOBX   smbFobx,
    IN     USHORT          Setup
#if DBG
    ,IN     PUNICODE_STRING smbtemplate
#endif
    )
{
    RxCaptureFcb;RxCaptureFobx;
    PSIDE_BUFFER SideBuffer;
    ULONG SideBufferSize = UnalignedDirEntrySideBufferSize+sizeof(SIDE_BUFFER);
    POOL_TYPE PoolType;

    PAGED_CODE();

    ASSERT( smbFobx->Enumeration.UnalignedDirEntrySideBuffer == NULL);

#ifdef _WIN64

    //
    // NT64: When PagedPool is used here, we get memory corruption on
    //       some findfirst/findnext operations.  Find out why.
    //

    PoolType = NonPagedPool;
#else
    PoolType = PagedPool;
#endif
    SideBuffer = (PSIDE_BUFFER)RxAllocatePoolWithTag(
                                    PoolType,
                                    SideBufferSize,
                                    MRXSMB_DIRCTL_POOLTAG);
    if (SideBuffer==NULL) {
        return;
    }
    ASSERT( smbFobx->Enumeration.UnalignedDirEntrySideBuffer == NULL);
    SideBuffer->Signature = 'JLBS';
    SideBuffer->smbFobx = smbFobx;
    SideBuffer->Fobx = capFobx;
    SideBuffer->Fcb = capFcb;
    smbFobx->Enumeration.UnalignedDirEntrySideBuffer = &SideBuffer->Buffer;
    RxLog(("Allocsidebuf %lx fo/f=%lx,%lx\n",
            smbFobx->Enumeration.UnalignedDirEntrySideBuffer,
            capFobx,capFcb));
    smbFobx->Enumeration.SerialNumber = SideBuffer->SerialNumber = InterlockedIncrement(&MRxSmbSideBuffersSerialNumber);
    InterlockedIncrement(&MRxSmbSideBuffersCount);
    if (MRxSmbSideBuffersList.Flink==NULL) {
        InitializeListHead(&MRxSmbSideBuffersList);
    }
    ExAcquireFastMutex(&MRxSmbSerializationMutex);
    InsertTailList(&MRxSmbSideBuffersList,&SideBuffer->ListEntry);
    ExReleaseFastMutex(&MRxSmbSerializationMutex);
    if (!MRxSmbLoudSideBuffers) return;
    KdPrint(("Allocating side buffer %08lx %08lx %08lx %08lx %08lxon <%wZ> %s %wZ\n",
                     &SideBuffer->Buffer,
                     MRxSmbSideBuffersCount,
                     smbFobx,capFobx,capFobx->pSrvOpen,
               